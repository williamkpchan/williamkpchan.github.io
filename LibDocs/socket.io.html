<base target="_blank"><html><head><title>Socket.IO</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src="https://williamkpchan.github.io/lazyload.min.js"></script>
<script src='https://williamkpchan.github.io/mainscript.js'></script>
<script src="https://williamkpchan.github.io/commonfunctions.js"></script>
<script>
  var showTopicNumber = true;
  var bookid = "Socket.IO"
  var markerName = "h2,h3"
</script>
<style>
body{width:80%;margin-left: 10%; font-size:24px;}
h1, h2 {color: gold;}
strong {color: orange;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px;}
</style></head><body onkeypress="chkKey()"><center>
<h1>Socket.IO</h1>
<a href="#mustWatch">Must Watch!</a><br><br>
<div id="toc"></div></center><br><br>
<div id="mustWatch"><center><span class="red">MustWatch</span></center><br></div>
<pre><br><br>

<h2><span class="orange">Overview</span></h2>

Socket.IO is a JavaScript library for <b>real-time web applications</b>. 
It enables real-time, bi-directional communication between web clients and servers. 
It has two parts: a <b>client-side library</b> that runs in the browser, and a <b>server-side library</b> for node.js. 
Both components have an identical API.

<h2>Real-time applications</h2>
A real-time application (RTA) is an application that functions within a period that the user senses as immediate or current.

Some examples of real-time applications are -
<b>Instant messengers</b> - Chat apps like Whatsapp, Facebook Messenger, etc. 
You need not refresh your app/website to receive new messages.

<b>Push Notifications</b> - When someone tags you in a picture on Facebook, you receive a notification instantly.

<b>Collaboration Applications</b> - Apps like google docs, which allow multiple people to update same documents simultaneously and apply changes to all people's instances.

<b>Online Gaming</b> - Games like Counter Strike, Call of Duty, etc., are also some examples of real-time applications.

<h2>Why Socket.IO?</h2>
Writing a real-time application with popular web applications stacks like LAMP (PHP) has traditionally been very hard. 
It involves polling the server for changes, keeping track of timestamps, and it is a lot slower than it should be.

Sockets have traditionally been the solution around which most real-time systems are architected, providing a bi-directional communication channel between a client and a server. 
This means that the server can push messages to clients. 
Whenever an event occurs, the idea is that the server will get it and push it to the concerned connected clients.

Socket.IO is quite popular, it is used by <b>Microsoft Office, Yammer, Zendesk, Trello</b>, and numerous other organizations to build robust real-time systems. 
It one of the most powerful <b>JavaScript frameworks</b> on <b>GitHub</b>, and most depended-upon NPM (Node Package Manager) module. 
Socket.IO also has a huge community, which means finding help is quite easy.

<h2>ExpressJS</h2>
We will be using express to build the web server that Socket.IO will work with. 
Any other node-server-side framework or even node HTTP server can be used. 
However, ExpressJS makes it easy to define routes and other things. 
To read more about express and get a basic idea about it, head to ExpressJS tutorial.

<h2><span class="orange">Environment</span></h2>

To get started with developing using the <b>Socket.IO</b>, you need to have <b>Node</b> and <b>npm (node package manager)</b> installed. 
If you do not have these, head over to <b>Node setup</b> to install node on your local system. 
Confirm that node and npm are installed by running the following commands in your terminal.

node --version
npm --version

You should get an output similar to -
v5.0.0 3.5.2

Open your terminal and enter the following in your terminal to create a new folder and enter the following commands -

$ mkdir test-project
$ cd test-proect
$ npm init

It will ask you some questions; answer them in the following way -

<img src="https://www.tutorialspoint.com/socket.io/images/environment_setup.jpg">
This will create a <b>‘package.json node.js’</b> configuration file. 
Now we need to install <b>Express</b> and <b>Socket.IO</b>. 
To install these and save them to <b>package.json</b> file, enter the following command in your terminal, into the project directory.

npm install --save express socket.io

One final thing is that we should keep restarting the server. 
When we make changes, we will need a tool called nodemon. 
To install <b>nodemon</b>, open your terminal and enter the following command -

npm install -g nodemon

Whenever you need to start the server, instead of using the <b>node app.js</b> use, <b>nodemon app.js</b>. 
This will ensure that you do not need to restart the server whenever you change a file. 
It speeds up the development process.

Now, we have our development environment set up. 
Let us now get started with developing real-time applications with Socket.IO.

<h2><span class="orange">Hello World</span></h2>

Create a file called <b>app.js</b> and enter the following code to set up an express application -

var app = require('express')();
var http = require('http').Server(app);

app.get('/', function(req, res) {
   res.sendfile('index.html');
});

http.listen(3000, function() {
   console.log('listening on *:3000');
});

We will need an <b>index.html</b> file to serve, create a new file called index.html and enter the following code in it -

&lt;!DOCTYPE html>
&lt;html>
   &lt;head>
      &lt;title>Hello world&lt;/title>
   &lt;/head>
   &lt;body>Hello world&lt;/body>
&lt;/html>

To test if this works, go to the terminal and run this app using the following command -

nodemon app.js

This will run the server on localhost:3000. 
Go to the browser and enter localhost:3000 to check this.

This sets up our express application and is now serving a HTML file on the root route. 
Now we will require Socket.IO and will log "A user connected", every time a user goes to this page and "A user disconnected", every time someone navigates away/closes this page.

var app = require('express')();
var http = require('http').Server(app);
var io = require('socket.io')(http);

app.get('/', function(req, res) {
   res.sendfile('index.html');
});

//Whenever someone connects this gets executed
io.on('connection', function(socket) {
   console.log('A user connected');

   //Whenever someone disconnects this piece of code executed
   socket.on('disconnect', function () {
      console.log('A user disconnected');
   });
});

http.listen(3000, function() {
   console.log('listening on *:3000');
});

The require('socket.io')(http) creates a new socket.io instance attached to the http server. 
The <b>io.on event handler</b> handles connection, disconnection, etc., events in it, using the socket object.

We have set up our server to log messages on connections and disconnections. 
We now have to include the client script and initialize the socket object there, so that clients can establish connections when required. 
The script is served by our <b>io server</b> at <b>'/socket.io/socket.io.js'</b>.

After completing the above procedure, the index.html file will look as follows -

&lt;!DOCTYPE html>
&lt;html>
   &lt;head>
      &lt;title>Hello world&lt;/title>
   &lt;/head>
   &lt;script src = "/socket.io/socket.io.js">&lt;/script>

   &lt;script>
      var socket = io();
   &lt;/script>
   &lt;body>Hello world&lt;/body>
&lt;/html>

If you go to localhost:3000 now (make sure your server is running), you will get <b>Hello World</b> printed in your browser. 
Now check your server console logs, it will show the following message -

A user connected

If you refresh your browser, it will disconnect the socket connection and recreate. 
You can see the following on your console logs -

A user connected
A user disconnected
A user connected

We now have socket connections working. 
This is how easy it is to set up connections in Socket.IO.

<h2><span class="orange">Event Handling</span></h2>

Sockets work based on events. 
There are some reserved events, which can be accessed using the socket object on the server side.

These are -

Connect
Message
Disconnect
Reconnect
Ping
Join and
Leave

The client-side socket object also provides us with some reserved events, which are -

Connect
Connect_error
Connect_timeout
Reconnect, etc

In the Hello World example, we used the connection and disconnection events to log when a user connected and left. 
Now we will be using the message event to pass message from the server to the client. 
To do this, modify the <b>io.on</b> ('connection', function(socket)) call to include the following -

var app = require('express')();
var http = require('http').Server(app);
var io = require('socket.io')(http);

app.get('/', function(req, res) {
   res.sendfile('index.html');
});

io.on('connection', function(socket) {
   console.log('A user connected');

   //Send a message after a timeout of 4seconds
   setTimeout(function() {
      socket.send('Sent a message 4seconds after connection!');
   }, 4000);

   socket.on('disconnect', function () {
      console.log('A user disconnected');
   });
});

http.listen(3000, function() {
   console.log('listening on *:3000');
});

This will send an event called <b>message(built in)</b> to our client, four seconds after the client connects. 
The send function on socket object associates the 'message' event.

Now, we need to handle this event on our client side. 
So, edit your index.html script tag to include the following code -

&lt;script>
   var socket = io();
   socket.on('message', function(data){document.write(data)});
&lt;/script>

We are now handling the 'message' event on the client. 
When you go to the page in your browser now, you will be presented with the following screenshot.

<img src="https://www.tutorialspoint.com/socket.io/images/events_before.jpg" />
After 4 seconds pass and the server sends the message event, our client will handle it and produce the following output -

<img src="https://www.tutorialspoint.com/socket.io//images/events_after.jpg" />
<b>Note</b> - We sent a string of text here; we can also send an object in any event.

Message was a built-in event provided by the API, but is of not much use in a real application, as we need to be able to differentiate between events.

To allow this, Socket.IO provides us the ability to create <b>custom events</b>. 
You can create and fire custom events using the <b>socket.emit</b> function.

For example, the following code emits an event called <b>testerEvent</b> -

var app = require('express')();
var http = require('http').Server(app);
var io = require('socket.io')(http);

app.get('/', function(req, res) {
   res.sendfile('index.html');
});

io.on('connection', function(socket) {
   console.log('A user connected');

   //Send a message when 
   setTimeout(function() {
      //Sending an object when emmiting an event
      socket.emit('testerEvent', { description: 'A custom event named testerEvent!'});
   }, 4000);

   socket.on('disconnect', function () {
      console.log('A user disconnected');
   });
});

http.listen(3000, function() {
   console.log('listening on localhost:3000');
});

To handle this custom event on client we need a listener that listens for the event testerEvent. 
The following code handles this event on the client -

&lt;!DOCTYPE html>
&lt;html>
   &lt;head>
      &lt;title>Hello world&lt;/title>
   &lt;/head>
   &lt;script src = "/socket.io/socket.io.js">&lt;/script>

   &lt;script>
      var socket = io();
      socket.on('testerEvent', function(data){document.write(data.description)});
   &lt;/script>
   &lt;body>Hello world&lt;/body>
&lt;/html>

This will work in the same way as our previous example, with the event being testerEvent in this case. 
When you open your browser and go to localhost:3000, you'll be greeted with -

Hello world

After four seconds, this event will be fired and the browser will have the text changed to -

A custom event named testerEvent!

We can also emit events from the client. 
To emit an event from your client, use the emit function on the socket object.

&lt;!DOCTYPE html>
&lt;html>
   &lt;head>
      &lt;title>Hello world&lt;/title>
   &lt;/head>
   &lt;script src = "/socket.io/socket.io.js">&lt;/script>

   &lt;script>
      var socket = io();
      socket.emit('clientEvent', 'Sent an event from the client!');
   &lt;/script>
   &lt;body>Hello world&lt;/body>
&lt;/html>

To handle these events, use the <b>on function</b> on the socket object on your server.

var app = require('express')();
var http = require('http').Server(app);
var io = require('socket.io')(http);

app.get('/', function(req, res) {
   res.sendfile('index.html');
});

io.on('connection', function(socket) {
   socket.on('clientEvent', function(data) {
      console.log(data);
   });
});

http.listen(3000, function() {
   console.log('listening on localhost:3000');
});

So, now if we go to localhost:3000, we will get a custom event called <b>clientEvent</b> fired. 
This event will be handled on the server by logging -

Sent an event from the client!

<h2><span class="orange">Broadcasting</span></h2>

Broadcasting means sending a message to all connected clients. 
Broadcasting can be done at multiple levels. 
We can send the message to all the connected clients, to clients on a namespace and clients in a particular room. 
To broadcast an event to all the clients, we can use the <b>io.sockets.emit</b> method.

<b>Note</b> - This will emit the event to <b>ALL</b> the connected clients (event the socket that might have fired this event).

In this example, we will broadcast the number of connected clients to all the users. 
Update the <b>app.js</b> file to incorporate the following.

var app = require('express')();
var http = require('http').Server(app);
var io = require('socket.io')(http);

app.get('/', function(req, res) {
   res.sendfile('index.html');
});

var clients = 0;
io.on('connection', function(socket) {
   clients++;
   io.sockets.emit('broadcast',{ description: clients + ' clients connected!'});
   socket.on('disconnect', function () {
      clients--;
      io.sockets.emit('broadcast',{ description: clients + ' clients connected!'});
   });
});

http.listen(3000, function() {
   console.log('listening on localhost:3000');
});

On the client side, we just need to handle the broadcast event -

&lt;!DOCTYPE html>
&lt;html>
   &lt;head>
      &lt;title>Hello world&lt;/title>
   &lt;/head>
   &lt;script src = "/socket.io/socket.io.js">&lt;/script>
   &lt;script>
      var socket = io();
      socket.on('broadcast',function(data) {
         document.body.innerHTML = '';
         document.write(data.description);
      });
   &lt;/script>
   &lt;body>Hello world&lt;/body>
&lt;/html>

If you connect four clients, you will get the following result -

<img src="https://www.tutorialspoint.com/socket.io/images/broadcast_to_all.jpg" />
This was to send an event to everyone. 
Now, if we want to send an event to everyone, but the client that caused it (in the previous example, it was caused by new clients on connecting), we can use the <b>socket.broadcast.emit</b>.

Let us send the new user a welcome message and update the other clients about him/her joining. 
So in your app.js file, on connection of client send him a welcome message and broadcast connected client number to all others.

var app = require('express')();
var http = require('http').Server(app);
var io = require('socket.io')(http);

app.get('/', function(req, res) {
   res.sendfile('index.html');
});

var clients = 0;
io.on('connection', function(socket) {
   clients++;
   socket.emit('newclientconnect',{ description: 'Hey, welcome!'});
   socket.broadcast.emit('newclientconnect',{ description: clients + ' clients connected!'})
   socket.on('disconnect', function () {
      clients--;
      socket.broadcast.emit('newclientconnect',{ description: clients + ' clients connected!'})
   });
});

http.listen(3000, function() {
   console.log('listening on localhost:3000');
});

And your html to handle this event -

&lt;!DOCTYPE html>
&lt;html>
   &lt;head>
      &lt;title>Hello world&lt;/title>
   &lt;/head>
   &lt;script src = "/socket.io/socket.io.js">&lt;/script>
   &lt;script>
      var socket = io();
      socket.on('newclientconnect',function(data) {
         document.body.innerHTML = '';
         document.write(data.description);
      });
   &lt;/script>
   &lt;body>Hello world&lt;/body>
&lt;/html>

Now, the newest client gets a welcome message and others get how many clients are connected currently to the server.

<h2><span class="orange">Namespaces</span></h2>

Socket.IO allows you to “namespace” your sockets, which essentially means assigning different endpoints or paths. 
This is a useful feature to minimize the number of resources (TCP connections) and at the same time separate concerns within your application by introducing separation between communication channels. 
Multiple namespaces actually share the same WebSockets connection thus saving us socket ports on the server.

Namespaces are created on the server side. 
However, they are joined by clients by sending a request to the server.

<h2>Default Namespaces</h2>
The root namespace '/' is the default namespace, which is joined by clients if a namespace is not specified by the client while connecting to the server. 
All connections to the server using the socket-object client side are made to the default namespace. 
For example -

var socket = io();

This will connect the client to the default namespace. 
All events on this namespace connection will be handled by the <b>io object</b> on the server. 
All the previous examples were utilizing default namespaces to communicate with the server and back.

<h2>Custom Namespaces</h2>
We can create our own custom namespaces. 
To set up a custom namespace, we can call the ‘of’ function on the server side -

var app = require('express')();
var http = require('http').Server(app);
var io = require('socket.io')(http);

app.get('/', function(req, res) {
   res.sendfile('index.html');
});

var nsp = io.of('/my-namespace');
nsp.on('connection', function(socket) {
   console.log('someone connected');
   nsp.emit('hi', 'Hello everyone!');
});

http.listen(3000, function() {
   console.log('listening on localhost:3000');
});

Now, to connect a client to this namespace, you need to provide the namespace as an argument to the <b>io constructor call</b> to create a connection and a socket object on client side.

For example, to connect to the above namespace, use the following HTML -

&lt;!DOCTYPE html>
&lt;html>
   &lt;head>
      &lt;title>Hello world&lt;/title>
   &lt;/head>
   &lt;script src = "/socket.io/socket.io.js">&lt;/script>

   &lt;script>
      var socket = io('/my-namespace');
      socket.on('hi',function(data) {
         document.body.innerHTML = '';
         document.write(data);
      });
   &lt;/script>
   &lt;body>&lt;/body>
&lt;/html>

Every time someone connects to this namespace, they will receive a ‘hi’ event.

<h2><span class="orange">Rooms</span></h2>

Within each namespace, you can also define arbitrary channels that sockets can join and leave. 
These channels are called rooms. 
Rooms are used to further-separate concerns. 
Rooms also share the same socket connection like namespaces. 
One thing to keep in mind while using rooms is that they can only be joined on the server side.

<h2>Joining Rooms</h2>
You can call the <b>join</b> method on the socket to subscribe the socket to a given channel/room. 
For example, let us create rooms called <b>'room-&lt;room-number>'</b> and join some clients. 
As soon as this room is full, create another room and join clients there.

<b>Note</b> - We are currently doing this on the default namespace, i.e. 
'/'. 
You can also implement this in custom namespaces in the same fashion.

To join a room you need to provide the room name as the argument to your join function call.

var app = require('express')();
var http = require('http').Server(app);
var io = require('socket.io')(http);

app.get('/', function(req, res) {
   res.sendfile('index.html');
});

var roomno = 1;
io.on('connection', function(socket) {

   //Increase roomno 2 clients are present in a room.
   if(io.nsps['/'].adapter.rooms["room-"+roomno] &amp;&amp; io.nsps['/'].adapter.rooms["room-"+roomno].length > 1) roomno++;
   socket.join("room-"+roomno);

   //Send this event to everyone in the room.
   io.sockets.in("room-"+roomno).emit('connectToRoom', "You are in room no. 
"+roomno);
})

http.listen(3000, function() {
   console.log('listening on localhost:3000');
});

Just handle this <b>connectToRoom</b> event on the client. 


&lt;!DOCTYPE html>
&lt;html>
   &lt;head>
      &lt;title>Hello world&lt;/title>
   &lt;/head>
   &lt;script src = "/socket.io/socket.io.js">&lt;/script>

   &lt;script>
      var socket = io();
      socket.on('connectToRoom',function(data) {
         document.body.innerHTML = '';
         document.write(data);
      });
   &lt;/script>
   &lt;body>&lt;/body>
&lt;/html>

Now if you connect three clients, the first two will get the following message -

You are in room no. 1

The last client will get the following message -

You are in room no. 2

 
<img src="https://www.tutorialspoint.com/socket.io/images/rooms.jpg" />
<h2>Leaving a room</h2>
To leave a room, you need to call the leave function just as you called the join function on the socket.

For example - To leave room <b>'room-1'</b>,

socket.leave("room-"+roomno);

<h2><span class="orange">Error Handling</span></h2>

We have worked on local servers until now, which will almost never give us errors related to connections, timeouts, etc. 
However, in real life production environments, handling such errors are of utmost importance. 
Therefore, we will now discuss how we can handle connection errors on the client side.

The client API provides us with following built in events -

<b>Connect</b> - When the client successfully connects.
<b>Connecting</b> - When the client is in the process of connecting.
<b>Disconnect</b> - When the client is disconnected.
<b>Connect_failed</b> - When the connection to the server fails.
<b>Error</b> - An error event is sent from the server.
<b>Message</b> - When the server sends a message using the <b>send</b> function.
<b>Reconnect</b> - When reconnection to the server is successful.
<b>Reconnecting</b> - When the client is in the process of connecting.
<b>Reconnect_failed</b> - When the reconnection attempt fails.
To handle errors, we can handle these events using the out-socket object that we created on our client.

For example - If we have a connection that fails, we can use the following code to connect to the server again -

socket.on('connect_failed', function() {
   document.write("Sorry, there seems to be an issue with the connection!");
})

<h2><span class="orange">Logging and Debugging</span></h2>

Socket.IO uses a very famous debugging module developed by ExpresJS's main author, called <b>debug</b>. 
Earlier Socket.IO used to log everything to the console making it quite difficult to debug the problem. 
After the v1.0 release, you can specify what you want to log.

<h2>Server-side</h2>
The best way to see what information is available is to use the * -

DEBUG=* node app.js

This will colorize and output everything that happens to your server console. 
For example, we can consider the following screenshot.

<img src="https://www.tutorialspoint.com/socket.io/images/logging_example.jpg" />
<h2>Client-side</h2>
Paste this to console, click enter and refresh your page. 
This will again output everything related to Socket.io to your console.

localStorage.debug = '*';

You can limit the output to get the debug info with incoming data from the socket using the following command.

localStorage.debug = 'socket.io-client:socket';

You can see the result like the following screenshot, if you use the second statement to log the info -

<img src="https://www.tutorialspoint.com/socket.io/images/client_logging.jpg" />
There is a very good blog post related to socket.io debugging <a target="_blank" href="https://www.rethinkdb.com/blog/websocket-debugging/">here.</a>

<h2><span class="orange">Internals</span></h2>

In this chapter, we will discuss regarding Fallbacks, Connection using Socket.IO, Events and Messages.

<h2>Fallbacks</h2>
Socket.IO has a lot of underlying transport mechanisms, which deal with various constraints arising due to cross browser issues, WebSocket implementations, firewalls, port blocking, etc.

Though W3C has a defined specification for WebSocket API, it is still lacking in implementation. 
Socket.IO provides us with fallback mechanisms, which can deal with such issues. 
If we develop apps using the native API, we have to implement the fallbacks ourselves. 
Socket.IO covers a large list of fallbacks in the following order -

WebSockets
FlashSocket
XHR long polling
XHR multipart streaming
XHR polling
JSONP polling
iframes

<h2>Connection using Socket.IO</h2>
The Socket.IO connection begins with the handshake. 
This makes the handshake a special part of the protocol. 
Apart from the handshake, all the other events and messages in the protocol are transferred over the socket.

Socket.IO is intended for use with web applications, and therefore it is assumed that these applications will always be able to use HTTP. 
It is because of this reasoning that the Socket.IO handshake takes place over HTTP using a POST request on the handshake URI (passed to the connect method).

<h2>Events and messages</h2>
WebSocket native API only sends messages across. 
Socket.IO provides an addition layer over these messages, which allows us to create events and again helps us develop apps easily by separating the different types of messages sent.

The native API sends messages only in plain text. 
This is also taken care of by Socket.IO. 
It handles the serialization and deserialization of data for us.

We have an official client API for the web. 
For other clients such as native mobile phones, other application clients also we can use Socket.IO using the following steps.

<b>Step 1</b> - A connection needs to be established using the same connection protocol discussed above.

<b>Step 2</b> - The messages need to be in the same format as specified by Socket.IO. 
This format enables Socket.IO to determine the type of the message and the data sent in the message and some metadata useful for operation.

The message format is -

[type] : [id ('+')] : [endpoint] (: [data]

The parameters in the above command are explained below -

<b>Type</b> is a single digit integer, specifying what type message it is.

<b>ID</b> is message ID, an incremental integer used for acknowledgements.

<b>Endpoint</b> is the socket endpoint that the message is intended to be delivered to...

<b>Data</b> is the associated data to be delivered to the socket. 
In case of messages, it is treated as plain text, for other events, it is treated as JSON.

In the next chapter, we will write a chat application in Socket.IO.

<h2><span class="orange">Chat Application</span></h2>

Now that we are well acquainted with Socket.IO, let us write a chat application, which we can use to chat on different chat rooms. 
We will allow users to choose a username and allow them to chat using them. 
So first, let us set up our HTML file to request for a username -

&lt;!DOCTYPE html>
&lt;html>
   &lt;head>
      &lt;title>Hello world&lt;/title>
   &lt;/head>
   &lt;script src = "/socket.io/socket.io.js">&lt;/script>

   &lt;script>
      var socket = io();
   &lt;/script>
   &lt;body>
      &lt;input type = "text" name = "name" value = "" placeholder = "Enter your name!">
      &lt;button type = "button" name = "button">Let me chat!&lt;/button>
   &lt;/body>
&lt;/html>
Now that we have set up our HTML to request for a username, let us create the server to accept connections from the client. 
We will allow people to send their chosen usernames using the <b>setUsername</b> event. 
If a user exists, we will respond by a <b>userExists</b> event, else using a <b>userSet</b> event.

var app = require('express')();
var http = require('http').Server(app);
var io = require('socket.io')(http);

app.get('/', function(req, res) {
   res.sendfile('index.html');
});

users = [];
io.on('connection', function(socket) {
   console.log('A user connected');
   socket.on('setUsername', function(data) {
      if(users.indexOf(data) > -1) {
         users.push(data);
         socket.emit('userSet', {username: data});
      } else {
         socket.emit('userExists', data + ' username is taken! Try some other username.');
      }
   })
});

http.listen(3000, function() {
   console.log('listening on localhost:3000');
});

We need to send the username to the server when people click on the button. 
If user exists, we show an error message; else, we show a messaging screen - 

&lt;!DOCTYPE html>
&lt;html>
   &lt;head>
      &lt;title>Hello world&lt;/title>
   &lt;/head>

   &lt;script src = "/socket.io/socket.io.js">&lt;/script>
   &lt;script>
      var socket = io();
      function setUsername() {
         socket.emit('setUsername', document.getElementById('name').value);
      };
      var user;
      socket.on('userExists', function(data) {
         document.getElementById('error-container').innerHTML = data;
      });
      socket.on('userSet', function(data) {
         user = data.username;
         document.body.innerHTML = '&lt;input type = "text" id = "message">\
         &lt;button type = "button" name = "button" onclick = "sendMessage()">Send&lt;/button>\
         &lt;div id = "message-container">&lt;/div>';
      });
      function sendMessage() {
         var msg = document.getElementById('message').value;
         if(msg) {
            socket.emit('msg', {message: msg, user: user});
         }
      }
      socket.on('newmsg', function(data) {
         if(user) {
            document.getElementById('message-container').innerHTML += '&lt;div>&lt;b>' + 
               data.user + '&lt;/b>: ' + data.message + '&lt;/div>'
         }
      })
   &lt;/script>

   &lt;body>
      &lt;div id = "error-container">&lt;/div>
      &lt;input id = "name" type = "text" name = "name" value = "" 
         placeholder = "Enter your name!">
      &lt;button type = "button" name = "button" onclick = "setUsername()">
         Let me chat!
      &lt;/button>
   &lt;/body>
&lt;/html>

Now if you connect two clients with same username, it will give you an error as shown in the screenshot below -

<img src="https://www.tutorialspoint.com/socket.io/images/chat_name_taken.jpg" />
Once you have provided an acceptable username, you will be taken to a screen with a message box and a button to send messages. 
Now, we have to handle and direct the messages to the connected client. 
For that, modify your app.js file to include the following changes -

var app = require('express')();
var http = require('http').Server(app);
var io = require('socket.io')(http);

app.get('/', function(req, res) {
   res.sendfile('index.html');
});

users = [];
io.on('connection', function(socket) {
   console.log('A user connected');
   socket.on('setUsername', function(data) {
      console.log(data);
   
      if(users.indexOf(data) > -1) {
         socket.emit('userExists', data + ' username is taken! Try some other username.');
      } else {
         users.push(data);
         socket.emit('userSet', {username: data});
      }
   });

   socket.on('msg', function(data) {
      //Send message to everyone
      io.sockets.emit('newmsg', data);
   })
});

http.listen(3000, function() {
   console.log('listening on localhost:3000');
});

Now connect any number of clients to your server, provide them a username and start chatting! In the following example, we have connected two clients with names Ayush and Harshit and sent some messages from both the clients -

<img src="https://www.tutorialspoint.com/socket.io/images/chat_example.jpg" />

<h2>Useful Links on Socket.IO</h2>

<a target="_blank" href="https://socket.io/docs">Socket.io</a> - Official website for socket.io, its you complete detail including socket.io library and associated documentation.

<a target="_blank" href="https://www.npmjs.com/package/socket.io">Socket.io at npm</a> socket.io repository at npm 

<h2>Useful Books on Socket.IO</h2>

<a target="_blank" href="https://www.amazon.com/Socket-IO-Real-time-Web-Application-Development/dp/1782160787/httpwwwtuto0a-20"><img src="https://images-na.ssl-images-amazon.com/images/I/51AJwvbiI9L._SX404_BO1,204,203,200_.jpg"/></a>
<a target="_blank" href="https://www.amazon.com/Socket-IO-Cookbook-Tyson-Cadenhead/dp/1785880861/httpwwwtuto0a-20"><img src="https://images-na.ssl-images-amazon.com/images/I/51z00hSUzUL._SX404_BO1,204,203,200_.jpg"/></a>  

<h2><span class="orange borRad20 bordred1">Introduction</span></h2>
<h2>What Socket.IO is</h2>
Socket.IO is a library that enables real-time, bidirectional and event-based communication between the browser and the server. 
It consists of:
a Node.js server: <a href="https://github.com/socketio/socket.io">Source</a> | <a href="https://socket.io/docs/v3/server-api/">API</a>

a Javascript client library for the browser (which can be also run from Node.js): <a href="https://github.com/socketio/socket.io-client">Source</a> | <a href="https://socket.io/docs/v3/client-api/">API</a>

<img src="https://socket.io/images/bidirectional-communication.png">
<h2>How does that work?</h2>
The client will try to establish a <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket">WebSocket</a> connection if possible, and will fall back on HTTP long polling if not.

WebSocket is a communication protocol which provides a full-duplex and low-latency channel between the server and the browser. 
More information can be found <a href="https://en.wikipedia.org/wiki/WebSocket">here</a>.

So, in the best-case scenario, provided that:
the browser supports WebSocket (<a href="https://caniuse.com/#search=websocket">97%</a> of all browsers in 2020)

there is no element (proxy, firewall, …) preventing WebSocket connections between the client and the server  

you can consider the Socket.IO client as a “slight” wrapper around the WebSocket API. 
Instead of writing:

const socket = new WebSocket("ws://localhost:3000");
socket.onopen = () => {
  socket.send("Hello!");
};
socket.onmessage = (data) => {
  console.log(data);
};

You will have, on the client-side:
const socket = io("ws://localhost:3000");
socket.on("connect", () => {
  // either with send()
  socket.send("Hello!");

  // or with emit() <i>and custom event names</i>
  socket.emit("salutations", "Hello!", { "mr": "john" }, Uint8Array.from([1, 2, 3, 4]));
});

// handle the event sent with socket.send()
socket.on("message", data => {
  console.log(data);
});

// handle the event sent with socket.emit()
socket.on("greetings", (elem1, elem2, elem3) => {
  console.log(elem1, elem2, elem3);
});

The API on the server-side is similar, you also get a <code>socket</code> object which extends the Node.js <a href="https://nodejs.org/docs/latest/api/events.html#events_class_eventemitter">EventEmitter</a> class:

const io = require("socket.io")(3000);

io.on("connection", socket => {
  // either with send()
  socket.send("Hello!");

  // or with emit() and custom event names
  socket.emit("greetings", "Hey!", { "ms": "jane" }, Buffer.from([4, 3, 3, 1]));

  // handle the event sent with socket.send()
  socket.on("message", (data) => {
    console.log(data);
  });

  // handle the event sent with socket.emit()
  socket.on("salutations", (elem1, elem2, elem3) => {
    console.log(elem1, elem2, elem3);
  });
});

Socket.IO provides additional features over a plain WebSocket object, which are listed below.

But first, let’s detail what the Socket.IO library is not.
<h2>What Socket.IO is not</h2>
Socket.IO is <strong>NOT</strong> a WebSocket implementation. 
Although Socket.IO indeed uses WebSocket as a transport when possible, it adds additional metadata to each packet. 
That is why a WebSocket client will not be able to successfully connect to a Socket.IO server, and a Socket.IO client will not be able to connect to a plain WebSocket server either.

// WARNING: the client will NOT be able to connect!
const socket = io("ws://echo.websocket.org");

If you are looking for a plain WebSocket server, please take a look at <a href="https://github.com/websockets/ws">ws</a> or <a href="https://github.com/uNetworking/uWebSockets.js">uWebSockets.js</a>.

There are also <a href="https://github.com/nodejs/node/issues/19308">talks</a> to include a WebSocket server in the Node.js core.

On the client-side, you might be interested by the <a href="https://github.com/nathanboktae/robust-websocket">robust-websocket</a> package.
<h2><span class="orange borRad20 bordred1">Namespaces</span></h2>

A Namespace is a communication channel that allows you to split the logic of your application over a single shared connection (also called “multiplexing”).

<img src="https://socket.io/images/namespaces.png">
<h2>Introduction</h2>
Each namespace has its own:

<a href="https://socket.io/docs/v3/listening-to-events/">event handlers</a>

io.of("/orders").on("connection", (socket) => {
  socket.on("order:list", () => {});
  socket.on("order:create", () => {});
});

io.of("/users").on("connection", (socket) => {
  socket.on("user:list", () => {});
});

<a href="https://socket.io/docs/v3/rooms/">rooms</a>

const orderNamespace = io.of("/orders");

orderNamespace.on("connection", (socket) => {
  socket.join("room1");
  orderNamespace.to("room1").emit("hello");
});

const userNamespace = io.of("/users");

userNamespace.on("connection", (socket) => {
  socket.join("room1"); // distinct from the room in the "orders" namespace
  userNamespace.to("room1").emit("holà");
});

<a href="https://socket.io/docs/v3/middlewares/">middlewares</a>

const orderNamespace = io.of("/orders");

orderNamespace.use((socket, next) => {
  // ensure the socket has access to the "orders" namespace, and then
  next();
});

const userNamespace = io.of("/users");

userNamespace.use((socket, next) => {
  // ensure the socket has access to the "users" namespace, and then
  next();
});

Possible use cases:

you want to create a special namespace that only authorized users have access to, so the logic related to those users is separated from the rest of the application

const adminNamespace = io.of("/admin");

adminNamespace.use((socket, next) => {
  // ensure the user has sufficient rights
  next();
});

adminNamespace.on("connection", socket => {
  socket.on("delete user", () => {
    // ...
  });
});

your application has multiple tenants so you want to dynamically create one namespace per tenant

const workspaces = io.of(/^\/\w+$/);

workspaces.on("connection", socket => {
  const workspace = socket.nsp;

  workspace.emit("hello");
});
<h2>Main namespace</h2>
Until now, you interacted with the main namespace, called <code>/</code>. 
The <code>io</code> instance inherits all of its methods:

io.on("connection", (socket) => {});
io.use((socket, next) => { next() });
io.emit("hello");
// are actually equivalent to
io.of("/").on("connection", (socket) => {});
io.of("/").use((socket, next) => { next() });
io.of("/").emit("hello");

Some tutorials may also mention <code>io.sockets</code>, it’s simply an alias for <code>io.of("/")</code>.

io.sockets === io.of("/")
<h2>Custom namespaces</h2>
To set up a custom namespace, you can call the <code>of</code> function on the server-side:

const nsp = io.of("/my-namespace");

nsp.on("connection", socket => {
  console.log("someone connected");
});

nsp.emit("hi", "everyone!");
<h2>Client initialization</h2>
Same-origin version:

const socket = io(); // or io("/"), the main namespace
const orderSocket = io("/orders"); // the "orders" namespace
const userSocket = io("/users"); // the "users" namespace

Cross-origin/Node.js version:

const socket = io("https://example.com"); // or io("https://example.com/"), the main namespace
const orderSocket = io("https://example.com/orders"); // the "orders" namespace
const userSocket = io("https://example.com/users"); // the "users" namespace

In the example above, only one WebSocket connection will be established, and the packets will automatically be routed to the right namespace.

Please note that multiplexing will be disabled in the following cases:

multiple creation for the same namespace

const socket1 = io();
const socket2 = io(); // no multiplexing, two distinct WebSocket connections

different domains

const socket1 = io("https://first.example.com");
const socket2 = io("https://second.example.com"); // no multiplexing, two distinct WebSocket connections

usage of the <a href="https://socket.io/docs/v3/client-initialization/#forceNew">forceNew</a> option

const socket1 = io();
const socket2 = io("/admin", { forceNew: true }); // no multiplexing, two distinct WebSocket connections
<h2>Dynamic namespaces</h2>
It is also possible to dynamically create namespaces, either with a regular expression:

io.of(/^\/dynamic-\d+$/);

or with a function:

io.of((name, auth, next) => {
  next(null, true); // or false, when the creation is denied
});

You can have access to the new namespace in the <code>connection</code> event:

io.of(/^\/dynamic-\d+$/).on("connection", (socket) => {
  const namespace = socket.nsp;
});

The return value of the <code>of()</code> method is what we call the parent namespace, from which you can:

register <a href="https://socket.io/docs/v3/middlewares/">middlewares</a>

const parentNamespace = io.of(/^\/dynamic-\d+$/);

parentNamespace.use((socket, next) => { next() });

The middleware will automatically be registered on each child namespace.

<a href="https://socket.io/docs/v3/broadcasting-events/">broadcast</a> events

const parentNamespace = io.of(/^\/dynamic-\d+$/);

parentNamespace.emit("hello"); // will be sent to users in /dynamic-1, /dynamic-2, ...
<h2>Complete API</h2>
The complete API exposed by the Namespace instance can be found <a href="https://socket.io/docs/v3/server-api/#Namespace">here</a>.


<h2><span class="orange borRad20 bordred1">Client API</span></h2>
https://socket.io/docs/v3/client-api/index.html
<h2>IO</h2>Exposed as the <code>io</code> namespace in the standalone build, or the result of calling <code>require("socket.io-client")</code>.

&lt;script src="/socket.io/socket.io.js">&lt;/script>
&lt;script>
  const socket = io("http://localhost");
&lt;/script>

const io = require("socket.io-client");
// or with import syntax
import { io } from "socket.io-client";

<h3><span class="brown">io.protocol</span></h3>
<em>(Number)</em>

The protocol revision number (currently: 5).

The protocol defines the format of the packets exchanged between the client and the server. 
Both the client and the server must use the same revision in order to understand each other.

You can find more information <a href="https://github.com/socketio/socket.io-protocol">here</a>.

<h3><span class="brown">io([url][, options])</span></h3>
<code>url</code> <em>(String)</em> (defaults to <code>window.location</code>)
<code>options</code> <em>(Object)</em>
<code>forceNew</code> <em>(Boolean)</em> whether to reuse an existing connection

<strong>Returns</strong> <code>Socket</code>

Creates a new <code>Manager</code> for the given URL, and attempts to reuse an existing <code>Manager</code> for subsequent calls, unless the <code>multiplex</code> option is passed with <code>false</code>. 
Passing this option is the equivalent of passing <code>"force new connection": true</code> or <code>forceNew: true</code>.

A new <code>Socket</code> instance is returned for the namespace specified by the pathname in the URL, defaulting to <code>/</code>. 
For example, if the <code>url</code> is <code>http://localhost/users</code>, a transport connection will be established to <code>http://localhost</code> and a Socket.IO connection will be established to <code>/users</code>.

Query parameters can also be provided, either with the <code>query</code> option or directly in the url (example: <code>http://localhost/users?token=abc</code>).

const io = require("socket.io-client");

const socket = io("ws://example.com/my-namespace", {
  reconnectionDelayMax: 10000,
  auth: {
    token: "123"
  },
  query: {
    "my-key": "my-value"
  }
});

is the short version of:

const { Manager } = require("socket.io-client");

const manager = new Manager("ws://example.com", {
  reconnectionDelayMax: 10000,
  query: {
    "my-key": "my-value"
  }
});

const socket = manager.socket("/my-namespace", {
  auth: {
    token: "123"
  }
});

See new Manager(url[, options])</a> for the list of available <code>options</code>.

Please note: <code>manager.socket("/my-namespace", options )</code> will only read the <code>auth</code> key in the <code>options</code> object.
<code>query: {…}</code> and other optional values are only used when passed via a <code>new Manager(uri, options)</code> instance.

<h2>Manager</h2>The <code>Manager</code> <em>manages</em> the Engine.IO <a href="https://github.com/socketio/engine.io-client/">client</a> instance, which is the low-level engine that establishes the connection to the server (by using transports like WebSocket or HTTP long-polling).

The <code>Manager</code> handles the reconnection logic.

A single <code>Manager</code> can be used by several Sockets</a>. 

Please note that, in most cases, you won’t use the Manager directly but use the Socket</a> instance instead.

<h3><span class="brown">new Manager(url[, options])</span></h3>
<code>url</code> <em>(String)</em>
<code>options</code> <em>(Object)</em>
<strong>Returns</strong> <code>Manager</code>

Available options:

Option
Default value
Description

<code>path</code>
<code>/socket.io</code>
name of the path that is captured on the server side

<code>reconnection</code>
<code>true</code>
whether to reconnect automatically

<code>reconnectionAttempts</code>
<code>Infinity</code>
number of reconnection attempts before giving up

<code>reconnectionDelay</code>
<code>1000</code>
how long to initially wait before attempting a new reconnection. 
Affected by +/- <code>randomizationFactor</code>, for example the default initial delay will be between 500 to 1500ms.

<code>reconnectionDelayMax</code>
<code>5000</code>
maximum amount of time to wait between reconnections. 
Each attempt increases the reconnection delay by 2x along with a randomization factor.

<code>randomizationFactor</code>
<code>0.5</code>
0 &lt;= randomizationFactor &lt;= 1

<code>timeout</code>
<code>20000</code>
connection timeout before an <code>error</code> event is emitted

<code>autoConnect</code>
<code>true</code>
by setting this false, you have to call <code>manager.open</code> whenever you decide it’s appropriate

<code>query</code>
<code>{}</code>
additional query parameters that are sent when connecting a namespace (then found in <code>socket.handshake.query</code> object on the server-side)

<code>parser</code>
-
the parser to use. 
Defaults to an instance of the <code>Parser</code> that ships with socket.io. 
See <a href="https://github.com/socketio/socket.io-parser">socket.io-parser</a>.

Available options for the underlying Engine.IO client:

Option
Default value
Description

<code>upgrade</code>
<code>true</code>
whether the client should try to upgrade the transport from long-polling to something better.

<code>forceJSONP</code>
<code>false</code>
forces JSONP for polling transport.

<code>jsonp</code>
<code>true</code>
determines whether to use JSONP when necessary for polling. 
If disabled (by settings to false) an error will be emitted (saying “No transports available”) if no other transports are available. 
If another transport is available for opening a connection (e.g. 
WebSocket) that transport will be used instead.

<code>forceBase64</code>
<code>false</code>
forces base 64 encoding for polling transport even when XHR2 responseType is available and WebSocket even if the used standard supports binary.

<code>enablesXDR</code>
<code>false</code>
enables XDomainRequest for IE8 to avoid loading bar flashing with click sound. 
default to <code>false</code> because XDomainRequest has a flaw of not sending cookie.

<code>timestampRequests</code>
-
whether to add the timestamp with each transport request. 
Note: polling requests are always stamped unless this option is explicitly set to <code>false</code>

<code>timestampParam</code>
<code>t</code>
the timestamp parameter

<code>transports</code>
<code>["polling", "websocket"]</code>
a list of transports to try (in order). 
<code>Engine</code> always attempts to connect directly with the first one, provided the feature detection test for it passes.

<code>transportOptions</code>
<code>{}</code>
hash of options, indexed by transport name, overriding the common options for the given transport

<code>rememberUpgrade</code>
<code>false</code>
If true and if the previous websocket connection to the server succeeded, the connection attempt will bypass the normal upgrade process and will initially try websocket. 
A connection attempt following a transport error will use the normal upgrade process. 
It is recommended you turn this on only when using SSL/TLS connections, or if you know that your network does not block websockets.

<code>onlyBinaryUpgrades</code>
<code>false</code>
whether transport upgrades should be restricted to transports supporting binary data

<code>requestTimeout</code>
<code>0</code>
timeout for xhr-polling requests in milliseconds (<code>0</code>) (<em>only for polling transport</em>)

<code>protocols</code>
-
a list of subprotocols (see <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#Subprotocols">MDN reference</a>) (<em>only for websocket transport</em>)

Node.js-only options for the underlying Engine.IO client:

Option
Default value
Description

<code>agent</code>
<code>false </code>
the <code>http.Agent</code> to use

<code>pfx</code>
-
Certificate, Private key and CA certificates to use for SSL.

<code>key</code>
-
Private key to use for SSL.

<code>passphrase</code>
-
A string of passphrase for the private key or pfx.

<code>cert</code>
-
Public x509 certificate to use.

<code>ca</code>
-
An authority certificate or array of authority certificates to check the remote host against.

<code>ciphers</code>
-
A string describing the ciphers to use or exclude. 
Consult the <a href="http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT">cipher format list</a> for details on the format.

<code>rejectUnauthorized</code>
<code>true</code>
If true, the server certificate is verified against the list of supplied CAs. 
An “error” event is emitted if verification fails. 
Verification happens at the connection level, before the HTTP request is sent.

<code>perMessageDeflate</code>
<code>true</code>
parameters of the WebSocket permessage-deflate extension (see <a href="https://github.com/einaros/ws">ws module</a> api docs). 
Set to <code>false</code> to disable.

<code>extraHeaders</code>
<code>{}</code>
Headers that will be passed for each request to the server (via xhr-polling and via websockets). 
These values then can be used during handshake or for special proxies.

<code>forceNode</code>
<code>false</code>
Uses NodeJS implementation for websockets - even if there is a native Browser-Websocket available, which is preferred by default over the NodeJS implementation. 
(This is useful when using hybrid platforms like nw.js or electron)

<code>localAddress</code>
-
the local IP address to connect to

<h3><span class="brown">manager.reconnection([value])</span></h3>
<code>value</code> <em>(Boolean)</em>
<strong>Returns</strong> <code>Manager|Boolean</code>

Sets the <code>reconnection</code> option, or returns it if no parameters are passed.

<h3><span class="brown">manager.reconnectionAttempts([value])</span></h3>
<code>value</code> <em>(Number)</em>
<strong>Returns</strong> <code>Manager|Number</code>

Sets the <code>reconnectionAttempts</code> option, or returns it if no parameters are passed.

<h3><span class="brown">manager.reconnectionDelay([value])</span></h3>
<code>value</code> <em>(Number)</em>
<strong>Returns</strong> <code>Manager|Number</code>

Sets the <code>reconnectionDelay</code> option, or returns it if no parameters are passed.

<h3><span class="brown">manager.reconnectionDelayMax([value])</span></h3>
<code>value</code> <em>(Number)</em>
<strong>Returns</strong> <code>Manager|Number</code>

Sets the <code>reconnectionDelayMax</code> option, or returns it if no parameters are passed.

<h3><span class="brown">manager.timeout([value])</span></h3>
<code>value</code> <em>(Number)</em>
<strong>Returns</strong> <code>Manager|Number</code>

Sets the <code>timeout</code> option, or returns it if no parameters are passed.

<h3><span class="brown">manager.open([callback])</span></h3>
<code>callback</code> <em>(Function)</em>
<strong>Returns</strong> <code>Manager</code>

If the manager was initiated with <code>autoConnect</code> to <code>false</code>, launch a new connection attempt.

The <code>callback</code> argument is optional and will be called once the attempt fails/succeeds.

<h3><span class="brown">manager.connect([callback])</span></h3>Synonym of manager.open([callback])</a></a>.

<h3><span class="brown">manager.socket(nsp, options)</span></h3>
<code>nsp</code> <em>(String)</em>
<code>options</code> <em>(Object)</em>
<strong>Returns</strong> <code>Socket</code>

Creates a new <code>Socket</code> for the given namespace. 
Only <code>auth</code> (<code>{ auth: {key: "value"} }</code>) is read from the <code>options</code> object. 
Other keys will be ignored and should be passed when instancing a <code>new Manager(nsp, options)</code>.

<h3><span class="brown">Event: ‘error’</span></h3>
<code>error</code> <em>(Object)</em> error object

Fired upon a connection error.

<h3><span class="brown">Event: ‘reconnect’</span></h3>
<code>attempt</code> <em>(Number)</em> reconnection attempt number

Fired upon a successful reconnection.

<h3><span class="brown">Event: ‘reconnect_attempt’</span></h3>
<code>attempt</code> <em>(Number)</em> reconnection attempt number

Fired upon an attempt to reconnect.

<h3><span class="brown">Event: ‘reconnect_error’</span></h3>
<code>error</code> <em>(Object)</em> error object

Fired upon a reconnection attempt error.

<h3><span class="brown">Event: ‘reconnect_failed’</span></h3>Fired when couldn’t reconnect within <code>reconnectionAttempts</code>.

<h3><span class="brown">Event: 'ping'</span></h3>Fired when a ping packet is received from the server.

<h2>Socket</h2>A <code>Socket</code> is the fundamental class for interacting with the server. 
A <code>Socket</code> belongs to a certain <a href="/docs/v3/namespaces/">Namespace</a> (by default <code>/</code>) and uses an underlying Manager</a> to communicate.

A <code>Socket</code> is basically an <a href="https://nodejs.org/api/events.html#events_class_eventemitter">EventEmitter</a> which sends events to — and receive events from — the server over the network.

socket.emit("hello", { a: "b", c: [] });

socket.on("hey", (...args) => {
  // ...
});

More information can be found <a href="/docs/v3/client-socket-instance/">here</a>.

<h3><span class="brown">socket.id</span></h3>
<em>(String)</em>

An unique identifier for the socket session. 
Set after the <code>connect</code> event is triggered, and updated after the <code>reconnect</code> event.

const socket = io("http://localhost");

console.log(socket.id); // undefined

socket.on("connect", () => {
  console.log(socket.id); // "G5p5..."
});

<h3><span class="brown">socket.connected</span></h3>
<em>(Boolean)</em>

Whether or not the socket is connected to the server.

const socket = io("http://localhost");

socket.on("connect", () => {
  console.log(socket.connected); // true
});

<h3><span class="brown">socket.disconnected</span></h3>
<em>(Boolean)</em>

Whether or not the socket is disconnected from the server.

const socket = io("http://localhost");

socket.on("connect", () => {
  console.log(socket.disconnected); // false
});

<h3><span class="brown">socket.open()</span></h3>
<strong>Returns</strong> <code>Socket</code>

Manually opens the socket.

const socket = io({
  autoConnect: false
});

// ...
socket.open();

It can also be used to manually reconnect:

socket.on("disconnect", () => {
  socket.open();
});

<h3><span class="brown">socket.connect()</span></h3>Synonym of socket.open()</a></a>.

<h3><span class="brown">socket.send([…args][, ack])</span></h3>
<code>args</code>
<code>ack</code> <em>(Function)</em>
<strong>Returns</strong> <code>Socket</code>

Sends a <code>message</code> event. 
See socket.emit(eventName[, …args][, ack])</a>.

<h3><span class="brown">socket.emit(eventName[, …args][, ack])</span></h3>
<code>eventName</code> <em>(String)</em>
<code>args</code>
<code>ack</code> <em>(Function)</em>
<strong>Returns</strong> <code>true</code>

Emits an event to the socket identified by the string name. 
Any other parameters can be included. 
All serializable datastructures are supported, including <code>Buffer</code>.

socket.emit("hello", "world");
socket.emit("with-binary", 1, "2", { 3: "4", 5: Buffer.from([6, 7, 8]) });

The <code>ack</code> argument is optional and will be called with the server answer.

socket.emit("ferret", "tobi", (data) => {
  console.log(data); // data will be "woot"
});

// server:
//  io.on("connection", (socket) => {
//    socket.on("ferret", (name, fn) => {
//      fn("woot");
//    });
//  });

<h3><span class="brown">socket.on(eventName, callback)</span></h3>
<code>eventName</code> <em>(String)</em>
<code>callback</code> <em>(Function)</em>
<strong>Returns</strong> <code>Socket</code>

Register a new handler for the given event.

socket.on("news", (data) => {
  console.log(data);
});

// with multiple arguments
socket.on("news", (arg1, arg2, arg3, arg4) => {
  // ...
});
// with callback
socket.on("news", (cb) => {
  cb(0);
});

The socket actually inherits every method of the <a href="https://github.com/component/emitter">Emitter</a> class, like <code>hasListeners</code>, <code>once</code> or <code>off</code> (to remove an event listener).

<h3><span class="brown">socket.onAny(callback)</span></h3>
<code>callback</code> <em>(Function)</em>

Register a new catch-all listener.

socket.onAny((event, ...args) => {
  console.log(`got ${event}`);
});

<h3><span class="brown">socket.prependAny(callback)</span></h3>
<code>callback</code> <em>(Function)</em>

Register a new catch-all listener. 
The listener is added to the beginning of the listeners array.

socket.prependAny((event, ...args) => {
  console.log(`got ${event}`);
});

<h3><span class="brown">socket.offAny([listener])</span></h3>
<code>listener</code> <em>(Function)</em>

Removes the previously registered listener. 
If no listener is provided, all catch-all listeners are removed. 

const myListener = () => { /* ... 
*/ };

socket.onAny(myListener);

// then, later
socket.offAny(myListener);

socket.offAny();

<h3><span class="brown">socket.listenersAny()</span></h3>
<strong>Returns</strong> <code>Function[]</code>

Returns the list of registered catch-all listeners.

const listeners = socket.listenersAny();

<h3><span class="brown">socket.compress(value)</span></h3>
<code>value</code> <em>(Boolean)</em>
<strong>Returns</strong> <code>Socket</code>

Sets a modifier for a subsequent event emission that the event data will only be <em>compressed</em> if the value is <code>true</code>. 
Defaults to <code>true</code> when you don’t call the method.

socket.compress(false).emit("an event", { some: "data" });

<h3><span class="brown">socket.close()</span></h3>
<strong>Returns</strong> <code>Socket</code>

Disconnects the socket manually.

<h3><span class="brown">socket.disconnect()</span></h3>Synonym of socket.close()</a></a>.

<h3><span class="brown">Event: 'connect'</span></h3>Fired upon connection to the Namespace (including a successful reconnect</ion).

socket.on("connect", () => {
  // ...
});

// note: you should register event handlers outside of connect,
// so they are not registered again on reconnection
socket.on("myevent", () => {
  // ...
});

<h3><span class="brown">Event: ‘disconnect’</span></h3>
<code>reason</code> <em>(String)</em>

Fired upon disconnection. 
The list of possible disconnection reasons:

Reason
Description

<code>io server disconnect</code>
The server has forcefully disconnected the socket with socket.disconnect()

<code>io client disconnect</code>
The socket was manually disconnected using socket.disconnect()

<code>ping timeout</code>
The server did not send a PING within the <code>pingInterval + pingTimeout</code> range

<code>transport close</code>
The connection was closed (example: the user has lost connection, or the network was changed from WiFi to 4G)

<code>transport error</code>
The connection has encountered an error (example: the server was killed during a HTTP long-polling cycle)

In the first two cases (explicit disconnection), the client will not try to reconnect and you need to manually call <code>socket.connect()</code>.

In all other cases, the client will wait for a small random delay and then try to reconnect:

socket.on("disconnect", (reason) => {
  if (reason === "io server disconnect") {
    // the disconnection was initiated by the server, you need to reconnect manually
    socket.connect();
  }
  // else the socket will automatically try to reconnect
});

<h3><span class="brown">Event: ‘connect_error’</span></h3>
<code>connect_error</code> <em>(Object)</em> error object

Fired when an namespace middleware error occurs.

socket.on("connect_error", (error) => {
  // ...
});


<h2><span class="orange">Rooms</span></h2>
https://socket.io/docs/v3/rooms/

A <em>room</em> is an arbitrary channel that sockets can <code>join</code> and <code>leave</code>. 
It can be used to broadcast events to a subset of clients:

<img src="https://socket.io/images/rooms.png">

Please note that rooms are a <strong>server-only</strong> concept (i.e. the client does not have access to the list of rooms it has joined).

<h2>Joining and leaving</h2>
You can call <code>join</code> to subscribe the socket to a given channel:

io.on(&#x27;connection&#x27;, socket =&gt; {
  socket.join(&#x27;some room&#x27;);
});

And then simply use <code>to</code> or <code>in</code> (they are the same) when broadcasting or emitting:

io.to(&#x27;some room&#x27;).emit(&#x27;some event&#x27;);

You can emit to several rooms at the same time:

io.to(&#x27;room1&#x27;).to(&#x27;room2&#x27;).to(&#x27;room3&#x27;).emit(&#x27;some event&#x27;);

In that case, a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Union_(set_theory)">union</a> is performed: every socket that is at least in one of the rooms will get the event <strong>once</strong> (even if the socket is in two or more rooms).

You can also broadcast to a room from a given socket:

io.on(&#x27;connection&#x27;, function(socket){
  socket.to(&#x27;some room&#x27;).emit(&#x27;some event&#x27;);
});

In that case, every socket in the room <strong>excluding</strong> the sender will get the event.

<img src="https://socket.io/images/rooms2.png">

To leave a channel you call <code>leave</code> in the same fashion as <code>join</code>.

<h2>Default room</h2>
Each <code>Socket</code> in Socket.IO is identified by a random, unguessable, unique identifier <a href="https://socket.io/docs/v3/server-socket-instance/#Socket-id">Socket#id</a>. 
For your convenience, each socket automatically joins a room identified by its own id.

This makes it easy to implement private messages:

io.on("connection", socket =&gt; {
  socket.on("private message", (anotherSocketId, msg) =&gt; {
    socket.to(anotherSocketId).emit("private message", socket.id, msg);
  });
});

<h2>Sample use cases</h2>
broadcast data to each device / tab of a given user

io.on(&#x27;connection&#x27;, async (socket) =&gt; {
  const userId = await fetchUserId(socket);

  socket.join(userId);

  // and then later
  io.to(userId).emit(&#x27;hi&#x27;);
});

send notifications about a given entity

io.on(&#x27;connection&#x27;, async (socket) =&gt; {
  const projects = await fetchProjects(socket);

  projects.forEach(project =&gt; socket.join(&#x27;project:&#x27; + project.id));

  // and then later
  io.to(&#x27;project:4321&#x27;).emit(&#x27;project updated&#x27;);
});

<h2>Usage with asynchronous code</h2>
Please make sure to use <code>io.to(...).emit(...)</code> (or <code>socket.to(...).emit(...)</code>) in a synchronous manner.

Example with callback:

// BAD
const room = socket.to(&#x27;room1&#x27;);
saveProduct(() =&gt; {
  room.emit(&#x27;product-updated&#x27;);
});

// GOOD
saveProduct(() =&gt; {
  socket.to(&#x27;room1&#x27;).emit(&#x27;product-updated&#x27;);
});

Example with <code>async/await</code>:

// BAD
io.to(&#x27;room2&#x27;).emit(&#x27;details&#x27;, await fetchDetails());

// GOOD
const details = await fetchDetails();
io.to(&#x27;room2&#x27;).emit(&#x27;details&#x27;, details);

Explanation: the <code>to()</code> method does not return a new object, it mutates an attribute on the <code>io</code> (respectively, the <code>socket</code>) object.

This also applies to other broadcast modifiers:

<a href="https://socket.io/docs/v3/server-api/#Flag-%E2%80%98local%E2%80%99">local</a>
<a href="https://socket.io/docs/v3/server-api/#Flag-%E2%80%98broadcast%E2%80%99">broadcast</a>
<a href="https://socket.io/docs/v3/server-api/#Flag-%E2%80%98volatile%E2%80%99">volatile</a>

<h2>Disconnection</h2>
Upon disconnection, sockets <code>leave</code> all the channels they were part of automatically, and no special teardown is needed on your part.

You can fetch the rooms the Socket was in by listening to the <code>disconnecting</code> event:

io.on(&#x27;connection&#x27;, socket =&gt; {
  socket.on(&#x27;disconnecting&#x27;, () =&gt; {
    console.log(socket.rooms); // the Set contains at least the socket ID
  });

  socket.on(&#x27;disconnect&#x27;, () =&gt; {
    // socket.rooms.size === 0
  });
});

<h2>With multiple Socket.IO servers</h2>
Like <a href="https://socket.io/docs/v3/broadcasting-events/#With-multiple-Socket-IO-servers">global broadcasting</a>, broadcasting to rooms also works with multiple Socket.IO servers.

You just need to replace the default <a href="https://socket.io/docs/v3/glossary/#Adapter">Adapter</a> by the Redis Adapter. 
More information about it <a href="https://socket.io/docs/v3/using-multiple-nodes/#Passing-events-between-nodes">here</a>.

<img src="https://socket.io/images/rooms-redis.png">

<h2>Implementation details</h2>
The “room” feature is implemented by what we call an Adapter. 
This Adapter is a server-side component which is responsible for:

storing the relationships between the Socket instances and the rooms
broadcasting events to all (or a subset of) clients

You can find the code of the default in-memory adapter <a target="_blank" rel="noopener" href="https://github.com/socketio/socket.io-adapter">here</a>.

Basically, it consists in two <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">ES6 Maps</a>:

<code>sids</code>: <code>Map&lt;SocketId, Set&lt;Room&gt;&gt;</code>
<code>rooms</code>: <code>Map&lt;Room, Set&lt;SocketId&gt;&gt;</code>

Calling <code>socket.join("the-room")</code> will result in:

in the ̀<code>sids</code> Map, adding “the-room” to the Set identified by the socket ID
in the <code>rooms</code> Map, adding the socket ID in the Set identified by the string “the-room”

Those two maps are then used when broadcasting:

a broadcast to all sockets (<code>io.emit()</code>) loops through the <code>sids</code> Map, and send the packet to all sockets
a broadcast to a given room (<code>io.to("room21").emit()</code>) loops through the Set in the <code>rooms</code> Map, and sends the packet to all matching sockets

You can access those objects with:

// main namespace
const rooms = io.of("/").adapter.rooms;
const sids = io.of("/").adapter.sids;

// custom namespace
const rooms = io.of("/my-namespace").adapter.rooms;
const sids = io.of("/my-namespace").adapter.sids;

Notes:

those objects are not meant to be directly modified, you should always use <a href="https://socket.io/docs/v3/server-api/#socket-join-room"><code>socket.join(...)</code></a> and <a href="https://socket.io/docs/v3/server-api/#socket-leave-room"><code>socket.leave(...)</code></a> instead.
in a <a href="https://socket.io/docs/v3/using-multiple-nodes/">multi-server</a> setup, the <code>rooms</code> and <code>sids</code> objects are not shared between the Socket.IO servers (a room may only “exist” on one server and not on another).

<h2>Room events</h2>
Starting with <code>socket.io@3.1.0</code>, the underlying Adapter will emit the following events:

<code>create-room</code> (argument: room)
<code>delete-room</code> (argument: room)
<code>join-room</code> (argument: room, id)
<code>leave-room</code> (argument: room, id)

Example:

io.of("/").adapter.on("create-room", (room) =&gt; {
  console.log(`room ${room} was created`);
});

io.of("/").adapter.on("join-room", (room, id) =&gt; {
  console.log(`socket ${id} has joined room ${room}`);
});

<h2><span class="orange">Using multiple nodes</span></h2>
https://socket.io/docs/v3/using-multiple-nodes/index.html

When deploying multiple Socket.IO servers, there are two things to take care of:

enabling sticky session, if HTTP long-polling is enabled (which is the default): see below</a>
using the Redis adapter (or another compatible <a href="https://socket.io/docs/v3/glossary/#Adapter">Adapter</a>): see below</a>

<h2>Sticky load balancing</h2>
If you plan to distribute the load of connections among different processes or machines, you have to make sure that all requests associated with a particular session ID reach the process that originated them.

<h3>Why is sticky-session required</h3>
This is because the HTTP long-polling transport sends multiple HTTP requests during the lifetime of the Socket.IO session.

In fact, Socket.IO could technically work without sticky sessions, with the following synchronization (in dashed lines):

<img src="https://socket.io/images/mutiple-nodes-no-sticky.png">

While obviously possible to implement, we think that this synchronization process between the Socket.IO servers would result in a big performance hit for your application.

Remarks:

without enabling sticky-session, you will experience HTTP 400 errors due to “Session ID unknown”
the WebSocket transport does not have this limitation, since it relies on a single TCP connection for the whole session. 
Which means that if you disable the HTTP long-polling transport (which is a perfectly valid choice in 2021), you won’t need sticky sessions:

const socket = io("https://io.yourhost.com", {
  // WARNING: in that case, there is no fallback to long-polling
  transports: [ "websocket" ] // or [ "websocket", "polling" ] (the order matters)
});

Documentation: <a href="https://socket.io/docs/v3/client-initialization/#transports"><code>transports</code></a>

<h3>Enabling sticky-session</h3>
To achieve sticky-session, there are two main solutions:

routing clients based on a cookie (recommended solution)
routing clients based on their originating address

You will find below some examples with common load-balancing solutions:

NginX</a> (IP-based)
Apache HTTPD</a> (cookie-based)
HAProxy</a> (cookie-based)
Traefik</a> (cookie-based)
Node.js <code>cluster</code> module</a>

For other platforms, please refer to the relevant documentation:

Kubernetes: <a target="_blank" rel="noopener" href="https://kubernetes.github.io/ingress-nginx/examples/affinity/cookie/">https://kubernetes.github.io/ingress-nginx/examples/affinity/cookie/</a>
AWS (Application Load Balancers): <a target="_blank" rel="noopener" href="https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-target-groups.html#sticky-sessions">https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-target-groups.html#sticky-sessions</a>
GCP: <a target="_blank" rel="noopener" href="https://cloud.google.com/load-balancing/docs/backend-service#session_affinity">https://cloud.google.com/load-balancing/docs/backend-service#session_affinity</a>
Heroku: <a target="_blank" rel="noopener" href="https://devcenter.heroku.com/articles/session-affinity">https://devcenter.heroku.com/articles/session-affinity</a>

<strong>Important note</strong>: if you are in a CORS situation (the front domain is different from the server domain) and session affinity is achieved with a cookie, you need to allow credentials:

<em>Server</em>

const io = require("socket.io")(httpServer, {
  cors: {
    origin: "https://front-domain.com",
    methods: ["GET", "POST"],
    credentials: true
  }
});

<em>Client</em>

const io = require("socket.io-client");
const socket = io("https://server-domain.com", {
  withCredentials: true
});

Without it, the cookie will not be sent by the browser and you will experience HTTP 400 “Session ID unknown” responses. 
More information <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials">here</a>.

<h3>NginX configuration</h3>
Within the <code>http { }</code> section of your <code>nginx.conf</code> file, you can declare a <code>upstream</code> section with a list of Socket.IO process you want to balance load between:

http {
  server {
    listen 3000;
    server_name io.yourhost.com;

    location / {
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header Host $host;

      proxy_pass http://nodes;

      # enable WebSockets
      proxy_http_version 1.1;
      proxy_set_header Upgrade $http_upgrade;
      proxy_set_header Connection "upgrade";
    }
  }

  upstream nodes {
    # enable sticky session with either "hash" (uses the complete IP address)
    hash $remote_addr consistent;
    # or "ip_hash" (uses the first three octets of the client IPv4 address, or the entire IPv6 address)
    # ip_hash;
    # or "sticky" (needs commercial subscription)
    # sticky cookie srv_id expires=1h domain=.example.com path=/;

    server app01:3000;
    server app02:3000;
    server app03:3000;
  }
}

Notice the <code>hash</code> instruction that indicates the connections will be sticky.

Make sure you also configure <code>worker_processes</code> in the topmost level to indicate how many workers NginX should use. 
You might also want to look into tweaking the <code>worker_connections</code> setting within the <code>events { }</code> block.

Links:

<a target="_blank" rel="noopener" href="https://github.com/socketio/socket.io/tree/master/examples/cluster-nginx">Example</a>
<a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html#hash">NginX Documentation</a>

<h3>Apache HTTPD configuration</h3>
Header add Set-Cookie "SERVERID=sticky.%{BALANCER_WORKER_ROUTE}e; path=/" env=BALANCER_ROUTE_CHANGED

&lt;Proxy "balancer://nodes_polling"&gt;
    BalancerMember "http://app01:3000" route=app01
    BalancerMember "http://app02:3000" route=app02
    BalancerMember "http://app03:3000" route=app03
    ProxySet stickysession=SERVERID
&lt;/Proxy&gt;

&lt;Proxy "balancer://nodes_ws"&gt;
    BalancerMember "ws://app01:3000" route=app01
    BalancerMember "ws://app02:3000" route=app02
    BalancerMember "ws://app03:3000" route=app03
    ProxySet stickysession=SERVERID
&lt;/Proxy&gt;

RewriteEngine On
RewriteCond %{HTTP:Upgrade} =websocket [NC]
RewriteRule /(.*) balancer://nodes_ws/$1 [P,L]
RewriteCond %{HTTP:Upgrade} !=websocket [NC]
RewriteRule /(.*) balancer://nodes_polling/$1 [P,L]

ProxyTimeout 3

Links:

<a target="_blank" rel="noopener" href="https://github.com/socketio/socket.io/tree/master/examples/cluster-httpd">Example</a>
<a target="_blank" rel="noopener" href="https://httpd.apache.org/docs/2.4/en/mod/mod_proxy.html#proxypass">Documentation</a>

<h3>HAProxy configuration</h3>
# Reference: http:&#x2F;&#x2F;blog.haproxy.com&#x2F;2012&#x2F;11&#x2F;07&#x2F;websockets-load-balancing-with-haproxy&#x2F;

listen chat
  bind *:80
  default_backend nodes

backend nodes
  option httpchk HEAD &#x2F;health
  http-check expect status 200
  cookie io prefix indirect nocache # using the &#96;io&#96; cookie set upon handshake
  server app01 app01:3000 check cookie app01
  server app02 app02:3000 check cookie app02
  server app03 app03:3000 check cookie app03

Links:

<a target="_blank" rel="noopener" href="https://github.com/socketio/socket.io/tree/master/examples/cluster-haproxy">Example</a>
<a target="_blank" rel="noopener" href="http://cbonte.github.io/haproxy-dconv/2.4/configuration.html#cookie">Documentation</a>

<h3>Traefik</h3>
Using container labels:

# docker-compose.yml
services:
  traefik:
    image: traefik:2.4
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    links:
      - server

  server:
    image: my-image:latest
    labels:
      - "traefik.http.routers.my-service.rule=PathPrefix(`/`)"
      - traefik.http.services.my-service.loadBalancer.sticky.cookie.name=server_id
      - traefik.http.services.my-service.loadBalancer.sticky.cookie.httpOnly=true

With the <a target="_blank" rel="noopener" href="https://doc.traefik.io/traefik/v2.0/providers/file/">File provider</a>:

## Dynamic configuration
http:
  services:
    my-service:
      rule: "PathPrefix(`/`)"
      loadBalancer:
        sticky:
          cookie:
            name: server_id
            httpOnly: true

Links:

<a target="_blank" rel="noopener" href="https://github.com/socketio/socket.io/tree/master/examples/cluster-traefik">Example</a>
<a target="_blank" rel="noopener" href="https://doc.traefik.io/traefik/v2.0/routing/services/#sticky-sessions">Documentation</a>

<h3>Using Node.js Cluster</h3>
Just like NginX, Node.js comes with built-in clustering support through the <code>cluster</code> module.

There are several solutions, depending on your use case:

NPM package
How it works

<a target="_blank" rel="noopener" href="https://github.com/darrachequesne/socket.io-sticky"><code>@socket.io/sticky</code></a>
the routing is based on the <code>sid</code> query parameter

<a target="_blank" rel="noopener" href="https://github.com/indutny/sticky-session"><code>sticky-session</code></a>
the routing is based on <code>connection.remoteAddress</code>

<a target="_blank" rel="noopener" href="https://github.com/wzrdtales/socket-io-sticky-session"><code>socketio-sticky-session</code></a>
the routing based on the <code>x-forwarded-for</code> header)

Example with <code>@socket.io/sticky</code>:

const cluster = require("cluster");
const http = require("http");
const { Server } = require("socket.io");
const redisAdapter = require("socket.io-redis");
const numCPUs = require("os").cpus().length;
const { setupMaster, setupWorker } = require("@socket.io/sticky");

if (cluster.isMaster) {
  console.log(`Master ${process.pid} is running`);

  const httpServer = http.createServer();
  setupMaster(httpServer, {
    loadBalancingMethod: "least-connection", // either "random", "round-robin" or "least-connection"
  });
  httpServer.listen(3000);

  for (let i = 0; i &lt; numCPUs; i++) {
    cluster.fork();
  }

  cluster.on("exit", (worker) =&gt; {
    console.log(`Worker ${worker.process.pid} died`);
    cluster.fork();
  });
} else {
  console.log(`Worker ${process.pid} started`);

  const httpServer = http.createServer();
  const io = new Server(httpServer);
  io.adapter(redisAdapter({ host: "localhost", port: 6379 }));
  setupWorker(io);

  io.on("connection", (socket) =&gt; {
    /* ... 
*/
  });
}

<h2>Passing events between nodes</h2><h3>The Redis adapter</h3>
Now that you have multiple Socket.IO nodes accepting connections, if you want to broadcast events to all clients (or to the clients in a certain <a href="https://socket.io/docs/v3/rooms/">room</a>) you&#8217;ll need some way of passing messages between processes or computers.

The interface in charge of routing messages is what we call the <a href="https://socket.io/docs/v3/glossary/#Adapter">Adapter</a>. 
You can implement your own on top of the <a target="_blank" rel="noopener" href="https://github.com/socketio/socket.io-adapter">socket.io-adapter</a> (by inheriting from it) or you can use the one we provide on top of <a target="_blank" rel="noopener" href="https://redis.io/">Redis</a>: <a target="_blank" rel="noopener" href="https://github.com/socketio/socket.io-redis">socket.io-redis</a>:

const io = require("socket.io")(3000);
const redis = require("socket.io-redis");
io.adapter(redis({ host: "localhost", port: 6379 }));

Then the following call:

io.emit("hi", "all sockets");

will be broadcast to every clients through the <a target="_blank" rel="noopener" href="https://redis.io/topics/pubsub">Pub/Sub mechanism</a> of Redis:

<img src="https://socket.io/images/broadcasting-redis.png">

<h3>Sending messages from the outside world</h3>
Using the Redis adapter has another benefit: you can now emit events from outside the context of your Socket.IO processes.

<img src="https://socket.io/images/emitter.png">

This emitter is available in several languages:

Javascript: <a target="_blank" rel="noopener" href="https://github.com/socketio/socket.io-emitter">https://github.com/socketio/socket.io-emitter</a>
Java: <a target="_blank" rel="noopener" href="https://github.com/sunsus/socket.io-java-emitter">https://github.com/sunsus/socket.io-java-emitter</a>
Python: <a target="_blank" rel="noopener" href="https://pypi.org/project/socket.io-emitter/">https://pypi.org/project/socket.io-emitter/</a>
PHP: <a target="_blank" rel="noopener" href="https://github.com/rase-/socket.io-php-emitter">https://github.com/rase-/socket.io-php-emitter</a>
Golang: <a target="_blank" rel="noopener" href="https://github.com/yosuke-furukawa/socket.io-go-emitter">https://github.com/yosuke-furukawa/socket.io-go-emitter</a>
Perl: <a target="_blank" rel="noopener" href="https://metacpan.org/pod/SocketIO::Emitter">https://metacpan.org/pod/SocketIO::Emitter</a>
Rust: <a target="_blank" rel="noopener" href="https://github.com/epli2/socketio-rust-emitter">https://github.com/epli2/socketio-rust-emitter</a>

<h2><span class="orange">The Socket instance (client-<</span>/side)</h2>
https://socket.io/docs/v3/client-socket-instance/

Besides <a href="https://socket.io/docs/v3/emitting-events/#Basic-emit">emitting</a> and <a href="https://socket.io/docs/v3/listening-to-events/">listening to</a> events, the Socket instance has a few attributes that may be of use in your application:

<h2>Socket#id</h2>
Each new connection is assigned a random 20-characters identifier.

This identifier is synced with the value on the server-side.

// server-side
io.on("connection", (socket) =&gt; {
  console.log(socket.id); // x8WIv7-mJelg7on_ALbx
});

// client-side
socket.on("connect", () =&gt; {
  console.log(socket.id); // x8WIv7-mJelg7on_ALbx
});

socket.on("disconnect", () =&gt; {
  console.log(socket.id); // undefined
});

<h2>Socket#connected</h2>
This attribute describes whether the socket is currently connected to the server.

socket.on("connect", () =&gt; {
  console.log(socket.connected); // true
});

socket.on("disconnect", () =&gt; {
  console.log(socket.connected); // false
});

<h2>Lifecycle</h2><img src="https://socket.io/images/client_socket_events.png" />

<h2>Events</h2>
The Socket instance emits three special events:

<code>connect</code></a>
<code>connect_error</code></a>
<code>disconnect</code></a>

Please note that since Socket.IO v3, the Socket instance does not emit any event related to the reconnection logic anymore. 
You can listen to the events on the Manager instance directly:

socket.io.on("reconnection_attempt", () =&gt; {
  // ...
});

socket.io.on("reconnect", () =&gt; {
  // ...
});

More information can be found in the <a href="https://socket.io/docs/v3/migrating-from-2-x-to-3-0/#The-Socket-instance-will-no-longer-forward-the-events-emitted-by-its-Manager">migration guide</a>.

<h3><code>connect</code></h3>
This event is fired by the Socket instance upon connection <strong>and</strong> reconnection.

socket.on("connect", () =&gt; {
  // ...
});

Please note that you shouldn’t register event handlers in the <code>connect</code> handler itself, as a new handler will be registered every time the Socket reconnects:

// BAD
socket.on("connect", () =&gt; {
  socket.on("data", () =&gt; { /* ... 
*/ });
});

// GOOD
socket.on("connect", () =&gt; {
  // ...
});

socket.on("data", () =&gt; { /* ... 
*/ });

<h3><code>connect_error</code></h3>
This event is fired when:

the low-level connection cannot be established
the connection is denied by the server in a <a href="https://socket.io/docs/v3/middlewares/">middleware function</a>

In the first case, the Socket will automatically try to reconnect, after a <a href="https://socket.io/docs/v3/client-initialization/#reconnectionDelay">given delay</a>.

In the latter case, you need to manually reconnect. 
You might need to update the credentials:

// either by directly modifying the `auth` attribute
socket.on("connect_error", () =&gt; {
  socket.auth.token = "abcd";
  socket.connect();
});

// or if the `auth` attribute is a function
const socket = io({
  auth: (cb) =&gt; {
    cb(localStorage.getItem("token"));
  }
});

socket.on("connect_error", () =&gt; {
  setTimeout(() =&gt; {
    socket.connect();
  }, 1000);
});

<h3><code>disconnect</code></h3>
This event is fired upon disconnection.

socket.on("disconnect", (reason) =&gt; {
  // ...
});

Here is the list of possible reasons:

Reason
Description

<code>io server disconnect</code>
The server has forcefully disconnected the socket with <a href="https://socket.io/docs/v3/server-api/#socket-disconnect-close">socket.disconnect()</a>

<code>io client disconnect</code>
The socket was manually disconnected using <a href="https://socket.io/docs/v3/client-api/#socket-disconnect">socket.disconnect()</a>

<code>ping timeout</code>
The server did not send a PING within the <code>pingInterval + pingTimeout</code> range

<code>transport close</code>
The connection was closed (example: the user has lost connection, or the network was changed from WiFi to 4G)

<code>transport error</code>
The connection has encountered an error (example: the server was killed during a HTTP long-polling cycle)

In the first two cases (explicit disconnection), the client will not try to reconnect and you need to manually call <code>socket.connect()</code>.

In all other cases, the client will wait for a small <a href="https://socket.io/docs/v3/client-initialization/#reconnectionDelay">random delay</a> and then try to reconnect:

socket.on("disconnect", (reason) =&gt; {
  if (reason === "io server disconnect") {
    // the disconnection was initiated by the server, you need to reconnect manually
    socket.connect();
  }
  // else the socket will automatically try to reconnect
});

Note: those events, along with <code>disconnecting</code>, <code>newListener</code> and <code>removeListener</code>, are special events that shouldn’t be used in your application:

// BAD, will throw an error
socket.emit("disconnect");

<h2>Complete API</h2>
The complete API exposed by the Socket instance can be found <a href="https://socket.io/docs/v3/client-api/#Socket">here</a>.

<h2><span class="orange borRad20 bordred1">Server API</span></h2>

<h2>Server</h2>Exposed by <code>require("socket.io")</code>.

Related documentation pages:

<a href="https://socket.io/docs/v3/server-installation/">installation</a>

<a href="https://socket.io/docs/v3/server-initialization/">initialization</a>

<a href="https://socket.io/docs/v3/server-instance/">details of the server instance</a>

<h3><span class="brown">new Server(httpServer[, options])</span></h3>
<code>httpServer</code> <em>(http.Server)</em> the server to bind to.

<code>options</code> <em>(Object)</em>

Works with and without <code>new</code>:

const io = require("socket.io")();
// or
const { Server } = require("socket.io");
const io = new Server();

Available options:

Option
Default value
Description

<code>path</code>
<code>/socket.io</code>
name of the path to capture

<code>serveClient</code>
<code>true</code>
whether to serve the client files

<code>adapter</code>
-
the adapter to use. 
Defaults to an instance of the <code>Adapter</code> that ships with socket.io which is memory based. 
See <a href="https://github.com/socketio/socket.io-adapter">socket.io-adapter</a>

<code>parser</code>
-
the parser to use. 
Defaults to an instance of the <code>Parser</code> that ships with socket.io. 
See <a href="https://github.com/socketio/socket.io-parser">socket.io-parser</a>.

<code>connectTimeout</code>
<code>45000</code>
the number of ms before closing a client that has not successfully joined a namespace.

Available options for the underlying Engine.IO server:

Option
Default value
Description

<code>pingTimeout</code>
<code>5000</code>
how many ms without a pong packet to consider the connection closed

<code>pingInterval</code>
<code>25000</code>
how many ms before sending a new ping packet

<code>upgradeTimeout</code>
<code>10000</code>
how many ms before an uncompleted transport upgrade is cancelled

<code>maxHttpBufferSize</code>
<code>1e6</code>
how many bytes or characters a message can be, before closing the session (to avoid DoS).

<code>allowRequest</code>

A function that receives a given handshake or upgrade request as its first parameter, and can decide whether to continue or not. 
The second argument is a function that needs to be called with the decided information: <code>fn(err, success)</code>, where <code>success</code> is a boolean value where false means that the request is rejected, and err is an error code.

<code>transports</code>
<code>["polling", "websocket"]</code>
transports to allow connections to

<code>allowUpgrades</code>
<code>true</code>
whether to allow transport upgrades

<code>perMessageDeflate</code>
<code>false</code>
parameters of the WebSocket permessage-deflate extension (see <a href="https://github.com/einaros/ws">ws module</a> api docs). 
Set to <code>true</code> to enable.

<code>httpCompression</code>
<code>true</code>
parameters of the http compression for the polling transports (see <a href="http://nodejs.org/api/zlib.html#zlib_options">zlib</a> api docs). 
Set to <code>false</code> to disable.

<code>wsEngine</code>
<code>ws</code>
what WebSocket server implementation to use. 
Specified module must conform to the <code>ws</code> interface (see <a href="https://github.com/websockets/ws/blob/master/doc/ws.md">ws module api docs</a>). 
Default value is <code>ws</code>. 
An alternative c++ addon is also available by installing the <a href="https://www.npmjs.com/package/eiows">eiows</a> module.

<code>cors</code>

the list of options that will be forwarded to the <a href="https://www.npmjs.com/package/cors">cors</a> module

<code>cookie</code>

the list of options that will be forwarded to the <a href="https://github.com/jshttp/cookie/">cookie</a> module

<code>allowEIO3</code>
<code>false</code>
whether to enable compatibility with Socket.IO v2 clients

More information <a href="https://socket.io/docs/v3/server-initialization/">here</a>.

<h3><span class="brown">new Server(port[, options])</span></h3>
<code>port</code> <em>(Number)</em> a port to listen to (a new <code>http.Server</code> will be created)

<code>options</code> <em>(Object)</em>

See above</a> for the list of available <code>options</code>.

const io = require("socket.io")(3000, {
  path: "/test",
  serveClient: false,
  // below are engine.IO options
  pingInterval: 10000,
  pingTimeout: 5000,
  cookie: false
});

<h3><span class="brown">new Server(options)</span></h3>
<code>options</code> <em>(Object)</em>

See above</a> for the list of available <code>options</code>.

const io = require("socket.io")({
  path: "/test",
  serveClient: false,
});

// either
const server = require("http").createServer();

io.attach(server, {
  pingInterval: 10000,
  pingTimeout: 5000,
  cookie: false
});

server.listen(3000);

// or
io.attach(3000, {
  pingInterval: 10000,
  pingTimeout: 5000,
  cookie: false
});

<h3><span class="brown">server.sockets</span></h3>
<em>(Namespace)</em>

An alias for the default (<code>/</code>) namespace.

io.sockets.emit("hi", "everyone");
// is equivalent to
io.of("/").emit("hi", "everyone");

<h3><span class="brown">server.serveClient([value])</span></h3>
<code>value</code> <em>(Boolean)</em>

<strong>Returns</strong> <code>Server|Boolean</code>

If <code>value</code> is <code>true</code> the attached server (see <code>Server#attach</code>) will serve the client files. 
Defaults to <code>true</code>. 
This method has no effect after <code>attach</code> is called. 
If no arguments are supplied this method returns the current value.

// pass a server and the `serveClient` option
const io = require("socket.io")(http, { serveClient: false });

// or pass no server and then you can call the method
const io = require("socket.io")();
io.serveClient(false);
io.attach(http);

<h3><span class="brown">server.path([value])</span></h3>
<code>value</code> <em>(String)</em>

<strong>Returns</strong> <code>Server|String</code>

Sets the path <code>value</code> under which <code>engine.io</code> and the static files will be served. 
Defaults to <code>/socket.io</code>. 
If no arguments are supplied this method returns the current value.

const io = require("socket.io")();
io.path("/myownpath");

// client-side
const socket = io({
  path: "/myownpath"
});

<h3><span class="brown">server.adapter([value])</span></h3>
<code>value</code> <em>(Adapter)</em>

<strong>Returns</strong> <code>Server|Adapter</code>

Sets the adapter <code>value</code>. 
Defaults to an instance of the <code>Adapter</code> that ships with socket.io which is memory based. 
See <a href="https://github.com/socketio/socket.io-adapter">socket.io-adapter</a>. 
If no arguments are supplied this method returns the current value.

const io = require("socket.io")(3000);
const redis = require("socket.io-redis");
io.adapter(redis({ host: "localhost", port: 6379 }));

<h3><span class="brown">server.attach(httpServer[, options])</span></h3>
<code>httpServer</code> <em>(http.Server)</em> the server to attach to

<code>options</code> <em>(Object)</em>

Attaches the <code>Server</code> to an engine.io instance on <code>httpServer</code> with the supplied <code>options</code> (optionally).

<h3><span class="brown">server.attach(port[, options])</span></h3>
<code>port</code> <em>(Number)</em> the port to listen on

<code>options</code> <em>(Object)</em>

Attaches the <code>Server</code> to an engine.io instance on a new http.Server with the supplied <code>options</code> (optionally).

<h3><span class="brown">server.listen(httpServer[, options])</span></h3>Synonym of server.attach(httpServer[, options])</a>.

<h3><span class="brown">server.listen(port[, options])</span></h3>Synonym of server.attach(port[, options])</a>.

<h3><span class="brown">server.bind(engine)</span></h3>
<code>engine</code> <em>(engine.Server)</em>

<strong>Returns</strong> <code>Server</code>

Advanced use only. 
Binds the server to a specific engine.io <code>Server</code> (or compatible API) instance.

<h3><span class="brown">server.onconnection(socket)</span></h3>
<code>socket</code> <em>(engine.Socket)</em>

<strong>Returns</strong> <code>Server</code>

Advanced use only. 
Creates a new <code>socket.io</code> client from the incoming engine.io (or compatible API) <code>Socket</code>.

<h3><span class="brown">server.of(nsp)</span></h3>
<code>nsp</code> <em>(String|RegExp|Function)</em>

<strong>Returns</strong> <code>Namespace</code>

Initializes and retrieves the given <code>Namespace</code> by its pathname identifier <code>nsp</code>. 
If the namespace was already initialized it returns it immediately.

const adminNamespace = io.of("/admin");

A regex or a function can also be provided, in order to create namespace in a dynamic way:

const dynamicNsp = io.of(/^\/dynamic-\d+$/).on("connection", (socket) => {
  const newNamespace = socket.nsp; // newNamespace.name === "/dynamic-101"

  // broadcast to all clients in the given sub-namespace
  newNamespace.emit("hello");
});

// client-side
const socket = io("/dynamic-101");

// broadcast to all clients in each sub-namespace
dynamicNsp.emit("hello");

// use a middleware for each sub-namespace
dynamicNsp.use((socket, next) => { /* ... */ });

With a function:

io.of((name, query, next) => {
  // the checkToken method must return a boolean, indicating whether the client is able to connect or not.
  next(null, checkToken(query.token));
}).on("connection", (socket) => { /* ... */ });

<h3><span class="brown">server.close([callback])</span></h3>
<code>callback</code> <em>(Function)</em>

Closes the Socket.IO server. 
The <code>callback</code> argument is optional and will be called when all connections are closed.

Note: this also closes the underlying HTTP server.

const Server = require("socket.io");
const PORT   = 3030;
const server = require("http").Server();

const io = Server(PORT);

io.close(); // Close current server

server.listen(PORT); // PORT is free to use

io = Server(server);

<h3><span class="brown">server.engine.generateId</span></h3>Overwrites the default method to generate your custom socket id.

The function is called with a node request object (<code>http.IncomingMessage</code>) as first parameter.

const uuid = require("uuid");

io.engine.generateId = (req) => {
  return uuid.v4(); // must be unique across all Socket.IO servers
}

<h2>Namespace</h2>Represents a pool of sockets connected under a given scope identified by a pathname (eg: <code>/chat</code>).

More information can be found <a href="https://socket.io/docs/v3/namespaces/">here</a>.

<h3><span class="brown">namespace.name</span></h3>
<em>(String)</em>

The namespace identifier property.

<h3><span class="brown">namespace.sockets</span></h3>
<em>(Map&lt;SocketId, Socket>)</em>

A map of Socket</a> instances that are connected to this namespace.

// number of sockets in this namespace (on this node)
const socketCount = io.of("/admin").sockets.size;

<h3><span class="brown">namespace.adapter</span></h3>
<em>(Adapter)</em>

The <a href="https://socket.io/docs/v3/glossary/#Adapter">“Adapter”</a> used for the namespace. 
Useful when using the <code>Adapter</code> based on <a href="https://github.com/socketio/socket.io-redis">Redis</a>, as it exposes methods to manage sockets and rooms across your cluster.

<strong>Note:</strong> the adapter of the main namespace can be accessed with <code>io.of("/").adapter</code>.

Please see the explanation <a href="https://socket.io/docs/v3/rooms/#Implementation-details">here</a>.

<h3><span class="brown">namespace.to(room)</span></h3>
<code>room</code> <em>(String)</em>

<strong>Returns</strong> <code>Namespace</code> for chaining

Sets a modifier for a subsequent event emission that the event will only be <em>broadcasted</em> to clients that have joined the given <code>room</code>.

To emit to multiple rooms, you can call <code>to</code> several times.

const io = require("socket.io")();
const adminNamespace = io.of("/admin");

adminNamespace.to("level1").emit("an event", { some: "data" });

<h3><span class="brown">namespace.in(room)</span></h3>Synonym of namespace.to(room)</a>.

<h3><span class="brown">namespace.emit(eventName[, …args])</span></h3>
<code>eventName</code> <em>(String)</em>

<code>args</code>

<strong>Returns</strong> <code>true</code>

Emits an event to all connected clients. 
The following two are equivalent:

const io = require("socket.io")();
io.emit("an event sent to all connected clients"); // main namespace

const chat = io.of("/chat");
chat.emit("an event sent to all connected clients in chat namespace");

<strong>Note:</strong> acknowledgements are not supported when emitting from namespace.

<h3><span class="brown">namespace.allSockets()</span></h3>
<strong>Returns</strong> <code>Promise&lt;Set&lt;SocketId>></code>

Gets a list of socket IDs connected to this namespace (across all nodes if applicable).

// all sockets in the main namespace
const ids = await io.allSockets();

// all sockets in the main namespace and in the "user:1234" room
const ids = await io.in("user:1234").allSockets();

// all sockets in the "chat" namespace
const ids = await io.of("/chat").allSockets();

// all sockets in the "chat" namespace and in the "general" room
const ids = await io.of("/chat").in("general").allSockets();

<h3><span class="brown">namespace.use(fn)</span></h3>
<code>fn</code> <em>(Function)</em>

Registers a middleware, which is a function that gets executed for every incoming <code>Socket</code>, and receives as parameters the socket and a function to optionally defer execution to the next registered middleware.

Errors passed to middleware callbacks are sent as special <code>connect_error</code> packets to clients.

// server-side
io.use((socket, next) => {
  const err = new Error("not authorized");
  err.data = { content: "Please retry later" }; // additional details
  next(err);
});

// client-side
socket.on("connect_error", err => {
  console.log(err instanceof Error); // true
  console.log(err.message); // not authorized
  console.log(err.data); // { content: "Please retry later" }
});

<h3><span class="brown">Event: ‘connection’</span></h3>
<code>socket</code> <em>(Socket)</em> socket connection with client

Fired upon a connection from client.

io.on("connection", (socket) => {
  // ...
});

io.of("/admin").on("connection", (socket) => {
  // ...
});

<h3><span class="brown">Event: ‘connect’</span></h3>Synonym of Event: “connection”</a>.

<h3><span class="brown">Flag: ‘volatile’</span></h3>Sets a modifier for a subsequent event emission that the event data may be lost if the clients are not ready to receive messages (because of network slowness or other issues, or because they’re connected through long polling and is in the middle of a request-response cycle).

io.volatile.emit("an event", { some: "data" }); // the clients may or may not receive it

<h3><span class="brown">Flag: ‘local’</span></h3>Sets a modifier for a subsequent event emission that the event data will only be <em>broadcast</em> to the current node (when the <a href="https://github.com/socketio/socket.io-redis">Redis adapter</a> is used).

io.local.emit("an event", { some: "data" });

<h2>Socket</h2>A <code>Socket</code> is the fundamental class for interacting with browser clients. 
A <code>Socket</code> belongs to a certain <code>Namespace</code> (by default <code>/</code>) and uses an underlying <code>Client</code> to communicate.

It should be noted the <code>Socket</code> doesn’t relate directly to the actual underlying TCP/IP <code>socket</code> and it is only the name of the class.

Within each <code>Namespace</code>, you can also define arbitrary channels (called <code>room</code>) that the <code>Socket</code> can join and leave. 
That provides a convenient way to broadcast to a group of <code>Socket</code>s (see <code>Socket#to</code> below).

The <code>Socket</code> class inherits from <a href="https://nodejs.org/api/events.html#events_class_eventemitter">EventEmitter</a>. 
The <code>Socket</code> class overrides the <code>emit</code> method, and does not modify any other <code>EventEmitter</code> method. 
All methods documented here which also appear as <code>EventEmitter</code> methods (apart from <code>emit</code>) are implemented by <code>EventEmitter</code>, and documentation for <code>EventEmitter</code> applies.

More information can be found <a href="https://socket.io/docs/v3/server-socket-instance/">here</a>.

<h3><span class="brown">socket.id</span></h3>
<em>(String)</em>

A unique identifier for the session, that comes from the underlying <code>Client</code>.

<h3><span class="brown">socket.rooms</span></h3>
<em>(Set)</em>

A Set of strings identifying the rooms this client is in.

io.on("connection", (socket) => {

  console.log(socket.rooms); // Set { &lt;socket.id> }

  socket.join("room1");

  console.log(socket.rooms); // Set { &lt;socket.id>, "room1" }

});

<h3><span class="brown">socket.client</span></h3>
<em>(Client)</em>

A reference to the underlying <code>Client</code> object.

<h3><span class="brown">socket.conn</span></h3>
<em>(engine.Socket)</em>

A reference to the underlying <code>Client</code> transport connection (engine.io <code>Socket</code> object). 
This allows access to the IO transport layer, which still (mostly) abstracts the actual TCP/IP socket.

<h3><span class="brown">socket.request</span></h3>
<em>(Request)</em>

A getter proxy that returns the reference to the <code>request</code> that originated the underlying engine.io <code>Client</code>. 
Useful for accessing request headers such as <code>Cookie</code> or <code>User-Agent</code>.

const cookie = require("cookie");

io.on("connection", (socket) => {
  const cookies = cookie.parse(socket.request.headers.cookie || ");
});

<h3><span class="brown">socket.handshake</span></h3>
<em>(Object)</em>

The handshake details:

{
  headers: /* the headers sent as part of the handshake */,
  time: /* the date of creation (as string) */,
  address: /* the ip of the client */,
  xdomain: /* whether the connection is cross-domain */,
  secure: /* whether the connection is secure */,
  issued: /* the date of creation (as unix timestamp) */,
  url: /* the request URL string */,
  query: /* the query params of the first request */,
  auth: /* the authentication payload */
}

Usage:

io.use((socket, next) => {
  let handshake = socket.handshake;
  // ...
});

io.on("connection", (socket) => {
  let handshake = socket.handshake;
  // ...
});

<h3><span class="brown">socket.send([…args][, ack])</span></h3>
<code>args</code>

<code>ack</code> <em>(Function)</em>

<strong>Returns</strong> <code>Socket</code>

Sends a <code>message</code> event. 
See socket.emit(eventName[, …args][, ack])</a>.

<h3><span class="brown">socket.emit(eventName[, …args][, ack])</span></h3><em>(overrides <code>EventEmitter.emit</code>)</em>

<code>eventName</code> <em>(String)</em>

<code>args</code>

<code>ack</code> <em>(Function)</em>

<strong>Returns</strong> <code>true</code>

Emits an event to the socket identified by the string name. 
Any other parameters can be included. 
All serializable datastructures are supported, including <code>Buffer</code>.

socket.emit("hello", "world");
socket.emit("with-binary", 1, "2", { 3: "4", 5: Buffer.from([6]) });

The <code>ack</code> argument is optional and will be called with the client’s answer.

io.on("connection", (socket) => {
  socket.emit("an event", { some: "data" });

  socket.emit("ferret", "tobi", (data) => {
    console.log(data); // data will be "woot"
  });

  // the client code
  // client.on("ferret", (name, fn) => {
  //   fn("woot");
  // });

});

<h3><span class="brown">socket.on(eventName, callback)</span></h3><em>(inherited from <code>EventEmitter</code>)</em>

<code>eventName</code> <em>(String)</em>

<code>callback</code> <em>(Function)</em>

<strong>Returns</strong> <code>Socket</code>

Register a new handler for the given event.

socket.on("news", (data) => {
  console.log(data);
});
// with several arguments
socket.on("news", (arg1, arg2, arg3) => {
  // ...
});
// or with acknowledgement
socket.on("news", (data, callback) => {
  callback(0);
});

<h3><span class="brown">socket.once(eventName, listener)</span></h3><h3><span class="brown">socket.removeListener(eventName, listener)</span></h3><h3><span class="brown">socket.removeAllListeners([eventName])</span></h3><h3><span class="brown">socket.eventNames()</span></h3>Inherited from <code>EventEmitter</code> (along with other methods not mentioned here). 
See the Node.js documentation for the <a href="https://nodejs.org/docs/latest/api/events.html">events</a> module.

<h3><span class="brown">socket.onAny(callback)</span></h3>
<code>callback</code> <em>(Function)</em>

Register a new catch-all listener.

socket.onAny((event, ...args) => {
  console.log(`got ${event}`);
});

<h3><span class="brown">socket.prependAny(callback)</span></h3>
<code>callback</code> <em>(Function)</em>

Register a new catch-all listener. 
The listener is added to the beginning of the listeners array.

socket.prependAny((event, ...args) => {
  console.log(`got ${event}`);
});

<h3><span class="brown">socket.offAny([listener])</span></h3>
<code>listener</code> <em>(Function)</em>

Removes the previously registered listener. 
If no listener is provided, all catch-all listeners are removed. 

const myListener = () => { /* ... */ };

socket.onAny(myListener);

// then, later
socket.offAny(myListener);

socket.offAny();

<h3><span class="brown">socket.listenersAny()</span></h3>
<strong>Returns</strong> <code>Function[]</code>

Returns the list of registered catch-all listeners.

const listeners = socket.listenersAny();

<h3><span class="brown">socket.join(room)</span></h3>
<code>room</code> <em>(string)</em> | <em>(string[])</em>

<strong>Returns</strong> <code>void</code> | <code>Promise</code>

Adds the socket to the given <code>room</code> or to the list of rooms.

io.on("connection", (socket) => {
  socket.join("room 237");
  
  console.log(socket.rooms); // Set { &lt;socket.id>, "room 237" }

  socket.join(["room 237", "room 238"]);

  io.to("room 237").emit("a new user has joined the room"); // broadcast to everyone in the room
});

The mechanics of joining rooms are handled by the <code>Adapter</code> that has been configured (see <code>Server#adapter</code> above), defaulting to <a href="https://github.com/socketio/socket.io-adapter">socket.io-adapter</a>.

For your convenience, each socket automatically joins a room identified by its id (see <code>Socket#id</code>). 
This makes it easy to broadcast messages to other sockets:

io.on("connection", (socket) => {
  socket.on("say to someone", (id, msg) => {
    // send a private message to the socket with the given id
    socket.to(id).emit("my message", msg);
  });
});

<h3><span class="brown">socket.leave(room)</span></h3>
<code>room</code> <em>(String)</em>

<strong>Returns</strong> <code>void</code> | <code>Promise</code>

Removes the socket from the given <code>room</code>.

io.on("connection", (socket) => {
  socket.leave("room 237");

  io.to("room 237").emit(`user ${socket.id} has left the room`);
});

<strong>Rooms are left automatically upon disconnection</strong>.

<h3><span class="brown">socket.to(room)</span></h3>
<code>room</code> <em>(String)</em>

<strong>Returns</strong> <code>Socket</code> for chaining

Sets a modifier for a subsequent event emission that the event will only be <em>broadcasted</em> to clients that have joined the given <code>room</code> (the socket itself being excluded).

To emit to multiple rooms, you can call <code>to</code> several times.

io.on("connection", (socket) => {

  // to one room
  socket.to("others").emit("an event", { some: "data" });

  // to multiple rooms
  socket.to("room1").to("room2").emit("hello");

  // a private message to another socket
  socket.to(/* another socket id */).emit("hey");

  // WARNING: `socket.to(socket.id).emit()` will NOT work, as it will send to everyone in the room
  // named `socket.id` but the sender. 
Please use the classic `socket.emit()` instead.
});

<strong>Note:</strong> acknowledgements are not supported when broadcasting.

<h3><span class="brown">socket.in(room)</span></h3>Synonym of socket.to(room)</a>.

<h3><span class="brown">socket.compress(value)</span></h3>
<code>value</code> <em>(Boolean)</em> whether to following packet will be compressed

<strong>Returns</strong> <code>Socket</code> for chaining

Sets a modifier for a subsequent event emission that the event data will only be <em>compressed</em> if the value is <code>true</code>. 
Defaults to <code>true</code> when you don’t call the method.

io.on("connection", (socket) => {
  socket.compress(false).emit("uncompressed", "that&#x27;s rough");
});

<h3><span class="brown">socket.disconnect(close)</span></h3>
<code>close</code> <em>(Boolean)</em> whether to close the underlying connection

<strong>Returns</strong> <code>Socket</code>

Disconnects this socket. 
If value of close is <code>true</code>, closes the underlying connection. 
Otherwise, it just disconnects the namespace.

io.on("connection", (socket) => {
  setTimeout(() => socket.disconnect(true), 5000);
});

<h3><span class="brown">Flag: ‘broadcast’</span></h3>Sets a modifier for a subsequent event emission that the event data will only be <em>broadcast</em> to every sockets but the sender.

io.on("connection", (socket) => {
  socket.broadcast.emit("an event", { some: "data" }); // everyone gets it but the sender
});

<h3><span class="brown">Flag: ‘volatile’</span></h3>Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to receive messages (because of network slowness or other issues, or because they’re connected through long polling and is in the middle of a request-response cycle).

io.on("connection", (socket) => {
  socket.volatile.emit("an event", { some: "data" }); // the client may or may not receive it
});

<h3><span class="brown">Event: ‘disconnect’</span></h3>
<code>reason</code> <em>(String)</em> the reason of the disconnection (either client or server-side)

Fired upon disconnection.

io.on("connection", (socket) => {
  socket.on("disconnect", (reason) => {
    // ...
  });
});

Possible reasons:

Reason
Description

<code>server namespace disconnect</code>
The socket was forcefully disconnected with <a href="https://socket.io/docs/v3/server-api/#socket-disconnect-close">socket.disconnect()</a>

<code>client namespace disconnect</code>
The client has manually disconnected the socket using <a href="https://socket.io/docs/v3/client-api/#socket-disconnect">socket.disconnect()</a>

<code>server shutting down</code>
The server is, well, shutting down

<code>ping timeout</code>
The client did not send a PONG packet in the <code>pingTimeout</code> delay

<code>transport close</code>
The connection was closed (example: the user has lost connection, or the network was changed from WiFi to 4G)

<code>transport error</code>
The connection has encountered an error

<h3><span class="brown">Event: ‘disconnecting’</span></h3>
<code>reason</code> <em>(String)</em> the reason of the disconnection (either client or server-side)

Fired when the client is going to be disconnected (but hasn’t left its <code>rooms</code> yet).

io.on("connection", (socket) => {
  socket.on("disconnecting", (reason) => {
    console.log(socket.rooms); // Set { ... }
  });
});

Note: those events, along with <code>connect</code>, <code>connect_error</code>, <code>newListener</code> and <code>removeListener</code>, are special events that shouldn’t be used in your application:

// BAD, will throw an error
socket.emit("disconnect");

<h2>Client</h2>The <code>Client</code> class represents an incoming transport (engine.io) connection. 
A <code>Client</code> can be associated with many multiplexed <code>Socket</code>s that belong to different <code>Namespace</code>s.

<h3><span class="brown">client.conn</span></h3>
<em>(engine.Socket)</em>

A reference to the underlying <code>engine.io</code> <code>Socket</code> connection.

<h3><span class="brown">client.request</span></h3>
<em>(Request)</em>

A getter proxy that returns the reference to the <code>request</code> that originated the engine.io connection. 
Useful for accessing request headers such as <code>Cookie</code> or <code>User-Agent</code>.

<h2><span class="orange borRad20 bordred1">Emit cheatsheet</span></h2>
io.on("connection", (socket) => {

  // sending to the client
  socket.emit("hello", "can you hear me?", 1, 2, "abc");

  // sending to all clients except sender
  socket.broadcast.emit("broadcast", "hello friends!");

  // sending to all clients in "game" room except sender
  socket.to("game").emit("nice game", "let's play a game");

  // sending to all clients in "game1" and/or in "game2" room, except sender
  socket.to("game1").to("game2").emit("nice game", "let's play a game (too)");

  // sending to all clients in "game" room, including sender
  io.in("game").emit("big-announcement", "the game will start soon");

  // sending to all clients in namespace "myNamespace", including sender
  io.of("myNamespace").emit("bigger-announcement", "the tournament will start soon");

  // sending to a specific room in a specific namespace, including sender
  io.of("myNamespace").to("room").emit("event", "message");

  // sending to individual socketid (private message)
  io.to(socketId).emit("hey", "I just met you");

  // WARNING: `socket.to(socket.id).emit()` will NOT work, as it will send to everyone in the room
  // named `socket.id` but the sender. Please use the classic `socket.emit()` instead.

  // sending with acknowledgement
  socket.emit("question", "do you think so?", (answer) => {});

  // sending without compression
  socket.compress(false).emit("uncompressed", "that's rough");

  // sending a message that might be dropped if the client is not ready to receive messages
  socket.volatile.emit("maybe", "do you really need it?");

  // sending to all clients on this node (when using multiple nodes)
  io.local.emit("hi", "my lovely babies");

  // sending to all connected clients
  io.emit("an event sent to all connected clients");

});

<strong>Note:</strong> The following events are reserved and should not be used as event names by your application:

<code>connect</code>
<code>connect_error</code>
<code>disconnect</code>
<code>disconnecting</code>
<code>newListener</code>
<code>removeListener</code>

// BAD, will throw an error
socket.emit(disconnecting);

<h2>List of Socket.io Events</h2>
<h4>Client-side events for <code>socket.io</code> object:</h4>
<code>connect</code>. Fired upon a successful connection.
<code>connect_error</code>. Fired upon a connection error.
Parameters:
<code>Object</code> error object
<code>connect_timeout</code>. Fired upon a connection timeout.
<code>reconnect</code>. Fired upon a successful reconnection.
Parameters:
<code>Number</code> reconnection attempt number
<code>reconnect_attempt</code>. Fired upon an attempt to reconnect.
<code>reconnecting</code>. Fired upon an attempt to reconnect.
Parameters:
<code>Number</code> reconnection attempt number
<code>reconnect_error</code>. Fired upon a reconnection attempt error.
Parameters:
<code>Object</code> error object
<code>reconnect_failed</code>. Fired when couldn’t reconnect within <code>reconnectionAttempts</code>
<h4>Client-side events for <code>socket</code> object:</h4>
<a href="https://socket.io/docs/client-api/#socket-disconnect">Client-side events for <code>socket</code> object:</a>
<code>connect</code>. Fired upon connecting.
<code>error</code>. Fired upon a connection error
Parameters:
<code>Object</code> error data
<code>disconnect</code>. Fired upon a disconnection.
<code>reconnect</code>. Fired upon a successful reconnection.
Parameters:
<code>Number</code> reconnection attempt number
<code>reconnect_attempt</code>. Fired upon an attempt to reconnect.
<code>reconnecting</code>. Fired upon an attempt to reconnect.
Parameters:
<code>Number</code> reconnection attempt number
<code>reconnect_error</code>. Fired upon a reconnection attempt error.
Parameters:
<code>Object</code> error object
<code>reconnect_failed</code>. Fired when couldn’t reconnect within <code>reconnectionAttempts</code>
<h4>Server-side events:</h4>
<a href="http://socket.io/docs/server-api/#namespace">Server-side events:</a>
<code>connection</code> / <code>connect</code>. Fired upon a connection.
Parameters:
<code>Socket</code> the incoming socket.
<h4>Edit:</h4>
For the current version (<code>1.3.4</code>) the <code>reconnect_attempt</code> and <code>reconnecting</code>
 client-side events are synonyms.










<script src='https://williamkpchan.github.io/LibDocs/readbook.js'></script>
<script>
var lazyLoadInstance = new LazyLoad({
    elements_selector: ".lazy"
    // ... more custom settings?
});
</script>
</pre></body></html>