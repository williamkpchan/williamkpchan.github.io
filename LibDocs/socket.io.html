<base target="_blank"><html><head><title>Socket.IO</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src="https://williamkpchan.github.io/lazyload.min.js"></script>
<script src='https://williamkpchan.github.io/mainscript.js'></script>
<script src="https://williamkpchan.github.io/commonfunctions.js"></script>
<script>
  var showTopicNumber = true;
  var bookid = "Socket.IO"
  var markerName = "h2"
</script>
<style>
body{width:80%;margin-left: 10%; font-size:24px;}
h1, h2 {color: gold;}
strong {color: orange;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px;}
</style></head><body onkeypress="chkKey()"><center>
<h1>Socket.IO</h1>
<a href="#mustWatch" class="red goldbs" target="_self">Must Watch!</a><br><br>
<div id="toc"></div></center><br><br>
<div id="mustWatch"><center><span class="red">MustWatch</span></center><br></div>
<pre><br><br>

<h2><span class="orange">Socket.IO - Overview</span></h2>

Socket.IO is a JavaScript library for <b>real-time web applications</b>. 
It enables real-time, bi-directional communication between web clients and servers. 
It has two parts: a <b>client-side library</b> that runs in the browser, and a <b>server-side library</b> for node.js. 
Both components have an identical API.

<h2>Real-time applications</h2>
A real-time application (RTA) is an application that functions within a period that the user senses as immediate or current.

Some examples of real-time applications are -
<b>Instant messengers</b> - Chat apps like Whatsapp, Facebook Messenger, etc. 
You need not refresh your app/website to receive new messages.

<b>Push Notifications</b> - When someone tags you in a picture on Facebook, you receive a notification instantly.

<b>Collaboration Applications</b> - Apps like google docs, which allow multiple people to update same documents simultaneously and apply changes to all people's instances.

<b>Online Gaming</b> - Games like Counter Strike, Call of Duty, etc., are also some examples of real-time applications.

<h2>Why Socket.IO?</h2>
Writing a real-time application with popular web applications stacks like LAMP (PHP) has traditionally been very hard. 
It involves polling the server for changes, keeping track of timestamps, and it is a lot slower than it should be.

Sockets have traditionally been the solution around which most real-time systems are architected, providing a bi-directional communication channel between a client and a server. 
This means that the server can push messages to clients. 
Whenever an event occurs, the idea is that the server will get it and push it to the concerned connected clients.

Socket.IO is quite popular, it is used by <b>Microsoft Office, Yammer, Zendesk, Trello</b>, and numerous other organizations to build robust real-time systems. 
It one of the most powerful <b>JavaScript frameworks</b> on <b>GitHub</b>, and most depended-upon NPM (Node Package Manager) module. 
Socket.IO also has a huge community, which means finding help is quite easy.

<h2>ExpressJS</h2>
We will be using express to build the web server that Socket.IO will work with. 
Any other node-server-side framework or even node HTTP server can be used. 
However, ExpressJS makes it easy to define routes and other things. 
To read more about express and get a basic idea about it, head to <a href="/expressjs/index.htm">ExpressJS tutorial</a>.

<h2><span class="orange">Socket.IO - Environment</span></h2>

To get started with developing using the <b>Socket.IO</b>, you need to have <b>Node</b> and <b>npm (node package manager)</b> installed. 
If you do not have these, head over to <b>Node setup</b> to install node on your local system. 
Confirm that node and npm are installed by running the following commands in your terminal.

node --version
npm --version

You should get an output similar to -
v5.0.0 3.5.2

Open your terminal and enter the following in your terminal to create a new folder and enter the following commands -

$ mkdir test-project
$ cd test-proect
$ npm init

It will ask you some questions; answer them in the following way -

<img src="https://www.tutorialspoint.com/socket.io/images/environment_setup.jpg">
This will create a <b>‘package.json node.js’</b> configuration file. 
Now we need to install <b>Express</b> and <b>Socket.IO</b>. 
To install these and save them to <b>package.json</b> file, enter the following command in your terminal, into the project directory.

npm install --save express socket.io

One final thing is that we should keep restarting the server. 
When we make changes, we will need a tool called nodemon. 
To install <b>nodemon</b>, open your terminal and enter the following command -

npm install -g nodemon

Whenever you need to start the server, instead of using the <b>node app.js</b> use, <b>nodemon app.js</b>. 
This will ensure that you do not need to restart the server whenever you change a file. 
It speeds up the development process.

Now, we have our development environment set up. 
Let us now get started with developing real-time applications with Socket.IO.

<h2><span class="orange">Socket.IO - Hello World</span></h2>

Create a file called <b>app.js</b> and enter the following code to set up an express application -

var app = require('express')();
var http = require('http').Server(app);

app.get('/', function(req, res) {
   res.sendfile('index.html');
});

http.listen(3000, function() {
   console.log('listening on *:3000');
});

We will need an <b>index.html</b> file to serve, create a new file called index.html and enter the following code in it -

&lt;!DOCTYPE html>
&lt;html>
   &lt;head>
      &lt;title>Hello world&lt;/title>
   &lt;/head>
   &lt;body>Hello world&lt;/body>
&lt;/html>

To test if this works, go to the terminal and run this app using the following command -

nodemon app.js

This will run the server on localhost:3000. 
Go to the browser and enter localhost:3000 to check this.

This sets up our express application and is now serving a HTML file on the root route. 
Now we will require Socket.IO and will log "A user connected", every time a user goes to this page and "A user disconnected", every time someone navigates away/closes this page.

var app = require('express')();
var http = require('http').Server(app);
var io = require('socket.io')(http);

app.get('/', function(req, res) {
   res.sendfile('index.html');
});

//Whenever someone connects this gets executed
io.on('connection', function(socket) {
   console.log('A user connected');

   //Whenever someone disconnects this piece of code executed
   socket.on('disconnect', function () {
      console.log('A user disconnected');
   });
});

http.listen(3000, function() {
   console.log('listening on *:3000');
});

The require('socket.io')(http) creates a new socket.io instance attached to the http server. 
The <b>io.on event handler</b> handles connection, disconnection, etc., events in it, using the socket object.

We have set up our server to log messages on connections and disconnections. 
We now have to include the client script and initialize the socket object there, so that clients can establish connections when required. 
The script is served by our <b>io server</b> at <b>'/socket.io/socket.io.js'</b>.

After completing the above procedure, the index.html file will look as follows -

&lt;!DOCTYPE html>
&lt;html>
   &lt;head>
      &lt;title>Hello world&lt;/title>
   &lt;/head>
   &lt;script src = "/socket.io/socket.io.js">&lt;/script>
   
   &lt;script>
      var socket = io();
   &lt;/script>
   &lt;body>Hello world&lt;/body>
&lt;/html>

If you go to localhost:3000 now (make sure your server is running), you will get <b>Hello World</b> printed in your browser. 
Now check your server console logs, it will show the following message -

A user connected

If you refresh your browser, it will disconnect the socket connection and recreate. 
You can see the following on your console logs -

A user connected
A user disconnected
A user connected

We now have socket connections working. 
This is how easy it is to set up connections in Socket.IO.

<h2><span class="orange">Socket.IO - Event Handling</span></h2>

Sockets work based on events. 
There are some reserved events, which can be accessed using the socket object on the server side.

These are -

Connect
Message
Disconnect
Reconnect
Ping
Join and
Leave

The client-side socket object also provides us with some reserved events, which are -

Connect
Connect_error
Connect_timeout
Reconnect, etc

In the Hello World example, we used the connection and disconnection events to log when a user connected and left. 
Now we will be using the message event to pass message from the server to the client. 
To do this, modify the <b>io.on</b> ('connection', function(socket)) call to include the following -

var app = require('express')();
var http = require('http').Server(app);
var io = require('socket.io')(http);

app.get('/', function(req, res) {
   res.sendfile('index.html');
});

io.on('connection', function(socket) {
   console.log('A user connected');

   //Send a message after a timeout of 4seconds
   setTimeout(function() {
      socket.send('Sent a message 4seconds after connection!');
   }, 4000);

   socket.on('disconnect', function () {
      console.log('A user disconnected');
   });
});

http.listen(3000, function() {
   console.log('listening on *:3000');
});

This will send an event called <b>message(built in)</b> to our client, four seconds after the client connects. 
The send function on socket object associates the 'message' event.

Now, we need to handle this event on our client side. 
So, edit your index.html script tag to include the following code -

&lt;script>
   var socket = io();
   socket.on('message', function(data){document.write(data)});
&lt;/script>

We are now handling the 'message' event on the client. 
When you go to the page in your browser now, you will be presented with the following screenshot.

<img src="https://www.tutorialspoint.com/socket.io/images/events_before.jpg" />
After 4 seconds pass and the server sends the message event, our client will handle it and produce the following output -

<img src="https://www.tutorialspoint.com/socket.io//images/events_after.jpg" />
<b>Note</b> - We sent a string of text here; we can also send an object in any event.

Message was a built-in event provided by the API, but is of not much use in a real application, as we need to be able to differentiate between events.

To allow this, Socket.IO provides us the ability to create <b>custom events</b>. 
You can create and fire custom events using the <b>socket.emit</b> function.

For example, the following code emits an event called <b>testerEvent</b> -

var app = require('express')();
var http = require('http').Server(app);
var io = require('socket.io')(http);

app.get('/', function(req, res) {
   res.sendfile('index.html');
});

io.on('connection', function(socket) {
   console.log('A user connected');

   //Send a message when 
   setTimeout(function() {
      //Sending an object when emmiting an event
      socket.emit('testerEvent', { description: 'A custom event named testerEvent!'});
   }, 4000);

   socket.on('disconnect', function () {
      console.log('A user disconnected');
   });
});

http.listen(3000, function() {
   console.log('listening on localhost:3000');
});

To handle this custom event on client we need a listener that listens for the event testerEvent. 
The following code handles this event on the client -

&lt;!DOCTYPE html>
&lt;html>
   &lt;head>
      &lt;title>Hello world&lt;/title>
   &lt;/head>
   &lt;script src = "/socket.io/socket.io.js">&lt;/script>
   
   &lt;script>
      var socket = io();
      socket.on('testerEvent', function(data){document.write(data.description)});
   &lt;/script>
   &lt;body>Hello world&lt;/body>
&lt;/html>

This will work in the same way as our previous example, with the event being testerEvent in this case. 
When you open your browser and go to localhost:3000, you'll be greeted with -

Hello world

After four seconds, this event will be fired and the browser will have the text changed to -

A custom event named testerEvent!

We can also emit events from the client. 
To emit an event from your client, use the emit function on the socket object.

&lt;!DOCTYPE html>
&lt;html>
   &lt;head>
      &lt;title>Hello world&lt;/title>
   &lt;/head>
   &lt;script src = "/socket.io/socket.io.js">&lt;/script>
   
   &lt;script>
      var socket = io();
      socket.emit('clientEvent', 'Sent an event from the client!');
   &lt;/script>
   &lt;body>Hello world&lt;/body>
&lt;/html>

To handle these events, use the <b>on function</b> on the socket object on your server.

var app = require('express')();
var http = require('http').Server(app);
var io = require('socket.io')(http);

app.get('/', function(req, res) {
   res.sendfile('index.html');
});

io.on('connection', function(socket) {
   socket.on('clientEvent', function(data) {
      console.log(data);
   });
});

http.listen(3000, function() {
   console.log('listening on localhost:3000');
});

So, now if we go to localhost:3000, we will get a custom event called <b>clientEvent</b> fired. 
This event will be handled on the server by logging -

Sent an event from the client!

<h2><span class="orange">Socket.IO - Broadcasting</span></h2>

Broadcasting means sending a message to all connected clients. 
Broadcasting can be done at multiple levels. 
We can send the message to all the connected clients, to clients on a namespace and clients in a particular room. 
To broadcast an event to all the clients, we can use the <b>io.sockets.emit</b> method.

<b>Note</b> - This will emit the event to <b>ALL</b> the connected clients (event the socket that might have fired this event).

In this example, we will broadcast the number of connected clients to all the users. 
Update the <b>app.js</b> file to incorporate the following.

var app = require('express')();
var http = require('http').Server(app);
var io = require('socket.io')(http);

app.get('/', function(req, res) {
   res.sendfile('index.html');
});

var clients = 0;
io.on('connection', function(socket) {
   clients++;
   io.sockets.emit('broadcast',{ description: clients + ' clients connected!'});
   socket.on('disconnect', function () {
      clients--;
      io.sockets.emit('broadcast',{ description: clients + ' clients connected!'});
   });
});

http.listen(3000, function() {
   console.log('listening on localhost:3000');
});

On the client side, we just need to handle the broadcast event -

&lt;!DOCTYPE html>
&lt;html>
   &lt;head>
      &lt;title>Hello world&lt;/title>
   &lt;/head>
   &lt;script src = "/socket.io/socket.io.js">&lt;/script>
   &lt;script>
      var socket = io();
      socket.on('broadcast',function(data) {
         document.body.innerHTML = '';
         document.write(data.description);
      });
   &lt;/script>
   &lt;body>Hello world&lt;/body>
&lt;/html>

If you connect four clients, you will get the following result -

<img src="https://www.tutorialspoint.com/socket.io/images/broadcast_to_all.jpg" />
This was to send an event to everyone. 
Now, if we want to send an event to everyone, but the client that caused it (in the previous example, it was caused by new clients on connecting), we can use the <b>socket.broadcast.emit</b>.

Let us send the new user a welcome message and update the other clients about him/her joining. 
So in your app.js file, on connection of client send him a welcome message and broadcast connected client number to all others.

var app = require('express')();
var http = require('http').Server(app);
var io = require('socket.io')(http);

app.get('/', function(req, res) {
   res.sendfile('index.html');
});

var clients = 0;
io.on('connection', function(socket) {
   clients++;
   socket.emit('newclientconnect',{ description: 'Hey, welcome!'});
   socket.broadcast.emit('newclientconnect',{ description: clients + ' clients connected!'})
   socket.on('disconnect', function () {
      clients--;
      socket.broadcast.emit('newclientconnect',{ description: clients + ' clients connected!'})
   });
});

http.listen(3000, function() {
   console.log('listening on localhost:3000');
});

And your html to handle this event -

&lt;!DOCTYPE html>
&lt;html>
   &lt;head>
      &lt;title>Hello world&lt;/title>
   &lt;/head>
   &lt;script src = "/socket.io/socket.io.js">&lt;/script>
   &lt;script>
      var socket = io();
      socket.on('newclientconnect',function(data) {
         document.body.innerHTML = '';
         document.write(data.description);
      });
   &lt;/script>
   &lt;body>Hello world&lt;/body>
&lt;/html>

Now, the newest client gets a welcome message and others get how many clients are connected currently to the server.

<h2><span class="orange">Socket.IO - Namespaces</span></h2>

Socket.IO allows you to “namespace” your sockets, which essentially means assigning different endpoints or paths. 
This is a useful feature to minimize the number of resources (TCP connections) and at the same time separate concerns within your application by introducing separation between communication channels. 
Multiple namespaces actually share the same WebSockets connection thus saving us socket ports on the server.

Namespaces are created on the server side. 
However, they are joined by clients by sending a request to the server.

<h2>Default Namespaces</h2>
The root namespace '/' is the default namespace, which is joined by clients if a namespace is not specified by the client while connecting to the server. 
All connections to the server using the socket-object client side are made to the default namespace. 
For example -

var socket = io();

This will connect the client to the default namespace. 
All events on this namespace connection will be handled by the <b>io object</b> on the server. 
All the previous examples were utilizing default namespaces to communicate with the server and back.

<h2>Custom Namespaces</h2>
We can create our own custom namespaces. 
To set up a custom namespace, we can call the ‘of’ function on the server side -

var app = require('express')();
var http = require('http').Server(app);
var io = require('socket.io')(http);

app.get('/', function(req, res) {
   res.sendfile('index.html');
});

var nsp = io.of('/my-namespace');
nsp.on('connection', function(socket) {
   console.log('someone connected');
   nsp.emit('hi', 'Hello everyone!');
});

http.listen(3000, function() {
   console.log('listening on localhost:3000');
});

Now, to connect a client to this namespace, you need to provide the namespace as an argument to the <b>io constructor call</b> to create a connection and a socket object on client side.

For example, to connect to the above namespace, use the following HTML -

&lt;!DOCTYPE html>
&lt;html>
   &lt;head>
      &lt;title>Hello world&lt;/title>
   &lt;/head>
   &lt;script src = "/socket.io/socket.io.js">&lt;/script>
   
   &lt;script>
      var socket = io('/my-namespace');
      socket.on('hi',function(data) {
         document.body.innerHTML = '';
         document.write(data);
      });
   &lt;/script>
   &lt;body>&lt;/body>
&lt;/html>

Every time someone connects to this namespace, they will receive a ‘hi’ event.

<h2><span class="orange">Socket.IO - Rooms</span></h2>

Within each namespace, you can also define arbitrary channels that sockets can join and leave. 
These channels are called rooms. 
Rooms are used to further-separate concerns. 
Rooms also share the same socket connection like namespaces. 
One thing to keep in mind while using rooms is that they can only be joined on the server side.

<h2>Joining Rooms</h2>
You can call the <b>join</b> method on the socket to subscribe the socket to a given channel/room. 
For example, let us create rooms called <b>'room-&lt;room-number>'</b> and join some clients. 
As soon as this room is full, create another room and join clients there.

<b>Note</b> - We are currently doing this on the default namespace, i.e. 
'/'. 
You can also implement this in custom namespaces in the same fashion.

To join a room you need to provide the room name as the argument to your join function call.

var app = require('express')();
var http = require('http').Server(app);
var io = require('socket.io')(http);

app.get('/', function(req, res) {
   res.sendfile('index.html');
});

var roomno = 1;
io.on('connection', function(socket) {
   
   //Increase roomno 2 clients are present in a room.
   if(io.nsps['/'].adapter.rooms["room-"+roomno] &amp;&amp; io.nsps['/'].adapter.rooms["room-"+roomno].length > 1) roomno++;
   socket.join("room-"+roomno);

   //Send this event to everyone in the room.
   io.sockets.in("room-"+roomno).emit('connectToRoom', "You are in room no. 
"+roomno);
})

http.listen(3000, function() {
   console.log('listening on localhost:3000');
});

Just handle this <b>connectToRoom</b> event on the client. 


&lt;!DOCTYPE html>
&lt;html>
   &lt;head>
      &lt;title>Hello world&lt;/title>
   &lt;/head>
   &lt;script src = "/socket.io/socket.io.js">&lt;/script>
   
   &lt;script>
      var socket = io();
      socket.on('connectToRoom',function(data) {
         document.body.innerHTML = '';
         document.write(data);
      });
   &lt;/script>
   &lt;body>&lt;/body>
&lt;/html>

Now if you connect three clients, the first two will get the following message -

You are in room no. 1

The last client will get the following message -

You are in room no. 2

 
<img src="https://www.tutorialspoint.com/socket.io/images/rooms.jpg" />
<h2>Leaving a room</h2>
To leave a room, you need to call the leave function just as you called the join function on the socket.

For example - To leave room <b>'room-1'</b>,

socket.leave("room-"+roomno);

<h2><span class="orange">Socket.IO - Error Handling</span></h2>

We have worked on local servers until now, which will almost never give us errors related to connections, timeouts, etc. 
However, in real life production environments, handling such errors are of utmost importance. 
Therefore, we will now discuss how we can handle connection errors on the client side.

The client API provides us with following built in events -

<b>Connect</b> - When the client successfully connects.

<b>Connecting</b> - When the client is in the process of connecting.

<b>Disconnect</b> - When the client is disconnected.

<b>Connect_failed</b> - When the connection to the server fails.

<b>Error</b> - An error event is sent from the server.

<b>Message</b> - When the server sends a message using the <b>send</b> function.

<b>Reconnect</b> - When reconnection to the server is successful.

<b>Reconnecting</b> - When the client is in the process of connecting.

<b>Reconnect_failed</b> - When the reconnection attempt fails.

To handle errors, we can handle these events using the out-socket object that we created on our client.

For example - If we have a connection that fails, we can use the following code to connect to the server again -

socket.on('connect_failed', function() {
   document.write("Sorry, there seems to be an issue with the connection!");
})

<h2><span class="orange">Socket.IO - Logging and Debugging</span></h2>

Socket.IO uses a very famous debugging module developed by ExpresJS's main author, called <b>debug</b>. 
Earlier Socket.IO used to log everything to the console making it quite difficult to debug the problem. 
After the v1.0 release, you can specify what you want to log.

<h2>Server-side</h2>
The best way to see what information is available is to use the * -

DEBUG=* node app.js

This will colorize and output everything that happens to your server console. 
For example, we can consider the following screenshot.

<img src="https://www.tutorialspoint.com/socket.io/images/logging_example.jpg" />
<h2>Client-side</h2>
Paste this to console, click enter and refresh your page. 
This will again output everything related to Socket.io to your console.

localStorage.debug = '*';

You can limit the output to get the debug info with incoming data from the socket using the following command.

localStorage.debug = 'socket.io-client:socket';

You can see the result like the following screenshot, if you use the second statement to log the info -

<img src="https://www.tutorialspoint.com/socket.io/images/client_logging.jpg" />
There is a very good blog post related to socket.io debugging <a target="_blank" href="https://www.rethinkdb.com/blog/websocket-debugging/">here.</a>

<h2><span class="orange">Socket.IO - Internals</span></h2>

In this chapter, we will discuss regarding Fallbacks, Connection using Socket.IO, Events and Messages.

<h2>Fallbacks</h2>
Socket.IO has a lot of underlying transport mechanisms, which deal with various constraints arising due to cross browser issues, WebSocket implementations, firewalls, port blocking, etc.

Though W3C has a defined specification for WebSocket API, it is still lacking in implementation. 
Socket.IO provides us with fallback mechanisms, which can deal with such issues. 
If we develop apps using the native API, we have to implement the fallbacks ourselves. 
Socket.IO covers a large list of fallbacks in the following order -

WebSockets
FlashSocket
XHR long polling
XHR multipart streaming
XHR polling
JSONP polling
iframes

<h2>Connection using Socket.IO</h2>
The Socket.IO connection begins with the handshake. 
This makes the handshake a special part of the protocol. 
Apart from the handshake, all the other events and messages in the protocol are transferred over the socket.

Socket.IO is intended for use with web applications, and therefore it is assumed that these applications will always be able to use HTTP. 
It is because of this reasoning that the Socket.IO handshake takes place over HTTP using a POST request on the handshake URI (passed to the connect method).

<h2>Events and messages</h2>
WebSocket native API only sends messages across. 
Socket.IO provides an addition layer over these messages, which allows us to create events and again helps us develop apps easily by separating the different types of messages sent.

The native API sends messages only in plain text. 
This is also taken care of by Socket.IO. 
It handles the serialization and deserialization of data for us.

We have an official client API for the web. 
For other clients such as native mobile phones, other application clients also we can use Socket.IO using the following steps.

<b>Step 1</b> - A connection needs to be established using the same connection protocol discussed above.

<b>Step 2</b> - The messages need to be in the same format as specified by Socket.IO. 
This format enables Socket.IO to determine the type of the message and the data sent in the message and some metadata useful for operation.

The message format is -

[type] : [id ('+')] : [endpoint] (: [data]

The parameters in the above command are explained below -

<b>Type</b> is a single digit integer, specifying what type message it is.

<b>ID</b> is message ID, an incremental integer used for acknowledgements.

<b>Endpoint</b> is the socket endpoint that the message is intended to be delivered to...

<b>Data</b> is the associated data to be delivered to the socket. 
In case of messages, it is treated as plain text, for other events, it is treated as JSON.

In the next chapter, we will write a chat application in Socket.IO.

<h2><span class="orange">Socket.IO - Chat Application</span></h2>

Now that we are well acquainted with Socket.IO, let us write a chat application, which we can use to chat on different chat rooms. 
We will allow users to choose a username and allow them to chat using them. 
So first, let us set up our HTML file to request for a username -

&lt;!DOCTYPE html>
&lt;html>
   &lt;head>
      &lt;title>Hello world&lt;/title>
   &lt;/head>
   &lt;script src = "/socket.io/socket.io.js">&lt;/script>
   
   &lt;script>
      var socket = io();
   &lt;/script>
   &lt;body>
      &lt;input type = "text" name = "name" value = "" placeholder = "Enter your name!">
      &lt;button type = "button" name = "button">Let me chat!&lt;/button>
   &lt;/body>
&lt;/html>
Now that we have set up our HTML to request for a username, let us create the server to accept connections from the client. 
We will allow people to send their chosen usernames using the <b>setUsername</b> event. 
If a user exists, we will respond by a <b>userExists</b> event, else using a <b>userSet</b> event.

var app = require('express')();
var http = require('http').Server(app);
var io = require('socket.io')(http);

app.get('/', function(req, res) {
   res.sendfile('index.html');
});

users = [];
io.on('connection', function(socket) {
   console.log('A user connected');
   socket.on('setUsername', function(data) {
      if(users.indexOf(data) > -1) {
         users.push(data);
         socket.emit('userSet', {username: data});
      } else {
         socket.emit('userExists', data + ' username is taken! Try some other username.');
      }
   })
});

http.listen(3000, function() {
   console.log('listening on localhost:3000');
});

We need to send the username to the server when people click on the button. 
If user exists, we show an error message; else, we show a messaging screen - 

&lt;!DOCTYPE html>
&lt;html>
   &lt;head>
      &lt;title>Hello world&lt;/title>
   &lt;/head>
   
   &lt;script src = "/socket.io/socket.io.js">&lt;/script>
   &lt;script>
      var socket = io();
      function setUsername() {
         socket.emit('setUsername', document.getElementById('name').value);
      };
      var user;
      socket.on('userExists', function(data) {
         document.getElementById('error-container').innerHTML = data;
      });
      socket.on('userSet', function(data) {
         user = data.username;
         document.body.innerHTML = '&lt;input type = "text" id = "message">\
         &lt;button type = "button" name = "button" onclick = "sendMessage()">Send&lt;/button>\
         &lt;div id = "message-container">&lt;/div>';
      });
      function sendMessage() {
         var msg = document.getElementById('message').value;
         if(msg) {
            socket.emit('msg', {message: msg, user: user});
         }
      }
      socket.on('newmsg', function(data) {
         if(user) {
            document.getElementById('message-container').innerHTML += '&lt;div>&lt;b>' + 
               data.user + '&lt;/b>: ' + data.message + '&lt;/div>'
         }
      })
   &lt;/script>
   
   &lt;body>
      &lt;div id = "error-container">&lt;/div>
      &lt;input id = "name" type = "text" name = "name" value = "" 
         placeholder = "Enter your name!">
      &lt;button type = "button" name = "button" onclick = "setUsername()">
         Let me chat!
      &lt;/button>
   &lt;/body>
&lt;/html>

Now if you connect two clients with same username, it will give you an error as shown in the screenshot below -

<img src="https://www.tutorialspoint.com/socket.io/images/chat_name_taken.jpg" />
Once you have provided an acceptable username, you will be taken to a screen with a message box and a button to send messages. 
Now, we have to handle and direct the messages to the connected client. 
For that, modify your app.js file to include the following changes -

var app = require('express')();
var http = require('http').Server(app);
var io = require('socket.io')(http);

app.get('/', function(req, res) {
   res.sendfile('index.html');
});

users = [];
io.on('connection', function(socket) {
   console.log('A user connected');
   socket.on('setUsername', function(data) {
      console.log(data);
      
      if(users.indexOf(data) > -1) {
         socket.emit('userExists', data + ' username is taken! Try some other username.');
      } else {
         users.push(data);
         socket.emit('userSet', {username: data});
      }
   });
   
   socket.on('msg', function(data) {
      //Send message to everyone
      io.sockets.emit('newmsg', data);
   })
});

http.listen(3000, function() {
   console.log('listening on localhost:3000');
});

Now connect any number of clients to your server, provide them a username and start chatting! In the following example, we have connected two clients with names Ayush and Harshit and sent some messages from both the clients -

<img src="https://www.tutorialspoint.com/socket.io/images/chat_example.jpg" />

<h2><span class="orange">Socket.IO - Overview</span></h2>
Socket.IO is a JavaScript library for <b>real-time web applications</b>. 
It enables real-time, bi-directional communication between web clients and servers. 
It has two parts: a <b>client-side library</b> that runs in the browser, and a <b>server-side library</b> for node.js. 
Both components have an identical API.

<h2>Real-time applications</h2>
A real-time application (RTA) is an application that functions within a period that the user senses as immediate or current.

Some examples of real-time applications are -

<b>Instant messengers</b> - Chat apps like Whatsapp, Facebook Messenger, etc. 
You need not refresh your app/website to receive new messages.

<b>Push Notifications</b> - When someone tags you in a picture on Facebook, you receive a notification instantly.

<b>Collaboration Applications</b> - Apps like google docs, which allow multiple people to update same documents simultaneously and apply changes to all people's instances.

<b>Online Gaming</b> - Games like Counter Strike, Call of Duty, etc., are also some examples of real-time applications.

<h2>Why Socket.IO?</h2>
Writing a real-time application with popular web applications stacks like LAMP (PHP) has traditionally been very hard. 
It involves polling the server for changes, keeping track of timestamps, and it is a lot slower than it should be.

Sockets have traditionally been the solution around which most real-time systems are architected, providing a bi-directional communication channel between a client and a server. 
This means that the server can push messages to clients. 
Whenever an event occurs, the idea is that the server will get it and push it to the concerned connected clients.

Socket.IO is quite popular, it is used by <b>Microsoft Office, Yammer, Zendesk, Trello</b>, and numerous other organizations to build robust real-time systems. 
It one of the most powerful <b>JavaScript frameworks</b> on <b>GitHub</b>, and most depended-upon NPM (Node Package Manager) module. 
Socket.IO also has a huge community, which means finding help is quite easy.

<h2>ExpressJS</h2>
We will be using express to build the web server that Socket.IO will work with. 
Any other node-server-side framework or even node HTTP server can be used. 
However, ExpressJS makes it easy to define routes and other things. 
To read more about express and get a basic idea about it, head to <a href="/expressjs/index.htm">ExpressJS tutorial</a>.

<h2><span class="orange">Socket.IO - Environment</span></h2>
To get started with developing using the <b>Socket.IO</b>, you need to have <b>Node</b> and <b>npm (node package manager)</b> installed. 
If you do not have these, head over to <b>Node setup</b> to install node on your local system. 
Confirm that node and npm are installed by running the following commands in your terminal.

node --version
npm --version

You should get an output similar to -

v5.0.0
3.5.2

Open your terminal and enter the following in your terminal to create a new folder and enter the following commands -

$ mkdir test-project
$ cd test-proect
$ npm init

It will ask you some questions; answer them in the following way -

<img src="https://www.tutorialspoint.com/socket.io/images/environment_setup.jpg" />
This will create a <b>‘package.json node.js’</b> configuration file. 
Now we need to install <b>Express</b> and <b>Socket.IO</b>. 
To install these and save them to <b>package.json</b> file, enter the following command in your terminal, into the project directory.

npm install --save express socket.io

One final thing is that we should keep restarting the server. 
When we make changes, we will need a tool called nodemon. 
To install <b>nodemon</b>, open your terminal and enter the following command -

npm install -g nodemon

Whenever you need to start the server, instead of using the <b>node app.js</b> use, <b>nodemon app.js</b>. 
This will ensure that you do not need to restart the server whenever you change a file. 
It speeds up the development process.

Now, we have our development environment set up. 
Let us now get started with developing real-time applications with Socket.IO.

<h2><span class="orange">Socket.IO - Hello World</span></h2>
Create a file called <b>app.js</b> and enter the following code to set up an express application -

var app = require('express')();
var http = require('http').Server(app);

app.get('/', function(req, res) {
   res.sendfile('index.html');
});

http.listen(3000, function() {
   console.log('listening on *:3000');
});

We will need an <b>index.html</b> file to serve, create a new file called index.html and enter the following code in it -

&lt;!DOCTYPE html>
&lt;html>
   &lt;head>
      &lt;title>Hello world&lt;/title>
   &lt;/head>
   &lt;body>Hello world&lt;/body>
&lt;/html>

To test if this works, go to the terminal and run this app using the following command -

nodemon app.js

This will run the server on localhost:3000. 
Go to the browser and enter localhost:3000 to check this.

This sets up our express application and is now serving a HTML file on the root route. 
Now we will require Socket.IO and will log "A user connected", every time a user goes to this page and "A user disconnected", every time someone navigates away/closes this page.

var app = require('express')();
var http = require('http').Server(app);
var io = require('socket.io')(http);

app.get('/', function(req, res) {
   res.sendfile('index.html');
});

//Whenever someone connects this gets executed
io.on('connection', function(socket) {
   console.log('A user connected');

   //Whenever someone disconnects this piece of code executed
   socket.on('disconnect', function () {
      console.log('A user disconnected');
   });
});

http.listen(3000, function() {
   console.log('listening on *:3000');
});

The require('socket.io')(http) creates a new socket.io instance attached to the http server. 
The <b>io.on event handler</b> handles connection, disconnection, etc., events in it, using the socket object.

We have set up our server to log messages on connections and disconnections. 
We now have to include the client script and initialize the socket object there, so that clients can establish connections when required. 
The script is served by our <b>io server</b> at <b>'/socket.io/socket.io.js'</b>.

After completing the above procedure, the index.html file will look as follows -

&lt;!DOCTYPE html>
&lt;html>
   &lt;head>
      &lt;title>Hello world&lt;/title>
   &lt;/head>
   &lt;script src = "/socket.io/socket.io.js">&lt;/script>
   
   &lt;script>
      var socket = io();
   &lt;/script>
   &lt;body>Hello world&lt;/body>
&lt;/html>

If you go to localhost:3000 now (make sure your server is running), you will get <b>Hello World</b> printed in your browser. 
Now check your server console logs, it will show the following message -

A user connected

If you refresh your browser, it will disconnect the socket connection and recreate. 
You can see the following on your console logs -

A user connected
A user disconnected
A user connected

We now have socket connections working. 
This is how easy it is to set up connections in Socket.IO.

<h2><span class="orange">Socket.IO - Event Handling</span></h2>
Sockets work based on events. 
There are some reserved events, which can be accessed using the socket object on the server side.

These are -

Connect
Message
Disconnect
Reconnect
Ping
Join and
Leave

The client-side socket object also provides us with some reserved events, which are -

Connect
Connect_error
Connect_timeout
Reconnect, etc

In the Hello World example, we used the connection and disconnection events to log when a user connected and left. 
Now we will be using the message event to pass message from the server to the client. 
To do this, modify the <b>io.on</b> ('connection', function(socket)) call to include the following -

var app = require('express')();
var http = require('http').Server(app);
var io = require('socket.io')(http);

app.get('/', function(req, res) {
   res.sendfile('index.html');
});

io.on('connection', function(socket) {
   console.log('A user connected');

   //Send a message after a timeout of 4seconds
   setTimeout(function() {
      socket.send('Sent a message 4seconds after connection!');
   }, 4000);

   socket.on('disconnect', function () {
      console.log('A user disconnected');
   });
});

http.listen(3000, function() {
   console.log('listening on *:3000');
});

This will send an event called <b>message(built in)</b> to our client, four seconds after the client connects. 
The send function on socket object associates the 'message' event.

Now, we need to handle this event on our client side. 
So, edit your index.html script tag to include the following code -

&lt;script>
   var socket = io();
   socket.on('message', function(data){document.write(data)});
&lt;/script>

We are now handling the 'message' event on the client. 
When you go to the page in your browser now, you will be presented with the following screenshot.

<img src="https://www.tutorialspoint.com/socket.io/images/events_before.jpg" />
After 4 seconds pass and the server sends the message event, our client will handle it and produce the following output -

<img src="https://www.tutorialspoint.com/socket.io//images/events_after.jpg" />
<b>Note</b> - We sent a string of text here; we can also send an object in any event.

Message was a built-in event provided by the API, but is of not much use in a real application, as we need to be able to differentiate between events.

To allow this, Socket.IO provides us the ability to create <b>custom events</b>. 
You can create and fire custom events using the <b>socket.emit</b> function.

For example, the following code emits an event called <b>testerEvent</b> -

var app = require('express')();
var http = require('http').Server(app);
var io = require('socket.io')(http);

app.get('/', function(req, res) {
   res.sendfile('index.html');
});

io.on('connection', function(socket) {
   console.log('A user connected');

   //Send a message when 
   setTimeout(function() {
      //Sending an object when emmiting an event
      socket.emit('testerEvent', { description: 'A custom event named testerEvent!'});
   }, 4000);

   socket.on('disconnect', function () {
      console.log('A user disconnected');
   });
});

http.listen(3000, function() {
   console.log('listening on localhost:3000');
});

To handle this custom event on client we need a listener that listens for the event testerEvent. 
The following code handles this event on the client -

&lt;!DOCTYPE html>
&lt;html>
   &lt;head>
      &lt;title>Hello world&lt;/title>
   &lt;/head>
   &lt;script src = "/socket.io/socket.io.js">&lt;/script>
   
   &lt;script>
      var socket = io();
      socket.on('testerEvent', function(data){document.write(data.description)});
   &lt;/script>
   &lt;body>Hello world&lt;/body>
&lt;/html>

This will work in the same way as our previous example, with the event being testerEvent in this case. 
When you open your browser and go to localhost:3000, you'll be greeted with -

Hello world

After four seconds, this event will be fired and the browser will have the text changed to -

A custom event named testerEvent!

We can also emit events from the client. 
To emit an event from your client, use the emit function on the socket object.

&lt;!DOCTYPE html>
&lt;html>
   &lt;head>
      &lt;title>Hello world&lt;/title>
   &lt;/head>
   &lt;script src = "/socket.io/socket.io.js">&lt;/script>
   
   &lt;script>
      var socket = io();
      socket.emit('clientEvent', 'Sent an event from the client!');
   &lt;/script>
   &lt;body>Hello world&lt;/body>
&lt;/html>

To handle these events, use the <b>on function</b> on the socket object on your server.

var app = require('express')();
var http = require('http').Server(app);
var io = require('socket.io')(http);

app.get('/', function(req, res) {
   res.sendfile('index.html');
});

io.on('connection', function(socket) {
   socket.on('clientEvent', function(data) {
      console.log(data);
   });
});

http.listen(3000, function() {
   console.log('listening on localhost:3000');
});

So, now if we go to localhost:3000, we will get a custom event called <b>clientEvent</b> fired. 
This event will be handled on the server by logging -

Sent an event from the client!

<h2><span class="orange">Socket.IO - Broadcasting</span></h2>
Broadcasting means sending a message to all connected clients. 
Broadcasting can be done at multiple levels. 
We can send the message to all the connected clients, to clients on a namespace and clients in a particular room. 
To broadcast an event to all the clients, we can use the <b>io.sockets.emit</b> method.

<b>Note</b> - This will emit the event to <b>ALL</b> the connected clients (event the socket that might have fired this event).

In this example, we will broadcast the number of connected clients to all the users. 
Update the <b>app.js</b> file to incorporate the following.

var app = require('express')();
var http = require('http').Server(app);
var io = require('socket.io')(http);

app.get('/', function(req, res) {
   res.sendfile('index.html');
});

var clients = 0;
io.on('connection', function(socket) {
   clients++;
   io.sockets.emit('broadcast',{ description: clients + ' clients connected!'});
   socket.on('disconnect', function () {
      clients--;
      io.sockets.emit('broadcast',{ description: clients + ' clients connected!'});
   });
});

http.listen(3000, function() {
   console.log('listening on localhost:3000');
});

On the client side, we just need to handle the broadcast event -

&lt;!DOCTYPE html>
&lt;html>
   &lt;head>
      &lt;title>Hello world&lt;/title>
   &lt;/head>
   &lt;script src = "/socket.io/socket.io.js">&lt;/script>
   &lt;script>
      var socket = io();
      socket.on('broadcast',function(data) {
         document.body.innerHTML = '';
         document.write(data.description);
      });
   &lt;/script>
   &lt;body>Hello world&lt;/body>
&lt;/html>

If you connect four clients, you will get the following result -

<img src="https://www.tutorialspoint.com/socket.io/images/broadcast_to_all.jpg" />
This was to send an event to everyone. 
Now, if we want to send an event to everyone, but the client that caused it (in the previous example, it was caused by new clients on connecting), we can use the <b>socket.broadcast.emit</b>.

Let us send the new user a welcome message and update the other clients about him/her joining. 
So in your app.js file, on connection of client send him a welcome message and broadcast connected client number to all others.

var app = require('express')();
var http = require('http').Server(app);
var io = require('socket.io')(http);

app.get('/', function(req, res) {
   res.sendfile('index.html');
});

var clients = 0;
io.on('connection', function(socket) {
   clients++;
   socket.emit('newclientconnect',{ description: 'Hey, welcome!'});
   socket.broadcast.emit('newclientconnect',{ description: clients + ' clients connected!'})
   socket.on('disconnect', function () {
      clients--;
      socket.broadcast.emit('newclientconnect',{ description: clients + ' clients connected!'})
   });
});

http.listen(3000, function() {
   console.log('listening on localhost:3000');
});

And your html to handle this event -

&lt;!DOCTYPE html>
&lt;html>
   &lt;head>
      &lt;title>Hello world&lt;/title>
   &lt;/head>
   &lt;script src = "/socket.io/socket.io.js">&lt;/script>
   &lt;script>
      var socket = io();
      socket.on('newclientconnect',function(data) {
         document.body.innerHTML = '';
         document.write(data.description);
      });
   &lt;/script>
   &lt;body>Hello world&lt;/body>
&lt;/html>

Now, the newest client gets a welcome message and others get how many clients are connected currently to the server.

<h2><span class="orange">Socket.IO - Namespaces</span></h2>
Socket.IO allows you to “namespace” your sockets, which essentially means assigning different endpoints or paths. 
This is a useful feature to minimize the number of resources (TCP connections) and at the same time separate concerns within your application by introducing separation between communication channels. 
Multiple namespaces actually share the same WebSockets connection thus saving us socket ports on the server.

Namespaces are created on the server side. 
However, they are joined by clients by sending a request to the server.

<h2>Default Namespaces</h2>
The root namespace '/' is the default namespace, which is joined by clients if a namespace is not specified by the client while connecting to the server. 
All connections to the server using the socket-object client side are made to the default namespace. 
For example -

var socket = io();

This will connect the client to the default namespace. 
All events on this namespace connection will be handled by the <b>io object</b> on the server. 
All the previous examples were utilizing default namespaces to communicate with the server and back.

<h2>Custom Namespaces</h2>
We can create our own custom namespaces. 
To set up a custom namespace, we can call the ‘of’ function on the server side -

var app = require('express')();
var http = require('http').Server(app);
var io = require('socket.io')(http);

app.get('/', function(req, res) {
   res.sendfile('index.html');
});

var nsp = io.of('/my-namespace');
nsp.on('connection', function(socket) {
   console.log('someone connected');
   nsp.emit('hi', 'Hello everyone!');
});

http.listen(3000, function() {
   console.log('listening on localhost:3000');
});

Now, to connect a client to this namespace, you need to provide the namespace as an argument to the <b>io constructor call</b> to create a connection and a socket object on client side.

For example, to connect to the above namespace, use the following HTML -

&lt;!DOCTYPE html>
&lt;html>
   &lt;head>
      &lt;title>Hello world&lt;/title>
   &lt;/head>
   &lt;script src = "/socket.io/socket.io.js">&lt;/script>
   
   &lt;script>
      var socket = io('/my-namespace');
      socket.on('hi',function(data) {
         document.body.innerHTML = '';
         document.write(data);
      });
   &lt;/script>
   &lt;body>&lt;/body>
&lt;/html>

Every time someone connects to this namespace, they will receive a ‘hi’ event.

<h2><span class="orange">Socket.IO - Rooms</span></h2>
Within each namespace, you can also define arbitrary channels that sockets can join and leave. 
These channels are called rooms. 
Rooms are used to further-separate concerns. 
Rooms also share the same socket connection like namespaces. 
One thing to keep in mind while using rooms is that they can only be joined on the server side.

<h2>Joining Rooms</h2>
You can call the <b>join</b> method on the socket to subscribe the socket to a given channel/room. 
For example, let us create rooms called <b>'room-&lt;room-number>'</b> and join some clients. 
As soon as this room is full, create another room and join clients there.

<b>Note</b> - We are currently doing this on the default namespace, i.e. 
'/'. 
You can also implement this in custom namespaces in the same fashion.

To join a room you need to provide the room name as the argument to your join function call.

var app = require('express')();
var http = require('http').Server(app);
var io = require('socket.io')(http);

app.get('/', function(req, res) {
   res.sendfile('index.html');
});

var roomno = 1;
io.on('connection', function(socket) {
   
   //Increase roomno 2 clients are present in a room.
   if(io.nsps['/'].adapter.rooms["room-"+roomno] &amp;&amp; io.nsps['/'].adapter.rooms["room-"+roomno].length > 1) roomno++;
   socket.join("room-"+roomno);

   //Send this event to everyone in the room.
   io.sockets.in("room-"+roomno).emit('connectToRoom', "You are in room no. 
"+roomno);
})

http.listen(3000, function() {
   console.log('listening on localhost:3000');
});

Just handle this <b>connectToRoom</b> event on the client. 


&lt;!DOCTYPE html>
&lt;html>
   &lt;head>
      &lt;title>Hello world&lt;/title>
   &lt;/head>
   &lt;script src = "/socket.io/socket.io.js">&lt;/script>
   
   &lt;script>
      var socket = io();
      socket.on('connectToRoom',function(data) {
         document.body.innerHTML = '';
         document.write(data);
      });
   &lt;/script>
   &lt;body>&lt;/body>
&lt;/html>

Now if you connect three clients, the first two will get the following message -

You are in room no. 
1

The last client will get the following message -

You are in room no. 
2

 
<img src="https://www.tutorialspoint.com/socket.io/images/rooms.jpg" />
<h2>Leaving a room</h2>
To leave a room, you need to call the leave function just as you called the join function on the socket.

For example - To leave room <b>'room-1'</b>,

socket.leave("room-"+roomno);

<h2><span class="orange">Socket.IO - Error Handling</span></h2>
We have worked on local servers until now, which will almost never give us errors related to connections, timeouts, etc. 
However, in real life production environments, handling such errors are of utmost importance. 
Therefore, we will now discuss how we can handle connection errors on the client side.

The client API provides us with following built in events -

<b>Connect</b> - When the client successfully connects.

<b>Connecting</b> - When the client is in the process of connecting.

<b>Disconnect</b> - When the client is disconnected.

<b>Connect_failed</b> - When the connection to the server fails.

<b>Error</b> - An error event is sent from the server.

<b>Message</b> - When the server sends a message using the <b>send</b> function.

<b>Reconnect</b> - When reconnection to the server is successful.

<b>Reconnecting</b> - When the client is in the process of connecting.

<b>Reconnect_failed</b> - When the reconnection attempt fails.

To handle errors, we can handle these events using the out-socket object that we created on our client.

For example - If we have a connection that fails, we can use the following code to connect to the server again -

socket.on('connect_failed', function() {
   document.write("Sorry, there seems to be an issue with the connection!");
})

<h2><span class="orange">Socket.IO - Logging and Debugging</span></h2>
Socket.IO uses a very famous debugging module developed by ExpresJS's main author, called <b>debug</b>. 
Earlier Socket.IO used to log everything to the console making it quite difficult to debug the problem. 
After the v1.0 release, you can specify what you want to log.

<h2>Server-side</h2>
The best way to see what information is available is to use the * -

DEBUG=* node app.js

This will colorize and output everything that happens to your server console. 
For example, we can consider the following screenshot.

<img src="https://www.tutorialspoint.com/socket.io/images/logging_example.jpg" />
<h2>Client-side</h2>
Paste this to console, click enter and refresh your page. 
This will again output everything related to Socket.io to your console.

localStorage.debug = '*';

You can limit the output to get the debug info with incoming data from the socket using the following command.

localStorage.debug = 'socket.io-client:socket';

You can see the result like the following screenshot, if you use the second statement to log the info -

<img src="https://www.tutorialspoint.com/socket.io/images/client_logging.jpg" />
There is a very good blog post related to socket.io debugging <a target="_blank" href="https://www.rethinkdb.com/blog/websocket-debugging/">here.</a>

<h2><span class="orange">Socket.IO - Internals</span></h2>
In this chapter, we will discuss regarding Fallbacks, Connection using Socket.IO, Events and Messages.

<h2>Fallbacks</h2>
Socket.IO has a lot of underlying transport mechanisms, which deal with various constraints arising due to cross browser issues, WebSocket implementations, firewalls, port blocking, etc.

Though W3C has a defined specification for WebSocket API, it is still lacking in implementation. 
Socket.IO provides us with fallback mechanisms, which can deal with such issues. 
If we develop apps using the native API, we have to implement the fallbacks ourselves. 
Socket.IO covers a large list of fallbacks in the following order -

WebSockets
FlashSocket
XHR long polling
XHR multipart streaming
XHR polling
JSONP polling
iframes

<h2>Connection using Socket.IO</h2>
The Socket.IO connection begins with the handshake. 
This makes the handshake a special part of the protocol. 
Apart from the handshake, all the other events and messages in the protocol are transferred over the socket.

Socket.IO is intended for use with web applications, and therefore it is assumed that these applications will always be able to use HTTP. 
It is because of this reasoning that the Socket.IO handshake takes place over HTTP using a POST request on the handshake URI (passed to the connect method).

<h2>Events and messages</h2>
WebSocket native API only sends messages across. 
Socket.IO provides an addition layer over these messages, which allows us to create events and again helps us develop apps easily by separating the different types of messages sent.

The native API sends messages only in plain text. 
This is also taken care of by Socket.IO. 
It handles the serialization and deserialization of data for us.

We have an official client API for the web. 
For other clients such as native mobile phones, other application clients also we can use Socket.IO using the following steps.

<b>Step 1</b> - A connection needs to be established using the same connection protocol discussed above.

<b>Step 2</b> - The messages need to be in the same format as specified by Socket.IO. 
This format enables Socket.IO to determine the type of the message and the data sent in the message and some metadata useful for operation.

The message format is -

[type] : [id ('+')] : [endpoint] (: [data]

The parameters in the above command are explained below -

<b>Type</b> is a single digit integer, specifying what type message it is.

<b>ID</b> is message ID, an incremental integer used for acknowledgements.

<b>Endpoint</b> is the socket endpoint that the message is intended to be delivered to...

<b>Data</b> is the associated data to be delivered to the socket. 
In case of messages, it is treated as plain text, for other events, it is treated as JSON.

In the next chapter, we will write a chat application in Socket.IO.

<h2><span class="orange">Socket.IO - Chat Application</span></h2>
Now that we are well acquainted with Socket.IO, let us write a chat application, which we can use to chat on different chat rooms. 
We will allow users to choose a username and allow them to chat using them. 
So first, let us set up our HTML file to request for a username -

&lt;!DOCTYPE html>
&lt;html>
   &lt;head>
      &lt;title>Hello world&lt;/title>
   &lt;/head>
   &lt;script src = "/socket.io/socket.io.js">&lt;/script>
   &lt;script>
      var socket = io();
   &lt;/script>
   &lt;body>
      &lt;input type = "text" name = "name" value = "" placeholder = "Enter your name!">
      &lt;button type = "button" name = "button">Let me chat!&lt;/button>
   &lt;/body>
&lt;/html>
Now that we have set up our HTML to request for a username, let us create the server to accept connections from the client. 
We will allow people to send their chosen usernames using the <b>setUsername</b> event. 
If a user exists, we will respond by a <b>userExists</b> event, else using a <b>userSet</b> event.

var app = require('express')();
var http = require('http').Server(app);
var io = require('socket.io')(http);

app.get('/', function(req, res) {
   res.sendfile('index.html');
});

users = [];
io.on('connection', function(socket) {
   console.log('A user connected');
   socket.on('setUsername', function(data) {
      if(users.indexOf(data) > -1) {
         users.push(data);
         socket.emit('userSet', {username: data});
      } else {
         socket.emit('userExists', data + ' username is taken! Try some other username.');
      }
   })
});

http.listen(3000, function() {
   console.log('listening on localhost:3000');
});

We need to send the username to the server when people click on the button. 
If user exists, we show an error message; else, we show a messaging screen - 

&lt;!DOCTYPE html>
&lt;html>
   &lt;head>
      &lt;title>Hello world&lt;/title>
   &lt;/head>
   
   &lt;script src = "/socket.io/socket.io.js">&lt;/script>
   &lt;script>
      var socket = io();
      function setUsername() {
         socket.emit('setUsername', document.getElementById('name').value);
      };
      var user;
      socket.on('userExists', function(data) {
         document.getElementById('error-container').innerHTML = data;
      });

      socket.on('userSet', function(data) {
         user = data.username;
         document.body.innerHTML = '&lt;input type = "text" id = "message">\
         &lt;button type = "button" name = "button" onclick = "sendMessage()">Send&lt;/button>\
         &lt;div id = "message-container">&lt;/div>';
      });

      function sendMessage() {
         var msg = document.getElementById('message').value;
         if(msg) {
            socket.emit('msg', {message: msg, user: user});
         }
      }

      socket.on('newmsg', function(data) {
         if(user) {
            document.getElementById('message-container').innerHTML += '&lt;div>&lt;b>' + 
               data.user + '&lt;/b>: ' + data.message + '&lt;/div>'
         }
      })
   &lt;/script>
   
   &lt;body>
      &lt;div id = "error-container">&lt;/div>
      &lt;input id = "name" type = "text" name = "name" value = "" 
         placeholder = "Enter your name!">
      &lt;button type = "button" name = "button" onclick = "setUsername()">
         Let me chat!
      &lt;/button>
   &lt;/body>
&lt;/html>

Now if you connect two clients with same username, it will give you an error as shown in the screenshot below -

<img src="https://www.tutorialspoint.com/socket.io/images/chat_name_taken.jpg" />
Once you have provided an acceptable username, you will be taken to a screen with a message box and a button to send messages. 
Now, we have to handle and direct the messages to the connected client. 
For that, modify your app.js file to include the following changes -

var app = require('express')();
var http = require('http').Server(app);
var io = require('socket.io')(http);

app.get('/', function(req, res) {
   res.sendfile('index.html');
});

users = [];
io.on('connection', function(socket) {
   console.log('A user connected');
   socket.on('setUsername', function(data) {
      console.log(data);
      if(users.indexOf(data) > -1) {
         socket.emit('userExists', data + ' username is taken! Try some other username.');
      } else {
         users.push(data);
         socket.emit('userSet', {username: data});
      }
   });
   
   socket.on('msg', function(data) {
      //Send message to everyone
      io.sockets.emit('newmsg', data);
   })
});

http.listen(3000, function() {
   console.log('listening on localhost:3000');
});

Now connect any number of clients to your server, provide them a username and start chatting! In the following example, we have connected two clients with names Ayush and Harshit and sent some messages from both the clients -

<img src="https://www.tutorialspoint.com/socket.io/images/chat_example.jpg" />

<h2><span class="orange">Socket.IO - Useful Resources</span></h2>

The following resources contain additional information on Socket.IO. 
Please use them to get more in-depth knowledge on this topic.

<h2>Useful Links on Socket.IO</h2>   

<a target="_blank" href="https://socket.io/docs">Socket.io</a> - Official website for socket.io, its you complete detail including socket.io library and associated documentation.

<a target="_blank" href="https://www.npmjs.com/package/socket.io">Socket.io at npm</a> socket.io repository at npm 

<h2>Useful Books on Socket.IO</h2>   

<a target="_blank" href="https://www.amazon.com/Socket-IO-Real-time-Web-Application-Development/dp/1782160787/httpwwwtuto0a-20"><img src="https://images-na.ssl-images-amazon.com/images/I/51AJwvbiI9L._SX404_BO1,204,203,200_.jpg"/></a>   
<a target="_blank" href="https://www.amazon.com/Socket-IO-Cookbook-Tyson-Cadenhead/dp/1785880861/httpwwwtuto0a-20"><img src="https://images-na.ssl-images-amazon.com/images/I/51z00hSUzUL._SX404_BO1,204,203,200_.jpg"/></a>  


<script src='https://williamkpchan.github.io/LibDocs/readbook.js'></script>
<script>
var lazyLoadInstance = new LazyLoad({
    elements_selector: ".lazy"
    // ... more custom settings?
});
</script>
