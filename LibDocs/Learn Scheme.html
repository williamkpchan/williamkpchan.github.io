<base target="_blank"><html><head><title>Learn Scheme</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script type='text/javascript' src='../mainscript.js'></script>
<script>
  var showTopicNumber = true;
</script>
<style>
body{width:90%;margin-left: 5%; font-size:22px;}
strong, h1, h2 {color: gold;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px;}
 .highlight scheme-language{color:#8aa;}
 .comment{color:#488;}
 .paren1{color:#689;}
 .default{color:#789;}
 .paren2{color:#888;}
 .symbol{color:#128;}
 .string{color:#592;}
 .character{color:#447;}
 .paren3{color:#860;}
 .paren4{color:#984;}
 .keyword{color:#642;}
</style></head><body onkeypress="chkKey()"><center>
<h1>Learn Scheme</h1>
<a href="http://www.shido.info/lisp/idx_scm_e.html" class="whitebut ">Another Scheme Tutorial</a>

</center>
<pre>
<br>
<br>

<h3>Learn Scheme in 15 minutes</h3>
<pre><tt class="highlight scheme-language"><span class="comment">;; This gives an introduction to Scheme in 15 minutes
;;
;; First make sure you read this text by Peter Norvig:
;; http://norvig.com/21-days.html
;;
;; Then install GNU Guile
;; NOTE: I won&#x27;t encourage using Racket but if you really want,
;;       I still give you some hints in this tutorial. But the
;;       tutorial will base on Guile and RnRs.
;;
;; openSUSE: zypper install guile
;; Debian: apt-get install guile-2.0 (or see your distro instructions)
;; MacOSX: Building Guile 2.0 on the Mac
;;         http://irrealblog.blogspot.hk/2011/03/building-guile-2.html
;; Windows try web: <a href="http://repl.it/languages/Scheme" class="whitebut ">Online Scheme compiler</a>
;; More general information can be found at:
;; http://www.gnu.org/software/guile
</span>
<span class="comment">;; Important warning:
;;
;; Going through this tutorial won&#x27;t damage your computer unless
;; you get so angry that you throw it on the floor.  In that case,
;; I hereby decline any responsability.  Have fun!
</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 
;; Fire up Scheme:
;; Type &#x27;guile&#x27; for GNU Guile
;; Or just use the browser for web version
;;
;; Now look at the prompt:
</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Semi-colons start comments anywhere on a line.
;;
;; Scheme programs are made of symbolic expressions (s-exps):
</span><span class="paren1">(<span class="default">+ 2 2</span>)</span>

<span class="comment">;; This symbolic expression reads as &quot;Add 2 to 2&quot;.
</span>
<span class="comment">;; Sexps are enclosed into parentheses, possibly nested:
</span><span class="paren1">(<span class="default">+ 2 <span class="paren2">(<span class="default">+ 1 1</span>)</span></span>)</span>

<span class="comment">;; A symbolic expression contains atoms or other symbolic
;; expressions.  In the above examples, 1 and 2 are atoms,
;; (+ 2 (+ 1 1)) and (+ 1 1) are symbolic expressions.
</span>
<span class="paren1">(<span class="default">+ 3 <span class="paren2">(<span class="default">+ 1 2</span>)</span></span>)</span>
<span class="comment">;; =&gt; 6
</span>
<span class="comment">;; `set!&#x27; stores a value into a variable:
;; Please define my-name first, or you can&#x27;t assign it.
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> my-name <span class="string">&quot;unknown&quot;</span></span>)</span>
<span class="paren1">(<span class="default">set! my-name <span class="string">&quot;NalaGinrut&quot;</span></span>)</span>

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 1. Primitive Datatypes and Operators
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span>
<span class="comment">;;; Numbers
</span>9999999999999999999999 <span class="comment">; integers
</span>#b111                  <span class="comment">; binary =&gt; 7
</span>#o111                  <span class="comment">; octal =&gt; 73
</span>#x111                  <span class="comment">; hexadecimal =&gt; 273
</span>3.14                   <span class="comment">; reals
</span>6.02e+23
1/2                    <span class="comment">; rationals
</span>1+2i                   <span class="comment">; complex numbers
</span>
<span class="comment">;; Function application is written (f x y z ...)
;; where f is a function and x, y, z, ... are operands
;; If you want to create a literal list of data, use &#x27; to stop it from
;; being evaluated
</span>&#x27;<span class="paren1">(<span class="default">+ 1 2</span>)</span> <span class="comment">; =&gt; (+ 1 2)
;; Now, some arithmetic operations
</span><span class="paren1">(<span class="default">+ 1 1</span>)</span>  <span class="comment">; =&gt; 2
</span><span class="paren1">(<span class="default">- 8 1</span>)</span>  <span class="comment">; =&gt; 7
</span><span class="paren1">(<span class="default">* 10 2</span>)</span> <span class="comment">; =&gt; 20
</span><span class="paren1">(<span class="default">expt 2 3</span>)</span> <span class="comment">; =&gt; 8
</span><span class="paren1">(<span class="default">quotient 5 2</span>)</span> <span class="comment">; =&gt; 2
</span><span class="paren1">(<span class="default">remainder 5 2</span>)</span> <span class="comment">; =&gt; 1
</span><span class="paren1">(<span class="default">/ 35 5</span>)</span> <span class="comment">; =&gt; 7
</span><span class="paren1">(<span class="default">/ 1 3</span>)</span> <span class="comment">; =&gt; 1/3
</span><span class="paren1">(<span class="default">exact-&gt;inexact 1/3</span>)</span> <span class="comment">; =&gt; 0.3333333333333333
</span><span class="paren1">(<span class="default">+ 1+2i  2-3i</span>)</span> <span class="comment">; =&gt; 3-1i
</span>
<span class="comment">;;; Booleans
</span>#t <span class="comment">; for true
</span>#f <span class="comment">; for false -- any value other than #f is true
</span><span class="paren1">(<span class="default">not #t</span>)</span> <span class="comment">; =&gt; #f
</span><span class="paren1">(<span class="default">and 0 #f <span class="paren2">(<span class="default">error <span class="string">&quot;doesn&#x27;t get here&quot;</span></span>)</span></span>)</span> <span class="comment">; =&gt; #f
</span><span class="paren1">(<span class="default">or #f 0 <span class="paren2">(<span class="default">error <span class="string">&quot;doesn&#x27;t get here&quot;</span></span>)</span></span>)</span>  <span class="comment">; =&gt; 0
</span>
<span class="comment">;;; Characters
;; According to RnRs, characters only have two notations:
;; #\ and #\x
;; Racket support #\u, but it&#x27;s never Scheme.
</span><span class="character">#\A</span> <span class="comment">; =&gt; #\A
</span><span class="character">#\λ</span> <span class="comment">; =&gt; #\λ
</span><span class="character">#\x03BB</span> <span class="comment">; =&gt; #\λ
</span>
<span class="comment">;;; Strings are fixed-length array of characters.
</span><span class="string">&quot;Hello, world!&quot;</span>
<span class="string">&quot;Benjamin </span><span class="string">\&quot;</span><span class="string">Bugsy</span><span class="string">\&quot;</span><span class="string"> Siegel&quot;</span>   <span class="comment">; backslash is an escaping character
</span><span class="string">&quot;Foo</span><span class="string">\t</span><span class="string">bar</span><span class="string">\x</span><span class="string">21</span><span class="string">\a</span><span class="string">\r</span><span class="string">\n</span><span class="string">&quot;</span> <span class="comment">; includes C escapes (only support hex)
;; try to print the above string
;; Printing is pretty easy
</span><span class="paren1">(<span class="default">display <span class="string">&quot;I&#x27;m Guile. Nice to meet you!</span><span class="string">\n</span><span class="string">&quot;</span></span>)</span>
<span class="comment">;; and unicode escapes
</span><span class="string">&quot;</span><span class="string">\u</span><span class="string">004B&quot;</span> <span class="comment">; =&gt; K
</span>
<span class="comment">;; Strings can be added too!
</span><span class="paren1">(<span class="default">string-append <span class="string">&quot;Hello &quot;</span> <span class="string">&quot;world!&quot;</span></span>)</span> <span class="comment">; =&gt; &quot;Hello world!&quot;
</span>
<span class="comment">;; A string can be treated like a list of characters
</span><span class="paren1">(<span class="default">string-ref <span class="string">&quot;Apple&quot;</span> 0</span>)</span> <span class="comment">; =&gt; #\A
</span>
<span class="comment">;; format can be used to format strings:
</span><span class="paren1">(<span class="default">format #t <span class="string">&quot;~a can be ~a&quot;</span> <span class="string">&quot;strings&quot;</span> <span class="string">&quot;formatted&quot;</span></span>)</span>
<span class="comment">;; ==&gt; print &quot;strings can be formatted&quot; on screen
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> str <span class="paren2">(<span class="default">format #f <span class="string">&quot;~a can be ~a&quot;</span> <span class="string">&quot;strings&quot;</span> <span class="string">&quot;formatted&quot;</span></span>)</span></span>)</span>
<span class="comment">;; str was assigned to &quot;strings can be formatted&quot;
</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 2. Variables
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; You can create a variable using define
;; a variable name can use any character except: ()[]{}&quot;,&#x27;`;#|\
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> some-var 5</span>)</span>
some-var <span class="comment">; =&gt; 5
</span>
<span class="comment">;; Accessing a previously unassigned variable is an exception
; x ; =&gt; x: undefined ...
</span>
<span class="comment">;; Local binding: `me&#x27; is bound to &quot;Bob&quot; only within the (let ...)
</span><span class="paren1">(<span class="default"><i><span class="symbol">let</span></i> <span class="paren2">(<span class="default"><span class="paren3">(<span class="default">me <span class="string">&quot;Bob&quot;</span></span>)</span></span>)</span>
  <span class="string">&quot;Alice&quot;</span>
  me</span>)</span> 
<span class="comment">;; =&gt; &quot;Bob&quot;
</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 3. Structs and Collections
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span>
<span class="comment">;; Record Type (Skip this chapter if you&#x27;re trying web version
</span><span class="paren1">(<span class="default">use-modules <span class="paren2">(<span class="default">srfi srfi-9</span>)</span></span>)</span>
<span class="paren1">(<span class="default"><i><span class="symbol">define-record-type</span></i> dog 
  <span class="paren2">(<span class="default">make-dog name breed age</span>)</span>
  dog?
  <span class="paren2">(<span class="default">name dog-name</span>)</span>
  <span class="paren2">(<span class="default">breed dog-breed</span>)</span>
  <span class="paren2">(<span class="default">age dog-age</span>)</span></span>)</span>
<span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> my-pet
  <span class="paren2">(<span class="default">make-dog <span class="string">&quot;lassie&quot;</span> <span class="string">&quot;collie&quot;</span> 5</span>)</span></span>)</span>
my-pet <span class="comment">; =&gt; #&lt;dog&gt;
</span><span class="paren1">(<span class="default">dog? my-pet</span>)</span> <span class="comment">; =&gt; #t
</span><span class="paren1">(<span class="default">dog-name my-pet</span>)</span> <span class="comment">; =&gt; &quot;lassie&quot;
</span>
<span class="comment">;;; Pairs (immutable)
;; `cons&#x27; constructs pairs, `car&#x27; and `cdr&#x27; extract the first
;; and second elements
</span><span class="paren1">(<span class="default">cons 1 2</span>)</span> <span class="comment">; =&gt; &#x27;(1 . 2)
</span><span class="paren1">(<span class="default">car <span class="paren2">(<span class="default">cons 1 2</span>)</span></span>)</span> <span class="comment">; =&gt; 1
</span><span class="paren1">(<span class="default">cdr <span class="paren2">(<span class="default">cons 1 2</span>)</span></span>)</span> <span class="comment">; =&gt; 2
</span>
<span class="comment">;;; Lists
</span>
<span class="comment">;; Lists are linked-list data structures, made of `cons&#x27; pairs and end
;; with a &#x27;() to mark the end of the list
</span><span class="paren1">(<span class="default">cons 1 <span class="paren2">(<span class="default">cons 2 <span class="paren3">(<span class="default">cons 3 &#x27;<span class="paren4">(<span class="default"></span>)</span></span>)</span></span>)</span></span>)</span> <span class="comment">; =&gt; &#x27;(1 2 3)
;; `list&#x27; is a convenience variadic constructor for lists
</span><span class="paren1">(<span class="default">list 1 2 3</span>)</span> <span class="comment">; =&gt; &#x27;(1 2 3)
;; and a quote can also be used for a literal list value
</span>&#x27;<span class="paren1">(<span class="default">1 2 3</span>)</span> <span class="comment">; =&gt; &#x27;(1 2 3)
</span>
<span class="comment">;; Can still use `cons&#x27; to add an item to the beginning of a list
</span><span class="paren1">(<span class="default">cons 4 &#x27;<span class="paren2">(<span class="default">1 2 3</span>)</span></span>)</span> <span class="comment">; =&gt; &#x27;(4 1 2 3)
</span>
<span class="comment">;; Use `append&#x27; to add lists together
</span><span class="paren1">(<span class="default">append &#x27;<span class="paren2">(<span class="default">1 2</span>)</span> &#x27;<span class="paren2">(<span class="default">3 4</span>)</span></span>)</span> <span class="comment">; =&gt; &#x27;(1 2 3 4)
</span>
<span class="comment">;; Lists are a very basic type, so there is a *lot* of functionality for
;; them, a few examples:
;; For Racket users:
</span><span class="paren1">(<span class="default">map add1 &#x27;<span class="paren2">(<span class="default">1 2 3</span>)</span></span>)</span>          <span class="comment">; =&gt; &#x27;(2 3 4)
;; For Guile users:
</span><span class="paren1">(<span class="default">map 1+ &#x27;<span class="paren2">(<span class="default">1 2 3</span>)</span></span>)</span>	     <span class="comment">; =&gt; &#x27;(2 3 4)
;; add1 or 1+ is not a standard primitive, so it depends on implementations.
</span>
<span class="paren1">(<span class="default">map + &#x27;<span class="paren2">(<span class="default">1 2 3</span>)</span> &#x27;<span class="paren2">(<span class="default">10 20 30</span>)</span></span>)</span> <span class="comment">; =&gt; &#x27;(11 22 33)
</span>
<span class="comment">;; filter/count/take/drop are dwell in SRFI-1, so you have to load it first.
;; For Racket users:
</span><span class="paren1">(<span class="default">require srfi/1</span>)</span>
<span class="comment">;; For Guile users:
</span><span class="paren1">(<span class="default">use-modules <span class="paren2">(<span class="default">srfi srfi-1</span>)</span></span>)</span>

<span class="paren1">(<span class="default">filter even? &#x27;<span class="paren2">(<span class="default">1 2 3 4</span>)</span></span>)</span>    <span class="comment">; =&gt; &#x27;(2 4)
</span><span class="paren1">(<span class="default">count even? &#x27;<span class="paren2">(<span class="default">1 2 3 4</span>)</span></span>)</span>     <span class="comment">; =&gt; 2
</span><span class="paren1">(<span class="default">take &#x27;<span class="paren2">(<span class="default">1 2 3 4</span>)</span> 2</span>)</span>          <span class="comment">; =&gt; &#x27;(1 2)
</span><span class="paren1">(<span class="default">drop &#x27;<span class="paren2">(<span class="default">1 2 3 4</span>)</span> 2</span>)</span>          <span class="comment">; =&gt; &#x27;(3 4)
</span>
<span class="comment">;;; Vectors
</span>
<span class="comment">;; Vectors are fixed-length arrays
</span>#<span class="paren1">(<span class="default">1 2 3</span>)</span> <span class="comment">; =&gt; &#x27;#(1 2 3)
</span>
<span class="comment">;; Use `vector-append&#x27; to add vectors together
;; NOTE: vector-append is in SRFI-43 which is not supported in Guile-2.0.9
;;       or earlier. And it may not be added in Guile-2.0.10.
;;       But it&#x27;s proposed in R7RS, and there&#x27;s a r7rs branch in Guile upstream.
;;       If your Guile doesn&#x27;t support vector-append, please skip this step.
</span><span class="paren1">(<span class="default">vector-append #<span class="paren2">(<span class="default">1 2 3</span>)</span> #<span class="paren2">(<span class="default">4 5 6</span>)</span></span>)</span> <span class="comment">; =&gt; #(1 2 3 4 5 6)
</span>
<span class="comment">;;; Hashes
</span>
<span class="comment">;; Create mutable hash table
;; For GNU Guile
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> m <span class="paren2">(<span class="default">make-hash-table</span>)</span></span>)</span>
<span class="paren1">(<span class="default">hash-set! m &#x27;a 1</span>)</span>
<span class="paren1">(<span class="default">hash-set! m &#x27;b 2</span>)</span>
<span class="paren1">(<span class="default">hash-set! m &#x27;c 3</span>)</span>

<span class="comment">;; Retrieve a value
</span><span class="paren1">(<span class="default">hash-ref m &#x27;a</span>)</span> <span class="comment">; =&gt; 1
</span>
<span class="comment">;; Retrieving a non-present value is an exception
</span><span class="paren1">(<span class="default">hash-ref m &#x27;d</span>)</span> 
<span class="comment">;; =&gt; #f 
</span>
<span class="comment">;; You can provide a default value for missing keys
</span><span class="paren1">(<span class="default">hash-ref m &#x27;d 0</span>)</span>
<span class="comment">;; =&gt; 0
</span>
<span class="comment">;; Use `hash-remove&#x27; to remove keys (functional too)
</span><span class="paren1">(<span class="default">hash-remove! m &#x27;a</span>)</span> <span class="comment">; =&gt; ((b . 2) (c . 3))
</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 3. Functions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span>
<span class="comment">;; Use `lambda&#x27; to create functions.
;; A function always returns the value of its last expression
</span><span class="paren1">(<span class="default"><i><span class="symbol">lambda</span></i> <span class="paren2">(<span class="default"></span>)</span> <span class="string">&quot;Hello World&quot;</span></span>)</span> <span class="comment">; =&gt; #&lt;procedure&gt;
</span>
<span class="comment">;; Use parens to call all functions, including a lambda expression
</span><span class="paren1">(<span class="default"><span class="paren2">(<span class="default"><i><span class="symbol">lambda</span></i> <span class="paren3">(<span class="default"></span>)</span> <span class="string">&quot;Hello World&quot;</span></span>)</span></span>)</span> <span class="comment">; =&gt; &quot;Hello World&quot;
</span><span class="paren1">(<span class="default"><span class="paren2">(<span class="default"><i><span class="symbol">lambda</span></i> <span class="paren3">(<span class="default">x</span>)</span> <span class="paren3">(<span class="default">+ x x</span>)</span></span>)</span> 5</span>)</span>      <span class="comment">; =&gt; 10
</span>
<span class="comment">;; Assign a function to a var
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> hello-world <span class="paren2">(<span class="default"><i><span class="symbol">lambda</span></i> <span class="paren3">(<span class="default"></span>)</span> <span class="string">&quot;Hello World&quot;</span></span>)</span></span>)</span>
<span class="paren1">(<span class="default">hello-world</span>)</span> <span class="comment">; =&gt; &quot;Hello World&quot;
</span>
<span class="comment">;; You can shorten this using the function definition syntatcic sugar:
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> <span class="paren2">(<span class="default">hello-world2</span>)</span> <span class="string">&quot;Hello World&quot;</span></span>)</span>
<span class="paren1">(<span class="default">hello-world2</span>)</span> <span class="comment">; =&gt; &quot;Hello World&quot;
</span>
<span class="comment">;; The () in the above is the list of arguments for the function
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> hello
  <span class="paren2">(<span class="default"><i><span class="symbol">lambda</span></i> <span class="paren3">(<span class="default">name</span>)</span>
    <span class="paren3">(<span class="default">string-append <span class="string">&quot;Hello &quot;</span> name</span>)</span></span>)</span></span>)</span>
<span class="paren1">(<span class="default">hello <span class="string">&quot;Steve&quot;</span></span>)</span> <span class="comment">; =&gt; &quot;Hello Steve&quot;
;; ... or equivalently, using a sugared definition:
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> <span class="paren2">(<span class="default">hello2 name</span>)</span>
  <span class="paren2">(<span class="default">string-append <span class="string">&quot;Hello &quot;</span> name</span>)</span></span>)</span>

<span class="comment">;; You can have multi-variadic functions too, using `case-lambda&#x27;
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> hello3
  <span class="paren2">(<span class="default">case-lambda
    <span class="paren3">(<span class="default"><span class="paren4">(<span class="default"></span>)</span> <span class="string">&quot;Hello World&quot;</span></span>)</span>
    <span class="paren3">(<span class="default"><span class="paren4">(<span class="default">name</span>)</span> <span class="paren4">(<span class="default">string-append <span class="string">&quot;Hello &quot;</span> name</span>)</span></span>)</span></span>)</span></span>)</span>
<span class="paren1">(<span class="default">hello3 <span class="string">&quot;Jake&quot;</span></span>)</span> <span class="comment">; =&gt; &quot;Hello Jake&quot;
</span><span class="paren1">(<span class="default">hello3</span>)</span> <span class="comment">; =&gt; &quot;Hello World&quot;
;; ... or specify optional arguments with a default value expression
</span><span class="paren1">(<span class="default"><i><span class="symbol">define*</span></i> <span class="paren2">(<span class="default">hello4 <span class="keyword">#:key</span> <span class="paren3">(<span class="default">name <span class="string">&quot;World&quot;</span></span>)</span></span>)</span>
  <span class="paren2">(<span class="default">string-append <span class="string">&quot;Hello &quot;</span> name</span>)</span></span>)</span>

<span class="comment">;; Functions can pack extra arguments up in a list
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> <span class="paren2">(<span class="default">count-args . args</span>)</span>
  <span class="paren2">(<span class="default">format #t <span class="string">&quot;You passed ~a args: ~a&quot;</span> <span class="paren3">(<span class="default">length args</span>)</span> args</span>)</span></span>)</span>
<span class="paren1">(<span class="default">count-args 1 2 3</span>)</span> <span class="comment">; =&gt; &quot;You passed 3 args: (1 2 3)&quot;
;; ... or with the unsugared `lambda&#x27; form:
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> count-args2
  <span class="paren2">(<span class="default"><i><span class="symbol">lambda</span></i> args
    <span class="paren3">(<span class="default">format #t <span class="string">&quot;You passed ~a args: ~a&quot;</span> <span class="paren4">(<span class="default">length args</span>)</span> args</span>)</span></span>)</span></span>)</span>

<span class="comment">;; You can mix regular and packed arguments
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> <span class="paren2">(<span class="default">hello-count name . args</span>)</span>
  <span class="paren2">(<span class="default">format #t <span class="string">&quot;Hello ~a, you passed ~a extra args&quot;</span> name <span class="paren3">(<span class="default">length args</span>)</span></span>)</span></span>)</span>
<span class="paren1">(<span class="default">hello-count <span class="string">&quot;Finn&quot;</span> 1 2 3</span>)</span>
<span class="comment">; =&gt; &quot;Hello Finn, you passed 3 extra args&quot;
;; ... unsugared:
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> hello-count2
  <span class="paren2">(<span class="default"><i><span class="symbol">lambda</span></i> <span class="paren3">(<span class="default">name . args</span>)</span>
    <span class="paren3">(<span class="default">format #t <span class="string">&quot;Hello ~a, you passed ~a extra args&quot;</span> name <span class="paren4">(<span class="default">length args</span>)</span></span>)</span></span>)</span></span>)</span>

<span class="comment">;; And with keywords
;; the keywords are those like this #:its-name, sometimes you may see
;; :its-name without &#x27;#&#x27; in certain Scheme implementation.
;; NOTE: keywords is not in any Scheme standards like RnRs.
;;       But mainstream Scheme implementation often contains it. 
;;	 This truth also means that different implementation may has
;;	 different result.
;;       The code below will follow Guile situation.
</span><span class="paren1">(<span class="default"><i><span class="symbol">define*</span></i> <span class="paren2">(<span class="default">hello <span class="keyword">#:key</span> <span class="paren3">(<span class="default">name <span class="string">&quot;World&quot;</span></span>)</span> <span class="paren3">(<span class="default">greeting <span class="string">&quot;Hello&quot;</span></span>)</span> . args</span>)</span>
  <span class="paren2">(<span class="default">format #t <span class="string">&quot;~a ~a, ~a extra args~%&quot;</span> greeting name <span class="paren3">(<span class="default">length args</span>)</span></span>)</span></span>)</span>
<span class="comment">;; &#x27;define*&#x27; is similar with &#x27;define&#x27;, but you may use it for defining
;; optional args or using keyword to specify the value to specified argument.
</span><span class="paren1">(<span class="default">hello</span>)</span>                 <span class="comment">; =&gt; &quot;Hello World, 0 extra args&quot;
</span><span class="paren1">(<span class="default">hello 1 2 3</span>)</span>           <span class="comment">; =&gt; &quot;Hello World, 3 extra args&quot;
</span><span class="paren1">(<span class="default">hello <span class="keyword">#:greeting</span> <span class="string">&quot;Hi&quot;</span></span>)</span> <span class="comment">; =&gt; &quot;Hi World, 2 extra args&quot;
;; NOTE: In Guile, all the keyword-value pairs are countered as the rest args.
;;       It means &#x27;args&#x27; here will be (#:greeting &quot;Hi&quot;), so its length is 2.
;;       If you are in Racket, it&#x27;s different, so the result will be 0.
;;       Because it&#x27;s not defined in RnRs, so it&#x27;s implementation specific.
</span><span class="paren1">(<span class="default">hello <span class="keyword">#:name</span> <span class="string">&quot;Finn&quot;</span> <span class="keyword">#:greeting</span> <span class="string">&quot;Hey&quot;</span></span>)</span> <span class="comment">; =&gt; &quot;Hey Finn, 4 extra args&quot;
</span><span class="paren1">(<span class="default">hello 1 2 3 <span class="keyword">#:greeting</span> <span class="string">&quot;Hi&quot;</span> <span class="keyword">#:name</span> <span class="string">&quot;Finn&quot;</span> 4 5 6</span>)</span> <span class="comment">; =&gt; &quot;Hi Finn, 10 extra args&quot;
</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 4. Equality
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span>
<span class="comment">;; for numbers use `=&#x27;
</span><span class="paren1">(<span class="default">= 3 3.0</span>)</span> <span class="comment">; =&gt; #t
</span><span class="paren1">(<span class="default">= 2 1</span>)</span> <span class="comment">; =&gt; #f
</span>
<span class="comment">;; for characters use `char=?&#x27;
</span><span class="paren1">(<span class="default">char=? <span class="character">#\c</span> <span class="character">#\c</span></span>)</span> <span class="comment">; =&gt; #t
</span>
<span class="comment">;; for object identity use `eq?&#x27;
;; WARNING: don&#x27;t use `eq?&#x27; on numbers and characters, the reason is very simple:
;;          because RnRs treat this rule as undefined! 
;;(eq? 3 3) ; =&gt; Wrong! it&#x27;s undefined! So it depends on implementation!
;; No matter if you got #t from above, it&#x27;s a wrong usage!!!
;; Should use (= 3 3) or (eqv? 3 3)
</span>
<span class="paren1">(<span class="default">eq? <span class="paren2">(<span class="default">list 3</span>)</span> <span class="paren2">(<span class="default">list 3</span>)</span></span>)</span> <span class="comment">; =&gt; #f
;; Why it&#x27;s #f? Because comparison between objects depends on their head-pointers.
;; These two lists are different objects, and they have different head-pointers.
</span>
<span class="paren1">(<span class="default">eq? &#x27;a &#x27;a</span>)</span> <span class="comment">; =&gt; #t
;; Symbols are the typical objects to compare with their head-pointers
</span>
<span class="comment">;; eqv?
;; The difference between `eqv?&#x27; and `eq&#x27;:
;; You can compare numbers and characters with `eqv?&#x27;
;; When you use `eqv?&#x27; for any objects other than numbers&amp;characters, it&#x27;s the
;; same with `eq?&#x27;.
</span><span class="paren1">(<span class="default">eqv? 3 3</span>)</span>     <span class="comment">; =&gt; #t
</span><span class="paren1">(<span class="default">eqv? <span class="character">#\c</span> <span class="character">#\c</span></span>)</span> <span class="comment">; =&gt; #t
</span><span class="paren1">(<span class="default">eqv? &#x27;a &#x27;a</span>)</span>   <span class="comment">; =&gt; #t
</span>
<span class="comment">;; for collections use `equal?&#x27;
;; `equal?&#x27; will compare all the values in a collections type like record or list.
;; You can compare any objects with `equal?&#x27; safely, but inefficiency.
</span><span class="paren1">(<span class="default">equal? <span class="paren2">(<span class="default">list &#x27;a &#x27;b</span>)</span> <span class="paren2">(<span class="default">list &#x27;a &#x27;b</span>)</span></span>)</span> <span class="comment">; =&gt; #t
</span><span class="paren1">(<span class="default">equal? <span class="paren2">(<span class="default">list &#x27;a &#x27;b</span>)</span> <span class="paren2">(<span class="default">list &#x27;b &#x27;a</span>)</span></span>)</span> <span class="comment">; =&gt; #f
</span>
<span class="comment">;; Choosing proper equal pred for you code, is one of the art in Scheme programming!
</span>
<span class="paren1">(<span class="default">eqv? <span class="string">&quot;abcd&quot;</span> <span class="string">&quot;abcd&quot;</span></span>)</span> <span class="comment">; =&gt; unspecified
;; Obviously, strings are collections type, so...it&#x27;s your EXECISE now!
</span>
<span class="comment">;; Another EXECISE, what&#x27;s the proper &#x27;equal-pred&#x27; for functions?
</span><span class="paren1">(<span class="default">what-to-use? <span class="paren2">(<span class="default"><i><span class="symbol">lambda</span></i> <span class="paren3">(<span class="default">x</span>)</span> <span class="paren3">(<span class="default">1+ x</span>)</span></span>)</span> <span class="paren2">(<span class="default"><i><span class="symbol">lambda</span></i> <span class="paren3">(<span class="default">x</span>)</span> <span class="paren3">(<span class="default">1+ x</span>)</span></span>)</span></span>)</span>

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 5. Control Flow
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span>
<span class="comment">;;; Conditionals
</span>
<span class="paren1">(<span class="default"><i><span class="symbol">if</span></i> #t               <span class="comment">; test expression
</span>    <span class="string">&quot;this is true&quot;</span>   <span class="comment">; then expression
</span>    <span class="string">&quot;this is false&quot;</span></span>)</span> <span class="comment">; else expression
; =&gt; &quot;this is true&quot;
</span>
<span class="comment">;; In conditionals, all non-#f values are treated as true
</span><span class="paren1">(<span class="default">member &#x27;Groucho &#x27;<span class="paren2">(<span class="default">Harpo Groucho Zeppo</span>)</span></span>)</span> <span class="comment">; =&gt; &#x27;(Groucho Zeppo)
</span><span class="paren1">(<span class="default"><i><span class="symbol">if</span></i> <span class="paren2">(<span class="default">member &#x27;Groucho &#x27;<span class="paren3">(<span class="default">Harpo Groucho Zeppo</span>)</span></span>)</span>
    &#x27;yep
    &#x27;nope</span>)</span>
<span class="comment">; =&gt; &#x27;yep
</span>
<span class="comment">;; `cond&#x27; chains a series of tests to select a result
</span><span class="paren1">(<span class="default"><i><span class="symbol">cond</span></i> <span class="paren2">(<span class="default"><span class="paren3">(<span class="default">&gt; 2 2</span>)</span> <span class="paren3">(<span class="default">error <span class="string">&quot;wrong!&quot;</span></span>)</span></span>)</span>
      <span class="paren2">(<span class="default"><span class="paren3">(<span class="default">&lt; 2 2</span>)</span> <span class="paren3">(<span class="default">error <span class="string">&quot;wrong again!&quot;</span></span>)</span></span>)</span>
      <span class="paren2">(<span class="default">else &#x27;ok</span>)</span></span>)</span> <span class="comment">; =&gt; &#x27;ok
</span>
<span class="comment">;;; Pattern Matching
;; For Racket users:
</span><span class="paren1">(<span class="default">require racket/match</span>)</span> <span class="comment">; use match module
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> <span class="paren2">(<span class="default">fizzbuzz? n</span>)</span>
  <span class="paren2">(<span class="default">match <span class="paren3">(<span class="default">list <span class="paren4">(<span class="default">remainder n 3</span>)</span> <span class="paren4">(<span class="default">remainder n 5</span>)</span></span>)</span>
    <span class="paren3">(<span class="default"><span class="paren4">(<span class="default">list 0 0</span>)</span> &#x27;fizzbuzz</span>)</span>
    <span class="paren3">(<span class="default"><span class="paren4">(<span class="default">list 0 _</span>)</span> &#x27;fizz</span>)</span>
    <span class="paren3">(<span class="default"><span class="paren4">(<span class="default">list _ 0</span>)</span> &#x27;buzz</span>)</span>
    <span class="paren3">(<span class="default">else #f</span>)</span></span>)</span></span>)</span>

<span class="comment">;; For Guile users:
</span><span class="paren1">(<span class="default">use-modules <span class="paren2">(<span class="default">ice-9 match</span>)</span></span>)</span> <span class="comment">; use match module
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> <span class="paren2">(<span class="default">fizzbuzz? n</span>)</span>
  <span class="paren2">(<span class="default">match <span class="paren3">(<span class="default">list <span class="paren4">(<span class="default">remainder n 3</span>)</span> <span class="paren4">(<span class="default">remainder n 5</span>)</span></span>)</span>
    <span class="paren3">(<span class="default"><span class="paren4">(<span class="default">0 0</span>)</span> &#x27;fizzbuzz</span>)</span>
    <span class="paren3">(<span class="default"><span class="paren4">(<span class="default">0 _</span>)</span> &#x27;fizz</span>)</span>
    <span class="paren3">(<span class="default"><span class="paren4">(<span class="default">_ 0</span>)</span> &#x27;buzz</span>)</span>
    <span class="paren3">(<span class="default">else #f</span>)</span></span>)</span></span>)</span>

<span class="paren1">(<span class="default">fizzbuzz? 15</span>)</span> <span class="comment">; =&gt; &#x27;fizzbuzz
</span><span class="paren1">(<span class="default">fizzbuzz? 37</span>)</span> <span class="comment">; =&gt; #f
</span>
<span class="comment">;;; Loops
</span>
<span class="comment">;; Looping can be done through (tail-) recursion
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> <span class="paren2">(<span class="default">lp i</span>)</span>
  <span class="paren2">(<span class="default">when <span class="paren3">(<span class="default">&lt; i 10</span>)</span>
    <span class="paren3">(<span class="default">format #t <span class="string">&quot;i=~a</span><span class="string">\n</span><span class="string">&quot;</span> i</span>)</span>
    <span class="paren3">(<span class="default">lp <span class="paren4">(<span class="default">1+ i</span>)</span></span>)</span></span>)</span></span>)</span>
<span class="paren1">(<span class="default">lp 5</span>)</span> <span class="comment">; =&gt; i=5, i=6, ...
</span>
<span class="comment">;; Similarly, with a named let
</span><span class="paren1">(<span class="default"><i><span class="symbol">let</span></i> lp <span class="paren2">(<span class="default"><span class="paren3">(<span class="default">i 0</span>)</span></span>)</span>
  <span class="paren2">(<span class="default">when <span class="paren3">(<span class="default">&lt; i 10</span>)</span>
    <span class="paren3">(<span class="default">format #t <span class="string">&quot;i=~a</span><span class="string">\n</span><span class="string">&quot;</span> i</span>)</span>
    <span class="paren3">(<span class="default">lp <span class="paren4">(<span class="default">1+ i</span>)</span></span>)</span></span>)</span></span>)</span> <span class="comment">; =&gt; i=0, i=1, ...
</span>
<span class="comment">;; how to get a range? just like range(0, 9)?
;; the original &#x27;iota&#x27; only accept one para
</span><span class="paren1">(<span class="default">iota 10</span>)</span> <span class="comment">; ==&gt; (0 1 2 3 4 5 6 7 8 9)
;; the &#x27;iota&#x27; in srfi-1 was extended 
</span><span class="paren1">(<span class="default">use-modules <span class="paren2">(<span class="default">srfi srfi-1</span>)</span></span>)</span>
<span class="comment">;; #&lt;procedure iota (count #:optional start step)&gt;
</span><span class="paren1">(<span class="default">iota 5 10</span>)</span> <span class="comment">; =&gt; (10 11 12 13 14) 
;; means from 10 count 5 times, each step +1 (plus one is default)
</span><span class="paren1">(<span class="default">iota 5 10 2</span>)</span> <span class="comment">; =&gt; (10 12 14 16 18)
;; from 10 count 5 times, each step +2
;; If you need a Python like range(5, 10) ==&gt; (5 6 7 8 9), try:
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> <span class="paren2">(<span class="default">range from to</span>)</span> <span class="paren2">(<span class="default">map <span class="paren3">(<span class="default"><i><span class="symbol">lambda</span></i> <span class="paren4">(<span class="default">x</span>)</span> <span class="paren4">(<span class="default">+ from x</span>)</span></span>)</span> <span class="paren3">(<span class="default">iota <span class="paren4">(<span class="default">- to from</span>)</span></span>)</span></span>)</span></span>)</span>
<span class="comment">;; EXECISE: you may find this &#x27;range&#x27; implementation is not so good,
;;          please optimize it if you can.
</span><span class="paren1">(<span class="default">range 5 10</span>)</span> <span class="comment">; =&gt; (5 6 7 8 9)
</span>
<span class="comment">;; how to do iteration?
</span><span class="paren1">(<span class="default">for-each display &#x27;<span class="paren2">(<span class="default">1 2 3 4 5</span>)</span></span>)</span>
<span class="comment">;; =&gt; 12345
</span><span class="paren1">(<span class="default">for-each <span class="paren2">(<span class="default"><i><span class="symbol">lambda</span></i> <span class="paren3">(<span class="default">i</span>)</span> <span class="paren3">(<span class="default">format #t <span class="string">&quot;i=~a</span><span class="string">\n</span><span class="string">&quot;</span> i</span>)</span></span>)</span>
          <span class="paren2">(<span class="default">iota 10</span>)</span></span>)</span> <span class="comment">; =&gt; i=0, i=1, ...
</span><span class="paren1">(<span class="default">for-each <span class="paren2">(<span class="default"><i><span class="symbol">lambda</span></i> <span class="paren3">(<span class="default">i</span>)</span> <span class="paren3">(<span class="default">format #t <span class="string">&quot;i=~a</span><span class="string">\n</span><span class="string">&quot;</span> i</span>)</span></span>)</span>
          <span class="paren2">(<span class="default">range 5 10</span>)</span></span>)</span> <span class="comment">; =&gt; i=5, i=6, ...
</span>
<span class="comment">;;; Iteration Over Other Sequences
;; `for&#x27; allows iteration over many other kinds of sequences:
;; lists, vectors, strings, sets, hash tables, etc...
</span><span class="paren1">(<span class="default">for-each display &#x27;<span class="paren2">(<span class="default">l i s t</span>)</span></span>)</span>
<span class="comment">;; =&gt; list
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> vector-for-each <span class="paren2">(<span class="default">@ <span class="paren3">(<span class="default">rnrs</span>)</span> vector-for-each</span>)</span></span>)</span>
<span class="comment">;; export vector-for-each from rnrs only
</span><span class="paren1">(<span class="default">vector-for-each display #<span class="paren2">(<span class="default">v e c t o r</span>)</span></span>)</span>
<span class="comment">;; =&gt; vector
</span><span class="paren1">(<span class="default">string-for-each display <span class="string">&quot;string&quot;</span></span>)</span>
<span class="comment">;; =&gt; string
;;; More Iterations
</span><span class="paren1">(<span class="default">do <span class="paren2">(<span class="default"><span class="paren3">(<span class="default">i 10 <span class="paren4">(<span class="default">1+ i</span>)</span></span>)</span> <span class="paren3">(<span class="default">j &#x27;<span class="paren4">(<span class="default">x y z</span>)</span> <span class="paren4">(<span class="default">cdr j</span>)</span></span>)</span></span>)</span> 
    <span class="paren2">(<span class="default"><span class="paren3">(<span class="default">null? j</span>)</span></span>)</span> <span class="comment">; if j is &#x27;(), just end the loop
</span>  <span class="paren2">(<span class="default">format #t <span class="string">&quot;~a:~a &quot;</span> i <span class="paren3">(<span class="default">car j</span>)</span></span>)</span></span>)</span>
<span class="comment">; =&gt; 0:x 1:y 2:z
</span>
<span class="comment">;;; Exceptions
</span>
<span class="comment">;; To catch exceptions, use the &#x27;catch&#x27; form
</span><span class="paren1">(<span class="default"><i><span class="symbol">catch</span></i> &#x27;my-error 
  <span class="paren2">(<span class="default"><i><span class="symbol">lambda</span></i> <span class="paren3">(<span class="default"></span>)</span> <span class="paren3">(<span class="default"><i><span class="symbol">throw</span></i> &#x27;my-error</span>)</span></span>)</span>
  <span class="paren2">(<span class="default"><i><span class="symbol">lambda</span></i> e <span class="paren3">(<span class="default">display <span class="string">&quot;oh~my error!</span><span class="string">\n</span><span class="string">&quot;</span></span>)</span></span>)</span></span>)</span>
<span class="comment">; =&gt; oh~my error!
</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 6. Mutation
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span>
<span class="comment">;; Use `set!&#x27; to assign a new value to an existing variable
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> n 5</span>)</span>
<span class="paren1">(<span class="default">set! n <span class="paren2">(<span class="default">1+ n</span>)</span></span>)</span>
n <span class="comment">; =&gt; 6
</span>
<span class="comment">;; Use fluid for explicitly mutable values
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> n* <span class="paren2">(<span class="default">make-fluid 5</span>)</span></span>)</span>
<span class="paren1">(<span class="default">fluid-set! n* <span class="paren2">(<span class="default">1+ <span class="paren3">(<span class="default">fluid-ref n*</span>)</span></span>)</span></span>)</span>
<span class="paren1">(<span class="default">fluid-ref n*</span>)</span> <span class="comment">; =&gt; 6
</span>
<span class="comment">;; Many Guile datatypes are immutable (pairs, lists, etc), some come in
;; both mutable and immutable flavors (strings, vectors, hash tables,
;; etc...)
</span>
<span class="comment">;; Use `vector&#x27; or `make-vector&#x27; to create mutable vectors
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> vec <span class="paren2">(<span class="default">vector 2 2 3 4</span>)</span></span>)</span>
<span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> wall <span class="paren2">(<span class="default">make-vector 100 &#x27;bottle-of-beer</span>)</span></span>)</span>
<span class="comment">;; Use vector-set! to update a slot
</span><span class="paren1">(<span class="default">vector-set! vec 0 1</span>)</span>
<span class="paren1">(<span class="default">vector-set! wall 99 &#x27;down</span>)</span>
vec <span class="comment">; =&gt; #(1 2 3 4)
</span>
<span class="comment">;; Create an empty mutable hash table and manipulate it
</span><span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> m3 <span class="paren2">(<span class="default">make-hash-table</span>)</span></span>)</span>
<span class="paren1">(<span class="default">hash-set! m3 &#x27;a 1</span>)</span>
<span class="paren1">(<span class="default">hash-set! m3 &#x27;b 2</span>)</span>
<span class="paren1">(<span class="default">hash-set! m3 &#x27;c 3</span>)</span>
<span class="paren1">(<span class="default">hash-ref m3 &#x27;a</span>)</span>   <span class="comment">; =&gt; 1
</span><span class="paren1">(<span class="default">hash-ref m3 &#x27;d 0</span>)</span> <span class="comment">; =&gt; 0
</span><span class="paren1">(<span class="default">hash-remove! m3 &#x27;a</span>)</span>

<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 7. Modules
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span>
<span class="comment">;; Modules let you organize code into multiple files and reusable
;; libraries; Make sure put all the module code in one file, since 
;; the modules split as files. And the module name should be same 
;; with the filename, say, module named (my-cake) is &#x27;my-cake.scm&#x27;,
;; and module named (mods my-cake) is &#x27;mods/my-cake.scm&#x27;,
;; (mods submods my-cake) ==&gt; &#x27;mods/submods/my-cake.scm&#x27;.
;; ---begin my-cake.scm---
</span><span class="paren1">(<span class="default"><i><span class="symbol">define-module</span></i> <span class="paren2">(<span class="default">my-cake</span>)</span> <span class="comment">; define a `cake&#x27; module based on racket/base
</span>  <span class="keyword">#:use-module</span> <span class="paren2">(<span class="default">ice-9 format</span>)</span> <span class="comment">; the pre-requisition of current module
</span>  <span class="keyword">#:export</span> <span class="paren2">(<span class="default">print-cake</span>)</span></span>)</span> <span class="comment">; function exported by the module
</span>
  <span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> <span class="paren2">(<span class="default">show fmt n ch</span>)</span> <span class="comment">; internal function
</span>    <span class="paren2">(<span class="default">format #t fmt <span class="paren3">(<span class="default">make-string n ch</span>)</span></span>)</span>
    <span class="paren2">(<span class="default">newline</span>)</span></span>)</span>

  <span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> <span class="paren2">(<span class="default">print-cake n</span>)</span>
    <span class="paren2">(<span class="default">show <span class="string">&quot;   ~a   &quot;</span> n <span class="character">#\.</span></span>)</span>
    <span class="paren2">(<span class="default">show <span class="string">&quot; .-~a-. &quot;</span> n <span class="character">#\|</span></span>)</span>
    <span class="paren2">(<span class="default">show <span class="string">&quot; | ~a | &quot;</span> n <span class="character">#\space</span></span>)</span>
    <span class="paren2">(<span class="default">show <span class="string">&quot;---~a---&quot;</span> n <span class="character">#\-</span></span>)</span></span>)</span>
<span class="comment">;; --end my-cake.scm---
</span>
<span class="comment">;; Be sure that the path of &#x27;my-cake.scm&#x27; is in your current 
;; %load-path list. Use `use-modules&#x27; to get all `provide&#x27;d names 
;; from a module.
</span><span class="paren1">(<span class="default">use-modules <span class="paren2">(<span class="default">my-cake</span>)</span></span>)</span> <span class="comment">; the &#x27; is for a local submodule
</span><span class="paren1">(<span class="default">print-cake 3</span>)</span>
<span class="comment">; (show &quot;~a&quot; 1 #\A) ; =&gt; error, `show&#x27; was not exported
</span>
<span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 8. Classes and Objects
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; TODO
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 9. Macros
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
</span>
<span class="comment">;; Macros let you extend the syntax of the language
</span>
<span class="comment">;; Let&#x27;s add a while loop
</span><span class="paren1">(<span class="default"><i><span class="symbol">define-syntax-rule</span></i> <span class="paren2">(<span class="default">while condition body ...</span>)</span>
  <span class="paren2">(<span class="default"><i><span class="symbol">let</span></i> <i><span class="symbol">loop</span></i> <span class="paren3">(<span class="default"></span>)</span>
    <span class="paren3">(<span class="default">when condition
      body ...
      <span class="paren4">(<span class="default"><i><span class="symbol">loop</span></i></span>)</span></span>)</span></span>)</span></span>)</span>

<span class="paren1">(<span class="default"><i><span class="symbol">let</span></i> <span class="paren2">(<span class="default"><span class="paren3">(<span class="default">i 0</span>)</span></span>)</span>
  <span class="paren2">(<span class="default">while <span class="paren3">(<span class="default">&lt; i  10</span>)</span>
    <span class="paren3">(<span class="default">display i</span>)</span>
    <span class="paren3">(<span class="default">set! i <span class="paren4">(<span class="default">1+ i</span>)</span></span>)</span></span>)</span></span>)</span>

<span class="comment">;; Macros are hygienic, you cannot clobber existing variables!
</span><span class="paren1">(<span class="default"><i><span class="symbol">define-syntax-rule</span></i> <span class="paren2">(<span class="default">swap! x y</span>)</span> <span class="comment">; -! is idomatic for mutation
</span>  <span class="paren2">(<span class="default"><i><span class="symbol">let</span></i> <span class="paren3">(<span class="default"><span class="paren4">(<span class="default">tmp x</span>)</span></span>)</span>
    <span class="paren3">(<span class="default">set! x y</span>)</span>
    <span class="paren3">(<span class="default">set! y tmp</span>)</span></span>)</span></span>)</span>

<span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> tmp 1</span>)</span>
<span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> a 2</span>)</span>
<span class="paren1">(<span class="default"><i><span class="symbol">define</span></i> b 3</span>)</span>
<span class="paren1">(<span class="default">swap! a b</span>)</span>
<span class="paren1">(<span class="default">format #t <span class="string">&quot;tmp = ~a; a = ~a; b = ~a</span><span class="string">\n</span><span class="string">&quot;</span> tmp a b</span>)</span> <span class="comment">; tmp is unaffected
</span>
<span class="comment">;; But they are still code transformations, for example:
</span><span class="paren1">(<span class="default"><i><span class="symbol">define-syntax-rule</span></i> <span class="paren2">(<span class="default">bad-while condition body ...</span>)</span>
  <span class="paren2">(<span class="default">when condition
    body ...
    <span class="paren3">(<span class="default">bad-while condition body ...</span>)</span></span>)</span></span>)</span>
<span class="comment">;; this macro is broken: it generates infinite code, if you try to use
;; it, the compiler will get in an infinite loop
</span></tt></pre>

</body></html>