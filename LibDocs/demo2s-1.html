<base target="_blank"><html><head><title>demo2s-1</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src="https://williamkpchan.github.io/lazyload.min.js"></script>
<script src='https://williamkpchan.github.io/mainscript.js'></script>
<script src="https://williamkpchan.github.io/commonfunctions.js"></script>
<script>
  var showTopicNumber = true;
  var topicEnd = "<br>";
  var bookid = "demo2s-1"
  var markerName = "h2"
</script>
<style>
body{width:80%;margin-left: 10%; font-size:24px;}
h1, h2 {color: gold;}
strong {color: orange;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px;}
</style></head><body onkeypress="chkKey()"><center>
<h1>demo2s-1</h1>
<a href="#mustWatch" class="red goldbs" target="_self">Must Watch!</a><br><br>
<div id="toc"></div></center><br><br>
<div id="mustWatch"><center><span class="red">MustWatch</span></center><br></div>
<pre><br><br>

<h2>Implementations</h2>

JavaScript is a scripting language designed to interact with web pages and is made up of the following
three distinct parts:

The Core (ECMAScript)
The Document Object Model (DOM)
The Browser Object Model (BOM)

JavaScript and ECMAScript are often used synonymously, but JavaScript is much more than just
what is defined in ECMA-262.

<h3>ECMAScript</h3>
ECMAScript, the language defined in ECMA-262, isn't tied to web browsers.

ECMA-262 defines this language as a base upon which
more-robust scripting languages may be built.

Web browsers are just one host environment in which
an ECMAScript implementation may exist.

Extensions, such as the Document Object Model (DOM), use ECMAScript's core types and syntax
to provide additional functionality that's more specific to the environment.

Other host environments
include <b>NodeJS</b>, a server-side JavaScript platform, and the increasingly obsolete Adobe Flash.

ECMA-262 describes the following parts of the language:

Syntax
Types
Statements
Keywords
Reserved words
Operators
Global objects

ECMAScript is a description of a language implementing all of the facets described in the
specification.

JavaScript implements ECMAScript, but so does Adobe <b>ActionScript</b>.

The different versions of ECMAScript are defined as editions.
For example, the ECMA-262 edition 7 is released in 2016.

<h3>The Document Object Model</h3>
The Document Object Model (DOM) is an application programming interface (API) for XML that
was extended for use in HTML.

The DOM maps out an entire page as a hierarchy of nodes.

Each part of an HTML or XML page is a type of node.

By creating a tree to represent a document, the DOM can control its content and structure.

Nodes can be removed, added, replaced, and modified by using the DOM API.

<h3>The Browser Object Model</h3>
The BOM deals with the browser window and frames.

For example, with BOM we can pop up new browser windows,
move, resize, and close browser windows

<h2>&lt;script> Element, attribute and its meaning</h2>

The primary method of inserting JavaScript into an HTML page is via the &lt;script> element.

There are six attributes for the &lt;script> element:

<table>
<thead><tr><th>Attribute</th><th>   Optional</th><th>   Description</th></tr></thead>
<tbody>
<tr><td>async</td><td>   Optional</td><td>    The script should begin downloading immediately.                                                               <br>   Should not prevent other actions on the page such as downloading resources or waiting for other scripts to load.<br>   Valid only for external script files.                                                                           </td></tr>
<tr><td>charset</td><td>   Optional</td><td>   The character set of the code specified using the src attribute.<br>   This attribute is rarely used.                                  </td></tr>
<tr><td><i>crossorigin</i></td><td>   Optional</td><td>     Configures the settings for the associated request.                                                                <br><i>crossorigin="anonymous"</i> will configure the request for the file to not have the credentials flag set.              <br><i>crossorigin="use-credentials"</i> will set the credentials flag, meaning the outgoing request will include credentials.</td></tr>
<tr><td>defer</td><td>   Optional</td><td>   Indicates that the execution of the script can safely be deferred until after the document's content has been completely parsed and displayed.<br>   Valid only for external scripts.                                                                                                              </td></tr>
<tr><td>integrity</td><td>   Optional</td><td>   Allows for verification of Sub resource Integrity (SRI) by checking the retrieved resource against a provided cryptographic signature.          <br>   If the signature of the retrieved resource does not match that specified by this attribute, the page will error and the script will not execute.</td></tr>
<tr><td>language</td><td>   Deprecated</td><td>   Originally indicated the scripting language being used by the code block</td></tr>
<tr><td>src</td><td>   Optional</td><td>   Indicates an external file that contains code to be executed.</td></tr>
<tr><td>type</td><td>   Optional</td><td>   Replaces language attribute.                                                                                                 <br>   indicates the content type, also called MIME type of the scripting language.                                                 <br>   If the value is module, the code is treated as an ES6 module and only then is eligible to use the import and export keywords.</td></tr>
</tbody></table>

<h2>&lt;script> Usage</h2>

There are two ways to use the &lt;script> element:

embed JavaScript code directly into the page or
include JavaScript from an external file.

To include inline JavaScript code, place JavaScript code inside the &lt;script> element directly,
as follows:

function test() {
    console.log("Hi!");
}
&lt;/script>

The JavaScript code contained inside a &lt;script> element is interpreted from top to bottom.

In the case of this example, a function definition is interpreted and stored inside the interpreter environment.

The rest of the page content is not loaded and/or displayed until after all of the code inside the &lt;script> element has been evaluated.

When using inline JavaScript code, you cannot have the string  "&lt;/script>"
anywhere in your code.

For example, the following code causes an error when loaded into a browser:

&lt;script>
function test() {
    console.log("&lt;/script>");
}
&lt;/script>

You can escape the "/" character, as follows:

&lt;script>
function test() {
   console.log("&lt;\/script>");
}
&lt;/script>

To include JavaScript from an external file, the <i>src</i> attribute is required.

The value of <i>src</i> is a URL linked to a file containing JavaScript code, like this:

&lt;script src="example.js">&lt;/script>

In this example, an external file named <i>example.js</i> is loaded into the page.

The file need only contain the JavaScript code that would occur between the opening &lt;script> and closing &lt;/script>
tags.

Processing of the page is halted while the external file is interpreted.

In XHTML documents, you can omit the closing tag, as in this example:

&lt;script src="example.js"/>

By convention, external JavaScript files have a <i>.js</i> extension.

If you don't use a <i>.js</i> extension, double-check that your server is returning the correct MIME type.

The &lt;script> elements are interpreted in the order in which
they appear in the page so long as the <i>defer</i> and <i>async</i> attributes are not present.

<h2>&lt;script> Tag Placement</h2>

Traditionally, all &lt;script> elements were placed within the &lt;head> element on a page, as in
this example:

&lt;!DOCTYPE html>
&lt;html>
    &lt;head>
         &lt;title>Example HTML Page&lt;/title>
         &lt;script src="example1.js">&lt;/script>
         &lt;script src="example2.js">&lt;/script>
    &lt;/head>
&lt;body>
&lt;!-- content here -->
&lt;/body>
&lt;/html>

Including all JavaScript files in the &lt;head> of a document means that
all of the JavaScript code must be downloaded, parsed, and interpreted before the page begins
rendering.

The rendering begins when the browser receives the opening &lt;body> tag.

This may cause a noticeable delay in page rendering.

For this reason, modern web applications typically include all JavaScript
references in the &lt;body> element, after the page content, as shown in this example:

&lt;!DOCTYPE html>
&lt;html>
 &lt;head>
 &lt;title>Example HTML Page&lt;/title>
 &lt;/head>
 &lt;body>
 &lt;!-- content here -->
 &lt;!-- content here -->
 &lt;!-- content here -->
 &lt;script src="example1.js">&lt;/script>
 &lt;script src="example2.js">&lt;/script>
 &lt;/body>
&lt;/html>

Using this approach, the page is completely rendered in the browser before the JavaScript code is
processed.

<h2>&lt;script> deferred Scripts</h2>

HTML 4.01 defines an attribute named <i>defer</i> for the &lt;script> element.

<i>defer</i> indicates that a script won't be changing the structure of the page as it executes.

The script can be run safely after the entire page has been parsed.

Setting the <i>defer</i> attribute on a &lt;script> element
signals to the browser that download should begin immediately but execution should be deferred:

&lt;!DOCTYPE html>
&lt;html>
  &lt;head>
  &lt;title>Example HTML Page&lt;/title>
  &lt;script defer src="example1.js">&lt;/script>
  &lt;script defer src="example2.js">&lt;/script>
  &lt;/head>
  &lt;body>
  &lt;!-- content here -->
  &lt;/body>
&lt;/html>

<h3>Note</h3>
Even though the two &lt;script> elements are included in the document &lt;head>,
they will not be executed until after the browser has received the closing &lt;/html> tag.

The <i>defer</i> attribute is supported only for external script files.

Some browsers may ignore this attribute.
We should put deferred scripts at the bottom of the page.

For XHTML documents, specify the defer attribute as defer="defer".

<h2>Asynchronous Scripts</h2>

HTML5 adds the <i>async</i> attribute for &lt;script> elements.

The <i>async</i> attribute changes the way the script is processed.

 <i>async</i> applies only to external scripts and signals the browser to begin downloading the file immediately.

Unlike defer, scripts marked as <i>async</i> are not guaranteed to execute in the order in which they are specified.
For example:

&lt;!DOCTYPE html>
&lt;html>
  &lt;head>
     &lt;title>Example HTML Page&lt;/title>
     &lt;script async src="example1.js">&lt;/script>
     &lt;script async src="example2.js">&lt;/script>
  &lt;/head>
  &lt;body>
     &lt;!-- content here -->
  &lt;/body>
&lt;/html>

In this code, the second script file might execute before the first.

There should be no dependencies between the two script files.

For XHTML documents, specify the async attribute as async="async".

<h2>&lt;noscript> element</h2>

The &lt;noscript> element was created to provide alternate content for browsers without JavaScript.

This element is useful for browsers that explicitly disable JavaScript.

The &lt;noscript> element can contain any HTML elements, aside from &lt;script>, that can be
included in the document &lt;body>.

Any content contained in a &lt;noscript> element will be displayed
under only the following two circumstances:

The browser doesn't support scripting.
The browser's scripting support is turned off.

If either of these conditions is met, then the content inside the &lt;noscript> element is rendered. In all
other cases, the browser does not render the content of &lt;noscript>.

Here is a simple example:

&lt;!DOCTYPE html>
&lt;html>
  &lt;head>
  &lt;title>Example HTML Page&lt;/title>
  &lt;script src="example1.js">&lt;/script>
  &lt;script src="example2.js">&lt;/script>
  &lt;/head>
  &lt;body>
  &lt;noscript>
    &lt;p>This page requires a JavaScript-enabled browser.&lt;/p>
  &lt;/noscript>
  &lt;/body>
&lt;/html>

In this example, a message is displayed to the user when the scripting is not available.

For scripting-enabled browsers, this message will never be seen even though it is still a part of the page.

<h2>Case-Sensitivity</h2>

ECMAScript's syntax borrows heavily from C and other C-like languages such as Java and Perl.

Javascript is case-sensitive.

The variables, function names, and operators are all case-sensitive.

JavaScript language keywords, variables,
function names, and other identifiers must always be typed with a consistent 
capitalization of letters. 

The while keyword, for example, must be typed "while," not "While"
or "WHILE." 

A variable named test is different from a variable named Test.

let test = 'a';
let Test = 'v';

console.log(test);
console.log(Test);

Output:



<h2>Identifiers</h2>

An identifier is the name of a variable, function, property, or function argument.

Identifiers may be one or more characters in the following format:

The first character must be a letter, an underscore _, or a dollar sign $.
All other characters may be letters, underscores, dollar signs, or numbers.

Letters in an identifier may include extended ASCII or Unicode letter characters.

JavaScript identifiers are used to name constants,
variables, properties, functions, and classes and to provide labels for certain loops in
JavaScript code. 

A JavaScript identifier must begin with a letter, an underscore (_), or
a dollar sign ($). 

Subsequent characters can be letters, digits, underscores, or dollar
signs.

Digits are not allowed as the first character.

By convention, ECMAScript identifiers use camel case, meaning that the first letter is lowercase and
each additional word is offset by a capital letter, like this:

firstSecondThird
myCarIsGood
doSomethingImportantAnd

These are all legal identifiers:

x
my_variable_<b>name</b>
v13
_dummy
$string
$$abc

Keywords, reserved words, <i>true</i>,  <i>false</i>, and <i>null</i> cannot be used as
identifiers.

let firstSecondThird = 'a';

console.log(firstSecondThird);

Output:



<h2>Comments</h2>

ECMAScript uses C-style comments for both single-line and block comments.

A single-line comment begins with two forward-slash characters, such as this:

// single line comment

A block comment begins with a forward slash and asterisk (/*) and ends with the opposite (*/), as in
this example:

/* This is a multi-line
comment */

<h3>Example</h3>
The following code adds some comments to a simple script.

//This is a test file

let a= 'a';

/*
  The following code output message to console
*/
console.log(a);

Output:



<h2>Strict Mode</h2>

ECMAScript strict mode is a different parsing and execution model for JavaScript.

To enable strict mode for an entire script, include the following at the top:

"use strict";

This is a pragma that tells supporting JavaScript engines to change into strict mode.

You may also specify just a function to execute in strict mode by including the pragma at the top of
the function body:

function doSomething() {
  "use strict";
  // function body
}

Strict mode changes how JavaScript is executed.
All modern browsers support strict mode.

"use strict" does  not  include  any  language  keywords:  
the  directive  is  just  an  expression
statement that consists of a special string literal (in single or double quotes).

"use strict" can appear only at the start of a script or at the start of a function body, before
any real statements have appeared.

<h2>Statements</h2>

Statements in ECMAScript are terminated by a semicolon.

Omitting the semicolon makes the parser determine where the end of a statement occurs.

let sum = a + b    // valid even without a semicolon - not recommended
let diff = a - b;  // valid - preferred

Even though a semicolon is not required at the end of statements,
you should always include one.

Including semicolons helps prevent errors of omission.

Including semicolons also improves performance in certain situations.

Multiple statements can be combined into a code block by using C-style syntax, beginning with a left
curly brace { and ending with a right curly brace }:

let test = true;

if (test) {
  test = false;
  console.log(test);
}

Control statements, such as if, require code blocks only when executing multiple statements.

It is a best practice to always use code blocks with control statements, even if there's
only one statement to be executed:

let test = true;

// valid, but error-prone and should be avoided
if (test)
   console.log(test);

// preferred
if (test) {
    console.log(test);
}

Using code blocks for control statements makes the intent clearer, and there's less chance for errors
when changes need to be made.

<h2>Keywords And Reserved Words</h2>

ECMA-262 describes a set of reserved keywords that have specific uses.

The keywords are reserved and cannot be used as identifiers or property names.

The complete list of keywords for ECMA-262, sixth edition is as follows:

break       do          in          <b>typeof</b>
case        else        instanceof  var
<b>catch</b>       export      new         void
<b>class</b>       <b>extends</b>     return      while
<b>const</b>       <b>finally</b>     <b>super</b>       with
continue    for         switch      yield
<b>debugger</b>    function    this
default     if          <b>throw</b>
delete      import      <b>try</b>

The specification also describes a set of future reserved words that cannot be used as identifiers
or property names.

Though reserved words don't have any specific usage in the language, they are
reserved for future use as keywords.

The following is the complete list of future reserved words defined in ECMA-262, sixth edition:

Always reserved:

<b>enum</b>

Reserved in strict mode:

implements  package     public
interface   protected   static
let         private

Reserved in module code:

await

These words may still not be used as identifiers but now can be used as property names in objects.

We should avoid using both keywords and reserved words as both identifiers and
property names to ensure compatibility with past and future ECMAScript editions.

<h2>Try Out</h2>

<h3>With Browser Developer Tools</h3>
We try out short JavaScript code in a browser with the following steps:

Open up the web developer tools in your web browser (with F12, Ctrl-Shift-I, or Command-Option-I) and
Select the Console tab.
Type code at the prompt
See the results as you type.

Browser developer tools often appear as panes at the bottom or right of the browser
window,  but  you  can  usually  detach  them  as  separate  windows, 
which is often quite convenient.

<h3>Node.js</h3>
Another way to try out JavaScript code is to download and install Node from  
<i>https://nodejs.org</i>. 

Once Node is installed on your system, you can simply open a Terminal
window and type node to begin an interactive JavaScript session like this one:

$ node/*w  w  w    .d    e  mo    2 s   .  co  m  */
Welcome to Node.js v15.2.1.
Type ".help" for more information.
> .help
.break    Sometimes you get stuck, this gets you out
.clear    Alias for .break
.editor   Enter editor mode
.exit     Exit the REPL
.help     Print this help message
.load     Load JS from a file into the REPL session
.save     Save all evaluated commands in this REPL session to a file

Press Ctrl+C to abort current expression, Ctrl+D to exit the REPL
>
> let x = 2, y = 3;
undefined
> x + y
5
> (x === 2) &amp;&amp; (y === 3)
true
> (x > 3) || (y &lt; 3)
false

<h3>Hello World</h3>
You can write your code in a text editor. 

From there, you can copy and paste to the JavaScript console or into a Node session. 

Or you can save your code to a file with file name extension .js and then run 
that file of JavaScript code with Node:

$ node yourFileName.js

If you use Node in a non interactive manner like this, it won't automatically print out
the value of all the code you run. 

You  can use the function  console.<i>log</i>() to display text and other JavaScript 
values in your terminal
window  or  in  a  browser's  developer  tools  console.  

So, for  example,  if  you  create  a hello.js file containing this line of code:

console.log("Hello World!");

and  execute  the  file  with  node hello.js,  you'll  see  the  message  "Hello  World!"
printed out.

If you want to see that same message printed out in the JavaScript console of a web
browser, create a new file named hello.html, and put this text in it:

&lt;script src="hello.js">&lt;/script>

Then load hello.html into your web browser using a file:// URL like this one:

file:///Users/username/javascript/hello.html

Open the developer tools window to see the greeting in the console.

You can drag and drop your html file to browser.

<h2>Quick Syntax Reference</h2>

This section presents a quick introduction, through code examples, to the JavaScript
language. 

Anything following double slashes is an English-language comment.

They explain the JavaScript code.

<h3>Variable</h3>
A variable is a symbolic name for a value.

Variables are declared with the let keyword:

let x;        // Declare a variable named x.

Values can be assigned to variables with an = sign
x = 0;        // Now the variable x has the value 0
x             // => 0: A variable evaluates to its value.

<h3>Data Types</h3>
JavaScript supports several types of values

x = 1;               // Numbers.
x = 0.01;            // Numbers can be integers or reals.
x = "hello world";   // Strings of text in quotation marks.
x =  'JavaScript';   // Single quote marks also delimit strings.
x = true;            // A Boolean value.
x = false;           // The other Boolean value.
x = null;            // Null is a special value that means "no value."
x = undefined;       // Undefined is another special value like null.

<h3>Object</h3>
JavaScript also have objects and arrays. 

JavaScript's most important datatype is the object.

An object is a collection of name/value pairs, or a string to value map.

let book = {               // Objects are enclosed in curly braces.
    topic: "JavaScript",   // The property "topic" has value "JavaScript."
    edition: 7             // The property "edition" has value 7
};                         // The curly brace marks the end of the object.

Access the properties of an object with . or []:

book.topic            // => "JavaScript"
book["edition"]       // => 7: another way to access property values.
book.author = "CSS";  // Create new properties by assignment.
book.contents = {};   // {} is an empty object with no properties.

book.contents?.c?.s   // => undefined: book.contents has no c property.

 JavaScript also supports arrays of values:

let myArray = [2, 3, 5, 7]; // An array of 4 values, delimited with [ and ].
myArray[0]                  // => 2: the first element (index 0) of the array.
myArray.<b>length</b>              // => 4: how many elements in the array.
myArray[myArray.<b>length</b>-1]   // => 7: the last element of the array.
myArray[4] = 9;             // Add a new element by assignment.
myArray[4] = 11;            // Or alter an existing element by assignment.
let empty = [];             // [] is an empty array with no elements.
empty.<b>length</b>                // => 0

 Arrays and objects can hold other arrays and objects:

let points = [             // An array with 2 elements.
    {x: 0, y: 0},          // Each element is an object.
    {x: 1, y: 1}
];
let data = {                 // An object with 2 properties
    trial1: [[1,2], [3,4]],  // The value of each property is an array.
    trial2: [[2,3], [4,5]]   // The elements of the arrays are arrays.
};

<h3>Operators</h3>
To form expressions in JavaScript, use operators:

Operators act on values to produce a new value.

Arithmetic operators are simple:

3 + 2        // => 5: addition
3 - 2        // => 1: subtraction
3 * 2        // => 6: multiplication
3 / 2        // => 1.5: division
"3" + "2"    // => "32": + adds numbers and concatenates strings

JavaScript defines some shorthand arithmetic operators

let count = 0;    // Define a variable
count++;          // Increment the variable
count--;          // Decrement the variable
count += 2;       // Add 2: same as count = count + 2;
count *= 3;       // Multiply by 3: same as count = count * 3;
count             // => 6: variable names are expressions, too.

Equality and relational operators test whether two values are equal,
 unequal, less than, greater than, and so on. 

They evaluate to true or false.

let x = 2, y = 3;     // These = signs are assignment, not equality tests
x === y               // => false: equality
x  !== y              // => true: inequality
x &lt; y                 // => true: less-than
x &lt;= y                // => true: less-than or equal
x > y                 // => false: greater-than
x >= y                // => false: greater-than or equal
"two" === "three"     // => false: the two strings are different
"two" > "three"       // => true: "tw" is alphabetically greater than "th"
false === (x > y)     // => true: false is equal to false

 Logical operators combine or invert boolean values

(x === 2) &amp;&amp; (y === 3) // => true: both comparisons are true. &amp;&amp; is AND
(x > 3)  || (y &lt; 3)    // => false: neither comparison is true. || is OR
!(x === y)             // => true: ! inverts a boolean value

<h3>Function</h3>
A function is  a  named  and  parameterized  block  of  JavaScript  code. 

You can define them once,  and  then  invoke  them many times.  

Functions are parameterized blocks of JavaScript code that we can invoke.

function myFunc(x) {// Define a function named "myFunc" with parameter "x"
    return x + 1;  // Return a value one larger than the value passed in
}                  // Functions are enclosed in curly braces

myFunc(y)           // => 4: y is 3, so this invocation returns 3+1

let square = function(x) { // Functions are values and can be assigned to vars
    return x * x;          // Compute the function's value
};                         // Semicolon marks the end of the assignment.

square(myFunc(y))           // => 16: invoke two functions in one expression

We can use => to separate the argument list from the function body, 
and functions defined this  way  are  known  as  arrow  functions.  

Arrow  functions  are  most  commonly  used
when  you  want  to  pass  an  unnamed  function  as  an  argument  to  another  function.

The preceding code looks like this when rewritten to use arrow functions:

<b>const</b> myFunc = x => x + 1;   // The input x maps to the output x + 1
<b>const</b> square = x => x * x;  // The input x maps to the output x * x
myFunc(y)                    // => 4: function invocation is the same
square(myFunc(y))            // => 16

When we use functions with objects, we get methods:

When functions are assigned to the properties of an object, we call them "methods."  

All JavaScript objects including arrays have methods:

let a = [];         // Create an empty array
a.push(1,2,3);      // The push() method adds elements to an array
a.reverse();        // reverse the order of elements

 We can define our own methods. 

The "this" keyword refers to the object on which the method is defined.

The points array from earlier.

points.dist = function() { // Define a method to compute distance between points
    let p1 = this[0];      // First element of array we're invoked on
    let p2 = this[1];      // Second element of the "this" object
    let a = p2.x-p1.x;     // Difference in x coordinates
    let b = p2.y-p1.y;     // Difference in y coordinates
    return <b>Math</b>.sqrt(a*a + // The Pythagorean theorem
                     b*b); // Math.sqrt() computes the square root
};
points.dist()              // => Math.sqrt(2): distance between our 2 points

<h3>Statement</h3>
JavaScript statements include conditionals and loops using the syntax
 of C, C++, Java, and other languages.

if statement

function abs(x) {          // compute the absolute value.
    if (x >= 0) {          // if statement
        return x;          // executes this code if the comparison is true.
    }                      // This is the end of the if clause.
    else {                 // The optional else clause executes its code if
        return -x;         // the comparison is false.
    }                      // Curly braces optional when 1 statement per clause.
}                          // Note return statements nested inside if/else.
abs(-10) === abs(10)       // => true

for of loop

function sum(array) {      // sum elements of an array
    let sum = 0;           // Start with an initial sum of 0.
    for(let x of array) {  // Loop over array, assigning each element to x.
        sum += x;          // Add the element value to the sum.
    }                      // This is the end of the loop.
    return sum;            // Return the sum.
}

while loop

function factorial(n) {    // A function to compute factorials
    let product = 1;       // Start with a product of 1
    while(n > 1) {         // Repeat statements in {} while expr in () is true
        product *= n;      // Shortcut for product = product * n;
        n--;               // Shortcut for n = n - 1
    }                      // End of loop
    return product;        // Return the product
}

for loop

function factorial2(n) {   // Another version using a different loop
    let i, product = 1;    // Start with 1
    for(i=2; i &lt;= n; i++)  // Automatically increment i from 2 up to n
        product *= i;      // Do this each time. {} not needed for 1-line loops
    return product;        // Return the factorial
}

<h3>Class</h3>
JavaScript supports an object-oriented programming style.  

The following code shows how to define a JavaScript class to represent
2D  geometric  points.  

Objects  that  are  instances  of  this  class  have  a  single  method,
named <i>distance</i>(), that computes the distance of the point from the origin:

<b>class</b> Point {              // class names are capitalized.
    <b>constructor</b>(x, y) {    // Constructor function to initialize new instances.
        this.x = x;        // this refers to the new object being initialized.
        this.y = y;        // store function arguments as object properties.
    }                      // no return for constructor functions.

    distance() {           // Method to compute distance from origin to point.
        return <b>Math</b>.sqrt(  // Return the square root of x square + y square.
            this.x * this.x +  // this refers to the Point object on which
            this.y * this.y    // the distance method is invoked.
        );
    }
}

// Use the Point() constructor function with "new" to create Point objects
let p = new Point(1, 1);   // The geometric point (1,1).

// Now use a method of the Point object p
console.log(p.distance());

<h2>Variables</h2>

ECMAScript variables are loosely typed.
A variable can hold any type of data.

Every variable is a named placeholder for a value.

There are three keywords that can be used to declare a variable:

var
const
let

var is supported for all versions and let and const were introduced in ECMAScript 6.

var a = 'a';
console.log(a);

let b = 'b';
console.log(b);

<b>const</b> c = 'c'
console.log(c);

Output:

<h3>Note</h3>
The introduction of <i>let</i> and <i>const</i> in ECMAScript 6 bring better tooling to the Javascript language.

It increases precision of declaration scope and semantics.

<h3>Don't Use var</h3>
With <i>let</i> and <i>const</i>, we no longer need to use <i>var</i> in our code base.

<h3>Prefer const Over let</h3>
Using const declarations allows the browser runtime to enforce constant variables.

We should declare variables as <i>const</i> unless they know they will need to
reassign its value at some point.

<h2>Use 'var' Keyword to define variables</h2>

To define a variable, use the <i>var</i> operator followed by the variable name, like this:

var myValue;

This code defines a variable named <i>myValue</i> that can be used to hold any value.

ECMAScript supports variable initialization,
so it's possible to define the variable and set its value at the same time, as in this example:

var myValue = "hi";

Here, <i>myValue</i> is defined to hold a string value of  "hi".

Doing this initialization doesn't mark the
variable as being a string type.

It is the assignment of a value to the variable.

It is still possible to not only change the value stored in the variable but also change the type of value, such as this:

var myValue = "hi";
myValue = 100;  // legal, but not recommended

In this example, the variable <i>myValue</i> is first defined as having the string value  "hi" and then
overwritten with the numeric value 100.

Although it's not recommended to switch the data type that a
variable contains, it is completely valid in ECMAScript.

<h3>More than one</h3>
If you need to define more than one variable, you can do it using a single statement, separating each
variable and optional initialization with a comma like this:

var myValue = "hi",
    found = false,
    age = 12;

Here, three variables are defined and initialized.

Because ECMAScript is loosely typed,
variable initializations using different data types may be combined into a single statement.

Inserting line breaks and indenting the variables helps to improve readability.

When you are running in strict mode, you cannot define variables named <i>eval</i> or <i>arguments</i>.

Doing so results in a syntax error.

<h2>var Declaration Scope</h2>

Using the <i>var</i> operator to define a variable makes it local to the function
scope where it was defined.

For example, defining a variable inside of a function using <i>var</i> means
that the variable is destroyed as soon as the function exits, as shown here:

function test() {
   var myValue = "hi";  // local variable
}
test();
console.log(myValue); // error!

Here, the <i>myValue</i> variable is defined within a function using <i>var</i>.

The function <i>test</i>() creates the variable and assigns its value.

Immediately after that, the variable is destroyed so
the last line in this example causes an error.

<h3>Global</h3>
We can define a variable globally by simply omitting the <i>var</i> operator as follows:

function test() {
   myValue = "hi";  // global variable
}
test();
console.log(myValue); // "hi"

By removing the <i>var</i> operator from the example, the <i>myValue</i> variable becomes global.

When the function <i>test</i>() is called, the variable is defined and becomes accessible outside of the function once
it has been executed.

Although it's possible to define global variables by omitting the var operator,
this approach is not recommended.

Global variables defined locally are hard to maintain and cause confusion.

Strict mode throws a ReferenceError when an undeclared variable is assigned a value.

<h2>var Declaration Hoisting</h2>

When using <i>var</i>, the following is possible because variables declared using that keyword are hoisted
to the top of the function scope:

function foo() {
  console.log(age);
  var age = 26;
}
foo(); // undefined

Output:

This does not throw an error because the ECMAScript runtime technically treats it like this:

function foo() {
  var age;
  console.log(age);
  age = 26;
}
foo();  // undefined

Output:

This is "hoisting" where the interpreter pulls all variable declarations to the top of its scope.

It also allows you to use redundant var declarations without penalty:

function foo() {
     var age = 16;
     var age = 26;
     var age = 36;
     console.log(age);
}
foo();  // 36

<h2>let Declarations</h2>

<i>let</i> keyword works like <i>var</i> with some important differences.

<i>let</i> is block scoped, but <i>var</i> is function scoped.

if (true) {
  var <b>name</b> = 'Javascript';
  console.log(<b>name</b>);  // Javascript
}
console.log(<b>name</b>);    // Javascript

if (true) {
  let age = 11;
  console.log(age);   // 11
}
console.log(age);     // ReferenceError: age is not defined

Here, the <i>age</i> variable cannot be referenced outside the if block because its scope does not extend
outside the block.

Block scope is a subset of function scope, so any scope limitations that
apply to <i>var</i> declarations will also apply to <i>let</i> declarations.

A <i>let</i> declaration does not allow for any redundant declarations within a block scope.

Doing so will result in an error:

var <b>name</b>;
var <b>name</b>;  //no error

let age;
let age;  // SyntaxError; identifier 'age' has already been declared

The JavaScript engine keeps track of identifiers used for variable declarations.

Nesting identifiers behaves as you would
expect with no errors because no redeclaration is occurring:

var <b>name</b> = 'CSS';
console.log(<b>name</b>);  // 'CSS'
if (true) {
  var <b>name</b> = 'Javascript';
  console.log(<b>name</b>);  // 'Javascript'
}

let age = 12;
console.log(age);  // 12
if (true) {
  let age = 11;
  console.log(age);  // 11
}

The declaration redundancy errors are not a function of order, and are not
affected if let is mixed with <i>var</i>.

The two keywords specify how
the variables exist inside the relevant scope.

var <b>name</b>;
let <b>name</b>;  // SyntaxError

let age;
var age;   // SyntaxError

<h2>let declarations does not support hoisting:</h2>

<i>let</i> declarations cannot be used in a way that assumes hoisting:

// name is hoisted, since it is defined by var
console.log(<b>name</b>);  // undefined
var <b>name</b> = 'Javascript';

// age is not hoisted, since it is defined by let
console.log(age);  // ReferenceError: age is not defined
let age = 26;

JavaScript engines knows that the let declarations that appear later in a block.

These variables cannot be referenced before the actual declaration
occurs.

Any attempted references to these variables
from the segment of execution that occurs before the declaration
will throw a <b>ReferenceError</b>.

<h2>let Global Declarations</h2>

When declaring variables using <i>let</i> in the global context, variables will not
attach to the window object as they do with <i>var</i>.

var <b>name</b> = 'Javascript';
console.log(<b>window</b>.<b>name</b>);  // 'Javascript'

let age = 26;
console.log(<b>window</b>.age);   // undefined

However, let declarations will still occur inside the global block scope, which will persist for the
lifetime of the page.

let age = 26;

function test(){
   console.log(age);
}
test();

Output:

You must ensure your page does not attempt duplicate declarations in
order to avoid throwing a SyntaxError.

<h2>let Declaration in for Loops</h2>

Prior to <i>let</i>, <i>for</i> loop definition involved using an iterator variable whose definition
would go outside the loop body:

for (var i = 0; i &lt; 5; ++i) {
  // do loop things
}
console.log(i);  // 5

This is no longer a problem when switching to let declarations, as the iterator variable will be
scoped only to the for loop block:

for (let i = 0; i &lt; 5; ++i) {
  // do loop things
}
console.log(i);  // ReferenceError: i is not defined

When using <i>var</i>, there is a problem in the singular declaration and modification of
the iterator variable:

for (var i = 0; i &lt; 5; ++i) {
  <b>setTimeout</b>(() => console.log(i), 0)
}
// You might expect this to console.log 0, 1, 2, 3, 4
// It will actually console.log 5, 5, 5, 5, 5

This happens because the loop exits with its iterator variable still set to the value that caused the
loop to exit: 5.

When the timeouts later execute, they reference this same variable, and consequently
console.log its final value.

When using <i>let</i> to declare the loop iterator, behind the scenes the JavaScript engine will
actually declare a new iterator variable each loop iteration.

Each <i>setTimeout</i> references that separate
instance, and therefore it will console.log the expected value: the value of the iterator variable
when that loop iteration was executed.

for (let i = 0; i &lt; 5; ++i) {
  <b>setTimeout</b>(() => console.log(i), 0)
}
// console.logs 0, 1, 2, 3, 4

This per-iteration declarative behavior is applicable for all styles of for loops, including for-in and
for-of loops.

<h2>const Declarations</h2>

<i>const</i> must be initialized with a value, and that value cannot be redefined after declaration.

Attempting to modify a const variable will result in a runtime error.

<b>const</b> age = 26;
age = 36;  // TypeError: assignment to a constant

const still disallows redundant declaration

<b>const</b> <b>name</b> = 'Javascript';
<b>const</b> <b>name</b> = 'CSS';  // SyntaxError

const is still scoped to blocks

<b>const</b> <b>name</b> = 'Javascript';
if (true) {
   <b>const</b> <b>name</b> = 'CSS';
}
console.log(<b>name</b>);  // Javascript

The <i>const</i> declaration is only enforced with respect to the reference to the variable that it points to.

If a const variable references an object, it does not violate the <i>const</i> constraints to modify properties
inside that object.

<b>const</b> person = {};
person.<b>name</b> = 'Javascript';  // ok

You cannot use <i>const</i> to declare for loop iterators:

for (<b>const</b> i = 0; i &lt; 10; ++i) {}
   // TypeError: assignment to constant variable

You can use <i>const</i> to declare a for loop variable that is not modified.

This is especially relevant in the case of for-of and for-in loops:

Define j as constant inside for loop

let i = 0;
for (<b>const</b> j = 7; i &lt; 5; ++i) {
  console.log(j);
}

Output:

Use <i>const</i> in for-in loop

for (<b>const</b> key in {a: 1, b: 2}) {
  console.log(key);
}

Output:

Use <i>const</i> in for-of loop

for (<b>const</b> value of [1,2,3,4,5]) {
  console.log(value);
}

Output:



<h2>Data Types</h2>

There are six simple data types or primitive types in ECMAScript:

undefined
null,
Boolean,
Number,
String,
Symbol.

There is also one complex data type called Object.

Object is an unordered list of name-value pairs.

let a = undefined;
console.log(a);
a = null;
console.log(a);

a = true;
console.log(a);

a = 123.123;
console.log(a);

a = 'string';
console.log(a);

a = Symbol();
console.log(a);

Output:



<h2>Data Type Overview and Definitions</h2>

JavaScript types can be divided into two categories: 

primitive types and
object types.

<h3>Primitive types</h3>
JavaScript's primitive types include numbers, strings, and booleans.  

The special JavaScript values  <i>null</i>  and  <i>undefined</i> are primitive values, 
but they are not  numbers,  strings,  or  booleans.  

ES6 adds a new special-purpose type, known as <b>Symbol</b>, that enables the 
definition of language extensions without harming backward compatibility. 

<h3>Object</h3>
Any JavaScript value that is not a number, a string, a boolean, a symbol, null, or unde
fined is an object. 

An object is a collection of
properties  where  each  property  has  a  name  and  a  value. 

An ordinary JavaScript object is an unordered collection of named values. 

<h3>Array</h3>
The language  also  defines  a  special  kind  of  object,  known  as  an  array,  that  represents  an
ordered collection of numbered values. 

The JavaScript language includes special syntax for working with arrays, and arrays have some special behavior that distinguishes
them from ordinary objects. 

<h3>Other</h3>
JavaScript defines a number of other useful object types. 

A Set object represents a set of values. 

A Map object represents a mapping from keys to values. 

Various "typed array" types facilitate operations on arrays of
bytes and other binary data. 

The <b>RegExp</b> type represents String patterns and enables
matching, searching, and replacing operations on strings. 

The Date type
represents dates and times. 

Error and its subtypes represent errors that can arise when executing JavaScript code. 

JavaScript functions and classes are not just
part  of  the  language  syntax,  they  are  values  that  can  be  manipulated  by
JavaScript programs. 

<h3>Note</h3>
JavaScript's object types are  mutable and its primitive types are  immutable. 

JavaScript liberally converts values from one type to another. 

If a program expects a
string, for example, and you give it a number, it will automatically convert the num
ber  to  a  string  for  you.  

And  if  you  use  a  non-boolean  value  where  a  boolean  is
expected,  JavaScript  will  convert  accordingly.  

<h2>typeof Operator to check data type</h2>

The <i>typeof</i> operator determine the data type in Javascript.

Using the typeof operator on a value returns one of the following strings:

"undefined" if the value is undefined
"boolean" if the value is a Boolean
"string" if the value is a string
"number" if the value is a number
"object" if the value is an object (other than a function) or null
"function" if the value is a function
"symbol" if the value is a Symbol

<h3>Example</h3>
The typeof operator is called like this:

let message = "some string";
console.log(<b>typeof</b> message);   // "string"
console.log(<b>typeof</b>(message));  // "string"
console.log(<b>typeof</b> 5);        // "number"

In this example, both a variable <i>message</i> and a numeric literal are passed into the typeof operator.

<i>typeof</i> is an operator and not a function, no parentheses are required although
they can be used.

<h3>Note</h3>
<i>typeof</i> might return a confusing but technically correct value.

Calling typeof null returns a value of  "object", as the special value null is considered to be
an empty object reference.

Technically, functions are considered objects in ECMAScript and don't
represent another data type.

<h2>undefined Type</h2>

The <i>undefined</i> type has only one value, which is the special value <i>undefined</i>.

When a variable is
declared using <i>var</i> or let but not initialized, it is assigned the value of <i>undefined</i> as follows:

let message;
console.log(message == undefined);  // true

In this example, the variable <i>message</i> is declared without initializing it.

When compared with the literal value of undefined, the two are equal.

This example is identical to the following:

let message = undefined;
console.log(message == undefined);  // true

Here the variable <i>message</i> is explicitly initialized to be <i>undefined</i>.

This is unnecessary because, by default, any uninitialized variable gets the value of undefined.

You should never explicitly set a variable to be <i>undefined</i>.

The literal <i>undefined</i> value is provided for comparison.

A variable containing the value of <i>undefined</i> is different from a variable that hasn't been
defined at all.

Consider the following:

let message;   // this variable is declared
               // but has a value of undefined

console.log(message);  // "undefined"
console.log(age);      // causes an error

In this example, the first console.log displays the variable message,
which is  "undefined".

In the second console.log, an undeclared variable called <i>age</i> is passed into the console.<i>log</i>() function,
which causes an error because the variable hasn't been declared.

The <i>typeof</i> operator returns  "undefined" when called on an uninitialized variable, but it also
returns  "undefined" when called on an undeclared variable, which can be a bit confusing.

Consider this example:

let message;   // this variable is declared but has a value of undefined

console.log(<b>typeof</b> message);  // "undefined"
console.log(<b>typeof</b> age);      // "undefined"

In both cases, calling typeof on the variable returns the string  "undefined".

Logically, this makes sense because no real operations can be performed with either variable even though they are
technically different.

We should always initialize variables.

That way, when <i>typeof</i> returns  "undefined", you'll know that it's because a given variable hasn't been
declared rather than was simply not initialized.

<h3>falsy</h3>
The value <i>undefined</i> is falsy and you can use if to check it.

There are many other possible values as falsy,
so be careful when using if statement to test <i>undefined</i>:

let message;   // this variable is declared but has a value of undefined
// 'age' is not declared

if (message) {
  // This block will not execute
}

if (!message) {
  // This block will execute
}

if (age) {
  // This will throw an error
}

<h2>null Type</h2>

The Null type has only one value: the special value <i>null</i>.

Logically, a null value is an empty object pointer, which is why typeof returns  "object" when it's passed a
null value in the following example:

let myValue = null;
console.log(<b>typeof</b> myValue);   // "object"

When defining a variable that is meant to later hold an object, we should initialize the variable
to null as opposed to anything else.

You can explicitly check for the value null to determine if the variable has been filled with an object reference at a later time, such as in this example:

let myValue = null;
if (myValue != null) {
  // do something with myValue
}

The value undefined is a derivative of null, so ECMA-262 defines them to be superficially equal
as follows:

console.log(null == undefined);   // true

Using the equality operator (==) between null and undefined always returns true.

<h3>falsy</h3>
The <i>null</i> type is falsy; therefore, you can use <i>if</i> statement to check it.

let myValue = null;
let age;

if (myValue) {
  // This block will not execute
}

if (!myValue) {
  // This block will execute
}

if (age) {
  // This block will not execute
}

if (!age) {
  // This block will execute
}

<h2>Boolean Type</h2>

The Boolean type has only two literal values: <i>true</i> and <i>false</i>.

These values are distinct from numeric values, so true is not equal to 1, and
false is not equal to 0.

Assignment of Boolean values to variables is as follows:

let found = true;
let lost = false;

The Boolean literals <i>true</i> and <i>false</i> are case-sensitive, so True and False
are valid as identifiers but not as Boolean values.

let found = true;
let lost = false;

console.log(found === 0); //false
console.log(found === 1); //false

console.log(lost === 0);  //false
console.log(lost === 1);  //false

console.log(found == 0); //false
console.log(found == 1); //true

console.log(lost == 0);  //true
console.log(lost == 1);  //false



<h2>Convert values to Boolean using Boolean() convert function</h2>

All types of values have Boolean equivalents in ECMAScript.

To convert a value into its Boolean equivalent, the special <b>Boolean</b>() casting function
is called, like this:

let message = "hi!";
let messageAsBoolean = <b>Boolean</b>(message);

In this example, the string <i>message</i> is converted into a Boolean value and stored in
<i>messageAsBoolean</i>.

The <b>Boolean</b>() casting function can be called on any type of data and will always return
a Boolean value.

The rules for when a value is converted to true or false depend on the data type
as much as the actual value.

The following table outlines the various data types and their specific conversions.

<table>
<thead><tr><th>Data Type</th><th>   Values Converted To True</th><th>   Values Converted To False</th></tr></thead>
<tbody>
<tr><td>Boolean</td><td>   true</td><td>   false</td></tr>
<tr><td>String</td><td>   Any nonempty string</td><td>   "" (empty string)</td></tr>
<tr><td>Number</td><td>   Any nonzero number  <br>   (including infinity)</td><td>   0, NaN</td></tr>
<tr><td>Object</td><td>   Any object</td><td>   null</td></tr>
<tr><td>Undefined</td><td>   n/a</td><td>   undefined</td></tr>
</tbody></table>
The flow-control statements, such as the if statement,
automatically perform this Boolean conversion, as shown here:

let message = "hi!";
if (message) {
  console.log("Value is true");
}

In this example, the console.log will be displayed because the string message is automatically
converted into its Boolean equivalent (true).

It's important to understand what variable you're using in a
flow-control statement because of this automatic conversion.

<h2>Integer Literal Octal and hexadecimal value</h2>

JavaScript's  primary  numeric  type,  Number,  is  used  to  represent  integers  and  to
approximate real numbers. 

ECMAScript Number uses the IEEE-754 format to represent both integers and floating-point values.

The  JavaScript  number  format  allows  you  to  exactly  represent  all  integers  between
-9,007,199,254,740,992  and  9,007,199,254,740,992,  inclusive.  

To support the various types of numbers, there are several different number literal formats.

<h3>Literal</h3>
The most basic number literal format is that of a decimal integer, which can be entered directly as
shown here:

let intNum = 55;  // integer

In  a  JavaScript  program,  a  base-10  integer  is  written  as  a  sequence  of  digits.  
For example:

0
3
10000000

<h3>Octal</h3>
Integers can also be represented as either octal (base 8) or hexadecimal (base 16) literals.

For an octal literal, the first digit must be a zero (0) followed by a sequence of octal digits (numbers 0 through 7).

If a number out of this range is detected in the literal, then the leading zero is ignored and the number
is treated as a decimal, as in the following examples:

let octalNum1 = 070;  // octal for 56
let octalNum2 = 079;  // invalid octal - interpreted as 79
let octalNum3 = 08;   // invalid octal - interpreted as 8

Octal literals are invalid when running in strict mode and will cause the JavaScript engine to throw a
syntax error.

<h3>hexadecimal</h3>
To create a hexadecimal literal, you must make the first two characters 0x (case insensitive), followed
by any number of hexadecimal digits (0 through 9, and A through F).

Letters may be in uppercase or lowercase.

Here's an example:

let hexNum1 = 0xA;   // hexadecimal for 10
let hexNum2 = 0x1f;  // hexadecimal for 31

Numbers created using octal or hexadecimal format are treated as decimal numbers in all arithmetic
operations.

<h3>Binary</h3>
In  ES6  and  later,  you  can  also  express  integers  in  binary  (base  2)  
or  octal  (base  8)
using the prefixes 0b and 0o (or 0B and 0O):

0b10101  // => 21:  (1*16 + 0*8 + 1*4 + 0*2 + 1*1)
0o377    // => 255: (3*64 + 7*8 + 7*1)

<h2>Floating-Point Values</h2>

To define a floating-point value, you must include a decimal point and at least one number after the
decimal point.

Although an integer is not necessary before a decimal point, it is recommended.

Here are some examples:

let floatNum1 = 1.1;
let floatNum2 = 0.1;
let floatNum3 = .1;   // valid, but not recommended

You can use underscores within numeric literals to break long literals up into chunks
that are easier to read:

let billion = 1_000_000_000;   // Underscore as a thousands separator.
let bytes = 0x89_AB_CD_EF;     // As a bytes separator.
let bits = 0b0001_1101_0111;   // As a nibble separator.
let fraction = 0.123_456_789;  // Works in the fractional part, too.

When there is no digit after the
decimal point, the number becomes an integer.

If the number being represented is a whole number (such as 1.0), it will be converted into an integer, as in this example:

let floatNum1 = 1.;    // missing digit after decimal - interpreted as integer 1
let floatNum2 = 10.0;  // whole number - interpreted as integer 10

<h3>E-notation</h3>
Javascript floating-point values can be represented using e-notation.

E-notation is used to indicate a number that should be multiplied by 10 raised to a given power.

The format of e-notation in ECMAScript is to have a number, integer or floating-point,
followed by an uppercase or lowercase letter E, followed by the power of 10 to multiply by.

Consider the following:

let floatNum = 3.125e7;  // equal to 31250000

In this example, <i>floatNum</i> is equal to 31,250,000 and it is represented in a more compact
form using e-notation.

The notation says, "Take 3.125 and multiply it by 10000000."

E-notation can also be used to represent very small numbers, such as 0.00000000000000003, which
can be written more succinctly as 3e-17.

By default, ECMAScript converts any floating-point value
with at least six zeros after the decimal point into e-notation (for example, 0.0000003 becomes 3e-7).

<h3>Accuracy</h3>
Floating-point values are accurate up to 17 decimal places but are far less accurate in arithmetic
computations than whole numbers.

For instance, adding 0.1 and 0.2 yields 0.30000000000000004
instead of 0.3.

These small rounding errors make it difficult to test for specific floating-point values.
Consider this example:

<b>const</b> a = 0.1;
<b>const</b> b = 0.2;

if (a + b == 0.3) {  // avoid!
  console.log("You got 0.3.");
}else{
  console.log("not 0.3.");
}

Output:

Here, the sum of two numbers is tested to see if it's equal to 0.3.

You should never test for specific floating-point values.

<h3>Note</h3>
The rounding errors are caused by how the floating-point arithmetic is done in IEEE-754-based numbers and is not
unique to ECMAScript.

Other languages that use the same format have the same issues.

<h2>Number Range of Values, Infinity, and negative infinity</h2>

The smallest number that can be represented in ECMAScript is stored in <b>Number.MIN_VALUE</b>
and is 5e-324 on most browsers; the largest number is stored in <b>Number.MAX_VALUE</b> and is
1.7976931348623157e+308 on most browsers.

If a calculation results in a number that cannot be
represented by JavaScript's numeric range, the number automatically gets the special value of
<b>Infinity</b>.

Any negative number that can't be represented is <i>-Infinity</i> (negative infinity), and any
positive number that can't be represented is <b>Infinity</b> (positive infinity).

If a calculation returns either positive or negative Infinity, that value cannot be used in any
further calculations.

To determine if a value is finite, there is the <i>isFinite</i>() function.

This function returns true only if the argument is between the minimum and
the maximum values, as in this example:

let result = <b>Number</b>.MAX_VALUE + <b>Number</b>.MAX_VALUE;
console.log(<b>isFinite</b>(result));  // false

You can get the values of positive and negative Infinity by accessing
*Number.NEGATIVE _INFINITY* and *Number.POSITIVE _INFINITY*.

These properties contain the values <i>-Infinity</i> and <b>Infinity</b>, respectively.

<h2>Float value NaN, Not a Number</h2>

There is a special numeric value called <b>NaN</b>, short for Not a Number, which indicates the returned value is Not a Number.

For example, in ECMAScript, dividing a number by 0 returns <b>NaN</b>, which allows other processing to continue.

The value <b>NaN</b> has a couple of unique properties.

First, any operation involving NaN always returns NaN, For example NaN /20.

Second, <b>NaN</b> is not equal to any value, including <b>NaN</b>.

For example, the following returns false:

console.log(<b>NaN</b> == <b>NaN</b>);  // false

<h3>isNaN()</h3>
ECMAScript provides the <i>isNaN</i>() function.

<i>isNaN</i>() function accepts a single argument to determine if the value is "not a number".

When a value is passed into
<i>isNaN</i>(), an attempt is made to convert it into a number.

Some nonnumerical values convert into numbers directly, such as the string  "10" or a Boolean value.

Any value that cannot be converted into a number causes the function to return true.

Consider the following:

console.log(isNaN(<b>NaN</b>));     // true
console.log(isNaN(10));      // false - 10 is a number
console.log(isNaN("10"));    // false - can be converted to number 10
console.log(isNaN("demo2s.com"));  // true - cannot be converted to a number
console.log(isNaN(true));    // false - can be converted to number 1

This example tests five different values.

The first test is on the value NaN itself, which returns true.

The next two tests use numeric 10 and the string "10", which both return false
because the numeric value for each is 10.

The string  "demo2s.com" cannot be converted into a
number, so the function returns true.

The Boolean value of true can be converted into the number 1,
so the function returns false.

<i>isNaN</i>() can be applied to objects.

In that case, the object's <i>valueOf</i>() method is first called to determine if the returned value can be converted into a number.

If not, the <i>toString</i>() method is called and its returned value is tested as well.

<h2>Number Conversions with Number() function, convert values into numbers</h2>

There are three functions to convert nonnumeric values into numbers: the <b>Number</b>() casting function, the <i>parseInt</i>() function, and the <i>parseFloat</i>() function.

The first function, <b>Number</b>(), can be
used on any data type; the other two functions are used specifically for converting strings to numbers.

The <b>Number</b>() function performs conversions based on these rules:

<i>1.</i> When applied to Boolean values, true and false get converted into 1 and 0, respectively.

<i>2.</i> When applied to numbers, the value is returned.

<i>3.</i> When applied to null, <b>Number</b>() returns 0.

<i>4.</i> When applied to undefined, <b>Number</b>() returns NaN.

<i>5.</i> When applied to strings, the following rules are applied:

If the string contains only numeric characters, optionally preceded by a plus or minus sign, it is always converted to a decimal number, so <b>Number</b>("1") becomes 1, <b>Number</b>("123") becomes 123, and <b>Number</b>("011") becomes 11.  Leading zeros are ignored.
If the string contains a valid floating-point format, such as  "1.1", it is converted into the appropriate floating-point numeric value. Leading zeros are ignored.
If the string contains a valid hexadecimal format, such as  "0xf", it is converted into an integer that matches the hexadecimal value.
If the string is empty, it is converted to 0.
If the string contains anything other than these previous formats, it is converted into NaN.

<i>6.</i> When applied to objects, the <i>valueOf</i>() method is called and the returned value is converted based on the previously described rules. If that conversion results in NaN, the <i>toString</i>() method is called and the rules for converting strings are applied.

. Here are some concrete examples:

let num1 = <b>Number</b>("hi!");  // NaN
let num2 = <b>Number</b>("");     // 0
let num3 = <b>Number</b>("00002");// 2
let num4 = <b>Number</b>(true);   // 1

In these examples, the string  "hi!" is converted into NaN because it has no corresponding numeric value, and the empty string is converted into 0.

The string  "00002" is converted to the number 2 because the initial zeros are ignored.

Last, the value true is converted to 1.

<h2>Convert String to Number with parseInt()</h2>

<i>parseInt</i>() function is usually used when you are dealing with integers.

The <i>parseInt</i>() function examines the string to see if it matches a number pattern.

Leading white space in the string is ignored until the first non-white space character is found.

If this first character isn't a number, the minus sign, or the plus sign, <i>parseInt</i>() always returns NaN, which means the empty string returns NaN.

If the first character is a number,
plus, or minus, then the conversion goes on to the second character and continues on until either the end of the string is reached or a nonnumeric character is found.

For instance,  "1234demo" is converted to 1234 because  "demo" is completely ignored.

"22.5" will be converted to 22 because the decimal is not a valid integer character.

If the first character in the string is a number, the <i>parseInt</i>() function also recognizes the various integer formats: decimal, octal, and hexadecimal.

The string begins with  "0x" is interpreted as a hexadecimal integer; if it begins with  "0" followed by a number, it is interpreted as an octal value.

Here are some conversion examples to illustrate what happens:

let num1 = <b>parseInt</b>("1234demo");  // 1234
let num2 = <b>parseInt</b>("");          // NaN
let num3 = <b>parseInt</b>("0xA");       // 10 - hexadecimal
let num4 = <b>parseInt</b>(2.5);         // 2
let num5 = <b>parseInt</b>("70");        // 70 - decimal
let num6 = <b>parseInt</b>("0xf");       // 15 - hexadecimal

<b>parseInt</b>("3 asdf ")     // => 3
<b>parseFloat</b>(" 3.14 meters")   // => 3.14
<b>parseInt</b>("-12.34")           // => -12
<b>parseInt</b>("0xFF")             // => 255
<b>parseInt</b>("0xff")             // => 255
<b>parseInt</b>("-0XFF")            // => -255
<b>parseFloat</b>(".1")             // => 0.1
<b>parseInt</b>("0.1")              // => 0
<b>parseInt</b>(".1")               // => NaN: integers can't start with "."
<b>parseFloat</b>("$72.47")         // => NaN: numbers can't start with "$"

<h3>radix</h3>
<i>parseInt</i>() provides a second argument: the radix.

If you know that the value you're parsing is in hexadecimal format,
you can pass in the radix 16 as a second argument and ensure that the correct parsing
will occur, as shown here:

let num = <b>parseInt</b>("0xAF", 16);     // 175

In fact, by providing the hexadecimal radix, you can leave off the leading  "0x" and the conversion will work as follows:

let num1 = <b>parseInt</b>("AF", 16);  // 175
let num2 = <b>parseInt</b>("AF");      // NaN

In this example, the first conversion occurs correctly, but the second conversion fails.

The radix is passed in on the first line, telling <i>parseInt</i>() that it will be passed a hexadecimal string; the second line sees that the first character is not a number and stops automatically.

Passing in a radix can change the outcome of the conversion. Consider the following:

let num1 = <b>parseInt</b>("10", 2);   // 2 - parsed as binary
let num2 = <b>parseInt</b>("10", 8);   // 8 - parsed as octal
let num3 = <b>parseInt</b>("10", 10);  // 10 - parsed as decimal
let num4 = <b>parseInt</b>("10", 16);  // 16 - parsed as hexadecimal

<b>parseInt</b>("11", 2)     // => 3: (1*2 + 1)
<b>parseInt</b>("ff", 16)    // => 255: (15*16 + 15)
<b>parseInt</b>("zz", 36)    // => 1295: (35*36 + 35)
<b>parseInt</b>("077", 8)    // => 63: (7*8 + 7)
<b>parseInt</b>("077", 10)   // => 77: (7*10 + 7)

We should always include a radix to avoid errors.

Most of the time you'll be parsing decimal numbers, so it's good to
always include 10 as the second argument.

<h2>Convert String to Number with parseFloat()</h2>

The <i>parseFloat</i>() function looks at each character starting in position 0.

It continues to parse the string until it reaches either the end of the string or a
character that is invalid in a floating-point number.

This means that a decimal point (.) is valid the first
time it appears, but a second decimal point is invalid and the rest of the string is ignored, resulting in "2.34.5" being converted to 2.34.

<i>parseFloat</i>() always ignores the initial zeros.

<i>parseFloat</i>() recognizes any of the floating-point formats.

Hexadecimal numbers always become 0 in <i>parseFloat</i>().

Because <i>parseFloat</i>() parses only decimal values, there is no radix mode.

If the string represents a whole number without decimal point or only a zero after the decimal point, <i>parseFloat</i>() returns an integer.

Here are some examples:

let num1 = <b>parseFloat</b>("1234demo");  // 1234 - integer
let num2 = <b>parseFloat</b>("0xA");       // 0
let num3 = <b>parseFloat</b>("2.5");       // 2.5
let num4 = <b>parseFloat</b>("2.34.5");    // 2.34
let num5 = <b>parseFloat</b>("0907.6");    // 907.6
let num6 = <b>parseFloat</b>("3.125e7");   // 31250000

<h2>Number Format</h2>

Formatting and parsing numbers are common tasks in computer programs.

JavaScript has specialized functions and methods that provide more precise control over
number-to-string and string-to-number conversions.

The  <i>toString</i>() method defined by the Number class accepts an optional argument
that specifies a radix, or base, for the conversion. 

If you do not specify the argument,
the conversion is done in base 10. 

However, you can also convert numbers in other
bases (between 2 and 36). 

For example:

let n = 17;
let binary = "0b" + n.<b>toString</b>(2);  // binary == "0b10001"
let octal = "0o" + n.<b>toString</b>(8);   // octal == "0o21"
let hex = "0x" + n.<b>toString</b>(16);    // hex == "0x11"

You may want to convert numbers to
strings in ways that give you control over the number of decimal places or the 
number of significant digits in the output, or you may want to control whether 
exponential  notation  is  used.  

The  Number  class  defines  three  methods  for  these  kinds  of
number-to-string conversions. 

<i>toFixed</i>() converts a number to a string with a specified  number  of  digits  after  the  decimal  point.  

It  never  uses  exponential  notation.

<i>toExponential</i>() converts a number to a string using exponential notation, with one
digit before the decimal point and a specified number of digits after the decimal point. 

<i>toPrecision</i>() converts a number to a string with the number of significant
digits you specify. 

It uses exponential notation if the number of significant digits is
not  large  enough  to  display  the  entire  integer  portion  of  the  number.  

Note  that  all
three methods round the trailing digits or pad with zeros as appropriate. 

Consider the following examples:

let n = 123456.789;
n.toFixed(0)         // => "123457"
n.toFixed(2)         // => "123456.79"
n.toFixed(5)         // => "123456.78900"
n.toExponential(1)   // => "1.2e+5"
n.toExponential(3)   // => "1.235e+5"
n.toPrecision(4)     // => "1.235e+5"
n.toPrecision(7)     // => "123456.8"
n.toPrecision(10)    // => "123456.7890"

<h2>Object Type</h2>

Objects in ECMAScript are created
by using the <i>new</i> operator followed by the name of the object type to create.

Developers create their
own objects by creating instances of the <b>Object</b> type and adding properties and/or methods to it, as
shown here:

let o = new <b>Object</b>();

ECMAScript requires parentheses to be used only when providing arguments to the constructor.

If there are no arguments, as in the following example, then the
parentheses can be omitted safely. It is not recommended to do this.

let o = new <b>Object</b>;  // legal, but not recommended

The Object type in ECMAScript is the base from which all other objects are derived.

All of the properties and methods of the Object type are also
present on other, more specific objects.

Each Object instance has the following properties and methods:

<table>
<thead><tr><th>Method</th><th>   Description</th></tr></thead>
<tbody>
<tr><td>constructor</td><td>   The function that was used to create the object.                  <br>   In the previous example, the constructor is the <b>Object</b>() function.</td></tr>
<tr><td><i>hasOwnProperty</i>(propertyName )</td><td>   Indicates if the given property exists on the object instance (not on the prototype). The property name must be specified as a string (for example, o.<i>hasOwnProperty</i>("name")).</td></tr>
<tr><td><i>isPrototypeof</i>(object)</td><td>   Determines if the object is a prototype of another object.</td></tr>
<tr><td><i>propertyIsEnumerable</i>(propertyName )</td><td>   Indicates if the given property can be enumerated using the for-in statement (discussed later in this chapter). As with <i>hasOwnProperty</i>(), the property name must be a string.</td></tr>
<tr><td><i>toLocaleString</i>()</td><td>   Returns a string representation of the object that is appropriate for the locale of execution environment.</td></tr>
<tr><td><i>toString</i>()</td><td>   Returns a string representation of the object.</td></tr>
<tr><td><i>valueOf</i>()</td><td>   Returns a string, number, or Boolean equivalent of the object. It often returns the same value as <i>toString</i>().</td></tr>
</tbody></table>
Because Object is the base for all objects in ECMAScript, every object has these base properties and methods.

<h2>Arbitrary Precision Integers with BigInt</h2>

BigInt is a numeric type whose values are integers. 

The type was added to JavaScript
mainly to allow the representation of 64-bit integers. 

BigInt values can have thousands  or  even  millions  of  digits.

<h3>Literal</h3>
BigInt  literals  are  written  as  a  string  of  digits  followed  by  a  
lowercase  letter  <i>n</i>.  

By default, the are in base 10, but you can use the 0b, 0o, and 0x prefixes for binary, octal,
and hexadecimal BigInts:

1234n                // A not-so-big BigInt literal
0b111111n            // A binary BigInt
0o7777n              // An octal BigInt
0x8000000000000000n  // => 2n**63n: A 64-bit integer

You  can  use  <b>BigInt</b>()  as  a  function  for  converting  regular  JavaScript  numbers  or
strings to BigInt values:

BigInt(<b>Number</b>.MAX_SAFE_INTEGER)     // => 9007199254740991n

//from string
let string = "1" + "0".repeat(100); // 1 followed by 100 zeros.
BigInt(string)                      // => 10n**100n: one googol

Arithmetic with BigInt values works like arithmetic with regular JavaScript numbers,
except that division drops any remainder and rounds down (toward zero):

1000n + 2000n  // => 3000n
3000n - 2000n  // => 1000n
2000n * 3000n  // => 6000000n
3000n / 997n   // => 3n: the quotient is 3
3000n % 997n   // => 9n: and the remainder is 9
(2n ** 131071n) - 1n  // A Mersenne prime with 39457 decimal digits

Although the standard +,  -, *, /, %, and <i>**</i> operators work with BigInt, 
you  may  not  mix  operands  of  type  BigInt  with  regular  number
operands. 

Comparison  operators,  by  contrast,  do  work  with  mixed  numeric  types:

1 &lt; 2n     // => true
2 > 1n     // => true
0 == 0n    // => true
0 === 0n   // => false: the === checks for type equality as well

The  bitwise  operators work  with  BigInt  operands.

None of the functions of the Math object accept BigInt operands, however.

<h2>Primitive And Reference Values</h2>

ECMAScript variables has two different types of data: primitive values and reference values.

<h3>Primitive values</h3>
Primitive values are simple atomic pieces of data, while reference values are objects that may be made up of multiple values.

When a value is assigned to a variable, the JavaScript engine must determine if it's a primitive or a reference value.

The six primitive types are:

undefined,
null,
Boolean,
Number,
String, and
Symbol.

These variables are accessed by value, because you
are manipulating the actual value stored in the variable.

<h3>Reference values</h3>
Reference values are objects stored in memory.

JavaScript does not permit direct access of memory locations, so direct manipulation of the object's memory space is not allowed.

When you manipulate an object, you're really working on a reference to that object rather than the actual object itself.

For this reason, such values are said to be accessed by reference.

<h2>Dynamic Properties on Primitive And Reference Values</h2>

When you work with reference values, you can add, change, or delete properties and methods at any time.

Consider this example:

let person = new <b>Object</b>();
person.<b>name</b> = "CSS";
console.log(person.<b>name</b>);  // "CSS"

Here, an object is created and stored in the variable <i>person</i>.

Next, a property called <i>name</i> is added
and assigned the string value of  "CSS".

The new property is accessible until the object is destroyed or the property is explicitly removed.

Primitive values can't have properties added to them even though attempting to do so won't cause an error.

Here's an example:

let <b>name</b> = "CSS";
<b>name</b>.age = 12;
console.log(<b>name</b>.age);  // undefined

Here, a property called <i>age</i> is defined on the string name and assigned a value of 12.

On the next line, however, the property is gone.

Only reference values can have properties defined dynamically for later use.

Note that the instantiation of a primitive type can be accomplished using only the primitive literal form.

If you were to use the <i>new</i> keyword, JavaScript will create an Object type, but one that behaves like a primitive.

Here's an example to distinguish between the two:

let <b>name</b>1 = "CSS";
let <b>name</b>2 = new <b>String</b>("Javascript");
<b>name</b>1.age = 27;
<b>name</b>2.age = 26;
console.log(<b>name</b>1.age);  // undefined
console.log(<b>name</b>2.age);  // 26
console.log(<b>typeof</b> <b>name</b>1); // string
console.log(<b>typeof</b> <b>name</b>2); // object

<h2>Copying Values on Primitive And Reference Values</h2>

Javascript primitive and reference values act differently when
copied from one variable to another.

<h3>Primitive value</h3>
When a primitive value is assigned from one variable to another,
the value stored on the variable object is created and copied into the location for the new variable.

Consider the following example:

let num1 = 5;
let num2 = num1;

Here, <i>num1</i> contains the value of 5.

When <i>num2</i> is initialized to <i>num1</i>, it also gets the value of 5.

This value is completely separate from the one
that is stored in num1 because it's a copy of that value.

Each of these variables can now be used separately with no side effects.

<h3>Reference value</h3>
When a reference value is assigned from one variable to another, the value              stored on the variable object is copied into the location for the new
variable.

This value is a pointer to an object variable object after copy stored on the heap.

Once the operation is complete, two variables point to
exactly the same object, so changes to one are reflected on the other, as in
the following example:

let obj1 = new <b>Object</b>();
let obj2 = obj1;
obj1.<b>name</b> = "CSS";
console.log(obj2.<b>name</b>);  // "CSS"

In this example, the variable <i>obj1</i> is filled with a new instance of an
object.

This value is then copied into <i>obj2</i>, meaning that both variables
are now pointing to the same object.

When the property name is set on <i>obj1</i>, it can later be accessed
from <i>obj2</i> because they both point to the same object.

<h2>Argument Passing on Primitive And Reference Values</h2>

All function arguments in ECMAScript are passed by value.

The value outside of the
function is copied into an argument on the inside of the function the same way a value is copied from one variable to another.

If the value is primitive, then it acts just like a primitive variable copy, and if
the value is a reference, it acts just like a reference variable copy.

<h3>Pass by value vs Pass by reference</h3>
When an argument is passed by value, the value is copied into a local variable.

When an argument is passed by reference, the
location of the value in memory is stored into a local variable, which means that changes to the local variable are reflected outside of the function.

Pass by reference is not supported by Javascript.

<h3>Example</h3>
Consider the following example:

function addTen(num) {
  num += 10;
  return num;
}

let count = 20;
let result = addTen(count);
console.log(count);   // 20 - no change
console.log(result);  // 30

Here, the function <i>addTen</i>() has an argument, <i>num</i>, which is essentially a local variable.

When called, the variable <i>count</i> is passed in as an argument.

This variable has a value of 20, which is copied into the argument <i>num</i> for use inside of <i>addTen</i>().

Within the function, the argument <i>num</i> has its value changed by adding 10, but this doesn't change the original variable <i>count</i> that exists outside of
the function.

The argument <i>num</i> and the variable <i>count</i> are not related and they just have the same value.

If <i>num</i> had been passed by reference (which cannot be done by Javascript), then the value of count would have changed to 30 to reflect the change made inside the function.

<h3>Pass reference type</h3>
For reference type value such as Javascript objects, for example:

function setName(obj) {
  obj.<b>name</b> = "CSS";
}

let person = new <b>Object</b>();
setName(person);
console.log(person.<b>name</b>);  // "CSS"

In this code, an object is created and stored in the variable <i>person</i>.

This object is then passed into the <i>setName</i>() method, where it is copied into <i>obj</i>.

Inside the function, <i>obj</i> and <i>person</i> both point to the same object.

The result is that <i>obj</i> is accessing an object by reference, even though it was passed
into the function by value.

When the name property is set on <i>obj</i> inside the function, this change is
reflected outside the function, because the object that it points to exists globally on the heap.

<h3>NOT passed by reference</h3>
Javascript object is NOT passed by reference.

To prove that objects are passed by value, consider the following modified code:

function setName(obj) {
  obj.<b>name</b> = "CSS";
  obj = new <b>Object</b>();
  obj.<b>name</b> = "HTML";
}

let person = new <b>Object</b>();
setName(person);
console.log(person.<b>name</b>);  // "CSS"

This example added two lines to redefine <i>obj</i> as a new object with a different name.

When person is passed into <i>setName</i>(), its name property is set to  "CSS".

Then the variable <i>obj</i> is set to be a new object and its name property is set to  "HTML".

If person were passed by reference, then person would automatically be changed to point to the object whose name is  "HTML".

However, when person.name is accessed again, its value is  "CSS", indicating that the original reference remained intact
even though the argument's value changed inside the function.

When <i>obj</i> is overwritten inside the
function, it becomes a pointer to a local object.

That local object is destroyed as soon as the function
finishes executing.

You can think function arguments in ECMAScript as local variables.

<h2>Determining Type using instanceof operator</h2>

The <i>typeof</i> operator can determine if a variable is a primitive type.

We can use <i>typeof</i> operator to determine if a variable is a string,
number, Boolean, or undefined.

If the value is an object or null, then typeof returns  "object", as in
this example:

let s = "CSS";
let b = true;
let i = 2;
let u;
let n = null;
let o = new <b>Object</b>();
console.log(<b>typeof</b> s);   // string
console.log(<b>typeof</b> i);   // number
console.log(<b>typeof</b> b);   // boolean
console.log(<b>typeof</b> u);   // undefined
console.log(<b>typeof</b> n);   // object
console.log(<b>typeof</b> o);   // object

<i>typeof</i> operator has little use for reference values.

<h3>instanceof</h3>
<i>instanceof</i> operator can check object type.

ECMAScript instanceof operator is used with the following syntax:

result = variable instanceof <b>constructor</b>

The <i>instanceof</i> operator returns true if the variable is an instance of the given reference type.

Consider this example:

console.log(person instanceof <b>Object</b>);   // is the variable person an Object?
console.log(colors instanceof <b>Array</b>);    // is the variable colors an Array?
console.log(pattern instanceof <b>RegExp</b>);  // is the variable pattern a RegExp?

All reference values, by definition, are instances of <b>Object</b>, so the instanceof operator always
returns true when used with a reference value and the <b>Object</b> constructor.

Similarly, if instanceof
is used with a primitive value, it will always return false, because primitives aren't objects.

<h2>Execution Context And Scope</h2>

The JavaScript execution context of a variable or function defines what other data it has access to, as well as how it should behave.

Each execution context has an associated variable object upon which
all of its defined variables and functions exist.

This object is not accessible by code but is used behind
the scenes to handle data.

<h3>Global</h3>
The global execution context is the outermost one.

Depending on the host environment for an
ECMAScript implementation, the object representing this context may differ.

In web browsers, the global context is said to be that of the <i>window</i> object, so all global variables and functions defined with <i>var</i> are created as properties and methods on the window object.

Declarations using <i>let</i> and <i>const</i> at the top level are not defined in the global
context, but they are resolved identically on the scope chain.

When an execution context has executed all of its code, it is destroyed.

The global context isn't destroyed until the application exits, such as when a web page is closed or a web browser is shut down.

<h3>Function</h3>
Each function call has its own execution context.

Whenever code execution flows into a function, the
function's context is pushed onto a context stack.

After the function has finished executing, the stack
is popped, returning control to the previously executing context.

<h3>Scope</h3>
When code is executed in a context, a scope chain of variable objects is created.

The scope chain provides ordered access to all variables and functions that an execution context has access to.

The top of the scope chain is the variable object of the context whose code is
executing.

If the context is a function, then the activation object is used as the variable object.

This pattern continues until the global context is reached; the
global context's variable object is always the last of the scope chain.

Identifiers are resolved by navigating the scope chain in search of the identifier name.

The search
always begins at the front of the chain and proceeds to the back until the identifier is found.

If the identifier isn't found, typically an error occurs.

Consider the following code:

var color = "blue";

function changeValue() {
  if (color === "blue") {
    color = "red";
  } else {
    color = "blue";
  }
}
changeValue();

In this simple example, the function <i>changeValue</i>() has a scope chain with two objects in it: its
own variable object, where the arguments object is defined, and the global context's variable object.

The variable color is therefore accessible inside the function, because it can be found in the scope chain.

<h3>Local</h3>
The locally defined variables can be used interchangeably with global variables in a local context.

Here's an example:

var color = "blue";

function changeValue() {
    let anotherValue = "red";

    function swapValues() {
        let tempValue = anotherValue;
        anotherValue = color;
        color = tempValue;
        // color, anotherValue, and tempValue are all accessible here
    }

    // color and anotherValue are accessible here, but not tempValue
    swapValues();
}
// only color is accessible here
changeValue();

There are three execution contexts in this code:

global context,
the local context of <i>changeValue</i>(), and
the local context of <i>swapValues</i>().

The global context has one variable, color, and one function, <i>changeValue</i>().

The local context of <i>changeValue</i>() has one variable named <i>anotherValue</i>
and one function named <i>swapValues</i>(), but it can also access the variable color from the global context.

The local context of <i>swapValues</i>() has one variable, named <i>tempValue</i>, that is accessible only within that context.

Neither the global context nor the local context of <i>swapValues</i>() has
access to <i>tempValue</i>.

Within <i>swapValues</i>(), though, the variables of the other two contexts are fully
accessible because they are parent execution contexts.

The connection between the contexts is linear and ordered.

Each context can search up the scope chain for variables and
functions, but no context can search down the scope chain into another execution context.

There are three objects in the scope chain for the
local context of <i>swapValues</i>(): the <i>swapValues</i>() variable object, the
variable object from <i>changeValue</i>(), and the global variable object.

The local context of <i>swapValues</i>() begins its search for variable and
function names in its own variable object before moving along the
chain.

The scope chain for the <i>changeValue</i>() context has only two
objects: its own variable object and the global variable object.

This means that it cannot access the context of <i>swapValues</i>().

NOTE  Function arguments are considered to be variables and follow the same
access rules as any other variable in the execution context.

<h2>Execution Context And Scope Chain Augmentation</h2>

Even though there are only two primary types of execution contexts, global and function,
there are other ways to augment the scope chain.

Certain statements
cause a temporary addition to the front of the scope chain that is later removed after code execution.

There are two times when this occurs, specifically when execution enters either of the following:

The catch block in a try-catch statement
A with statement

Both of these statements add a variable object to the front of the scope chain.

For the <i>with</i> statement,
the specified object is added to the scope chain; for the <i>catch</i> statement, a new variable object is created and contains a declaration for the thrown error object.

Consider the following:

function buildUrl() {
  let qs = "?debug=true";

  with(<b>location</b>){
    let url = href + qs;
  }

  return url;
}

In this example, the <i>with</i> statement is acting on the location object, so location itself is added to the front of the scope chain.

There is one variable, <i>qs</i>, defined in the <i>buildUrl</i>() function.

When the variable <i>href</i> is referenced, it's actually referring to location.href, which is in its own variable object.

When the variable qs is referenced, it's referring to the variable defined in <i>buildUrl</i>(), which
is in the function context's variable object.

Inside the <i>with</i> statement is a variable declaration for url,
which becomes part of the function's context and can, therefore, be returned as the function value.

<h2>Function Scope Declaration Using var</h2>

When a variable is declared using <i>var</i>, it is automatically added to the most immediate context available.

In a function, the most immediate one is the function's local context; in a with statement, the
most immediate is the function context.

If a variable is initialized without first being declared, it gets
added to the global context automatically, as in this example:

function add(num1, num2) {
  var sum = num1 + num2;
  return sum;
}

let result = add(10, 20);  // 30
console.log(sum);          // causes an error: sum is not a valid variable

Here, the function <i>add</i>() defines a local variable named sum that contains the result of an addition  operation.

This value is returned as the function value, but the variable sum isn't accessible outside the function.

If the <i>var</i> keyword is omitted from this example, <i>sum</i> becomes accessible after <i>add</i>() has  been called, as shown here:

function add(num1, num2) {
 sum = num1 + num2;
 return sum;
}

let result = add(10, 20);  // 30
console.log(sum);        // 30

Here, the variable <i>sum</i> is initialized to a value without ever having been declared using <i>var</i>.

When <i>add</i>() is called, <i>sum</i> is created in the global context and continues to exist even after the function has completed, allowing you to access it later.

It's advisable to always declare variables before initializing them.

In strict mode, initializing variables without declaration causes an error.

A <i>var</i> declaration will be brought to the top of the function or global scope and before any existing code inside it.

This is referred to as "hoisting".

This allows you to safely use a hoisted variable anywhere in the same scope without consideration for whether or not it was declared yet.

Here is an example of two equivalent code in the global scope:

var <b>name</b> = "css";

// This is equivalent to:
<b>name</b> = 'css';
var <b>name</b>;

Here is an example of two equivalent functions:

function fn1() {
 var <b>name</b> = 'css';
}

// This is equivalent to:
function fn2() {
 var <b>name</b>;
 <b>name</b> = 'css';
}

You can prove to yourself that a variable is hoisted by inspecting it before its declaration.

The hoisting of the declaration means you will see undefined instead of ReferenceError:

console.log(<b>name</b>);  // undefined
var <b>name</b> = 'css';
function() {
    console.log(<b>name</b>);  // undefined
    var <b>name</b> = 'css';
}

<h2>Block Scope Declaration Using let</h2>

ES6 <i>let</i> operates much in the same way as <i>var</i>, but it is scoped at the block level in JavaScript.

Block scope is defined as the nearest set of enclosing curly braces  {}.

This means if blocks, while blocks, function blocks, and even standalone blocks will be the extent of the scope of any variable declared with let.

if (true) {/*w    w  w . d    e  m  o2   s   . c  o   m*/
  let a;
}
console.log(a);  // ReferenceError: a is not defined

while (true) {
  let b;
}
console.log(b);  // ReferenceError: b is not defined

function foo() {
  let c;
}
console.log(c);  // ReferenceError: c is not defined

// This is not an object literal, this is a standalone block.
{
  let d;
}
console.log(d);  // ReferenceError: d is not defined

<i>let</i> cannot be declared twice inside the same
block scope.

Duplicate <i>var</i> declarations are simply ignored; duplicate <i>let</i> declarations throw a
SyntaxError.

var a;
var a;
// No errors thrown

{
    let b;
    let b;
}
// SyntaxError: Identifier 'b' has already been declared

The behavior of <i>let</i> is especially useful when using iterators inside loops.

Iterator declarations using
var will bleed outside the loop after it completes, which is frequently a very undesirable behavior.

Consider these two examples:

for (var i = 0; i &lt; 10; ++i) {}
console.log(i);  // 10
for (let j = 0; j &lt; 10; ++j) {}
console.log(j);  // ReferenceError: j is not defined

<h2>Constant Declaration Using const</h2>

ES6 introduces <i>const</i> as companion to <i>let</i>.

A variable declared using <i>const</i> must be initialized to some value.

Once declared, it cannot be reassigned to a new value at any point in its lifetime.

<b>const</b> a;  // SyntaxError: Missing initializer in const declaration

<b>const</b> b = 3;
console.log(b);  // 3
b = 4;  // TypeError: Assignment to a constant variable

Apart from its <i>const</i> rule enforcement, <i>const</i> variables behave identically to <i>let</i> variables:

if (true) {
  <b>const</b> a = 0;
}
console.log(a);  // ReferenceError: a is not defined

while (true) {
  <b>const</b> b = 1;
}
console.log(b);  // ReferenceError: b is not defined

function foo() {
  <b>const</b> c = 2;
}
console.log(c);  // ReferenceError: c is not defined

{
  <b>const</b> d = 3;
}
console.log(d);  // ReferenceError: d is not defined

The <i>const</i> declaration only applies to the top-level primitive or object.

A <i>const</i> variable assigned to an object cannot be reassigned to another reference value, but the keys inside that
object are not protected.

<b>const</b> o1 = {};
o1 = {};  // TypeError: Assignment to a constant variable;

<b>const</b> o2 = {};
o2.<b>name</b> = 'css';
console.log(o2.<b>name</b>);  // 'css'

If you wish to make the entire object immutable, you can use Object.<i>freeze</i>(), although attempted property assignment will not raise errors; it will just silently fail:

<b>const</b> o3 = <b>Object</b>.freeze({});
o3.<b>name</b> = 'css';
console.log(o3.<b>name</b>);  // undefined

<h2>Identifier Lookup</h2>

When an identifier is referenced for reading or writing, Javascript
need to determine what identifier it represents.

The search starts at the front of the scope
chain, looking for an identifier with the given name.

If it finds that identifier name in the local
context, then the search stops and the variable is set; if the search doesn't find the variable name, it
continues along the scope chain.

This process continues until the search reaches
the global context's variable object.

If the identifier isn't found there, it hasn't been declared.

Consider the following example:

var color = 'blue';

function getColor() {
  return color;
}

console.log(getColor());  // 'blue'

When the function <i>getColor</i>() is called in this example, the variable color is referenced.

At that point, a two-step search begins.

First <i>getColor</i>()'s variable object is searched for an identifier named <i>color</i>.

When it isn't found, the search goes to the next variable object, the global context, and then searches for an identifier named <i>color</i>.

Because color is defined in that variable object, the search ends.

Referencing local variables automatically stops the search from going into
another variable object.

The identifiers in a parent context cannot be referenced if an
identifier in the local context has the same name, as in this example:

var color = 'blue';

function getColor() {
  let color = 'red';
  return color;
}

console.log(getColor());  // 'red'

Using block scoped declarations does not change the search process, but it can add extra levels to the lexical hierarchy:

var color = 'blue';

function getColor() {
    let color = 'red';
    {
          let color = 'green';
          return color;
    }
}

console.log(getColor());  // 'green'

In this modified code, a local variable named <i>color</i> is declared inside the <i>getColor</i>() function.

When the function is called, the variable is declared.

When the second line of the function is executed,
it knows that a variable named <i>color</i> must be used.

The search begins in the local context, where it
finds a variable named color with a value of  'green'.

Because the variable was found, the search
stops and the local variable is used, meaning that the function returns  'green'.

<h2>String Type</h2>

The String data type represents a sequence of zero or more 16-bit Unicode characters.

Strings can be delineated by either double quotes ", single quotes ', or backticks `, so all of the following are legal:

let firstName = "css";
let lastName = 'html';
let lastName = `this is a test from demo2s.com`;

A string beginning with a certain character must end with the same character.

For example, the following will cause a syntax error:

let firstName = 'CSS";  // syntax error - quotes must match

Here are some examples

<b>const</b> a = 'a';
console.log(a);

<b>const</b> b = "b";
console.log(b);

<b>const</b> c = `c`;
console.log(c);

Output:

<h3>Operation</h3>
To determine the length of a string-the number of 16-bit values it contains-use the
<i>length</i> property of the string:

s.<b>length</b>

JavaScript provides a rich API for working with strings:

let s = "Hello, world"; // Start with some text.

 Obtaining portions of a string

s.substring(1,4)        // => "ell": the 2nd, 3rd, and 4th characters.
s.slice(1,4)            // => "ell": same thing
s.slice(-3)             // => "rld": last 3 characters
s.split(", ")           // => ["Hello", "world"]: split at delimiter string

 Searching a string

s.indexOf("l")          // => 2: position of first letter l
s.indexOf("l", 3)       // => 3: position of first "l" at or after 3
s.indexOf("zz")         // => -1: s does not include the substring "zz"
s.lastIndexOf("l")      // => 10: position of last letter l

 Boolean searching functions

s.startsWith("Hell")    // => true: the string starts with these
s.endsWith("!")         // => false: s does not end with that
s.includes("or")        // => true: s includes substring "or"

 Creating modified versions of a string

s.replace("llo", "ya")  // => "Heya, world"
s.toLowerCase()         // => "hello, world"
s.toUpperCase()         // => "HELLO, WORLD"
s.normalize()           // Unicode NFC normalization: ES6
s.normalize("NFD")      // NFD normalization.

 Inspecting individual (16-bit) characters of a string

s.charAt(0)             // => "H": the first character
s.charAt(s.<b>length</b>-1)    // => "d": the last character
s.charCodeAt(0)         // => 72: 16-bit number at the specified position
s.codePointAt(0)        // => 72: ES6, works for codepoints > 16 bits

 String padding functions
"x".<i>padStart</i>(3)         // => "  x": add spaces on the left to a length of 3
"x".<i>padEnd</i>(3)           // => "x  ": add spaces on the right to a length of 3
"x".<i>padStart</i>(3, "*")    // => "<i>**</i>x": add stars on the left to a length of 3
"x".<i>padEnd</i>(3, "-")      // => "x--": add dashes on the right to a length of 3

 Space trimming functions. <i>trim</i>() is ES5; others ES2019

" test ".trim()         // => "test": remove spaces at start and end
" test ".trimStart()    // => "test ": remove spaces on left. Also trimLeft
" test ".trimEnd()      // => " test": remove spaces at right. Also trimRight

Other string methods
s.<i>concat</i>("!")           // => "Hello, world!": just use + operator instead
"&lt;>".<i>repeat</i>(5)          // => "&lt;>&lt;>&lt;>&lt;>&lt;>": concatenate n copies. ES6

Javascript strings  are  immutable.  

Methods  like  <i>replace</i>()  and
<i>toUpperCase</i>() return new strings: they do not modify the string on which they are
invoked.

Strings can also be treated like read-only arrays, and you can access individual 
characters  (16-bit  values)  from  a  string  using  square  brackets  instead  of  the  <i>charAt</i>()
method:

let s = "hello, world";
s[0]                  // => "h"
s[s.<b>length</b>-1]         // => "d"

<h2>String Literals</h2>

To  include  a  string  in  a  JavaScript  program,  simply  enclose  the  
characters  of  the
string  within  a  matched  pair  of  single  or  double  quotes  or  
backticks  ( ' '  or  " "  or  ` `).

Double-quote characters and backticks may be contained within strings delimited by
single-quote  characters,  and  similarly  for  strings  delimited  by  double  quotes  and
backticks. 

Here are examples of string literals:

""  // The empty string: it has zero characters
'testing'
"3.14"
'name="myform"' //mix
"Wouldn't you prefer paper book?"
`"She said 'hi'", he said.`

Strings delimited with backticks are a feature of ES6, and allow JavaScript expressions
to be embedded within the string literal. 

<h3>Multiline</h3>
You can break a string literal across multiple lines by ending each line but the 
last with a backslash (\). 

Neither the backslash nor the line terminator that follow it are part of the 
string literal. 

If you need to include a newline character in a single-quoted or double-quoted string
literal,  use  the  character  sequence  \n.  

The  ES6 backtick syntax allows strings to be broken across multiple lines, and in this case, the
line terminators are part of the string literal:

A string representing 2 lines written on one line:

A one-line string written on 3 lines:

"one\
 long\
 line"

A two-line string written on two lines:

`the newline character at the end of this line
     is included literally in this string`

Note  that  when  you  use  single  quotes  to  delimit  your  strings,  you  must  be  careful
with English contractions and possessives, such as <i>can't</i>. 

Since the apostrophe is the same as the single-quote character, you must use the backslash character
(\)  to  "escape"  any  apostrophes  that  appear  in  single-quoted  strings.

In client-side JavaScript programming, JavaScript code may contain strings of HTML
code, and HTML code may contain strings of JavaScript code. 

Like JavaScript, HTML
uses either single or double quotes to delimit its strings. 

Thus, when combining Java
Script and HTML, it is a good idea to use one style of quotes for JavaScript and the
other  style  for  HTML.  

In  the  following  example,  the  string  "Thank  you"  is  single-
quoted within a JavaScript expression, which is then double-quoted within an HTML
event-handler attribute:

&lt;button onclick="alert('Thank you')">Click Me&lt;/button>

<h2>String Character Escape</h2>

The String data type includes several character literals to represent nonprintable
useful characters, as listed in the following table:

<table>
<thead><tr><th>LITERAL</th><th>   MEANING</th></tr></thead>
<tbody>
<tr><td>\n</td><td>   New line</td></tr>
<tr><td>\t</td><td>   Tab</td></tr>
<tr><td>\b</td><td>   Backspace</td></tr>
<tr><td>\r</td><td>   Carriage return</td></tr>
<tr><td>\f</td><td>   Form feed</td></tr>
<tr><td>\\</td><td>   Backslash (\)</td></tr>
<tr><td>\'</td><td>   Single quote '-used when the string is delineated by single quotes.<br>   Example: 'He said, \'hi.\''.                                       </td></tr>
<tr><td>\"</td><td>   Double quote (")-used when the string is delineated by double quotes.<br>   Example: "He said, \"hi.\"".                                         </td></tr>
<tr><td>\`</td><td>   Backtick (`)-used when the string is delineated by backticks.<br>   Example:  `He said, \`hi.\``.                                </td></tr>
<tr><td>\xnn</td><td>   A character represented by hexadecimal code nn (where n is a hexadecimal digit 0-F).<br>   Example: \x41 is equivalent to  "A".                                                </td></tr>
<tr><td>\unnnn</td><td>   A Unicode character represented by the hexadecimal code nnnn (where n is a hexadecimal digit 0-F).<br>   Example: \u03a3 is equivalent to the Greek character S.                                           </td></tr>
</tbody></table>
These character literals can be included anywhere with a string and will be interpreted as if they were
a single character, as shown here:

let text = "This is the letter sigma: \u03a3.";

The entire escape sequence represents a single character, so it is counted as such.

The length of any string can be returned by using the <i>length</i> property, as follows:

console.log("asdf".<b>length</b>); //4

This property returns the number of 16-bit characters in the string.

If a string contains double-byte characters, the length property may not
accurately return the number of characters in the string.

<h2>immutable String</h2>

Strings are immutable in ECMAScript, and once they are created, their values cannot
change.

To change the string held by a variable, the original string must be destroyed and the variable
filled with another string containing a new value, like this:

let lang = "Java";
lang = lang + "Script";

Here, the variable <i>lang</i> is defined to contain the string  "Java".

On the next line, lang is redefined to combine  "Java" with  "Script", making its value  "JavaScript".

The last step in the process is to destroy the original string  "Java" and the string  "Script", because
neither is necessary anymore.

All of this happens behind the scenes.

<h2>Converting value to a String using toString() method</h2>

There are two ways to convert a value into a string.

The first is to use the <i>toString</i>() method that almost every value has.

This method's job is to return the string equivalent of the value.

Consider this example:

let age = 11;
let ageAsString = age.<b>toString</b>();      // the string "11"
let found = true;
let foundAsString = found.<b>toString</b>();  // the string "true"

The <i>toString</i>() method is available on values that are numbers, Booleans, objects, and strings.

If a value is null or undefined, this method is not available.

In most cases, <i>toString</i>() doesn't have any arguments.

However, when used on a number value,
<i>toString</i>() actually accepts a single argument: the radix in which to output the number.

By default, <i>toString</i>() always returns a string that represents the number as a decimal, but by passing in a
radix, <i>toString</i>() can output the value in binary, octal, hexadecimal, or any other valid base, as in
this example:

let num = 10;
console.log(num.<b>toString</b>());     // "10"
console.log(num.<b>toString</b>(2));    // "1010"
console.log(num.<b>toString</b>(8));    // "12"
console.log(num.<b>toString</b>(10));   // "10"
console.log(num.<b>toString</b>(16));   // "a"

This example shows how the output of <i>toString</i>() can change for numbers when providing a radix.

The value 10 can be output into any number of numeric formats.

The default is the same as providing a radix of 10.

<h2>Converting value to a String using String() method</h2>

If you're not sure that a value isn't null or undefined, you can use the <b>String</b>() casting function,
which always returns a string regardless of the value type.

The <b>String</b>() function follows these rules:

If the value has a <i>toString</i>() method, it is called and the result is returned.
If the value is null,  "null" is returned.
If the value is undefined,  "undefined" is returned.

Consider the following:

let value1 = 10;
let value2 = true;
let value3 = null;
let value4;

console.log(<b>String</b>(value1));   // "10"
console.log(<b>String</b>(value2));   // "true"
console.log(<b>String</b>(value3));   // "null"
console.log(<b>String</b>(value4));   // "undefined"

Here, four values are converted into strings: a number, a Boolean, null, and undefined.

The result for the number and the Boolean are the same as if <i>toString</i>() were called.

Because <i>toString</i>()
isn't available on  "null" and  "undefined", the <b>String</b>() method simply returns literal text for
those values.

You can also convert a value to a string by adding an empty string ("") to
that value using the plus operator.

<h2>String Template Literals</h2>

ECMAScript can define strings using template literals.

Unlike single and double quoted, template literals respect new line characters, and can be defined
spanning multiple lines:

let myMultiLineString = 'first line\nsecond line';

console.log(myMultiLineString);
// first line
// second line

let myMultiLineTemplateLiteral = `first line
second line`;

console.log(myMultiLineTemplateLiteral);
// first line
// second line

console.log(myMultiLineString === myMultiLineTemplateLiteral);   // true

Output:

The template literals are useful when defining templates, such as HTML:

let pageHTML = `
&lt;div>
  &lt;a href="#">
    &lt;span>Javascript&lt;/span>
  &lt;/a>
&lt;/div>`;

Because template literals will exactly match the whitespace inside the backticks, special care will
need to be applied when defining them.

A correctly formatted template string may appear to have improper indentation:

This template literal has 25 spaces following the line return character

let myTemplateLiteral = `A
                         B`;
console.log(myTemplateLiteral.<b>length</b>);

Output:

This template literal begins with a line return character

let secondTemplateLiteral = `
A
B`;
console.log(secondTemplateLiteral[0] === '\n'); // true

This template literal has no unexpected whitespace characters

let thirdTemplateLiteral = `A
B`;
console.log(thirdTemplateLiteral[0]);

Output:



<h2>String Template Interpolation</h2>

Javascript template literals supports for interpolation.

We can insert values at one or more places inside a String template.

Javascript String Templates are special JavaScript syntactical expressions that evaluate into strings.

Template literals are evaluated immediately when they are defined and converted into a string
instance, and any interpolated variables will be drawn from its immediate scope.

This can be accomplished using a JavaScript expression inside ${}:

let <b>name</b> = "Bill";
let greeting = `Hello ${ <b>name</b> }.`;  // greeting == "Hello Bill."

let value = 5;
let exponent = '2';

let interpolatedTemplateLiteral =
`${ value } to the ${ exponent } power is ${ value * value }`;

console.log(interpolatedTemplateLiteral);  // 5 to the 2 power is 25

The value being interpolated will eventually be coerced into a string using <i>toString</i>(), but any
JavaScript expression can safely be interpolated.

Nesting template strings is safe with no escaping required:

console.log(`Hello, ${ `World` }!`);  // Hello, World!

<i>toString</i>() is invoked to coerce expression result into string:

let foo = { <b>toString</b>: () => 'World' };
console.log(`Hello, ${ foo }!`);      // Hello, World!

Invoking functions and methods inside interpolated expressions is allowed:

function capitalize(word) {
  return `${ word[0].toUpperCase() }${ word.slice(1) }`;
}
console.log(`${ capitalize('hello') }, ${ capitalize('world') }!`);  
// Hello, World!

Additionally, templates can safely interpolate their previous value:

let value = '';
function append() {
  value = `${value}a`
  console.log(value);
}
append();  // a
append();  // aa
append();  // aaa

<h2>String Template Literal Tag Functions</h2>

Template literals can define tag functions to define custom interpolation behavior.

A tag function is defined as a regular function and is applied to a template literal by being prepended
to it.

The tag function will be passed the template literal split
into its pieces: the first argument is an array of the raw strings, and the remaining arguments are the
results of the evaluated expressions.

The return value of this function will be the string evaluated from the template literal.

let a = 6;/*w    w  w.  d    e  m  o 2   s  .  c o  m */
let b = 9;
function simpleTag(strings, aVal, bVal, sumVal) {
  console.log(strings);
  console.log(aVal);
  console.log(bVal);
  console.log(sumVal);

  return 'test';
}

let untaggedResult = `${ a } + ${ b } = ${ a + b }`;
let taggedResult = simpleTag`${ a } + ${ b } = ${ a + b }`;
// ["", " + ", " = ", ""]
// 6
// 9
// 15

console.log(untaggedResult); // "6 + 9 = 15"
console.log(taggedResult); // "test"

Because there are a variable number of expression arguments, using the spread operator to combine
them into a single collection is usually prudent:

let a = 6;
let b = 9;

function simpleTag(strings, ...expressions) {
  console.log(strings);
  for(<b>const</b> expression of expressions) {
    console.log(expression);
  }

  return 'test';
}
let taggedResult = simpleTag`${ a } + ${ b } = ${ a + b }`;
// ["", " + ", " = ", ""]
// 6
// 9
// 15

console.log(taggedResult);  // "test"

For a template literal with n interpolated values, the number of expression arguments to the tag
function will always be n, and the number of string pieces in the first argument will always be exactly n + 1.

If you wished to zip the strings and the evaluated expressions together into the default
returned string, you could do so as follows:

let a = 6;
let b = 9;

function zipTag(strings, ...expressions) {
   return strings[0] +
             expressions.map((e, i) => `${e}${strings[i + 1]}`)
                                .join('');
}

let untaggedResult =     `${ a } + ${ b } = ${ a + b }`;
let taggedResult = zipTag`${ a } + ${ b } = ${ a + b }`;

console.log(untaggedResult);  // "6 + 9 = 15"
console.log(taggedResult);    // "6 + 9 = 15"

<h2>Get Raw Strings from String template literals</h2>

We can get the raw template literal contents without being converted into actual character representations, such as a new line or Unicode character.

This can be done by using the <b>String.raw</b> tag function.

Unicode demo

// \u00A9 is the copyright symbol
console.log(`\u00A9`);
console.log(<b>String</b>.raw`\u00A9`);  // \u00A9

Newline demo

console.log(`first line\nsecond line`);
// first line
// second line
console.log(<b>String</b>.raw`first line\nsecond line`);  // "first line\nsecond line"

This does not work for actual newline characters: they do not undergo conversion from their plaintext escaped equivalents

console.log(`first line
second line`);
// first line
// second line

console.log(<b>String</b>.raw`first line
second line`);
// first line
// second line

The raw values are available as a property on each element in the string piece collection inside
the tag function:

function printRaw(strings) {
  console.log('Actual characters:');
  for (<b>const</b> string of strings) {
    console.log(string);
  }

  console.log('Escaped characters;');
  for (<b>const</b> rawString of strings.raw) {
    console.log(rawString);
  }
 }

printRaw`a\nb${ 'and' }\n`;

Output:



<h2>String Reference Type</h2>

The String type is the object representation for strings and is created using the String constructor
as follows:

let stringObject = new <b>String</b>("hi");

The methods of a String object are available on all string primitives.

All three of the inherited methods-<i>valueOf</i>(), <i>toLocaleString</i>(), and <i>toString</i>()-return the object's primitive string value.

Each instance of String contains a single property, <i>length</i>, which indicates the number of characters
in the string.

Consider the following example:

let stringValue = "hello world";
console.log(stringValue.<b>length</b>);   // "11"

This example outputs  "11", the number of characters in  "hello world".

Note that even if the string contains a double-byte character, each
character is still counted as one.

The String type has a large number of methods to aid in the dissection and manipulation of strings
in ECMAScript.

<h2>String Character</h2>

JavaScript strings consist of 16 bit code units.

For most characters, each 16 bit code unit will correspond to a single character.

<h3>Length</h3>
The <i>length</i> property indicates how many 16 bit code units occur inside
the string:

let message = "abcde";

console.log(message.<b>length</b>);  // 5

<h3>charAt()</h3>
The <i>charAt</i>() returns the character at a given index, specified by an integer argument to
the method.

This method finds the 16 bit code unit at the specified index and returns the
character that corresponds to that code unit:

let message = "abcde";

console.log(message.charAt(2));  // "c"

<h3>charCodeAt()</h3>
You can inspect the character encoding of a given code unit with the <i>charCodeAt</i>() method.

This method returns the code unit value at a given index, specified by an integer argument to the method.

This method is demonstrated here:

let message = "abcde";

// Unicode "Latin small letter C" is U+0063
console.log(message.charCodeAt(2));  // 99

// Decimal 99 === Hexadecimal 63
console.log(99 === 0x63);            // true

<h3>fromCharCode()</h3>
The <i>fromCharCode</i>() method is used for creating characters in a string from their UTF-16 code unit
representation.

This method accepts any number of numbers and returns their character equivalents
concatenated into a string:

// Unicode "Latin small letter A" is U+0061 and === 97
// Unicode "Latin small letter B" is U+0062 and === 98
// Unicode "Latin small letter C" is U+0063 and === 99
// Unicode "Latin small letter D" is U+0064 and === 100
// Unicode "Latin small letter E" is U+0065 and === 101
console.log(<b>String</b>.fromCharCode(0x61, 0x62, 0x63, 0x64, 0x65));  // "abcde"
console.log(<b>String</b>.fromCharCode(97, 98, 99, 100, 101));          // "abcde"

For characters in the range of U+0000 to <b>U+FFFF</b>, length, <i>charAt</i>(), <i>charCodeAt</i>(), and
<i>fromCharCode</i>() all behave exactly as you would expect them to.

This is because every character is
represented by exactly 16 bits, and each of these methods are all operating on 16 bit code units.

<h2>String normalize Unicode character</h2>

Some Unicode characters can be encoded in more than one way.

Sometimes, a character can be 
represented by either a single BMP character or a surrogate pair.

For example, consider the following:

// U+00C5: Latin capital letter A with ring above
console.log(<b>String</b>.fromCharCode(0x00C5));         

// U+212B: Angstrom sign
console.log(<b>String</b>.fromCharCode(0x212B));         

Comparison operators do not care about the visual appearance of characters, and so these three will
be considered distinct:

let a1 = <b>String</b>.fromCharCode(0x00C5),
a2 = <b>String</b>.fromCharCode(0x212B),

console.log(a1, a2); 
console.log(a1 === a2);  // false

<h3>Normalization</h3>
We can normalize Unicode by four normalization forms.

The unicode character can be normalized into a consistent format irrespective of their character code derivation.

These four normalization forms can be applied to a string using the <i>normalize</i>() method.

Normalization <b>Form</b> D (NFD), 
Normalization <b>Form</b> C (NFC), 
Normalization <b>Form</b> KD (NFKD), and 
Normalization <b>Form</b> KC (NFKC)

The <i>normalize</i>() method should be provided with a string identifier to specify which 
 normalization form to apply: <b>NFD</b>, <b>NFC</b>, <b>NFKD</b>, or <b>NFKC</b>.

It is possible to determine if a string is already normalized by checking it against the return value of
<i>normalize</i>():

let a1 = <b>String</b>.fromCharCode(0x00C5),
    a2 = <b>String</b>.fromCharCode(0x212B),

// U+00C5 is the NFC/NFKC normalized form of 0+212B
console.log(a1 === a1.normalize("NFD"));   // false
console.log(a1 === a1.normalize("NFC"));   // true
console.log(a1 === a1.normalize("NFKD"));  // false
console.log(a1 === a1.normalize("NFKC"));  // true

// U+212B is non-normalized
console.log(a2 === a2.normalize("NFD"));   // false
console.log(a2 === a2.normalize("NFC"));   // false
console.log(a2 === a2.normalize("NFKD"));  // false
console.log(a2 === a2.normalize("NFKC"));  // false

Selecting a normal form will allow for the comparison operator to behave as expected between 
identical characters:

let a1 = <b>String</b>.fromCharCode(0x00C5),
a2 = <b>String</b>.fromCharCode(0x212B),
console.log(a1.normalize("NFD") === a2.normalize("NFD"));    // true

<h2>String concatenation</h2>

Several methods manipulate the values of strings.

<h3>concat()</h3>
The first of these methods is <i>concat</i>(), which is
used to concatenate one or more strings to another, returning the concatenated string as the result.

Consider the following example:

let stringValue = "hello ";
let result = stringValue.concat("world");

console.log(result);       // "hello world"
console.log(stringValue);  // "hello"

The result of calling the <i>concat</i>() method on <i>stringValue</i> in this example is  "hello world"-
the value of <i>stringValue</i> remains unchanged.

The <i>concat</i>() method accepts any number of arguments,
so it can create a string from any number of other strings, as shown here:

let stringValue = "hello ";
let result = stringValue.concat("world", "!");

console.log(result);       // "hello world!"
console.log(stringValue);  // "hello"

This modified example concatenates  "world" and  "!" to the end of  "hello".

The addition operator (+) is used more often than <i>concat</i>() method.

<h2>Get String sub string using slice(), substr(), and substring()</h2>

ECMAScript provides three methods for creating string values from a substring: <i>slice</i>(), <i>substr</i>(),
and <i>substring</i>().

All three methods return a substring of the string they act on, and all accept either
one or two arguments.

The first argument is the position where capture of the substring begins; the
second argument, if used, indicates where the operation should stop.

For <i>slice</i>() and <i>substring</i>(),
this second argument is the position before which capture is stopped. All characters up to this point
are included except the character at that point.

For <i>substr</i>(), the second argument is the number of characters to return.

If the second argument is omitted in any case, it is assumed that the ending
position is the length of the string.

<i>slice</i>(), <i>substr</i>(), and <i>substring</i>() do not alter the value of the string itself-they simply return a primitive string value as
the result, leaving the original unchanged.

Consider this example:

let stringValue = "hello world";
console.log(stringValue.slice(3));        // "lo world"
console.log(stringValue.substring(3));    // "lo world"
console.log(stringValue.substr(3));       // "lo world"
console.log(stringValue.slice(3, 7));     // "lo w"
console.log(stringValue.substring(3,7));  // "lo w"
console.log(stringValue.substr(3, 7));    // "lo worl"

In this example, <i>slice</i>(), <i>substr</i>(), and <i>substring</i>() are used in the same manner and, in most
cases, return the same value.

When given just one argument, 3, all three methods return  "lo world"
because the second  "l" in  "hello" is in position 3.

When given two arguments, 3 and 7, <i>slice</i>()
and <i>substring</i>() return  "lo w", while
<i>substr</i>() returns  "lo worl" because the second argument specifies the number of characters
to return.

<h3>Negative index</h3>
There are different behaviors for these methods when an argument is a negative number.

For the <i>slice</i>() method, a negative argument is treated as the length of the string plus the 
negative argument.

For the <i>substr</i>() method, a negative first argument is treated as the length of the string plus the
number, whereas a negative second number is converted to 0.

For the <i>substring</i>() method, all negative numbers are converted to 0.

Consider this example:

let stringValue = "hello world";
console.log(stringValue.slice(-3));         // "rld"
console.log(stringValue.substring(-3));     // "hello world"
console.log(stringValue.substr(-3));        // "rld"
console.log(stringValue.slice(3, -4));      // "lo w"
console.log(stringValue.substring(3, -4));  // "hel"
console.log(stringValue.substr(3, -4));     // "" (empty string)

When <i>slice</i>() and <i>substr</i>() are called with a single negative argument, they act the same.

This occurs because -3 is translated into
7, which is the length plus the argument, effectively making the calls <i>slice</i>(7) and <i>substr</i>(7).

The <i>substring</i>() method returns the entire string because -3 is translated to  0.

When the second argument is negative, the three methods act differently from one another.

The <i>slice</i>() method translates the second argument to 7, making the call equivalent to <i>slice</i>(3, 7)
and so returning  "lo w".

For the <i>substring</i>() method, the second argument gets translated to 0,
making the call equivalent to <i>substring</i>(3, 0), which is actually equivalent to <i>substring</i>(0,3)
because this method expects that the smaller number is the starting position and the larger one is the
ending position.

For the <i>substr</i>() method, the second argument is also converted to  0, which means
there should be zero characters in the returned string, leading to the return value of an empty string.

<h2>String Search Location Methods</h2>

There are two methods for locating substrings within another string: <i>indexOf</i>() and
<i>lastIndexOf</i>().

Both methods search a string for a given substring and return the position or -1
if the substring isn't found.

The <i>indexOf</i>() method begins looking for the substring at the beginning of the string, whereas the <i>lastIndexOf</i>() method begins
looking from the end of the string.

Consider this example:

let stringValue = "hello world";
console.log(stringValue.indexOf("o"));      // 4
console.log(stringValue.lastIndexOf("o"));  // 7

Here, the first occurrence of the string  "o" is at position 4, which is the  "o" in  "hello".

The last
occurrence of the string  "o" is in the word  "world", at position 7.

If there is only one occurrence of "o" in the string, then <i>indexOf</i>() and <i>lastIndexOf</i>() return the same position.

Each method accepts an optional second argument that indicates the position to start searching
from within the string.

The <i>indexOf</i>() method will start searching from that position and go toward the end of the string, ignoring everything before the start position.

The last <b>IndexOf</b>() starts searching from the given position and continues searching toward the 
beginning of the string, ignoring everything between the given position and the end of the string.

Here's an example:

let stringValue = "hello world";
console.log(stringValue.indexOf("o", 6));      // 7
console.log(stringValue.lastIndexOf("o", 6));  // 4

When the second argument of 6 is passed into each method, the results are the opposite from the 
previous example.

<i>indexOf</i>() returns 7 because it starts searching the string from position 6
(the letter "w") and continues to position 7, where "o" is found.

The <i>lastIndexOf</i>() method returns
4 because the search starts from position 6 and continues back toward the beginning of the string,
where it encounters the  "o" in  "hello".

Using this second argument allows you to locate all instances
of a substring by looping callings to <i>indexOf</i>() or <i>lastIndexOf</i>(), as in the following example:

let stringValue = "Cate Kate Jane Jason Joe";
let positions = new <b>Array</b>();
let pos = stringValue.indexOf("e");

while(pos > -1) {
  positions.push(pos);
  pos = stringValue.indexOf("e", pos + 1);
}

console.log(positions);  

Output:

This example works through a string by constantly increasing the position at which <i>indexOf</i>()
should begin.

It begins by getting the initial position of  "e" in the string and then enters a loop that
continually passes in the last position plus one to <i>indexOf</i>(), ensuring that the search continues
after the last substring instance.

Each position is stored in the positions array so the data can be used later.

<h2>String Inclusion Contains Methods</h2>

ECMAScript 6 added three additional methods for determining if a string is included inside another
string: <i>startsWith</i>(), <i>endsWith</i>(), and <i>includes</i>().

All methods search a string for a given substring and return a boolean indicating whether it is not included.

<i>startsWith</i>() checks for a match beginning at index 0.

<i>endsWith</i>() checks for a match beginning at index of (string.length - substring.length).

<i>includes</i>() checks the entire string.

let message = "foobarbaz";

console.log(message.startsWith("foo"));  // true
console.log(message.startsWith("bar"));  // false

console.log(message.endsWith("baz"));    // true
console.log(message.endsWith("bar"));    // false

console.log(message.includes("bar"));    // true
console.log(message.includes("qux"));    // false

The <i>startsWith</i>() and <i>includes</i>() methods accept an optional second argument that indicates the
position to start searching from within the string.

The methods will start searching
from that position and go toward the end of the string, ignoring everything before the start position.

Here's an example:

let message = "foobarbaz";

console.log(message.startsWith("foo"));     // true
console.log(message.startsWith("foo", 1));  // false

console.log(message.includes("bar"));       // true
console.log(message.includes("bar", 4));    // false

The <i>endsWith</i>() method accepts an optional second argument that indicates the position that should
be treated as the end of the string.

If this value is not provided, the length of the string is used by
default.

When a second argument is provided, the method will treat the string as if it only has that
many characters:

let message = "foobarbaz";

console.log(message.endsWith("bar"));     // false
console.log(message.endsWith("bar", 6));  // true

<h2>Use String trim() Method to remove leading and trailing white space</h2>

ECMAScript features a <i>trim</i>() method on all strings.

The <i>trim</i>() method creates a copy of the
string, removes all leading and trailing white space, and then returns the result.

For example:

let stringValue = "  hello world  ";
let trimmedStringValue = stringValue.trim();
console.log(stringValue);         // "  hello world  "
console.log(trimmedStringValue);  // "hello world"

Since <i>trim</i>() returns a copy of a string, the original string remains intact with leading and
trailing white space in place.

The <i>trimLeft</i>() and <i>trimRight</i>() methods remove white space only from the
beginning or end of the string, respectively.

<h2>Create a String via repeat() Method</h2>

ECMAScript features a <i>repeat</i>() method on all strings.

The <i>repeat</i>() method accepts a single 
integer argument count, copies the string count times, and concatenates all the copies.

let stringValue = "hi ";
console.log(stringValue.repeat(6) + "hello");

Output:



<h2>Pad a String via padStart() and padEnd() Methods</h2>

The <i>padStart</i>() and <i>padEnd</i>() methods will copy a string and, if the length of the string is less than
the specified length, add padding to either side of a string to extend it to a certain length.

The first argument is the desired length, and the second is the optional string to add as a pad.

If not provided, the U+0020 'space' character will be used.

let stringValue = "foo";

console.log(stringValue.padStart(6));       // "   foo"
console.log(stringValue.padStart(9, "."));  // "......foo"

console.log(stringValue.padEnd(6));         // "foo   "
console.log(stringValue.padEnd(9, "."));    // "foo......"

The optional argument is not limited to a single character.

If provided a multiple-character string,
the method will use the concatenated padding and truncate it to the exact length.

Additionally, if the
length is less than or equal to the string length, the operation is effectively a no-op.

let stringValue = "foo";

console.log(stringValue.padStart(8, "bar"));  // "barbafoo"
console.log(stringValue.padStart(2));         // "foo"

console.log(stringValue.padEnd(8, "bar"));    // "foobarba"
console.log(stringValue.padEnd(2));           // "foo"

<h2>String Iterators</h2>

The string prototype exposes an @@iterator method on each string, which allows for iteration
through individual characters.

Manual use of the iterator works as follows:

let message = "abc";
let stringIterator = message[Symbol.iterator]();

console.log(stringIterator.next());  // {value: "a", done: false}
console.log(stringIterator.next());  // {value: "b", done: false}
console.log(stringIterator.next());  // {value: "c", done: false}
console.log(stringIterator.next());  // {value: undefined, done: true}

When used in a for of loop, the loop will use this iterator to visit each character in order:

for (<b>const</b> c of "abcde") {
    console.log(c);
}

Output:



<h2>String Destructuring</h2>

The string iterator allows for interoperability with the destructuring
operator.

This allows you to easily split a string by its characters:

let message = "abcde";

console.log([...message]);  

Output:



<h2>Use String Case Methods to change string case</h2>

Four methods perform case conversion: <i>toLowerCase</i>(), <i>toLocaleLowerCase</i>(), <i>toUpperCase</i>(), and <i>toLocaleUpperCase</i>().

The <i>toLowerCase</i>() and <i>toUpperCase</i>() methods are the original methods.

The <i>toLocaleLowerCase</i>() and <i>toLocaleUpperCase</i>() methods are intended to be
implemented based on a particular locale.

In many locales, the locale-specific methods are identical
to the generic ones; however, a few languages (such as Turkish) apply special rules to Unicode case
conversion, and this necessitates using the locale-specific methods for proper conversion.

Here are some examples:

let stringValue = "hello world";
console.log(stringValue.toLocaleUpperCase());  // "HELLO WORLD"
console.log(stringValue.toUpperCase());        // "HELLO WORLD"
console.log(stringValue.toLocaleLowerCase());  // "hello world"
console.log(stringValue.toLowerCase());        // "hello world"

This code outputs  "HELLO WORLD" for both <i>toLocaleUpperCase</i>() and <i>toUpperCase</i>(), just as
"hello world" is output for both <i>toLocaleLowerCase</i>() and <i>toLowerCase</i>().

<h2>String Pattern-Matching Methods</h2>

The String type has several methods designed to pattern-match within the string.

<h3>match()</h3>
String <i>match</i>() is the same as calling a RegExp object's <i>exec</i>() method.

The <i>match</i>() method accepts a single argument, which is either a regular-expression string or a RegExp
object.

Consider this example:

let text = "cat, bat, sat, fat";
let pattern = /.at/;

// same as pattern.exec(text)
let matches = text.match(pattern);
console.log(matches.index);      // 0
console.log(matches[0]);         // "cat"
console.log(pattern.lastIndex);  // 0

The array returned from <i>match</i>() is the same array that is returned when the RegExp object's <i>exec</i>()
method is called with the string as an argument: 

the first item is the string that matches the entire pattern, and
each other item (if applicable) represents capturing groups in the expression.

<h3>search()</h3>
String <i>search</i>() finds patterns.

String <i>search</i>() method accepts a regular expression specified by either a string or a RegExp object as its parameter.

The <i>search</i>() method returns the index of the first pattern occurrence in the string or -1 if it's not found.

<i>search</i>() always begins looking for the pattern at the beginning of the string.

Consider this example:

let text = "cat, bat, sat, fat";
let pos = text.search(/at/);
console.log(pos);  // 1

Here, <i>search</i>(/at/) returns  1, which is the first position of  "at" in the string.

<h2>Use replace() method to replace sub string</h2>

To replace substrings, ECMAScript provides the <i>replace</i>() method.

This method accepts two arguments.

The first argument can be a RegExp object or a string which is not converted to
a regular expression, and the second argument can be a string or a function.

If the first argument is a string, then only the first occurrence of the substring will be replaced.

The only way to replace all instances of a substring is to provide a regular expression with the global flag specified, as in
this example:

let text = "cat, bat, sat, fat";
let result = text.replace("at", "ond");
console.log(result);  // "cond, bat, sat, fat"

result = text.replace(/at/g, "ond");
console.log(result);  // "cond, bond, sond, fond"

In this example, the string  "at" is first passed into <i>replace</i>() with a replacement text of  "ond".

The result of the operation is that  "cat" is changed to  "cond", but the rest of the string remains intact.

By changing the first argument to a regular expression with the global flag set, each instance of  "at" is
replaced with  "ond".

When the second argument is a string, there are several special character sequences that can be used
to insert values from the regular-expression operations.

ECMA-262 specifies the following table of values.

<table>
<thead><tr><th>Sequence</th><th>   Replacement Text</th></tr></thead>
<tbody>
<tr><td> $$</td><td>   $</td></tr>
<tr><td> $&amp;</td><td>   The substring matching the entire pattern. Same as <b>RegExp.lastMatch</b>.</td></tr>
<tr><td> $'</td><td>   The part of the string occurring before the matched substring.<br>   Same as <b>RegExp.rightContext</b>.                                </td></tr>
<tr><td> $`</td><td>   The part of the string occurring after the matched substring.<br>   Same as <b>RegExp.leftContext</b>.                                </td></tr>
<tr><td> $n</td><td>   The nth capture, where n is a value 0-9.                             <br>   For instance,  $1 is the first capture,  $2 is the second, and so on.<br>   If there is no capture then the empty string is used.                </td></tr>
<tr><td> $nn</td><td>   The <i>nnth</i> capture, where nn is a value 01-99.                        <br>   For instance,  $01 is the first capture, $02 is the second, and so on.<br>   If there is no capture then the empty string is used.                 </td></tr>
</tbody></table>
Using these special sequences allows replacement using information about the last match, such as in
this example:

let text = "cat, bat, sat, fat";
result = text.replace(/(.at)/g, "word ($1)");
console.log(result);  // word (cat), word (bat), word (sat), word (fat)

Here, each word ending with  "at" is replaced with  "word" followed in parentheses by what it
replaces by using the $1 sequence.

The second argument of <i>replace</i>() may also be a function.

When there is a single match, the function gets passed three arguments: the string match, the position of the match within the string, and
the whole string.

When there are multiple capturing groups, each matched string is passed in as an
argument, with the last two arguments being the position of the pattern match in the string and the
original string.

The function should return a string indicating what the match should be replaced
with.

Using a function as the second argument allows more granular control over replacement text, as
in this example:

function htmlEscape(text) {
  return text.replace(/[&lt;>"&amp;]/g, function(match, pos, originalText) {
    switch(match) {
      case "&lt;":
        return "&amp;lt;";
      case ">":
        return "&amp;gt;";
      case "&amp;":
        return "&amp;amp;";
      case "\"":
        return "&amp;quot;";
    }
  });
}

console.log(htmlEscape("&lt;p class=\"greeting\">Hello world!&lt;/p>"));

Output:

Here, the function <i>htmlEscape</i>() is defined to escape four characters for insertion into HTML: the
less-than, greater-than, ampersand, and double-quote characters all must be escaped.

We use a regular expression to look for those characters and then define a 
function that returns the specific HTML entities for each matched character.

<h2>Use split() method to split string</h2>

String <i>split</i>() separates the string into an array of substrings based on a separator.

The separator may be a string or a RegExp object.

The string is not converted to a regular expression for this method.

An optional second argument, the array limit,
ensures that the returned array will be no larger than a certain size.

Consider this example:

let sText = "A,B,C,D,E";
let s1 = sText.split(",");       
let s2 = sText.split(",", 2);    
let s3 = sText.split(/[^\,]+/);  
console.log(s1);
console.log(s2);
console.log(s3);

Output:

In this example, the string <i>sText</i> is a comma-separated string of letters.

The call to <i>split</i>(",")
retrieves an array of those letters, splitting the string on the comma character.

To truncate the results
to only two items, a second argument of 2 is specified.

Last, using a regular expression, it's possible
to get an array of the comma characters.

<h2>Compare String with localeCompare() Method</h2>

String <i>localeCompare</i>() compares one string to another and returns one of three
values as follows:

If the string should come alphabetically before the string argument, a negative number is returned.
If the string is equal to the string argument, 0 is returned.
If the string should come alphabetically after the string argument, a positive number is returned.

Here's an example:

let stringValue = "y";
console.log(stringValue.localeCompare("b"));  // 1
console.log(stringValue.localeCompare("y")); // 0
console.log(stringValue.localeCompare("z"));  // -1

In this code, the string  "y" is compared to three different values: "b", "y", and
"z".

Because "b" comes alphabetically before  "y", <i>localeCompare</i>() returns  1;  
"y" is equal to  "y", so <i>localeCompare</i>() returns  0 for that line; and  "z" comes after
"y", so <i>localeCompare</i>() returns -1 for that line.

The returned values are implementation-specific, it is best to use <i>localeCompare</i>() as shown in this example:

function determineOrder(value) {
  let stringValue = "y";  
  let result = stringValue.localeCompare(value);
  if (result &lt; 0) {
    console.log(`The string 'y' comes before the string '${value}'.`);
  } else if (result > 0) {
    console.log(`The string 'y' comes after the string '${value}'.`);
  } else {
    console.log(`The string 'y' is equal to the string '${value}'.`);
  }
}
determineOrder("b");
determineOrder("y");
determineOrder("z");

Output:

<i>localeCompare</i>() is depended on an implementation's locale (country and language).

In the United States, where English is the standard language
for ECMAScript implementations, <i>localeCompare</i>() is case-sensitive, determining that uppercase
letters come alphabetically after lowercase letters.

This may not be the case in other locales.

<h2>String HTML Methods</h2>

The web browser vendors recognized a need early on to format HTML dynamically using JavaScript.

As a result, they extended the specification to include several methods specifically designed to aid in
common HTML formatting tasks.

The following table enumerates the HTML methods.

Typically these methods aren't used, because they tend to create non-semantic markup.

<table>
<thead><tr><th>Method</th><th>   Output</th></tr></thead>
<tbody>
<tr><td><i>anchor</i>(name)</td><td>   &lt;a name="name ">string&lt;/a></td></tr>
<tr><td><i>big</i>()</td><td>   &lt;big>string&lt;/big></td></tr>
<tr><td><i>bold</i>()</td><td>   &lt;b>string&lt;/b></td></tr>
<tr><td><i>fixed</i>()</td><td>   &lt;tt>string&lt;/tt></td></tr>
<tr><td><i>fontcolor</i>(color)</td><td>   &lt;font color="color">string&lt;/font></td></tr>
<tr><td><i>fontsize</i>(size)</td><td>   &lt;font size="size">string&lt;/font></td></tr>
<tr><td><i>italics</i>()</td><td>   &lt;i>string&lt;/i></td></tr>
<tr><td><i>link</i>(url)</td><td>   &lt;a href="url">string&lt;/a></td></tr>
<tr><td><i>small</i>()</td><td>   &lt;small>string&lt;/small></td></tr>
<tr><td><i>strike</i>()</td><td>   &lt;strike>string&lt;/strike></td></tr>
<tr><td><i>sub</i>()</td><td>   &lt;sub>string&lt;/sub></td></tr>
<tr><td><i>sup</i>()</td><td>   &lt;sup>string&lt;/sup></td></tr>
</tbody></table>

<h2>String search()</h2>

The <i>search</i>() method executes a search for a regular expression.

<h3>Syntax</h3>

str.search(regexp)

<h3>Parameters</h3>
<table>
<thead><tr><th>Item</th><th>   Description</th></tr></thead>
<tbody><tr><td>regexp</td><td>   A regular expression object.</td></tr></tbody></table>
If a non-RegExp object regexp is passed, it is implicitly converted to a RegExp with new <b>RegExp</b>(regexp).

<h3>Return value</h3>
The index of the first match between the regular expression and the given string, or -1 if no match was found.

The following example searches a string with two different regex objects to show a successful search (positive value) vs. an unsuccessful search (-1)

let str = "hey JudE";
let re = /[A-Z]/g;
let reDot = /[.]/g;
console.log(str.search(re));
// returns 4, which is the index of the first capital letter "J"
console.log(str.search(reDot));
// returns -1 cannot find '.' dot punctuation

Result



<h2>String slice()</h2>

The <i>slice</i>() method extracts a sub string and returns it as a new string, without modifying the original string.

<h3>Syntax</h3>

str.slice(begin_Index[, end_Index])

<h3>Parameters</h3>
<table>
<thead><tr><th>Item</th><th>   Description</th></tr></thead>
<tbody>
<tr><td>begin_Index</td><td>   The zero-based index at which to begin extraction.</td></tr>
<tr><td>end_Index</td><td>   Optional                                            <br>   The zero-based index before which to end extraction.<br>     The character at this index will not be included. </td></tr>
</tbody></table>
begin_Index possible values:

If negative, it is treated as str.length + begin_Index. For example, if begin_Index is -3, it is treated as str.length - 3.)
If begin_Index is not a number after <b>Number</b>(begin_Index), it is treated as 0.
If begin_Index is greater than or equal to str.length, an empty string is returned.

end_Index possible values:

If end_Index is omitted or undefined, or greater than str.length, <i>slice</i>() extracts to the end of the string.
If negative, it is treated as str.length + end_Index. For example, if end_Index is -3, it is treated as str.length - 3.
If it is not undefined and not a number after <b>Number</b>(end_Index), an empty string is returned.
If end_Index is specified and start_Index is negative, end_Index should be negative, otherwise an empty string is returned. For example, <i>slice</i>(-3, 0) returns "".
If end_Index is specified, and start_Index and end_Index are both positive or negative, end_Index should be greater than start_Index, otherwise an empty string is returned. For example, <i>slice</i>(-1, -3) or <i>slice</i>(3, 1) returns "".

<h3>Return value</h3>
A new string containing the extracted section of the string.

The following example uses <i>slice</i>() to create a new string.

let str1 = 'This is a test from us.',
    str2 = str1.slice(1, 8),
    str3 = str1.slice(4, -2),
    str4 = str1.slice(12),
    str5 = str1.slice(30);
console.log(str2);
console.log(str3);
console.log(str4);
console.log(str5);

Result

Using <i>slice</i>() with negative indexes

The following example uses <i>slice</i>() with negative indexes.

let str = 'This is a test from us.';
a = str.slice(-3);
console.log(a);
a = str.slice(-3, -1);
console.log(a);
a = str.slice(0, -1);
console.log(a);

Result

This example counts backwards from the end of the string by 11 to find the start index and forwards from the start of the string by 16 to find the end index.

let str = 'This is a test from us.';
console.log(str.slice(-11, 16));

Result

Here it counts forwards from the start by 11 to find the start index and backwards from the end by 7 to find the end index.

let str = 'This is a test from us.';
console.log(str.slice(11, -7));

Result

These arguments count backwards from the end by 5 to find the start index and backwards from the end by 1 to find the end index.

let str = 'This is a test from us.';
console.log(str.slice(-5, -1));

Result



<h2>String small()</h2>

<b>Deprecated</b>

The <i>small</i>() method creates a &lt;small> HTML element to display a string in a small font.

The <i>small</i>() method embeds a string in a &lt;small> tag: "&lt;small>str&lt;/small>".

<h3>Syntax</h3>

str.small()

<h3>Return value</h3>
A string containing a &lt;small> HTML element.

The following example uses string methods to change the size of a string:

var worldString = 'Hello, world';

console.log(worldString.small());     // &lt;small>Hello, world&lt;/small>
console.log(worldString.big());       // &lt;big>Hello, world&lt;/big>
console.log(worldString.fontsize(7)); // &lt;font size="7">Hello, world&lt;/fontsize>

Result

With the element.style object you can get the element's style attribute and set it:

<b>document</b>.getElementById('yourElemId').style.fontSize = '0.7em';

<h2>String split()</h2>

The <i>split</i>() method divides a String into an array of substrings by a separator.  

<h3>Syntax</h3>

str.split([separator[, limit]])

<table>
<thead><tr><th>Item</th><th>   Description</th></tr></thead>
<tbody>
<tr><td>separator</td><td>   Optional                                                                <br>    The separator can be a simple string or it can be a regular expression.</td></tr>
<tr><td>limit</td><td>   Optional                                                                                          <br>   A non-negative integer specifying a limit on the number of substrings to be included in the array.<br>   If limit is 0, [] is returned.                                                                    </td></tr>
</tbody></table>
<h3>Return value</h3>
An Array of strings, split at each point where the separator occurs in the given string.

If the string and separator are both empty strings, an empty array is returned.

<b>const</b> myString = ''
<b>const</b> splits = myString.split()

console.log(splits)

Result

The following example defines a function that splits a string into an array of strings using separator. 

After splitting the string, the function logs messages indicating the original string, the separator used, the number of elements in the array, and the individual array elements.

function splitString(stringToSplit, separator) {
  <b>const</b> arrayOfStrings = stringToSplit.split(separator)

  console.log('The original string is: ', stringToSplit)
  console.log('The separator is: ', separator)
  console.log('The array has ', arrayOfStrings.<b>length</b>, 
               ' elements: ', arrayOfStrings.join(' / '))
}

<b>const</b> tempestString = 'This is a test from demo2s.com.'
<b>const</b> monthString = 'Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec'

<b>const</b> space = ' '
<b>const</b> comma = ','

splitString(tempestString, space)
splitString(tempestString)
splitString(monthString, comma)

Result

In the following example, <i>split</i>() looks for zero or more spaces, followed by a semicolon, followed by zero or more spaces and, when found, removes the spaces and the semicolon from the string. 

<b>const</b> names = 
'CSS HTML;HTML Javascript; Javascript SQL; SQL Database ;Database ABC '

console.log(names)

<b>const</b> re = /\s*(?:;|$)\s*/
<b>const</b> nameList = names.split(re)

console.log(nameList)

Result

In the following example, <i>split</i>() looks for spaces in a string and returns the first 3 splits that it finds.

<b>const</b> myString = 'Hello World. How are you doing?'
<b>const</b> splits = myString.split(' ', 3)

console.log(splits)

Result

Splitting with a RegExp to include parts of the separator in the result

If separator is a regular expression that contains capturing parentheses (), matched results are included in the array.

<b>const</b> myString = 'Hello 1 word. Sentence number 2.'
<b>const</b> splits = myString.split(/(\d)/)

console.log(splits)

Result

Note: \d matches the character class for digits between 0 and 9.

Reversing a String using <i>split</i>()

<b>const</b> str = 'demo2s.com'
<b>const</b> strReverse = str.split('').reverse().join('') 
console.log(strReverse);

Result



<h2>String startsWith()</h2>

The <i>startsWith</i>() method determines whether a string begins with a specified string, returning true or false.

This method is case-sensitive.

<h3>Syntax</h3>

str.startsWith(search_<b>String</b>[, position])

<h3>Parameters</h3>
<table>
<thead><tr><th>Item</th><th>   Description</th></tr></thead>
<tbody>
<tr><td>search_String</td><td>   The characters to be searched for at the start of this string.</td></tr>
<tr><td>position</td><td>   Optional                                                                  <br>   The position in this string at which to begin searching for search_String.<br>   Defaults to 0.                                                            </td></tr>
</tbody></table>
<h3>Return value</h3>
true if the given characters are found at the beginning of the string; otherwise, false.

Using <i>startsWith</i>()

//startswith
let str = 'To be, or not to be, that is the question.'

console.log(str.startsWith('To be'))          // true
console.log(str.startsWith('not to be'))      // false
console.log(str.startsWith('not to be', 10))  // true

Result



<h2>String strike()</h2>

<b>Deprecated</b>

The <i>strike</i>() method creates a &lt;strike> HTML element that causes a string to be displayed as struck-out text.

The <i>strike</i>() method embeds a string in a &lt;strike> tag: "&lt;strike>str&lt;/strike>".

<h3>Syntax</h3>

str.strike()

<h3>Return value</h3>
A string containing a &lt;strike> HTML element.

<h3>Using strike()</h3>
The following example uses string methods to change the formatting of a string:

var worldString = 'Hello, world'; 

console.log(worldString.blink()); // &lt;blink>Hello, world&lt;/blink> 
console.log(worldString.bold()); // &lt;b>Hello, world&lt;/b> 
console.log(worldString.italics()); // &lt;i>Hello, world&lt;/i> 
console.log(worldString.strike()); // &lt;strike>Hello, world&lt;/strike>

Result



<h2>String constructor</h2>

The String constructor can create a new String object. 

When called instead as a function, it performs type conversion to a primitive string.

<h3>Syntax</h3>

new <b>String</b>(thing) //constructor syntax
<b>String</b>(thing)     //call as a function

<table>
<thead><tr><th>Item</th><th>   Description</th></tr></thead>
<tbody><tr><td>thing</td><td>   Anything to be converted to a string.</td></tr></tbody></table>
String constructor and String function

String function and String constructor produce different results:

let a = <b>typeof</b> <b>String</b>('Hello world'); // string
console.log(a);
a = <b>typeof</b> new <b>String</b>('Hello world'); // object
console.log(a);

Result

Here, the function produces a string (the primitive type) as promised. 

However, the constructor produces an instance of the type String, which is an object wrapper.

You should not use the String constructor at all.

<h2>String sub()</h2>

<b>Deprecated</b>

The <i>sub</i>() method creates a &lt;sub> HTML element that causes a string to be displayed as subscript.

The <i>sub</i>() method embeds a string in a &lt;sub> tag: "&lt;sub>str&lt;/sub>".

<h3>Syntax</h3>

str.sub()

<h3>Return value</h3>
A string containing a &lt;sub> HTML element.

Using <i>sub</i>() and <i>sup</i>() methods

The following example uses the <i>sub</i>() and <i>sup</i>() methods to format a string:

var superText = 'superscript'; 
var subText = 'subscript'; 

console.log('This is what a ' + superText.sup() + ' looks like.'); 
console.log('This is what a ' + subText.sub() + ' looks like.'); 

Result



<h2>String substr()</h2>

The <i>substr</i>() method returns a portion of the string, starting at the specified index and extending for a given number of characters afterwards.

<h3>Syntax</h3>

str.substr(start[, <b>length</b>])

<table>
<thead><tr><th>Item</th><th>   Description</th></tr></thead>
<tbody>
<tr><td>start</td><td>   The index of the first character to include in the returned substring.</td></tr>
<tr><td>length</td><td>   Optional.                           <br>   The number of characters to extract.</td></tr>
</tbody></table>
If start is a positive number, the index starts counting at the start of the string. Its value is capped at str.length.
If start is a negative number, the index starts counting from the end of the string. Its value is capped at -str.length.
If length is omitted, <i>substr</i>() extracts characters to the end of the string.
If length is undefined, <i>substr</i>() extracts characters to the end of the string.
If length is a negative number, it is treated as 0.
For both start and length, NaN is treated as 0.

<h3>Return value</h3>
A new string containing the specified part of the given string.

<i>substr</i>() extracts length characters from a str, counting from the start index.

var aString = 'demo2s.com';

console.log(aString.substr(0, 1));   
console.log(aString.substr(1, 0));   
console.log(aString.substr(-1, 1));  
console.log(aString.substr(1, -1));  
console.log(aString.substr(-3));     
console.log(aString.substr(1));      
console.log(aString.substr(-20, 2)); 
console.log(aString.substr(20, 2));  

Result



<h2>String substring()</h2>

The <i>substring</i>() method returns a string part between the start and end indexes, or to the end of the string.

<h3>Syntax</h3>

str.substring(index_Start[, index_End])

<h3>Parameters</h3>
<table>
<thead><tr><th>Item</th><th>   Description</th></tr></thead>
<tbody>
<tr><td>index_Start</td><td>   The index of the first character to include in the returned substring.</td></tr>
<tr><td>index_End</td><td>    Optional                                                               <br>   The index of the first character to exclude from the returned substring.</td></tr>
</tbody></table>
<i>substring</i>() extracts characters from index_Start up to but not including index_End. In particular:

If index_End is omitted, <i>substring</i>() extracts characters to the end of the string.
If index_Start is equal to index_End, <i>substring</i>() returns an empty string.
If index_Start is greater than index_End, then the effect of <i>substring</i>() is as if the two arguments were swapped

Any argument value that is less than 0 or greater than <i>stringName.length</i> is treated as if it were 0 
and <i>stringName.length</i>, respectively.

Any argument value that is NaN is treated as if it were 0.

<h3>Return value</h3>
A new string containing the specified part of the given string.

The following example uses <i>substring</i>() to display characters from the string 'demo2s.com':

let anyString = 'demo2s.com'

console.log(anyString.substring(0, 1));
console.log(anyString.substring(1, 0));

console.log(anyString.substring(0, 6));

console.log(anyString.substring(4));
console.log(anyString.substring(4, 7));
console.log(anyString.substring(7, 4));

console.log(anyString.substring(0, 7));
console.log(anyString.substring(0, 10));

Result

Using <i>substring</i>() with length property

The following example uses the <i>substring</i>() method and length property to extract the last characters of a particular string. 

Get the last four characters:

let anyString = 'demo2s.com';
let anyString4 = anyString.substring(anyString.<b>length</b> - 4);
console.log(anyString4);

Result

Get the last 5 characters

let anyString = 'demo2s.com';
let anyString5 = anyString.substring(anyString.<b>length</b> - 5);
console.log(anyString5);

Result

The difference between <i>substring</i>() and <i>substr</i>()

The arguments of <i>substring</i>() represent the starting and ending indexes, while the arguments of <i>substr</i>() represent the starting index and the number of characters to include in the returned string.

<i>substr</i>() is considered a legacy feature in ECMAScript.

let text = 'demo2s.com';
console.log(text.substring(2,5));
console.log(text.substr(2,3))

Result

Differences between <i>substring</i>() and <i>slice</i>()

The <i>substring</i>() method swaps its two arguments if index_Start is greater than index_End, meaning that a string is still returned. 

The <i>slice</i>() method returns an empty string if this is the case.

let text = 'demo2s.com';
console.log(text.substring(5, 2));
console.log(text.slice(5, 2));

Result

If either or both of the arguments are negative or NaN, the <i>substring</i>() method treats them as if they were 0.

let text = 'demo2s.com';
console.log(text.substring(-5, 2));
console.log(text.substring(-5, -2));

Result

<i>slice</i>() also treats NaN arguments as 0, but when it is given negative values it counts backwards from the end of the string to find the indexes.

let text = 'demo2s.com';
console.log(text.slice(-5, 2));
console.log(text.slice(-5, -2));

Result



<h2>String sup()</h2>

<b>Deprecated</b>

The <i>sup</i>() method creates a &lt;sup> HTML element that causes a string to be displayed as superscript.

The <i>sup</i>() method embeds a string in a &lt;sup> tag: "&lt;sup>str&lt;/sup>".

<h3>Syntax</h3>

str.sup()

<h3>Return value</h3>
A string containing a &lt;sup> HTML element.

Using <i>sub</i>() and <i>sup</i>() methods

The following example uses the <i>sub</i>() and <i>sup</i>() methods to format a string:

var superText = 'superscript';
var subText = 'subscript';

console.log('This is what a ' + superText.sup() + ' looks like.');
console.log('This is what a ' + subText.sub() + ' looks like.');

Result



<h2>String toLocaleLowerCase()</h2>

The <i>toLocaleLowerCase</i>() method returns the calling string value converted to lower case, according to any locale-specific case mappings.

<h3>Syntax</h3>

str.toLocaleLowerCase()
str.toLocaleLowerCase(locale) 
str.toLocaleLowerCase([locale, locale, ...])

<h3>Parameters</h3>
<table>
<thead><tr><th>Item</th><th>   Description</th></tr></thead>
<tbody><tr><td>locale</td><td>   Optional</td></tr></tbody></table>
The <i>locale</i> parameter indicates the locale to be used to convert to lower case according to any locale-specific case mappings. 

If multiple locales are given in an Array, the best available locale is used. 

The default locale is the host environment's current locale.

<h3>Return value</h3>
A new string representing the calling string converted to lower case, according to any locale-specific case mappings.

<h3>Using toLocaleLowerCase()</h3>

let a = 'ALPHABET'.toLocaleLowerCase(); // 'alphabet'
console.log(a);

a = '\u0130'.toLocaleLowerCase('tr') === 'i';    // true
console.log(a);
a = '\u0130'.toLocaleLowerCase('en-US') === 'i'; // false
console.log(a);

let locales = ['tr', 'TR', 'tr-TR', 'tr-u-co-search', 'tr-x-turkish'];
let b = '\u0130'.toLocaleLowerCase(locales) === 'i'; // true
console.log(b);

Result



<h2>String toLocaleUpperCase()</h2>

The <i>toLocaleUpperCase</i>() method returns the calling string value converted to upper case, according to any locale-specific case mappings.

<h3>Syntax</h3>

str.toLocaleUpperCase()
str.toLocaleUpperCase(locale) 
str.toLocaleUpperCase([locale, locale, ...])

<h3>Parameters</h3>
<table>
<thead><tr><th>Item</th><th>   Description</th></tr></thead>
<tbody><tr><td>locale</td><td>   Optional                                                 <br>   indicates the locale to be used to convert to upper case.</td></tr></tbody></table>
If multiple locales are given in an Array, the best available locale is used. 

The default locale is the host environment's current locale.

<h3>Return value</h3>
A new string representing the calling string converted to upper case, according to any locale-specific case mappings.

<h3>Using toLocaleUpperCase()</h3>

let a = 'alphabet'.toLocaleUpperCase(); // 'ALPHABET'
console.log(a);

a = 'Ges'.toLocaleUpperCase(); // 'GES
console.log(a);

a = 'i\u0307'.toLocaleUpperCase('lt-LT'); // 'I'
console.log(a);

let locales = ['lt', 'LT', 'lt-LT', 'lt-u-co-phonebk', 'lt-x-lietuva'];
a = 'i\u0307'.toLocaleUpperCase(locales); // 'I'
console.log(a);

Result



<h2>String toLowerCase()</h2>

The <i>toLowerCase</i>() method returns the calling string value converted to lower case.

<h3>Syntax</h3>

str.toLowerCase()

<h3>Return value</h3>
A new string representing the calling string converted to lower case.

<i>toLowerCase</i>() does not affect the value of the string str itself.

Using <i>toLowerCase</i>()

console.log('ALPHABET'.toLowerCase()); // 'alphabet'

Result



<h2>String toString()</h2>

The <i>toString</i>() method returns a string representing the specified object.

<h3>Syntax</h3>

str.<b>toString</b>()

<h3>Return value</h3>
A string representing the calling object.

Using <i>toString</i>()

The following example displays the string value of a String object:

var x = new <b>String</b>('Hello world');

console.log(x.<b>toString</b>()); // logs 'Hello world'

Result



<h2>String toUpperCase()</h2>

The <i>toUpperCase</i>() method returns the calling string value converted to uppercase.

<h3>Syntax</h3>

str.toUpperCase()

<h3>Return value</h3>
A new string representing the calling string converted to upper case.

Basic usage

console.log('alphabet'.toUpperCase()); // 'ALPHABET'

<h2>String trim()</h2>

The <i>trim</i>() method removes whitespace from both ends of a string. 

Whitespace includes all the whitespace characters (space, tab, no-break space, etc.) and all the line terminator characters (LF, CR, etc.).

<h3>Syntax</h3>

str.trim()

<h3>Return value</h3>
A new string representing the str stripped of whitespace from both ends.

Using <i>trim</i>()

The following example displays the lowercase string 'foo':

var orig = '   foo  ';
console.log(orig.trim()); // 'foo'

Result

 Another example of .<i>trim</i>() removing whitespace from just one side.

var orig = 'foo    ';
console.log(orig.trim()); // 'foo'

Result



<h2>String trimEnd()</h2>

The <i>trimEnd</i>() method removes whitespace from the end of a string. 

<i>trimRight</i>() is an alias of this method.

<h3>Syntax</h3>

str.trimEnd();
str.trimRight();

<h3>Return value</h3>
A new string representing the calling string stripped of whitespace from its (right) end.

<h3>Description</h3>
The <i>trimEnd</i>() / <i>trimRight</i>() methods return the string stripped of whitespace from its right end. 

<i>trimEnd</i>() or <i>trimRight</i>() do not affect the value of the string itself.

The following example displays the lowercase string '  foo':

var str = '   foo  ';

console.log(str.<b>length</b>); // 8

str = str.trimEnd();
console.log(str.<b>length</b>); // 6
console.log(str);        // '   foo'

Result



<h2>String trimStart()</h2>

The <i>trimStart</i>() method removes whitespace from the beginning of a string. 

<i>trimLeft</i>() is an alias of this method.

<h3>Syntax</h3>

str.trimStart();
str.trimLeft();

<h3>Return value</h3>
A new string representing the calling string stripped of whitespace from its beginning (left end).

The following example displays the lowercase string 'foo  ':

var str = '   foo  ';

console.log(str.<b>length</b>); // 8

str = str.trimStart();
console.log(str.<b>length</b>); // 5
console.log(str);        // 'foo  '

Result



<h2>String valueOf()</h2>

The <i>valueOf</i>() method returns the primitive value of a String object.

<h3>Syntax</h3>

str.<b>valueOf</b>()

<h3>Return value</h3>
A string representing the primitive value of a given String object.

This method is usually called internally by JavaScript.

<h3>Examples</h3>
<h3>Using valueOf()</h3>

var x = new <b>String</b>('Hello world');
console.log(x.<b>valueOf</b>()); // Displays 'Hello world'

Result



<h2>Symbol Type Introduction</h2>

ECMAScript Symbols are primitive values, and symbol instances
are unique and immutable.

A symbol is a unique identifier for object properties.

The symbols should be used as unique tokens to identify special properties.

<h3>Basic Symbol Use</h3>
Symbols are instantiated using the <b>Symbol</b> function.

Because it is its own primitive type, the <i>typeof</i> operator will identify a symbol as <i>symbol</i>.

let sym = Symbol();
console.log(<b>typeof</b> sym);  // symbol

When invoking the function, you can provide an optional string that can be used for identifying the
symbol instance when debugging.

let genericSymbol = Symbol();
console.log(genericSymbol);  // Symbol()

let fooSymbol = Symbol('foo');
console.log(fooSymbol);      // Symbol(foo);

Output:

The string you provide is totally separate from the symbol's definition or identity:

let genericSymbol = Symbol();
let otherGenericSymbol = Symbol();

let fooSymbol = Symbol('foo');
let mySymbol = Symbol('foo');

console.log(genericSymbol == otherGenericSymbol);  // false
console.log(fooSymbol == mySymbol);          // false

We can create a new Symbol instance and use it to key a
new property on an object.

In this way we can guarantee that we will not overwrite an existing object property.

The <b>Symbol</b> function cannot be used with the <i>new</i> keyword.

This avoids symbol object wrappers, as is possible with Boolean, String, and Number, which support
constructor behavior and instantiate a primitive wrapper object:

let myBoolean = new <b>Boolean</b>();
console.log(<b>typeof</b> myBoolean);  // "object"

let myString = new <b>String</b>();
console.log(<b>typeof</b> myString);   // "object"

let myNumber = new <b>Number</b>();
console.log(<b>typeof</b> myNumber);   // "object"

let mySymbol = new Symbol();  // TypeError: Symbol is not a constructor

To utilize an object wrapper for symbol, you can make use of the <b>Object</b>() function:

let mySymbol = Symbol();
let myWrappedSymbol = <b>Object</b>(mySymbol);
console.log(<b>typeof</b> myWrappedSymbol);  // "object"

<h2>Using the Global Symbol Registry</h2>

We can create and reuse symbols in a string-keyed global symbol registry.

let fooGlobalSymbol = Symbol.for('foo');
console.log(<b>typeof</b> fooGlobalSymbol);  // "object"

Symbol.<i>for</i>() is an idempotent operation for each string key.

The first time it is called with a given
string, it will check the global runtime registry, find that no symbol exists, generate a new
symbol instance, and add it to the registry.

Additional invocations with the same string key will check
the global runtime registry, find that a symbol does exist for that string, and return that symbol
instance instead.

let fooGlobalSymbol = Symbol.for('foo');          // creates new symbol
let mySymbol = Symbol.for('foo');     // reuses existing symbol

console.log(fooGlobalSymbol === mySymbol);  // true

Symbols defined in the global registry are totally distinct from symbols created using <b>Symbol</b>(), even
if they share a description:

let localSymbol = Symbol('foo');
let globalSymbol = Symbol.for('foo');

console.log(localSymbol === globalSymbol);  // false

The global registry requires string keys, so anything you provide as an argument to Symbol.<i>for</i>()
will be converted to a string.

Additionally, the key used for the registry will also be used as the symbol description.

let emptyGlobalSymbol = Symbol.for();
console.log(emptyGlobalSymbol);   // Symbol(undefined)

let globalSymbol = Symbol.for('foo');
console.log(globalSymbol);   // Symbol(foo)

We can check the global registry using Symbol.<i>keyFor</i>(), which accepts a symbol
and will return the global string key for that global symbol, or undefined if the symbol is not a
global symbol.

// Create global symbol
let s = Symbol.for('foo');
console.log(Symbol.keyFor(s));   // foo

// Create regular symbol
let s2 = Symbol('bar');
console.log(Symbol.keyFor(s2));  // undefined

Using Symbol.<i>keyFor</i>() with a non-symbol will throw a TypeError:

Symbol.keyFor(123);  // TypeError: 123 is not a symbol

<h2>Using Symbols as Properties</h2>

Anywhere you can normally use a string or number property, you can also use a symbol.

This includes object literal properties and <b>Object.defineProperty()/Object.defineProperties()</b>.

An object literal can only use a symbol as a property inside the computed property syntax.

let s1 = Symbol('test'),
    s2 = Symbol('demo'),
    s3 = Symbol('baz'),
    s4 = Symbol('qux');

let o = {//   w   w  w  .  d e m    o  2 s .   c o    m
  [s1]: 'test val'
};
// Also valid:   o[s1] = 'test val';

console.log(o);
// {Symbol{test}: test val}

<b>Object</b>.defineProperty(o, s2, {value: 'demo val'});

console.log(o);
// {Symbol{test}: test val, Symbol(demo): demo val}

<b>Object</b>.defineProperties(o, {
  [s3]: {value: 'baz val'},
  [s4]: {value: 'qux val'}
});

console.log(o);
// {Symbol{test}: test val, Symbol(demo): demo val,
//  Symbol{baz}: baz val, Symbol(qux): qux val}

Object.<i>getOwnPropertyNames</i>() returns an array of regular properties on an object instance.

Object.<i>getOwnPropertySymbols</i>() returns an array of symbol properties on an object instance.

The return values of these two methods are mutually exclusive.

Object.<i>getOwnPropertyDescriptors</i>() will return an object containing both regular and symbol
property descriptors.

Reflect.<i>ownKeys</i>() will return both types of keys:

let s1 = Symbol('test'),
    s2 = Symbol('demo');

let o = {//    w w  w   .d  e    m  o 2   s.   c  o m  
    [s1]: 'test val',
    [s2]: 'demo val',
    baz: 'baz val',
    qux: 'qux val'
};

console.log(<b>Object</b>.getOwnPropertySymbols(o));
// [Symbol(test), Symbol(demo)]

console.log(<b>Object</b>.getOwnPropertyNames(o));
// ["baz", "qux"]

console.log(<b>Object</b>.getOwnPropertyDescriptors(o));
// {baz: {...}, qux: {...}, Symbol(test): {...}, Symbol(demo): {...}}

console.log(Reflect.ownKeys(o));
// ["baz", "qux", Symbol(test), Symbol(demo)]

Symbols can be directly created and used as properties.

We can traverse all the object's symbol properties to get the property key:

let o = {
   [Symbol('test')]: 'test val',
   [Symbol('demo')]: 'demo val'
};

console.log(o);
// {Symbol(test): "test val", Symbol(demo): "demo val"}

let demoSymbol = <b>Object</b>.getOwnPropertySymbols(o)
              .<b>find</b>((symbol) => symbol.<b>toString</b>().match(/demo/));

console.log(demoSymbol);
// Symbol(demo)

<h2>Well-Known Symbols</h2>

ECMAScript 6 introduced a collection of well-known
symbols that would be used throughout the language to expose internal language behaviors for direct
access, overriding, or emulating.

These well-known symbols exist as string properties on the Symbol factory function.

We can redefine well-known symbols to alter the behavior of the native language constructs.

For example, the for-of loop will use the
Symbol.iterator property, we can provide a custom
definition of Symbol.iterator's value in a custom object in order to control how for-of behaves for that
object.

These well-known symbols are regular string properties on the Symbol global that identify an instance of a symbol.

Each well-defined symbol property is non-writeable, non-enumerable, and non-configurable.

The well-known symbols are referred by their specification names prefixed with @@.

For example, @@iterator refers to Symbol.iterator.

<h2>Well Known Symbol Symbol.asyncIterator</h2>

Well Known Symbol <b>Symbol.asyncIterator</b> is used as a property for "A method that returns the
default AsyncIterator for an object. Called by the semantics of the for-await-of statement".

It is used to identify the function that implements the asynchronous iterator API.

The for-await-of loop uses this function to perform asynchronous iteration.

They will invoke the function keyed by <b>Symbol.asyncIterator</b> and expect it
to return an object which implements the Iterator API.

In many cases, this will take the form of an
AsyncGenerator, an object which implements this API:

<b>class</b> Foo {
  async *[Symbol.asyncIterator]() {}
}

let f = new Foo();

console.log(f[Symbol.asyncIterator]());
// AsyncGenerator {&lt;suspended>}

The object produced by the <b>Symbol.asyncIterator</b> function should sequentially
produce <b>Promise</b> instances via its <i>next</i>() method.

This can be through explicit <i>next</i>() method definition or implicitly through an async generator function:

<b>class</b> Emitter {/* w  w w   .   d  em    o 2  s   .c   o m  */
  <b>constructor</b>(max) {
    this.max = max;
    this.asyncIdx = 0;
  }

  async *[Symbol.asyncIterator]() {
    while(this.asyncIdx &lt; this.max) {
      yield new Promise((resolve) => resolve(this.asyncIdx++));
    }
  }
}

async function asyncCount() {
  let emitter = new Emitter(5);

  for await(<b>const</b> x of emitter) {
    console.log(x);
  }
}

asyncCount();

Output:

Symbol.asyncIterator is part of the ES2018 specification.

<h2>Well Known Symbol Symbol.hasInstance</h2>

ECMAScript Well Known Symbol Symbol.hasInstance is used as a property for "A method that determines if
a constructor object recognizes an object as one of the constructor's instances.
Called by the semantics of the instanceof operator".

The <i>instanceof</i> operator provides a way of determining if an
object instance has a prototype in its prototype chain.

Typical use of the <i>instanceof</i> is as follows:

function Demo() {}
let f = new Demo();
console.log(f instanceof Demo);  // true

<b>class</b> Test {}
let b = new Test();
console.log(b instanceof Test);  // true

In ES6, the <i>instanceof</i> operator is using a Symbol.hasInstance function to evaluate this
relationship.

The Symbol.hasInstance identifies a function which performs the same behavior but with the
operands reversed:

function Demo() {}
let f = new Demo();
console.log(Demo[Symbol.hasInstance](f));  // true

<b>class</b> Test {}
let b = new Test();
console.log(Test[Symbol.hasInstance](b));  // true

This property is defined on the <b>Function</b> prototype, and therefore it is automatically available by
default to all function and class definitions.

Because the <i>instanceof</i> operator will seek the property
definition on the prototype chain like any other property, it is possible to redefine the function on an
inherited class as a static method:

<b>class</b> Test {}

<b>class</b> Baz <b>extends</b> Test {
  static [Symbol.hasInstance]() {
    return false;
  }
}

let b = new Baz();
console.log(Test[Symbol.hasInstance](b));  // true
console.log(b instanceof Test);            // true
console.log(Baz[Symbol.hasInstance](b));  // false
console.log(b instanceof Baz);            // false

<h2>Well Known Symbol Symbol.isConcatSpreadable</h2>

ECMAScript Well Known Symbol Symbol.isConcatSpreadable is used as a property for "A Boolean valued property
that if true indicates that an object should be flattened to its array elements by Array.prototype.<i>concat</i>()".

The Array.prototype.concat method in ES6 will select how to join an array-like
object to the array instance based on the type of object it is passed.

The value of Symbol.isConcatSpreadable allows you to override this behavior.

Array objects by default will be flattened into the existing array; a value of false or falsy value will
append the entire object to the array.

Array-like objects by default will be appended to the array; a
value of true or truthy value will flatten the array-like object into the array instance.

Other objects which are not array-like will be ignored when Symbol.isConcatSpreadable is set to true.

let initial = ['test'];

let array = ['demo'];
console.log(array[Symbol.isConcatSpreadable]);  // undefined
console.log(initial.concat(array));             // ['test', 'demo']
array[Symbol.isConcatSpreadable] = false;
console.log(initial.concat(array));             // ['test', Array(1)]

let test = { <b>length</b>: 1, 0: 'baz' };
console.log(test[Symbol.isConcatSpreadable]);  // undefined
console.log(initial.concat(test));             // ['test', {...}]
test[Symbol.isConcatSpreadable] = true;
console.log(initial.concat(test));             // ['test', 'baz']

let otherObject = new Set().add('qux');
console.log(otherObject[Symbol.isConcatSpreadable]);  // undefined
console.log(initial.concat(otherObject));             // ['test', Set(1)]
otherObject[Symbol.isConcatSpreadable] = true;
console.log(initial.concat(otherObject));             // ['test']

<h2>Well Known Symbol Symbol.iterator</h2>

ECMAScript Well Known Symbol Symbol.iterator is used as a property for "A method that returns the
default Iterator for an object. Called by the semantics of the for-of statement".

It is used to identify the function that implements the iterator API.

Javascript <i>for-of</i> loop make use of this function to perform iteration.

They will invoke the function identified by Symbol.iterator and expect it to return an object which
implements the Iterator API.

In many cases, this will take the form of a Generator, an object which implements this API:

<b>class</b> Foo {
  *[Symbol.iterator]() {}
 }

let f = new Foo();

console.log(f[Symbol.iterator]());
// Generator {&lt;suspended>}

Specifically, the object produced by the Symbol.iterator function should sequentially produce
values via its <i>next</i>() method.

This can be through explicit <i>next</i>() method definition or implicitly through a generator function:

<b>class</b> Emitter {/*w    w  w.    d  em    o2   s  .   c o m  */
  <b>constructor</b>(max) {
    this.max = max;
    this.idx = 0;
  }

  *[Symbol.iterator]() {
    while(this.idx &lt; this.max) {
      yield this.idx++;
    }
  }
}

function count() {
  let emitter = new Emitter(5);

  for (<b>const</b> x of emitter) {
    console.log(x);
  }
}

count();

Output:



<h2>Well Known Symbol Symbol.match</h2>

ECMAScript Well Known Symbol Symbol.match is used as a property for "A regular expression method
that matches the regular expression against a string. Called by the String.prototype.<i>match</i>()
method".

The String.prototype.<i>match</i>() method will use the function identified by Symbol.match
to evaluate the expression.

The regular expression prototype has this function defined by default, and
therefore all regular expression instances are valid parameters to the String method by default:

console.log(<b>RegExp</b>.<b>prototype</b>[Symbol.match]);
//f [Symbol.match]() { [native code] }

console.log('foobar'.match(/bar/));
//  ["bar", index: 3, input: "foobar", groups: undefined]

Providing something other than a regular expression to this method will cause it to be converted to
a RegExp object.

This function has a single parameter which is the string instance
upon which <i>match</i>() is invoked. The return value is unrestricted:

<b>class</b> FooMatcher {//   w   w w  .   de   m o    2 s   .  c o m  
  static [Symbol.match](target) {
    return target.includes('foo');
  }
 }

console.log('foobar'.match(FooMatcher));  // true
console.log('barbaz'.match(FooMatcher));  // false

<b>class</b> StringMatcher {
  <b>constructor</b>(str) {
    this.str = str;
  }

   [Symbol.match](target) {
    return target.includes(this.str);
  }
 }

console.log('foobar'.match(new StringMatcher('foo')));  // true
console.log('barbaz'.match(new StringMatcher('qux')));  // false

<h2>Well Known Symbol Symbol.replace</h2>

ECMAScript Well Known Symbol Symbol.replace is used as a property for "A regular expression method
that replaces matched substrings of a string. Called by the String.prototype.<i>replace</i>() method".

The String.prototype.<i>replace</i>() method will use the function identified by Symbol.replace to
evaluate the expression.

The regular expression prototype has this function defined by default, and
therefore all regular expression instances are valid parameters to the String method by default:

console.log(<b>RegExp</b>.<b>prototype</b>[Symbol.replace]);
// f[Symbol.replace]() { [native code] }

console.log('foobarbaz'.replace(/bar/, 'qux'));
// 'fooquxbaz'

Providing something other than a regular expression to this method will cause it to be converted to
a RegExp object.

This function has two parameters, the string instance upon which
<i>replace</i>() is invoked and the replacement string.

The return value is unrestricted:

<b>class</b> FooReplacer {//  w   w  w   .d   e  m  o   2  s . c    o  m
    static[Symbol.replace](target, replacement) {
        return target.split('foo').join(replacement);
    }
}
console.log('barfoobaz'.replace(FooReplacer, 'qux'));
// "barquxbaz"

<b>class</b> StringReplacer {
    <b>constructor</b>(str) {
        this.str = str;
    }

    [Symbol.replace](target, replacement) {
        return target.split(this.str).join(replacement);
    }
}

console.log('barfoobaz'.replace(new StringReplacer('foo'), 'qux'));
// "barquxbaz"

<h2>Well Known Symbol Symbol.search</h2>

ECMAScript Well Known Symbol Symbol.search is used as a property for "A regular expression method
that returns the index within a string that matches the regular expression. Called by the String
.prototype.<i>search</i>() method".

The String.prototype.<i>search</i>() method will use the function identified by Symbol.search to evaluate the expression.

The regular expression prototype has this function defined by default, and therefore all regular expression instances are valid parameters to the
String method by default:

console.log(<b>RegExp</b>.<b>prototype</b>[Symbol.search]);
// f [Symbol.search]() { [native code] }

console.log('foobar'.search(/bar/));
// 3

Providing something other than a regular expression to this method will cause it to be converted to
a RegExp object.

This function has a single parameter which is the string instance
upon which <i>search</i>() is invoked.

The return value is unrestricted:

<b>class</b> FooSearcher {//    w  ww  .  d  e    m  o 2 s  .  c    om  
    static[Symbol.search](target) {
        return target.indexOf('foo');
    }
}

console.log('foobar'.search(FooSearcher)); // 0
console.log('barfoo'.search(FooSearcher)); // 3
console.log('barbaz'.search(FooSearcher)); // -1

<b>class</b> StringSearcher {
    <b>constructor</b>(str) {
            this.str = str;
        }
        [Symbol.search](target) {
            return target.indexOf(this.str);
        }
}

console.log('foobar'.search(new StringSearcher('foo'))); // 0
console.log('barfoo'.search(new StringSearcher('foo'))); // 3
console.log('barbaz'.search(new StringSearcher('qux'))); // -1

<h2>Well Known Symbol Symbol.species</h2>

ECMAScript  Well Known Symbol Symbol.species is used as a property for "A function valued property
that is the constructor function that is used to create derived objects".

This is most commonly used
for build-in types which expose methods that instantiate derived objects for the return value of an
instance method.

Defining a static getter method with Symbol.species allows you to override the
prototype definition for the newly created instance:

<b>class</b> Bar <b>extends</b> <b>Array</b> {}
<b>class</b> Test <b>extends</b> <b>Array</b> {
  static get [Symbol.species]() {//   w   ww   .  d  e   m  o 2  s .   c o    m
    return <b>Array</b>;
  }
}

let bar = new Bar();
console.log(bar instanceof <b>Array</b>);  // true
console.log(bar instanceof Bar);    // true
bar = bar.concat('bar');
console.log(bar instanceof <b>Array</b>);  // true
console.log(bar instanceof Bar);    // true

let baz = new Test();
console.log(baz instanceof <b>Array</b>);  // true
console.log(baz instanceof Test);    // true
baz = baz.concat('baz');
console.log(baz instanceof <b>Array</b>);  // true
console.log(baz instanceof Test);    // false

<h2>Well Known Symbol Symbol.split</h2>

ECMAScript Well Known Symbol Symbol.split is used as a property for "A regular expression
method that splits a string at the indices that match the regular expression. Called by the String
.prototype.<i>split</i>() method".

The String.prototype.<i>split</i>() method will use the function
identified by Symbol.split to evaluate the expression.

The regular expression prototype has this function defined by default, and therefore all regular expression instances are valid parameters to the
String method by default:

console.log(<b>RegExp</b>.<b>prototype</b>[Symbol.split]);
// f [Symbol.split]() { [native code] }

console.log('footestbaz'.split(/test/));
// ['foo', 'baz']

Providing something other than a regular expression to this method will cause it to be converted to
a RegExp object.

This function has a single parameter which is the string instance
upon which <i>split</i>() is invoked. The return value is unrestricted:

<b>class</b> FooSplitter {/*w    w w   .d  e  m    o2    s.    c  om  */
  static [Symbol.split](target) {
    return target.split('foo');
  }
}

console.log('testfoobaz'.split(FooSplitter));
// ["test", "baz"]

<b>class</b> StringSplitter {
  <b>constructor</b>(str) {
    this.str = str;
  }

   [Symbol.split](target) {
    return target.split(this.str);
  }
}

console.log('testfoobaz'.split(new StringSplitter('foo')));
// ["test", "baz"]

<h2>Well Known Symbol Symbol.toPrimitive</h2>

ECMAScript Well Known Symbol Symbol.toPrimitive is used as a property for "A method that converts an
object to a corresponding primitive value. Called by the ToPrimitive abstract operation".

There are a number of built-in operations which will attempt to coerce an object into a primitive value: a
string, a number, or an unspecified primitive type.

For a custom object instance, it is possible to divert
this behavior by defining a function on the instance's Symbol.toPrimitive property.

Based on a string parameter provided to the function, you are
able to control the returned primitive:

<b>class</b> Foo {}/*w    w  w .   d e  m   o  2  s  .  co   m */
let foo = new Foo();

console.log(3 + foo); // "3[object Object]"
console.log(3 - foo); // NaN
console.log(<b>String</b>(foo)); // "[object Object]"

<b>class</b> Bar {
    <b>constructor</b>() {
        this[Symbol.toPrimitive] = function(hint) {
            switch (hint) {
                case 'number':
                    return 3;
                case 'string':
                    return 'string test';
                case 'default':
                default:
                    return 'default test';
            }
        }
    }
}
let test = new Bar();

console.log(3 + test); // "3default test"
console.log(3 - test); // 0
console.log(<b>String</b>(test)); // "string test"

<h2>Well Known Symbol Symbol.toStringTag</h2>

ECMAScript Well Known Symbol Symbol.toStringTag is used as a property for "A String valued property that
is used in the creation of the default string description of an object. Accessed by the built-in method
Object.prototype.<i>toString</i>()".

Object identification via the <i>toString</i>() method will retrieve the instance identifier specified by
Symbol.toStringTag, defaulting to Object.

Built-in types have this value already specified, but
custom class instances require explicit definition:

let s = new Set();

console.log(s);                      // Set(0) {}
console.log(s.<b>toString</b>());           // [object Set]
console.log(s[Symbol.toStringTag]);  // Set

<b>class</b> Foo {}//    w  w w  .   de  m    o  2 s .    c o m  
let foo = new Foo();

console.log(foo);                      // Foo {}
console.log(foo.<b>toString</b>());           // [object Object]
console.log(foo[Symbol.toStringTag]);  // undefined

<b>class</b> Bar {
  <b>constructor</b>() {
    this[Symbol.toStringTag] = 'Bar';
  }
}
let bar = new Bar();

console.log(bar);                      // Bar {}
console.log(bar.<b>toString</b>());           // [object Bar]
console.log(bar[Symbol.toStringTag]);  // Bar

<h2>Well Known Symbol Symbol.unscopables</h2>

ECMAScript Well Known Symbol Symbol.unscopables is used as a property for "An object valued
property whose own and inherited property names are property names that are excluded from the with
environment bindings of the associated object".

Setting this symbol so it keys an object mapping a
corresponding property to true will prevent a with environment binding, as shown here:

let o = { foo: 'test' };
with (o) {
  console.log(foo);  // test
}

o[Symbol.unscopables] = {
  foo: true
};

with (o) {
  console.log(foo);  // ReferenceError
}

It's not recommended to use <i>with</i> statement, so using <b>Symbol.unscopables</b> is also
not recommended.

<h2>Operators</h2>

ECMA-262 describes a set of operators that can be used to manipulate data values.

The operators
range from mathematical operations, such as addition and subtraction, and bitwise operators to
relational operators and equality operators.

Operators in ECMAScript can be
used on a wide range of values, including strings, numbers, Booleans, and even objects.

When used on
objects, operators typically call the <i>valueOf</i>() and/or <i>toString</i>() method to retrieve a value they
can work with.

<h3>Unary Operators</h3>
Operators that work on only one value are called unary operators. They are the simplest operators in
ECMAScript.

<h2>Increment Decrement Operators</h2>

The increment and decrement operators are taken directly from C and come in two versions: prefix
and postfix.

The prefix versions of the operators are placed before the variable they work on; the
postfix ones are placed after the variable.

To use a prefix increment, which adds 1 to a numeric value,
you place two plus signs (++) in front of a variable like this:

let myValue = 29;
++myValue;

In this example, the prefix increment changes the value of <i>myValue</i> to 30 by adding 1 to its previous value
of 29.

This is effectively equal to the following:

let myValue = 29;
myValue = myValue + 1;

The prefix decrement acts in a similar manner, subtracting 1 from a numeric value.

To use a prefix decrement, place two minus signs (--) before a variable, as shown here:

let myValue = 29;
--myValue;

Here the <i>myValue</i> variable is decremented to 28 by subtracting 1 from 29.

When using either a prefix increment or a prefix decrement, the variable's value is converted before
the statement is evaluated.

Consider the following:

let myValue = 29;
let otherValue = --myValue + 2;

console.log(myValue);         // 28
console.log(otherValue);  // 30

In this example, the variable <i>otherValue</i> is initialized with the decremented value of <i>myValue</i> plus 2.

Because the decrement happens first, <i>myValue</i> is set to 28, and then 2 is added, resulting in 30.

The prefix increment and decrement are equal in terms of order of precedence in a statement and are
therefore evaluated left to right.

Consider this example:

let num1 = 2;
let num2 = 20;
let num3 = --num1 + num2;
let num4 = num1 + num2;
console.log(num3);  // 21
console.log(num4);  // 21

Here, <i>num3</i> is equal to 21 because <i>num1</i> is decremented to 1 before the addition occurs.

The variable <i>num4</i> also contains 21, because the addition is also done using the changed values.

The postfix versions of increment and decrement use the same syntax (++ and  --, respectively) but
are placed after the variable instead of before it.

Postfix increment and decrement differ from the
prefix versions in one important way: the increment or decrement doesn't occur until after the containing statement has been evaluated.

In certain circumstances, this difference doesn't matter, as in
this example:

let myValue = 29;
myValue++;

Moving the increment operator after the variable doesn't change what these statements do, because
the increment is the only operation occurring.

However, when mixed together with other operations,
the difference becomes apparent, as in the following example:

let num1 = 2;
let num2 = 20;
let num3 = num1-- + num2;
let num4 = num1 + num2;
console.log(num3);  // 22
console.log(num4);  // 21

With just one simple change in this example, using postfix decrement instead of prefix, you can see
the difference.

In the prefix example, <i>num3</i> and <i>num4</i> both ended up equal to 21, whereas this example ends with num3 equal to 22 and <i>num4</i> equal to 21.

The difference is that the calculation for <i>num3</i>
uses the original value of <i>num1</i> (2) to complete the addition, whereas num4 is using the decremented
value (1).

<h3>Converting Rules</h3>
All four of these operators work on any values, meaning not just integers but strings, Booleans,
floating-point values, and objects.

The increment and decrement operators follow these rules regarding values:

When used on a string that is a valid representation of a number, convert to a number and apply the change. The variable is converted from a string to a number.
When used on a string that is not a valid number, the variable's value is set to NaN. The variable is converted from a string to a number.
When used on a Boolean value that is false, convert to 0 and apply the change. The variable is converted from a Boolean to a number.
When used on a Boolean value that is true, convert to 1 and apply the change. The variable is converted from a Boolean to a number.
When used on a floating-point value, apply the change by adding or subtracting 1.
When used on an object, call its <i>valueOf</i>() method to get a value to work with. Apply the other rules. If the result is NaN, then call <i>toString</i>() and apply the other rules again. The variable is converted from an object to a number.

The following example demonstrates some of these rules:

let s1 = "2";
let s2 = "z";
let b = false;
let f = 1.1;
let o = {
  <b>valueOf</b>() {
    return -2;
  }
};

s1++;  // value becomes numeric 3
s2++;  // value becomes NaN
b++;   // value becomes numeric 1
f--;   // value becomes 0.10000000000000009 (due to floating-point inaccuracies)
o--;   // value becomes numeric -3

<h2>Unary Plus and Minus Operator</h2>

The unary plus is represented by a single plus
sign (+) placed before a variable and does nothing to a numeric value, as shown in this example:

let num = 25;
num = +num;
console.log(num);  // 25

When the unary plus is applied to a nonnumeric value, it performs the same conversion as the <b>Number</b>() casting function:

the Boolean values of false and true are converted to 0 and 1,
string values are parsed according to a set of specific rules, and
objects have their <i>valueOf</i>() and/or <i>toString</i>() method called to get a value to convert.

The following example demonstrates the behavior of the unary plus when acting on different
data types:

let s1 = "01";
let s2 = "1.1";
let s3 = "z";
let b = false;
let f = 1.1;
let o = {
  <b>valueOf</b>() {
    return -1;
  }
};

s1 = +s1;  // value becomes numeric 1
s2 = +s2;  // value becomes numeric 1.1
s3 = +s3;  // value becomes NaN
b = +b;    // value becomes numeric 0
f = +f;    // no change, still 1.1
o = +o;    // value becomes numeric -1

<h3>unary minus</h3>
The unary minus operator's primary use is to negate a numeric value, such as converting 1 into -1.

The simple case is illustrated here:

let num = 25;
num = -num;
console.log(num);  // -25

When used on a numeric value, the unary minus simply negates the value.

When used on nonnumeric values, unary minus applies all of the same rules as unary plus and then negates
the result, as shown here:

let s1 = "01";
let s2 = "1.1";
let s3 = "z";
let b = false;
let f = 1.1;
let o = {
  <b>valueOf</b>() {
    return -1;
  }
};

s1 = -s1;  // value becomes numeric -1
s2 = -s2;  // value becomes numeric -1.1
s3 = -s3;  // value becomes NaN
b = -b;    // value becomes numeric 0
f = -f;    // change to -1.1
o = -o;    // value becomes numeric 1

The unary plus and minus operators are used primarily for basic arithmetic but can also be useful for conversion purposes.

<h2>Number bit format for Bitwise Operators</h2>

<h3>Bits</h3>
All numbers in ECMAScript are stored in IEEE-754 64-bit format, but the bitwise
operations do not work directly on the 64-bit representation.

Instead, the value is converted into a
32-bit integer, the operation takes place, and the result is converted back into 64 bits.

To the developer, it appears that only the 32-bit integer exists because the 64-bit storage format is transparent.

Signed integers use the first 31 of the 32 bits to represent the numeric value of the integer.

The 32nd bit represents the sign of the number: 0 for positive or 1
for negative. Depending on the value of that bit, called
the sign bit, the format of the rest of the number is determined.

Positive numbers are stored in true binary format, with each of the 31 bits representing a power of 2, starting with the first bit (called bit 0) representing 2<sup>0</sup>, the second bit represents 2<sup>1</sup>.

If any bits are unused, they are filled with 0 and essentially
ignored.

For example, the number 18 is represented as 00000000000000000000000000010010, or more succinctly as 10010.

These are the five most
significant bits and can be used, by themselves, to determine the actual value.

<h3>Negative numbers</h3>
Negative numbers are also stored in binary code but in a format called two's complement.

The two's complement of a number is calculated in three steps:

Determine the binary representation of the absolute value (for example, to find -18, first determine the binary representation of 18).
Find the one's complement of the number, which essentially means that every 0 must be
replaced with a 1, and vice versa.
Add 1 to the result.

Using this process to determine the binary representation -18, start with the binary representation of 18, which is the following:

0000 0000 0000 0000 0000 0000 0001 0010

Next, take the one's complement, which is the inverse of this number:

1111 1111 1111 1111 1111 1111 1110 1101

Finally, add 1 to the one's complement as follows:

1111 1111 1111 1111 1111 1111 1110 1101
                                      1
---------------------------------------
1111 1111 1111 1111 1111 1111 1110 1110

So the binary equivalent of -18 is 11111111111111111111111111101110.

Keep in mind that you have no access to bit 31 when dealing with signed integers.

When outputting a negative number as a binary string, you get the binary code of the absolute value preceded by a minus sign, as in
this example:

let num = -18;
console.log(num.<b>toString</b>(2));  // "-10010"

When you convert the number -18 to a binary string, the result is -10010.

The conversion process
interprets the two's complement and represents it in an arguably more logical form.

By default, all integers are represented as signed in ECMAScript.

In an unsigned integer, the 32nd
bit doesn't represent the sign because there are only positive numbers.

Unsigned integers can be larger, because the extra bit becomes part of the number
instead of an indicator of the sign.

<h3>Apply bitwise operators</h3>
When you apply bitwise operators to numbers in ECMAScript, a conversion takes place behind the
scenes: the 64-bit number is converted into a 32-bit number, the operation is performed, and then
the 32-bit result is stored back into a 64-bit number.

This gives the illusion that you're dealing with
true 32-bit numbers, which makes the binary operations work in a way similar to the operations of
other languages.

<b>NaN</b> and  <b>Infinity</b> both are treated as equivalent to 0 when used in bitwise operations.

If a bitwise operator is applied to a nonnumeric value, the value is first converted into a number using the <b>Number</b>() function and then the bitwise operation is applied.

The resulting value is a number.
<script src='https://williamkpchan.github.io/LibDocs/readbook.js'></script>
<script>
var lazyLoadInstance = new LazyLoad({
    elements_selector: ".lazy"
    // ... more custom settings?
});
</script>
