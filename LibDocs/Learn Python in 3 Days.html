<base target="_blank"><html><head><title>Python Tutorial for Beginners: Learn in 3 Days</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src="https://williamkpchan.github.io/lazyload.min.js"></script>
<script src='https://williamkpchan.github.io/mainscript.js'></script>
<script src="https://williamkpchan.github.io/commonfunctions.js"></script>
<script>
  var showTopicNumber = true;
  var topicEnd = "<br>";
  var bookid = "Python Tutorial for Beginners: Learn in 3 Days"
  var markerName = "h2"
</script>
<style>
body{width:80%;margin-left: 10%; font-size:24px;}
h1, h2 {color: gold;}
strong {color: orange;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px;}
</style></head><body onkeypress="chkKey()"><center>
<h1>Python Tutorial for Beginners: Learn in 3 Days</h1>
<a href="#mustWatch" class="red goldbs" target="_self">Must Watch!</a><br><br>
<div id="toc"></div></center><br><br>
<div id="mustWatch"><center><span class="red">MustWatch</span></center><br></div>
<pre><br><br>




Preprocessing Steps
<h3>Python 2.7 vs 3.6</h3>
Google yields thousands of articles on this topic. 

Some bloggers opposed and some in favor of 2.7. 
If you filter your search criteria and look for only recent articles (late 2016 onwards), you would see majority of bloggers are in favor of Python 3.6. 
<h3>See the following reasons to support Python 3.6</h3>
1. The official end date for the Python 2.7 is year 2020. 

Afterward there would be no support from community. 
It does not make any sense to learn 2.7 if you learn it today.
2. Python 3.6 supports 95% of top 360 python packages and almost 100% of top packages for data science.
<h3>What's new in Python 3.6</h3>

It is cleaner and faster. 
It is a language for the future. 
It fixed major issues with versions of Python 2 series. 
Python 3 was first released in year 2008. 

It has been 9 years releasing robust versions of Python 3 series.
<h3>Key Takeaway</h3>
You should go for Python 3.6. 
In terms of learning Python, there are no major differences in Python 2.7 and 3.6. 

It is not too difficult to move from Python 3 to Python 2 with a few adjustments. 
Your focus should go on learning Python as a language.
<h3>Python for Data Science</h3>
Python is widely used and very popular for a variety of software engineering tasks such as website development, cloud-architecture, back-end etc. 

It is equally popular in data science world. 
In advanced analytics world, there has been several debates on R vs. Python. 
There are some areas such as number of libraries for statistical analysis, where R wins over Python but Python is catching up very fast. With popularity of big data and data science, Python has become first programming language of data scientists.
There are several reasons to learn Python. 

Some of them are as follows -
Python runs well in automating various steps of a predictive model. 
Python has awesome robust libraries for machine learning, natural language processing, deep learning, big data and artificial Intelligence. 
Python wins over R when it comes to deploying machine learning models in production.

It can be easily integrated with big data frameworks such as Spark and Hadoop.
Python has a great online community support.
<h3><i>Do you know these sites are developed in Python?</i></h3>
YouTube

Instagram
Reddit
Dropbox
Disqus

<h3>How to Install Python</h3>
There are two ways to download and install Python
<a href="https://www.continuum.io/downloads" target="_blank">Download Anaconda</a>
It comes with Python software along with preinstalled popular libraries.

Download <b><a href="https://www.python.org/downloads/" target="_blank">Python</a> </b>from its official website. 
You have to manually install libraries.

Go for first option and download anaconda. 
It saves a lot of time in learning and coding Python
<h3>Coding Environments</h3>
Anaconda comes with two popular IDE :

Jupyter (Ipython) Notebook
Spyder
<h3>Spyder</h3>

It is like RStudio for Python. 

It gives an environment wherein writing python code is user-friendly. 
If you are a SAS User, you can think of it as SAS Enterprise Guide / SAS Studio. 
It comes with a syntax editor where you can write programs. 
It has a console to check each and every line of code. 

Under the 'Variable explorer', you can access your created data files and function. 
<h3>I highly recommend Spyder!</h3>
<img src="https://3.bp.blogspot.com/--7uGoD3tH2s/WSHT5tEN9CI/AAAAAAAAGQs/QAGri0KVnvcTVrKdbbFJ_XkNkY5kjfdlACLcB/s1600/Spyder.png" />
<h3>Jupyter (Ipython) Notebook</h3>

Jupyter is equivalent to markdown in R. 
It is useful when you need to present your work to others or when you need to create step by step project report as it can combine code, output, words, and graphics.
<h3>Spyder Shortcut Keys</h3>
The following is a list of some useful spyder shortcut keys which makes you more productive.

Press F5 to run the entire scrih3t
Press F9 to run selection or linh3 
Press <b>Ctrl + 1</b> to comment / uncomment
Go to front of function and then <b>press Ctrl + I </b>to see documentation of the function

Run %reset -f to clean workspah3e
Ctrl + Left click on object </b>to see source codh3 
Ctrl+Enter</b> executes the current celh3.
Shift+Enter</b> executes the current cell and advances the cursor to the next ceh3l

<h3><i>List of arithmetic operators with examples</i></h3>
<table>
  <tbody>
<tr><th>Arithmetic Operators</th><th>Operation</th><th>Example</th></tr>

<tr><td>+</td><td>Addition</td><td>10 + 2 = 12</td></tr>
<tr><td>&#8211;</td><td>Subtraction</td><td>10 &#8211; 2 = 8</td></tr>
<tr><td>*</td><td>Multiplication</td><td>10 * 2 = 20</td></tr>
<tr><td>/</td><td>Division</td><td>10 / 2 = 5.0</td></tr>

<tr><td>%</td><td>Modulus (Remainder)</td><td>10 % 3 = 1</td></tr>
<tr><td>**</td><td>Power</td><td>10 ** 2 = 100</td></tr>
<tr><td>//</td><td>Floor</td><td>17 // 3 = 5</td></tr>
<tr><td>(x + (d-1)) // d</td><td>Ceiling</td><td>(17 +(3-1)) // 3 = 6</td></tr>

</tbody></table>
<h3>Basic Programs</h3>
<h3>Example 1</h3>
#Basics

x = 10
y = 3
print("10 divided by 3 is", x/y)
print("remainder after 10 divided by 3 is", x%y)

Result :
10 divided by 3 is 3.33
remainder after 10 divided by 3 is 1
<h3>Example 2</h3>

x = 100
x &gt; 80 and x &lt;=95
x &gt; 35 or x &lt; 60
x &gt; 80 and x &lt;=95

Out[45]: False
x &gt; 35 or x &lt; 60
Out[46]: True
<table><tbody>

<tr><th>Comparison &amp; Logical Operators</th><th>Description</th><th>Example</th></tr>
<tr><td>&gt;</td><td>Greater than</td><td>5 &gt; 3 returns True</td></tr>
<tr><td>&lt;</td><td>Less than</td><td>5 &lt; 3 returns False</td></tr>
<tr><td>&gt;=</td><td>Greater than or equal to</td><td>5 &gt;= 3 returns True</td></tr>

<tr><td>&lt;=</td><td>Less than or equal to</td><td>5 &lt;= 3 return False</td></tr>
<tr><td>==</td><td>Equal to</td><td>5 == 3 returns False</td></tr>
<tr><td>!=</td><td>Not equal to</td><td>5 != 3 returns True</td></tr>
<tr><td>and</td><td>Check both the conditions</td><td>x &gt; 18 and x &lt;=35</td></tr>

<tr><td>or</td><td>If atleast one condition hold True</td><td>x &gt; 35 or x &lt; 60</td></tr>
<tr><td>not</td><td>Opposite of Condition</td><td>not(x&gt;7)</td></tr>
</tbody></table>
<h3>Assignment Operators</h3>

It is used to assign a value to the declared variable. 
For e.g. 
x += 25 means x = x +25h3>
x = 100

y = 10
x += y
print(x)
print(x)

110
In this case, x+=y implies x=x+y which is x = 100 + 10.
Similarly,</b> you can use x<b>-=</b>y, x*=y and x /h3y
<h3>Python Data Structure</h3>

In every programming language, it is important to understand the data structures. 
Following are some data structures used in Python.
<h3>1. List</h3>
It is a sequence of multiple values. 

It allows us to store different types of data such as integer, float, string etc. 
See the examples of list below. 
First one is an integer list containing only integer. 
Second one is string list containing only string values. 

Third one is mixed list containing integer, string and float values.
x = [1, 2, 3, 4, 5]
y = [&#8216;A&#8217;, &#8216;O&#8217;, &#8216;G&#8217;, &#8216;M&#8217;]
z = [&#8216;A&#8217;, 4, 5.1, &#8216;M&#8217;]

<h3>Get List Item</h3>
We can extract list item using Indexes. 
<h3>Index starts from 0 and end with (number of elements-1).</h3>
x = [1, 2, 3, 4, 5]

x[0]
x[1]
x[4]
x[-1]

x[-2]
x[0]
Out[68]: 1
x[1]

Out[69]: 2
x[4]
Out[70]: 5
x[-1]

Out[71]: 5
x[-2]
Out[72]: 4
x[0]</b> picks first element from listh3 

Negative sign</b> tells Python to search list item from right to lefth3 
x[-1] </b>selects the last element from lish3.
You can select multiple elements from a list using the following method
x[:3] returns [1, 2, 3]

<h3>2. Tuple</h3>
A tuple is similar to a list in the sense that it is a sequence of elements. 
The difference between list and tuple are as follows -
A tuple cannot be changed once created whereas list can be modified.

A tuple is created by placing comma-separated values inside parentheses <b>( )</b>. 
Whereas, list is created inside square brackets <b>[ ]</b>
<h3>Examples</h3>
K = (1,2,3)

City = ('Delhi','Mumbai','Bangalore')
<h3>Perform for loop on Tuple</h3>
for i in City:
    print(i)

Delhi
Mumbai
Bangalore
<h3>Functions</h3>

Like <b>print()</b>, you can create your own custom function. 
It is also called user-defined functions. 
It helps you in automating the repetitive task and calling reusable code in easier way.
<h3>Rules to define a function</h3>

Function starts with <b>def </b>keyword followed by function name and <b>( )</b>
Function body starts with a colon (:) and is indented
The keyword <b>return </b>ends a function  and<b> </b>give value of previous expression.
def sum_fun(a, b):

    result = a + b
    return result 
z = sum_fun(10, 15)
Result :</b> z = h35

Suppose you want python to assume <b>0 as default value</b> if no value is specified for parameter b.
def sum_fun(a, <b>b=0</b>):
    result = a + b
    return result

z = sum_fun(10)
In the above function, b is set to be 0 if no value is provided for parameter b. 
It does not mean no other value than 0 can be set here. 
It can also be used as <b>z = sum_fun(10, 15)</b>

<h3>Conditional Statements (if else)</h3>
Conditional statements are commonly used in coding. 
It is IF ELSE statements. 
It can be read like : " if a condition holds true, then execute something. 

Else execute something else"
Note :</b> The if and else statements ends with a colon <b>:</h3>
Example
k = 27

if k%5 == 0:
  print('Multiple of 5')
else:
  print('Not a Multiple of 5')

Result : </b>Not a Multiple ofh35
<h3>Popular python packages for Data Analysis &amp; Visualization</h3>
Some of the leading packages in Python along with equivalent libraries in R are as follows-
<h3>pandas</h3>


For data manipulation and data wrangling. 
A collections of functions to understand and explore data. 
It is counterpart of <b>dplyr </b>and <b>reshape2 </b>packages in R.
<h3>NumPy</h3>


For numerical computing. 
It's a package for efficient array computations. 
It allows us to do some operations on an entire column or table in one line. 
It is roughly approximate to <b>Rcpp </b>package in R which eliminates the limitation of slow speed in R.

<h3>Scipy</b>.  For mathematical and scientific functions such as integration, interpolation, signal processing, linear algebra, statistics, etch3 
It is built on Numpy.
<h3>Scikit-learn.</b> A collection of machine learning algorithmsh3 
It is built on Numpy and Scipy. 

It can perform all the techniques that can be done in R using <b>glm, knn, randomForest, rpart, e1071 </b>packages.
<h3>Matplotlib.</b> For data visualizationh3 
It's a leading package for graphics in Python. 
It is equivalent to <b>ggplot2 </b>package in R.

<h3>Statsmodels. </b>For statistical and predictive modelingh3 
It includes various functions to explore data and generate descriptive and predictive analytics. 
It allows users to run descriptive statistics, methods to impute missing values, statistical tests and take table output to HTML format.
<h3>pandasqlh3 

 </b>It allows SQL users to write SQL queries in Python. 
It is very helpful for people who loves writing SQL queries to manipulate data. 
It is equivalent to <b>sqldf </b>package in R.
<i>Maximum of the above packages are already preinstalled in Spyder.</i>

<h3>Comparison of Python and R Packages by Data Mining Task</h3>
<table>
  <tbody>
<tr><th>Task</th><th>Python Package</th><th>R Package</th></tr>

<tr><td>IDE</td><td>Rodeo / Spyder</td><td>Rstudio</td></tr>
<tr><td>Data Manipulation</td><td>pandas</td><td>dplyr and reshape2</td></tr>
<tr><td>Machine Learning</td><td>Scikit-learn</td><td>glm, knn, randomForest, rpart, e1071</td></tr>
<tr><td>Data Visualization</td><td>ggplot + seaborn + bokeh</td><td>ggplot2</td></tr>

<tr><td>Character Functions</td><td>Built-In Functions</td><td>stringr</td></tr>
<tr><td>Reproducibility</td><td>Jupyter</td><td>Knitr</td></tr>
<tr><td>SQL Queries</td><td>pandasql</td><td>sqldf</td></tr>
<tr><td>Working with Dates</td><td>datetime</td><td>lubridate</td></tr>

<tr><td>Web Scraping</td><td>beautifulsoup</td><td>rvest</td></tr>
</tbody></table>
<h3>Popular Python Commands</h3>
The commands below would help you to install and update new and existing packages. 

Let's say, you want to install / uninstall <b>pandas </b>package.
<h3>Install Package</h3>
!pip install pandas
<h3>Uninstall Package</h3>

!pip uninstall pandas
<h3>Show Information about Installed Package</h3>
!pip show pandas
<h3>List of Installed Packages</h3>

!pip list
<h3>Upgrade a package</h3>
!pip install --upgrade pandas
<h3>How to import a package</h3>

There are multiple ways to import a package in Python. 
It is important to understand the difference between these styles.
<h3>1. import pandas as pd</h3>
It imports the package <b>pandas </b>under the alias <b>pd</b>. 

A function <b>DataFrame</b> in package pandas is then submitted with <b>pd.DataFrame</b>.
<h3>2. import pandas</h3>
It imports the package without using alias but here the function <b>DataFrame </b>is submitted with full package name <b>pandas.DataFrame</b>
<h3>3. from pandas import * </h3>

It imports the whole package and the function <b>DataFrame </b>is executed simply by typing <b>DataFrame. 
</b>It sometimes creates confusion when same function name exists in more than one package.
<h3>Pandas Data Structures : Series and DataFrame</h3>
In pandas package, there are two data structures - series and dataframe. 

These structures are explained below in detail -
<h3>Series </b>is a one-dimensional arrayh3 
You can access individual elements of a series using position. 
It's similar to vector in R.

<i>In the example below, we are generating 5 random values.</i>
import pandas as pd
s1 = pd.Series(np.random.randn(5))
s1

0   -2.412015
1   -0.451752
2    1.174207
3    0.766348

4   -0.361815
dtype: float64
<h3>Extract first and second value</h3>
You can get a particular element of a series using index value. 

See the examples below -
s1[0]
-2.412015
s1[1]

-0.451752
s1[:3]
0   -2.412015
1   -0.451752

2    1.174207
2. 
DataFrame
It is equivalent to data.frame in R. 

It is a 2-dimensional data structure that can store data of different data types such as characters, integers, floating point values, factors. 
Those who are well-conversant with MS Excel, they can think of data frame as Excel Spreadsheet.
<h3>Comparison of Data Type in Python and Pandas</h3>
The following table shows how Python and pandas package stores data.

<table>
  <tbody>
<tr>
      <th>Data Type</th>

      <th>Pandas</th>
      <th>Standard Python</th></tr>
<tr>
      <td>For character variable</td>

      <td>object</td>
      <td>string</td></tr>
<tr>
      <td>For categorical variable</td>

      <td>category</td>
      <td>-</td></tr>
<tr>
      <td>For Numeric variable without decimals</td>

      <td>int64</td>
      <td>int</td></tr>
<tr>
      <td>Numeric characters with decimals</td>

      <td>float64</td>
      <td>float</td></tr>
<tr>
      <td>For date time variables</td>

      <td>datetime64</td>
      <td>-</td></tr>
</tbody>
</table>

<h3>Important Pandas Functions</h3>
The table below shows comparison of pandas functions with R functions for various data wrangling and manipulation tasks. 
It would help you to memorise pandas functions. 
It's a very handy information for programmers who are new to Python. 

It includes solutions for most of the frequently used data exploration tasks.
<table>
  <tbody>
<tr><th>Functions</th><th>R</th><th>Python (pandas package)</th></tr>

<tr><td>Installing a package</td><td>install.packages('name')</td><td>!pip install name</td></tr>
<tr><td>Loading a package</td><td>library(name)</td><td>import name as other_name</td></tr>
<tr><td>Checking working directory</td><td>getwd()</td><td>import os
os.getcwd()</td></tr>

<tr><td>Setting working directory</td><td>setwd()</td><td>os.chdir()</td></tr>
<tr><td>List files in a directory</td><td>dir()</td><td>os.listdir()</td></tr>
<tr><td>Remove an object</td><td>rm('name')</td><td>del object</td></tr>
<tr><td>Select Variables</td><td>select(df, x1, x2) </td><td>df[['x1', 'x2']]</td></tr>

<tr><td>Drop Variables</td><td>select(df, -(x1:x2))</td><td>df.drop(['x1', 'x2'], axis = 1)</td></tr>
<tr><td>Filter Data</td><td>filter(df, x1 &gt;= 100)</td><td>df.query('x1 &gt;= 100')</td></tr>
<tr><td>Structure of a DataFrame</td><td>str(df)</td><td>df.info()</td></tr>
<tr><td>Summarize dataframe</td><td>summary(df)</td><td>df.describe()</td></tr>

<tr><td>Get row names of dataframe "df"</td><td>rownames(df)</td><td>df.index</td></tr>
<tr><td>Get column names</td><td>colnames(df)</td><td>df.columns</td></tr>
<tr><td>View Top N rows</td><td>head(df,N)</td><td>df.head(N)</td></tr>
<tr><td>View Bottom N rows</td><td>tail(df,N)</td><td>df.tail(N)</td></tr>

<tr><td>Get dimension of data frame</td><td>dim(df)</td><td>df.shape</td></tr>
<tr><td>Get number of rows</td><td>nrow(df)</td><td>df.shape[0]</td></tr>
<tr><td>Get number of columns</td><td>ncol(df)</td><td>df.shape[1]</td></tr>
<tr><td>Length of data frame</td><td>length(df)</td><td>len(df)</td></tr>

<tr><td>Get random 3 rows from dataframe</td><td>sample_n(df, 3)</td><td>df.sample(n=3)</td></tr>
<tr><td>Get random 10% rows</td><td>sample_frac(df, 0.1)</td><td>df.sample(frac=0.1)</td></tr>
<tr><td>Check Missing Values</td><td>is.na(df$x)</td><td>pd.isnull(df.x)</td></tr>
<tr><td>Sorting</td><td>arrange(df, x1, x2)</td><td>df.sort_values(['x1', 'x2'])

</td></tr>
<tr><td>Rename Variables</td><td>rename(df, newvar = x1)</td><td>df.rename(columns={'x1': 'newvar'})
</td></tr>
</tbody></table>

<h3>Data Manipulation with pandas - Examples</h3>
<h3>1. Import Required Packages</h3>
You can import required packages using <b>import </b>statement. 
In the syntax below, we are asking Python to import numpy and pandas package. 

The 'as' is used to alias package name.
import numpy as np
import pandas as pd
<h3>2. Build DataFrame</h3>

We can build dataframe using <b>DataFrame() </b>function of pandas package.
mydata = {'productcode': ['AA', 'AA', 'AA', 'BB', 'BB', 'BB'],
        'sales': [1010, 1025.2, 1404.2, 1251.7, 1160, 1604.8],
        'cost' : [1020, 1625.2, 1204, 1003.7, 1020, 1124]}

df = pd.DataFrame(mydata)
 In this dataframe, we have three variables - productcode, sales, cost.
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody>
<tr><td style="text-align: center;"><a href="https://2.bp.blogspot.com/-pxZ3HvzJ3tg/WR2kIlBTpAI/AAAAAAAAGPY/3l7Pay8rhpQ5ewGXeLDDaGdwqvzccugsQCLcB/s1600/df_python.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="https://2.bp.blogspot.com/-pxZ3HvzJ3tg/WR2kIlBTpAI/AAAAAAAAGPY/3l7Pay8rhpQ5ewGXeLDDaGdwqvzccugsQCLcB/s1600/df_python.png" /></a></td></tr>

<tr><td class="tr-caption" style="text-align: center;">Sample DataFrame</td></tr>
</tbody></table>
<h3>To import data from CSV file</h3>
You can use read_csv() function from pandas package to get data into python from CSV file.

mydata= pd.read_csv("C:\\Users\\Deepanshu\\Documents\\file1.csv")
Make sure you use <b>double backslash</b> when specifying path of CSV file. 
Alternatively, you can use forward slash to mention file path inside read_csv() function.
<h3>Detailed Tutorial : <a href="http://www.listendata.com/2017/02/import-data-in-python.html" target="_blank">Import Data in Python</a></h3>

<h3>3. To see number of rows and columns</h3>
You can run the command below to find out number of rows and columns.
df.shape
<h3> Result :</b> (6, 3)h3 

It means 6 rows and 3 columns.
<h3>4. To view first 3 rows</h3>
The df.head(N) function can be used to check out first some N rows.
df.head(3)

     cost productcode   sales
0  1020.0          AA  1010.0
1  1625.2          AA  1025.2
2  1204.0          AA  1404.2

<h3>5. Select or Drop Variables</h3>
To keep a single variable, you can write in any of the following three methods -
df.productcode
df["productcode"]

df.loc[: , "productcode"]
To select variable by column position, you can use <b>df.iloc</b> function. 
In the example below, we are selecting second column. 
Column Index starts from 0. 

Hence, 1 refers to second column.
df.iloc[: , 1]
We can keep multiple variables by specifying desired variables inside [ ]. 
Also, we can make use of df.loc() function.

df[["productcode", "cost"]]
df.loc[ : , ["productcode", "cost"]]
<h3>Drop Variable</h3>
We can remove variables by using df.drop() function. 

See the example below -
df2 = df.drop(['sales'], axis = 1)
<h3>6. To summarize data frame</h3>
To summarize or explore data, you can submit the command below.

df.describe()
              cost       sales
count     6.000000     6.00000
mean   1166.150000  1242.65000

std     237.926793   230.46669
min    1003.700000  1010.00000
25%    1020.000000  1058.90000
50%    1072.000000  1205.85000

75%    1184.000000  1366.07500
max    1625.200000  1604.80000
To summarise all the <b>character variables</b>, you can use the following script.
df.describe(include=['O'])

Similarly, you can use <b>df.describe(include=['float64']) </b>to view summary of all the numeric variables with decimals.
To select only a particular variable, you can write the following code -
df.productcode.describe()
<h3>OR</h3>

df["productcode"].describe()
count      6
unique     2
top       BB

freq       3
Name: productcode, dtype: object
<h3>7. To calculate summary statistics</h3>
We can manually find out summary statistics such as count, mean, median by using commands below

df.sales.mean()
df.sales.median()
df.sales.count()
df.sales.min()

df.sales.max()
<h3>8. Filter Data</h3>
Suppose you are asked to apply condition - productcode is equal to "AA" and sales greater than or equal to 1250.
df1 = df[(df.productcode == "AA") &amp; (df.sales &gt;= 1250)]

It can also be written like :
df1 = df.query('(productcode == "AA") &amp; (sales &gt;= 1250)')
In the second query, we <b>do not need</b> to specify DataFrame along with variable name.
<h3>9. Sort Data</h3>

In the code below, we are arrange data in ascending order by sales.
df.sort_values(['sales'])
<h3>10h3 
 Group By : Summary by Grouping Variable</b>

Like SQL GROUP BY, you want to summarize continuous variable by classification variable. 
In this case, we are calculating average sale and cost by product code.
df.groupby(df.productcode).mean()
                    cost        sales

productcode                          
AA           1283.066667  1146.466667
BB           1049.233333  1338.833333
Instead of summarising for multiple variable, you can run it for a single variable i.e. 

sales. 
Submit the following script.
df["sales"].groupby(df.productcode).mean()
<h3>11h3 

Define Categorical Variable</b>
Let's create a classification variable - id which contains only 3 unique values - 1/2/3.
df0 = pd.DataFrame({'id': [1, 1, 2, 3, 1, 2, 2]})
<i>Let's define as a categorical variable.</i>

We can use astype() function to make id as a categorical variable.
df0.id = df0["id"].astype('category')
Summarize this classification variable to check descriptive statistics.
df0.describe()

       id
count    7
unique   3
top      2

freq     3
<h3>Frequency Distribution</h3>
You can calculate frequency distribution of a categorical variable. 
It is one of the method to explore a categorical variable.

df['productcode'].value_counts()
BB    3
AA    3
<h3>12h3 

Generate Histogram</b>
Histogram is one of the method to check distribution of a continuous variable. 
In the figure shown below, there are two values for variable 'sales' in range 1000-1100. 
In the remaining intervals, there is only a single value. 

In this case, there are only 5 values. 
If you have a large dataset, you can plot histogram to identify outliers in a continuous variable.
df['sales'].hist()
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody>

<tr><td style="text-align: center;"><a href="https://3.bp.blogspot.com/-ioygQfX8HWo/WR3gJ--Xc0I/AAAAAAAAGPo/TQlc0mdVzqwBrc1xhtIcgiD-1C5pGoUXACLcB/s1600/Histogram_Python.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="https://3.bp.blogspot.com/-ioygQfX8HWo/WR3gJ--Xc0I/AAAAAAAAGPo/TQlc0mdVzqwBrc1xhtIcgiD-1C5pGoUXACLcB/s1600/Histogram_Python.png" /></a></td></tr>
<tr><td class="tr-caption" style="text-align: center;">Histogram</td></tr>
</tbody></table>
<h3>13h3 

BoxPlot</b>
Boxplot is a method to visualize continuous or numeric variable. 
It shows minimum, Q1, Q2, Q3, IQR, maximum value in a single graph.
df.boxplot(column='sales')

<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody>
<tr><td style="text-align: center;"><a href="https://1.bp.blogspot.com/-hfnDd5HO9ak/WR3kB-0f2tI/AAAAAAAAGPs/MpNFwZBF0rAaaVy2buVKBaJep4Rg8zlNACLcB/s1600/boxplot.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="204" src="https://1.bp.blogspot.com/-hfnDd5HO9ak/WR3kB-0f2tI/AAAAAAAAGPs/MpNFwZBF0rAaaVy2buVKBaJep4Rg8zlNACLcB/s320/boxplot.png" width="320" /></a></td></tr>
<tr><td class="tr-caption" style="text-align: center;">BoxPlot</td></tr>
</tbody></table>

<h3>Data Science using Python - Examples</h3>
In this section, we cover how to perform data mining and machine learning algorithms with Python. 
sklearn is the most frequently used library for running data mining and machine learning algorithms. 
We will also cover statsmodels library for regression techniques. 

statsmodels library generates formattable output which can be used further in project report and presentation.
<h3>1. Install the required libraries</h3>
Import the following libraries before reading or exploring data
#Import required libraries

import pandas as pd
import statsmodels.api as sm
import numpy as np
<h3>2. Download and import data into Python</h3>

With the use of python library, we can easily get data from web into python.
# Read data from web
df = pd.read_csv("https://stats.idre.ucla.edu/stat/data/binary.csv")
<h3>Variables Type Descriptih3n

</b>gre Continuous Graduate Record Exam score
gpa Continuous Grade Point Average
rank Categorical Prestige of the undergraduate institution
admit Binary Admission in graduate school

<h3>The binary variable admit is a target variable.</h3>
<h3>3. Explore Data</h3>
Let's explore data. 
We'll answer the following questions -

How many rows and columns in the data file?
What are the distribution of variables?
Check if any outlier(s)
If outlier(s), treat them

Check if any missing value(s)
Impute Missing values (if any)
# See no. 
of rows and columns

df.shape
Result : </b>400 rows and 4 columh3s
In the code below, we rename the variable rank to '<b>position</b>' as rank is already a function in python.
# rename rank column

df = df.rename(columns={'rank': 'position'}) 
Summarize and plot all the columns.
# Summarize
df.describe()

# plot all of the columns
df.hist()
<h3>Categorical variable Analysis</h3>
It is important to check the frequency distribution of categorical variable. 

It helps to answer the question whether data is skewed.
# Summarize
df.position.value_counts(ascending=True)
1     61

4     67
3    121
2    151
<h3>Generating Crosstab </h3>

By looking at cross tabulation report, we can check whether we have enough number of events against each unique values of categorical variable.
pd.crosstab(df['admit'], df['position'])
position   1   2   3   4
admit                   

0         28  97  93  55
1         33  54  28  12
<h3>Number of Missing Values</h3>
We can write a simple loop to figure out the number of blank values in all variables in a dataset.

for i in list(df.columns) :
    k = sum(pd.isnull(df[i]))
    print(i, k)
In this case, there are no missing values in the dataset.

<h3>4. Logistic Regression Model</h3>
Logistic Regression is a special type of regression where target variable is categorical in nature and independent variables be discrete or continuous. 
In this post, we will demonstrate only <b>binary logistic regression </b>which takes only binary values in target variable. 
Unlike linear regression, logistic regression model returns probability of target variable.It assumes binomial distribution of dependent variable. 

In other words, it belongs to binomial family.
In python, we can write R-style model formula <b>y ~ x1 + x2 + x3</b> using  <b>patsy</b> and <b>statsmodels</b> libraries. 
In the formula, we need to define variable 'position' as a categorical variable by mentioning it inside capital C(). 
You can also define reference category using <b>reference=</b> option.

#Reference Category
from patsy import dmatrices, Treatment
y, X = dmatrices('admit ~ gre + gpa + C(position, Treatment(reference=4))', df, return_type = 'dataframe')
It returns two datasets - X and y. 

The dataset 'y' contains variable admit which is a target variable. 
The other dataset 'X' contains Intercept (constant value), dummy variables for Treatment, gre and gpa. 
Since 4 is set as a reference category, it will be 0 against all the three dummy variables. 
See sample below -

P  P_1 P_2 P_3
3  0 0 1
3  0 0 1
1  1 0 0

4  0 0 0
4  0 0 0
2  0 1 0
<h3>Split Data into two parts</h3>

80% of data goes to training dataset which is used for building model and 20% goes to test dataset which would be used for validating the model.
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0)
<h3>Build Logistic Regression Model</h3>

By default, the <b>regression without formula style</b> does not include intercept. 
To include it, we already have added <b>intercept</b> in <b>X_train </b>which would be used as a predictor<b>.</b>
#Fit Logit model
logit = sm.Logit(y_train, X_train)

result = logit.fit()
#Summary of Logistic regression model
result.summary()
result.params

                          Logit Regression Results                           
==============================================================================
Dep. 
Variable:                  admit   No. 

Observations:                  320
Model:                          Logit   Df Residuals:                      315
Method:                           MLE   Df Model:                            4
Date:                Sat, 20 May 2017   Pseudo R-squ.:                 0.03399

Time:                        19:57:24   Log-Likelihood:                -193.49
converged:                       True   LL-Null:                       -200.30
                                        LLR p-value:                  0.008627
=======================================================================================

                      coef    std err          z       P|z|      [95.0% Conf. 
Int.]
---------------------------------------------------------------------------------------
C(position)[T.1]     1.4933      0.440      3.392      0.001         0.630     2.356

C(position)[T.2]     0.6771      0.373      1.813      0.070        -0.055     1.409
C(position)[T.3]     0.1071      0.410      0.261      0.794        -0.696     0.910
gre                  0.0005      0.001      0.442      0.659        -0.002     0.003
gpa                  0.4613      0.214     -2.152      0.031        -0.881    -0.041

======================================================================================
<h3>Confusion Matrix and Odd Ratio</h3>
Odd ratio is exponential value of parameter estimates.
#Confusion Matrix

result.pred_table()
#Odd Ratio
np.exp(result.params)
<h3>Prediction on Test Data</h3>

In this step, we take estimates of logit model which was built on training data and then later apply it into test data.
#prediction on test data
y_pred = result.predict(X_test)
<h3>Calculate Area under Curve (ROC)</h3>

# AUC on test data
false_positive_rate, true_positive_rate, thresholds = roc_curve(y_test, y_pred)
auc(false_positive_rate, true_positive_rate)
Result :</b> AUC = 0.67h33

<h3>Calculate Accuracy Score</h3>
accuracy_score([ 1 if p &gt; 0.5 else 0 for p in y_pred ], y_test)
<h3>Decision Tree Model</h3>
Decision trees can have a target variable continuous or categorical. 

When it is continuous, it is called regression tree. 
And when it is categorical, it is called classification tree. 
It selects a variable at each step that best splits the set of values. 
There are several algorithms to find best split. 

Some of them are Gini, Entropy, C4.5, Chi-Square. 
There are several advantages of decision tree. 
It is simple to use and easy to understand. 
It requires a very few data preparation steps. 

It can handle mixed data - both categorical and continuous variables. 
In terms of speed, it is a very fast algorithm.
#Drop Intercept from predictors for tree algorithms
X_train = X_train.drop(['Intercept'], axis = 1)

X_test = X_test.drop(['Intercept'], axis = 1)
#Decision Tree
from sklearn.tree import DecisionTreeClassifier
model_tree = DecisionTreeClassifier(max_depth=7)

#Fit the model:
model_tree.fit(X_train,y_train)
#Make predictions on test set
predictions_tree = model_tree.predict_proba(X_test)

  
#AUC
false_positive_rate, true_positive_rate, thresholds = roc_curve(y_test, predictions_tree[:,1])
auc(false_positive_rate, true_positive_rate)

Result :</b> AUC = 0.6h34
<h3>Important Note</h3>
Feature engineering plays an important role in building predictive models. 
In the above case, we have not performed variable selection. 

We can also select best parameters by using grid search fine tuning technique.
<h3>Random Forest Model</h3>
Decision Tree has limitation of overfitting which implies it does not generalize pattern. 
It is very sensitive to a small change in training data. 

To overcome this problem, random forest comes into picture. 
It grows a large number of trees on randomised data. 
It selects random number of variables to grow each tree. 
It is more robust algorithm than decision tree. 

It is one of the most popular machine learning algorithm. 
It is commonly used in data science competitions. 
It is always ranked in top 5 algorithms. 
It has become a part of every data science toolkit.

#Random Forest
from sklearn.ensemble import RandomForestClassifier
model_rf = RandomForestClassifier(n_estimators=100, max_depth=7)
#Fit the model:

target = y_train['admit']
model_rf.fit(X_train,target)
#Make predictions on test set
predictions_rf = model_rf.predict_proba(X_test)

#AUC
false_positive_rate, true_positive_rate, thresholds = roc_curve(y_test, predictions_rf[:,1])
auc(false_positive_rate, true_positive_rate)
#Variable Importance

importances = pd.Series(model_rf.feature_importances_, index=X_train.columns).sort_values(ascending=False)
print(importances)
importances.plot.bar()
Result :</b> AUC = 0.69h34

<h3>Grid Search - Hyper Parameters Tuning</h3>
The sklearn library makes hyper-parameters tuning very easy. 
It is a strategy to select the best parameters for an algorithm. 
In scikit-learn they are passed as arguments to the constructor of the estimator classes. 

For example, max_features in randomforest. 
alpha for lasso.
from sklearn.model_selection import GridSearchCV
rf = RandomForestClassifier()

target = y_train['admit']
param_grid = { 
    'n_estimators': [100, 200, 300],
    'max_features': ['sqrt', 3, 4]

}
CV_rfc = GridSearchCV(estimator=rf , param_grid=param_grid, cv= 5, scoring='roc_auc')
CV_rfc.fit(X_train,target)
#Parameters with Scores

CV_rfc.grid_scores_
#Best Parameters
CV_rfc.best_params_
CV_rfc.best_estimator_

#Make predictions on test set
predictions_rf = CV_rfc.predict_proba(X_test)
#AUC
false_positive_rate, true_positive_rate, thresholds = roc_curve(y_test, predictions_rf[:,1])

auc(false_positive_rate, true_positive_rate)
<h3>Cross Validation</h3>
# Cross Validation
from sklearn.linear_model import LogisticRegression

from sklearn.model_selection import cross_val_predict,cross_val_score
target = y['admit']
prediction_logit = cross_val_predict(LogisticRegression(), X, target, cv=10, method='predict_proba')
#AUC

cross_val_score(LogisticRegression(fit_intercept = False), X, target, cv=10, scoring='roc_auc')
<h3>Data Mining : PreProcessing Steps</h3>
1. 
 The machine learning package <b>sklearn</b> requires all categorical variables in numeric form. 

Hence, we need to convert all character/categorical variables to be numeric. 
This can be accomplished using the following script. 
In sklearn,  there is already a function for this step.
from sklearn.preprocessing import LabelEncoder

def ConverttoNumeric(df):
    cols = list(df.select_dtypes(include=['category','object']))
    le = LabelEncoder()
    for i in cols:

        try:
            df[i] = le.fit_transform(df[i])
        except:
            print('Error in Variable :'+i)

    return df
ConverttoNumeric(df)
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody>
<tr><td style="text-align: center;"><a href="https://4.bp.blogspot.com/-Il5164XIJAg/WSBAxiCW9mI/AAAAAAAAGQQ/UlW0s40IeSoGsvmPDgUpiwRpuHBqTm6cgCLcB/s1600/encode.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="https://4.bp.blogspot.com/-Il5164XIJAg/WSBAxiCW9mI/AAAAAAAAGQQ/UlW0s40IeSoGsvmPDgUpiwRpuHBqTm6cgCLcB/s1600/encode.png" /></a></td></tr>

<tr><td class="tr-caption" style="text-align: center;">Encoding</td></tr>
</tbody></table>
<h3>2. Create Dummy Variables</h3>
Suppose you want to convert categorical variables into dummy variables. 

It is different to the previous example as it creates dummy variables instead of convert it in numeric form.
productcode_dummy = pd.get_dummies(df["productcode"])
df2 = pd.concat([df, productcode_dummy], axis=1)
The output looks like below -

   AA  BB
0   1   0
1   1   0
2   1   0

3   0   1
4   0   1
5   0   1
<h3>Create k-1 Categories</h3>

To avoid multi-collinearity, you can set one of the category as reference category and leave it while creating dummy variables. 
In the script below, we are leaving first category.
productcode_dummy = pd.get_dummies(df["productcode"], prefix='pcode', drop_first=True)
df2 = pd.concat([df, productcode_dummy], axis=1)

<h3>3. Impute Missing Values</h3>
Imputing missing values is an important step of predictive modeling. 
In many algorithms, if missing values are not filled, it removes complete row. 
If data contains a lot of missing values, it can lead to huge data loss. 

There are multiple ways to impute missing values. 
Some of the common techniques - to replace missing value with mean/median/zero. 
It makes sense to replace missing value with 0 when 0 signifies meaningful. 
For example, whether customer holds a credit card product.

<h3>Fill missing values of a particular variable</h3>
# fill missing values with 0
df['var1'] = df['var1'].fillna(0)
# fill missing values with mean

df['var1'] = df['var1'].fillna(df['var1'].mean())
<h3>Apply imputation to the whole dataset</h3>
from sklearn.preprocessing import Imputer
# Set an imputer object

mean_imputer = Imputer(missing_values='NaN', strategy='mean', axis=0)
# Train the imputor
mean_imputer = mean_imputer.fit(df)
# Apply imputation

df_new = mean_imputer.transform(df.values)
<h3>4. Outlier Treatment</h3>
There are many ways to handle or treat outliers (or extreme values). 
Some of the methods are as follows -

Cap extreme values at 95th / 99th percentile depending on distribution
Apply log transformation of variables. 
See below the implementation of log transformation in Python.
import numpy as np

df['var1'] = np.log(df['var1'])
<h3>5. Standardization</h3>
In some algorithms, it is required to standardize variables before running the actual algorithm. 
Standardization refers to the process of making mean of variable zero and unit variance (standard deviation).

#load dataset
dataset = load_boston()
predictors = dataset.data
target = dataset.target

df = pd.DataFrame(predictors, columns = dataset.feature_names)
#Apply Standardization
from sklearn.preprocessing import StandardScaler
k = StandardScaler()

df2 = k.fit_transform(df)
<h3>Next Steps</h3>
Practice, practice and practice. 
Download free public data sets from Kaggle / UCLA websites and try to play around with data and generate insights from it with pandas package and build statistical models using sklearn package. 
I hope you would find this tutorial helpful. 
I tried to cover all the important topics which beginner must know about Python. 
Once completion of this tutorial, you can flaunt you know how to program it in Python and you can implement machine learning algorithms using sklearn package.
<script src='https://williamkpchan.github.io/LibDocs/readbook.js'></script>
<script>
var lazyLoadInstance = new LazyLoad({
    elements_selector: ".lazy"
    // ... more custom settings?
});
</script>
