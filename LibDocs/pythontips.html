<base target="_blank"><html><head><title>Intermediate Python</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script type='text/javascript' src='../mainscript.js'></script>
<style>
body{width:80%;margin-left: 10%; font-size:22px;}
strong, h1, h2 {color: gold;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px;}
</style></head><body onkeypress="chkKey()"><center>
<h1>Intermediate Python</h1>
<div id="toc"></div></center>
<pre>

<h2>Preface</h2>
Python is an amazing language with a strong and friendly community of programmers. 
However, there is a lack of documentation on what to learn after getting the basics of Python down your throat. 
Through this book I aim to solve this problem. 
I would give you bits of information about some interesting topics which you can further explore.

The topics which are discussed in this book open up your mind towards some nice corners of Python language. 
This book is an outcome of my desire to have something like this when I was beginning to learn Python.

If you are a beginner, intermediate or even an advanced programmer there is something for you in this book.

Please note that this book is not a tutorial and does not teach you Python. 
The topics are not explained in depth, instead only the minimum required information is given.

I am sure you are as excited as I am so let’s start!

<strong>Note:</strong> This book is a continuous work in progress. 
If you find anything which you can further improve (I know you will find a lot of stuff) then kindly submit a pull request!


<h2>Author</h2>
I am Muhammad Yasoob Ullah Khalid. 
I have been programming extensively in Python for over 3 years now. 
I have been involved in a lot of Open Source projects. 
I regularly blog about interesting Python topics over at my <a class="reference external" href="http://www.pythontips.com">blog</a> . 
In 2014 I also spoke at EuroPython which was held in Berlin. 
It is the biggest Python conference in Europe. 
If you have an interesting Internship opportunity for me then I would definitely like to hear from you!


<h2></h2>
<h2>1. *args and **kwargs</h2>
I have come to see that most new python programmers have a hard time
figuring out the *args and **kwargs magic variables. 
So what are they
? First of all let me tell you that it is not necessary to write *args
or **kwargs. 
Only the <code>*</code> (asterisk) is necessary. 
You could have
also written *var and **vars. 
Writing *args and **kwargs is just a
convention. 
So now lets take a look at *args first.


<h2>1.1. Usage of *args</h2>
*args and **kwargs are mostly used in function definitions. 
*args and **kwargs allow you to pass a variable number of arguments to a
function. 
What variable means here is that you do not know beforehand
how many arguments can be passed to your function by the user
so in this case you use these two keywords. 
*args is used to send a
<strong>non-keyworded</strong> variable length argument list to the function. 
Here’s an example to help you get a clear idea:

def test_var_args(f_arg, *argv):
    print(&quot;first normal arg:&quot;, f_arg)
    for arg in argv:
     print(&quot;another arg through *argv:&quot;, arg)

test_var_args(&#39;yasoob&#39;, &#39;python&#39;, &#39;eggs&#39;, &#39;test&#39;)
This produces the following result:

first normal arg: yasoob
another arg through *argv: python
another arg through *argv: eggs
another arg through *argv: test
I hope this cleared away any confusion that you had. 
So now let’s talk about **kwargs


<h2>1.2. Usage of **kwargs</h2>
**kwargs allows you to pass <strong>keyworded</strong> variable length of arguments to a function. 
You should use **kwargs if you want to handle <strong>named
arguments</strong> in a function. 
Here is an example to get you going with it:

def greet_me(**kwargs):
    for key, value in kwargs.items():
     print(&quot;{0} = {1}&quot;.format(key, value))

&gt;&gt;&gt; greet_me(name=&quot;yasoob&quot;)
name = yasoob
So you can see how we handled a keyworded argument list in our function.
This is just the basics of **kwargs and you can see how useful it is.
Now let’s talk about how you can use *args and **kwargs to call a
function with a list or dictionary of arguments.


<h2>1.3. Using *args and **kwargs to call a function</h2>
So here we will see how to call a function using *args and **kwargs.
Just consider that you have this little function:

def test_args_kwargs(arg1, arg2, arg3):
    print(&quot;arg1:&quot;, arg1)
    print(&quot;arg2:&quot;, arg2)
    print(&quot;arg3:&quot;, arg3)
Now you can use *args or **kwargs to pass arguments to this little
function. 
Here’s how to do it:

# first with *args
&gt;&gt;&gt; args = (&quot;two&quot;, 3, 5)
&gt;&gt;&gt; test_args_kwargs(*args)
arg1: two
arg2: 3
arg3: 5

# now with **kwargs:
&gt;&gt;&gt; kwargs = {&quot;arg3&quot;: 3, &quot;arg2&quot;: &quot;two&quot;, &quot;arg1&quot;: 5}
&gt;&gt;&gt; test_args_kwargs(**kwargs)
arg1: 5
arg2: two
arg3: 3
<strong>Order of using *args **kwargs and formal args</strong>

So if you want to use all three of these in functions then the order is

some_func(fargs, *args, **kwargs)

<h2>1.4. When to use them?</h2>
It really depends on what your requirements are. 
The most common use
case is when making function decorators (discussed in another chapter).
Moreover it can be used in monkey patching as well. 
Monkey patching
means modifying some code at runtime. 
Consider that you have a class
with a function called <code>get_info</code> which calls an API and returns the
response data. 
If we want to test it we can replace the API call with
some test data. 
For instance:

import someclass

def get_info(self, *args):
    return &quot;Test data&quot;

someclass.get_info = get_info
I am sure that you can think of some other use cases as well.


<h2></h2>
<h2>2. Debugging</h2>
Debugging is also something which once mastered can greatly enhance your
bug hunting skills. 
Most of the newcomers neglect the importance of the
Python debugger (<code>pdb</code>). 
In this section I am going to tell you only a
few important commands. 
You can learn more about it from the official
documentation.

<strong>Running from commandline</strong>

You can run a script from the commandline using the Python debugger.
Here is an example:

$ python -m pdb my_script.py
It would cause the debugger to stop the execution on the first statement
it finds. 
This is helpful if your script is short. 
You can then inspect
the variables and continue execution line-by-line.

<strong>Running from inside a script</strong>

You can set break points in the script itself so that you can inspect
the variables and stuff at particular points. 
This is possible using the
<code>pdb.set_trace()</code> method. 
Here is an example:

import pdb

def make_bread():
    pdb.set_trace()
    return &quot;I don&#39;t have time&quot;

print(make_bread())
Try running the above script after saving it. 
You would enter the
debugger as soon as you run it. 
Now it’s time to learn some of the
commands of the debugger.

<strong>Commands:</strong>

<ul class="simple">
<li><code>c</code>: continue execution</li>
<li><code>w</code>: shows the context of the current line it is executing.</li>
<li><code>a</code>: print the argument list of the current function</li>
<li><code>s</code>: Execute the current line and stop at the first possible
occasion.</li>
<li><code>n</code>: Continue execution until the next line in the current function
is reached or it returns.</li>
</ul>
The difference between <code>n</code>ext and <code>s</code>tep is that step stops
inside a called function, while next executes called functions at
(nearly) full speed, only stopping at the next line in the current
function.

These are just a few commands. 
<code>pdb</code> also supports post mortem. 
It is
also a really handy function. 
I would highly suggest you to look at the
official documentation and learn more about it.


<h2></h2>
<h2>3. Generators</h2>
First lets understand iterators. 
According to Wikipedia, an iterator is
an object that enables a programmer to traverse a container,
particularly lists. 
However, an iterator performs traversal and gives
access to data elements in a container, but does not perform iteration.
You might be confused so lets take it a bit slow. 
There are three parts
namely:

<ul class="simple">
<li>Iterable</li>
<li>Iterator</li>
<li>Iteration</li>
</ul>
All of these parts are linked to each other. 
We will discuss them one by
one and later talk about generators.


<h2>3.1. Iterable</h2>
An <code>iterable</code> is any object in Python which has an <code>__iter__</code> or a
<code>__getitem__</code> method defined which returns an <strong>iterator</strong> or can take
indexes (You can read more about them <a class="reference external" href="https://stackoverflow.com/a/20551346">here</a>).
In short an <code>iterable</code> is any object which can provide us
with an <strong>iterator</strong>. 
So what is an <strong>iterator</strong>?


<h2>3.2. Iterator</h2>
An iterator is any object in Python which has a <code>next</code> (Python2) or
<code>__next__</code> method defined. 
That’s it. 
That’s an iterator. 
Now let’s
understand <strong>iteration</strong>.


<h2>3.3. Iteration</h2>
In simple words it is the process of taking an item from something e.g a
list. 
When we use a loop to loop over something it is called iteration.
It is the name given to the process itself. 
Now as we have a basic
understanding of these terms let’s understand <strong>generators</strong>.


<h2>3.4. Generators</h2>
Generators are iterators, but you can only iterate over them once. 
It’s
because they do not store all the values in memory, they generate the
values on the fly. 
You use them by iterating over them, either with a
‘for’ loop or by passing them to any function or construct that
iterates. 
Most of the time <code>generators</code> are implemented as functions.
However, they do not <code>return</code> a value, they <code>yield</code> it. 
Here is a
simple example of a <code>generator</code> function:

def generator_function():
    for i in range(10):
     yield i

for item in generator_function():
    print(item)

# Output: 0
# 1
# 2
# 3
# 4
# 5
# 6
# 7
# 8
# 9
It is not really useful in this case. 
Generators are best for
calculating large sets of results (particularly calculations involving
loops themselves) where you don’t want to allocate the memory for all
results at the same time. 
Many Standard Library functions that return
<code>lists</code> in Python 2 have been modified to return <code>generators</code> in
Python 3 because <code>generators</code> require fewer resources.

Here is an example <code>generator</code> which calculates fibonacci numbers:

# generator version
def fibon(n):
    a = b = 1
    for i in range(n):
     yield a
         a, b = b, a + b
Now we can use it like this:

for x in fibon(1000000):
    print(x)
This way we would not have to worry about it using a lot of resources.
However, if we would have implemented it like this:

def fibon(n):
    a = b = 1
    result = []
    for i in range(n):
     result.append(a)
         a, b = b, a + b
    return result
It would have used up all our resources while calculating a large input.
We have discussed that we can iterate over <code>generators</code> only once but
we haven’t tested it. 
Before testing it you need to know about one more
built-in function of Python, <code>next()</code>. 
It allows us to access the next
element of a sequence. 
So let’s test out our understanding:

def generator_function():
    for i in range(3):
     yield i

gen = generator_function()
print(next(gen))
# Output: 0
print(next(gen))
# Output: 1
print(next(gen))
# Output: 2
print(next(gen))
# Output: Traceback (most recent call last):
#            File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
#         StopIteration
As we can see that after yielding all the values <code>next()</code> caused a
<code>StopIteration</code> error. 
Basically this error informs us that all the
values have been yielded. 
You might be wondering that why don’t we get
this error while using a <code>for</code> loop? Well the answer is simple. 
The
<code>for</code> loop automatically catches this error and stops calling
<code>next</code>. 
Do you know that a few built-in data types in Python also
support iteration? Let’s check it out:

my_string = &quot;Yasoob&quot;
next(my_string)
# Output: Traceback (most recent call last):
#      File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
#    TypeError: str object is not an iterator
Well that’s not what we expected. 
The error says that <code>str</code> is not an
iterator. 
Well it’s right! It’s an iterable but not an iterator. 
This
means that it supports iteration but we can’t iterate over
it directly. 
So how would we iterate over it? It’s time to learn about one more
built-in function, <code>iter</code>. 
It returns an <code>iterator</code> object from an
iterable. 
While an <code>int</code> isn’t an iterable, we can use it on string!

int_var = 1779
iter(int_var)
# Output: Traceback (most recent call last):
#   File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
# TypeError: &#39;int&#39; object is not iterable
# This is because int is not iterable

my_string = &quot;Yasoob&quot;
my_iter = iter(my_string)
print(next(my_iter))
# Output: &#39;Y&#39;
Now that is much better. 
I am sure that you loved learning about
generators. 
Do bear it in mind that you can fully grasp this concept
only when you use it. 
Make sure that you follow this pattern and use
<code>generators</code> whenever they make sense to you. 
You won’t be
disappointed!


<h2></h2>
<h2>4. Map, Filter and Reduce</h2>
These are three functions which facilitate a functional approach to
programming. 
We will discuss them one by one and understand their use
cases.


<h2>4.1. Map</h2>
<code>Map</code> applies a function to all the items in an input_list. 
Here is
the blueprint:

<strong>Blueprint</strong>

map(function_to_apply, list_of_inputs)
Most of the times we want to pass all the list elements to a function
one-by-one and then collect the output. 
For instance:

items = [1, 2, 3, 4, 5]
squared = []
for i in items:
    squared.append(i**2)
<code>Map</code> allows us to implement this in a much simpler and nicer way.
Here you go:

items = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x**2, items))
Most of the times we use lambdas with <code>map</code> so I did the same. 
Instead
of a list of inputs we can even have a list of functions!

def multiply(x):
    return (x*x)
def add(x):
    return (x+x)

funcs = [multiply, add]
for i in range(5):
    value = list(map(lambda x: x(i), funcs))
    print(value)

# Output:
# [0, 0]
# [1, 2]
# [4, 4]
# [9, 6]
# [16, 8]

<h2>4.2. Filter</h2>
As the name suggests, <code>filter</code> creates a list of elements for which a
function returns true. 
Here is a short and concise example:

number_list = range(-5, 5)
less_than_zero = list(filter(lambda x: x &lt; 0, number_list))
print(less_than_zero)

# Output: [-5, -4, -3, -2, -1]
The filter resembles a for loop but it is a builtin function and faster.

<strong>Note:</strong> If map &amp; filter do not appear beautiful to you then you can
read about <code>list/dict/tuple</code> comprehensions.


<h2>4.3. Reduce</h2>
<code>Reduce</code> is a really useful function for performing some computation on
a list and returning the result. 
It applies a rolling computation to sequential
pairs of values in a list. 
For example, if you wanted to compute the product
of a list of integers.

So the normal way you might go about doing this task in python is using
a basic for loop:

product = 1
list = [1, 2, 3, 4]
for num in list:
    product = product * num

# product = 24
Now let’s try it with reduce:

from functools import reduce
product = reduce((lambda x, y: x * y), [1, 2, 3, 4])

# Output: 24

<h2></h2>
<h2>5. <code>set</code> Data Structure</h2>
<code>set</code> is a really useful data structure. 
<code>sets</code> behave mostly like
lists with the distinction that they can not contain duplicate values.
It is really useful in a lot of cases. 
For instance you might want to
check whether there are duplicates in a list or not. 
You have two
options. 
The first one involves using a <code>for</code> loop. 
Something like
this:

some_list = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;b&#39;, &#39;d&#39;, &#39;m&#39;, &#39;n&#39;, &#39;n&#39;]

duplicates = []
for value in some_list:
    if some_list.count(value) &gt; 1:
     if value not in duplicates:
             duplicates.append(value)

print(duplicates)
# Output: [&#39;b&#39;, &#39;n&#39;]
But there is a simpler and more elegant solution involving <code>sets</code>. 
You
can simply do something like this:

some_list = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;b&#39;, &#39;d&#39;, &#39;m&#39;, &#39;n&#39;, &#39;n&#39;]
duplicates = set([x for x in some_list if some_list.count(x) &gt; 1])
print(duplicates)
# Output: set([&#39;b&#39;, &#39;n&#39;])
Sets also have a few other methods. 
Below are some of them.

<strong>Intersection</strong>

You can intersect two sets. 
For instance:

valid = set([&#39;yellow&#39;, &#39;red&#39;, &#39;blue&#39;, &#39;green&#39;, &#39;black&#39;])
input_set = set([&#39;red&#39;, &#39;brown&#39;])
print(input_set.intersection(valid))
# Output: set([&#39;red&#39;])
<strong>Difference</strong>

You can find the invalid values in the above example using the
difference method. 
For example:

valid = set([&#39;yellow&#39;, &#39;red&#39;, &#39;blue&#39;, &#39;green&#39;, &#39;black&#39;])
input_set = set([&#39;red&#39;, &#39;brown&#39;])
print(input_set.difference(valid))
# Output: set([&#39;brown&#39;])
You can also create sets using the new notation:

a_set = {&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;}
print(type(a_set))
# Output: &lt;type &#39;set&#39;&gt;
There are a few other methods as well. 
I would recommend visiting the
official documentation and giving it a quick read.


<h2></h2>
<h2>6. Ternary Operators</h2>
Ternary operators are more commonly known as conditional expressions in
Python. 
These operators evaluate something based on a condition being
true or not. 
They became a part of Python in version 2.4

Here is a blueprint and an example of using these conditional
expressions.

<strong>Blueprint:</strong>

condition_is_true if condition else condition_is_false
<strong>Example:</strong>

is_fat = True
state = &quot;fat&quot; if is_fat else &quot;not fat&quot;
It allows to quickly test a condition instead of a multiline if
statement. 
Often times it can be immensely helpful and can make your
code compact but still maintainable.

Another more obscure and not widely used example involves tuples. 
Here
is some sample code:

<strong>Blueprint:</strong>

(if_test_is_false, if_test_is_true)[test]
<strong>Example:</strong>

fat = True
fitness = (&quot;skinny&quot;, &quot;fat&quot;)[fat]
print(&quot;Ali is &quot;, fitness)
# Output: Ali is fat
This works simply because True == 1 and False == 0, and so can be done
with lists in addition to tuples.

The above example is not widely used and is generally disliked by
Pythonistas for not being Pythonic. 
It is also easy to confuse where to
put the true value and where to put the false value in the tuple.

Another reason to avoid using a tupled ternery is that it results in
both elements of the tuple being evaluated, whereas the if-else
ternary operator does not.

<strong>Example:</strong>

condition = True
print(2 if condition else 1/0)
#Output is 2

print((1/0, 2)[condition])
#ZeroDivisionError is raised
This happens because with the tupled ternary technique, the tuple is
first built, then an index is found. 
 For the if-else ternary operator,
it follows the normal if-else logic tree. 
 Thus, if one case could
raise an exception based on the condition, or if either case is a
computation-heavy method, using tuples is best avoided.


<h2></h2>
<h2>7. Decorators</h2>
Decorators are a significant part of Python. 
In simple words: they are
functions which modify the functionality of another function. 
They help
to make our code shorter and more Pythonic. 
Most of the beginners do not
know where to use them so I am going to share some areas where
decorators can make your code more concise.

First, let’s discuss how to write your own decorator.

It is perhaps one of the most difficult concepts to grasp. 
We will take
it one step at a time so that you can fully understand it.


<h2>7.1. Everything in Python is an object:</h2>
First of all let’s understand functions in Python:

def hi(name=&quot;yasoob&quot;):
    return &quot;hi &quot; + name

print(hi())
# output: &#39;hi yasoob&#39;

# We can even assign a function to a variable like
greet = hi
# We are not using parentheses here because we are not calling the function hi
# instead we are just putting it into the greet variable. 
Let&#39;s try to run this

print(greet())
# output: &#39;hi yasoob&#39;

# Let&#39;s see what happens if we delete the old hi function!
del hi
print(hi())
#outputs: NameError

print(greet())
#outputs: &#39;hi yasoob&#39;

<h2>7.2. Defining functions within functions:</h2>
So those are the basics when it comes to functions. 
Let’s take your
knowledge one step further. 
In Python we can define functions inside
other functions:

def hi(name=&quot;yasoob&quot;):
    print(&quot;now you are inside the hi() function&quot;)
      def greet():
       return &quot;now you are in the greet() function&quot;
           def welcome():
           return &quot;now you are in the welcome() function&quot;
           print(greet())
    print(welcome())
    print(&quot;now you are back in the hi() function&quot;)

hi()
#output:now you are inside the hi() function
#       now you are in the greet() function
#       now you are in the welcome() function
#       now you are back in the hi() function

# This shows that whenever you call hi(), greet() and welcome()
# are also called. 
However the greet() and welcome() functions
# are not available outside the hi() function e.g:

greet()
#outputs: NameError: name &#39;greet&#39; is not defined
So now we know that we can define functions in other functions. 
In
other words: we can make nested functions. 
Now you need to learn one
more thing, that functions can return functions too.


<h2>7.3. Returning functions from within functions:</h2>
It is not necessary to execute a function within another function, we
can return it as an output as well:

def hi(name=&quot;yasoob&quot;):
    def greet():
     return &quot;now you are in the greet() function&quot;
           def welcome():
           return &quot;now you are in the welcome() function&quot;
           if name == &quot;yasoob&quot;:
           return greet
    else:
     return welcome

a = hi()
print(a)
#outputs: &lt;function greet at 0x7f2143c01500&gt;

#This clearly shows that `a` now points to the greet() function in hi()
#Now try this

print(a())
#outputs: now you are in the greet() function
Just take a look at the code again. 
In the <code>if/else</code> clause we are
returning <code>greet</code> and <code>welcome</code>, not <code>greet()</code> and <code>welcome()</code>.
Why is that? It’s because when you put a pair of parentheses after it, the
function gets executed; whereas if you don’t put parenthesis after it,
then it can be passed around and can be assigned to other variables
without executing it. 
Did you get it? Let me explain it in a little bit
more detail. 
When we write <code>a = hi()</code>, <code>hi()</code> gets executed and
because the name is yasoob by default, the function <code>greet</code> is returned.
If we change the statement to <code>a = hi(name = &quot;ali&quot;)</code> then the <code>welcome</code>
function will be returned. 
We can also do print <code>hi()()</code> which outputs
<em>now you are in the greet() function</em>.


<h2>7.4. Giving a function as an argument to another function:</h2>
def hi():
    return &quot;hi yasoob!&quot;

def doSomethingBeforeHi(func):
    print(&quot;I am doing some boring work before executing hi()&quot;)
    print(func())

doSomethingBeforeHi(hi)
#outputs:I am doing some boring work before executing hi()
#        hi yasoob!
Now you have all the required knowledge to learn what decorators really
are. 
Decorators let you execute code before and after a function.


<h2>7.5. Writing your first decorator:</h2>
In the last example we actually made a decorator! Let’s modify the
previous decorator and make a little bit more usable program:

def a_new_decorator(a_func):
    def wrapTheFunction():
     print(&quot;I am doing some boring work before executing a_func()&quot;)
               a_func()
                     print(&quot;I am doing some boring work after executing a_func()&quot;)
                 return wrapTheFunction

def a_function_requiring_decoration():
    print(&quot;I am the function which needs some decoration to remove my foul smell&quot;)

a_function_requiring_decoration()
#outputs: &quot;I am the function which needs some decoration to remove my foul smell&quot;

a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)
#now a_function_requiring_decoration is wrapped by wrapTheFunction()

a_function_requiring_decoration()
#outputs:I am doing some boring work before executing a_func()
#        I am the function which needs some decoration to remove my foul smell
#        I am doing some boring work after executing a_func()
Did you get it? We just applied the previously learned principles. 
This
is exactly what the decorators do in Python! They wrap a function and
modify its behaviour in one way or the another. 
Now you might be
wondering that we did not use the &#64; anywhere in our code? That is just a
short way of making up a decorated function. 
Here is how we could have
run the previous code sample using &#64;.

@a_new_decorator
def a_function_requiring_decoration():
    &quot;&quot;&quot;Hey you! Decorate me!&quot;&quot;&quot;
    print(&quot;I am the function which needs some decoration to &quot;
       &quot;remove my foul smell&quot;)

a_function_requiring_decoration()
#outputs: I am doing some boring work before executing a_func()
#         I am the function which needs some decoration to remove my foul smell
#         I am doing some boring work after executing a_func()

#the @a_new_decorator is just a short way of saying:
a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)
I hope you now have a basic understanding of how decorators work in
Python. 
Now there is one problem with our code. 
If we run:

print(a_function_requiring_decoration.__name__)
# Output: wrapTheFunction
That’s not what we expected! Its name is
“a_function_requiring_decoration”. 
Well our function was replaced by
wrapTheFunction. 
It overrode the name and docstring of our function.
Luckily Python provides us a simple function to solve this problem and
that is <code>functools.wraps</code>. 
Let’s modify our previous example to use
<code>functools.wraps</code>:

from functools import wraps

def a_new_decorator(a_func):
    @wraps(a_func)
    def wrapTheFunction():
     print(&quot;I am doing some boring work before executing a_func()&quot;)
         a_func()
         print(&quot;I am doing some boring work after executing a_func()&quot;)
    return wrapTheFunction

@a_new_decorator
def a_function_requiring_decoration():
    &quot;&quot;&quot;Hey yo! Decorate me!&quot;&quot;&quot;
    print(&quot;I am the function which needs some decoration to &quot;
       &quot;remove my foul smell&quot;)

print(a_function_requiring_decoration.__name__)
# Output: a_function_requiring_decoration
Now that is much better. 
Let’s move on and learn some use-cases of
decorators.

<strong>Blueprint:</strong>

from functools import wraps
def decorator_name(f):
    @wraps(f)
    def decorated(*args, **kwargs):
     if not can_run:
             return &quot;Function will not run&quot;
             return f(*args, **kwargs)
    return decorated

@decorator_name
def func():
    return(&quot;Function is running&quot;)

can_run = True
print(func())
# Output: Function is running

can_run = False
print(func())
# Output: Function will not run
Note: <code>&#64;wraps</code> takes a function to be decorated and adds the
functionality of copying over the function name, docstring, arguments
list, etc. 
This allows to access the pre-decorated function’s properties
in the decorator.


<h2>7.5.1. Use-cases:</h2>
Now let’s take a look at the areas where decorators really shine and
their usage makes something really easy to manage.


<h2>7.5.2. Authorization</h2>
Decorators can help to check whether someone is authorized to use an
endpoint in a web application. 
They are extensively used in Flask web
framework and Django. 
Here is an example to employ decorator based
authentication:

<strong>Example :</strong>

from functools import wraps

def requires_auth(f):
    @wraps(f)
    def decorated(*args, **kwargs):
     auth = request.authorization
         if not auth or not check_auth(auth.username, auth.password):
             authenticate()
             return f(*args, **kwargs)
    return decorated

<h2>7.5.3. Logging</h2>
Logging is another area where the decorators shine. 
Here is an example:

from functools import wraps

def logit(func):
    @wraps(func)
    def with_logging(*args, **kwargs):
     print(func.__name__ + &quot; was called&quot;)
         return func(*args, **kwargs)
    return with_logging

@logit
def addition_func(x):
   &quot;&quot;&quot;Do some math.&quot;&quot;&quot;
   return x + x


result = addition_func(4)
# Output: addition_func was called
I am sure you are already thinking about some clever uses of decorators.


<h2>7.6. Decorators with Arguments</h2>
Come to think of it, isn’t <code>&#64;wraps</code> also a decorator?  But, it takes an
argument like any normal function can do. 
 So, why can’t we do that too?

This is because when you use the <code>&#64;my_decorator</code> syntax, you are
applying a wrapper function with a single function as a parameter
Remember, everything in Python is an object, and this includes
functions!  With that in mind, we can write a function that returns
a wrapper function.


<h2>7.6.1. Nesting a Decorator Within a Function</h2>
Let’s go back to our logging example, and create a wrapper which lets
us specify a logfile to output to.

from functools import wraps

def logit(logfile=&#39;out.log&#39;):
    def logging_decorator(func):
     @wraps(func)
         def wrapped_function(*args, **kwargs):
             log_string = func.__name__ + &quot; was called&quot;
                 print(log_string)
                 # Open the logfile and append
                 with open(logfile, &#39;a&#39;) as opened_file:
                     # Now we log to the specified logfile
                         opened_file.write(log_string + &#39;\n&#39;)
                 return wrapped_function
    return logging_decorator

@logit()
def myfunc1():
    pass

myfunc1()
# Output: myfunc1 was called
# A file called out.log now exists, with the above string

@logit(logfile=&#39;func2.log&#39;)
def myfunc2():
    pass

myfunc2()
# Output: myfunc2 was called
# A file called func2.log now exists, with the above string

<h2>7.6.2. Decorator Classes</h2>
Now we have our logit decorator in production, but when some parts
of our application are considered critical, failure might be
something that needs more immediate attention. 
 Let’s say sometimes
you want to just log to a file. 
 Other times you want an email sent,
so the problem is brought to your attention, and still keep a log
for your own records. 
 This is a case for using inheritence, but
so far we’ve only seen functions being used to build decorators.

Luckily, classes can also be used to build decorators. 
 So, let’s
rebuild logit as a class instead of a function.

class logit(object):
    def __init__(self, logfile=&#39;out.log&#39;):
     self.logfile = logfile
           def __call__(self, func):
           log_string = func.__name__ + &quot; was called&quot;
         print(log_string)
         # Open the logfile and append
         with open(self.logfile, &#39;a&#39;) as opened_file:
             # Now we log to the specified logfile
                 opened_file.write(log_string + &#39;\n&#39;)
             # Now, send a notification
         self.notify()
           def notify(self):
           # logit only logs, no more
         pass
This implementation has an additional advantage of being much cleaner than
the nested function approach, and wrapping a function still will use
the same syntax as before:

@logit()
def myfunc1():
    pass
Now, let’s subclass logit to add email functionality (though this topic
will not be covered here).

class email_logit(logit):
    &#39;&#39;&#39;
    A logit implementation for sending emails to admins
    when the function is called.
    &#39;&#39;&#39;
    def __init__(self, email=&#39;admin@myproject.com&#39;, *args, **kwargs):
     self.email = email
         super(email_logit, self).__init__(*args, **kwargs)
           def notify(self):
           # Send an email to self.email
         # Will not be implemented here
         pass
From here, <code>&#64;email_logit</code> works just like <code>&#64;logit</code> but sends an email
to the admin in addition to logging.


<h2></h2>
<h2>8. Global &amp; Return</h2>
You might have encountered some functions written in python which have a
<code>return</code> keyword in the end of the function. 
Do you know what it does? It
is similar to return in other languages. 
Lets examine this little
function:

def add(value1, value2):
    return value1 + value2

result = add(3, 5)
print(result)
# Output: 8
The function above takes two values as input and then output their
addition. 
We could have also done:

def add(value1,value2):
    global result
    result = value1 + value2

add(3,5)
print(result)
# Output: 8
So first lets talk about the first bit of code which involves the
<code>return</code> keyword. 
What that function is doing is that it is assigning
the value to the variable which is calling that function which in our
case is <code>result</code>. 
In most cases and you won’t need to use the
<code>global</code> keyword. 
However lets examine the other bit of code as well
which includes the <code>global</code> keyword. 
So what that function is doing is
that it is making a global variable <code>result</code>. 
What does global mean
here? Global variable means that we can access that variable outside the
scope of the function as well. 
Let me demonstrate it with an example:

# first without the global variable
def add(value1, value2):
    result = value1 + value2

add(2, 4)
print(result)

# Oh crap, we encountered an exception. 
Why is it so?
# the python interpreter is telling us that we do not
# have any variable with the name of result. 
It is so
# because the result variable is only accessible inside
# the function in which it is created if it is not global.
Traceback (most recent call last):
  File &quot;&quot;, line 1, in
    result
NameError: name &#39;result&#39; is not defined

# Now lets run the same code but after making the result
# variable global
def add(value1, value2):
    global result
    result = value1 + value2

add(2, 4)
result
6
So hopefully there are no errors in the second run as expected. 
In
practical programming you should try to stay away from <code>global</code>
keyword as it only makes life difficult by introducing unwanted variables
to the global scope.


<h2>8.1. Multiple return values</h2>
So what if you want to return two variables from a function instead of one? There are a couple of approaches which new programmers take. 
The most famous approach is to use <code>global</code> keyword. 
Let’s take a look at a useless example:

def profile():
    global name
    global age
    name = &quot;Danny&quot;
    age = 30

profile()
print(name)
# Output: Danny

print(age)
# Output: 30
<a href="#id1">**</a>Note:<a href="#id3">**</a>Don’t try to use the above mentioned method. 
I repeat, don’t try to use the above mentioned method!

Some try to solve this problem by <em>returning</em> a <code>tuple</code>, <code>list</code> or <code>dict</code> with the required values after the function terminates. 
It is one way to do it and works like a charm:

def profile():
    name = &quot;Danny&quot;
    age = 30
    return (name, age)

profile_data = profile()
print(profile_data[0])
# Output: Danny

print(profile_data[1])
# Output: 30
Or by more common convention:

def profile():
    name = &quot;Danny&quot;
    age = 30
    return name, age

profile_name, profile_age = profile()
print(profile_name)
# Output: Danny
print(profile_age)
# Output: 30
Keep in mind that even in the above example we are returning a tuple (despite the lack of paranthesis) and not separate multiple values. 
If you want to take it one step further, you can also make use of <a class="reference external" href="https://docs.python.org/3/library/collections.html#collections.namedtuple">namedtuple</a>. 
Here is an example:

from collections import namedtuple
def profile():
    Person = namedtuple(&#39;Person&#39;, &#39;name age&#39;)
    return Person(name=&quot;Danny&quot;, age=31)

# Use as namedtuple
p = profile()
print(p, type(p))
# Person(name=&#39;Danny&#39;, age=31) &lt;class &#39;__main__.Person&#39;&gt;
print(p.name)
# Danny
print(p.age)
#31

# Use as plain tuple
p = profile()
print(p[0])
# Danny
print(p[1])
#31

# Unpack it immediatly
name, age = profile()
print(name)
# Danny
print(age)
#31
This is a better way to do it along with returning <code>lists</code> and <code>dicts</code>. 
Don’t use <code>global</code> keyword unless you know what you are doing. 
<code>global</code> might be a better option in a few cases but is not in most of them.


<h2></h2>
<h2>9. Mutation</h2>
The mutable and immutable datatypes in Python cause a lot of headache
for new programmers. 
In simple words, mutable means ‘able to be changed’
and immutable means ‘constant’. 
Want your head to spin? Consider this
example:

foo = [&#39;hi&#39;]
print(foo)
# Output: [&#39;hi&#39;]

bar = foo
bar += [&#39;bye&#39;]
print(foo)
# Output: [&#39;hi&#39;, &#39;bye&#39;]
What just happened? We were not expecting that! We were expecting
something like this:

foo = [&#39;hi&#39;]
print(foo)
# Output: [&#39;hi&#39;]

bar = foo
bar += [&#39;bye&#39;]

print(foo)
# Expected Output: [&#39;hi&#39;]
# Output: [&#39;hi&#39;, &#39;bye&#39;]

print(bar)
# Output: [&#39;hi&#39;, &#39;bye&#39;]
It’s not a bug. 
It’s mutability in action. 
Whenever you assign a
variable to another variable of mutable datatype, any changes to the
data are reflected by both variables. 
The new variable is just an alias
for the old variable. 
This is only true for mutable datatypes. 
Here is a
gotcha involving functions and mutable data types:

def add_to(num, target=[]):
    target.append(num)
    return target

add_to(1)
# Output: [1]

add_to(2)
# Output: [1, 2]

add_to(3)
# Output: [1, 2, 3]
You might have expected it to behave differently. 
You might be expecting
that a fresh list would be created when you call <code>add_to</code> like this:

def add_to(num, target=[]):
    target.append(num)
    return target

add_to(1)
# Output: [1]

add_to(2)
# Output: [2]

add_to(3)
# Output: [3]
Well again it is the mutability of lists which causes this pain. 
In
Python the default arguments are evaluated once when the function is
defined, not each time the function is called. 
You should never define
default arguments of mutable type unless you know what you are doing.
You should do something like this:

def add_to(element, target=None):
    if target is None:
     target = []
    target.append(element)
    return target
Now whenever you call the function without the <code>target</code> argument, a
new list is created. 
For instance:

add_to(42)
# Output: [42]

add_to(42)
# Output: [42]

add_to(42)
# Output: [42]

<h2></h2>
<h2>10. __slots__ Magic</h2>
In Python every class can have instance attributes. 
By default Python
uses a dict to store an object’s instance attributes. 
This is really
helpful as it allows setting arbitrary new attributes at runtime.

However, for small classes with known attributes it might be a
bottleneck. 
The <code>dict</code> wastes a lot of RAM. 
Python can’t just allocate
a static amount of memory at object creation to store all the
attributes. 
Therefore it sucks a lot of RAM if you create a lot of
objects (I am talking in thousands and millions). 
Still there is a way
to circumvent this issue. 
It involves the usage of <code>__slots__</code> to
tell Python not to use a dict, and only allocate space for a fixed set
of attributes. 
Here is an example with and without <code>__slots__</code>:

<strong>Without</strong> <code>__slots__</code>:

class MyClass(object):
    def __init__(self, name, identifier):
     self.name = name
         self.identifier = identifier
         self.set_up()
    # ...
<strong>With</strong> <code>__slots__</code>:

class MyClass(object):
    __slots__ = [&#39;name&#39;, &#39;identifier&#39;]
    def __init__(self, name, identifier):
     self.name = name
         self.identifier = identifier
         self.set_up()
    # ...
The second piece of code will reduce the burden on your RAM. 
Some people
have seen almost 40 to 50% reduction in RAM usage by using this
technique.

On a sidenote, you might want to give PyPy a try. 
It does all of these
optimizations by default.

Below you can see an example showing exact memory usage with and without <code>__slots__</code> done in IPython thanks to <a class="reference external" href="https://github.com/ianozsvald/ipython_memory_usage">https://github.com/ianozsvald/ipython_memory_usage</a>

Python 3.4.3 (default, Jun  6 2015, 13:32:34)
Type &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.

IPython 4.0.0 -- An enhanced Interactive Python.
?         -&gt; Introduction and overview of IPython&#39;s features.
%quickref -&gt; Quick reference.
help      -&gt; Python&#39;s own help system.
object?   -&gt; Details about &#39;object&#39;, use &#39;object??&#39; for extra details.

In [1]: import ipython_memory_usage.ipython_memory_usage as imu

In [2]: imu.start_watching_memory()
In [2] used 0.0000 MiB RAM in 5.31s, peaked 0.00 MiB above current, total RAM usage 15.57 MiB

In [3]: %cat slots.py
class MyClass(object):
 __slots__ = [&#39;name&#39;, &#39;identifier&#39;]
         def __init__(self, name, identifier):
                 self.name = name
                         self.identifier = identifier

num = 1024*256
x = [MyClass(1,1) for i in range(num)]
In [3] used 0.2305 MiB RAM in 0.12s, peaked 0.00 MiB above current, total RAM usage 15.80 MiB

In [4]: from slots import *
In [4] used 9.3008 MiB RAM in 0.72s, peaked 0.00 MiB above current, total RAM usage 25.10 MiB

In [5]: %cat noslots.py
class MyClass(object):
 def __init__(self, name, identifier):
                 self.name = name
                         self.identifier = identifier

num = 1024*256
x = [MyClass(1,1) for i in range(num)]
In [5] used 0.1758 MiB RAM in 0.12s, peaked 0.00 MiB above current, total RAM usage 25.28 MiB

In [6]: from noslots import *
In [6] used 22.6680 MiB RAM in 0.80s, peaked 0.00 MiB above current, total RAM usage 47.95 MiB

<h2></h2>
<h2>11. Virtual Environment</h2>
Have you ever heard of <code>virtualenv</code>? If you are a beginner,
then you might not have heard about it but if you are a
seasoned programmer then it may well be a vital part of your toolset.

So what is <code>virtualenv</code>? <code>Virtualenv</code> is a tool which allows us to
make isolated python environments. 
Imagine you have an application that
needs version 2 of a library, but another application requires
version 3. 
How can you use and develop both these applications?

If you install everything into <code>/usr/lib/python2.7/site-packages</code> (or
whatever your platform’s standard location is), it’s easy to end up in a
situation where you unintentionally upgrade a package.

In another case, imagine that you have an application which is fully
developed and you do not want to make any change to the libraries it is
using but at the same time you start developing another application
which requires the updated versions of those libraries.

What will you do? Use <code>virtualenv</code>! It creates isolated environments
for your python application and allows you to install Python libraries
in that isolated environment instead of installing them globally.

To install it, just type this command in the shell:

$ pip install virtualenv
The most important commands are:

<ul class="simple">
<li><code>$ virtualenv myproject</code></li>
<li><code>$ source myproject/bin/activate</code></li>
</ul>
This first one makes an isolated virtualenv environment in the
<code>myproject</code> folder and the second command activates that isolated
environment.

While creating the virtualenv you have to make a decision. 
Do you
want this virtualenv to use packages from your system <code>site-packages</code>
or install them in the virtualenv’s site-packages? By default,
virtualenv will not give access to the global <code>site-packages</code>.

If you want your <code>virtualenv</code> to have access to your systems
<code>site-packages</code>, use the <code>--system-site-packages</code> switch when creating
your virtualenv like this:

$ virtualenv --system-site-packages mycoolproject
You can turn off the <code>env</code> by typing:

$ deactivate
Running <cite>python</cite> after deactivating will use your system installation
of Python again.

<strong>Bonus</strong>

You can use <code>smartcd</code> which is a library for bash and zsh and allows
you to alter your bash (or zsh) environment as you cd. 
It can be really
helpful to activate and deactivate a <code>virtualenv</code> when you change
directories. 
I have used it quite a lot and love it. 
You can read more
about it on <a class="reference external" href="https://github.com/cxreg/smartcd">GitHub</a>

This was just a short intro to virtualenv. 
There’s a lot more to it; <a class="reference external" href="http://docs.python-guide.org/en/latest/dev/virtualenvs/">this
link</a> has more
information.


<h2></h2>
<h2>12. Collections</h2>
Python ships with a module that contains a number of container data
types called Collections. 
We will talk about a few of them and discuss
their usefulness.

The ones which we will talk about are:

<ul class="simple">
<li><code>defaultdict</code></li>
<li><code>OrderedDict</code></li>
<li><code>counter</code></li>
<li><code>deque</code></li>
<li><code>namedtuple</code></li>
<li><code>enum.Enum</code> (outside of the module; Python 3.4+)</li>
</ul>

<h2>12.1. <code>defaultdict</code></h2>
I personally use defaultdict quite a bit. 
Unlike <code>dict</code>, with
<code>defaultdict</code> you do not need to check whether a key is present or
not. 
So we can do:

from collections import defaultdict

colours = (
    (&#39;Yasoob&#39;, &#39;Yellow&#39;),
    (&#39;Ali&#39;, &#39;Blue&#39;),
    (&#39;Arham&#39;, &#39;Green&#39;),
    (&#39;Ali&#39;, &#39;Black&#39;),
    (&#39;Yasoob&#39;, &#39;Red&#39;),
    (&#39;Ahmed&#39;, &#39;Silver&#39;),
)

favourite_colours = defaultdict(list)

for name, colour in colours:
    favourite_colours[name].append(colour)

print(favourite_colours)

# output
# defaultdict(&lt;type &#39;list&#39;&gt;,
#    {&#39;Arham&#39;: [&#39;Green&#39;],
#     &#39;Yasoob&#39;: [&#39;Yellow&#39;, &#39;Red&#39;],
#     &#39;Ahmed&#39;: [&#39;Silver&#39;],
#     &#39;Ali&#39;: [&#39;Blue&#39;, &#39;Black&#39;]
# })
One other very important use case is when you are appending to nested
lists inside a dictionary. 
If a <code>key</code> is not already present in the
dictionary then you are greeted with a <code>KeyError</code>. 
<code>defaultdict</code>
allows us to circumvent this issue in a clever way. 
First let me share
an example using <code>dict</code> which raises <code>KeyError</code> and then I will
share a solution using <code>defaultdict</code>.

<strong>Problem:</strong>

some_dict = {}
some_dict[&#39;colours&#39;][&#39;favourite&#39;] = &quot;yellow&quot;
# Raises KeyError: &#39;colours&#39;
<strong>Solution:</strong>

import collections
tree = lambda: collections.defaultdict(tree)
some_dict = tree()
some_dict[&#39;colours&#39;][&#39;favourite&#39;] = &quot;yellow&quot;
# Works fine
You can print <code>some_dict</code> using <code>json.dumps</code>. 
Here is some
sample code:

import json
print(json.dumps(some_dict))
# Output: {&quot;colours&quot;: {&quot;favourite&quot;: &quot;yellow&quot;}}

<h2>12.2. <code>OrderedDict</code></h2>
<code>OrderedDict</code> keeps its entries sorted as they are initially inserted.
Overwriting a value of an existing key doesn’t change the position of
that key. 
However, deleting and reinserting an entry moves the key to
the end of the dictionary.

<strong>Problem:</strong>

colours =  {&quot;Red&quot; : 198, &quot;Green&quot; : 170, &quot;Blue&quot; : 160}
for key, value in colours.items():
    print(key, value)
# Output:
#   Green 170
#   Blue 160
#   Red 198
# Entries are retrieved in an unpredictable order
<strong>Solution:</strong>

from collections import OrderedDict

colours = OrderedDict([(&quot;Red&quot;, 198), (&quot;Green&quot;, 170), (&quot;Blue&quot;, 160)])
for key, value in colours.items():
    print(key, value)
# Output:
#   Red 198
#   Green 170
#   Blue 160
# Insertion order is preserved

<h2>12.3. <code>counter</code></h2>
Counter allows us to count the occurrences of a particular item. 
For
instance it can be used to count the number of individual favourite
colours:

from collections import Counter

colours = (
    (&#39;Yasoob&#39;, &#39;Yellow&#39;),
    (&#39;Ali&#39;, &#39;Blue&#39;),
    (&#39;Arham&#39;, &#39;Green&#39;),
    (&#39;Ali&#39;, &#39;Black&#39;),
    (&#39;Yasoob&#39;, &#39;Red&#39;),
    (&#39;Ahmed&#39;, &#39;Silver&#39;),
)

favs = Counter(name for name, colour in colours)
print(favs)
# Output: Counter({
#    &#39;Yasoob&#39;: 2,
#    &#39;Ali&#39;: 2,
#    &#39;Arham&#39;: 1,
#    &#39;Ahmed&#39;: 1
# })
We can also count the most common lines in a file using it. 
For example:

with open(&#39;filename&#39;, &#39;rb&#39;) as f:
    line_count = Counter(f)
print(line_count)

<h2>12.4. <code>deque</code></h2>
<code>deque</code> provides you with a double ended queue which means that you
can append and delete elements from either side of the queue. 
First of
all you have to import the deque module from the collections library:

from collections import deque
Now we can instantiate a deque object.

d = deque()
It works like python lists and provides you with somewhat similar
methods as well. 
For example you can do:

d = deque()
d.append(&#39;1&#39;)
d.append(&#39;2&#39;)
d.append(&#39;3&#39;)

print(len(d))
# Output: 3

print(d[0])
# Output: &#39;1&#39;

print(d[-1])
# Output: &#39;3&#39;
You can pop values from both sides of the deque:

d = deque(range(5))
print(len(d))
# Output: 5

d.popleft()
# Output: 0

d.pop()
# Output: 4

print(d)
# Output: deque([1, 2, 3])
We can also limit the amount of items a deque can hold. 
By doing this
when we achieve the maximum limit of our deque it will simply pop out
the items from the opposite end. 
It is better to explain it using an
example so here you go:

d = deque(maxlen=30)
Now whenever you insert values after 30, the leftmost value will be
popped from the list. 
You can also expand the list in any direction with
new values:

d = deque([1,2,3,4,5])
d.extendleft([0])
d.extend([6,7,8])
print(d)
# Output: deque([0, 1, 2, 3, 4, 5, 6, 7, 8])

<h2>12.5. <code>namedtuple</code></h2>
You might already be acquainted with tuples. 
A tuple is basically
a immutable list which&nbsp;allows you to store a sequence of values
separated by commas. 
They are just like lists but have a few key
differences. 
The major one is&nbsp;that unlike lists, <strong>you can not
reassign an item in a tuple</strong>. 
In order to access the value in a
tuple you use integer indexes like:

man = (&#39;Ali&#39;, 30)
print(man[0])
# Output: Ali
Well, so now what are <code>namedtuples</code>? They turn tuples into convenient
containers for simple tasks. 
With namedtuples you don’t have to use
integer indexes for accessing members of a tuple. 
You can think of
namedtuples like dictionaries but unlike dictionaries they are
immutable.

from collections import namedtuple

Animal = namedtuple(&#39;Animal&#39;, &#39;name age type&#39;)
perry = Animal(name=&quot;perry&quot;, age=31, type=&quot;cat&quot;)

print(perry)
# Output: Animal(name=&#39;perry&#39;, age=31, type=&#39;cat&#39;)

print(perry.name)
# Output: &#39;perry&#39;
You can now see that we can access members of a tuple just by their
name using a <code>.</code>. 
Let’s dissect it a little more. 
A named tuple has two
required arguments. 
They are the tuple name and the tuple field_names.
In the above example our tuple name was ‘Animal’ and the tuple
field_names were ‘name’, ‘age’ and ‘type’. 
Namedtuple makes your tuples
<strong>self-document</strong>. 
You can easily understand what is going on by having
a quick glance at your code. 
And as you are not bound to use integer
indexes to access members of a tuple, it makes it more easy to maintain
your code. 
Moreover, as <strong>`namedtuple` instances do not have
per-instance dictionaries</strong>, they are lightweight and require no more
memory than regular tuples. 
This makes them faster than dictionaries.
However, do remember that as with tuples, <strong>attributes in namedtuples
are immutable</strong>. 
It means that this would not work:

from collections import namedtuple

Animal = namedtuple(&#39;Animal&#39;, &#39;name age type&#39;)
perry = Animal(name=&quot;perry&quot;, age=31, type=&quot;cat&quot;)
perry.age = 42

# Output: Traceback (most recent call last):
#            File &quot;&quot;, line 1, in
#         AttributeError: can&#39;t set attribute
You should use named tuples to make your code self-documenting. 
<strong>They
are backwards compatible with normal tuples</strong>. 
It means that you can use
integer indexes with namedtuples as well:

from collections import namedtuple

Animal = namedtuple(&#39;Animal&#39;, &#39;name age type&#39;)
perry = Animal(name=&quot;perry&quot;, age=31, type=&quot;cat&quot;)
print(perry[0])
# Output: perry
Last but not the least, you can convert a namedtuple to a dictionary.
Like this:

from collections import namedtuple

Animal = namedtuple(&#39;Animal&#39;, &#39;name age type&#39;)
perry = Animal(name=&quot;Perry&quot;, age=31, type=&quot;cat&quot;)
print(perry._asdict())
# Output: OrderedDict([(&#39;name&#39;, &#39;Perry&#39;), (&#39;age&#39;, 31), ...

<h2>12.6. <code>enum.Enum</code> (Python 3.4+)</h2>
Another useful collection is the enum object. 
It is available in the <code>enum</code>
module, in Python 3.4 and up (also available as a backport in PyPI named <code>enum34</code>.)
Enums (<a class="reference external" href="https://en.wikipedia.org/wiki/Enumerated_type">enumerated type</a>) are
basically a way to organize various things.

Let’s consider the Animal namedtuple from the last example. 
 It had a <code>type</code>
field. 
 The problem is, the type was a string. 
 This poses some problems for
us. 
What if the user types in <code>Cat</code> because they held the Shift key?  Or
<code>CAT</code>?  Or <code>kitten</code>?

Enumerations can help us avoid this problem, by not using strings. 
 Consider
this example:

from collections import namedtuple
from enum import Enum

class Species(Enum):
    cat = 1
    dog = 2
    horse = 3
    aardvark = 4
    butterfly = 5
    owl = 6
    platypus = 7
    dragon = 8
    unicorn = 9
    # The list goes on and on...
      # But we don&#39;t really care about age, so we can use an alias.
    kitten = 1
    puppy = 2

Animal = namedtuple(&#39;Animal&#39;, &#39;name age type&#39;)
perry = Animal(name=&quot;Perry&quot;, age=31, type=Species.cat)
drogon = Animal(name=&quot;Drogon&quot;, age=4, type=Species.dragon)
tom = Animal(name=&quot;Tom&quot;, age=75, type=Species.cat)
charlie = Animal(name=&quot;Charlie&quot;, age=2, type=Species.kitten)

# And now, some tests.
&gt;&gt;&gt; charlie.type == tom.type
True
&gt;&gt;&gt; charlie.type
&lt;Species.cat: 1&gt;
This is much less error-prone. 
 We have to be specific, and we should use only
the enumeration to name types.

There are three ways to access enumeration members. 
 For example, all three
methods will get you the value for <code>cat</code>:

Species(1)
Species[&#39;cat&#39;]
Species.cat
This was just a quick drive through the <code>collections</code> module. 
Make
sure you read the official documentation after reading this.


<h2></h2>
<h2>13. Enumerate</h2>
Enumerate is a built-in function of Python. 
It’s usefulness can not be
summarized in a single line. 
Yet most of the newcomers and even some
advanced programmers are unaware of it. 
It allows us to loop over
something and have an automatic counter. 
Here is an example:

for counter, value in enumerate(some_list):
    print(counter, value)
And there is more! <code>enumerate</code> also accepts an optional argument which
makes it even more useful.

my_list = [&#39;apple&#39;, &#39;banana&#39;, &#39;grapes&#39;, &#39;pear&#39;]
for c, value in enumerate(my_list, 1):
    print(c, value)

# Output:
# 1 apple
# 2 banana
# 3 grapes
# 4 pear
The optional argument allows us to tell <code>enumerate</code> from where to
start the index. 
You can also create tuples containing the index and
list item using a list. 
Here is an example:

my_list = [&#39;apple&#39;, &#39;banana&#39;, &#39;grapes&#39;, &#39;pear&#39;]
counter_list = list(enumerate(my_list, 1))
print(counter_list)
# Output: [(1, &#39;apple&#39;), (2, &#39;banana&#39;), (3, &#39;grapes&#39;), (4, &#39;pear&#39;)]

<h2></h2>
<h2>14. Object introspection</h2>
In computer programming, introspection is the ability to determine the
type of an object at runtime. 
It is one of Python’s strengths.
Everything in Python is an object and we can examine those objects.
Python ships with a few built-in functions and modules to help us.


<h2>14.1. <code>dir</code></h2>
In this section we will learn about <code>dir</code> and how it facilitates us
in introspection.

It is one of the most important functions for introspection. 
It returns
a list of attributes and methods belonging to an object. 
Here is an
example:

my_list = [1, 2, 3]
dir(my_list)
# Output: [&#39;__add__&#39;, &#39;__class__&#39;, &#39;__contains__&#39;, &#39;__delattr__&#39;, &#39;__delitem__&#39;,
# &#39;__delslice__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;,
# &#39;__getitem__&#39;, &#39;__getslice__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__iadd__&#39;, &#39;__imul__&#39;,
# &#39;__init__&#39;, &#39;__iter__&#39;, &#39;__le__&#39;, &#39;__len__&#39;, &#39;__lt__&#39;, &#39;__mul__&#39;, &#39;__ne__&#39;,
# &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__reversed__&#39;, &#39;__rmul__&#39;,
# &#39;__setattr__&#39;, &#39;__setitem__&#39;, &#39;__setslice__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;,
# &#39;__subclasshook__&#39;, &#39;append&#39;, &#39;count&#39;, &#39;extend&#39;, &#39;index&#39;, &#39;insert&#39;, &#39;pop&#39;,
# &#39;remove&#39;, &#39;reverse&#39;, &#39;sort&#39;]
Our introspection gave us the names of all the methods of a list. 
This
can be handy when you are not able to recall a method name. 
If we run
<code>dir()</code> without any argument then it returns all names in the current
scope.


<h2>14.2. <code>type</code> and <code>id</code></h2>
The <code>type</code> function returns the type of an object. 
For example:

print(type(&#39;&#39;))
# Output: &lt;type &#39;str&#39;&gt;

print(type([]))
# Output: &lt;type &#39;list&#39;&gt;

print(type({}))
# Output: &lt;type &#39;dict&#39;&gt;

print(type(dict))
# Output: &lt;type &#39;type&#39;&gt;

print(type(3))
# Output: &lt;type &#39;int&#39;&gt;
<code>id</code> returns the unique ids of various objects. 
For instance:

name = &quot;Yasoob&quot;
print(id(name))
# Output: 139972439030304

<h2>14.3. <code>inspect</code> module</h2>
The inspect module also provides several useful functions to get
information about live objects. 
For example you can check the members of
an object by running:

import inspect
print(inspect.getmembers(str))
# Output: [(&#39;__add__&#39;, &lt;slot wrapper &#39;__add__&#39; of ... 
...
There are a couple of other methods as well which help in introspection.
You can explore them if you wish.


<h2></h2>
<h2>15. Comprehensions</h2>
Comprehensions are a feature of Python which I would really miss if I
ever have to leave it. 
Comprehensions are constructs that allow
sequences to be built from other sequences. 
Three types of
comprehensions are supported in both Python 2 and Python 3:

<ul class="simple">
<li>list comprehensions</li>
<li>dictionary comprehensions</li>
<li>set comprehensions</li>
<li>generator comprehensions</li>
</ul>
We will discuss them one by one. 
Once you get the hang of using <code>list</code>
comprehensions then you can use any of them easily.


<h2>15.1. <code>list</code> comprehensions</h2>
List comprehensions provide a short and concise way to create lists. 
It
consists of square brackets containing an expression followed by a
<code>for</code> clause, then zero or more <code>for</code> or <code>if</code> clauses. 
The
expressions can be anything, meaning you can put in all kinds of objects
in lists. 
The result would be a new list made after the evaluation of
the expression in context of the <code>if</code> and <code>for</code> clauses.

<strong>Blueprint</strong>

variable = [out_exp for out_exp in input_list if out_exp == 2]
Here is a short example:

multiples = [i for i in range(30) if i % 3 == 0]
print(multiples)
# Output: [0, 3, 6, 9, 12, 15, 18, 21, 24, 27]
This can be really useful to make lists quickly. 
It is even preferred by
some instead of the <code>filter</code> function. 
List comprehensions really
shine when you want to supply a list to a method or function to make a
new list by appending to it in each iteration of the <code>for</code> loop. 
For
instance you would usually do something like this:

squared = []
for x in range(10):
    squared.append(x**2)
You can simplify it using list comprehensions. 
For example:

squared = [x**2 for x in range(10)]

<h2>15.2. <code>dict</code> comprehensions</h2>
They are used in a similar way. 
Here is an example which I found
recently:

mcase = {&#39;a&#39;: 10, &#39;b&#39;: 34, &#39;A&#39;: 7, &#39;Z&#39;: 3}

mcase_frequency = {
    k.lower(): mcase.get(k.lower(), 0) + mcase.get(k.upper(), 0)
    for k in mcase.keys()
}

# mcase_frequency == {&#39;a&#39;: 17, &#39;z&#39;: 3, &#39;b&#39;: 34}
In the above example we are combining the values of keys which are same
but in different typecase. 
I personally do not use <code>dict</code>
comprehensions a lot. 
You can also quickly switch keys and values of a dictionary:

{v: k for k, v in some_dict.items()}

<h2>15.3. <code>set</code> comprehensions</h2>
They are also similar to list comprehensions. 
The only difference is
that they use braces <code>{}</code>. 
Here is an example:

squared = {x**2 for x in [1, 1, 2]}
print(squared)
# Output: {1, 4}

<h2>15.4. <code>generator</code> comprehensions</h2>
They are also similar to list comprehensions. 
The only difference is that they don’t allocate memory for the whole list but generate one item at a time, thus more memory effecient.

multiples_gen = (i for i in range(30) if i % 3 == 0)
print(multiples_gen)
# Output: &lt;generator object &lt;genexpr&gt; at 0x7fdaa8e407d8&gt;
for x in multiples_gen:
  print(x)
  # Outputs numbers

<h2></h2>
<h2>16. Exceptions</h2>
Exception handling is an art which once you master grants you immense
powers. 
I am going to show you some of the ways in which we can handle
exceptions.

In basic terminology we are aware of <code>try/except</code> clause. 
The code
which can cause an exception to occur is put in the <code>try</code> block and
the handling of the exception is implemented in the <code>except</code> block.
Here is a simple example:

try:
    file = open(&#39;test.txt&#39;, &#39;rb&#39;)
except IOError as e:
    print(&#39;An IOError occurred. 
{}&#39;.format(e.args[-1]))
In the above example we are handling only the IOError exception. 
What
most beginners do not know is that we can handle multiple exceptions.


<h2>16.1. Handling multiple exceptions:</h2>
We can use three methods to handle multiple exceptions. 
The first one
involves putting all the exceptions which are likely to occur in a
tuple. 
Like so:

try:
    file = open(&#39;test.txt&#39;, &#39;rb&#39;)
except (IOError, EOFError) as e:
    print(&quot;An error occurred. 
{}&quot;.format(e.args[-1]))
Another method is to handle individual exceptions in separate <code>except</code>
blocks. 
We can have as many <code>except</code> blocks as we want. 
Here is an example:

try:
    file = open(&#39;test.txt&#39;, &#39;rb&#39;)
except EOFError as e:
    print(&quot;An EOF error occurred.&quot;)
    raise e
except IOError as e:
    print(&quot;An error occurred.&quot;)
    raise e
This way if the exception is not handled by the first <code>except</code> block then
it may be handled by a following block, or none at all. 
Now the last method involves
trapping ALL exceptions:

try:
    file = open(&#39;test.txt&#39;, &#39;rb&#39;)
except Exception:
    # Some logging if you want
    raise
This can be helpful when you have no idea about the exceptions which may
be thrown by your program.


<h2>16.1.1. <code>finally</code> clause</h2>
We wrap our main code in the <code>try</code> clause. 
After that we wrap some code in
an <code>except</code> clause which gets executed if an exception occurs in the code
wrapped in the <code>try</code> clause. 
In this example we will use a third clause as
well which is the <code>finally</code> clause. 
The code which is wrapped in the
<code>finally</code> clause will run whether or not an exception occurred. 
It might be used
to perform clean-up after a script. 
Here is a simple example:

try:
    file = open(&#39;test.txt&#39;, &#39;rb&#39;)
except IOError as e:
    print(&#39;An IOError occurred. 
{}&#39;.format(e.args[-1]))
finally:
    print(&quot;This would be printed whether or not an exception occurred!&quot;)

# Output: An IOError occurred. 
No such file or directory
# This would be printed whether or not an exception occurred!

<h2>16.1.2. <code>try/else</code> clause</h2>
Often times we might want some code to run if <strong>no</strong> exception occurs. 
This
can easily be achieved by using an <code>else</code> clause. 
One might ask: why, if
you only want some code to run if no exception occurs, wouldn’t you simply
put that code inside the <code>try</code>? The answer is that then any exceptions in
that code will be caught by the <code>try</code>, and you might not want that. 
Most
people don’t use it and honestly I have myself not used it widely. 
Here is an
example:

try:
    print(&#39;I am sure no exception is going to occur!&#39;)
except Exception:
    print(&#39;exception&#39;)
else:
    # any code that should only run if no exception occurs in the try,
    # but for which exceptions should NOT be caught
    print(&#39;This would only run if no exception occurs. 
And an error here &#39;
       &#39;would NOT be caught.&#39;)
finally:
    print(&#39;This would be printed in every case.&#39;)

# Output: I am sure no exception is going to occur!
# This would only run if no exception occurs. 
And an error here would NOT be caught
# This would be printed in every case.
The <code>else</code> clause would only run if no exception occurs and it would run
before the <code>finally</code> clause.


<h2></h2>
<h2>17. Classes</h2>
Classes are the core of Python. 
They give us a lot of power but it is
really easy to misuse this power. 
In this section I will share some
obscure tricks and caveats related to <code>classes</code> in Python. 
Let’s get
going!


<h2>17.1. 1. 
Instance &amp; Class variables</h2>
Most beginners and even some advanced Python programmers do not
understand the distinction between instance and class variables. 
Their
lack of understanding forces them to use these different types of
variables incorrectly. 
Let’s understand them.

The basic difference is:

<ul class="simple">
<li>Instance variables are for data which is unique to every object</li>
<li>Class variables are for data shared between different instances of a
class</li>
</ul>
Let’s take a look at an example:

class Cal(object):
    # pi is a class variable
    pi = 3.142
      def __init__(self, radius):
       # self.radius is an instance variable
         self.radius = radius
           def area(self):
           return self.pi * (self.radius ** 2)

a = Cal(32)
a.area()
# Output: 3217.408
a.pi
# Output: 3.142
a.pi = 43
a.pi
# Output: 43

b = Cal(44)
b.area()
# Output: 6082.912
b.pi
# Output: 3.142
b.pi = 50
b.pi
# Output: 50
There are not many issues while using mutable class variables. 
This is
the major reason due to which beginners do not try to learn more about
this subject because everything works! If you also believe that instance
and class variables can not cause any problem if used incorrectly then
check the next example.

class SuperClass(object):
    superpowers = []
      def __init__(self, name):
       self.name = name
           def add_superpower(self, power):
           self.superpowers.append(power)

foo = SuperClass(&#39;foo&#39;)
bar = SuperClass(&#39;bar&#39;)
foo.name
# Output: &#39;foo&#39;

bar.name
# Output: &#39;bar&#39;

foo.add_superpower(&#39;fly&#39;)
bar.superpowers
# Output: [&#39;fly&#39;]

foo.superpowers
# Output: [&#39;fly&#39;]
That is the beauty of the wrong usage of mutable class variables. 
To
make your code safe against this kind of surprise attacks then make sure
that you do not use mutable class variables. 
You may use them only if
you know what you are doing.


<h2>17.2. 2. 
New style classes</h2>
New style classes were introduced in Python 2.1 but a lot of people do
not know about them even now! It is so because Python also supports old
style classes just to maintain backward compatibility. 
I have said a lot
about new and old but I have not told you about the difference. 
Well the
major difference is that:

<ul class="simple">
<li>Old base classes do not inherit from anything</li>
<li>New style base classes inherit from <code>object</code></li>
</ul>
A very basic example is:

class OldClass():
    def __init__(self):
     print(&#39;I am an old class&#39;)

class NewClass(object):
    def __init__(self):
     print(&#39;I am a jazzy new class&#39;)

old = OldClass()
# Output: I am an old class

new = NewClass()
# Output: I am a jazzy new class
This inheritance from <code>object</code> allows new style classes to utilize
some <em>magic</em>. 
A major advantage is that you can employ some useful
optimizations like <code>__slots__</code>. 
You can use <code>super()</code> and
descriptors and the likes. 
Bottom line? Always try to use new-style
classes.

<strong>Note:</strong> Python 3 only has new-style classes. 
It does not matter
whether you subclass from <code>object</code> or not. 
However it is recommended
that you still subclass from <code>object</code>.


<h2>17.3. 3. 
Magic Methods</h2>
Python’s classes are famous for their magic methods, commonly called
<strong>dunder</strong> (double underscore) methods. 
I am going to discuss a few of
them.

<ul class="simple">
<li><code>__init__</code></li>
</ul>
It is a class initializer. 
Whenever an instance of a class is created
its <code>__init__</code> method is called. 
For example:

class GetTest(object):
    def __init__(self):
     print(&#39;Greetings!!&#39;)
    def another_method(self):
     print(&#39;I am another method which is not&#39;
               &#39; automatically called&#39;)

a = GetTest()
# Output: Greetings!!

a.another_method()
# Output: I am another method which is not automatically
# called
You can see that <code>__init__</code> is called immediately after an instance is
created. 
You can also pass arguments to the class during it’s
initialization. 
Like this:

class GetTest(object):
    def __init__(self, name):
     print(&#39;Greetings!! {0}&#39;.format(name))
    def another_method(self):
     print(&#39;I am another method which is not&#39;
               &#39; automatically called&#39;)

a = GetTest(&#39;yasoob&#39;)
# Output: Greetings!! yasoob

# Try creating an instance without the name arguments
b = GetTest()
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: __init__() takes exactly 2 arguments (1 given)
I am sure that now you understand the <code>__init__</code> method.

<ul class="simple">
<li><code>__getitem__</code></li>
</ul>
Implementing <strong>getitem</strong> in a class allows its instances to use the []
(indexer) operator. 
Here is an example:

class GetTest(object):
    def __init__(self):
     self.info = {
             &#39;name&#39;:&#39;Yasoob&#39;,
                 &#39;country&#39;:&#39;Pakistan&#39;,
                 &#39;number&#39;:12345812
             }
           def __getitem__(self,i):
           return self.info[i]

foo = OldClass()
foo[&#39;title&#39;]
# Output: &#39;Yasoob&#39;

foo[&#39;number&#39;]
# Output: 36845124
Without the <code>__getitem__</code> method we would have got this error:

&gt;&gt;&gt; foo[&#39;title&#39;]

Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: &#39;GetTest&#39; object has no attribute &#39;__getitem__&#39;

<h2></h2>
<h2>18. Lambdas</h2>
Lambdas are one line functions. 
They are also known as anonymous
functions in some other languages. 
You might want to use lambdas when
you don’t want to use a function twice in a program. 
They are just like
normal functions and even behave like them.

<strong>Blueprint</strong>

lambda argument: manipulate(argument)
<strong>Example</strong>

add = lambda x, y: x + y

print(add(3, 5))
# Output: 8
Here are a few useful use cases for lambdas and just a few ways in which
they are used in the wild:

<strong>List sorting</strong>

a = [(1, 2), (4, 1), (9, 10), (13, -3)]
a.sort(key=lambda x: x[1])

print(a)
# Output: [(13, -3), (4, 1), (1, 2), (9, 10)]
<strong>Parallel sorting of lists</strong>

data = zip(list1, list2)
data.sort()
list1, list2 = map(lambda t: list(t), zip(*data))

<h2></h2>
<h2>19. One-Liners</h2>
In this chapter I will show you some one-liner Python commands which can
be really helpful.

<strong>Simple Web Server</strong>

Ever wanted to quickly share a file over a network? Well you are in
luck. 
Python has a feature just for you. 
Go to the directory
which you want to serve over the network and write the following code in
your terminal:

# Python 2
python -m SimpleHTTPServer

# Python 3
python -m http.server
<strong>Pretty Printing</strong>

You can print a list and dictionary in a beautiful format in the Python
repl. 
Here is the relevant code:

from pprint import pprint

my_dict = {&#39;name&#39;: &#39;Yasoob&#39;, &#39;age&#39;: &#39;undefined&#39;, &#39;personality&#39;: &#39;awesome&#39;}
print(dir(my_dict))
# [&#39;__add__&#39;, &#39;__class__&#39;, &#39;__contains__&#39;, &#39;__delattr__&#39;, &#39;__delitem__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__getitem__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__iadd__&#39;, &#39;__imul__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__iter__&#39;, &#39;__le__&#39;, &#39;__len__&#39;, &#39;__lt__&#39;, &#39;__mul__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__reversed__&#39;, &#39;__rmul__&#39;, &#39;__setattr__&#39;, &#39;__setitem__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;append&#39;, &#39;clear&#39;, &#39;copy&#39;, &#39;count&#39;, &#39;extend&#39;, &#39;index&#39;, &#39;insert&#39;, &#39;pop&#39;, &#39;remove&#39;, &#39;reverse&#39;, &#39;sort&#39;]

pprint(dir(my_dict))
# [&#39;__add__&#39;,
#  &#39;__class__&#39;,
#  &#39;__contains__&#39;,
#  &#39;__delattr__&#39;,
#  &#39;__delitem__&#39;,
#  &#39;__dir__&#39;,
#  &#39;__doc__&#39;,
#  &#39;__eq__&#39;,
#  &#39;__format__&#39;,
#  &#39;__ge__&#39;,
#  &#39;__getattribute__&#39;,
#  &#39;__getitem__&#39;,
#  &#39;__gt__&#39;,
#  &#39;__hash__&#39;,
#  &#39;__iadd__&#39;,
#  &#39;__imul__&#39;,
#  &#39;__init__&#39;,
#  &#39;__init_subclass__&#39;,
#  &#39;__iter__&#39;,
#  &#39;__le__&#39;,
#  &#39;__len__&#39;,
#  &#39;__lt__&#39;,
#  &#39;__mul__&#39;,
#  &#39;__ne__&#39;,
#  &#39;__new__&#39;,
#  &#39;__reduce__&#39;,
#  &#39;__reduce_ex__&#39;,
#  &#39;__repr__&#39;,
#  &#39;__reversed__&#39;,
#  &#39;__rmul__&#39;,
#  &#39;__setattr__&#39;,
#  &#39;__setitem__&#39;,
#  &#39;__sizeof__&#39;,
#  &#39;__str__&#39;,
#  &#39;__subclasshook__&#39;,
#  &#39;append&#39;,
#  &#39;clear&#39;,
#  &#39;copy&#39;,
#  &#39;count&#39;,
#  &#39;extend&#39;,
#  &#39;index&#39;,
#  &#39;insert&#39;,
#  &#39;pop&#39;,
#  &#39;remove&#39;,
#  &#39;reverse&#39;,
#  &#39;sort&#39;]
This is more effective on nested <code>dict</code> s. 
Moreover, if you want to pretty print
json quickly from a file then you can simply do:

cat file.json | python -m json.tool
<strong>Profiling a script</strong>

This can be extremely helpful in pinpointing the bottlenecks in your
scripts:

python -m cProfile my_script.py
Note: <code>cProfile</code> is a faster implementation of <code>profile</code> as it is
written in c

<strong>CSV to json</strong>

Run this in the terminal:

python -c &quot;import csv,json;print json.dumps(list(csv.reader(open(&#39;csv_file.csv&#39;))))&quot;
Make sure that you replace <code>csv_file.csv</code> to the relevant file name.

<strong>List Flattening</strong>

You can quickly and easily flatten a list using
<code>itertools.chain.from_iterable</code> from the <code>itertools</code> package. 
Here
is a simple example:

a_list = [[1, 2], [3, 4], [5, 6]]
print(list(itertools.chain.from_iterable(a_list)))
# Output: [1, 2, 3, 4, 5, 6]

# or
print(list(itertools.chain(*a_list)))
# Output: [1, 2, 3, 4, 5, 6]
<strong>One-Line Constructors</strong>

Avoid a lot of boilerplate assignments when initializing a class

class A(object):
    def __init__(self, a, b, c, d, e, f):
     self.__dict__.update({k: v for k, v in locals().items() if k != &#39;self&#39;})
Additional one-liners can be found on the <a class="reference external" href="https://wiki.python.org/moin/Powerful%20Python%20One-Liners">Python
website</a>.


<h2></h2>
<h2>20. <code>for/else</code></h2>
Loops are an integral part of any language. 
Likewise <code>for</code> loops are
an important part of Python. 
However there are a few things which most
beginners do not know about them. 
We will discuss a few of them one-by-one.

Let’s first start off with what we know. 
We know that we can use <code>for</code> loops
like this:

fruits = [&#39;apple&#39;, &#39;banana&#39;, &#39;mango&#39;]
for fruit in fruits:
    print(fruit.capitalize())

# Output: Apple
#         Banana
#         Mango
That is the very basic structure of a <code>for</code> loop. 
Now let’s move on to
some of the lesser known features of <code>for</code> loops in Python.


<h2>20.1. <code>else</code> Clause</h2>
<code>for</code> loops also have an <code>else</code> clause which most of us are unfamiliar
with. 
The <code>else</code> clause executes after the loop completes normally.
This means that the loop did not encounter a <code>break</code> statement. 
They are
really useful once you understand where to use them. 
I, myself, came to
know about them a lot later.

The common construct is to run a loop and search for an item. 
If the
item is found, we break out of the loop using the <code>break</code> statement. 
There are two
scenarios in which the loop may end. 
The first one is when the item is
found and <code>break</code> is encountered. 
The second scenario is that the loop
ends without encountering a <code>break</code> statement. 
Now we may want to know which one of these is the reason for a
loop’s completion. 
One method is to set a flag and then check it once the
loop ends. 
Another is to use the <code>else</code> clause.

This is the basic structure of a <code>for/else</code> loop:

for item in container:
    if search_something(item):
     # Found it!
         process(item)
         break
else:
    # Didn&#39;t find anything..
    not_found_in_container()
Consider this simple example which I took from the official
documentation:

for n in range(2, 10):
    for x in range(2, n):
     if n % x == 0:
             print(n, &#39;equals&#39;, x, &#39;*&#39;, n/x)
                 break
It finds factors for numbers between 2 to 10. 
Now for the fun part. 
We
can add an additional <code>else</code> block which catches the numbers which have no factors and are therefore prime numbers:

for n in range(2, 10):
    for x in range(2, n):
     if n % x == 0:
             print( n, &#39;equals&#39;, x, &#39;*&#39;, n/x)
                 break
    else:
     # loop fell through without finding a factor
         print(n, &#39;is a prime number&#39;)

<h2></h2>
<h2>21. Python C extensions</h2>
An interesting feature offered to developers by the CPython
implementation is the ease of interfacing C code to Python.

There are three key methods developers use to call C functions from
their python code - <code>ctypes</code>, <code>SWIG</code> and <code>Python/C API</code>. 
Each
method comes with it’s own merits and demerits.

Firstly, why would you want to interface C with Python?

A few common reasons are :

<ul class="simple">
<li>You want speed and you know C is about 50x faster than Python.</li>
<li>Certain legacy C libraries work just as well as you want them to, so you don’t want to rewrite them in python.</li>
<li>Certain low level resource access - from memory to file interfaces.</li>
<li>Just because you want to.</li>
</ul>

<h2>21.1. CTypes</h2>
The Python <a class="reference external" href="https://docs.python.org/2/library/ctypes.html">ctypes
module</a> is probably
the easiest way to call C functions from Python. 
The ctypes module
provides C compatible data types and functions to load DLLs so that
calls can be made to C shared libraries without having to modify them.
The fact that the C side needn’t be touched adds to the simplicity of
this method.

<strong>Example</strong>

Simple C code to add two numbers, save it as <code>add.c</code>

//sample C file to add 2 numbers - int and floats

#include &lt;stdio.h&gt;

int add_int(int, int);
float add_float(float, float);

int add_int(int num1, int num2){
    return num1 + num2;
}

float add_float(float num1, float num2){
    return num1 + num2;
}
Next compile the C file to a <code>.so</code> file (DLL in windows) This will
generate an adder.so file.

#For Linux
$  gcc -shared -Wl,-soname,adder -o adder.so -fPIC add.c

#For Mac
$ gcc -shared -Wl,-install_name,adder.so -o adder.so -fPIC add.c
Now in your python code -

from ctypes import *

#load the shared object file
adder = CDLL(&#39;./adder.so&#39;)

#Find sum of integers
res_int = adder.add_int(4,5)
print &quot;Sum of 4 and 5 = &quot; + str(res_int)

#Find sum of floats
a = c_float(5.5)
b = c_float(4.1)

add_float = adder.add_float
add_float.restype = c_float
print &quot;Sum of 5.5 and 4.1 = &quot;, str(add_float(a, b))
And the output is as follows

Sum of 4 and 5 = 9
Sum of 5.5 and 4.1 =  9.60000038147
In this example the C file is self explanatory - it contains two
functions, one to add two integers and another to add two floats.

In the python file, first the ctypes module is imported. 
Then the CDLL
function of the ctypes module is used to load the shared lib file we
created. 
The functions defined in the C lib are now available to us via
the <code>adder</code> variable. 
When <code>adder.add_int()</code> is called, internally a
call is made to the <code>add_int</code> C function. 
The ctypes interface allows
us to use native python integers and strings by default while calling
the C functions.

For other types such as boolean or float, we have to use the correct
ctypes. 
This is seen while passing parameters to the
<code>adder.add_float()</code>. 
We first create the required c_float types from
python decimal values, and then use them as arguments to the C code.
This method is simple and clean, but limited. 
For example it’s not
possible to manipulate objects on the C side.


<h2>21.2. SWIG</h2>
Simplified Wrapper and Interface Generator, or SWIG for short is another
way to interface C code to Python. 
In this method, the developer must
develop an extra interface file which is an input to SWIG (the command
line utility).

Python developers generally don’t use this method, because it is in most
cases unnecessarily complex. 
This is a great method when you have a
C/C++ code base, and you want to interface it to many different
languages.

<strong>Example</strong> (from the <a class="reference external" href="http://www.swig.org/tutorial.html">SWIG website</a> )

The C code, <code>example.c</code> that has a variety of functions and variables

#include &lt;time.h&gt;
double My_variable = 3.0;

int fact(int n) {
    if (n &lt;= 1) return 1;
    else return n*fact(n-1);
}

int my_mod(int x, int y) {
    return (x%y);
}

char *get_time()
{
    time_t ltime;
    time(&amp;ltime);
    return ctime(&amp;ltime);
}
The interface file - this will remain the same irrespective of the
language you want to port your C code to :

/* example.i */
 %module example
 %{
 /* Put header files here or function declarations like below */
 extern double My_variable;
 extern int fact(int n);
 extern int my_mod(int x, int y);
 extern char *get_time();
 %}

 extern double My_variable;
 extern int fact(int n);
 extern int my_mod(int x, int y);
 extern char *get_time();
And now to compile it

unix % swig -python example.i
unix % gcc -c example.c example_wrap.c \
 -I/usr/local/include/python2.1
unix % ld -shared example.o example_wrap.o -o _example.so
Finally, the Python output

&gt;&gt;&gt; import example
&gt;&gt;&gt; example.fact(5)
120
&gt;&gt;&gt; example.my_mod(7,3)
1
&gt;&gt;&gt; example.get_time()
&#39;Sun Feb 11 23:01:07 1996&#39;
&gt;&gt;&gt;
As we can see, SWIG achieves the same result, but requires a slightly
more involved effort. 
But it’s worth it if you are targeting multiple
languages.


<h2>21.3. Python/C API</h2>
The <a class="reference external" href="https://docs.python.org/2/c-api/">C/Python API</a> is probably the
most widely used method - not for it’s simplicity but for the fact that
you can manipulate python objects in your C code.

This method requires your C code to be specifically written for
interfacing with Python code. 
All Python objects are represented as a
PyObject struct and the <code>Python.h</code> header file provides various
functions to manipulate it. 
For example if the PyObject is also a
PyListType (basically a list), then we can use the <code>PyList_Size()</code>
function on the struct to get the length of the list. 
This is equivalent
to calling <code>len(list)</code> in python. 
Most of the basic
functions/opertions that are there for native Python objects are made
available in C via the <code>Python.h</code> header.

<strong>Example</strong>

To write a C extension that adds all the elements in a python list. 
(all elements are numbers)

Let’s start with the final interface we’d like to have, here is the
python file that uses the C extension :

#Though it looks like an ordinary python import, the addList module is implemented in C
import addList

l = [1,2,3,4,5]
print &quot;Sum of List - &quot; + str(l) + &quot; = &quot; +  str(addList.add(l))
The above looks like any ordinary python file, which imports and uses
another python module called <code>addList</code>. 
The only difference is that
the addList module is not written in Python at all, but rather in C.

Next we’ll have a look at the C code that get’s built into the
<code>addList</code> Python module. 
This may seem a bit daunting at first, but
once you understand the various components that go into writing the C
file, it’s pretty straight forward.

<em>adder.c</em>

//Python.h has all the required function definitions to manipulate the Python objects
#include &lt;Python.h&gt;

 //This is the function that is called from your python code
static PyObject* addList_add(PyObject* self, PyObject* args){
PyObject * listObj;
//The input arguments come as a tuple, we parse the args to get the various variables
  //In this case it&#39;s only one list variable, which will now be referenced by listObj
  if (! PyArg_ParseTuple( args, &quot;O&quot;, &amp;listObj))
    return NULL;
    //length of the list
  long length = PyList_Size(listObj);
  //iterate over all the elements
  long i, sum =0;
  for(i = 0; i &lt; length; i++){
    //get an element out of the list - the element is also a python objects
    PyObject* temp = PyList_GetItem(listObj, i);
    //we know that object represents an integer - so convert it into C long
    long elem = PyInt_AsLong(temp);
    sum += elem;
  }
  //value returned back to python code - another python object
  //build value here converts the C long to a python integer
  return Py_BuildValue(&quot;i&quot;, sum);
}

//This is the docstring that corresponds to our &#39;add&#39; function.
static char addList_docs[] =
    &quot;add( ): add all elements of the list\n&quot;;

/* This table contains the relavent info mapping -
  &lt;function-name in python module&gt;, &lt;actual-function&gt;,
  &lt;type-of-args the function expects&gt;, &lt;docstring associated with the function&gt;
*/
static PyMethodDef addList_funcs[] = {
    {&quot;add&quot;, (PyCFunction)addList_add, METH_VARARGS, addList_docs},
    {NULL, NULL, 0, NULL}
};

/*
addList is the module name, and this is the initialization block of the module.
&lt;desired module name&gt;, &lt;the-info-table&gt;, &lt;module&#39;s-docstring&gt;
*/
PyMODINIT_FUNC initaddList(void){
    Py_InitModule3(&quot;addList&quot;, addList_funcs,
                &quot;Add all ze lists&quot;);
}
A step by step explanation :

<ul class="simple">
<li>The <code>&lt;Python.h&gt;</code> file consists of all the required types (to represent Python object types) and function definitions (to operate on the python objects).</li>
<li>Next we write the function which we plan to call from python. 
Conventionally the function names are {module-name}_{function-name}, which in this case is <code>addList_add</code>. 
More about the function later.</li>
<li>Then fill in the info table - which contains all the relevant info of the functions we desire to have in the module. 
Every row corresponds to a function, with the last one being a sentinel value (row of null elements).</li>
<li>Finally the module initialization block which is of the signature <code>PyMODINIT_FUNC init{module-name}</code>.</li>
</ul>
The function <code>addList_add</code> accepts arguments as a PyObject type struct
(args is also a tuple type - but since everything in python is an
object, we use the generic PyObject notion). 
The incoming arguments is
parsed (basically split the tuple into individual elements) by
<code>PyArg_ParseTuple()</code>. 
The first parameter is the argument variable to
be parsed. 
The second argument is a string that tells us how to parse
each element in the args tuple. 
The character in the Nth position of the
string tells us the type of the Nth element in the args tuple, example -
‘i’ would mean integer, ‘s’ would mean string and ‘O’ would mean a
Python object. 
Next multiple arguments follow, these are where you would
like the <code>PyArg_ParseTuple()</code> function to store all the elements that
it has parsed. 
The number of such arguments is equal to the number of
arguments which the module function expects to receive, and positional
integrity is maintained. 
For example if we expected a string, integer
and a python list in that order, the function signature would be

int n;
char *s;
PyObject* list;
PyArg_ParseTuple(args, &quot;siO&quot;, &amp;s, &amp;n, &amp;list);
In this case we only have to extract a list object, and store it in the
variable <code>listObj</code>. 
We then use the <code>PyList_Size()</code> function on our
list object and get the length. 
This is similar to how you would call
<code>len(list)</code> in python.

Now we loop through the list, get each element using the
<code>PyList_GetItem(list, index)</code> function. 
This returns a PyObject*. 
But
since we know that the Python objects are also <code>PyIntType</code>, we just
use the <code>PyInt_AsLong(PyObj *)</code> function to get the required value. 
We
do this for every element and finally get the sum.

The sum is converted to a python object and is returned to the Python
code with the help of <code>Py_BuildValue()</code>. 
Here the “i” indicates that
the value we want to build is a python integer object.

Now we build the C module. 
Save the following code as <code>setup.py</code>

#build the modules

from distutils.core import setup, Extension

setup(name=&#39;addList&#39;, version=&#39;1.0&#39;,  \
      ext_modules=[Extension(&#39;addList&#39;, [&#39;adder.c&#39;])])
and run

python setup.py install
This should now build and install the C file into the python module we
desire.

After all this hard work, we’ll now test if the module works -

#module that talks to the C code
import addList

l = [1,2,3,4,5]
print &quot;Sum of List - &quot; + str(l) + &quot; = &quot; +  str(addList.add(l))
And here is the output

Sum of List - [1, 2, 3, 4, 5] = 15
So as you can see, we have developed our first successful C Python
extension using the Python.h API. 
This method does seem complex at
first, but once you get used to it it can prove to be quite useful.

Other ways to interface C code to Python is to use an alternative and
faster build of python - <a class="reference external" href="http://cython.org/">Cython</a>. 
But Cython is
a slightly different language than the main stream python we see. 
Hence
that method is not covered here.


<h2></h2>
<h2>22. <code>open</code> Function</h2>
<a class="reference external" href="http://docs.python.org/dev/library/functions.html#open">open</a> opens
a file. 
Pretty simple, eh? Most of the time, we see it being used like
this:

f = open(&#39;photo.jpg&#39;, &#39;r+&#39;)
jpgdata = f.read()
f.close()
The reason I am writing this article is that most of the time, I see
open used like this. 
There are <strong>three</strong> errors in the above code. 
Can
you spot them all? If not, read on. 
By the end of this article, you’ll
know what’s wrong in the above code, and, more importantly, be able to
avoid these mistakes in your own code. 
Let’s start with the basics:

The return value from <code>open</code> is a file handle, given out from the operating system
to your Python application. 
You will want to return this file handle
once you’re finished with the file, if only so that your application
won’t reach the limit of the number of open file handles it can have at
once.

Explicitly calling <code>close</code> closes the file handle, but only if the
read was successful. 
If there is any error just after <code>f = open(...)</code>,
<code>f.close()</code> will not be called (depending on the Python interpreter,
the file handle may still be returned, but that’s another story). 
To
make sure that the file gets closed whether an exception occurs or not,
pack it into a <code>with</code> statement:

with open(&#39;photo.jpg&#39;, &#39;r+&#39;) as f:
    jpgdata = f.read()
The first argument of <code>open</code> is the filename. 
The second one (the
<em>mode</em>) determines <em>how</em> the file gets opened.

<ul class="simple">
<li>If you want to read the file, pass in <code>r</code></li>
<li>If you want to read and write the file, pass in <code>r+</code></li>
<li>If you want to overwrite the file, pass in <code>w</code></li>
<li>If you want to append to the file, pass in <code>a</code></li>
</ul>
While there are a couple of other valid mode strings, chances are you
won’t ever use them. 
The mode matters not only because it changes the
behavior, but also because it may result in permission errors. 
For
example, if we were to open a jpg-file in a write-protected directory,
<code>open(.., 'r+')</code> would fail. 
The mode can contain one further
character; we can open the file in binary (you’ll get a string of bytes)
or text mode (a string of characters).

In general, if the format is written by humans, it tends to be text
mode. 
<code>jpg</code> image files are not generally written by humans (and are
indeed not readable by humans), and you should therefore open them in
binary mode by adding a <code>b</code> to the mode string (if you’re following
the opening example, the correct mode would be <code>rb</code>). 
If you open
something in text mode (i.e. 
add a <code>t</code>, or nothing apart from
<code>r/r+/w/a</code>), you must also know which encoding to use. 
For a
computer, all files are just bytes, not characters.

Unfortunately, <code>open</code> does not allow explicit encoding specification
in Python 2.x. 
However, the function
<a class="reference external" href="http://docs.python.org/2/library/io.html#io.open">io.open</a> is
available in both Python 2.x and 3.x (where it is an alias of <code>open</code>),
and does the right thing. 
You can pass in the encoding with the
<code>encoding</code> keyword. 
If you don’t pass in any encoding, a system – and
Python – specific default will be picked. 
You may be tempted to rely on
these defaults, but the defaults are often wrong, or the default
encoding cannot actually express all characters in the file (this will happen often on
Python 2.x and/or Windows). 
So go ahead and pick an encoding. 
Encoding is the way to instruct computers about how the numbers should be stored as bytes in memory. 
<code>utf-8</code>
is a terrific one and is supported by major browsers and programming languages. 
When you write a file, you can just pick the encoding
to your liking (or the liking of the program that will eventually read
your file).

How do you find out which encoding a file you’re reading was written in? Well,
unfortunately, there is no foolproof way to detect the encoding - the
same bytes can represent different, but equally valid characters in
different encodings. 
Therefore, you must rely on metadata (for example,
in HTTP headers) to know the encoding. 
Increasingly, formats just define
the encoding to be UTF-8.

Armed with this knowledge, let’s write a program that reads a file,
determines whether it’s JPG (hint: These files start with the bytes
<code>FF D8</code>), and writes a text file that describe the input file.

import io

with open(&#39;photo.jpg&#39;, &#39;rb&#39;) as inf:
    jpgdata = inf.read()

if jpgdata.startswith(b&#39;\xff\xd8&#39;):
    text = u&#39;This is a JPEG file (%d bytes long)\n&#39;
else:
    text = u&#39;This is a random file (%d bytes long)\n&#39;

with io.open(&#39;summary.txt&#39;, &#39;w&#39;, encoding=&#39;utf-8&#39;) as outf:
    outf.write(text % len(jpgdata))
I am sure that now you will use <code>open</code> correctly!


<h2></h2>
<h2>23. Targeting Python 2+3</h2>
In a lot of cases you might want to develop programs which can be run in
both Python 2+ and 3+.

Just imagine that you have a very popular Python module which is used by
hundreds of people but not all of them have Python 2 or 3. 
In that case
you have two choices. 
The first one is to distribute 2 modules, one for
Python 2 and the other for Python 3. 
The other choice is to modify your
current code and make it compatible with both Python 2 and 3.

In this section I am going to highlight some of the tricks which you can
employ to make a script compatible with both of them.

<strong>Future imports</strong>

The first and most important method is to use <code>__future__</code> imports. 
It
allows you to import Python 3 functionality in Python 2. 
Here are a couple
examples:

Context managers were new in Python 2.6+. 
For using them in Python 2.5 you can use:

from __future__ import with_statement
<code>print</code> was changed to a function in Python 3. 
If you want to use it
in Python 2 you can import it from <code>__future__</code>:

print
# Output:

from __future__ import print_function
print(print)
# Output: &lt;built-in function print&gt;
<strong>Dealing with module renaming</strong>

First, tell me how you import packages in your script ? Most of us do
this :

import foo
# or
from foo import bar
Do you know that you can do something like this as well?

import foo as foo
I know its function is the same as the above listed code but it is vital
for making your script compatible with Python 2 and 3. 
Now examine the
code below :

try:
    import urllib.request as urllib_request  # for Python 3
except ImportError:
    import urllib2 as urllib_request  # for Python 2
So let me explain the above code a little. 
We are wrapping our importing
code in a <code>try/except</code> clause. 
We are doing it because in Python 2 there is
no <code>urllib.request</code> module so this would result in an <code>ImportError</code>. 
The
functionality of <code>urllib.request</code> is provided by the <code>urllib2</code> module in
Python 2. 
So, when using Python 2, we try to import <code>urllib.request</code> and
if we get an <code>ImportError</code> then we tell Python to import <code>urllib2</code> instead.

The final thing you need to know about is the <code>as</code> keyword. 
It is
mapping the imported module to <code>urllib_request</code>. 
So that all of
the classes and methods within <code>urllib2</code> are available to us via the alias
<code>urllib_request</code>.

<strong>Obsolete Python 2 builtins</strong>

Another thing to keep in mind is that there are 12 Python 2 builtins
which have been removed from Python 3. 
Make sure that you don’t use them
in Python 2 in order to make your code compatible with Python 3.
Here is a way to enforce that you abandon these 12 builtins in Python 2 as
well:

from future.builtins.disabled import *
Now whenever you try to use the modules which are abandoned in Python 3,
it raises a <code>NameError</code> like this:

from future.builtins.disabled import *

apply()
# Output: NameError: obsolete Python 2 builtin apply is disabled
<strong>External standard-library backports</strong>

There are a few packages in the wild which provide Python 3
functionality in Python 2. 
For instance, we have:

<ul class="simple">
<li>enum <code>pip install enum34</code></li>
<li>singledispatch <code>pip install singledispatch</code></li>
<li>pathlib <code>pip install pathlib</code></li>
</ul>
For further reading, the Python documentation has a <a class="reference external" href="https://docs.python.org/3/howto/pyporting.html">comprehensive guide</a> of steps you need to
take to make your code compatible with both Python 2 and 3.


<h2></h2>
<h2>24. Coroutines</h2>
Coroutines are similar to generators with a few differences. 
The main
differences are:

<ul class="simple">
<li>generators are data producers</li>
<li>coroutines are data consumers</li>
</ul>
First of all let’s review the generator creation process. 
We can make
generators like this:

def fib():
    a, b = 0, 1
    while True:
     yield a
         a, b = b, a+b
We then commonly use it in a <code>for</code> loop like this:

for i in fib():
    print(i)
It is fast and does not put a lot of pressure on memory because it
<strong>generates</strong> the values on the fly rather than storing them in a list.
Now, if we use <code>yield</code> in the above example, more generally, we get a
coroutine. 
Coroutines consume values which are sent to it. 
A very basic
example would be a <code>grep</code> alternative in Python:

def grep(pattern):
    print(&quot;Searching for&quot;, pattern)
    while True:
     line = (yield)
         if pattern in line:
             print(line)
Wait! What does <code>yield</code> return? Well we have turned it into a
coroutine. 
It does not contain any value initially, instead we supply it
values externally. 
We supply values by using the <code>.send()</code> method.
Here is an example:

search = grep(&#39;coroutine&#39;)
next(search)
# Output: Searching for coroutine
search.send(&quot;I love you&quot;)
search.send(&quot;Don&#39;t you love me?&quot;)
search.send(&quot;I love coroutines instead!&quot;)
# Output: I love coroutines instead!
The sent values are accessed by <code>yield</code>. 
Why did we run <code>next()</code>? It is
required in order to start the coroutine. 
Just like <code>generators</code>, coroutines do not
start the function immediately. 
Instead they run it in response to the
<code>__next__()</code> and <code>.send()</code> methods. 
Therefore, you have to run
<code>next()</code> so that the execution advances to the <code>yield</code> expression.

We can close a coroutine by calling the <code>.close()</code> method:

search = grep(&#39;coroutine&#39;)
# ...
search.close()
There is a lot more to <code>coroutines</code>. 
I suggest you check out <a class="reference external" href="http://www.dabeaz.com/coroutines/Coroutines.pdf">this
awesome
presentation</a> by
David Beazley.


<h2></h2>
<h2>25. Function caching</h2>
Function caching allows us to cache the return values of a function
depending on the arguments. 
It can save time when an I/O bound function
is periodically called with the same arguments. 
Before Python 3.2 we had
to write a custom implementation. 
In Python 3.2+ there is an
<code>lru_cache</code> decorator which allows us to quickly cache and uncache the
return values of a function.

Let’s see how we can use it in Python 3.2+ and the versions before it.


<h2>25.1. Python 3.2+</h2>
Let’s implement a Fibonacci calculator and use <code>lru_cache</code>.

from functools import lru_cache

@lru_cache(maxsize=32)
def fib(n):
    if n &lt; 2:
     return n
    return fib(n-1) + fib(n-2)

&gt;&gt;&gt; print([fib(n) for n in range(10)])
# Output: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
The <code>maxsize</code> argument tells <code>lru_cache</code> about how many recent
return values to cache.

We can easily uncache the return values as well by using:

fib.cache_clear()

<h2>25.2. Python 2+</h2>
There are a couple of ways to achieve the same effect. 
You can create
any type of caching mechanism. 
It entirely depends upon your needs. 
Here
is a generic cache:

from functools import wraps

def memoize(function):
    memo = {}
    @wraps(function)
    def wrapper(*args):
     if args in memo:
             return memo[args]
             else:
             rv = function(*args)
                 memo[args] = rv
                 return rv
    return wrapper

@memoize
def fibonacci(n):
    if n &lt; 2: return n
    return fibonacci(n - 1) + fibonacci(n - 2)

fibonacci(25)
<strong>Note:</strong> memoize won’t cache unhashable types (dict, lists, etc…) but only the immutable types. 
Keep that in mind when using it.

<a class="reference external" href="https://www.caktusgroup.com/blog/2015/06/08/testing-client-side-applications-django-post-mortem/">Here</a>
is a fine article by Caktus Group in which they caught a bug in Django
which occurred due to <code>lru_cache</code>. 
It’s an interesting read. 
Do check it out.


<h2></h2>
<h2>26. Context Managers</h2>
Context managers allow you to allocate and release resources precisely
when you want to. 
The most widely used example of context managers is
the <code>with</code> statement. 
Suppose you have two related operations which
you’d like to execute as a pair, with a block of code in between.
Context managers allow you to do specifically that. 
For example:

with open(&#39;some_file&#39;, &#39;w&#39;) as opened_file:
    opened_file.write(&#39;Hola!&#39;)
The above code opens the file, writes some data to it and then closes
it. 
If an error occurs while writing the data to the file, it tries to
close it. 
The above code is equivalent to:

file = open(&#39;some_file&#39;, &#39;w&#39;)
try:
    file.write(&#39;Hola!&#39;)
finally:
    file.close()
While comparing it to the first example we can see that a lot of
boilerplate code is eliminated just by using <code>with</code>. 
The main
advantage of using a <code>with</code> statement is that it makes sure our file
is closed without paying attention to how the nested block exits.

A common use case of context managers is locking and unlocking resources
and closing opened files (as I have already shown you).

Let’s see how we can implement our own Context Manager. 
This should allow
us to understand exactly what’s going on behind the scenes.


<h2>26.1. Implementing a Context Manager as a Class:</h2>
At the very least a context manager has an <code>__enter__</code> and
<code>__exit__</code> method defined. 
Let’s make our own file-opening Context
Manager and learn the basics.

class File(object):
    def __init__(self, file_name, method):
     self.file_obj = open(file_name, method)
    def __enter__(self):
     return self.file_obj
    def __exit__(self, type, value, traceback):
     self.file_obj.close()
Just by defining <code>__enter__</code> and <code>__exit__</code> methods we can use our new class in
a <code>with</code> statement. 
Let’s try:

with File(&#39;demo.txt&#39;, &#39;w&#39;) as opened_file:
    opened_file.write(&#39;Hola!&#39;)
Our <code>__exit__</code> method accepts three arguments. 
They are required by
every <code>__exit__</code> method which is a part of a Context Manager class.
Let’s talk about what happens under-the-hood.

<ol class="arabic simple">
<li>The <code>with</code> statement stores the <code>__exit__</code> method of the <code>File</code>
class.</li>
<li>It calls the <code>__enter__</code> method of the <code>File</code> class.</li>
<li>The <code>__enter__</code> method opens the file and returns it.</li>
<li>The opened file handle is passed to <code>opened_file</code>.</li>
<li>We write to the file using <code>.write()</code>.</li>
<li>The <code>with</code> statement calls the stored <code>__exit__</code> method.</li>
<li>The <code>__exit__</code> method closes the file.</li>
</ol>

<h2>26.2. Handling Exceptions</h2>
We did not talk about the <code>type</code>, <code>value</code> and <code>traceback</code>
arguments of the <code>__exit__</code> method. 
Between the 4th and 6th step, if
an exception occurs, Python passes the type, value and traceback of the
exception to the <code>__exit__</code> method. 
It allows the <code>__exit__</code> method
to decide how to close the file and if any further steps are required.
In our case we are not paying any attention to them.

What if our file object raises an exception? We might be trying to
access a method on the file object which it does not supports. 
For
instance:

with File(&#39;demo.txt&#39;, &#39;w&#39;) as opened_file:
    opened_file.undefined_function(&#39;Hola!&#39;)
Let’s list the steps which are taken by the <code>with</code> statement when
an error is encountered:

<ol class="arabic simple">
<li>It passes the type, value and traceback of the error to the
<code>__exit__</code> method.</li>
<li>It allows the <code>__exit__</code> method to handle the exception.</li>
<li>If <code>__exit__</code> returns <code>True</code> then the exception was gracefully
handled.</li>
<li>If anything other than <code>True</code> is returned by the <code>__exit__</code> method then
the exception is raised by the <code>with</code> statement.</li>
</ol>
In our case the <code>__exit__</code> method returns <code>None</code> (when no return
statement is encountered then the method returns <code>None</code>). 
Therefore,
the <code>with</code> statement raises the exception:

Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 2, in &lt;module&gt;
AttributeError: &#39;file&#39; object has no attribute &#39;undefined_function&#39;
Let’s try handling the exception in the <code>__exit__</code> method:

class File(object):
    def __init__(self, file_name, method):
     self.file_obj = open(file_name, method)
    def __enter__(self):
     return self.file_obj
    def __exit__(self, type, value, traceback):
     print(&quot;Exception has been handled&quot;)
         self.file_obj.close()
         return True

with File(&#39;demo.txt&#39;, &#39;w&#39;) as opened_file:
    opened_file.undefined_function()

# Output: Exception has been handled
Our <code>__exit__</code> method returned <code>True</code>, therefore no exception was raised
by the <code>with</code> statement.

This is not the only way to implement Context Managers. 
There is another
way and we will be looking at it in the next section.


<h2>26.3. Implementing a Context Manager as a Generator</h2>
We can also implement Context Managers using decorators and generators.
Python has a contextlib module for this very purpose. 
Instead of a
class, we can implement a Context Manager using a generator function.
Let’s see a basic, useless example:

from contextlib import contextmanager

@contextmanager
def open_file(name):
    f = open(name, &#39;w&#39;)
    yield f
    f.close()
Okay! This way of implementing Context Managers appear to be more
intuitive and easy. 
However, this method requires some knowledge about
generators, yield and decorators. 
In this example we have not caught any
exceptions which might occur. 
It works in mostly the same way as the
previous method.

Let’s dissect this method a little.

<ol class="arabic simple">
<li>Python encounters the <code>yield</code> keyword. 
Due to this it creates a
generator instead of a normal function.</li>
<li>Due to the decoration, contextmanager is called with the function
name (<code>open\_file</code>) as it’s argument.</li>
<li>The <code>contextmanager</code> decorator returns the generator wrapped by the
<code>GeneratorContextManager</code> object.</li>
<li>The <code>GeneratorContextManager</code> is assigned to the <code>open_file</code>
function. 
Therefore, when we later call the <code>open_file</code> function, we
are actually calling the <code>GeneratorContextManager</code> object.</li>
</ol>
So now that we know all this, we can use the newly generated Context
Manager like this:

with open_file(&#39;some_file&#39;) as f:
    f.write(&#39;hola!&#39;)
<br>
<br>
<br>
<br>
</pre>
<script type='text/javascript' src='readbook.js'></script>
</body>
</html>
