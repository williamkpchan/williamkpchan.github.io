<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width"/>
<link rel="stylesheet" href="..\maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script>
$(document).ready(function(){
    $('h1, h2, h3, h4, h5, .goldword, .apply, div.title').click(function(){
    parent.history.back();
    return false;
    });
});
</script>
<style>
body{width:80%;margin-left: 10%;}
h1, h2 {color: gold;}
</style>
</head><body>
<center><h1>All about JavaScript functions</h1>
<div id="toc"></div></center>
<br>
<br>
<br>


<p>Everything you ever needed to know about JavaScript functions.</p>
<figure>
<img src="https://cdn-images-1.medium.com/max/1000/1*bspCAmmkd_vyf9mg5TB_aQ.png" crossorigin="anonymous">
<figcaption>Recursion</figcaption></figure>
<p>This story is part of a larger open source curriculum</p>
<p>
<a href="https://codeburst.io/mastering-front-end-engineering-in-12-to-20-weeks-for-beginners-and-experienced-alike-6dc5172e3295" data-href="https://codeburst.io/mastering-front-end-engineering-in-12-to-20-weeks-for-beginners-and-experienced-alike-6dc5172e3295">Mastering front end engineering in 12 to 20 weeks for beginners and experienced alike.</a></p>
<p>Let’s begin at the beginning.</p>
<p>What is a function ?</p>
<p>Function, generally speaking is a “subprogram” that can be called by code externally or internally (in case of recursion) to the function.</p>
<p>It is composed of a series of statements called function body. Values can be passed to a function and the function can/will return a value.</p>
<blockquote>Now, with modern applications, functions can be a complete program in itself, rather than the general notion of a “subprogram”.</blockquote>
<p>The laymay differentiation between a function and a procedure is that the functions ideally should return a value and the procedure doesn’t (now this may vary according to the programming language under consideration).</p>
<p>As with everything lets write a ‘function’ that prints hello to console.</p>
<h4>Function that does not take a parameter and doesn’t return anything.</h4>
<pre>function sayHello () {
<br>  console.log(&quot;Hello !&quot;);
<br>}</pre>
<p>The above function does not take a parameter and doesn’t return a value;</p>
<p>The above function can be called/invoked as follows:</p>
<pre>sayHello();</pre>
<p>Now, you may prefer to use a semicolon or choose to omit it (as we will not get into the war of whether to use semicolon or not to terminate a javascript statement.)</p>
<p>The output of the above code will following in the console.</p>
<figure>
<img src="https://cdn-images-1.medium.com/max/1000/1*5NjMo3GmdcqbbyfYy2MC5w.png" crossorigin="anonymous">
</figure>
<p>If you are using es6/es2015 then the same function can be written as an arrow function.</p>
<pre>const sayHello = () =&gt; {
<br>  console.log(&quot;Hello !&quot;);
<br>}</pre>
<p>The arrow function is a concise way to write a function. It can be invoked exactly as before.</p>
<pre>sayHello();</pre>
<p>An arrow function expression has a shorter syntax than a function expression and does not have its own this, arguments, super, or new.target (more about this later).</p>
<p>These function expressions are best suited for non-method 
<br>functions, and they cannot be used as constructors.</p>
<p>What do I mean when I say, the above function doesn’t return anything?.</p>
<p>If I try to store the result of calling the function in a variable, it will be undefined.</p>
<p>For e.g.</p>
<pre>let message = sayHello();</pre>
<pre>// The below console.log will return undefined as the function 
<br>// doesn&#39;t return any value.</pre>
<pre>console.log (message);</pre>
<h4>Function that does take a parameter but doesn’t return anything.</h4>
<p>Let’s write a function that take one parameter but doesn’t return anything.</p>
<pre>function log (message) {
<br>  console.log (message);
<br>}</pre>
<p>The above function takes one parameter, named message, and logs the value to the console, and ends.</p>
<p>You can invoke the above function as shown below.</p>
<pre>// The below call to log() function, logs the output to the 
<br>// and returns undefined.
<br>log (&quot;Hello JavaScript!&quot;);</pre>
<blockquote>NOTE: If the function doesn’t return any value explicitly, then by default it returns “undefined”</blockquote>
<h4>Function that takes a parameter and returns a value.</h4>
<p>Let’s write a function that takes a number as a parameter and returns the square of the number.</p>
<pre>function square(number) {
<br> return number * number;
<br>}</pre>
<p>console.log(square(2));</p>
<p>The output of the above function execution is shown below.</p>
<figure>
<img src="https://cdn-images-1.medium.com/max/1000/1*AlcanrK9hNxIYhom_nLoLA.png" crossorigin="anonymous">
</figure>
<h4>Functions are first class objects</h4>
<p>Functions are first class objects and they can be assigned to a variable and also be passed as a parameter. We will see an example of this.</p>
<p>But let’s see how to assign the above function into a variable and use it.</p>
<pre>// You can also, use var or let.  I am using const indicating 
<br>// that this function cannot be reassigned once declared.</pre>
<pre>const square = function (number) {
<br>  return number * number;
<br>}</pre>
<pre>console.log(square(2));</pre>
<p>Let’s write the above function as an arrow function.</p>
<pre>const square = (number) =&gt; {
<br>  return number * number;
<br>}</pre>
<pre>console.log(square(2)); // Outputs: 4</pre>
<h4>Function can take more than one arguments(in fact, it can take ’n’ parameter)</h4>
<p>There is no theoretical maximum number of arguments/parameters in the spec but there are practical limits.</p>
<p>Refer the below stack overflow for some more info.</p>
<p>
<a href="https://stackoverflow.com/questions/22747068/is-there-a-max-number-of-arguments-javascript-functions-can-accept" data-href="https://stackoverflow.com/questions/22747068/is-there-a-max-number-of-arguments-javascript-functions-can-accept">Stackoverflow: javascript functions, maximum no. of arguments</a></p>
<h4>How to write a function that can take ’n’ arguments?</h4>
<p>Let’s write an sum() than can take ’n’ arguments and returns the sum of the arguments.</p>
<pre>// Old way
<br>const sum = function () {
<br>  let result = 0;
<br>  for(let i = 0; i &lt; arguments.length; i++) {
<br>    result += arguments[i];
<br>  }
<br>  return result;
<br>}</pre>
<p>We can invoke the above functions as shown below.</p>
<pre>console.log(sum(1,2));
<br>console.log(sum(1,2,3,4));
<br>console.log(sum(1,3,5,7,9));</pre>
<h4>How does it work?</h4>
<p>If you look at the sum function, it is not taking any parameter explicitly. Now imagine you are implementing this sum() function explicitly, how difficult it would be to define all the parameters upfront. You don’t know, with how many parameters the sum() function will be invoked.</p>
<p>It can be invoked with 1 parameter as sum(1) which returns 1.
<br>It can be invoked with 2 parameters as sum(1,2) which returns 3.
<br>It can be invoked with 100 parameters as sum(1,2,3,4,5,6………..,100) which returns 5050.</p>
<p>So, JavaScript provides us with this secret “arguments” object, that contains all the parameters and can be used within any functions.</p>
<p>Now note, the arguments object is not an array but an array like object. that means you cannot invoke any array methods on the arguments object (More on this later. If you are too curious, do some research on this).</p>
<p>The working of the above sum() is pictorically shown below.</p>
<figure>
<img src="https://cdn-images-1.medium.com/max/1000/1*_Hp7nKeFtv54fFIaI_mrJA.png" crossorigin="anonymous">
</figure>
<p>When I say that the “arguments” is an array like object, lets see this in a picture with one invocation of the sum function. Observe the console.log of arguments. What do you see?</p>
<figure>
<img src="https://cdn-images-1.medium.com/max/1000/1*XXwIn643Dah6l0j7kiq6aQ.png" crossorigin="anonymous">
</figure>
<p>In the above picture its very clear that the “arguments” is an object with the keys representing the index and the values, the actual parameter.</p>
<p>This object is like any other object. For e.g.</p>
<pre>{
<br>   name:  &quot;Rajesh&quot;,
<br>   hobbies: [&quot;writing&quot;,&quot;programming&quot;]
<br>}</pre>
<pre>except the keys in the &#39;arguments&#39; object looks like array index as
<br>{
<br>   0:  &quot;rajesh&quot;,
<br>   1:  [&quot;writing&quot;,&quot;programming&quot;]
<br>}</pre>
<pre>Both of the above are object representation.</pre>
<blockquote>NOTE: In modern JavaScript era using “arguments” object is not recommended. We can use a new concept called rest parameters.</blockquote>
<p>Let’s see how to achieve the above result without using arguments object, but with REST parameters.</p>
<pre>// New way using REST parameter
<br>const sum = function (...args) {
<br>  let result = 0;
<br>  for(let i = 0; i &lt; args.length; i++) {
<br>    result += args[i];
<br>  }
<br>  return result;
<br>}</pre>
<p>Everything is same in the function except the magical “arguments” is replaced with the explicit REST parameter (…args). Now you can call it anything, here, as a convention, I choose to call it as “args”.</p>
<h4>What does 
<code>...args does?</code></h4>
<p>The …args takes every parameter passed to the function and make it available as an actual array object. Remember I mentioned earlier that the “arguments” object is an array like object and not an actual array, but the …args here is an actual array.</p>
<p>Let’s take one example of invoking the sum function again and also put a console.log statement in the sum function as shown below. This time we will use the 
<code>reduce</code> method of the array. As I mentioned earlier that …args is a real array we can use any method on it.</p>
<pre>const sum = function (...args) {
<br>  console.log(args);
<br>  let result = 0;
<br>  result = args.reduce((current, prev) =&gt; {
<br>    return current + prev;
<br>  });
<br>  return result;
<br>}</pre>
<pre>sum(1,2,3,4,5);</pre>
<p>The output of invoking the sum function along with the console.log(args) is shown below, as they say “A picture is worth a 1000 words”.</p>
<figure>
<img src="https://cdn-images-1.medium.com/max/1000/1*bZ2JVSjNfi9L2Z9XRXwBcw.png" crossorigin="anonymous">
</figure>
<p>In the above log you can easily visualize the 
<code>…args</code> is an array. And since it is an array we can use the reduce method of the array to compute the sum.</p>
<p>NOTE: Explore the web, or watch out for my other article on understanding ‘reduce’ function.</p>
<blockquote>…args can also be partially used. Lets take an example to complete this part.</blockquote>
<figure>
<img src="https://cdn-images-1.medium.com/max/1000/1*U7ZJbc_2yJaAKhVZ2VEnRg.png" crossorigin="anonymous">
</figure>
<p>Now if we invoke the sum function with three parameter(note: we are not doing actual summation) sum(1,2,3), and the output we get is,</p>
<figure>
<div>
<div></div>
<img></div></figure>
<h4>Function taking ‘function’ as a parameter</h4>
<p>As we mentioned earlier in this article that a function is a first class object and hence it can also be passed as a parameter/argument to a function.</p>
<p>Let us write a function that takes a function as a parameter.</p>
<pre>function dispatch (fn) {
<br>  fn();
<br>}</pre>
<p>In the above code we define a function named ‘dispatch’ which takes a function as a argument. Note the name ‘fn’ is just a convention, you can use any name. The other common name is ‘
<strong>callback</strong>’ but used in a different context.</p>
<blockquote>NOTE: We will use the term ‘callback’ when we are referring to functions that take function as a parameter.</blockquote>
<p>Now, how to use the above function?</p>
<p>Let’s call/invoke the above function as shown below. You can use the normal function syntax or arrow function, whichever you prefer. I will use the arrow function notation.</p>
<pre>METHOD 1: Defining function as a variable and passing it.
<br>var fn = () =&gt; { console.log( &quot;Hello !&quot;); }
<br>// Invoke the dispatch () function
<br>dispatch(fn);  // Outputs &quot;Hello !&quot;</pre>
<pre>METHOD 2:  Defining an normal anonymous function inline.
<br>dispatch (function () {
<br>  console.log(&quot;Hello !&quot;);
<br>});</pre>
<pre>METHOD 3:  Defining an arrow function inline
<br>dispatch (() =&gt; { console.log (&quot;Hello !&quot;) });</pre>
<p>NOTE: All the above 3 methods of dispatching is same.</p>
<p>The ‘callback’ function can also take parameter and return value. Let’s see one more example of this.</p>
<pre>function dispatch(fn) {    // Takes &#39;function&#39; as an argument
<br>  return fn(&quot;hello&quot;);   // You can send some parameters.
<br>}</pre>
<p>The above dispatch function takes a function as an argument and returns the return value from the passed in function. It invokes the passed in function with an argument as well.</p>
<p>How to invoke this function?</p>
<pre>let result = dispatch(function (p1) {
<br>  return `My message and ${p1}`;
<br>});</pre>
<p>Ponder over this for a moment.</p>
<h4>Practical applications of callback functions</h4>
<p>Let’s say we have to execute some method after 1 second and not immediately. Here’ we can use the setTimeout function.</p>
<pre>setTimeout(function () {
<br>  console.log(&#39;Check the status of some server...&#39;);
<br>}, 1000);</pre>
<p>The above method will wait for minimum 1 second before executed. Please note, that the time passed to setTimeout and setInterval is in millisecond and indicates the minimum time (but the minimum time is not guraranted. More on that on a separate article).</p>
<p>What if you need to execute some operations after every 5 second. This is where setInterval comes into play.</p>
<pre>// Here I am using the arrow function notation.
<br>setInterval(()=&gt; {
<br>   console.log(&quot;This will be executed every 5 second&quot;);
<br>}, 5000);</pre>
<p>Within these functions you can write any code, may be make some ajax calls etc.</p>
<blockquote>NOTE: I am mixing arrow function notation and normal functions just so that by the time readers finishes this article they are comfortable with both approach.</blockquote>
<p>You will find callback method in real life in ajax calls, configuring routes for applications etc. May be I will write a separate article on that.</p>
<h4>Function can call itself (aka recursion)</h4>
<p>Recursion is an interesting concept where a function calls itself. Now if you don’t handle the terminal condition, the function can run infinitely and finally the browser may vomit a stack overflow exception like ‘Maximum call stack size exceeded’.</p>
<p>Let us see what recursion looks like and a useful application of recursion.</p>
<pre>function runForEver() {
<br>    runForEver();
<br>}</pre>
<pre>// You can invoke the above function by running
<br>runForEver();   // If you try you will get the call stack error</pre>
<p>The above function is a simple representation of recursive function call. As the name suggest, this function will run forever, until the above error is thrown by the browser.</p>
<p>Ok, thats a pretty useless function.</p>
<p>Let’s now write a little useful function for printing a countdown from a start value.</p>
<pre>function countDown(n) {
<br>  console.log (n);
<br>  if (n &gt;= 1) {  // Exit or terminal condition
<br>    countDown(n-1);
<br>  }
<br>}</pre>
<p>You can invoke/run the above function by the code below.</p>
<pre>countDown(5);  // -&gt; The output will be 5, 4, 3, 2, 1</pre>
<p>How does this recursive function works?</p>
<figure>
<img src="https://cdn-images-1.medium.com/max/1000/1*bspCAmmkd_vyf9mg5TB_aQ.png" crossorigin="anonymous">
</figure>
<p>From the above diagram it is very clear how the recursive calls creates a stack and in case we forgot to put the terminal condition then the stack will grow infinitely and finally you will be presented with the “Maximum call stack size exceeded” error.</p>
<p>Let us build a more practical example. Assume you have the below data structure.</p>
<pre>let data = [
<br>  {
<br>    title: &quot;menu 1&quot;,
<br>    children :[
<br>      { title: &quot;menu 1.1&quot;},
<br>      { 
<br>        title: &quot;menu 1.2&quot;,
<br>        children: [
<br>          {title: &quot;menu 1.2.1&quot;},
<br>          {title: &quot;menu 1.2.2&quot;},          
<br>        ]
<br>      },
<br>    ]
<br>  },
<br>  {
<br>    title: &quot;menu 2&quot;,
<br>    children :[
<br>      { title: &quot;menu 2.1&quot;},
<br>      { title: &quot;menu 2.2&quot;},
<br>    ]
<br>  } 
<br>]</pre>
<p>Above, we have a hierarchical structure, that may be representing a menu or anything you wish.</p>
<p>We want to take this as an input and to create an unordered list with the correct hierarchy.</p>
<p>For eg. the final output should be as shown below.</p>
<figure>
<img src="https://cdn-images-1.medium.com/max/1000/1*CB-_Y0hgCZ4qKIN87F34BQ.png" crossorigin="anonymous">
<figcaption>Left image is the output from the function and right image is the rendering of the left.</figcaption></figure>
<p>Let’s code our recursive function that transforms the data into the abvoe &lt;ul&gt; pairs.</p>
<p>First, lets see how we intend using the function.</p>
<pre>let uls = buildTree(data);</pre>
<pre>// Output data to console
<br>console.log(uls);</pre>
<pre>// Render on the window
<br>// Only for demo. In real case append it to any parent element
<br>// instead of using document.write</pre>
<pre>document.write(uls);  
<br>
<br></pre>
<p>Let us now implement the buildTree function.</p>
<pre>// Accepts two arguments
<br>// data-&gt; the data to transform
<br>// isChild -&gt; default false, used to indicate whether the node
<br>//            being rendered is a child element or not</pre>
<pre>function buildTree(data, isChild = false) {
<br>  let html = &#39;&lt;ul&gt;&#39;;   // Let&#39;s initial html variable 
<br>  // Run the forloop over the data
<br>  data.forEach((d) =&gt; {
<br>    // For every data element render an &lt;li&gt;
<br>    html += `&lt;li&gt;${d.title}&lt;/li&gt;`;
<br>    // If the current data element has children then call the 
<br>    // buildTree again passing in the children and isChild = true
<br>    if (d.children) {
<br>      html += buildTree(d.children, true);
<br>    }
<br>  });
<br>  // Build the closing &lt;ul&gt; tag
<br>  html += &#39;&lt;/ul&gt;&#39;;
<br>  return html;  // Return the html
<br>}</pre>
<p>I have put the required code comments for your kind perusal. In case anyone has any queries/or need clarification on the above code, please feel free to leave a message and I will reply back.</p>
<h4>Immediately Invoked Function Expression aka IIFE</h4>
<p>Let us now understand what an IIFE is and what problem does it solves. Before that let’s see what an anonymous function is.</p>
<p>An anonymous function is a function without a name. For e.g.</p>
<pre>function () {
<br>  let message = &quot;I don&#39;t have a name&quot;;
<br>  console.log(message);
<br>}</pre>
<p>If the function doesn’t have a name, then how will you invoke it?</p>
<p>The answer is you can’t, unless it is part of a callback function parameter.</p>
<p>Now, let’s see how to execute the above anonymous function.</p>
<pre>(function () {
<br>   let message = &quot;I don&#39;t have a name&quot;;
<br>   console.log(message);
<br>})();</pre>
<p>Wrap the function within a parenthesis (this makes it an expression) and invoke it using a pair of opening and closing parenthesis ().</p>
<blockquote>The beauty of IIFE is that it can only be invoked once.</blockquote>
<h4>Where can IIFE be used?</h4>
<p>It can be used in scenarios where you need to run the function only once, like fetching some initial data, setting some configuration values, checking system status on startup etc.</p>
<h4>Technical Notes for the Nerdy among you</h4>
<p>All functions are objects but not all objects are functions. What distinguishes function from other objects is that functions can be called. In brief, they are `Function` objects.</p>
<h4>Objects and Functions (call, apply and bind)</h4>
<p>Let’s have a look at how objects and functions can co-exist. Every function has access to three methods</p>
<ul>
<li>call</li>
<li>apply</li>
<li>bind</li></ul>
<p>Let us see the usage of the above with an example. Let’s take the following object to work with.</p>
<pre>let user = {
<br>  userName: &quot;codingmonk&quot;,
<br>  displayName: &quot;rajesh&quot;,
<br>  sendMessage: function (message) {
<br>    console.log(`Sending ${message} to ${this.displayName}`);
<br>  }
<br>}</pre>
<pre>let student = {
<br>  displayName: &quot;rohan&quot;
<br>}</pre>
<p>The above code creates two variables for representing user and student object. The astute reader might notice that the user object has some additional properties and method whereas the student object has only one property, and that matches with the user object.</p>
<p>Let us see how to send message to user. It’s very easy as dropping in the code below.</p>
<pre>user.sendMessage(&quot;Hello...&quot;);</pre>
<p>And the message “Hello…” will be logged to console.</p>
<p>Please note within the function sendMessage() the ‘this’ refers to the object on which the function was invoked, in this case the 
<code>user</code> object.</p>
<p>Now, how can you call the sendMessage() on the student object (a weird scenario but sometimes useful in many practical cases).</p>
<p>This is where call, apply and bind comes into action.</p>
<h4>Using call() method to invoke method on another object</h4>
<pre>user.sendMessage.call(student, “Hello from Rajesh”);</pre>
<p>The first parameter to call method is the new context, in this case, student, and the subsequent parameters are the arguments for the sendMessage, in this case the text ‘Hello from Rajesh’;</p>
<p>This will print the output ‘Hello from Rajesh to rohan’. Within sendMessage, the 
<code>this</code> will now point to the 
<code>student</code> object rather than the 
<code>user</code>object.</p>
<h4>Using apply() method to invoke method on another object</h4>
<pre>user.sendMessage.apply(student, [“Hello from Rajesh agin..”]);</pre>
<p>The first parameter to apply method is the new context, in this case, student, and the subsequent parameters are the arguments for the sendMessage, in this case the text ‘Hello from Rajesh’;</p>
<blockquote>In apply() method the arguments are passed as an array. This is the only difference between call() and apply()</blockquote>
<p>This will print the output ‘Hello from Rajesh again.. to rohan’. Within sendMessage, the 
<code>this</code> will now point to the 
<code>student</code> object rather than the 
<code>user</code>object.</p>
<h4>Using bind() method</h4>
<p>The bind method returns a new method with the new context. For e.g. lets create a new variable that will point to the sendMessage() but with the new context.</p>
<pre>let sendMessageToStudent = user.sendMessage.bind(student);</pre>
<p>The above line creates a new variable 
<code>sendMessageToStudent</code> which is actually a function which you can invoke. But the 
<code>this</code> context will point to 
<code>student</code> object rather than 
<code>user</code> object.</p>
<p>You can invoke the function as shown below.</p>
<pre>sendMessageToStudent(&quot;Yet another message&quot;);</pre>
<p>This will output the text ‘Sending Yet another message.. to rohan”.</p>
<p>I hope this makes the concepts of call, apply and bind very clear.</p>
<h4>Constructor Function</h4>
<p>A constructor function in JavaScript starts with an Uppercase letter by convention. It is a mechanism via which we can simulate object oriented programming using JavaScript.</p>
<p>A Constructor function is invoked by the 
<code>new</code> keyword. You can pass parameters to constructor function just like any other function and it can also return object.</p>
<blockquote>NOTE: If you return a simple value like 
<code>string</code> or 
<code>number</code> or 
<code>boolean</code> from a constructor function, it will be ignored and the instance of itself will be return.</blockquote>
<p>Let’s create a constructor function representing a 
<code>User</code> object.</p>
<pre>function User (name, email) {
<br>  this.name = name;   // instance variables
<br>  this.email = email;
<br>  
<br>  // You can define methods here, but is not recommended 
<br>  // from performance perspective.
<br>  // See the prototype method below
<br>  this.save = function () {
<br>    // Do whatever you want
<br>    this.id = +new Date(); 
<br>    //console.log(`${this.name} saved to DB successfully!`);
<br>    return this.id;
<br>  }
<br>}</pre>
<pre>// PROTOTYPE: Recommended way to create instance methods
<br>User.prototype.saveDB = function () {
<br>  this.id = +new Date();
<br>  //console.log(`${this.name} saved to DB successfully!`);
<br>  return this.id;
<br>}</pre>
<p>So, the above constructor function represents a template for a 
<code>User</code> object. It takes name and email as an argument and assign it to the newly created instance (when someone invokes it with the 
<code>new</code> keyword).</p>
<p>You can also add methods to the function directly on 
<code>this</code>, but it is not recommended for scenarios where you will be creating lot of objects. For one of instance or singleton cases this will work fine (more on that later).</p>
<p>Within the constructor function the 
<code>this</code> points to the current instance. Please note just after the function we are also creating a duplicate method on the functions prototype.</p>
<p>Before we go into detail the pros and cons of creating methods directly on 
<code>this</code> vs 
<code>prototype</code>, let see the output of this function and how this can be invoked.</p>
<pre>let user = new User(&#39;rajesh&#39;, &#39;someemail@test.com&#39;);
<br>console.log(user);
<br>console.log(user.save());
<br>console.log(user.saveDB());  // Exact output as save().</pre>
<pre>// Access instance variables/methods
<br>console.log(user.email);  // Outputs emails </pre>
<blockquote>NOTE: If you fail to use the ‘new’ keyword with User, the function will not work as expected as inside the function ‘this’ will point to global object.</blockquote>
<p>So, the below code will not work.</p>
<pre>// WILL NOTE WORK.  YOU HAVE TO USE &#39;new&#39; with Constructor function
<br>let user = User(&quot;rajesh&quot;,&quot;someemail2@test.com&quot;);</pre>
<p>So, the above code creates an instance of User object and invokes the save() method. Within the constructor function you can access the instance variables by using 
<code>this.variablename</code>.</p>
<p>The output on the console will be as shown below.</p>
<figure>
<img src="https://cdn-images-1.medium.com/max/1000/1*uhYrQ7xDDMLQUfjhzRkFoA.png" crossorigin="anonymous">
<figcaption>User object and the ID is return from the save method()</figcaption></figure>
<p>As a convention, functions inside the constructor function or on prototype is called as 
<code>methods</code> just to avoid any confusion.</p>
<h4>Why to use prototype for adding instance methods?</h4>
<p>Now, we know both the 
<code>save()</code> and 
<code>saveDB()</code> method above works similarly, why use prototype.</p>
<p>Let’s take the below scenario.</p>
<p>Use Case: Read users list from external file / api and create user objects to work with in the application.</p>
<p>Since we are not dealing with external api/web services here, let’s create 100 users in a loop.</p>
<pre>let users = [];
<br>for(let i = 1; i &lt;= 100; i++) {
<br>  let user = new User(`user ${i}`);
<br>  user.email = `
<a href="mailto:someemail@test.com" data-href="mailto:someemail@test.com">user${i}@test.com</a>`; // Lets create dynamic email
<br>  users.push(user);
<br>}</pre>
<pre>console.log(users);</pre>
<p>Now let’s take a look at the 
<code>users</code> array.</p>
<figure>
<img src="https://cdn-images-1.medium.com/max/1000/1*rWZlSZMmu-yUEhI-_cDvEA.png" crossorigin="anonymous">
</figure>
<p>Observe the array. There are 100 user objects and 100 copies of the 
<code>save()</code> method . This is very BAD for memory.</p>
<blockquote>Whereas’ the 
<code>saveDB()</code> is attached only once to the prototype of 
<code>User</code>. And any method added to the prototype is shared by all instances of the constructor function, in this case 
<code>User</code>.</blockquote>
<h4>Providing protection against missing ‘new’ for invoking constructor function.</h4>
<p>What if you want to provide protection against missing ‘new’ when invoking constructor function.</p>
<p>For e.g. you want both the below code to work.</p>
<pre>let user1 = new User(&quot;rajesh&quot;, &quot;somemail2@test.com&quot;);
<br>let user2 = User(&quot;rohan&quot;, &quot;somemail3@test.com&quot;);</pre>
<p>We can put a simple guard condition in the constructor function as shown below to achieve the desired result. Please modify this as per your requirement. In some cases you will prefer to throw an exception.</p>
<p>I am only shown the part code of User function.</p>
<pre>function User (name, email){
<br>  if (!(this instanceof User)) {
<br>    return new User(name, email);  // Don&#39;t forget parameter if any
<br>  }</pre>
<pre>  // REST OF THE CODE GOES HERE</pre>
<pre>}</pre>
<p>So, the above takes care of missing new for constructor function. We are checking if the instance is not of type User then create a new User object with the required parameters and return it.</p>
<p>In case the above code is invoked as</p>
<pre>let user = User(&quot;rajesh&quot;,&quot;someemail@test.com&quot;);</pre>
<p>It will correctly return the instance of User object.</p>
<h4>How to return a custom object from a Constructor function ?</h4>
<p>As we discussed earlier we can return any object from constructor function except primitive types.</p>
<p>For example, take a look at the below code.</p>
<pre>function Api(baseUrl) {
<br>  let _secret = +new Date();  
<br>  let self = this;  // in case you access to &#39;this&#39; of Api.</pre>
<pre>  return {
<br>    fetchData: function (resource) {
<br>      // Here you cannot use &#39;this&#39; as &#39;this&#39; points to the 
<br>      // fetchData function.</pre>
<pre>      // The &#39;self&#39; variable created above will point the the 
<br>      // API instance
<br>      let url = `${baseUrl}/${resource}/`;
<br>      console.log(url);
<br>      fetch(`${url}`)
<br>        .then(response =&gt; response.json())
<br>        .then(json =&gt; console.log(json));
<br>    }
<br>  }
<br>}</pre>
<p>The above approach is typically used for singleton pattern(but not exactly, will update singleton pattern in a while), where you only need one instance to work with. You can also use the object literal syntax to create this type of behaviour.</p>
<p>Now, let’s see how to use the above function. I am using the free json service from typicode.</p>
<pre>let api = new Api(&quot;
<a href="https://jsonplaceholder.typicode.com" data-href="https://jsonplaceholder.typicode.com">https://jsonplaceholder.typicode.com</a>&quot;);
<br>api.fetchData(&quot;posts&quot;);   // Get posts data</pre>
<pre>api.fetchData(&quot;users&quot;);  // Get users data</pre>
<p>One gain that you get from the above approach is that even if you miss the 
<code>new</code> keyword the function will work correctly as you are explicitly returning the object and you are not relying on the 
<code>this</code> context.</p>
<p>For e.g. the above code can also be written as</p>
<pre>let api = Api(&quot;
<a href="https://jsonplaceholder.typicode.com" data-href="https://jsonplaceholder.typicode.com">https://jsonplaceholder.typicode.com</a>&quot;);
<br>api.fetchData(&quot;posts&quot;);   // Get posts data</pre>
<h4>Singleton</h4>
<p>Singleton is a design pattern wherein you can have only one instance of class or constructor function.</p>
<p>We can easily create a single object by using IIFE. IIFE is executed only once and hence we can control the creation of our objects by wrapping our singleton object within IIFE and returning a new instance or an existing instance as required.</p>
<pre>var Singleton = (function () {
<br>    var instance;
<br> 
<br>    function createInstance() {
<br>        var object = new Object(&quot;I am the instance&quot;);
<br>        return object;
<br>    }
<br> 
<br>    return {
<br>        getInstance: function () {
<br>            if (!instance) {
<br>                instance = createInstance();
<br>            }
<br>            return instance;
<br>        }
<br>    };
<br>})();</pre>
<p>We can use the above function as shown below.</p>
<pre>let instance1 = Singleton.getInstance();
<br>let instance2 = Singleton.getInstance();</pre>
<pre>console.log(instance1 === instance2);   // Will return true</pre>
<p>How does Singleton work?</p>
<p>We first wrap the entire code in an IIFE and create a local variable named 
<code>instance</code>. In the getInstance() method, we check if the local variable is already initialized. If no, we create a new instance using the createInstance() function otherwise we return the already created instance.</p>
<p>Now, no matter how may times you call getInstance(), you will only get one copy of the object in memory. This is a very useful pattern for conserving memory and for creating utility functions where only once instance is required.</p>
<h3>Closures</h3>
<p>A closure is the combination of a function and the lexical environment within which that function was declared.</p>
<p>The word “lexical” refers to that fact that lexical scoping uses the location where a variable was declared within the source code to determine where that variable is available.</p>
<p>Nested functions have access to variables declared in their outer scope.</p>
<h4>Applications of Closures</h4>
<p>
<em>Partial Application</em>
<br>The process of applying a function to some of its arguments. The partially applied function gets returned for later use.</p>
<p>In other words, a function that takes a function with multiple parameters and returns a function with fewer parameters.</p>
<p>
<em>Event Handlers</em></p>
<p>
<em>Ajax</em></p>
<p>
<em>Private methods</em></p>
<p>Let us see a very simple example of closure</p>
<figure>
<img src="https://cdn-images-1.medium.com/max/1000/1*vPWGZgGgCO7uBL4nw79KgA.png" crossorigin="anonymous">
<figcaption>A closure demo</figcaption></figure>
<p>In the above functions let’s see what each function has access to.</p>
<p>The dialog () has access to its parameters and globals.</p>
<p>The message () has access to its parameter, m1, and its parent function, dialog()’s d1 parameter. It also has access to the 
<code>privateVar.</code></p>
<p>The show () has access to its parameter, p1, its parent function scope, message, and the variables from the dialog function.</p>
<p>Finally, when the show() function is invoked it has access to all the parameters enclosed by it, even though, those variables and parameters were not in scope when the show method is executed.</p>
<p>This is closure. It encloses all the surrounding variables and functions long after they are out of scope.</p>
<blockquote>Warning: Closures may leak memory if not correctly used. (More on that later).</blockquote>
<h4>Conclusion</h4>
<p>In the meantime you can enjoy the videos for the below two topics on my youtube channel.</p>
<ul>
<li>Constructor function (
<a href="https://www.youtube.com/watch?v=AHfPiTcH-G8&amp;t=2553s" data-href="https://www.youtube.com/watch?v=AHfPiTcH-G8&amp;t=2553s">Learn OOP using JavaScript</a>)</li>
<li>Closures (
<a href="https://www.youtube.com/watch?v=gqrDYtBh63Y" data-href="https://www.youtube.com/watch?v=gqrDYtBh63Y">Mastering JavaScript Closure</a>)</li></ul>
<h4>Coming up</h4>
<ul>
<li>Closures (Work in Progress)</li>
<li>Use cases</li></ul>
<h4>History</h4>
<ul>
<li>16-April-2018 — Updated example of …args as per comment to the story 
<a href="http://twitter.com/jeremievandersande" data-href="http://twitter.com/jeremievandersande">@jeremievandersande</a></li>
<li>Added Constructor function</li>
<li>Added special coupon for my upcoming live ReactSJ course on Udemy.</li></ul>
<br>
<br>
<br>
<br>

<script>
  $(function() {
    var toc = $('#toc');

    function makeLi(text, href) {
      return $('<a href="' + href + '" target="_self">' + text + '</a><br>');
    }

    $('h4').each(function(i) {
      var chapter = $(this), chapterNumber = i + 1;
      toc.append(
        makeLi(chapter.text(), '#chapter-' + chapterNumber)
      );
      chapter.attr('id', 'chapter-' + chapterNumber);
    });

  });
</script>
</body>
</html>
