<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width"/>
<link rel="stylesheet" href="..\maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script>
$(document).ready(function(){
    $('h1, h2, h3, h4, h5, .goldword, .apply, div.title').click(function(){
    parent.history.back();
    return false;
    });
});
</script>
<style>
body{width:80%;margin-left: 10%}
h1, h2 {color: gold;}
</style>
</head><body>
<center><h1>Python 3 入门</h1>
<div id="toc"></div></center>
<br>
<br>
<br>


<h3>简介</h3>
<p>Python 是一种高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。Python 由 Guido van Rossum 于 1989 年底在荷兰国家数学和计算机科学研究所发明，第一个公开发行版发行于 1991 年。
</p>
<h3 style="font-size: 20px;">特点</h3>
<ul style="" class=" list-paddingleft-2">
<p>
数据库：Python 提供所有主要的商业数据库的接口。
</p>
</li>
<li>
<p>
GUI 编程：Python 支持 GUI 可以创建和移植到许多系统调用。
</p>
</li>
<li>
<p>
可嵌入：你可以将 Python 嵌入到 C/C++ 程序，让你的程序的用户获得”脚本化”的能力。
</p>
</li>
<li>
<p>
面向对象：Python 是强面向对象的语言，程序中任何内容统称为对象，包括数字、字符串、函数等。
</p>
</li>
</ul>

<h2>
<span style="background-color: rgb(255, 251, 0);">

<h3>基础语法</h3>
</h2>
<h3 style="font-size: 20px;">运行 Python</h3>
<h4>
交互式解释器
</h4>
<p>在命令行窗口执行
<code>python</code>后，进入 Python 的交互式解释器。
<code>exit()</code>&nbsp;或&nbsp;
<code>Ctrl + D</code>&nbsp;组合键退出交互式解释器。
</p>

<h4>
命令行脚本
</h4>
<p>在命令行窗口执行
<code>python script-file.py</code>，以执行 Python 脚本文件。
</p>

<h4>
指定解释器
</h4>
<p>如果在 Python 脚本文件首行输入
<code>#!/usr/bin/env python</code>，那么可以在命令行窗口中执行
<code>/path/to/script-file.py</code>以执行该脚本文件。
</p>
<p>注：该方法不支持 Windows 环境。
</p>

<h3 style="font-size: 20px;">编码</h3>
<p>默认情况下，3.x 源码文件都是 UTF-8 编码，字符串都是 Unicode 字符。也可以手动指定文件编码：
</p>
<pre>
<code>
# -*- coding: utf-8 -*-</code>
</pre>
<p>
或者
</p>
<p>
<span>
</p>
<pre>
<code>
# encoding: utf-8</code>
</pre>
<p>
<span>
</p>
<p>注意: 该行标注必须位于文件第一行
</p>

<h3 style="font-size: 20px;">标识符</h3>
<ul style="" class=" list-paddingleft-2">
<li>
<p>第一个字符必须是英文字母或下划线&nbsp;
<code>_</code>&nbsp;。
</p>
</li>
<li>
<p>标识符的其他的部分由字母、数字和下划线组成。
</p>
</li>
<li>
<p>标识符对大小写敏感。
</p>
</li>
</ul>
<p>注：从 3.x 开始，非 ASCII 标识符也是允许的，但不建议。
</p>

<h3 style="font-size: 20px;">保留字</h3>
<p>保留字即关键字，我们不能把它们用作任何标识符名称。Python 的标准库提供了一个 keyword 模块，可以输出当前版本的所有关键字：
</p>
<pre>
<code>
<span class="hljs-prompt" style="color: rgb(230, 219, 116);">&gt;&gt;&gt; import keyword
<br  />
<span class="hljs-prompt" style="color: rgb(230, 219, 116);">&gt;&gt;&gt; keyword.kwlist
<br  />['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']</code>
</pre>
<p>

<span style="font-size: 20px;">注释
</p>

<p>单行注释采用
<code>#</code>，多行注释采用
<code>'''</code>或
<code>"""</code>。
</p>
<pre>
<code>
# 这是单行注释
<br  />
<br  />'''
<br  />这是多行注释
<br  />这是多行注释
<br  />'''
<br  />
<br  />"""
<br  />这也是多行注释
<br  />这也是多行注释
<br  />"""</code>
</pre>
<h3 style="font-size: 20px;">行与缩进</h3>
<p>Python 最具特色的就是使用缩进来表示代码块，不需要使用大括号&nbsp;
<code>{}</code>。 缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。缩进不一致，会导致运行错误。
</p>

<h3 style="font-size: 20px;">多行语句</h3>
<p>Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠
<code></code>来实现多行语句。
</p>
<pre>
<code>total = item_one + 
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;item_two + 
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;item_three</code>
</pre>
<p>在&nbsp;
<code>[]</code>,&nbsp;
<code>{}</code>, 或&nbsp;
<code>()</code>&nbsp;中的多行语句，不需要使用反斜杠
<code></code>。
</p>

<h3 style="font-size: 20px;">空行</h3>
<p>函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。
</p>
<p>空行与代码缩进不同，空行并不是 Python 语法的一部分。书写时不插入空行，Python 解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。
</p>
<p>记住：空行也是程序代码的一部分。
</p>

<h3 style="font-size: 20px;">等待用户输入</h3>
<p>
<code>input</code>函数可以实现等待并接收命令行中的用户输入。
</p>
<pre>
<code>content = input("请输入点东西并按 Enter 键")
<br  />print(content)</code>
</pre>

<h3 style="font-size: 20px;">同一行写多条语句</h3>
<p>Python 可以在同一行中使用多条语句，语句之间使用分号
<code>;</code>分割。
</p>
<pre>
<code>import sys; x = 'hello world'; sys.stdout.write(x + '')</code>
</pre>
<h3 style="font-size: 20px;">多个语句构成代码组</h3>

<p>缩进相同的一组语句构成一个代码块，我们称之代码组。
</p>
<p>像
<code>if</code>、
<code>while</code>、
<code>def</code>和
<code>class</code>这样的复合语句，首行以关键字开始，以冒号
<code>:</code>结束，该行之后的一行或多行代码构成代码组。
</p>
<p>我们将首行及后面的代码组称为一个子句(clause)。
</p>

<h3 style="font-size: 20px;">print 输出</h3>
<p>print 默认输出是换行的，如果要实现不换行需要在变量末尾加上
<code>end=""</code>或别的非换行符字符串：
</p>
<pre>
<code>print('123') 
# 默认换行
<br  />print('123', end = "") 
# 不换行</code>
</pre>
<h3 style="font-size: 20px;">import 与 from…import</h3>
<p>在 Python 用&nbsp;
<code>import</code>&nbsp;或者&nbsp;
<code>from...import</code>&nbsp;来导入相应的模块。
</p>
<p>将整个模块导入，格式为：
<code>import module_name</code>
</p>
<p>从某个模块中导入某个函数,格式为：
<code>from module_name import func1</code>
</p>
<p>从某个模块中导入多个函数,格式为：
<code>from module_name import func1, func2, func3</code>
</p>
<p>将某个模块中的全部函数导入，格式为：
<code>from module_name import *</code>
</p>
<h2>
<br  />
</h2>
<h2>
<span style="background-color: rgb(255, 251, 0);">

<h3>运算符</h3>
</h2>
<h3 style="font-size: 20px;">算术运算符</h3>
<table>
<thead style="background: rgb(248, 245, 236);">
<tr>
<th>运算符
</th>
<th>描述
</th></tr>
</thead>
<tbody>
<tr><td>+</td><td>加</td></tr>
<tr><td>-</td><td>减</td></tr>
<tr><td>*</td><td>乘</td></tr>
<tr><td>/</td><td>除</td></tr>
<tr><td>%</td><td>取模</td></tr>
<tr><td>**</td><td>幂</td></tr>
<tr><td>//</td><td>取整除</td></tr>
</tbody>
</table>
<h3 style="font-size: 20px;">
<br  /></h3>
<h3 style="font-size: 20px;">比较运算符</h3>
<table>
<thead style="background: rgb(248, 245, 236);">
<tr>
<th>运算符
</th>
<th>描述
</th></tr>
</thead>
<tbody>
<tr><td>==</td><td>等于</td></tr>
<tr><td>!=</td><td>不等于</td></tr>
<tr><td>&gt;</td><td>大于</td></tr>
<tr><td>&lt;</td><td>小于</td></tr>
<tr><td>&gt;=</td><td>大于等于</td></tr>
<tr><td>&lt;=</td><td>小于等于</td></tr>
</tbody>
</table>
<h3 style="font-size: 20px;">
<br  /></h3>
<h3 style="font-size: 20px;">赋值运算符</h3>
<table>
<thead style="background: rgb(248, 245, 236);">
<tr>
<th>运算符
</th>
<th>描述
</th></tr>
</thead>
<tbody>
<tr><td>=</td><td>简单的赋值运算符</td></tr>
<tr><td>+=</td><td>加法赋值运算符</td></tr>
<tr><td>-=</td><td>减法赋值运算符</td></tr>
<tr><td>*=</td><td>乘法赋值运算符</td></tr>
<tr><td>/=</td><td>除法赋值运算符</td></tr>
<tr><td>%=</td><td>取模赋值运算符</td></tr>
<tr><td>**=</td><td>幂赋值运算符</td></tr>
<tr><td>//=</td><td>取整除赋值运算符</td></tr>
</tbody>
</table>
<h3 style="font-size: 20px;">
<br  /></h3>
<h3 style="font-size: 20px;">位运算符</h3>
<p>
<img src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://mmbiz.qpic.cn/mmbiz_png/MQ4FoG1HmnJ5dS7gxiccqcC97db2ja87B4fUYvutb1drTAogWiclr0rR3I08wlUcbayo5S1eRsqJK2HbwTPTblIQ/640">
</p>
<h3 style="font-size: 20px;">逻辑运算符</h3>
<p>
<img src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://mmbiz.qpic.cn/mmbiz_png/MQ4FoG1HmnJ5dS7gxiccqcC97db2ja87BLjdGLeWx5iayNQK0fqmFJKR6Jsh9LDNa8RGMUsG8rIykoqmeDs8x1ibg/640">
</p>
<h3 style="font-size: 20px;">
<br  /></h3>
<h3 style="font-size: 20px;">成员运算符</h3>
<p>
<img src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://mmbiz.qpic.cn/mmbiz_png/MQ4FoG1HmnJbicSb8Y5yANyyiaWVmXMjQR5kLRDq6rJCVmgUVLCI0GZutPVGlUmRNrEAYf6GxqZIrrash6hKfx6w/640">
</p>
<h3 style="font-size: 20px;">身份运算符</h3>
<p>
<img src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://mmbiz.qpic.cn/mmbiz_png/MQ4FoG1HmnJbicSb8Y5yANyyiaWVmXMjQRric3O2zSpB4YojrdaLJGk65o1D5GrOa7vyibplNwAhBnUvrxVoX9SeVw/640">
</p>
<h3 style="font-size: 20px;">运算符优先级</h3>
<p>
<img src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://mmbiz.qpic.cn/mmbiz_png/MQ4FoG1HmnJbicSb8Y5yANyyiaWVmXMjQRicZtoReHiarOnyaSAvWgQbia4MCv9OCMxwHozicQI4dIl58Wib3Ofx4FvUw/640">
</p>
<p>
具有相同优先级的运算符将从左至右的方式依次进行。用小括号
<code>()</code>
可以改变运算顺序。
</p>
<p>

<br  />
</p>
<h2>
<span style="background-color: rgb(255, 251, 0);">

<h3>变量</h3>
</h2>

<p>变量在使用前必须先”定义”（即赋予变量一个值），否则会报错：
</p>
<pre>
<code>
<span class="hljs-prompt" style="color: rgb(230, 219, 116);">&gt;&gt;&gt; name
<br  />Traceback (most recent call last):
<br  /> &nbsp;File "&lt;stdin&gt;", line 1, in &lt;module&gt;
<br  />NameError: name 'name' is not defined</code>
</pre>
<h2>
<span style="background-color: rgb(255, 251, 0);">

<h3>数据类型</h3>
</h2>
<p>

<span style="font-size: 24px;color: rgb(171, 25, 66);">
<br  />
</p>
<h3 style="font-size: 20px;">布尔(bool)</h3>
<p>只有&nbsp;
<code>True</code>&nbsp;和&nbsp;
<code>False</code>&nbsp;两个值，表示真或假。
</p>

<h3 style="font-size: 20px;">数字(number)</h3>
<h4>
整型(int)
</h4>
<p>整数值，可正数亦可复数，无小数。 3.x 整型是没有限制大小的，可以当作 Long 类型使用，所以 3.x 没有 2.x 的 Long 类型。
</p>

<h4>
浮点型(float)
</h4>
<p>浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 10^2 = 250）
</p>

<h4>
复数(complex)
</h4>
<p>复数由实数部分和虚数部分构成，可以用
<code>a + bj</code>，或者
<code>complex(a,b)</code>表示，复数的实部 a 和虚部 b 都是浮点型。
</p>

<h4>
数字运算
</h4>
<ul style="" class=" list-paddingleft-2">
<li>
<p>不同类型的数字混合运算时会将整数转换为浮点数
</p>
</li>
<li>
<p>在不同的机器上浮点运算的结果可能会不一样
</p>
</li>
<li>
<p>在整数除法中，除法&nbsp;
<code>/</code>&nbsp;总是返回一个浮点数，如果只想得到整数的结果，丢弃可能的分数部分，可以使用运算符&nbsp;
<code>//</code>。
</p>
</li>
<li>
<p>
<code>//</code>&nbsp;得到的并不一定是整数类型的数，它与分母分子的数据类型有关系
</p>
</li>
<li>
<p>在交互模式中，最后被输出的表达式结果被赋值给变量&nbsp;
<code>_</code>，
<code>_</code>&nbsp;是个只读变量
</p>
</li>
</ul>
<h4>
数学函数
</h4>
<p>注：以下函数的使用，需先导入 math 包。
</p>
<p>
<img src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://mmbiz.qpic.cn/mmbiz_png/MQ4FoG1HmnJbicSb8Y5yANyyiaWVmXMjQRDzD2gvzeBX2pjddoHZqgib6EFQVAcvRZvSqgINlMG3OBu4zVws7sMmw/640">
</p>
<h4>
随机数函数
</h4>
<p>注：以下函数的使用，需先导入 random 包。
</p>
<p>
<img src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://mmbiz.qpic.cn/mmbiz_png/MQ4FoG1HmnJbicSb8Y5yANyyiaWVmXMjQRia9cX96HaFCAyKCEMwicZdG0AgyaqNmmMjEmRibka7I8SVMtAF149pS7g/640">
</p>
<h4>
三角函数
</h4>
<p>注：以下函数的使用，需先导入 math 包。
</p>
<p>
<img src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://mmbiz.qpic.cn/mmbiz_png/MQ4FoG1HmnJbicSb8Y5yANyyiaWVmXMjQRK4QUBTu1UBVlibDZDCdwicHEX1BiaqpXicVd4XRH7ib0iaspEtujPYicfuEaA/640">
</p>
<h4>
数学常量
</h4>
<p>
<img src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://mmbiz.qpic.cn/mmbiz_png/MQ4FoG1HmnJbicSb8Y5yANyyiaWVmXMjQRB4c5TOQsnqj8qrIE1McOaDWBfQ9aEArBePWzzn10Bn3lQpb3n8rAaw/640">
</p>
<h3 style="font-size: 20px;">字符串(string)</h3>
<ul style="" class=" list-paddingleft-2">
<li>
<p>单引号和双引号使用完全相同
</p>
</li>
<li>
<p>使用三引号(
<code>'''</code>或
<code>"""</code>)可以指定一个多行字符串
</p>
</li>
<li>
<p>转义符(反斜杠
<code></code>)可以用来转义，使用
<code>r</code>可以让反斜杠不发生转义，如
<code>r"this is a line with "</code>，则
<code></code>会显示，并不是换行
</p>
</li>
<li>
<p>按字面意义级联字符串，如
<code>"this " "is " "string"</code>会被自动转换为
<code>this is string</code>
</p>
</li>
<li>
<p>字符串可以用&nbsp;
<code>+</code>&nbsp;运算符连接在一起，用&nbsp;
<code>*</code>&nbsp;运算符重复
</p>
</li>
<li>
<p>字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始
</p>
</li>
<li>
<p>字符串不能改变
</p>
</li>
<li>
<p>没有单独的字符类型，一个字符就是长度为 1 的字符串
</p>
</li>
<li>
<p>字符串的截取的语法格式如下：
<code>变量[头下标:尾下标]</code>
</p>
</li>
</ul>
<h4>

<br  />
</h4>
<h4>
转义字符
</h4>
<p>
<img src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://mmbiz.qpic.cn/mmbiz_png/MQ4FoG1HmnJbicSb8Y5yANyyiaWVmXMjQRQps1xXurcapLiacJPhXbJiajJT3FdZXiaVvlynaJLqNKpiaxicvboHm7tsw/640">
</p>
<h4>
字符串运算符
</h4>
<p>
<img src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://mmbiz.qpic.cn/mmbiz_png/MQ4FoG1HmnJbicSb8Y5yANyyiaWVmXMjQR5RvgTpJKB0QKO904htXdT0xfI0icetXP72CAektAcujCbZYZBv9hjSQ/640">
</p>
<h4>
字符串格式化
</h4>
<p>在 Python 中，字符串格式化不是 sprintf 函数，而是用&nbsp;
<code>%</code>&nbsp;符号。例如：
</p>
<pre>
<code>print("我叫%s， 今年 %d 岁！" % ('小明', 10))
<br  />// 输出:
<br  />我叫小明， 今年 10 岁！</code>
</pre>
<p>
<span style="font-weight: 700;color: rgb(52, 73, 94);">格式化符号:
</p>
<p>
<img src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://mmbiz.qpic.cn/mmbiz_png/MQ4FoG1HmnJbicSb8Y5yANyyiaWVmXMjQRXXcU0YLSPz5Rd9icowK9JehCibw0ib38weaFhcUVEibtQdVXZX8nucSS4g/640">
</p>
<p>
<span style="font-weight: 700;color: rgb(52, 73, 94);">辅助指令:
<br  />
</p>
<p>
<img src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://mmbiz.qpic.cn/mmbiz_png/MQ4FoG1HmnJbicSb8Y5yANyyiaWVmXMjQRmQYfEjPXibOMQH40ax1BwUiaAA1ZTaD8nia8su5gatQiar6tGng28NW42g/640">
</p>
<p>
<span style="font-weight: 700;color: rgb(52, 73, 94);">
</p>
<p>Python 2.6 开始，新增了一种格式化字符串的函数&nbsp;
<code>str.format()</code>，它增强了字符串格式化的功能。
</p>

<h4>
多行字符串
</h4>
<ul style="" class=" list-paddingleft-2">
<li>
<p>用三引号(
<code>'''</code>&nbsp;或&nbsp;
<code>"""</code>)包裹字符串内容
</p>
</li>
<li>
<p>多行字符串内容支持转义符，用法与单双引号一样
</p>
</li>
<li>
<p>三引号包裹的内容，有变量接收或操作即字符串，否则就是多行注释
</p>
</li>
</ul>
<p>实例：
</p>
<pre>
<code>string = '''
<br  />print(math.fabs(-10))
<br  />print(random.choice(li))
<br  />'''
<br  />print(string)</code>
</pre>
<p>输出：
</p>
<pre>
<code>print( &nbsp;math.fabs(-10))
<br  />print(
<br  />random.choice(li))</code>
</pre>
<h4>
Unicode
</h4>
<p>在 2.x 中，普通字符串是以 8 位 ASCII 码进行存储的，而 Unicode 字符串则存储为 16 位 Unicode 字符串，这样能够表示更多的字符集。使用的语法是在字符串前面加上前缀&nbsp;
<code>u</code>。
</p>
<p>在 3.x 中，所有的字符串都是 Unicode 字符串。
</p>

<h4>
字符串函数
</h4>
<p>
<img src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://mmbiz.qpic.cn/mmbiz_png/MQ4FoG1HmnJbicSb8Y5yANyyiaWVmXMjQR0dbmB4qKjAQG7cTpOrXicnoI27LAHziacYEGefV4ChBwiazia6mgEYD7Zg/640">
</p>
<p>
<img src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://mmbiz.qpic.cn/mmbiz_png/MQ4FoG1HmnJbicSb8Y5yANyyiaWVmXMjQRTCaRDoVLNMqNBsRlBpYcSPrtZsRWNJaNdibxKFblmgNoanm2vmR7Hgw/640">
</p>
<p>
<img src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://mmbiz.qpic.cn/mmbiz_png/MQ4FoG1HmnJbicSb8Y5yANyyiaWVmXMjQRic5CF9KVbD2CQPaxo8UiaSOvS3XZ80TrG78tvxWWDuuAX4hRQZXib0EmQ/640">
</p>
<h3 style="font-size: 20px;"><br  /></h3>
<h3 style="font-size: 20px;">字节(bytes)</h3>
<p>在 3.x 中，字符串和二进制数据完全区分开。文本总是 Unicode，由 str 类型表示，二进制数据则由 bytes 类型表示。Python 3 不会以任意隐式的方式混用 str 和 bytes，你不能拼接字符串和字节流，也无法在字节流里搜索字符串（反之亦然），也不能将字符串传入参数为字节流的函数（反之亦然）。
</p>

<ul style="" class=" list-paddingleft-2">
<li>
<p>bytes 类型与 str 类型，二者的方法仅有 encode() 和 decode() 不同。
</p>
</li>
<li>
<p>bytes 类型数据需在常规的 str 类型前加个&nbsp;
<code>b</code>&nbsp;以示区分，例如&nbsp;
<code>b'abc'</code>。
</p>
</li>
<li>
<p>只有在需要将 str 编码(encode)成 bytes 的时候，比如：通过网络传输数据；或者需要将 bytes 解码(decode)成 str 的时候，我们才会关注 str 和 bytes 的区别。
</p>
</li>
</ul>
<p>
bytes 转 str：
</p>
<p>

</p>
<pre>
<code>b'abc'.decode()
<br  />str(b'abc')
<br  />str(b'abc', encoding='utf-8')</code>
</pre>
<p>
str 转 bytes：
</p>
<p>

</p>
<pre>
<code>'中国'.encode()
<br  />bytes('中国', encoding='utf-8')</code>
</pre>
<h3 style="font-size: 20px;">列表(list)</h3>
<ul style="" class=" list-paddingleft-2">
<li>
<p>列表是一种无序的、可重复的数据序列，可以随时添加、删除其中的元素。
</p>
</li>
<li>
<p>列表页的每个元素都分配一个数字索引，从 0 开始
</p>
</li>
<li>
<p>列表使用方括号创建，使用逗号分隔元素
</p>
</li>
<li>
<p>列表元素值可以是任意类型，包括变量
</p>
</li>
<li>
<p>使用方括号对列表进行元素访问、切片、修改、删除等操作，开闭合区间为
<code>[)</code>形式
</p>
</li>
<li>
<p>列表的元素访问可以嵌套
</p>
</li>
<li>
<p>方括号内可以是任意表达式
</p>
</li>
</ul>
<h4>
创建列表
</h4>
<p>

</p>
<pre>
<code>hello = (1, 2, 3)
<br  />li = [1, "2", [3, 'a'], (1, 3), hello]</code>
</pre>
<h4>
访问元素
</h4>
<p>

</p>
<pre>
<code>li = [1, "2", [3, 'a'], (1, 3)]
<br  />print(li[3]) &nbsp; &nbsp; &nbsp; &nbsp;
# (1, 3)
<br  />print(li[-2]) &nbsp; &nbsp; &nbsp; 
# [3, 'a']</code>
</pre>
<h4>
切片访问
</h4>
<p>格式:&nbsp;
<code>list_name[begin:end:step]</code>&nbsp;begin 表示起始位置(默认为0)，end 表示结束位置(默认为最后一个元素)，step 表示步长(默认为1)
</p>
<pre>
<code>hello = (1, 2, 3)
<br  />li = [1, "2", [3, 'a'], (1, 3), hello]
<br  />print(li) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
# [1, '2', [3, 'a'], (1, 3), (1, 2, 3)]
<br  />print(li[1:2]) &nbsp; &nbsp; &nbsp;
# ['2']
<br  />print(li[:2]) &nbsp; &nbsp; &nbsp; 
# [1, '2']
<br  />print(li[:]) &nbsp; &nbsp; &nbsp; &nbsp;
# [1, '2', [3, 'a'], (1, 3), (1, 2, 3)]
<br  />print(li[2:]) &nbsp; &nbsp; &nbsp; 
# [[3, 'a'], (1, 3), (1, 2, 3)]
<br  />print(li[1:-1:2]) &nbsp; 
# ['2', (1, 3)]</code>
</pre>
<p>访问内嵌 list 的元素：
</p>
<pre>
<code>li = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ['a', 'b', 'c']]
<br  />print(li[1:-1:2][1:3]) &nbsp; &nbsp; &nbsp;
# (3, 5)
<br  />print(li[-1][1:3]) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
# ['b', 'c']
<br  />print(li[-1][1]) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
# b</code>
</pre>
<h4>
修改列表
</h4>
<p>通过使用方括号，可以非常灵活的对列表的元素进行修改、替换、删除等操作。
</p>
<pre>
<code>li = [0, 1, 2, 3, 4, 5]
<br  />li[len(li) - 2] = 22 &nbsp; &nbsp;
# 修改 [0, 1, 2, 22, 4, 5]
<br  />li[3] = 33 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
# 修改 [0, 1, 2, 33, 4, 5]
<br  />li[1:-1] = [9, 9] &nbsp; &nbsp; &nbsp; 
# 替换 [0, 9, 9, 5]
<br  />li[1:-1] = [] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
# 删除 [0, 5]</code>
</pre>
<h4>
删除元素
</h4>
<p>可以用 del 语句来删除列表的指定范围的元素。
</p>
<pre>
<code>li = [0, 1, 2, 3, 4, 5]
<br  />del li[3] &nbsp; &nbsp; &nbsp; 
# [0, 1, 2, 4, 5]
<br  />del li[2:-1] &nbsp; &nbsp;
# [0, 1, 5]</code>
</pre>
<h4>
列表操作符
</h4>
<ul style="" class=" list-paddingleft-2">
<li>
<p>
<code>+</code>&nbsp;用于合并列表
</p>
</li>
<li>
<p>
<code>*</code>&nbsp;用于重复列表元素
</p>
</li>
<li>
<p>
<code>in</code>&nbsp;用于判断元素是否存在于列表中
</p>
</li>
<li>
<p>
<code>for ... in ...</code>&nbsp;用于遍历列表元素
</p>
</li>
</ul>
<pre>
<code>[1, 2, 3] + [3, 4, 5] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
# [1, 2, 3, 3, 4, 5]
<br  />[1, 2, 3] * 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
# [1, 2, 3, 1, 2, 3]
<br  />3 in [1, 2, 3] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
# True
<br  />for x in [1, 2, 3]: print(x) &nbsp; &nbsp;
# 1 2 3</code>
</pre>
<h4>
列表函数
</h4>
<ul style="" class=" list-paddingleft-2">
<li>
<p>
<code>len(list)</code>&nbsp;列表元素个数
</p>
</li>
<li>
<p>
<code>max(list)</code>&nbsp;列表元素中的最大值
</p>
</li>
<li>
<p>
<code>min(list)</code>&nbsp;列表元素中的最小值
</p>
</li>
<li>
<p>
<code>list(seq)</code>&nbsp;将元组转换为列表
</p>
</li>
</ul>
<pre>
<code>li = [0, 1, 5]
<br  />max(li) &nbsp; &nbsp; 
# 5
<br  />len(li) &nbsp; &nbsp; 
# 3</code>
</pre>
<p>注: 对列表使用 max/min 函数，2.x 中对元素值类型无要求，3.x 则要求元素值类型必须一致。
</p>

<h4>
列表方法
</h4>
<ul style="" class=" list-paddingleft-2">
<li>
<p>list.append(obj)
</p>
<p>在列表末尾添加新的对象
</p>
</li>
<li>
<p>list.count(obj)
</p>
<p>返回元素在列表中出现的次数
</p>
</li>
<li>
<p>list.extend(seq)
</p>
<p>在列表末尾一次性追加另一个序列中的多个值
</p>
</li>
<li>
<p>list.index(obj)
</p>
<p>返回查找对象的索引位置，如果没有找到对象则抛出异常
</p>
</li>
<li>
<p>list.insert(index, obj)
</p>
<p>将指定对象插入列表的指定位置
</p>
</li>
<li>
<p>list.pop([index=-1]])
</p>
<p>移除列表中的一个元素（默认最后一个元素），并且返回该元素的值
</p>
</li>
<li>
<p>list.remove(obj)
</p>
<p>移除列表中某个值的第一个匹配项
</p>
</li>
<li>
<p>list.reverse()
</p>
<p>反向排序列表的元素
</p>
</li>
<li>
<p>list.sort(cmp=None, key=None, reverse=False)
</p>
<p>对原列表进行排序，如果指定参数，则使用比较函数指定的比较函数
</p>
</li>
<li>
<p>list.clear()
</p>
<p>清空列表 还可以使用&nbsp;
<code>del list[:]</code>、
<code>li = []</code>&nbsp;等方式实现
</p>
</li>
<li>
<p>list.copy()
</p>
<p>复制列表 默认使用等号赋值给另一个变量，实际上是引用列表变量。如果要实现
</p>
</li>
</ul>
<h4>

<span style="color: rgb(64, 118, 0);">列表推导式
</h4>
<p>列表推导式提供了从序列创建列表的简单途径。通常应用程序将一些操作应用于某个序列的每个元素，用其获得的结果作为生成新列表的元素，或者根据确定的判定条件创建子序列。
</p>
<p>每个列表推导式都在 for 之后跟一个表达式，然后有零到多个 for 或 if 子句。返回结果是一个根据表达从其后的 for 和 if 上下文环境中生成出来的列表。如果希望表达式推导出一个元组，就必须使用括号。
</p>
<p>将列表中每个数值乘三，获得一个新的列表：
</p>
<pre>
<code>vec = [2, 4, 6]
<br  />[(x, x**2) for x in vec]
<br  />
# [(2, 4), (4, 16), (6, 36)]</code>
</pre>
<p>对序列里每一个元素逐个调用某方法：
</p>
<pre>
<code>freshfruit = [' &nbsp;banana', ' &nbsp;loganberry ', 'passion fruit &nbsp;']
<br  />[weapon.strip() for weapon in freshfruit]
<br  />
# ['banana', 'loganberry', 'passion fruit']</code>
</pre>
<p>用 if 子句作为过滤器：
</p>
<pre>
<code>vec = [2, 4, 6]
<br  />[3*x for x in vec if x &gt; 3]
<br  />
# [12, 18]</code>
</pre>
<pre>
<code>vec1 = [2, 4, 6]
<br  />vec2 = [4, 3, -9]
<br  />[x*y for x in vec1 for y in vec2]
<br  />
# [8, 6, -18, 16, 12, -36, 24, 18, -54]
<br  />[vec1[i]*vec2[i] for i in range(len(vec1))]
<br  />
# [8, 12, -54]</code>
</pre>
<p>列表嵌套解析：
</p>
<pre>
<code>matrix = [
<br  />[1, 2, 3],
<br  />[4, 5, 6],
<br  />[7, 8, 9],
<br  />]
<br  />new_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]
<br  />print(new_matrix)
<br  />
# [[1, 4, 7], [2, 5, 8], [3, 6, 9]]</code>
</pre>
<figure class="language-py hljs python highlight" style="margin-top: 1em;margin-bottom: 1em;border-radius: 5px;overflow-x: auto;box-shadow: rgba(0, 0, 0, 0.125) 1px 1px 2px;color: rgb(52, 73, 94);">
</figure>
<h3 style="font-size: 20px;">元组(tuple)</h3>
<ul style="" class=" list-paddingleft-2">
<li>
<p>元组与列表类似，不同之处在于元组的元素不能修改
</p>
</li>
<li>
<p>元组使用小括号，列表使用方括号
</p>
</li>
<li>
<p>元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可
</p>
</li>
<li>
<p>没有 append()，insert() 这样进行修改的方法，其他方法都与列表一样
</p>
</li>
<li>
<p>字典中的键必须是唯一的同时不可变的，值则没有限制
</p>
</li>
<li>
<p>元组中只包含一个元素时，需要在元素后面添加逗号，否则括号会被当作运算符使用
</p>
</li>
</ul>
<h4>
访问元组
</h4>
<p>访问元组的方式与列表是一致的。 元组的元素可以直接赋值给多个变量，但变量数必须与元素数量一致。
</p>
<pre>
<code>a, b, c = (1, 2, 3)
<br  />print(a, b, c)</code>
</pre>
<h4>
组合元组
</h4>
<p>元组中的元素值是不允许修改的，但我们可以对元组进行连接组合
</p>
<pre>
<code>tup1 = (12, 34.56);
<br  />tup2 = ('abc', 'xyz')
<br  />tup3 = tup1 + tup2;
<br  />print (tup3)
<br  />
# (12, 34.56, 'abc', 'xyz')</code>
</pre>
<h4>
删除元组
</h4>
<p>元组中的元素值是不允许删除的，但我们可以使用 del 语句来删除整个元组
</p>
<h4>元组函数
</h4>
<ul style="" class=" list-paddingleft-2">
<li>
<p>
<code>len(tuple)</code>&nbsp;元组元素个数
</p>
</li>
<li>
<p>
<code>max(tuple)</code>&nbsp;元组元素中的最大值
</p>
</li>
<li>
<p>
<code>min(tuple)</code>&nbsp;元组元素中的最小值
</p>
</li>
<li>
<p>
<code>tuple(tuple)</code>&nbsp;将列表转换为元组
</p>
</li>
</ul>
<h4>
元组推导式
</h4>
<pre>
<code>t = 1, 2, 3
<br  />print(t)
<br  />
# (1, 2, 3)
<br  />u = t, (3, 4, 5)
<br  />print(u)
<br  />
# ((1, 2, 3), (3, 4, 5))</code>
</pre>
<h3 style="font-size: 20px;">字典(dict)</h3>
<ul style="" class=" list-paddingleft-2">
<li>
<p>字典是另一种可变容器模型，可存储任意类型对象
</p>
</li>
<li>
<p>字典的每个键值(key=&gt;value)对用冒号(:)分割，每个对之间用逗号(,)分割，整个字典包括在花括号({})中
</p>
</li>
<li>
<p>键必须是唯一的，但值则不必
</p>
</li>
<li>
<p>值可以是任意数据类型
</p>
</li>
<li>
<p>键必须是不可变的，例如：数字、字符串、元组可以，但列表就不行
</p>
</li>
<li>
<p>如果用字典里没有的键访问数据，会报错
</p>
</li>
<li>
<p>字典的元素没有顺序，不能通过下标引用元素，通过键来引用
</p>
</li>
<li>
<p>字典内部存放的顺序和 key 放入的顺序是没有关系的
</p>
</li>
</ul>
<p>格式如下:
</p>
<pre>
<code>d = {key1 : value1, key2 : value2 }</code>
</pre>
<h4>
访问字典
</h4>
<p>

</p>
<pre>
<code>dis = {'a': 1, 'b': [1, 2, 3]}
<br  />print(dis['b'][2])</code>
</pre>
<h4>
修改字典
</h4>
<p>

</p>
<pre>
<code>dis = {'a': 1, 'b': [1, 2, 3], 9: {'name': 'hello'}}
<br  />dis[9]['name'] = 999
<br  />print(dis)
<br  />
# {'a': 1, 9: {'name': 999}, 'b': [1, 2, 3]}</code>
</pre>
<h4>
删除字典
</h4>
<p>用 del 语句删除字典或字典的元素。
</p>
<pre>
<code>dis = {'a': 1, 'b': [1, 2, 3], 9: {'name': 'hello'}}
<br  />del dis[9]['name']
<br  />print(dis)
<br  />del dis &nbsp; &nbsp; &nbsp; &nbsp; 
# 删除字典
<br  />
# {'a': 1, 9: {}, 'b': [1, 2, 3]}</code>
</pre>
<h4>
字典函数
</h4>
<ul style="" class=" list-paddingleft-2">
<li>
<p>
<code>len(dict)</code>&nbsp;计算字典元素个数，即键的总数
</p>
</li>
<li>
<p>
<code>str(dict)</code>&nbsp;输出字典，以可打印的字符串表示
</p>
</li>
<li>
<p>
<code>type(variable)</code>&nbsp;返回输入的变量类型，如果变量是字典就返回字典类型
</p>
</li>
<li>
<p>
<code>key in dict</code>&nbsp;判断键是否存在于字典中
</p>
</li>
</ul>
<h4>
字典方法
</h4>
<ul style="" class=" list-paddingleft-2">
<li>
<p>dict.clear()
</p>
<p>删除字典内所有元素
</p>
</li>
<li>
<p>dict.copy()
</p>
<p>返回一个字典的浅复制
</p>
</li>
<li>
<p>dict.fromkeys(seq[, value])
</p>
<p>创建一个新字典，以序列 seq 中元素做字典的键，value 为字典所有键对应的初始值
</p>
</li>
<li>
<p>dict.get(key, default=None)
</p>
<p>返回指定键的值，如果值不在字典中返回默认值
</p>
</li>
<li>
<p>dict.items()
</p>
<p>以列表形式返回可遍历的(键, 值)元组数组
</p>
</li>
<li>
<p>dict.keys()
</p>
<p>以列表返回一个字典所有的键
</p>
</li>
<li>
<p>dict.values()
</p>
<p>以列表返回字典中的所有值
</p>
</li>
<li>
<p>dict.setdefault(key, default=None)
</p>
<p>如果 key 在字典中，返回对应的值。如果不在字典中，则插入 key 及设置的默认值 default，并返回 default ，default 默认值为 None。
</p>
</li>
<li>
<p>dict.update(dict2)
</p>
<p>把字典参数 dict2 的键/值对更新到字典 dict 里
</p>
<figure class="language-py hljs python highlight" style="margin-top: 1em;margin-bottom: 1em;border-radius: 5px;overflow-x: auto;box-shadow: rgba(0, 0, 0, 0.125) 1px 1px 2px;">
</figure>
</li>
<pre>
<code>
<br  />dic1 = {'a': 'a'}
<br  />dic2 = {9: 9, 'a': 'b'}
<br  />dic1.update(dic2)
<br  />print(dic1)
<br  />
# {'a': 'b', 9: 9}
<br  /></code>
</pre>
<li>
<p>dict.pop(key[,default])
</p>
<p>删除字典给定键 key 所对应的值，返回值为被删除的值。key 值必须给出，否则返回 default 值。
</p>
</li>
<li>
<p>dict.popitem()
</p>
<p>随机返回并删除字典中的一对键和值(一般删除末尾对)
</p>
</li>
</ul>
<h4>
字典推导式
</h4>
<p>构造函数 dict() 直接从键值对元组列表中构建字典。如果有固定的模式，列表推导式指定特定的键值对：
</p>
<pre>
<code>
<span class="hljs-prompt" style="color: rgb(230, 219, 116);">&gt;&gt;&gt; dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])
<br  />{'sape': 4139, 'jack': 4098, 'guido': 4127}</code>
</pre>
<p>此外，字典推导可以用来创建任意键和值的表达式词典：
</p>
<pre>
<code>
<span class="hljs-prompt" style="color: rgb(230, 219, 116);">&gt;&gt;&gt; {x: x**2 for x in (2, 4, 6)}
<br  />{2: 4, 4: 16, 6: 36}</code>
</pre>
<p>如果关键字只是简单的字符串，使用关键字参数指定键值对有时候更方便：
</p>
<pre>
<code>
<span class="hljs-prompt" style="color: rgb(230, 219, 116);">&gt;&gt;&gt; dict(sape=4139, guido=4127, jack=4098)
<br  />{'sape': 4139, 'jack': 4098, 'guido': 4127}</code>
</pre>
<h3 style="font-size: 20px;">集合(set)</h3>
<p>集合是一个无序不重复元素的序列
</p>

<h4>
创建集合
</h4>
<ul style="" class=" list-paddingleft-2">
<li>
<p>可以使用大括号&nbsp;
<code>{}</code>&nbsp;或者&nbsp;
<code>set()</code>&nbsp;函数创建集合
</p>
</li>
<li>
<p>创建一个空集合必须用&nbsp;
<code>set()</code>&nbsp;而不是&nbsp;
<code>{}</code>，因为&nbsp;
<code>{}</code>&nbsp;是用来创建一个空字典
</p>
</li>
<li>
<p>
<code>set(value)</code>&nbsp;方式创建集合，value 可以是字符串、列表、元组、字典等序列类型
</p>
</li>
<li>
<p>创建、添加、修改等操作，集合会自动去重
</p>
</li>
</ul>
<pre>
<code>{1, 2, 1, 3} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
# {} {1, 2, 3}
<br  />set('12345') &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
# 字符串 {'3', '5', '4', '2', '1'}
<br  />set([1, 'a', 23.4]) &nbsp; &nbsp; 
# 列表 {1, 'a', 23.4}
<br  />set((1, 'a', 23.4)) &nbsp; &nbsp; 
# 元组 {1, 'a', 23.4}
<br  />set({1:1, 'b': 9}) &nbsp; &nbsp; &nbsp;
# 字典 {1, 'b'}</code>
</pre>
<h4>
添加元素
</h4>
<p>将元素 val 添加到集合 set 中，如果元素已存在，则不进行任何操作：
</p>
<pre>
<code>set.add(val)</code>
</pre>
<p>也可以用 update 方法批量添加元素，参数可以是列表，元组，字典等：
</p>
<pre>
<code>set.update(list1, list2,...)</code>
</pre>
<h4>
移除元素
</h4>
<p>如果存在元素 val 则移除，不存在就报错：
</p>
<pre>
<code>set.remove(val)</code>
</pre>
<p>如果存在元素 val 则移除，不存在也不会报错：
</p>
<pre>
<code>set.discard(val)</code>
</pre>
<figure class="language-py hljs python highlight" style="margin-top: 1em;margin-bottom: 1em;border-radius: 5px;overflow-x: auto;box-shadow: rgba(0, 0, 0, 0.125) 1px 1px 2px;color: rgb(52, 73, 94);">
</figure>
<p>
随机移除一个元素：
<br  />
</p>
<p>

</p>
<pre>
<code>set.pop()</code>
</pre>
<h4>
元素个数
</h4>
<p>与其他序列一样，可以用&nbsp;
<code>len(set)</code>&nbsp;获取集合的元素个数。
</p>

<h4>
清空集合
</h4>
<p>

</p>
<pre>
<code>set.clear()
<br  />set = set()</code>
</pre>
<h4>
判断元素是否存在
</h4>
<p>
</p>
<pre>
<code>val in set</code>
</pre>
<h4>
其他方法
</h4>
<ul style="" class=" list-paddingleft-2">
<li>
<p>set.copy()
</p>
<p>复制集合
</p>
</li>
<li>
<p>set.difference(set2)
</p>
<p>求差集，在 set 中却不在 set2 中
</p>
</li>
<li>
<p>set.intersection(set2)
</p>
<p>求交集，同时存在于 set 和 set2 中
</p>
</li>
<li>
<p>set.union(set2)
</p>
<p>求并集，所有 set 和 set2 的元素
</p>
</li>
<li>
<p>set.symmetric_difference(set2)
</p>
<p>求对称差集，不同时出现在两个集合中的元素
</p>
</li>
<li>
<p>set.isdisjoint(set2)
</p>
<p>如果两个集合没有相同的元素，返回 True
</p>
</li>
<li>
<p>set.issubset(set2)
</p>
<p>如果 set 是 set2 的一个子集，返回 True
</p>
</li>
<li>
<p>set.issuperset(set2)
</p>
<p>如果 set 是 set2 的一个超集，返回 True
</p>
</li>
</ul>
<h4>
集合计算
</h4>
<p>

</p>
<pre>
<code>a = set('abracadabra')
<br  />b = set('alacazam')
<br  />print(a) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
# a 中唯一的字母
<br  />
# {'a', 'r', 'b', 'c', 'd'}
<br  />print(a - b) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
# 在 a 中的字母，但不在 b 中
<br  />
# {'r', 'd', 'b'}
<br  />print(a | b) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
# 在 a 或 b 中的字母
<br  />
# {'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}
<br  />print(a &amp; b) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
# 在 a 和 b 中都有的字母
<br  />
# {'a', 'c'}
<br  />print(a ^ b) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
# 在 a 或 b 中的字母，但不同时在 a 和 b 中
<br  />
# {'r', 'd', 'b', 'm', 'z', 'l'}</code>
</pre>
<h4>
集合推导式
</h4>
<p>
</p>
<pre>
<code>a = {x for x in 'abracadabra' if x not in 'abc'}
<br  />print(a)
<br  />
# {'d', 'r'}</code>
</pre>
<h2>
<span style="background-color: rgb(255, 251, 0);">

<h3>流程控制</h3>
</h2>
<h3 style="font-size: 20px;">if 控制</h3>
<p>

</p>
<pre>
<code>if 表达式1:
<br  /> &nbsp; &nbsp;语句
<br  /> &nbsp; &nbsp;if 表达式2:
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;语句
<br  /> &nbsp; &nbsp;elif 表达式3:
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;语句
<br  /> &nbsp; &nbsp;else:
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;语句
<br  />elif 表达式4:
<br  /> &nbsp; &nbsp;语句
<br  />else:
<br  /> &nbsp; &nbsp;语句</code>
</pre>
<p>
1、每个条件后面要使用冒号&nbsp;
<code>:</code>
，表示接下来是满足条件后要执行的语句块。 2、使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。 3、在 Python 中没有 switch - case 语句。

<br  />
</p>
<p>

<br  />
</p>
<p>三元运算符：
</p>
<pre>
<code>&lt;表达式1&gt; if &lt;条件&gt; else &lt;表达式2&gt;</code>
</pre>
<p>编写条件语句时，应该尽量避免使用嵌套语句。嵌套语句不便于阅读，而且可能会忽略一些可能性。
</p>

<h3 style="font-size: 20px;">for 遍历</h3>
<pre>
<code>for &lt;循环变量&gt; in &lt;循环对象&gt;：
<br  /> &nbsp; &nbsp;&lt;语句1&gt;
<br  />else:
<br  /> &nbsp; &nbsp;&lt;语句2&gt;</code>
</pre>
<p>else 语句中的语句2只有循环正常退出（遍历完所有遍历对象中的值）时执行。
</p>
<p>在字典中遍历时，关键字和对应的值可以使用&nbsp;
<code>items()</code>&nbsp;方法同时解读出来：
</p>
<pre>
<code>knights = {'gallahad': 'the pure', 'robin': 'the brave'}
<br  />for k, v in knights.items():
<br  /> &nbsp; &nbsp;print(k, v)</code>
</pre>
<p>在序列中遍历时，索引位置和对应值可以使用&nbsp;
<code>enumerate()</code>&nbsp;函数同时得到：
</p>
<pre>
<code>for i, v in enumerate(['tic', 'tac', 'toe']):
<br  /> &nbsp; &nbsp;print(i, v)</code>
</pre>
<p>同时遍历两个或更多的序列，可以使用&nbsp;
<code>zip()</code>&nbsp;组合：
</p>
<pre>
<code>questions = ['name', 'quest', 'favorite color']
<br  />answers = ['lancelot', 'the holy grail', 'blue']
<br  />for q, a in zip(questions, answers):
<br  /> &nbsp; &nbsp;print('What is your {0}? &nbsp;It is {1}.'.format(q, a))</code>
</pre>
<p>要反向遍历一个序列，首先指定这个序列，然后调用&nbsp;
<code>reversed()</code>&nbsp;函数：
</p>
<pre>
<code>for i in reversed(range(1, 10, 2)):
<br  /> &nbsp; &nbsp;print(i)</code>
</pre>
<p>要按顺序遍历一个序列，使用&nbsp;
<code>sorted()</code>&nbsp;函数返回一个已排序的序列，并不修改原值：
</p>
<pre>
<code>basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
<br  />for f in sorted(set(basket)):
<br  /> &nbsp; &nbsp;print(f)</code>
</pre>
<h3 style="font-size: 20px;">while 循环</h3>
<p>
</p>
<pre>
<code>while&lt;条件&gt;：
<br  /> &nbsp; &nbsp;&lt;语句1&gt;
<br  />else：
<br  /> &nbsp; &nbsp;&lt;语句2&gt;</code>
</pre>
<h3 style="font-size: 20px;">break、continue、pass</h3>
<p>break 语句用在 while 和 for 循环中，break 语句用来终止循环语句，即循环条件没有 False 条件或者序列还没被完全递归完，也会停止执行循环语句。 　　 continue 语句用在 while 和 for 循环中，continue 语句用来告诉 Python 跳过当前循环的剩余语句，然后继续进行下一轮循环。 continue 语句跳出本次循环，而 break 跳出整个循环。
</p>

<p>pass 是空语句，是为了保持程序结构的完整性。pass 不做任何事情，一般用做占位语句。
</p>

<h2>
<span style="background-color: rgb(255, 251, 0);">

<h3>迭代器</h3>
</h2>
<p>

<span style="font-size: 24px;color: rgb(171, 25, 66);">
<br  />
</p>
<ul style="" class=" list-paddingleft-2">
<li>
<p>迭代器是一个可以记住遍历的位置的对象。
</p>
</li>
<li>
<p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。
</p>
</li>
<li>
<p>迭代器有两个基本的方法：
<code>iter()</code>&nbsp;和&nbsp;
<code>next()</code>。
</p>
</li>
<li>
<p>字符串，列表或元组对象都可用于创建迭代器。
</p>
</li>
</ul>
<p>迭代器可以被 for 循环进行遍历：
</p>
<pre>
<code>li = [1, 2, 3]
<br  />it = iter(li)
<br  />for val in it:
<br  /> &nbsp; &nbsp;print(val)</code>
</pre>
<p>迭代器也可以用 next() 函数访问下一个元素值：
</p>
<pre>
<code>import sys
<br  />
<br  />li = [1,2,3,4]
<br  />it = iter(li)
<br  />
<br  />while True:
<br  /> &nbsp; &nbsp;try:
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;print (next(it))
<br  /> &nbsp; &nbsp;except StopIteration:
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;sys.exit()</code>
</pre>
<h2>
<span style="background-color: rgb(255, 251, 0);">

<h3>生成器</h3>
</h2>
<p>

<span style="font-size: 24px;color: rgb(171, 25, 66);">
<br  />
</p>
<ul style="" class=" list-paddingleft-2">
<li>
<p>在 Python 中，使用了 yield 的函数被称为生成器（generator）。
</p>
</li>
<li>
<p>跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。
</p>
</li>
<li>
<p>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。
</p>
</li>
<li>
<p>调用一个生成器函数，返回的是一个迭代器对象。
</p>
</li>
</ul>
<pre>
<code>import sys
<br  />
<br  />
<span class="hljs-function" style="color: rgb(249, 38, 114);">
<span class="hljs-keyword" style="color: rgb(249, 38, 114);color: rgb(102, 217, 239);">def 
<span class="hljs-title" style="color: rgb(166, 226, 46);">fibonacci
<span class="hljs-params" style="color: rgb(248, 248, 242);">(n): 
# 生成器函数 - 斐波那契
<br  /> &nbsp; &nbsp;a, b, counter = 0, 1, 0
<br  /> &nbsp; &nbsp;while True:
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;if (counter &gt; n): 
<br  /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;yield a
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;a, b = b, a + b
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;counter += 1
<br  />f = fibonacci(10) 
# f 是一个迭代器，由生成器返回生成
<br  />
<br  />while True:
<br  /> &nbsp; &nbsp;try:
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;print(next(f))
<br  /> &nbsp; &nbsp;except StopIteration:
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;sys.exit()
<br  /></code>
</pre>
<h2>
<span style="color: rgb(171, 25, 66);font-size: 24px;background-color: rgb(255, 251, 0);">
函数
</h2>
<p>
<br  />
</p>
<h3 style="font-size: 20px;">自定义函数</h3>
<p>函数（Functions）是指可重复使用的程序片段。它们允许你为某个代码块赋予名字，允许你通过这一特殊的名字在你的程序任何地方来运行代码块，并可重复任何次数。这就是所谓的调用（Calling）函数。
</p>

<ul style="" class=" list-paddingleft-2">
<li>
<p>函数代码块以&nbsp;
<code>def</code>&nbsp;关键词开头，后接函数标识符名称和圆括号&nbsp;
<code>()</code>。
</p>
</li>
<li>
<p>任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。
</p>
</li>
<li>
<p>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。
</p>
</li>
<li>
<p>函数内容以冒号起始，并且缩进。
</p>
</li>
<li>
<p>
<code>return [表达式]</code>&nbsp;结束函数，选择性地返回一个值给调用方。不带表达式的 return 相当于返回 None。
</p>
</li>
<li>
<p>
<code>return</code>&nbsp;可以返回多个值，此时返回的数据未元组类型。
</p>
</li>
<li>
<p>定义参数时，带默认值的参数必须在无默认值参数的后面。
</p>
</li>
</ul>
<pre>
<code>
<span class="hljs-function" style="color: rgb(249, 38, 114);">
<span class="hljs-keyword" style="color: rgb(249, 38, 114);color: rgb(102, 217, 239);">def 函数名（参数列表）:
<br  /> &nbsp; &nbsp;函数体</code>
</pre>
<h3 style="font-size: 20px;">参数传递</h3>
<p>在 Python 中，类型属于对象，变量是没有类型的：
</p>

<pre>
<code>a = [1,2,3]
<br  />a = "Runoob"</code>
</pre>
<p>以上代码中，[1,2,3] 是 List 类型，”Runoob” 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是指向 List 类型对象，也可以是指向 String 类型对象。
</p>

<h4>
可更改与不可更改对象
</h4>
<p>在 Python 中，字符串，数字和元组是不可更改的对象，而列表、字典等则是可以修改的对象。
</p>

<ul style="" class=" list-paddingleft-2">
<li>
<p>
不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。
</p>
</li>
<li>
<p>
可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。
</p>
</li>
</ul>
<p>Python 函数的参数传递：
</p>
<ul style="" class=" list-paddingleft-2">
<li>
<p>
不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。
</p>
</li>
<li>
<p>
可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响
</p>
</li>
</ul>
<p>
Python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。
</p>
<h3 style="font-size: 20px;">参数</h3>
<h4>
必需参数
</h4>
<p>必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。
</p>

<h4>
关键字参数
</h4>
<p>关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。 使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。
</p>

<pre>
<code>
<span class="hljs-function" style="color: rgb(249, 38, 114);">
<span class="hljs-keyword" style="color: rgb(249, 38, 114);color: rgb(102, 217, 239);">def 
<span class="hljs-title" style="color: rgb(166, 226, 46);">print_info
<span class="hljs-params" style="color: rgb(248, 248, 242);">(name, age):
<br  /> &nbsp; &nbsp;"打印任何传入的字符串"
<br  /> &nbsp; &nbsp;print("名字: ", name)
<br  /> &nbsp; &nbsp;print("年龄: ", age)
<br  /> &nbsp; &nbsp;return
<br  />print_info(age=50, name="john")</code>
</pre>
<h4>
默认参数
</h4>
<p>调用函数时，如果没有传递参数，则会使用默认参数。
</p>
<pre>
<code>
<span class="hljs-function" style="color: rgb(249, 38, 114);">
<span class="hljs-keyword" style="color: rgb(249, 38, 114);color: rgb(102, 217, 239);">def 
<span class="hljs-title" style="color: rgb(166, 226, 46);">print_info
<span class="hljs-params" style="color: rgb(248, 248, 242);">(name, age=35):
<br  /> &nbsp; &nbsp;print ("名字: ", name)
<br  /> &nbsp; &nbsp;print ("年龄: ", age)
<br  /> &nbsp; &nbsp;return
<br  />print_info(age=50, name="john")
<br  />print("------------------------")
<br  />print_info(name="john")</code>
</pre>
<h4>
不定长参数
</h4>
<ul style="" class=" list-paddingleft-2">
<li>
<p>加了星号&nbsp;
<code>*</code>&nbsp;的参数会以元组的形式导入，存放所有未命名的变量参数。
</p>
</li>
<li>
<p>如果在函数调用时没有指定参数，它就是一个空元组。我们也可以不向函数传递未命名的变量。
</p>
</li>
</ul>
<pre>
<code>
<span class="hljs-function" style="color: rgb(249, 38, 114);">
<span class="hljs-keyword" style="color: rgb(249, 38, 114);color: rgb(102, 217, 239);">def 
<span class="hljs-title" style="color: rgb(166, 226, 46);">print_info
<span class="hljs-params" style="color: rgb(248, 248, 242);">(arg1, *vartuple):
<br  /> &nbsp; &nbsp;print("输出: ")
<br  /> &nbsp; &nbsp;print(arg1)
<br  /> &nbsp; &nbsp;for var in vartuple:
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;print (var)
<br  /> &nbsp; &nbsp;return
<br  />print_info(10)
<br  />print_info(70, 60, 50)</code>
</pre>
<ul style="" class=" list-paddingleft-2">
<li>
<p>加了两个星号&nbsp;
<code>**</code>&nbsp;的参数会以字典的形式导入。变量名为键，变量值为字典元素值。
</p>
</li>
</ul>
<pre>
<code>
<span class="hljs-function" style="color: rgb(249, 38, 114);">
<span class="hljs-keyword" style="color: rgb(249, 38, 114);color: rgb(102, 217, 239);">def 
<span class="hljs-title" style="color: rgb(166, 226, 46);">print_info
<span class="hljs-params" style="color: rgb(248, 248, 242);">(arg1, **vardict):
<br  /> &nbsp; &nbsp;print("输出: ")
<br  /> &nbsp; &nbsp;print(arg1)
<br  /> &nbsp; &nbsp;print(vardict)
<br  />print_info(1, a=2, b=3)</code>
</pre>
<h3 style="font-size: 20px;">匿名函数</h3>
<p>Python 使用 lambda 来创建匿名函数。
</p>

<p>所谓匿名，意即不再使用&nbsp;
<code>def</code>&nbsp;语句这样标准的形式定义一个函数。
</p>
<p>lambda 只是一个表达式，函数体比 def 简单很多。 lambda 的主体是一个表达式，而不是一个代码块。仅仅能在 lambda 表达式中封装有限的逻辑进去。 lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。 虽然 lambda 函数看起来只能写一行，却不等同于 C 或 C++ 的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。
</p>
<pre>
<code>
# 语法格式
<br  />lambda [arg1 [,arg2,.....argn]]:expression</code>
</pre>
<h2>
<span style="background-color: rgb(255, 251, 0);">

<span style="background-color: rgb(255, 251, 0);color: rgb(171, 25, 66);font-size: 24px;">变量作用域
</h2>
<p>

<span style="color: rgb(171, 25, 66);font-size: 24px;">
<br  />
</p>
<ul style="" class=" list-paddingleft-2">
<li>
<p>L （Local） 局部作用域
</p>
</li>
<li>
<p>E （Enclosing） 闭包函数外的函数中
</p>
</li>
<li>
<p>G （Global） 全局作用域
</p>
</li>
<li>
<p>B （Built-in） 内建作用域
</p>
</li>
</ul>
<p>以 L –&gt; E –&gt; G –&gt; B 的规则查找，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内建中找。
</p>
<p>Python 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如 if/elif/else/、try/except、for/while等）是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问。
</p>
<p>定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。
</p>
<p>局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。
</p>
<p>当内部作用域想修改外部作用域的变量时，就要用到global和nonlocal关键字。
</p>
<pre>
<code>num = 1
<br  />
<span class="hljs-function" style="color: rgb(249, 38, 114);">
<span class="hljs-keyword" style="color: rgb(249, 38, 114);color: rgb(102, 217, 239);">def 
<span class="hljs-title" style="color: rgb(166, 226, 46);">fun1
<span class="hljs-params" style="color: rgb(248, 248, 242);">():
<br  /> &nbsp; &nbsp;global num &nbsp;
# 需要使用 global 关键字声明
<br  /> &nbsp; &nbsp;print(num) 
<br  /> &nbsp; &nbsp;num = 123
<br  /> &nbsp; &nbsp;print(num)
<br  />fun1()</code>
</pre>
<p>如果要修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量则需要 nonlocal 关键字。
</p>
<pre>
<code>
<span class="hljs-function" style="color: rgb(249, 38, 114);">
<span class="hljs-keyword" style="color: rgb(249, 38, 114);color: rgb(102, 217, 239);">def 
<span class="hljs-title" style="color: rgb(166, 226, 46);">outer
<span class="hljs-params" style="color: rgb(248, 248, 242);">():
<br  /> &nbsp; &nbsp;num = 10
<br  /> &nbsp; &nbsp;
<span class="hljs-function" style="color: rgb(249, 38, 114);">
<span class="hljs-keyword" style="color: rgb(249, 38, 114);color: rgb(102, 217, 239);">def 
<span class="hljs-title" style="color: rgb(166, 226, 46);">inner
<span class="hljs-params" style="color: rgb(248, 248, 242);">():
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;nonlocal num &nbsp; 
# nonlocal关键字声明
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;num = 100
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;print(num)
<br  /> &nbsp; &nbsp;inner()
<br  /> &nbsp; &nbsp;print(num)
<br  />outer()</code>
</pre>
<h2>
<span style="color: rgb(171, 25, 66);background-color: rgb(255, 251, 0);">

<span style="color: rgb(171, 25, 66);background-color: rgb(255, 251, 0);font-size: 24px;">模块
</h2>
<p>
<span style="color: rgb(171, 25, 66);">

<span style="font-size: 24px;">
<br  />
</p>
<p>编写模块有很多种方法，其中最简单的一种便是创建一个包含函数与变量、以 .py 为后缀的文件。
</p>
<p>另一种方法是使用撰写 Python 解释器本身的本地语言来编写模块。举例来说，你可以使用 C 语言来撰写 Python 模块，并且在编译后，你可以通过标准 Python 解释器在你的 Python 代码中使用它们。
</p>
<p>模块是一个包含所有你定义的函数和变量的文件，其后缀名是
<code>.py</code>。模块可以被别的程序引入，以使用该模块中的函数等功能。这也是使用 Python 标准库的方法。
</p>
<p>当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。
</p>
<p>搜索路径是一个解释器会先进行搜索的所有目录的列表。如想要导入模块，需要把命令放在脚本的顶端。
</p>
<p>一个模块只会被导入一次，这样可以防止导入模块被一遍又一遍地执行。
</p>
<p>搜索路径被存储在 sys 模块中的 path 变量。当前目录指的是程序启动的目录。
</p>

<h3 style="font-size: 20px;">导入模块</h3>
<p>导入模块：
</p>
<pre>
<code>import module1[, module2[,... moduleN]
<span style="color: rgb(248, 248, 242);font-family: Consolas, Inconsolata, Courier, monospace;font-size: 11.56px;white-space: pre;background-color: rgb(35, 36, 31);">]</code>
</pre>
<p>从模块中导入一个指定的部分到当前命名空间中：
</p>
<pre>
<code>from modname import name1[, name2[, ... nameN]
<span style="color: rgb(248, 248, 242);font-family: Consolas, Inconsolata, Courier, monospace;font-size: 11.56px;white-space: pre;background-color: rgb(35, 36, 31);">]</code>
</pre>
<p>把一个模块的所有内容全都导入到当前的命名空间：
</p>
<pre>
<code>from modname import *</code>
</pre>
<h3 style="font-size: 20px;">__name__ 属性</h3>
<p>每个模块都有一个&nbsp;
<code>__name__</code>&nbsp;属性，当其值是&nbsp;
<code>'__main__'</code>&nbsp;时，表明该模块自身在运行，否则是被引入。
</p>
<p>一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用&nbsp;
<code>__name__</code>&nbsp;属性来使该程序块仅在该模块自身运行时执行。
</p>

<pre>
<code>if __name__ == '__main__':
<br  /> &nbsp; &nbsp;print('程序自身在运行')
<br  />else:
<br  /> &nbsp; &nbsp;print('我来自另一模块')</code>
</pre>
<h3 style="font-size: 20px;">dir 函数</h3>
<p>内置的函数&nbsp;
<code>dir()</code>&nbsp;可以找到模块内定义的所有名称。以一个字符串列表的形式返回。
</p>
<p>如果没有给定参数，那么&nbsp;
<code>dir()</code>&nbsp;函数会罗列出当前定义的所有名称。
</p>
<p>在 Python 中万物皆对象，
<code>int</code>、
<code>str</code>、
<code>float</code>、
<code>list</code>、
<code>tuple</code>等内置数据类型其实也是类，也可以用&nbsp;
<code>dir(int)</code>&nbsp;查看&nbsp;
<code>int</code>&nbsp;包含的所有方法。也可以使用&nbsp;
<code>help(int)</code>&nbsp;查看&nbsp;
<code>int</code>&nbsp;类的帮助信息。
</p>

<h3 style="font-size: 20px;">包</h3>
<p>包是一种管理 Python 模块命名空间的形式，采用”点模块名称”。
</p>
<p>比如一个模块的名称是 A.B， 那么他表示一个包 A中的子模块 B 。
</p>
<p>就好像使用模块的时候，你不用担心不同模块之间的全局变量相互影响一样，采用点模块名称这种形式也不用担心不同库之间的模块重名的情况。
</p>
<p>在导入一个包的时候，Python 会根据 sys.path 中的目录来寻找这个包中包含的子目录。
</p>
<p>目录只有包含一个叫做&nbsp;
<code>__init__.py</code>&nbsp;的文件才会被认作是一个包，主要是为了避免一些滥俗的名字（比如叫做 string）不小心的影响搜索路径中的有效模块。
</p>
<p>最简单的情况，放一个空的&nbsp;
<code>__init__.py</code>&nbsp;文件就可以了。当然这个文件中也可以包含一些初始化代码或者为&nbsp;
<code>__all__</code>&nbsp;变量赋值。
</p>

<h3 style="font-size: 20px;">第三方模块</h3>
<ul style="" class=" list-paddingleft-2">
<li>
<p>easy_install 和 pip 都是用来下载安装 Python 一个公共资源库 PyPI 的相关资源包的，pip 是 easy_install 的改进版，提供更好的提示信息，删除 package 等功能。老版本的 python 中只有 easy_install，没有pip。
</p>
</li>
<li>
<p>easy_install 打包和发布 Python 包，pip 是包管理。
</p>
</li>
</ul>
<p>
easy_install 的用法：
</p>
<ul style="" class=" list-paddingleft-2">
<li>
<p>安装一个包
</p>
<figure class="hljs nginx highlight" style="margin-top: 1em;margin-bottom: 1em;border-radius: 5px;overflow-x: auto;box-shadow: rgba(0, 0, 0, 0.125) 1px 1px 2px;">
</figure>
</li>
<pre>
<code>easy_install 包名
<br  />easy_install "包名 == 包的版本号"</code>
</pre>
<li>
<p>升级一个包
</p>
</li>
<pre>
<code>easy_install -U "包名 &gt;= 包的版本号"</code>
</pre>
<span style="color: rgb(248, 248, 242);font-family: Consolas, Inconsolata, Courier, monospace;font-size: 11.56px;white-space: pre;background-color: rgb(35, 36, 31);">
</ul>
<p>
pip 的用法：
</p>
<ul style="" class=" list-paddingleft-2">
<li>
<p>安装一个包
</p>
<figure class="hljs sql highlight" style="margin-top: 1em;margin-bottom: 1em;border-radius: 5px;overflow-x: auto;box-shadow: rgba(0, 0, 0, 0.125) 1px 1px 2px;">
</figure>
</li>
<pre>
<code>pip install 包名pip install 包名 == 包的版本号</code>
</pre>
<li>
<p>升级一个包 （如果不提供version号，升级到最新版本）
</p>
</li>
<pre>
<code>pip install —upgrade 包名 &gt;= 包的版本号</code>
</pre>
<li>
<p>删除一个包
</p>
<figure class="hljs sql highlight" style="margin-top: 1em;margin-bottom: 1em;border-radius: 5px;overflow-x: auto;box-shadow: rgba(0, 0, 0, 0.125) 1px 1px 2px;">
</figure>
</li>
<pre>
<code>pip uninstall 包名</code>
</pre>
<li>
<p>已安装包列表
</p>
<figure class="hljs php highlight" style="margin-top: 1em;margin-bottom: 1em;border-radius: 5px;overflow-x: auto;box-shadow: rgba(0, 0, 0, 0.125) 1px 1px 2px;">
</figure>
</li>
<pre>
<code>pip list</code>
</pre>
</ul>
<h2>
<span style="background-color: rgb(255, 251, 0);">

<h3>面向对象</h3>
</h2>

<p>类与对象是面向对象编程的两个主要方面。一个
类（Class）能够创建一种新的类型（Type），其中
对象（Object）就是类的
实例（Instance）。可以这样来类比：你可以拥有类型&nbsp;
<code>int</code>&nbsp;的变量，也就是说存储整数的变量是&nbsp;
<code>int</code>&nbsp;类的实例（对象）。
</p>

<ul style="" class=" list-paddingleft-2">
<li>
<p>
类(Class)：用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。
</p>
</li>
<li>
<p>
方法：类中定义的函数。
</p>
</li>
<li>
<p>
类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。
</p>
</li>
<li>
<p>
数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。
</p>
</li>
<li>
<p>
方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。
</p>
</li>
<li>
<p>
实例变量：定义在方法中的变量，只作用于当前实例的类。
</p>
</li>
<li>
<p>
继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。
</p>
</li>
<li>
<p>
实例化：创建一个类的实例，类的具体对象。
</p>
</li>
<li>
<p>
对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。
</p>
</li>
</ul>
<p>Python 中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。
</p>
<p>对象可以包含任意数量和类型的数据。
</p>

<h3 style="font-size: 20px;">self</h3>
<p>
<code>self</code>&nbsp;表示的是当前实例，代表当前对象的地址。类由&nbsp;
<code>self.__class__</code>&nbsp;表示。
</p>
<p>
<code>self</code>&nbsp;不是关键字，其他名称也可以替代，但&nbsp;
<code>self</code>&nbsp;是个通用的标准名称。
</p>

<h3 style="font-size: 20px;">类</h3>
<p>类由&nbsp;
<code>class</code>&nbsp;关键字来创建。 类实例化后，可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性。
</p>

<h3 style="font-size: 20px;">对象方法</h3>
<p>方法由&nbsp;
<code>def</code>&nbsp;关键字定义，与函数不同的是，方法必须包含参数&nbsp;
<code>self</code>, 且为第一个参数，
<code>self</code>&nbsp;代表的是本类的实例。
</p>

<h3 style="font-size: 20px;">类方法</h3>
<p>装饰器&nbsp;
<code>@classmethod</code>&nbsp;可以将方法标识为类方法。类方法的第一个参数必须为&nbsp;
<code>cls</code>，而不再是&nbsp;
<code>self</code>。
</p>

<h3 style="font-size: 20px;">静态方法</h3>
<p>装饰器&nbsp;
<code>@staticmethod</code>&nbsp;可以将方法标识为静态方法。静态方法的第一个参数不再指定，也就不需要&nbsp;
<code>self</code>&nbsp;或&nbsp;
<code>cls</code>。
</p>

<h3 style="font-size: 20px;">__init__ 方法</h3>
<p>
<code>__init__</code>&nbsp;方法即构造方法，会在类的对象被实例化时先运行，可以将初始化的操作放置到该方法中。
</p>
<p>如果重写了&nbsp;
<code>__init__</code>，实例化子类就不会调用父类已经定义的&nbsp;
<code>__init__</code>。
</p>

<h3 style="font-size: 20px;">变量</h3>
<p>
<code>类变量</code>（Class Variable）是共享的（Shared）——它们可以被属于该类的所有实例访问。该类变量只拥有一个副本，当任何一个对象对类变量作出改变时，发生的变动将在其它所有实例中都会得到体现。
</p>
<p>
<code>对象变量</code>（Object variable）由类的每一个独立的对象或实例所拥有。在这种情况下，每个对象都拥有属于它自己的字段的副本，也就是说，它们不会被共享，也不会以任何方式与其它不同实例中的相同名称的字段产生关联。
</p>
<p>在 Python 中，变量名类似&nbsp;
<code>__xxx__</code>&nbsp;的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是 private 变量，所以，不能用&nbsp;
<code>__name__</code>、
<code>__score__</code>&nbsp;这样的变量名。
</p>

<h3 style="font-size: 20px;">访问控制</h3>
<ul style="" class=" list-paddingleft-2">
<li>
<p>私有属性
</p>
<p>
<code>__private_attr</code>：两个下划线开头，声明该属性为私有，不能在类地外部被使用或直接访问。
</p>
</li>
<li>
<p>私有方法
</p>
<p>
<code>__private_method</code>：两个下划线开头，声明该方法为私有方法，只能在类的内部调用，不能在类地外部调用。
</p>
</li>
</ul>
<p>我们还认为约定，一个下划线开头的属性或方法为
<code>受保护</code>的。比如，
<code>_protected_attr</code>、
<code>_protected_method</code>。
</p>

<h3 style="font-size: 20px;">继承</h3>
<p>类可以继承，并且支持继承多个父类。在定义类时，类名后的括号中指定要继承的父类，多个父类之间用逗号分隔。
</p>
<p>子类的实例可以完全访问所继承所有父类的非私有属性和方法。
</p>
<p>若是父类中有相同的方法名，而在子类使用时未指定，Python 从左至右搜索，即方法在子类中未找到时，从左到右查找父类中是否包含方法。
</p>

<h3 style="font-size: 20px;">方法重写</h3>
<p>子类的方法可以重写父类的方法。重写的方法参数不强制要求保持一致，不过合理的设计都应该保持一致。
</p>
<p>
<code>super()</code>&nbsp;函数可以调用父类的一个方法，以多继承问题。
</p>

<h3 style="font-size: 20px;">类的专有方法：</h3>
<ul style="" class=" list-paddingleft-2">
<li>
<p>
<code>__init__</code>: 构造函数，在生成对象时调用
</p>
</li>
<li>
<p>
<code>__del__</code>: 析构函数，释放对象时使用
</p>
</li>
<li>
<p>
<code>__repr__</code>: 打印，转换
</p>
</li>
<li>
<p>
<code>__setitem__</code>: 按照索引赋值
</p>
</li>
<li>
<p>
<code>__getitem__</code>: 按照索引获取值
</p>
</li>
<li>
<p>
<code>__len__</code>: 获得长度
</p>
</li>
<li>
<p>
<code>__cmp__</code>: 比较运算
</p>
</li>
<li>
<p>
<code>__call__</code>: 函数调用
</p>
</li>
<li>
<p>
<code>__add__</code>: 加运算
</p>
</li>
<li>
<p>
<code>__sub__</code>: 减运算
</p>
</li>
<li>
<p>
<code>__mul__</code>: 乘运算
</p>
</li>
<li>
<p>
<code>__div__</code>: 除运算
</p>
</li>
<li>
<p>
<code>__mod__</code>: 求余运算
</p>
</li>
<li>
<p>
<code>__pow__</code>: 乘方
</p>
</li>
</ul>
<p>类的专有方法也支持重载。
</p>
<h3 style="font-size: 20px;">
<br  /></h3>
<h3 style="font-size: 20px;">实例</h3>
<pre>
<code>
<span class="hljs-class">
<span class="hljs-keyword" style="color: rgb(249, 38, 114);color: rgb(102, 217, 239);">class 
<span class="hljs-title" style="color: rgb(166, 226, 46);font-style: italic;color: rgb(248, 248, 242);">Person:
<br  /> &nbsp; &nbsp;"""人员信息"""
<br  /> &nbsp; &nbsp;
# 姓名(共有属性)
<br  /> &nbsp; &nbsp;name = ''
<br  /> &nbsp; &nbsp;
# 年龄(共有属性)
<br  /> &nbsp; &nbsp;age = 0
<br  /> &nbsp; &nbsp;
<span class="hljs-function" style="color: rgb(249, 38, 114);">
<span class="hljs-keyword" style="color: rgb(249, 38, 114);color: rgb(102, 217, 239);">def 
<span class="hljs-title" style="color: rgb(166, 226, 46);">__init__
<span class="hljs-params" style="color: rgb(248, 248, 242);">(self, name='', age=0):
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;self.name = name
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;self.age = age
<br  /> &nbsp; &nbsp;
# 重载专有方法: __str__
<br  /> &nbsp; &nbsp;
<span class="hljs-function" style="color: rgb(249, 38, 114);">
<span class="hljs-keyword" style="color: rgb(249, 38, 114);color: rgb(102, 217, 239);">def 
<span class="hljs-title" style="color: rgb(166, 226, 46);">__str__
<span class="hljs-params" style="color: rgb(248, 248, 242);">(self):
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;return "这里重载了 __str__ 专有方法, " + str({'name': self.name, 'age': self.age})
<br  /> &nbsp; &nbsp;
<span class="hljs-function" style="color: rgb(249, 38, 114);">
<span class="hljs-keyword" style="color: rgb(249, 38, 114);color: rgb(102, 217, 239);">def 
<span class="hljs-title" style="color: rgb(166, 226, 46);">set_age
<span class="hljs-params" style="color: rgb(248, 248, 242);">(self, age):
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;self.age = age
<br  />
<span class="hljs-class">
<span class="hljs-keyword" style="color: rgb(249, 38, 114);color: rgb(102, 217, 239);">class 
<span class="hljs-title" style="color: rgb(166, 226, 46);font-style: italic;color: rgb(248, 248, 242);">Account:
<br  /> &nbsp; &nbsp;"""账户信息"""
<br  /> &nbsp; &nbsp;
# 账户余额(私有属性)
<br  /> &nbsp; &nbsp;__balance = 0
<br  /> &nbsp; &nbsp;
# 所有账户总额
<br  /> &nbsp; &nbsp;__total_balance = 0
<br  /> &nbsp; &nbsp;
# 获取账户余额
<br  /> &nbsp; &nbsp;
# self 必须是方法的第一个参数
<br  /> &nbsp; &nbsp;
<span class="hljs-function" style="color: rgb(249, 38, 114);">
<span class="hljs-keyword" style="color: rgb(249, 38, 114);color: rgb(102, 217, 239);">def 
<span class="hljs-title" style="color: rgb(166, 226, 46);">balance
<span class="hljs-params" style="color: rgb(248, 248, 242);">(self):
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;return self.__balance
<br  /> &nbsp; &nbsp;
# 增加账户余额
<br  /> &nbsp; &nbsp;
<span class="hljs-function" style="color: rgb(249, 38, 114);">
<span class="hljs-keyword" style="color: rgb(249, 38, 114);color: rgb(102, 217, 239);">def 
<span class="hljs-title" style="color: rgb(166, 226, 46);">balance_add
<span class="hljs-params" style="color: rgb(248, 248, 242);">(self, cost):
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;
# self 访问的是本实例
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;self.__balance += cost
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;
# self.__class__ 可以访问类
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;self.__class__.__total_balance += cost
<br  /> &nbsp; &nbsp;
# 类方法(用 @classmethod 标识，第一个参数为 cls)
<br  /> &nbsp; &nbsp;
<span class="hljs-decorator" style="color: rgb(117, 113, 94);">@classmethod
<br  /> &nbsp; &nbsp;
<span class="hljs-function" style="color: rgb(249, 38, 114);">
<span class="hljs-keyword" style="color: rgb(249, 38, 114);color: rgb(102, 217, 239);">def 
<span class="hljs-title" style="color: rgb(166, 226, 46);">total_balance
<span class="hljs-params" style="color: rgb(248, 248, 242);">(cls):
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;return cls.__total_balance
<br  /> &nbsp; &nbsp;
# 静态方法(用 @staticmethod 标识，不需要类参数或实例参数)
<br  /> &nbsp; &nbsp;
<span class="hljs-decorator" style="color: rgb(117, 113, 94);">@staticmethod
<br  /> &nbsp; &nbsp;
<span class="hljs-function" style="color: rgb(249, 38, 114);">
<span class="hljs-keyword" style="color: rgb(249, 38, 114);color: rgb(102, 217, 239);">def 
<span class="hljs-title" style="color: rgb(166, 226, 46);">exchange
<span class="hljs-params" style="color: rgb(248, 248, 242);">(a, b):
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;return b, a
<br  />
<span class="hljs-class">
<span class="hljs-keyword" style="color: rgb(249, 38, 114);color: rgb(102, 217, 239);">class 
<span class="hljs-title" style="color: rgb(166, 226, 46);color: rgb(248, 248, 242);">Teacher(Person, Account):
<br  /> &nbsp; &nbsp;"""教师"""
<br  /> &nbsp; &nbsp;
# 班级名称
<br  /> &nbsp; &nbsp;_class_name = ''
<br  /> &nbsp; &nbsp;
<span class="hljs-function" style="color: rgb(249, 38, 114);">
<span class="hljs-keyword" style="color: rgb(249, 38, 114);color: rgb(102, 217, 239);">def 
<span class="hljs-title" style="color: rgb(166, 226, 46);">__init__
<span class="hljs-params" style="color: rgb(248, 248, 242);">(self, name):
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;
# 第一种重载父类__init__()构造方法
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;
# super(子类，self).__init__(参数1，参数2，....)
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;super(Teacher, self).__init__(name)
<br  /> &nbsp; &nbsp;
<span class="hljs-function" style="color: rgb(249, 38, 114);">
<span class="hljs-keyword" style="color: rgb(249, 38, 114);color: rgb(102, 217, 239);">def 
<span class="hljs-title" style="color: rgb(166, 226, 46);">get_info
<span class="hljs-params" style="color: rgb(248, 248, 242);">(self):
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;
# 以字典的形式返回个人信息
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;return {
<br  /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;'name': self.name, &nbsp;
# 此处访问的是父类Person的属性值
<br  /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;'age': self.age,
<br  /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;'class_name': self._class_name,
<br  /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;'balance': self.balance(), &nbsp;
# 此处调用的是子类重载过的方法
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;}
<br  /> &nbsp; &nbsp;
# 方法重载
<br  /> &nbsp; &nbsp;
<span class="hljs-function" style="color: rgb(249, 38, 114);">
<span class="hljs-keyword" style="color: rgb(249, 38, 114);color: rgb(102, 217, 239);">def 
<span class="hljs-title" style="color: rgb(166, 226, 46);">balance
<span class="hljs-params" style="color: rgb(248, 248, 242);">(self):
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;
# Account.__balance 为私有属性，子类无法访问，所以父类提供方法进行访问
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;return Account.balance(self) * 1.1
<br  />
<span class="hljs-class">
<span class="hljs-keyword" style="color: rgb(249, 38, 114);color: rgb(102, 217, 239);">class 
<span class="hljs-title" style="color: rgb(166, 226, 46);color: rgb(248, 248, 242);">Student(Person, Account):
<br  /> &nbsp; &nbsp;"""学生"""
<br  /> &nbsp; &nbsp;_teacher_name = ''
<br  /> &nbsp; &nbsp;
<span class="hljs-function" style="color: rgb(249, 38, 114);">
<span class="hljs-keyword" style="color: rgb(249, 38, 114);color: rgb(102, 217, 239);">def 
<span class="hljs-title" style="color: rgb(166, 226, 46);">__init__
<span class="hljs-params" style="color: rgb(248, 248, 242);">(self, name, age=18):
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;
# 第二种重载父类__init__()构造方法
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;
# 父类名称.__init__(self,参数1，参数2，...)
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;Person.__init__(self, name, age)
<br  /> &nbsp; &nbsp;
<span class="hljs-function" style="color: rgb(249, 38, 114);">
<span class="hljs-keyword" style="color: rgb(249, 38, 114);color: rgb(102, 217, 239);">def 
<span class="hljs-title" style="color: rgb(166, 226, 46);">get_info
<span class="hljs-params" style="color: rgb(248, 248, 242);">(self):
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;
# 以字典的形式返回个人信息
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;return {
<br  /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;'name': self.name, &nbsp;
# 此处访问的是父类Person的属性值
<br  /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;'age': self.age,
<br  /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;'teacher_name': self._teacher_name,
<br  /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;'balance': self.balance(),
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;}
<br  />
# 教师 John
<br  />john = Teacher('John')
<br  />john.balance_add(20)
<br  />john.set_age(36) &nbsp;
# 子类的实例可以直接调用父类的方法
<br  />print("John's info:", john.get_info())
<br  />
# 学生 Mary
<br  />mary = Student('Mary', 18)
<br  />mary.balance_add(18)
<br  />print("Mary's info:", mary.get_info())
<br  />
# 学生 Fake
<br  />fake = Student('Fake')
<br  />fake.balance_add(30)
<br  />print("Fake's info", fake.get_info())
<br  />
# 三种不同的方式调用静态方法
<br  />print("john.exchange('a', 'b'):", john.exchange('a', 'b'))
<br  />print('Teacher.exchange(1, 2)', Teacher.exchange(1, 2))
<br  />print('Account.exchange(10, 20):', Account.exchange(10, 20))
<br  />
# 类方法、类属性
<br  />print('Account.total_balance():', Account.total_balance())
<br  />print('Teacher.total_balance():', Teacher.total_balance())
<br  />print('Student.total_balance():', Student.total_balance())
<br  />
# 重载专有方法
<br  />print(fake)</code>
</pre>
<p>
输出：
</p>
<p>

</p>
<pre>
<code>John's info: {'name': 'John', 'age': 36, 'class_name': '', 'balance': 22.0}Mary's info: {'name': 'Mary', 'age': 18, 'teacher_name': '', 'balance': 18}Fake's info {'name': 'Fake', 'age': 18, 'teacher_name': '', 'balance': 30}john.exchange('a', 'b'): ('b', 'a')Teacher.exchange(1, 2) (2, 1)Account.exchange(10, 20): (20, 10)Account.total_balance(): 0Teacher.total_balance(): 20Student.total_balance(): 48这里重载了 __str__ 专有方法, {'name': 'Fake', 'age': 18}</code>
</pre>
<p>

</p>
<h2>
<span style="background-color: rgb(255, 251, 0);">

<h3>错误和异常</h3>
</h2>
<h3 style="font-size: 20px;"><br  /></h3>
<h3 style="font-size: 20px;">语法错误</h3>
<p>SyntaxError 类表示语法错误，当解释器发现代码无法通过语法检查时会触发的错误。语法错误是无法用&nbsp;
<code>try...except...</code>捕获的。
</p>

<pre>
<code>
<span class="hljs-prompt" style="color: rgb(230, 219, 116);">&gt;&gt;&gt; print:
<br  /> &nbsp;File "&lt;stdin&gt;", line 1
<br  /> &nbsp; &nbsp;print:
<br  /> &nbsp; &nbsp; &nbsp; &nbsp; ^
<br  />SyntaxError: invalid syntax</code>
</pre>
<h3 style="font-size: 20px;">异常</h3>
<p>即便程序的语法是正确的，在运行它的时候，也有可能发生错误。运行时发生的错误被称为异常。 错误信息的前面部分显示了异常发生的上下文，并以调用栈的形式显示具体信息。
</p>

<pre>
<code>
<span class="hljs-prompt" style="color: rgb(230, 219, 116);">&gt;&gt;&gt; 1 + '0'
<br  />Traceback (most recent call last):
<br  /> &nbsp;File "&lt;stdin&gt;", line 1, in &lt;module&gt;
<br  />TypeError: unsupported operand type(s) for +: 'int' and 'str'</code>
</pre>
<h3 style="font-size: 20px;">异常处理</h3>
<p>
<br  />
</p>
<p>Python 提供了&nbsp;
<code>try ... except ...</code>&nbsp;的语法结构来捕获和处理异常。
</p>
<p>try 语句执行流程大致如下：
</p>
<p>
<img src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://mmbiz.qpic.cn/mmbiz_png/MQ4FoG1HmnJbicSb8Y5yANyyiaWVmXMjQR18E4uAm0hhe9qsHLdyVXPATIFDarMq4pZmka71Qlof5LMVs1JrNZZw/640">
</p>
<ul style="" class=" list-paddingleft-2">
<li>
<p>首先，执行 try 子句（在关键字 try 和关键字 except 之间的语句）
</p>
</li>
<li>
<p>如果没有异常发生，忽略 except 子句，try 子句执行后结束。
</p>
</li>
<li>
<p>如果在执行 try 子句的过程中发生了异常，那么 try 子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的 except 子句将被执行。最后执行 try 语句之后的代码。
</p>
</li>
<li>
<p>如果一个异常没有与任何的 except 匹配，那么这个异常将会传递给上层的 try 中。
</p>
</li>
<li>
<p>一个 try 语句可能包含多个 except 子句，分别来处理不同的特定的异常。
</p>
</li>
<li>
<p>
最多只有一个 except 子句会被执行。
</p>
</li>
<li>
<p>处理程序将只针对对应的 try 子句中的异常进行处理，而不是其他的 try 的处理程序中的异常。
</p>
</li>
<li>
<p>一个 except 子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组。
</p>
</li>
<li>
<p>最后一个 except 子句可以忽略异常的名称，它将被当作通配符使用。可以使用这种方法打印一个错误信息，然后再次把异常抛出。
</p>
</li>
<li>
<p>try except 语句还有一个可选的 else 子句，如果使用这个子句，那么必须放在所有的 except 子句之后。这个子句将在 try 子句没有发生任何异常的时候执行。
</p>
</li>
<li>
<p>异常处理并不仅仅处理那些直接发生在 try 子句中的异常，而且还能处理子句中调用的函数（甚至间接调用的函数）里抛出的异常。
</p>
</li>
<li>
<p>不管 try 子句里面有没有发生异常，finally 子句都会执行。
</p>
</li>
<li>
<p>如果一个异常在 try 子句里（或者在 except 和 else 子句里）被抛出，而又没有任何的 except 把它截住，那么这个异常会在 finally 子句执行后再次被抛出。
</p>
</li>
</ul>
<h3 style="font-size: 20px;">抛出异常</h3>
<p>使用&nbsp;
<code>raise</code>&nbsp;语句抛出一个指定的异常。
</p>
<p>raise 唯一的一个参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类（也就是 Exception 的子类）。
</p>
<p>如果你只想知道这是否抛出了一个异常，并不想去处理它，那么一个简单的 raise 语句就可以再次把它抛出。
</p>

<h3 style="font-size: 20px;">自定义异常</h3>
<p>可以通过创建一个新的异常类来拥有自己的异常。异常类继承自 Exception 类，可以直接继承，或者间接继承。
</p>
<p>当创建一个模块有可能抛出多种不同的异常时，一种通常的做法是为这个包建立一个基础异常类，然后基于这个基础类为不同的错误情况创建不同的子类。
</p>
<p>大多数的异常的名字都以”Error”结尾，就跟标准的异常命名一样。
</p>

<h3 style="font-size: 20px;">实例</h3>
<pre>
<code>import sys
<br  />
<span class="hljs-class">
<span class="hljs-keyword" style="color: rgb(249, 38, 114);color: rgb(102, 217, 239);">class 
<span class="hljs-title" style="color: rgb(166, 226, 46);color: rgb(248, 248, 242);">Error(Exception):
<br  /> &nbsp; &nbsp;"""Base class for exceptions in this module."""
<br  /> &nbsp; &nbsp;pass
<br  />
# 自定义异常
<br  />
<span class="hljs-class">
<span class="hljs-keyword" style="color: rgb(249, 38, 114);color: rgb(102, 217, 239);">class 
<span class="hljs-title" style="color: rgb(166, 226, 46);color: rgb(248, 248, 242);">InputError(Error):
<br  /> &nbsp; &nbsp;"""Exception raised for errors in the input.
<br  /> &nbsp; &nbsp;Attributes:
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;expression -- input expression in which the error occurred
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;message -- explanation of the error
<br  /> &nbsp; &nbsp;"""
<br  /> &nbsp; &nbsp;
<span class="hljs-function" style="color: rgb(249, 38, 114);">
<span class="hljs-keyword" style="color: rgb(249, 38, 114);color: rgb(102, 217, 239);">def 
<span class="hljs-title" style="color: rgb(166, 226, 46);">__init__
<span class="hljs-params" style="color: rgb(248, 248, 242);">(self, expression, message):
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;self.expression = expression
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;self.message = message
<br  />try:
<br  /> &nbsp; &nbsp;print('code start running...')
<br  /> &nbsp; &nbsp;raise InputError('input()', 'input error')
<br  /> &nbsp; &nbsp;
# ValueError
<br  /> &nbsp; &nbsp;int('a')
<br  /> &nbsp; &nbsp;
# TypeError
<br  /> &nbsp; &nbsp;s = 1 + 'a'
<br  /> &nbsp; &nbsp;dit = {'name': 'john'}
<br  /> &nbsp; &nbsp;
# KeyError
<br  /> &nbsp; &nbsp;print(dit['1'])
<br  />except InputError as ex:
<br  /> &nbsp; &nbsp;print("InputError:", ex.message)
<br  />except TypeError as ex:
<br  /> &nbsp; &nbsp;print('TypeError:', ex.args)
<br  /> &nbsp; &nbsp;pass
<br  />except (KeyError, IndexError) as ex:
<br  /> &nbsp; &nbsp;"""支持同时处理多个异常, 用括号放到元组里"""
<br  /> &nbsp; &nbsp;print(sys.exc_info())
<br  />except:
<br  /> &nbsp; &nbsp;"""捕获其他未指定的异常"""
<br  /> &nbsp; &nbsp;print("Unexpected error:", sys.exc_info()[0])
<br  /> &nbsp; &nbsp;
# raise 用于抛出异常
<br  /> &nbsp; &nbsp;raise RuntimeError('RuntimeError')
<br  />else:
<br  /> &nbsp; &nbsp;"""当无任何异常时, 会执行 else 子句"""
<br  /> &nbsp; &nbsp;print('"else" 子句...')
<br  />finally:
<br  /> &nbsp; &nbsp;"""无论有无异常, 均会执行 finally"""
<br  /> &nbsp; &nbsp;print('finally, ending')</code>
</pre>
<h2>
<span style="background-color: rgb(255, 251, 0);">

<h3>文件操作</h3>
</h2>
<p>

<span style="font-size: 24px;color: rgb(171, 25, 66);">
<br  />
</p>
<h3 style="font-size: 20px;">打开文件</h3>
<p>
<code>open()</code>&nbsp;函数用于打开/创建一个文件，并返回一个 file 对象：
</p>
<pre>
<code>open(filename, mode)</code>
</pre>
<ul style="" class=" list-paddingleft-2">
<li>
<p>filename：包含了你要访问的文件名称的字符串值
</p>
</li>
<li>
<p>mode：决定了打开文件的模式：只读，写入，追加等
</p>
</li>
</ul>
<p>
文件打开模式：
</p>
<p>
<img src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://mmbiz.qpic.cn/mmbiz_png/MQ4FoG1HmnJbicSb8Y5yANyyiaWVmXMjQRc1RibByJJjIzehRjypZ7f96OONqoupoCzfLElTrczuTib2ibCuXzHTzIQ/640">
</p>
<h3 style="font-size: 20px;">文件对象方法</h3>
<ul style="" class=" list-paddingleft-2">
<li>
<p>
fileObject.close()
</p>
<p>close() 方法用于关闭一个已打开的文件。关闭后的文件不能再进行读写操作，否则会触发 ValueError 错误。 close() 方法允许调用多次。
</p>
<p>当 file 对象，被引用到操作另外一个文件时，Python 会自动关闭之前的 file 对象。 使用 close() 方法关闭文件是一个好的习惯。
</p>
</li>
<li>
<p>
fileObject.flush()
</p>
<p>flush() 方法是用来刷新缓冲区的，即将缓冲区中的数据立刻写入文件，同时清空缓冲区，不需要是被动的等待输出缓冲区写入。
</p>
<p>一般情况下，文件关闭后会自动刷新缓冲区，但有时你需要在关闭前刷新它，这时就可以使用 flush() 方法。
</p>
</li>
<li>
<p>
fileObject.fileno()
</p>
<p>fileno() 方法返回一个整型的文件描述符(file descriptor FD 整型)，可用于底层操作系统的 I/O 操作。
</p>
</li>
<li>
<p>
fileObject.isatty()
</p>
<p>isatty() 方法检测文件是否连接到一个终端设备，如果是返回 True，否则返回 False。
</p>
</li>
<li>
<p>
next(iterator[,default])
</p>
<p>Python 3 中的 File 对象不支持 next() 方法。 Python 3 的内置函数&nbsp;
<code>next()</code>&nbsp;通过迭代器调用&nbsp;
<code>__next__()</code>&nbsp;方法返回下一项。在循环中，
<code>next()</code>&nbsp;函数会在每次循环中调用，该方法返回文件的下一行，如果到达结尾(EOF)，则触发 StopIteration。
</p>
</li>
<li>
<p>
fileObject.read()
</p>
<p>read() 方法用于从文件读取指定的字节数，如果未给定或为负则读取所有。
</p>
</li>
<li>
<p>
fileObject.readline()
</p>
<p>readline() 方法用于从文件读取整行，包括 “” 字符。如果指定了一个非负数的参数，则返回指定大小的字节数，包括 “” 字符。
</p>
</li>
<li>
<p>
fileObject.readlines()
</p>
<p>readlines() 方法用于读取所有行(直到结束符 EOF)并返回列表，该列表可以由 Python 的&nbsp;
<code>for... in ...</code>&nbsp;结构进行处理。如果碰到结束符 EOF，则返回空字符串。
</p>
</li>
<li>
<p>
fileObject.seek(offset[, whence])
</p>
<p>seek() 方法用于移动文件读取指针到指定位置。
</p>
<p>whence 的值, 如果是 0 表示开头, 如果是 1 表示当前位置, 2 表示文件的结尾。whence 值为默认为0，即文件开头。例如：
</p>
<p>
<code>seek(x, 0)</code>：从起始位置即文件首行首字符开始移动 x 个字符
</p>
<p>
<code>seek(x, 1)</code>：表示从当前位置往后移动 x 个字符
</p>
<p>
<code>seek(-x, 2)</code>：表示从文件的结尾往前移动 x 个字符
</p>
</li>
<li>
<p>
fileObject.tell(offset[, whence])
</p>
<p>tell() 方法返回文件的当前位置，即文件指针当前位置。
</p>
</li>
<li>
<p>
fileObject.truncate([size])
</p>
<p>truncate() 方法用于从文件的首行首字符开始截断，截断文件为 size 个字符，无 size 表示从当前位置截断；截断之后 V 后面的所有字符被删除，其中 Widnows 系统下的换行代表2个字符大小。
</p>
</li>
<li>
<p>
fileObject.write([str])
</p>
<p>write() 方法用于向文件中写入指定字符串。
</p>
<p>在文件关闭前或缓冲区刷新前，字符串内容存储在缓冲区中，这时你在文件中是看不到写入的内容的。
</p>
<p>如果文件打开模式带 b，那写入文件内容时，str (参数)要用 encode 方法转为 bytes 形式，否则报错：
<code>TypeError: a bytes-like object is required, not 'str'</code>。
</p>
</li>
<li>
<p>
fileObject.writelines([str])
</p>
<p>writelines() 方法用于向文件中写入一序列的字符串。这一序列字符串可以是由迭代对象产生的，如一个字符串列表。换行需要指定换行符&nbsp;
<code></code>。
</p>
</li>
</ul>
<h3 style="font-size: 20px;">
<br  /></h3>
<h3 style="font-size: 20px;">实例</h3>
<pre>
<code>filename = 'data.log'
<br  />
# 打开文件(a+ 追加读写模式)
<br  />
# 用 with 关键字的方式打开文件，会自动关闭文件资源
<br  />with open(filename, 'w+', encoding='utf-8') as file:
<br  /> &nbsp; &nbsp;print('文件名称: {}'.format(file.name))
<br  /> &nbsp; &nbsp;print('文件编码: {}'.format(file.encoding))
<br  /> &nbsp; &nbsp;print('文件打开模式: {}'.format(file.mode))
<br  /> &nbsp; &nbsp;print('文件是否可读: {}'.format(file.readable()))
<br  /> &nbsp; &nbsp;print('文件是否可写: {}'.format(file.writable()))
<br  /> &nbsp; &nbsp;print('此时文件指针位置为: {}'.format(file.tell()))
<br  /> &nbsp; &nbsp;
# 写入内容
<br  /> &nbsp; &nbsp;num = file.write("第一行内容")
<br  /> &nbsp; &nbsp;print('写入文件 {} 个字符'.format(num))
<br  /> &nbsp; &nbsp;
# 文件指针在文件尾部，故无内容
<br  /> &nbsp; &nbsp;print(file.readline(), file.tell())
<br  /> &nbsp; &nbsp;
# 改变文件指针到文件头部
<br  /> &nbsp; &nbsp;file.seek(0)
<br  /> &nbsp; &nbsp;
# 改变文件指针后，读取到第一行内容
<br  /> &nbsp; &nbsp;print(file.readline(), file.tell())
<br  /> &nbsp; &nbsp;
# 但文件指针的改变，却不会影响到写入的位置
<br  /> &nbsp; &nbsp;file.write('第二次写入的内容')
<br  /> &nbsp; &nbsp;
# 文件指针又回到了文件尾
<br  /> &nbsp; &nbsp;print(file.readline(), file.tell())
<br  /> &nbsp; &nbsp;
# file.read() 从当前文件指针位置读取指定长度的字符
<br  /> &nbsp; &nbsp;file.seek(0)
<br  /> &nbsp; &nbsp;print(file.read(9))
<br  /> &nbsp; &nbsp;
# 按行分割文件，返回字符串列表
<br  /> &nbsp; &nbsp;file.seek(0)
<br  /> &nbsp; &nbsp;print(file.readlines())
<br  /> &nbsp; &nbsp;
# 迭代文件对象，一行一个元素
<br  /> &nbsp; &nbsp;file.seek(0)
<br  /> &nbsp; &nbsp;for line in file:
<br  /> &nbsp; &nbsp; &nbsp; &nbsp;print(line, end='')
<br  />
# 关闭文件资源
<br  />if not file.closed:
<br  /> &nbsp; &nbsp;file.close()</code>
</pre>
<p>
<span style="font-weight: 700;color: rgb(52, 73, 94);">输出：
</p>
<p>
<span style="font-weight: 700;color: rgb(52, 73, 94);">
</p>
<pre>
<code>文件名称: data.log
<br  />文件编码: utf-8
<br  />文件打开模式: w+
<br  />文件是否可读: True
<br  />文件是否可写: True
<br  />此时文件指针位置为: 0
<br  />写入文件 6 个字符
<br  /> 16
<br  />第一行内容
<br  /> 16
<br  /> 41
<br  />第一行内容
<br  />第二次
<br  />['第一行内容', '第二次写入的内容']
<br  />第一行内容
<br  />第二次写入的内容</code>
</pre>
<p>
<span style="font-weight: 700;color: rgb(52, 73, 94);">
</p>
<h2>
<span style="color: rgb(171, 25, 66);background-color: rgb(255, 251, 0);">

<span style="color: rgb(171, 25, 66);background-color: rgb(255, 251, 0);font-size: 24px;">序列化
</h2>
<p>

<span style="font-size: 24px;color: rgb(217, 33, 66);">
<br  />
</p>
<p>在 Python 中 pickle 模块实现对数据的序列化和反序列化。pickle 支持任何数据类型，包括内置数据类型、函数、类、对象等。
</p>

<h3 style="font-size: 20px;">方法</h3>
<h4>
dump
</h4>
<p>将数据对象序列化后写入文件
</p>
<pre>
<code>pickle.dump(obj, file, protocol=None, fix_imports=True)</code>
</pre>
<p>必填参数 obj 表示将要封装的对象。 必填参数 file 表示 obj 要写入的文件对象，file 必须以二进制可写模式打开，即
<code>wb</code>。 可选参数 protocol 表示告知 pickle 使用的协议，支持的协议有 0,1,2,3，默认的协议是添加在 Python 3 中的协议3。
</p>

<h4>
load
</h4>
<p>从文件中读取内容并反序列化
</p>
<pre>
<code>pickle.load(file, fix_imports=True, encoding='ASCII', errors='strict')</code>
</pre>
<p>必填参数 file 必须以二进制可读模式打开，即
<code>rb</code>，其他都为可选参数。
</p>

<h4>
dumps
</h4>
<p>以字节对象形式返回封装的对象，不需要写入文件中
</p>
<pre>
<code>pickle.dumps(obj, protocol=None, fix_imports=True)</code>
</pre>
<h4>
loads
</h4>
<p>从字节对象中读取被封装的对象，并返回
</p>

<pre>
<code>pickle.loads(bytes_object, fix_imports=True, encoding='ASCII', errors='strict')</code>
</pre>
<h3 style="font-size: 20px;">实例</h3>
<pre>
<code>import pickle
<br  />data = [1, 2, 3]
<br  />
# 序列化数据并以字节对象返回
<br  />dumps_obj = pickle.dumps(data)
<br  />print('pickle.dumps():', dumps_obj)
<br  />
# 从字节对象中反序列化数据
<br  />loads_data = pickle.loads(dumps_obj)
<br  />print('pickle.loads():', loads_data)
<br  />filename = 'data.log'
<br  />
# 序列化数据到文件中
<br  />with open(filename, 'wb') as file:
<br  /> &nbsp; &nbsp;pickle.dump(data, file)
<br  />
# 从文件中加载并反序列化
<br  />with open(filename, 'rb') as file:
<br  /> &nbsp; &nbsp;load_data = pickle.load(file)
<br  /> &nbsp; &nbsp;print('pickle.load():', load_data)</code>
</pre>
<p>
<span style="font-weight: 700;color: rgb(52, 73, 94);">输出：
</p>
<p>
<span style="font-weight: 700;color: rgb(52, 73, 94);">
</p>
<pre>
<code>pickle.dumps(): b']q(KKKe.'
<br  />pickle.loads(): [1, 2, 3]
<br  />pickle.load(): [1, 2, 3]</code>
</pre>
<p>
<span style="font-weight: 700;color: rgb(52, 73, 94);">
</p>
<h2>
<span style="background-color: rgb(255, 251, 0);">

<h3>命名规范</h3>
</h2>

<p>Python 之父 Guido 推荐的规范
</p>
<p>
<img src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://mmbiz.qpic.cn/mmbiz_png/MQ4FoG1HmnJbicSb8Y5yANyyiaWVmXMjQRPSnSCoy8lj26rlo9mb9IIOjtRsicFgJmFULWDPae0WnFk0ibSsDE8jKw/640">
</p>
<p>一份来自谷歌的 Python 风格规范：
</p>
<p>http://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/
</p>
<br>
<br>
<br>
<br>

<script>
  $(function() {
    var toc = $('#toc');

    function makeLi(text, href) {
      return $('<a href="' + href + '" target="_self">' + text + '</a><br>');
    }

    $('h2,h3').each(function(i) {
      var chapter = $(this), chapterNumber = i + 1;
      toc.append(
        makeLi(chapter.text(), '#chapter-' + chapterNumber)
      );
      chapter.attr('id', 'chapter-' + chapterNumber);
    });

  });
</script>
</body>
</html>

</body>
</html>
