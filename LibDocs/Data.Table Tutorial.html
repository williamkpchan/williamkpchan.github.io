<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width"/>

<title>R : Data.Table Tutorial (with 50 Examples)</title>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script>
$(document).ready(function(){
    $('h1, h2, h3, h4, h5, .topicline').click(function(){
    parent.history.back();
    return false;
    });
});
</script>
<style type='text/css'>
blockquote{color:gray;}
.hidden-section-container {
  background-color:rgba(232, 232, 232, 0.93);
  box-shadow:0 2px 10px rgba(0,0,0,0.2);
}
b{color:DarkSeaGreen ;} 
.sh-section-btn {
  font-size:18px;
  color:#000;
  padding:5px 10px;
  cursor:pointer;
}
 
.h-section-cont {
 padding:10px 10px;
 background-color:#fff; 
 display:none;
}


pre {font-family: Andale Mono, Lucida Console, Monaco, fixed, monospace; 
                color: #444; background-color: #fafafa;
                font-size: 13px; border: 1px solid #999999;
                line-height: 14px; padding: 5px; 
                overflow: auto; width: 100%; 
			    white-space: pre-wrap;
}


code {color: #444; background-color: #f2f2f2; border: 1px solid #999999;
                 padding: 3px; font-weight:600; margin-right : 5px;
}


.content-box-gray .content {
    overflow: hidden;
    padding: 10px;
    font-size: 16px;
    border-bottom-left-radius: 5px;
    border-bottom-right-radius: 5px;
    border: 1px solid gray;
    color: #444;
}
.content-box-gray .title {
    height:auto;
    line-height:30px;
    border-top-left-radius: 5px;
    border-top-right-radius: 5px;
    background:#990000;
    font-size:18px;
    font-weight:bold;
    font-family:verdana;
    display:block;
    color:white;
    display:block;
    padding:10px;
    border: 1px solid gray;
    border-bottom:none;
}

#fdw-pricing-table {
  margin:0 auto;
  text-align: center;
  width: 928px; /* total computed width */
  zoom: 1;
 }

 #fdw-pricing-table:before, #fdw-pricing-table:after {
   content: "";
   display: table
 }

 #fdw-pricing-table:after {
   clear: both
 }

 /* --------------- */ 
#w-pricing-table {
  margin:0 auto;
  text-align: center;
  width: 928px; /* total computed width */
  zoom: 1;
 }

 #w-pricing-table:before, #w-pricing-table:after {
   content: "";
   display: table
 }

 #w-pricing-table:after {
   clear: both
 }


 #w-pricing-table .plan {
  font: 13px 'Lucida Sans', 'trebuchet MS', Arial, Helvetica;     
  background: #fff;      
  border: 1px solid #ddd;
  color: #333;
  padding: 20px;
  width: 250px;
  float: left;
  _display: inline; /* IE6 double margin fix */
  position: relative;
  margin: 0 5px;
  -moz-box-shadow: 0 2px 2px -1px rgba(0,0,0,.3);
  -webkit-box-shadow: 0 2px 2px -1px rgba(0,0,0,.3);
  box-shadow: 0 2px 2px -1px rgba(0,0,0,.3);  
 }

 #w-pricing-table .plan:after {
   z-index: -1; 
   position: absolute; 
   content: "";
   bottom: 10px;
   right: 4px;
   width: 80%; 
   top: 80%; 
   -webkit-box-shadow: 0 12px 5px rgba(0, 0, 0, .3);   
   -moz-box-shadow: 0 12px 5px rgba(0, 0, 0, .3);
   box-shadow: 0 12px 5px rgba(0, 0, 0, .3);
   -webkit-transform: rotate(3deg);    
   -moz-transform: rotate(3deg);   
   -o-transform: rotate(3deg);
   -ms-transform: rotate(3deg);
   transform: rotate(3deg); 
 } 

 #w-pricing-table .header {
  font-size: 18px;
  font-weight: normal;
  border-bottom: 3px solid;
 }

 #w-pricing-table .header:after {
  position: absolute;
  bottom: -8px; left: 0;
  height: 3px; width: 100%;
  content: '';
 }


 #w-pricing-table .price{
  font-size: 25px;
 }

 #w-pricing-table .monthly{
  font-size: 18px;
  margin-bottom: 20px;
  color: #666;
 }


 #fdw-pricing-table .plan {
  font: 13px 'Lucida Sans', 'trebuchet MS', Arial, Helvetica;     
  background: #fff;      
  border: 1px solid #ddd;
  color: #333;
  padding: 20px;
  width: 180px;
  float: left;
  _display: inline; /* IE6 double margin fix */
  position: relative;
  margin: 0 5px;
  -moz-box-shadow: 0 2px 2px -1px rgba(0,0,0,.3);
  -webkit-box-shadow: 0 2px 2px -1px rgba(0,0,0,.3);
  box-shadow: 0 2px 2px -1px rgba(0,0,0,.3);  
 }

 #fdw-pricing-table .plan:after {
   z-index: -1; 
   position: absolute; 
   content: "";
   bottom: 10px;
   right: 4px;
   width: 80%; 
   top: 80%; 
   -webkit-box-shadow: 0 12px 5px rgba(0, 0, 0, .3);   
   -moz-box-shadow: 0 12px 5px rgba(0, 0, 0, .3);
   box-shadow: 0 12px 5px rgba(0, 0, 0, .3);
   -webkit-transform: rotate(3deg);    
   -moz-transform: rotate(3deg);   
   -o-transform: rotate(3deg);
   -ms-transform: rotate(3deg);
   transform: rotate(3deg); 
 } 
 
 
 /* --------------- */ 

 #fdw-pricing-table .header {
  font-size: 18px;
  font-weight: normal;
  border-bottom: 3px solid;
 }

 #fdw-pricing-table .header:after {
  position: absolute;
  bottom: -8px; left: 0;
  height: 3px; width: 100%;
  content: '';
 }
 
 
 #fdw-pricing-table .plan1 .header{
  border-bottom-color: #B3E03F;
 }

 #fdw-pricing-table .plan2 .header{
  border-bottom-color: #7BD553;
 }

 #fdw-pricing-table .plan3 .header{
  border-bottom-color: #3AD5A0;
 }

 #w-pricing-table .plan4 .header{
  border-bottom-color: #990000;
 }   
 
 /* --------------- */

 #fdw-pricing-table .price{
  font-size: 25px;
 }

 #fdw-pricing-table .monthly{
  font-size: 18px;
  margin-bottom: 20px;
  color: #666;
 }

 /* --------------- */

 #fdw-pricing-table ul {
  margin: 20px 0;
  padding: 0;
  list-style: none;
 }

 #fdw-pricing-table li {
  padding: 10px 0;
 }
 
 /* --------------- */
  
 #fdw-pricing-table .signup {
  position: relative;
  padding: 10px 20px;
  color: #fff;
  font: bold 15px Arial, Helvetica;
  text-decoration: none;
  display: inline-block;       
  background-color: #72ce3f;
  -moz-border-radius: 3px;
  -webkit-border-radius: 3px;
  border-radius: 3px;     
  text-shadow: 0 -1px 0 rgba(0,0,0,.15);
  opacity: .9;       
 }

 #fdw-pricing-table .signup:hover {
  opacity: 1;       
 }

 #fdw-pricing-table .signup:active {
  -moz-box-shadow: 0 2px 2px rgba(0,0,0,.3) inset;
  -webkit-box-shadow: 0 2px 2px rgba(0,0,0,.3) inset;
  box-shadow: 0 2px 2px rgba(0,0,0,.3) inset;       
 }   

 #fdw-pricing-table .plan1 .signup{
  background: #B3E03F;
 }

 #fdw-pricing-table .plan2 .signup{
  background: #7BD553;
 }

 #fdw-pricing-table .plan3 .signup{
  background: #3AD5A0;
 }

 #w-pricing-table .plan4 .signup{
 font-size: 16px;
 font-weight: bold;
 }
 
@media only screen and (max-width: 600px) {
    #fdw-pricing-table {
        width: 100%;
    }
}

.navigation {
  width: 300px;
}

.mainmenu, .submenu {
  list-style: none;
  padding: 0;
  margin: 0;
}

.mainmenu a {
  display: block;
  background-color: #CCC;
  text-decoration: none;
  padding: 10px;
  color: #000;
}

.mainmenu a:hover {
    background-color: #C5C5C5;
}

.mainmenu li:hover .submenu {
  display: block;
  max-height: 200px;
}

.submenu a {
  background-color: #999;
}

/* hover behaviour for links inside .submenu */
.submenu a:hover {
  background-color: #666;
}

.submenu {
  overflow: hidden;
  max-height: 0;
  -webkit-transition: all 0.5s ease-out;
}
</style>
<style type='text/css'>#related-post{margin:20px 0 30px}#related-post h3{font-family:"Oswald",Arial,sans-serif;text-transform:uppercase;color:#555;font-size:16px;font-weight:normal;padding:0 0 8px;margin:0}#related-post ul{margin-left:0}</style>
<link href='https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css' rel='stylesheet'/>

<style>
.header-left{
display: inline-block;
float: left;
}
#header-right {
display:inline-block;
float:right;
margin-top: 10px;
margin-right: 0px;
}
</style>
<link rel="stylesheet" href="..\maincss.css">
<style>
body{font-size: x-large;width:80%;margin-left: 10%}
.topicline{color: gold; font-size: xx-large;}
.tr_bq{background: #001010;}
</style>
</head>
<body class='loading'>
<center><h1>R : Data.Table Tutorial (with 50 Examples)</h1>

<a href="https://www.listendata.com/2016/10/r-data-table.html">DATA.TABLE TUTORIAL (WITH 50 EXAMPLES)</a>
<br>
<div id="toc"></div></center>
<br>
<div dir="ltr" style="text-align: left;" trbidi="on">
The data.table R package is considered as the fastest package for data manipulation. This tutorial includes various examples and practice questions to make you familiar with the package. Analysts generally call R programming not compatible with big datasets ( &gt; 10 GB) as it is not memory efficient and loads everything into RAM. To change their perception, 'data.table' package comes into play. This package was designed to be concise and painless. There are many benchmarks done in the past to compare dplyr vs data.table. In every benchmark, data.table wins. The efficiency of this package was also compared with python' package (panda). And data.table wins. In CRAN, there are more than 200 packages that are dependent on data.table which makes it listed in the top 5 R's package.<br />
<br>
<span class="topicline">data.table Syntax</span></span><br />
<br />
The syntax of data.table is shown in the image below :<br />
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody>
<tr><td style="text-align: center;"><a href="https://2.bp.blogspot.com/-L-DIRIa6pi4/WAdcNIhzCfI/AAAAAAAAFiE/RN9-bFU6rZAIfZpAbY9v8pLFRpoTHbQxACLcB/s1600/Data%2BTable%2BSyntax.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="https://2.bp.blogspot.com/-L-DIRIa6pi4/WAdcNIhzCfI/AAAAAAAAFiE/RN9-bFU6rZAIfZpAbY9v8pLFRpoTHbQxACLcB/s1600/Data%2BTable%2BSyntax.png" /></a></td></tr>
<tr><td class="tr-caption" style="text-align: center;">data.table Syntax</td></tr>
</tbody></table>
<br />
<b><span style="font-size: x-large;">DT[ i , j , by]</span></b><br />
<div>
<ol style="text-align: left;">
<li>The first parameter of data.table <b>i </b>refers to rows. It implies subsetting rows. It is equivalent to <b>WHERE </b>clause in SQL</li>
<li>The second parameter of data.table <b>j </b>refers to columns. It implies subsetting columns (dropping / keeping). It is equivalent to <b>SELECT </b>clause in SQL.</li>
<li>The third parameter of data.table <b>by </b>refers to adding a group so that all calculations would be done within a group. Equivalent to SQL's <b>GROUP BY</b> clause.</li>
</ol>

<div>
<b><span style="color: cyan;">The data.table syntax is NOT RESTRICTED to only 3 parameters.</span></b> There are other arguments that can be added to data.table syntax. The list is as follows -</div>
<div>
<ol style="text-align: left;">
<li>with, which</li>
<li>allow.cartesian</li>
<li>roll, rollends</li>
<li>.SD, .SDcols</li>
<li>on, mult, nomatch</li>
</ol>
</div>
</div>
<div>
The above arguments would be explained in the latter part of the post.</div>
<div>
<br /></div>
<br>
<span class="topicline">How to Install and load data.table Package</span></span><br />
<blockquote class="tr_bq">
install.packages("data.table")&nbsp;</blockquote>
<blockquote class="tr_bq">
#load required library<br />
library(data.table)</blockquote>
<br />
<br>
<span class="topicline">Read Data</span></span><br />
<br />
In data.table package, <b>fread() function </b>is available to read or get data from your computer or from a web page. It is equivalent to read.csv() function of base R.<br />
<blockquote class="tr_bq">
mydata = fread("https://github.com/arunsrinivasan/satrdays-workshop/raw/master/flights_2014.csv")</blockquote>
<br />
<br>
<span class="topicline">Describe Data</span></span><br />
<br />
This dataset contains 253K observations and 17 columns. It constitutes information about flights' arrival or departure time, delays, flight cancellation and destination in year 2014.<br />
<blockquote class="tr_bq">
nrow(mydata)<br />
[1] 253316</blockquote>
<blockquote class="tr_bq">
ncol(mydata)<br />
[1] 17</blockquote>
<blockquote class="tr_bq">
names(mydata)<br />
&nbsp;[1] "year" &nbsp; &nbsp; &nbsp;"month" &nbsp; &nbsp; "day" &nbsp; &nbsp; &nbsp; "dep_time" &nbsp;"dep_delay" "arr_time" &nbsp;"arr_delay"<br />
&nbsp;[8] "cancelled" "carrier" &nbsp; "tailnum" &nbsp; "flight" &nbsp; &nbsp;"origin" &nbsp; &nbsp;"dest" &nbsp; &nbsp; &nbsp;"air_time"<br />
[15] "distance" &nbsp;"hour" &nbsp; &nbsp; &nbsp;"min" &nbsp; &nbsp; &nbsp;</blockquote>
<blockquote class="tr_bq">
head(mydata)<br />
&nbsp; &nbsp;year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight<br />
1: 2014 &nbsp; &nbsp; 1 &nbsp; 1 &nbsp; &nbsp; &nbsp;914 &nbsp; &nbsp; &nbsp; &nbsp;14 &nbsp; &nbsp; 1238 &nbsp; &nbsp; &nbsp; &nbsp;13 &nbsp; &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp;AA &nbsp;N338AA &nbsp; &nbsp; &nbsp;1<br />
2: 2014 &nbsp; &nbsp; 1 &nbsp; 1 &nbsp; &nbsp; 1157 &nbsp; &nbsp; &nbsp; &nbsp;-3 &nbsp; &nbsp; 1523 &nbsp; &nbsp; &nbsp; &nbsp;13 &nbsp; &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp;AA &nbsp;N335AA &nbsp; &nbsp; &nbsp;3<br />
3: 2014 &nbsp; &nbsp; 1 &nbsp; 1 &nbsp; &nbsp; 1902 &nbsp; &nbsp; &nbsp; &nbsp; 2 &nbsp; &nbsp; 2224 &nbsp; &nbsp; &nbsp; &nbsp; 9 &nbsp; &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp;AA &nbsp;N327AA &nbsp; &nbsp; 21<br />
4: 2014 &nbsp; &nbsp; 1 &nbsp; 1 &nbsp; &nbsp; &nbsp;722 &nbsp; &nbsp; &nbsp; &nbsp;-8 &nbsp; &nbsp; 1014 &nbsp; &nbsp; &nbsp; -26 &nbsp; &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp;AA &nbsp;N3EHAA &nbsp; &nbsp; 29<br />
5: 2014 &nbsp; &nbsp; 1 &nbsp; 1 &nbsp; &nbsp; 1347 &nbsp; &nbsp; &nbsp; &nbsp; 2 &nbsp; &nbsp; 1706 &nbsp; &nbsp; &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp;AA &nbsp;N319AA &nbsp; &nbsp;117<br />
6: 2014 &nbsp; &nbsp; 1 &nbsp; 1 &nbsp; &nbsp; 1824 &nbsp; &nbsp; &nbsp; &nbsp; 4 &nbsp; &nbsp; 2145 &nbsp; &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp;AA &nbsp;N3DEAA &nbsp; &nbsp;119<br />
&nbsp; &nbsp;origin dest air_time distance hour min<br />
1: &nbsp; &nbsp;JFK &nbsp;LAX &nbsp; &nbsp; &nbsp;359 &nbsp; &nbsp; 2475 &nbsp; &nbsp;9 &nbsp;14<br />
2: &nbsp; &nbsp;JFK &nbsp;LAX &nbsp; &nbsp; &nbsp;363 &nbsp; &nbsp; 2475 &nbsp; 11 &nbsp;57<br />
3: &nbsp; &nbsp;JFK &nbsp;LAX &nbsp; &nbsp; &nbsp;351 &nbsp; &nbsp; 2475 &nbsp; 19 &nbsp; 2<br />
4: &nbsp; &nbsp;LGA &nbsp;PBI &nbsp; &nbsp; &nbsp;157 &nbsp; &nbsp; 1035 &nbsp; &nbsp;7 &nbsp;22<br />
5: &nbsp; &nbsp;JFK &nbsp;LAX &nbsp; &nbsp; &nbsp;350 &nbsp; &nbsp; 2475 &nbsp; 13 &nbsp;47<br />
6: &nbsp; &nbsp;EWR &nbsp;LAX &nbsp; &nbsp; &nbsp;339 &nbsp; &nbsp; 2454 &nbsp; 18 &nbsp;24</blockquote>
<br />
<br />
<br>
<span class="topicline">Selecting or Keeping Columns</span></span><br />
<br />
<b>Suppose you need to select only 'origin' column.</b> You can use the code below -<br />
<blockquote class="tr_bq">
dat1 = mydata[ , origin] # returns a vector</blockquote>
<b><i>The above line of code <span style="color: #990000;">returns a vector not data.table.</span></i></b><br />
<br />
To get result in data.table format, run the code below :<br />
<blockquote class="tr_bq">
dat1 = mydata[ , <b>.(origin)</b>] # returns a data.table</blockquote>
It can also be written like <b>data.frame way</b><br />
<blockquote class="tr_bq">
dat1 = mydata[, c("origin"), with=FALSE]</blockquote>
<br />
<span style="font-size: x-large;"><b>Keeping a column based on column position</b></span><br />
<blockquote class="tr_bq">
dat2 =mydata[, 2, with=FALSE]</blockquote>
In this code, we are selecting <b>second column </b>from mydata<b>.</b><br />
<br />
<b><span style="font-size: x-large;">Keeping Multiple Columns</span></b><br />
<br />
The following code tells R to select 'origin', 'year', 'month', 'hour' columns.<br />
<blockquote class="tr_bq">
dat3 = mydata[, .(origin, year, month, hour)]</blockquote>
<br />
<b><span style="font-size: x-large;">Keeping multiple columns based on column position</span></b><br />
<br />
You can keep second through fourth columns using the code below -<br />
<blockquote class="tr_bq">
dat4 = mydata[, c(2:4), with=FALSE]</blockquote>
<br />
<b><span style="font-size: x-large;">Dropping a Column</span></b><br />
<br />
Suppose you want to include all the variables except one column, say. 'origin'. It can be easily done by adding <b>! sign</b> (implies negation in R)<br />
<blockquote class="tr_bq">
dat5 = mydata[, !c("origin"), with=FALSE]</blockquote>
<br />
<b><span style="font-size: x-large;">Dropping Multiple Columns</span></b><br />
<blockquote class="tr_bq">
dat6 = mydata[, !c("origin", "year", "month"), with=FALSE]</blockquote>
<br />
<b><span style="font-size: x-large;">Keeping variables that contain 'dep'</span></b><br />
<br />
You can use <b>%like%</b> operator to find pattern. It is same as <b>base R's grepl() function</b>,&nbsp;<b>SQL's LIKE </b>operator and <b>SAS's CONTAINS </b>function.<br />
<blockquote class="tr_bq">
dat7 = mydata[,names(mydata) <b>%like%</b> "dep", with=FALSE]</blockquote>
<br />
<br>
<span class="topicline">Rename Variables</span></span><br />
<br />
You can rename variables with <b>setnames()</b> function. In the following code, we are renaming a variable 'dest' to 'destination'.<br />
<blockquote class="tr_bq">
setnames(mydata, c("dest"), c("Destination"))</blockquote>
To rename multiple variables, you can simply add variables in both the sides.<br />
<blockquote class="tr_bq">
setnames(mydata, c("dest","origin"), c("Destination", "origin.of.flight"))</blockquote>
<br />
<br>
<span class="topicline">Subsetting Rows / Filtering</span></span><br />
<i><span style="font-size: x-large;"><br /></span></i>
<i><b><span style="font-size: x-large;">Suppose you are asked to find all the flights whose origin is 'JFK'.</span></b></i><br />
<blockquote class="tr_bq">
# Filter based on one variable<br />
dat8 = mydata[origin == "JFK"]</blockquote>
<b><span style="font-size: x-large;">Select Multiple Values</span></b><br />
<br />
Filter all the flights whose origin is either 'JFK' or 'LGA'<br />
<blockquote class="tr_bq">
dat9 = mydata[origin %in% c("JFK", "LGA")]</blockquote>
<br />
<b><span style="font-size: x-large;">Apply Logical Operator : NOT</span></b><br />
<br />
The following program selects all the flights whose origin is not equal to 'JFK' and 'LGA'<br />
<blockquote class="tr_bq">
# Exclude Values<br />
dat10 = mydata[<b>!</b>origin %in% c("JFK", "LGA")]</blockquote>
<br />
<b><span style="font-size: x-large;">Filter based on Multiple variables</span></b><br />
<br />
If you need to select all the flights whose origin is equal to 'JFK' and carrier = 'AA'<br />
<blockquote class="tr_bq">
dat11 = mydata[origin == "JFK" &amp; carrier == "AA"]</blockquote>
<br />
<br>
<span class="topicline">Faster Data Manipulation with Indexing</span></span><br />
<br />
data.table uses <b>binary search algorithm</b> that makes data manipulation faster.<br />
<br />
<b><span style="font-size: x-large;">Binary Search Algorithm</span></b><br />
<blockquote class="tr_bq">
Binary search is an efficient algorithm for finding a value from a <b>sorted </b>list of values.&nbsp;It involves repeatedly splitting in half the portion of the list that contains values, until you found the value that you were searching for.</blockquote>
Suppose you have the following values in a variable :<br />
<blockquote class="tr_bq">
5, 10, 7, 20, 3, 13, 26</blockquote>
You are searching the value <b>20&nbsp;</b>in the above list. See how binary search algorithm works -<br />
<br />
<ol style="text-align: left;">
<li>First, we sort the values&nbsp;</li>
<li>We would calculate the middle value i.e. 10.</li>
<li>We would check whether 20 = 10? No. 20 &lt; 10.</li>
<li>Since 20 is greater than 10, it should be somewhere after 10. So we can ignore all the values that are lower than or equal to 10.</li>
<li>We are left with 13, 20, 26. The middle value is 20.&nbsp;</li>
<li>We would again check whether 20=20. Yes. the match found.</li>
</ol>
<br />
If we do not use this algorithm, we would have to search 5 in the whole list of seven values.<br />
<br />
<span style="color: red;">It is important to set <b>key </b>in your dataset which tells system that data is sorted by the key column</span>. For example, you have employee&#8217;s name, address, salary, designation, department, employee ID. We can use 'employee ID' as a key to search a particular employee.<br />
<b><span style="font-size: x-large;"><br /></span></b>
<b><span style="font-size: x-large;">Set Key</span></b><br />
<br />
In this case, we are setting <b>'origin'</b> as a key in the dataset <b>mydata</b>.<br />
<blockquote class="tr_bq">
# Indexing (Set Keys)<br />
setkey(mydata, origin)</blockquote>
<b>Note : </b>It makes the data table <b>sorted </b>by the column 'origin'.<br />
<br />
<b><span style="font-size: x-large;">How to filter when key is turned on.</span></b><br />
<br />
You don't need to refer the key column when you apply filter.<br />
<blockquote class="tr_bq">
data12 = mydata[c("JFK", "LGA")]</blockquote>
<br />
<br>
<span class="topicline">Performance Comparison</span></span><br />
<br />
You can compare performance of the filtering process <b>(With or Without KEY).</b><br />
<blockquote class="tr_bq">
system.time(mydata[origin %in% c("JFK", "LGA")])<br />
system.time(mydata[c("JFK", "LGA")])</blockquote>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody>
<tr><td style="text-align: center;"><a href="https://2.bp.blogspot.com/-cNI65X2y9_c/WAeNAnOf54I/AAAAAAAAFiU/mgen0LJVzXkn0_DHd5ibxExSudLhAwWtwCLcB/s1600/Performance%2Bdata.table.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="https://2.bp.blogspot.com/-cNI65X2y9_c/WAeNAnOf54I/AAAAAAAAFiU/mgen0LJVzXkn0_DHd5ibxExSudLhAwWtwCLcB/s1600/Performance%2Bdata.table.png" /></a></td></tr>
<tr><td class="tr-caption" style="text-align: center;">Performance - With or without KEY</td></tr>
</tbody></table>
If you look at the real time in the image above, setting key makes filtering twice as faster than without using keys.<br />
<br />
<b><span style="font-size: x-large;">Indexing Multiple Columns</span></b><br />
<br />
We can also set keys to multiple columns like we did below to columns 'origin' and 'dest'. See the example below.<br />
<blockquote class="tr_bq">
setkey(mydata, origin, dest)</blockquote>
<b><span style="font-size: x-large;">Filtering while setting keys on Multiple Columns</span></b><br />
<blockquote class="tr_bq">
# First key column 'origin' matches &#8220;JFK&#8221; and second key column 'dest' matches &#8220;MIA&#8221;<br />
mydata[.("JFK", "MIA")]</blockquote>
<i><b>It is equivalent to the following code :</b></i><br />
<blockquote class="tr_bq">
mydata[origin == "JFK" &amp; dest == "MIA"]</blockquote>
<b><span style="font-size: x-large;">To identify the column(s) indexed by</span></b><br />
<blockquote class="tr_bq">
key(mydata)</blockquote>
<div>
<b>Result :</b> It returns origin and dest as these are columns that are set keys.</div>
<div>
<br /></div>
<br>
<span class="topicline">Sorting Data</span></span><br />
<br />
We can sort data using <b>setorder()</b> function, By default, it sorts data on ascending order.<br />
<blockquote class="tr_bq">
mydata01 = setorder(mydata, origin)</blockquote>
<br />
<b><span style="font-size: x-large;">Sorting Data on descending order</span></b><br />
<br />
In this case, we are sorting data by 'origin' variable on descending order.<br />
<blockquote class="tr_bq">
mydata02 = setorder(mydata, <b>-</b>origin)</blockquote>
<br />
<b><span style="font-size: x-large;">Sorting Data based on multiple variables</span></b><br />
<br />
In this example, we tells R to reorder data first by origin on ascending order and then variable 'carrier'on descending order.<br />
<blockquote class="tr_bq">
mydata03 = setorder(mydata, origin, -carrier)</blockquote>
<br />
<br>
<span class="topicline">Adding Columns (Calculation on rows)</span></span><br />
<br />
You can do any operation on rows by adding <b>:= operator</b>. In this example, we are subtracting 'dep_delay' variable from 'dep_time' variable to compute scheduled departure time.<br />
<blockquote class="tr_bq">
mydata[, dep_sch:=dep_time - dep_delay]</blockquote>
<br />
<b><span style="font-size: x-large;">Adding Multiple Columns</span></b><br />
<span style="font-size: x-large;"><b></b></span><br />
<blockquote class="tr_bq">
mydata002 = mydata[, c("dep_sch","arr_sch"):=list(dep_time - dep_delay, arr_time - arr_delay)]</blockquote>
<br />
<br>
<span class="topicline">IF THEN ELSE</span></span><br />
<br />
The 'IF THEN ELSE' conditions are very popular for recoding values. In data.table package, it can be done with the following methods :<br />
<b><br /></b>
<b>Method I : &nbsp; &nbsp;</b>mydata[, flag:= 1*(min &lt; 50)]<br />
<b>Method II :</b>&nbsp; &nbsp;mydata[, flag:= ifelse(min &lt; 50, 1,0)]<br />
<div>
<br /></div>
<div>
It means to set flag= 1 if min is less than 50. Otherwise, set flag =0.</div>
<br />
<div>
<br>
<span class="topicline">How to write Sub Queries (like SQL)</span></span></div>
<br />
We can use this format - <b>DT[ ] [ ] [ ] </b>to build a chain in data.table. It is like sub-queries like SQL.<br />
<blockquote class="tr_bq">
mydata[, dep_sch:=dep_time - dep_delay][,.(dep_time,dep_delay,dep_sch)]</blockquote>
First, we are computing scheduled departure time and then selecting only relevant columns.<br />
<br />
<br />
<br>
<span class="topicline">Summarize or Aggregate Columns</span></span><br />
<br />
Like SAS PROC MEANS procedure, we can generate summary statistics of specific variables. In this case, we are calculating mean, median, minimum and maximum value of variable arr_delay.<br />
<blockquote class="tr_bq">
mydata[, .(mean = mean(arr_delay, na.rm = TRUE),<br />
median = median(arr_delay, na.rm = TRUE),<br />
min = min(arr_delay, na.rm = TRUE),<br />
max = max(arr_delay, na.rm = TRUE))]</blockquote>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto;"><tbody>
<tr><td style="text-align: center;"><a href="https://1.bp.blogspot.com/-TvbAiwlS0QY/WAeYoCr7lgI/AAAAAAAAFik/aR6CXMEpi8oXAWp3amjHepdNwNjsiQO_gCLcB/s1600/Summary.png" imageanchor="1" style="margin-left: auto; margin-right: auto; text-align: center;"><img border="0" src="https://1.bp.blogspot.com/-TvbAiwlS0QY/WAeYoCr7lgI/AAAAAAAAFik/aR6CXMEpi8oXAWp3amjHepdNwNjsiQO_gCLcB/s1600/Summary.png" /></a></td></tr>
<tr><td class="tr-caption" style="text-align: center;">Summarize with data.table package</td></tr>
</tbody></table>
<b><span style="font-size: x-large;">Summarize Multiple Columns</span></b><br />
<br />
To summarize multiple variables, we can simply write all the summary statistics function in a bracket. See the command below-<br />
<blockquote class="tr_bq">
mydata[, .(mean(arr_delay), mean(dep_delay))]</blockquote>
If you need to calculate summary statistics for a larger list of variables, you can use <b>.SD and .SDcols</b> operators. The <b>.SD</b>&nbsp;operator implies <b>'Subset of Data'.&nbsp;</b><br />
<blockquote class="tr_bq">
mydata[, lapply(.SD, mean), .SDcols = c("arr_delay", "dep_delay")]</blockquote>
In this case, we are calculating mean of two variables - arr_delay and dep_delay.<br />
<br />
<b><span style="font-size: x-large;">Summarize all numeric Columns</span></b><br />
<br />
By default, <b>.SD</b> takes all continuous variables (excluding grouping variables)<br />
<blockquote class="tr_bq">
mydata[, lapply(.SD, mean)]</blockquote>
<br />
<b><span style="font-size: x-large;">Summarize with multiple statistics</span></b><br />
<blockquote class="tr_bq">
mydata[, sapply(.SD, function(x) c(mean=mean(x), median=median(x)))]</blockquote>
<br />
<br />
<br>
<span class="topicline">GROUP BY (Within Group Calculation)</span></span><br />
<br />
<b><span style="font-size: x-large;">Summarize by group 'origin</span></b><br />
<blockquote class="tr_bq">
mydata[, .(mean_arr_delay = mean(arr_delay, na.rm = TRUE)), by = origin]</blockquote>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody>
<tr><td style="text-align: center;"><a href="https://3.bp.blogspot.com/-ZA_hGEWElZE/WAectuyCWrI/AAAAAAAAFiw/_9auwLWLPX4ZZ99eWnJEtHwKY02S-nYHQCLcB/s1600/Summary%2Bby%2Bgroup.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="https://3.bp.blogspot.com/-ZA_hGEWElZE/WAectuyCWrI/AAAAAAAAFiw/_9auwLWLPX4ZZ99eWnJEtHwKY02S-nYHQCLcB/s1600/Summary%2Bby%2Bgroup.png" /></a></td></tr>
<tr><td class="tr-caption" style="text-align: center;">Summary by group</td></tr>
</tbody></table>
<br />
<b><span style="font-size: x-large;">Use key column in a by operation</span></b><br />
<br />
Instead of 'by', you can use <b>keyby=&nbsp;</b>operator.<br />
<blockquote class="tr_bq">
mydata[, .(mean_arr_delay = mean(arr_delay, na.rm = TRUE)), <b>keyby </b>= origin]</blockquote>
<br />
<div>
<b><span style="font-size: x-large;">Summarize multiple variables by group 'origin'</span></b><br />
<blockquote class="tr_bq">
mydata[, .(mean(arr_delay, na.rm = TRUE), mean(dep_delay, na.rm = TRUE)), by = origin]</blockquote>
&nbsp;Or it can be written like below -</div>
<blockquote class="tr_bq">
mydata[, lapply(.SD, mean, na.rm = TRUE), .SDcols = c("arr_delay", "dep_delay"), by = origin]</blockquote>
<br>
<span class="topicline">Remove Duplicates</span></span><br />
<br />
You can remove non-unique / duplicate cases with unique() function. Suppose you want to eliminate duplicates based on a variable, say. carrier.<br />
<blockquote class="tr_bq">
setkey(mydata, "carrier")<br />
unique(mydata)</blockquote>
<div>
<br /></div>
<div>
Suppose you want to remove duplicated based on all the variables. You can use the command below -</div>
<div>
<blockquote class="tr_bq">
setkey(mydata, NULL)<br />
unique(mydata)</blockquote>
</div>
<div>
<b>Note : </b>Setting key to NULL is not required if no key is already set.</div>
<br>
<span class="topicline">Extract values within a group</span></span><br />
<br />
The following command selects first and second values from a categorical variable carrier.<br />
<blockquote class="tr_bq">
mydata[, .SD[1:2], by=carrier]</blockquote>
<br />
<b><span style="font-size: x-large;">Select LAST value from a group</span></b><br />
<blockquote class="tr_bq">
mydata[, .SD[.N], by=carrier]</blockquote>
<div>

<br>
<span class="topicline">SQL's RANK OVER PARTITION</span></span><br />
<br />
In SQL, Window functions are very useful for solving complex data problems. RANK OVER PARTITION is the most popular window function. It can be easily translated in data.table with the help of <b>frank() </b>function. frank() is similar to base R's rank() function but much faster. See the code below.<br />
<blockquote class="tr_bq">
dt = mydata[, rank:=<b>frank(-distance,ties.method = "min")</b>, by=carrier]</blockquote>
<div>
In this case, we are calculating rank of variable 'distance' by 'carrier'. We are assigning rank 1 to the highest value of 'distance' within unique values of 'carrier'.</div>
<div>
<br /></div>
<div>
<br /></div>
<br>
<span class="topicline">Cumulative SUM by GROUP</span></span><br />
<br />
We can calculate cumulative sum by using <b>cumsum()</b> function.<br />
<blockquote class="tr_bq">
dat = mydata[, cum:=<b>cumsum</b>(distance), by=carrier]</blockquote>
<br /></div>
<br>
<span class="topicline">Lag and Lead</span></span><br />
<br />
The lag and lead of a variable can be calculated with shift() function. The syntax of shift() function is as follows -&nbsp;<b>shift(variable_name, number_of_lags, type=c("lag", "lead"))</b><br />
<blockquote class="tr_bq">
DT &lt;- data.table(A=1:5)<br />
DT[ , X := <b>shift</b>(A, 1, type="lag")]<br />
DT[ , Y := <b>shift</b>(A, 1, type="lead")]</blockquote>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody>
<tr><td style="text-align: center;"><a href="https://3.bp.blogspot.com/-Jz3wnUM0A-g/WAerXNB1x5I/AAAAAAAAFjA/vYRXZpGj3TkX4-tnhqbvIck6uG4iMsgKQCLcB/s1600/Lag%2Band%2Blead.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="https://3.bp.blogspot.com/-Jz3wnUM0A-g/WAerXNB1x5I/AAAAAAAAFjA/vYRXZpGj3TkX4-tnhqbvIck6uG4iMsgKQCLcB/s1600/Lag%2Band%2Blead.png" /></a></td></tr>
<tr><td class="tr-caption" style="text-align: center;">Lag and Lead Function</td></tr>
</tbody></table>

<br>
<span class="topicline">Between and LIKE Operator</span></span><br />
<br />
We can use %between% operator to define a range. It is inclusive of the values of both the ends.<br />
<blockquote class="tr_bq">
DT = data.table(x=6:10)<br />
DT[x <b>%between%</b> c(7,9)]</blockquote>
The %like% is mainly used to find all the values that matches a pattern.<br />
<blockquote class="tr_bq">
DT = data.table(Name=c("dep_time","dep_delay","arrival"), ID=c(2,3,4))<br />
DT[Name <b>%like%</b> "dep"]&nbsp;</blockquote>
<div>
<br /></div>
<br>
<span class="topicline">Merging / Joins</span></span><br />
<br />
The merging in data.table is very similar to base R merge() function. The only difference is data.table by default takes common key variable as a primary key to merge two datasets. Whereas, data.frame takes common variable name as a primary key to merge the datasets.<br />
<b><span style="font-size: x-large;"><br /></span></b>
<b><span style="font-size: x-large;">Sample Data</span></b><br />
<blockquote class="tr_bq">
(dt1 &lt;- data.table(A = letters[rep(1:3, 2)], X = 1:6, key = "A"))<br />
(dt2 &lt;- data.table(A = letters[rep(2:4, 2)], Y = 6:1, key = "A"))</blockquote>
<b><span style="font-size: x-large;">Inner Join</span></b><br />
<br />
It returns all the matching observations in both the datasets.<br />
<blockquote class="tr_bq">
merge(dt1, dt2, by="A")</blockquote>
<br />
<b><span style="font-size: x-large;">Left Join</span></b><br />
<br />
It returns all observations&nbsp;from the left dataset and the matched observations&nbsp;from the right dataset.<br />
<blockquote class="tr_bq">
merge(dt1, dt2, by="A", all.x = TRUE)</blockquote>
<br />
<b><span style="font-size: x-large;">Right Join</span></b><br />
<br />
It returns all observations from the right dataset and the matched observations from the left dataset.<br />
<blockquote class="tr_bq">
merge(dt1, dt2, by="A", all.y = TRUE)</blockquote>
<br />
<b><span style="font-size: x-large;">Full Join</span></b><br />
<br />
It return all rows when there is a match in one of the datasets.<br />
<blockquote class="tr_bq">
merge(dt1, dt2, all=TRUE)</blockquote>
<br />
<br />
<br>
<span class="topicline">Convert a data.table to data.frame</span></span><br />
<br />
You can use <b>setDF()</b> function to accomplish this task.<br />
<blockquote class="tr_bq">
setDF(mydata)</blockquote>
Similarly, you can use <b>setDT() </b>function to convert data frame to data table.<br />
<blockquote class="tr_bq">
set.seed(123)<br />
X = data.frame(A=sample(3, 10, TRUE),<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;B=sample(letters[1:3], 10, TRUE)</blockquote>
<blockquote class="tr_bq">
setDT(X, key = "A")</blockquote>
<br />
<br>
<span class="topicline">Other Useful Functions</span></span><br />
<br />
<b><span style="font-size: x-large;">Reshape Data</span></b><br />
<blockquote class="tr_bq">
It includes several useful functions which makes data cleaning easy and smooth. To reshape or transpose data, you can use <b>dcast.data.table() </b>and <b>melt.data.table()</b> functions. These functions are sourced from reshape2 package and make them efficient. It also add some new features in these functions.</blockquote>
<br />
<b><span style="font-size: x-large;">Rolling Joins</span></b><br />
<blockquote class="tr_bq">
It supports rolling joins. They are commonly used for analyzing time series data. A very R packages supports these kind of joins.</blockquote>
<br />
<br>
<span class="topicline">Examples for Practise</span></span><br />
<br />
<span style="font-size: x-large;">Q1. Calculate total number of rows by month and then sort on descending order</span><br />
<blockquote class="tr_bq">
mydata[, .N, by = month] [order(-N)]</blockquote>
<div>
The <b>.N operator</b> is used to find count.</div>
<div>
<span style="font-size: x-large;"><br /></span></div>
<span style="font-size: x-large;">Q2. Find top 3 months with high mean arrival delay</span><br />
<blockquote class="tr_bq">
mydata[, .(mean_arr_delay = mean(arr_delay, na.rm = TRUE)), by = month][order(-mean_arr_delay)][1:3]</blockquote>
<br />
<span style="font-size: x-large;">Q3. Find origin of flights having average total delay is greater than 20 minutes</span><br />
<blockquote class="tr_bq">
mydata[, lapply(.SD, mean, na.rm = TRUE), .SDcols = c("arr_delay", "dep_delay"), by = origin][(arr_delay + dep_delay) &gt; 20]</blockquote>
<br />
<span style="font-size: x-large;">Q4. &nbsp;Extract average of arrival and departure delays for carrier == 'DL' by 'origin' and 'dest' variables</span><br />
<blockquote class="tr_bq">
mydata[carrier == "DL",<br />
&nbsp; &nbsp; &nbsp; &nbsp; lapply(.SD, mean, na.rm = TRUE),<br />
&nbsp; &nbsp; &nbsp; &nbsp; by = .(origin, dest),<br />
&nbsp; &nbsp; &nbsp; &nbsp; .SDcols = c("arr_delay", "dep_delay")]</blockquote>
<br />
<span style="font-size: x-large;">Q5. Pull first value of 'air_time' by 'origin' and then sum the returned values when it is greater than 300</span><br />
<blockquote class="tr_bq">
mydata[, .SD[1], .SDcols="air_time", by=origin][air_time &gt; 300, sum(air_time)]</blockquote>
<br />
<b>Endnotes</b></span><br />
<br />
This package provides a one-stop solution for data wrangling in R. It offers two main benefits - less coding and lower computing time. However, it's not a first choice of some of R programmers. Some prefer <b>dplyr</b> package for its simplicity. I would recommend learn both the packages. Check out <a href="http://www.listendata.com/2016/08/dplyr-tutorial.html" target="_blank"><b>dplyr tutorial</b></a>. If you are working on data having size less than 1 GB, you can use dplyr package. It offers decent speed but slower than data.table package.</div>
</div>

<br>
<br>
<br>
<br>

<script>
	$(function() {
		var toc = $('#toc');

		function buildLink(text, href) {
			return $('<a href="' + href + '" target="_self">' + text + '</a><br>');
		}

		$('h2').each(function(i) {
			var topic = $(this), topicNumber = i + 1;
			toc.append(
				buildLink(topic.text(), '#topic-' + topicNumber)
			);
			topic.attr('id', 'topic-' + topicNumber);
		});

	});
</script>
</body>
</html>


//improved version!
<script>
	$(function() {
		var toc = $('#toc');
		$('.topicline').each(function(i) {
			var topic = $(this), topicNumber = i + 1;
			toc.append('<a href="#topic-'+topicNumber+'" target="_self">'+topic.text()+'</a><br>');
			topic.attr('id', 'topic-' + topicNumber);
		});
	});
</script>
