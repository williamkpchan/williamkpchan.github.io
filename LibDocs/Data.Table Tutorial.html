<base target="_blank"><html><head><title>data.table</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src="https://williamkpchan.github.io/lazyload.min.js"></script>
<script src='https://williamkpchan.github.io/mainscript.js'></script>
<script src="https://williamkpchan.github.io/commonfunctions.js"></script>
<script>
  var showTopicNumber = true;
  var bookid = "data.table"
  var markerName = "h2, h3, .topicline"
</script>
<style>
body{width:96%;margin-left: 2%; font-size:24px;}
h1, h2 {color: gold;}
.topicline, strong {color: orange;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px;}
</style></head><body onkeypress="chkKey()"><center>
<h1>data.table</h1>
<a href="#mustWatch" class="red goldbs" target="_self">Must Watch!</a>
<br>
<div id="toc"></div></center>
<br>
<center><span class="red">MustWatch</span></center>

<pre>



<h2><span class="orange">Introduction to data.table</span></h2>
<h4>2020-10-17</h4>
This vignette introduces the <code>data.table</code> syntax, its general form, how to <em>subset</em> rows, <em>select and compute</em> on columns, and perform aggregations <em>by group</em>. 
Familiarity with <code>data.frame</code> data structure from base R is useful, but not essential to follow this vignette.

<h2><span class="orange">Data analysis using <code>data.table</code></span></h2>
Data manipulation operations such as <em>subset</em>, <em>group</em>, <em>update</em>, <em>join</em> etc., are all inherently related. 
Keeping these <em>related operations together</em> allows for:

<em>concise</em> and <em>consistent</em> syntax irrespective of the set of operations you would like to perform to achieve your end goal.

performing analysis <em>fluidly</em> without the cognitive burden of having to map each operation to a particular function from a potentially huge set of functions available before performing the analysis.

<em>automatically</em> optimising operations internally, and very effectively, by knowing precisely the data required for each operation, leading to very fast and memory efficient code.

Briefly, if you are interested in reducing <em>programming</em> and <em>compute</em> time tremendously, then this package is for you. 
The philosophy that <code>data.table</code> adheres to makes this possible. 
Our goal is to illustrate it through this series of vignettes.

<h2><span class="orange">Data</span></h2>
In this vignette, we will use NYC-flights14 data obtained by flights package (available on GitHub only). 
It contains On-Time flights data from the Bureau of Transporation Statistics for all the flights that departed from New York City airports in 2014 (inspired by nycflights13). 
The data is available only for Jan-Oct’14.

We can use <code>data.table</code>’s fast-and-friendly file reader <code>fread</code> to load <code>flights</code> directly as follows:

<code>input &lt;- if (file.exists("flights14.csv")) {
   "flights14.csv"
} else {
  "https://raw.githubusercontent.com/Rdatatable/data.table/master/vignettes/flights14.csv"
}
flights &lt;- fread(input)
flights
#         year month day dep_delay arr_delay carrier origin dest air_time distance hour
#      1: 2014     1   1        14        13      AA    JFK  LAX      359     2475    9
#      2: 2014     1   1        -3        13      AA    JFK  LAX      363     2475   11
#      3: 2014     1   1         2         9      AA    JFK  LAX      351     2475   19
#      4: 2014     1   1        -8       -26      AA    LGA  PBI      157     1035    7
#      5: 2014     1   1         2         1      AA    JFK  LAX      350     2475   13
#     ---                                                                              
# 253312: 2014    10  31         1       -30      UA    LGA  IAH      201     1416   14
# 253313: 2014    10  31        -5       -14      UA    EWR  IAH      189     1400    8
# 253314: 2014    10  31        -8        16      MQ    LGA  RDU       83      431   11
# 253315: 2014    10  31        -4        15      MQ    LGA  DTW       75      502   11
# 253316: 2014    10  31        -5         1      MQ    LGA  SDF      110      659    8
dim(flights)
# [1] 253316     11</code>

Aside: <code>fread</code> accepts <code>http</code> and <code>https</code> URLs directly as well as operating system commands such as <code>sed</code> and <code>awk</code> output. 
See <code>?fread</code> for examples.

<h2><span class="orange">Introduction</span></h2>
In this vignette, we will

Start with basics - what is a <code>data.table</code>, its general form, how to <em>subset</em> rows, how to <em>select and compute</em> on columns;

Then we will look at performing data aggregations by group

<h2><span class="orange">1. Basics</span></h2>

<h3> - a) What is <code>data.table</code>?</h3>
<code>data.table</code> is an R package that provides <strong>an enhanced version</strong> of <code>data.frame</code>s, which are the standard data structure for storing data in <code>base</code> R. 
In the Data section above, we already created a <code>data.table</code> using <code>fread()</code>. 
We can also create one using the <code>data.table()</code> function. 
Here is an example:

<code>DT = data.table(
  ID = c("b","b","b","a","a","c"),
  a = 1:6,
  b = 7:12,
  c = 13:18
)
DT
#    ID a  b  c
# 1:  b 1  7 13
# 2:  b 2  8 14
# 3:  b 3  9 15
# 4:  a 4 10 16
# 5:  a 5 11 17
# 6:  c 6 12 18
class(DT$ID)
# [1] "character"</code>

You can also convert existing objects to a <code>data.table</code> using <code>setDT()</code> (for <code>data.frame</code>s and <code>list</code>s) and <code>as.data.table()</code> (for other structures); the difference is beyond the scope of this vignette, see <code>?setDT</code> and <code>?as.data.table</code> for more details.

<h4>Note that:</h4>
Unlike <code>data.frame</code>s, columns of <code>character</code> type are <em>never</em> converted to <code>factors</code> by default.

Row numbers are printed with a <code>:</code> in order to visually separate the row number from the first column.

When the number of rows to print exceeds the global option <code>datatable.print.nrows</code> (default = 100), it automatically prints only the top 5 and bottom 5 rows (as can be seen in the Data section). 
If you’ve had a lot of experience with <code>data.frame</code>s, you may have found yourself waiting around while larger tables print-and-page, sometimes seemingly endlessly. 
You can query the default number like so:

<code>getOption("datatable.print.nrows")</code>

<code>data.table</code> doesn’t set or use <em>row names</em>, ever. 
We will see why in the <em>“Keys and fast binary search based subset”</em> vignette.

<h3> - b) General form - in what way is a <code>data.table</code> <em>enhanced</em>?</h3>
In contrast to a <code>data.frame</code>, you can do <em>a lot more</em> than just subsetting rows and selecting columns within the frame of a <code>data.table</code>, i.e., within <code>[ ... 
]</code> (NB: we might also refer to writing things inside <code>DT[...]</code> as “querying <code>DT</code>”, in analogy to SQL). 
To understand it we will have to first look at the <em>general form</em> of <code>data.table</code> syntax, as shown below:

<code>DT[i, j, by]

##   R:                 i                 j        by
## SQL:  where | order by   select | update  group by</code>

Users who have an SQL background might perhaps immediately relate to this syntax.

<h4>The way to read it (out loud) is:</h4>
Take <code>DT</code>, subset/reorder rows using <code>i</code>, then calculate <code>j</code>, grouped by <code>by</code>.

Let’s begin by looking at <code>i</code> and <code>j</code> first - subsetting rows and operating on columns.

<h3> - c) Subset rows in <code>i</code></h3>

<h4>– Get all the flights with “JFK” as the origin airport in the month of June.</h4>
<code>ans &lt;- flights[origin == "JFK" &amp; month == 6L]
head(ans)
#    year month day dep_delay arr_delay carrier origin dest air_time distance hour
# 1: 2014     6   1        -9        -5      AA    JFK  LAX      324     2475    8
# 2: 2014     6   1       -10       -13      AA    JFK  LAX      329     2475   12
# 3: 2014     6   1        18        -1      AA    JFK  LAX      326     2475    7
# 4: 2014     6   1        -6       -16      AA    JFK  LAX      320     2475   10
# 5: 2014     6   1        -4       -45      AA    JFK  LAX      326     2475   18
# 6: 2014     6   1        -6       -23      AA    JFK  LAX      329     2475   14</code>

Within the frame of a <code>data.table</code>, columns can be referred to <em>as if they are variables</em>, much like in SQL or Stata. 
Therefore, we simply refer to <code>origin</code> and <code>month</code> as if they are variables. 
We do not need to add the prefix <code>flights$</code> each time. 
Nevertheless, using <code>flights$origin</code> and <code>flights$month</code> would work just fine.

The <em>row indices</em> that satisfy the condition <code>origin == "JFK" &amp; month == 6L</code> are computed, and since there is nothing else left to do, all columns from <code>flights</code> at rows corresponding to those <em>row indices</em> are simply returned as a <code>data.table</code>.

A comma after the condition in <code>i</code> is not required. 
But <code>flights[origin == "JFK" &amp; month == 6L, ]</code> would work just fine. 
In <code>data.frame</code>s, however, the comma is necessary.

<h4>– Get the first two rows from <code>flights</code>.</h4>
<code>ans &lt;- flights[1:2]
ans
#    year month day dep_delay arr_delay carrier origin dest air_time distance hour
# 1: 2014     1   1        14        13      AA    JFK  LAX      359     2475    9
# 2: 2014     1   1        -3        13      AA    JFK  LAX      363     2475   11</code>

In this case, there is no condition. 
The row indices are already provided in <code>i</code>. 
We therefore return a <code>data.table</code> with all columns from <code>flights</code> at rows for those <em>row indices</em>.

<h4>– Sort <code>flights</code> first by column <code>origin</code> in <em>ascending</em> order, and then by <code>dest</code> in <em>descending</em> order:</h4>
We can use the R function <code>order()</code> to accomplish this.

<code>ans &lt;- flights[order(origin, -dest)]
head(ans)
#    year month day dep_delay arr_delay carrier origin dest air_time distance hour
# 1: 2014     1   5         6        49      EV    EWR  XNA      195     1131    8
# 2: 2014     1   6         7        13      EV    EWR  XNA      190     1131    8
# 3: 2014     1   7        -6       -13      EV    EWR  XNA      179     1131    8
# 4: 2014     1   8        -7       -12      EV    EWR  XNA      184     1131    8
# 5: 2014     1   9        16         7      EV    EWR  XNA      181     1131    8
# 6: 2014     1  13        66        66      EV    EWR  XNA      188     1131    9</code>

<h4><code>order()</code> is internally optimised</h4>
We can use “-” on a <code>character</code> columns within the frame of a <code>data.table</code> to sort in decreasing order.

In addition, <code>order(...)</code> within the frame of a <code>data.table</code> uses <code>data.table</code>’s internal fast radix order <code>forder()</code>. 
This sort provided such a compelling improvement over R’s <code>base::order</code> that the R project adopted the <code>data.table</code> algorithm as its default sort in 2016 for R 3.3.0, see <code>?sort</code> and the R Release NEWS.

We will discuss <code>data.table</code>’s fast order in more detail in the <em><code>data.table</code> internals</em> vignette.

<h3> - d) Select column(s) in <code>j</code></h3>

<h4>– Select <code>arr_delay</code> column, but return it as a <em>vector</em>.</h4>
<code>ans &lt;- flights[, arr_delay]
head(ans)
# [1]  13  13   9 -26   1   0</code>

Since columns can be referred to as if they are variables within the frame of <code>data.table</code>s, we directly refer to the <em>variable</em> we want to subset. 
Since we want <em>all the rows</em>, we simply skip <code>i</code>.

It returns <em>all</em> the rows for the column <code>arr_delay</code>.

<h4>– Select <code>arr_delay</code> column, but return as a <code>data.table</code> instead.</h4>
<code>ans &lt;- flights[, list(arr_delay)]
head(ans)
#    arr_delay
# 1:        13
# 2:        13
# 3:         9
# 4:       -26
# 5:         1
# 6:         0</code>

We wrap the <em>variables</em> (column names) within <code>list()</code>, which ensures that a <code>data.table</code> is returned. 
In case of a single column name, not wrapping with <code>list()</code> returns a vector instead, as seen in the previous example.

<code>data.table</code> also allows wrapping columns with <code>.()</code> instead of <code>list()</code>. 
It is an <em>alias</em> to <code>list()</code>; they both mean the same. 
Feel free to use whichever you prefer; we have noticed most users seem to prefer <code>.()</code> for conciseness, so we will continue to use <code>.()</code> hereafter.

<code>data.table</code>s (and <code>data.frame</code>s) are internally <code>list</code>s as well, with the stipulation that each element has the same length and the <code>list</code> has a <code>class</code> attribute. 
Allowing <code>j</code> to return a <code>list</code> enables converting and returning <code>data.table</code> very efficiently.

<h4>Tip:</h4>
As long as <code>j-expression</code> returns a <code>list</code>, each element of the list will be converted to a column in the resulting <code>data.table</code>. 
This makes <code>j</code> quite powerful, as we will see shortly. 
It is also very important to understand this for when you’d like to make more complicated queries!!

<h4>– Select both <code>arr_delay</code> and <code>dep_delay</code> columns.</h4>
<code>ans &lt;- flights[, .(arr_delay, dep_delay)]
head(ans)
#    arr_delay dep_delay
# 1:        13        14
# 2:        13        -3
# 3:         9         2
# 4:       -26        -8
# 5:         1         2
# 6:         0         4

## alternatively
# ans &lt;- flights[, list(arr_delay, dep_delay)]</code>

Wrap both columns within <code>.()</code>, or <code>list()</code>. 
That’s it.

<h4>– Select both <code>arr_delay</code> and <code>dep_delay</code> columns <em>and</em> rename them to <code>delay_arr</code> and <code>delay_dep</code>.</h4>
Since <code>.()</code> is just an alias for <code>list()</code>, we can name columns as we would while creating a <code>list</code>.

<code>ans &lt;- flights[, .(delay_arr = arr_delay, delay_dep = dep_delay)]
head(ans)
#    delay_arr delay_dep
# 1:        13        14
# 2:        13        -3
# 3:         9         2
# 4:       -26        -8
# 5:         1         2
# 6:         0         4</code>

That’s it.

<h3> - e) Compute or <em>do</em> in <code>j</code></h3>

<h4>– How many trips have had total delay &lt; 0?</h4>
<code>ans &lt;- flights[, sum( (arr_delay + dep_delay) &lt; 0 )]
ans
# [1] 141814</code>

<h4>What’s happening here?</h4>
<code>data.table</code>’s <code>j</code> can handle more than just <em>selecting columns</em> - it can handle <em>expressions</em>, i.e., <em>computing on columns</em>. 
This shouldn’t be surprising, as columns can be referred to as if they are variables. 
Then we should be able to <em>compute</em> by calling functions on those variables. 
And that’s what precisely happens here.

<h3> - f) Subset in <code>i</code> <em>and</em> do in <code>j</code></h3>

<h4>– Calculate the average arrival and departure delay for all flights with “JFK” as the origin airport in the month of June.</h4>
<code>ans &lt;- flights[origin == "JFK" &amp; month == 6L,
               .(m_arr = mean(arr_delay), m_dep = mean(dep_delay))]
ans
#       m_arr    m_dep
# 1: 5.839349 9.807884</code>

We first subset in <code>i</code> to find matching <em>row indices</em> where <code>origin</code> airport equals <code>"JFK"</code>, and <code>month</code> equals <code>6L</code>. 
We <em>do not</em> subset the <em>entire</em> <code>data.table</code> corresponding to those rows <em>yet</em>.

Now, we look at <code>j</code> and find that it uses only <em>two columns</em>. 
And what we have to do is to compute their <code>mean()</code>. 
Therefore we subset just those columns corresponding to the matching rows, and compute their <code>mean()</code>.

Because the three main components of the query (<code>i</code>, <code>j</code> and <code>by</code>) are <em>together</em> inside <code>[...]</code>, <code>data.table</code> can see all three and optimise the query altogether <em>before evaluation</em>, not each separately. 
We are able to therefore avoid the entire subset (i.e., subsetting the columns <em>besides</em> <code>arr_delay</code> and <code>dep_delay</code>), for both speed and memory efficiency.

<h4>– How many trips have been made in 2014 from “JFK” airport in the month of June?</h4>
<code>ans &lt;- flights[origin == "JFK" &amp; month == 6L, length(dest)]
ans
# [1] 8422</code>

The function <code>length()</code> requires an input argument. 
We just needed to compute the number of rows in the subset. 
We could have used any other column as input argument to <code>length()</code> really. 
This approach is reminiscent of <code>SELECT COUNT(dest) FROM flights WHERE origin = &#39;JFK&#39; AND month = 6</code> in SQL.

This type of operation occurs quite frequently, especially while grouping (as we will see in the next section), to the point where <code>data.table</code> provides a <em>special symbol</em> <code>.N</code> for it.

<h4>Special symbol <code>.N</code>:</h4>
<code>.N</code> is a special built-in variable that holds the number of observations <em>in the current group</em>. 
It is particularly useful when combined with <code>by</code> as we’ll see in the next section. 
In the absence of group by operations, it simply returns the number of rows in the subset.

So we can now accomplish the same task by using <code>.N</code> as follows:

<code>ans &lt;- flights[origin == "JFK" &amp; month == 6L, .N]
ans
# [1] 8422</code>

Once again, we subset in <code>i</code> to get the <em>row indices</em> where <code>origin</code> airport equals <em>“JFK”</em>, and <code>month</code> equals <em>6</em>.

We see that <code>j</code> uses only <code>.N</code> and no other columns. 
Therefore the entire subset is not materialised. 
We simply return the number of rows in the subset (which is just the length of row indices).

Note that we did not wrap <code>.N</code> with <code>list()</code> or <code>.()</code>. 
Therefore a vector is returned.

We could have accomplished the same operation by doing <code>nrow(flights[origin == "JFK" &amp; month == 6L])</code>. 
However, it would have to subset the entire <code>data.table</code> first corresponding to the <em>row indices</em> in <code>i</code> <em>and then</em> return the rows using <code>nrow()</code>, which is unnecessary and inefficient. 
We will cover this and other optimisation aspects in detail under the <em><code>data.table</code> design</em> vignette.

<h3> - g) Great! But how can I refer to columns by names in <code>j</code> (like in a <code>data.frame</code>)?</h3>
If you’re writing out the column names explicitly, there’s no difference vis-a-vis <code>data.frame</code> (since v1.9.8).

<h4>– Select both <code>arr_delay</code> and <code>dep_delay</code> columns the <code>data.frame</code> way.</h4>
<code>ans &lt;- flights[, c("arr_delay", "dep_delay")]
head(ans)
#    arr_delay dep_delay
# 1:        13        14
# 2:        13        -3
# 3:         9         2
# 4:       -26        -8
# 5:         1         2
# 6:         0         4</code>

If you’ve stored the desired columns in a character vector, there are two options: Using the <code>..</code> prefix, or using the <code>with</code> argument.

<h4>– Select columns named in a variable using the <code>..</code> prefix</h4>
<code>select_cols = c("arr_delay", "dep_delay")
flights[ , ..select_cols]
#         arr_delay dep_delay
#      1:        13        14
#      2:        13        -3
#      3:         9         2
#      4:       -26        -8
#      5:         1         2
#     ---                    
# 253312:       -30         1
# 253313:       -14        -5
# 253314:        16        -8
# 253315:        15        -4
# 253316:         1        -5</code>

For those familiar with the Unix terminal, the <code>..</code> prefix should be reminiscent of the “up-one-level” command, which is analogous to what’s happening here – the <code>..</code> signals to <code>data.table</code> to look for the <code>select_cols</code> variable “up-one-level”, i.e., in the global environment in this case.

<h4>– Select columns named in a variable using <code>with = FALSE</code></h4>
<code>flights[ , select_cols, with = FALSE]
#         arr_delay dep_delay
#      1:        13        14
#      2:        13        -3
#      3:         9         2
#      4:       -26        -8
#      5:         1         2
#     ---                    
# 253312:       -30         1
# 253313:       -14        -5
# 253314:        16        -8
# 253315:        15        -4
# 253316:         1        -5</code>

The argument is named <code>with</code> after the R function <code>with()</code> because of similar functionality. 
Suppose you have a <code>data.frame</code> <code>DF</code> and you’d like to subset all rows where <code>x &gt; 1</code>. 
In <code>base</code> R you can do the following:

<code>DF = data.frame(x = c(1,1,1,2,2,3,3,3), y = 1:8)

## (1) normal way
DF[DF$x &gt; 1, ] # data.frame needs that &#39;,&#39; as well
#   x y
# 4 2 4
# 5 2 5
# 6 3 6
# 7 3 7
# 8 3 8

## (2) using with
DF[with(DF, x &gt; 1), ]
#   x y
# 4 2 4
# 5 2 5
# 6 3 6
# 7 3 7
# 8 3 8</code>

Using <code>with()</code> in (2) allows using <code>DF</code>’s column <code>x</code> as if it were a variable.

Hence the argument name <code>with</code> in <code>data.table</code>. 
Setting <code>with = FALSE</code> disables the ability to refer to columns as if they are variables, thereby restoring the “<code>data.frame</code> mode”.

We can also <em>deselect</em> columns using <code>-</code> or <code>!</code>. 
For example:

<code>## not run

# returns all columns except arr_delay and dep_delay
ans &lt;- flights[, !c("arr_delay", "dep_delay")]
# or
ans &lt;- flights[, -c("arr_delay", "dep_delay")]</code>

From <code>v1.9.5+</code>, we can also select by specifying start and end column names, e.g., <code>year:day</code> to select the first three columns.

<code>## not run

# returns year,month and day
ans &lt;- flights[, year:day]
# returns day, month and year
ans &lt;- flights[, day:year]
# returns all columns except year, month and day
ans &lt;- flights[, -(year:day)]
ans &lt;- flights[, !(year:day)]</code>

This is particularly handy while working interactively.

<code>with = TRUE</code> is the default in <code>data.table</code> because we can do much more by allowing <code>j</code> to handle expressions - especially when combined with <code>by</code>, as we’ll see in a moment.

<h2><span class="orange">2. Aggregations</span></h2>
We’ve already seen <code>i</code> and <code>j</code> from <code>data.table</code>’s general form in the previous section. 
In this section, we’ll see how they can be combined together with <code>by</code> to perform operations <em>by group</em>. 
Let’s look at some examples.

<h3> - a) Grouping using <code>by</code></h3>

<h4>– How can we get the number of trips corresponding to each origin airport?</h4>
<code>ans &lt;- flights[, .(.N), by = .(origin)]
ans
#    origin     N
# 1:    JFK 81483
# 2:    LGA 84433
# 3:    EWR 87400

## or equivalently using a character vector in &#39;by&#39;
# ans &lt;- flights[, .(.N), by = "origin"]</code>

We know <code>.N</code> is a special variable that holds the number of rows in the current group. 
Grouping by <code>origin</code> obtains the number of rows, <code>.N</code>, for each group.

By doing <code>head(flights)</code> you can see that the origin airports occur in the order <em>“JFK”</em>, <em>“LGA”</em> and <em>“EWR”</em>. 
The original order of grouping variables is preserved in the result. 
<em>This is important to keep in mind!</em>

Since we did not provide a name for the column returned in <code>j</code>, it was named <code>N</code> automatically by recognising the special symbol <code>.N</code>.

<code>by</code> also accepts a character vector of column names. 
This is particularly useful for coding programmatically, e.g., designing a function with the grouping columns as a (<code>character</code> vector) function argument.

When there’s only one column or expression to refer to in <code>j</code> and <code>by</code>, we can drop the <code>.()</code> notation. 
This is purely for convenience. 
We could instead do:

<code>ans &lt;- flights[, .N, by = origin]
ans
#    origin     N
# 1:    JFK 81483
# 2:    LGA 84433
# 3:    EWR 87400</code>

We’ll use this convenient form wherever applicable hereafter.

<h4>– How can we calculate the number of trips for each origin airport for carrier code <code>"AA"</code>?</h4>
The unique carrier code <code>"AA"</code> corresponds to <em>American Airlines Inc.</em>

<code>ans &lt;- flights[carrier == "AA", .N, by = origin]
ans
#    origin     N
# 1:    JFK 11923
# 2:    LGA 11730
# 3:    EWR  2649</code>

We first obtain the row indices for the expression <code>carrier == "AA"</code> from <code>i</code>.

Using those <em>row indices</em>, we obtain the number of rows while grouped by <code>origin</code>. 
Once again no columns are actually materialised here, because the <code>j-expression</code> does not require any columns to be actually subsetted and is therefore fast and memory efficient.

<h4>– How can we get the total number of trips for each <code>origin, dest</code> pair for carrier code <code>"AA"</code>?</h4>
<code>ans &lt;- flights[carrier == "AA", .N, by = .(origin, dest)]
head(ans)
#    origin dest    N
# 1:    JFK  LAX 3387
# 2:    LGA  PBI  245
# 3:    EWR  LAX   62
# 4:    JFK  MIA 1876
# 5:    JFK  SEA  298
# 6:    EWR  MIA  848

## or equivalently using a character vector in &#39;by&#39;
# ans &lt;- flights[carrier == "AA", .N, by = c("origin", "dest")]</code>

<code>by</code> accepts multiple columns. 
We just provide all the columns by which to group by. 
Note the use of <code>.()</code> again in <code>by</code> – again, this is just shorthand for <code>list()</code>, and <code>list()</code> can be used here as well. 
Again, we’ll stick with <code>.()</code> in this vignette.

<h4>– How can we get the average arrival and departure delay for each <code>orig,dest</code> pair for each month for carrier code <code>"AA"</code>?</h4>
<code>ans &lt;- flights[carrier == "AA",
        .(mean(arr_delay), mean(dep_delay)),
        by = .(origin, dest, month)]
ans
#      origin dest month         V1         V2
#   1:    JFK  LAX     1   6.590361 14.2289157
#   2:    LGA  PBI     1  -7.758621  0.3103448
#   3:    EWR  LAX     1   1.366667  7.5000000
#   4:    JFK  MIA     1  15.720670 18.7430168
#   5:    JFK  SEA     1  14.357143 30.7500000
#  ---                                        
# 196:    LGA  MIA    10  -6.251799 -1.4208633
# 197:    JFK  MIA    10  -1.880184  6.6774194
# 198:    EWR  PHX    10  -3.032258 -4.2903226
# 199:    JFK  MCO    10 -10.048387 -1.6129032
# 200:    JFK  DCA    10  16.483871 15.5161290</code>

Since we did not provide column names for the expressions in <code>j</code>, they were automatically generated as <code>V1</code> and <code>V2</code>.

Once again, note that the input order of grouping columns is preserved in the result.

Now what if we would like to order the result by those grouping columns <code>origin</code>, <code>dest</code> and <code>month</code>?

<h3> - b) Sorted <code>by</code>: <code>keyby</code></h3>
<code>data.table</code> retaining the original order of groups is intentional and by design. 
There are cases when preserving the original order is essential. 
But at times we would like to automatically sort by the variables in our grouping.

<h4>– So how can we directly order by all the grouping variables?</h4>
<code>ans &lt;- flights[carrier == "AA",
        .(mean(arr_delay), mean(dep_delay)),
        keyby = .(origin, dest, month)]
ans
#      origin dest month         V1         V2
#   1:    EWR  DFW     1   6.427673 10.0125786
#   2:    EWR  DFW     2  10.536765 11.3455882
#   3:    EWR  DFW     3  12.865031  8.0797546
#   4:    EWR  DFW     4  17.792683 12.9207317
#   5:    EWR  DFW     5  18.487805 18.6829268
#  ---                                        
# 196:    LGA  PBI     1  -7.758621  0.3103448
# 197:    LGA  PBI     2  -7.865385  2.4038462
# 198:    LGA  PBI     3  -5.754098  3.0327869
# 199:    LGA  PBI     4 -13.966667 -4.7333333
# 200:    LGA  PBI     5 -10.357143 -6.8571429</code>

All we did was to change <code>by</code> to <code>keyby</code>. 
This automatically orders the result by the grouping variables in increasing order. 
In fact, due to the internal implementation of <code>by</code> first requiring a sort before recovering the original table’s order, <code>keyby</code> is typically faster than <code>by</code> because it doesn’t require this second step.

<strong>Keys:</strong> Actually <code>keyby</code> does a little more than <em>just ordering</em>. 
It also <em>sets a key</em> after ordering by setting an <code>attribute</code> called <code>sorted</code>.

We’ll learn more about <code>keys</code> in the <em>Keys and fast binary search based subset</em> vignette; for now, all you have to know is that you can use <code>keyby</code> to automatically order the result by the columns specified in <code>by</code>.

<h3> - c) Chaining</h3>
Let’s reconsider the task of getting the total number of trips for each <code>origin, dest</code> pair for carrier <em>“AA”</em>.

<code>ans &lt;- flights[carrier == "AA", .N, by = .(origin, dest)]</code>

<h4>– How can we order <code>ans</code> using the columns <code>origin</code> in ascending order, and <code>dest</code> in descending order?</h4>
We can store the intermediate result in a variable, and then use <code>order(origin, -dest)</code> on that variable. 
It seems fairly straightforward.

<code>ans &lt;- ans[order(origin, -dest)]
head(ans)
#    origin dest    N
# 1:    EWR  PHX  121
# 2:    EWR  MIA  848
# 3:    EWR  LAX   62
# 4:    EWR  DFW 1618
# 5:    JFK  STT  229
# 6:    JFK  SJU  690</code>

Recall that we can use <code>-</code> on a <code>character</code> column in <code>order()</code> within the frame of a <code>data.table</code>. 
This is possible to due <code>data.table</code>’s internal query optimisation.

Also recall that <code>order(...)</code> with the frame of a <code>data.table</code> is <em>automatically optimised</em> to use <code>data.table</code>’s internal fast radix order <code>forder()</code> for speed.

But this requires having to assign the intermediate result and then overwriting that result. 
We can do one better and avoid this intermediate assignment to a temporary variable altogether by <em>chaining</em> expressions.

<code>ans &lt;- flights[carrier == "AA", .N, by = .(origin, dest)][order(origin, -dest)]
head(ans, 10)
#     origin dest    N
#  1:    EWR  PHX  121
#  2:    EWR  MIA  848
#  3:    EWR  LAX   62
#  4:    EWR  DFW 1618
#  5:    JFK  STT  229
#  6:    JFK  SJU  690
#  7:    JFK  SFO 1312
#  8:    JFK  SEA  298
#  9:    JFK  SAN  299
# 10:    JFK  ORD  432</code>

We can tack expressions one after another, <em>forming a chain</em> of operations, i.e., <code>DT[ ... 
][ ... 
][ ... 
]</code>.

Or you can also chain them vertically:

<code>DT[ ...
   ][ ...
     ][ ...
       ]</code>

<h3> - d) Expressions in <code>by</code></h3>

<h4>– Can <code>by</code> accept <em>expressions</em> as well or does it just take columns?</h4>
Yes it does. 
As an example, if we would like to find out how many flights started late but arrived early (or on time), started and arrived late etc…

<code>ans &lt;- flights[, .N, .(dep_delay&gt;0, arr_delay&gt;0)]
ans
#    dep_delay arr_delay      N
# 1:      TRUE      TRUE  72836
# 2:     FALSE      TRUE  34583
# 3:     FALSE     FALSE 119304
# 4:      TRUE     FALSE  26593</code>

The last row corresponds to <code>dep_delay &gt; 0 = TRUE</code> and <code>arr_delay &gt; 0 = FALSE</code>. 
We can see that 26593 flights started late but arrived early (or on time).

Note that we did not provide any names to <code>by-expression</code>. 
Therefore, names have been automatically assigned in the result. 
As with <code>j</code>, you can name these expressions as you would elements of any <code>list</code>, e.g. 
<code>DT[, .N, .(dep_delayed = dep_delay&gt;0, arr_delayed = arr_delay&gt;0)]</code>.

You can provide other columns along with expressions, for example: <code>DT[, .N, by = .(a, b&gt;0)]</code>.

<h3> - e) Multiple columns in <code>j</code> - <code>.SD</code></h3>

<h4>– Do we have to compute <code>mean()</code> for each column individually?</h4>
It is of course not practical to have to type <code>mean(myCol)</code> for every column one by one. 
What if you had 100 columns to average <code>mean()</code>?

How can we do this efficiently, concisely? To get there, refresh on this tip - <em>“As long as the <code>j</code>-expression returns a <code>list</code>, each element of the <code>list</code> will be converted to a column in the resulting <code>data.table</code>”</em>. 
Suppose we can refer to the <em>data subset for each group</em> as a variable <em>while grouping</em>, then we can loop through all the columns of that variable using the already- or soon-to-be-familiar base function <code>lapply()</code>. 
No new names to learn specific to <code>data.table</code>.

<h4>Special symbol <code>.SD</code>:</h4>
<code>data.table</code> provides a <em>special</em> symbol, called <code>.SD</code>. 
It stands for <strong>S</strong>ubset of <strong>D</strong>ata. 
It by itself is a <code>data.table</code> that holds the data for <em>the current group</em> defined using <code>by</code>.

Recall that a <code>data.table</code> is internally a <code>list</code> as well with all its columns of equal length.

Let’s use the <code>data.table</code> <code>DT</code> from before to get a glimpse of what <code>.SD</code> looks like.

<code>DT
#    ID a  b  c
# 1:  b 1  7 13
# 2:  b 2  8 14
# 3:  b 3  9 15
# 4:  a 4 10 16
# 5:  a 5 11 17
# 6:  c 6 12 18

DT[, print(.SD), by = ID]
#    a b  c
# 1: 1 7 13
# 2: 2 8 14
# 3: 3 9 15
#    a  b  c
# 1: 4 10 16
# 2: 5 11 17
#    a  b  c
# 1: 6 12 18
# Empty data.table (0 rows and 1 cols): ID</code>

<code>.SD</code> contains all the columns <em>except the grouping columns</em> by default.

It is also generated by preserving the original order - data corresponding to <code>ID = "b"</code>, then <code>ID = "a"</code>, and then <code>ID = "c"</code>.

To compute on (multiple) columns, we can then simply use the base R function <code>lapply()</code>.

<code>DT[, lapply(.SD, mean), by = ID]
#    ID   a    b    c
# 1:  b 2.0  8.0 14.0
# 2:  a 4.5 10.5 16.5
# 3:  c 6.0 12.0 18.0</code>

<code>.SD</code> holds the rows corresponding to columns <code>a</code>, <code>b</code> and <code>c</code> for that group. 
We compute the <code>mean()</code> on each of these columns using the already-familiar base function <code>lapply()</code>.

Each group returns a list of three elements containing the mean value which will become the columns of the resulting <code>data.table</code>.

Since <code>lapply()</code> returns a <code>list</code>, so there is no need to wrap it with an additional <code>.()</code> (if necessary, refer to this tip).

We are almost there. 
There is one little thing left to address. 
In our <code>flights</code> <code>data.table</code>, we only wanted to calculate the <code>mean()</code> of two columns <code>arr_delay</code> and <code>dep_delay</code>. 
But <code>.SD</code> would contain all the columns other than the grouping variables by default.

<h4>– How can we specify just the columns we would like to compute the <code>mean()</code> on?</h4>
<h4>.SDcols</h4>
Using the argument <code>.SDcols</code>. 
It accepts either column names or column indices. 
For example, <code>.SDcols = c("arr_delay", "dep_delay")</code> ensures that <code>.SD</code> contains only these two columns for each group.

Similar to part g), you can also provide the columns to remove instead of columns to keep using <code>-</code> or <code>!</code> sign as well as select consecutive columns as <code>colA:colB</code> and deselect consecutive columns as <code>!(colA:colB)</code> or <code>-(colA:colB)</code>.

Now let us try to use <code>.SD</code> along with <code>.SDcols</code> to get the <code>mean()</code> of <code>arr_delay</code> and <code>dep_delay</code> columns grouped by <code>origin</code>, <code>dest</code> and <code>month</code>.

<code>flights[carrier == "AA",                       ## Only on trips with carrier "AA"
        lapply(.SD, mean),                     ## compute the mean
        by = .(origin, dest, month),           ## for every &#39;origin,dest,month&#39;
        .SDcols = c("arr_delay", "dep_delay")] ## for just those specified in .SDcols
#      origin dest month  arr_delay  dep_delay
#   1:    JFK  LAX     1   6.590361 14.2289157
#   2:    LGA  PBI     1  -7.758621  0.3103448
#   3:    EWR  LAX     1   1.366667  7.5000000
#   4:    JFK  MIA     1  15.720670 18.7430168
#   5:    JFK  SEA     1  14.357143 30.7500000
#  ---                                        
# 196:    LGA  MIA    10  -6.251799 -1.4208633
# 197:    JFK  MIA    10  -1.880184  6.6774194
# 198:    EWR  PHX    10  -3.032258 -4.2903226
# 199:    JFK  MCO    10 -10.048387 -1.6129032
# 200:    JFK  DCA    10  16.483871 15.5161290</code>

<h3> - f) Subset <code>.SD</code> for each group:</h3>

<h4>– How can we return the first two rows for each <code>month</code>?</h4>
<code>ans &lt;- flights[, head(.SD, 2), by = month]
head(ans)
#    month year day dep_delay arr_delay carrier origin dest air_time distance hour
# 1:     1 2014   1        14        13      AA    JFK  LAX      359     2475    9
# 2:     1 2014   1        -3        13      AA    JFK  LAX      363     2475   11
# 3:     2 2014   1        -1         1      AA    JFK  LAX      358     2475    8
# 4:     2 2014   1        -5         3      AA    JFK  LAX      358     2475   11
# 5:     3 2014   1       -11        36      AA    JFK  LAX      375     2475    8
# 6:     3 2014   1        -3        14      AA    JFK  LAX      368     2475   11</code>

<code>.SD</code> is a <code>data.table</code> that holds all the rows for <em>that group</em>. 
We simply subset the first two rows as we have seen here already.

For each group, <code>head(.SD, 2)</code> returns the first two rows as a <code>data.table</code>, which is also a <code>list</code>, so we do not have to wrap it with <code>.()</code>.

<h3> - g) Why keep <code>j</code> so flexible?</h3>
So that we have a consistent syntax and keep using already existing (and familiar) base functions instead of learning new functions. 
To illustrate, let us use the <code>data.table</code> <code>DT</code> that we created at the very beginning under What is a data.table? section.

<h4>– How can we concatenate columns <code>a</code> and <code>b</code> for each group in <code>ID</code>?</h4>
<code>DT[, .(val = c(a,b)), by = ID]
#     ID val
#  1:  b   1
#  2:  b   2
#  3:  b   3
#  4:  b   7
#  5:  b   8
#  6:  b   9
#  7:  a   4
#  8:  a   5
#  9:  a  10
# 10:  a  11
# 11:  c   6
# 12:  c  12</code>

That’s it. 
There is no special syntax required. 
All we need to know is the base function <code>c()</code> which concatenates vectors and the tip from before.

<h4>– What if we would like to have all the values of column <code>a</code> and <code>b</code> concatenated, but returned as a list column?</h4>
<code>DT[, .(val = list(c(a,b))), by = ID]
#    ID         val
# 1:  b 1,2,3,7,8,9
# 2:  a  4, 5,10,11
# 3:  c        6,12</code>

Here, we first concatenate the values with <code>c(a,b)</code> for each group, and wrap that with <code>list()</code>. 
So for each group, we return a list of all concatenated values.

Note those commas are for display only. 
A list column can contain any object in each cell, and in this example, each cell is itself a vector and some cells contain longer vectors than others.

Once you start internalising usage in <code>j</code>, you will realise how powerful the syntax can be. 
A very useful way to understand it is by playing around, with the help of <code>print()</code>.

For example:

<code>## (1) look at the difference between
DT[, print(c(a,b)), by = ID]
# [1] 1 2 3 7 8 9
# [1]  4  5 10 11
# [1]  6 12
# Empty data.table (0 rows and 1 cols): ID

## (2) and
DT[, print(list(c(a,b))), by = ID]
# [[1]]
# [1] 1 2 3 7 8 9
# 
# [[1]]
# [1]  4  5 10 11
# 
# [[1]]
# [1]  6 12
# Empty data.table (0 rows and 1 cols): ID</code>

In (1), for each group, a vector is returned, with length = 6,4,2 here. 
However (2) returns a list of length 1 for each group, with its first element holding vectors of length 6,4,2. 
Therefore (1) results in a length of <code>6+4+2 = 12</code>, whereas (2) returns <code>1+1+1=3</code>.

<h2><span class="orange">Summary</span></h2>
The general form of <code>data.table</code> syntax is:

<code>DT[i, j, by]</code>

We have seen so far that,

<h4>Using <code>i</code>:</h4>
We can subset rows similar to a <code>data.frame</code>- except you don’t have to use <code>DT$</code> repetitively since columns within the frame of a <code>data.table</code> are seen as if they are <em>variables</em>.

We can also sort a <code>data.table</code> using <code>order()</code>, which internally uses <code>data.table</code>’s fast order for performance.

We can do much more in <code>i</code> by keying a <code>data.table</code>, which allows blazing fast subsets and joins. 
We will see this in the <em>“Keys and fast binary search based subsets”</em> and <em>“Joins and rolling joins”</em> vignette.

<h4>Using <code>j</code>:</h4>
Select columns the <code>data.table</code> way: <code>DT[, .(colA, colB)]</code>.

Select columns the <code>data.frame</code> way: <code>DT[, c("colA", "colB")]</code>.

Compute on columns: <code>DT[, .(sum(colA), mean(colB))]</code>.

Provide names if necessary: <code>DT[, .(sA =sum(colA), mB = mean(colB))]</code>.

Combine with <code>i</code>: <code>DT[colA &gt; value, sum(colB)]</code>.

<h4>Using <code>by</code>:</h4>
Using <code>by</code>, we can group by columns by specifying a <em>list of columns</em> or a <em>character vector of column names</em> or even <em>expressions</em>. 
The flexibility of <code>j</code>, combined with <code>by</code> and <code>i</code> makes for a very powerful syntax.

<code>by</code> can handle multiple columns and also <em>expressions</em>.

We can <code>keyby</code> grouping columns to automatically sort the grouped result.

We can use <code>.SD</code> and <code>.SDcols</code> in <code>j</code> to operate on multiple columns using already familiar base functions. 
Here are some examples:

<code>DT[, lapply(.SD, fun), by = ..., .SDcols = ...]</code> - applies <code>fun</code> to all columns specified in <code>.SDcols</code> while grouping by the columns specified in <code>by</code>.

<code>DT[, head(.SD, 2), by = ...]</code> - return the first two rows for each group.

<code>DT[col &gt; val, head(.SD, 1), by = ...]</code> - combine <code>i</code> along with <code>j</code> and <code>by</code>.

<h4>And remember the tip:</h4>
As long as <code>j</code> returns a <code>list</code>, each element of the list will become a column in the resulting <code>data.table</code>.

We will see how to <em>add/update/delete</em> columns <em>by reference</em> and how to combine them with <code>i</code> and <code>by</code> in the next vignette.

<h2><span class="orange">R : Data.Table Tutorial (with 50 Examples)</span></h2>
<a href="https://www.listendata.com/2016/10/r-data-table.html">DATA.TABLE TUTORIAL (WITH 50 EXAMPLES)</a>

The data.table R package is considered as the fastest package for data manipulation. This tutorial includes various examples and practice questions to make you familiar with the package. Analysts generally call R programming not compatible with big datasets ( &gt; 10 GB) as it is not memory efficient and loads everything into RAM. To change their perception, 'data.table' package comes into play. This package was designed to be concise and painless. There are many benchmarks done in the past to compare dplyr vs data.table. In every benchmark, data.table wins. The efficiency of this package was also compared with python' package (panda). And data.table wins. In CRAN, there are more than 200 packages that are dependent on data.table which makes it listed in the top 5 R's package.

<span class="topicline"> - data.table Syntax</span>

The syntax of data.table is shown in the image below :
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody>
<tr><td style="text-align: center;"><a href="https://2.bp.blogspot.com/-L-DIRIa6pi4/WAdcNIhzCfI/AAAAAAAAFiE/RN9-bFU6rZAIfZpAbY9v8pLFRpoTHbQxACLcB/s1600/Data%2BTable%2BSyntax.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="https://2.bp.blogspot.com/-L-DIRIa6pi4/WAdcNIhzCfI/AAAAAAAAFiE/RN9-bFU6rZAIfZpAbY9v8pLFRpoTHbQxACLcB/s1600/Data%2BTable%2BSyntax.png" /></a></td></tr>
<tr><td class="tr-caption" style="text-align: center;">data.table Syntax</td></tr>
</tbody></table>

<b>DT[ i , j , by]</b>


The first parameter of data.table <b>i </b>refers to rows. It implies subsetting rows. It is equivalent to <b>WHERE </b>clause in SQL
The second parameter of data.table <b>j </b>refers to columns. It implies subsetting columns (dropping / keeping). It is equivalent to <b>SELECT </b>clause in SQL.
The third parameter of data.table <b>by </b>refers to adding a group so that all calculations would be done within a group. Equivalent to SQL's <b>GROUP BY</b> clause.



<b>The data.table syntax is NOT RESTRICTED to only 3 parameters.</b> There are other arguments that can be added to data.table syntax. The list is as follows -


with, which
allow.cartesian
roll, rollends
.SD, .SDcols
on, mult, nomatch




The above arguments would be explained in the latter part of the post.



<span class="topicline"> - How to Install and load data.table Package</span>

install.packages("data.table") 

#load required library
library(data.table)


<span class="topicline"> - Read Data</span>

In data.table package, <b>fread() function </b>is available to read or get data from your computer or from a web page. It is equivalent to read.csv() function of base R.

mydata = fread("https://github.com/arunsrinivasan/satrdays-workshop/raw/master/flights_2014.csv")


<span class="topicline"> - Describe Data</span>

This dataset contains 253K observations and 17 columns. It constitutes information about flights' arrival or departure time, delays, flight cancellation and destination in year 2014.

nrow(mydata)
[1] 253316

ncol(mydata)
[1] 17

names(mydata)
 [1] "year"      "month"     "day"       "dep_time"  "dep_delay" "arr_time"  "arr_delay"
 [8] "cancelled" "carrier"   "tailnum"   "flight"    "origin"    "dest"      "air_time"
[15] "distance"  "hour"      "min"      

head(mydata)
   year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight
1: 2014     1   1      914        14     1238        13         0      AA  N338AA      1
2: 2014     1   1     1157        -3     1523        13         0      AA  N335AA      3
3: 2014     1   1     1902         2     2224         9         0      AA  N327AA     21
4: 2014     1   1      722        -8     1014       -26         0      AA  N3EHAA     29
5: 2014     1   1     1347         2     1706         1         0      AA  N319AA    117
6: 2014     1   1     1824         4     2145         0         0      AA  N3DEAA    119
   origin dest air_time distance hour min
1:    JFK  LAX      359     2475    9  14
2:    JFK  LAX      363     2475   11  57
3:    JFK  LAX      351     2475   19   2
4:    LGA  PBI      157     1035    7  22
5:    JFK  LAX      350     2475   13  47
6:    EWR  LAX      339     2454   18  24



<span class="topicline"> - Selecting or Keeping Columns</span>

<b>Suppose you need to select only 'origin' column.</b> You can use the code below -

dat1 = mydata[ , origin] # returns a vector
<b>The above line of code returns a vector not data.table.</b>
To get result in data.table format, run the code below :

dat1 = mydata[ , <b>.(origin)</b>] # returns a data.table
It can also be written like <b>data.frame way</b>

dat1 = mydata[, c("origin"), with=FALSE]

<b>Keeping a column based on column position</b>
dat2 =mydata[, 2, with=FALSE]
In this code, we are selecting <b>second column </b>from mydata<b>.</b>

<b>Keeping Multiple Columns</b>

The following code tells R to select 'origin', 'year', 'month', 'hour' columns.

dat3 = mydata[, .(origin, year, month, hour)]

<b>Keeping multiple columns based on column position</b>

You can keep second through fourth columns using the code below -

dat4 = mydata[, c(2:4), with=FALSE]

<b>Dropping a Column</b>

Suppose you want to include all the variables except one column, say. 'origin'. It can be easily done by adding <b>! sign</b> (implies negation in R)

dat5 = mydata[, !c("origin"), with=FALSE]

<b>Dropping Multiple Columns</b>

dat6 = mydata[, !c("origin", "year", "month"), with=FALSE]

<b>Keeping variables that contain 'dep'</b>

You can use <b>%like%</b> operator to find pattern. It is same as <b>base R's grepl() function</b>, <b>SQL's LIKE </b>operator and <b>SAS's CONTAINS </b>function.

dat7 = mydata[,names(mydata) <b>%like%</b> "dep", with=FALSE]


<span class="topicline"> - Rename Variables</span>

You can rename variables with <b>setnames()</b> function. In the following code, we are renaming a variable 'dest' to 'destination'.

setnames(mydata, c("dest"), c("Destination"))
To rename multiple variables, you can simply add variables in both the sides.

setnames(mydata, c("dest","origin"), c("Destination", "origin.of.flight"))


<span class="topicline"> - Subsetting Rows / Filtering</span>

<b>Suppose you are asked to find all the flights whose origin is 'JFK'.</b>

# Filter based on one variable
dat8 = mydata[origin == "JFK"]
<b>Select Multiple Values</b>

Filter all the flights whose origin is either 'JFK' or 'LGA'

dat9 = mydata[origin %in% c("JFK", "LGA")]

<b>Apply Logical Operator : NOT</b>

The following program selects all the flights whose origin is not equal to 'JFK' and 'LGA'

# Exclude Values
dat10 = mydata[<b>!</b>origin %in% c("JFK", "LGA")]

<b>Filter based on Multiple variables</b>

If you need to select all the flights whose origin is equal to 'JFK' and carrier = 'AA'

dat11 = mydata[origin == "JFK" &amp; carrier == "AA"]


<span class="topicline"> - Faster Data Manipulation with Indexing</span>

data.table uses <b>binary search algorithm</b> that makes data manipulation faster.

<b>Binary Search Algorithm</b>

Binary search is an efficient algorithm for finding a value from a <b>sorted </b>list of values. It involves repeatedly splitting in half the portion of the list that contains values, until you found the value that you were searching for.
Suppose you have the following values in a variable :

5, 10, 7, 20, 3, 13, 26
You are searching the value <b>20 </b>in the above list. See how binary search algorithm works -


First, we sort the values 
We would calculate the middle value i.e. 10.
We would check whether 20 = 10? No. 20 &lt; 10.
Since 20 is greater than 10, it should be somewhere after 10. So we can ignore all the values that are lower than or equal to 10.
We are left with 13, 20, 26. The middle value is 20. 
We would again check whether 20=20. Yes. the match found.


If we do not use this algorithm, we would have to search 5 in the whole list of seven values.

It is important to set <b>key </b>in your dataset which tells system that data is sorted by the key column</span>. For example, you have employee&#8217;s name, address, salary, designation, department, employee ID. We can use 'employee ID' as a key to search a particular employee.
<b>
</b>
<b>Set Key</b>

In this case, we are setting <b>'origin'</b> as a key in the dataset <b>mydata</b>.

# Indexing (Set Keys)
setkey(mydata, origin)
<b>Note : </b>It makes the data table <b>sorted </b>by the column 'origin'.

<b>How to filter when key is turned on.</b>

You don't need to refer the key column when you apply filter.

data12 = mydata[c("JFK", "LGA")]


<span class="topicline"> - Performance Comparison</span>

You can compare performance of the filtering process <b>(With or Without KEY).</b>

system.time(mydata[origin %in% c("JFK", "LGA")])
system.time(mydata[c("JFK", "LGA")])
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody>
<tr><td style="text-align: center;"><a href="https://2.bp.blogspot.com/-cNI65X2y9_c/WAeNAnOf54I/AAAAAAAAFiU/mgen0LJVzXkn0_DHd5ibxExSudLhAwWtwCLcB/s1600/Performance%2Bdata.table.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="https://2.bp.blogspot.com/-cNI65X2y9_c/WAeNAnOf54I/AAAAAAAAFiU/mgen0LJVzXkn0_DHd5ibxExSudLhAwWtwCLcB/s1600/Performance%2Bdata.table.png" /></a></td></tr>
<tr><td class="tr-caption" style="text-align: center;">Performance - With or without KEY</td></tr>
</tbody></table>
If you look at the real time in the image above, setting key makes filtering twice as faster than without using keys.

<b>Indexing Multiple Columns</b>

We can also set keys to multiple columns like we did below to columns 'origin' and 'dest'. See the example below.

setkey(mydata, origin, dest)
<b>Filtering while setting keys on Multiple Columns</b>

# First key column 'origin' matches &#8220;JFK&#8221; and second key column 'dest' matches &#8220;MIA&#8221;
mydata[.("JFK", "MIA")]
<b>It is equivalent to the following code :</b>

mydata[origin == "JFK" &amp; dest == "MIA"]
<b>To identify the column(s) indexed by</b>

key(mydata)

<b>Result :</b> It returns origin and dest as these are columns that are set keys.



<span class="topicline"> - Sorting Data</span>

We can sort data using <b>setorder()</b> function, By default, it sorts data on ascending order.

mydata01 = setorder(mydata, origin)

<b>Sorting Data on descending order</b>

In this case, we are sorting data by 'origin' variable on descending order.

mydata02 = setorder(mydata, <b>-</b>origin)

<b>Sorting Data based on multiple variables</b>

In this example, we tells R to reorder data first by origin on ascending order and then variable 'carrier'on descending order.

mydata03 = setorder(mydata, origin, -carrier)


<span class="topicline"> - Adding Columns (Calculation on rows)</span>

You can do any operation on rows by adding <b>:= operator</b>. In this example, we are subtracting 'dep_delay' variable from 'dep_time' variable to compute scheduled departure time.

mydata[, dep_sch:=dep_time - dep_delay]

<b>Adding Multiple Columns</b>
<b></b>
mydata002 = mydata[, c("dep_sch","arr_sch"):=list(dep_time - dep_delay, arr_time - arr_delay)]


<span class="topicline"> - IF THEN ELSE</span>

The 'IF THEN ELSE' conditions are very popular for recoding values. In data.table package, it can be done with the following methods :
<b>
</b>
<b>Method I :    </b>mydata[, flag:= 1*(min &lt; 50)]
<b>Method II :</b>   mydata[, flag:= ifelse(min &lt; 50, 1,0)]



It means to set flag= 1 if min is less than 50. Otherwise, set flag =0.



<span class="topicline"> - How to write Sub Queries (like SQL)</span>

We can use this format - <b>DT[ ] [ ] [ ] </b>to build a chain in data.table. It is like sub-queries like SQL.

mydata[, dep_sch:=dep_time - dep_delay][,.(dep_time,dep_delay,dep_sch)]
First, we are computing scheduled departure time and then selecting only relevant columns.



<span class="topicline"> - Summarize or Aggregate Columns</span>

Like SAS PROC MEANS procedure, we can generate summary statistics of specific variables. In this case, we are calculating mean, median, minimum and maximum value of variable arr_delay.

mydata[, .(mean = mean(arr_delay, na.rm = TRUE),
median = median(arr_delay, na.rm = TRUE),
min = min(arr_delay, na.rm = TRUE),
max = max(arr_delay, na.rm = TRUE))]
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto;"><tbody>
<tr><td style="text-align: center;"><a href="https://1.bp.blogspot.com/-TvbAiwlS0QY/WAeYoCr7lgI/AAAAAAAAFik/aR6CXMEpi8oXAWp3amjHepdNwNjsiQO_gCLcB/s1600/Summary.png" imageanchor="1" style="margin-left: auto; margin-right: auto; text-align: center;"><img border="0" src="https://1.bp.blogspot.com/-TvbAiwlS0QY/WAeYoCr7lgI/AAAAAAAAFik/aR6CXMEpi8oXAWp3amjHepdNwNjsiQO_gCLcB/s1600/Summary.png" /></a></td></tr>
<tr><td class="tr-caption" style="text-align: center;">Summarize with data.table package</td></tr>
</tbody></table>
<b>Summarize Multiple Columns</b>

To summarize multiple variables, we can simply write all the summary statistics function in a bracket. See the command below-

mydata[, .(mean(arr_delay), mean(dep_delay))]
If you need to calculate summary statistics for a larger list of variables, you can use <b>.SD and .SDcols</b> operators. The <b>.SD</b> operator implies <b>'Subset of Data'. </b>

mydata[, lapply(.SD, mean), .SDcols = c("arr_delay", "dep_delay")]
In this case, we are calculating mean of two variables - arr_delay and dep_delay.

<b>Summarize all numeric Columns</b>

By default, <b>.SD</b> takes all continuous variables (excluding grouping variables)

mydata[, lapply(.SD, mean)]

<b>Summarize with multiple statistics</b>

mydata[, sapply(.SD, function(x) c(mean=mean(x), median=median(x)))]



<span class="topicline"> - GROUP BY (Within Group Calculation)</span>

<b>Summarize by group 'origin</b>

mydata[, .(mean_arr_delay = mean(arr_delay, na.rm = TRUE)), by = origin]
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody>
<tr><td style="text-align: center;"><a href="https://3.bp.blogspot.com/-ZA_hGEWElZE/WAectuyCWrI/AAAAAAAAFiw/_9auwLWLPX4ZZ99eWnJEtHwKY02S-nYHQCLcB/s1600/Summary%2Bby%2Bgroup.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="https://3.bp.blogspot.com/-ZA_hGEWElZE/WAectuyCWrI/AAAAAAAAFiw/_9auwLWLPX4ZZ99eWnJEtHwKY02S-nYHQCLcB/s1600/Summary%2Bby%2Bgroup.png" /></a></td></tr>
<tr><td class="tr-caption" style="text-align: center;">Summary by group</td></tr>
</tbody></table>

<b>Use key column in a by operation</b>

Instead of 'by', you can use <b>keyby= </b>operator.

mydata[, .(mean_arr_delay = mean(arr_delay, na.rm = TRUE)), <b>keyby </b>= origin]


<b>Summarize multiple variables by group 'origin'</b>

mydata[, .(mean(arr_delay, na.rm = TRUE), mean(dep_delay, na.rm = TRUE)), by = origin]
 Or it can be written like below -

mydata[, lapply(.SD, mean, na.rm = TRUE), .SDcols = c("arr_delay", "dep_delay"), by = origin]

<span class="topicline"> - Remove Duplicates</span>

You can remove non-unique / duplicate cases with unique() function. Suppose you want to eliminate duplicates based on a variable, say. carrier.

setkey(mydata, "carrier")
unique(mydata)



Suppose you want to remove duplicated based on all the variables. You can use the command below -


setkey(mydata, NULL)
unique(mydata)


<b>Note : </b>Setting key to NULL is not required if no key is already set.

<span class="topicline"> - Extract values within a group</span>

The following command selects first and second values from a categorical variable carrier.

mydata[, .SD[1:2], by=carrier]

<b>Select LAST value from a group</b>

mydata[, .SD[.N], by=carrier]



<span class="topicline"> - SQL's RANK OVER PARTITION</span>

In SQL, Window functions are very useful for solving complex data problems. RANK OVER PARTITION is the most popular window function. It can be easily translated in data.table with the help of <b>frank() </b>function. frank() is similar to base R's rank() function but much faster. See the code below.

dt = mydata[, rank:=<b>frank(-distance,ties.method = "min")</b>, by=carrier]

In this case, we are calculating rank of variable 'distance' by 'carrier'. We are assigning rank 1 to the highest value of 'distance' within unique values of 'carrier'.





<span class="topicline"> - Cumulative SUM by GROUP</span>

We can calculate cumulative sum by using <b>cumsum()</b> function.

dat = mydata[, cum:=<b>cumsum</b>(distance), by=carrier]


<span class="topicline"> - Lag and Lead</span>

The lag and lead of a variable can be calculated with shift() function. The syntax of shift() function is as follows - <b>shift(variable_name, number_of_lags, type=c("lag", "lead"))</b>

DT &lt;- data.table(A=1:5)
DT[ , X := <b>shift</b>(A, 1, type="lag")]
DT[ , Y := <b>shift</b>(A, 1, type="lead")]
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody>
<tr><td style="text-align: center;"><a href="https://3.bp.blogspot.com/-Jz3wnUM0A-g/WAerXNB1x5I/AAAAAAAAFjA/vYRXZpGj3TkX4-tnhqbvIck6uG4iMsgKQCLcB/s1600/Lag%2Band%2Blead.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="https://3.bp.blogspot.com/-Jz3wnUM0A-g/WAerXNB1x5I/AAAAAAAAFjA/vYRXZpGj3TkX4-tnhqbvIck6uG4iMsgKQCLcB/s1600/Lag%2Band%2Blead.png" /></a></td></tr>
<tr><td class="tr-caption" style="text-align: center;">Lag and Lead Function</td></tr>
</tbody></table>


<span class="topicline"> - Between and LIKE Operator</span>

We can use %between% operator to define a range. It is inclusive of the values of both the ends.

DT = data.table(x=6:10)
DT[x <b>%between%</b> c(7,9)]
The %like% is mainly used to find all the values that matches a pattern.

DT = data.table(Name=c("dep_time","dep_delay","arrival"), ID=c(2,3,4))
DT[Name <b>%like%</b> "dep"] 



<span class="topicline"> - Merging / Joins</span>

The merging in data.table is very similar to base R merge() function. The only difference is data.table by default takes common key variable as a primary key to merge two datasets. Whereas, data.frame takes common variable name as a primary key to merge the datasets.
<b>
</b>
<b>Sample Data</b>

(dt1 &lt;- data.table(A = letters[rep(1:3, 2)], X = 1:6, key = "A"))
(dt2 &lt;- data.table(A = letters[rep(2:4, 2)], Y = 6:1, key = "A"))
<b>Inner Join</b>

It returns all the matching observations in both the datasets.

merge(dt1, dt2, by="A")

<b>Left Join</b>

It returns all observations from the left dataset and the matched observations from the right dataset.

merge(dt1, dt2, by="A", all.x = TRUE)

<b>Right Join</b>

It returns all observations from the right dataset and the matched observations from the left dataset.

merge(dt1, dt2, by="A", all.y = TRUE)

<b>Full Join</b>

It return all rows when there is a match in one of the datasets.

merge(dt1, dt2, all=TRUE)



<span class="topicline"> - Convert a data.table to data.frame</span>

You can use <b>setDF()</b> function to accomplish this task.

setDF(mydata)
Similarly, you can use <b>setDT() </b>function to convert data frame to data table.

set.seed(123)
X = data.frame(A=sample(3, 10, TRUE),
               B=sample(letters[1:3], 10, TRUE)

setDT(X, key = "A")


<span class="topicline"> - Other Useful Functions</span>

<b>Reshape Data</b>

It includes several useful functions which makes data cleaning easy and smooth. To reshape or transpose data, you can use <b>dcast.data.table() </b>and <b>melt.data.table()</b> functions. These functions are sourced from reshape2 package and make them efficient. It also add some new features in these functions.

<b>Rolling Joins</b>

It supports rolling joins. They are commonly used for analyzing time series data. A very R packages supports these kind of joins.


<span class="topicline"> - Examples for Practise</span>

Q1. Calculate total number of rows by month and then sort on descending order</span>

mydata[, .N, by = month] [order(-N)]

The <b>.N operator</b> is used to find count.


</span>
Q2. Find top 3 months with high mean arrival delay</span>

mydata[, .(mean_arr_delay = mean(arr_delay, na.rm = TRUE)), by = month][order(-mean_arr_delay)][1:3]

Q3. Find origin of flights having average total delay is greater than 20 minutes</span>

mydata[, lapply(.SD, mean, na.rm = TRUE), .SDcols = c("arr_delay", "dep_delay"), by = origin][(arr_delay + dep_delay) &gt; 20]

Q4.  Extract average of arrival and departure delays for carrier == 'DL' by 'origin' and 'dest' variables</span>

mydata[carrier == "DL",
        lapply(.SD, mean, na.rm = TRUE),
        by = .(origin, dest),
        .SDcols = c("arr_delay", "dep_delay")]

Q5. Pull first value of 'air_time' by 'origin' and then sum the returned values when it is greater than 300</span>

mydata[, .SD[1], .SDcols="air_time", by=origin][air_time &gt; 300, sum(air_time)]

<b>Endnotes</b>
This package provides a one-stop solution for data wrangling in R. It offers two main benefits - less coding and lower computing time. However, it's not a first choice of some of R programmers. Some prefer <b>dplyr</b> package for its simplicity. I would recommend learn both the packages. Check out <a href="http://www.listendata.com/2016/08/dplyr-tutorial.html" target="_blank"><b>dplyr tutorial</b></a>. If you are working on data having size less than 1 GB, you can use dplyr package. It offers decent speed but slower than data.table package.








<script src='https://williamkpchan.github.io/LibDocs/readbook.js'></script>
<script>
var lazyLoadInstance = new LazyLoad({
    elements_selector: ".lazy"
    // ... more custom settings?
});
</script>
</pre></body></html>