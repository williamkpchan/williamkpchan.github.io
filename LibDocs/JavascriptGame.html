<base target="_blank"><html><head><title>html game</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src="../lazyload.min.js"></script>
<script type='text/javascript' src='../mainscript.js'></script>
<script src="D:/Dropbox/Public/commonfunctions.js"></script>
<script>
  var showTopicNumber = true;
  var bookid = "html game" 
</script>
<style>
body{width:80%;margin-left: 10%; font-size:22px;}
h1, h2 {color: gold;}
strong {color: orange;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px;}
</style></head><body onkeypress="chkKey()"><center>
<h1>html game</h1>
<a href="#mustWatch" class="red goldbs" target="_self">Must Watch!</a>
<br><br>
<div id="toc"></div></center>
<br><br>
<div id="mustWatch"><center><span class="red">MustWatch</span></center><br>
<a href="https://github.com/CodeExplainedRepo" class="whitebut ">javascript Games</a>

</div>
<pre>
<br>
<br>

<p>Learn how to make games, using nothing but HTML and JavaScript.</p>
<p>Push the buttons to move the red square:</p>
<div id="myfilter"></div>
<div id="myrestartbutton">
<button onclick="restartGame()">Restart</button></div>
<div id="canvascontainer"></div>
<div>
  <button ontouchstart="moveup()" onmousedown="moveup()" onmouseup="clearmove()">UP</button><br><br>
  <button ontouchstart="moveleft()" onmousedown="moveleft()" onmouseup="clearmove()">LEFT</button>
  <button ontouchstart="moveright()" onmousedown="moveright()" onmouseup="clearmove()">RIGHT</button><br><br>
  <button ontouchstart="movedown()" onmousedown="movedown()" onmouseup="clearmove()">DOWN</button>
</div>

<script>

var myGameArea;
var myGamePiece;
var myObstacles = [];
var myscore;

function restartGame() {
document.getElementById("myfilter").style.display = "none";
document.getElementById("myrestartbutton").style.display = "none";
myGameArea.stop();
myGameArea.clear();
myGameArea = {};
myGamePiece = {};
myObstacles = [];
myscore = {};
document.getElementById("canvascontainer").innerHTML = "";
startGame()
}

function startGame() {
    myGameArea = new gamearea();
    myGamePiece = new component(30, 30, "red", 10, 75);
    myscore = new component("15px", "Consolas", "black", 220, 25, "text");
    myGameArea.start();
}

function gamearea() {
    this.canvas = document.createElement("canvas");
    this.canvas.width = 320;
    this.canvas.height = 180;    
    document.getElementById("canvascontainer").appendChild(this.canvas);
    this.context = this.canvas.getContext("2d");
    this.pause = false;
    this.frameNo = 0;
    this.start = function() {
        this.interval = setInterval(updateGameArea, 20);
    }
    this.stop = function() {
        clearInterval(this.interval);
        this.pause = true;
    }
    this.clear = function(){
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
}

function component(width, height, color, x, y, type) {

    this.type = type;
    if (type == "text") {
        this.text = color;
    }
    this.score = 0;    this.width = width;
    this.height = height;
    this.speedX = 0;
    this.speedY = 0;    
    this.x = x;
    this.y = y;    
    this.update = function() {
        ctx = myGameArea.context;
        if (this.type == "text") {
            ctx.font = this.width + " " + this.height;
            ctx.fillStyle = color;
            ctx.fillText(this.text, this.x, this.y);
        } else {
            ctx.fillStyle = color;
            ctx.fillRect(this.x, this.y, this.width, this.height);
        }
    }
    this.crashWith = function(otherobj) {
        var myleft = this.x;
        var myright = this.x + (this.width);
        var mytop = this.y;
        var mybottom = this.y + (this.height);
        var otherleft = otherobj.x;
        var otherright = otherobj.x + (otherobj.width);
        var othertop = otherobj.y;
        var otherbottom = otherobj.y + (otherobj.height);
        var crash = true;
        if ((mybottom < othertop) || (mytop > otherbottom) || (myright < otherleft) || (myleft > otherright)) {
            crash = false;
        }
        return crash;
    }
}

function updateGameArea() {
    var x, y, min, max, height, gap;
    for (i = 0; i < myObstacles.length; i += 1) {
        if (myGamePiece.crashWith(myObstacles[i])) {
            myGameArea.stop();
            document.getElementById("myfilter").style.display = "block";
            document.getElementById("myrestartbutton").style.display = "block";
            return;
        } 
    }
    if (myGameArea.pause == false) {
        myGameArea.clear();
        myGameArea.frameNo += 1;
        myscore.score +=1;        
        if (myGameArea.frameNo == 1 || everyinterval(150)) {
            x = myGameArea.canvas.width;
            y = myGameArea.canvas.height - 100;
            min = 20;
            max = 100;
            height = Math.floor(Math.random()*(max-min+1)+min);
            min = 50;
            max = 100;
            gap = Math.floor(Math.random()*(max-min+1)+min);
            myObstacles.push(new component(10, height, "green", x, 0));
            myObstacles.push(new component(10, x - height - gap, "green", x, height + gap));
        }
        for (i = 0; i < myObstacles.length; i += 1) {
            myObstacles[i].x += -1;
            myObstacles[i].update();
        }
        myscore.text="SCORE: " + myscore.score;        
        myscore.update();
        myGamePiece.x += myGamePiece.speedX;
        myGamePiece.y += myGamePiece.speedY;    
        myGamePiece.update();
    }
}

function everyinterval(n) {
    if ((myGameArea.frameNo / n) % 1 == 0) {return true;}
    return false;
}

function moveup(e) {
    myGamePiece.speedY = -1; 
}

function movedown() {
    myGamePiece.speedY = 1; 
}

function moveleft() {
    myGamePiece.speedX = -1; 
}

function moveright() {
    myGamePiece.speedX = 1; 
}

function clearmove(e) {
    myGamePiece.speedX = 0; 
    myGamePiece.speedY = 0; 
}
startGame();

</script>

<h3>Example</h3>
function startGame() {
 myGamePiece = new component(30, 30, "red", 10, 120);
 myGamePiece.gravity = 0.05;
   myScore = new component("30px", "Consolas", "black", 280, 40, "text");
   myGameArea.start();
}

var myGameArea = {
 canvas : document.createElement("canvas"),
   start : function() {
   this.canvas.width = 480;
   this.canvas.height = 270;
   this.context = this.canvas.getContext("2d");
   document.body.insertBefore(this.canvas, document.body.childNodes[0]);
   this.frameNo = 0;
   },
 clear : function() {
   this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
   }
}

&lt;div id="canvascontainer">&lt;/div>
The HTML <code>&lt;canvas&gt;</code> element is displayed as a rectangular object on a web page:

&lt;script>
var myGameArea;
function startGame() {
   myGameArea = new gamearea();
}
var x = 0, y = 0;

function gamearea() {
   this.canvas = document.createElement("canvas");
   this.canvas.width = 320;
   this.canvas.height = 180;    
   document.getElementById("canvascontainer").appendChild(this.canvas);
   this.context = this.canvas.getContext("2d");
   this.context.scale(1.4, 1.4);
//var v = document.getElementById("video1");
var i;

//v.addEventListener("play", function() {
   i = window.setInterval(function() {
   myGameArea.context.clearRect(0, 0, myGameArea.canvas.width, myGameArea.canvas.height);
   x++;
   var ctx = document.getElementsByTagName("canvas")[0].getContext("2d");
   //ctx.drawImage(v,5,5,260,125);
   ctx.strokeStyle="#000000";
   ctx.font="20px Georgia";
   if (x > 0) {
       ctx.strokeText("You can do anything",10,30);        
   }
   if (x > 50) {
       y += 0.5;
       ctx.strokeText("on the canvas",10,50+y);        
   }
   if (x > 250) {    
       clearInterval(i);  
       var ctx = document.getElementsByTagName("canvas")[0].getContext("2d");
       ctx.font="20px Georgia";
       ctx.strokeText("Try it!",140,100);
   }
},20)//;}, false);
//v.addEventListener("pause", function() {window.clearInterval(i);}, false);
//v.addEventListener("ended", function() {
//}, false); 
}

startGame();
&lt;/script>

&lt;h2>HTML Canvas&lt;/h2>

The <code>&lt;canvas&gt;</code> element is perfect for making games in HTML.
The <code>&lt;canvas&gt;</code> element offers all the functionality you need for making games.
Use JavaScript to draw, write, insert images, and more, onto the <code>&lt;canvas&gt;</code>.

<h2>.getContext("2d")</h2>

The <code>&lt;canvas&gt;</code> element has a built-in object, called the <code>getContext("2d")</code> object, with methods and properties for drawing.

<h2>Get Started</h2>

To make a game, start by creating a gaming area, and make it ready for drawing:

<h3>Example</h3>
function startGame() {
 myGameArea.start();
}

var myGameArea = {
 canvas : document.createElement("canvas"),
 start : function() {
   this.canvas.width = 480;
   this.canvas.height = 270;
   this.context = this.canvas.getContext("2d");

     document.body.insertBefore(this.canvas, document.body.childNodes[0]);
   }
}

<a target="_blank" href="https://www.w3schools.com/graphics/tryit.asp?filename=trygame_canvas" class="w3-btn w3-margin-bottom">Try it Yourself &raquo;</a>

The object <code>myGameArea</code> will have more properties and methods later in this tutorial.
The function <code>startGame()</code> invokes the method <code> start()</code> of the <code> myGameArea</code> object.

The <code> start()</code> method creates a <code>&lt;canvas&gt;</code> element and inserts it as the first childnode of the <code>&lt;body&gt;</code> element.

&lt;script>

var myGameArea;
var myGamePiece;

function startGame() {
   myGameArea = new gamearea();
   myGamePiece = new component(30, 30, "rgb(255, 0, 0)", 10, 75);
}

function gamearea() {
   this.canvas = document.createElement("canvas");
   this.canvas.width = 320;
   this.canvas.height = 180;    
   document.getElementById("canvascontainer").appendChild(this.canvas);
   this.context = this.canvas.getContext("2d");
}

function component(width, height, color, x, y) {
   this.width = width;
   this.height = height;
   this.x = x;
   this.y = y;    
   ctx = myGameArea.context;
   ctx.fillStyle = color;
   ctx.fillRect(this.x, this.y, this.width, this.height);
}
startGame();
&lt;/script>
<h2>Add a Component</h2>

Make a component constructor, which lets you add components onto the gamearea.

The object constructor is called <code>
component</code>, and we make our first component, called <code>myGamePiece</code>:

<h3>Example</h3>
<strong>var myGamePiece;</strong>
function startGame() {
 myGameArea.start();

   <strong>myGamePiece = new component(30, 30, "red", 10, 120);</strong>}

<strong>function component(width, height, color, x, y) {
 this.width = width;
 this.height = height;
 this.x = x;
 this.y = y; 
 ctx = myGameArea.context;
 ctx.fillStyle = color;
 ctx.fillRect(this.x, this.y, this.width, this.height);
}</strong>

<a target="_blank" href="https://www.w3schools.com/graphics/tryit.asp?filename=trygame_component_simple" class="w3-btn">Try it Yourself &raquo;</a>

The components have  properties and methods to control their appearances and movements.

<h2>Frames</h2>

To make the game ready for action, we will update the display 50 times per second, 
which is much like frames in a movie. 

First, create a new function called <code>updateGameArea()</code>.

In the <code>myGameArea</code> object, add an interval which will run the <code>updateGameArea()</code> function every 20th millisecond (50 times per second). Also add a function called <code>clear()</code>, that clears the entire canvas.

In the <code>component</code> constructor, add a function called <code> update()</code>, to handle the drawing of the component.

The <code>updateGameArea()</code> function calls the <code>clear()</code> and the <code>update()</code> method.

The result is that the component is drawn and cleared 50 times per second:

<h3>Example</h3>
var myGameArea = {
 canvas : document.createElement("canvas"),

   start : function() {
   this.canvas.width = 480;
   this.canvas.height = 270;
   this.context = this.canvas.getContext("2d");
   document.body.insertBefore(this.canvas, document.body.childNodes[0]);
<strong>    this.interval = setInterval(updateGameArea, 20);</strong>
 },
<strong>
   clear : function() {
   this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
   }</strong>}

function component(width, height, color, x, y) {
 this.width = width;

   this.height = height;
 this.x = x;
 this.y = y; 
<strong>  this.update = function(){</strong>
    ctx = myGameArea.context;

     ctx.fillStyle = color;
   ctx.fillRect(this.x, this.y, this.width, this.height);
<strong>   }</strong>}
<strong>
function updateGameArea() {
 myGameArea.clear();  
myGamePiece.update();
}</strong>

<a target="_blank" href="https://www.w3schools.com/graphics/tryit.asp?filename=trygame_component" class="w3-btn w3-margin-bottom">Try it Yourself &raquo;</a>

<h2>Make it Move</h2>

To prove that the red square is being drawn 50 times per second, we will change the x position (horizontal)
by one pixel every time we update the game area:

<h3>Example</h3>
function updateGameArea() {
 myGameArea.clear();

<strong>myGamePiece.x += 1; </strong>
myGamePiece.update();
}

<a target="_blank" href="https://www.w3schools.com/graphics/tryit.asp?filename=trygame_component_move" class="w3-btn w3-margin-bottom">Try it Yourself &raquo;</a>

<h2>Why Clear The Game Area?</h2>

It might seem unnecessary to clear the game area at every update. However, if we leave out the 
<code>clear()</code> method,
all movements of the component will leave a trail of where it was positioned in the last frame:

<h3>Example</h3>
function updateGameArea() {
 // myGameArea.clear();

<strong>myGamePiece.x += 1; </strong>
myGamePiece.update();
}

<a target="_blank" href="https://www.w3schools.com/graphics/tryit.asp?filename=trygame_component_move_noclear" class="w3-btn w3-margin-bottom">Try it Yourself &raquo;</a>

<h2>Change the Size</h2>

You can 
control the width and height of the component:

<h3>Example</h3>

Create a 10x140 pixels rectangle:

function startGame() {
 myGameArea.start();
 myGamePiece = new component(<strong>140</strong>, <strong>10</strong>, "red", 10, 120);
}

<a target="_blank" href="https://www.w3schools.com/graphics/tryit.asp?filename=trygame_component_long" class="w3-btn w3-margin-bottom">Try it Yourself &raquo;</a>

<h2>Change the Color</h2>

You can control the color of the component:

<h3>Example</h3>
function startGame() {
 myGameArea.start();
 myGamePiece = new component(30, 30, <strong>"blue"</strong>, 10, 120);
}

<a target="_blank" href="https://www.w3schools.com/graphics/tryit.asp?filename=trygame_component_color" class="w3-btn w3-margin-bottom">Try it Yourself &raquo;</a>

You can also use other colorvalues like hex, rgb, or rgba:

<h3>Example</h3>
function startGame() {
 myGameArea.start();
 myGamePiece = new component(30, 30, <strong>"rgba(0, 0, 255, 0.5)"</strong>, 10, 120);
}

<a target="_blank" href="https://www.w3schools.com/graphics/tryit.asp?filename=trygame_component_color_rgba" class="w3-btn w3-margin-bottom">Try it Yourself &raquo;</a>

<h2>Change the Position</h2>

We use x- and y-coordinates to position components onto the game area.

The upper-left corner of the canvas has the coordinates (0,0)

Mouse over the game area below to see its x and y coordinates:

<iframe src="https://www.w3schools.com/graphics/trygame_coordinates.htm" frameborder="0" style="margin-left:20px;border:0;overflow:hidden;width:90%;max-width:320px;height:210px;"></iframe>

You can position the components wherever you like on the game area:

<h3>Example</h3>
function startGame() {
 myGameArea.start();
 myGamePiece = new component(30, 30, "red", <strong>2</strong>, <strong>2</strong>);
}

<a target="_blank" href="https://www.w3schools.com/graphics/tryit.asp?filename=trygame_component_position" class="w3-btn w3-margin-bottom">Try it Yourself &raquo;</a>

<h2>Many Components</h2>

You can put as many components as you like on the game area:

<h3>Example</h3>
<strong>var redGamePiece, blueGamePiece, yellowGamePiece;

</strong>
function startGame() {
<strong>  redGamePiece = new component(75, 75, "red", 10, 10);
 yellowGamePiece = new component(75, 75, "yellow", 50, 60); 

   blueGamePiece = new component(75, 75, "blue", 10, 110);

</strong>myGameArea.start();
}

function updateGameArea() {
 myGameArea.clear();
<strong>
   redGamePiece.update();
 yellowGamePiece.update(); 
 blueGamePiece.update();

</strong>}

<a target="_blank" href="https://www.w3schools.com/graphics/tryit.asp?filename=trygame_component_more" class="w3-btn w3-margin-bottom">Try it Yourself &raquo;</a>

<h2>Moving Components</h2>

Make all three components move in different directions:

<h3>Example</h3>
function updateGameArea() {
 myGameArea.clear();

<strong>  redGamePiece.x += 1;
 yellowGamePiece.x += 1; 
 yellowGamePiece.y += 1; 

   blueGamePiece.x += 1; 
 blueGamePiece.y -= 1; 

</strong>  redGamePiece.update();
 yellowGamePiece.update(); 
 blueGamePiece.update();

}

<a target="_blank" href="https://www.w3schools.com/graphics/tryit.asp?filename=trygame_component_more_move" class="w3-btn w3-margin-bottom">Try it Yourself &raquo;</a>

var myGameArea;
var myGamePiece;

function startGame() {
   myGameArea = new gamearea();
   myGamePiece = new component(30, 30, "red", 10, 75);
   myGameArea.start();    
}

function gamearea() {
   this.canvas = document.createElement("canvas");
   this.canvas.width = 320;
   this.canvas.height = 180;    
   document.getElementById("canvascontainer").appendChild(this.canvas);
   this.context = this.canvas.getContext("2d");
   this.start = function() {
       this.interval = setInterval(updateGameArea, 20);
   }
   this.clear = function(){
       this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
   }        
}

function component(width, height, color, x, y) {
   this.width = width;
   this.height = height;
   this.x = x;
   this.y = y; 
   this.speedX = 0;
   this.speedY = 0;       
   this.update = function() {
       ctx = myGameArea.context;
       ctx.fillStyle = color;
       ctx.fillRect(this.x, this.y, this.width, this.height);
   }
}

function updateGameArea() {
   myGameArea.clear();
   myGamePiece.x += myGamePiece.speedX;
   myGamePiece.y += myGamePiece.speedY;    
   myGamePiece.update();
}

function moveup(e) {
   myGamePiece.speedY = -1; 
}

function movedown() {
   myGamePiece.speedY = 1; 
}

function moveleft() {
   myGamePiece.speedX = -1; 
}

function moveright() {
   myGamePiece.speedX = 1; 
}

function clearmove(e) {
   myGamePiece.speedX = 0; 
   myGamePiece.speedY = 0; 
}
startGame();

<h2>Get in Control</h2>

Now we want to control the red square.

Add four buttons, up, down, left, and right.

Write a function for each button to move the component in the selected 
direction.

Make two new properties in the <code>component</code> constructor, and call them <code>speedX</code> and <code>speedY</code>. These properties are being used as speed indicators.

Add a function in the <code>component</code> constructor, called <code>newPos()</code>, which uses the <code>speedX</code> and <code>speedY</code> properties to change the component's position.

The newpos function is called from the updateGameArea function before drawing the component:

<h3>Example</h3>
&lt;script&gt;

function component(width, height,  color, x, y) {
 this.width = width;
 this.height = height;

  <strong>  this.speedX = 0;

  this.speedY = 0;

</strong>  this.x = x;
 this.y = y;

 this.update = function() {
   ctx = myGameArea.context;

      ctx.fillStyle = color;
   ctx.fillRect(this.x, this.y, this.width, this.height);
 }
<strong>
    this.newPos = function() {
   this.x += this.speedX;
   this.y += this.speedY; 

    } 
</strong>}

function updateGameArea() {
 myGameArea.clear();
 <strong>myGamePiece.newPos();

    </strong>myGamePiece.update();
}

function moveup() {
<strong>  myGamePiece.speedY -= 1;

</strong>}

function movedown() {
<strong>  myGamePiece.speedY += 1; 
</strong>}

function moveleft() {
 <strong>myGamePiece.speedX -= 1;
</strong>}

function moveright() {
<strong>
    myGamePiece.speedX += 1;
</strong>}

&lt;/script&gt;

&lt;button onclick="moveup()"&gt;UP&lt;/button&gt;
&lt;button onclick="movedown()"&gt;DOWN&lt;/button&gt;
&lt;button onclick="moveleft()"&gt;LEFT&lt;/button&gt;
&lt;button onclick="moveright()"&gt;RIGHT&lt;/button&gt;

<a target="_blank" href="https://www.w3schools.com/graphics/tryit.asp?filename=trygame_controllers_moving" class="w3-btn w3-margin-bottom">Try it Yourself &raquo;</a>

<h2>Stop Moving</h2>

If you want, you can make the red square stop when you release a button.

Add a function that will set the speed indicators to 0.

To deal with both normal screens and touch screens, we will add code for both 
devices:

<h3>Example</h3>
<strong>function stopMove() {
 myGamePiece.speedX = 0;

    myGamePiece.speedY = 0; 

 </strong>}<strong>
</strong>
&lt;/script&gt;

&lt;button  onmousedown="moveup()" <strong>onmouseup="stopMove()"  ontouchstart="moveup()</strong>"&gt;UP&lt;/button&gt;
&lt;button  onmousedown="movedown()" <strong>onmouseup="stopMove()"  ontouchstart="movedown()"</strong>&gt;DOWN&lt;/button&gt;
&lt;button  onmousedown="moveleft()" <strong>onmouseup="stopMove()"  ontouchstart="moveleft()"</strong>&gt;LEFT&lt;/button&gt;
&lt;button  onmousedown="moveright()" <strong>onmouseup="stopMove()"  ontouchstart="moveright()"</strong>&gt;RIGHT&lt;/button&gt;

<a target="_blank" href="https://www.w3schools.com/graphics/tryit.asp?filename=trygame_controllers_moving_stop" class="w3-btn w3-margin-bottom">Try it Yourself &raquo;</a>

<h2>Keyboard as Controller</h2>

We can also control the red square by using the arrow keys on the keyboard.

Create a method that checks if a key is pressed, and set the <code>key</code> 
property of the <code>myGameArea</code> object to the key code. When the key is 
released, set the <code>key</code> property to <code>false</code>:

<h3>Example</h3>
var myGameArea = {
 canvas : document.createElement("canvas"),

   start : function() {
   this.canvas.width = 480;
   this.canvas.height = 270;
   this.context = this.canvas.getContext("2d");
   document.body.insertBefore(this.canvas, document.body.childNodes[0]);
   this.interval = setInterval(updateGameArea, 20);
<strong>
     window.addEventListener('keydown', function (e) {
     myGameArea.key = e.keyCode;

     })
   window.addEventListener('keyup', function (e) {

       myGameArea.key = false;
   })

</strong>  }, 
 clear : function(){
   this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);

   }
}

Then we can move the red square if one of the arrow keys are pressed:

<h3>Example</h3>
function updateGameArea() {
 myGameArea.clear();

<strong>  myGamePiece.speedX = 0;
 myGamePiece.speedY = 0; 
 if (myGameArea.key &amp;&amp; myGameArea.key == 37) {myGamePiece.speedX = -1; }

   if (myGameArea.key &amp;&amp; myGameArea.key == 39) {myGamePiece.speedX = 1; }

   if (myGameArea.key &amp;&amp; myGameArea.key == 38) {myGamePiece.speedY = -1; }

   if (myGameArea.key &amp;&amp; myGameArea.key == 40) {myGamePiece.speedY = 1; }

  
</strong>myGamePiece.newPos(); 
 myGamePiece.update();
}

<a target="_blank" href="https://www.w3schools.com/graphics/tryit.asp?filename=trygame_controllers_keys" class="w3-btn w3-margin-bottom">Try it Yourself &raquo;</a>

<h2>Multiple Keys Pressed</h2>

What if more than one key is pressed at the same time?

In the example above, the component can only move horizontally or vertically. 
Now we want the component to also move diagonally.

Create a <code>
keys</code> <em>array</em> for the <code>myGameArea</code> object, and insert one element 
for each key that is pressed, and give it the value <code>true</code> , the 
value remains true untill the key is no longer pressed, the value becomes <code>
false</code> in the <em>keyup</em> event listener function:

<h3>Example</h3>
var myGameArea = {
 canvas : document.createElement("canvas"),

   start : function() {
   this.canvas.width = 480;
   this.canvas.height = 270;
   this.context = this.canvas.getContext("2d");
   document.body.insertBefore(this.canvas, document.body.childNodes[0]);
   this.interval = setInterval(updateGameArea, 20);
<strong>
     window.addEventListener('keydown', function (e) {
     myGameArea.keys = (myGameArea.keys || []);
     myGameArea.keys[e.keyCode] = true;

     })
   window.addEventListener('keyup', function (e) {
     myGameArea.keys[e.keyCode] = false; 

     })
</strong>  }, 
 clear : function(){
   this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);

   }
}

function updateGameArea() {
 myGameArea.clear();

   myGamePiece.speedX = 0;
 myGamePiece.speedY = 0; 

   if (<strong>myGameArea.keys &amp;&amp; myGameArea.keys[37]</strong>) {myGamePiece.speedX = -1; }

   if (<strong>myGameArea.keys &amp;&amp; myGameArea.keys[39]</strong>) {myGamePiece.speedX = 1; }

   if (<strong>myGameArea.keys &amp;&amp; myGameArea.keys[38]</strong>) {myGamePiece.speedY = -1; }
 if (<strong>myGameArea.keys &amp;&amp; myGameArea.keys[40]</strong>) {myGamePiece.speedY = 1; }

<strong> 
</strong>myGamePiece.newPos(); 
 myGamePiece.update();
}

<a target="_blank" href="https://www.w3schools.com/graphics/tryit.asp?filename=trygame_controllers_keys_multiple" class="w3-btn w3-margin-bottom">Try it Yourself &raquo;</a>

<h2>Using The Mouse Cursor as a Controller</h2>

If you want to control the red square by using the mouse cursor, add a method in <code>myGameArea</code> object that updates the x and y coordinates of the mouse cursor:.

<h3>Example</h3>
var myGameArea = {
 canvas : document.createElement("canvas"),

   start : function() {
   this.canvas.width = 480;
   this.canvas.height = 270;
<strong>    this.canvas.style.cursor = "none"; //hide the original cursor
</strong>    this.context = this.canvas.getContext("2d");
   document.body.insertBefore(this.canvas, document.body.childNodes[0]);
   this.interval = setInterval(updateGameArea, 20);
<strong>
     window.addEventListener('mousemove', function (e) {
     myGameArea.x = e.pageX;

       myGameArea.y = e.pageY;
   })
</strong>  }, 
 clear : function(){
   this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);

   }
}

Then we can move the red square using the mouse cursor:

<h3>Example</h3>
function updateGameArea() {
 myGameArea.clear();

 <strong>  if (myGameArea.x &amp;&amp; myGameArea.y) {
   myGamePiece.x = myGameArea.x;

     myGamePiece.y = myGameArea.y; 
 }
</strong>  myGamePiece.update();
}

<a target="_blank" href="https://www.w3schools.com/graphics/tryit.asp?filename=trygame_controllers_mouse" class="w3-btn w3-margin-bottom">Try it Yourself &raquo;</a>

<h2>Touch The Screen to Control The Game</h2>

We can also control the red square on a touch screen.

Add a method in the <code>myGameArea</code> object that uses the x and y coordinates of where the screen is touched:

<h3>Example</h3>
var myGameArea = {
 canvas : document.createElement("canvas"),

   start : function() {
   this.canvas.width = 480;
   this.canvas.height = 270;

     this.context = this.canvas.getContext("2d");
   document.body.insertBefore(this.canvas, document.body.childNodes[0]);
   this.interval = setInterval(updateGameArea, 20);
<strong>
     window.addEventListener('touchmove', function (e) {
     myGameArea.x = e.touches[0].screenX;

       myGameArea.y = e.touches[0].screenY;
   })
</strong>  }, 

   clear : function(){
   this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);

   }
}

Then we can move the red square if the user touches the screen, by using the same code as we did for the mouse cursor:

<h3>Example</h3>
function updateGameArea() {
 myGameArea.clear();

<strong>  if (myGameArea.x &amp;&amp; myGameArea.y) {
   myGamePiece.x = myGameArea.x;

     myGamePiece.y = myGameArea.y; 
 }
</strong>  myGamePiece.update();
}

<a target="_blank" href="https://www.w3schools.com/graphics/tryit.asp?filename=trygame_controllers_touch" class="w3-btn w3-margin-bottom">Try it Yourself &raquo;</a>

<h2>Controllers on The Canvas</h2>

We can also draw our own buttons on the canvas, and use them as controllers:

<h3>Example</h3>
function startGame() {
 myGamePiece = new component(30, 30, "red", 10, 120);
<strong>  myUpBtn = new component(30, 30, "blue", 50, 10); 
 myDownBtn = new component(30, 30, "blue", 50, 70); 
 myLeftBtn = new component(30, 30, "blue", 20, 40); 
 myRightBtn = new component(30, 30, "blue", 80, 40); 
</strong>  myGameArea.start();
}

Add a new function that figures out if a component, in this case a button, is clicked.

Start by adding event listeners to check if a mouse button is clicked (<code>mousedown</code> and <code>mouseup</code>). 
To deal with touch screens, also add event listeners to check if the screen is clicked on (<code>touchstart</code> and <code>touchend</code>):

<h3>Example</h3>
var myGameArea = {
 canvas : document.createElement("canvas"),
 start : function() {

     this.canvas.width = 480;
   this.canvas.height = 270;
   this.context = this.canvas.getContext("2d");

     document.body.insertBefore(this.canvas, document.body.childNodes[0]);
   this.interval = setInterval(updateGameArea, 20);
<strong>    window.addEventListener('mousedown', function (e) {

       myGameArea.x = e.pageX;
     myGameArea.y = e.pageY;
   })
   window.addEventListener('mouseup', function (e) {
     myGameArea.x = false;
     myGameArea.y = false;
   })
   window.addEventListener('touchstart', function (e) {

       myGameArea.x = e.pageX;
     myGameArea.y = e.pageY;
   })
   window.addEventListener('touchend', function (e) {
     myGameArea.x = false;

       myGameArea.y = false;
   })

</strong>  }, 
 clear : function(){
   this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);

   }
}

Now the <code>myGameArea</code> object has properties that tells us the x- and y-coordinates of a click. We use these properties to check if the click was performed on one of our blue buttons.

The new method is called <code>clicked</code>, it is a method of the <code> component</code> constructor, and it checks if the component is being clicked.

In the <code>updateGameArea</code> function, we take the neccessarry actions if one of the blue buttons is clicked:

<h3>Example</h3>
function component(width, height, color, x, y) {
 this.width = width;
 this.height = height;
 this.speedX = 0;
 this.speedY = 0;

   this.x = x;
 this.y = y; 
 this.update = function() {

     ctx = myGameArea.context;
   ctx.fillStyle = color;
   ctx.fillRect(this.x, this.y, this.width, this.height);

   }
<strong>  this.clicked = function() {
   var myleft = this.x;
   var myright = this.x + (this.width);

     var mytop = this.y;
   var mybottom = this.y + (this.height);
   var clicked = true;

     if ((mybottom &lt; myGameArea.y) || (mytop &gt; myGameArea.y) || (myright &lt; myGameArea.x) || (myleft &gt; myGameArea.x)) {
     clicked = false;

     }
   return clicked;
 }
</strong>}

function updateGameArea() {
 myGameArea.clear();
<strong>
   if (myGameArea.x &amp;&amp; myGameArea.y) {
   if (myUpBtn.clicked()) {
     myGamePiece.y -= 1;

     }
   if (myDownBtn.clicked()) {
     myGamePiece.y += 1;

     }
   if (myLeftBtn.clicked()) {
     myGamePiece.x += -1;

     }

    if (myRightBtn.clicked()) {
     myGamePiece.x += 1;

     }
 }
 myUpBtn.update(); 
 myDownBtn.update(); 
 myLeftBtn.update(); 

   myRightBtn.update(); 
</strong>  myGamePiece.update();
}

<a target="_blank" href="https://www.w3schools.com/graphics/tryit.asp?filename=trygame_controllers_buttons" class="w3-btn w3-margin-bottom">Try it Yourself &raquo;</a>

&lt;script>

var myGameArea;
var myGamePiece;
var myObstacles = [];

function startGame() {
   myGameArea = new gamearea();
   myGamePiece = new component(30, 30, "red", 10, 75);
   myGameArea.start();
}

function gamearea() {
   this.canvas = document.createElement("canvas");
   this.canvas.width = 320;
   this.canvas.height = 180;    
   document.getElementById("canvascontainer").appendChild(this.canvas);
   this.context = this.canvas.getContext("2d");
   this.pause = false;
   this.frameNo = 0;
   this.start = function() {
       this.interval = setInterval(updateGameArea, 20);
   }
   this.stop = function() {
       clearInterval(this.interval);
       this.pause = true;
   }
   this.clear = function(){
       this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
   }
}

function component(width, height, color, x, y) {
   this.width = width;
   this.height = height;
   this.speedX = 0;
   this.speedY = 0;    
   this.x = x;
   this.y = y;    
   this.update = function() {
       ctx = myGameArea.context;
       ctx.fillStyle = color;
       ctx.fillRect(this.x, this.y, this.width, this.height);
   }
   this.crashWith = function(otherobj) {
       var myleft = this.x;
       var myright = this.x + (this.width);
       var mytop = this.y;
       var mybottom = this.y + (this.height);
       var otherleft = otherobj.x;
       var otherright = otherobj.x + (otherobj.width);
       var othertop = otherobj.y;
       var otherbottom = otherobj.y + (otherobj.height);
       var crash = true;
       if ((mybottom < othertop) || (mytop > otherbottom) || (myright < otherleft) || (myleft > otherright)) {
           crash = false;
       }
       return crash;
   }
}

function updateGameArea() {
   var x, y, min, max, height, gap;
   for (i = 0; i < myObstacles.length; i += 1) {
       if (myGamePiece.crashWith(myObstacles[i])) {
           myGameArea.stop();
       } 
   }
   if (myGameArea.pause == false) {
       myGameArea.clear();
       myGameArea.frameNo += 1;
       if (myGameArea.frameNo == 1 || everyinterval(100)) {
           x = myGameArea.canvas.width;
           y = myGameArea.canvas.height - 100;
           min = 20;
           max = 100;
           height = Math.floor(Math.random()*(max-min+1)+min);
           min = 50;
           max = 100;
           gap = Math.floor(Math.random()*(max-min+1)+min);
           myObstacles.push(new component(10, height, "green", x, 0));
           myObstacles.push(new component(10, x - height - gap, "green", x, height + gap));
       }
       for (i = 0; i < myObstacles.length; i += 1) {
           myObstacles[i].x += -1;
           myObstacles[i].update();
       }
       myGamePiece.x += myGamePiece.speedX;
       myGamePiece.y += myGamePiece.speedY;    
       myGamePiece.update();
   }
}

function everyinterval(n) {
   if ((myGameArea.frameNo / n) % 1 == 0) {return true;}
   return false;
}

function moveup(e) {
   myGamePiece.speedY = -1; 
}

function movedown() {
   myGamePiece.speedY = 1; 
}

function moveleft() {
   myGamePiece.speedX = -1; 
}

function moveright() {
   myGamePiece.speedX = 1; 
}

function clearmove(e) {
   myGamePiece.speedX = 0; 
   myGamePiece.speedY = 0; 
}
startGame();

&lt;/script>
<h2>Add Some Obstacles</h2>

Now we want to add some obstacles to our game.

Add a new component to the gaming area. Make it green, 10px wide, 200px high, 
and place it 300px to the right and 120px down.

Also update the obstacle component in every frame:

<h3>Example</h3>
var myGamePiece;
<strong>var myObstacle;
</strong>
function startGame() {
 myGamePiece = new component(30, 30, "red", 10, 120);

   <strong>myObstacle = new component(10, 200, "green", 300, 120); 

</strong>  myGameArea.start();
}

function updateGameArea() {
 myGameArea.clear();

   <strong>myObstacle.update();

   </strong>myGamePiece.newPos();
 myGamePiece.update();
}

<a target="_blank" href="https://www.w3schools.com/graphics/tryit.asp?filename=trygame_obstacle" class="w3-btn w3-margin-bottom">Try it Yourself &raquo;</a>

<h2>Hit The Obstacle = Game Over</h2>

In the example above, nothing happens when you hit the obstacle. In a game, 
that is not very satisfying.

How do we know if our red square hits the obstacle?

Create a new method in the component constructor, that checks if the 
component crashes with another component. This method should be called every 
time the frames updates, 50 times per second.

Also add a <code>stop()</code> method to the <code>myGameArea</code> object, 
which clears the 20 milliseconds interval.

<h3>Example</h3>
var myGameArea = {
 canvas : document.createElement("canvas"),

   start : function() {
   this.canvas.width = 480;
   this.canvas.height = 270;

     this.context = this.canvas.getContext("2d");
   document.body.insertBefore(this.canvas, document.body.childNodes[0]);
   this.interval = setInterval(updateGameArea, 20);
 },
 clear : function() {
   this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);

   }<strong>,
 stop : function() {
   clearInterval(this.interval);

   }
</strong>}

function component(width, height, color, x, y) {
 this.width = width;

   this.height = height;
 this.speedX = 0;
 this.speedY = 0; 
 this.x = x;

   this.y = y; 
 this.update = function() {
   ctx = myGameArea.context;

     ctx.fillStyle = color;
   ctx.fillRect(this.x, this.y, this.width, this.height);

   }
 this.newPos = function() {
   this.x += this.speedX;

     this.y += this.speedY; 
 }
<strong>  this.crashWith = function(otherobj) {
   var myleft = this.x;
   var myright = this.x + (this.width);
   var mytop = this.y;
   var mybottom = this.y + (this.height);

     var otherleft = otherobj.x;
   var otherright = otherobj.x + (otherobj.width);

     var othertop = otherobj.y;
   var otherbottom = otherobj.y + (otherobj.height);

     var crash = true;
   if ((mybottom &lt; othertop) ||

     (mytop &gt; otherbottom) ||
   (myright &lt; otherleft) ||
   (myleft &gt; otherright)) {

       crash = false;
   }
   return crash;

   }
</strong>}<strong>
</strong>

function updateGameArea() {
<strong>  if (myGamePiece.crashWith(myObstacle)) {
   myGameArea.stop();
 } else {
</strong>    myGameArea.clear();
   myObstacle.update();

     myGamePiece.newPos(); 
   myGamePiece.update();
 }
}

<a target="_blank" href="https://www.w3schools.com/graphics/tryit.asp?filename=trygame_obstacle_hit" class="w3-btn w3-margin-bottom">Try it Yourself &raquo;</a>

<h2>Moving Obstacle</h2>

The obstacle is of no danger when it is static, so we want it to move.

Change the property value of <code>myObstacle.x</code> at every update:

<h3>Example</h3>
function updateGameArea() {
 if (myGamePiece.crashWith(myObstacle)) {

     myGameArea.stop();
 } else {
   myGameArea.clear();
<strong>    myObstacle.x += -1;
</strong>    myObstacle.update();

     myGamePiece.newPos(); 
   myGamePiece.update();
 }
}

<a target="_blank" href="https://www.w3schools.com/graphics/tryit.asp?filename=trygame_obstacle_move" class="w3-btn w3-margin-bottom">Try it Yourself &raquo;</a>

<h2>Multiple Obstacles</h2>

How about adding multiple obstacles?

For that we need a property for counting frames, and a method for execute something at a given frame rate.

<h3>Example</h3>
var myGameArea = {
 canvas : document.createElement("canvas"),
 start : function() {
   this.canvas.width = 480;
   this.canvas.height = 270;

     this.context = this.canvas.getContext("2d");
   document.body.insertBefore(this.canvas, document.body.childNodes[0]);

    
<strong>this.frameNo = 0;</strong>        

     this.interval = setInterval(updateGameArea, 20);
 },
 clear : function() {

     this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
 },
 stop : function() {

     clearInterval(this.interval);
 }
}

<strong>function everyinterval(n) {
 if ((myGameArea.frameNo / n) % 1 == 0) {return true;}
 return false;
}</strong>

   

The everyinterval function returns true if the current framenumber corresponds with the given interval.

To define multiple obstacles, first declare the obstacle variable as an array.

Second, we need to make some changes in the updateGameArea function.

<h3>Example</h3>
var myGamePiece;
<strong>var myObstacles = [];
</strong>
<strong>function updateGameArea() {

   var x, y;
 for (i = 0; i &lt; myObstacles.length; i += 1) {
   if (myGamePiece.crashWith(myObstacles[i])) {
     myGameArea.stop();
     return;

     } 
 }
 myGameArea.clear();
 myGameArea.frameNo += 1;
 if (myGameArea.frameNo == 1 || everyinterval(150)) {
   x = myGameArea.canvas.width;
   y = myGameArea.canvas.height - 200
   myObstacles.push(new component(10, 200, "green", x, y));

   }
 for (i = 0; i &lt; myObstacles.length; i += 1) {
   myObstacles[i].x += -1;
   myObstacles[i].update();

   }
</strong>  myGamePiece.newPos(); 
 myGamePiece.update();
<strong>}</strong>

<a target="_blank" href="https://www.w3schools.com/graphics/tryit.asp?filename=trygame_obstacles" class="w3-btn w3-margin-bottom">Try it Yourself &raquo;</a>

In the <code>updateGameArea</code> function we must loop through every obstacle to see if there is a crash. If there is a crash, the <code>updateGameArea</code> function will stop, and no more drawing is done.

The <code>updateGameArea</code> function counts frames and adds an obstacle for every 150th frame.

<h2>Obstacles of Random Size</h2>

To make the game a bit more difficult, and fun, we will send in obstacles of random sizes, so that the red square must move up and down to not crash.

<h3>Example</h3>
function updateGameArea() {
 var x, height, gap, minHeight, maxHeight, minGap, maxGap;

   for (i = 0; i &lt; myObstacles.length; i += 1) {
   if (myGamePiece.crashWith(myObstacles[i])) {
     myGameArea.stop();

       return;
   } 
 }
 myGameArea.clear();
 myGameArea.frameNo += 1;
<strong>
   if (myGameArea.frameNo == 1 || everyinterval(150)) {
   x = myGameArea.canvas.width;
   minHeight = 20;

     maxHeight = 200;
   height = Math.floor(Math.random()*(maxHeight-minHeight+1)+minHeight);
   minGap = 50;

     maxGap = 200;
   gap = Math.floor(Math.random()*(maxGap-minGap+1)+minGap);
   myObstacles.push(new component(10, height, "green", x, 0));
   myObstacles.push(new component(10, x - height - gap, "green", x, height + gap));

   }
</strong>  for (i = 0; i &lt; myObstacles.length; i += 1) {

     myObstacles[i].x += -1;
   myObstacles[i].update();

   }
 myGamePiece.newPos(); 
 myGamePiece.update();
}

<a target="_blank" href="https://www.w3schools.com/graphics/tryit.asp?filename=trygame_obstacles_random" class="w3-btn w3-margin-bottom">Try it Yourself &raquo;</a>

&lt;script>

var myGameArea;
var myGamePiece;
var myObstacles = [];
var myscore;

function restartGame() {
document.getElementById("myfilter").style.display = "none";
document.getElementById("myrestartbutton").style.display = "none";
myGameArea.stop();
myGameArea.clear();
myGameArea = {};
myGamePiece = {};
myObstacles = [];
myscore = {};
document.getElementById("canvascontainer").innerHTML = "";
startGame()
}

function startGame() {
   myGameArea = new gamearea();
   myGamePiece = new component(30, 30, "red", 10, 75);
   myscore = new component("15px", "Consolas", "black", 220, 25, "text");
   myGameArea.start();
}

function gamearea() {
   this.canvas = document.createElement("canvas");
   this.canvas.width = 320;
   this.canvas.height = 180;    
   document.getElementById("canvascontainer").appendChild(this.canvas);
   this.context = this.canvas.getContext("2d");
   this.pause = false;
   this.frameNo = 0;
   this.start = function() {
       this.interval = setInterval(updateGameArea, 20);
   }
   this.stop = function() {
       clearInterval(this.interval);
       this.pause = true;
   }
   this.clear = function(){
       this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
   }
}

function component(width, height, color, x, y, type) {

   this.type = type;
   if (type == "text") {
       this.text = color;
   }
   this.score = 0;    this.width = width;
   this.height = height;
   this.speedX = 0;
   this.speedY = 0;    
   this.x = x;
   this.y = y;    
   this.update = function() {
       ctx = myGameArea.context;
       if (this.type == "text") {
           ctx.font = this.width + " " + this.height;
           ctx.fillStyle = color;
           ctx.fillText(this.text, this.x, this.y);
       } else {
           ctx.fillStyle = color;
           ctx.fillRect(this.x, this.y, this.width, this.height);
       }
   }
   this.crashWith = function(otherobj) {
       var myleft = this.x;
       var myright = this.x + (this.width);
       var mytop = this.y;
       var mybottom = this.y + (this.height);
       var otherleft = otherobj.x;
       var otherright = otherobj.x + (otherobj.width);
       var othertop = otherobj.y;
       var otherbottom = otherobj.y + (otherobj.height);
       var crash = true;
       if ((mybottom < othertop) || (mytop > otherbottom) || (myright < otherleft) || (myleft > otherright)) {
           crash = false;
       }
       return crash;
   }
}

function updateGameArea() {
   var x, y, min, max, height, gap;
   for (i = 0; i < myObstacles.length; i += 1) {
       if (myGamePiece.crashWith(myObstacles[i])) {
           myGameArea.stop();
           document.getElementById("myfilter").style.display = "block";
           document.getElementById("myrestartbutton").style.display = "block";
           return;
       } 
   }
   if (myGameArea.pause == false) {
       myGameArea.clear();
       myGameArea.frameNo += 1;
       myscore.score +=1;        
       if (myGameArea.frameNo == 1 || everyinterval(150)) {
           x = myGameArea.canvas.width;
           y = myGameArea.canvas.height - 100;
           min = 20;
           max = 100;
           height = Math.floor(Math.random()*(max-min+1)+min);
           min = 50;
           max = 100;
           gap = Math.floor(Math.random()*(max-min+1)+min);
           myObstacles.push(new component(10, height, "green", x, 0));
           myObstacles.push(new component(10, x - height - gap, "green", x, height + gap));
       }
       for (i = 0; i < myObstacles.length; i += 1) {
           myObstacles[i].x += -1;
           myObstacles[i].update();
       }
       myscore.text="SCORE: " + myscore.score;        
       myscore.update();
       myGamePiece.x += myGamePiece.speedX;
       myGamePiece.y += myGamePiece.speedY;    
       myGamePiece.update();
   }
}

function everyinterval(n) {
   if ((myGameArea.frameNo / n) % 1 == 0) {return true;}
   return false;
}

function moveup(e) {
   myGamePiece.speedY = -1; 
}

function movedown() {
   myGamePiece.speedY = 1; 
}

function moveleft() {
   myGamePiece.speedX = -1; 
}

function moveright() {
   myGamePiece.speedX = 1; 
}

function clearmove(e) {
   myGamePiece.speedX = 0; 
   myGamePiece.speedY = 0; 
}
startGame();

&lt;/script>
<h2>Count The Score</h2>

There are many ways to keep the score in a game, we will show you how to 
write a score onto the canvas.

First make a score component:

<h3>Example</h3>
var myGamePiece;
var myObstacles = [];
<strong>var myScore;

</strong>
function startGame() {
 myGamePiece = new component(30, 30, "red", 10, 160);

<strong>  myScore = new component("30px", "Consolas", "black", 280, 40, "text");
</strong>  myGameArea.start();
}

The syntax for writing text on a canvas element is different from drawing a rectangle.
Therefore we must call the component constructor using an additional argument, telling the constructor that this component is of type "text".

In the component constructor we test if the component is of type "text", and use the 
<code>fillText</code> method instead of the <code>fillRect</code> method:

<h3>Example</h3>
function component(width, height, color, x, y<strong>, type</strong>) {
<strong>  this.type = type;
</strong>  this.width = width;
 this.height = height;
 this.speedX = 0;
 this.speedY = 0; 
 this.x = x;
 this.y = y; 
 this.update = function() {
   ctx = myGameArea.context;
<strong>    if (this.type == "text") {
     ctx.font = this.width + " " + this.height;
     ctx.fillStyle = color;
     ctx.fillText(this.text, this.x, this.y);
   } else {

</strong>      ctx.fillStyle = color;
     ctx.fillRect(this.x, this.y, this.width, this.height);
<strong>    }
</strong>  }
...
}

At last we add some code in the updateGameArea function that writes the score onto the canvas. We use the <code>frameNo</code> property to count the score:

<h3>Example</h3>
function updateGameArea() {
 var x, height, gap, minHeight, maxHeight, minGap, maxGap;

   for (i = 0; i &lt; myObstacles.length; i += 1) {
   if (myGamePiece.crashWith(myObstacles[i])) {

       myGameArea.stop();
     return;
   } 
 }
 myGameArea.clear();

 <strong>  myGameArea.frameNo += 1;
</strong>  if (myGameArea.frameNo == 1 || everyinterval(150)) {
   x = myGameArea.canvas.width;

     minHeight = 20;
   maxHeight = 200;
   height = Math.floor(Math.random()*(maxHeight-minHeight+1)+minHeight);
   minGap = 50;
   maxGap = 200;
   gap = Math.floor(Math.random()*(maxGap-minGap+1)+minGap);

     myObstacles.push(new component(10, height, "green", x, 0));

     myObstacles.push(new component(10, x - height - gap, "green", x, height + gap));

   }
 for (i = 0; i &lt; myObstacles.length; i += 1) {
   myObstacles[i].speedX = -1;

     myObstacles[i].newPos();
   myObstacles[i].update();

   }
<strong>  myScore.text = "SCORE: " + myGameArea.frameNo;

   myScore.update();
</strong>  myGamePiece.newPos();

 myGamePiece.update();
}

<a target="_blank" href="https://www.w3schools.com/graphics/tryit.asp?filename=trygame_score" class="w3-btn w3-margin-bottom">Try it Yourself &raquo;</a>

&lt;script>

var myGameArea;
var myGamePiece;

function startGame() {
   myGameArea = new gamearea();
   myGamePiece = new component(30, 30, "smiley.gif", 10, 75, "image");
   myGameArea.start();
}

function gamearea() {
   this.canvas = document.createElement("canvas");
   this.canvas.width = 320;
   this.canvas.height = 180;    
   document.getElementById("canvascontainer").appendChild(this.canvas);
   this.context = this.canvas.getContext("2d");
   this.start = function() {
       this.interval = setInterval(updateGameArea, 20);
   }
   this.clear = function(){
       this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
   }
}

function component(width, height, color, x, y, type) {
   this.type = type;
   if (type == "image") {
       this.image = new Image();
       this.image.src = color;
   }
   this.width = width;
   this.height = height;
   this.speedX = 0;
   this.speedY = 0;    
   this.x = x;
   this.y = y;    
   this.update = function() {
       ctx = myGameArea.context;
       if (type == "image") {
           ctx.drawImage(this.image, 
               this.x, 
               this.y,
               this.width, this.height);
       } else {
           ctx.fillStyle = color;
           ctx.fillRect(this.x, this.y, this.width, this.height);
       }
   }
}

function updateGameArea() {
   myGameArea.clear();
   myGamePiece.x += myGamePiece.speedX;
   myGamePiece.y += myGamePiece.speedY;    
   myGamePiece.update();
}

function move(dir) {
   myGamePiece.image.src = "angry.gif";
   if (dir == "up") {myGamePiece.speedY = -1; }
   if (dir == "down") {myGamePiece.speedY = 1; }
   if (dir == "left") {myGamePiece.speedX = -1; }
   if (dir == "right") {myGamePiece.speedX = 1; }
}

function clearmove() {
   myGamePiece.image.src = "smiley.gif";
   myGamePiece.speedX = 0; 
   myGamePiece.speedY = 0; 
}
startGame();
&lt;/script>
<h2>How to Use Images?</h2>

To add images on a canvas, the getContext("2d") object has built-in image properties and methods.

In our game, to create the gamepiece as an image, use the component constructor, but instead of referring to a color, you must refer to the url of the image. And you must tell the constructor that this component is of type "image":

<h3>Example</h3>
function startGame() {
 myGamePiece = new component(30, 30, <strong>"smiley.gif"</strong>, 10, 120, <strong>"image"</strong>);
 myGameArea.start();
}

In the component constructor we test if the component is of type "image", and create an image object by using the built-in "new Image()" object constructor. 
When we are ready to draw the image, we use the drawImage method instead of the fillRect method:

<h3>Example</h3>
function component(width, height, color, x, y, type) {
 this.type = type;
<strong>  if (type == "image") {
   this.image = new Image();
   this.image.src = color;
 }
</strong>  this.width = width;
 this.height = height;
 this.speedX = 0;
 this.speedY = 0; 
 this.x = x;
 this.y = y; 
 this.update = function() {
   ctx = myGameArea.context;
<strong>    if (type == "image") {
     ctx.drawImage(this.image, 
       this.x, 
       this.y,
       this.width, this.height);
   } else {
</strong>      ctx.fillStyle = color;
     ctx.fillRect(this.x, this.y, this.width, this.height);
   }
 }
}

<a target="_blank" href="https://www.w3schools.com/graphics/tryit.asp?filename=trygame_image" class="w3-btn w3-margin-bottom">Try it Yourself &raquo;</a>

<h2>Change Images</h2>

You can change the image whenever you like by changing the <code>src</code> property of the <code>image</code> object of your component.

<img src="https://www.w3schools.com/graphics/smiley.gif"> <img src="https://www.w3schools.com/graphics/angry.gif">

If you want to change the smiley everytime it moves, change the image source when the user clicks a button, 
and back to normal when the button is not clicked:

<h3>Example</h3>
function move(dir) {
<strong>  myGamePiece.image.src = "angry.gif";
</strong>  if (dir == "up") {myGamePiece.speedY = -1; }

   if (dir == "down") {myGamePiece.speedY = 1; }
 if (dir == "left") {myGamePiece.speedX = -1; }

   if (dir == "right") {myGamePiece.speedX = 1; }
}

function clearmove() {
<strong>
   myGamePiece.image.src = "smiley.gif";
</strong>  myGamePiece.speedX = 0; 

   myGamePiece.speedY = 0; 
}

<a target="_blank" href="https://www.w3schools.com/graphics/tryit.asp?filename=trygame_image_change" class="w3-btn w3-margin-bottom">Try it Yourself &raquo;</a>

<h2>Background Images</h2>

Add a background image to your game area by adding it as a component, and also update the background in every frame:

<h3>Example</h3>
var myGamePiece;
<strong>var myBackground;
</strong>
function startGame() {

   myGamePiece = new component(30, 30, "smiley.gif", 10, 120, "image");
<strong>
   myBackground = new component(656, 270, "citymarket.jpg", 0, 0, "image");
</strong>
   myGameArea.start();
}

function updateGameArea() {
 myGameArea.clear();

 <strong>  myBackground.newPos(); 
 myBackground.update();
</strong>
   myGamePiece.newPos();

 myGamePiece.update();
}

<a target="_blank" href="https://www.w3schools.com/graphics/tryit.asp?filename=trygame_image_background" class="w3-btn w3-margin-bottom">Try it Yourself &raquo;</a>

<h2>Moving Background</h2>

Change the background component's <code>speedX</code> property to make the background move:

<h3>Example</h3>
function updateGameArea() {
 myGameArea.clear();
<strong>  myBackground.speedX = -1;

</strong>  myBackground.newPos(); 
 myBackground.update();
 myGamePiece.newPos();

 myGamePiece.update();
}

<a target="_blank" href="https://www.w3schools.com/graphics/tryit.asp?filename=trygame_image_background_moving" class="w3-btn w3-margin-bottom">Try it Yourself &raquo;</a>

<h2>Background Loop</h2>

To make the same background loop forever, we must use a specific technique.

Start by telling the component constructor that this is a <em>background</em>.
The component constructor will then add the image twice, placing the second image immediately after the first image.

In the <code>newPos()</code> method, check if the <code>x</code> position of the component has reach the end of the image, if it has, set the <code>x</code> position of the component to 0:

<h3>Example</h3>
function component(width, height, color, x, y, type) {
 this.type = type;
 if (type == "image"<strong> || type == "background"</strong>) {
   this.image = new Image();
   this.image.src = color;

   }
 this.width = width;
 this.height = height;

   this.speedX = 0;
 this.speedY = 0; 
 this.x = x;
 this.y = y; 

   this.update = function() {
   ctx = myGameArea.context;
   if (type == "image" || type == "background") {
     ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
<strong>
       if (type == "background") {
       ctx.drawImage(this.image, this.x + this.width, this.y, this.width, this.height);

       }
</strong>    } else {
     ctx.fillStyle = color;

       ctx.fillRect(this.x, this.y, this.width, this.height);
   }
 }
 this.newPos = function() {
   this.x += this.speedX;

     this.y += this.speedY;
<strong>    if (this.type == "background") {

       if (this.x == -(this.width)) {
       this.x = 0;
     }

     }
</strong>  } 
}

<a target="_blank" href="https://www.w3schools.com/graphics/tryit.asp?filename=trygame_image_background_loop" class="w3-btn w3-margin-bottom">Try it Yourself &raquo;</a>

&lt;script>

var myGameArea;
var myGamePiece;
var myObstacles = [];
var mysound;

function startGame() {
   myGameArea = new gamearea();
   myGamePiece = new component(30, 30, "red", 10, 75);
   mysound = new sound("bounce.mp3");
   myGameArea.start();
}

function gamearea() {
   this.canvas = document.createElement("canvas");
   this.canvas.width = 320;
   this.canvas.height = 180;    
   document.getElementById("canvascontainer").appendChild(this.canvas);
   this.context = this.canvas.getContext("2d");
   this.pause = false;
   this.frameNo = 0;
   this.start = function() {
       this.interval = setInterval(updateGameArea, 20);
   }
   this.stop = function() {
       this.pause = true;
       clearInterval(this.interval);
   }
   this.clear = function(){
       this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
   }
}

function component(width, height, color, x, y) {
   this.width = width;
   this.height = height;
   this.speedX = 0;
   this.speedY = 0;    
   this.x = x;
   this.y = y;    
   this.update = function() {
       ctx = myGameArea.context;
       ctx.fillStyle = color;
       ctx.fillRect(this.x, this.y, this.width, this.height);
   }
   this.crashWith = function(otherobj) {
       var myleft = this.x;
       var myright = this.x + (this.width);
       var mytop = this.y;
       var mybottom = this.y + (this.height);
       var otherleft = otherobj.x;
       var otherright = otherobj.x + (otherobj.width);
       var othertop = otherobj.y;
       var otherbottom = otherobj.y + (otherobj.height);
       var crash = true;
       if ((mybottom < othertop) || (mytop > otherbottom) || (myright < otherleft) || (myleft > otherright)) {
           crash = false;
       }
       return crash;
   }
}

function updateGameArea() {
   var x, y, min, max, height, gap;
   for (i = 0; i < myObstacles.length; i += 1) {
       if (myGamePiece.crashWith(myObstacles[i])) {
           mysound.play();
           myGameArea.stop();
       } 
   }
   if (myGameArea.pause == false) {
       myGameArea.clear();
       myGameArea.frameNo += 1;
       if (myGameArea.frameNo == 1 || everyinterval(150)) {
           x = myGameArea.canvas.width;
           y = myGameArea.canvas.height - 100;
           min = 20;
           max = 100;
           height = Math.floor(Math.random()*(max-min+1)+min);
           min = 50;
           max = 100;
           gap = Math.floor(Math.random()*(max-min+1)+min);
           myObstacles.push(new component(10, height, "green", x, 0));
           myObstacles.push(new component(10, x - height - gap, "green", x, height + gap));
       }
       for (i = 0; i < myObstacles.length; i += 1) {
           myObstacles[i].x += -1;
           myObstacles[i].update();
       }
       myGamePiece.x += myGamePiece.speedX;
       myGamePiece.y += myGamePiece.speedY;    
       myGamePiece.update();
   }
}

function sound(src) {
   this.sound = document.createElement("audio");
   this.sound.src = src;
   this.sound.setAttribute("preload", "auto");
   this.sound.setAttribute("controls", "none");
   this.sound.style.display = "none";
   document.body.appendChild(this.sound);
   this.play = function(){
       this.sound.play();
   }
}

function everyinterval(n) {
   if ((myGameArea.frameNo / n) % 1 == 0) {return true;}
   return false;
}

function moveup(e) {
   myGamePiece.speedY = -1; 
}

function movedown() {
   myGamePiece.speedY = 1; 
}

function moveleft() {
   myGamePiece.speedX = -1; 
}

function moveright() {
   myGamePiece.speedX = 1; 
}

function clearmove(e) {
   myGamePiece.speedX = 0; 
   myGamePiece.speedY = 0; 
}
startGame();

&lt;/script>
<h2>How to Add Sounds?</h2>

Use the HTML5 &lt;audio&gt; element to add sound and music to your games.

In our examples, we create a new object constructor to handle sound objects:

<h3>Example</h3>
function sound(src) {
 this.sound = document.createElement("audio");

   this.sound.src = src;
 this.sound.setAttribute("preload", "auto");

   this.sound.setAttribute("controls", "none");
 this.sound.style.display = "none";
 document.body.appendChild(this.sound);
 this.play = function(){
   this.sound.play();

   }
 this.stop = function(){
   this.sound.pause();
 }
}

To create a new sound object use the <code>sound</code> constructor, and when the red square hits an obstacle, play the sound:

<h3>Example</h3>
var myGamePiece;
var myObstacles = [];
<strong>var mySound;
</strong>
function startGame() {
 myGamePiece = new component(30, 30, "red", 10, 120);

  
<strong>mySound = new sound("bounce.mp3");
</strong>  myGameArea.start();
}

function updateGameArea() {
 var x, height, gap, minHeight, maxHeight, minGap, maxGap;
 for (i = 0; i &lt; myObstacles.length; i += 1) {
   if (myGamePiece.crashWith(myObstacles[i])) {
<strong>      mySound.play();
</strong>
       myGameArea.stop();
     return;
   } 
 }

...

}

<a target="_blank" href="https://www.w3schools.com/graphics/tryit.asp?filename=trygame_sound" class="w3-btn w3-margin-bottom">Try it Yourself &raquo;</a>

<h2>Background Music</h2>

To add background music to your game, add a new sound object, and start playing when you start the game:

<h3>Example</h3>
var myGamePiece;
var myObstacles = [];
var mySound;
<strong>var myMusic;</strong>

function startGame() {

   myGamePiece = new component(30, 30, "red", 10, 120);
 mySound = new sound("bounce.mp3");

 <strong>  myMusic = new sound("gametheme.mp3");
 myMusic.play();

</strong>  myGameArea.start();
}

<a target="_blank" href="https://www.w3schools.com/graphics/tryit.asp?filename=trygame_sound_music" class="w3-btn w3-margin-bottom">Try it Yourself &raquo;</a>

&lt;script>

var myGameArea;
var myGamePiece;
var myoverlay;
var myresult;
var accel = false;

function startGame() {
   myGameArea = new gamearea("canvascontainer");
   //myresult = new component(myGameArea, "30px", "Consolas", "white", 30, 50, "text");
   //myresult.text = "Land me Safely"
   myGamePiece = new component(30, 30, "red", 50, 50);
   //myoverlay = new component(myGameArea, 640, 360, "rgba(0,255,0,0.1)", 0, 0);    
   myGameArea.start();
}

function gamearea() {
   this.canvas = document.createElement("canvas");
   this.canvas.width = 320;
   this.canvas.height = 180;    
   document.getElementById("canvascontainer").appendChild(this.canvas);
   this.context = this.canvas.getContext("2d");
   this.start = function() {
       this.interval = setInterval(updateGameArea, 20);
   }
   this.stop = function() {
       clearInterval(this.interval);
       this.pause = true;
   }    
   this.clear = function(){
       this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
   }
}

function component(width, height, color, x, y, type) {

   this.type = type;
   if (type == "image") {
       this.image = new Image();
       this.image.src = color;
   }
   this.width = width;
   this.height = height;
   this.angle = 0;
   this.moveangle = 0;
   this.color = color;
   this.rotation = 0;
   this.speed = 0;
   this.fallspeed = 0;
   this.x = x;
   this.y = y;
   this.speedX = 0;
   this.speedY = 0;
   this.update = function() {
       ctx = myGameArea.context;
       ctx.save();
       ctx.translate(this.x, this.y);        
       ctx.rotate(this.angle);
       if (this.type == "text") {
           ctx.font = this.width + " " + this.height;
           ctx.fillStyle = color;
           ctx.fillText(this.text, this.x, this.y);
       } else {        
           ctx.fillStyle = this.color;
           ctx.fillRect(-(this.width / 2), -(this.height / 2), this.width, this.height);        
       }
       ctx.restore();    
   }
   this.newGravityPos = function(degrees, thrust) {
       degrees -= 90;
       angle = degrees * Math.PI / 180;
       this.speedX += thrust * Math.cos(angle);
       this.speedY += thrust * Math.sin(angle);
       this.calcSpeedAngle();
   }
   this.calcSpeedAngle = function(){
       this.speed = Math.sqrt((this.speedX * this.speedX) + (this.speedY * this.speedY));
   }
}

function updateGameArea() {
   myGameArea.clear();
   myGamePiece.x += myGamePiece.speedX;
   myGamePiece.y += myGamePiece.speedY;    
   if (accel == true || (document.key && document.key == 38)) {
       myGamePiece.newGravityPos(0, 0.2);
   }
   myGamePiece.newGravityPos(180, 0.05);
   if (myGamePiece.speed > 2 || myGamePiece.y < -15) {
   //    myoverlay.color = "rgba(255,0,0,0.1)"
   } else {
   //    myoverlay.color = "rgba(0,255,0,0.1)"
   }    
   myGamePiece.update();
   //myoverlay.update();    
   if (myGamePiece.y > 165) {
       myGameArea.stop();
       if (myGamePiece.speed > 2) {
           //myresult.width = "26px";
           //myresult.x = 10;
           //myresult.text = "Landing was to hard!";
           //myoverlay.color = "rgba(255,0,0,0.1)"
       } else {
           //myoverlay.color = "rgba(0,255,0,0.1)"
           //myresult.text = "Nice landing!";
       }
   }
   if (myGamePiece.y < -15) {
       myGameArea.stop();
       //myresult.width = "18px";
       //myresult.x = 4;
       //myresult.text = "You lost the red square!";
   }
   //myresult.update();            
}

function accelerate(x) {
   accel = x;
}

function restartgame(x) {
   myGameArea.stop();
   document.getElementById("canvascontainer").innerHTML = "";
   startGame();
}

startGame();
&lt;/script>
<h2>Gravity</h2>

To add this functionality to our component constructor, first add a <code>gravity</code> property, which sets the current gravity.
Then add a <code>gravitySpeed</code> property, which increases everytime we update the frame:

<h3>Example</h3>
function component(width, height, color, x, y, type) {
 this.type = type;
 this.width = width;
 this.height = height;

   this.x = x;
 this.y = y; 
 this.speedX = 0;
 this.speedY = 0; 
<strong>
   this.gravity = 0.05;
 this.gravitySpeed = 0;
 </strong>this.update = function() {
   ctx = myGameArea.context;
   ctx.fillStyle = color;
   ctx.fillRect(this.x, this.y, this.width, this.height);

   }
 this.newPos = function() {
<strong>    this.gravitySpeed += this.gravity;
</strong>
     this.x += this.speedX;
   this.y += this.speedY<strong> + this.gravitySpeed</strong>; 

   }

}

<a target="_blank" href="https://www.w3schools.com/graphics/tryit.asp?filename=trygame_gravity" class="w3-btn w3-margin-bottom">Try it Yourself &raquo;</a>

<h2>Hit the Bottom</h2>

To prevent the red square from falling forever, stop the falling when it hits the bottom of the game area:

<h3>Example</h3>
  this.newPos = function() {
   this.gravitySpeed += this.gravity;

     this.x += this.speedX;
   this.y += this.speedY + this.gravitySpeed;
<strong>    this.hitBottom();
</strong>
   }
<strong>  this.hitBottom = function() {
   var rockbottom = myGameArea.canvas.height - this.height;

     if (this.y &gt; rockbottom) {
     this.y = rockbottom;

     }
 }</strong>

<a target="_blank" href="https://www.w3schools.com/graphics/tryit.asp?filename=trygame_gravity_bottom" class="w3-btn w3-margin-bottom">Try it Yourself &raquo;</a>

<h2>Accelerate Up</h2>

In a game, when you have a force that pulls you down, you should have a method to force the component to accelerate up.

Trigger a function when someone clicks a button, and make the red square fly up in the air: 

<h3>Example</h3>
&lt;script&gt;
function accelerate(n) {
 myGamePiece.gravity = n;
}
&lt;/script&gt;

&lt;button onmousedown="accelerate(-0.2)" onmouseup="accelerate(0.1)"&gt;ACCELERATE&lt;/button&gt;

<a target="_blank" href="https://www.w3schools.com/graphics/tryit.asp?filename=trygame_gravity_accelerate" class="w3-btn w3-margin-bottom">Try it Yourself &raquo;</a>

<h2>A Game</h2>

Make a game based on what we have learned so far:

<h3>Example</h3>

<iframe id="game1" src="https://www.w3schools.com/graphics/trygame_gravity_game.htm" style="width:100%;max-width:650px;height:480px;border:none;"></iframe>

<a target="_blank" href="https://www.w3schools.com/graphics/tryit.asp?filename=trygame_gravity_game" class="w3-btn w3-margin-top w3-margin-bottom">Try it Yourself &raquo;</a>

&lt;script>

var myGamePiece;
var myoverlay;
var myresult;
var accel = false;

function startGame() {
   myGamePiece = new component(30, 30, "red", 50, 50);
   myGameArea.start();
}

var myGameArea = {
   canvas : document.createElement("canvas"),
   start : function() {
       this.canvas.width = 320;
       this.canvas.height = 180;
       this.context = this.canvas.getContext("2d");
       document.getElementById("canvascontainer").appendChild(this.canvas);
       this.interval = setInterval(updateGameArea, 20);        
   },
   stop : function() {
       clearInterval(this.interval);
   },    
   clear : function() {
       this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
   }
}

function component(width, height, color, x, y, type) {
   this.type = type;
   this.width = width;
   this.height = height;
   this.speed = 0;
   this.gravity = 0.1;
   this.gravitySpeed = 0;
   this.bounce = 0.6;
   this.angle = 0;
   this.x = x;
   this.y = y;    
   this.update = function() {
       ctx = myGameArea.context;
       ctx.save();
       ctx.translate(this.x, this.y);
       ctx.rotate(this.angle);
       ctx.fillStyle = color;
       ctx.fillRect(this.width / -2, this.height / -2, this.width, this.height);        
       ctx.restore();    
   }
   this.newPos = function() {
       var rockbottom = myGameArea.canvas.height - (this.height / 2);
       this.gravitySpeed += this.gravity;
       this.x += this.speed * Math.cos(this.angle);
       this.y += (this.speed * Math.sin(this.angle)) + this.gravitySpeed;
       if (this.y > rockbottom) {
           this.gravitySpeed=-(this.gravitySpeed * this.bounce);
           this.gravitySpeed = Number(this.gravitySpeed.toFixed(2));
           this.y = rockbottom;
       }
   }
}

function updateGameArea() {
   myGameArea.clear();
   myGamePiece.newPos();
   myGamePiece.update();
}

function restartgame(x) {
   myGameArea.stop();
   document.getElementById("canvascontainer").innerHTML = "";
   startGame();
}

startGame();
&lt;/script>
<h2>Bouncing</h2>

Another functionallity we want to add is the <code>bounce</code> property.

The <code>bounce</code> property indicates if the component will bounce back when gravity makes it fall down to the ground.

The bounce property value must be a number. 0 is no bounce at all, and 1 will make the component bounce all the way backto where it start falling.

<h3>Example</h3>
function component(width, height, color, x, y, type) {
 this.type = type;
 this.width = width;
 this.height = height;

   this.x = x;
 this.y = y; 
 this.speedX = 0;
 this.speedY = 0; 

   this.gravity = 0.1;
 this.gravitySpeed = 0;
<strong>  this.bounce = 0.6;

   </strong>this.update = function() {
   ctx = myGameArea.context;
   ctx.fillStyle = color;
   ctx.fillRect(this.x, this.y, this.width, this.height);

   }
 this.newPos = function() {
   this.gravitySpeed += this.gravity;

     this.x += this.speedX;
   this.y += this.speedY + this.gravitySpeed;
   this.hitBottom();

   }
 this.hitBottom = function() {
   var rockbottom = this.gamearea.canvas.height - this.height;
   if (this.y &gt; rockbottom) {
     this.y = rockbottom;
<strong>      this.gravitySpeed = -(this.gravitySpeed * this.bounce);
</strong>
     }
 }
}

<a target="_blank" href="https://www.w3schools.com/graphics/tryit.asp?filename=trygame_bouncing" class="w3-btn w3-margin-bottom">Try it Yourself &raquo;</a>

&lt;button id="playagain" onclick="clickPlayagain()">Rotate&lt;/button>
&lt;script>

var myGameArea;
var myGamePiece;

function startGame() {
   myGameArea = new gamearea("");
   myGamePiece = new component(30, 30, "red", 25, 90);
   myGameArea.start();
}

function gamearea(x) {
   this.canvas = document.createElement("canvas");
   this.canvas.width = 320;
   this.canvas.height = 180;
   document.getElementById("canvascontainer" + x).innerHTML = "";
   document.getElementById("canvascontainer" + x).appendChild(this.canvas);
   this.context = this.canvas.getContext("2d");
   this.frameNo = 0;
   this.start = function() {
       this.interval = setInterval(updateGameArea, 20);
   }
   this.stop = function() {
       clearInterval(this.interval);
   }    
   this.clear = function(){
       this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
   }
}

function component(width, height, color, x, y, type) {
   this.type = type;
   this.width = width;
   this.height = height;
   this.speed = 0;
   this.angle = 0;
   this.moveangle = 0;
   this.x = x;
   this.y = y;    
   this.update = function() {
       ctx = myGameArea.context;
       ctx.save();
       ctx.translate(this.x, this.y);
       ctx.rotate(this.angle);
       if (this.type == "text") {
           ctx.font = this.width + " " + this.height;
           ctx.fillStyle = color;
           width = ctx.measureText(this.text).width;
           height = ctx.measureText("m").width 
           ctx.fillText(this.text, width/ -2, height/2);        
       } else {
           ctx.fillStyle = color;
           ctx.fillRect(this.width / -2, this.height / -2, this.width, this.height);        
       }
       ctx.restore();    
   }
   this.newPos = function() {
       this.x += this.speed * Math.cos(this.angle);
       this.y += this.speed * Math.sin(this.angle);
       this.angle += this.moveangle
   }
}

var rotation;
function updateGameArea(y) {
   myGameArea.clear();
   myGameArea.frameNo++;
   myGamePiece.speed = 0;
   myGamePiece.moveangle = 1 * Math.PI / 180;    
   if (myGameArea.frameNo > 90) {
       myGamePiece.moveangle = 0;
   }
   myGamePiece.newPos();
   myGamePiece.update();
}

function clickPlayagain() {
   myGameArea.stop();
   startGame();

}

startGame();
&lt;/script>

<h2>Rotating Components</h2>

Earlier in this tutorial, the red square was able to move around on the gamearea, but it could not turn or rotate.

To rotate components, we have to change the way we draw components.

The only rotation method available for the canvas element will rotate the entire canvas:

<img src="https://www.w3schools.com/graphics/rotate1.png" class="w3-image">

Everything else you draw on the canvas will also be rotated, not only the specific component.

That is why we have to make some changes in the <code>update()</code> method:

First, we save the current canvas context object:

<code>ctx.save();</code>

       

Then we move the entire canvas to the center of the specific component, using the translate method:
       

<code>ctx.translate(x, y);</code>

<img src="https://www.w3schools.com/graphics/game_movement1.png" class="w3-image">

Then we perform the wanted rotation using the rotate() method:

<code>ctx.rotate(<em>angle</em>);</code>

<img src="https://www.w3schools.com/graphics/game_movement2.png" class="w3-image">

Now we are ready to draw the component onto the canvas, but now we will draw it with its center position at position 0,0 on the translated (and rotated) canvas:

<code>ctx.fillRect(width / -2, height / -2, width, height);</code>

<img src="https://www.w3schools.com/graphics/game_movement3.png" class="w3-image">

When we are finished, we must restore the context object back to its saved position, using the restore method:

<code>ctx.restore();</code>

The component is the only thing that is rotated:

<img src="https://www.w3schools.com/graphics/game_movement4.png" class="w3-image">

<h2>The Component Constructor</h2>

The <code>component</code> constructor has a new property called <code>angle</code>, which is radian number that represents the angle of the component.

The <code>update</code> method of the <code>component</code> constructor is were we draw the component, and here you can see the changes that will allow the component to rotate:

<h3>Example</h3>
function component(width, height, color, x, y) {
 this.width = width;
 this.height = height;
<strong>
   this.angle = 0;

</strong>  this.x = x;
 this.y = y;

 this.update = function() {
   ctx = myGameArea.context;
<strong>    ctx.save();
   ctx.translate(this.x, this.y); 
   ctx.rotate(this.angle);
</strong>
     ctx.fillStyle = color;
<strong>    ctx.fillRect(this.width / -2, this.height / -2, this.width, this.height);

   ctx.restore(); 
</strong>  }
}

function updateGameArea() {
 myGameArea.clear();

 <strong>  myGamePiece.angle += 1 * Math.PI / 180; 
</strong>  myGamePiece.update();
}

<a target="_blank" href="https://www.w3schools.com/graphics/tryit.asp?filename=trygame_rotate_game" class="w3-btn w3-margin-bottom">Try it Yourself &raquo;</a>

&lt;button id="playagain" onclick="clickPlayagain()">Play again&lt;/button>
<h2>How to Move Objects?</h2>

Add a <code>speed</code> property to the <code>component</code> constructor, which represents the current speed of the component.

Also make some changes in the <code>newPos()</code> method, to calculate the position of the component, based on <code>speed</code> and <code>angle</code>.

By default, the components are facing up, and by setting the speed property to 1, the component will start moving forward.

<h3>Example</h3>
function component(width, height, color, x, y) {
 this.gamearea = gamearea;

   this.width = width;
 this.height = height;
 this.angle = 0;
<strong>
   this.speed = 1;

</strong>  this.x = x;
 this.y = y;

 this.update = function() {
   ctx = myGameArea.context;
   ctx.save();

     ctx.translate(this.x, this.y); 
   ctx.rotate(this.angle);

     ctx.fillStyle = color;
   ctx.fillRect(this.width / -2, this.height / -2, this.width, this.height);

   ctx.restore(); 
 }
<strong>  this.newPos = function() {
   this.x += this.speed * Math.sin(this.angle);

     this.y -= this.speed * Math.cos(this.angle);
 }

</strong>}

<a target="_blank" href="https://www.w3schools.com/graphics/tryit.asp?filename=trygame_movement_forward" class="w3-btn w3-margin-bottom">Try it Yourself &raquo;</a>

<h2>Making Turns</h2>

We also want to be able to make left and right turns. Make a new property called <code>moveAngle</code>, which indicates the current moving value, or rotation angle. In the <code>newPos()</code> method calculate the
<code>angle</code> based on the <code>moveAngle</code> property:

<h3>Example</h3>

Set the moveangle property to 1, and see what happens:

function component(width, height, color, x, y) {
 this.width = width;

   this.height = height;
 this.angle = 0;
<strong>  this.moveAngle = 1;

</strong>  this.speed = 1;

  this.x = x;
 this.y = y;

 this.update = function() {
   ctx = myGameArea.context;
   ctx.save();
   ctx.translate(this.x, this.y); 
   ctx.rotate(this.angle);
   ctx.fillStyle = color;
   ctx.fillRect(this.width / -2, this.height / -2, this.width, this.height);

   ctx.restore(); 
 }
 this.newPos = function() {
<strong>    this.angle += this.moveAngle * Math.PI / 180;
</strong>
     this.x += this.speed * Math.sin(this.angle);
   this.y -= this.speed * Math.cos(this.angle);

   }

}

<a target="_blank" href="https://www.w3schools.com/graphics/tryit.asp?filename=trygame_movement_turn" class="w3-btn w3-margin-bottom">Try it Yourself &raquo;</a>

<h2>Use the Keyboard</h2>

How does the red square move when using the keyboard?
Instead of moving up and down, and from side to side, the red square moves forward when you use the "up" arrow,and turns left and right when pressing the left and right arrows.

<h3>Example</h3>
<iframe src="https://www.w3schools.com/graphics/trygame_movement_keyboard.htm" style="width:100%;height:440px;border:none;"></iframe>

<a target="_blank" href="https://www.w3schools.com/graphics/tryit.asp?filename=trygame_movement_keyboard" class="w3-btn w3-margin-top w3-margin-bottom">Try it Yourself &raquo;</a>

&lt;script>

var myGameArea;
var myGamePiece;

//var myGameArea2;
//var myGamePiece2;

function startGame() {
   myGameArea = new gamearea("");
   myGamePiece = new component(20, 20, "red", 15, 110);
   myGameArea.start();

//    myGameArea2 = new gamearea("2");
//    myGamePiece2 = new component(myGameArea2, "50px", "Consolas", "red", 100, 15, "text");
//    myGamePiece2.text = "\u00BB";
//    myGameArea2.start();

}

function gamearea(x) {
   this.canvas = document.createElement("canvas");
   this.canvas.width = 320;
   this.canvas.height = 180;
   document.getElementById("canvascontainer" + x).innerHTML = "";
   document.getElementById("canvascontainer" + x).appendChild(this.canvas);
   this.context = this.canvas.getContext("2d");
   this.frameNo = 0;
   this.start = function() {
       this.interval = setInterval(updateGameArea, 20);
   }
   this.stop = function() {
       clearInterval(this.interval);
   }    
   this.clear = function(){
       this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
   }
}

function component(width, height, color, x, y, type) {

   this.type = type;
   this.width = width;
   this.height = height;
   this.speed = 0;
   this.angle = 0;
   this.moveangle = 0;
   this.x = x;
   this.y = y;    
   this.update = function() {
       ctx = myGameArea.context;
       ctx.save();
       ctx.translate(this.x, this.y);
       ctx.rotate(this.angle);
       if (this.type == "text") {
           ctx.font = this.width + " " + this.height;
           ctx.fillStyle = color;
           width = ctx.measureText(this.text).width;
           height = ctx.measureText("m").width 
           ctx.fillText(this.text, width/ -2, height/2);        
       } else {
           ctx.fillStyle = color;
           ctx.fillRect(this.width / -2, this.height / -2, this.width, this.height);        
       }
       ctx.restore();    
   }
   this.newPos = function() {
       this.x += this.speed * Math.sin(this.angle);
       this.y -= this.speed * Math.cos(this.angle);
       this.angle += this.moveangle
   }
}

var rotation;
function updateGameArea(y) {
   myGameArea.clear();
   myGameArea.frameNo++;
   myGamePiece.speed = 1;
   if (myGameArea.frameNo == 1) {
       rotation = 0;
       document.getElementById("playagain").disabled = true;
//        document.getElementById("playagain2").disabled = true;
   }
   rotation++;
   if (rotation == 40) {
       myGamePiece.moveangle = 1 * Math.PI / 180;
   }
   if (rotation == 130) {
       myGamePiece.moveangle = 0;
   }
   if (myGameArea.frameNo >= 520) {
       myGamePiece.speed = 0;
       myGamePiece.moveangle = 0;
       document.getElementById("playagain").disabled = false;        
//        document.getElementById("playagain2").disabled = false;                
   }

   myGamePiece.newPos();
   myGamePiece.update();

//    myGameArea2.clear();
//    myGameArea2.frameNo++;
//    myGamePiece2.speed = 1;
//    if (rotation == 40) {
//        myGamePiece2.moveangle = 1 * Math.PI / 180;
//    }
   if (rotation == 130) {
//        myGamePiece2.moveangle = 0;
       rotation = 0;
   }
//    if (myGameArea2.frameNo >= 520) {
//        myGamePiece2.speed = 0;
//        myGamePiece2.moveangle = 0;        
//    }
//    myGamePiece2.newPos();
//    myGamePiece2.update();

}

function clickPlayagain() {
   myGameArea.stop();
//    myGameArea2.stop();    
   startGame();

}

startGame();
&lt;/script>

<script type='text/javascript' src='readbook.js'></script>
<script>
var lazyLoadInstance = new LazyLoad({
    elements_selector: ".lazy"
    // ... more custom settings?
});
</script>
</pre></body></html>