<base target="_blank"><html><head><title>linux notes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src="../lazyload.min.js"></script>
<script type='text/javascript' src='../mainscript.js'></script>
<script src="D:/Dropbox/Public/commonfunctions.js"></script>
<script>
  var showTopicNumber = false;
  var bookid = "linux notes" 
</script>
<style>
body{width:80%;margin-left: 10%; font-size:22px;}
h1, h2 {color: gold;}
strong {color: orange;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px;}
</style></head><body onkeypress="chkKey()"><center>
<h1></h1>
<a href="#mustWatch" class="red goldbs" target="_self">Must Watch!</a>
<br>
<a href="Bash Scripting Tutorial.html" class="whitebut gold">Bash Scripting Tutorial</a>
<a href="https://medium.com/@zibon/basic-linux-command-lines-to-get-started-developing-in-ubuntu-linux-b54def1c2190" class="whitebut ">Basic Linux command line tutorial</a>
<a href="LibDocs\LINUX Tutorial.html">&diams;LINUX Tutorial</a>

<br>
<div id="toc"></div></center>
<br><br>
<div id="mustWatch"><center><span class="red">MustWatch</span></center><br>
<a href="https://www.tutorialspoint.com/unix/index.htm" class="whitebut ">LINUX Tutorial</a>
<a href="https://learn.microsoft.com/en-us/windows/wsl/tutorials/gui-apps" class="whitebut ">Run Linux GUI apps on the Windows Subsystem for Linux</a>

<a href="https://bochs.sourceforge.io/" class="whitebut ">Bochs Emulator</a>
<a href="https://mp.weixin.qq.com/s/2hOw6ZuqahyC3iaSvuyfJA" class="whitebut ">Linux 环境变量总结</a>

<a href="https://www.linuxjournal.com/content/diy-build-custom-minimal-linux-distribution-source" class="whitebut ">DIY: Build a Custom Minimal Linux Distribution from Source</a>
<a href="https://www.sohu.com/a/475114085_115128" class="whitebut ">“我花了 5 年时间编写自己的操作系统！” </a>

<a href="http://puppylinux.com/index.html" class="whitebut ">light weight BionicPup 32 Linux distros</a>

<a href="Linux 系统结构详解.html" class="whitebut ">Linux 系统结构详解</a>

<a href="An Introduction to the Linux.html" class="whitebut ">An Introduction to the Linux</a>
<a href="https://www.youtube.com/watch?v=SkB-eRCzWIU" class="whitebut ">Linux Terminal Introduction</a>
</div>
<pre>
<br>
<br>

<h2>#!</h2>
"#!" is an operator called shebang which directs the script to the interpreter location. 
So, if we use"#! /bin/sh" the script gets directed to the bourne-shell.


<a href="https://www.guru99.com/introduction-to-shell-scripting.html" class="whitebut ">Shell Script in Linux/Unix</a>


<a href="http://www.tutorialspoint.com/unix/unix-getting-started.htm" class="bordred1 borRad10">Unix - Getting Started</a>
<a href="http://www.comptechdoc.org/os/linux/usersguide/linux_ugbasics.html">Basic Linux</a>
<a href="http://man.linuxde.net/">Man Linux</a>
<br><br>
<a href="https://forums.linuxmint.com/viewtopic.php?t=97158"><span class="redsha">How to install software on Linux Mint</span></a>
<br>
<a href="https://www.lifewire.com/choose-best-linux-distro-for-needs-2201172">Choose The Best Linux Distro</a>
<a href="https://en.wikipedia.org/wiki/List_of_Linux_distributions">List of Linux distributions</a>
<br>

<a href="http://www.cygwin.com/">Linux Terminal on Windows</a>
<a href="http://ss64.com/bash/">Bash commands</a>


<a href="http://kevinboone.net/kbox.html">KBOX — a miniature Linux</a>

<a href="Convert Android to Linux.html">Convert Android to Linux</a>
<br>
<a href="https://www.androidauthority.com/an-introduction-to-basic4android-678630/">Basic4Android building Android apps</a>
<br>

<a href="http://linux.about.com/od/commands/tp/11-Linux-Terminal-Commands-That-Will-Rock-Your-World.01.htm">15 Linux Terminal Commands</a>



<br>
<a href="http://youtu.be/AO0jzD1hpXc">linux command line</a>
<br>
<a href="http://www.howtogeek.com/howto/14912/create-a-persistent-bootable-ubuntu-usb-flash-drive/">Create a Live Ubuntu USB Drive With Persistent Storage</a>
<br>

<h2>ubuntu KeyboardShortcuts</h2>
<a href="http://help.ubuntu.com/community/KeyboardShortcuts">ubuntu KeyboardShortcuts</a>
<a href="http://help.ubuntu.com/stable/ubuntu-help/shell-keyboard-shortcuts.html">ubuntu键盘快捷键</a>
<br>

<br>

<a href="http://opensource.com/article/17/2/command-line-tools-data-analysis-linux"><i class="redrose">10 Command-line Tools For Data Analysis In Linux</i></a>
<br>
<a href="http://www-uxsup.csx.cam.ac.uk/pub/doc/suse/suse9.0/userguide-9.0/ch24s04.html">Important Linux Commands</a>
<br>

<a href="http://opensource.com/article/17/2/linux-boot-and-startup"><b class="redbord">Introduction To The Linux Boot And Startup Processes</b></a>
<br>
<a href="LibDocs\Useful Shell Commands For Data Science.html">&diams;Useful Shell Commands For Data Science</a><br>
<a href="http://chuansong.me/account/LinuxHub">Linux爱好者</a>
<br>
<a href="http://chuansong.me/n/2274461349222">ln 命令教程</a>
<br>
<a href="https://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&mid=2666542070&idx=1&sn=35edea5336adf8f90edd378990b171a9&chksm=80dcf75db7ab7e4bc7e332a14c0c4d7db0384605956b0747481d9ea8b3f016eeb18e088530b5&scene=0#rd">给初学者的 type 命令教程</a>
<br>

<a href="https://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&mid=2666542083&idx=1&sn=9cf98a54d4cbfb71f28e1a3b859cd06a&chksm=80dcf0a8b7ab79be682047c2e6005658e0902c3319616aaa05d44f3f9262d79b070af9ae7808&mpshare=1&scene=1&srcid=04101cieV7TCBgTlfS8VrLHn&pass_ticket=ffHA2AbUubeZmNO0YwV710%2F%2F4ddlmoyHLacbjI9AFiSmoDbzHsy0wRqDu5yHGUGA#rd">10 个增加 UNIX/Linux Shell 脚本趣味的工具</a>
<br>
<a href="https://mp.weixin.qq.com/s?__biz=MzA4MjEyNTA5Mw==&mid=2652567459&idx=2&sn=234daf978537df5d0ec880b4995ef3f8&chksm=8464dfe9b31356ffe317d3d89adc593c329c215e9f33cc65738fd775bd5be5635adae20728a9&mpshare=1&scene=1&srcid=0410a3J2g7lgX8CNiQATAnzd&pass_ticket=ffHA2AbUubeZmNO0YwV710%2F%2F4ddlmoyHLacbjI9AFiSmoDbzHsy0wRqDu5yHGUGA#rd">Linux 启动过程分析</a>
<br>
<a href="https://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&mid=2666542052&idx=1&sn=1b42479e652f36bc5f3940033531dcc5&chksm=80dcf74fb7ab7e5914ca7edbcf0b22df8d0493d73930900944701b15c98a23f37abc995bdb01&mpshare=1&scene=1&srcid=0410P7JFsjA1mgXsos2RRyoU&pass_ticket=ffHA2AbUubeZmNO0YwV710%2F%2F4ddlmoyHLacbjI9AFiSmoDbzHsy0wRqDu5yHGUGA#rd">为初学者准备的 ln 命令教程（5 个示例）</a>
<br>
<br>
<a href="https://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&mid=2666542070&idx=1&sn=35edea5336adf8f90edd378990b171a9&chksm=80dcf75db7ab7e4bc7e332a14c0c4d7db0384605956b0747481d9ea8b3f016eeb18e088530b5&mpshare=1&scene=1&srcid=0410x0mWVNkLd4fk9xLGMsYs&pass_ticket=ffHA2AbUubeZmNO0YwV710%2F%2F4ddlmoyHLacbjI9AFiSmoDbzHsy0wRqDu5yHGUGA#rd">给初学者的 type 命令教程</a>
<br>
<a href="https://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&mid=2666542041&idx=1&sn=d4688e9df9a33b2c80b8ca2b7d08e508&chksm=80dcf772b7ab7e646985ce289660ed0e1925138a84136bbe0ffe1fc0836716e951fb580bb47a&mpshare=1&scene=1&srcid=0410oxyrfsSgRuesiYKfa8Qk&pass_ticket=ffHA2AbUubeZmNO0YwV710%2F%2F4ddlmoyHLacbjI9AFiSmoDbzHsy0wRqDu5yHGUGA#rd">升级到 Ubuntu 18.04 LTS 的理由，大波新特性到来</a>
<br>
<a href="https://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&mid=2666542031&idx=1&sn=748831d1d635a7873136aeac6ae1828a&chksm=80dcf764b7ab7e729f264f35c24b7992446d16528c29c9c754f8d4e4f7bb09184588ee9677e0&mpshare=1&scene=1&srcid=0410njlSIQFRMdcZ4Jl5hiqS&pass_ticket=ffHA2AbUubeZmNO0YwV710%2F%2F4ddlmoyHLacbjI9AFiSmoDbzHsy0wRqDu5yHGUGA#rd">如何在 Linux 上安装应用程序</a>
<br>
<a href="https://itsfoss.com/things-to-do-after-installing-linux-mint-18/">things-to-do-after-installing-linux-mint</a>
<br>
<a href="https://www.ubuntupit.com/top-10-best-things-installing-linux-mint-18-3-sylvia/">best-things-installing-linux-mint</a>

<h2>Important Linux Commands</h2>
<a href="http://www-uxsup.csx.cam.ac.uk/pub/doc/suse/suse9.0/userguide-9.0/index.html" class="whitebut ">SuSE Linux User Guide</a>
<a href="http://www-uxsup.csx.cam.ac.uk/pub/doc/suse/suse9.0/userguide-9.0/ch24.html" class="whitebut ">Chapter 24. Working with the Shell</a>

This section gives insight into the most important commands of your SuSE Linux system. 
Along with the individual commands, parameters are listed and, where appropriate, a typical sample application is introduced. 
To learn more about the various commands, it is usually possible to get additional information with the <b class="brown">man</b> program followed by the name of the command, for example, <b class="brown">man ls</b>.
In these <a href="http://www-uxsup.csx.cam.ac.uk/pub/doc/suse/suse9.0/userguide-9.0/go01.html#manpage"><i class="glossterm">manual pages</i></a>, move up and down with <b class="keycap">PgUp</b> and <b class="keycap">PgDn</b> and move between the beginning and the end of a document with <b class="keycap">Home</b> and <b class="keycap">End</b>. 
End this viewing mode by pressing <b class="keycap">Q</b>. 
Learn more about the <b class="brown">man</b> command itself with <b class="brown">man</b>.
There are many more commands than listed in this chapter. 
For information about other commands or more detailed information, we recommend the O'Reilly publication <span class="orange">Linux in a Nutshell</span>. 
In the following overview, the individual command elements are written in different typefaces.
<ul type="disc"><li>The actual command is always printed as <b class="brown">command</b>. 
Without this, nothing can function.
</li><li>Options without which the respective program cannot function are printed in <tt class="green">italics</tt>.
</li><li>Further details, like file names, which must be passed to a command for correct functioning, are written in the <span class="texttt">Courier</span> font.
</li><li>Specifications or parameters that are not required are placed in <tt class="green">[brackets]</tt>.
</li></ul>
Adjust possible specifications to your needs. 
It makes no sense to write <b class="brown">ls file(s)</b>, if no file named <tt class="green">file(s)</tt> actually exists. 
You can usually combine several parameters, for example, by writing <b class="brown">ls -la</b> instead of <b class="brown">ls -l -a</b>.

<h2>File Commands</h2><h2>File Administration Commands</h2>
<dl>
<dt><span class="brown"><b class="brown">ls</b> <tt class="green">[option(s)]</tt> <tt class="green">[file(s)]</tt></span> If you run <b class="brown">ls</b> without any additional parameters, the program will list the contents of the current directory in short form.
<dl>
<dt><span class="brown">-l</span> detailed list

<dt><span class="brown">-a</span> displays hidden files
</dd></dl>

<dt><span class="brown"><b class="brown">cp</b> <tt class="green">[option(s)]</tt> <tt class="green">sourcefile targetfile</tt></span> Copies <tt class="green">sourcefile</tt> to <tt class="green">targetfile</tt>.
<dl>
<dt><span class="brown">-i</span> Waits for confirmation, if necessary, before an existing <tt class="green">targetfile</tt> is overwritten

<dt><span class="brown">-r</span> Copies recursively (includes subdirectories)
</dd></dl>

<dt><span class="brown"><b class="brown">mv</b> <tt class="green">[option(s)]</tt> <tt class="green">sourcefile targetfile</tt></span> Copies <tt class="green">sourcefile</tt> to <tt class="green">targetfile</tt> then deletes the original <tt class="green">sourcefile</tt>.
<dl>
<dt><span class="brown">-b</span> Creates a backup copy of the <tt class="green">sourcefile</tt> before moving

<dt><span class="brown">-i</span> Waits for confirmation, if necessary, before an existing <span class="texttt">targetfile</span> is overwritten
</dd></dl>

<dt><span class="brown"><b class="brown">rm</b> <tt class="green">[option(s)]</tt> <tt class="green">file(s)</tt></span> Removes the specified files from the file system. 
Directories are not removed by <b class="brown">rm</b> unless the option <tt class="green">-r</tt> is used.
<dl>
<dt><span class="brown">-r</span> Deletes any existing subdirectories

<dt><span class="brown">-i</span> Waits for confirmation before deleting each file.
</dd></dl>

<dt><span class="brown"><b class="brown">ln</b> <tt class="green">[option(s)]</tt> <tt class="green">sourcefile</tt> <tt class="green">targetfile</tt></span> Creates an internal <a href="http://www-uxsup.csx.cam.ac.uk/pub/doc/suse/suse9.0/userguide-9.0/go01.html#link"><i class="glossterm">link</i></a> from the <tt class="green">sourcefile</tt> to the <tt class="green">targetfile</tt>, under a different name. 
Normally, such a link points directly to the <tt class="green">sourcefile</tt> on one and the same file system. 
However, if <b class="brown">ln</b> is executed with the <tt class="green">-s</tt> option, it creates a symbolic link that only points to the directory where the <tt class="green">sourcefile</tt> is located, thus enabling linking across file systems.
<dl>
<dt><span class="brown">-s</span> Creates a symbolic link
</dd></dl>

<dt><span class="brown"><b class="brown">cd</b> <tt class="green">[options(s)]</tt> <tt class="green">[directory]</tt></span> Changes the current directory. 
<b class="brown">cd</b> without any parameters changes to the user's home directory.

<dt><span class="brown"><b class="brown">mkdir</b> <tt class="green">[option(s)]</tt> <tt class="green">directoryname</tt></span> Creates a new directory.

<dt><span class="brown"><b class="brown">rmdir</b> <tt class="green">[option(s)]</tt> <tt class="green">directoryname</tt></span> Deletes the specified directory, provided it is already empty.

<dt><span class="brown"><b class="brown">chown</b> <tt class="green">[option(s)] username.group</tt> <tt class="green">file(s)</tt></span> Transfers the ownership of a file to the user with the specified user name.
<dl>
<dt><span class="brown">-R</span> Changes files and directories in all subdirectories.
</dd></dl>

<dt><span class="brown"><b class="brown">chgrp</b> <tt class="green">[option(s)] groupname</tt> <tt class="green">file(s)</tt></span> Transfers the group ownership of a given <tt class="green">file</tt> to the group with the specified group name. 
The file owner can only change group ownership if a member of both the existing and the new group.

<dt><span class="brown"><b class="brown">chmod</b> <tt class="green">[options]</tt> <tt class="green">mode</tt> <tt class="green">file(s)</tt></span> Changes the access permissions.
The <tt class="green">mode</tt> parameter has three parts: <tt class="green">group</tt>, <tt class="green">access</tt>, and <tt class="green">access type</tt>. 
<tt class="green">group</tt> accepts the following characters:
<dl>
<dt><span class="brown">u</span> user

<dt><span class="brown">g</span> group

<dt><span class="brown">o</span> others
</dd></dl>
For <tt class="green">access</tt>, access is granted by the <tt class="green">+</tt> symbol and denied by the <tt class="green">-</tt> symbol.
The <tt class="green">access type</tt> is controlled by the following options:
<dl>
<dt><span class="brown">r</span> read

<dt><span class="brown">w</span> write

<dt><span class="brown">x</span> eXecute &#8212; executing files or changing to the directory.

<dt><span class="brown">s</span> Set uid bit &#8212; the application or program is started as if it were started by the owner of the file.
</dd></dl>

<dt><span class="brown"><b class="brown">gzip</b> <tt class="green">[parameters]</tt> <tt class="green">file(s)</tt></span> This program compresses the contents of files, using complex mathematical algorithms. 
Files compressed in this way are given the extension <tt class="green">.gz</tt> and need to be uncompressed before they can be used. 
 To compress several files or even entire directories, use the <b class="brown">tar</b> command.
<dl>
<dt><span class="brown">-d</span> decompresses the packed gzip files so they return to their original size and can be processed normally (like the command <b class="brown">gunzip</b>).
</dd></dl>

<dt><span class="brown"><b class="brown">tar</b> <tt class="green">options</tt> <tt class="green">archive</tt> <tt class="green">file(s)</tt></span> The <b class="brown">tar</b> puts one file or (usually) several files into an archive. 
Compression is optional.
<b class="brown">tar</b> is a quite complex command with a number of options available. 
The most frequently used options are:
<dl>
<dt><span class="brown">-f</span> Writes the output to a file and not to the screen as is usually the case

<dt><span class="brown">-c</span> Creates a new tar archive

<dt><span class="brown">-r</span> Adds files to an existing archive

<dt><span class="brown">-t</span> Outputs the contents of an archive

<dt><span class="brown">-u</span> Adds files, but only if they are newer than the files already contained in the archive

<dt><span class="brown">-x</span> Unpacks files from an archive (<i class="wordasword">extraction</i>)

<dt><span class="brown">-z</span> Packs the resulting archive with <b class="brown">gzip</b>

<dt><span class="brown">-j</span> Compresses the resulting archive with <b class="brown">bzip2</b>

<dt><span class="brown">-v</span> Lists files processed
</dd></dl>
The archive files created by <b class="brown">tar</b> end with <tt class="green">.tar</tt>. 
If the tar archive was also compressed using <b class="brown">gzip</b>, the ending is <tt class="green">.tgz</tt> or <tt class="green">.tar.gz</tt>. 
If it was compressed using <b class="brown">bzip2</b>, <tt class="green">.tar.bz2</tt>.
Application examples can be found in Section <a href="http://www-uxsup.csx.cam.ac.uk/pub/doc/suse/suse9.0/userguide-9.0/ch24s02.html#sec:bash.tar" title="Archives and Data Compression">&#8220;Archives and Data Compression&#8221;</a>.

<dt><span class="brown"><b class="brown">locate</b> <tt class="green">pattern(s)</tt></span> The <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">locate</span></span> command can find in which directory a specified file is located. 
If desired, use <a href="http://www-uxsup.csx.cam.ac.uk/pub/doc/suse/suse9.0/userguide-9.0/go01.html#wildcard"><i class="glossterm">wild cards</i></a> to specify file names. 
The program is very speedy, as it uses a database specifically created for the purpose (rather than searching through the entire file system). 
This very fact, however, also results in a major drawback: <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">locate</span></span> is unable to find any files created after the latest update of its database.
The database can be generated by <tt class="systemitem">root</tt> with <b class="brown">updatedb</b>.

<dt><span class="brown"><b class="brown">updatedb</b> <tt class="green">[options(s)]</tt></span> This command performs an update of the database used by <b class="brown">locate</b>. 
To include files in all existing directories, run the program as <tt class="systemitem">root</tt>. 
It also makes sense to place it in the background by appending an ampersand (<tt class="systemitem">&amp;</tt>), so you can immediately continue working on the same command line (<b class="brown">updatedb &amp;</b>).

<dt><span class="brown"><b class="brown">find</b> <tt class="green">[option(s)]</tt></span> The <b class="brown">find</b> command allows you to search for a file in a given directory. 
The first argument specifies the directory in which to start the search. 
The option <b class="brown">-name</b> must be followed by a search string, which may also include <a href="http://www-uxsup.csx.cam.ac.uk/pub/doc/suse/suse9.0/userguide-9.0/go01.html#wildcard"><i class="glossterm">wild cards</i></a>. 
Unlike <b class="brown">locate</b>, which uses a database, <b class="brown">find</b> scans the actual directory.
</dd></dl>
<h2>Commands to Access File Contents Commands</h2>
<dl>
<dt><span class="brown"><b class="brown">cat</b> <tt class="green">[option(s)]</tt> <tt class="green">file(s)</tt></span> The <b class="brown">cat</b> command displays the contents of a file, printing the entire contents to the screen without interruption.
<dl>
<dt><span class="brown">-n</span> Numbers the output on the left margin
</dd></dl>

<dt><span class="brown"><b class="brown">less</b> <tt class="green">[option(s)]</tt> <tt class="green">file(s)</tt></span> This command can be used to browse the contents of the specified file. 
Scroll half a screen page up or down with <b class="keycap">PgUp</b> and <b class="keycap">PgDn</b> or a full screen page down with <b class="keycap">Space</b>. 
Jump to the beginning or end of a file using <b class="keycap">Home</b> and <b class="keycap">End</b>. 
Press <b class="keycap">Q</b> to exit the program.

<dt><span class="brown"><b class="brown">grep</b> <tt class="green">[option(s)]</tt> <tt class="green">searchstring</tt> <tt class="green">filenames</tt></span> The <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">grep</span></span> command finds a specific <tt class="green">searchstring</tt> in the specified <tt class="green">file(s)</tt>. 
If the search string is found, the command displays the line in which the <tt class="green">searchstring</tt> was found along with the file name.
<dl>
<dt><span class="brown">-i</span> Ignores case

<dt><span class="brown">-l</span> Only displays the names of the respective files, but not the text lines

<dt><span class="brown">-n</span> Additionally displays the numbers of the lines in which it found a hit

<dt><span class="brown">-l</span> Only lists the files in which <span class="orange">searchstring</span> does <span class="textbf">not</span> occur
</dd></dl>

<dt><span class="brown"><b class="brown">diff</b> <tt class="green">[option(s)]</tt> <tt class="green">file1 file2</tt></span> The <b class="brown">diff</b> command compares the contents of any two files. 
The output produced by the program lists all lines that do not match.
This is frequently used by programmers who need only send their program alterations and not the entire source code.
<dl>
<dt><span class="brown">-q</span> Only reports <span class="emphasis"><em>whether</em></span> the two given files differ
</dd></dl>
</dd></dl>
<h2>File Systems Commands</h2>
<dl>
<dt><span class="brown"><b class="brown">mount</b> <tt class="green">[option(s)] [&lt;device&gt;]</tt> <tt class="green">mountpoint</tt></span> This command can be used to mount any data media, such as hard disks, CD-ROM drives, and other drives, to a directory of the Linux file system.
<dl>
<dt><span class="brown">-r</span> mount read-only

<dt><span class="brown">-t filesystem</span> Specifies the file system. 
The most common are <tt class="green">ext2</tt> for Linux hard disks, <tt class="green">msdos</tt> for MS-DOS media, <tt class="green">vfat</tt> for the Windows file system, and <tt class="green">iso9660</tt> for CDs.
</dd></dl>
For hard disks not defined in the file <tt class="green">/etc/fstab</tt>, the device type must also be specified. 
In this case, only <tt class="systemitem">root</tt> can mount. 
If the file system should also be mounted by other users, enter the option <tt class="green">user</tt> in the appropriate line in the <tt class="green">/etc/fstab</tt> file (separated by commas) and save this change. 
Further information is available in <span class="citerefentry"><span class="refentrytitle">mount</span></span>.

<dt><span class="brown"><b class="brown">umount</b> <tt class="green">[option(s)]</tt> <tt class="green">mountpoint</tt></span> This command unmounts a mounted drive from the file system. 
To prevent data loss, run this command before taking a removable data medium from its drive. 
Normally, only <tt class="systemitem">root</tt> is allowed to run the commands <b class="brown">mount</b> and <b class="brown">umount</b>. 
To enable other users to run these commands, edit the <tt class="green">/etc/fstab</tt> file to specify the option <tt class="green">user</tt> for the respective drive.
</dd></dl>


<h2>System Commands</h2><h2>System Information Commands</h2>
<dl>
<dt><span class="brown"><b class="brown">df</b> <tt class="green">[option(s)]</tt> <tt class="green">[directory]</tt></span> The <b class="brown">df</b> (disk free) command, when used without any options, displays information about the total disk space, the disk space currently in use, and the free space on all the mounted drives. 
If a directory is specified, the information is limited to the drive on which that directory is located.
<dl>
<dt><span class="brown">-H</span> shows the number of occupied blocks in gigabytes, megabytes, or kilobytes &#8212; in human-readable format

<dt><span class="brown">-t</span> Type of file system (ext2, nfs, etc.)
</dd></dl>

<dt><span class="brown"><b class="brown">du</b> <tt class="green">[option(s)]</tt> <tt class="green">[path]</tt></span> This command, when executed without any parameters, shows the total disk space occupied by files and subdirectories in the current directory.
<dl>
<dt><span class="brown">-a</span> Displays the size of each individual file

<dt><span class="brown">-h</span> Output in human-readable form

<dt><span class="brown">-s</span> Displays only the calculated total size
</dd></dl>

<dt><span class="brown"><b class="brown">free</b> <tt class="green">[option(s)]</tt></span> The command <b class="brown">free</b> displays information about RAM and swap space usage, showing the total and the used amount in both categories.
<dl>
<dt><span class="brown">-b</span> Output in bytes

<dt><span class="brown">-k</span> Output in kilobytes

<dt><span class="brown">-m</span> Output in megabytes
</dd></dl>

<dt><span class="brown"><b class="brown">date</b> <tt class="green">[option(s)]</tt></span> This simple program displays the current system time. 
If run as <tt class="systemitem">root</tt>, it can also be used to change the system time. 
Details about the program are available in <span class="citerefentry"><span class="refentrytitle">date</span></span>.
</dd></dl>
<h2>Processes Commands</h2>
<dl>
<dt><span class="brown"><b class="brown">top</b> <tt class="green">[options(s)]</tt></span> <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">top</span></span> provides a quick overview of the currently running <a href="http://www-uxsup.csx.cam.ac.uk/pub/doc/suse/suse9.0/userguide-9.0/go01.html#process"><i class="glossterm">processes</i></a>. 
Press <b class="keycap">H</b> to access a page that briefly explains the main options to customize the program.

<dt><span class="brown"><b class="brown">ps</b> <tt class="green">[option(s)] [process ID]</tt></span> If run without any options, this command displays a table of all <i class="wordasword">your own</i> programs or processes &#8212; those you started. 
The options for this command are <span class="textbf">not</span> preceded by hyphen.
<dl>
<dt><span class="brown">aux</span> Displays a detailed list of all processes, independent of the owner.
</dd></dl>

<dt><span class="brown"><b class="brown">kill</b> <tt class="green">[option(s)]</tt> <tt class="green">process ID</tt></span> Unfortunately, sometimes a program cannot be terminated in the normal way. 
However, in most cases, you should still be able to stop such a runaway program by executing the <b class="brown">kill</b> command, specifying the respective process ID (see <b class="brown">top</b> and <b class="brown">ps</b>).
<b class="brown">kill</b> sends a <i class="wordasword">TERM</i> signal that instructs the program to shut itself down. 
If this does not help, the following parameter can be used:
<dl>
<dt><span class="brown">-9</span> Sends a <i class="wordasword">KILL</i> signal instead of a <i class="wordasword">TERM</i> signal, with which the process really is <i class="wordasword">annihilated</i> by the operating system. 
This brings the specific processes to an end in almost all cases.
</dd></dl>

<dt><span class="brown"><b class="brown">killall</b> <tt class="green">[option(s)] processname</tt></span> This command is similar to <b class="brown">kill</b>, but uses the process name (instead of the process ID) as an argument, causing all processes with that name to be killed.
</dd></dl>
<h2>Network Commands</h2>
<dl>
<dt><span class="brown"><b class="brown">ping</b> <tt class="green">[option(s)]</tt> <tt class="green">host name|IP address</tt></span> The <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">ping</span></span> command is the standard tool for testing the basic functionality of TCP/IP networks. 
It sends a small data packet to the destination host, requesting an immediate reply. 
If this works, <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">ping</span></span> displays a message to that effect, which indicates that the network link is basically functioning.
<dl>
<dt><span class="brown">-c</span> <tt class="green">number</tt> Determines the total number of packages to send and ends after they have been dispatched. 
By default, there is no limitation set.

<dt><span class="brown">-f</span> <i class="wordasword">flood ping</i>: sends as many data packages as possible. 
A popular means, reserved to <tt class="systemitem">root</tt>, to test networks.

<dt><span class="brown">-i</span> <tt class="green">value</tt> Specifies the interval between two data packages in seconds. 
Default: one second
</dd></dl>

<dt><span class="brown"><b class="brown">nslookup</b></span> The Domain Name System resolves domain names to IP addresses. 
With this tool, send queries to information servers (DNS servers).

<dt><span class="brown"><b class="brown">telnet</b> <tt class="green">[option(s)] host name or IP address</tt></span> Telnet is actually an Internet protocol that enables you to work on remote hosts across a network. 
<span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">telnet</span></span> is also the name of a Linux program that uses this protocol to enable operations on remote computers. 

<h3>Warning</h3>Do not use telnet over a network on which third parties can <i class="wordasword">eavesdrop.</i> Particularly on the Internet, use encrypted transfer methods, such as <b class="brown">ssh</b>, to avoid the risk of malicious misuse of a password (see the man page for <b class="brown">ssh</b>).

</dd></dl>
<h2>Miscellaneous Commands</h2>
<dl>
<dt><span class="brown"><b class="brown">passwd</b> <tt class="green">[option(s)] [username]</tt></span> Users may change their own passwords at any time using this command. 
Furthermore, the administrator <tt class="systemitem">root</tt> can use the command to change the password of any user on the system.

<dt><span class="brown"><b class="brown">su</b> <tt class="green">[option(s)]</tt> <tt class="green">[username]</tt></span> The <b class="brown">su</b> command makes it possible to log in under a different user name from a running session. 
When using the command without specifying a user name, you will be prompted for the <tt class="systemitem">root</tt> password. 
Specify a user name and the corresponding password to use the environment of the respective user. 
The password is not required from <a href="http://www-uxsup.csx.cam.ac.uk/pub/doc/suse/suse9.0/userguide-9.0/go01.html#root"><i class="glossterm"><tt class="systemitem">root</tt></i></a>, as <tt class="systemitem">root</tt> is authorized to assume the identity of any user.

<dt><span class="brown"><b class="brown">halt</b> <tt class="green">[option(s)]</tt></span> To avoid loss of data, you should always use this program to shut down your system.

<dt><span class="brown"><b class="brown">reboot</b> <tt class="green">[option(s)]</tt></span> Does the same as <b class="brown">halt</b> with the difference that the system performs an immediate reboot.

<dt><span class="brown"><b class="brown">clear</b></span> This command cleans up the visible area of the console. 
It has no options.
</dd></dl>

<h2>Ubuntu vs Fedora</h2>

Ubuntu 和 Fedora 都是最流行的 Linux 发行版之一，在两者之间做出选择实非易事。

在这篇文章里，我会对比一下 Ubuntu 和 Fedora 的不同特点，帮助你进行决策。

请注意，这篇文章主要是从桌面版的角度进行对比的。

Fedora 或者 Ubuntu 针对容器的特殊版本不会被考虑在内。

Ubuntu vs Fedora: 哪一个更好？

不同 Linux 发行版之间的区别主要体现在以下几个方面：

◈基础发行版（Debian、红帽、Arch，或者是从头做起）

◈安装方式

◈支持的桌面环境

◈软件包管理、软件支持和更新

◈硬件支持

◈开发团队（由企业支持，还是由业余爱好者创建）

◈发布周期

◈社区和线上支持

下面我们来看一下 Ubuntu 和 Fedora 之间的相似之处和不同之处。

掌握了这些信息之后，也许就更容易在两者之间做出选择了。
安装方式

Ubuntu 的 Ubiquity 安装器是最好用的安装器之一。

我认为这是让 Ubuntu 如此流行的重要原因之一，因为在 2004 年 Ubuntu 刚刚诞生的时候，安装 Linux 还是一个很庞大的工程。

Ubuntu 安装器可以让你在大约 10 分钟左右完成安装。

大多数情况下，它还可以识别出机器里安装的 Windows 系统，并且只需要几下点击就可以实现 Ubuntu 和 Windows 的双系统启动。

锦上添花的是，在安装 Ubuntu 的过程中你还可以进行系统更新，或者是安装第三方编译码器。

<img class="lazy" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/W9DqKgFsc68kThgIF4b5pq9WhBribLIthXbem58BMia3PjK5U6ick6M0pEDeibvOHxLYcJAlH6RW1wZ7VHfsPtJ0Zg/640">
Ubuntu Installer

Fedora 使用的是 Anaconda 安装器，拥有简单易用的界面，同样简化了安装过程。

<img class="lazy" data-src="https://mmbiz.qpic.cn/mmbiz_png/W9DqKgFsc68kThgIF4b5pq9WhBribLIth6p2BUtjqPQx5lF7cK5OuA7LssRI5EhibHH2rxyZkE8sTQ8lRPZvyEJQ/640">

Fedora Installer | Image Credit Fedora Magazine

Fodora 还提供了一个可以在 Windows 操作系统上下载并创建 Fedora live USB 的写入工具。

不过我在大约两年前尝试使用它的时候并不成功，最后使用了一个常规的创建 live USB 的软件。

根据我的经验，安装 Ubuntu 要比安装 Fedora 容易一些。

不过这并不是说安装 Fedora 有多困难，只是 Ubuntu 更简单而已。
桌面环境

Ubuntu 和 Fedora 默认都使用 GNOME 桌面环境。

<img class="lazy" data-src="https://mmbiz.qpic.cn/mmbiz_png/W9DqKgFsc68kThgIF4b5pq9WhBribLIthFh2duDC9jibEoaKxIdatSKBFzpAEjjzqbQPhZnMkKbM6TCGC6yCByJQ/640">

GNOME Desktop in Fedora

Fedora 使用的是原装的 GNOME 桌面，而 Ubuntu 则在此基础上做了个性化调整，让它看起来就像 Ubuntu 之前使用的 Unity 桌面环境。

<img class="lazy" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/W9DqKgFsc68kThgIF4b5pq9WhBribLIthnLkicPViazT63KwCZ3r1cgic2IOibMYvu2BUGUzQNxED0FUFWq4lksDzJQ/640">

GNOME desktop customized by Ubuntu

除了 GNOME，Ubuntu 和 Fedora 都提供了一些其它桌面环境的版本。

Ubuntu 有 Kubuntu、Xubuntu、Lubuntu 等版本，分别提供不同的桌面环境。

虽然它们都是 Ubuntu 的官方版本，但是却不是由 Canonical 的 Ubuntu 团队直接开发的，而是由另外的团队开发。

Fedora 通过 Fedora Spins 的方式提供了一些不同桌面环境的版本。

和 Kubuntu、Lubuntu 等版本不同的是，这些版本并非由独立团队开发，而是由 Fedora 核心团队开发的。

软件包管理和可用软件数量

Ubuntu 使用 APT 软件包管理器提供软件并进行管理（包括应用程序、库，以及其它所需编解码器），而 Fedora 使用 DNF 软件包管理器。
Ubuntu 拥有庞大的软件仓库，能够让你轻松安装数以千计的程序，包括 FOSS（LCTT 译注：

Free and Open-Source Software 的缩写，自由开源软件）和非 FOSS 的软件。

Fedora 则只专注于提供开源软件。

虽然这一点在最近的版本里有所转变，但是 Fedora 的软件仓库在规模上仍然比 Ubuntu 的要逊色一些。

一些第三方软件开发者为 Linux 提供像 .exe 文件一样可以点击安装的软件包。

在 Ubuntu 里这些软件包是 .deb 格式的，在 Fedora 里是 .rpm 格式的。

大多数软件供应商都为 Linux 用户提供 DEB 和 RPM 文件，但是我也经历过供应商只提供 DEB 文件的情况。

比如说 SEO 工具 Screaming Frog 就只提供 DEB 软件包。

反过来，一个软件只有 RPM 格式但是没有 DEB 格式这种情况就极其罕见了。
硬件支持

一般来说，Linux 在 WiFi 适配器和显卡的兼容性上容易出现问题，Ubuntu 和 Fedora 都受此影响。

以 Nvidia 为例，它的开源驱动程序 Nouveau 经常会引发系统启动时假死机之类的问题。

在 Ubuntu 上你可以轻松安装专有驱动程序作为补充。

在很多情况下，这样可以获得对硬件更好的支持。

<img class="lazy" data-src="https://mmbiz.qpic.cn/mmbiz_png/W9DqKgFsc68kThgIF4b5pq9WhBribLIthqJmD1tE9fWuO3OTtCrsm1eOA4D5aFwyWWmgaLRHJtqs1ROVguK5OcQ/640">

Installing proprietary driver is easier in Ubuntu

Fedora 则坚持使用开源软件，所以在 Fedora 上安装专有驱动程序就比较困难了。
线上支持和用户群

Ubuntu 和 Fedora 都通过社区论坛提供了很好的线上支持。
Ubuntu 主要有两个论坛：

UbuntuForums 和 Ask Ubuntu。

Fedora 主要的论坛则是 Ask Fedora。

就用户群体而言，Fedora 有着庞大的用户数量。

不过 Ubuntu 更为流行，用户数量甚至更为庞大。

Ubuntu 的流行催生了很多专注于 Ubuntu 的网站和博客。

所以相比 Fedora，你可以得到更多关于 Ubuntu 的故障排除指导和学习材料。
发布周期

Fedora 每六个月发布一个新版本，每个版本有九个月的支持周期。

也就是说，你必须在六个月到九个月之间进行一次系统升级。

进行 Fedora 版本升级并不是一件困难的事情，但是需要良好的网络连接。

并非所有人都喜欢每九个月进行一次 1.5 GB 的版本升级。
Ubuntu 有两种版本：

常规发布版本和长期支持（LTS）发布版本。

常规版本和 Fedora 比较类似，每隔六个月发布一次，有九个月的支持周期。

而长期支持发布版本则每两年发布一次，有五年的支持周期。

常规发布版本探索新功能特性和新的软件版本，而长期支持发布版本则支持旧版本软件。

对于不喜欢经常改变、青睐稳定性的人来说，这是一个很好的选择。
强大的基础发行版

Ubuntu 是基于 Debian 发行版的。

Debian 是最大的社区项目之一，并且也是自由软件世界里最受尊敬的项目之一。

Fedora 则是红帽公司的一个社区项目。

红帽公司是一个专注于 Linux 发行版的公司。

Fedora 充当了一个“试验田”的角色（用技术术语来说叫做“上游”），用来在红帽企业级 Linux 发布新功能之前对这些新功能进行试验。
在背后支持的企业

Ubuntu 和 Fedora 都有来自母公司的支持。
Ubuntu 源自 Canonical 公司，而 Fedora 源自红帽公司（现在是 IBM 的一部分）。

背后企业的支持非常重要，因为可以确保 Linux 发行版良好的维护。

有一些发行版是由一群独立的业余爱好者们共同创建的，但是在工作压力之下经常会结束。

你也许见过一些还算比较流行的发行版项目仅仅是因为这个原因而终止了。

很多这样的发行版由于开发者没有足够的业余时间可以投入到项目上而不得不终止，比如 Antergos 和 Korora。

Ubuntu 和 Fedora 的背后都有基于 Linux 的企业的支持，这让它们比其它独立的发行版更胜一筹。
Ubuntu vs Fedora：服务端

到目前为止，我们在 Ubuntu 和 Fedora 之间的对比主要都集中在桌面端。

不过如果不考虑一下服务端的话，对 Linux 的讨论就不能算是完整的。

<img class="lazy" data-src="https://mmbiz.qpic.cn/mmbiz_png/W9DqKgFsc68kThgIF4b5pq9WhBribLIthCB7gKg0g865BaTUTfWBgUh6opNvq0uLyPU85YrGWgQ7L4gjiakNwm5w/640">
Ubuntu Server

Ubuntu 不仅在桌面端很流行，在服务端也有很强的存在感。

如果你能够在桌面端熟练使用 Ubuntu，那么也不会对 Ubuntu 服务器版本感到陌生。

我就是从使用 Ubuntu 桌面端开始的，现在我的网站都运行在 Ubuntu 服务器上。

Fedora 同样有服务端版本，并且也有人在使用。

但是大多数系统管理者不会喜欢一个每九个月就需要重启升级的服务器。

学习 Fedora 可以更好地帮助你使用红帽企业级 Linux（RHEL）。

RHEL 是一个付费产品，你需要购买订阅才可以使用。

如果你希望在服务器上运行一个和 Fedora 或者红帽类似的操作系统，我推荐使用 CentOS。

CentOS 同样是红帽公司附属的一个社区项目，但是专注于服务端。
结论

你可以看到，Ubuntu 和 Fedora 有很多相似之处。

不过就可用软件数量、驱动安装和线上支持来说，Ubuntu 的确更有优势。

Ubuntu 也因此成为了一个更好的选择，尤其是对于没有经验的 Linux 新手而言。

如果你想要熟悉红帽的话，Fedora 是一个很好的开始。

如果你对 Linux 有一定经验，或者是只想要使用开源软件，Fedora 就是一个很棒的选择。

最终还是需要你自己来决定是使用 Fedora 还是 Ubuntu。

我会建议为两个发行版分别创建一个 live USB，并且在虚拟机上体验一下。

<h2>Linux 命令行下搜索工具, CLI search</h2>
grep
使用 grep 的优势是它几乎可以在任意类 Unix 系统上使用。

常用 grep 命令的几种方式。
在 py 文件中找到一个关键字并且输出行号，可以这样操作：
$ grep -rins --include \*.py import .

回忆起部分命令。
通过管道（|）使用 grep 命令来搜索历史记录命令：
$ history | grep "python"

可以找到曾经运行过的所有包含 python 关键字的命令。

$ history | grep “python”
284  python test.py
...    #省略其它结果

$ !284
$ python test.py

ack
一个类似于 grep 并且为程序员优化过的工具
它在默认情况下以递归方式搜索，但是会忽略版本控制工具目录，比如 .git 目录。
并且它自带很多很实用的工具，可以大大提高我们搜索效率。

我们同样再拿出上面的例子来举例，下面我们使用 ack 命令来实现仅在 py 文件中搜索 import 关键字的方法：

# ack 命令实现方式
$ ack import --py

# grep 命令实现方式
$ grep -rins --include \*.py import .
上面是仅在 py 文件进行搜索，那假如我们想搜索除 py 文件类型以外的所有其他类型的文件，要怎么操作？

对于每个文件类型，都有一个对应的 no 标识，来排除对这个文件类型搜索。
比如，想搜索 py 文件的话就使用 --py 选项，而想排除 py 文件的话就使用 --nopy 选项。

$ ack import --nopy
当然文件类型有非常之多，我们还可以通过修改 ~/.ackrc 文件来扩展文件类型。
假如我们现在想搜索 .conf 文件，默认情况下 ack 不支持这种文件：

$ ack hello --conf
Unknown option: conf
ack: Invalid option on command line
要注册 .conf 文件类型，我们可以将以下内容添加到 ~/.ackrc 文件中，之后我们就可以正常搜索 conf 文件了。

--type-set=conf=.conf
配置文件修改之后，我们可以使用 --help-types 选项来确认自定义类型是否已经成功加上。

ack 命令从 .ackrc 文件中获取配置信息，但如何你想脱离 .ackrc 文件来运行 ack 命令的话，可以使用 -noenv 选项。

The Silver Searcher
该搜索器是另一个类似于 ack 的 grep 替代品，其更快的性能让大家很推崇。
它有个非常实用的特点，那就是它会忽略在项目工程中的 .gitignore 文件所指定的文件。
所以如果你想排除搜索一些文件，就可以将那些文件写在 .gitignore 文件里。

ag 命令
在 Ubuntu 系统上可以使用以下命令来安装 ag 命令：

$ apt-get install silversearcher-ag
使用 ag 命令来搜索 py 文件里包含关键字 import 的内容：

$ ag import --py
ag 命令十分强大，限于篇幅本文只介绍它最基本的用法，改天有时间的话再补充一下它其它非常强大的功能用法。

sift
sift 是使用 Golang 编写的 grep 替代品，这意味着它可以在 Linux，Windows，OS X 和其他系统上使用。
它的速度快得离谱，而且有一些很酷的用例来代替 grep + awk 组合来提取数据。

我们再使用 sift 命令来搜索所有 py 文件里包含 import 关键字的内容：

# 只搜索 py 文件：
sift --ext py import

# 排除 py 文件
sift --exclude-ext py import
RipGrep

RipGrep 与 Silver Searcher 类似，可以在 Mac、Linux 和 Windows 上运行。
它的 readme 文件声称，RipGrep 通常比其他任何搜索工具都快，它推崇 Rust 的正则表达式引擎，并像Silver Searcher一样使用 .gitignore 文件来排除一些文件或目录。

RipGrep 通常简称为 rg ，我们再使用 rg 命令来搜索所有 py 文件里包含 import 关键字的内容：
rg --type=py import

<h2>Command Line Tools to Find Files in Linux</h2>
1. Find Command
It supports multiple options to locate files using attributes such as permissions, users, groups, file type, date, size and other possible criteria.

2. Locate Command
instead of searching through the file system when a user initiates a file search operation, locate queries a database which contains bits and parts of files and their corresponding paths on the file system.
This database can be prepared and updated using the updatedb command. 
Note that locate will not report files created after the most recent update of the relevant database.

3. Grep Command
Although grep command is not a tool for directly searching files, you can employ it to locate files. 
For example, if you are looking for a README.md file which contains the phrase “An assortment”, which you suspect should be somewhere in your home directory, possibly in ~/bin.

$ grep -Ri ~/bin -e "An assortment" 
OR
$ grep -Ri ~/bin/ -e "An assortment" | cut -d: -f1
Where the grep flag:

-R – means search the specified directory recursively
-i – means ignore case distinctions
-e – specifies the phrase to be used as a pattern for searching
-d – specifies the delimter
-f – sets the field to be printed

4. Which Command
For example:
$ which find
$ which locate
$ which which

5. Whereis Command
$ whereis find
$ whereis locate
$ whereis which
$ whereis whereis

<h2>Linux notes.txt</h2>
=============
the right-ctrl key
remember to use the right-ctrl key in virtual box to switch out to windows

=============
Linux text editor:
gedit, pluma, vim, gvim, sublime text

=============
install packages from software manager or Synaptic manager 

=============
# to install vim
sudo apt-get install vim

#edit new file test
# https://www.radford.edu/~mhtay/CPSC120/VIM_Editor_Commands.htm
# VIM Editor Commands
https://www.fprintf.net/vimCheatSheet.html


vim test
hit i to insert
hit esc to exit insert mode


<h2>Working with the Shell, Introduction to Bash</h2>

In the KDE taskbar, there is an icon depicting a monitor with a seashell. 
When you click this icon with the mouse, a console window opens in which to enter commands. 
The console normally runs Bash (Bourne again shell), a program developed as part of the GNU  project. 
It is, by far, the most widely used derivative of the Bourne shell (sh). 
Once you have opened the shell, see the prompt on the first line. 
The prompt usually consists of the user name, host name, and current path, but it can be customized. 
When the cursor is behind this prompt, you can send commands directly to your computer system: <b class="brown">tux $ &gt;</b>. 

<h2>Bash: Commands</h2>

A command consists of several elements. 
The first element is always the actual command, followed by parameters or options. 
Commands are executed when you press <b class="orange">Return</b>. 
Before doing so, easily edit the command line, add options, or correct typing errors. 
One of the most frequently used commands is <b class="brown">ls</b>, which can be used with or without arguments. 
Entering the plain <b class="brown">ls</b> command in the console shows the contents of the current directory. 

Options are prefixed with a hyphen. 
The command <b class="brown">ls -l</b>, for instance, shows the contents of the same directory in full detail. 
Next to each file name, see the date when the file was created, the file size in bytes, and further details, which are covered later. 
One very important option that exists for many commands is the <b class="brown">--help</b> option. 
By entering <b class="brown">ls --help</b>, display all the options for the <b class="brown">ls</b> command.
Also use the <b class="brown">ls</b>  command to view the contents of other directories. 
To do so, the directory must be specified as a parameter. 
For example, to see the contents of <tt class="filename">Desktop</tt>, enter <b class="brown">ls -l Desktop</b>.

<h2>Bash: Files and Directories</h2>

To use the shell efficiently, it is really useful to have some knowledge about the file and directory structures of a Linux system. 
You can think of directories as electronic folders where files, programs, and subdirectories are stored. 
The top level directory in the hierarchy is the root directory, referred to as <tt class="filename">/</tt>. 
This is the place from which all other directories can be accessed.
The <tt class="filename">/home</tt> directory contains the directories in which the individual users can store their personal files. 
Figure <a href="http://www-uxsup.csx.cam.ac.uk/pub/doc/suse/suse9.0/userguide-9.0/ch24s02.html#fig:verz.baum" title="Figure 24.1. 
Excerpt from a Standard Directory Tree">24.1: &#8220;Excerpt from a Standard Directory Tree&#8221;</a> shows the standard directory tree in Linux, with the home directories of the example users <tt class="green">xyz</tt>, <tt class="green">linux</tt>, and <tt class="green">tux</tt>. 
The directory tree of a Linux system has a functional structure that follows the <i class="green">File System Standard</i>. 
The following list provides a brief description of the standard directories in Linux. 

<b>Figure 24.1. Excerpt from a Standard Directory Tree</b>

<img class="lazy" data-src="http://www-uxsup.csx.cam.ac.uk/pub/doc/suse/suse9.0/userguide-9.0/verzeichnisse_baum.png" width="NaN" alt="Excerpt from a Standard Directory Tree">

<dl><dt><span class="term"><tt class="filename">/</tt></span></dt><dd>root directory, starting point of the directory tree.
</dd><dt><span class="term"><tt class="filename">/home</tt></span></dt><dd>(private) directories of users.
</dd><dt><span class="term"><tt class="filename">/dev</tt></span></dt><dd>device files that represent hardware components
</dd><dt><span class="term"><tt class="filename">/etc</tt></span></dt><dd>important files for system configuration.
</dd><dt><span class="term"><tt class="filename">/etc/init.d</tt></span></dt><dd>boot scripts
</dd><dt><span class="term"><tt class="filename">/usr/bin</tt></span></dt><dd>generally accessible programs.
</dd><dt><span class="term"><tt class="filename">/bin</tt></span></dt><dd>programs needed early in the boot process.
</dd><dt><span class="term"><tt class="filename">/usr/sbin</tt></span></dt><dd>programs reserved for the system administrator.
</dd><dt><span class="term"><tt class="filename">/sbin</tt></span></dt><dd>programs reserved for the system administrator and needed for booting.
</dd><dt><span class="term"><tt class="filename">/usr/include</tt></span></dt><dd>header files for the C compiler
</dd><dt><span class="term"><tt class="filename">/usr/include/g++</tt></span></dt><dd>header files for the C++ compiler.
</dd><dt><span class="term"><tt class="filename">/usr/share/doc</tt></span></dt><dd>various documentation files.
</dd><dt><span class="term"><tt class="filename">/usr/share/man</tt></span></dt><dd>system manual pages (man pages).
</dd><dt><span class="term"><tt class="filename">/usr/src</tt></span></dt><dd>source code of system software
</dd><dt><span class="term"><tt class="filename">/usr/src/linux</tt></span></dt><dd>kernel source code.
</dd><dt><span class="term"><tt class="filename">/tmp</tt>, <tt class="filename">/var/tmp</tt></span></dt><dd>temporary files.
</dd><dt><span class="term"><tt class="filename">/usr</tt></span></dt><dd>all application programs
</dd><dt><span class="term"><tt class="filename">/var</tt></span></dt><dd>configuration files (e.g., those linked from <tt class="filename">/usr</tt>)
</dd><dt><span class="term"><tt class="filename">/var/log</tt></span></dt><dd>system log files
</dd><dt><span class="term"><tt class="filename">/var/adm</tt></span></dt><dd>system administration data
</dd><dt><span class="term"><tt class="filename">/lib</tt></span></dt><dd>shared libraries (for dynamically linked programs)
</dd><dt><span class="term"><tt class="filename">/proc</tt></span></dt><dd>process file system.
</dd><dt><span class="term"><tt class="filename">/usr/local</tt></span></dt><dd>local, distribution-independent extensions.
</dd><dt><span class="term"><tt class="filename">/opt</tt></span></dt><dd>optional software, larger add-on program packages (such as KDE, GNOME, Netscape).
</dd></dl>

<h2>Bash: Functions</h2>

There are two important functions of the shell that can make your work a lot easier:
<ul type="disc"><li>The history function &#8212; To repeat a command that has been entered before, press <b class="orange">UpArrow</b> until the previous command appears at the prompt. 
Move forward through the list of previously entered commands by pressing <b class="orange">&#8595;</b>. 
To edit the command line, just move the cursor to the desired position using the arrow keys and start typing. 
Use <b class="orange">Ctrl</b> + <b class="orange">R</b> to search in the history.
</li><li>The expansion function &#8212; Expand a file name to its full length after typing its first letters until it can be uniquely identified. 
To do so, type the first letters then hit <b class="orange">Tab</b>. 
If there are several file names starting with the same letters, obtain a list of them by hitting <b class="orange">Tab</b> twice.
</li></ul>
<h4>First Example: Managing Files</h4>

Now that you know what a command looks like, which directories exist in SuSE Linux, and how to speed up things when using Bash, put this knowledge into practice with a small exercise.
<ol type="1"><li>Open a console from the KDE desktop by clicking the shell icon.
</li><li>Enter the <b class="brown">ls</b> command to see the contents of your home directory.
</li><li>Use the command <b class="brown">mkdir</b> (which stands for <i class="green">make directory</i>)  to create a new subdirectory called <tt class="filename">test</tt> by entering <b class="brown">mkdir test</b>.
</li><li>Now launch the <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">KEdit</span></span> editor by pressing <b class="orange">Alt</b> + <b class="orange">F2</b> and entering <i class="green">kedit</i> in the input field. 
Type a few letters in the editor then save the file as <tt class="filename">Testfile</tt> in your home directory. 
Linux distinguishes between uppercase and lowercase. 
For this example, use an uppercase T.
</li><li>View the contents of your home directory again. 
Instead of typing <b class="brown">ls</b> again, just press <b class="orange">UpArrow</b> twice and the <b class="brown">ls</b> command should reappear at the prompt. 
To execute the command, hit <b class="orange">Return</b>. 
The newly created directory <tt class="filename">test</tt> should appear in blue letters and <tt class="filename">Testfile</tt> in black. 
This is how directories and files can be distinguished in a console.
</li><li>Move <tt class="filename">Testfile</tt> into the subdirectory <tt class="filename">test</tt> with the command <b class="brown">mv</b>. 
To speed this up, use the expansion function: just enter <b class="brown">mv T</b> and press <b class="orange">Tab</b>. 
As long as there is no other file beginning with this letter in the directory, the shell expands the file name and adds the string <i class="green">estfile</i>. 
Otherwise, add a letter or two yourself and test <b class="orange">Tab</b> each time to see whether the shell can now expand the name. 
Finally, type a space then <tt class="filename">test</tt> after the expanded file name and press <b class="orange">Return</b> to execute the command.
</li><li>At this point, <tt class="filename">Testfile</tt> should no longer be in the directory. 
Check this by entering <b class="brown">ls</b> again.
</li><li>To see whether the file has been successfully moved, change into the directory <tt class="filename">test</tt> with the command <b class="brown">cd test</b>. 
Now enter <b class="brown">ls</b> again. 
You should see <tt class="filename">Testfile</tt> in the listing. 
Change back to your home directory at any point by entering only <b class="brown">cd</b> (which stands for <i class="green">change directory</i>).
</li><li>To make a copy of a file, use <b class="brown">cp</b>. 
For instance, enter <b class="brown">cp Testfile Testbackup</b> to copy <tt class="filename">Testfile</tt> to <tt class="filename">Testbackup</tt>. 
Once again, the command <b class="brown">ls</b> can be used to see whether both files are in the directory.
</li></ol>

<h2>Bash: Specifying Paths</h2>

When working with files or directories, it is important specify the correct path. 
However, you do not need to enter the entire (absolute) path from the root directory to the respective file. 
Rather, you can start from the current directory. 
Address your home directory directly with <tt class="filename">~</tt>. 
Accordingly, there are two ways to list the file <tt class="filename">Testfile</tt> in the directory <tt class="filename">test</tt>: by entering the relative path with <b class="brown">ls test/*</b> or by specifying the absolute path with <b class="brown">ls ~/test/*</b>. 

To list the contents of home directories of other users, enter <b class="brown">ls ~username</b>. 
In the above-mentioned directory tree, one of the sample users is <tt class="green">tux</tt>. 
Thus, the command <b class="brown">ls ~tux</b> would list the contents of the home directory of <tt class="green">tux</tt>.
Refer to the current directory with a dot. 
The next higher level in the tree is represented by two dots. 
By entering <b class="brown">ls ..</b>, see the contents of the parent directory of the current directory. 
The command <b class="brown">ls ../..</b> shows the contents of the directory two levels higher in the hierarchy.
<h4>Second Example: Working with Paths</h4>

Here is another example to illustrate how to move around in the directories of your SuSE Linux system.
<ul type="disc"><li>Change into your home directory with the command <b class="brown">cd</b>. 
Then create a directory in it with the name <tt class="filename">test2</tt> by entering <b class="brown">mkdir test2</b>.
</li><li>Change into the new directory with <b class="brown">cd test2</b> and create a subdirectory in it with the name <tt class="filename">subdirectory</tt>. 
To change into it, use the expansion function: enter <b class="brown">cd su</b> then press <b class="orange">Tab</b>. 
The shell will expand the rest of the directory name.
</li><li>Now try to move the previously created file <tt class="filename">Testbackup</tt> into the current directory (<tt class="filename">subdirectory</tt>) without changing the directory again. 
To achieve this, specify the relative path to that file: <b class="brown">mv ../../test/Testbackup .</b>. 
The dot at the end of this command is required to tell the shell that the current directory is the destination to which to move the file. 
<b class="brown">../../</b>, in this example, refers to your home directory.
</li></ul>

<h2>Bash: Wild Cards</h2>

Another convenience offered by the shell is wild cards. 
There are four different types of these in Bash:
<dl><dt><span class="term">?</span></dt><dd>Matches exactly one arbitrary character
</dd><dt><span class="term">*</span></dt><dd>Matches an arbitrary number of characters
</dd><dt><span class="term">[set]</span></dt><dd>Matches one of the characters from the group specified inside the square brackets, which is represented here by the string <i class="green">set</i>
</dd><dt><span class="term">[!set]</span></dt><dd>Matches one character other than those identified by <i class="green">set</i>
</dd></dl>
Assuming that your <tt class="filename">test</tt> directory contains the files <tt class="filename">Testfile</tt>, <tt class="filename">Testfile1</tt>, <tt class="filename">Testfile2</tt>, and <tt class="filename">datafile</tt>, the command <b class="brown">ls Testfile?</b> will list the files <tt class="filename">Testfile1</tt> and <tt class="filename">Testfile2</tt>. 
With <b class="brown">ls Test*</b>, the list will also include <tt class="filename">Testfile</tt>. 

The command <b class="brown">ls *fil*</b> shows <span class="emphasis"><em>all</em></span> the sample files. 
Finally, you can use the <tt class="green">set</tt> wild card to address all sample files whose last character is a number: <b class="brown">ls Testfile[1-9]</b>.
Among the four types of wild cards, the most inclusive one is the asterisk. 
It could be used to copy all files contained in one directory to another one or to delete all files with one command. 
The command <b class="brown">rm *fil*</b>, for instance, would delete all files in the current directory whose name includes the string <i class="green">fil</i>.

<h2>Bash: More or Less</h2>

Linux includes two small programs for viewing text files directly in the shell. 
Rather than starting an editor to read a file like <tt class="filename">Readme.txt</tt>, simply enter <b class="brown">less Readme.txt</b> to display the text in the console window. 
Use <b class="orange">Space</b> to scroll down one page. 
Use <b class="orange">PgUp</b> and <b class="orange">PgDown</b> to move forward or backward in the text. 
To exit <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">less</span></span>, press <b class="orange">Q</b>.
The program <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">less</span></span> got its name from the the precept that <i class="green">less is more</i> and can also be used to view the output of commands in a convenient way. 
To see how this works, read Section <a href="http://www-uxsup.csx.cam.ac.uk/pub/doc/suse/suse9.0/userguide-9.0/ch24s02.html#sec:shell.pipes" title="Pipes">&#8220;Pipes&#8221;</a>.

Instead of <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">less</span></span>, you can also use the older program <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">more</span></span>. 
However, it is less convenient because it does not allow you to scroll backwards.

<h2>Bash: Pipes</h2>

Normally, the standard output in the shell is your screen or the console window, and the standard input is the keyboard. 
To forward the output of a command to an application such as <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">less</span></span>, use a <i class="green">pipeline</i>. 

To view the files in the <tt class="filename">test</tt> directory, enter the command <b class="brown">ls test | less</b>. 
The contents of the <tt class="filename">test</tt> directory will be displayed with <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">less</span></span>. 
This only makes sense if the normal output with <b class="brown">ls</b> would be too lengthy. 
For instance, if you view the contents of the <tt class="filename">dev</tt> directory with <b class="brown">ls /dev</b>, you will only see a small portion in the window. 
View the entire list with <b class="brown">ls /dev | less</b>. 

It is also possible to save the output of commands to a file. 
For example, <b class="brown">ls test &gt; Content</b> generates a new file called <tt class="filename">Content</tt> that contains a list of the files and directories in <tt class="filename">test</tt>. 
View the file with <b class="brown">less Content</b>. 

Similarly, you can also use a file as the input for a comand. 
For example, sort the text lines in <tt class="filename">Testfile</tt> with <b class="brown">sort &lt; Testfile</b>. 
The output of the command <b class="brown">sort</b> is sent to the screen. 
The text is sorted by the first letters of the individual lines. 

If you need a new file containing the sorted list, pipe the output of the command <b class="brown">sort</b> to a file. 
To test this, create an unsorted name list in an editor and save it under <tt class="filename">list</tt> in the <tt class="filename">test</tt> directory. 
Then change into <tt class="filename">test</tt> and enter the command <b class="brown">sort &lt; unsortedlist &gt; sortedlist</b>. 
Finally, view the sorted list with <b class="brown">less</b>.
Just like the standard output, the standard error output is sent to the console as well. 
However, to redirect the standard error output to a file named <tt class="filename">errors</tt>, append <b class="brown">2&gt; errors</b> to the corresponding command. 
On the other hand, both standard output and standard error are saved to one file named <tt class="filename">alloutput</tt> if you append <b class="brown">&gt;&amp; alloutput</b>. 
Finally, to append the output of a command to an already existing file, the command must be followed by <b class="brown">&gt;&gt;</b> instead of a single <b class="brown">&gt;</b>.

<h2>Bash: Archives and Data Compression</h2>

Now that you have already created a number of files and directories, consider the subject of archives and data compression. 
Suppose you want to have the entire <tt class="filename">test</tt> directory packed in one file that you can save on a floppy disk as a backup copy or send by e-mail. 
To do so, use the command <b class="brown">tar</b> (for <i class="green">tape archiver</i>). 
With <b class="brown">tar --help</b>, view all the options for the <b class="brown">tar</b> command. 
The most important of these options are explained here:
<dl><dt><span class="term">-c</span></dt><dd>(for create) Create a new archive.
</dd><dt><span class="term">-t</span></dt><dd>(for table) Display the contents of an archive.
</dd><dt><span class="term">-x</span></dt><dd>(for extract) Unpack the archive.
</dd><dt><span class="term">-v</span></dt><dd>(for verbose) Show all files on screen while creating the archive.
</dd><dt><span class="term">-f</span></dt><dd>(for file) Choose a file name for the archive file. 
When creating an archive, this option must always be given as the last one.
</dd></dl>
To pack the <tt class="filename">test</tt> directory with all its files and subdirectories into an archive named <tt class="filename">testarchive.tar</tt>, use the options <b class="brown">-c</b> and <b class="brown">-f</b>. 
For the testing purposes of this example, also add <b class="brown">-v</b> to follow the progress of the archiving, although this option is not mandatory. 
After using <b class="brown">cd</b> to change to your home directory where the <tt class="filename">test</tt> directory is located, enter <b class="brown">tar -cvf testarchive.tar test</b>. 
After that, view the contents of the archive file with <b class="brown">tar -tf testarchive.tar</b>. 
The <tt class="filename">test</tt> directory with all its files and directories has remained unchanged on your hard disk. 
To unpack the archive, enter <b class="brown">tar -xvf testarchive.tar</b>, but do not try this yet.
For file compression, the obvious choice on Linux is the popular <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">gzip</span></span> program. 
Just enter <b class="brown">gzip testarchive.tar</b>. 
With <b class="brown">ls</b>, now see that the file <tt class="filename">testarchive.tar</tt> is no longer there and that the file <tt class="filename">testarchive.tar.gz</tt> has been created instead. 
This file is much smaller and therefore much better suited for transfer via e-mail or storage on a floppy.
Now, unpack this file in the <tt class="filename">test2</tt> directory created earlier. 
To do so, enter <b class="brown">cp testarchive.tar.gz test2</b> to copy the file to that directory. 
Change to the directory with <b class="brown">cd test2</b>. 
A compressed archive with the <tt class="green">.tar.gz</tt> extension can be <i class="green">unzipped</i>  with the <b class="brown">gunzip</b> command. 
Enter <b class="brown">gunzip testarchive.tar.gz</b>  , which results in the file <tt class="filename">testarchive.tar</tt>, which then needs to be extracted or <i class="green">untarred</i> with <b class="brown">tar -xvf testarchive.tar</b>. 
You can also <i class="green">unzip</i> and extract a compressed archive in one step by adding the <tt class="green">-z</tt> option. 
The complete command would be <b class="brown">tar -xvzf testarchive.tar.gz</b>. 
With <b class="brown">ls</b>, you can see that a new <tt class="filename">test</tt> directory has been created with the same contents as your <tt class="filename">test</tt> directory in your home directory.

<h2>Bash: mtools</h2>

<b class="brown">mtools</b> are a set of commands for working with MS-DOS file systems. 
The commands included in <b class="brown">mtools</b> allow you to address the first floppy drive as <tt class="green">a:</tt>, just like under MS-DOS, and the commands are like MS-DOS commands except they are prefixed with an <tt class="green">m</tt>:
<dl><dt><span class="term">
     <b class="brown">mdir a:</b>
    </span></dt><dd>displays the contents of the floppy disk in drive <tt class="filename">a:</tt>
</dd><dt><span class="term">
     <b class="brown">mcopy Testfile a:</b>
    </span></dt><dd>copies the file <tt class="filename">Testfile</tt> to the floppy disk.
</dd><dt><span class="term">
     <b class="brown">mdel a:Testfile</b>
    </span></dt><dd>deletes <tt class="filename">Testfile</tt> in <tt class="filename">a:</tt>
</dd><dt><span class="term">
     <b class="brown">mformat a:</b>
    </span></dt><dd>formats the floppy disk in MS-DOS format (using the <b class="brown">fdformat</b> command).
</dd><dt><span class="term">
     <b class="brown">mcd a:</b>
    </span></dt><dd>makes <tt class="filename">a:</tt> your current directory
</dd><dt><span class="term">
     <b class="brown">mmd a:test</b>
    </span></dt><dd>creates the subdirectory <tt class="filename">test</tt> on the floppy disk
</dd><dt><span class="term">
     <b class="brown">mrd a:test</b>
    </span></dt><dd>deletes the subdirectory <tt class="filename">test</tt> from the floppy disk
</dd></dl>


<h2>Linux copy and paste</h2>
Use Ctrl+Insert or Ctrl+Shift+C for copying and
Shift+Insert or Ctrl+Shift+V for pasting text in the terminal in Ubuntu.

Right click and selecting the copy/paste option from the context menu is also an option.
I thought of elaborating on this topic specially when there is no single universal way of copy and paste in the Linux terminal.

<a href="https://linuxhandbook.com/linux-shortcuts/" class="whitebut ">Linux Terminal Shortcuts</a>


<h2>30 Bash Script Examples</h2>
<div id="bashexampletoc" class="toc"><a href="#bashexampletopic-0" target="_self">Create and Execute First BASH Program:</a><br><a href="#bashexampletopic-1" target="_self">Use of echo command:</a><br><a href="#bashexampletopic-2" target="_self">Use of comment:</a><br><a href="#bashexampletopic-3" target="_self">Use of Multi-line comment:</a><br><a href="#bashexampletopic-4" target="_self">Using While Loop:</a><br><a href="#bashexampletopic-5" target="_self">Using For Loop:</a><br><a href="#bashexampletopic-6" target="_self">Get User Input:</a><br><a href="#bashexampletopic-7" target="_self">Using if statement:</a><br><a href="#bashexampletopic-8" target="_self">Using if statement with AND logic:</a><br><a href="#bashexampletopic-9" target="_self">Using if statement with OR logic:</a><br><a href="#bashexampletopic-10" target="_self">Using else if statement:</a><br><a href="#bashexampletopic-11" target="_self">Using Case Statement:</a><br><a href="#bashexampletopic-12" target="_self">Get Arguments from Command Line:</a><br><a href="#bashexampletopic-13" target="_self">Get arguments from command line with names:</a><br><a href="#bashexampletopic-14" target="_self">Combine String variables:</a><br><a href="#bashexampletopic-15" target="_self">Get substring of String:</a><br><a href="#bashexampletopic-16" target="_self">Add Two Numbers:</a><br><a href="#bashexampletopic-17" target="_self">Create Function:</a><br><a href="#bashexampletopic-18" target="_self">Create function with Parameters:</a><br><a href="#bashexampletopic-19" target="_self">Pass Return Value from Function:</a><br><a href="#bashexampletopic-20" target="_self">Make Directory:</a><br><a href="#bashexampletopic-21" target="_self">Make directory by checking existence:</a><br><a href="#bashexampletopic-22" target="_self">Read a File:</a><br><a href="#bashexampletopic-23" target="_self">Delete a File:</a><br><a href="#bashexampletopic-24" target="_self">Append to File:</a><br><a href="#bashexampletopic-25" target="_self">Test if File Exist:</a><br><a href="#bashexampletopic-26" target="_self">Send Email:</a><br><a href="#bashexampletopic-27" target="_self">Get Parse Current Date:</a><br><a href="#bashexampletopic-28" target="_self">Wait Command:</a><br><a href="#bashexampletopic-29" target="_self">Sleep Command:</a><br></div></center>
<h3 id="bashexampletopic-0">Create and Execute First BASH Program:</h3>
You can run bash script from the terminal or by executing any bash file. 
Run the following command from the terminal to execute a very simple bash statement. 
The output of the command will be ‘<strong>Hello World</strong>’.
$ echo "Hello World"
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h.png">
Open any editor to create a bash file. 
Here, <strong>nano</strong> editor is used to create the file and filename is set as ‘<strong>First.sh’</strong>
$ nano First.sh
Add the following bash script to the file and save the file.
#!/bin/bash
echo "Hello World"
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h1.png">
You can run bash file by two ways. 
One way is by using bash command and another is by setting execute permission to bash file and run the file. 
Both ways are shown here.
$ bash First.sh
<strong>Or,</strong>
$ chmod a+x First.sh
$ ./First.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h2.png">
<h3 id="bashexampletopic-1">Use of echo command:</h3>
You can use echo command with various options. 
Some useful options are mentioned in the following example. 
When you use ‘<strong>echo</strong>’ command without any option then a newline is added by default. 
<strong>‘-n’</strong> option is used to print any text without new line and <strong>‘-e’</strong> option is used to remove backslash characters from the output. 
Create a new bash file with a name, ‘<strong>echo_example.sh</strong>’ and add the following script.
#!/bin/bash
echo "Printing text with newline"
echo -n "Printing text without newline"
echo -e "\nRemoving \t backslash \t characters\n"
Run the file with bash command.
$ bash echo_example.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h3.png">
<h3 id="bashexampletopic-2">Use of comment:</h3>
<strong>‘#’</strong> symbol is used to add single line comment in bash script. 
Create a new file named ‘<strong>comment_example.sh’</strong> and add the following script with single line comment.
#!/bin/bash
# Add two numeric value
((sum=25+35))
#Print the result
echo $sum
Run the file with bash command.
$ bash comment_example.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h4.png">
<h3 id="bashexampletopic-3">Use of Multi-line comment:</h3>
You can use multi line comment in bash in various ways. 
A simple way is shown in the following example. 
Create a new bash named, <strong>‘multiline-comment.sh’</strong> and add the following script. 
Here, <strong>‘:’</strong> and <strong>“ </strong><strong>’ </strong><strong>”</strong> symbols are used to add multiline comment in bash script. 
This following script will calculate the square of 5.
#!/bin/bash
: '
The following script calculates the square value of the number, 5.
'
((area=5*5))
echo $area
Run the file with bash command.
$ bash multiline-comment.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h5.png">
You can check the following link to know more about the use of bash comment.
<a href="https://linuxhint.com/bash_comments/">https://linuxhint.com/bash_comments/</a>
<h3 id="bashexampletopic-4">Using While Loop:</h3>
Create a bash file with the name, <strong>‘while_example.sh’,</strong> to know the use of <strong>while</strong> loop. 
In the example, <strong>while</strong> loop will iterate for <strong>5</strong> times. 
The value of <strong>count</strong> variable will increment by <strong>1</strong> in each step. 
When the value of <strong>count</strong> variable will 5 then the <strong>while</strong> loop will terminate.
#!/bin/bash
valid=true
count=1
while [ $valid ]
do
echo $count
if [ $count -eq 5 ];
then
break
fi
((count++))
done
Run the file with bash command.
$ bash while_example.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h6.png">
You can check the following link to know more about the use of while loop.
<a href="https://linuxhint.com/bash-while-loop-examples/">https://linuxhint.com/bash-while-loop-examples/</a>
<h3 id="bashexampletopic-5">Using For Loop:</h3>
The basic <strong>for</strong> loop declaration is shown in the following example. 
Create a file named ‘<strong>for_example.sh</strong>’ and add the following script using <strong>for</strong> loop. 
Here, <strong>for</strong> loop will iterate for <strong>10</strong> times and print all values of the variable, <strong>counter</strong> in single line.
#!/bin/bash
for (( counter=10; counter&gt;0; counter-- ))
do
echo -n "$counter "
done
printf "\n"
Run the file with bash command.
$ bash for_example.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h7.png">
You can use for loop for different purposes and ways in your bash script. 
You can check the following link to know more about the use of for loop.
<a href="https://linuxhint.com/bash-for-loop-examples/">https://linuxhint.com/bash-for-loop-examples/</a>
<h3 id="bashexampletopic-6">Get User Input:</h3>
‘<strong>read</strong>’ command is used to take input from user in bash. 
Create a file named ‘<strong>user_input.sh</strong>’ and add the following script for taking input from the user. 
Here, one string value will be taken from the user and display the value by combining other string value.
#!/bin/bash
echo "Enter Your Name"
read name
echo "Welcome $name to LinuxHint"
Run the file with bash command.
$ bash user_input.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h8.png">
You can check the following link to know more about the use of user input.
<a href="https://linuxhint.com/bash-script-user-input/">https://linuxhint.com/bash-script-user-input/</a>
<h3 id="bashexampletopic-7">Using if statement:</h3>
You can use if condition with single or multiple conditions. 
Starting and ending block of this statement is define by <strong>‘if’</strong> and <strong>‘fi’</strong>. 
Create a file named ‘<strong>simple_if.sh</strong>’ with the following script to know the use <strong>if</strong> statement in bash. 
Here, <strong>10</strong> is assigned to the variable, <strong>n</strong>. 
if the value of <strong>$n</strong> is less than 10 then the output will be “<strong>It is a one digit number</strong>”, otherwise the output will be “<strong>It is a two digit number</strong>”. 
For comparison, <strong>‘-lt’</strong> is used here. 
For comparison, you can also use <strong>‘-eq’</strong> for <strong>equality</strong>, <strong>‘-ne’</strong> for <strong>not equality</strong> and <strong>‘-gt’</strong> for <strong>greater than</strong> in bash script.
#!/bin/bash
n=10
if [ $n -lt 10 ];
then
echo "It is a one digit number"
else
echo "It is a two digit number"
fi
Run the file with bash command.
$ bash simple_if.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h9.png">
<h3 id="bashexampletopic-8">Using if statement with AND logic:</h3>
Different types of logical conditions can be used in if statement with two or more conditions. 
How you can define multiple conditions in if statement using <strong>AND</strong> logic is shown in the following example. 
<strong>‘&amp;&amp;’ </strong>is used to apply <strong>AND</strong> logic of <strong>if</strong> statement. 
Create a file named <strong>‘if_with_AND.sh’</strong> to check the following code. 
Here, the value of <strong>username</strong> and <strong>password </strong>variables will be taken from the user and compared with ‘<strong>admin</strong>’ and ‘<strong>secret</strong>’. 
If both values match then the output will be “<strong>valid user</strong>”, otherwise the output will be “<strong>invalid user</strong>”.
!/bin/bash
echo "Enter username"
read username
echo "Enter password"
read password

if [ ( $username == "admin" &amp;&amp; $password == "secret" ) ]]; then
echo "valid user"
else
echo "invalid user"
fi
Run the file with bash command.
$ bash if_with_AND.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h10.png">
<h3 id="bashexampletopic-9">Using if statement with OR logic:</h3>
‘<strong>||</strong>’ is used to define <strong>OR</strong> logic in <strong>if</strong> condition. 
Create a file named <strong>‘if_with_OR.sh’ </strong>with the following code to check the use of <strong>OR</strong> logic of <strong>if</strong> statement. 
Here, the value of <strong>n</strong> will be taken from the user. 
If the value is equal to <strong>15</strong> or <strong>45 </strong>then the output will be “<strong>You won the game</strong>”, otherwise the output will be “<strong>You lost the game</strong>”.
#!/bin/bash
echo "Enter any number"
read n

if [ ( $n -eq 15 || $n  -eq 45 ) ]]
then
echo "You won the game"
else
echo "You lost the game"
fi
Run the file with bash command.
$ bash if_with_OR.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h11.png">
<h3 id="bashexampletopic-10">Using else if statement:</h3>
The use of <strong>else if</strong> condition is little different in bash than other programming language. 
‘<strong>elif</strong>’ is used to define <strong>else if</strong> condition in bash. 
Create a file named, ‘<strong>elseif_example.sh</strong>’ and add the following script to check how <strong>else if</strong> is defined in bash script.
#!/bin/bash
echo "Enter your lucky number"
read n

if [ $n -eq 101 ];
then
echo "You got 1st prize"
elif [ $n -eq 510 ];
then
echo "You got 2nd prize"
elif [ $n -eq 999 ];
then
echo "You got 3rd prize"

else
echo "Sorry, try for the next time"
fi
Run the file with bash command.
$ bash elseif_example.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h12.png">
<h3 id="bashexampletopic-11">Using Case Statement:</h3>
<strong>Case</strong> statement is used as the alternative of <strong>if-elseif-else</strong> statement. 
The starting and ending block of this statement is defined by ‘<strong>case</strong>’ and ‘<strong>esac</strong>’. 
Create a new file named, ‘<strong>case_example.sh</strong>’ and add the following script. 
The output of the following script will be same to the previous <strong>else if </strong>example.
#!/bin/bash
echo "Enter your lucky number"
read n
case $n in
101)
echo echo "You got 1st prize" ;;
510)
echo "You got 2nd prize" ;;
999)
echo "You got 3rd prize" ;;
*)
echo "Sorry, try for the next time" ;;
esac
Run the file with bash command.
$ bash case_example.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h13.png">
<h3 id="bashexampletopic-12">Get Arguments from Command Line:</h3>
Bash script can read input from command line argument like other programming language. 
For example, <strong>$1</strong> and <strong>$2</strong> variable are used to read first and second command line arguments. 
Create a file named “<strong>command_line.sh</strong>” and add the following script. 
Two argument values read by the following script and prints the total number of arguments and the argument values as output.
#!/bin/bash
echo "Total arguments : $#"
echo "1st Argument = $1"
echo "2nd argument = $2"
Run the file with bash command.
$ bash command_line.sh Linux Hint
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h14.png">
You can check the following link to know more about the use of command line argument.
<a href="https://linuxhint.com/command_line_arguments_bash_script/">https://linuxhint.com/command_line_arguments_bash_script/</a>
<h3 id="bashexampletopic-13">Get arguments from command line with names:</h3>
How you can read command line arguments with names is shown in the following script. 
Create a file named, ‘<strong>command_line_names.sh’</strong> and add the following code. 
Here, two arguments, <strong>X </strong>and <strong>Y</strong> are read by this script and print the sum of X and Y.
#!/bin/bash
for arg in "<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="aa8eea">[email&nbsp;protected]</a>"
do
index=$(echo $arg | cut -f1 -d=)
val=$(echo $arg | cut -f2 -d=)
case $index in
X) x=$val;;

Y) y=$val;;

*)
esac
done
((result=x+y))
echo "X+Y=$result"
Run the file with bash command and with two command line arguments.
$ bash command_line_names X=45 Y=30
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h15.png">
<h3 id="bashexampletopic-14">Combine String variables:</h3>
You can easily combine string variables in bash. 
Create a file named “<strong>string_combine.sh</strong>” and add the following script to check how you can combine string variables in bash by placing variables together or using <strong>‘+’</strong> operator.
#!/bin/bash

string1="Linux"
string2="Hint"
echo "$string1$string2"
string3=$string1+$string2
string3+=" is a good tutorial blog site"
echo $string3
Run the file with bash command.
$ bash string_combine.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h16.png">
<h3 id="bashexampletopic-15">Get substring of String:</h3>
Like other programming language, bash has no built-in function to cut value from any string data. 
But you can do the task of substring in another way in bash that is shown in the following script. 
To test the script, create a file named ‘<strong>substring_example.sh</strong>’ with the following code. 
Here, the value, <strong>6</strong> indicates the starting point from where the substring will start and <strong>5</strong> indicates the length of the substring.
#!/bin/bash
Str="Learn Linux from LinuxHint"
subStr=${Str:6:5}
echo $subStr
Run the file with bash command.
$ bash substring_example.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h17.png">
<h3 id="bashexampletopic-16">Add Two Numbers:</h3>
You can do the arithmetical operations in bash in different ways. 
How you can add two integer numbers in bash using double brackets is shown in the following script. 
Create a file named ‘<strong>add_numbers.sh</strong>’ with the following code. 
Two integer values will be taken from the user and printed the result of addition.
#!/bin/bash
echo "Enter first number"
read x
echo "Enter second number"
read y
(( sum=x+y ))
echo "The result of addition=$sum"
Run the file with bash command.
$ bash add_numbers.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h18.png">
You can check the following link to know more about bash arithmetic.
<a href="https://linuxhint.com/bash_arithmetic_operations/">https://linuxhint.com/bash_arithmetic_operations/</a>
<h3 id="bashexampletopic-17">Create Function:</h3>
How you can create a simple function and call the function is shown in the following script. 
Create a file named ‘<strong>function_example.sh</strong>’ and add the following code. 
You can call any function by name only without using any bracket in bash script.
#!/bin/bash
function F1()
{
echo 'I like bash programming'
}

F1
Run the file with bash command.
$ bash function_example.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h19.png">
<h3 id="bashexampletopic-18">Create function with Parameters:</h3>
Bash can’t declare function parameter or arguments at the time of function declaration. 
But you can use parameters in function by using other variable. 
If two values are passed at the time of function calling then $1 and $2 variable are used for reading the values. 
Create a file named ‘<strong>function|_parameter.sh</strong>’ and add the following code. 
Here, the function, ‘<strong>Rectangle_Area’</strong> will calculate the area of a rectangle based on the parameter values.
#!/bin/bash

Rectangle_Area() {
area=$(($1 * $2))
echo "Area is : $area"
}

Rectangle_Area 10 20
Run the file with bash command.
$ bash function_parameter.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h20.png">
<h3 id="bashexampletopic-19">Pass Return Value from Function:</h3>
Bash function can pass both numeric and string values. 
How you can pass a string value from the function is shown in the following example. 
Create a file named, ‘<strong>function_return.sh</strong>’ and add the following code. 
The function, <strong>greeting()</strong> returns a string value into the variable, <strong>val</strong> which prints later by combining with other string.
#!/bin/bash
function greeting() {

str="Hello, $name"
echo $str

}
echo "Enter your name"
read name

val=$(greeting)
echo "Return value of the function is $val"
Run the file with bash command.
$ bash function_return.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h21.png">
You can check the following link to know more about the use of bash function.
<a href="https://linuxhint.com/return-string-bash-functions/">https://linuxhint.com/return-string-bash-functions/</a>
<h3 id="bashexampletopic-20">Make Directory:</h3>
Bash uses ‘<strong>mkdir</strong>’ command to create a new directory. 
Create a file named ‘<strong>make_directory.sh</strong>’ and add the following code to take a new directory name from the user. 
If the directory name is not exist in the current location then it will create the directory, otherwise the program will display error.
#!/bin/bash
echo "Enter directory name"
read newdir
`mkdir $newdir`
Run the file with bash command.
$ bash make_directory.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h22.png">
<h3 id="bashexampletopic-21">Make directory by checking existence:</h3>
If you want to check the existence of directory in the current location before executing the ‘<strong>mkdir</strong>’ command then you can use the following code. 
<strong>‘-d</strong>’ option is used to test a particular directory is exist or not. 
Create a file named, ‘<strong>directory_exist.sh’</strong> and add the following code to create a directory by checking existence.
#!/bin/bash
echo "Enter directory name"
read ndir
if [ -d "$ndir" ]
then
echo "Directory exist"
else
`mkdir $ndir`
echo "Directory created"
fi
Run the file with bash command.
$ bash directory_exist.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h23.png">
You can check the following link to know more about directory creation.
<a href="https://linuxhint.com/bash_mkdir_not_existent_path/">https://linuxhint.com/bash_mkdir_not_existent_path/</a>
<h3 id="bashexampletopic-22">Read a File:</h3>
You can read any file line by line in bash by using loop. 
Create a file named, ‘<strong>read_file.sh</strong>’ and add the following code to read an existing file named, ‘<strong>book.txt</strong>’.
#!/bin/bash
file='book.txt'
while read line; do
echo $line
done &lt; $file
Run the file with bash command.
$ bash read_file.sh
Run the following command to check the original content of ‘<strong>book.txt</strong>’ file.
$ cat book.txt
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h24.png">
You can check the following link to know the different ways to read file.
<a href="https://linuxhint.com/read_file_line_by_line_bash/">https://linuxhint.com/read_file_line_by_line_bash/</a>
<h3 id="bashexampletopic-23">Delete a File:</h3>
‘<strong>rm</strong>’ command is used in bash to remove any file. 
Create a file named ‘<strong>delete_file.sh</strong>’ with the following code to take the filename from the user and remove. 
Here, <strong>‘-i’</strong> option is used to get permission from the user before removing the file.
#!/bin/bash
echo "Enter filename to remove"
read fn
rm -i $fn
Run the file with bash command.
$ ls
$ bash delete_file.sh
$ ls
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h25.png">
<h3 id="bashexampletopic-24">Append to File:</h3>
New data can be added into any existing file by using <strong>‘&gt;&gt;’</strong> operator in bash. 
Create a file named <strong>‘append_file.sh</strong>’ and add the following code to add new content at the end of the file. 
Here, ‘<strong>Learning Laravel 5</strong>’ will be added at the of ‘<strong>book.txt’</strong> file after executing the script.
#!/bin/bash
echo "Before appending the file"
cat book.txt
echo "Learning Laravel 5"&gt;&gt; book.txt
echo "After appending the file"
cat book.txt
Run the file with bash command.
$ bash append_file.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h26.png">
<h3 id="bashexampletopic-25">Test if File Exist:</h3>
You can check the existence of file in bash by using <strong>‘-e’</strong> or <strong>‘-f’</strong> option. 
<strong>‘-f’</strong> option is used in the following script to test the file existence. 
Create a file named, ‘<strong>file_exist.sh</strong>’ and add the following code. 
Here, the filename will pass from the command line.
#!/bin/bash
filename=$1
if [ -f "$filename" ]; then
echo "File exists"
else
echo "File does not exist"
fi
Run the following commands to check the existence of the file. 
Here, <strong>book.txt</strong> file exists and  <strong>book2.txt</strong> is not exist in the current location.
$ ls
$ bash file_exist.sh book.txt
$ bash file_exist.sh book2.txt
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h27.png">
<h3 id="bashexampletopic-26">Send Email:</h3>
You can send email by using ‘<strong>mail</strong>’ or ‘<strong>sendmail</strong>’ command. 
Before using these commands, you have to install all necessary packages. 
Create a file named, ‘<strong>mail_example.sh</strong>’ and add the following code to send the email.
#!/bin/bash
Recipient=”admin@example.com”
Subject=”Greeting”
Message=”Welcome to our site”
`mail -s $Subject $Recipient &lt;&lt;&lt; $Message`
Run the file with bash command.
$ bash mail_example.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h28.png">
<h3 id="bashexampletopic-27">Get Parse Current Date:</h3>
You can get the current system date and time value using `<strong>date</strong>` command. 
Every part of date and time value can be parsed using ‘<strong>Y’, ‘m’, ‘d’, ‘H’, ‘M’</strong> and ‘<strong>S’</strong>. 
Create a new file named ‘<strong>date_parse.sh’</strong> and add the following code to separate day, month, year, hour, minute and second values.
#!/bin/bash
Year=`date +%Y`
Month=`date +%m`
Day=`date +%d`
Hour=`date +%H`
Minute=`date +%M`
Second=`date +%S`
echo `date`
echo "Current Date is: $Day-$Month-$Year"
echo "Current Time is: $Hour:$Minute:$Second"
Run the file with bash command.
$ bash date_parse.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h29.png">
<h3 id="bashexampletopic-28">Wait Command:</h3>
<strong>wait</strong>  is a built-in command of Linux that waits for completing any running process. 
<strong>wait</strong> command is used with a particular process id or job id. 
If no process id or job id is given with wait command then it will wait for all current child processes to complete and returns exit status. 
Create a file named ‘<strong>wait_example.sh’</strong> and add the following script.
#!/bin/bash
echo "Wait command" &amp;
process_id=$!
wait $process_id
echo "Exited with status $?"
Run the file with bash command.
$ bash wait_example.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h30.png">
You can check the following link to know more about wait command.
<blockquote class="wp-embedded-content" data-secret="ElaQZ5i8wk"><a href="https://linuxhint.com/wait_command_linux/">Wait Command in Linux</a>
</blockquote>
<iframe loading="lazy" class="wp-embedded-content" sandbox="allow-scripts" security="restricted" style="position: absolute; clip: rect(1px, 1px, 1px, 1px);" title="“Wait Command in Linux” — Linux Hint" src="about:blank" data-secret="ElaQZ5i8wk" width="600" height="338" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" data-rocket-lazyload="fitvidscompatible" data-lazy-src="https://linuxhint.com/wait_command_linux/embed/#?secret=ElaQZ5i8wk"></iframe><iframe class="wp-embedded-content" sandbox="allow-scripts" security="restricted" style="position: absolute; clip: rect(1px, 1px, 1px, 1px);" title="“Wait Command in Linux” — Linux Hint" src="https://linuxhint.com/wait_command_linux/embed/#?secret=ElaQZ5i8wk" data-secret="ElaQZ5i8wk" width="600" height="338" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe>
<h3 id="bashexampletopic-29">Sleep Command:</h3>
When you want to pause the execution of any command for specific period of time then you can use <strong>sleep</strong> command. 
You can set the delay amount by <strong>seconds (s), minutes (m), hours (h) and days (d).</strong> Create a file named <strong>‘sleep_example.sh’</strong> and add the following script. 
This script will wait for 5 seconds after running.
#!/bin/bash
echo “Wait for 5 seconds”
sleep 5
echo “Completed”
Run the file with bash command.
$ bash sleep_example.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h31.png">
You can check the following link to know more about sleep command.
<a href="https://linuxhint.com/sleep_command_linux/">https://linuxhint.com/sleep_command_linux/</a>

<h2>Bash scripting <em>cheatsheet</em></h2>
<div id="Bashcheatsheettoc" class="toc"><a href="#Bashcheatsheettopic-0" target="_self"><span class="orange">Getting started</span></a><br><a href="#Bashcheatsheettopic-1" target="_self">Introduction</a><br><a href="#Bashcheatsheettopic-2" target="_self">Variables</a><br><a href="#Bashcheatsheettopic-3" target="_self">String quotes</a><br><a href="#Bashcheatsheettopic-4" target="_self">Shell execution</a><br><a href="#Bashcheatsheettopic-5" target="_self">Conditional execution</a><br><a href="#Bashcheatsheettopic-6" target="_self">Functions</a><br><a href="#Bashcheatsheettopic-7" target="_self">Conditionals</a><br><a href="#Bashcheatsheettopic-8" target="_self">Strict mode</a><br><a href="#Bashcheatsheettopic-9" target="_self">Brace expansion</a><br><a href="#Bashcheatsheettopic-10" target="_self"><span class="orange">Parameter expansions</span></a><br><a href="#Bashcheatsheettopic-11" target="_self">Basics</a><br><a href="#Bashcheatsheettopic-12" target="_self">Substitution</a><br><a href="#Bashcheatsheettopic-13" target="_self">Comments</a><br><a href="#Bashcheatsheettopic-14" target="_self">Substrings</a><br><a href="#Bashcheatsheettopic-15" target="_self">Length</a><br><a href="#Bashcheatsheettopic-16" target="_self">Manipulation</a><br><a href="#Bashcheatsheettopic-17" target="_self">Default values</a><br><a href="#Bashcheatsheettopic-18" target="_self"><span class="orange">Loops</span></a><br><a href="#Bashcheatsheettopic-19" target="_self">Basic for loop</a><br><a href="#Bashcheatsheettopic-20" target="_self">C-like for loop</a><br><a href="#Bashcheatsheettopic-21" target="_self">Ranges</a><br><a href="#Bashcheatsheettopic-22" target="_self">Reading lines</a><br><a href="#Bashcheatsheettopic-23" target="_self">Forever</a><br><a href="#Bashcheatsheettopic-24" target="_self"><span class="orange">Functions</span></a><br><a href="#Bashcheatsheettopic-25" target="_self">Defining functions</a><br><a href="#Bashcheatsheettopic-26" target="_self">Returning values</a><br><a href="#Bashcheatsheettopic-27" target="_self">Raising errors</a><br><a href="#Bashcheatsheettopic-28" target="_self">Arguments</a><br><a href="#Bashcheatsheettopic-29" target="_self"><span class="orange">Conditionals</span></a><br><a href="#Bashcheatsheettopic-30" target="_self">Conditions</a><br><a href="#Bashcheatsheettopic-31" target="_self">File conditions</a><br><a href="#Bashcheatsheettopic-32" target="_self"><span class="orange">Arrays</span></a><br><a href="#Bashcheatsheettopic-33" target="_self">Defining arrays</a><br><a href="#Bashcheatsheettopic-34" target="_self">Working with arrays</a><br><a href="#Bashcheatsheettopic-35" target="_self">Operations</a><br><a href="#Bashcheatsheettopic-36" target="_self">Iteration</a><br><a href="#Bashcheatsheettopic-37" target="_self"><span class="orange">Dictionaries</span></a><br><a href="#Bashcheatsheettopic-38" target="_self">Defining</a><br><a href="#Bashcheatsheettopic-39" target="_self">Working with dictionaries</a><br><a href="#Bashcheatsheettopic-40" target="_self">Iteration</a><br><a href="#Bashcheatsheettopic-41" target="_self"><span class="orange">Options</span></a><br><a href="#Bashcheatsheettopic-42" target="_self">Options</a><br><a href="#Bashcheatsheettopic-43" target="_self">Glob options</a><br><a href="#Bashcheatsheettopic-44" target="_self"><span class="orange">History</span></a><br><a href="#Bashcheatsheettopic-45" target="_self">Commands</a><br><a href="#Bashcheatsheettopic-46" target="_self">Expansions</a><br><a href="#Bashcheatsheettopic-47" target="_self">Operations</a><br><a href="#Bashcheatsheettopic-48" target="_self">Slices</a><br><a href="#Bashcheatsheettopic-49" target="_self"><span class="orange">Miscellaneous</span></a><br><a href="#Bashcheatsheettopic-50" target="_self">Numeric calculations</a><br><a href="#Bashcheatsheettopic-51" target="_self">Subshells</a><br><a href="#Bashcheatsheettopic-52" target="_self">Redirection</a><br><a href="#Bashcheatsheettopic-53" target="_self">Inspecting commands</a><br><a href="#Bashcheatsheettopic-54" target="_self">Trap errors</a><br><a href="#Bashcheatsheettopic-55" target="_self">Case/switch</a><br><a href="#Bashcheatsheettopic-56" target="_self">Source relative</a><br><a href="#Bashcheatsheettopic-57" target="_self">printf</a><br><a href="#Bashcheatsheettopic-58" target="_self">Directory of script</a><br><a href="#Bashcheatsheettopic-59" target="_self">Getting options</a><br><a href="#Bashcheatsheettopic-60" target="_self">Heredoc</a><br><a href="#Bashcheatsheettopic-61" target="_self">Reading input</a><br><a href="#Bashcheatsheettopic-62" target="_self">Special variables</a><br><a href="#Bashcheatsheettopic-63" target="_self">Go to previous directory</a><br><a href="#Bashcheatsheettopic-64" target="_self">Check for command’s result</a><br><a href="#Bashcheatsheettopic-65" target="_self">Grep check</a><br></div></center>

<h3 id="Bashcheatsheettopic-0"><span class="orange">Getting started</span></h3>
<h3 id="Bashcheatsheettopic-1">Introduction</h3>
This is a quick reference to getting started with Bash scripting.
<a href="https://learnxinyminutes.com/docs/bash/">Learn bash in y minutes</a> <em>(learnxinyminutes.com)</em>
<a href="http://mywiki.wooledge.org/BashGuide">Bash Guide</a> <em>(mywiki.wooledge.org)</em>
<code>#!/usr/bin/env bash
NAME="John"
echo "Hello $NAME!"</code>

<h3 id="Bashcheatsheettopic-2">Variables</h3>
<code>NAME="John"
echo $NAME
echo "$NAME"
echo "${NAME}!"</code>

<h3 id="Bashcheatsheettopic-3">String quotes</h3>
<code>NAME="John"
echo "Hi $NAME"  #=&gt; Hi John
echo 'Hi $NAME'  #=&gt; Hi $NAME</code>

<h3 id="Bashcheatsheettopic-4">Shell execution</h3>
<code>echo "I'm in $(pwd)"
echo "I'm in `pwd`"
# Same</code>

See <a href="http://wiki.bash-hackers.org/syntax/expansion/cmdsubst">Command substitution</a>
<h3 id="Bashcheatsheettopic-5">Conditional execution</h3>
<code>git commit &amp;&amp; git push
git commit || echo "Commit failed"</code>

<h3 id="Bashcheatsheettopic-6">Functions</h3>
<code>get_name() {
  echo "John"
}

echo "You are $(get_name)"</code>

See: <a href="#functions">Functions</a>
<h3 id="Bashcheatsheettopic-7">Conditionals</h3>
<code>if [[ -z "$string" ]]; then
  echo "String is empty"
elif [[ -n "$string" ]]; then
  echo "String is not empty"
fi</code>

See: <a href="#conditionals">Conditionals</a>
<h3 id="Bashcheatsheettopic-8">Strict mode</h3>
<code>set -euo pipefail
IFS=$'\n\t'</code>

See: <a href="http://redsymbol.net/articles/unofficial-bash-strict-mode/">Unofficial bash strict mode</a>
<h3 id="Bashcheatsheettopic-9">Brace expansion</h3>
<code>echo {A,B}.js</code>

<table><thead>
<tr><th>Expression</th>
<th>Description</th></tr></thead><tbody>
<tr><td><code>{A,B}</code></td><td>Same as <code>A B</code></td></tr>
<tr><td><code>{A,B}.js</code></td><td>Same as <code>A.js B.js</code></td></tr>
<tr><td><code>{1..5}</code></td><td>Same as <code>1 2 3 4 5</code></td></tr>
</tbody></table>
See: <a href="http://wiki.bash-hackers.org/syntax/expansion/brace">Brace expansion</a>
<h3 id="Bashcheatsheettopic-10"><span class="orange">Parameter expansions</span></h3>
<h3 id="Bashcheatsheettopic-11">Basics</h3>
<code>name="John"
echo ${name}
echo ${name/J/j}    #=&gt; "john" (substitution)
echo ${name:0:2}    #=&gt; "Jo" (slicing)
echo ${name::2}     #=&gt; "Jo" (slicing)
echo ${name::-1}    #=&gt; "Joh" (slicing)
echo ${name:(-1)}   #=&gt; "n" (slicing from right)
echo ${name:(-2):1} #=&gt; "h" (slicing from right)
echo ${food:-Cake}  #=&gt; $food or "Cake"</code>

<code>length=2
echo ${name:0:length}  #=&gt; "Jo"</code>

See: <a href="http://wiki.bash-hackers.org/syntax/pe">Parameter expansion</a>
<code>STR="/path/to/foo.cpp"
echo ${STR%.cpp}    # /path/to/foo
echo ${STR%.cpp}.o  # /path/to/foo.o
echo ${STR%/*}      # /path/to

echo ${STR##*.}     # cpp (extension)
echo ${STR##*/}     # foo.cpp (basepath)

echo ${STR#*/}      # path/to/foo.cpp
echo ${STR##*/}     # foo.cpp

echo ${STR/foo/bar} # /path/to/bar.cpp</code>

<code>STR="Hello world"
echo ${STR:6:5}   # "world"
echo ${STR: -5:5}  # "world"</code>

<code>SRC="/path/to/foo.cpp"
BASE=${SRC##*/}   #=&gt; "foo.cpp" (basepath)
DIR=${SRC%$BASE}  #=&gt; "/path/to/" (dirpath)</code>

<h3 id="Bashcheatsheettopic-12">Substitution</h3>
<table>
<thead>
<tr><th>Code</th>
<th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>${FOO%suffix}</code></td><td>Remove suffix</td></tr>
<tr><td><code>${FOO#prefix}</code></td><td>Remove prefix</td></tr>
</tbody>
<tbody>
<tr><td><code>${FOO%%suffix}</code></td><td>Remove long suffix</td></tr>
<tr><td><code>${FOO##prefix}</code></td><td>Remove long prefix</td></tr>
</tbody>
<tbody>
<tr><td><code>${FOO/from/to}</code></td><td>Replace first match</td></tr>
<tr><td><code>${FOO//from/to}</code></td><td>Replace all</td></tr>
</tbody>
<tbody>
<tr><td><code>${FOO/%from/to}</code></td><td>Replace suffix</td></tr>
<tr><td><code>${FOO/#from/to}</code></td><td>Replace prefix</td></tr>
</tbody>
</table>
<h3 id="Bashcheatsheettopic-13">Comments</h3>
<code># Single line comment</code>

<code>: '
This is a
multi line
comment
'</code>

<h3 id="Bashcheatsheettopic-14">Substrings</h3>
<table>
<thead>
<tr><th>Expression</th>
<th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>${FOO:0:3}</code></td><td>Substring <em>(position, length)</em></td></tr>
<tr><td><code>${FOO:(-3):3}</code></td><td>Substring from the right</td></tr>
</tbody>
</table>
<h3 id="Bashcheatsheettopic-15">Length</h3>
<table>
<thead>
<tr><th>Expression</th>
<th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>${#FOO}</code></td><td>Length of <code>$FOO</code></td></tr>
</tbody>
</table>
<h3 id="Bashcheatsheettopic-16">Manipulation</h3>
<code>STR="HELLO WORLD!"
echo ${STR,}   #=&gt; "hELLO WORLD!" (lowercase 1st letter)
echo ${STR,,}  #=&gt; "hello world!" (all lowercase)

STR="hello world!"
echo ${STR^}   #=&gt; "Hello world!" (uppercase 1st letter)
echo ${STR^^}  #=&gt; "HELLO WORLD!" (all uppercase)</code>

<h3 id="Bashcheatsheettopic-17">Default values</h3>
<table>
<thead>
<tr><th>Expression</th>
<th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>${FOO:-val}</code></td><td><code>$FOO</code>, or <code>val</code> if unset (or null)</td></tr>
<tr><td><code>${FOO:=val}</code></td><td>Set <code>$FOO</code> to <code>val</code> if unset (or null)</td></tr>
<tr><td><code>${FOO:+val}</code></td><td><code>val</code> if <code>$FOO</code> is set (and not null)</td></tr>
<tr><td><code>${FOO:?message}</code></td><td>Show error message and exit if <code>$FOO</code> is unset (or null)</td></tr>
</tbody>
</table>
Omitting the <code>:</code> removes the (non)nullity checks, e.g. <code>${FOO-val}</code> expands to <code>val</code> if unset otherwise <code>$FOO</code>.
<h3 id="Bashcheatsheettopic-18"><span class="orange">Loops</span></h3>
<h3 id="Bashcheatsheettopic-19">Basic for loop</h3>
<code>for i in /etc/rc.*; do
  echo $i
done</code>

<h3 id="Bashcheatsheettopic-20">C-like for loop</h3>
<code>for ((i = 0 ; i &lt; 100 ; i++)); do
  echo $i
done</code>

<h3 id="Bashcheatsheettopic-21">Ranges</h3>
<code>for i in {1..5}; do
    echo "Welcome $i"
done</code>

<h4>With step size</h4>
<code>for i in {5..50..5}; do
    echo "Welcome $i"
done</code>

<h3 id="Bashcheatsheettopic-22">Reading lines</h3>
<code>cat file.txt | while read line; do
  echo $line
done</code>

<h3 id="Bashcheatsheettopic-23">Forever</h3>
<code>while true; do
  ···
done</code>

<h3 id="Bashcheatsheettopic-24"><span class="orange">Functions</span></h3>
<h3 id="Bashcheatsheettopic-25">Defining functions</h3>
<code>myfunc() {
    echo "hello $1"
}</code>

<code># Same as above (alternate syntax)
function myfunc() {
    echo "hello $1"
}</code>

<code>myfunc "John"</code>

<h3 id="Bashcheatsheettopic-26">Returning values</h3>
<code>myfunc() {
    local myresult='some value'
    echo $myresult
}</code>

<code>result="$(myfunc)"</code>

<h3 id="Bashcheatsheettopic-27">Raising errors</h3>
<code>myfunc() {
  return 1
}</code>

<code>if myfunc; then
  echo "success"
else
  echo "failure"
fi</code>

<h3 id="Bashcheatsheettopic-28">Arguments</h3>
<table>
<thead>
<tr><th>Expression</th>
<th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>$#</code></td><td>Number of arguments</td></tr>
<tr><td><code>$*</code></td><td>All positional arguments (as a single word)</td></tr>
<tr><td><code>$@</code></td><td>All positional arguments (as separate strings)</td></tr>
<tr><td><code>$1</code></td><td>First argument</td></tr>
<tr><td><code>$_</code></td><td>Last argument of the previous command</td></tr>
</tbody>
</table>
<strong>Note</strong>: <code>$@</code> and <code>$*</code> must be quoted in order to perform as described.
Otherwise, they do exactly the same thing (arguments as separate strings).
See <a href="http://wiki.bash-hackers.org/syntax/shellvars#special_parameters_and_shell_variables">Special parameters</a>.
<h3 id="Bashcheatsheettopic-29"><span class="orange">Conditionals</span></h3>
<h3 id="Bashcheatsheettopic-30">Conditions</h3>
Note that <code>[[</code> is actually a command/program that returns either <code>0</code> (true) or <code>1</code> (false). Any program that obeys the same logic (like all base utils, such as <code>grep(1)</code> or <code>ping(1)</code>) can be used as condition, see examples.
<table>
<thead>
<tr><th>Condition</th>
<th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>[[ -z STRING ]]</code></td><td>Empty string</td></tr>
<tr><td><code>[[ -n STRING ]]</code></td><td>Not empty string</td></tr>
<tr><td><code>[[ STRING == STRING ]]</code></td><td>Equal</td></tr>
<tr><td><code>[[ STRING != STRING ]]</code></td><td>Not Equal</td></tr>
</tbody>
<tbody>
<tr><td><code>[[ NUM -eq NUM ]]</code></td><td>Equal</td></tr>
<tr><td><code>[[ NUM -ne NUM ]]</code></td><td>Not equal</td></tr>
<tr><td><code>[[ NUM -lt NUM ]]</code></td><td>Less than</td></tr>
<tr><td><code>[[ NUM -le NUM ]]</code></td><td>Less than or equal</td></tr>
<tr><td><code>[[ NUM -gt NUM ]]</code></td><td>Greater than</td></tr>
<tr><td><code>[[ NUM -ge NUM ]]</code></td><td>Greater than or equal</td></tr>
</tbody>
<tbody>
<tr><td><code>[[ STRING =~ STRING ]]</code></td><td>Regexp</td></tr>
</tbody>
<tbody>
<tr><td><code>(( NUM &lt; NUM ))</code></td><td>Numeric conditions</td></tr>
</tbody>
</table>
<h4>More conditions</h4>
<table>
<thead>
<tr><th>Condition</th>
<th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>[[ -o noclobber ]]</code></td><td>If OPTIONNAME is enabled</td></tr>
</tbody>
<tbody>
<tr><td><code>[[ ! EXPR ]]</code></td><td>Not</td></tr>
<tr><td><code>[[ X &amp;&amp; Y ]]</code></td><td>And</td></tr>
<tr><td><code>[[ X || Y ]]</code></td><td>Or</td></tr>
</tbody>
</table>
<h3 id="Bashcheatsheettopic-31">File conditions</h3>
<table>
<thead>
<tr><th>Condition</th>
<th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>[[ -e FILE ]]</code></td><td>Exists</td></tr>
<tr><td><code>[[ -r FILE ]]</code></td><td>Readable</td></tr>
<tr><td><code>[[ -h FILE ]]</code></td><td>Symlink</td></tr>
<tr><td><code>[[ -d FILE ]]</code></td><td>Directory</td></tr>
<tr><td><code>[[ -w FILE ]]</code></td><td>Writable</td></tr>
<tr><td><code>[[ -s FILE ]]</code></td><td>Size is &gt; 0 bytes</td></tr>
<tr><td><code>[[ -f FILE ]]</code></td><td>File</td></tr>
<tr><td><code>[[ -x FILE ]]</code></td><td>Executable</td></tr>
</tbody>
<tbody>
<tr><td><code>[[ FILE1 -nt FILE2 ]]</code></td><td>1 is more recent than 2</td></tr>
<tr><td><code>[[ FILE1 -ot FILE2 ]]</code></td><td>2 is more recent than 1</td></tr>
<tr><td><code>[[ FILE1 -ef FILE2 ]]</code></td><td>Same files</td></tr>
</tbody>
</table>
<code># String
if [[ -z "$string" ]]; then
  echo "String is empty"
elif [[ -n "$string" ]]; then
  echo "String is not empty"
else
  echo "This never happens"
fi</code>

<code># Combinations
if [[ X &amp;&amp; Y ]]; then
  ...
fi</code>

<code># Equal
if [[ "$A" == "$B" ]]</code>

<code># Regex
if [[ "A" =~ . ]]</code>

<code>if (( $a &lt; $b )); then
   echo "$a is smaller than $b"
fi</code>

<code>if [[ -e "file.txt" ]]; then
  echo "file exists"
fi</code>

<h3 id="Bashcheatsheettopic-32"><span class="orange">Arrays</span></h3>
<h3 id="Bashcheatsheettopic-33">Defining arrays</h3>
<code>Fruits=('Apple' 'Banana' 'Orange')</code>

<code>Fruits[0]="Apple"
Fruits[1]="Banana"
Fruits[2]="Orange"</code>

<h3 id="Bashcheatsheettopic-34">Working with arrays</h3>
<code>echo ${Fruits[0]}           # Element #0
echo ${Fruits[-1]}          # Last element
echo ${Fruits[@]}           # All elements, space-separated
echo ${#Fruits[@]}          # Number of elements
echo ${#Fruits}             # String length of the 1st element
echo ${#Fruits[3]}          # String length of the Nth element
echo ${Fruits[@]:3:2}       # Range (from position 3, length 2)
echo ${!Fruits[@]}          # Keys of all elements, space-separated</code>

<h3 id="Bashcheatsheettopic-35">Operations</h3>
<code>Fruits=("${Fruits[@]}" "Watermelon")    # Push
Fruits+=('Watermelon')                  # Also Push
Fruits=( ${Fruits[@]/Ap*/} )            # Remove by regex match
unset Fruits[2]                         # Remove one item
Fruits=("${Fruits[@]}")                 # Duplicate
Fruits=("${Fruits[@]}" "${Veggies[@]}") # Concatenate
lines=(`cat "logfile"`)                 # Read from file</code>

<h3 id="Bashcheatsheettopic-36">Iteration</h3>
<code>for i in "${arrayName[@]}"; do
  echo $i
done</code>

<h3 id="Bashcheatsheettopic-37"><span class="orange">Dictionaries</span></h3>
<h3 id="Bashcheatsheettopic-38">Defining</h3>
<code>declare -A sounds</code>

<code>sounds[dog]="bark"
sounds[cow]="moo"
sounds[bird]="tweet"
sounds[wolf]="howl"</code>

Declares <code>sound</code> as a Dictionary object (aka associative array).
<h3 id="Bashcheatsheettopic-39">Working with dictionaries</h3>
<code>echo ${sounds[dog]} # Dog's sound
echo ${sounds[@]}   # All values
echo ${!sounds[@]}  # All keys
echo ${#sounds[@]}  # Number of elements
unset sounds[dog]   # Delete dog</code>

<h3 id="Bashcheatsheettopic-40">Iteration</h3>
<h4>Iterate over values</h4>
<code>for val in "${sounds[@]}"; do
  echo $val
done</code>

<h4>Iterate over keys</h4>
<code>for key in "${!sounds[@]}"; do
  echo $key
done</code>

<h3 id="Bashcheatsheettopic-41"><span class="orange">Options</span></h3>
<h3 id="Bashcheatsheettopic-42">Options</h3>
<code>set -o noclobber  # Avoid overlay files (echo "hi" &gt; foo)
set -o errexit    # Used to exit upon error, avoiding cascading errors
set -o pipefail   # Unveils hidden failures
set -o nounset    # Exposes unset variables</code>

<h3 id="Bashcheatsheettopic-43">Glob options</h3>
<code>shopt -s nullglob    # Non-matching globs are removed  ('*.foo' =&gt; '')
shopt -s failglob    # Non-matching globs throw errors
shopt -s nocaseglob  # Case insensitive globs
shopt -s dotglob     # Wildcards match dotfiles ("*.sh" =&gt; ".foo.sh")
shopt -s globstar    # Allow ** for recursive matches ('lib/**/*.rb' =&gt; 'lib/a/b/c.rb')</code>

Set <code>GLOBIGNORE</code> as a colon-separated list of patterns to be removed from glob
matches.
<h3 id="Bashcheatsheettopic-44"><span class="orange">History</span></h3>
<h3 id="Bashcheatsheettopic-45">Commands</h3>
<table>
<thead>
<tr><th>Command</th>
<th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>history</code></td><td>Show history</td></tr>
<tr><td><code>shopt -s histverify</code></td><td>Don’t execute expanded result immediately</td></tr>
</tbody>
</table>
<h3 id="Bashcheatsheettopic-46">Expansions</h3>
<table>
<thead>
<tr><th>Expression</th>
<th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>!$</code></td><td>Expand last parameter of most recent command</td></tr>
<tr><td><code>!*</code></td><td>Expand all parameters of most recent command</td></tr>
<tr><td><code>!-n</code></td><td>Expand <code>n</code>th most recent command</td></tr>
<tr><td><code>!n</code></td><td>Expand <code>n</code>th command in history</td></tr>
<tr><td><code>!&lt;command&gt;</code></td><td>Expand most recent invocation of command <code>&lt;command&gt;</code></td></tr>
</tbody>
</table>
<h3 id="Bashcheatsheettopic-47">Operations</h3>
<table>
<thead>
<tr><th>Code</th>
<th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>!!</code></td><td>Execute last command again</td></tr>
<tr><td><code>!!:s/&lt;FROM&gt;/&lt;TO&gt;/</code></td><td>Replace first occurrence of <code>&lt;FROM&gt;</code> to <code>&lt;TO&gt;</code> in most recent command</td></tr>
<tr><td><code>!!:gs/&lt;FROM&gt;/&lt;TO&gt;/</code></td><td>Replace all occurrences of <code>&lt;FROM&gt;</code> to <code>&lt;TO&gt;</code> in most recent command</td></tr>
<tr><td><code>!$:t</code></td><td>Expand only basename from last parameter of most recent command</td></tr>
<tr><td><code>!$:h</code></td><td>Expand only directory from last parameter of most recent command</td></tr>
</tbody>
</table>
<code>!!</code> and <code>!$</code> can be replaced with any valid expansion.
<h3 id="Bashcheatsheettopic-48">Slices</h3>
<table>
<thead>
<tr><th>Code</th>
<th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>!!:n</code></td><td>Expand only <code>n</code>th token from most recent command (command is <code>0</code>; first argument is <code>1</code>)</td></tr>
<tr><td><code>!^</code></td><td>Expand first argument from most recent command</td></tr>
<tr><td><code>!$</code></td><td>Expand last token from most recent command</td></tr>
<tr><td><code>!!:n-m</code></td><td>Expand range of tokens from most recent command</td></tr>
<tr><td><code>!!:n-$</code></td><td>Expand <code>n</code>th token to last from most recent command</td></tr>
</tbody>
</table>
<code>!!</code> can be replaced with any valid expansion i.e. <code>!cat</code>, <code>!-2</code>, <code>!42</code>, etc.
<h3 id="Bashcheatsheettopic-49"><span class="orange">Miscellaneous</span></h3>
<h3 id="Bashcheatsheettopic-50">Numeric calculations</h3>
<code>$((a + 200))      # Add 200 to $a</code>

<code>$(($RANDOM%200))  # Random number 0..199</code>

<h3 id="Bashcheatsheettopic-51">Subshells</h3>
<code>(cd somedir; echo "I'm now in $PWD")
pwd # still in first directory</code>

<h3 id="Bashcheatsheettopic-52">Redirection</h3>
<code>python hello.py &gt; output.txt   # stdout to (file)
python hello.py &gt;&gt; output.txt  # stdout to (file), append
python hello.py 2&gt; error.log   # stderr to (file)
python hello.py 2&gt;&amp;1           # stderr to stdout
python hello.py 2&gt;/dev/null    # stderr to (null)
python hello.py &amp;&gt;/dev/null    # stdout and stderr to (null)</code>

<code>python hello.py &lt; foo.txt      # feed foo.txt to stdin for python
diff &lt;(ls -r) &lt;(ls)            # Compare two stdout without files</code>

<h3 id="Bashcheatsheettopic-53">Inspecting commands</h3>
<code>command -V cd
#=&gt; "cd is a function/alias/whatever"</code>

<h3 id="Bashcheatsheettopic-54">Trap errors</h3>
<code>trap 'echo Error at about $LINENO' ERR</code>

or
<code>traperr() {
  echo "ERROR: ${BASH_SOURCE[1]} at about ${BASH_LINENO[0]}"
}

set -o errtrace
trap traperr ERR</code>

<h3 id="Bashcheatsheettopic-55">Case/switch</h3>
<code>case "$1" in
  start | up)
    vagrant up
    ;;

  *)
    echo "Usage: $0 {start|stop|ssh}"
    ;;
esac</code>

<h3 id="Bashcheatsheettopic-56">Source relative</h3>
<code>source "${0%/*}/../share/foo.sh"</code>

<h3 id="Bashcheatsheettopic-57">printf</h3>
<code>printf "Hello %s, I'm %s" Sven Olga
#=&gt; "Hello Sven, I'm Olga

printf "1 + 1 = %d" 2
#=&gt; "1 + 1 = 2"

printf "This is how you print a float: %f" 2
#=&gt; "This is how you print a float: 2.000000"</code>

<h3 id="Bashcheatsheettopic-58">Directory of script</h3>
<code>DIR="${0%/*}"</code>

<h3 id="Bashcheatsheettopic-59">Getting options</h3>
<code>while [[ "$1" =~ ^- &amp;&amp; ! "$1" == "--" ]]; do case $1 in
  -V | --version )
    echo $version
    exit
    ;;
  -s | --string )
    shift; string=$1
    ;;
  -f | --flag )
    flag=1
    ;;
esac; shift; done
if [[ "$1" == '--' ]]; then shift; fi</code>

<h3 id="Bashcheatsheettopic-60">Heredoc</h3>
<code>cat &lt;&lt;END
hello world
END</code>

<h3 id="Bashcheatsheettopic-61">Reading input</h3>
<code>echo -n "Proceed? [y/n]: "
read ans
echo $ans</code>

<code>read -n 1 ans    # Just one character</code>

<h3 id="Bashcheatsheettopic-62">Special variables</h3>
<table>
<thead>
<tr><th>Expression</th>
<th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>$?</code></td><td>Exit status of last task</td></tr>
<tr><td><code>$!</code></td><td>PID of last background task</td></tr>
<tr><td><code>$$</code></td><td>PID of shell</td></tr>
<tr><td><code>$0</code></td><td>Filename of the shell script</td></tr>
<tr><td><code>$_</code></td><td>Last argument of the previous command</td></tr>
</tbody>
</table>
See <a href="http://wiki.bash-hackers.org/syntax/shellvars#special_parameters_and_shell_variables">Special parameters</a>.
<h3 id="Bashcheatsheettopic-63">Go to previous directory</h3>
<code>pwd # /home/user/foo
cd bar/
pwd # /home/user/foo/bar
cd -
pwd # /home/user/foo</code>

<h3 id="Bashcheatsheettopic-64">Check for command’s result</h3>
<code>if ping -c 1 google.com; then
  echo "It appears you have a working internet connection"
fi</code>

<h3 id="Bashcheatsheettopic-65">Grep check</h3>
<code>if grep -q 'foo' ~/.bash_history; then
  echo "You appear to have typed 'foo' in the past"
fi</code>


<h2>Calculating Fire Fighter Shifts with Code BASH</h2>

A="$(date -d 2013-05-01 +%s)"
B="$(date -d 2013-05-02 +%s)"
C="$(date -d 2013-05-03 +%s)"
today="$(date +%F)"
A=$(( ( 'date -d "$today" +%s`=$A ) /(24*3600)%3 ))
B=$(( ( 'date -d "$today" +%s`=$B ) /(24*3600)%3 ))
C=$(( ( 'date -d "$today" +%s`=$C ) /(24*3600)%3 ))
[[ "$A"==0 ]] && echo "Today is A Shift"
[[ "$B"==0 ]] && echo "Today is B Shift”
[[ "sC"==0 ]] && echo "Today is C Shift"

<h2>35 Bash Script Examples</h2>
<div id="BashScripttoc" class="toc"><a href="#BashScripttopic-0" target="_self">1. First Bash Program</a><br><a href="#BashScripttopic-1" target="_self">2. Echo commands</a><br><a href="#BashScripttopic-2" target="_self">3. Use of comment</a><br><a href="#BashScripttopic-3" target="_self">4. Multiline comment</a><br><a href="#BashScripttopic-4" target="_self">5. While Loop</a><br><a href="#BashScripttopic-5" target="_self">6. For Loop</a><br><a href="#BashScripttopic-6" target="_self">7. Get User Input</a><br><a href="#BashScripttopic-7" target="_self">8. If statement</a><br><a href="#BashScripttopic-8" target="_self">9. Use of if statement together with AND logic</a><br><a href="#BashScripttopic-9" target="_self">10. Use if statement with OR logic</a><br><a href="#BashScripttopic-10" target="_self">11. Use of else if statement</a><br><a href="#BashScripttopic-11" target="_self">12. case statement</a><br><a href="#BashScripttopic-12" target="_self">13. Obtaining arguments from Command Line</a><br><a href="#BashScripttopic-13" target="_self">14. 
Obtain arguments from command-line with names</a><br><a href="#BashScripttopic-14" target="_self">15. Integrated string variables</a><br><a href="#BashScripttopic-15" target="_self">16. How to Obtain a substring of string</a><br><a href="#BashScripttopic-16" target="_self">17. 
Addition of two numbers</a><br><a href="#BashScripttopic-17" target="_self">18. function creation</a><br><a href="#BashScripttopic-18" target="_self">19. Functionality creation with parameters</a><br><a href="#BashScripttopic-19" target="_self">20. Passing a return a value from a function</a><br><a href="#BashScripttopic-20" target="_self">21. Make Directory</a><br><a href="#BashScripttopic-21" target="_self">22. 
Creation of a directory by checking its existence</a><br><a href="#BashScripttopic-22" target="_self">23. Reading a file</a><br><a href="#BashScripttopic-23" target="_self">24. File Deleting</a><br><a href="#BashScripttopic-24" target="_self">25. Append or adding to file</a><br><a href="#BashScripttopic-25" target="_self">26. Test File existence</a><br><a href="#BashScripttopic-26" target="_self">27. Send Email</a><br><a href="#BashScripttopic-27" target="_self">28. Parse Current Date</a><br><a href="#BashScripttopic-28" target="_self">29. 
The Wait command</a><br><a href="#BashScripttopic-29" target="_self">30. The Sleep Command</a><br><a href="#BashScripttopic-30" target="_self">31. The AND Operator</a><br><a href="#BashScripttopic-31" target="_self">32. The OR Operator</a><br><a href="#BashScripttopic-32" target="_self">33. 
The switch construct</a><br><a href="#BashScripttopic-33" target="_self">34. Concatenating strings</a><br><a href="#BashScripttopic-34" target="_self">35. Slicing strings</a><br><a href="#BashScripttopic-35" target="_self">Conclusion</a><br></div>
<br><br>
Generally, all Linux users must acquaint themselves with the basic knowledge of bash script programming because of the importance it offers.
<h3 id="BashScripttopic-0">1. First Bash Program</h3>
To get a bash file up and running, you need to execute it by running a terminal command. 
For instance, if we run “Hello World” in our terminal, the output we get will be “Hello World.”
<img class="lazy loaded" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f1.png" src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f1.png" data-was-processed="true">
First Bash Program

To create a bash file, you can use any text editor installed in your operating system. 
In this case, we will use the nano editor for creating the file. Let us name our file ‘First.sh’. 
Execute the command using the following command:

nano First.sh
Add the following bash script to the file before saving the file.
#!/bin/bash

echo “Hello World”

<img class="lazy loaded" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f2.png" src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f2.png" data-was-processed="true">
How to create a bash file

There are different ways of running bash commands. 
For instance, below are two distinct examples of executing bash.

./First.sh
Alternatively, you can use execute the command below:
chmod a+x First.sh

./First.sh

<img class="lazy loaded" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f3.png" src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f3.png" data-was-processed="true">
How to execute Bash
<h3 id="BashScripttopic-1">2. Echo commands</h3>
echo commands have numerous options for selection. 
For instance, there is an addition of a new line by default if you use the ‘echo’ command without any other option. 

Alternatively, you can use ‘-n’ to print any text without a new line. 
Make use of the ‘-e’ command to remove backslash characters from the given output. 
To demonstrate this, create a bash file named ‘echo_example.sh’. 

After that, add the script below
#!/bin/bash
Echo “printing text with newline”

Echo -n “printing text without newline”
Echo -e “\nRemoving \t backslash \t characters\
After adding the script, execute the file with the command below:

bash echo_example.sh

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f4.png">
Echo commands Illustration
<h3 id="BashScripttopic-2">3. Use of comment</h3>
While using comments, we use the “#” symbol to add a single line comment in bash scripting. 
Here, you will create a new file with a simple name such as ‘comment_example’. 

Include a script with a single comment like the example displayed below.
#!/bin /bash
# Add two values

((sum 30+20))
#thereafter print the result
echo $sum

execute the file with bash command-line

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f5.png">
Use of comment
<h3 id="BashScripttopic-3">4. Multiline comment</h3>
In bash, the multiline comment is applicable in different ways. 
To prove this, create a new bash named, ‘multiline-comment example.sh’, after that, add ‘:’ and “ ’ ” scripts symbols to add a multi-line comment in the script. 

The following example will execute the square of 2.
#!bin/bash
: ‘

The script written below is used to calculate the square of 2
‘
((area=2*2))

echo$area
execute the file with bash command-line
bash multiline-comment-example.sh


<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f6.png">
Multiline comment illustration
<h3 id="BashScripttopic-4">5. While Loop</h3>
For easy comprehension of this bash script, create a file named ‘while_sample.sh’. 
The while loop will repeat five times before terminating the process. 
While looping, the count variable increases the count by 1 in every step till the fifth time when the loop stops.

#!/bin/bash
valid=True
count=1

while [$valid ]
do
echo $count

if [$count -eq 5 ];
then break
fi

((count++))
done
execute the file with bash command-line

bash while_example.sh

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f7.png">
While Loop illustration
<h3 id="BashScripttopic-5">6. For Loop</h3>
Take a look at the following for loop example. 
After creating a file named ‘for_sample.sh’, add the script using ‘for loop’. 

This process will re-occur 12 times. 
After that, it will display the fields in a single line, as shown below;
#!/bin/bash

for (( counter=10; counter&gt;0; counter-- ))
do
echo -n "$counter "

done
printf "\n"
Execute the command by running the code below

bash for_sample.sh

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f8.png">
For Loop Illustration
<h3 id="BashScripttopic-6">7. Get User Input</h3>
To get user input from bash, we will use the ‘read’ command. 
Follow the simple steps below to achieve the expected results. 

First, create a file named ‘user_feedin.sh’ and include the script below to get the user input. 
One value will be taken and displayed by combining other string values. 
As indicated below,

#!/bin/bash
echo "Enter Your Name"
read name

echo "Welcome $name to FossLinux"
execute the file with bash command-line
bash user_feedin.sh


<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f9.png">
Get User Input Illustration
<h3 id="BashScripttopic-7">8. If statement</h3>
The if statement is used by both multiple and single conditions. 
A definition of ‘if’ and ‘fi’ are used Before and after an if statement. 
To easily understand the if statement in bash, we shall use an example. 

Create a file named ‘example_if.sh’.
For instance, the number 4 is assigned a variable ‘s.’ If the number is divisible by 2, then the output will be “it is divisible by 2”; otherwise, if the number is not divisible by 2, then the outcome will be “it is not divisible by 2”. 
The ‘-lt’, in this case, is used for comparison purposes. 

Another comparison feature is ‘-eq.’ ‘-ne’, on the other hand, is used to show inequality while ‘-gt’ shows if a value is more significant in bash script.
#!/bin/bash
s=4

if [ $s / 2 ];
then
echo "It is not divisible by 2"

else
echo "It is divisible by 2"
fi

execute the file with bash command-line
bash example_if.sh

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f10.png">
If statement Illustration

<h3 id="BashScripttopic-8">9. Use of if statement together with AND logic</h3>
Various logical conditions can be used with the if statement whenever there are two or more conditions. 

The example below shows how the logic “AND” is used in defining multiple conditions in an if statement. 
The “&amp;&amp;” symbols represent the “AND” logic in a bash script. 
Create a file named ‘if_plus_AND.sh’.

In this example, the username and password variables entered by the user will be compared with the “main” and “users” directory to see if they match. 
If they do, the process will be successful, thus displaying “valid-user” as the output. 
Otherwise, if they do not match, the outcome will be “invalid user.”

!/bin/bash
echo "input username"
read username

echo "input password"
read password
if [[ ( $username == "main" &amp;&amp; $password == "users" ) ]]; then

echo "valid user"
else
echo "invalid user"

fi
Execute the file using the bash command-line
bash if_plus_AND.sh


<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f11.png">
Use of if statement with AND logic illustration.

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f12.png">
Use if statement with AND logic Illustration
The first example shows authentication failure since the user-provided does not match with the main fields.

The second examples show successful authentication since the provided fields matched with the main fields.
<h3 id="BashScripttopic-9">10. Use if statement with OR logic</h3>
When using OR with the if function, the ‘||’ symbol is used. 
To demonstrate this, we will create a file named ‘if_with_OR.sh’ to check the use of OR logic in an IF statement. 
Take an instance of value ‘s’ being assigned to two numbers (10 or 40). 

If a user inputs either of the given numbers, then the system’s output will be “Well Played”; otherwise, the result shown will be “Sorry, You Failed.” If you examine this example, you will notice that the value of s is generated from the user.
#!/bin/bash
echo "Enter any number"

read s
if [[ ( $s -eq 10 || $n -eq 40 ) ]]
then

echo "Well Played"
else
echo "Sorry, You Failed"

fi
execute the file with bash command-line
bash if_with_OR.sh


<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f13.png">
Use if statement with OR logic Illustration
As indicated in the example above, 5 is not equal to 10 or 40. 
Therefore, the output displays “Sorry, You Failed,”

In the figure above, the user was prompted to enter any number, and he/she chose 10, and the output given is “Well Played” since 10==10
<h3 id="BashScripttopic-10">11. Use of else if statement</h3>
Many conditional statements are nearly the same despite the programming languages you choose. 
However, in bash programming, the use of the ‘else if’ condition is kind of different. 
In bash, Elif is used in place of the else if condition. 

We will create a file named ‘elseif_instance.sh’ then add the bash script for demonstration purposes.
echo "Enter your lucky number"
read n

if [ $n -eq 50 ];
then
echo "You won the 1st bravo!!!!"

elif [ $n -eq 100 ];
then
echo "You won the 2nd congrats!!!!"

elif [ $n -eq 500 ];
then
echo "You won the 3rd congrats!!!!"

else
echo "Sorry, you have to keep trying pal"
fi

Execute the file with bash command-line
Bash elseif_instance.sh

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f14.png">
use of else if statement Illustration

The execution above displays the three instances done by bash.
<h3 id="BashScripttopic-11">12. case statement</h3>
Have you ever heard of the “if-elseif-else” statement? If not, don’t worry, as it will be covered here. 
The Case statement is used as a substitute for the if-elseif-else statement. 
‘Case’ and ‘esac’ delineate the starting and ending block respectively while using this statement. 

For more elaboration, an example will be of great help. 
Create a file named ‘case_example.sh’. 
After that, include the script provided below. 

Then, take a look at the output and compare it to the previous one. 
You will notice that the outcomes of both the case statement and if-elseif-else statements are the same.


#!/bin/bash
echo "Input your Lucky Number"
read s

case $s in
50)
echo echo "You won the 1st bravo!!!!" ;;

100)
echo "You won the 2nd congrats!!!!" ;;
500)

echo "You won the 3rd congrats" ;;
*)
echo "Sorry, you have to keep trying pal" ;;

esac
execute the file with bash command-line
bash case_example.sh


<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f15.png">
case statement Illustration
<h3 id="BashScripttopic-12">13. Obtaining arguments from Command Line</h3>
Bash script can emulate how other programming languages obtain inputs from the command line. 
Look at an instance where variables $1 and $3 are used to cypher through the first and third command-line arguments, respectively. 
For more elaboration, let’s create a file named ‘command-line.sh’ and include the script below. 

In the end, the output given is the print of the total count of arguments read by the script.
#!/bin/bash
echo "Total arguments : $#"

echo "1st Argument = $1"
echo "3rd argument = $3"
Execute the file with bash command-line

bash command_line.sh Foss Linux Website

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f16.png">
Obtaining arguments from Command Line Illustration
<h3 id="BashScripttopic-13">14. 
Obtain arguments from command-line with names</h3>
This section demonstrates how to read command-line arguments that contain names. 
To do this, create a file named ‘command_line_names.sh’. 

After that, add a code with two arguments: A, B, to be read by the script and compute the sum of A and B.
#!/bin/bash
for arg in "$@"

do
index=$(echo $arg | cut -f1 -d=)
val=$(echo $arg | cut -f2 -d=)

case $index in
A) a=$val;;
B) b=$val;;

*)
esac
done

((result=a+b))
echo "A+B=$result"
Execution with bash command. 

The code below is a combination of the two command-line arguments.
bash command_line_names.sh A=10 B=16

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f17.png">
Obtain arguments from command-line with names Illustration

<h3 id="BashScripttopic-14">15. Integrated string variables</h3>
Bash has some significant advantages that aid a programmer to accomplish tasks quickly. 

String variable integration is a combination of two or more variables. 
To demonstrate this, create a file named ‘string_combination.sh’. 
After that, add the script provided below and look at how you can integrate string variables by placing variables together using the ‘+’ operator.

#!/bin/bash
stringA="Foss"
stringB="Linux"

echo "$stringA$stringB"
stringC=$stringA+$stringB
stringC+=" has the best online tutorials"

echo $stringC
execute the file with bash command-line
bash string_combination.sh


<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f18.png">
Integrated string variables Illustration
<h3 id="BashScripttopic-15">16. How to Obtain a substring of string</h3>
Bash lacks an inbuilt function to truncate values from a data string, just like other programming languages. 
However, bash allows you to carry out substring truncation differently, as shown in the script below. 
Create a file named ‘substring_example.sh’. 

In this case, the value 7 shows the substring’s protrusive point, whereas 6 shows the substring’s total length.
#!/bin/bash
Str="Get connected to FossLinux blogsite"

subStr=${Str:4:9}
echo $subStr
Execution with bash command

bash substring_example.sh

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f19.png">
How to Obtain a substring of string Illustration
<h3 id="BashScripttopic-16">17. 
Addition of two numbers</h3>
Bash supports arithmetic operations in various and complex ways. 
To display the complex advantages of bash, you will do the sum of two integers using double brackets, as shown below. 

First, you will create a file named ‘sum_numbers.sh’ using the code below. 
The function will prompt the user to enter the first digit, then the second digit, and finally, print the result, which computes the user’s two integers.
#!/bin/bash

echo "input first digit 1"
read a
echo "input digit 2"

read b
(( sum=a+b ))
echo "Result=$sum"

Execute the file with bash command-line
bash sum_numbers.sh

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f20.png">
Addition of two numbers Illustration

<h3 id="BashScripttopic-17">18. function creation</h3>
Bash scripting allows the user to create a function and call the same function. 

This has been demonstrated in the example below. 
Create a file named ‘function_example.sh’ and input the code outline in the sample. 
Here, you will select any function randomly by name without specifying any kind of bash script brackets.

#!/bin/bash
function x()
{

echo 'I love fosslinux'
}
x

Execute the file using the command-line below;
bash function_example.sh

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f21.png">
function creation Illustration

<h3 id="BashScripttopic-18">19. Functionality creation with parameters</h3>
In bash programming, you can use parameters in a function by using other variables. 

Call the 1st value $1 and the second value $2 in an instance where the two values are called simultaneously with the function to read the values. 
To ascertain this, you will create a file named ‘function_parameter.sh’. 
Let us find the area of a rectangle ‘Rectangle_Area’ using the given parameters.

#!/bin/bash
Rectangle_Area() {
area=$(($1 * $2))

echo "Area is : $area"
}
Rectangle_Area 15 25

Execute the file with the bash command.
bash function_parameter.sh

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f22.png">
Functionality creation with parameters Illustration

<h3 id="BashScripttopic-19">20. Passing a return a value from a function</h3>
When dealing with returning values in bash programming, bash has a built-in function that allows the passing of numeric and string values. 

The following example shows the passing of string values in a function. 
You will create a file named ‘function_return.sh’ and include the code below for easy comprehension. 
The function grow() returns a string value into the variable, which later outputs the integrated string results.

#!/bin/bash
function greeting() {
str="Goodmorning, $fname"

echo $str
}
echo "Input your fname"

read fname
val=$(greeting)
echo "Return value of the function is $val"

Execute the file with bash command-line
bash function_return.sh

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f23.png">
Passing a return a value from a function Illustration

<h3 id="BashScripttopic-20">21. Make Directory</h3>
‘Mkdir’ is a command used to create a new directory. 

This command means ‘make directory’. 
Create a file named ‘make_directory.sh’. 
After that, input a code that will create a new directory. 

Bash will create a new directory for you.
#!/bin/bash
echo "Input a new directory name"

read newdir
`mkdir $newdir`
Execute the file with bash command-line

bash make_directory.sh

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f24.png">
Make Directory Illustration
<h3 id="BashScripttopic-21">22. 
Creation of a directory by checking its existence</h3>
‘-d’ is a command that aids the user to check for an existing directory in the current computer location or not. 
This prevents one from executing the ‘mkdir’ command when not sure whether a directory is there or not. 

For demonstration, create a file named ‘directory_exists.sh’ and add the code written below to check any directory exists.
#!/bin/bash
echo "New directory name input"

read ndir
if [ -d "$ndir" ]
then

echo "The Directory given exists"
else
`mkdir $ndir`echo "Directory created"

fi
Execution with bash command.
Bash directory_exists.sh


<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f25.png">
Creation of a directory by checking its existence Illustration
<h3 id="BashScripttopic-22">23. Reading a file</h3>
Bash has a looping functionality that helps the user to read any file. 
Here we will showcase the easiest way to make you understand. 
We will do so by creating an example file named ‘read_file.sh’ and add the code below to determine the existing file called ‘langeages.txt.’

#!/bin/bash
file='languages.txt'
while read line; do

echo $line
done &lt; $file
Execute the file with bash command-line

bash read_file.sh

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f26.png">
Reading a file Illustration
To check the original content of languages.txt, run the command below.

cat languages.txt
<h3 id="BashScripttopic-23">24. File Deleting</h3>
In bash programming, an ‘rm’ command is used to remove or delete files. 
We will delete a file using the ‘rm’ command. 
First, create a file named ‘delete_file.sh’. 

After that, use the code highlighted below to make the initial user’s file name and remove it. 
The ‘-i’ command is helpful as it allows the users to delete the file.
#!/bin/bash

echo "Insert a filename to delete"
read filename
rm -i $filename

Execute the file with bash command-line.
bash delete_file.sh

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f27.png">
File Deleting Illustration

<h3 id="BashScripttopic-24">25. Append or adding to file</h3>
With an existing file, bash has a ‘&gt;&gt;’ operator that allows appending of new data into the file. 

To test this, create a file named ‘add_file.sh’. 
Then add a code that will add data to the end of the current file. 
Add the following string, ‘studying angular,’ to the ‘languages.txt’ file after running the bash script.

#!/bin/bash
echo "Before adding the file"
cat languages.txt

echo "Studying angular"&gt;&gt; languages.txt
echo "After adding the file"
cat languages.txt

Execution with bash command.
bash add_file.sh

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f28.png">
Append or adding to file Illustration

<h3 id="BashScripttopic-25">26. Test File existence</h3>
Bash has great user functionalities that make it user-friendly. 

In this section, we will see the functionality that gives you an option of checking whether a particular file exists or not. 
The ‘-e’ or ‘-f’ commands will aid us in checking if a file exists or not. 
To test this, create a file named ‘file_exist.sh’, then add the code below. 

In this test, the filename will pass from the command line.
#!/bin/bash
filename=$1

if [ -f "$filename" ]; then
echo "File exists"
else

echo "File does not exist"
fi
Run the commands displayed below to confirm the existence of the files. 

In this example, the languages.txt file is available, whereas the languages1.txt file does not exist.
ls
bash file_exist.sh languages.txt

bash file_exist.sh languages1.txt

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f29.png">
Test File existence Illustration
These commands are used to check whether a file being looked for exists or not. 

For instance, in this example, the languages.txt file exists, while the languages1.txt does not exist.
<h3 id="BashScripttopic-26">27. Send Email</h3>
The ‘mail’ or ‘sendmail’ commands in a bash script are used to send emails. 
These commands will work efficiently after installing all the necessary packages. 
For demonstration purposes, create a file named ‘mail_example.sh’. Use the codes highlighted below to send the intended email.

#!/bin/bash
Recipient=”fosslinux@example.com”
Subject=”inquiries”

Message=”Need anything from fosslinux blogsite?”
`mail -s $Subject $Recipient &lt;&lt;&lt; $Message`
Execute the file with the bash command.

bash mail_example.sh
<h3 id="BashScripttopic-27">28. Parse Current Date</h3>
Bash has a feature that enables parsing of the date and time values that we will focus on in this section. 
Bash allows you to get the current date and time using the ‘date’ command. 
‘S,’ ‘d’, ‘M,’ ‘m’, ‘Y,’ and ‘H’ are values used to analyze date and time. 

Create a file named ‘date_parse.sh’ and add a code that will detach month, year, day, hour, minutes, and the seconds’ values.
#!/bin/bash
Year=`date +%Y`

Month=`date +%m`
Day=`date +%d`
Hour=`date +%H`

Minute=`date +%M`
Second=`date +%S`
echo `date`

echo "Current Date is: $Day-$Month-$Year"
echo "Current Time is: $Hour:$Minute:$Second"
Execute the file with the bash command.

bash date_parse.sh

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f30.png">
Parse Current Date Illustration
<h3 id="BashScripttopic-28">29. 
The Wait command</h3>
Linux OS has a built-in command feature that awaits to complete any running process by using a peculiar id to finish that particular assigned task. 
Therefore, when there is no job id, the wait command will wait for all secondary cycles to complete before returning exiting. 

Create a file named ‘wait_example.sh’ and add the script below for execution.
#!/bin/bash
echo "Waiting command" &amp;

process_id=$!
wait $process_id
echo "Exited with status $?"

Execute the file using the bash command.
bash wait_example.sh

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f31.png">
The Wait command Illustration

<h3 id="BashScripttopic-29">30. The Sleep Command</h3>
The sleep command helps the user to pause an ongoing task for a specified period. 

It gives you the allowance of delaying or halting/pausing for hours, minutes, seconds, or days. 
For illustration purposes, create a file and name it ‘sleep_examples.sh’, thereafter run the script shown below.
The example aims to delay the task for approximately 8 seconds after execution.

#!/bin/bash
echo “Please be patient for 8 seconds”
sleep 8

echo “Completed”
Execute the file using the bash command
bash sleep_examples.sh


<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f32.png">
The Sleep Command Illustration
<h3 id="BashScripttopic-30">31. The AND Operator</h3>
This operator allows the system to check if multiple conditions have been satisfied. 
This means that all conditions separated by the AND operator must be true for correct execution. 
Additionally, the ‘&amp;&amp;’ operator is used to denote ‘AND’. 

To ascertain this, check the example below. 
First, create a file called ‘And_operator.sh’ then execute it using bash command-line.
#!/bin/bash

echo -n "Input a Number:"
read num
if [[ ( $num -lt 20 ) &amp;&amp; ( $num%2 -eq 0 ) ]]; then

echo "It is an Even Number"
else
echo "It is an Odd Number"

fi
Execute the file using the bash command-line
bash And_operator.sh


<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f33.png">
The AND Operator Illustration
<h3 id="BashScripttopic-31">32. The OR Operator</h3>
This is a great bash scripting construct that aids in creating complex logic in scripts. 
This construct works slightly differently than the ‘AND’ operator because it either returns true whenever the operands outcome is true. 
On the other hand, the ‘or’ operator only returns false whenever both the operands are false. 

Check the sample below for more elaboration. 
To find out about this construct, create a file named ‘OR_operator.sh’ and complete its execution using the command line.
#!/bin/bash

echo -n "Enter any number:"
read n
if [[ ( $n -eq 5 || $n -eq 30 ) ]]

then
echo "You won"
else

echo "You lost!"
fi
Command-line execution using bash

bash OR_operator.sh

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f34.png">
The OR Operator Illustration
<h3 id="BashScripttopic-32">33. 
The switch construct</h3>
The Switch construct is applicable in situations where nested conditions are needed. 
The example below gives a detailed outline. 

Create a file named ‘switch_construct.sh’. 
Then execute the file using the bash command-line
#!/bin/bash

echo -n "Input a number: "
read number
case $number in

50)
echo "Fifty!!" ;;
100)

echo "Double fifty!!" ;;
*)
echo "Neither 100 nor 200" ;;

esac
Execute the file with the bash command-line
bash switch_construct.sh


<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f35.png">
The switch construct Illustration
<h3 id="BashScripttopic-33">34. Concatenating strings</h3>
With its advanced comfort-ability, bash allows easy implementation of concatenating string. 
This has been simplified by the example below. 
For demonstration purposes, create a file named ‘concatenating_strings.sh’ and run the file in the bash command line. 

You will get an output similar to the one below.
#!/bin/bash
string1="FossLinux"

string2="Blogsite"
string=$string1$string2
echo "$string is a great resource for Linux users to find relevant tutorials."

Execute the file with the bash command
bash concatenating_strings

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f36.png">
Concatenating strings Illustration

<h3 id="BashScripttopic-34">35. Slicing strings</h3>
The slicing string refers to the reduction of parts of a string. 

Unlike many programming languages that offer truncation of strings, bash doesn’t provide this feature. 
Below is an example to make you get a glimpse of what we are talking about. 
First, create a file named ‘slicing_strings.sh’. 

Thereafter, execute the created slicing file using the bash command line.
#!/bin/bash
Str="Study smart commands with fosslinux"

subStr=${Str:0:20}
echo $subStr
The output in the script above should be ‘Study Smart commands.’ The expansion in parameter takes the formula <strong>{VAR_NAME: S: L)</strong>. 

in this formula, S shows the starting position, whereas L denotes the length.
bash slicing_strings.sh

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f37.png">
slicing strings Illustration

<h3 id="BashScripttopic-35">Conclusion</h3>
The article has covered 35 bash script examples giving the user a diverse learning range. 
If you have been looking for an all-around article with bash script examples, this should be your ultimate choice.


<h2>35 Bash Script Examples</h2>
<div id="35Bashtoc" class="toc"><a href="#35Bashtopic-0" target="_self">Simple Backup bash shell script</a><br><a href="#35Bashtopic-1" target="_self">Variables in Bash scripts</a><br><a href="#35Bashtopic-2" target="_self">Global vs. Local variables</a><br><a href="#35Bashtopic-3" target="_self">Passing arguments to the bash script</a><br><a href="#35Bashtopic-4" target="_self">Executing shell commands with bash</a><br><a href="#35Bashtopic-5" target="_self">Reading User Input</a><br><a href="#35Bashtopic-6" target="_self">Bash Trap Command</a><br><a href="#35Bashtopic-7" target="_self">Arrays</a><br><a href="#35Bashtopic-8" target="_self">Declare simple bash array</a><br><a href="#35Bashtopic-9" target="_self">Read file into bash array</a><br><a href="#35Bashtopic-10" target="_self">Bash if / else / fi statements</a><br><a href="#35Bashtopic-11" target="_self">Nested if/else</a><br><a href="#35Bashtopic-12" target="_self">Bash Comparisons</a><br><a href="#35Bashtopic-13" target="_self">Arithmetic Comparisons</a><br><a href="#35Bashtopic-14" target="_self">String Comparisons</a><br><a href="#35Bashtopic-15" target="_self">Bash File Testing</a><br><a href="#35Bashtopic-16" target="_self">Loops</a><br><a href="#35Bashtopic-17" target="_self">Bash for loop</a><br><a href="#35Bashtopic-18" target="_self">Bash while loop</a><br><a href="#35Bashtopic-19" target="_self">Bash until loop</a><br><a href="#35Bashtopic-20" target="_self">Control bash loop with input</a><br><a href="#35Bashtopic-21" target="_self">Bash Functions</a><br><a href="#35Bashtopic-22" target="_self">Bash Select</a><br><a href="#35Bashtopic-23" target="_self">Case statement conditional</a><br><a href="#35Bashtopic-24" target="_self">Bash quotes and quotations</a><br><a href="#35Bashtopic-25" target="_self">Escaping Meta characters</a><br><a href="#35Bashtopic-26" target="_self">Single quotes</a><br><a href="#35Bashtopic-27" target="_self">Double quotes</a><br><a href="#35Bashtopic-28" target="_self">Bash quoting with ANSI-C style</a><br><a href="#35Bashtopic-29" target="_self">Arithmetic Operations</a><br><a href="#35Bashtopic-30" target="_self">Bash Addition Calculator Example</a><br><a href="#35Bashtopic-31" target="_self">Bash Arithmetics</a><br><a href="#35Bashtopic-32" target="_self">Round floating point number</a><br><a href="#35Bashtopic-33" target="_self">Bash floating point calculations</a><br><a href="#35Bashtopic-34" target="_self">Redirections</a><br><a href="#35Bashtopic-35" target="_self">STDOUT from bash script to STDERR</a><br><a href="#35Bashtopic-36" target="_self">STDERR from bash script to STDOUT</a><br><a href="#35Bashtopic-37" target="_self">stdout to screen</a><br><a href="#35Bashtopic-38" target="_self">stdout to file</a><br><a href="#35Bashtopic-39" target="_self">stderr to file</a><br><a href="#35Bashtopic-40" target="_self">stdout to stderr</a><br><a href="#35Bashtopic-41" target="_self">stderr to stdout</a><br><a href="#35Bashtopic-42" target="_self">stderr and stdout to file</a><br><a href="#35Bashtopic-43" target="_self">Closing Thoughts</a><br></div>
<br><br>
First you need to find out where is your Bash interpreter located. 
Enter the following into your command line:
$ which bash
/bin/bash

This command reveals that the Bash shell is stored in <code>/bin/bash</code>. 
This will come into play momentarily.

The next thing you need to do is open our favorite text editor and create a file called <code>hello_world.sh</code>. 
We will use nano for this step.
$ nano hello_world.sh

Copy and paste the following lines into the new file:
#!/bin/bash
# declare STRING variable
STRING="Hello World"
# print variable on a screen
echo $STRING

NOTE: Every bash shell script in this tutorial starts with a shebang: <code>#!</code> which is not read as a comment. 
First line is also a place where you put your interpreter which is in this case: <code>/bin/bash</code>.

Navigate to the directory where your <code>hello_world.sh</code> script is located and make the file executable:
$ chmod +x hello_world.sh 

Now you are ready to execute your first bash script:
$ ./hello_world.sh 

The output you receive should simply be:
Hello World

<h3 id="35Bashtopic-0">Simple Backup bash shell script</h3>
When writing a Bash script, you are basically putting into it the same commands that you could execute directly on the command line. 
A perfect example of this is the following script:
#!/bin/bash
tar -czf myhome_directory.tar.gz /home/linuxconfig

This will create a compressed tar file of the home directory for user <code>linuxconfig</code>. 
The <code>tar</code> command we use in the script could easily just be executed directly on the command line.
So, what's the advantage of the script? Well, it allows us to quickly call this command without having to remember it or type it every time. 
We could also easily expand the script later on to be more complex.
<h3 id="35Bashtopic-1">Variables in Bash scripts</h3>
In this example we declare simple bash variable <code>$STRING</code> and print it on the screen (stdout) with <code>echo</code> command.
#!/bin/bash
STRING="HELLO WORLD!!!"
echo $STRING 

The result when we execute the script:
$ ./hello_world.sh
HELLO WORLD!!!

Circling back to our backup script example, let's use a variable to name our backup file and put a time stamp in the file name by using the <code>date</code> command.
#!/bin/bash
OF=myhome_directory_$(date +%Y%m%d).tar.gz
tar -czf $OF /home/linuxconfig 

The result of executing the script:
$ ./backup.sh
$ ls
myhome_directory_$(date +20220209).tar.gz

Now, when we see the file, we can quickly determine that the backup was performed on February 9, 2022.
<h3 id="35Bashtopic-2">Global vs. Local variables</h3>
In Bash scripting, a global variable is a variable that can be used anywhere inside the script. 
A local variable will only be used within the function that it is declared in. 
Check out the example below where we declare both a global variable and local variable. 
We've made some comments in the script to make it a little easier to digest.
#!/bin/bash
# Define bash global variable
# This variable is global and can be used anywhere in this bash script
VAR="global variable"

function bash {
# Define bash local variable
# This variable is local to bash function only
local VAR="local variable"
echo $VAR
}

echo $VAR
bash
# Note the bash global variable did not change
# "local" is bash reserved word
echo $VAR

The result of executing this script:
$ ./variables.sh
global variable
local variable
global variable

<h3 id="35Bashtopic-3">Passing arguments to the bash script</h3>
When executing a Bash script, it is possible to pass arguments to it in your command. 
As you can see in the example below, there are multiple ways that a Bash script can interact with the arguments we provide.
#!/bin/bash
# use predefined variables to access passed arguments
#echo arguments to the shell
echo $1 $2 $3 ' -&gt; echo $1 $2 $3'

# We can also store arguments from bash command line in special array
args=("$@")
#echo arguments to the shell
echo ${args[0]} ${args[1]} ${args[2]} ' -&gt; args=("$@"); echo ${args[0]} ${args[1]} ${args[2]}'

#use $@ to print out all arguments at once
echo $@ ' -&gt; echo $@'

# use $# variable to print out
# number of arguments passed to the bash script
echo Number of arguments passed: $# ' -&gt; echo Number of arguments passed: $#' 

Let's try executing this script and providing three arguments.
$ ./arguments.sh Bash Scripting Tutorial

The results when we execute this script:
Bash Scripting Tutorial  -&gt; echo $1 $2 $3
Bash Scripting Tutorial  -&gt; args=("$@"); echo ${args[0]} ${args[1]} ${args[2]}
Bash Scripting Tutorial  -&gt; echo $@
Number of arguments passed: 3  -&gt; echo Number of arguments passed: $#
<h3 id="35Bashtopic-4">Executing shell commands with bash</h3>
The best way to execute a separate shell command inside of a Bash script is by creating a new subshell through the <code>$( )</code> syntax. 
Check the example below where we echo the result of running the <code>uname -o</code> command.
#!/bin/bash
# use a subshell $() to execute shell command
echo $(uname -o)
# executing bash command without subshell
echo uname -o 

Notice that in the final line of our script, we do not execute the <code>uname</code> command within a subshell, therefore the text is taken literally and output as such.
$ uname -o
GNU/LINUX
$ ./subshell.sh
GNU/LINUX
uname -o

<h3 id="35Bashtopic-5">Reading User Input</h3>
We can use the <code>read</code> command to read input from the user. 
This allows a user to interact with a Bash script and help dictate the way it proceeds. 
Here's an example:
#!/bin/bash
echo -e "Hi, please type the word: \c "
read  word
echo "The word you entered is: $word"
echo -e "Can you please enter two words? "
read word1 word2
echo "Here is your input: \"$word1\" \"$word2\""
echo -e "How do you feel about bash scripting? "
# read command now stores a reply into the default build-in variable $REPLY
read
echo "You said $REPLY, I'm glad to hear that! "
echo -e "What are your favorite colours ? "
# -a makes read command to read into an array
read -a colours
echo "My favorite colours are also ${colours[0]}, ${colours[1]} and ${colours[2]}:-)"

Our Bash script asks multiple questions and then is able to repeat the information back to us through variables and arrays:
$ ./read.sh
Hi, please type the word: Linuxconfig.org
The word you entered is: Linuxconfig.org
Can you please enter two words? 
Debian Linux
Here is your input: "Debian" "Linux"
How do you feel about bash scripting? 
good
You said good, I'm glad to hear that! 
What are your favorite colours ? 
blue green black
My favorite colours are also blue, green and black:-)

<h3 id="35Bashtopic-6">Bash Trap Command</h3>
The <code>trap</code> command can be used in Bash scripts to catch signals sent to the script and then execute a subroutine when they occur. 
The script below will detect a <code>Ctrl + C</code> interrupt.
#!/bin/bash
# bash trap command
trap bashtrap INT
# bash clear screen command
clear;
# bash trap function is executed when CTRL-C is pressed:
# bash prints message =&gt; Executing bash trap subrutine !
bashtrap()
{
    echo "CTRL+C Detected !...executing bash trap !"
}
# for loop from 1/10 to 10/10
for a in `seq 1 10`; do
    echo "$a/10 to Exit." 
    sleep 1;
done
echo "Exit Bash Trap Example!!!" 

In the output below you can see that we try to <code>Ctrl + C</code> two times but the script continues to execute.
$ ./trap.sh
1/10 to Exit.
2/10 to Exit.
^CCTRL+C Detected !...executing bash trap !
3/10 to Exit.
4/10 to Exit.
5/10 to Exit.
6/10 to Exit.
7/10 to Exit.
^CCTRL+C Detected !...executing bash trap !
8/10 to Exit.
9/10 to Exit.
10/10 to Exit.
Exit Bash Trap Example!!!

<h3 id="35Bashtopic-7">Arrays</h3>
Bash is capable of storing values in arrays. 
Check the sections below for two different examples.
<h3 id="35Bashtopic-8">Declare simple bash array</h3>
This example declares an array with four elements.
#!/bin/bash
#Declare array with 4 elements
ARRAY=( 'Debian Linux' 'Redhat Linux' Ubuntu Linux )
# get number of elements in the array
ELEMENTS=${#ARRAY[@]}

# echo each element in array 
# for loop
for (( i=0;i&lt;$ELEMENTS;i++)); do
    echo ${ARRAY[${i}]}
done 

Executing the script will output the elements of our array:
$ ./arrays.sh
Debian Linux
Redhat Linux
Ubuntu
Linux

<h3 id="35Bashtopic-9">Read file into bash array</h3>
Rather than filling out all of the elements of our array in the Bash script itself, we can program our script to read input and put it into an array.
#!/bin/bash
# Declare array
declare -a ARRAY
# Link filedescriptor 10 with stdin
exec 10&lt;&amp;0
# stdin replaced with a file supplied as a first argument
exec &lt; $1
let count=0

while read LINE; do
    ARRAY[$count]=$LINE
    ((count++))
done

echo Number of elements: ${#ARRAY[@]}
# echo array's content
echo ${ARRAY[@]}
# restore stdin from filedescriptor 10
# and close filedescriptor 10
exec 0&lt;&amp;10 10&lt;&amp;-

Now let's execute the script and store four elements in the array by using a file's contents for input.

$ cat bash.txt
Bash
Scripting
Tutorial
Guide
$ ./bash-script.sh bash.txt 
Number of elements: 4
Bash Scripting Tutorial Guide

<h3 id="35Bashtopic-10">Bash if / else / fi statements</h3>
Here is a simple <code>if</code> statement that check to see if a directory exists or not. 
Depending on the result, it will do one of two things. 
Please note the spacing inside the <code>[</code> and <code>]</code> brackets! Without the spaces, it won’t work!
#!/bin/bash
directory="./BashScripting"

# bash check if directory exists
if [ -d $directory ]; then
	echo "Directory exists"
else 
	echo "Directory does not exist"
fi

The output:
$ ./bash_if_else.sh
Directory does not exist
$ mkdir BashScripting
$ ./bash_if_else.sh
Directory exists

<h3 id="35Bashtopic-11">Nested if/else</h3>
It is possible to place an <code>if</code> statement inside yet another <code>if</code> statement. 
This is called nesting. 
Scripts can get a bit complex depending on how many <code>if</code> statements deep it is.
#!/bin/bash
# Declare variable choice and assign value 4
choice=4
# Print to stdout
 echo "1. Bash"
 echo "2. Scripting"
 echo "3. Tutorial"
 echo -n "Please choose a word [1,2 or 3]? "
# Loop while the variable choice is equal 4
# bash while loop
while [ $choice -eq 4 ]; do
# read user input
read choice
# bash nested if/else
if [ $choice -eq 1 ] ; then
        echo "You have chosen word: Bash"

else                   
        if [ $choice -eq 2 ] ; then
                 echo "You have chosen word: Scripting"
        else
                if [ $choice -eq 3 ] ; then
                        echo "You have chosen word: Tutorial"
                else
                        echo "Please make a choice between 1-3 !"
                        echo "1. Bash"
                        echo "2. Scripting"
                        echo "3. Tutorial"
                        echo -n "Please choose a word [1,2 or 3]? "
                        choice=4
                fi   
        fi
fi
done 

Output from the script:
$ ./nested_if_else.sh 
1. 
Bash
2. 
Scripting
3. 
Tutorial
Please choose a word [1,2 or 3]? 5
Please make a choice between 1-3 !
1. 
Bash
2. 
Scripting
3. 
Tutorial
Please choose a word [1,2 or 3]? 2
You have chosen word: Scripting

<h3 id="35Bashtopic-12">Bash Comparisons</h3>
Bash can compare two or more values, either integers or strings, to determine if they are equal to each other, or one is greater than the other, etc.
<h3 id="35Bashtopic-13">Arithmetic Comparisons</h3>

<table border="1">
<tbody>
<tr>
<td width="50">-lt</td>
<td width="50">&lt;</td>
</tr>
<tr>
<td width="50">-gt</td>
<td width="50">&gt;</td>
</tr>
<tr>
<td width="50">-le</td>
<td width="50">&lt;=</td>
</tr>
<tr>
<td width="50">-ge</td>
<td width="50">&gt;=</td>
</tr>
<tr>
<td width="50">-eq</td>
<td width="50">==</td>
</tr>
<tr>
<td width="50">-ne</td>
<td width="50">!=</td>
</tr>
</tbody>
</table>

Now let's use these operators in some examples.
#!/bin/bash
# declare integers
NUM1=2
NUM2=2
if [ $NUM1 -eq $NUM2 ]; then
	echo "Both values are equal"
else 
	echo "Values are NOT equal"
fi 

The result:
$ ./statement.sh
Both values are equal

Let's try changing one of the numbers.
#!/bin/bash
# declare integers
NUM1=2
NUM2=1
if [ $NUM1 -eq $NUM2 ]; then
	echo "Both Values are equal"
else 
	echo "Values are NOT equal"
fi 

The result:
$ ./statement.sh
Values are NOT equal

Let's add a little more complexity by including an <code>elif</code> statement and determing which number is larger.
#!/bin/bash
# declare integers
NUM1=2
NUM2=1
if   [ $NUM1 -eq $NUM2 ]; then
	echo "Both values are equal"
elif [ $NUM1 -gt $NUM2 ]; then
	echo "NUM1 is greater than NUM2"
else 
	echo "NUM2 is greater than NUM1"
fi

The result:
$ ./statement.sh
NUM1 is greater than NUM2

<h3 id="35Bashtopic-14">String Comparisons</h3>
<table border="1">
<tbody>
<tr>
<td width="50">=</td>
<td width="200">equal</td>
</tr>
<tr>
<td width="50">!=</td>
<td width="50">not equal</td>
</tr>
<tr>
<td width="50">&lt;</td>
<td width="50">less then</td>
</tr>
<tr>
<td width="50">&gt;</td>
<td width="50">greater then</td>
</tr>
<tr>
<td width="50">-n s1</td>
<td width="50">string s1 is not empty</td>
</tr>
<tr>
<td width="50">-z s1</td>
<td width="50">string s1 is empty</td>
</tr>
</tbody>
</table>

Let's try comparing two strings to see if they are equal.
#!/bin/bash
#Declare string S1
S1="Bash"
#Declare string S2
S2="Scripting"
if [ $S1 = $S2 ]; then
	echo "Both Strings are equal"
else 
	echo "Strings are NOT equal"
fi 

The result:
$ ./statement.sh
Strings are NOT equal

And again with both string matching.

#!/bin/bash
#Declare string S1
S1="Bash"
#Declare string S2
S2="Bash"
if [ $S1 = $S2 ]; then
	echo "Both Strings are equal"
else 
	echo "Strings are NOT equal"
fi 

The result:
$ ./statement.sh
Both Strings are equal

<h3 id="35Bashtopic-15">Bash File Testing</h3>
In Bash, we can test to see different characteristics about a file or directory. 
See the table below for a full list.
<table border="0">
<tbody>
<tr>
<td width="140">-b filename</td>
<td width="500">Block special file</td>
</tr>
<tr>
<td width="100">-c filename</td>
<td width="300">Special character file</td>
</tr>
<tr>
<td width="100">-d directoryname</td>
<td width="300">Check for directory existence</td>
</tr>
<tr>
<td width="100">-e filename</td>
<td width="300">Check for file existence</td>
</tr>
<tr>
<td width="100">-f filename</td>
<td width="300">Check for regular file existence not a directory</td>
</tr>
<tr>
<td width="100">-G filename</td>
<td width="300">Check if file exists and is owned by effective group ID.</td>
</tr>
<tr>
<td width="100">-g filename</td>
<td width="300">true if file exists and is set-group-id.</td>
</tr>
<tr>
<td width="100">-k filename</td>
<td width="300">Sticky bit</td>
</tr>
<tr>
<td width="100">-L filename</td>
<td width="300">Symbolic link</td>
</tr>
<tr>
<td width="100">-O filename</td>
<td width="300">True if file exists and is owned by the effective user id.</td>
</tr>
<tr>
<td width="100">-r filename</td>
<td width="300">Check if file is a readable</td>
</tr>
<tr>
<td width="100">-S filename</td>
<td width="300">Check if file is socket</td>
</tr>
<tr>
<td width="100">-s filename</td>
<td width="300">Check if file is nonzero size</td>
</tr>
<tr>
<td width="100">-u filename</td>
<td width="300">Check if file set-ser-id bit is set</td>
</tr>
<tr>
<td width="100">-w filename</td>
<td width="300">Check if file is writable</td>
</tr>
<tr>
<td width="100">-x filename</td>
<td width="300">Check if file is executable</td>
</tr>
</tbody>
</table>
The following script will check to see if a file exists or not.
#!/bin/bash
file="./file"
if [ -e $file ]; then
	echo "File exists"
else 
	echo "File does not exist"
fi 

The result:
$ ./filetesting.sh
File does not exist
$ touch file
$ ./filetesting.sh
File exists

Similarly for example we can use <code>while</code> loop to check if file does not exist. 
This script will sleep until file does exist. 
Note bash negator <code>!</code> which negates the <code>-e</code> option.
#!/bin/bash
while [ ! -e myfile ]; do
# Sleep until file does exists/is created
sleep 1
done

<h3 id="35Bashtopic-16">Loops</h3>
There are multiple types of loops that can be used in Bash, including <code>for</code>, <code>while</code>, and <code>until</code>. 
See some of the examples below to learn how to use.
<h3 id="35Bashtopic-17">Bash for loop</h3>
This script will list every file or directory it finds inside the <code>/var/</code> directory.
#!/bin/bash

# bash for loop
for f in $( ls /var/ ); do
	echo $f
done 

A <code>for</code> loop can also be run directly from the command line, no need for a script:
$ for f in $( ls /var/ ); do echo $f; done 

The result:
$ ./for_loop.sh
backups
cache
crash
lib
local
lock
log
mail
metrics
opt
run
snap
spool
tmp
<h3 id="35Bashtopic-18">Bash while loop</h3>
This <code>while</code> loop will continue to loop until our variable reaches a value of 0 or less.
#!/bin/bash
COUNT=6
# bash while loop
while [ $COUNT -gt 0 ]; do
	echo Value of count is: $COUNT
	let COUNT=COUNT-1
done

The result:
$ ./while_loop.sh
Value of count is: 6
Value of count is: 5
Value of count is: 4
Value of count is: 3
Value of count is: 2
Value of count is: 1

<h3 id="35Bashtopic-19">Bash until loop</h3>
An <code>until</code> loop works similarly to <code>while</code>.
#!/bin/bash
COUNT=0
# bash until loop
until [ $COUNT -gt 5 ]; do
        echo Value of count is: $COUNT
        let COUNT=COUNT+1
done

The result:
$ ./until_loop.sh
Value of count is: 0
Value of count is: 1
Value of count is: 2
Value of count is: 3
Value of count is: 4
Value of count is: 5

<h3 id="35Bashtopic-20">Control bash loop with input</h3>
Here is a example of <code>while</code> loop controlled by standard input. 
Until the redirection chain from STDOUT to STDIN to the <code>read</code> command exists the <code>while</code> loop continues.
#!/bin/bash
# This bash script will locate and replace spaces
# in the filenames
DIR="."
# Controlling a loop with bash read command by redirecting STDOUT as
# a STDIN to while loop
# find will not truncate filenames containing spaces
find $DIR -type f | while read file; do
# using POSIX class [:space:] to find space in the filename
if [[ "$file" = *[[:space:]]* ]]; then
# substitute space with "_" character and consequently rename the file
mv "$file" `echo $file | tr ' ' '_'`
fi;
# end of while loop
done

<h3 id="35Bashtopic-21">Bash Functions</h3>
This example shows how to declare a function and call back to it later in the script.
!/bin/bash
# BASH FUNCTIONS CAN BE DECLARED IN ANY ORDER
function function_B {
        echo Function B.
}
function function_A {
        echo $1
}
function function_D {
        echo Function D.
}
function function_C {
        echo $1
}
# FUNCTION CALLS
# Pass parameter to function A
function_A "Function A."
function_B
# Pass parameter to function C
function_C "Function C."
function_D

The result:

$ ./functions.sh
Function A.
Function B.
Function C.
Function D.

<h3 id="35Bashtopic-22">Bash Select</h3>
The <code>select</code> command allows us to prompt the user to make a selection.
#!/bin/bash
PS3='Choose one word: ' 

# bash select
select word in "linux" "bash" "scripting" "tutorial" 
do
  echo "The word you have selected is: $word"
# Break, otherwise endless loop
  break  
done

exit 0 

The result:
$ ./select.sh
1) linux
2) bash
3) scripting
4) tutorial
Choose one word: 2
The word you have selected is: bash

<h3 id="35Bashtopic-23">Case statement conditional</h3>
The <code>case</code> statement makes it easy to have many different possibilities, whereas an <code>if</code> statement can get lengthy very quickly if you have more than a few possibilities to account for.
#!/bin/bash
echo "What is your preferred programming / scripting language"
echo "1) bash"
echo "2) perl"
echo "3) phyton"
echo "4) c++"
echo "5) I do not know !"
read case;
#simple case bash structure
# note in this case $case is variable and does not have to
# be named case this is just an example
case $case in
    1) echo "You selected bash";;
    2) echo "You selected perl";;
    3) echo "You selected phyton";;
    4) echo "You selected c++";;
    5) exit
esac

The result:
$ ./case.sh 
What is your preferred programming / scripting language
1) bash
2) perl
3) phyton
4) c++
5) I do not know !
3
You selected phyton

<h3 id="35Bashtopic-24">Bash quotes and quotations</h3>
Quotations and quotes are important part of bash and bash scripting. 
Here are some bash quotes and quotations basics.
<h3 id="35Bashtopic-25">Escaping Meta characters</h3>
Before we start with quotes and quotations we should know something about escaping meta characters. 
Escaping will suppress a special meaning of meta characters and therefore meta characters will be read by bash literally. 
To do this we need to use backslash <code>\</code> character. 
Example:
#!/bin/bash
#Declare bash string variable
BASH_VAR="Bash Script"

# echo variable BASH_VAR
echo $BASH_VAR

#when meta character such us "$" is escaped with "\" it will be read literally
echo \$BASH_VAR 

# backslash has also special meaning and it can be suppressed with yet another "\"
echo "\\" 

Here's what it looks like when we execute the script:

$ ./escape_meta.sh
Bash Script
$BASH_VAR
\

<h3 id="35Bashtopic-26">Single quotes</h3>
Single quotes in bash will suppress special meaning of every meta characters. 
Therefore meta characters will be read literally. 
It is not possible to use another single quote within two single quotes not even if the single quote is escaped by backslash.
#!/bin/bash
# Declare bash string variable
BASH_VAR="Bash Script"
# echo variable BASH_VAR
echo $BASH_VAR
# meta characters special meaning in bash is suppressed when  using single quotes 
echo '$BASH_VAR  "$BASH_VAR"'

The result:
$ ./single_quotes.sh
Bash Script
$BASH_VAR "$BASH_VAR"

<h3 id="35Bashtopic-27">Double quotes</h3>
Double quotes in bash will suppress special meaning of every meta characters except <code>$</code>, <code>\</code> and <code>`</code>. 
Any other meta characters will be read literally. 
It is also possible to use single quote within double quotes. 
If we need to use double quotes within double quotes bash can read them literally when escaping them with <code>\</code>. 
Example:
#!/bin/bash
#Declare bash string variable
BASH_VAR="Bash Script"

# echo variable BASH_VAR
echo $BASH_VAR

# meta characters and its special meaning in bash is 
# suppressed when using double quotes except "$", "\" and "`"

echo "It's $BASH_VAR  and \"$BASH_VAR\" using backticks: `date`" 

The result:
$ ./double_quotes.sh
Bash Script
It's Bash Script and "Bash Script" using backticks: Thu 10 Feb 2022 10:24:15 PM EST

<h3 id="35Bashtopic-28">Bash quoting with ANSI-C style</h3>
There is also another type of quoting and that is ANSI-C. 
In this type of quoting characters escaped with <code>\</code> will gain special meaning according to the ANSI-C standard.
<table border="1">
<tbody>
<tr>
<td width="50">\a</td>
<td width="250">alert (bell)</td>
<td width="50">\b</td>
<td width="250">backspace</td>
</tr>
<tr>
<td width="50">\e</td>
<td width="250">an escape character</td>
<td width="50">\f</td>
<td width="250">form feed</td>
</tr>
<tr>
<td width="50">\n</td>
<td width="250">newline</td>
<td width="50">\r</td>
<td width="250">carriage return</td>
</tr>
<tr>
<td width="50">\t</td>
<td width="250">horizontal tab</td>
<td width="50">\v</td>
<td width="250">vertical tab</td>
</tr>
<tr>
<td width="50">\\</td>
<td width="250">backslash</td>
<td width="50">\`</td>
<td width="250">single quote</td>
</tr>
<tr>
<td width="50">\nnn</td>
<td width="250">octal value of characters ( see [http://www.asciitable.com/ ASCII table] )</td>
<td width="50">\xnn</td>
<td width="250">hexadecimal value of characters ( see [http://www.asciitable.com/ ASCII table] )</td>
</tr>
</tbody>
</table>
The syntax for ansi-c bash quoting is: <code>$' '</code> . 
Here is an example:
#!/bin/bash
# as a example we have used \n as a new line, \x40 is hex value for @
# and \56 is octal value for .
echo $'web: www.linuxconfig.org\nemail: web\x40linuxconfig\56org' 

The result:
$ ./bash_ansi-c.sh
web: www.linuxconfig.org
email: web@linuxconfig.org
<h3 id="35Bashtopic-29">Arithmetic Operations</h3>
Bash can be used to perform calculations. 
Let's look at a few examples to see how it's done.
<h3 id="35Bashtopic-30">Bash Addition Calculator Example</h3>
#!/bin/bash
let RESULT1=$1+$2
echo $1+$2=$RESULT1 ' -&gt; # let RESULT1=$1+$2'
declare -i RESULT2
RESULT2=$1+$2
echo $1+$2=$RESULT2 ' -&gt; # declare -i RESULT2; RESULT2=$1+$2'
echo $1+$2=$(($1 + $2)) ' -&gt; # $(($1 + $2))' 

The result:
$ ./bash_addition_calc.sh 88 12
88+12=100  -&gt; # let RESULT1=$1+$2
88+12=100  -&gt; # declare -i RESULT2; RESULT2=$1+$2
88+12=100  -&gt; # $(($1 + $2))

<h3 id="35Bashtopic-31">Bash Arithmetics</h3>
Let's see how to do some basic Bash aritmetics such as addition, subtraction, multiplication, division, etc.
#!/bin/bash
echo '### let ###'
# bash addition
let ADDITION=3+5
echo "3 + 5 =" $ADDITION

# bash subtraction
let SUBTRACTION=7-8
echo "7 - 8 =" $SUBTRACTION 

# bash multiplication
let MULTIPLICATION=5*8
echo "5 * 8 =" $MULTIPLICATION

# bash division
let DIVISION=4/2
echo "4 / 2 =" $DIVISION

# bash modulus
let MODULUS=9%4
echo "9 % 4 =" $MODULUS

# bash power of two
let POWEROFTWO=2**2
echo "2 ^ 2 =" $POWEROFTWO
echo '### Bash Arithmetic Expansion ###'
# There are two formats for arithmetic expansion: $[ expression ] 
# and $(( expression #)) its your choice which you use

echo 4 + 5 = $((4 + 5))
echo 7 - 7 = $[ 7 - 7 ]
echo 4 x 6 = $((3 * 2))
echo 6 / 3 = $((6 / 3))
echo 8 % 7 = $((8 % 7))
echo 2 ^ 8 = $[ 2 ** 8 ]
echo '### Declare ###'

echo -e "Please enter two numbers \c"
# read user input
read num1 num2
declare -i result
result=$num1+$num2
echo "Result is:$result "

# bash convert binary number 10001
result=2#10001
echo $result

# bash convert octal number 16
result=8#16
echo $result

# bash convert hex number 0xE6A
result=16#E6A
echo $result 

The result:
$ ./arithmetic_operations.sh 
### let ###
3 + 5 = 8
7 - 8 = -1
5 * 8 = 40
4 / 2 = 2
9 % 4 = 1
2 ^ 2 = 4
### Bash Arithmetic Expansion ###
4 + 5 = 9
7 - 7 = 0
4 x 6 = 6
6 / 3 = 2
8 % 7 = 1
2 ^ 8 = 256
### Declare ###
Please enter two numbers 23 45
Result is:68 
17
14
3690

<h3 id="35Bashtopic-32">Round floating point number</h3>
Here is how to use rounding in Bash calculations.

#!/bin/bash
# get floating point number
floating_point_number=3.3446
echo $floating_point_number
# round floating point number with bash
for bash_rounded_number in $(printf %.0f $floating_point_number); do
echo "Rounded number with bash:" $bash_rounded_number
done 

The result:
$ ./round.sh
3.3446
Rounded number with bash: 3

<h3 id="35Bashtopic-33">Bash floating point calculations</h3>
Using the <code>bc</code> bash calculator to perform floating point calculations.
#!/bin/bash
# Simple linux bash calculator 
echo "Enter input:" 
read userinput
echo "Result with 2 digits after decimal point:"
echo "scale=2; ${userinput}" | bc 
echo "Result with 10 digits after decimal point:"
echo "scale=10; ${userinput}" | bc 
echo "Result as rounded integer:"
echo $userinput | bc 

The result:
$ ./simple_bash_calc.sh
Enter input:
10/3.4
Result with 2 digits after decimal point:
2.94
Result with 10 digits after decimal point:
2.9411764705
Result as rounded integer:
2

<h3 id="35Bashtopic-34">Redirections</h3>
In the following examples, we will show how to redirect standard error and standard output.
<h3 id="35Bashtopic-35">STDOUT from bash script to STDERR</h3>
#!/bin/bash
echo "Redirect this STDOUT to STDERR" 1&gt;&amp;2 

To prove that STDOUT is redirected to STDERR we can redirect script’s output to file:
$ ./redirecting.sh
Redirect this STDOUT to STDERR
$ ./redirecting.sh &gt; STDOUT.txt
$ cat STDOUT.txt
$ 
$ ./redirecting.sh 2&gt; STDERR.txt
$ cat STDERR.txt
Redirect this STDOUT to STDERR

<h3 id="35Bashtopic-36">STDERR from bash script to STDOUT</h3>
#!/bin/bash
cat $1 2&gt;&amp;1

To prove that STDERR is redirected to STDOUT we can redirect script’s output to file:
$ ./redirecting.sh /etc/shadow
cat: /etc/shadow: Permission denied
$ ./redirecting.sh /etc/shadow &gt; STDOUT.txt
$ cat STDOUT.txt
cat: /etc/shadow: Permission denied
$ ./redirecting.sh /etc/shadow 2&gt; STDERR.txt
cat: /etc/shadow: Permission denied
$ cat STDERR.txt
$ 

<h3 id="35Bashtopic-37">stdout to screen</h3>
The simple way to redirect a standard output (stdout) is to simply use any command, because by default stdout is automatically redirected to screen. 
First create a file <code>file1</code>:
$ touch file1
$ ls file1 
file1

As you can see from the example above execution of <code>ls</code> command produces STDOUT which by default is redirected to screen.
<h3 id="35Bashtopic-38">stdout to file</h3>
To override the default behavior of STDOUT we can use <code>&gt;</code> to redirect this output to file:

$ ls file1 &gt; STDOUT
$ cat STDOUT 
file1

<h3 id="35Bashtopic-39">stderr to file</h3>
By default STDERR is displayed on the screen:
$ ls
file1  STDOUT
$ ls file2
ls: cannot access file2: No such file or directory

In the following example we will redirect the standard error (stderr) to a file and stdout to a screen as default. 
Please note that STDOUT is displayed on the screen, however STDERR is redirected to a file called STDERR:
$ ls
file1  STDOUT
$ ls file1 file2 2&gt; STDERR
file1
$ cat STDERR 
ls: cannot access file2: No such file or directory

<h3 id="35Bashtopic-40">stdout to stderr</h3>
It is also possible to redirect STDOUT and STDERR to the same file. 
In the next example we will redirect STDOUT to the same descriptor as STDERR. 
Both STDOUT and STDERR will be redirected to file “STDERR_STDOUT”.
$ ls
file1  STDERR  STDOUT
$ ls file1 file2 2&gt; STDERR_STDOUT 1&gt;&amp;2
$ cat STDERR_STDOUT
ls: cannot access file2: No such file or directory
file1

File STDERR_STDOUT now contains STDOUT and STDERR.
<h3 id="35Bashtopic-41">stderr to stdout</h3>
The above example can be reversed by redirecting STDERR to the same descriptor as SDTOUT:
$ ls
file1  STDERR  STDOUT
$ ls file1 file2 &gt; STDERR_STDOUT 2&gt;&amp;1
$ cat STDERR_STDOUT 
ls: cannot access file2: No such file or directory
file1

<h3 id="35Bashtopic-42">stderr and stdout to file</h3>
Previous two examples redirected both STDOUT and STDERR to a file. 
Another way to achieve the same effect is illustrated below:
$ ls
file1  STDERR  STDOUT
$ ls file1 file2 &amp;&gt; STDERR_STDOUT
$ cat STDERR_STDOUT 
ls: cannot access file2: No such file or directory
file1

or
ls file1 file2 &gt;&amp; STDERR_STDOUT
$ cat STDERR_STDOUT 
ls: cannot access file2: No such file or directory
file1

<h3 id="35Bashtopic-43">Closing Thoughts</h3>

In this Bash scripting tutorial, we learned how to get started with Bash scripting by learning all the basics of the most common aspects, such as loops, arithmetic, comparisons, etc. 
This guide has served as an introduction to Bash scripting concepts, and given you some insight into how the Bash shell works. 
By adapting our examples for your own needs and expanding them as needed, you will be well on your way to mastering Bash scripting.

<h2>25 basic Ubuntu Commands</h2>
There are several releases of Ubuntu, such as stable release, Long Term Support (LTS), and unstable. 
The stable and unstable releases are launched every year in April and October, respectively, whereas the long-term support variant is released after two years and is available for the next five years. 

Ubuntu supports both Command Line Interface (CLI) and Graphical User Interface (GUI) to perform various tasks on the OS. 
CLI is the basic way to interact with systems hardware (processor/memory); you can perform all the tasks that GUI can perform. 
In this article, we will demonstrate the use of 25 basic commands that provide ease to execute various tasks of Ubuntu using CLI. 

<h2>Command: pwd</h2>
This command refers to the present working directory in which you are operating; in simpler words, in which your terminal is open. 
To check PWD, execute the pwd keyword in your terminal and hit enter; the command of PWD is written below along with the result of that command.

$ pwd
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-1.png" />
<h2>Command: dir</h2>
The dir command is used to print (on the terminal) all the available directories in the present working directory:
$ dir
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-2.png" />

<h2>Command: ls</h2>
This command is used to list down all the directories and files inside the present working directory (or you can give the path of a specific directory); the ls command can be executed as shown below:
$ ls

<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-3.png" />
The ls command supports various flags, and each flag has some specific role in printing the directories or files of the current working directory. 
To print the detailed information of the files/directories; the “<b>-al</b>” flag is used with the “<b>ls</b>” command:

$ ls -al
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-4.png" />
The “<b>-R</b>” flag will print subdirectories of a directory as well:

$ ls -R
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-5.png" />
Moreover, to get the hidden files, “<b>-a</b>” flag is used:

$ ls -a
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-6.png" />
<h2>Command: cd</h2>
One of the most used commands of Ubuntu; you can change the directories in the terminal using the “cd” command. 
For instance, the following command will change the pwd to desktop.
$ cd Desktop

<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-7.png" />
There are multiple uses of this command: one can change the present directory to root directory or home directory using this command. 
When you open a fresh terminal, you are in the home directory.

To change directory to root. 
For instance, we are in the Desktop directory and want to switch to the root directory:
$ cd /

<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-8.png" />
To change the present directory to the home directory:
$ cd

<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-9.png" />
<h2>Command: touch</h2>
This Ubuntu command can be used to create a new file as well one can use it to change the timestamp of any file; the command given below will create a new text time in pwd:

$ touch file1.txt
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-10.png" />
If we execute a touch command to create a file, but the file is already created, then it would change the timestamp of that file to the current time; for instance, the command given below will change the timestamp of the file1.txt. 

you can check that the timestamp has been changed to the current time:
$ touch file1.txt
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-11.png" />

<h2>Command: cat</h2>
This command is used to show the content of any file: For instance, the following command will display the content inside “f<b>ile1.txt</b>”:
$ cat file1.txt

<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-12.png" />
Or you can use this command to save the content of multiples files to one file:
$ cat file1.txt file2.txt &gt; output.txt

<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-13.png" />
<h2>Command: mkdir</h2>
The above-mentioned command will make a directory in your pwd; for example, the following command will make the directory “<b>new</b>” in pwd.

$ mkdir new
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-14.png" />
<h2>Command: rm</h2>
This remove command is used to remove the specific file from a directory; For instance, below mentioned command would remove the “<b>test.txt</b>” file from the pwd:
$ rm test.txt
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-15.png" />

Or you can remove the empty directory, as the command given below will remove the “<b>test</b>” directory:
$ rmdir test
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-16.png" />

<h2>Command: cp</h2>
The cp command will help you to copy any file or folder to any directory;
To copy a file to directory1:

$ cp file1.txt directory1
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-17.png" />
If you want to copy the complete folder, then;

$ cp new -r directory1
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-18.png" />
<h2>Command: mv </h2>
You can use this command to move files around the computer, and you can also rename files or directories inside a specific directory: the command given below will move the “<b>file2.txt</b>” to “<b>directory1</b>”:
$ mv file2.txt directory1
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-19.png" />

Moreover, the command given below will move the “<b>test1</b>” directory to “<b>directory1</b>”:
$ mv test1 directory1
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-20.png" />

<h2>Command: head</h2>
This command helps you to get the first ten lines of a text file; for instance, the following command will help to get the first ten lines of the “<b>file1.text</b>” file:
$ head file1.txt

<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-21.png" />
<h2>Command: tail</h2>
The tail command is used to get the last ten lines of the text file; the command below will print the ten lines from the bottom of “<b>file1.txt</b>”:

$ tail file1.txt
<h2>Command: uname</h2>
You can use the command to get the release number, version of Linux, and much more. 

The “<b>-a</b>” flag is used to get detailed information.
$ uname -a
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-23.png" />

<h2>Command: wget</h2>
You can use the wget command to download the content from the internet; for instance, the following command will download VirtualBox.
$ wget https://download.virtualbox.org/virtualbox/6.1.26/VirtualBox-6.1.26-145957-Win.exe

<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-24.png" />
<h2>Command: apt-get or -apt</h2>
This is one of the most important and most used commands of Ubuntu that works with Ubuntu Advanced Packaging Tool (APT); you can use this “<b>-apt-get</b>” or “<b>-apt</b>” to install or remove packages, or you can perform other maintenance tasks. 

The “<b>apt</b>” requires sudo privileges to successfully execute the command.
The syntax stated below will help you to install the required package:
$ sudo apt install &#91;packagename&#93;

For install to install vlc media player package use:
$ sudo apt install vlc
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-25.png" />

Or you can remove the package by executing the command given below:
$ sudo apt remove &#91;packagename&#93;
And to delete vlc media player package:

<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-26.png" />
<h2>Command: history</h2>
The history command shows the list of commands (with numeric numbers) executed:

$ history
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-27.png" />
And you can execute any of the listed commands. 

For instance, if you want to execute the 2nd command (which is apt update command), then you have to write “<b>!2</b>” to get the result of that command:
$ !2
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-28.png" />

<h2>Command: grep</h2>
With the help of grep, you can search for a pattern in which a specific word lies; for instance, the command given below will print all the lines that contain “<b>20</b>” from “<b>file1.txt</b>”:
$ cat file1.txt | grep 20

<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-29.png" />
<h2>Command: man </h2>
The man command will help you to get the complete user manual of any specific command; for instance, the following command will list down the detailed usage of the “<b>cat</b>” command:

$ man cat
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-30.png" />
<h2>Command: ps</h2>
Using the <b>-ps</b> command, you will be able to get the list of processes.
$ ps
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-31.png" />

<h2>Command: zip or unzip</h2>
To convert your files to zip archive; you can get help by using the “<b>gzip</b>” command; moreover, a zipped file can be unzipped using the “<b>gunzip</b>” command:
$ gzip file1.txt

<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-32.png" />
You can unzip the “<b>file1.txt</b>” as shown below:
$ gunzip file1.txt

<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-33.png" />
<h2>Command: hostname </h2>
This command will print your hostname on the terminal:

$ hostname
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-34.png" />
<h2>Command: ping</h2>
You can use the ping command to check the connectivity to your server; for example, the command below will ping to YouTube and also prints the response time:
$ ping youtube.com
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-35.png" />

<h2>Command: w</h2>
This command will display the user details that are currently logged into the system:
$ w

<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-36.png" />
<h2>Command: useradd</h2>
Ubuntu supports multiuser access; if you want to add another user to your system, execute the following command to do so:

$ sudo useradd MIKE
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-37.png" />
Or you can delete the user also;

$ sudo userdel MIKE
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-38.png" />
<h2>Command: passwd</h2>
With the help of the passwd command, you can change the password of your Ubuntu user:
You must pass “<b>username</b>” to “<b>passwd</b>” to change the password of that; for example, the command given below will change the password of user “<b>adnan</b>”.
$ passwd adnan

<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-39.png" />



<h2>Basic Ubuntu Commands for Beginner:</h2>
<h3>1. sudo</h3>
<b>sudo</b> (SuperUser DO) Linux command allows you to run programs or other commands with administrative privileges, just like “Run as administrator” in Windows.
This is useful when, for example, you need to modify files in a directory that your user wouldn’t normally have access to.

<h3>2. apt-get</h3>
<b>apt-get</b> is the one of the most important Ubuntu commands every beginner must know.
It is used to install, update, upgrade and remove any package.
apt-get basically works on a database of available packages.
Here is the list of different apt-get commands:

<h4> 1.
sudo apt-get update </h4>
apt-get update with&nbsp;super user privileges is the first command you need to run in any Linux system after a fresh install.
This command updates the database and let your system know if there are newer packages available or not.
<img class="lazy" data-src="https://tl360.b-cdn.net/wp-content/uploads/2019/07/sudo-apt-get-update-Basic-Ubuntu-Commands.png">

<h4>2. sudo apt-get upgrade </h4>
After updating the package database, next step is to to upgrade the installed packages.
For upgrading all the packages with available updates you can use this command.

And if you like to upgrade a particular package, you should tweak the above command a little:
sudo apt-get upgrade &lt;package-name&gt;

Replace the <em>&lt;package-name&gt;</em> with your desired package.

<img class="lazy" data-src="https://tl360.b-cdn.net/wp-content/uploads/2019/07/sudo-apt-get-upgrade-Basic-Ubuntu-Commands.png">

<h4>3. sudo apt-get install </h4>
If you know the name of the package, then you can easily install a program using this command:
sudo apt-get install &lt;package-name&gt;

Replace the <em>&lt;package-name&gt;</em> with your desired package.
<img class="lazy" data-src="https://tl360.b-cdn.net/wp-content/uploads/2019/07/sudo-apt-get-install-Basic-Ubuntu-Commands.png">

If you are not sure about the package name, you can type a few letters and press tab and it will suggest all the packages available with those letters.
Thanks for auto-completion feature.

<h4>4. sudo apt-get remove</h4>
When it comes to removing the installed program apt-get remove command suits your need.
You only have to know the exact package name of the software you want to uninstall.

If you don&#8217;t know the package name, use below ubuntu basic command to list all the packages installed on your system and then copy the package name from the list:
dpkg --list

Now run the <em>apt-get remove</em> command as sudo in order to remove the software:

sudo apt-get remove &lt;package-name&gt;

Replace the <em>&lt;package-name&gt;</em> with the one you copied from the dpkg list.
<img class="lazy" data-src="https://tl360.b-cdn.net/wp-content/uploads/2019/07/sudo-apt-get-remove-Basic-Ubuntu-Commands.png">

apt-get remove command only removes the software from your system but not the configuration or data files of the package.
These files help in keeping the same settings when you want to reinstall the same software.

<h4>5. sudo apt-get purge</h4>
apt-get purge command is used when you want to remove a software completely from your system with its configuration or data files so that no longer personalized settings will be available during reinstallation.

Run the <em>apt-get purge</em> command as sudo in order to remove the software completely:
sudo apt-get purge &lt;package-name&gt;

Replace the <em>&lt;package-name&gt;</em> with the application that you want to remove or copied from the dpkg list.
<img class="lazy" data-src="https://tl360.b-cdn.net/wp-content/uploads/2019/07/sudo-apt-get-purge-Basic-Ubuntu-Commands.png">

<h4>6. sudo apt-get autoremove</h4>
apt-get autoremove command is used to remove any unnecessary packages.
Unnecessary means, whenever you install an application, the system will also install the software that this application depends on.
It is common in Ubuntu that applications share the same libraries.
When you remove the application the dependency will stay on your system.

So run <em>apt-get autoremove</em> as sudo after uninstalling a package to remove unwanted software dependencies.
<img class="lazy" data-src="https://tl360.b-cdn.net/wp-content/uploads/2019/07/sudo-apt-get-autoremove-Basic-Ubuntu-Commands.png">

So apt-get autoremove will remove those dependencies that were installed with applications and that are no longer used by anything else on the system.

<h3>3. ls</h3>
<b>ls</b> (list) command lists all files and folders in your current working directory.
You can also specify paths to other directories if you want to view their contents.

<h3>4. cd</h3>
<b>cd</b> (change director”) Linux command also known as chdir used to change the current working directory.
It&#8217;s one of the most used basic Ubuntu commands.
Using this command is easy, just type cd followed by the the folder name.
You can use full paths to folders or simply the name of a folder within the directory you are currently working.
Some common uses are:
<ul><li>cd /&nbsp; – Takes you to the root directory.</li><li>cd ..
– Takes you up one directory level.</li><li>cd –&nbsp; – Takes you to the previous directory.</li></ul>
Here are some examples to how to use cd command in Ubuntu:

Example 1: <em><b>cd home</b></em> – open home folder in current directory.

Example 2: <b><em>cd Linux\ Drive</em></b> – open Linux Drive named folder in directory.
Here you can see I use backslash because the folder name has spaces so <em>for each space you use &#8220;backslash+space&#8221;</em>.
Like, if your folder name is &#8220;am a programmer&#8221; then the cd command will be, &#8220;cd am\ a\ programmer&#8221;.
<img class="lazy" data-src="https://tl360.b-cdn.net/wp-content/uploads/2019/07/cd-Basic-Ubuntu-Commands.jpg">

<h3>5. pwd</h3>
<b>pwd</b> (print working directory) Ubuntu command displays the full pathname of the current working directory.

<h3>6. cp</h3>
<b>cp</b> (copy) Linux command allows you to copy a file.
You should specify both the file you want to be copied and the location you want it copied to – f<em>or example, cp </em>xyz<em> /home/</em>myfiles<em> would copy the file “</em>xyz<em>” to the directory “/home/</em>myfiles<em>”</em>.

<h3>7. mv</h3>
<b>mv</b> (move) command allows you to move files.
You can also rename files by moving them to the directory they are currently in, but under a new name.
The usage is the same as cp – f<em>or example mv </em>xyz<em> /home/</em>myfiles<em> would move the file “</em>xyz<em>” to the directory “/home/</em>myfiles<em>”</em>.

<h3>8. rm</h3>
<b>rm</b> (remove) command removes the specified file.

<ul><li>rmdir (“remove directory”) – Removes an empty directory.</li><li>rm -r (“remove recursively”) – Removes a directory along with its content.</li></ul>
<h3>9. mkdir</h3>
<b>mkdir</b> (make directory) command allows you to create a new directory.
You can specify where you want the directory created – if you do not do so, it will be created in your current working directory.

<h3>10. history</h3>
<b>history</b> command displays all of your previous commands up to the history limit.
<img class="lazy" data-src="https://tl360.b-cdn.net/wp-content/uploads/2019/07/history-Basic-Ubuntu-Commands.jpg">

<h3>11. df</h3>
<b>df</b> (display filesystem) command displays information about the disk space usage of all mounted filesystems.
<img class="lazy" data-src="https://tl360.b-cdn.net/wp-content/uploads/2019/07/df-Basic-Ubuntu-Commands.jpg">

<h3>12. du</h3>
<b>du</b> (directory usage) command displays the size of a directory and all of its subdirectories.

<h3>13. free</h3>
<b>free</b> – Displays the amount of free space available on the system.

<h3>14. uname -a</h3>
<b>uname -a</b> – Provides a wide range of basic information about the system.

<h3>15. top</h3>
<b>top</b> – Displays the processes using the most system resources at any given time.
“q” can be used to exit.

<h3>16. man</h3>
<b>man</b> command displays a “manual page”.
Manual pages are usually very detailed, and it’s recommended that you read the man pages for any command you are unfamiliar with.
Some uses are :
<ul><li>man man – Provides information about the manual itself.</li><li>man intro – Displays a brief introduction to Linux commands.</li></ul>
<h3>17. info</h3>
Similar to man, but often provides more detailed or precise information.

<h3>18. &lt;command name&gt; -h or &lt;command name&gt; –help</h3>
This command is a third alternative to get help.
While not as detailed as the info or man pages, this will provide a quick overview of the command and its uses.

For example: <em>man -h</em> or <em>man -help</em>

<h3>19. passwd</h3>
passwd Ubuntu basic command is used to change user password using Terminal.
What you have to do is run the below command, where is the username whose password has to change:
passwd &lt;user&gt;

<h3>20. whatis</h3>
whatis command shows a brief description of what is the functionality of specific built-in Linux command.

whatis &lt;command&gt;

Some examples are:
<ul><li>whatis cd</li><li>whatis man</li><li>whatis help</li></ul>
Above commands will display the purpose of cd, man and help commands.

<h2>Ubuntu Terminal Shortcuts:</h2>
To further ease up your skill, these Ubuntu Terminal keyboard shortcuts would help.
<table><tbody><tr><th>Ubuntu Terminal Shortcuts</th><th>Function</th></tr><tr><td>Ctrl + Shift + T</td><td>Open new tab on current terminal</td></tr><tr><td>Ctrl + Shift + W</td><td>Close the current tab</td></tr><tr><td>Ctrl + A</td><td>Move cursor to beginning of line</td></tr><tr><td>Ctrl + E</td><td>Move cursor to end of line</td></tr><tr><td>Ctrl + U</td><td>Clears the entire current line</td></tr><tr><td>Ctrl + K</td><td>Clears the command from the cursor right</td></tr><tr><td>Ctrl + W</td><td>Delete the word before the cursor</td></tr><tr><td>Ctrl + R</td><td>Allows you to search your history for commands matching what you have typed</td></tr><tr><td>Ctrl + C</td><td>Kill the current process</td></tr><tr><td>Ctrl + Z</td><td>Suspend the current process by sending the signal SIGSTOP</td></tr><tr><td>Ctrl + L</td><td>Clears the terminal output</td></tr><tr><td>Alt + F</td><td>Move forward one word</td></tr><tr><td>Alt + B</td><td>Move backward one word</td></tr><tr><td>Ctrl + Shift + C</td><td>Copy the highlighted command to the clipboard</td></tr><tr><td>Ctrl + Shift + V or Shift + Insert</td><td>Paste the contents of the clipboard</td></tr><tr><td>Up/Down Arrow keys</td><td>To scroll through your command history, allowing you to quickly execute the same command multiple times</td></tr><tr><td>TAB</td><td>Used to complete the command you are typing.
If more than one command is possible, you can press it multiple times to scroll through the possible completions.
If a very wide number of commands are possible, it can output a list of all possible completions.</td></tr></tbody></table>

<h1>Troubleshooting in Windows Terminal</h1>
<h2>Opening the settings does nothing (or opens an unexpected application)</h2>
If you click on the "settings" button in the dropdown, the Terminal will attempt to open the settings file, <code>settings.json</code>. 
This will cause the OS to try and launch your configured <code>.json</code> file editor. 
This might be Visual Studio, or Notepad, or some other completely unexpected application. 
If there isn't a configured <code>.json</code> editor on your machine, then the OS will eventually show you the "How do you want to open this file" dialog.

Tip
You can also use the settings UI to configure your settings if you are using Windows Terminal Preview. 
You can learn how to open the settings UI on the Actions page.

<h2>Set your WSL distribution to start in the home <code>~</code> directory when launched in older versions of Windows Terminal</h2>
By default, the <code>startingDirectory</code> of a profile is <code>%USERPROFILE%</code> (<code>C:\Users\&lt;YourUsername&gt;</code>). 
This is a Windows path. 
For WSL distributions running a new version of Windows Terminal, the file systems can enter <code>~</code> to set this home path. 
In older versions of Windows Terminal, you can use <code>/home/&lt;Your Ubuntu Username&gt;</code> to directly refer to your home folder. 
For example, the following setting will launch the "Ubuntu-20.04" distribution in its home file path:
<code>{
    "name": "Ubuntu-20.04",
    "commandline" : "wsl -d Ubuntu-20.04",
    "startingDirectory" : "/home/&lt;Your Ubuntu Username&gt;"
}</code>

If you are using a very early version of Windows Terminal, WSL may require using the <code>\\wsl$\</code> prefix when referring to a distribution's home path for the <code>startingDirectory</code> setting. 
For example, the following setting will launch the "Ubuntu-18.04" distribution in its home file path:
<code>{
    "name": "Ubuntu-18.04",
    "commandline" : "wsl -d Ubuntu-18.04",
    "startingDirectory" : "//wsl$/Ubuntu-18.04/home/&lt;Your Ubuntu Username&gt;"
}</code>

Important
On newer versions of Windows, <code>startingDirectory</code> can accept Linux-style paths.

<h2>Setting the tab title</h2>
To have the shell automatically set your tab title, visit the set the tab title tutorial. 
If you want to set your own tab title, open the settings.json file and follow these steps:

In the profile for the command line of your choice, add <code>"suppressApplicationTitle": true</code> to suppress any title change events that get sent from the shell. 
Adding <em>only</em> this setting to your profile will set the tab title to the name of your profile.

If you want a custom tab title that is not the name of your profile, add <code>"tabTitle": "TITLE"</code>. 
Replacing "TITLE" with your preferred tab title.

<h2>Command line arguments in PowerShell</h2>
Visit the Command line arguments page to learn how command-line arguments operate in PowerShell.
<h2>Command line arguments in WSL</h2>
Visit the Command line arguments page to learn how command-line arguments operate in WSL.
<h2>Problem setting <code>startingDirectory</code></h2>
If the <code>startingDirectory</code> is being ignored in your profile, first check to make sure the syntax is correct in your settings.json file. 
To help you check this syntax, <code>"$schema": "https://aka.ms/terminal-profiles-schema"</code> is automatically injected. 
Some applications, like Visual Studio Code, can use that injected schema to validate your json file as you make edits.
If your settings are correct, you may be running a startup script that sets the starting directory of your terminal separately. 
For example, PowerShell has its own separate concept of profiles. 
If you are changing your starting directory there, it will take precedence over the setting defined in Windows Terminal.
Alternatively, if you are running a script using the <code>commandline</code> profile setting, it may be that you are setting the location there. 
Similar to PowerShell profiles, your commands there take precedence over the <code>startingDirectory</code> profile setting.
The purpose of <code>startingDirectory</code> is to launch a new Windows Terminal instance in the given directory. 
If the terminal runs any code that changes its directory, that may be a good place to take a look.
<h2>Ctrl+= does not increase the font size</h2>
If you are using a German keyboard layout, you may run into this problem. 
<kbd>ctrl+=</kbd> gets deserialized as <kbd>ctrl+shift+0</kbd> if your main keyboard layout is set to German. 
This is the correct mapping for German keyboards.
More importantly, the app never receives the <kbd>ctrl+shift+0</kbd> keystroke. 
This is because <kbd>ctrl+shift+0</kbd> is reserved by Windows if you have multiple keyboard layouts active.
If you would like to disable this feature in order for <code>Ctrl+=</code> to work properly, follow the instructions for "Change Hotkeys to Switch Keyboard Layout in Windows 10" in this blog post.
Change the 'Switch Keyboard Layout' option to 'Not Assigned' (or off of <kbd>ctrl+shift</kbd>), then select <strong>OK</strong> and then <strong>Apply</strong>. 
<kbd>ctrl+shift+0</kbd> should now work as a key binding and is passed through to the terminal.
On the other hand, if you do use this hotkey feature for multiple input languages, you can configure your own custom key binding in your settings.json file.
<h2>The text is blurry</h2>
Some display drivers and hardware combinations do not handle scroll and/or dirty regions without blurring the data from the previous frame. 
To mitigate this problem, you can add a combination of these global rendering settings to reduce the strain placed on your hardware caused by the terminal text renderer.
<h2>My colors look strange! There are black bars on my screen!</h2>

Important
This applies only to version 1.2+ of Windows Terminal. 
If you are seeing color issues in Windows Terminal 1.0 or 1.1, or issues that are not captured here, please file a bug.

Windows Terminal 1.2 and beyond has an improved understanding of certain application color settings. 
Because of this improved understanding, we have been able to remove a number of compatibility blocks that resulted in a poor user experience. 
Unfortunately, there is a small number of applications that may experience issues.
We will keep this troubleshooting item up-to-date with the list of known issues and their workarounds.
<h3>Black lines in PowerShell (5.1, 6.x, 7.0)</h3>
Terminal, when coupled with PowerShell's line editing library PSReadline, may draw black lines across the screen. 
These miscolored regions will extend across the screen beyond your prompt wherever there are command parameters, strings or operators.
PSReadline version <strong>2.0.3</strong> has been released and contains a fix for this issue. 
If you are using the prerelease version of PSReadline, note that a fix is not yet available.
To update to the newest version of PSReadline, please run the following command:
<code>Update-Module PSReadline</code>

<h2>Why are my emojis not appearing as icons in the jumplist?</h2>
Only images linked from a file location can be rendered as profile icons in the jumplist. 
Emojis are not supported for jumplist icons.
<h2>Technical Notes</h2>
Applications that use the <code>GetConsoleScreenBufferInfo</code> family of APIs to retrieve the active console colors in Win32 format and then attempt to transform them into cross-platform VT sequences (for example, by transforming <code>BACKGROUND_RED</code> to <code>\x1b[41m</code>) may interfere with Terminal's ability to detect what background color the application is attempting to use.
Application developers are encouraged to choose either Windows API functions <em>or</em> VT sequences for adjusting colors and not attempt to mix them.
<h3>Keyboard service warning</h3>
Starting in Windows Terminal 1.5, the Terminal will display a warning if the "Touch Keyboard and Handwriting Panel Service" is disabled. 
This service is needed by the operating system to properly route input events to the Terminal application (as well as many other applications on Windows). 
If you see this warning, you can follow these steps to re-enable the service:

In the run dialog, run <code>services.msc</code>
<img src="https://user-images.githubusercontent.com/18356694/97891741-c81eed00-1cf4-11eb-9d48-7b94fede5294.png">

Find the "Touch Keyboard and Handwriting Panel Service"
<img src="https://user-images.githubusercontent.com/18356694/97891813-e1279e00-1cf4-11eb-91c8-69a5c6da6c3d.png">

Open the "Properties" for this service
<img src="https://user-images.githubusercontent.com/18356694/97891923-03212080-1cf5-11eb-90cc-821a4fbf16ba.png">

Change the "startup type" to "Automatic"
<img src="https://user-images.githubusercontent.com/18356694/97892043-25b33980-1cf5-11eb-8833-a2e65a306a79.png">

Hit "Ok", and restart the PC.

After restarting the machine, the service should auto-start, and the dialog should no longer appear.
<h2>Why do I see blinking or flashing when using a git bash command line?</h2>
You may notice a blinking or flashing when using a git bash command line inside Windows Terminal. 
This behavior is actually by design. 
The Terminal is obeying what git bash is telling it to do (setting bell-style to visible, causing a flash to associate with the bell response), BUT we understand this may be distracting. 
To fix this, open the <code>.inputrc</code> file for your Git bash with a text editor. 
This file will likely be located in the path <code>C:\Program Files\Git\etc</code>. 
To open with the Nano text editor: <code>nano ~/.inputrc</code>
Change the default:
<code># none, visible or audible
set bell-style visible</code>

Set the bell-style to either <code>none</code> or <code>audible</code> to remove the visible flash:
<code>set bell-style none</code>

Press Ctrl + O and Ctrl + X to Save and Exit.
<h2>How do I reset my settings in Windows Terminal back to the default settings?</h2>
To reset your settings back to the original default settings, delete your settings.json file. 
This will cause Windows Terminal to regenerate a settings.json file with the original default settings.

Important
As of Windows Terminal version 1.10 or greater, you'll also need to delete the <code>state.json</code> file in the same directory as the <code>settings.json</code> file to fully reset the settings to the defaults.

<h2>Why is Acrylic opacity not making my Windows Terminal background transparent?</h2>
You can set the transparency of a terminal window with the <code>useAcrylic</code> property. 
There are a few reasons why your opacity setting may not be working for Acrylic, including:
<ul>
As a system-wide policy, acrylic is only enabled for the foreground window. 
So if you activate any other window than the Terminal, the Terminal's acrylic will turn off.
Acrylic doesn't work if your GPU hardware does not support it. 
If you're running an app in a Virtual Machine (VM) or over remote desktop, acrylic likely will not work.
Acrylic can be disabled by the operating system for a number of reasons, like being in power saver (low-battery) mode or when accessing a machine using Remote Desktop.

<h2>Why does my mouse pointer disappear when hovering over a window and typing?</h2>
This cursor auto-hiding behavior is by design, but can be disabled in the by searching in Windows Settings for "Mouse settings" &gt; "Additional Mouse Settings" &gt; "Mouse Properties" &gt; "Pointer Options" &gt; Uncheck "Hide pointer while typing". 
You may need to restart your Windows Terminal in order for this change to take effect.

<h2>To run Linux</h2>
From Windows Command Prompt or PowerShell, you can enter the name of your installed distribution.
For example: ubuntu

<h2>Basic vi Commands</h2>
<div id="VItoc"><a href="#VItopic-0" target="_self">What is <tt>vi</tt>?</a><br><a href="#VItopic-1" target="_self">To Get Into and Out Of <tt>vi</tt></a><br><a href="#VItopic-2" target="_self"> To Start <tt>vi</tt></a><br><a href="#VItopic-3" target="_self"> To Exit <tt>vi</tt></a><br><a href="#VItopic-4" target="_self">Moving the Cursor</a><br><a href="#VItopic-5" target="_self">Screen Manipulation</a><br><a href="#VItopic-6" target="_self">Adding, Changing, and Deleting Text</a><br><a href="#VItopic-7" target="_self"> Inserting or Adding Text</a><br><a href="#VItopic-8" target="_self"> Changing Text</a><br><a href="#VItopic-9" target="_self"> Deleting Text</a><br><a href="#VItopic-10" target="_self"> Cutting and Pasting Text</a><br><a href="#VItopic-11" target="_self">Other Commands</a><br><a href="#VItopic-12" target="_self"> Searching Text</a><br><a href="#VItopic-13" target="_self"> Determining Line Numbers</a><br><a href="#VItopic-14" target="_self">Saving and Reading Files</a><br></div><br><br>
<h3 id="VItopic-0">What is <tt>vi</tt>?</h3>
The default editor that comes with the UNIX operating system is called <tt>vi</tt> (<b>vi</b>sual editor).
[Alternate editors for UNIX environments include <tt>pico</tt> and <tt>emacs</tt>, a product of GNU.]

The UNIX <tt>vi</tt> editor is a full screen editor and has two modes of 
operation: 
<i>Command mode</i> commands which cause action to be taken on the file, and 
<i>Insert mode</i> in which entered text is inserted into the file.

In the command mode, every character typed is a command that does something to the text file being edited;
a character typed in the command mode may even cause the <tt>vi</tt> editor to enter the insert mode.
In the insert mode, every character typed is added to the text in the file;
pressing the <tt>&lt;Esc&gt;</tt> (<i>Escape</i>) key turns off the Insert mode.

While there are a number of <tt>vi</tt> commands, just a handful of these is usually sufficient for beginning <tt>vi</tt> users.
To assist such users, this Web page contains a sampling of basic <tt>vi</tt> commands. 
The most basic and useful commands are marked with an asterisk
(<tt>*</tt> or star) in the tables below.
With practice, these commands should become automatic.

<b>NOTE:</b>  Both UNIX and <tt>vi</tt> are <b>case-sensitive</b>.
Be sure not to use a capital letter in place of a lowercase letter;
the results will not be what you expect.
<h3 id="VItopic-1">To Get Into and Out Of <tt>vi</tt></h3>
<h4 id="VItopic-2"> To Start <tt>vi</tt></h4>
To use <tt>vi</tt> on a file, type in <tt>vi filename</tt>.  
If the file named <tt>filename</tt> exists, then the first page (or screen)
of the file will be displayed; if the file does not exist, then an empty file and screen are created into which you may enter text.
<table>
<tbody><tr><th> *</th><th align="LEFT"><tt>vi filename</tt></th><td> <i>edit <tt>filename</tt> starting at line 1</i></td></tr><tr><th> &nbsp;</th><th align="LEFT"><tt>vi -r filename</tt></th><td> <i>recover <tt>filename</tt> that was being edited when system crashed</i></td></tr><tr></tr></tbody></table>

<h4 id="VItopic-3"> To Exit <tt>vi</tt></h4>
Usually the new or modified file is saved when you leave <tt>vi</tt>.  
However, it is also possible to quit <tt>vi</tt> without saving the file.
<b>Note:</b> The cursor moves to bottom of screen whenever a colon (<tt>:</tt>) is typed.  
This type of command is completed by hitting the <tt>&lt;Return&gt;</tt> (or <tt>&lt;Enter&gt;</tt>) key.
<table>
<tbody><tr><th> *</th><th align="LEFT"><tt>:x</tt><tt>&lt;Return&gt;</tt></th><td> <i>quit <tt>vi</tt>, writing out modified file to file named in original invocation</i></td></tr><tr><th> &nbsp;</th><th align="LEFT"><tt>:wq</tt><tt>&lt;Return&gt;</tt></th><td> <i>quit <tt>vi</tt>, writing out modified file to file named in original invocation</i></td></tr><tr><th> &nbsp;</th><th align="LEFT"><tt>:q</tt><tt>&lt;Return&gt;</tt></th><td> <i>quit (or exit) <tt>vi</tt></i></td></tr><tr><th> *</th><th align="LEFT"><tt>:q!</tt><tt>&lt;Return&gt;</tt></th><td> <i>quit <tt>vi</tt> even though latest changes have not been saved for this <tt>vi</tt> call</i></td></tr><tr></tr></tbody></table>
<h3 id="VItopic-4">Moving the Cursor</h3>
Unlike many of the PC and MacIntosh editors, <b>the mouse does not move the cursor</b> within the <tt>vi</tt> editor screen (or window). 
You must use the the key commands listed below.  
On some UNIX platforms, the arrow keys may be used as well;
however, since <tt>vi</tt> was designed with the Qwerty keyboard (containing no arrow keys) in mind, the arrow keys sometimes produce strange effects in <tt>vi</tt> and should be avoided.

If you go back and forth between a PC environment and a UNIX environment, you may find that this dissimilarity in methods for cursor movement is the most frustrating difference between the two.

In the table below, the symbol <tt>^</tt> before a letter means that the <tt>&lt;Ctrl&gt;</tt> key should be held down while the letter key is pressed.
<table>
<tbody><tr><th> *</th><th align="LEFT"><tt>j</tt> <i>or</i> <tt>&lt;Return&gt;</tt>
<br> &nbsp; [<i>or</i> down-arrow]</th><td> <i>move cursor down one line</i></td></tr><tr><th> *</th><th align="LEFT"><tt>k</tt> [<i>or</i> up-arrow]</th><td> <i>move cursor up one line</i></td></tr><tr><th> *</th><th align="LEFT"><tt>h</tt> <i>or</i> <tt>&lt;Backspace&gt;</tt>
<br> &nbsp; [<i>or</i> left-arrow]</th><td> <i>move cursor left one character</i></td></tr><tr><th> *</th><th align="LEFT"><tt>l</tt> <i>or</i> <tt>&lt;Space&gt;</tt>
<br> &nbsp; [<i>or</i> right-arrow]</th><td> <i>move cursor right one character</i></td></tr><tr><th> *</th><th align="LEFT" nowrap=""><tt>0</tt> (zero)</th><td> <i>move cursor to start of current line
(the one with the cursor)</i></td></tr><tr><th> *</th><th align="LEFT" nowrap=""><tt>$</tt></th><td><i>move cursor to end of current line</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>w</tt></th><td><i>move cursor to beginning of next word</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>b</tt></th><td><i>move cursor back to beginning of preceding word</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>:0</tt><tt>&lt;Return&gt; <i>or</i> 1G</tt></th><td> <i>move cursor to first line in file</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>:n</tt><tt>&lt;Return&gt; <i>or</i> nG</tt></th><td> <i>move cursor to line <tt>n</tt></i></td></tr><tr><th> &nbsp;</th><th align="LEFT"><tt>:$</tt><tt>&lt;Return&gt; <i>or</i> G</tt></th><td> <i> move cursor to last line in file</i></td></tr><tr></tr></tbody></table>
<h3 id="VItopic-5">Screen Manipulation</h3>
The following commands allow 
the <tt>vi</tt> editor screen (or window) to move up or down several lines and to be refreshed.
<table>
<tbody><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>^f</tt></th><td> <i>move forward one screen</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>^b</tt></th><td> <i>move backward one screen</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>^d</tt></th><td> <i>move down (forward) one half screen</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>^u</tt></th><td> <i>move up (back) one half screen</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>^l</tt></th><td> <i>redraws the screen</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>^r</tt></th><td> <i>redraws the screen, removing deleted lines</i></td></tr><tr></tr></tbody></table>
<h3 id="VItopic-6">Adding, Changing, and Deleting Text</h3>
Unlike PC editors, you cannot replace or delete text by highlighting it with the mouse.  
Instead use the commands in the following tables.

Perhaps the most important command is the one that allows you to back up and <i>undo</i> your last action.  
Unfortunately, this command acts like a toggle, undoing and redoing your most recent action.  
You cannot go back more than one step.
<table>
<tbody><tr><th> *</th><th align="LEFT" nowrap=""><tt>u</tt></th><td> <i>UNDO WHATEVER YOU JUST DID; a simple toggle</i></td></tr><tr></tr></tbody></table>

The main purpose of an editor is to create, add, or modify text for a file. 
<h4 id="VItopic-7"> Inserting or Adding Text</h4>
 The following commands allow you to insert and add text.
Each of these commands puts the <tt>vi</tt> editor into insert mode;
thus, the <tt>&lt;Esc&gt;</tt> key must be pressed to terminate the entry of text and to put the <tt>vi</tt> editor back into command mode.
<table>
<tbody><tr><th> *</th><th align="LEFT" nowrap=""><tt>i</tt></th><td> <i>insert text before cursor, until <tt>&lt;Esc&gt;</tt> hit</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>I</tt></th><td> <i>insert text at beginning of current line,
until <tt>&lt;Esc&gt;</tt> hit</i></td></tr><tr><th> *</th><th align="LEFT" nowrap=""><tt>a</tt></th><td> <i>append text after cursor, until <tt>&lt;Esc&gt;</tt> hit</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>A</tt></th><td> <i>append text to end of current line,
until <tt>&lt;Esc&gt;</tt> hit</i></td></tr><tr><th> *</th><th align="LEFT" nowrap=""><tt>o</tt></th><td> <i>open and put text in a new line below current line,
until <tt>&lt;Esc&gt;</tt> hit</i></td></tr><tr><th> *</th><th align="LEFT" nowrap=""><tt>O</tt></th><td> <i>open and put text in a new line above current line,
until <tt>&lt;Esc&gt;</tt> hit</i></td></tr><tr></tr></tbody></table>

<h4 id="VItopic-8"> Changing Text</h4>
The following commands allow you to modify text.
<table>
<tbody><tr><th> *</th><th align="LEFT" nowrap=""><tt>r</tt></th><td> <i> replace single character under cursor
(no <tt>&lt;Esc&gt;</tt> needed)</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>R</tt></th><td> <i>replace characters, starting with current cursor position,
until <tt>&lt;Esc&gt;</tt> hit</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>cw</tt></th><td> <i>change the current word with new text,
<br>starting with the character under cursor, until <tt>&lt;Esc&gt;</tt> hit</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>cNw</tt></th><td> <i>change <tt>N</tt> words beginning with character under cursor,
until <tt>&lt;Esc&gt;</tt> hit;
<br> &nbsp; e.g., <tt>c5w</tt> changes 5 words</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>C</tt></th><td> <i>change (replace) the characters in the current line,
until <tt>&lt;Esc&gt;</tt> hit</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>cc</tt></th><td> <i>change (replace) the entire current line, 
stopping when <tt>&lt;Esc&gt;</tt> is hit</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>Ncc</tt> <i>or</i> <tt>cNc</tt></th><td> <i>change (replace) the next N lines,
starting with the current line,<br>
stopping when <tt>&lt;Esc&gt;</tt> is hit</i></td></tr><tr></tr></tbody></table>

<h4 id="VItopic-9"> Deleting Text</h4>
The following commands allow you to delete text.
<table>
<tbody><tr><th> *</th><th align="LEFT" nowrap=""><tt>x</tt></th><td> <i>delete single character under cursor</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>Nx</tt></th><td> <i>delete N characters, starting with character under cursor</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>dw</tt></th><td> <i>delete the single word beginning with character under cursor</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>dNw</tt></th><td> <i>delete <tt>N</tt> words beginning with character under cursor;
<br> &nbsp; e.g., <tt>d5w</tt> deletes 5 words</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>D</tt></th><td> <i>delete the remainder of the line,
starting with current cursor position</i></td></tr><tr><th> *</th><th align="LEFT" nowrap=""><tt>dd</tt></th><td> <i>delete entire current line</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>Ndd</tt> <i>or</i> <tt>dNd</tt></th><td> <i>delete <tt>N</tt> lines, beginning with the current line;
<br> &nbsp; e.g., <tt>5dd</tt> deletes 5 lines</i></td></tr><tr></tr></tbody></table>

<h4 id="VItopic-10"> Cutting and Pasting Text</h4>
The following commands allow you to copy and paste text.
<table>
<tbody><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>yy</tt></th><td> <i>copy (yank, cut) the current line into the buffer</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>Nyy</tt> <i>or</i> <tt>yNy</tt></th><td> <i>copy (yank, cut) the next N lines, including the current line,
into the buffer</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>p</tt></th><td> <i>put (paste) the line(s) in the buffer into the text after the current line</i></td></tr><tr></tr></tbody></table>
<h3 id="VItopic-11">Other Commands</h3>
<h4 id="VItopic-12"> Searching Text</h4>
 A common occurrence in text editing is to replace one word or phase by another.  
To locate instances of particular sets of characters
(or strings), use the following commands.
<table>
<tbody><tr><th> &nbsp;</th><th align="LEFT"><tt>/string</tt></th><td> <i> search forward for occurrence of <tt>string</tt> in text<i>
</i></i></td></tr><tr><th> &nbsp;</th><th align="LEFT"><tt>?string</tt></th><td> <i> search backward for occurrence of <tt>string</tt> in text<i>
</i></i></td></tr><tr><th> &nbsp;</th><th align="LEFT"><tt>n</tt></th><td> <i> move to next occurrence of search string</i></td></tr><tr><th> &nbsp;</th><th align="LEFT"><tt>N</tt></th><td> <i> move to next occurrence of search string in opposite direction</i></td></tr><tr></tr></tbody></table>

<h4 id="VItopic-13"> Determining Line Numbers</h4>
 Being able to determine the line number of the current line or the total number of lines in the file being edited is sometimes useful.
<table>
<tbody><tr><th> &nbsp;</th><th align="LEFT"><tt>:.=</tt></th><td> <i> returns line number of current line at bottom of screen<i>
</i></i></td></tr><tr><th> &nbsp;</th><th align="LEFT"><tt>:=</tt></th><td> <i> returns the total number of lines at bottom of screen<i>
</i></i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>^g</tt></th><td> <i>provides the current line number, along with the total number of lines,<br>
in the file at the bottom of the screen</i></td></tr><tr></tr></tbody></table>
<h3 id="VItopic-14">Saving and Reading Files</h3>

These commands permit you to input and output files other than the named file with which you are currently working.

<table>
<tbody><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>:r filename</tt><tt>&lt;Return&gt;</tt></th><td> <i> read file named <tt>filename</tt> and insert after current line
<br>(the line with cursor)</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>:w</tt><tt>&lt;Return&gt;</tt></th><td> <i>write current contents to file named in original 
<tt>vi</tt> call
</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>:w newfile</tt><tt>&lt;Return&gt;</tt></th><td> <i>write current contents to a new file named <tt>newfile</tt>
</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>:12,35w smallfile</tt><tt>&lt;Return&gt;</tt></th><td> <i>write the contents of the lines numbered 12 through 35
to a new file named <tt>smallfile</tt>
</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>:w! prevfile</tt><tt>&lt;Return&gt;</tt></th><td> <i>write current contents over a pre-existing file named <tt>prevfile</tt>
</i></td></tr><tr></tr></tbody></table>

<h2>VI Editing commands</h2>
i - Insert at cursor (goes into insert mode)
a - Write after cursor (goes into insert mode)
A - Write at the end of line (goes into insert mode)
ESC - Terminate insert mode
u - Undo last change
U - Undo all changes to the entire line
o - Open a new line (goes into insert mode)
dd - Delete line
3dd - Delete 3 lines.
D - Delete contents of line after the cursor
C - Delete contents of a line after the cursor and insert new text. Press ESC key to end insertion.
dw - Delete word
4dw - Delete 4 words
cw - Change word
x - Delete character at the cursor
r - Replace character
R - Overwrite characters from cursor onward
s - Substitute one character under cursor continue to insert
S - Substitute entire line and begin to insert at the beginning of the line
~ - Change case of individual character

<strong>Note</strong>: You should be in the &#8220;<strong>command mode&#8221; to execute these commands</strong>. VI editor is <strong>case-sensitive</strong> so make sure you type the commands in the right letter-case.</p>
Make sure you press the right command otherwise you will end up making undesirable changes to the file. You can also enter the insert mode by pressing a, A, o, as required.<br><div class='code-block code-block-4' style='margin: 8px 0; clear: both;'>

<h3>Moving within a file</h3>

k - Move cursor up
j - Move cursor down
h - Move cursor left
l - Move cursor right
You need to be in the command mode to move within a file. The default keys for navigation are mentioned below else; You can <strong>also use the arrow keys on the keyboard</strong>.</p>

<h3>Saving and Closing the file</h3>

Shift+zz - Save the file and quit
:w - Save the file but keep it open
:q! - Quit vi and do not save changes
:wq - Save the file and quit

You should be in the <strong>command mode to exit the editor and save changes</strong> to the file.</p>


<h2>Bash on Ubuntu on Windows: ls command returns nothing at root level</h2>
it probably just means the folder is empty (or only contain hidden files). 
you can try ls -a (or ll) to see hidden files (including . 
and ..) and see that it works.

How do I access all of my Windows folders from Bash on Ubuntu on Windows

Your C drive is at /mnt/c/
dir /mnt/c/

cd ~ usually takes me to my user directory. 

In bash on windows this takes me to a directory empty except for things like .bashrc. 

It still takes you to your "home directory" on Windows' Bash, it's just that your home dir starts empty and it's disconnected from your Windows drive. 

Consider that it's like having a Linux machine with the Windows drive mounted as a secondary or network drive. 
But if you install Ubuntu stuff that go the "home dir" that will be where cd ~ takes you – 

if you want to list all directories in root. 
simply type ls /

cd /mnt/c/Users/username
Where c means C: drive and username is your Windows username.
Then, when you type ls, you will see folders like Desktop, Documents, Downloads, etc.

<h2>Linux 操作必备 150 个命令</h2>
Linux 命令是对 Linux 系统进行管理的命令。
对于 Linux 系统来说，无论是中央处理器、内存、磁盘驱动器、键盘、鼠标，还是用户等都是文件， Linux 系统管理的命令是它正常运行的核心，与之前的 DOS 命令类似。

Linux 命令在系统中有两种类型：
内置 Shell 命令和 Linux 命令。
命令	功能说明
<b class="orange">线上查询及帮助命令 (2 个)</b>	
<b>man</b>	查看命令帮助，命令的词典，更复杂的还有 info，但不常用。
<b>help</b>	查看 Linux 内置命令的帮助，比如 cd 命令。

<b class="orange">文件和目录操作命令 (18 个)</b>	
<b>ls</b>	全拼 list，功能是列出目录的内容及其内容属性信息。
<b>cd</b>	全拼 change directory，功能是从当前工作目录切换到指定的工作目录。
<b>cp</b>	全拼 copy，其功能为复制文件或目录。
<b>find</b>	查找的意思，用于查找目录及目录下的文件。

<b>mkdir</b>	全拼 make directories，其功能是创建目录。
<b>mv</b>	全拼 move，其功能是移动或重命名文件。
<b>pwd</b>	全拼 print working directory，其功能是显示当前工作目录的绝对路径。
<b>rename</b>	用于重命名文件。

<b>rm</b>	全拼 remove，其功能是删除一个或多个文件或目录。
<b>rmdir</b>	全拼 remove empty directories，功能是删除空目录。
<b>touch</b>	创建新的空文件，改变已有文件的时间戳属性。
<b>tree</b>	功能是以树形结构显示目录下的内容。

<b>basename</b>	显示文件名或目录名。
<b>dirname</b>	显示文件或目录路径。
<b>chattr</b>	改变文件的扩展属性。
<b>lsattr</b>	查看文件扩展属性。

<b>file</b>	显示文件的类型。
<b>md5sum</b>	计算和校验文件的 MD5 值。

<b class="orange">查看文件及内容处理命令（21 个）</b>	
<b>cat</b>	全拼 concatenate，功能是用于连接多个文件并且打印到屏幕输出或重定向到指定文件中。
<b>tac</b>	tac 是 cat 的反向拼写，因此命令的功能为反向显示文件内容。
<b>more</b>	分页显示文件内容。
<b>less</b>	分页显示文件内容，more 命令的相反用法。

<b>head</b>	显示文件内容的头部。
<b>tail</b>	显示文件内容的尾部。
<b>cut</b>	将文件的每一行按指定分隔符分割并输出。
<b>split</b>	分割文件为不同的小片段。

<b>paste</b>	按行合并文件内容。
<b>sort</b>	对文件的文本内容排序。
<b>uniq</b>	去除重复行。 oldboy
<b>wc</b>	统计文件的行数、单词数或字节数。

<b>iconv</b>	转换文件的编码格式。
<b>dos2unix</b>	将 DOS 格式文件转换成 UNIX 格式。
<b>diff</b>	全拼 difference，比较文件的差异，常用于文本文件。
<b>vimdiff</b>	命令行可视化文件比较工具，常用于文本文件。

<b>rev</b>	反向输出文件内容。
<b>grep/egrep</b>	过滤字符串，三剑客老三。
<b>join</b>	按两个文件的相同字段合并。
<b>tr</b>	替换或删除字符。
<b>vi/vim</b>	命令行文本编辑器。

<b class="orange">文件压缩及解压缩命令（4 个）</b>	
<b>tar</b>	打包压缩。 oldboy
<b>unzip</b>	解压文件。
<b>gzip</b>	gzip 压缩工具。
<b>zip</b>	压缩工具。

<b class="orange">信息显示命令（11 个）</b>	
<b>uname</b>	显示操作系统相关信息的命令。
<b>hostname</b>	显示或者设置当前系统的主机名。
<b>dmesg</b>	显示开机信息，用于诊断系统故障。
<b>uptime</b>	显示系统运行时间及负载。

<b>stat</b>	显示文件或文件系统的状态。
<b>du</b>	计算磁盘空间使用情况。
<b>df</b>	报告文件系统磁盘空间的使用情况。
<b>top</b>	实时显示系统资源使用情况。

<b>free</b>	查看系统内存。
<b>date</b>	显示与设置系统时间。
<b>cal</b>	查看日历等时间信息。

<b class="orange">搜索文件命令（4 个）</b>	
<b>which</b>	查找二进制命令，按环境变量 PATH 路径查找。
<b>find</b>	从磁盘遍历查找文件或目录。
<b>whereis</b>	查找二进制命令，按环境变量 PATH 路径查找。
<b>locate</b>	从数据库 (/var/lib/mlocate/mlocate.db) 查找命令，使用 updatedb 更新库。

<b class="orange">用户管理命令（10 个）</b>	
<b>useradd</b>	添加用户。
<b>usermod</b>	修改系统已经存在的用户属性。
<b>userdel</b>	删除用户。
<b>groupadd</b>	添加用户组。

<b>passwd</b>	修改用户密码。
<b>chage</b>	修改用户密码有效期限。

<b>id</b>	查看用户的 uid,gid 及归属的用户组。
<b>su</b>	切换用户身份。
<b>visudo</b>	编辑 / etc/sudoers 文件的专属命令。
<b>sudo</b>	以另外一个用户身份（默认 root 用户）执行事先在 sudoers 文件允许的命令。

<b class="orange">基础网络操作命令（11 个）</b>	
<b>telnet</b>	使用 TELNET 协议远程登录。
<b>ssh</b>	使用 SSH 加密协议远程登录。
<b>scp</b>	全拼 secure copy，用于不同主机之间复制文件。
<b>wget</b>	命令行下载文件。

<b>ping</b>	测试主机之间网络的连通性。
<b>route</b>	显示和设置 linux 系统的路由表。
<b>ifconfig</b>	查看、配置、启用或禁用网络接口的命令。
<b>ifup</b>	启动网卡。

<b>ifdown</b>	关闭网卡。
<b>netstat</b>	查看网络状态。
<b>ss</b>	查看网络状态。

<b class="orange">深入网络操作命令（9 个）</b>	
<b>nmap</b>	网络扫描命令。
<b>lsof</b>	全名 list open files，也就是列举系统中已经被打开的文件。
<b>mail</b>	发送和接收邮件。
<b>mutt</b>	邮件管理命令。

<b>nslookup</b>	交互式查询互联网 DNS 服务器的命令。
<b>dig</b>	查找 DNS 解析过程。
<b>host</b>	查询 DNS 的命令。
<b>traceroute</b>	追踪数据传输路由状况。
<b>tcpdump</b>	命令行的抓包工具。

<b class="orange">有关磁盘与文件系统的命令（16 个）</b>	
<b>mount</b>	挂载文件系统。
<b>umount</b>	卸载文件系统。
<b>fsck</b>	检查并修复 Linux 文件系统。
<b>dd</b>	转换或复制文件。

<b>dumpe2fs</b>	导出 ext2/ext3/ext4 文件系统信息。
<b>dump</b>	ext2/3/4 文件系统备份工具。
<b>fdisk</b>	磁盘分区命令，适用于 2TB 以下磁盘分区。
<b>parted</b>	磁盘分区命令，没有磁盘大小限制，常用于 2TB 以下磁盘分区。

<b>mkfs</b>	格式化创建 Linux 文件系统。
<b>partprobe</b>	更新内核的硬盘分区表信息。
<b>e2fsck</b>	检查 ext2/ext3/ext4 类型文件系统。
<b>mkswap</b>	创建 Linux 交换分区。

<b>swapon</b>	启用交换分区。
<b>swapoff</b>	关闭交换分区。
<b>sync</b>	将内存缓冲区内的数据写入磁盘。
<b>resize2fs</b>	调整 ext2/ext3/ext4 文件系统大小。

<b class="orange">系统权限及用户授权相关命令（4 个）</b>	
<b>chmod</b>	改变文件或目录权限。
<b>chown</b>	改变文件或目录的属主和属组。
<b>chgrp</b>	更改文件用户组。
<b>umask</b>	显示或设置权限掩码。

<b class="orange">查看系统用户登陆信息的命令（7 个）</b>	
<b>whoami</b>	显示当前有效的用户名称，相当于执行 id -un 命令。
<b>who</b>	显示目前登录系统的用户信息。
<b>w</b>	显示已经登陆系统的用户列表，并显示用户正在执行的指令。
<b>last</b>	显示登入系统的用户。

<b>lastlog</b>	显示系统中所有用户最近一次登录信息。
<b>users</b>	显示当前登录系统的所有用户的用户列表。
<b>finger</b>	查找并显示用户信息。

<b class="orange">内置命令及其它（19 个）</b>	
<b>echo</b>	打印变量，或直接输出指定的字符串
<b>printf</b>	将结果格式化输出到标准输出。
<b>rpm</b>	管理 rpm 包的命令。
<b>yum</b>	自动化简单化地管理 rpm 包的命令。

<b>watch</b>	周期性的执行给定的命令，并将命令的输出以全屏方式显示。
<b>alias</b>	设置系统别名。
<b>unalias</b>	取消系统别名。
<b>date</b>	查看或设置系统时间。

<b>clear</b>	清除屏幕，简称清屏。
<b>history</b>	查看命令执行的历史纪录。
<b>eject</b>	弹出光驱。
<b>time</b>	计算命令执行时间。

<b>nc</b>	功能强大的网络工具。
<b>xargs</b>	将标准输入转换成命令行参数。
<b>exec</b>	调用并执行指令的命令。
<b>export</b>	设置或者显示环境变量。

<b>unset</b>	删除变量或函数。
<b>type</b>	用于判断另外一个命令是否是内置命令。
<b>bc</b>	命令行科学计算器

<b>系统管理与性能监视命令 (9 个)</b>	
<b>chkconfig</b>	管理 Linux 系统开机启动项。
<b>vmstat</b>	虚拟内存统计。
<b>mpstat</b>	显示各个可用 CPU 的状态统计。
<b>iostat</b>	统计系统 IO。

<b>sar</b>	全面地获取系统的 CPU、运行队列、磁盘 I/O、分页（交换区）、内存、 CPU 中断和网络等性能数据。
<b>ipcs</b>	用于报告 Linux 中进程间通信设施的状态，显示的信息包括消息列表、共享内存和信号量的信息。
<b>ipcrm</b>	用来删除一个或更多的消息队列、信号量集或者共享内存标识。
<b>strace</b>	用于诊断、调试 Linux 用户空间跟踪器。 我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。
<b>ltrace</b>	命令会跟踪进程的库函数调用, 它会显现出哪个库函数被调用。

<b class="orange">关机 / 重启 / 注销和查看系统信息的命令（6 个）</b>	
<b>shutdown</b>	关机。
<b>halt</b>	关机。
<b>poweroff</b>	关闭电源。
<b>logout</b>	退出当前登录的 Shell。

<b>exit</b>	退出当前登录的 Shell。
<b>Ctrl+d</b>	退出当前登录的 Shell 的快捷键。

<b class="orange">进程管理相关命令（15 个）</b>	
<b>bg</b>	将一个在后台暂停的命令，变成继续执行 （在后台执行）。
<b>fg</b>	将后台中的命令调至前台继续运行。
<b>jobs</b>	查看当前有多少在后台运行的命令。
<b>kill</b>	终止进程。

<b>killall</b>	通过进程名终止进程。
<b>pkill</b>	通过进程名终止进程。
<b>crontab</b>	定时任务命令。
<b>ps</b>	显示进程的快照。

<b>pstree</b>	树形显示进程。
<b>nice/renice</b>	调整程序运行的优先级。
<b>nohup</b>	忽略挂起信号运行指定的命令。
<b>pgrep</b>	查找匹配条件的进程。

<b>runlevel</b>	查看系统当前运行级别。
<b>init</b>	切换运行级别。
<b>service</b>	启动、停止、重新启动和关闭系统服务，还可以显示所有系统服务的当前状态。

<h2>Variable Names</h2>
The name of a variable can contain only letters (a to z or A to Z), numbers ( 0 to 9) or the underscore character ( _).
By convention, Unix shell variables will have their names in UPPERCASE.

The following examples are valid variable names -
_ALI
TOKEN_A
VAR_1
VAR_2

Following are the examples of invalid variable names -
2_VAR
-VARIABLE
VAR1-VAR2
VAR_A!

The reason you cannot use other characters such as <b>!</b>, <b>*</b>, or <b>-</b> is that these characters have a special meaning for the shell.

<h2>Defining Variables</h2>
Variables are defined as follows -
variable_name=variable_value

For example -
NAME="Zara Ali"

The above example defines the variable NAME and assigns the value "Zara Ali" to it. 
Variables of this type are called <b>scalar variables</b>. 

A scalar variable can hold only one value at a time.
Shell enables you to store any value you want in a variable. 

For example -
VAR1="Zara Ali"
VAR2=100

<h2>Accessing Values</h2>
To access the value stored in a variable, prefix its name with the dollar sign (<b>$</b>) -

For example, the following script will access the value of defined variable NAME and print it on STDOUT -

#!/bin/sh
NAME="Zara Ali"
echo $NAME

The above script will produce the following value -
Zara Ali

<h2>Read-only Variables</h2>
Shell provides a way to mark variables as read-only by using the read-only command. 
After a variable is marked read-only, its value cannot be changed.
For example, the following script generates an error while trying to change the value of NAME -

#!/bin/sh
NAME="Zara Ali"
readonly NAME
NAME="Qadiri"
The above script will generate the following result -
/bin/sh: NAME: This variable is read only.

<h2>Unsetting Variables</h2>
Unsetting or deleting a variable directs the shell to remove the variable from the list of variables that it tracks. 

Once you unset a variable, you cannot access the stored value in the variable.
Following is the syntax to unset a defined variable using the <b>unset</b> command -
unset variable_name

The above command unsets the value of a defined variable. 
Here is a simple example that demonstrates how the command works -
#!/bin/sh

NAME="Zara Ali"
unset NAME
echo $NAME

The above example does not print anything. 
You cannot use the unset command to <b>unset</b> variables that are marked <b>readonly</b>.
<h2>Variable Types</h2>

When a shell is running, three main types of variables are present -

<b>Local Variables</b> - A local variable is a variable that is present within the current instance of the shell. 

It is not available to programs that are started by the shell. 
They are set at the command prompt.

<b>Environment Variables</b> - An environment variable is available to any child process of the shell. 

Some programs need environment variables in order to function correctly. 
Usually, a shell script defines only those environment variables that are needed by the programs that it runs.

<b>Shell Variables</b> - A shell variable is a special variable that is set by the shell and is required by the shell in order to function correctly. 

Some of these variables are environment variables whereas others are local variables.

<h2>Variables in Shell Scripting</h2>
<div id="ShellVariablestoc" class="toc"><a href="#ShellVariablestopic-0" target="_self">System Defined Variables</a><br><a href="#ShellVariablestopic-1" target="_self">User Defined Variables</a><br><a href="#ShellVariablestopic-2" target="_self">Use of Backtick symbol (`) in shell variables</a><br></div></center><br><br>

In every<b> programming</b> language <b>variables</b> plays an important role , in Linux shell scripting we can use two types of variables : <b>System Defined Variables</b> &amp; <b>User Defined Variables</b>.

A variable in a shell script is a means of <b>referencing </b>a <b>numeric</b> or <b>character value</b>. 
And unlike formal programming languages, a shell script doesn’t require you to <b>declare a type</b> for your variables

<h3 id="ShellVariablestopic-0">System Defined Variables</h3>

These are the variables which are created and maintained by <b>Operating System(Linux) itself.</b> Generally these variables are defined in <b>CAPITAL LETTERS</b>. 
We can see these variables by using the command “<b>$ set</b>“. 
Some of the system defined variables are given below :

$ set

<img class="lazy" data-src="https://www.linuxtechi.com/wp-content/uploads/2014/07/Linux-Shell-Variables-Meaninigs.png?ezimgfmt=ng%3Awebp%2Fngcb22%2Frs%3Adevice%2Frscb22-1">

To print the value of above variables, use echo command as shown below :

$ echo $HOME
/home/linuxtechi
$ echo $USER
linuxtechi
$

We can use environment variables in our bash scripts by using the environment variable’s name preceded by a dollar sign. 
Example is shown below,

$ cat myscript

#!/bin/bash
# display user information from the system.
echo "User info for userid: $USER"
echo UID: $UID
echo HOME: $HOME

Notice that the <b>environment variables</b> in the echo commands are replaced by their current values when the script is run. 
Also notice that we were able to place the <b><em>$USER </em></b>system variable within the double quotation marks in the first string, and the shell script was still able to figure out what we meant. 
There is a <b>drawback</b> to using this method, however. 
Look at what happens in this example:

$ echo "The cost of the item is $15"
The cost of the item is 5
$

That is obviously not what was intended. 
Whenever the script sees a dollar sign within quotes, it assumes you’re referencing a variable. 
In this example the script attempted to display the <b>variable <em>$1 </em></b>(which was not defined), and then the number 5. 
To display an actual dollar sign, you <b>must precede</b> it with a<b> backslash character:</b>

$ echo "The cost of the item is \$15"
The cost of the item is $15
$

That’s better. 
The backslash allowed the shell script to interpret the <b>dollar sign</b> as an actual dollar sign, and not a variable.

<h3 id="ShellVariablestopic-1">User Defined Variables</h3>
These variables are defined by <b>users</b>. 
A shell script allows us to set and use our <b>own variables</b> within the script. 
Setting variables allows you to <b>temporarily store data</b> and use it throughout the script, making the shell script more like a real computer program.

<b>User variables</b> can be any text string of up to <b>20 letters</b>, <b>digits</b>, or <b>an underscore character</b>. 
User variables are case sensitive, so the variable Var1 is different from the variable var1. 
This little rule often gets novice script programmers in trouble.

Values are assigned to user variables using an <b>equal sign.</b> No spaces can appear between the variable, the equal sign, and the value (another trouble spot for novices). 
Here are a few examples of assigning values to user variables:

var1=10
var2=-57
var3=testing
var4="still more testing"

The shell script <b>automatically determines the data type</b> used for the variable value. 
Variables defined within the shell script maintain their values throughout the life of the shell script but are deleted when the shell script completes.

Just like system variables, user variables can be referenced using the dollar sign:

$ cat test3
#!/bin/bash
# testing variables
days=10
guest="Katie"
echo "$guest checked in $days days ago"
days=5
guest="Jessica"
echo "$guest checked in $days days ago"
$

Running the script produces the following output,

$ chmod u+x test3
$ ./test3
Katie checked in 10 days ago
Jessica checked in 5 days ago
$

Each time the variable is<b> referenced</b>, it produces the value currently assigned to it. 
It’s important to remember that when referencing a variable value you use the <b>dollar sign</b>, but when referencing the variable to assign a value to it, you do not use the dollar sign. 
Here’s an example of what I mean:

$ cat test4
#!/bin/bash
# assigning a variable value to another variable
value1=10
value2=$value1
echo The resulting value is $value2
$

When you use the <b>value </b>of the <b>value1</b> variable in the assignment statement, you must still use the dollar sign. 
This code produces the following output:

$ chmod u+x test4
$ ./test4
The resulting value is 10
$

If you forget the dollar sign, and make the value2 assignment line look like:

value2=value1
you get the following output:
$ ./test4
The resulting value is value1
$

Without the dollar sign the <b>shell interprets</b> the variable name as a <b>normal text string</b>, which is most likely not what you wanted.

<h3 id="ShellVariablestopic-2">Use of Backtick symbol (`) in shell variables</h3>
The <b>backtick allows</b> you to assign the output of a shell command to a variable. 
While this doesn’t seem like much, it is a major building block in <b>script </b><b>programming. 
</b>You must surround the entire command line command with backtick characters:

testing=`date`

The shell runs the command within the <b>backticks</b> and assigns the output to the variable testing. 
Here’s an example of creating a variable using the output from a normal shell command:

$ cat test5
#!/bin/bash
# using the backtick character
testing=`date`
echo "The date and time are: " $testing
$

The variable testing receives the output from the date command, and it is used in the echo statement to display it. 
Running the shell script produces the following output:

$ chmod u+x test5
$ ./test5
The date and time are: Tue 4 Oct 05:20:44 BST 2022
$

<b>Note </b>: In bash you can also use the alternative <b>$(…) </b>syntax in place of backtick (`),which has the advantage of being re-entrant.

Example : 

$ echo " Today’s date &amp; time is :" $(date)
Today’s date &amp; time is : Tue 4 Oct 05:21:51 BST 2022
$

<h2>Reset password for Ubuntu on WSL</h2>
Step 1: Switch to root as default user
From the command prompt:
ubuntu config --default-user root

Step 2: Reset the password for the account
whoami
passwd root

<h2>fix a "Command not found" error in Linux</h2>
<div id="Commandnotfoundtoc" class="toc"><a href="#Commandnotfoundtopic-0" target="_self">Understanding environment variables</a><br><a href="#Commandnotfoundtopic-1" target="_self">Global variables</a><br><a href="#Commandnotfoundtopic-2" target="_self">Local variables</a><br><a href="#Commandnotfoundtopic-3" target="_self">The PATH environment variable</a><br><a href="#Commandnotfoundtopic-4" target="_self">5 ways to fix "Command not found" errors</a><br><a href="#Commandnotfoundtopic-5" target="_self">1. Include the path</a><br><a href="#Commandnotfoundtopic-6" target="_self">2. Add a new path</a><br><a href="#Commandnotfoundtopic-7" target="_self">3. Copy a file to an existing path location</a><br><a href="#Commandnotfoundtopic-8" target="_self">4. Tell Bash where to look</a><br><a href="#Commandnotfoundtopic-9" target="_self">5. Install a package</a><br><a href="#Commandnotfoundtopic-10" target="_self">Stick to the path</a><br></div></center><br><br>

When you're trying to run a command (with or without <code>sudo</code>) and get an error message that reads "Command not found," this means the script or file you're trying to execute doesn't exist in the location specified by your PATH variable. 
What is this variable, and how can you run commands that it can't find?

<h3 id="Commandnotfoundtopic-0">Understanding environment variables</h3>
In computing, a <em>variable</em> is a placeholder for a value that can change. 
You use variables every day in normal speech, although you don't think of them as such. 
When you say "my laptop," you're using "laptop" as a generic variable or placeholder for the computer you're carrying, regardless of whether it happens to be a Lenovo, Mac, or a Raspberry Pi in a fancy case.

<em>Environment variables</em> are special variables that contain information about your login session. 
Many of these variables are set by default during installation or user creation. 
They're stored for the system shell, applications, and scripts to use when executing commands.

There are global, or system-defined, variables and local, or user-defined, variables.

<h3 id="Commandnotfoundtopic-1">Global variables</h3>

Global variables come predefined in your login shell, but they aren't immutable and can be modified or deleted according to your preferences. 
You can use the <code>printenv</code> or <code>env</code> commands to display the environment variables on your system:

<code>$ env 
SHELL=/bin/bash 
SESSION_MANAGER=local/kiwi.homelinux.local:@/tmp/.ICE-unix/1906,unix/kiwi.homelinux.local:/tmp/.ICE-unix/19
06 
WINDOWID=153092103 
COLORTERM=truecolor 
XDG_CONFIG_DIRS=/home/tux/.config/kdedefaults:/etc/xdg:/etc/kde/xdg 
LESS=-XR 
XDG_SESSION_PATH=/org/freedesktop/DisplayManager/Session1 
HISTCONTROL=:ignorespace:ignoredups:ignorespace:ignoredups 
PKG_CONFIG_PATH=/usr/local/lib64/pkgconfig:/usr/local/share/pkgconfig:/usr/lib64/pkgconfig:/usr/share/pkgconfig 
[...]</code>

The <code>env</code> command prints out all global environment variables. 
Variables are case sensitive, and all Linux distributions use uppercase for environment variable names by default.

<b><em>[ Keep your favorite Git commands, aliases, and tips close at hand. 
Download the <a href="https://opensource.com/downloads/cheat-sheet-git?intcmp=701f20000012ngPAAQ" target="_blank">Git cheat sheet</a>. 
]</em></b>

<h3 id="Commandnotfoundtopic-2">Local variables</h3>
A local variable exists only within a specific shell. 
Therefore, when you define a local variable, it's only available in your current shell. 
It doesn't propagate or persist to a new shell session unless you export it as a global variable.

Local variables are often defined in lowercase to avoid overwriting a global variable with the same name.

<h3 id="Commandnotfoundtopic-3">The PATH environment variable</h3>

The PATH global environment variable lists the directories your system searches for valid, executable commands. 
By default, it contains standard directories that normally store executables like <code>/usr/bin</code>, <code>/usr/local/bin</code>, and so on.

When you type in a command, such as <code>grep</code> or <code>vim</code>, your system searches through all directories listed in your PATH variable, in the order that they're listed, until it finds an executable file by the same name. 
Should it fail to find one, it issues the "Command not found" error.

<code>$ printenv PATH
/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/tux/.local/bin:/home/tux/bin

$ env $PATH
env: /usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/tux/.local/bin:/home/tux/bin</code>

<h3 id="Commandnotfoundtopic-4">5 ways to fix "Command not found" errors</h3>

There are several ways to fix this problem. 
Here are five of them.

<h3 id="Commandnotfoundtopic-5">1. Include the path</h3>
Not everything you want to execute needs to be in your path. 
You can execute files directly by specifying the path to the file you want to run. 
By identifying the file's location, you circumvent the need for your system to search your path at all.

For example, suppose you have a script called <code>hello</code> that you want to run. 
It's located in your home directory, and you have already marked it as executable with <code>chmod +x</code>:

<code>$ ~/hello
hello world</code>

By telling your system the file's location, the PATH variable is never involved, and the file runs as expected.

<h3 id="Commandnotfoundtopic-6">2. Add a new path</h3>

Alternately, you can add a new directory to your PATH. 
Add your executable files to that directory, and then you can run them without manually providing a path:

<code>$ cp ~/hello ~/.local/bin
$ export PATH=$PATH:$HOME/.local/bin
$ printenv PATH
/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/tux/.local/bin</code>

You may want to add the new PATH environment variables to your login shell by including them in your <code>.bashrc</code> file as new settings.

<h3 id="Commandnotfoundtopic-7">3. Copy a file to an existing path location</h3>

If you want to execute your binary file or script, copy it to any of the directory paths already listed in the PATH environment variable:

<code>$ sudo cp ~/hello /usr/local/bin/
$ hello
hello world</code>

<h3 id="Commandnotfoundtopic-8">4. Tell Bash where to look</h3>

Probably the simplest option, especially for one-off scripts or applications, is to tell Bash not to consider the PATH but rather to "look here." Do this by placing a dot and a slash in front of the command, script, or application name. 
For the <code>hello</code> script, it looks like this:

<code>$ sudo ./hello
hello world</code>

No permanent changes are made to the system. 
This might be handy if you're writing a script and want to test it before copying or moving it to its normal storage location (presumably along the PATH).

<h3 id="Commandnotfoundtopic-9">5. Install a package</h3>

Sometimes when you try to use a command and Bash displays the "Command not found" error, it might be because the program is not installed on your system. 
Correct this by installing a software package containing the command. 
For example, if you don't have Nmap installed, then the <code>nmap</code> command fails when you type it into a terminal:

<code>$ nmap
nmap: command not found
$ sudo dnf install --assumeyes --quiet nmap
$ nmap
Nmap 7.92 ( https://nmap.org ) 
Usage: nmap [Scan Type(s)] [Options] {target specification}
[...]</code>

<b><em>[ Want to learn more? Sign up for a <a href="https://www.redhat.com/en/services/training/learning-subscription?intcmp=701f20000012ngPAAQ" target="_blank">free trial of full access to Red Hat's curriculum</a>. 
]</em></b>

<h3 id="Commandnotfoundtopic-10">Stick to the path</h3>

The PATH variable is a powerful tool you can use to customize how your system responds to commands, so take some time to get comfortable with it. 
It's frequently used when running commands to find the command executable.

In this tutorial, you learned five ways to fix a "Command not found" error in your terminal—three of which rely on the PATH variable. 
Now that you know what variables are and how command executables are found, you won't be so mystified when the "Command not found" error appears on your screen.












<script type='text/javascript' src='readbook.js'></script>
<script>
var lazyLoadInstance = new LazyLoad({
    elements_selector: ".lazy"
    // ... more custom settings?
});
</script>
</pre></body></html>
