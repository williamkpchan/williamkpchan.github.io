<base target="_blank"><html><head><title>linux notes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src="../lazyload.min.js"></script>
<script type='text/javascript' src='../mainscript.js'></script>
<script src="D:/Dropbox/Public/commonfunctions.js"></script>
<script>
  var showTopicNumber = false;
  var bookid = "linux notes" 
</script>
<style>
body{width:80%;margin-left: 10%; font-size:22px;}
h1, h2 {color: gold;}
strong {color: orange;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px;}
k {color: #205080;}
</style></head><body onkeypress="chkKey()"><center>
<h1></h1>
<a href="#mustWatch" class="red goldbs" target="_self">Must Watch!</a>
<br>
<a href="Bash Scripting Tutorial.html" class="whitebut gold">Bash Scripting Tutorial</a>
<a href="https://medium.com/@zibon/basic-linux-command-lines-to-get-started-developing-in-ubuntu-linux-b54def1c2190" class="whitebut ">Basic Linux command line tutorial</a>
<a href="LibDocs\LINUX Tutorial.html">&diams;LINUX Tutorial</a>

<br>
<div id="toc"></div></center>
<br><br>
<div id="mustWatch"><center><span class="red">MustWatch</span></center><br>
<a href="https://www.tutorialspoint.com/unix/index.htm" class="whitebut ">LINUX Tutorial</a>
<a href="https://learn.microsoft.com/en-us/windows/wsl/tutorials/gui-apps" class="whitebut ">Run Linux GUI apps on the Windows Subsystem for Linux</a>

<a href="https://bochs.sourceforge.io/" class="whitebut ">Bochs Emulator</a>
<a href="https://mp.weixin.qq.com/s/2hOw6ZuqahyC3iaSvuyfJA" class="whitebut ">Linux 环境变量总结</a>

<a href="https://www.linuxjournal.com/content/diy-build-custom-minimal-linux-distribution-source" class="whitebut ">DIY: Build a Custom Minimal Linux Distribution from Source</a>
<a href="https://www.sohu.com/a/475114085_115128" class="whitebut ">“我花了 5 年时间编写自己的操作系统！” </a>

<a href="http://puppylinux.com/index.html" class="whitebut ">light weight BionicPup 32 Linux distros</a>

<a href="Linux 系统结构详解.html" class="whitebut ">Linux 系统结构详解</a>

<a href="An Introduction to the Linux.html" class="whitebut ">An Introduction to the Linux</a>
<a href="https://www.youtube.com/watch?v=SkB-eRCzWIU" class="whitebut ">Linux Terminal Introduction</a>
</div>
<pre>
<br>
<br>

<h2>#!</h2>
"#!" is an operator called shebang which directs the script to the interpreter location. 
So, if we use"#! /bin/sh" the script gets directed to the bourne-shell.


<a href="https://www.guru99.com/introduction-to-shell-scripting.html" class="whitebut ">Shell Script in Linux/Unix</a>


<a href="http://www.tutorialspoint.com/unix/unix-getting-started.htm" class="bordred1 borRad10">Unix - Getting Started</a>
<a href="http://www.comptechdoc.org/os/linux/usersguide/linux_ugbasics.html">Basic Linux</a>
<a href="http://man.linuxde.net/">Man Linux</a>
<br><br>
<a href="https://forums.linuxmint.com/viewtopic.php?t=97158"><span class="redsha">How to install software on Linux Mint</span></a>
<br>
<a href="https://www.lifewire.com/choose-best-linux-distro-for-needs-2201172">Choose The Best Linux Distro</a>
<a href="https://en.wikipedia.org/wiki/List_of_Linux_distributions">List of Linux distributions</a>
<br>

<a href="http://www.cygwin.com/">Linux Terminal on Windows</a>
<a href="http://ss64.com/bash/">Bash commands</a>


<a href="http://kevinboone.net/kbox.html">KBOX — a miniature Linux</a>

<a href="Convert Android to Linux.html">Convert Android to Linux</a>
<br>
<a href="https://www.androidauthority.com/an-introduction-to-basic4android-678630/">Basic4Android building Android apps</a>
<br>

<a href="http://linux.about.com/od/commands/tp/11-Linux-Terminal-Commands-That-Will-Rock-Your-World.01.htm">15 Linux Terminal Commands</a>



<br>
<a href="http://youtu.be/AO0jzD1hpXc">linux command line</a>
<br>
<a href="http://www.howtogeek.com/howto/14912/create-a-persistent-bootable-ubuntu-usb-flash-drive/">Create a Live Ubuntu USB Drive With Persistent Storage</a>
<br>

<h2>ubuntu KeyboardShortcuts</h2>
<a href="http://help.ubuntu.com/community/KeyboardShortcuts">ubuntu KeyboardShortcuts</a>
<a href="http://help.ubuntu.com/stable/ubuntu-help/shell-keyboard-shortcuts.html">ubuntu键盘快捷键</a>
<br>

<br>

<a href="http://opensource.com/article/17/2/command-line-tools-data-analysis-linux"><i class="redrose">10 Command-line Tools For Data Analysis In Linux</i></a>
<br>
<a href="http://www-uxsup.csx.cam.ac.uk/pub/doc/suse/suse9.0/userguide-9.0/ch24s04.html">Important Linux Commands</a>
<br>

<a href="http://opensource.com/article/17/2/linux-boot-and-startup"><b class="redbord">Introduction To The Linux Boot And Startup Processes</b></a>
<br>
<a href="LibDocs\Useful Shell Commands For Data Science.html">&diams;Useful Shell Commands For Data Science</a><br>
<a href="http://chuansong.me/account/LinuxHub">Linux爱好者</a>
<br>
<a href="http://chuansong.me/n/2274461349222">ln 命令教程</a>
<br>
<a href="https://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&mid=2666542070&idx=1&sn=35edea5336adf8f90edd378990b171a9&chksm=80dcf75db7ab7e4bc7e332a14c0c4d7db0384605956b0747481d9ea8b3f016eeb18e088530b5&scene=0#rd">给初学者的 type 命令教程</a>
<br>

<a href="https://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&mid=2666542083&idx=1&sn=9cf98a54d4cbfb71f28e1a3b859cd06a&chksm=80dcf0a8b7ab79be682047c2e6005658e0902c3319616aaa05d44f3f9262d79b070af9ae7808&mpshare=1&scene=1&srcid=04101cieV7TCBgTlfS8VrLHn&pass_ticket=ffHA2AbUubeZmNO0YwV710%2F%2F4ddlmoyHLacbjI9AFiSmoDbzHsy0wRqDu5yHGUGA#rd">10 个增加 UNIX/Linux Shell 脚本趣味的工具</a>
<br>
<a href="https://mp.weixin.qq.com/s?__biz=MzA4MjEyNTA5Mw==&mid=2652567459&idx=2&sn=234daf978537df5d0ec880b4995ef3f8&chksm=8464dfe9b31356ffe317d3d89adc593c329c215e9f33cc65738fd775bd5be5635adae20728a9&mpshare=1&scene=1&srcid=0410a3J2g7lgX8CNiQATAnzd&pass_ticket=ffHA2AbUubeZmNO0YwV710%2F%2F4ddlmoyHLacbjI9AFiSmoDbzHsy0wRqDu5yHGUGA#rd">Linux 启动过程分析</a>
<br>
<a href="https://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&mid=2666542052&idx=1&sn=1b42479e652f36bc5f3940033531dcc5&chksm=80dcf74fb7ab7e5914ca7edbcf0b22df8d0493d73930900944701b15c98a23f37abc995bdb01&mpshare=1&scene=1&srcid=0410P7JFsjA1mgXsos2RRyoU&pass_ticket=ffHA2AbUubeZmNO0YwV710%2F%2F4ddlmoyHLacbjI9AFiSmoDbzHsy0wRqDu5yHGUGA#rd">为初学者准备的 ln 命令教程（5 个示例）</a>
<br>
<br>
<a href="https://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&mid=2666542070&idx=1&sn=35edea5336adf8f90edd378990b171a9&chksm=80dcf75db7ab7e4bc7e332a14c0c4d7db0384605956b0747481d9ea8b3f016eeb18e088530b5&mpshare=1&scene=1&srcid=0410x0mWVNkLd4fk9xLGMsYs&pass_ticket=ffHA2AbUubeZmNO0YwV710%2F%2F4ddlmoyHLacbjI9AFiSmoDbzHsy0wRqDu5yHGUGA#rd">给初学者的 type 命令教程</a>
<br>
<a href="https://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&mid=2666542041&idx=1&sn=d4688e9df9a33b2c80b8ca2b7d08e508&chksm=80dcf772b7ab7e646985ce289660ed0e1925138a84136bbe0ffe1fc0836716e951fb580bb47a&mpshare=1&scene=1&srcid=0410oxyrfsSgRuesiYKfa8Qk&pass_ticket=ffHA2AbUubeZmNO0YwV710%2F%2F4ddlmoyHLacbjI9AFiSmoDbzHsy0wRqDu5yHGUGA#rd">升级到 Ubuntu 18.04 LTS 的理由，大波新特性到来</a>
<br>
<a href="https://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&mid=2666542031&idx=1&sn=748831d1d635a7873136aeac6ae1828a&chksm=80dcf764b7ab7e729f264f35c24b7992446d16528c29c9c754f8d4e4f7bb09184588ee9677e0&mpshare=1&scene=1&srcid=0410njlSIQFRMdcZ4Jl5hiqS&pass_ticket=ffHA2AbUubeZmNO0YwV710%2F%2F4ddlmoyHLacbjI9AFiSmoDbzHsy0wRqDu5yHGUGA#rd">如何在 Linux 上安装应用程序</a>
<br>
<a href="https://itsfoss.com/things-to-do-after-installing-linux-mint-18/">things-to-do-after-installing-linux-mint</a>
<br>
<a href="https://www.ubuntupit.com/top-10-best-things-installing-linux-mint-18-3-sylvia/">best-things-installing-linux-mint</a>

<h2>Important Linux Commands</h2>
<a href="http://www-uxsup.csx.cam.ac.uk/pub/doc/suse/suse9.0/userguide-9.0/index.html" class="whitebut ">SuSE Linux User Guide</a>
<a href="http://www-uxsup.csx.cam.ac.uk/pub/doc/suse/suse9.0/userguide-9.0/ch24.html" class="whitebut ">Chapter 24. Working with the Shell</a>

This section gives insight into the most important commands of your SuSE Linux system. 
Along with the individual commands, parameters are listed and, where appropriate, a typical sample application is introduced. 
To learn more about the various commands, it is usually possible to get additional information with the <b class="brown">man</b> program followed by the name of the command, for example, <b class="brown">man ls</b>.
In these <a href="http://www-uxsup.csx.cam.ac.uk/pub/doc/suse/suse9.0/userguide-9.0/go01.html#manpage"><i class="glossterm">manual pages</i></a>, move up and down with <b class="keycap">PgUp</b> and <b class="keycap">PgDn</b> and move between the beginning and the end of a document with <b class="keycap">Home</b> and <b class="keycap">End</b>. 
End this viewing mode by pressing <b class="keycap">Q</b>. 
Learn more about the <b class="brown">man</b> command itself with <b class="brown">man</b>.
There are many more commands than listed in this chapter. 
For information about other commands or more detailed information, we recommend the O'Reilly publication <span class="orange">Linux in a Nutshell</span>. 
In the following overview, the individual command elements are written in different typefaces.
<ul type="disc"><li>The actual command is always printed as <b class="brown">command</b>. 
Without this, nothing can function.
</li><li>Options without which the respective program cannot function are printed in <tt class="green">italics</tt>.
</li><li>Further details, like file names, which must be passed to a command for correct functioning, are written in the <span class="texttt">Courier</span> font.
</li><li>Specifications or parameters that are not required are placed in <tt class="green">[brackets]</tt>.
</li></ul>
Adjust possible specifications to your needs. 
It makes no sense to write <b class="brown">ls file(s)</b>, if no file named <tt class="green">file(s)</tt> actually exists. 
You can usually combine several parameters, for example, by writing <b class="brown">ls -la</b> instead of <b class="brown">ls -l -a</b>.

<h2>File Commands</h2><h2>File Administration Commands</h2>
<dl>
<dt><span class="brown"><b class="brown">ls</b> <tt class="green">[option(s)]</tt> <tt class="green">[file(s)]</tt></span> If you run <b class="brown">ls</b> without any additional parameters, the program will list the contents of the current directory in short form.
<dl>
<dt><span class="brown">-l</span> detailed list

<dt><span class="brown">-a</span> displays hidden files
</dd></dl>

<dt><span class="brown"><b class="brown">cp</b> <tt class="green">[option(s)]</tt> <tt class="green">sourcefile targetfile</tt></span> Copies <tt class="green">sourcefile</tt> to <tt class="green">targetfile</tt>.
<dl>
<dt><span class="brown">-i</span> Waits for confirmation, if necessary, before an existing <tt class="green">targetfile</tt> is overwritten

<dt><span class="brown">-r</span> Copies recursively (includes subdirectories)
</dd></dl>

<dt><span class="brown"><b class="brown">mv</b> <tt class="green">[option(s)]</tt> <tt class="green">sourcefile targetfile</tt></span> Copies <tt class="green">sourcefile</tt> to <tt class="green">targetfile</tt> then deletes the original <tt class="green">sourcefile</tt>.
<dl>
<dt><span class="brown">-b</span> Creates a backup copy of the <tt class="green">sourcefile</tt> before moving

<dt><span class="brown">-i</span> Waits for confirmation, if necessary, before an existing <span class="texttt">targetfile</span> is overwritten
</dd></dl>

<dt><span class="brown"><b class="brown">rm</b> <tt class="green">[option(s)]</tt> <tt class="green">file(s)</tt></span> Removes the specified files from the file system. 
Directories are not removed by <b class="brown">rm</b> unless the option <tt class="green">-r</tt> is used.
<dl>
<dt><span class="brown">-r</span> Deletes any existing subdirectories

<dt><span class="brown">-i</span> Waits for confirmation before deleting each file.
</dd></dl>

<dt><span class="brown"><b class="brown">ln</b> <tt class="green">[option(s)]</tt> <tt class="green">sourcefile</tt> <tt class="green">targetfile</tt></span> Creates an internal <a href="http://www-uxsup.csx.cam.ac.uk/pub/doc/suse/suse9.0/userguide-9.0/go01.html#link"><i class="glossterm">link</i></a> from the <tt class="green">sourcefile</tt> to the <tt class="green">targetfile</tt>, under a different name. 
Normally, such a link points directly to the <tt class="green">sourcefile</tt> on one and the same file system. 
However, if <b class="brown">ln</b> is executed with the <tt class="green">-s</tt> option, it creates a symbolic link that only points to the directory where the <tt class="green">sourcefile</tt> is located, thus enabling linking across file systems.
<dl>
<dt><span class="brown">-s</span> Creates a symbolic link
</dd></dl>

<dt><span class="brown"><b class="brown">cd</b> <tt class="green">[options(s)]</tt> <tt class="green">[directory]</tt></span> Changes the current directory. 
<b class="brown">cd</b> without any parameters changes to the user's home directory.

<dt><span class="brown"><b class="brown">mkdir</b> <tt class="green">[option(s)]</tt> <tt class="green">directoryname</tt></span> Creates a new directory.

<dt><span class="brown"><b class="brown">rmdir</b> <tt class="green">[option(s)]</tt> <tt class="green">directoryname</tt></span> Deletes the specified directory, provided it is already empty.

<dt><span class="brown"><b class="brown">chown</b> <tt class="green">[option(s)] username.group</tt> <tt class="green">file(s)</tt></span> Transfers the ownership of a file to the user with the specified user name.
<dl>
<dt><span class="brown">-R</span> Changes files and directories in all subdirectories.
</dd></dl>

<dt><span class="brown"><b class="brown">chgrp</b> <tt class="green">[option(s)] groupname</tt> <tt class="green">file(s)</tt></span> Transfers the group ownership of a given <tt class="green">file</tt> to the group with the specified group name. 
The file owner can only change group ownership if a member of both the existing and the new group.

<dt><span class="brown"><b class="brown">chmod</b> <tt class="green">[options]</tt> <tt class="green">mode</tt> <tt class="green">file(s)</tt></span> Changes the access permissions.
The <tt class="green">mode</tt> parameter has three parts: <tt class="green">group</tt>, <tt class="green">access</tt>, and <tt class="green">access type</tt>. 
<tt class="green">group</tt> accepts the following characters:
<dl>
<dt><span class="brown">u</span> user

<dt><span class="brown">g</span> group

<dt><span class="brown">o</span> others
</dd></dl>
For <tt class="green">access</tt>, access is granted by the <tt class="green">+</tt> symbol and denied by the <tt class="green">-</tt> symbol.
The <tt class="green">access type</tt> is controlled by the following options:
<dl>
<dt><span class="brown">r</span> read

<dt><span class="brown">w</span> write

<dt><span class="brown">x</span> eXecute &#8212; executing files or changing to the directory.

<dt><span class="brown">s</span> Set uid bit &#8212; the application or program is started as if it were started by the owner of the file.
</dd></dl>

<dt><span class="brown"><b class="brown">gzip</b> <tt class="green">[parameters]</tt> <tt class="green">file(s)</tt></span> This program compresses the contents of files, using complex mathematical algorithms. 
Files compressed in this way are given the extension <tt class="green">.gz</tt> and need to be uncompressed before they can be used. 
 To compress several files or even entire directories, use the <b class="brown">tar</b> command.
<dl>
<dt><span class="brown">-d</span> decompresses the packed gzip files so they return to their original size and can be processed normally (like the command <b class="brown">gunzip</b>).
</dd></dl>

<dt><span class="brown"><b class="brown">tar</b> <tt class="green">options</tt> <tt class="green">archive</tt> <tt class="green">file(s)</tt></span> The <b class="brown">tar</b> puts one file or (usually) several files into an archive. 
Compression is optional.
<b class="brown">tar</b> is a quite complex command with a number of options available. 
The most frequently used options are:
<dl>
<dt><span class="brown">-f</span> Writes the output to a file and not to the screen as is usually the case

<dt><span class="brown">-c</span> Creates a new tar archive

<dt><span class="brown">-r</span> Adds files to an existing archive

<dt><span class="brown">-t</span> Outputs the contents of an archive

<dt><span class="brown">-u</span> Adds files, but only if they are newer than the files already contained in the archive

<dt><span class="brown">-x</span> Unpacks files from an archive (<i class="wordasword">extraction</i>)

<dt><span class="brown">-z</span> Packs the resulting archive with <b class="brown">gzip</b>

<dt><span class="brown">-j</span> Compresses the resulting archive with <b class="brown">bzip2</b>

<dt><span class="brown">-v</span> Lists files processed
</dd></dl>
The archive files created by <b class="brown">tar</b> end with <tt class="green">.tar</tt>. 
If the tar archive was also compressed using <b class="brown">gzip</b>, the ending is <tt class="green">.tgz</tt> or <tt class="green">.tar.gz</tt>. 
If it was compressed using <b class="brown">bzip2</b>, <tt class="green">.tar.bz2</tt>.
Application examples can be found in Section <a href="http://www-uxsup.csx.cam.ac.uk/pub/doc/suse/suse9.0/userguide-9.0/ch24s02.html#sec:bash.tar" title="Archives and Data Compression">&#8220;Archives and Data Compression&#8221;</a>.

<dt><span class="brown"><b class="brown">locate</b> <tt class="green">pattern(s)</tt></span> The <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">locate</span></span> command can find in which directory a specified file is located. 
If desired, use <a href="http://www-uxsup.csx.cam.ac.uk/pub/doc/suse/suse9.0/userguide-9.0/go01.html#wildcard"><i class="glossterm">wild cards</i></a> to specify file names. 
The program is very speedy, as it uses a database specifically created for the purpose (rather than searching through the entire file system). 
This very fact, however, also results in a major drawback: <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">locate</span></span> is unable to find any files created after the latest update of its database.
The database can be generated by <tt class="systemitem">root</tt> with <b class="brown">updatedb</b>.

<dt><span class="brown"><b class="brown">updatedb</b> <tt class="green">[options(s)]</tt></span> This command performs an update of the database used by <b class="brown">locate</b>. 
To include files in all existing directories, run the program as <tt class="systemitem">root</tt>. 
It also makes sense to place it in the background by appending an ampersand (<tt class="systemitem">&amp;</tt>), so you can immediately continue working on the same command line (<b class="brown">updatedb &amp;</b>).

<dt><span class="brown"><b class="brown">find</b> <tt class="green">[option(s)]</tt></span> The <b class="brown">find</b> command allows you to search for a file in a given directory. 
The first argument specifies the directory in which to start the search. 
The option <b class="brown">-name</b> must be followed by a search string, which may also include <a href="http://www-uxsup.csx.cam.ac.uk/pub/doc/suse/suse9.0/userguide-9.0/go01.html#wildcard"><i class="glossterm">wild cards</i></a>. 
Unlike <b class="brown">locate</b>, which uses a database, <b class="brown">find</b> scans the actual directory.
</dd></dl>
<h2>Commands to Access File Contents Commands</h2>
<dl>
<dt><span class="brown"><b class="brown">cat</b> <tt class="green">[option(s)]</tt> <tt class="green">file(s)</tt></span> The <b class="brown">cat</b> command displays the contents of a file, printing the entire contents to the screen without interruption.
<dl>
<dt><span class="brown">-n</span> Numbers the output on the left margin
</dd></dl>

<dt><span class="brown"><b class="brown">less</b> <tt class="green">[option(s)]</tt> <tt class="green">file(s)</tt></span> This command can be used to browse the contents of the specified file. 
Scroll half a screen page up or down with <b class="keycap">PgUp</b> and <b class="keycap">PgDn</b> or a full screen page down with <b class="keycap">Space</b>. 
Jump to the beginning or end of a file using <b class="keycap">Home</b> and <b class="keycap">End</b>. 
Press <b class="keycap">Q</b> to exit the program.

<dt><span class="brown"><b class="brown">grep</b> <tt class="green">[option(s)]</tt> <tt class="green">searchstring</tt> <tt class="green">filenames</tt></span> The <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">grep</span></span> command finds a specific <tt class="green">searchstring</tt> in the specified <tt class="green">file(s)</tt>. 
If the search string is found, the command displays the line in which the <tt class="green">searchstring</tt> was found along with the file name.
<dl>
<dt><span class="brown">-i</span> Ignores case

<dt><span class="brown">-l</span> Only displays the names of the respective files, but not the text lines

<dt><span class="brown">-n</span> Additionally displays the numbers of the lines in which it found a hit

<dt><span class="brown">-l</span> Only lists the files in which <span class="orange">searchstring</span> does <span class="textbf">not</span> occur
</dd></dl>

<dt><span class="brown"><b class="brown">diff</b> <tt class="green">[option(s)]</tt> <tt class="green">file1 file2</tt></span> The <b class="brown">diff</b> command compares the contents of any two files. 
The output produced by the program lists all lines that do not match.
This is frequently used by programmers who need only send their program alterations and not the entire source code.
<dl>
<dt><span class="brown">-q</span> Only reports <span class="emphasis"><em>whether</em></span> the two given files differ
</dd></dl>
</dd></dl>
<h2>File Systems Commands</h2>
<dl>
<dt><span class="brown"><b class="brown">mount</b> <tt class="green">[option(s)] [&lt;device&gt;]</tt> <tt class="green">mountpoint</tt></span> This command can be used to mount any data media, such as hard disks, CD-ROM drives, and other drives, to a directory of the Linux file system.
<dl>
<dt><span class="brown">-r</span> mount read-only

<dt><span class="brown">-t filesystem</span> Specifies the file system. 
The most common are <tt class="green">ext2</tt> for Linux hard disks, <tt class="green">msdos</tt> for MS-DOS media, <tt class="green">vfat</tt> for the Windows file system, and <tt class="green">iso9660</tt> for CDs.
</dd></dl>
For hard disks not defined in the file <tt class="green">/etc/fstab</tt>, the device type must also be specified. 
In this case, only <tt class="systemitem">root</tt> can mount. 
If the file system should also be mounted by other users, enter the option <tt class="green">user</tt> in the appropriate line in the <tt class="green">/etc/fstab</tt> file (separated by commas) and save this change. 
Further information is available in <span class="citerefentry"><span class="refentrytitle">mount</span></span>.

<dt><span class="brown"><b class="brown">umount</b> <tt class="green">[option(s)]</tt> <tt class="green">mountpoint</tt></span> This command unmounts a mounted drive from the file system. 
To prevent data loss, run this command before taking a removable data medium from its drive. 
Normally, only <tt class="systemitem">root</tt> is allowed to run the commands <b class="brown">mount</b> and <b class="brown">umount</b>. 
To enable other users to run these commands, edit the <tt class="green">/etc/fstab</tt> file to specify the option <tt class="green">user</tt> for the respective drive.
</dd></dl>


<h2>System Commands</h2><h2>System Information Commands</h2>
<dl>
<dt><span class="brown"><b class="brown">df</b> <tt class="green">[option(s)]</tt> <tt class="green">[directory]</tt></span> The <b class="brown">df</b> (disk free) command, when used without any options, displays information about the total disk space, the disk space currently in use, and the free space on all the mounted drives. 
If a directory is specified, the information is limited to the drive on which that directory is located.
<dl>
<dt><span class="brown">-H</span> shows the number of occupied blocks in gigabytes, megabytes, or kilobytes &#8212; in human-readable format

<dt><span class="brown">-t</span> Type of file system (ext2, nfs, etc.)
</dd></dl>

<dt><span class="brown"><b class="brown">du</b> <tt class="green">[option(s)]</tt> <tt class="green">[path]</tt></span> This command, when executed without any parameters, shows the total disk space occupied by files and subdirectories in the current directory.
<dl>
<dt><span class="brown">-a</span> Displays the size of each individual file

<dt><span class="brown">-h</span> Output in human-readable form

<dt><span class="brown">-s</span> Displays only the calculated total size
</dd></dl>

<dt><span class="brown"><b class="brown">free</b> <tt class="green">[option(s)]</tt></span> The command <b class="brown">free</b> displays information about RAM and swap space usage, showing the total and the used amount in both categories.
<dl>
<dt><span class="brown">-b</span> Output in bytes

<dt><span class="brown">-k</span> Output in kilobytes

<dt><span class="brown">-m</span> Output in megabytes
</dd></dl>

<dt><span class="brown"><b class="brown">date</b> <tt class="green">[option(s)]</tt></span> This simple program displays the current system time. 
If run as <tt class="systemitem">root</tt>, it can also be used to change the system time. 
Details about the program are available in <span class="citerefentry"><span class="refentrytitle">date</span></span>.
</dd></dl>
<h2>Processes Commands</h2>
<dl>
<dt><span class="brown"><b class="brown">top</b> <tt class="green">[options(s)]</tt></span> <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">top</span></span> provides a quick overview of the currently running <a href="http://www-uxsup.csx.cam.ac.uk/pub/doc/suse/suse9.0/userguide-9.0/go01.html#process"><i class="glossterm">processes</i></a>. 
Press <b class="keycap">H</b> to access a page that briefly explains the main options to customize the program.

<dt><span class="brown"><b class="brown">ps</b> <tt class="green">[option(s)] [process ID]</tt></span> If run without any options, this command displays a table of all <i class="wordasword">your own</i> programs or processes &#8212; those you started. 
The options for this command are <span class="textbf">not</span> preceded by hyphen.
<dl>
<dt><span class="brown">aux</span> Displays a detailed list of all processes, independent of the owner.
</dd></dl>

<dt><span class="brown"><b class="brown">kill</b> <tt class="green">[option(s)]</tt> <tt class="green">process ID</tt></span> Unfortunately, sometimes a program cannot be terminated in the normal way. 
However, in most cases, you should still be able to stop such a runaway program by executing the <b class="brown">kill</b> command, specifying the respective process ID (see <b class="brown">top</b> and <b class="brown">ps</b>).
<b class="brown">kill</b> sends a <i class="wordasword">TERM</i> signal that instructs the program to shut itself down. 
If this does not help, the following parameter can be used:
<dl>
<dt><span class="brown">-9</span> Sends a <i class="wordasword">KILL</i> signal instead of a <i class="wordasword">TERM</i> signal, with which the process really is <i class="wordasword">annihilated</i> by the operating system. 
This brings the specific processes to an end in almost all cases.
</dd></dl>

<dt><span class="brown"><b class="brown">killall</b> <tt class="green">[option(s)] processname</tt></span> This command is similar to <b class="brown">kill</b>, but uses the process name (instead of the process ID) as an argument, causing all processes with that name to be killed.
</dd></dl>
<h2>Network Commands</h2>
<dl>
<dt><span class="brown"><b class="brown">ping</b> <tt class="green">[option(s)]</tt> <tt class="green">host name|IP address</tt></span> The <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">ping</span></span> command is the standard tool for testing the basic functionality of TCP/IP networks. 
It sends a small data packet to the destination host, requesting an immediate reply. 
If this works, <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">ping</span></span> displays a message to that effect, which indicates that the network link is basically functioning.
<dl>
<dt><span class="brown">-c</span> <tt class="green">number</tt> Determines the total number of packages to send and ends after they have been dispatched. 
By default, there is no limitation set.

<dt><span class="brown">-f</span> <i class="wordasword">flood ping</i>: sends as many data packages as possible. 
A popular means, reserved to <tt class="systemitem">root</tt>, to test networks.

<dt><span class="brown">-i</span> <tt class="green">value</tt> Specifies the interval between two data packages in seconds. 
Default: one second
</dd></dl>

<dt><span class="brown"><b class="brown">nslookup</b></span> The Domain Name System resolves domain names to IP addresses. 
With this tool, send queries to information servers (DNS servers).

<dt><span class="brown"><b class="brown">telnet</b> <tt class="green">[option(s)] host name or IP address</tt></span> Telnet is actually an Internet protocol that enables you to work on remote hosts across a network. 
<span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">telnet</span></span> is also the name of a Linux program that uses this protocol to enable operations on remote computers. 

<h3>Warning</h3>Do not use telnet over a network on which third parties can <i class="wordasword">eavesdrop.</i> Particularly on the Internet, use encrypted transfer methods, such as <b class="brown">ssh</b>, to avoid the risk of malicious misuse of a password (see the man page for <b class="brown">ssh</b>).

</dd></dl>
<h2>Miscellaneous Commands</h2>
<dl>
<dt><span class="brown"><b class="brown">passwd</b> <tt class="green">[option(s)] [username]</tt></span> Users may change their own passwords at any time using this command. 
Furthermore, the administrator <tt class="systemitem">root</tt> can use the command to change the password of any user on the system.

<dt><span class="brown"><b class="brown">su</b> <tt class="green">[option(s)]</tt> <tt class="green">[username]</tt></span> The <b class="brown">su</b> command makes it possible to log in under a different user name from a running session. 
When using the command without specifying a user name, you will be prompted for the <tt class="systemitem">root</tt> password. 
Specify a user name and the corresponding password to use the environment of the respective user. 
The password is not required from <a href="http://www-uxsup.csx.cam.ac.uk/pub/doc/suse/suse9.0/userguide-9.0/go01.html#root"><i class="glossterm"><tt class="systemitem">root</tt></i></a>, as <tt class="systemitem">root</tt> is authorized to assume the identity of any user.

<dt><span class="brown"><b class="brown">halt</b> <tt class="green">[option(s)]</tt></span> To avoid loss of data, you should always use this program to shut down your system.

<dt><span class="brown"><b class="brown">reboot</b> <tt class="green">[option(s)]</tt></span> Does the same as <b class="brown">halt</b> with the difference that the system performs an immediate reboot.

<dt><span class="brown"><b class="brown">clear</b></span> This command cleans up the visible area of the console. 
It has no options.
</dd></dl>

<h2>Ubuntu vs Fedora</h2>

Ubuntu 和 Fedora 都是最流行的 Linux 发行版之一，在两者之间做出选择实非易事。

在这篇文章里，我会对比一下 Ubuntu 和 Fedora 的不同特点，帮助你进行决策。

请注意，这篇文章主要是从桌面版的角度进行对比的。

Fedora 或者 Ubuntu 针对容器的特殊版本不会被考虑在内。

Ubuntu vs Fedora: 哪一个更好？

不同 Linux 发行版之间的区别主要体现在以下几个方面：

◈基础发行版（Debian、红帽、Arch，或者是从头做起）

◈安装方式

◈支持的桌面环境

◈软件包管理、软件支持和更新

◈硬件支持

◈开发团队（由企业支持，还是由业余爱好者创建）

◈发布周期

◈社区和线上支持

下面我们来看一下 Ubuntu 和 Fedora 之间的相似之处和不同之处。

掌握了这些信息之后，也许就更容易在两者之间做出选择了。
安装方式

Ubuntu 的 Ubiquity 安装器是最好用的安装器之一。

我认为这是让 Ubuntu 如此流行的重要原因之一，因为在 2004 年 Ubuntu 刚刚诞生的时候，安装 Linux 还是一个很庞大的工程。

Ubuntu 安装器可以让你在大约 10 分钟左右完成安装。

大多数情况下，它还可以识别出机器里安装的 Windows 系统，并且只需要几下点击就可以实现 Ubuntu 和 Windows 的双系统启动。

锦上添花的是，在安装 Ubuntu 的过程中你还可以进行系统更新，或者是安装第三方编译码器。

<img class="lazy" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/W9DqKgFsc68kThgIF4b5pq9WhBribLIthXbem58BMia3PjK5U6ick6M0pEDeibvOHxLYcJAlH6RW1wZ7VHfsPtJ0Zg/640">
Ubuntu Installer

Fedora 使用的是 Anaconda 安装器，拥有简单易用的界面，同样简化了安装过程。

<img class="lazy" data-src="https://mmbiz.qpic.cn/mmbiz_png/W9DqKgFsc68kThgIF4b5pq9WhBribLIth6p2BUtjqPQx5lF7cK5OuA7LssRI5EhibHH2rxyZkE8sTQ8lRPZvyEJQ/640">

Fedora Installer | Image Credit Fedora Magazine

Fodora 还提供了一个可以在 Windows 操作系统上下载并创建 Fedora live USB 的写入工具。

不过我在大约两年前尝试使用它的时候并不成功，最后使用了一个常规的创建 live USB 的软件。

根据我的经验，安装 Ubuntu 要比安装 Fedora 容易一些。

不过这并不是说安装 Fedora 有多困难，只是 Ubuntu 更简单而已。
桌面环境

Ubuntu 和 Fedora 默认都使用 GNOME 桌面环境。

<img class="lazy" data-src="https://mmbiz.qpic.cn/mmbiz_png/W9DqKgFsc68kThgIF4b5pq9WhBribLIthFh2duDC9jibEoaKxIdatSKBFzpAEjjzqbQPhZnMkKbM6TCGC6yCByJQ/640">

GNOME Desktop in Fedora

Fedora 使用的是原装的 GNOME 桌面，而 Ubuntu 则在此基础上做了个性化调整，让它看起来就像 Ubuntu 之前使用的 Unity 桌面环境。

<img class="lazy" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/W9DqKgFsc68kThgIF4b5pq9WhBribLIthnLkicPViazT63KwCZ3r1cgic2IOibMYvu2BUGUzQNxED0FUFWq4lksDzJQ/640">

GNOME desktop customized by Ubuntu

除了 GNOME，Ubuntu 和 Fedora 都提供了一些其它桌面环境的版本。

Ubuntu 有 Kubuntu、Xubuntu、Lubuntu 等版本，分别提供不同的桌面环境。

虽然它们都是 Ubuntu 的官方版本，但是却不是由 Canonical 的 Ubuntu 团队直接开发的，而是由另外的团队开发。

Fedora 通过 Fedora Spins 的方式提供了一些不同桌面环境的版本。

和 Kubuntu、Lubuntu 等版本不同的是，这些版本并非由独立团队开发，而是由 Fedora 核心团队开发的。

软件包管理和可用软件数量

Ubuntu 使用 APT 软件包管理器提供软件并进行管理（包括应用程序、库，以及其它所需编解码器），而 Fedora 使用 DNF 软件包管理器。
Ubuntu 拥有庞大的软件仓库，能够让你轻松安装数以千计的程序，包括 FOSS（LCTT 译注：

Free and Open-Source Software 的缩写，自由开源软件）和非 FOSS 的软件。

Fedora 则只专注于提供开源软件。

虽然这一点在最近的版本里有所转变，但是 Fedora 的软件仓库在规模上仍然比 Ubuntu 的要逊色一些。

一些第三方软件开发者为 Linux 提供像 .exe 文件一样可以点击安装的软件包。

在 Ubuntu 里这些软件包是 .deb 格式的，在 Fedora 里是 .rpm 格式的。

大多数软件供应商都为 Linux 用户提供 DEB 和 RPM 文件，但是我也经历过供应商只提供 DEB 文件的情况。

比如说 SEO 工具 Screaming Frog 就只提供 DEB 软件包。

反过来，一个软件只有 RPM 格式但是没有 DEB 格式这种情况就极其罕见了。
硬件支持

一般来说，Linux 在 WiFi 适配器和显卡的兼容性上容易出现问题，Ubuntu 和 Fedora 都受此影响。

以 Nvidia 为例，它的开源驱动程序 Nouveau 经常会引发系统启动时假死机之类的问题。

在 Ubuntu 上你可以轻松安装专有驱动程序作为补充。

在很多情况下，这样可以获得对硬件更好的支持。

<img class="lazy" data-src="https://mmbiz.qpic.cn/mmbiz_png/W9DqKgFsc68kThgIF4b5pq9WhBribLIthqJmD1tE9fWuO3OTtCrsm1eOA4D5aFwyWWmgaLRHJtqs1ROVguK5OcQ/640">

Installing proprietary driver is easier in Ubuntu

Fedora 则坚持使用开源软件，所以在 Fedora 上安装专有驱动程序就比较困难了。
线上支持和用户群

Ubuntu 和 Fedora 都通过社区论坛提供了很好的线上支持。
Ubuntu 主要有两个论坛：

UbuntuForums 和 Ask Ubuntu。

Fedora 主要的论坛则是 Ask Fedora。

就用户群体而言，Fedora 有着庞大的用户数量。

不过 Ubuntu 更为流行，用户数量甚至更为庞大。

Ubuntu 的流行催生了很多专注于 Ubuntu 的网站和博客。

所以相比 Fedora，你可以得到更多关于 Ubuntu 的故障排除指导和学习材料。
发布周期

Fedora 每六个月发布一个新版本，每个版本有九个月的支持周期。

也就是说，你必须在六个月到九个月之间进行一次系统升级。

进行 Fedora 版本升级并不是一件困难的事情，但是需要良好的网络连接。

并非所有人都喜欢每九个月进行一次 1.5 GB 的版本升级。
Ubuntu 有两种版本：

常规发布版本和长期支持（LTS）发布版本。

常规版本和 Fedora 比较类似，每隔六个月发布一次，有九个月的支持周期。

而长期支持发布版本则每两年发布一次，有五年的支持周期。

常规发布版本探索新功能特性和新的软件版本，而长期支持发布版本则支持旧版本软件。

对于不喜欢经常改变、青睐稳定性的人来说，这是一个很好的选择。
强大的基础发行版

Ubuntu 是基于 Debian 发行版的。

Debian 是最大的社区项目之一，并且也是自由软件世界里最受尊敬的项目之一。

Fedora 则是红帽公司的一个社区项目。

红帽公司是一个专注于 Linux 发行版的公司。

Fedora 充当了一个“试验田”的角色（用技术术语来说叫做“上游”），用来在红帽企业级 Linux 发布新功能之前对这些新功能进行试验。
在背后支持的企业

Ubuntu 和 Fedora 都有来自母公司的支持。
Ubuntu 源自 Canonical 公司，而 Fedora 源自红帽公司（现在是 IBM 的一部分）。

背后企业的支持非常重要，因为可以确保 Linux 发行版良好的维护。

有一些发行版是由一群独立的业余爱好者们共同创建的，但是在工作压力之下经常会结束。

你也许见过一些还算比较流行的发行版项目仅仅是因为这个原因而终止了。

很多这样的发行版由于开发者没有足够的业余时间可以投入到项目上而不得不终止，比如 Antergos 和 Korora。

Ubuntu 和 Fedora 的背后都有基于 Linux 的企业的支持，这让它们比其它独立的发行版更胜一筹。
Ubuntu vs Fedora：服务端

到目前为止，我们在 Ubuntu 和 Fedora 之间的对比主要都集中在桌面端。

不过如果不考虑一下服务端的话，对 Linux 的讨论就不能算是完整的。

<img class="lazy" data-src="https://mmbiz.qpic.cn/mmbiz_png/W9DqKgFsc68kThgIF4b5pq9WhBribLIthCB7gKg0g865BaTUTfWBgUh6opNvq0uLyPU85YrGWgQ7L4gjiakNwm5w/640">
Ubuntu Server

Ubuntu 不仅在桌面端很流行，在服务端也有很强的存在感。

如果你能够在桌面端熟练使用 Ubuntu，那么也不会对 Ubuntu 服务器版本感到陌生。

我就是从使用 Ubuntu 桌面端开始的，现在我的网站都运行在 Ubuntu 服务器上。

Fedora 同样有服务端版本，并且也有人在使用。

但是大多数系统管理者不会喜欢一个每九个月就需要重启升级的服务器。

学习 Fedora 可以更好地帮助你使用红帽企业级 Linux（RHEL）。

RHEL 是一个付费产品，你需要购买订阅才可以使用。

如果你希望在服务器上运行一个和 Fedora 或者红帽类似的操作系统，我推荐使用 CentOS。

CentOS 同样是红帽公司附属的一个社区项目，但是专注于服务端。
结论

你可以看到，Ubuntu 和 Fedora 有很多相似之处。

不过就可用软件数量、驱动安装和线上支持来说，Ubuntu 的确更有优势。

Ubuntu 也因此成为了一个更好的选择，尤其是对于没有经验的 Linux 新手而言。

如果你想要熟悉红帽的话，Fedora 是一个很好的开始。

如果你对 Linux 有一定经验，或者是只想要使用开源软件，Fedora 就是一个很棒的选择。

最终还是需要你自己来决定是使用 Fedora 还是 Ubuntu。

我会建议为两个发行版分别创建一个 live USB，并且在虚拟机上体验一下。

<h2>Linux 命令行下搜索工具, CLI search</h2>
grep
使用 grep 的优势是它几乎可以在任意类 Unix 系统上使用。

常用 grep 命令的几种方式。
在 py 文件中找到一个关键字并且输出行号，可以这样操作：
$ grep -rins --include \*.py import .

回忆起部分命令。
通过管道（|）使用 grep 命令来搜索历史记录命令：
$ history | grep "python"

可以找到曾经运行过的所有包含 python 关键字的命令。

$ history | grep “python”
284  python test.py
...    #省略其它结果

$ !284
$ python test.py

ack
一个类似于 grep 并且为程序员优化过的工具
它在默认情况下以递归方式搜索，但是会忽略版本控制工具目录，比如 .git 目录。
并且它自带很多很实用的工具，可以大大提高我们搜索效率。

我们同样再拿出上面的例子来举例，下面我们使用 ack 命令来实现仅在 py 文件中搜索 import 关键字的方法：

# ack 命令实现方式
$ ack import --py

# grep 命令实现方式
$ grep -rins --include \*.py import .
上面是仅在 py 文件进行搜索，那假如我们想搜索除 py 文件类型以外的所有其他类型的文件，要怎么操作？

对于每个文件类型，都有一个对应的 no 标识，来排除对这个文件类型搜索。
比如，想搜索 py 文件的话就使用 --py 选项，而想排除 py 文件的话就使用 --nopy 选项。

$ ack import --nopy
当然文件类型有非常之多，我们还可以通过修改 ~/.ackrc 文件来扩展文件类型。
假如我们现在想搜索 .conf 文件，默认情况下 ack 不支持这种文件：

$ ack hello --conf
Unknown option: conf
ack: Invalid option on command line
要注册 .conf 文件类型，我们可以将以下内容添加到 ~/.ackrc 文件中，之后我们就可以正常搜索 conf 文件了。

--type-set=conf=.conf
配置文件修改之后，我们可以使用 --help-types 选项来确认自定义类型是否已经成功加上。

ack 命令从 .ackrc 文件中获取配置信息，但如何你想脱离 .ackrc 文件来运行 ack 命令的话，可以使用 -noenv 选项。

The Silver Searcher
该搜索器是另一个类似于 ack 的 grep 替代品，其更快的性能让大家很推崇。
它有个非常实用的特点，那就是它会忽略在项目工程中的 .gitignore 文件所指定的文件。
所以如果你想排除搜索一些文件，就可以将那些文件写在 .gitignore 文件里。

ag 命令
在 Ubuntu 系统上可以使用以下命令来安装 ag 命令：

$ apt-get install silversearcher-ag
使用 ag 命令来搜索 py 文件里包含关键字 import 的内容：

$ ag import --py
ag 命令十分强大，限于篇幅本文只介绍它最基本的用法，改天有时间的话再补充一下它其它非常强大的功能用法。

sift
sift 是使用 Golang 编写的 grep 替代品，这意味着它可以在 Linux，Windows，OS X 和其他系统上使用。
它的速度快得离谱，而且有一些很酷的用例来代替 grep + awk 组合来提取数据。

我们再使用 sift 命令来搜索所有 py 文件里包含 import 关键字的内容：

# 只搜索 py 文件：
sift --ext py import

# 排除 py 文件
sift --exclude-ext py import
RipGrep

RipGrep 与 Silver Searcher 类似，可以在 Mac、Linux 和 Windows 上运行。
它的 readme 文件声称，RipGrep 通常比其他任何搜索工具都快，它推崇 Rust 的正则表达式引擎，并像Silver Searcher一样使用 .gitignore 文件来排除一些文件或目录。

RipGrep 通常简称为 rg ，我们再使用 rg 命令来搜索所有 py 文件里包含 import 关键字的内容：
rg --type=py import

<h2>Command Line Tools to Find Files in Linux</h2>
1. Find Command
It supports multiple options to locate files using attributes such as permissions, users, groups, file type, date, size and other possible criteria.

2. Locate Command
instead of searching through the file system when a user initiates a file search operation, locate queries a database which contains bits and parts of files and their corresponding paths on the file system.
This database can be prepared and updated using the updatedb command. 
Note that locate will not report files created after the most recent update of the relevant database.

3. Grep Command
Although grep command is not a tool for directly searching files, you can employ it to locate files. 
For example, if you are looking for a README.md file which contains the phrase “An assortment”, which you suspect should be somewhere in your home directory, possibly in ~/bin.

$ grep -Ri ~/bin -e "An assortment" 
OR
$ grep -Ri ~/bin/ -e "An assortment" | cut -d: -f1
Where the grep flag:

-R – means search the specified directory recursively
-i – means ignore case distinctions
-e – specifies the phrase to be used as a pattern for searching
-d – specifies the delimter
-f – sets the field to be printed

4. Which Command
For example:
$ which find
$ which locate
$ which which

5. Whereis Command
$ whereis find
$ whereis locate
$ whereis which
$ whereis whereis

<h2>Linux notes.txt</h2>
=============
the right-ctrl key
remember to use the right-ctrl key in virtual box to switch out to windows

=============
Linux text editor:
gedit, pluma, vim, gvim, sublime text

=============
install packages from software manager or Synaptic manager 

=============
# to install vim
sudo apt-get install vim

#edit new file test
# https://www.radford.edu/~mhtay/CPSC120/VIM_Editor_Commands.htm
# VIM Editor Commands
https://www.fprintf.net/vimCheatSheet.html


vim test
hit i to insert
hit esc to exit insert mode


<h2>Working with the Shell, Introduction to Bash</h2>

In the KDE taskbar, there is an icon depicting a monitor with a seashell. 
When you click this icon with the mouse, a console window opens in which to enter commands. 
The console normally runs Bash (Bourne again shell), a program developed as part of the GNU  project. 
It is, by far, the most widely used derivative of the Bourne shell (sh). 
Once you have opened the shell, see the prompt on the first line. 
The prompt usually consists of the user name, host name, and current path, but it can be customized. 
When the cursor is behind this prompt, you can send commands directly to your computer system: <b class="brown">tux $ &gt;</b>. 

<h2>Bash: Commands</h2>

A command consists of several elements. 
The first element is always the actual command, followed by parameters or options. 
Commands are executed when you press <b class="orange">Return</b>. 
Before doing so, easily edit the command line, add options, or correct typing errors. 
One of the most frequently used commands is <b class="brown">ls</b>, which can be used with or without arguments. 
Entering the plain <b class="brown">ls</b> command in the console shows the contents of the current directory. 

Options are prefixed with a hyphen. 
The command <b class="brown">ls -l</b>, for instance, shows the contents of the same directory in full detail. 
Next to each file name, see the date when the file was created, the file size in bytes, and further details, which are covered later. 
One very important option that exists for many commands is the <b class="brown">--help</b> option. 
By entering <b class="brown">ls --help</b>, display all the options for the <b class="brown">ls</b> command.
Also use the <b class="brown">ls</b>  command to view the contents of other directories. 
To do so, the directory must be specified as a parameter. 
For example, to see the contents of <tt class="filename">Desktop</tt>, enter <b class="brown">ls -l Desktop</b>.

<h2>Bash: Files and Directories</h2>

To use the shell efficiently, it is really useful to have some knowledge about the file and directory structures of a Linux system. 
You can think of directories as electronic folders where files, programs, and subdirectories are stored. 
The top level directory in the hierarchy is the root directory, referred to as <tt class="filename">/</tt>. 
This is the place from which all other directories can be accessed.
The <tt class="filename">/home</tt> directory contains the directories in which the individual users can store their personal files. 
Figure <a href="http://www-uxsup.csx.cam.ac.uk/pub/doc/suse/suse9.0/userguide-9.0/ch24s02.html#fig:verz.baum" title="Figure 24.1. 
Excerpt from a Standard Directory Tree">24.1: &#8220;Excerpt from a Standard Directory Tree&#8221;</a> shows the standard directory tree in Linux, with the home directories of the example users <tt class="green">xyz</tt>, <tt class="green">linux</tt>, and <tt class="green">tux</tt>. 
The directory tree of a Linux system has a functional structure that follows the <i class="green">File System Standard</i>. 
The following list provides a brief description of the standard directories in Linux. 

<b>Figure 24.1. Excerpt from a Standard Directory Tree</b>

<img class="lazy" data-src="http://www-uxsup.csx.cam.ac.uk/pub/doc/suse/suse9.0/userguide-9.0/verzeichnisse_baum.png" width="NaN" alt="Excerpt from a Standard Directory Tree">

<dl><dt><span class="term"><tt class="filename">/</tt></span></dt><dd>root directory, starting point of the directory tree.
</dd><dt><span class="term"><tt class="filename">/home</tt></span></dt><dd>(private) directories of users.
</dd><dt><span class="term"><tt class="filename">/dev</tt></span></dt><dd>device files that represent hardware components
</dd><dt><span class="term"><tt class="filename">/etc</tt></span></dt><dd>important files for system configuration.
</dd><dt><span class="term"><tt class="filename">/etc/init.d</tt></span></dt><dd>boot scripts
</dd><dt><span class="term"><tt class="filename">/usr/bin</tt></span></dt><dd>generally accessible programs.
</dd><dt><span class="term"><tt class="filename">/bin</tt></span></dt><dd>programs needed early in the boot process.
</dd><dt><span class="term"><tt class="filename">/usr/sbin</tt></span></dt><dd>programs reserved for the system administrator.
</dd><dt><span class="term"><tt class="filename">/sbin</tt></span></dt><dd>programs reserved for the system administrator and needed for booting.
</dd><dt><span class="term"><tt class="filename">/usr/include</tt></span></dt><dd>header files for the C compiler
</dd><dt><span class="term"><tt class="filename">/usr/include/g++</tt></span></dt><dd>header files for the C++ compiler.
</dd><dt><span class="term"><tt class="filename">/usr/share/doc</tt></span></dt><dd>various documentation files.
</dd><dt><span class="term"><tt class="filename">/usr/share/man</tt></span></dt><dd>system manual pages (man pages).
</dd><dt><span class="term"><tt class="filename">/usr/src</tt></span></dt><dd>source code of system software
</dd><dt><span class="term"><tt class="filename">/usr/src/linux</tt></span></dt><dd>kernel source code.
</dd><dt><span class="term"><tt class="filename">/tmp</tt>, <tt class="filename">/var/tmp</tt></span></dt><dd>temporary files.
</dd><dt><span class="term"><tt class="filename">/usr</tt></span></dt><dd>all application programs
</dd><dt><span class="term"><tt class="filename">/var</tt></span></dt><dd>configuration files (e.g., those linked from <tt class="filename">/usr</tt>)
</dd><dt><span class="term"><tt class="filename">/var/log</tt></span></dt><dd>system log files
</dd><dt><span class="term"><tt class="filename">/var/adm</tt></span></dt><dd>system administration data
</dd><dt><span class="term"><tt class="filename">/lib</tt></span></dt><dd>shared libraries (for dynamically linked programs)
</dd><dt><span class="term"><tt class="filename">/proc</tt></span></dt><dd>process file system.
</dd><dt><span class="term"><tt class="filename">/usr/local</tt></span></dt><dd>local, distribution-independent extensions.
</dd><dt><span class="term"><tt class="filename">/opt</tt></span></dt><dd>optional software, larger add-on program packages (such as KDE, GNOME, Netscape).
</dd></dl>

<h2>Bash: Functions</h2>

There are two important functions of the shell that can make your work a lot easier:
<ul type="disc"><li>The history function &#8212; To repeat a command that has been entered before, press <b class="orange">UpArrow</b> until the previous command appears at the prompt. 
Move forward through the list of previously entered commands by pressing <b class="orange">&#8595;</b>. 
To edit the command line, just move the cursor to the desired position using the arrow keys and start typing. 
Use <b class="orange">Ctrl</b> + <b class="orange">R</b> to search in the history.
</li><li>The expansion function &#8212; Expand a file name to its full length after typing its first letters until it can be uniquely identified. 
To do so, type the first letters then hit <b class="orange">Tab</b>. 
If there are several file names starting with the same letters, obtain a list of them by hitting <b class="orange">Tab</b> twice.
</li></ul>
<h4>First Example: Managing Files</h4>

Now that you know what a command looks like, which directories exist in SuSE Linux, and how to speed up things when using Bash, put this knowledge into practice with a small exercise.
<ol type="1"><li>Open a console from the KDE desktop by clicking the shell icon.
</li><li>Enter the <b class="brown">ls</b> command to see the contents of your home directory.
</li><li>Use the command <b class="brown">mkdir</b> (which stands for <i class="green">make directory</i>)  to create a new subdirectory called <tt class="filename">test</tt> by entering <b class="brown">mkdir test</b>.
</li><li>Now launch the <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">KEdit</span></span> editor by pressing <b class="orange">Alt</b> + <b class="orange">F2</b> and entering <i class="green">kedit</i> in the input field. 
Type a few letters in the editor then save the file as <tt class="filename">Testfile</tt> in your home directory. 
Linux distinguishes between uppercase and lowercase. 
For this example, use an uppercase T.
</li><li>View the contents of your home directory again. 
Instead of typing <b class="brown">ls</b> again, just press <b class="orange">UpArrow</b> twice and the <b class="brown">ls</b> command should reappear at the prompt. 
To execute the command, hit <b class="orange">Return</b>. 
The newly created directory <tt class="filename">test</tt> should appear in blue letters and <tt class="filename">Testfile</tt> in black. 
This is how directories and files can be distinguished in a console.
</li><li>Move <tt class="filename">Testfile</tt> into the subdirectory <tt class="filename">test</tt> with the command <b class="brown">mv</b>. 
To speed this up, use the expansion function: just enter <b class="brown">mv T</b> and press <b class="orange">Tab</b>. 
As long as there is no other file beginning with this letter in the directory, the shell expands the file name and adds the string <i class="green">estfile</i>. 
Otherwise, add a letter or two yourself and test <b class="orange">Tab</b> each time to see whether the shell can now expand the name. 
Finally, type a space then <tt class="filename">test</tt> after the expanded file name and press <b class="orange">Return</b> to execute the command.
</li><li>At this point, <tt class="filename">Testfile</tt> should no longer be in the directory. 
Check this by entering <b class="brown">ls</b> again.
</li><li>To see whether the file has been successfully moved, change into the directory <tt class="filename">test</tt> with the command <b class="brown">cd test</b>. 
Now enter <b class="brown">ls</b> again. 
You should see <tt class="filename">Testfile</tt> in the listing. 
Change back to your home directory at any point by entering only <b class="brown">cd</b> (which stands for <i class="green">change directory</i>).
</li><li>To make a copy of a file, use <b class="brown">cp</b>. 
For instance, enter <b class="brown">cp Testfile Testbackup</b> to copy <tt class="filename">Testfile</tt> to <tt class="filename">Testbackup</tt>. 
Once again, the command <b class="brown">ls</b> can be used to see whether both files are in the directory.
</li></ol>

<h2>Bash: Specifying Paths</h2>

When working with files or directories, it is important specify the correct path. 
However, you do not need to enter the entire (absolute) path from the root directory to the respective file. 
Rather, you can start from the current directory. 
Address your home directory directly with <tt class="filename">~</tt>. 
Accordingly, there are two ways to list the file <tt class="filename">Testfile</tt> in the directory <tt class="filename">test</tt>: by entering the relative path with <b class="brown">ls test/*</b> or by specifying the absolute path with <b class="brown">ls ~/test/*</b>. 

To list the contents of home directories of other users, enter <b class="brown">ls ~username</b>. 
In the above-mentioned directory tree, one of the sample users is <tt class="green">tux</tt>. 
Thus, the command <b class="brown">ls ~tux</b> would list the contents of the home directory of <tt class="green">tux</tt>.
Refer to the current directory with a dot. 
The next higher level in the tree is represented by two dots. 
By entering <b class="brown">ls ..</b>, see the contents of the parent directory of the current directory. 
The command <b class="brown">ls ../..</b> shows the contents of the directory two levels higher in the hierarchy.
<h4>Second Example: Working with Paths</h4>

Here is another example to illustrate how to move around in the directories of your SuSE Linux system.
<ul type="disc"><li>Change into your home directory with the command <b class="brown">cd</b>. 
Then create a directory in it with the name <tt class="filename">test2</tt> by entering <b class="brown">mkdir test2</b>.
</li><li>Change into the new directory with <b class="brown">cd test2</b> and create a subdirectory in it with the name <tt class="filename">subdirectory</tt>. 
To change into it, use the expansion function: enter <b class="brown">cd su</b> then press <b class="orange">Tab</b>. 
The shell will expand the rest of the directory name.
</li><li>Now try to move the previously created file <tt class="filename">Testbackup</tt> into the current directory (<tt class="filename">subdirectory</tt>) without changing the directory again. 
To achieve this, specify the relative path to that file: <b class="brown">mv ../../test/Testbackup .</b>. 
The dot at the end of this command is required to tell the shell that the current directory is the destination to which to move the file. 
<b class="brown">../../</b>, in this example, refers to your home directory.
</li></ul>

<h2>Bash: Wild Cards</h2>

Another convenience offered by the shell is wild cards. 
There are four different types of these in Bash:
<dl><dt><span class="term">?</span></dt><dd>Matches exactly one arbitrary character
</dd><dt><span class="term">*</span></dt><dd>Matches an arbitrary number of characters
</dd><dt><span class="term">[set]</span></dt><dd>Matches one of the characters from the group specified inside the square brackets, which is represented here by the string <i class="green">set</i>
</dd><dt><span class="term">[!set]</span></dt><dd>Matches one character other than those identified by <i class="green">set</i>
</dd></dl>
Assuming that your <tt class="filename">test</tt> directory contains the files <tt class="filename">Testfile</tt>, <tt class="filename">Testfile1</tt>, <tt class="filename">Testfile2</tt>, and <tt class="filename">datafile</tt>, the command <b class="brown">ls Testfile?</b> will list the files <tt class="filename">Testfile1</tt> and <tt class="filename">Testfile2</tt>. 
With <b class="brown">ls Test*</b>, the list will also include <tt class="filename">Testfile</tt>. 

The command <b class="brown">ls *fil*</b> shows <span class="emphasis"><em>all</em></span> the sample files. 
Finally, you can use the <tt class="green">set</tt> wild card to address all sample files whose last character is a number: <b class="brown">ls Testfile[1-9]</b>.
Among the four types of wild cards, the most inclusive one is the asterisk. 
It could be used to copy all files contained in one directory to another one or to delete all files with one command. 
The command <b class="brown">rm *fil*</b>, for instance, would delete all files in the current directory whose name includes the string <i class="green">fil</i>.

<h2>Bash: More or Less</h2>

Linux includes two small programs for viewing text files directly in the shell. 
Rather than starting an editor to read a file like <tt class="filename">Readme.txt</tt>, simply enter <b class="brown">less Readme.txt</b> to display the text in the console window. 
Use <b class="orange">Space</b> to scroll down one page. 
Use <b class="orange">PgUp</b> and <b class="orange">PgDown</b> to move forward or backward in the text. 
To exit <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">less</span></span>, press <b class="orange">Q</b>.
The program <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">less</span></span> got its name from the the precept that <i class="green">less is more</i> and can also be used to view the output of commands in a convenient way. 
To see how this works, read Section <a href="http://www-uxsup.csx.cam.ac.uk/pub/doc/suse/suse9.0/userguide-9.0/ch24s02.html#sec:shell.pipes" title="Pipes">&#8220;Pipes&#8221;</a>.

Instead of <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">less</span></span>, you can also use the older program <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">more</span></span>. 
However, it is less convenient because it does not allow you to scroll backwards.

<h2>Bash: Pipes</h2>

Normally, the standard output in the shell is your screen or the console window, and the standard input is the keyboard. 
To forward the output of a command to an application such as <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">less</span></span>, use a <i class="green">pipeline</i>. 

To view the files in the <tt class="filename">test</tt> directory, enter the command <b class="brown">ls test | less</b>. 
The contents of the <tt class="filename">test</tt> directory will be displayed with <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">less</span></span>. 
This only makes sense if the normal output with <b class="brown">ls</b> would be too lengthy. 
For instance, if you view the contents of the <tt class="filename">dev</tt> directory with <b class="brown">ls /dev</b>, you will only see a small portion in the window. 
View the entire list with <b class="brown">ls /dev | less</b>. 

It is also possible to save the output of commands to a file. 
For example, <b class="brown">ls test &gt; Content</b> generates a new file called <tt class="filename">Content</tt> that contains a list of the files and directories in <tt class="filename">test</tt>. 
View the file with <b class="brown">less Content</b>. 

Similarly, you can also use a file as the input for a comand. 
For example, sort the text lines in <tt class="filename">Testfile</tt> with <b class="brown">sort &lt; Testfile</b>. 
The output of the command <b class="brown">sort</b> is sent to the screen. 
The text is sorted by the first letters of the individual lines. 

If you need a new file containing the sorted list, pipe the output of the command <b class="brown">sort</b> to a file. 
To test this, create an unsorted name list in an editor and save it under <tt class="filename">list</tt> in the <tt class="filename">test</tt> directory. 
Then change into <tt class="filename">test</tt> and enter the command <b class="brown">sort &lt; unsortedlist &gt; sortedlist</b>. 
Finally, view the sorted list with <b class="brown">less</b>.
Just like the standard output, the standard error output is sent to the console as well. 
However, to redirect the standard error output to a file named <tt class="filename">errors</tt>, append <b class="brown">2&gt; errors</b> to the corresponding command. 
On the other hand, both standard output and standard error are saved to one file named <tt class="filename">alloutput</tt> if you append <b class="brown">&gt;&amp; alloutput</b>. 
Finally, to append the output of a command to an already existing file, the command must be followed by <b class="brown">&gt;&gt;</b> instead of a single <b class="brown">&gt;</b>.

<h2>Bash: Archives and Data Compression</h2>

Now that you have already created a number of files and directories, consider the subject of archives and data compression. 
Suppose you want to have the entire <tt class="filename">test</tt> directory packed in one file that you can save on a floppy disk as a backup copy or send by e-mail. 
To do so, use the command <b class="brown">tar</b> (for <i class="green">tape archiver</i>). 
With <b class="brown">tar --help</b>, view all the options for the <b class="brown">tar</b> command. 
The most important of these options are explained here:
<dl><dt><span class="term">-c</span></dt><dd>(for create) Create a new archive.
</dd><dt><span class="term">-t</span></dt><dd>(for table) Display the contents of an archive.
</dd><dt><span class="term">-x</span></dt><dd>(for extract) Unpack the archive.
</dd><dt><span class="term">-v</span></dt><dd>(for verbose) Show all files on screen while creating the archive.
</dd><dt><span class="term">-f</span></dt><dd>(for file) Choose a file name for the archive file. 
When creating an archive, this option must always be given as the last one.
</dd></dl>
To pack the <tt class="filename">test</tt> directory with all its files and subdirectories into an archive named <tt class="filename">testarchive.tar</tt>, use the options <b class="brown">-c</b> and <b class="brown">-f</b>. 
For the testing purposes of this example, also add <b class="brown">-v</b> to follow the progress of the archiving, although this option is not mandatory. 
After using <b class="brown">cd</b> to change to your home directory where the <tt class="filename">test</tt> directory is located, enter <b class="brown">tar -cvf testarchive.tar test</b>. 
After that, view the contents of the archive file with <b class="brown">tar -tf testarchive.tar</b>. 
The <tt class="filename">test</tt> directory with all its files and directories has remained unchanged on your hard disk. 
To unpack the archive, enter <b class="brown">tar -xvf testarchive.tar</b>, but do not try this yet.
For file compression, the obvious choice on Linux is the popular <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">gzip</span></span> program. 
Just enter <b class="brown">gzip testarchive.tar</b>. 
With <b class="brown">ls</b>, now see that the file <tt class="filename">testarchive.tar</tt> is no longer there and that the file <tt class="filename">testarchive.tar.gz</tt> has been created instead. 
This file is much smaller and therefore much better suited for transfer via e-mail or storage on a floppy.
Now, unpack this file in the <tt class="filename">test2</tt> directory created earlier. 
To do so, enter <b class="brown">cp testarchive.tar.gz test2</b> to copy the file to that directory. 
Change to the directory with <b class="brown">cd test2</b>. 
A compressed archive with the <tt class="green">.tar.gz</tt> extension can be <i class="green">unzipped</i>  with the <b class="brown">gunzip</b> command. 
Enter <b class="brown">gunzip testarchive.tar.gz</b>  , which results in the file <tt class="filename">testarchive.tar</tt>, which then needs to be extracted or <i class="green">untarred</i> with <b class="brown">tar -xvf testarchive.tar</b>. 
You can also <i class="green">unzip</i> and extract a compressed archive in one step by adding the <tt class="green">-z</tt> option. 
The complete command would be <b class="brown">tar -xvzf testarchive.tar.gz</b>. 
With <b class="brown">ls</b>, you can see that a new <tt class="filename">test</tt> directory has been created with the same contents as your <tt class="filename">test</tt> directory in your home directory.

<h2>Bash: mtools</h2>

<b class="brown">mtools</b> are a set of commands for working with MS-DOS file systems. 
The commands included in <b class="brown">mtools</b> allow you to address the first floppy drive as <tt class="green">a:</tt>, just like under MS-DOS, and the commands are like MS-DOS commands except they are prefixed with an <tt class="green">m</tt>:
<dl><dt><span class="term">
     <b class="brown">mdir a:</b>
    </span></dt><dd>displays the contents of the floppy disk in drive <tt class="filename">a:</tt>
</dd><dt><span class="term">
     <b class="brown">mcopy Testfile a:</b>
    </span></dt><dd>copies the file <tt class="filename">Testfile</tt> to the floppy disk.
</dd><dt><span class="term">
     <b class="brown">mdel a:Testfile</b>
    </span></dt><dd>deletes <tt class="filename">Testfile</tt> in <tt class="filename">a:</tt>
</dd><dt><span class="term">
     <b class="brown">mformat a:</b>
    </span></dt><dd>formats the floppy disk in MS-DOS format (using the <b class="brown">fdformat</b> command).
</dd><dt><span class="term">
     <b class="brown">mcd a:</b>
    </span></dt><dd>makes <tt class="filename">a:</tt> your current directory
</dd><dt><span class="term">
     <b class="brown">mmd a:test</b>
    </span></dt><dd>creates the subdirectory <tt class="filename">test</tt> on the floppy disk
</dd><dt><span class="term">
     <b class="brown">mrd a:test</b>
    </span></dt><dd>deletes the subdirectory <tt class="filename">test</tt> from the floppy disk
</dd></dl>


<h2>Linux copy and paste</h2>
Use Ctrl+Insert or Ctrl+Shift+C for copying and
Shift+Insert or Ctrl+Shift+V for pasting text in the terminal in Ubuntu.

Right click and selecting the copy/paste option from the context menu is also an option.
I thought of elaborating on this topic specially when there is no single universal way of copy and paste in the Linux terminal.

<a href="https://linuxhandbook.com/linux-shortcuts/" class="whitebut ">Linux Terminal Shortcuts</a>


<h2>30 Bash Script Examples</h2>
<div id="bashexampletoc" class="toc"><a href="#bashexampletopic-0" target="_self">Create and Execute First BASH Program:</a><br><a href="#bashexampletopic-1" target="_self">Use of echo command:</a><br><a href="#bashexampletopic-2" target="_self">Use of comment:</a><br><a href="#bashexampletopic-3" target="_self">Use of Multi-line comment:</a><br><a href="#bashexampletopic-4" target="_self">Using While Loop:</a><br><a href="#bashexampletopic-5" target="_self">Using For Loop:</a><br><a href="#bashexampletopic-6" target="_self">Get User Input:</a><br><a href="#bashexampletopic-7" target="_self">Using if statement:</a><br><a href="#bashexampletopic-8" target="_self">Using if statement with AND logic:</a><br><a href="#bashexampletopic-9" target="_self">Using if statement with OR logic:</a><br><a href="#bashexampletopic-10" target="_self">Using else if statement:</a><br><a href="#bashexampletopic-11" target="_self">Using Case Statement:</a><br><a href="#bashexampletopic-12" target="_self">Get Arguments from Command Line:</a><br><a href="#bashexampletopic-13" target="_self">Get arguments from command line with names:</a><br><a href="#bashexampletopic-14" target="_self">Combine String variables:</a><br><a href="#bashexampletopic-15" target="_self">Get substring of String:</a><br><a href="#bashexampletopic-16" target="_self">Add Two Numbers:</a><br><a href="#bashexampletopic-17" target="_self">Create Function:</a><br><a href="#bashexampletopic-18" target="_self">Create function with Parameters:</a><br><a href="#bashexampletopic-19" target="_self">Pass Return Value from Function:</a><br><a href="#bashexampletopic-20" target="_self">Make Directory:</a><br><a href="#bashexampletopic-21" target="_self">Make directory by checking existence:</a><br><a href="#bashexampletopic-22" target="_self">Read a File:</a><br><a href="#bashexampletopic-23" target="_self">Delete a File:</a><br><a href="#bashexampletopic-24" target="_self">Append to File:</a><br><a href="#bashexampletopic-25" target="_self">Test if File Exist:</a><br><a href="#bashexampletopic-26" target="_self">Send Email:</a><br><a href="#bashexampletopic-27" target="_self">Get Parse Current Date:</a><br><a href="#bashexampletopic-28" target="_self">Wait Command:</a><br><a href="#bashexampletopic-29" target="_self">Sleep Command:</a><br></div></center>
<h3 id="bashexampletopic-0">Create and Execute First BASH Program:</h3>
You can run bash script from the terminal or by executing any bash file. 
Run the following command from the terminal to execute a very simple bash statement. 
The output of the command will be ‘<strong>Hello World</strong>’.
$ echo "Hello World"
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h.png">
Open any editor to create a bash file. 
Here, <strong>nano</strong> editor is used to create the file and filename is set as ‘<strong>First.sh’</strong>
$ nano First.sh
Add the following bash script to the file and save the file.
#!/bin/bash
echo "Hello World"
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h1.png">
You can run bash file by two ways. 
One way is by using bash command and another is by setting execute permission to bash file and run the file. 
Both ways are shown here.
$ bash First.sh
<strong>Or,</strong>
$ chmod a+x First.sh
$ ./First.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h2.png">
<h3 id="bashexampletopic-1">Use of echo command:</h3>
You can use echo command with various options. 
Some useful options are mentioned in the following example. 
When you use ‘<strong>echo</strong>’ command without any option then a newline is added by default. 
<strong>‘-n’</strong> option is used to print any text without new line and <strong>‘-e’</strong> option is used to remove backslash characters from the output. 
Create a new bash file with a name, ‘<strong>echo_example.sh</strong>’ and add the following script.
#!/bin/bash
echo "Printing text with newline"
echo -n "Printing text without newline"
echo -e "\nRemoving \t backslash \t characters\n"
Run the file with bash command.
$ bash echo_example.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h3.png">
<h3 id="bashexampletopic-2">Use of comment:</h3>
<strong>‘#’</strong> symbol is used to add single line comment in bash script. 
Create a new file named ‘<strong>comment_example.sh’</strong> and add the following script with single line comment.
#!/bin/bash
# Add two numeric value
((sum=25+35))
#Print the result
echo $sum
Run the file with bash command.
$ bash comment_example.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h4.png">
<h3 id="bashexampletopic-3">Use of Multi-line comment:</h3>
You can use multi line comment in bash in various ways. 
A simple way is shown in the following example. 
Create a new bash named, <strong>‘multiline-comment.sh’</strong> and add the following script. 
Here, <strong>‘:’</strong> and <strong>“ </strong><strong>’ </strong><strong>”</strong> symbols are used to add multiline comment in bash script. 
This following script will calculate the square of 5.
#!/bin/bash
: '
The following script calculates the square value of the number, 5.
'
((area=5*5))
echo $area
Run the file with bash command.
$ bash multiline-comment.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h5.png">
You can check the following link to know more about the use of bash comment.
<a href="https://linuxhint.com/bash_comments/">https://linuxhint.com/bash_comments/</a>
<h3 id="bashexampletopic-4">Using While Loop:</h3>
Create a bash file with the name, <strong>‘while_example.sh’,</strong> to know the use of <strong>while</strong> loop. 
In the example, <strong>while</strong> loop will iterate for <strong>5</strong> times. 
The value of <strong>count</strong> variable will increment by <strong>1</strong> in each step. 
When the value of <strong>count</strong> variable will 5 then the <strong>while</strong> loop will terminate.
#!/bin/bash
valid=true
count=1
while [ $valid ]
do
echo $count
if [ $count -eq 5 ];
then
break
fi
((count++))
done
Run the file with bash command.
$ bash while_example.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h6.png">
You can check the following link to know more about the use of while loop.
<a href="https://linuxhint.com/bash-while-loop-examples/">https://linuxhint.com/bash-while-loop-examples/</a>
<h3 id="bashexampletopic-5">Using For Loop:</h3>
The basic <strong>for</strong> loop declaration is shown in the following example. 
Create a file named ‘<strong>for_example.sh</strong>’ and add the following script using <strong>for</strong> loop. 
Here, <strong>for</strong> loop will iterate for <strong>10</strong> times and print all values of the variable, <strong>counter</strong> in single line.
#!/bin/bash
for (( counter=10; counter&gt;0; counter-- ))
do
echo -n "$counter "
done
printf "\n"
Run the file with bash command.
$ bash for_example.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h7.png">
You can use for loop for different purposes and ways in your bash script. 
You can check the following link to know more about the use of for loop.
<a href="https://linuxhint.com/bash-for-loop-examples/">https://linuxhint.com/bash-for-loop-examples/</a>
<h3 id="bashexampletopic-6">Get User Input:</h3>
‘<strong>read</strong>’ command is used to take input from user in bash. 
Create a file named ‘<strong>user_input.sh</strong>’ and add the following script for taking input from the user. 
Here, one string value will be taken from the user and display the value by combining other string value.
#!/bin/bash
echo "Enter Your Name"
read name
echo "Welcome $name to LinuxHint"
Run the file with bash command.
$ bash user_input.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h8.png">
You can check the following link to know more about the use of user input.
<a href="https://linuxhint.com/bash-script-user-input/">https://linuxhint.com/bash-script-user-input/</a>
<h3 id="bashexampletopic-7">Using if statement:</h3>
You can use if condition with single or multiple conditions. 
Starting and ending block of this statement is define by <strong>‘if’</strong> and <strong>‘fi’</strong>. 
Create a file named ‘<strong>simple_if.sh</strong>’ with the following script to know the use <strong>if</strong> statement in bash. 
Here, <strong>10</strong> is assigned to the variable, <strong>n</strong>. 
if the value of <strong>$n</strong> is less than 10 then the output will be “<strong>It is a one digit number</strong>”, otherwise the output will be “<strong>It is a two digit number</strong>”. 
For comparison, <strong>‘-lt’</strong> is used here. 
For comparison, you can also use <strong>‘-eq’</strong> for <strong>equality</strong>, <strong>‘-ne’</strong> for <strong>not equality</strong> and <strong>‘-gt’</strong> for <strong>greater than</strong> in bash script.
#!/bin/bash
n=10
if [ $n -lt 10 ];
then
echo "It is a one digit number"
else
echo "It is a two digit number"
fi
Run the file with bash command.
$ bash simple_if.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h9.png">
<h3 id="bashexampletopic-8">Using if statement with AND logic:</h3>
Different types of logical conditions can be used in if statement with two or more conditions. 
How you can define multiple conditions in if statement using <strong>AND</strong> logic is shown in the following example. 
<strong>‘&amp;&amp;’ </strong>is used to apply <strong>AND</strong> logic of <strong>if</strong> statement. 
Create a file named <strong>‘if_with_AND.sh’</strong> to check the following code. 
Here, the value of <strong>username</strong> and <strong>password </strong>variables will be taken from the user and compared with ‘<strong>admin</strong>’ and ‘<strong>secret</strong>’. 
If both values match then the output will be “<strong>valid user</strong>”, otherwise the output will be “<strong>invalid user</strong>”.
!/bin/bash
echo "Enter username"
read username
echo "Enter password"
read password

if [ ( $username == "admin" &amp;&amp; $password == "secret" ) ]]; then
echo "valid user"
else
echo "invalid user"
fi
Run the file with bash command.
$ bash if_with_AND.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h10.png">
<h3 id="bashexampletopic-9">Using if statement with OR logic:</h3>
‘<strong>||</strong>’ is used to define <strong>OR</strong> logic in <strong>if</strong> condition. 
Create a file named <strong>‘if_with_OR.sh’ </strong>with the following code to check the use of <strong>OR</strong> logic of <strong>if</strong> statement. 
Here, the value of <strong>n</strong> will be taken from the user. 
If the value is equal to <strong>15</strong> or <strong>45 </strong>then the output will be “<strong>You won the game</strong>”, otherwise the output will be “<strong>You lost the game</strong>”.
#!/bin/bash
echo "Enter any number"
read n

if [ ( $n -eq 15 || $n  -eq 45 ) ]]
then
echo "You won the game"
else
echo "You lost the game"
fi
Run the file with bash command.
$ bash if_with_OR.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h11.png">
<h3 id="bashexampletopic-10">Using else if statement:</h3>
The use of <strong>else if</strong> condition is little different in bash than other programming language. 
‘<strong>elif</strong>’ is used to define <strong>else if</strong> condition in bash. 
Create a file named, ‘<strong>elseif_example.sh</strong>’ and add the following script to check how <strong>else if</strong> is defined in bash script.
#!/bin/bash
echo "Enter your lucky number"
read n

if [ $n -eq 101 ];
then
echo "You got 1st prize"
elif [ $n -eq 510 ];
then
echo "You got 2nd prize"
elif [ $n -eq 999 ];
then
echo "You got 3rd prize"

else
echo "Sorry, try for the next time"
fi
Run the file with bash command.
$ bash elseif_example.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h12.png">
<h3 id="bashexampletopic-11">Using Case Statement:</h3>
<strong>Case</strong> statement is used as the alternative of <strong>if-elseif-else</strong> statement. 
The starting and ending block of this statement is defined by ‘<strong>case</strong>’ and ‘<strong>esac</strong>’. 
Create a new file named, ‘<strong>case_example.sh</strong>’ and add the following script. 
The output of the following script will be same to the previous <strong>else if </strong>example.
#!/bin/bash
echo "Enter your lucky number"
read n
case $n in
101)
echo echo "You got 1st prize" ;;
510)
echo "You got 2nd prize" ;;
999)
echo "You got 3rd prize" ;;
*)
echo "Sorry, try for the next time" ;;
esac
Run the file with bash command.
$ bash case_example.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h13.png">
<h3 id="bashexampletopic-12">Get Arguments from Command Line:</h3>
Bash script can read input from command line argument like other programming language. 
For example, <strong>$1</strong> and <strong>$2</strong> variable are used to read first and second command line arguments. 
Create a file named “<strong>command_line.sh</strong>” and add the following script. 
Two argument values read by the following script and prints the total number of arguments and the argument values as output.
#!/bin/bash
echo "Total arguments : $#"
echo "1st Argument = $1"
echo "2nd argument = $2"
Run the file with bash command.
$ bash command_line.sh Linux Hint
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h14.png">
You can check the following link to know more about the use of command line argument.
<a href="https://linuxhint.com/command_line_arguments_bash_script/">https://linuxhint.com/command_line_arguments_bash_script/</a>
<h3 id="bashexampletopic-13">Get arguments from command line with names:</h3>
How you can read command line arguments with names is shown in the following script. 
Create a file named, ‘<strong>command_line_names.sh’</strong> and add the following code. 
Here, two arguments, <strong>X </strong>and <strong>Y</strong> are read by this script and print the sum of X and Y.
#!/bin/bash
for arg in "<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="aa8eea">[email&nbsp;protected]</a>"
do
index=$(echo $arg | cut -f1 -d=)
val=$(echo $arg | cut -f2 -d=)
case $index in
X) x=$val;;

Y) y=$val;;

*)
esac
done
((result=x+y))
echo "X+Y=$result"
Run the file with bash command and with two command line arguments.
$ bash command_line_names X=45 Y=30
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h15.png">
<h3 id="bashexampletopic-14">Combine String variables:</h3>
You can easily combine string variables in bash. 
Create a file named “<strong>string_combine.sh</strong>” and add the following script to check how you can combine string variables in bash by placing variables together or using <strong>‘+’</strong> operator.
#!/bin/bash

string1="Linux"
string2="Hint"
echo "$string1$string2"
string3=$string1+$string2
string3+=" is a good tutorial blog site"
echo $string3
Run the file with bash command.
$ bash string_combine.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h16.png">
<h3 id="bashexampletopic-15">Get substring of String:</h3>
Like other programming language, bash has no built-in function to cut value from any string data. 
But you can do the task of substring in another way in bash that is shown in the following script. 
To test the script, create a file named ‘<strong>substring_example.sh</strong>’ with the following code. 
Here, the value, <strong>6</strong> indicates the starting point from where the substring will start and <strong>5</strong> indicates the length of the substring.
#!/bin/bash
Str="Learn Linux from LinuxHint"
subStr=${Str:6:5}
echo $subStr
Run the file with bash command.
$ bash substring_example.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h17.png">
<h3 id="bashexampletopic-16">Add Two Numbers:</h3>
You can do the arithmetical operations in bash in different ways. 
How you can add two integer numbers in bash using double brackets is shown in the following script. 
Create a file named ‘<strong>add_numbers.sh</strong>’ with the following code. 
Two integer values will be taken from the user and printed the result of addition.
#!/bin/bash
echo "Enter first number"
read x
echo "Enter second number"
read y
(( sum=x+y ))
echo "The result of addition=$sum"
Run the file with bash command.
$ bash add_numbers.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h18.png">
You can check the following link to know more about bash arithmetic.
<a href="https://linuxhint.com/bash_arithmetic_operations/">https://linuxhint.com/bash_arithmetic_operations/</a>
<h3 id="bashexampletopic-17">Create Function:</h3>
How you can create a simple function and call the function is shown in the following script. 
Create a file named ‘<strong>function_example.sh</strong>’ and add the following code. 
You can call any function by name only without using any bracket in bash script.
#!/bin/bash
function F1()
{
echo 'I like bash programming'
}

F1
Run the file with bash command.
$ bash function_example.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h19.png">
<h3 id="bashexampletopic-18">Create function with Parameters:</h3>
Bash can’t declare function parameter or arguments at the time of function declaration. 
But you can use parameters in function by using other variable. 
If two values are passed at the time of function calling then $1 and $2 variable are used for reading the values. 
Create a file named ‘<strong>function|_parameter.sh</strong>’ and add the following code. 
Here, the function, ‘<strong>Rectangle_Area’</strong> will calculate the area of a rectangle based on the parameter values.
#!/bin/bash

Rectangle_Area() {
area=$(($1 * $2))
echo "Area is : $area"
}

Rectangle_Area 10 20
Run the file with bash command.
$ bash function_parameter.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h20.png">
<h3 id="bashexampletopic-19">Pass Return Value from Function:</h3>
Bash function can pass both numeric and string values. 
How you can pass a string value from the function is shown in the following example. 
Create a file named, ‘<strong>function_return.sh</strong>’ and add the following code. 
The function, <strong>greeting()</strong> returns a string value into the variable, <strong>val</strong> which prints later by combining with other string.
#!/bin/bash
function greeting() {

str="Hello, $name"
echo $str

}
echo "Enter your name"
read name

val=$(greeting)
echo "Return value of the function is $val"
Run the file with bash command.
$ bash function_return.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h21.png">
You can check the following link to know more about the use of bash function.
<a href="https://linuxhint.com/return-string-bash-functions/">https://linuxhint.com/return-string-bash-functions/</a>
<h3 id="bashexampletopic-20">Make Directory:</h3>
Bash uses ‘<strong>mkdir</strong>’ command to create a new directory. 
Create a file named ‘<strong>make_directory.sh</strong>’ and add the following code to take a new directory name from the user. 
If the directory name is not exist in the current location then it will create the directory, otherwise the program will display error.
#!/bin/bash
echo "Enter directory name"
read newdir
`mkdir $newdir`
Run the file with bash command.
$ bash make_directory.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h22.png">
<h3 id="bashexampletopic-21">Make directory by checking existence:</h3>
If you want to check the existence of directory in the current location before executing the ‘<strong>mkdir</strong>’ command then you can use the following code. 
<strong>‘-d</strong>’ option is used to test a particular directory is exist or not. 
Create a file named, ‘<strong>directory_exist.sh’</strong> and add the following code to create a directory by checking existence.
#!/bin/bash
echo "Enter directory name"
read ndir
if [ -d "$ndir" ]
then
echo "Directory exist"
else
`mkdir $ndir`
echo "Directory created"
fi
Run the file with bash command.
$ bash directory_exist.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h23.png">
You can check the following link to know more about directory creation.
<a href="https://linuxhint.com/bash_mkdir_not_existent_path/">https://linuxhint.com/bash_mkdir_not_existent_path/</a>
<h3 id="bashexampletopic-22">Read a File:</h3>
You can read any file line by line in bash by using loop. 
Create a file named, ‘<strong>read_file.sh</strong>’ and add the following code to read an existing file named, ‘<strong>book.txt</strong>’.
#!/bin/bash
file='book.txt'
while read line; do
echo $line
done &lt; $file
Run the file with bash command.
$ bash read_file.sh
Run the following command to check the original content of ‘<strong>book.txt</strong>’ file.
$ cat book.txt
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h24.png">
You can check the following link to know the different ways to read file.
<a href="https://linuxhint.com/read_file_line_by_line_bash/">https://linuxhint.com/read_file_line_by_line_bash/</a>
<h3 id="bashexampletopic-23">Delete a File:</h3>
‘<strong>rm</strong>’ command is used in bash to remove any file. 
Create a file named ‘<strong>delete_file.sh</strong>’ with the following code to take the filename from the user and remove. 
Here, <strong>‘-i’</strong> option is used to get permission from the user before removing the file.
#!/bin/bash
echo "Enter filename to remove"
read fn
rm -i $fn
Run the file with bash command.
$ ls
$ bash delete_file.sh
$ ls
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h25.png">
<h3 id="bashexampletopic-24">Append to File:</h3>
New data can be added into any existing file by using <strong>‘&gt;&gt;’</strong> operator in bash. 
Create a file named <strong>‘append_file.sh</strong>’ and add the following code to add new content at the end of the file. 
Here, ‘<strong>Learning Laravel 5</strong>’ will be added at the of ‘<strong>book.txt’</strong> file after executing the script.
#!/bin/bash
echo "Before appending the file"
cat book.txt
echo "Learning Laravel 5"&gt;&gt; book.txt
echo "After appending the file"
cat book.txt
Run the file with bash command.
$ bash append_file.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h26.png">
<h3 id="bashexampletopic-25">Test if File Exist:</h3>
You can check the existence of file in bash by using <strong>‘-e’</strong> or <strong>‘-f’</strong> option. 
<strong>‘-f’</strong> option is used in the following script to test the file existence. 
Create a file named, ‘<strong>file_exist.sh</strong>’ and add the following code. 
Here, the filename will pass from the command line.
#!/bin/bash
filename=$1
if [ -f "$filename" ]; then
echo "File exists"
else
echo "File does not exist"
fi
Run the following commands to check the existence of the file. 
Here, <strong>book.txt</strong> file exists and  <strong>book2.txt</strong> is not exist in the current location.
$ ls
$ bash file_exist.sh book.txt
$ bash file_exist.sh book2.txt
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h27.png">
<h3 id="bashexampletopic-26">Send Email:</h3>
You can send email by using ‘<strong>mail</strong>’ or ‘<strong>sendmail</strong>’ command. 
Before using these commands, you have to install all necessary packages. 
Create a file named, ‘<strong>mail_example.sh</strong>’ and add the following code to send the email.
#!/bin/bash
Recipient=”admin@example.com”
Subject=”Greeting”
Message=”Welcome to our site”
`mail -s $Subject $Recipient &lt;&lt;&lt; $Message`
Run the file with bash command.
$ bash mail_example.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h28.png">
<h3 id="bashexampletopic-27">Get Parse Current Date:</h3>
You can get the current system date and time value using `<strong>date</strong>` command. 
Every part of date and time value can be parsed using ‘<strong>Y’, ‘m’, ‘d’, ‘H’, ‘M’</strong> and ‘<strong>S’</strong>. 
Create a new file named ‘<strong>date_parse.sh’</strong> and add the following code to separate day, month, year, hour, minute and second values.
#!/bin/bash
Year=`date +%Y`
Month=`date +%m`
Day=`date +%d`
Hour=`date +%H`
Minute=`date +%M`
Second=`date +%S`
echo `date`
echo "Current Date is: $Day-$Month-$Year"
echo "Current Time is: $Hour:$Minute:$Second"
Run the file with bash command.
$ bash date_parse.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h29.png">
<h3 id="bashexampletopic-28">Wait Command:</h3>
<strong>wait</strong>  is a built-in command of Linux that waits for completing any running process. 
<strong>wait</strong> command is used with a particular process id or job id. 
If no process id or job id is given with wait command then it will wait for all current child processes to complete and returns exit status. 
Create a file named ‘<strong>wait_example.sh’</strong> and add the following script.
#!/bin/bash
echo "Wait command" &amp;
process_id=$!
wait $process_id
echo "Exited with status $?"
Run the file with bash command.
$ bash wait_example.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h30.png">
You can check the following link to know more about wait command.
<blockquote class="wp-embedded-content" data-secret="ElaQZ5i8wk"><a href="https://linuxhint.com/wait_command_linux/">Wait Command in Linux</a>
</blockquote>
<iframe loading="lazy" class="wp-embedded-content" sandbox="allow-scripts" security="restricted" style="position: absolute; clip: rect(1px, 1px, 1px, 1px);" title="“Wait Command in Linux” — Linux Hint" src="about:blank" data-secret="ElaQZ5i8wk" width="600" height="338" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" data-rocket-lazyload="fitvidscompatible" data-lazy-src="https://linuxhint.com/wait_command_linux/embed/#?secret=ElaQZ5i8wk"></iframe><iframe class="wp-embedded-content" sandbox="allow-scripts" security="restricted" style="position: absolute; clip: rect(1px, 1px, 1px, 1px);" title="“Wait Command in Linux” — Linux Hint" src="https://linuxhint.com/wait_command_linux/embed/#?secret=ElaQZ5i8wk" data-secret="ElaQZ5i8wk" width="600" height="338" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe>
<h3 id="bashexampletopic-29">Sleep Command:</h3>
When you want to pause the execution of any command for specific period of time then you can use <strong>sleep</strong> command. 
You can set the delay amount by <strong>seconds (s), minutes (m), hours (h) and days (d).</strong> Create a file named <strong>‘sleep_example.sh’</strong> and add the following script. 
This script will wait for 5 seconds after running.
#!/bin/bash
echo “Wait for 5 seconds”
sleep 5
echo “Completed”
Run the file with bash command.
$ bash sleep_example.sh
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2018/07/h31.png">
You can check the following link to know more about sleep command.
<a href="https://linuxhint.com/sleep_command_linux/">https://linuxhint.com/sleep_command_linux/</a>

<h2>Bash scripting <em>cheatsheet</em></h2>
<div id="Bashcheatsheettoc" class="toc"><a href="#Bashcheatsheettopic-0" target="_self"><span class="orange">Getting started</span></a><br><a href="#Bashcheatsheettopic-1" target="_self">Introduction</a><br><a href="#Bashcheatsheettopic-2" target="_self">Variables</a><br><a href="#Bashcheatsheettopic-3" target="_self">String quotes</a><br><a href="#Bashcheatsheettopic-4" target="_self">Shell execution</a><br><a href="#Bashcheatsheettopic-5" target="_self">Conditional execution</a><br><a href="#Bashcheatsheettopic-6" target="_self">Functions</a><br><a href="#Bashcheatsheettopic-7" target="_self">Conditionals</a><br><a href="#Bashcheatsheettopic-8" target="_self">Strict mode</a><br><a href="#Bashcheatsheettopic-9" target="_self">Brace expansion</a><br><a href="#Bashcheatsheettopic-10" target="_self"><span class="orange">Parameter expansions</span></a><br><a href="#Bashcheatsheettopic-11" target="_self">Basics</a><br><a href="#Bashcheatsheettopic-12" target="_self">Substitution</a><br><a href="#Bashcheatsheettopic-13" target="_self">Comments</a><br><a href="#Bashcheatsheettopic-14" target="_self">Substrings</a><br><a href="#Bashcheatsheettopic-15" target="_self">Length</a><br><a href="#Bashcheatsheettopic-16" target="_self">Manipulation</a><br><a href="#Bashcheatsheettopic-17" target="_self">Default values</a><br><a href="#Bashcheatsheettopic-18" target="_self"><span class="orange">Loops</span></a><br><a href="#Bashcheatsheettopic-19" target="_self">Basic for loop</a><br><a href="#Bashcheatsheettopic-20" target="_self">C-like for loop</a><br><a href="#Bashcheatsheettopic-21" target="_self">Ranges</a><br><a href="#Bashcheatsheettopic-22" target="_self">Reading lines</a><br><a href="#Bashcheatsheettopic-23" target="_self">Forever</a><br><a href="#Bashcheatsheettopic-24" target="_self"><span class="orange">Functions</span></a><br><a href="#Bashcheatsheettopic-25" target="_self">Defining functions</a><br><a href="#Bashcheatsheettopic-26" target="_self">Returning values</a><br><a href="#Bashcheatsheettopic-27" target="_self">Raising errors</a><br><a href="#Bashcheatsheettopic-28" target="_self">Arguments</a><br><a href="#Bashcheatsheettopic-29" target="_self"><span class="orange">Conditionals</span></a><br><a href="#Bashcheatsheettopic-30" target="_self">Conditions</a><br><a href="#Bashcheatsheettopic-31" target="_self">File conditions</a><br><a href="#Bashcheatsheettopic-32" target="_self"><span class="orange">Arrays</span></a><br><a href="#Bashcheatsheettopic-33" target="_self">Defining arrays</a><br><a href="#Bashcheatsheettopic-34" target="_self">Working with arrays</a><br><a href="#Bashcheatsheettopic-35" target="_self">Operations</a><br><a href="#Bashcheatsheettopic-36" target="_self">Iteration</a><br><a href="#Bashcheatsheettopic-37" target="_self"><span class="orange">Dictionaries</span></a><br><a href="#Bashcheatsheettopic-38" target="_self">Defining</a><br><a href="#Bashcheatsheettopic-39" target="_self">Working with dictionaries</a><br><a href="#Bashcheatsheettopic-40" target="_self">Iteration</a><br><a href="#Bashcheatsheettopic-41" target="_self"><span class="orange">Options</span></a><br><a href="#Bashcheatsheettopic-42" target="_self">Options</a><br><a href="#Bashcheatsheettopic-43" target="_self">Glob options</a><br><a href="#Bashcheatsheettopic-44" target="_self"><span class="orange">History</span></a><br><a href="#Bashcheatsheettopic-45" target="_self">Commands</a><br><a href="#Bashcheatsheettopic-46" target="_self">Expansions</a><br><a href="#Bashcheatsheettopic-47" target="_self">Operations</a><br><a href="#Bashcheatsheettopic-48" target="_self">Slices</a><br><a href="#Bashcheatsheettopic-49" target="_self"><span class="orange">Miscellaneous</span></a><br><a href="#Bashcheatsheettopic-50" target="_self">Numeric calculations</a><br><a href="#Bashcheatsheettopic-51" target="_self">Subshells</a><br><a href="#Bashcheatsheettopic-52" target="_self">Redirection</a><br><a href="#Bashcheatsheettopic-53" target="_self">Inspecting commands</a><br><a href="#Bashcheatsheettopic-54" target="_self">Trap errors</a><br><a href="#Bashcheatsheettopic-55" target="_self">Case/switch</a><br><a href="#Bashcheatsheettopic-56" target="_self">Source relative</a><br><a href="#Bashcheatsheettopic-57" target="_self">printf</a><br><a href="#Bashcheatsheettopic-58" target="_self">Directory of script</a><br><a href="#Bashcheatsheettopic-59" target="_self">Getting options</a><br><a href="#Bashcheatsheettopic-60" target="_self">Heredoc</a><br><a href="#Bashcheatsheettopic-61" target="_self">Reading input</a><br><a href="#Bashcheatsheettopic-62" target="_self">Special variables</a><br><a href="#Bashcheatsheettopic-63" target="_self">Go to previous directory</a><br><a href="#Bashcheatsheettopic-64" target="_self">Check for command’s result</a><br><a href="#Bashcheatsheettopic-65" target="_self">Grep check</a><br></div></center>

<h3 id="Bashcheatsheettopic-0"><span class="orange">Getting started</span></h3>
<h3 id="Bashcheatsheettopic-1">Introduction</h3>
This is a quick reference to getting started with Bash scripting.
<a href="https://learnxinyminutes.com/docs/bash/">Learn bash in y minutes</a> <em>(learnxinyminutes.com)</em>
<a href="http://mywiki.wooledge.org/BashGuide">Bash Guide</a> <em>(mywiki.wooledge.org)</em>
<code>#!/usr/bin/env bash
NAME="John"
echo "Hello $NAME!"</code>

<h3 id="Bashcheatsheettopic-2">Variables</h3>
<code>NAME="John"
echo $NAME
echo "$NAME"
echo "${NAME}!"</code>

<h3 id="Bashcheatsheettopic-3">String quotes</h3>
<code>NAME="John"
echo "Hi $NAME"  #=&gt; Hi John
echo 'Hi $NAME'  #=&gt; Hi $NAME</code>

<h3 id="Bashcheatsheettopic-4">Shell execution</h3>
<code>echo "I'm in $(pwd)"
echo "I'm in `pwd`"
# Same</code>

See <a href="http://wiki.bash-hackers.org/syntax/expansion/cmdsubst">Command substitution</a>
<h3 id="Bashcheatsheettopic-5">Conditional execution</h3>
<code>git commit &amp;&amp; git push
git commit || echo "Commit failed"</code>

<h3 id="Bashcheatsheettopic-6">Functions</h3>
<code>get_name() {
  echo "John"
}

echo "You are $(get_name)"</code>

See: <a href="#functions">Functions</a>
<h3 id="Bashcheatsheettopic-7">Conditionals</h3>
<code>if [[ -z "$string" ]]; then
  echo "String is empty"
elif [[ -n "$string" ]]; then
  echo "String is not empty"
fi</code>

See: <a href="#conditionals">Conditionals</a>
<h3 id="Bashcheatsheettopic-8">Strict mode</h3>
<code>set -euo pipefail
IFS=$'\n\t'</code>

See: <a href="http://redsymbol.net/articles/unofficial-bash-strict-mode/">Unofficial bash strict mode</a>
<h3 id="Bashcheatsheettopic-9">Brace expansion</h3>
<code>echo {A,B}.js</code>

<table><thead>
<tr><th>Expression</th>
<th>Description</th></tr></thead><tbody>
<tr><td><code>{A,B}</code></td><td>Same as <code>A B</code></td></tr>
<tr><td><code>{A,B}.js</code></td><td>Same as <code>A.js B.js</code></td></tr>
<tr><td><code>{1..5}</code></td><td>Same as <code>1 2 3 4 5</code></td></tr>
</tbody></table>
See: <a href="http://wiki.bash-hackers.org/syntax/expansion/brace">Brace expansion</a>
<h3 id="Bashcheatsheettopic-10"><span class="orange">Parameter expansions</span></h3>
<h3 id="Bashcheatsheettopic-11">Basics</h3>
<code>name="John"
echo ${name}
echo ${name/J/j}    #=&gt; "john" (substitution)
echo ${name:0:2}    #=&gt; "Jo" (slicing)
echo ${name::2}     #=&gt; "Jo" (slicing)
echo ${name::-1}    #=&gt; "Joh" (slicing)
echo ${name:(-1)}   #=&gt; "n" (slicing from right)
echo ${name:(-2):1} #=&gt; "h" (slicing from right)
echo ${food:-Cake}  #=&gt; $food or "Cake"</code>

<code>length=2
echo ${name:0:length}  #=&gt; "Jo"</code>

See: <a href="http://wiki.bash-hackers.org/syntax/pe">Parameter expansion</a>
<code>STR="/path/to/foo.cpp"
echo ${STR%.cpp}    # /path/to/foo
echo ${STR%.cpp}.o  # /path/to/foo.o
echo ${STR%/*}      # /path/to

echo ${STR##*.}     # cpp (extension)
echo ${STR##*/}     # foo.cpp (basepath)

echo ${STR#*/}      # path/to/foo.cpp
echo ${STR##*/}     # foo.cpp

echo ${STR/foo/bar} # /path/to/bar.cpp</code>

<code>STR="Hello world"
echo ${STR:6:5}   # "world"
echo ${STR: -5:5}  # "world"</code>

<code>SRC="/path/to/foo.cpp"
BASE=${SRC##*/}   #=&gt; "foo.cpp" (basepath)
DIR=${SRC%$BASE}  #=&gt; "/path/to/" (dirpath)</code>

<h3 id="Bashcheatsheettopic-12">Substitution</h3>
<table>
<thead>
<tr><th>Code</th>
<th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>${FOO%suffix}</code></td><td>Remove suffix</td></tr>
<tr><td><code>${FOO#prefix}</code></td><td>Remove prefix</td></tr>
</tbody>
<tbody>
<tr><td><code>${FOO%%suffix}</code></td><td>Remove long suffix</td></tr>
<tr><td><code>${FOO##prefix}</code></td><td>Remove long prefix</td></tr>
</tbody>
<tbody>
<tr><td><code>${FOO/from/to}</code></td><td>Replace first match</td></tr>
<tr><td><code>${FOO//from/to}</code></td><td>Replace all</td></tr>
</tbody>
<tbody>
<tr><td><code>${FOO/%from/to}</code></td><td>Replace suffix</td></tr>
<tr><td><code>${FOO/#from/to}</code></td><td>Replace prefix</td></tr>
</tbody>
</table>
<h3 id="Bashcheatsheettopic-13">Comments</h3>
<code># Single line comment</code>

<code>: '
This is a
multi line
comment
'</code>

<h3 id="Bashcheatsheettopic-14">Substrings</h3>
<table>
<thead>
<tr><th>Expression</th>
<th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>${FOO:0:3}</code></td><td>Substring <em>(position, length)</em></td></tr>
<tr><td><code>${FOO:(-3):3}</code></td><td>Substring from the right</td></tr>
</tbody>
</table>
<h3 id="Bashcheatsheettopic-15">Length</h3>
<table>
<thead>
<tr><th>Expression</th>
<th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>${#FOO}</code></td><td>Length of <code>$FOO</code></td></tr>
</tbody>
</table>
<h3 id="Bashcheatsheettopic-16">Manipulation</h3>
<code>STR="HELLO WORLD!"
echo ${STR,}   #=&gt; "hELLO WORLD!" (lowercase 1st letter)
echo ${STR,,}  #=&gt; "hello world!" (all lowercase)

STR="hello world!"
echo ${STR^}   #=&gt; "Hello world!" (uppercase 1st letter)
echo ${STR^^}  #=&gt; "HELLO WORLD!" (all uppercase)</code>

<h3 id="Bashcheatsheettopic-17">Default values</h3>
<table>
<thead>
<tr><th>Expression</th>
<th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>${FOO:-val}</code></td><td><code>$FOO</code>, or <code>val</code> if unset (or null)</td></tr>
<tr><td><code>${FOO:=val}</code></td><td>Set <code>$FOO</code> to <code>val</code> if unset (or null)</td></tr>
<tr><td><code>${FOO:+val}</code></td><td><code>val</code> if <code>$FOO</code> is set (and not null)</td></tr>
<tr><td><code>${FOO:?message}</code></td><td>Show error message and exit if <code>$FOO</code> is unset (or null)</td></tr>
</tbody>
</table>
Omitting the <code>:</code> removes the (non)nullity checks, e.g. <code>${FOO-val}</code> expands to <code>val</code> if unset otherwise <code>$FOO</code>.
<h3 id="Bashcheatsheettopic-18"><span class="orange">Loops</span></h3>
<h3 id="Bashcheatsheettopic-19">Basic for loop</h3>
<code>for i in /etc/rc.*; do
  echo $i
done</code>

<h3 id="Bashcheatsheettopic-20">C-like for loop</h3>
<code>for ((i = 0 ; i &lt; 100 ; i++)); do
  echo $i
done</code>

<h3 id="Bashcheatsheettopic-21">Ranges</h3>
<code>for i in {1..5}; do
    echo "Welcome $i"
done</code>

<h4>With step size</h4>
<code>for i in {5..50..5}; do
    echo "Welcome $i"
done</code>

<h3 id="Bashcheatsheettopic-22">Reading lines</h3>
<code>cat file.txt | while read line; do
  echo $line
done</code>

<h3 id="Bashcheatsheettopic-23">Forever</h3>
<code>while true; do
  ···
done</code>

<h3 id="Bashcheatsheettopic-24"><span class="orange">Functions</span></h3>
<h3 id="Bashcheatsheettopic-25">Defining functions</h3>
<code>myfunc() {
    echo "hello $1"
}</code>

<code># Same as above (alternate syntax)
function myfunc() {
    echo "hello $1"
}</code>

<code>myfunc "John"</code>

<h3 id="Bashcheatsheettopic-26">Returning values</h3>
<code>myfunc() {
    local myresult='some value'
    echo $myresult
}</code>

<code>result="$(myfunc)"</code>

<h3 id="Bashcheatsheettopic-27">Raising errors</h3>
<code>myfunc() {
  return 1
}</code>

<code>if myfunc; then
  echo "success"
else
  echo "failure"
fi</code>

<h3 id="Bashcheatsheettopic-28">Arguments</h3>
<table>
<thead>
<tr><th>Expression</th>
<th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>$#</code></td><td>Number of arguments</td></tr>
<tr><td><code>$*</code></td><td>All positional arguments (as a single word)</td></tr>
<tr><td><code>$@</code></td><td>All positional arguments (as separate strings)</td></tr>
<tr><td><code>$1</code></td><td>First argument</td></tr>
<tr><td><code>$_</code></td><td>Last argument of the previous command</td></tr>
</tbody>
</table>
<strong>Note</strong>: <code>$@</code> and <code>$*</code> must be quoted in order to perform as described.
Otherwise, they do exactly the same thing (arguments as separate strings).
See <a href="http://wiki.bash-hackers.org/syntax/shellvars#special_parameters_and_shell_variables">Special parameters</a>.
<h3 id="Bashcheatsheettopic-29"><span class="orange">Conditionals</span></h3>
<h3 id="Bashcheatsheettopic-30">Conditions</h3>
Note that <code>[[</code> is actually a command/program that returns either <code>0</code> (true) or <code>1</code> (false). Any program that obeys the same logic (like all base utils, such as <code>grep(1)</code> or <code>ping(1)</code>) can be used as condition, see examples.
<table>
<thead>
<tr><th>Condition</th>
<th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>[[ -z STRING ]]</code></td><td>Empty string</td></tr>
<tr><td><code>[[ -n STRING ]]</code></td><td>Not empty string</td></tr>
<tr><td><code>[[ STRING == STRING ]]</code></td><td>Equal</td></tr>
<tr><td><code>[[ STRING != STRING ]]</code></td><td>Not Equal</td></tr>
</tbody>
<tbody>
<tr><td><code>[[ NUM -eq NUM ]]</code></td><td>Equal</td></tr>
<tr><td><code>[[ NUM -ne NUM ]]</code></td><td>Not equal</td></tr>
<tr><td><code>[[ NUM -lt NUM ]]</code></td><td>Less than</td></tr>
<tr><td><code>[[ NUM -le NUM ]]</code></td><td>Less than or equal</td></tr>
<tr><td><code>[[ NUM -gt NUM ]]</code></td><td>Greater than</td></tr>
<tr><td><code>[[ NUM -ge NUM ]]</code></td><td>Greater than or equal</td></tr>
</tbody>
<tbody>
<tr><td><code>[[ STRING =~ STRING ]]</code></td><td>Regexp</td></tr>
</tbody>
<tbody>
<tr><td><code>(( NUM &lt; NUM ))</code></td><td>Numeric conditions</td></tr>
</tbody>
</table>
<h4>More conditions</h4>
<table>
<thead>
<tr><th>Condition</th>
<th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>[[ -o noclobber ]]</code></td><td>If OPTIONNAME is enabled</td></tr>
</tbody>
<tbody>
<tr><td><code>[[ ! EXPR ]]</code></td><td>Not</td></tr>
<tr><td><code>[[ X &amp;&amp; Y ]]</code></td><td>And</td></tr>
<tr><td><code>[[ X || Y ]]</code></td><td>Or</td></tr>
</tbody>
</table>
<h3 id="Bashcheatsheettopic-31">File conditions</h3>
<table>
<thead>
<tr><th>Condition</th>
<th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>[[ -e FILE ]]</code></td><td>Exists</td></tr>
<tr><td><code>[[ -r FILE ]]</code></td><td>Readable</td></tr>
<tr><td><code>[[ -h FILE ]]</code></td><td>Symlink</td></tr>
<tr><td><code>[[ -d FILE ]]</code></td><td>Directory</td></tr>
<tr><td><code>[[ -w FILE ]]</code></td><td>Writable</td></tr>
<tr><td><code>[[ -s FILE ]]</code></td><td>Size is &gt; 0 bytes</td></tr>
<tr><td><code>[[ -f FILE ]]</code></td><td>File</td></tr>
<tr><td><code>[[ -x FILE ]]</code></td><td>Executable</td></tr>
</tbody>
<tbody>
<tr><td><code>[[ FILE1 -nt FILE2 ]]</code></td><td>1 is more recent than 2</td></tr>
<tr><td><code>[[ FILE1 -ot FILE2 ]]</code></td><td>2 is more recent than 1</td></tr>
<tr><td><code>[[ FILE1 -ef FILE2 ]]</code></td><td>Same files</td></tr>
</tbody>
</table>
<code># String
if [[ -z "$string" ]]; then
  echo "String is empty"
elif [[ -n "$string" ]]; then
  echo "String is not empty"
else
  echo "This never happens"
fi</code>

<code># Combinations
if [[ X &amp;&amp; Y ]]; then
  ...
fi</code>

<code># Equal
if [[ "$A" == "$B" ]]</code>

<code># Regex
if [[ "A" =~ . ]]</code>

<code>if (( $a &lt; $b )); then
   echo "$a is smaller than $b"
fi</code>

<code>if [[ -e "file.txt" ]]; then
  echo "file exists"
fi</code>

<h3 id="Bashcheatsheettopic-32"><span class="orange">Arrays</span></h3>
<h3 id="Bashcheatsheettopic-33">Defining arrays</h3>
<code>Fruits=('Apple' 'Banana' 'Orange')</code>

<code>Fruits[0]="Apple"
Fruits[1]="Banana"
Fruits[2]="Orange"</code>

<h3 id="Bashcheatsheettopic-34">Working with arrays</h3>
<code>echo ${Fruits[0]}           # Element #0
echo ${Fruits[-1]}          # Last element
echo ${Fruits[@]}           # All elements, space-separated
echo ${#Fruits[@]}          # Number of elements
echo ${#Fruits}             # String length of the 1st element
echo ${#Fruits[3]}          # String length of the Nth element
echo ${Fruits[@]:3:2}       # Range (from position 3, length 2)
echo ${!Fruits[@]}          # Keys of all elements, space-separated</code>

<h3 id="Bashcheatsheettopic-35">Operations</h3>
<code>Fruits=("${Fruits[@]}" "Watermelon")    # Push
Fruits+=('Watermelon')                  # Also Push
Fruits=( ${Fruits[@]/Ap*/} )            # Remove by regex match
unset Fruits[2]                         # Remove one item
Fruits=("${Fruits[@]}")                 # Duplicate
Fruits=("${Fruits[@]}" "${Veggies[@]}") # Concatenate
lines=(`cat "logfile"`)                 # Read from file</code>

<h3 id="Bashcheatsheettopic-36">Iteration</h3>
<code>for i in "${arrayName[@]}"; do
  echo $i
done</code>

<h3 id="Bashcheatsheettopic-37"><span class="orange">Dictionaries</span></h3>
<h3 id="Bashcheatsheettopic-38">Defining</h3>
<code>declare -A sounds</code>

<code>sounds[dog]="bark"
sounds[cow]="moo"
sounds[bird]="tweet"
sounds[wolf]="howl"</code>

Declares <code>sound</code> as a Dictionary object (aka associative array).
<h3 id="Bashcheatsheettopic-39">Working with dictionaries</h3>
<code>echo ${sounds[dog]} # Dog's sound
echo ${sounds[@]}   # All values
echo ${!sounds[@]}  # All keys
echo ${#sounds[@]}  # Number of elements
unset sounds[dog]   # Delete dog</code>

<h3 id="Bashcheatsheettopic-40">Iteration</h3>
<h4>Iterate over values</h4>
<code>for val in "${sounds[@]}"; do
  echo $val
done</code>

<h4>Iterate over keys</h4>
<code>for key in "${!sounds[@]}"; do
  echo $key
done</code>

<h3 id="Bashcheatsheettopic-41"><span class="orange">Options</span></h3>
<h3 id="Bashcheatsheettopic-42">Options</h3>
<code>set -o noclobber  # Avoid overlay files (echo "hi" &gt; foo)
set -o errexit    # Used to exit upon error, avoiding cascading errors
set -o pipefail   # Unveils hidden failures
set -o nounset    # Exposes unset variables</code>

<h3 id="Bashcheatsheettopic-43">Glob options</h3>
<code>shopt -s nullglob    # Non-matching globs are removed  ('*.foo' =&gt; '')
shopt -s failglob    # Non-matching globs throw errors
shopt -s nocaseglob  # Case insensitive globs
shopt -s dotglob     # Wildcards match dotfiles ("*.sh" =&gt; ".foo.sh")
shopt -s globstar    # Allow ** for recursive matches ('lib/**/*.rb' =&gt; 'lib/a/b/c.rb')</code>

Set <code>GLOBIGNORE</code> as a colon-separated list of patterns to be removed from glob
matches.
<h3 id="Bashcheatsheettopic-44"><span class="orange">History</span></h3>
<h3 id="Bashcheatsheettopic-45">Commands</h3>
<table>
<thead>
<tr><th>Command</th>
<th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>history</code></td><td>Show history</td></tr>
<tr><td><code>shopt -s histverify</code></td><td>Don’t execute expanded result immediately</td></tr>
</tbody>
</table>
<h3 id="Bashcheatsheettopic-46">Expansions</h3>
<table>
<thead>
<tr><th>Expression</th>
<th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>!$</code></td><td>Expand last parameter of most recent command</td></tr>
<tr><td><code>!*</code></td><td>Expand all parameters of most recent command</td></tr>
<tr><td><code>!-n</code></td><td>Expand <code>n</code>th most recent command</td></tr>
<tr><td><code>!n</code></td><td>Expand <code>n</code>th command in history</td></tr>
<tr><td><code>!&lt;command&gt;</code></td><td>Expand most recent invocation of command <code>&lt;command&gt;</code></td></tr>
</tbody>
</table>
<h3 id="Bashcheatsheettopic-47">Operations</h3>
<table>
<thead>
<tr><th>Code</th>
<th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>!!</code></td><td>Execute last command again</td></tr>
<tr><td><code>!!:s/&lt;FROM&gt;/&lt;TO&gt;/</code></td><td>Replace first occurrence of <code>&lt;FROM&gt;</code> to <code>&lt;TO&gt;</code> in most recent command</td></tr>
<tr><td><code>!!:gs/&lt;FROM&gt;/&lt;TO&gt;/</code></td><td>Replace all occurrences of <code>&lt;FROM&gt;</code> to <code>&lt;TO&gt;</code> in most recent command</td></tr>
<tr><td><code>!$:t</code></td><td>Expand only basename from last parameter of most recent command</td></tr>
<tr><td><code>!$:h</code></td><td>Expand only directory from last parameter of most recent command</td></tr>
</tbody>
</table>
<code>!!</code> and <code>!$</code> can be replaced with any valid expansion.
<h3 id="Bashcheatsheettopic-48">Slices</h3>
<table>
<thead>
<tr><th>Code</th>
<th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>!!:n</code></td><td>Expand only <code>n</code>th token from most recent command (command is <code>0</code>; first argument is <code>1</code>)</td></tr>
<tr><td><code>!^</code></td><td>Expand first argument from most recent command</td></tr>
<tr><td><code>!$</code></td><td>Expand last token from most recent command</td></tr>
<tr><td><code>!!:n-m</code></td><td>Expand range of tokens from most recent command</td></tr>
<tr><td><code>!!:n-$</code></td><td>Expand <code>n</code>th token to last from most recent command</td></tr>
</tbody>
</table>
<code>!!</code> can be replaced with any valid expansion i.e. <code>!cat</code>, <code>!-2</code>, <code>!42</code>, etc.
<h3 id="Bashcheatsheettopic-49"><span class="orange">Miscellaneous</span></h3>
<h3 id="Bashcheatsheettopic-50">Numeric calculations</h3>
<code>$((a + 200))      # Add 200 to $a</code>

<code>$(($RANDOM%200))  # Random number 0..199</code>

<h3 id="Bashcheatsheettopic-51">Subshells</h3>
<code>(cd somedir; echo "I'm now in $PWD")
pwd # still in first directory</code>

<h3 id="Bashcheatsheettopic-52">Redirection</h3>
<code>python hello.py &gt; output.txt   # stdout to (file)
python hello.py &gt;&gt; output.txt  # stdout to (file), append
python hello.py 2&gt; error.log   # stderr to (file)
python hello.py 2&gt;&amp;1           # stderr to stdout
python hello.py 2&gt;/dev/null    # stderr to (null)
python hello.py &amp;&gt;/dev/null    # stdout and stderr to (null)</code>

<code>python hello.py &lt; foo.txt      # feed foo.txt to stdin for python
diff &lt;(ls -r) &lt;(ls)            # Compare two stdout without files</code>

<h3 id="Bashcheatsheettopic-53">Inspecting commands</h3>
<code>command -V cd
#=&gt; "cd is a function/alias/whatever"</code>

<h3 id="Bashcheatsheettopic-54">Trap errors</h3>
<code>trap 'echo Error at about $LINENO' ERR</code>

or
<code>traperr() {
  echo "ERROR: ${BASH_SOURCE[1]} at about ${BASH_LINENO[0]}"
}

set -o errtrace
trap traperr ERR</code>

<h3 id="Bashcheatsheettopic-55">Case/switch</h3>
<code>case "$1" in
  start | up)
    vagrant up
    ;;

  *)
    echo "Usage: $0 {start|stop|ssh}"
    ;;
esac</code>

<h3 id="Bashcheatsheettopic-56">Source relative</h3>
<code>source "${0%/*}/../share/foo.sh"</code>

<h3 id="Bashcheatsheettopic-57">printf</h3>
<code>printf "Hello %s, I'm %s" Sven Olga
#=&gt; "Hello Sven, I'm Olga

printf "1 + 1 = %d" 2
#=&gt; "1 + 1 = 2"

printf "This is how you print a float: %f" 2
#=&gt; "This is how you print a float: 2.000000"</code>

<h3 id="Bashcheatsheettopic-58">Directory of script</h3>
<code>DIR="${0%/*}"</code>

<h3 id="Bashcheatsheettopic-59">Getting options</h3>
<code>while [[ "$1" =~ ^- &amp;&amp; ! "$1" == "--" ]]; do case $1 in
  -V | --version )
    echo $version
    exit
    ;;
  -s | --string )
    shift; string=$1
    ;;
  -f | --flag )
    flag=1
    ;;
esac; shift; done
if [[ "$1" == '--' ]]; then shift; fi</code>

<h3 id="Bashcheatsheettopic-60">Heredoc</h3>
<code>cat &lt;&lt;END
hello world
END</code>

<h3 id="Bashcheatsheettopic-61">Reading input</h3>
<code>echo -n "Proceed? [y/n]: "
read ans
echo $ans</code>

<code>read -n 1 ans    # Just one character</code>

<h3 id="Bashcheatsheettopic-62">Special variables</h3>
<table>
<thead>
<tr><th>Expression</th>
<th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>$?</code></td><td>Exit status of last task</td></tr>
<tr><td><code>$!</code></td><td>PID of last background task</td></tr>
<tr><td><code>$$</code></td><td>PID of shell</td></tr>
<tr><td><code>$0</code></td><td>Filename of the shell script</td></tr>
<tr><td><code>$_</code></td><td>Last argument of the previous command</td></tr>
</tbody>
</table>
See <a href="http://wiki.bash-hackers.org/syntax/shellvars#special_parameters_and_shell_variables">Special parameters</a>.
<h3 id="Bashcheatsheettopic-63">Go to previous directory</h3>
<code>pwd # /home/user/foo
cd bar/
pwd # /home/user/foo/bar
cd -
pwd # /home/user/foo</code>

<h3 id="Bashcheatsheettopic-64">Check for command’s result</h3>
<code>if ping -c 1 google.com; then
  echo "It appears you have a working internet connection"
fi</code>

<h3 id="Bashcheatsheettopic-65">Grep check</h3>
<code>if grep -q 'foo' ~/.bash_history; then
  echo "You appear to have typed 'foo' in the past"
fi</code>


<h2>Calculating Fire Fighter Shifts with Code BASH</h2>

A="$(date -d 2013-05-01 +%s)"
B="$(date -d 2013-05-02 +%s)"
C="$(date -d 2013-05-03 +%s)"
today="$(date +%F)"
A=$(( ( 'date -d "$today" +%s`=$A ) /(24*3600)%3 ))
B=$(( ( 'date -d "$today" +%s`=$B ) /(24*3600)%3 ))
C=$(( ( 'date -d "$today" +%s`=$C ) /(24*3600)%3 ))
[[ "$A"==0 ]] && echo "Today is A Shift"
[[ "$B"==0 ]] && echo "Today is B Shift”
[[ "sC"==0 ]] && echo "Today is C Shift"

<h2>35 Bash Script Examples</h2>
<div id="BashScripttoc" class="toc"><a href="#BashScripttopic-0" target="_self">1. First Bash Program</a><br><a href="#BashScripttopic-1" target="_self">2. Echo commands</a><br><a href="#BashScripttopic-2" target="_self">3. Use of comment</a><br><a href="#BashScripttopic-3" target="_self">4. Multiline comment</a><br><a href="#BashScripttopic-4" target="_self">5. While Loop</a><br><a href="#BashScripttopic-5" target="_self">6. For Loop</a><br><a href="#BashScripttopic-6" target="_self">7. Get User Input</a><br><a href="#BashScripttopic-7" target="_self">8. If statement</a><br><a href="#BashScripttopic-8" target="_self">9. Use of if statement together with AND logic</a><br><a href="#BashScripttopic-9" target="_self">10. Use if statement with OR logic</a><br><a href="#BashScripttopic-10" target="_self">11. Use of else if statement</a><br><a href="#BashScripttopic-11" target="_self">12. case statement</a><br><a href="#BashScripttopic-12" target="_self">13. Obtaining arguments from Command Line</a><br><a href="#BashScripttopic-13" target="_self">14. 
Obtain arguments from command-line with names</a><br><a href="#BashScripttopic-14" target="_self">15. Integrated string variables</a><br><a href="#BashScripttopic-15" target="_self">16. How to Obtain a substring of string</a><br><a href="#BashScripttopic-16" target="_self">17. 
Addition of two numbers</a><br><a href="#BashScripttopic-17" target="_self">18. function creation</a><br><a href="#BashScripttopic-18" target="_self">19. Functionality creation with parameters</a><br><a href="#BashScripttopic-19" target="_self">20. Passing a return a value from a function</a><br><a href="#BashScripttopic-20" target="_self">21. Make Directory</a><br><a href="#BashScripttopic-21" target="_self">22. 
Creation of a directory by checking its existence</a><br><a href="#BashScripttopic-22" target="_self">23. Reading a file</a><br><a href="#BashScripttopic-23" target="_self">24. File Deleting</a><br><a href="#BashScripttopic-24" target="_self">25. Append or adding to file</a><br><a href="#BashScripttopic-25" target="_self">26. Test File existence</a><br><a href="#BashScripttopic-26" target="_self">27. Send Email</a><br><a href="#BashScripttopic-27" target="_self">28. Parse Current Date</a><br><a href="#BashScripttopic-28" target="_self">29. 
The Wait command</a><br><a href="#BashScripttopic-29" target="_self">30. The Sleep Command</a><br><a href="#BashScripttopic-30" target="_self">31. The AND Operator</a><br><a href="#BashScripttopic-31" target="_self">32. The OR Operator</a><br><a href="#BashScripttopic-32" target="_self">33. 
The switch construct</a><br><a href="#BashScripttopic-33" target="_self">34. Concatenating strings</a><br><a href="#BashScripttopic-34" target="_self">35. Slicing strings</a><br><a href="#BashScripttopic-35" target="_self">Conclusion</a><br></div>
<br><br>
Generally, all Linux users must acquaint themselves with the basic knowledge of bash script programming because of the importance it offers.
<h3 id="BashScripttopic-0">1. First Bash Program</h3>
To get a bash file up and running, you need to execute it by running a terminal command. 
For instance, if we run “Hello World” in our terminal, the output we get will be “Hello World.”
<img class="lazy loaded" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f1.png" src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f1.png" data-was-processed="true">
First Bash Program

To create a bash file, you can use any text editor installed in your operating system. 
In this case, we will use the nano editor for creating the file. Let us name our file ‘First.sh’. 
Execute the command using the following command:

nano First.sh
Add the following bash script to the file before saving the file.
#!/bin/bash

echo “Hello World”

<img class="lazy loaded" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f2.png" src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f2.png" data-was-processed="true">
How to create a bash file

There are different ways of running bash commands. 
For instance, below are two distinct examples of executing bash.

./First.sh
Alternatively, you can use execute the command below:
chmod a+x First.sh

./First.sh

<img class="lazy loaded" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f3.png" src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f3.png" data-was-processed="true">
How to execute Bash
<h3 id="BashScripttopic-1">2. Echo commands</h3>
echo commands have numerous options for selection. 
For instance, there is an addition of a new line by default if you use the ‘echo’ command without any other option. 

Alternatively, you can use ‘-n’ to print any text without a new line. 
Make use of the ‘-e’ command to remove backslash characters from the given output. 
To demonstrate this, create a bash file named ‘echo_example.sh’. 

After that, add the script below
#!/bin/bash
Echo “printing text with newline”

Echo -n “printing text without newline”
Echo -e “\nRemoving \t backslash \t characters\
After adding the script, execute the file with the command below:

bash echo_example.sh

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f4.png">
Echo commands Illustration
<h3 id="BashScripttopic-2">3. Use of comment</h3>
While using comments, we use the “#” symbol to add a single line comment in bash scripting. 
Here, you will create a new file with a simple name such as ‘comment_example’. 

Include a script with a single comment like the example displayed below.
#!/bin /bash
# Add two values

((sum 30+20))
#thereafter print the result
echo $sum

execute the file with bash command-line

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f5.png">
Use of comment
<h3 id="BashScripttopic-3">4. Multiline comment</h3>
In bash, the multiline comment is applicable in different ways. 
To prove this, create a new bash named, ‘multiline-comment example.sh’, after that, add ‘:’ and “ ’ ” scripts symbols to add a multi-line comment in the script. 

The following example will execute the square of 2.
#!bin/bash
: ‘

The script written below is used to calculate the square of 2
‘
((area=2*2))

echo$area
execute the file with bash command-line
bash multiline-comment-example.sh


<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f6.png">
Multiline comment illustration
<h3 id="BashScripttopic-4">5. While Loop</h3>
For easy comprehension of this bash script, create a file named ‘while_sample.sh’. 
The while loop will repeat five times before terminating the process. 
While looping, the count variable increases the count by 1 in every step till the fifth time when the loop stops.

#!/bin/bash
valid=True
count=1

while [$valid ]
do
echo $count

if [$count -eq 5 ];
then break
fi

((count++))
done
execute the file with bash command-line

bash while_example.sh

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f7.png">
While Loop illustration
<h3 id="BashScripttopic-5">6. For Loop</h3>
Take a look at the following for loop example. 
After creating a file named ‘for_sample.sh’, add the script using ‘for loop’. 

This process will re-occur 12 times. 
After that, it will display the fields in a single line, as shown below;
#!/bin/bash

for (( counter=10; counter&gt;0; counter-- ))
do
echo -n "$counter "

done
printf "\n"
Execute the command by running the code below

bash for_sample.sh

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f8.png">
For Loop Illustration
<h3 id="BashScripttopic-6">7. Get User Input</h3>
To get user input from bash, we will use the ‘read’ command. 
Follow the simple steps below to achieve the expected results. 

First, create a file named ‘user_feedin.sh’ and include the script below to get the user input. 
One value will be taken and displayed by combining other string values. 
As indicated below,

#!/bin/bash
echo "Enter Your Name"
read name

echo "Welcome $name to FossLinux"
execute the file with bash command-line
bash user_feedin.sh


<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f9.png">
Get User Input Illustration
<h3 id="BashScripttopic-7">8. If statement</h3>
The if statement is used by both multiple and single conditions. 
A definition of ‘if’ and ‘fi’ are used Before and after an if statement. 
To easily understand the if statement in bash, we shall use an example. 

Create a file named ‘example_if.sh’.
For instance, the number 4 is assigned a variable ‘s.’ If the number is divisible by 2, then the output will be “it is divisible by 2”; otherwise, if the number is not divisible by 2, then the outcome will be “it is not divisible by 2”. 
The ‘-lt’, in this case, is used for comparison purposes. 

Another comparison feature is ‘-eq.’ ‘-ne’, on the other hand, is used to show inequality while ‘-gt’ shows if a value is more significant in bash script.
#!/bin/bash
s=4

if [ $s / 2 ];
then
echo "It is not divisible by 2"

else
echo "It is divisible by 2"
fi

execute the file with bash command-line
bash example_if.sh

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f10.png">
If statement Illustration

<h3 id="BashScripttopic-8">9. Use of if statement together with AND logic</h3>
Various logical conditions can be used with the if statement whenever there are two or more conditions. 

The example below shows how the logic “AND” is used in defining multiple conditions in an if statement. 
The “&amp;&amp;” symbols represent the “AND” logic in a bash script. 
Create a file named ‘if_plus_AND.sh’.

In this example, the username and password variables entered by the user will be compared with the “main” and “users” directory to see if they match. 
If they do, the process will be successful, thus displaying “valid-user” as the output. 
Otherwise, if they do not match, the outcome will be “invalid user.”

!/bin/bash
echo "input username"
read username

echo "input password"
read password
if [[ ( $username == "main" &amp;&amp; $password == "users" ) ]]; then

echo "valid user"
else
echo "invalid user"

fi
Execute the file using the bash command-line
bash if_plus_AND.sh


<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f11.png">
Use of if statement with AND logic illustration.

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f12.png">
Use if statement with AND logic Illustration
The first example shows authentication failure since the user-provided does not match with the main fields.

The second examples show successful authentication since the provided fields matched with the main fields.
<h3 id="BashScripttopic-9">10. Use if statement with OR logic</h3>
When using OR with the if function, the ‘||’ symbol is used. 
To demonstrate this, we will create a file named ‘if_with_OR.sh’ to check the use of OR logic in an IF statement. 
Take an instance of value ‘s’ being assigned to two numbers (10 or 40). 

If a user inputs either of the given numbers, then the system’s output will be “Well Played”; otherwise, the result shown will be “Sorry, You Failed.” If you examine this example, you will notice that the value of s is generated from the user.
#!/bin/bash
echo "Enter any number"

read s
if [[ ( $s -eq 10 || $n -eq 40 ) ]]
then

echo "Well Played"
else
echo "Sorry, You Failed"

fi
execute the file with bash command-line
bash if_with_OR.sh


<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f13.png">
Use if statement with OR logic Illustration
As indicated in the example above, 5 is not equal to 10 or 40. 
Therefore, the output displays “Sorry, You Failed,”

In the figure above, the user was prompted to enter any number, and he/she chose 10, and the output given is “Well Played” since 10==10
<h3 id="BashScripttopic-10">11. Use of else if statement</h3>
Many conditional statements are nearly the same despite the programming languages you choose. 
However, in bash programming, the use of the ‘else if’ condition is kind of different. 
In bash, Elif is used in place of the else if condition. 

We will create a file named ‘elseif_instance.sh’ then add the bash script for demonstration purposes.
echo "Enter your lucky number"
read n

if [ $n -eq 50 ];
then
echo "You won the 1st bravo!!!!"

elif [ $n -eq 100 ];
then
echo "You won the 2nd congrats!!!!"

elif [ $n -eq 500 ];
then
echo "You won the 3rd congrats!!!!"

else
echo "Sorry, you have to keep trying pal"
fi

Execute the file with bash command-line
Bash elseif_instance.sh

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f14.png">
use of else if statement Illustration

The execution above displays the three instances done by bash.
<h3 id="BashScripttopic-11">12. case statement</h3>
Have you ever heard of the “if-elseif-else” statement? If not, don’t worry, as it will be covered here. 
The Case statement is used as a substitute for the if-elseif-else statement. 
‘Case’ and ‘esac’ delineate the starting and ending block respectively while using this statement. 

For more elaboration, an example will be of great help. 
Create a file named ‘case_example.sh’. 
After that, include the script provided below. 

Then, take a look at the output and compare it to the previous one. 
You will notice that the outcomes of both the case statement and if-elseif-else statements are the same.


#!/bin/bash
echo "Input your Lucky Number"
read s

case $s in
50)
echo echo "You won the 1st bravo!!!!" ;;

100)
echo "You won the 2nd congrats!!!!" ;;
500)

echo "You won the 3rd congrats" ;;
*)
echo "Sorry, you have to keep trying pal" ;;

esac
execute the file with bash command-line
bash case_example.sh


<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f15.png">
case statement Illustration
<h3 id="BashScripttopic-12">13. Obtaining arguments from Command Line</h3>
Bash script can emulate how other programming languages obtain inputs from the command line. 
Look at an instance where variables $1 and $3 are used to cypher through the first and third command-line arguments, respectively. 
For more elaboration, let’s create a file named ‘command-line.sh’ and include the script below. 

In the end, the output given is the print of the total count of arguments read by the script.
#!/bin/bash
echo "Total arguments : $#"

echo "1st Argument = $1"
echo "3rd argument = $3"
Execute the file with bash command-line

bash command_line.sh Foss Linux Website

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f16.png">
Obtaining arguments from Command Line Illustration
<h3 id="BashScripttopic-13">14. 
Obtain arguments from command-line with names</h3>
This section demonstrates how to read command-line arguments that contain names. 
To do this, create a file named ‘command_line_names.sh’. 

After that, add a code with two arguments: A, B, to be read by the script and compute the sum of A and B.
#!/bin/bash
for arg in "$@"

do
index=$(echo $arg | cut -f1 -d=)
val=$(echo $arg | cut -f2 -d=)

case $index in
A) a=$val;;
B) b=$val;;

*)
esac
done

((result=a+b))
echo "A+B=$result"
Execution with bash command. 

The code below is a combination of the two command-line arguments.
bash command_line_names.sh A=10 B=16

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f17.png">
Obtain arguments from command-line with names Illustration

<h3 id="BashScripttopic-14">15. Integrated string variables</h3>
Bash has some significant advantages that aid a programmer to accomplish tasks quickly. 

String variable integration is a combination of two or more variables. 
To demonstrate this, create a file named ‘string_combination.sh’. 
After that, add the script provided below and look at how you can integrate string variables by placing variables together using the ‘+’ operator.

#!/bin/bash
stringA="Foss"
stringB="Linux"

echo "$stringA$stringB"
stringC=$stringA+$stringB
stringC+=" has the best online tutorials"

echo $stringC
execute the file with bash command-line
bash string_combination.sh


<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f18.png">
Integrated string variables Illustration
<h3 id="BashScripttopic-15">16. How to Obtain a substring of string</h3>
Bash lacks an inbuilt function to truncate values from a data string, just like other programming languages. 
However, bash allows you to carry out substring truncation differently, as shown in the script below. 
Create a file named ‘substring_example.sh’. 

In this case, the value 7 shows the substring’s protrusive point, whereas 6 shows the substring’s total length.
#!/bin/bash
Str="Get connected to FossLinux blogsite"

subStr=${Str:4:9}
echo $subStr
Execution with bash command

bash substring_example.sh

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f19.png">
How to Obtain a substring of string Illustration
<h3 id="BashScripttopic-16">17. 
Addition of two numbers</h3>
Bash supports arithmetic operations in various and complex ways. 
To display the complex advantages of bash, you will do the sum of two integers using double brackets, as shown below. 

First, you will create a file named ‘sum_numbers.sh’ using the code below. 
The function will prompt the user to enter the first digit, then the second digit, and finally, print the result, which computes the user’s two integers.
#!/bin/bash

echo "input first digit 1"
read a
echo "input digit 2"

read b
(( sum=a+b ))
echo "Result=$sum"

Execute the file with bash command-line
bash sum_numbers.sh

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f20.png">
Addition of two numbers Illustration

<h3 id="BashScripttopic-17">18. function creation</h3>
Bash scripting allows the user to create a function and call the same function. 

This has been demonstrated in the example below. 
Create a file named ‘function_example.sh’ and input the code outline in the sample. 
Here, you will select any function randomly by name without specifying any kind of bash script brackets.

#!/bin/bash
function x()
{

echo 'I love fosslinux'
}
x

Execute the file using the command-line below;
bash function_example.sh

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f21.png">
function creation Illustration

<h3 id="BashScripttopic-18">19. Functionality creation with parameters</h3>
In bash programming, you can use parameters in a function by using other variables. 

Call the 1st value $1 and the second value $2 in an instance where the two values are called simultaneously with the function to read the values. 
To ascertain this, you will create a file named ‘function_parameter.sh’. 
Let us find the area of a rectangle ‘Rectangle_Area’ using the given parameters.

#!/bin/bash
Rectangle_Area() {
area=$(($1 * $2))

echo "Area is : $area"
}
Rectangle_Area 15 25

Execute the file with the bash command.
bash function_parameter.sh

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f22.png">
Functionality creation with parameters Illustration

<h3 id="BashScripttopic-19">20. Passing a return a value from a function</h3>
When dealing with returning values in bash programming, bash has a built-in function that allows the passing of numeric and string values. 

The following example shows the passing of string values in a function. 
You will create a file named ‘function_return.sh’ and include the code below for easy comprehension. 
The function grow() returns a string value into the variable, which later outputs the integrated string results.

#!/bin/bash
function greeting() {
str="Goodmorning, $fname"

echo $str
}
echo "Input your fname"

read fname
val=$(greeting)
echo "Return value of the function is $val"

Execute the file with bash command-line
bash function_return.sh

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f23.png">
Passing a return a value from a function Illustration

<h3 id="BashScripttopic-20">21. Make Directory</h3>
‘Mkdir’ is a command used to create a new directory. 

This command means ‘make directory’. 
Create a file named ‘make_directory.sh’. 
After that, input a code that will create a new directory. 

Bash will create a new directory for you.
#!/bin/bash
echo "Input a new directory name"

read newdir
`mkdir $newdir`
Execute the file with bash command-line

bash make_directory.sh

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f24.png">
Make Directory Illustration
<h3 id="BashScripttopic-21">22. 
Creation of a directory by checking its existence</h3>
‘-d’ is a command that aids the user to check for an existing directory in the current computer location or not. 
This prevents one from executing the ‘mkdir’ command when not sure whether a directory is there or not. 

For demonstration, create a file named ‘directory_exists.sh’ and add the code written below to check any directory exists.
#!/bin/bash
echo "New directory name input"

read ndir
if [ -d "$ndir" ]
then

echo "The Directory given exists"
else
`mkdir $ndir`echo "Directory created"

fi
Execution with bash command.
Bash directory_exists.sh


<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f25.png">
Creation of a directory by checking its existence Illustration
<h3 id="BashScripttopic-22">23. Reading a file</h3>
Bash has a looping functionality that helps the user to read any file. 
Here we will showcase the easiest way to make you understand. 
We will do so by creating an example file named ‘read_file.sh’ and add the code below to determine the existing file called ‘langeages.txt.’

#!/bin/bash
file='languages.txt'
while read line; do

echo $line
done &lt; $file
Execute the file with bash command-line

bash read_file.sh

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f26.png">
Reading a file Illustration
To check the original content of languages.txt, run the command below.

cat languages.txt
<h3 id="BashScripttopic-23">24. File Deleting</h3>
In bash programming, an ‘rm’ command is used to remove or delete files. 
We will delete a file using the ‘rm’ command. 
First, create a file named ‘delete_file.sh’. 

After that, use the code highlighted below to make the initial user’s file name and remove it. 
The ‘-i’ command is helpful as it allows the users to delete the file.
#!/bin/bash

echo "Insert a filename to delete"
read filename
rm -i $filename

Execute the file with bash command-line.
bash delete_file.sh

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f27.png">
File Deleting Illustration

<h3 id="BashScripttopic-24">25. Append or adding to file</h3>
With an existing file, bash has a ‘&gt;&gt;’ operator that allows appending of new data into the file. 

To test this, create a file named ‘add_file.sh’. 
Then add a code that will add data to the end of the current file. 
Add the following string, ‘studying angular,’ to the ‘languages.txt’ file after running the bash script.

#!/bin/bash
echo "Before adding the file"
cat languages.txt

echo "Studying angular"&gt;&gt; languages.txt
echo "After adding the file"
cat languages.txt

Execution with bash command.
bash add_file.sh

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f28.png">
Append or adding to file Illustration

<h3 id="BashScripttopic-25">26. Test File existence</h3>
Bash has great user functionalities that make it user-friendly. 

In this section, we will see the functionality that gives you an option of checking whether a particular file exists or not. 
The ‘-e’ or ‘-f’ commands will aid us in checking if a file exists or not. 
To test this, create a file named ‘file_exist.sh’, then add the code below. 

In this test, the filename will pass from the command line.
#!/bin/bash
filename=$1

if [ -f "$filename" ]; then
echo "File exists"
else

echo "File does not exist"
fi
Run the commands displayed below to confirm the existence of the files. 

In this example, the languages.txt file is available, whereas the languages1.txt file does not exist.
ls
bash file_exist.sh languages.txt

bash file_exist.sh languages1.txt

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f29.png">
Test File existence Illustration
These commands are used to check whether a file being looked for exists or not. 

For instance, in this example, the languages.txt file exists, while the languages1.txt does not exist.
<h3 id="BashScripttopic-26">27. Send Email</h3>
The ‘mail’ or ‘sendmail’ commands in a bash script are used to send emails. 
These commands will work efficiently after installing all the necessary packages. 
For demonstration purposes, create a file named ‘mail_example.sh’. Use the codes highlighted below to send the intended email.

#!/bin/bash
Recipient=”fosslinux@example.com”
Subject=”inquiries”

Message=”Need anything from fosslinux blogsite?”
`mail -s $Subject $Recipient &lt;&lt;&lt; $Message`
Execute the file with the bash command.

bash mail_example.sh
<h3 id="BashScripttopic-27">28. Parse Current Date</h3>
Bash has a feature that enables parsing of the date and time values that we will focus on in this section. 
Bash allows you to get the current date and time using the ‘date’ command. 
‘S,’ ‘d’, ‘M,’ ‘m’, ‘Y,’ and ‘H’ are values used to analyze date and time. 

Create a file named ‘date_parse.sh’ and add a code that will detach month, year, day, hour, minutes, and the seconds’ values.
#!/bin/bash
Year=`date +%Y`

Month=`date +%m`
Day=`date +%d`
Hour=`date +%H`

Minute=`date +%M`
Second=`date +%S`
echo `date`

echo "Current Date is: $Day-$Month-$Year"
echo "Current Time is: $Hour:$Minute:$Second"
Execute the file with the bash command.

bash date_parse.sh

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f30.png">
Parse Current Date Illustration
<h3 id="BashScripttopic-28">29. 
The Wait command</h3>
Linux OS has a built-in command feature that awaits to complete any running process by using a peculiar id to finish that particular assigned task. 
Therefore, when there is no job id, the wait command will wait for all secondary cycles to complete before returning exiting. 

Create a file named ‘wait_example.sh’ and add the script below for execution.
#!/bin/bash
echo "Waiting command" &amp;

process_id=$!
wait $process_id
echo "Exited with status $?"

Execute the file using the bash command.
bash wait_example.sh

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f31.png">
The Wait command Illustration

<h3 id="BashScripttopic-29">30. The Sleep Command</h3>
The sleep command helps the user to pause an ongoing task for a specified period. 

It gives you the allowance of delaying or halting/pausing for hours, minutes, seconds, or days. 
For illustration purposes, create a file and name it ‘sleep_examples.sh’, thereafter run the script shown below.
The example aims to delay the task for approximately 8 seconds after execution.

#!/bin/bash
echo “Please be patient for 8 seconds”
sleep 8

echo “Completed”
Execute the file using the bash command
bash sleep_examples.sh


<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f32.png">
The Sleep Command Illustration
<h3 id="BashScripttopic-30">31. The AND Operator</h3>
This operator allows the system to check if multiple conditions have been satisfied. 
This means that all conditions separated by the AND operator must be true for correct execution. 
Additionally, the ‘&amp;&amp;’ operator is used to denote ‘AND’. 

To ascertain this, check the example below. 
First, create a file called ‘And_operator.sh’ then execute it using bash command-line.
#!/bin/bash

echo -n "Input a Number:"
read num
if [[ ( $num -lt 20 ) &amp;&amp; ( $num%2 -eq 0 ) ]]; then

echo "It is an Even Number"
else
echo "It is an Odd Number"

fi
Execute the file using the bash command-line
bash And_operator.sh


<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f33.png">
The AND Operator Illustration
<h3 id="BashScripttopic-31">32. The OR Operator</h3>
This is a great bash scripting construct that aids in creating complex logic in scripts. 
This construct works slightly differently than the ‘AND’ operator because it either returns true whenever the operands outcome is true. 
On the other hand, the ‘or’ operator only returns false whenever both the operands are false. 

Check the sample below for more elaboration. 
To find out about this construct, create a file named ‘OR_operator.sh’ and complete its execution using the command line.
#!/bin/bash

echo -n "Enter any number:"
read n
if [[ ( $n -eq 5 || $n -eq 30 ) ]]

then
echo "You won"
else

echo "You lost!"
fi
Command-line execution using bash

bash OR_operator.sh

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f34.png">
The OR Operator Illustration
<h3 id="BashScripttopic-32">33. 
The switch construct</h3>
The Switch construct is applicable in situations where nested conditions are needed. 
The example below gives a detailed outline. 

Create a file named ‘switch_construct.sh’. 
Then execute the file using the bash command-line
#!/bin/bash

echo -n "Input a number: "
read number
case $number in

50)
echo "Fifty!!" ;;
100)

echo "Double fifty!!" ;;
*)
echo "Neither 100 nor 200" ;;

esac
Execute the file with the bash command-line
bash switch_construct.sh


<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f35.png">
The switch construct Illustration
<h3 id="BashScripttopic-33">34. Concatenating strings</h3>
With its advanced comfort-ability, bash allows easy implementation of concatenating string. 
This has been simplified by the example below. 
For demonstration purposes, create a file named ‘concatenating_strings.sh’ and run the file in the bash command line. 

You will get an output similar to the one below.
#!/bin/bash
string1="FossLinux"

string2="Blogsite"
string=$string1$string2
echo "$string is a great resource for Linux users to find relevant tutorials."

Execute the file with the bash command
bash concatenating_strings

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f36.png">
Concatenating strings Illustration

<h3 id="BashScripttopic-34">35. Slicing strings</h3>
The slicing string refers to the reduction of parts of a string. 

Unlike many programming languages that offer truncation of strings, bash doesn’t provide this feature. 
Below is an example to make you get a glimpse of what we are talking about. 
First, create a file named ‘slicing_strings.sh’. 

Thereafter, execute the created slicing file using the bash command line.
#!/bin/bash
Str="Study smart commands with fosslinux"

subStr=${Str:0:20}
echo $subStr
The output in the script above should be ‘Study Smart commands.’ The expansion in parameter takes the formula <strong>{VAR_NAME: S: L)</strong>. 

in this formula, S shows the starting position, whereas L denotes the length.
bash slicing_strings.sh

<img class="lazy" data-src="https://786647.smushcdn.com/1490832/wp-content/uploads/2021/04/f37.png">
slicing strings Illustration

<h3 id="BashScripttopic-35">Conclusion</h3>
The article has covered 35 bash script examples giving the user a diverse learning range. 
If you have been looking for an all-around article with bash script examples, this should be your ultimate choice.


<h2>35 Bash Script Examples</h2>
<div id="35Bashtoc" class="toc"><a href="#35Bashtopic-0" target="_self">Simple Backup bash shell script</a><br><a href="#35Bashtopic-1" target="_self">Variables in Bash scripts</a><br><a href="#35Bashtopic-2" target="_self">Global vs. Local variables</a><br><a href="#35Bashtopic-3" target="_self">Passing arguments to the bash script</a><br><a href="#35Bashtopic-4" target="_self">Executing shell commands with bash</a><br><a href="#35Bashtopic-5" target="_self">Reading User Input</a><br><a href="#35Bashtopic-6" target="_self">Bash Trap Command</a><br><a href="#35Bashtopic-7" target="_self">Arrays</a><br><a href="#35Bashtopic-8" target="_self">Declare simple bash array</a><br><a href="#35Bashtopic-9" target="_self">Read file into bash array</a><br><a href="#35Bashtopic-10" target="_self">Bash if / else / fi statements</a><br><a href="#35Bashtopic-11" target="_self">Nested if/else</a><br><a href="#35Bashtopic-12" target="_self">Bash Comparisons</a><br><a href="#35Bashtopic-13" target="_self">Arithmetic Comparisons</a><br><a href="#35Bashtopic-14" target="_self">String Comparisons</a><br><a href="#35Bashtopic-15" target="_self">Bash File Testing</a><br><a href="#35Bashtopic-16" target="_self">Loops</a><br><a href="#35Bashtopic-17" target="_self">Bash for loop</a><br><a href="#35Bashtopic-18" target="_self">Bash while loop</a><br><a href="#35Bashtopic-19" target="_self">Bash until loop</a><br><a href="#35Bashtopic-20" target="_self">Control bash loop with input</a><br><a href="#35Bashtopic-21" target="_self">Bash Functions</a><br><a href="#35Bashtopic-22" target="_self">Bash Select</a><br><a href="#35Bashtopic-23" target="_self">Case statement conditional</a><br><a href="#35Bashtopic-24" target="_self">Bash quotes and quotations</a><br><a href="#35Bashtopic-25" target="_self">Escaping Meta characters</a><br><a href="#35Bashtopic-26" target="_self">Single quotes</a><br><a href="#35Bashtopic-27" target="_self">Double quotes</a><br><a href="#35Bashtopic-28" target="_self">Bash quoting with ANSI-C style</a><br><a href="#35Bashtopic-29" target="_self">Arithmetic Operations</a><br><a href="#35Bashtopic-30" target="_self">Bash Addition Calculator Example</a><br><a href="#35Bashtopic-31" target="_self">Bash Arithmetics</a><br><a href="#35Bashtopic-32" target="_self">Round floating point number</a><br><a href="#35Bashtopic-33" target="_self">Bash floating point calculations</a><br><a href="#35Bashtopic-34" target="_self">Redirections</a><br><a href="#35Bashtopic-35" target="_self">STDOUT from bash script to STDERR</a><br><a href="#35Bashtopic-36" target="_self">STDERR from bash script to STDOUT</a><br><a href="#35Bashtopic-37" target="_self">stdout to screen</a><br><a href="#35Bashtopic-38" target="_self">stdout to file</a><br><a href="#35Bashtopic-39" target="_self">stderr to file</a><br><a href="#35Bashtopic-40" target="_self">stdout to stderr</a><br><a href="#35Bashtopic-41" target="_self">stderr to stdout</a><br><a href="#35Bashtopic-42" target="_self">stderr and stdout to file</a><br><a href="#35Bashtopic-43" target="_self">Closing Thoughts</a><br></div>
<br><br>
First you need to find out where is your Bash interpreter located. 
Enter the following into your command line:
$ which bash
/bin/bash

This command reveals that the Bash shell is stored in <code>/bin/bash</code>. 
This will come into play momentarily.

The next thing you need to do is open our favorite text editor and create a file called <code>hello_world.sh</code>. 
We will use nano for this step.
$ nano hello_world.sh

Copy and paste the following lines into the new file:
#!/bin/bash
# declare STRING variable
STRING="Hello World"
# print variable on a screen
echo $STRING

NOTE: Every bash shell script in this tutorial starts with a shebang: <code>#!</code> which is not read as a comment. 
First line is also a place where you put your interpreter which is in this case: <code>/bin/bash</code>.

Navigate to the directory where your <code>hello_world.sh</code> script is located and make the file executable:
$ chmod +x hello_world.sh 

Now you are ready to execute your first bash script:
$ ./hello_world.sh 

The output you receive should simply be:
Hello World

<h3 id="35Bashtopic-0">Simple Backup bash shell script</h3>
When writing a Bash script, you are basically putting into it the same commands that you could execute directly on the command line. 
A perfect example of this is the following script:
#!/bin/bash
tar -czf myhome_directory.tar.gz /home/linuxconfig

This will create a compressed tar file of the home directory for user <code>linuxconfig</code>. 
The <code>tar</code> command we use in the script could easily just be executed directly on the command line.
So, what's the advantage of the script? Well, it allows us to quickly call this command without having to remember it or type it every time. 
We could also easily expand the script later on to be more complex.
<h3 id="35Bashtopic-1">Variables in Bash scripts</h3>
In this example we declare simple bash variable <code>$STRING</code> and print it on the screen (stdout) with <code>echo</code> command.
#!/bin/bash
STRING="HELLO WORLD!!!"
echo $STRING 

The result when we execute the script:
$ ./hello_world.sh
HELLO WORLD!!!

Circling back to our backup script example, let's use a variable to name our backup file and put a time stamp in the file name by using the <code>date</code> command.
#!/bin/bash
OF=myhome_directory_$(date +%Y%m%d).tar.gz
tar -czf $OF /home/linuxconfig 

The result of executing the script:
$ ./backup.sh
$ ls
myhome_directory_$(date +20220209).tar.gz

Now, when we see the file, we can quickly determine that the backup was performed on February 9, 2022.
<h3 id="35Bashtopic-2">Global vs. Local variables</h3>
In Bash scripting, a global variable is a variable that can be used anywhere inside the script. 
A local variable will only be used within the function that it is declared in. 
Check out the example below where we declare both a global variable and local variable. 
We've made some comments in the script to make it a little easier to digest.
#!/bin/bash
# Define bash global variable
# This variable is global and can be used anywhere in this bash script
VAR="global variable"

function bash {
# Define bash local variable
# This variable is local to bash function only
local VAR="local variable"
echo $VAR
}

echo $VAR
bash
# Note the bash global variable did not change
# "local" is bash reserved word
echo $VAR

The result of executing this script:
$ ./variables.sh
global variable
local variable
global variable

<h3 id="35Bashtopic-3">Passing arguments to the bash script</h3>
When executing a Bash script, it is possible to pass arguments to it in your command. 
As you can see in the example below, there are multiple ways that a Bash script can interact with the arguments we provide.
#!/bin/bash
# use predefined variables to access passed arguments
#echo arguments to the shell
echo $1 $2 $3 ' -&gt; echo $1 $2 $3'

# We can also store arguments from bash command line in special array
args=("$@")
#echo arguments to the shell
echo ${args[0]} ${args[1]} ${args[2]} ' -&gt; args=("$@"); echo ${args[0]} ${args[1]} ${args[2]}'

#use $@ to print out all arguments at once
echo $@ ' -&gt; echo $@'

# use $# variable to print out
# number of arguments passed to the bash script
echo Number of arguments passed: $# ' -&gt; echo Number of arguments passed: $#' 

Let's try executing this script and providing three arguments.
$ ./arguments.sh Bash Scripting Tutorial

The results when we execute this script:
Bash Scripting Tutorial  -&gt; echo $1 $2 $3
Bash Scripting Tutorial  -&gt; args=("$@"); echo ${args[0]} ${args[1]} ${args[2]}
Bash Scripting Tutorial  -&gt; echo $@
Number of arguments passed: 3  -&gt; echo Number of arguments passed: $#
<h3 id="35Bashtopic-4">Executing shell commands with bash</h3>
The best way to execute a separate shell command inside of a Bash script is by creating a new subshell through the <code>$( )</code> syntax. 
Check the example below where we echo the result of running the <code>uname -o</code> command.
#!/bin/bash
# use a subshell $() to execute shell command
echo $(uname -o)
# executing bash command without subshell
echo uname -o 

Notice that in the final line of our script, we do not execute the <code>uname</code> command within a subshell, therefore the text is taken literally and output as such.
$ uname -o
GNU/LINUX
$ ./subshell.sh
GNU/LINUX
uname -o

<h3 id="35Bashtopic-5">Reading User Input</h3>
We can use the <code>read</code> command to read input from the user. 
This allows a user to interact with a Bash script and help dictate the way it proceeds. 
Here's an example:
#!/bin/bash
echo -e "Hi, please type the word: \c "
read  word
echo "The word you entered is: $word"
echo -e "Can you please enter two words? "
read word1 word2
echo "Here is your input: \"$word1\" \"$word2\""
echo -e "How do you feel about bash scripting? "
# read command now stores a reply into the default build-in variable $REPLY
read
echo "You said $REPLY, I'm glad to hear that! "
echo -e "What are your favorite colours ? "
# -a makes read command to read into an array
read -a colours
echo "My favorite colours are also ${colours[0]}, ${colours[1]} and ${colours[2]}:-)"

Our Bash script asks multiple questions and then is able to repeat the information back to us through variables and arrays:
$ ./read.sh
Hi, please type the word: Linuxconfig.org
The word you entered is: Linuxconfig.org
Can you please enter two words? 
Debian Linux
Here is your input: "Debian" "Linux"
How do you feel about bash scripting? 
good
You said good, I'm glad to hear that! 
What are your favorite colours ? 
blue green black
My favorite colours are also blue, green and black:-)

<h3 id="35Bashtopic-6">Bash Trap Command</h3>
The <code>trap</code> command can be used in Bash scripts to catch signals sent to the script and then execute a subroutine when they occur. 
The script below will detect a <code>Ctrl + C</code> interrupt.
#!/bin/bash
# bash trap command
trap bashtrap INT
# bash clear screen command
clear;
# bash trap function is executed when CTRL-C is pressed:
# bash prints message =&gt; Executing bash trap subrutine !
bashtrap()
{
    echo "CTRL+C Detected !...executing bash trap !"
}
# for loop from 1/10 to 10/10
for a in `seq 1 10`; do
    echo "$a/10 to Exit." 
    sleep 1;
done
echo "Exit Bash Trap Example!!!" 

In the output below you can see that we try to <code>Ctrl + C</code> two times but the script continues to execute.
$ ./trap.sh
1/10 to Exit.
2/10 to Exit.
^CCTRL+C Detected !...executing bash trap !
3/10 to Exit.
4/10 to Exit.
5/10 to Exit.
6/10 to Exit.
7/10 to Exit.
^CCTRL+C Detected !...executing bash trap !
8/10 to Exit.
9/10 to Exit.
10/10 to Exit.
Exit Bash Trap Example!!!

<h3 id="35Bashtopic-7">Arrays</h3>
Bash is capable of storing values in arrays. 
Check the sections below for two different examples.
<h3 id="35Bashtopic-8">Declare simple bash array</h3>
This example declares an array with four elements.
#!/bin/bash
#Declare array with 4 elements
ARRAY=( 'Debian Linux' 'Redhat Linux' Ubuntu Linux )
# get number of elements in the array
ELEMENTS=${#ARRAY[@]}

# echo each element in array 
# for loop
for (( i=0;i&lt;$ELEMENTS;i++)); do
    echo ${ARRAY[${i}]}
done 

Executing the script will output the elements of our array:
$ ./arrays.sh
Debian Linux
Redhat Linux
Ubuntu
Linux

<h3 id="35Bashtopic-9">Read file into bash array</h3>
Rather than filling out all of the elements of our array in the Bash script itself, we can program our script to read input and put it into an array.
#!/bin/bash
# Declare array
declare -a ARRAY
# Link filedescriptor 10 with stdin
exec 10&lt;&amp;0
# stdin replaced with a file supplied as a first argument
exec &lt; $1
let count=0

while read LINE; do
    ARRAY[$count]=$LINE
    ((count++))
done

echo Number of elements: ${#ARRAY[@]}
# echo array's content
echo ${ARRAY[@]}
# restore stdin from filedescriptor 10
# and close filedescriptor 10
exec 0&lt;&amp;10 10&lt;&amp;-

Now let's execute the script and store four elements in the array by using a file's contents for input.

$ cat bash.txt
Bash
Scripting
Tutorial
Guide
$ ./bash-script.sh bash.txt 
Number of elements: 4
Bash Scripting Tutorial Guide

<h3 id="35Bashtopic-10">Bash if / else / fi statements</h3>
Here is a simple <code>if</code> statement that check to see if a directory exists or not. 
Depending on the result, it will do one of two things. 
Please note the spacing inside the <code>[</code> and <code>]</code> brackets! Without the spaces, it won’t work!
#!/bin/bash
directory="./BashScripting"

# bash check if directory exists
if [ -d $directory ]; then
	echo "Directory exists"
else 
	echo "Directory does not exist"
fi

The output:
$ ./bash_if_else.sh
Directory does not exist
$ mkdir BashScripting
$ ./bash_if_else.sh
Directory exists

<h3 id="35Bashtopic-11">Nested if/else</h3>
It is possible to place an <code>if</code> statement inside yet another <code>if</code> statement. 
This is called nesting. 
Scripts can get a bit complex depending on how many <code>if</code> statements deep it is.
#!/bin/bash
# Declare variable choice and assign value 4
choice=4
# Print to stdout
 echo "1. Bash"
 echo "2. Scripting"
 echo "3. Tutorial"
 echo -n "Please choose a word [1,2 or 3]? "
# Loop while the variable choice is equal 4
# bash while loop
while [ $choice -eq 4 ]; do
# read user input
read choice
# bash nested if/else
if [ $choice -eq 1 ] ; then
        echo "You have chosen word: Bash"

else                   
        if [ $choice -eq 2 ] ; then
                 echo "You have chosen word: Scripting"
        else
                if [ $choice -eq 3 ] ; then
                        echo "You have chosen word: Tutorial"
                else
                        echo "Please make a choice between 1-3 !"
                        echo "1. Bash"
                        echo "2. Scripting"
                        echo "3. Tutorial"
                        echo -n "Please choose a word [1,2 or 3]? "
                        choice=4
                fi   
        fi
fi
done 

Output from the script:
$ ./nested_if_else.sh 
1. 
Bash
2. 
Scripting
3. 
Tutorial
Please choose a word [1,2 or 3]? 5
Please make a choice between 1-3 !
1. 
Bash
2. 
Scripting
3. 
Tutorial
Please choose a word [1,2 or 3]? 2
You have chosen word: Scripting

<h3 id="35Bashtopic-12">Bash Comparisons</h3>
Bash can compare two or more values, either integers or strings, to determine if they are equal to each other, or one is greater than the other, etc.
<h3 id="35Bashtopic-13">Arithmetic Comparisons</h3>

<table border="1">
<tbody>
<tr>
<td width="50">-lt</td>
<td width="50">&lt;</td>
</tr>
<tr>
<td width="50">-gt</td>
<td width="50">&gt;</td>
</tr>
<tr>
<td width="50">-le</td>
<td width="50">&lt;=</td>
</tr>
<tr>
<td width="50">-ge</td>
<td width="50">&gt;=</td>
</tr>
<tr>
<td width="50">-eq</td>
<td width="50">==</td>
</tr>
<tr>
<td width="50">-ne</td>
<td width="50">!=</td>
</tr>
</tbody>
</table>

Now let's use these operators in some examples.
#!/bin/bash
# declare integers
NUM1=2
NUM2=2
if [ $NUM1 -eq $NUM2 ]; then
	echo "Both values are equal"
else 
	echo "Values are NOT equal"
fi 

The result:
$ ./statement.sh
Both values are equal

Let's try changing one of the numbers.
#!/bin/bash
# declare integers
NUM1=2
NUM2=1
if [ $NUM1 -eq $NUM2 ]; then
	echo "Both Values are equal"
else 
	echo "Values are NOT equal"
fi 

The result:
$ ./statement.sh
Values are NOT equal

Let's add a little more complexity by including an <code>elif</code> statement and determing which number is larger.
#!/bin/bash
# declare integers
NUM1=2
NUM2=1
if   [ $NUM1 -eq $NUM2 ]; then
	echo "Both values are equal"
elif [ $NUM1 -gt $NUM2 ]; then
	echo "NUM1 is greater than NUM2"
else 
	echo "NUM2 is greater than NUM1"
fi

The result:
$ ./statement.sh
NUM1 is greater than NUM2

<h3 id="35Bashtopic-14">String Comparisons</h3>
<table border="1">
<tbody>
<tr>
<td width="50">=</td>
<td width="200">equal</td>
</tr>
<tr>
<td width="50">!=</td>
<td width="50">not equal</td>
</tr>
<tr>
<td width="50">&lt;</td>
<td width="50">less then</td>
</tr>
<tr>
<td width="50">&gt;</td>
<td width="50">greater then</td>
</tr>
<tr>
<td width="50">-n s1</td>
<td width="50">string s1 is not empty</td>
</tr>
<tr>
<td width="50">-z s1</td>
<td width="50">string s1 is empty</td>
</tr>
</tbody>
</table>

Let's try comparing two strings to see if they are equal.
#!/bin/bash
#Declare string S1
S1="Bash"
#Declare string S2
S2="Scripting"
if [ $S1 = $S2 ]; then
	echo "Both Strings are equal"
else 
	echo "Strings are NOT equal"
fi 

The result:
$ ./statement.sh
Strings are NOT equal

And again with both string matching.

#!/bin/bash
#Declare string S1
S1="Bash"
#Declare string S2
S2="Bash"
if [ $S1 = $S2 ]; then
	echo "Both Strings are equal"
else 
	echo "Strings are NOT equal"
fi 

The result:
$ ./statement.sh
Both Strings are equal

<h3 id="35Bashtopic-15">Bash File Testing</h3>
In Bash, we can test to see different characteristics about a file or directory. 
See the table below for a full list.
<table border="0">
<tbody>
<tr>
<td width="140">-b filename</td>
<td width="500">Block special file</td>
</tr>
<tr>
<td width="100">-c filename</td>
<td width="300">Special character file</td>
</tr>
<tr>
<td width="100">-d directoryname</td>
<td width="300">Check for directory existence</td>
</tr>
<tr>
<td width="100">-e filename</td>
<td width="300">Check for file existence</td>
</tr>
<tr>
<td width="100">-f filename</td>
<td width="300">Check for regular file existence not a directory</td>
</tr>
<tr>
<td width="100">-G filename</td>
<td width="300">Check if file exists and is owned by effective group ID.</td>
</tr>
<tr>
<td width="100">-g filename</td>
<td width="300">true if file exists and is set-group-id.</td>
</tr>
<tr>
<td width="100">-k filename</td>
<td width="300">Sticky bit</td>
</tr>
<tr>
<td width="100">-L filename</td>
<td width="300">Symbolic link</td>
</tr>
<tr>
<td width="100">-O filename</td>
<td width="300">True if file exists and is owned by the effective user id.</td>
</tr>
<tr>
<td width="100">-r filename</td>
<td width="300">Check if file is a readable</td>
</tr>
<tr>
<td width="100">-S filename</td>
<td width="300">Check if file is socket</td>
</tr>
<tr>
<td width="100">-s filename</td>
<td width="300">Check if file is nonzero size</td>
</tr>
<tr>
<td width="100">-u filename</td>
<td width="300">Check if file set-ser-id bit is set</td>
</tr>
<tr>
<td width="100">-w filename</td>
<td width="300">Check if file is writable</td>
</tr>
<tr>
<td width="100">-x filename</td>
<td width="300">Check if file is executable</td>
</tr>
</tbody>
</table>
The following script will check to see if a file exists or not.
#!/bin/bash
file="./file"
if [ -e $file ]; then
	echo "File exists"
else 
	echo "File does not exist"
fi 

The result:
$ ./filetesting.sh
File does not exist
$ touch file
$ ./filetesting.sh
File exists

Similarly for example we can use <code>while</code> loop to check if file does not exist. 
This script will sleep until file does exist. 
Note bash negator <code>!</code> which negates the <code>-e</code> option.
#!/bin/bash
while [ ! -e myfile ]; do
# Sleep until file does exists/is created
sleep 1
done

<h3 id="35Bashtopic-16">Loops</h3>
There are multiple types of loops that can be used in Bash, including <code>for</code>, <code>while</code>, and <code>until</code>. 
See some of the examples below to learn how to use.
<h3 id="35Bashtopic-17">Bash for loop</h3>
This script will list every file or directory it finds inside the <code>/var/</code> directory.
#!/bin/bash

# bash for loop
for f in $( ls /var/ ); do
	echo $f
done 

A <code>for</code> loop can also be run directly from the command line, no need for a script:
$ for f in $( ls /var/ ); do echo $f; done 

The result:
$ ./for_loop.sh
backups
cache
crash
lib
local
lock
log
mail
metrics
opt
run
snap
spool
tmp
<h3 id="35Bashtopic-18">Bash while loop</h3>
This <code>while</code> loop will continue to loop until our variable reaches a value of 0 or less.
#!/bin/bash
COUNT=6
# bash while loop
while [ $COUNT -gt 0 ]; do
	echo Value of count is: $COUNT
	let COUNT=COUNT-1
done

The result:
$ ./while_loop.sh
Value of count is: 6
Value of count is: 5
Value of count is: 4
Value of count is: 3
Value of count is: 2
Value of count is: 1

<h3 id="35Bashtopic-19">Bash until loop</h3>
An <code>until</code> loop works similarly to <code>while</code>.
#!/bin/bash
COUNT=0
# bash until loop
until [ $COUNT -gt 5 ]; do
        echo Value of count is: $COUNT
        let COUNT=COUNT+1
done

The result:
$ ./until_loop.sh
Value of count is: 0
Value of count is: 1
Value of count is: 2
Value of count is: 3
Value of count is: 4
Value of count is: 5

<h3 id="35Bashtopic-20">Control bash loop with input</h3>
Here is a example of <code>while</code> loop controlled by standard input. 
Until the redirection chain from STDOUT to STDIN to the <code>read</code> command exists the <code>while</code> loop continues.
#!/bin/bash
# This bash script will locate and replace spaces
# in the filenames
DIR="."
# Controlling a loop with bash read command by redirecting STDOUT as
# a STDIN to while loop
# find will not truncate filenames containing spaces
find $DIR -type f | while read file; do
# using POSIX class [:space:] to find space in the filename
if [[ "$file" = *[[:space:]]* ]]; then
# substitute space with "_" character and consequently rename the file
mv "$file" `echo $file | tr ' ' '_'`
fi;
# end of while loop
done

<h3 id="35Bashtopic-21">Bash Functions</h3>
This example shows how to declare a function and call back to it later in the script.
!/bin/bash
# BASH FUNCTIONS CAN BE DECLARED IN ANY ORDER
function function_B {
        echo Function B.
}
function function_A {
        echo $1
}
function function_D {
        echo Function D.
}
function function_C {
        echo $1
}
# FUNCTION CALLS
# Pass parameter to function A
function_A "Function A."
function_B
# Pass parameter to function C
function_C "Function C."
function_D

The result:

$ ./functions.sh
Function A.
Function B.
Function C.
Function D.

<h3 id="35Bashtopic-22">Bash Select</h3>
The <code>select</code> command allows us to prompt the user to make a selection.
#!/bin/bash
PS3='Choose one word: ' 

# bash select
select word in "linux" "bash" "scripting" "tutorial" 
do
  echo "The word you have selected is: $word"
# Break, otherwise endless loop
  break  
done

exit 0 

The result:
$ ./select.sh
1) linux
2) bash
3) scripting
4) tutorial
Choose one word: 2
The word you have selected is: bash

<h3 id="35Bashtopic-23">Case statement conditional</h3>
The <code>case</code> statement makes it easy to have many different possibilities, whereas an <code>if</code> statement can get lengthy very quickly if you have more than a few possibilities to account for.
#!/bin/bash
echo "What is your preferred programming / scripting language"
echo "1) bash"
echo "2) perl"
echo "3) phyton"
echo "4) c++"
echo "5) I do not know !"
read case;
#simple case bash structure
# note in this case $case is variable and does not have to
# be named case this is just an example
case $case in
    1) echo "You selected bash";;
    2) echo "You selected perl";;
    3) echo "You selected phyton";;
    4) echo "You selected c++";;
    5) exit
esac

The result:
$ ./case.sh 
What is your preferred programming / scripting language
1) bash
2) perl
3) phyton
4) c++
5) I do not know !
3
You selected phyton

<h3 id="35Bashtopic-24">Bash quotes and quotations</h3>
Quotations and quotes are important part of bash and bash scripting. 
Here are some bash quotes and quotations basics.
<h3 id="35Bashtopic-25">Escaping Meta characters</h3>
Before we start with quotes and quotations we should know something about escaping meta characters. 
Escaping will suppress a special meaning of meta characters and therefore meta characters will be read by bash literally. 
To do this we need to use backslash <code>\</code> character. 
Example:
#!/bin/bash
#Declare bash string variable
BASH_VAR="Bash Script"

# echo variable BASH_VAR
echo $BASH_VAR

#when meta character such us "$" is escaped with "\" it will be read literally
echo \$BASH_VAR 

# backslash has also special meaning and it can be suppressed with yet another "\"
echo "\\" 

Here's what it looks like when we execute the script:

$ ./escape_meta.sh
Bash Script
$BASH_VAR
\

<h3 id="35Bashtopic-26">Single quotes</h3>
Single quotes in bash will suppress special meaning of every meta characters. 
Therefore meta characters will be read literally. 
It is not possible to use another single quote within two single quotes not even if the single quote is escaped by backslash.
#!/bin/bash
# Declare bash string variable
BASH_VAR="Bash Script"
# echo variable BASH_VAR
echo $BASH_VAR
# meta characters special meaning in bash is suppressed when  using single quotes 
echo '$BASH_VAR  "$BASH_VAR"'

The result:
$ ./single_quotes.sh
Bash Script
$BASH_VAR "$BASH_VAR"

<h3 id="35Bashtopic-27">Double quotes</h3>
Double quotes in bash will suppress special meaning of every meta characters except <code>$</code>, <code>\</code> and <code>`</code>. 
Any other meta characters will be read literally. 
It is also possible to use single quote within double quotes. 
If we need to use double quotes within double quotes bash can read them literally when escaping them with <code>\</code>. 
Example:
#!/bin/bash
#Declare bash string variable
BASH_VAR="Bash Script"

# echo variable BASH_VAR
echo $BASH_VAR

# meta characters and its special meaning in bash is 
# suppressed when using double quotes except "$", "\" and "`"

echo "It's $BASH_VAR  and \"$BASH_VAR\" using backticks: `date`" 

The result:
$ ./double_quotes.sh
Bash Script
It's Bash Script and "Bash Script" using backticks: Thu 10 Feb 2022 10:24:15 PM EST

<h3 id="35Bashtopic-28">Bash quoting with ANSI-C style</h3>
There is also another type of quoting and that is ANSI-C. 
In this type of quoting characters escaped with <code>\</code> will gain special meaning according to the ANSI-C standard.
<table border="1">
<tbody>
<tr>
<td width="50">\a</td>
<td width="250">alert (bell)</td>
<td width="50">\b</td>
<td width="250">backspace</td>
</tr>
<tr>
<td width="50">\e</td>
<td width="250">an escape character</td>
<td width="50">\f</td>
<td width="250">form feed</td>
</tr>
<tr>
<td width="50">\n</td>
<td width="250">newline</td>
<td width="50">\r</td>
<td width="250">carriage return</td>
</tr>
<tr>
<td width="50">\t</td>
<td width="250">horizontal tab</td>
<td width="50">\v</td>
<td width="250">vertical tab</td>
</tr>
<tr>
<td width="50">\\</td>
<td width="250">backslash</td>
<td width="50">\`</td>
<td width="250">single quote</td>
</tr>
<tr>
<td width="50">\nnn</td>
<td width="250">octal value of characters ( see [http://www.asciitable.com/ ASCII table] )</td>
<td width="50">\xnn</td>
<td width="250">hexadecimal value of characters ( see [http://www.asciitable.com/ ASCII table] )</td>
</tr>
</tbody>
</table>
The syntax for ansi-c bash quoting is: <code>$' '</code> . 
Here is an example:
#!/bin/bash
# as a example we have used \n as a new line, \x40 is hex value for @
# and \56 is octal value for .
echo $'web: www.linuxconfig.org\nemail: web\x40linuxconfig\56org' 

The result:
$ ./bash_ansi-c.sh
web: www.linuxconfig.org
email: web@linuxconfig.org
<h3 id="35Bashtopic-29">Arithmetic Operations</h3>
Bash can be used to perform calculations. 
Let's look at a few examples to see how it's done.
<h3 id="35Bashtopic-30">Bash Addition Calculator Example</h3>
#!/bin/bash
let RESULT1=$1+$2
echo $1+$2=$RESULT1 ' -&gt; # let RESULT1=$1+$2'
declare -i RESULT2
RESULT2=$1+$2
echo $1+$2=$RESULT2 ' -&gt; # declare -i RESULT2; RESULT2=$1+$2'
echo $1+$2=$(($1 + $2)) ' -&gt; # $(($1 + $2))' 

The result:
$ ./bash_addition_calc.sh 88 12
88+12=100  -&gt; # let RESULT1=$1+$2
88+12=100  -&gt; # declare -i RESULT2; RESULT2=$1+$2
88+12=100  -&gt; # $(($1 + $2))

<h3 id="35Bashtopic-31">Bash Arithmetics</h3>
Let's see how to do some basic Bash aritmetics such as addition, subtraction, multiplication, division, etc.
#!/bin/bash
echo '### let ###'
# bash addition
let ADDITION=3+5
echo "3 + 5 =" $ADDITION

# bash subtraction
let SUBTRACTION=7-8
echo "7 - 8 =" $SUBTRACTION 

# bash multiplication
let MULTIPLICATION=5*8
echo "5 * 8 =" $MULTIPLICATION

# bash division
let DIVISION=4/2
echo "4 / 2 =" $DIVISION

# bash modulus
let MODULUS=9%4
echo "9 % 4 =" $MODULUS

# bash power of two
let POWEROFTWO=2**2
echo "2 ^ 2 =" $POWEROFTWO
echo '### Bash Arithmetic Expansion ###'
# There are two formats for arithmetic expansion: $[ expression ] 
# and $(( expression #)) its your choice which you use

echo 4 + 5 = $((4 + 5))
echo 7 - 7 = $[ 7 - 7 ]
echo 4 x 6 = $((3 * 2))
echo 6 / 3 = $((6 / 3))
echo 8 % 7 = $((8 % 7))
echo 2 ^ 8 = $[ 2 ** 8 ]
echo '### Declare ###'

echo -e "Please enter two numbers \c"
# read user input
read num1 num2
declare -i result
result=$num1+$num2
echo "Result is:$result "

# bash convert binary number 10001
result=2#10001
echo $result

# bash convert octal number 16
result=8#16
echo $result

# bash convert hex number 0xE6A
result=16#E6A
echo $result 

The result:
$ ./arithmetic_operations.sh 
### let ###
3 + 5 = 8
7 - 8 = -1
5 * 8 = 40
4 / 2 = 2
9 % 4 = 1
2 ^ 2 = 4
### Bash Arithmetic Expansion ###
4 + 5 = 9
7 - 7 = 0
4 x 6 = 6
6 / 3 = 2
8 % 7 = 1
2 ^ 8 = 256
### Declare ###
Please enter two numbers 23 45
Result is:68 
17
14
3690

<h3 id="35Bashtopic-32">Round floating point number</h3>
Here is how to use rounding in Bash calculations.

#!/bin/bash
# get floating point number
floating_point_number=3.3446
echo $floating_point_number
# round floating point number with bash
for bash_rounded_number in $(printf %.0f $floating_point_number); do
echo "Rounded number with bash:" $bash_rounded_number
done 

The result:
$ ./round.sh
3.3446
Rounded number with bash: 3

<h3 id="35Bashtopic-33">Bash floating point calculations</h3>
Using the <code>bc</code> bash calculator to perform floating point calculations.
#!/bin/bash
# Simple linux bash calculator 
echo "Enter input:" 
read userinput
echo "Result with 2 digits after decimal point:"
echo "scale=2; ${userinput}" | bc 
echo "Result with 10 digits after decimal point:"
echo "scale=10; ${userinput}" | bc 
echo "Result as rounded integer:"
echo $userinput | bc 

The result:
$ ./simple_bash_calc.sh
Enter input:
10/3.4
Result with 2 digits after decimal point:
2.94
Result with 10 digits after decimal point:
2.9411764705
Result as rounded integer:
2

<h3 id="35Bashtopic-34">Redirections</h3>
In the following examples, we will show how to redirect standard error and standard output.
<h3 id="35Bashtopic-35">STDOUT from bash script to STDERR</h3>
#!/bin/bash
echo "Redirect this STDOUT to STDERR" 1&gt;&amp;2 

To prove that STDOUT is redirected to STDERR we can redirect script’s output to file:
$ ./redirecting.sh
Redirect this STDOUT to STDERR
$ ./redirecting.sh &gt; STDOUT.txt
$ cat STDOUT.txt
$ 
$ ./redirecting.sh 2&gt; STDERR.txt
$ cat STDERR.txt
Redirect this STDOUT to STDERR

<h3 id="35Bashtopic-36">STDERR from bash script to STDOUT</h3>
#!/bin/bash
cat $1 2&gt;&amp;1

To prove that STDERR is redirected to STDOUT we can redirect script’s output to file:
$ ./redirecting.sh /etc/shadow
cat: /etc/shadow: Permission denied
$ ./redirecting.sh /etc/shadow &gt; STDOUT.txt
$ cat STDOUT.txt
cat: /etc/shadow: Permission denied
$ ./redirecting.sh /etc/shadow 2&gt; STDERR.txt
cat: /etc/shadow: Permission denied
$ cat STDERR.txt
$ 

<h3 id="35Bashtopic-37">stdout to screen</h3>
The simple way to redirect a standard output (stdout) is to simply use any command, because by default stdout is automatically redirected to screen. 
First create a file <code>file1</code>:
$ touch file1
$ ls file1 
file1

As you can see from the example above execution of <code>ls</code> command produces STDOUT which by default is redirected to screen.
<h3 id="35Bashtopic-38">stdout to file</h3>
To override the default behavior of STDOUT we can use <code>&gt;</code> to redirect this output to file:

$ ls file1 &gt; STDOUT
$ cat STDOUT 
file1

<h3 id="35Bashtopic-39">stderr to file</h3>
By default STDERR is displayed on the screen:
$ ls
file1  STDOUT
$ ls file2
ls: cannot access file2: No such file or directory

In the following example we will redirect the standard error (stderr) to a file and stdout to a screen as default. 
Please note that STDOUT is displayed on the screen, however STDERR is redirected to a file called STDERR:
$ ls
file1  STDOUT
$ ls file1 file2 2&gt; STDERR
file1
$ cat STDERR 
ls: cannot access file2: No such file or directory

<h3 id="35Bashtopic-40">stdout to stderr</h3>
It is also possible to redirect STDOUT and STDERR to the same file. 
In the next example we will redirect STDOUT to the same descriptor as STDERR. 
Both STDOUT and STDERR will be redirected to file “STDERR_STDOUT”.
$ ls
file1  STDERR  STDOUT
$ ls file1 file2 2&gt; STDERR_STDOUT 1&gt;&amp;2
$ cat STDERR_STDOUT
ls: cannot access file2: No such file or directory
file1

File STDERR_STDOUT now contains STDOUT and STDERR.
<h3 id="35Bashtopic-41">stderr to stdout</h3>
The above example can be reversed by redirecting STDERR to the same descriptor as SDTOUT:
$ ls
file1  STDERR  STDOUT
$ ls file1 file2 &gt; STDERR_STDOUT 2&gt;&amp;1
$ cat STDERR_STDOUT 
ls: cannot access file2: No such file or directory
file1

<h3 id="35Bashtopic-42">stderr and stdout to file</h3>
Previous two examples redirected both STDOUT and STDERR to a file. 
Another way to achieve the same effect is illustrated below:
$ ls
file1  STDERR  STDOUT
$ ls file1 file2 &amp;&gt; STDERR_STDOUT
$ cat STDERR_STDOUT 
ls: cannot access file2: No such file or directory
file1

or
ls file1 file2 &gt;&amp; STDERR_STDOUT
$ cat STDERR_STDOUT 
ls: cannot access file2: No such file or directory
file1

<h3 id="35Bashtopic-43">Closing Thoughts</h3>

In this Bash scripting tutorial, we learned how to get started with Bash scripting by learning all the basics of the most common aspects, such as loops, arithmetic, comparisons, etc. 
This guide has served as an introduction to Bash scripting concepts, and given you some insight into how the Bash shell works. 
By adapting our examples for your own needs and expanding them as needed, you will be well on your way to mastering Bash scripting.

<h2>25 basic Ubuntu Commands</h2>
There are several releases of Ubuntu, such as stable release, Long Term Support (LTS), and unstable. 
The stable and unstable releases are launched every year in April and October, respectively, whereas the long-term support variant is released after two years and is available for the next five years. 

Ubuntu supports both Command Line Interface (CLI) and Graphical User Interface (GUI) to perform various tasks on the OS. 
CLI is the basic way to interact with systems hardware (processor/memory); you can perform all the tasks that GUI can perform. 
In this article, we will demonstrate the use of 25 basic commands that provide ease to execute various tasks of Ubuntu using CLI. 

<h2>Command: pwd</h2>
This command refers to the present working directory in which you are operating; in simpler words, in which your terminal is open. 
To check PWD, execute the pwd keyword in your terminal and hit enter; the command of PWD is written below along with the result of that command.

$ pwd
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-1.png" />
<h2>Command: dir</h2>
The dir command is used to print (on the terminal) all the available directories in the present working directory:
$ dir
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-2.png" />

<h2>Command: ls</h2>
This command is used to list down all the directories and files inside the present working directory (or you can give the path of a specific directory); the ls command can be executed as shown below:
$ ls

<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-3.png" />
The ls command supports various flags, and each flag has some specific role in printing the directories or files of the current working directory. 
To print the detailed information of the files/directories; the “<b>-al</b>” flag is used with the “<b>ls</b>” command:

$ ls -al
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-4.png" />
The “<b>-R</b>” flag will print subdirectories of a directory as well:

$ ls -R
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-5.png" />
Moreover, to get the hidden files, “<b>-a</b>” flag is used:

$ ls -a
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-6.png" />
<h2>Command: cd</h2>
One of the most used commands of Ubuntu; you can change the directories in the terminal using the “cd” command. 
For instance, the following command will change the pwd to desktop.
$ cd Desktop

<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-7.png" />
There are multiple uses of this command: one can change the present directory to root directory or home directory using this command. 
When you open a fresh terminal, you are in the home directory.

To change directory to root. 
For instance, we are in the Desktop directory and want to switch to the root directory:
$ cd /

<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-8.png" />
To change the present directory to the home directory:
$ cd

<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-9.png" />
<h2>Command: touch</h2>
This Ubuntu command can be used to create a new file as well one can use it to change the timestamp of any file; the command given below will create a new text time in pwd:

$ touch file1.txt
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-10.png" />
If we execute a touch command to create a file, but the file is already created, then it would change the timestamp of that file to the current time; for instance, the command given below will change the timestamp of the file1.txt. 

you can check that the timestamp has been changed to the current time:
$ touch file1.txt
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-11.png" />

<h2>Command: cat</h2>
This command is used to show the content of any file: For instance, the following command will display the content inside “f<b>ile1.txt</b>”:
$ cat file1.txt

<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-12.png" />
Or you can use this command to save the content of multiples files to one file:
$ cat file1.txt file2.txt &gt; output.txt

<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-13.png" />
<h2>Command: mkdir</h2>
The above-mentioned command will make a directory in your pwd; for example, the following command will make the directory “<b>new</b>” in pwd.

$ mkdir new
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-14.png" />
<h2>Command: rm</h2>
This remove command is used to remove the specific file from a directory; For instance, below mentioned command would remove the “<b>test.txt</b>” file from the pwd:
$ rm test.txt
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-15.png" />

Or you can remove the empty directory, as the command given below will remove the “<b>test</b>” directory:
$ rmdir test
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-16.png" />

<h2>Command: cp</h2>
The cp command will help you to copy any file or folder to any directory;
To copy a file to directory1:

$ cp file1.txt directory1
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-17.png" />
If you want to copy the complete folder, then;

$ cp new -r directory1
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-18.png" />
<h2>Command: mv </h2>
You can use this command to move files around the computer, and you can also rename files or directories inside a specific directory: the command given below will move the “<b>file2.txt</b>” to “<b>directory1</b>”:
$ mv file2.txt directory1
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-19.png" />

Moreover, the command given below will move the “<b>test1</b>” directory to “<b>directory1</b>”:
$ mv test1 directory1
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-20.png" />

<h2>Command: head</h2>
This command helps you to get the first ten lines of a text file; for instance, the following command will help to get the first ten lines of the “<b>file1.text</b>” file:
$ head file1.txt

<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-21.png" />
<h2>Command: tail</h2>
The tail command is used to get the last ten lines of the text file; the command below will print the ten lines from the bottom of “<b>file1.txt</b>”:

$ tail file1.txt
<h2>Command: uname</h2>
You can use the command to get the release number, version of Linux, and much more. 

The “<b>-a</b>” flag is used to get detailed information.
$ uname -a
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-23.png" />

<h2>Command: wget</h2>
You can use the wget command to download the content from the internet; for instance, the following command will download VirtualBox.
$ wget https://download.virtualbox.org/virtualbox/6.1.26/VirtualBox-6.1.26-145957-Win.exe

<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-24.png" />
<h2>Command: apt-get or -apt</h2>
This is one of the most important and most used commands of Ubuntu that works with Ubuntu Advanced Packaging Tool (APT); you can use this “<b>-apt-get</b>” or “<b>-apt</b>” to install or remove packages, or you can perform other maintenance tasks. 

The “<b>apt</b>” requires sudo privileges to successfully execute the command.
The syntax stated below will help you to install the required package:
$ sudo apt install &#91;packagename&#93;

For install to install vlc media player package use:
$ sudo apt install vlc
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-25.png" />

Or you can remove the package by executing the command given below:
$ sudo apt remove &#91;packagename&#93;
And to delete vlc media player package:

<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-26.png" />
<h2>Command: history</h2>
The history command shows the list of commands (with numeric numbers) executed:

$ history
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-27.png" />
And you can execute any of the listed commands. 

For instance, if you want to execute the 2nd command (which is apt update command), then you have to write “<b>!2</b>” to get the result of that command:
$ !2
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-28.png" />

<h2>Command: grep</h2>
With the help of grep, you can search for a pattern in which a specific word lies; for instance, the command given below will print all the lines that contain “<b>20</b>” from “<b>file1.txt</b>”:
$ cat file1.txt | grep 20

<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-29.png" />
<h2>Command: man </h2>
The man command will help you to get the complete user manual of any specific command; for instance, the following command will list down the detailed usage of the “<b>cat</b>” command:

$ man cat
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-30.png" />
<h2>Command: ps</h2>
Using the <b>-ps</b> command, you will be able to get the list of processes.
$ ps
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-31.png" />

<h2>Command: zip or unzip</h2>
To convert your files to zip archive; you can get help by using the “<b>gzip</b>” command; moreover, a zipped file can be unzipped using the “<b>gunzip</b>” command:
$ gzip file1.txt

<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-32.png" />
You can unzip the “<b>file1.txt</b>” as shown below:
$ gunzip file1.txt

<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-33.png" />
<h2>Command: hostname </h2>
This command will print your hostname on the terminal:

$ hostname
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-34.png" />
<h2>Command: ping</h2>
You can use the ping command to check the connectivity to your server; for example, the command below will ping to YouTube and also prints the response time:
$ ping youtube.com
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-35.png" />

<h2>Command: w</h2>
This command will display the user details that are currently logged into the system:
$ w

<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-36.png" />
<h2>Command: useradd</h2>
Ubuntu supports multiuser access; if you want to add another user to your system, execute the following command to do so:

$ sudo useradd MIKE
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-37.png" />
Or you can delete the user also;

$ sudo userdel MIKE
<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-38.png" />
<h2>Command: passwd</h2>
With the help of the passwd command, you can change the password of your Ubuntu user:
You must pass “<b>username</b>” to “<b>passwd</b>” to change the password of that; for example, the command given below will change the password of user “<b>adnan</b>”.
$ passwd adnan

<img class="lazy" data-src="https://linuxhint.com/wp-content/uploads/2021/08/25-basic-Ubuntu-Commands-39.png" />



<h2>Basic Ubuntu Commands for Beginner:</h2>
<h3>1. sudo</h3>
<b>sudo</b> (SuperUser DO) Linux command allows you to run programs or other commands with administrative privileges, just like “Run as administrator” in Windows.
This is useful when, for example, you need to modify files in a directory that your user wouldn’t normally have access to.

<h3>2. apt-get</h3>
<b>apt-get</b> is the one of the most important Ubuntu commands every beginner must know.
It is used to install, update, upgrade and remove any package.
apt-get basically works on a database of available packages.
Here is the list of different apt-get commands:

<h4> 1.
sudo apt-get update </h4>
apt-get update with&nbsp;super user privileges is the first command you need to run in any Linux system after a fresh install.
This command updates the database and let your system know if there are newer packages available or not.
<img class="lazy" data-src="https://tl360.b-cdn.net/wp-content/uploads/2019/07/sudo-apt-get-update-Basic-Ubuntu-Commands.png">

<h4>2. sudo apt-get upgrade </h4>
After updating the package database, next step is to to upgrade the installed packages.
For upgrading all the packages with available updates you can use this command.

And if you like to upgrade a particular package, you should tweak the above command a little:
sudo apt-get upgrade &lt;package-name&gt;

Replace the <em>&lt;package-name&gt;</em> with your desired package.

<img class="lazy" data-src="https://tl360.b-cdn.net/wp-content/uploads/2019/07/sudo-apt-get-upgrade-Basic-Ubuntu-Commands.png">

<h4>3. sudo apt-get install </h4>
If you know the name of the package, then you can easily install a program using this command:
sudo apt-get install &lt;package-name&gt;

Replace the <em>&lt;package-name&gt;</em> with your desired package.
<img class="lazy" data-src="https://tl360.b-cdn.net/wp-content/uploads/2019/07/sudo-apt-get-install-Basic-Ubuntu-Commands.png">

If you are not sure about the package name, you can type a few letters and press tab and it will suggest all the packages available with those letters.
Thanks for auto-completion feature.

<h4>4. sudo apt-get remove</h4>
When it comes to removing the installed program apt-get remove command suits your need.
You only have to know the exact package name of the software you want to uninstall.

If you don&#8217;t know the package name, use below ubuntu basic command to list all the packages installed on your system and then copy the package name from the list:
dpkg --list

Now run the <em>apt-get remove</em> command as sudo in order to remove the software:

sudo apt-get remove &lt;package-name&gt;

Replace the <em>&lt;package-name&gt;</em> with the one you copied from the dpkg list.
<img class="lazy" data-src="https://tl360.b-cdn.net/wp-content/uploads/2019/07/sudo-apt-get-remove-Basic-Ubuntu-Commands.png">

apt-get remove command only removes the software from your system but not the configuration or data files of the package.
These files help in keeping the same settings when you want to reinstall the same software.

<h4>5. sudo apt-get purge</h4>
apt-get purge command is used when you want to remove a software completely from your system with its configuration or data files so that no longer personalized settings will be available during reinstallation.

Run the <em>apt-get purge</em> command as sudo in order to remove the software completely:
sudo apt-get purge &lt;package-name&gt;

Replace the <em>&lt;package-name&gt;</em> with the application that you want to remove or copied from the dpkg list.
<img class="lazy" data-src="https://tl360.b-cdn.net/wp-content/uploads/2019/07/sudo-apt-get-purge-Basic-Ubuntu-Commands.png">

<h4>6. sudo apt-get autoremove</h4>
apt-get autoremove command is used to remove any unnecessary packages.
Unnecessary means, whenever you install an application, the system will also install the software that this application depends on.
It is common in Ubuntu that applications share the same libraries.
When you remove the application the dependency will stay on your system.

So run <em>apt-get autoremove</em> as sudo after uninstalling a package to remove unwanted software dependencies.
<img class="lazy" data-src="https://tl360.b-cdn.net/wp-content/uploads/2019/07/sudo-apt-get-autoremove-Basic-Ubuntu-Commands.png">

So apt-get autoremove will remove those dependencies that were installed with applications and that are no longer used by anything else on the system.

<h3>3. ls</h3>
<b>ls</b> (list) command lists all files and folders in your current working directory.
You can also specify paths to other directories if you want to view their contents.

<h3>4. cd</h3>
<b>cd</b> (change director”) Linux command also known as chdir used to change the current working directory.
It&#8217;s one of the most used basic Ubuntu commands.
Using this command is easy, just type cd followed by the the folder name.
You can use full paths to folders or simply the name of a folder within the directory you are currently working.
Some common uses are:
<ul><li>cd /&nbsp; – Takes you to the root directory.</li><li>cd ..
– Takes you up one directory level.</li><li>cd –&nbsp; – Takes you to the previous directory.</li></ul>
Here are some examples to how to use cd command in Ubuntu:

Example 1: <em><b>cd home</b></em> – open home folder in current directory.

Example 2: <b><em>cd Linux\ Drive</em></b> – open Linux Drive named folder in directory.
Here you can see I use backslash because the folder name has spaces so <em>for each space you use &#8220;backslash+space&#8221;</em>.
Like, if your folder name is &#8220;am a programmer&#8221; then the cd command will be, &#8220;cd am\ a\ programmer&#8221;.
<img class="lazy" data-src="https://tl360.b-cdn.net/wp-content/uploads/2019/07/cd-Basic-Ubuntu-Commands.jpg">

<h3>5. pwd</h3>
<b>pwd</b> (print working directory) Ubuntu command displays the full pathname of the current working directory.

<h3>6. cp</h3>
<b>cp</b> (copy) Linux command allows you to copy a file.
You should specify both the file you want to be copied and the location you want it copied to – f<em>or example, cp </em>xyz<em> /home/</em>myfiles<em> would copy the file “</em>xyz<em>” to the directory “/home/</em>myfiles<em>”</em>.

<h3>7. mv</h3>
<b>mv</b> (move) command allows you to move files.
You can also rename files by moving them to the directory they are currently in, but under a new name.
The usage is the same as cp – f<em>or example mv </em>xyz<em> /home/</em>myfiles<em> would move the file “</em>xyz<em>” to the directory “/home/</em>myfiles<em>”</em>.

<h3>8. rm</h3>
<b>rm</b> (remove) command removes the specified file.

<ul><li>rmdir (“remove directory”) – Removes an empty directory.</li><li>rm -r (“remove recursively”) – Removes a directory along with its content.</li></ul>
<h3>9. mkdir</h3>
<b>mkdir</b> (make directory) command allows you to create a new directory.
You can specify where you want the directory created – if you do not do so, it will be created in your current working directory.

<h3>10. history</h3>
<b>history</b> command displays all of your previous commands up to the history limit.
<img class="lazy" data-src="https://tl360.b-cdn.net/wp-content/uploads/2019/07/history-Basic-Ubuntu-Commands.jpg">

<h3>11. df</h3>
<b>df</b> (display filesystem) command displays information about the disk space usage of all mounted filesystems.
<img class="lazy" data-src="https://tl360.b-cdn.net/wp-content/uploads/2019/07/df-Basic-Ubuntu-Commands.jpg">

<h3>12. du</h3>
<b>du</b> (directory usage) command displays the size of a directory and all of its subdirectories.

<h3>13. free</h3>
<b>free</b> – Displays the amount of free space available on the system.

<h3>14. uname -a</h3>
<b>uname -a</b> – Provides a wide range of basic information about the system.

<h3>15. top</h3>
<b>top</b> – Displays the processes using the most system resources at any given time.
“q” can be used to exit.

<h3>16. man</h3>
<b>man</b> command displays a “manual page”.
Manual pages are usually very detailed, and it’s recommended that you read the man pages for any command you are unfamiliar with.
Some uses are :
<ul><li>man man – Provides information about the manual itself.</li><li>man intro – Displays a brief introduction to Linux commands.</li></ul>
<h3>17. info</h3>
Similar to man, but often provides more detailed or precise information.

<h3>18. &lt;command name&gt; -h or &lt;command name&gt; –help</h3>
This command is a third alternative to get help.
While not as detailed as the info or man pages, this will provide a quick overview of the command and its uses.

For example: <em>man -h</em> or <em>man -help</em>

<h3>19. passwd</h3>
passwd Ubuntu basic command is used to change user password using Terminal.
What you have to do is run the below command, where is the username whose password has to change:
passwd &lt;user&gt;

<h3>20. whatis</h3>
whatis command shows a brief description of what is the functionality of specific built-in Linux command.

whatis &lt;command&gt;

Some examples are:
<ul><li>whatis cd</li><li>whatis man</li><li>whatis help</li></ul>
Above commands will display the purpose of cd, man and help commands.

<h2>Ubuntu Terminal Shortcuts:</h2>
To further ease up your skill, these Ubuntu Terminal keyboard shortcuts would help.
<table><tbody><tr><th>Ubuntu Terminal Shortcuts</th><th>Function</th></tr><tr><td>Ctrl + Shift + T</td><td>Open new tab on current terminal</td></tr><tr><td>Ctrl + Shift + W</td><td>Close the current tab</td></tr><tr><td>Ctrl + A</td><td>Move cursor to beginning of line</td></tr><tr><td>Ctrl + E</td><td>Move cursor to end of line</td></tr><tr><td>Ctrl + U</td><td>Clears the entire current line</td></tr><tr><td>Ctrl + K</td><td>Clears the command from the cursor right</td></tr><tr><td>Ctrl + W</td><td>Delete the word before the cursor</td></tr><tr><td>Ctrl + R</td><td>Allows you to search your history for commands matching what you have typed</td></tr><tr><td>Ctrl + C</td><td>Kill the current process</td></tr><tr><td>Ctrl + Z</td><td>Suspend the current process by sending the signal SIGSTOP</td></tr><tr><td>Ctrl + L</td><td>Clears the terminal output</td></tr><tr><td>Alt + F</td><td>Move forward one word</td></tr><tr><td>Alt + B</td><td>Move backward one word</td></tr><tr><td>Ctrl + Shift + C</td><td>Copy the highlighted command to the clipboard</td></tr><tr><td>Ctrl + Shift + V or Shift + Insert</td><td>Paste the contents of the clipboard</td></tr><tr><td>Up/Down Arrow keys</td><td>To scroll through your command history, allowing you to quickly execute the same command multiple times</td></tr><tr><td>TAB</td><td>Used to complete the command you are typing.
If more than one command is possible, you can press it multiple times to scroll through the possible completions.
If a very wide number of commands are possible, it can output a list of all possible completions.</td></tr></tbody></table>

<h1>Troubleshooting in Windows Terminal</h1>
<h2>Opening the settings does nothing (or opens an unexpected application)</h2>
If you click on the "settings" button in the dropdown, the Terminal will attempt to open the settings file, <code>settings.json</code>. 
This will cause the OS to try and launch your configured <code>.json</code> file editor. 
This might be Visual Studio, or Notepad, or some other completely unexpected application. 
If there isn't a configured <code>.json</code> editor on your machine, then the OS will eventually show you the "How do you want to open this file" dialog.

Tip
You can also use the settings UI to configure your settings if you are using Windows Terminal Preview. 
You can learn how to open the settings UI on the Actions page.

<h2>Set your WSL distribution to start in the home <code>~</code> directory when launched in older versions of Windows Terminal</h2>
By default, the <code>startingDirectory</code> of a profile is <code>%USERPROFILE%</code> (<code>C:\Users\&lt;YourUsername&gt;</code>). 
This is a Windows path. 
For WSL distributions running a new version of Windows Terminal, the file systems can enter <code>~</code> to set this home path. 
In older versions of Windows Terminal, you can use <code>/home/&lt;Your Ubuntu Username&gt;</code> to directly refer to your home folder. 
For example, the following setting will launch the "Ubuntu-20.04" distribution in its home file path:
<code>{
    "name": "Ubuntu-20.04",
    "commandline" : "wsl -d Ubuntu-20.04",
    "startingDirectory" : "/home/&lt;Your Ubuntu Username&gt;"
}</code>

If you are using a very early version of Windows Terminal, WSL may require using the <code>\\wsl$\</code> prefix when referring to a distribution's home path for the <code>startingDirectory</code> setting. 
For example, the following setting will launch the "Ubuntu-18.04" distribution in its home file path:
<code>{
    "name": "Ubuntu-18.04",
    "commandline" : "wsl -d Ubuntu-18.04",
    "startingDirectory" : "//wsl$/Ubuntu-18.04/home/&lt;Your Ubuntu Username&gt;"
}</code>

Important
On newer versions of Windows, <code>startingDirectory</code> can accept Linux-style paths.

<h2>Setting the tab title</h2>
To have the shell automatically set your tab title, visit the set the tab title tutorial. 
If you want to set your own tab title, open the settings.json file and follow these steps:

In the profile for the command line of your choice, add <code>"suppressApplicationTitle": true</code> to suppress any title change events that get sent from the shell. 
Adding <em>only</em> this setting to your profile will set the tab title to the name of your profile.

If you want a custom tab title that is not the name of your profile, add <code>"tabTitle": "TITLE"</code>. 
Replacing "TITLE" with your preferred tab title.

<h2>Command line arguments in PowerShell</h2>
Visit the Command line arguments page to learn how command-line arguments operate in PowerShell.
<h2>Command line arguments in WSL</h2>
Visit the Command line arguments page to learn how command-line arguments operate in WSL.
<h2>Problem setting <code>startingDirectory</code></h2>
If the <code>startingDirectory</code> is being ignored in your profile, first check to make sure the syntax is correct in your settings.json file. 
To help you check this syntax, <code>"$schema": "https://aka.ms/terminal-profiles-schema"</code> is automatically injected. 
Some applications, like Visual Studio Code, can use that injected schema to validate your json file as you make edits.
If your settings are correct, you may be running a startup script that sets the starting directory of your terminal separately. 
For example, PowerShell has its own separate concept of profiles. 
If you are changing your starting directory there, it will take precedence over the setting defined in Windows Terminal.
Alternatively, if you are running a script using the <code>commandline</code> profile setting, it may be that you are setting the location there. 
Similar to PowerShell profiles, your commands there take precedence over the <code>startingDirectory</code> profile setting.
The purpose of <code>startingDirectory</code> is to launch a new Windows Terminal instance in the given directory. 
If the terminal runs any code that changes its directory, that may be a good place to take a look.
<h2>Ctrl+= does not increase the font size</h2>
If you are using a German keyboard layout, you may run into this problem. 
<kbd>ctrl+=</kbd> gets deserialized as <kbd>ctrl+shift+0</kbd> if your main keyboard layout is set to German. 
This is the correct mapping for German keyboards.
More importantly, the app never receives the <kbd>ctrl+shift+0</kbd> keystroke. 
This is because <kbd>ctrl+shift+0</kbd> is reserved by Windows if you have multiple keyboard layouts active.
If you would like to disable this feature in order for <code>Ctrl+=</code> to work properly, follow the instructions for "Change Hotkeys to Switch Keyboard Layout in Windows 10" in this blog post.
Change the 'Switch Keyboard Layout' option to 'Not Assigned' (or off of <kbd>ctrl+shift</kbd>), then select <strong>OK</strong> and then <strong>Apply</strong>. 
<kbd>ctrl+shift+0</kbd> should now work as a key binding and is passed through to the terminal.
On the other hand, if you do use this hotkey feature for multiple input languages, you can configure your own custom key binding in your settings.json file.
<h2>The text is blurry</h2>
Some display drivers and hardware combinations do not handle scroll and/or dirty regions without blurring the data from the previous frame. 
To mitigate this problem, you can add a combination of these global rendering settings to reduce the strain placed on your hardware caused by the terminal text renderer.
<h2>My colors look strange! There are black bars on my screen!</h2>

Important
This applies only to version 1.2+ of Windows Terminal. 
If you are seeing color issues in Windows Terminal 1.0 or 1.1, or issues that are not captured here, please file a bug.

Windows Terminal 1.2 and beyond has an improved understanding of certain application color settings. 
Because of this improved understanding, we have been able to remove a number of compatibility blocks that resulted in a poor user experience. 
Unfortunately, there is a small number of applications that may experience issues.
We will keep this troubleshooting item up-to-date with the list of known issues and their workarounds.
<h3>Black lines in PowerShell (5.1, 6.x, 7.0)</h3>
Terminal, when coupled with PowerShell's line editing library PSReadline, may draw black lines across the screen. 
These miscolored regions will extend across the screen beyond your prompt wherever there are command parameters, strings or operators.
PSReadline version <strong>2.0.3</strong> has been released and contains a fix for this issue. 
If you are using the prerelease version of PSReadline, note that a fix is not yet available.
To update to the newest version of PSReadline, please run the following command:
<code>Update-Module PSReadline</code>

<h2>Why are my emojis not appearing as icons in the jumplist?</h2>
Only images linked from a file location can be rendered as profile icons in the jumplist. 
Emojis are not supported for jumplist icons.
<h2>Technical Notes</h2>
Applications that use the <code>GetConsoleScreenBufferInfo</code> family of APIs to retrieve the active console colors in Win32 format and then attempt to transform them into cross-platform VT sequences (for example, by transforming <code>BACKGROUND_RED</code> to <code>\x1b[41m</code>) may interfere with Terminal's ability to detect what background color the application is attempting to use.
Application developers are encouraged to choose either Windows API functions <em>or</em> VT sequences for adjusting colors and not attempt to mix them.
<h3>Keyboard service warning</h3>
Starting in Windows Terminal 1.5, the Terminal will display a warning if the "Touch Keyboard and Handwriting Panel Service" is disabled. 
This service is needed by the operating system to properly route input events to the Terminal application (as well as many other applications on Windows). 
If you see this warning, you can follow these steps to re-enable the service:

In the run dialog, run <code>services.msc</code>
<img src="https://user-images.githubusercontent.com/18356694/97891741-c81eed00-1cf4-11eb-9d48-7b94fede5294.png">

Find the "Touch Keyboard and Handwriting Panel Service"
<img src="https://user-images.githubusercontent.com/18356694/97891813-e1279e00-1cf4-11eb-91c8-69a5c6da6c3d.png">

Open the "Properties" for this service
<img src="https://user-images.githubusercontent.com/18356694/97891923-03212080-1cf5-11eb-90cc-821a4fbf16ba.png">

Change the "startup type" to "Automatic"
<img src="https://user-images.githubusercontent.com/18356694/97892043-25b33980-1cf5-11eb-8833-a2e65a306a79.png">

Hit "Ok", and restart the PC.

After restarting the machine, the service should auto-start, and the dialog should no longer appear.
<h2>Why do I see blinking or flashing when using a git bash command line?</h2>
You may notice a blinking or flashing when using a git bash command line inside Windows Terminal. 
This behavior is actually by design. 
The Terminal is obeying what git bash is telling it to do (setting bell-style to visible, causing a flash to associate with the bell response), BUT we understand this may be distracting. 
To fix this, open the <code>.inputrc</code> file for your Git bash with a text editor. 
This file will likely be located in the path <code>C:\Program Files\Git\etc</code>. 
To open with the Nano text editor: <code>nano ~/.inputrc</code>
Change the default:
<code># none, visible or audible
set bell-style visible</code>

Set the bell-style to either <code>none</code> or <code>audible</code> to remove the visible flash:
<code>set bell-style none</code>

Press Ctrl + O and Ctrl + X to Save and Exit.
<h2>How do I reset my settings in Windows Terminal back to the default settings?</h2>
To reset your settings back to the original default settings, delete your settings.json file. 
This will cause Windows Terminal to regenerate a settings.json file with the original default settings.

Important
As of Windows Terminal version 1.10 or greater, you'll also need to delete the <code>state.json</code> file in the same directory as the <code>settings.json</code> file to fully reset the settings to the defaults.

<h2>Why is Acrylic opacity not making my Windows Terminal background transparent?</h2>
You can set the transparency of a terminal window with the <code>useAcrylic</code> property. 
There are a few reasons why your opacity setting may not be working for Acrylic, including:
<ul>
As a system-wide policy, acrylic is only enabled for the foreground window. 
So if you activate any other window than the Terminal, the Terminal's acrylic will turn off.
Acrylic doesn't work if your GPU hardware does not support it. 
If you're running an app in a Virtual Machine (VM) or over remote desktop, acrylic likely will not work.
Acrylic can be disabled by the operating system for a number of reasons, like being in power saver (low-battery) mode or when accessing a machine using Remote Desktop.

<h2>Why does my mouse pointer disappear when hovering over a window and typing?</h2>
This cursor auto-hiding behavior is by design, but can be disabled in the by searching in Windows Settings for "Mouse settings" &gt; "Additional Mouse Settings" &gt; "Mouse Properties" &gt; "Pointer Options" &gt; Uncheck "Hide pointer while typing". 
You may need to restart your Windows Terminal in order for this change to take effect.

<h2>To run Linux</h2>
From Windows Command Prompt or PowerShell, you can enter the name of your installed distribution.
For example: ubuntu

<h2>Basic vi Commands</h2>
<div id="VItoc"><a href="#VItopic-0" target="_self">What is <tt>vi</tt>?</a><br><a href="#VItopic-1" target="_self">To Get Into and Out Of <tt>vi</tt></a><br><a href="#VItopic-2" target="_self"> To Start <tt>vi</tt></a><br><a href="#VItopic-3" target="_self"> To Exit <tt>vi</tt></a><br><a href="#VItopic-4" target="_self">Moving the Cursor</a><br><a href="#VItopic-5" target="_self">Screen Manipulation</a><br><a href="#VItopic-6" target="_self">Adding, Changing, and Deleting Text</a><br><a href="#VItopic-7" target="_self"> Inserting or Adding Text</a><br><a href="#VItopic-8" target="_self"> Changing Text</a><br><a href="#VItopic-9" target="_self"> Deleting Text</a><br><a href="#VItopic-10" target="_self"> Cutting and Pasting Text</a><br><a href="#VItopic-11" target="_self">Other Commands</a><br><a href="#VItopic-12" target="_self"> Searching Text</a><br><a href="#VItopic-13" target="_self"> Determining Line Numbers</a><br><a href="#VItopic-14" target="_self">Saving and Reading Files</a><br></div><br><br>
<h3 id="VItopic-0">What is <tt>vi</tt>?</h3>
The default editor that comes with the UNIX operating system is called <tt>vi</tt> (<b>vi</b>sual editor).
[Alternate editors for UNIX environments include <tt>pico</tt> and <tt>emacs</tt>, a product of GNU.]

The UNIX <tt>vi</tt> editor is a full screen editor and has two modes of 
operation: 
<i>Command mode</i> commands which cause action to be taken on the file, and 
<i>Insert mode</i> in which entered text is inserted into the file.

In the command mode, every character typed is a command that does something to the text file being edited;
a character typed in the command mode may even cause the <tt>vi</tt> editor to enter the insert mode.
In the insert mode, every character typed is added to the text in the file;
pressing the <tt>&lt;Esc&gt;</tt> (<i>Escape</i>) key turns off the Insert mode.

While there are a number of <tt>vi</tt> commands, just a handful of these is usually sufficient for beginning <tt>vi</tt> users.
To assist such users, this Web page contains a sampling of basic <tt>vi</tt> commands. 
The most basic and useful commands are marked with an asterisk
(<tt>*</tt> or star) in the tables below.
With practice, these commands should become automatic.

<b>NOTE:</b>  Both UNIX and <tt>vi</tt> are <b>case-sensitive</b>.
Be sure not to use a capital letter in place of a lowercase letter;
the results will not be what you expect.
<h3 id="VItopic-1">To Get Into and Out Of <tt>vi</tt></h3>
<h4 id="VItopic-2"> To Start <tt>vi</tt></h4>
To use <tt>vi</tt> on a file, type in <tt>vi filename</tt>.  
If the file named <tt>filename</tt> exists, then the first page (or screen)
of the file will be displayed; if the file does not exist, then an empty file and screen are created into which you may enter text.
<table>
<tbody><tr><th> *</th><th align="LEFT"><tt>vi filename</tt></th><td> <i>edit <tt>filename</tt> starting at line 1</i></td></tr><tr><th> &nbsp;</th><th align="LEFT"><tt>vi -r filename</tt></th><td> <i>recover <tt>filename</tt> that was being edited when system crashed</i></td></tr><tr></tr></tbody></table>

<h4 id="VItopic-3"> To Exit <tt>vi</tt></h4>
Usually the new or modified file is saved when you leave <tt>vi</tt>.  
However, it is also possible to quit <tt>vi</tt> without saving the file.
<b>Note:</b> The cursor moves to bottom of screen whenever a colon (<tt>:</tt>) is typed.  
This type of command is completed by hitting the <tt>&lt;Return&gt;</tt> (or <tt>&lt;Enter&gt;</tt>) key.
<table>
<tbody><tr><th> *</th><th align="LEFT"><tt>:x</tt><tt>&lt;Return&gt;</tt></th><td> <i>quit <tt>vi</tt>, writing out modified file to file named in original invocation</i></td></tr><tr><th> &nbsp;</th><th align="LEFT"><tt>:wq</tt><tt>&lt;Return&gt;</tt></th><td> <i>quit <tt>vi</tt>, writing out modified file to file named in original invocation</i></td></tr><tr><th> &nbsp;</th><th align="LEFT"><tt>:q</tt><tt>&lt;Return&gt;</tt></th><td> <i>quit (or exit) <tt>vi</tt></i></td></tr><tr><th> *</th><th align="LEFT"><tt>:q!</tt><tt>&lt;Return&gt;</tt></th><td> <i>quit <tt>vi</tt> even though latest changes have not been saved for this <tt>vi</tt> call</i></td></tr><tr></tr></tbody></table>
<h3 id="VItopic-4">Moving the Cursor</h3>
Unlike many of the PC and MacIntosh editors, <b>the mouse does not move the cursor</b> within the <tt>vi</tt> editor screen (or window). 
You must use the the key commands listed below.  
On some UNIX platforms, the arrow keys may be used as well;
however, since <tt>vi</tt> was designed with the Qwerty keyboard (containing no arrow keys) in mind, the arrow keys sometimes produce strange effects in <tt>vi</tt> and should be avoided.

If you go back and forth between a PC environment and a UNIX environment, you may find that this dissimilarity in methods for cursor movement is the most frustrating difference between the two.

In the table below, the symbol <tt>^</tt> before a letter means that the <tt>&lt;Ctrl&gt;</tt> key should be held down while the letter key is pressed.
<table>
<tbody><tr><th> *</th><th align="LEFT"><tt>j</tt> <i>or</i> <tt>&lt;Return&gt;</tt>
<br> &nbsp; [<i>or</i> down-arrow]</th><td> <i>move cursor down one line</i></td></tr><tr><th> *</th><th align="LEFT"><tt>k</tt> [<i>or</i> up-arrow]</th><td> <i>move cursor up one line</i></td></tr><tr><th> *</th><th align="LEFT"><tt>h</tt> <i>or</i> <tt>&lt;Backspace&gt;</tt>
<br> &nbsp; [<i>or</i> left-arrow]</th><td> <i>move cursor left one character</i></td></tr><tr><th> *</th><th align="LEFT"><tt>l</tt> <i>or</i> <tt>&lt;Space&gt;</tt>
<br> &nbsp; [<i>or</i> right-arrow]</th><td> <i>move cursor right one character</i></td></tr><tr><th> *</th><th align="LEFT" nowrap=""><tt>0</tt> (zero)</th><td> <i>move cursor to start of current line
(the one with the cursor)</i></td></tr><tr><th> *</th><th align="LEFT" nowrap=""><tt>$</tt></th><td><i>move cursor to end of current line</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>w</tt></th><td><i>move cursor to beginning of next word</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>b</tt></th><td><i>move cursor back to beginning of preceding word</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>:0</tt><tt>&lt;Return&gt; <i>or</i> 1G</tt></th><td> <i>move cursor to first line in file</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>:n</tt><tt>&lt;Return&gt; <i>or</i> nG</tt></th><td> <i>move cursor to line <tt>n</tt></i></td></tr><tr><th> &nbsp;</th><th align="LEFT"><tt>:$</tt><tt>&lt;Return&gt; <i>or</i> G</tt></th><td> <i> move cursor to last line in file</i></td></tr><tr></tr></tbody></table>
<h3 id="VItopic-5">Screen Manipulation</h3>
The following commands allow 
the <tt>vi</tt> editor screen (or window) to move up or down several lines and to be refreshed.
<table>
<tbody><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>^f</tt></th><td> <i>move forward one screen</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>^b</tt></th><td> <i>move backward one screen</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>^d</tt></th><td> <i>move down (forward) one half screen</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>^u</tt></th><td> <i>move up (back) one half screen</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>^l</tt></th><td> <i>redraws the screen</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>^r</tt></th><td> <i>redraws the screen, removing deleted lines</i></td></tr><tr></tr></tbody></table>
<h3 id="VItopic-6">Adding, Changing, and Deleting Text</h3>
Unlike PC editors, you cannot replace or delete text by highlighting it with the mouse.  
Instead use the commands in the following tables.

Perhaps the most important command is the one that allows you to back up and <i>undo</i> your last action.  
Unfortunately, this command acts like a toggle, undoing and redoing your most recent action.  
You cannot go back more than one step.
<table>
<tbody><tr><th> *</th><th align="LEFT" nowrap=""><tt>u</tt></th><td> <i>UNDO WHATEVER YOU JUST DID; a simple toggle</i></td></tr><tr></tr></tbody></table>

The main purpose of an editor is to create, add, or modify text for a file. 
<h4 id="VItopic-7"> Inserting or Adding Text</h4>
 The following commands allow you to insert and add text.
Each of these commands puts the <tt>vi</tt> editor into insert mode;
thus, the <tt>&lt;Esc&gt;</tt> key must be pressed to terminate the entry of text and to put the <tt>vi</tt> editor back into command mode.
<table>
<tbody><tr><th> *</th><th align="LEFT" nowrap=""><tt>i</tt></th><td> <i>insert text before cursor, until <tt>&lt;Esc&gt;</tt> hit</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>I</tt></th><td> <i>insert text at beginning of current line,
until <tt>&lt;Esc&gt;</tt> hit</i></td></tr><tr><th> *</th><th align="LEFT" nowrap=""><tt>a</tt></th><td> <i>append text after cursor, until <tt>&lt;Esc&gt;</tt> hit</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>A</tt></th><td> <i>append text to end of current line,
until <tt>&lt;Esc&gt;</tt> hit</i></td></tr><tr><th> *</th><th align="LEFT" nowrap=""><tt>o</tt></th><td> <i>open and put text in a new line below current line,
until <tt>&lt;Esc&gt;</tt> hit</i></td></tr><tr><th> *</th><th align="LEFT" nowrap=""><tt>O</tt></th><td> <i>open and put text in a new line above current line,
until <tt>&lt;Esc&gt;</tt> hit</i></td></tr><tr></tr></tbody></table>

<h4 id="VItopic-8"> Changing Text</h4>
The following commands allow you to modify text.
<table>
<tbody><tr><th> *</th><th align="LEFT" nowrap=""><tt>r</tt></th><td> <i> replace single character under cursor
(no <tt>&lt;Esc&gt;</tt> needed)</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>R</tt></th><td> <i>replace characters, starting with current cursor position,
until <tt>&lt;Esc&gt;</tt> hit</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>cw</tt></th><td> <i>change the current word with new text,
<br>starting with the character under cursor, until <tt>&lt;Esc&gt;</tt> hit</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>cNw</tt></th><td> <i>change <tt>N</tt> words beginning with character under cursor,
until <tt>&lt;Esc&gt;</tt> hit;
<br> &nbsp; e.g., <tt>c5w</tt> changes 5 words</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>C</tt></th><td> <i>change (replace) the characters in the current line,
until <tt>&lt;Esc&gt;</tt> hit</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>cc</tt></th><td> <i>change (replace) the entire current line, 
stopping when <tt>&lt;Esc&gt;</tt> is hit</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>Ncc</tt> <i>or</i> <tt>cNc</tt></th><td> <i>change (replace) the next N lines,
starting with the current line,<br>
stopping when <tt>&lt;Esc&gt;</tt> is hit</i></td></tr><tr></tr></tbody></table>

<h4 id="VItopic-9"> Deleting Text</h4>
The following commands allow you to delete text.
<table>
<tbody><tr><th> *</th><th align="LEFT" nowrap=""><tt>x</tt></th><td> <i>delete single character under cursor</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>Nx</tt></th><td> <i>delete N characters, starting with character under cursor</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>dw</tt></th><td> <i>delete the single word beginning with character under cursor</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>dNw</tt></th><td> <i>delete <tt>N</tt> words beginning with character under cursor;
<br> &nbsp; e.g., <tt>d5w</tt> deletes 5 words</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>D</tt></th><td> <i>delete the remainder of the line,
starting with current cursor position</i></td></tr><tr><th> *</th><th align="LEFT" nowrap=""><tt>dd</tt></th><td> <i>delete entire current line</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>Ndd</tt> <i>or</i> <tt>dNd</tt></th><td> <i>delete <tt>N</tt> lines, beginning with the current line;
<br> &nbsp; e.g., <tt>5dd</tt> deletes 5 lines</i></td></tr><tr></tr></tbody></table>

<h4 id="VItopic-10"> Cutting and Pasting Text</h4>
The following commands allow you to copy and paste text.
<table>
<tbody><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>yy</tt></th><td> <i>copy (yank, cut) the current line into the buffer</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>Nyy</tt> <i>or</i> <tt>yNy</tt></th><td> <i>copy (yank, cut) the next N lines, including the current line,
into the buffer</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>p</tt></th><td> <i>put (paste) the line(s) in the buffer into the text after the current line</i></td></tr><tr></tr></tbody></table>
<h3 id="VItopic-11">Other Commands</h3>
<h4 id="VItopic-12"> Searching Text</h4>
 A common occurrence in text editing is to replace one word or phase by another.  
To locate instances of particular sets of characters
(or strings), use the following commands.
<table>
<tbody><tr><th> &nbsp;</th><th align="LEFT"><tt>/string</tt></th><td> <i> search forward for occurrence of <tt>string</tt> in text<i>
</i></i></td></tr><tr><th> &nbsp;</th><th align="LEFT"><tt>?string</tt></th><td> <i> search backward for occurrence of <tt>string</tt> in text<i>
</i></i></td></tr><tr><th> &nbsp;</th><th align="LEFT"><tt>n</tt></th><td> <i> move to next occurrence of search string</i></td></tr><tr><th> &nbsp;</th><th align="LEFT"><tt>N</tt></th><td> <i> move to next occurrence of search string in opposite direction</i></td></tr><tr></tr></tbody></table>

<h4 id="VItopic-13"> Determining Line Numbers</h4>
 Being able to determine the line number of the current line or the total number of lines in the file being edited is sometimes useful.
<table>
<tbody><tr><th> &nbsp;</th><th align="LEFT"><tt>:.=</tt></th><td> <i> returns line number of current line at bottom of screen<i>
</i></i></td></tr><tr><th> &nbsp;</th><th align="LEFT"><tt>:=</tt></th><td> <i> returns the total number of lines at bottom of screen<i>
</i></i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>^g</tt></th><td> <i>provides the current line number, along with the total number of lines,<br>
in the file at the bottom of the screen</i></td></tr><tr></tr></tbody></table>
<h3 id="VItopic-14">Saving and Reading Files</h3>

These commands permit you to input and output files other than the named file with which you are currently working.

<table>
<tbody><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>:r filename</tt><tt>&lt;Return&gt;</tt></th><td> <i> read file named <tt>filename</tt> and insert after current line
<br>(the line with cursor)</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>:w</tt><tt>&lt;Return&gt;</tt></th><td> <i>write current contents to file named in original 
<tt>vi</tt> call
</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>:w newfile</tt><tt>&lt;Return&gt;</tt></th><td> <i>write current contents to a new file named <tt>newfile</tt>
</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>:12,35w smallfile</tt><tt>&lt;Return&gt;</tt></th><td> <i>write the contents of the lines numbered 12 through 35
to a new file named <tt>smallfile</tt>
</i></td></tr><tr><th> &nbsp;</th><th align="LEFT" nowrap=""><tt>:w! prevfile</tt><tt>&lt;Return&gt;</tt></th><td> <i>write current contents over a pre-existing file named <tt>prevfile</tt>
</i></td></tr><tr></tr></tbody></table>

<h2>VI Editing commands</h2>
i - Insert at cursor (goes into insert mode)
a - Write after cursor (goes into insert mode)
A - Write at the end of line (goes into insert mode)
ESC - Terminate insert mode
u - Undo last change
U - Undo all changes to the entire line
o - Open a new line (goes into insert mode)
dd - Delete line
3dd - Delete 3 lines.
D - Delete contents of line after the cursor
C - Delete contents of a line after the cursor and insert new text. Press ESC key to end insertion.
dw - Delete word
4dw - Delete 4 words
cw - Change word
x - Delete character at the cursor
r - Replace character
R - Overwrite characters from cursor onward
s - Substitute one character under cursor continue to insert
S - Substitute entire line and begin to insert at the beginning of the line
~ - Change case of individual character

<strong>Note</strong>: You should be in the &#8220;<strong>command mode&#8221; to execute these commands</strong>. VI editor is <strong>case-sensitive</strong> so make sure you type the commands in the right letter-case.</p>
Make sure you press the right command otherwise you will end up making undesirable changes to the file. You can also enter the insert mode by pressing a, A, o, as required.<br><div class='code-block code-block-4' style='margin: 8px 0; clear: both;'>

<h3>Moving within a file</h3>

k - Move cursor up
j - Move cursor down
h - Move cursor left
l - Move cursor right
You need to be in the command mode to move within a file. The default keys for navigation are mentioned below else; You can <strong>also use the arrow keys on the keyboard</strong>.</p>

<h3>Saving and Closing the file</h3>

Shift+zz - Save the file and quit
:w - Save the file but keep it open
:q! - Quit vi and do not save changes
:wq - Save the file and quit

You should be in the <strong>command mode to exit the editor and save changes</strong> to the file.</p>


<h2>Bash on Ubuntu on Windows: ls command returns nothing at root level</h2>
it probably just means the folder is empty (or only contain hidden files). 
you can try ls -a (or ll) to see hidden files (including . 
and ..) and see that it works.

How do I access all of my Windows folders from Bash on Ubuntu on Windows

Your C drive is at /mnt/c/
dir /mnt/c/

cd ~ usually takes me to my user directory. 

In bash on windows this takes me to a directory empty except for things like .bashrc. 

It still takes you to your "home directory" on Windows' Bash, it's just that your home dir starts empty and it's disconnected from your Windows drive. 

Consider that it's like having a Linux machine with the Windows drive mounted as a secondary or network drive. 
But if you install Ubuntu stuff that go the "home dir" that will be where cd ~ takes you – 

if you want to list all directories in root. 
simply type ls /

cd /mnt/c/Users/username
Where c means C: drive and username is your Windows username.
Then, when you type ls, you will see folders like Desktop, Documents, Downloads, etc.

<h2>Linux 操作必备 150 个命令</h2>
Linux 命令是对 Linux 系统进行管理的命令。
对于 Linux 系统来说，无论是中央处理器、内存、磁盘驱动器、键盘、鼠标，还是用户等都是文件， Linux 系统管理的命令是它正常运行的核心，与之前的 DOS 命令类似。

Linux 命令在系统中有两种类型：
内置 Shell 命令和 Linux 命令。
命令	功能说明
<b class="orange">线上查询及帮助命令 (2 个)</b>	
<b>man</b>	查看命令帮助，命令的词典，更复杂的还有 info，但不常用。
<b>help</b>	查看 Linux 内置命令的帮助，比如 cd 命令。

<b class="orange">文件和目录操作命令 (18 个)</b>	
<b>ls</b>	全拼 list，功能是列出目录的内容及其内容属性信息。
<b>cd</b>	全拼 change directory，功能是从当前工作目录切换到指定的工作目录。
<b>cp</b>	全拼 copy，其功能为复制文件或目录。
<b>find</b>	查找的意思，用于查找目录及目录下的文件。

<b>mkdir</b>	全拼 make directories，其功能是创建目录。
<b>mv</b>	全拼 move，其功能是移动或重命名文件。
<b>pwd</b>	全拼 print working directory，其功能是显示当前工作目录的绝对路径。
<b>rename</b>	用于重命名文件。

<b>rm</b>	全拼 remove，其功能是删除一个或多个文件或目录。
<b>rmdir</b>	全拼 remove empty directories，功能是删除空目录。
<b>touch</b>	创建新的空文件，改变已有文件的时间戳属性。
<b>tree</b>	功能是以树形结构显示目录下的内容。

<b>basename</b>	显示文件名或目录名。
<b>dirname</b>	显示文件或目录路径。
<b>chattr</b>	改变文件的扩展属性。
<b>lsattr</b>	查看文件扩展属性。

<b>file</b>	显示文件的类型。
<b>md5sum</b>	计算和校验文件的 MD5 值。

<b class="orange">查看文件及内容处理命令（21 个）</b>	
<b>cat</b>	全拼 concatenate，功能是用于连接多个文件并且打印到屏幕输出或重定向到指定文件中。
<b>tac</b>	tac 是 cat 的反向拼写，因此命令的功能为反向显示文件内容。
<b>more</b>	分页显示文件内容。
<b>less</b>	分页显示文件内容，more 命令的相反用法。

<b>head</b>	显示文件内容的头部。
<b>tail</b>	显示文件内容的尾部。
<b>cut</b>	将文件的每一行按指定分隔符分割并输出。
<b>split</b>	分割文件为不同的小片段。

<b>paste</b>	按行合并文件内容。
<b>sort</b>	对文件的文本内容排序。
<b>uniq</b>	去除重复行。 oldboy
<b>wc</b>	统计文件的行数、单词数或字节数。

<b>iconv</b>	转换文件的编码格式。
<b>dos2unix</b>	将 DOS 格式文件转换成 UNIX 格式。
<b>diff</b>	全拼 difference，比较文件的差异，常用于文本文件。
<b>vimdiff</b>	命令行可视化文件比较工具，常用于文本文件。

<b>rev</b>	反向输出文件内容。
<b>grep/egrep</b>	过滤字符串，三剑客老三。
<b>join</b>	按两个文件的相同字段合并。
<b>tr</b>	替换或删除字符。
<b>vi/vim</b>	命令行文本编辑器。

<b class="orange">文件压缩及解压缩命令（4 个）</b>	
<b>tar</b>	打包压缩。 oldboy
<b>unzip</b>	解压文件。
<b>gzip</b>	gzip 压缩工具。
<b>zip</b>	压缩工具。

<b class="orange">信息显示命令（11 个）</b>	
<b>uname</b>	显示操作系统相关信息的命令。
<b>hostname</b>	显示或者设置当前系统的主机名。
<b>dmesg</b>	显示开机信息，用于诊断系统故障。
<b>uptime</b>	显示系统运行时间及负载。

<b>stat</b>	显示文件或文件系统的状态。
<b>du</b>	计算磁盘空间使用情况。
<b>df</b>	报告文件系统磁盘空间的使用情况。
<b>top</b>	实时显示系统资源使用情况。

<b>free</b>	查看系统内存。
<b>date</b>	显示与设置系统时间。
<b>cal</b>	查看日历等时间信息。

<b class="orange">搜索文件命令（4 个）</b>	
<b>which</b>	查找二进制命令，按环境变量 PATH 路径查找。
<b>find</b>	从磁盘遍历查找文件或目录。
<b>whereis</b>	查找二进制命令，按环境变量 PATH 路径查找。
<b>locate</b>	从数据库 (/var/lib/mlocate/mlocate.db) 查找命令，使用 updatedb 更新库。

<b class="orange">用户管理命令（10 个）</b>	
<b>useradd</b>	添加用户。
<b>usermod</b>	修改系统已经存在的用户属性。
<b>userdel</b>	删除用户。
<b>groupadd</b>	添加用户组。

<b>passwd</b>	修改用户密码。
<b>chage</b>	修改用户密码有效期限。

<b>id</b>	查看用户的 uid,gid 及归属的用户组。
<b>su</b>	切换用户身份。
<b>visudo</b>	编辑 / etc/sudoers 文件的专属命令。
<b>sudo</b>	以另外一个用户身份（默认 root 用户）执行事先在 sudoers 文件允许的命令。

<b class="orange">基础网络操作命令（11 个）</b>	
<b>telnet</b>	使用 TELNET 协议远程登录。
<b>ssh</b>	使用 SSH 加密协议远程登录。
<b>scp</b>	全拼 secure copy，用于不同主机之间复制文件。
<b>wget</b>	命令行下载文件。

<b>ping</b>	测试主机之间网络的连通性。
<b>route</b>	显示和设置 linux 系统的路由表。
<b>ifconfig</b>	查看、配置、启用或禁用网络接口的命令。
<b>ifup</b>	启动网卡。

<b>ifdown</b>	关闭网卡。
<b>netstat</b>	查看网络状态。
<b>ss</b>	查看网络状态。

<b class="orange">深入网络操作命令（9 个）</b>	
<b>nmap</b>	网络扫描命令。
<b>lsof</b>	全名 list open files，也就是列举系统中已经被打开的文件。
<b>mail</b>	发送和接收邮件。
<b>mutt</b>	邮件管理命令。

<b>nslookup</b>	交互式查询互联网 DNS 服务器的命令。
<b>dig</b>	查找 DNS 解析过程。
<b>host</b>	查询 DNS 的命令。
<b>traceroute</b>	追踪数据传输路由状况。
<b>tcpdump</b>	命令行的抓包工具。

<b class="orange">有关磁盘与文件系统的命令（16 个）</b>	
<b>mount</b>	挂载文件系统。
<b>umount</b>	卸载文件系统。
<b>fsck</b>	检查并修复 Linux 文件系统。
<b>dd</b>	转换或复制文件。

<b>dumpe2fs</b>	导出 ext2/ext3/ext4 文件系统信息。
<b>dump</b>	ext2/3/4 文件系统备份工具。
<b>fdisk</b>	磁盘分区命令，适用于 2TB 以下磁盘分区。
<b>parted</b>	磁盘分区命令，没有磁盘大小限制，常用于 2TB 以下磁盘分区。

<b>mkfs</b>	格式化创建 Linux 文件系统。
<b>partprobe</b>	更新内核的硬盘分区表信息。
<b>e2fsck</b>	检查 ext2/ext3/ext4 类型文件系统。
<b>mkswap</b>	创建 Linux 交换分区。

<b>swapon</b>	启用交换分区。
<b>swapoff</b>	关闭交换分区。
<b>sync</b>	将内存缓冲区内的数据写入磁盘。
<b>resize2fs</b>	调整 ext2/ext3/ext4 文件系统大小。

<b class="orange">系统权限及用户授权相关命令（4 个）</b>	
<b>chmod</b>	改变文件或目录权限。
<b>chown</b>	改变文件或目录的属主和属组。
<b>chgrp</b>	更改文件用户组。
<b>umask</b>	显示或设置权限掩码。

<b class="orange">查看系统用户登陆信息的命令（7 个）</b>	
<b>whoami</b>	显示当前有效的用户名称，相当于执行 id -un 命令。
<b>who</b>	显示目前登录系统的用户信息。
<b>w</b>	显示已经登陆系统的用户列表，并显示用户正在执行的指令。
<b>last</b>	显示登入系统的用户。

<b>lastlog</b>	显示系统中所有用户最近一次登录信息。
<b>users</b>	显示当前登录系统的所有用户的用户列表。
<b>finger</b>	查找并显示用户信息。

<b class="orange">内置命令及其它（19 个）</b>	
<b>echo</b>	打印变量，或直接输出指定的字符串
<b>printf</b>	将结果格式化输出到标准输出。
<b>rpm</b>	管理 rpm 包的命令。
<b>yum</b>	自动化简单化地管理 rpm 包的命令。

<b>watch</b>	周期性的执行给定的命令，并将命令的输出以全屏方式显示。
<b>alias</b>	设置系统别名。
<b>unalias</b>	取消系统别名。
<b>date</b>	查看或设置系统时间。

<b>clear</b>	清除屏幕，简称清屏。
<b>history</b>	查看命令执行的历史纪录。
<b>eject</b>	弹出光驱。
<b>time</b>	计算命令执行时间。

<b>nc</b>	功能强大的网络工具。
<b>xargs</b>	将标准输入转换成命令行参数。
<b>exec</b>	调用并执行指令的命令。
<b>export</b>	设置或者显示环境变量。

<b>unset</b>	删除变量或函数。
<b>type</b>	用于判断另外一个命令是否是内置命令。
<b>bc</b>	命令行科学计算器

<b>系统管理与性能监视命令 (9 个)</b>	
<b>chkconfig</b>	管理 Linux 系统开机启动项。
<b>vmstat</b>	虚拟内存统计。
<b>mpstat</b>	显示各个可用 CPU 的状态统计。
<b>iostat</b>	统计系统 IO。

<b>sar</b>	全面地获取系统的 CPU、运行队列、磁盘 I/O、分页（交换区）、内存、 CPU 中断和网络等性能数据。
<b>ipcs</b>	用于报告 Linux 中进程间通信设施的状态，显示的信息包括消息列表、共享内存和信号量的信息。
<b>ipcrm</b>	用来删除一个或更多的消息队列、信号量集或者共享内存标识。
<b>strace</b>	用于诊断、调试 Linux 用户空间跟踪器。 我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。
<b>ltrace</b>	命令会跟踪进程的库函数调用, 它会显现出哪个库函数被调用。

<b class="orange">关机 / 重启 / 注销和查看系统信息的命令（6 个）</b>	
<b>shutdown</b>	关机。
<b>halt</b>	关机。
<b>poweroff</b>	关闭电源。
<b>logout</b>	退出当前登录的 Shell。

<b>exit</b>	退出当前登录的 Shell。
<b>Ctrl+d</b>	退出当前登录的 Shell 的快捷键。

<b class="orange">进程管理相关命令（15 个）</b>	
<b>bg</b>	将一个在后台暂停的命令，变成继续执行 （在后台执行）。
<b>fg</b>	将后台中的命令调至前台继续运行。
<b>jobs</b>	查看当前有多少在后台运行的命令。
<b>kill</b>	终止进程。

<b>killall</b>	通过进程名终止进程。
<b>pkill</b>	通过进程名终止进程。
<b>crontab</b>	定时任务命令。
<b>ps</b>	显示进程的快照。

<b>pstree</b>	树形显示进程。
<b>nice/renice</b>	调整程序运行的优先级。
<b>nohup</b>	忽略挂起信号运行指定的命令。
<b>pgrep</b>	查找匹配条件的进程。

<b>runlevel</b>	查看系统当前运行级别。
<b>init</b>	切换运行级别。
<b>service</b>	启动、停止、重新启动和关闭系统服务，还可以显示所有系统服务的当前状态。

<h2>Variable Names</h2>
The name of a variable can contain only letters (a to z or A to Z), numbers ( 0 to 9) or the underscore character ( _).
By convention, Unix shell variables will have their names in UPPERCASE.

The following examples are valid variable names -
_ALI
TOKEN_A
VAR_1
VAR_2

Following are the examples of invalid variable names -
2_VAR
-VARIABLE
VAR1-VAR2
VAR_A!

The reason you cannot use other characters such as <b>!</b>, <b>*</b>, or <b>-</b> is that these characters have a special meaning for the shell.

<h2>Defining Variables</h2>
Variables are defined as follows -
variable_name=variable_value

For example -
NAME="Zara Ali"

The above example defines the variable NAME and assigns the value "Zara Ali" to it. 
Variables of this type are called <b>scalar variables</b>. 

A scalar variable can hold only one value at a time.
Shell enables you to store any value you want in a variable. 

For example -
VAR1="Zara Ali"
VAR2=100

<h2>Accessing Values</h2>
To access the value stored in a variable, prefix its name with the dollar sign (<b>$</b>) -

For example, the following script will access the value of defined variable NAME and print it on STDOUT -

#!/bin/sh
NAME="Zara Ali"
echo $NAME

The above script will produce the following value -
Zara Ali

<h2>Read-only Variables</h2>
Shell provides a way to mark variables as read-only by using the read-only command. 
After a variable is marked read-only, its value cannot be changed.
For example, the following script generates an error while trying to change the value of NAME -

#!/bin/sh
NAME="Zara Ali"
readonly NAME
NAME="Qadiri"
The above script will generate the following result -
/bin/sh: NAME: This variable is read only.

<h2>Unsetting Variables</h2>
Unsetting or deleting a variable directs the shell to remove the variable from the list of variables that it tracks. 

Once you unset a variable, you cannot access the stored value in the variable.
Following is the syntax to unset a defined variable using the <b>unset</b> command -
unset variable_name

The above command unsets the value of a defined variable. 
Here is a simple example that demonstrates how the command works -
#!/bin/sh

NAME="Zara Ali"
unset NAME
echo $NAME

The above example does not print anything. 
You cannot use the unset command to <b>unset</b> variables that are marked <b>readonly</b>.
<h2>Variable Types</h2>

When a shell is running, three main types of variables are present -

<b>Local Variables</b> - A local variable is a variable that is present within the current instance of the shell. 

It is not available to programs that are started by the shell. 
They are set at the command prompt.

<b>Environment Variables</b> - An environment variable is available to any child process of the shell. 

Some programs need environment variables in order to function correctly. 
Usually, a shell script defines only those environment variables that are needed by the programs that it runs.

<b>Shell Variables</b> - A shell variable is a special variable that is set by the shell and is required by the shell in order to function correctly. 

Some of these variables are environment variables whereas others are local variables.

<h2>Variables in Shell Scripting</h2>
<div id="ShellVariablestoc" class="toc"><a href="#ShellVariablestopic-0" target="_self">System Defined Variables</a><br><a href="#ShellVariablestopic-1" target="_self">User Defined Variables</a><br><a href="#ShellVariablestopic-2" target="_self">Use of Backtick symbol (`) in shell variables</a><br></div></center><br><br>

In every<b> programming</b> language <b>variables</b> plays an important role , in Linux shell scripting we can use two types of variables : <b>System Defined Variables</b> &amp; <b>User Defined Variables</b>.

A variable in a shell script is a means of <b>referencing </b>a <b>numeric</b> or <b>character value</b>. 
And unlike formal programming languages, a shell script doesn’t require you to <b>declare a type</b> for your variables

<h3 id="ShellVariablestopic-0">System Defined Variables</h3>

These are the variables which are created and maintained by <b>Operating System(Linux) itself.</b> Generally these variables are defined in <b>CAPITAL LETTERS</b>. 
We can see these variables by using the command “<b>$ set</b>“. 
Some of the system defined variables are given below :

$ set

<img class="lazy" data-src="https://www.linuxtechi.com/wp-content/uploads/2014/07/Linux-Shell-Variables-Meaninigs.png?ezimgfmt=ng%3Awebp%2Fngcb22%2Frs%3Adevice%2Frscb22-1">

To print the value of above variables, use echo command as shown below :

$ echo $HOME
/home/linuxtechi
$ echo $USER
linuxtechi
$

We can use environment variables in our bash scripts by using the environment variable’s name preceded by a dollar sign. 
Example is shown below,

$ cat myscript

#!/bin/bash
# display user information from the system.
echo "User info for userid: $USER"
echo UID: $UID
echo HOME: $HOME

Notice that the <b>environment variables</b> in the echo commands are replaced by their current values when the script is run. 
Also notice that we were able to place the <b><em>$USER </em></b>system variable within the double quotation marks in the first string, and the shell script was still able to figure out what we meant. 
There is a <b>drawback</b> to using this method, however. 
Look at what happens in this example:

$ echo "The cost of the item is $15"
The cost of the item is 5
$

That is obviously not what was intended. 
Whenever the script sees a dollar sign within quotes, it assumes you’re referencing a variable. 
In this example the script attempted to display the <b>variable <em>$1 </em></b>(which was not defined), and then the number 5. 
To display an actual dollar sign, you <b>must precede</b> it with a<b> backslash character:</b>

$ echo "The cost of the item is \$15"
The cost of the item is $15
$

That’s better. 
The backslash allowed the shell script to interpret the <b>dollar sign</b> as an actual dollar sign, and not a variable.

<h3 id="ShellVariablestopic-1">User Defined Variables</h3>
These variables are defined by <b>users</b>. 
A shell script allows us to set and use our <b>own variables</b> within the script. 
Setting variables allows you to <b>temporarily store data</b> and use it throughout the script, making the shell script more like a real computer program.

<b>User variables</b> can be any text string of up to <b>20 letters</b>, <b>digits</b>, or <b>an underscore character</b>. 
User variables are case sensitive, so the variable Var1 is different from the variable var1. 
This little rule often gets novice script programmers in trouble.

Values are assigned to user variables using an <b>equal sign.</b> No spaces can appear between the variable, the equal sign, and the value (another trouble spot for novices). 
Here are a few examples of assigning values to user variables:

var1=10
var2=-57
var3=testing
var4="still more testing"

The shell script <b>automatically determines the data type</b> used for the variable value. 
Variables defined within the shell script maintain their values throughout the life of the shell script but are deleted when the shell script completes.

Just like system variables, user variables can be referenced using the dollar sign:

$ cat test3
#!/bin/bash
# testing variables
days=10
guest="Katie"
echo "$guest checked in $days days ago"
days=5
guest="Jessica"
echo "$guest checked in $days days ago"
$

Running the script produces the following output,

$ chmod u+x test3
$ ./test3
Katie checked in 10 days ago
Jessica checked in 5 days ago
$

Each time the variable is<b> referenced</b>, it produces the value currently assigned to it. 
It’s important to remember that when referencing a variable value you use the <b>dollar sign</b>, but when referencing the variable to assign a value to it, you do not use the dollar sign. 
Here’s an example of what I mean:

$ cat test4
#!/bin/bash
# assigning a variable value to another variable
value1=10
value2=$value1
echo The resulting value is $value2
$

When you use the <b>value </b>of the <b>value1</b> variable in the assignment statement, you must still use the dollar sign. 
This code produces the following output:

$ chmod u+x test4
$ ./test4
The resulting value is 10
$

If you forget the dollar sign, and make the value2 assignment line look like:

value2=value1
you get the following output:
$ ./test4
The resulting value is value1
$

Without the dollar sign the <b>shell interprets</b> the variable name as a <b>normal text string</b>, which is most likely not what you wanted.

<h3 id="ShellVariablestopic-2">Use of Backtick symbol (`) in shell variables</h3>
The <b>backtick allows</b> you to assign the output of a shell command to a variable. 
While this doesn’t seem like much, it is a major building block in <b>script </b><b>programming. 
</b>You must surround the entire command line command with backtick characters:

testing=`date`

The shell runs the command within the <b>backticks</b> and assigns the output to the variable testing. 
Here’s an example of creating a variable using the output from a normal shell command:

$ cat test5
#!/bin/bash
# using the backtick character
testing=`date`
echo "The date and time are: " $testing
$

The variable testing receives the output from the date command, and it is used in the echo statement to display it. 
Running the shell script produces the following output:

$ chmod u+x test5
$ ./test5
The date and time are: Tue 4 Oct 05:20:44 BST 2022
$

<b>Note </b>: In bash you can also use the alternative <b>$(…) </b>syntax in place of backtick (`),which has the advantage of being re-entrant.

Example : 

$ echo " Today’s date &amp; time is :" $(date)
Today’s date &amp; time is : Tue 4 Oct 05:21:51 BST 2022
$

<h2>Reset password for Ubuntu on WSL</h2>
Step 1: Switch to root as default user
From the command prompt:
ubuntu config --default-user root

Step 2: Reset the password for the account
whoami
passwd root

<h2>fix a "Command not found" error in Linux</h2>
<div id="Commandnotfoundtoc" class="toc"><a href="#Commandnotfoundtopic-0" target="_self">Understanding environment variables</a><br><a href="#Commandnotfoundtopic-1" target="_self">Global variables</a><br><a href="#Commandnotfoundtopic-2" target="_self">Local variables</a><br><a href="#Commandnotfoundtopic-3" target="_self">The PATH environment variable</a><br><a href="#Commandnotfoundtopic-4" target="_self">5 ways to fix "Command not found" errors</a><br><a href="#Commandnotfoundtopic-5" target="_self">1. Include the path</a><br><a href="#Commandnotfoundtopic-6" target="_self">2. Add a new path</a><br><a href="#Commandnotfoundtopic-7" target="_self">3. Copy a file to an existing path location</a><br><a href="#Commandnotfoundtopic-8" target="_self">4. Tell Bash where to look</a><br><a href="#Commandnotfoundtopic-9" target="_self">5. Install a package</a><br><a href="#Commandnotfoundtopic-10" target="_self">Stick to the path</a><br></div></center><br><br>

When you're trying to run a command (with or without <code>sudo</code>) and get an error message that reads "Command not found," this means the script or file you're trying to execute doesn't exist in the location specified by your PATH variable. 
What is this variable, and how can you run commands that it can't find?

<h3 id="Commandnotfoundtopic-0">Understanding environment variables</h3>
In computing, a <em>variable</em> is a placeholder for a value that can change. 
You use variables every day in normal speech, although you don't think of them as such. 
When you say "my laptop," you're using "laptop" as a generic variable or placeholder for the computer you're carrying, regardless of whether it happens to be a Lenovo, Mac, or a Raspberry Pi in a fancy case.

<em>Environment variables</em> are special variables that contain information about your login session. 
Many of these variables are set by default during installation or user creation. 
They're stored for the system shell, applications, and scripts to use when executing commands.

There are global, or system-defined, variables and local, or user-defined, variables.

<h3 id="Commandnotfoundtopic-1">Global variables</h3>

Global variables come predefined in your login shell, but they aren't immutable and can be modified or deleted according to your preferences. 
You can use the <code>printenv</code> or <code>env</code> commands to display the environment variables on your system:

<code>$ env 
SHELL=/bin/bash 
SESSION_MANAGER=local/kiwi.homelinux.local:@/tmp/.ICE-unix/1906,unix/kiwi.homelinux.local:/tmp/.ICE-unix/19
06 
WINDOWID=153092103 
COLORTERM=truecolor 
XDG_CONFIG_DIRS=/home/tux/.config/kdedefaults:/etc/xdg:/etc/kde/xdg 
LESS=-XR 
XDG_SESSION_PATH=/org/freedesktop/DisplayManager/Session1 
HISTCONTROL=:ignorespace:ignoredups:ignorespace:ignoredups 
PKG_CONFIG_PATH=/usr/local/lib64/pkgconfig:/usr/local/share/pkgconfig:/usr/lib64/pkgconfig:/usr/share/pkgconfig 
[...]</code>

The <code>env</code> command prints out all global environment variables. 
Variables are case sensitive, and all Linux distributions use uppercase for environment variable names by default.

<b><em>[ Keep your favorite Git commands, aliases, and tips close at hand. 
Download the <a href="https://opensource.com/downloads/cheat-sheet-git?intcmp=701f20000012ngPAAQ" target="_blank">Git cheat sheet</a>. 
]</em></b>

<h3 id="Commandnotfoundtopic-2">Local variables</h3>
A local variable exists only within a specific shell. 
Therefore, when you define a local variable, it's only available in your current shell. 
It doesn't propagate or persist to a new shell session unless you export it as a global variable.

Local variables are often defined in lowercase to avoid overwriting a global variable with the same name.

<h3 id="Commandnotfoundtopic-3">The PATH environment variable</h3>

The PATH global environment variable lists the directories your system searches for valid, executable commands. 
By default, it contains standard directories that normally store executables like <code>/usr/bin</code>, <code>/usr/local/bin</code>, and so on.

When you type in a command, such as <code>grep</code> or <code>vim</code>, your system searches through all directories listed in your PATH variable, in the order that they're listed, until it finds an executable file by the same name. 
Should it fail to find one, it issues the "Command not found" error.

<code>$ printenv PATH
/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/tux/.local/bin:/home/tux/bin

$ env $PATH
env: /usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/tux/.local/bin:/home/tux/bin</code>

<h3 id="Commandnotfoundtopic-4">5 ways to fix "Command not found" errors</h3>

There are several ways to fix this problem. 
Here are five of them.

<h3 id="Commandnotfoundtopic-5">1. Include the path</h3>
Not everything you want to execute needs to be in your path. 
You can execute files directly by specifying the path to the file you want to run. 
By identifying the file's location, you circumvent the need for your system to search your path at all.

For example, suppose you have a script called <code>hello</code> that you want to run. 
It's located in your home directory, and you have already marked it as executable with <code>chmod +x</code>:

<code>$ ~/hello
hello world</code>

By telling your system the file's location, the PATH variable is never involved, and the file runs as expected.

<h3 id="Commandnotfoundtopic-6">2. Add a new path</h3>

Alternately, you can add a new directory to your PATH. 
Add your executable files to that directory, and then you can run them without manually providing a path:

<code>$ cp ~/hello ~/.local/bin
$ export PATH=$PATH:$HOME/.local/bin
$ printenv PATH
/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/tux/.local/bin</code>

You may want to add the new PATH environment variables to your login shell by including them in your <code>.bashrc</code> file as new settings.

<h3 id="Commandnotfoundtopic-7">3. Copy a file to an existing path location</h3>

If you want to execute your binary file or script, copy it to any of the directory paths already listed in the PATH environment variable:

<code>$ sudo cp ~/hello /usr/local/bin/
$ hello
hello world</code>

<h3 id="Commandnotfoundtopic-8">4. Tell Bash where to look</h3>

Probably the simplest option, especially for one-off scripts or applications, is to tell Bash not to consider the PATH but rather to "look here." Do this by placing a dot and a slash in front of the command, script, or application name. 
For the <code>hello</code> script, it looks like this:

<code>$ sudo ./hello
hello world</code>

No permanent changes are made to the system. 
This might be handy if you're writing a script and want to test it before copying or moving it to its normal storage location (presumably along the PATH).

<h3 id="Commandnotfoundtopic-9">5. Install a package</h3>

Sometimes when you try to use a command and Bash displays the "Command not found" error, it might be because the program is not installed on your system. 
Correct this by installing a software package containing the command. 
For example, if you don't have Nmap installed, then the <code>nmap</code> command fails when you type it into a terminal:

<code>$ nmap
nmap: command not found
$ sudo dnf install --assumeyes --quiet nmap
$ nmap
Nmap 7.92 ( https://nmap.org ) 
Usage: nmap [Scan Type(s)] [Options] {target specification}
[...]</code>

<b><em>[ Want to learn more? Sign up for a <a href="https://www.redhat.com/en/services/training/learning-subscription?intcmp=701f20000012ngPAAQ" target="_blank">free trial of full access to Red Hat's curriculum</a>. 
]</em></b>

<h3 id="Commandnotfoundtopic-10">Stick to the path</h3>

The PATH variable is a powerful tool you can use to customize how your system responds to commands, so take some time to get comfortable with it. 
It's frequently used when running commands to find the command executable.

In this tutorial, you learned five ways to fix a "Command not found" error in your terminal—three of which rely on the PATH variable. 
Now that you know what variables are and how command executables are found, you won't be so mystified when the "Command not found" error appears on your screen.

<h2>Linux 系统总结</h2>

<div id="LinuxSystoc" class="toc"><a href="#LinuxSystopic-0" target="_self"><span class="brown">Linux 基础</span></a><br><a href="#LinuxSystopic-1" target="_self"> <k>操作系统</k></a><br><a href="#LinuxSystopic-2" target="_self"> <k>什么是 Linux</k></a><br><a href="#LinuxSystopic-3" target="_self"> <k>Linux 系统内核与 Linux 发行套件的区别</k></a><br><a href="#LinuxSystopic-4" target="_self"> <k>Linux 对比 Windows</k></a><br><a href="#LinuxSystopic-5" target="_self"> <k>Linux 系统种类</k></a><br><a href="#LinuxSystopic-6" target="_self"> <k>终端连接阿里云服务器</k></a><br><a href="#LinuxSystopic-7" target="_self"> <k>Shell</k></a><br><a href="#LinuxSystopic-8" target="_self"> <k>Shell 的种类</k></a><br><a href="#LinuxSystopic-9" target="_self"> <k>命令</k></a><br><a href="#LinuxSystopic-10" target="_self"> <k>命令行提示符</k></a><br><a href="#LinuxSystopic-11" target="_self"> <k>命令格式</k></a><br><a href="#LinuxSystopic-12" target="_self"> 长短参数</a><br><a href="#LinuxSystopic-13" target="_self"> 参数值</a><br><a href="#LinuxSystopic-14" target="_self"> <k>快捷方式</k></a><br><a href="#LinuxSystopic-15" target="_self"> <k>文件和目录</k></a><br><a href="#LinuxSystopic-16" target="_self"> <k>文件的组织</k></a><br><a href="#LinuxSystopic-17" target="_self"> <k>查看路径</k></a><br><a href="#LinuxSystopic-18" target="_self"> pwd</a><br><a href="#LinuxSystopic-19" target="_self"> which</a><br><a href="#LinuxSystopic-20" target="_self"> <k>浏览和切换目录</k></a><br><a href="#LinuxSystopic-21" target="_self"> ls</a><br><a href="#LinuxSystopic-22" target="_self"> cd</a><br><a href="#LinuxSystopic-23" target="_self"> du</a><br><a href="#LinuxSystopic-24" target="_self"> <k>浏览和创建文件</k></a><br><a href="#LinuxSystopic-25" target="_self"> cat</a><br><a href="#LinuxSystopic-26" target="_self"> less</a><br><a href="#LinuxSystopic-27" target="_self"> head</a><br><a href="#LinuxSystopic-28" target="_self"> tail</a><br><a href="#LinuxSystopic-29" target="_self"> touch</a><br><a href="#LinuxSystopic-30" target="_self"> mkdir</a><br><a href="#LinuxSystopic-31" target="_self"> <k>文件的复制和移动</k></a><br><a href="#LinuxSystopic-32" target="_self"> cp</a><br><a href="#LinuxSystopic-33" target="_self"> mv</a><br><a href="#LinuxSystopic-34" target="_self"> <k>文件的删除和链接</k></a><br><a href="#LinuxSystopic-35" target="_self"> rm</a><br><a href="#LinuxSystopic-36" target="_self"> ln</a><br><a href="#LinuxSystopic-37" target="_self"> <k>用户与权限</k></a><br><a href="#LinuxSystopic-38" target="_self"> <k>用户</k></a><br><a href="#LinuxSystopic-39" target="_self"> sudo</a><br><a href="#LinuxSystopic-40" target="_self"> useradd + passwd</a><br><a href="#LinuxSystopic-41" target="_self"> userdel</a><br><a href="#LinuxSystopic-42" target="_self"> su</a><br><a href="#LinuxSystopic-43" target="_self"> <k>群组的管理</k></a><br><a href="#LinuxSystopic-44" target="_self"> groupadd</a><br><a href="#LinuxSystopic-45" target="_self"> groupdel</a><br><a href="#LinuxSystopic-46" target="_self"> groups</a><br><a href="#LinuxSystopic-47" target="_self"> usermod</a><br><a href="#LinuxSystopic-48" target="_self"> chgrp</a><br><a href="#LinuxSystopic-49" target="_self"> chown</a><br><a href="#LinuxSystopic-50" target="_self"> <k>文件权限管理</k></a><br><a href="#LinuxSystopic-51" target="_self"> chmod</a><br><a href="#LinuxSystopic-52" target="_self"> <k>查找文件</k></a><br><a href="#LinuxSystopic-53" target="_self"> <k>locate</k></a><br><a href="#LinuxSystopic-54" target="_self"> 安装 locate</a><br><a href="#LinuxSystopic-55" target="_self"> <k>find</k></a><br><a href="#LinuxSystopic-56" target="_self"> 根据文件名查找</a><br><a href="#LinuxSystopic-57" target="_self"> 根据文件大小查找</a><br><a href="#LinuxSystopic-58" target="_self"> 根据文件最近访问时间查找</a><br><a href="#LinuxSystopic-59" target="_self"> 仅查找目录或文件</a><br><a href="#LinuxSystopic-60" target="_self"> 操作查找结果</a><br><a href="#LinuxSystopic-61" target="_self"> <k>软件仓库</k></a><br><a href="#LinuxSystopic-62" target="_self"> <k>yum 常用命令</k></a><br><a href="#LinuxSystopic-63" target="_self"> <k>切换 CentOS 软件源</k></a><br><a href="#LinuxSystopic-64" target="_self"> <k>阅读手册</k></a><br><a href="#LinuxSystopic-65" target="_self"> <k>man</k></a><br><a href="#LinuxSystopic-66" target="_self"> 安装更新 man</a><br><a href="#LinuxSystopic-67" target="_self"> man 手册种类</a><br><a href="#LinuxSystopic-68" target="_self"> man + 数字 + 命令</a><br><a href="#LinuxSystopic-69" target="_self"> <k>help</k></a><br><a href="#LinuxSystopic-70" target="_self"><span class="brown">Linux 进阶</span></a><br><a href="#LinuxSystopic-71" target="_self"> <k>文本操作</k></a><br><a href="#LinuxSystopic-72" target="_self"> <k>grep</k></a><br><a href="#LinuxSystopic-73" target="_self"> 基础语法</a><br><a href="#LinuxSystopic-74" target="_self"> 常用参数</a><br><a href="#LinuxSystopic-75" target="_self"> 高级用法</a><br><a href="#LinuxSystopic-76" target="_self"> <k>sort</k></a><br><a href="#LinuxSystopic-77" target="_self"> 基础语法</a><br><a href="#LinuxSystopic-78" target="_self"> 实例用法</a><br><a href="#LinuxSystopic-79" target="_self"> 常用参数</a><br><a href="#LinuxSystopic-80" target="_self"> <k>wc</k></a><br><a href="#LinuxSystopic-81" target="_self"> 基础语法</a><br><a href="#LinuxSystopic-82" target="_self"> 实例用法</a><br><a href="#LinuxSystopic-83" target="_self"> 常用参数</a><br><a href="#LinuxSystopic-84" target="_self"> <k>uniq</k></a><br><a href="#LinuxSystopic-85" target="_self"> 基础语法</a><br><a href="#LinuxSystopic-86" target="_self"> 常用参数</a><br><a href="#LinuxSystopic-87" target="_self"> <k>cut</k></a><br><a href="#LinuxSystopic-88" target="_self"> 基础语法</a><br><a href="#LinuxSystopic-89" target="_self"> 常用参数</a><br><a href="#LinuxSystopic-90" target="_self"> <k>重定向 管道 流</k></a><br><a href="#LinuxSystopic-91" target="_self"> <k>重定向</k></a><br><a href="#LinuxSystopic-92" target="_self"> 输出重定向 <code>&gt;</code> </a><br><a href="#LinuxSystopic-93" target="_self"> 输出重定向 <code>&gt;&gt;</code> </a><br><a href="#LinuxSystopic-94" target="_self"> 输出重定向 <code>2&gt;</code> </a><br><a href="#LinuxSystopic-95" target="_self"> 输出重定向 <code>2&gt;&gt;</code> </a><br><a href="#LinuxSystopic-96" target="_self"> 输出重定向 <code>2&gt;&amp;1</code> </a><br><a href="#LinuxSystopic-97" target="_self"> 输入重定向 <code>&lt;</code> </a><br><a href="#LinuxSystopic-98" target="_self"> 输入重定向 <code>&lt;&lt;</code> </a><br><a href="#LinuxSystopic-99" target="_self"> <k>管道 <code>|</code> </k></a><br><a href="#LinuxSystopic-100" target="_self"> <k>流</k></a><br><a href="#LinuxSystopic-101" target="_self"> <k>查看进程</k></a><br><a href="#LinuxSystopic-102" target="_self"> <k>w</k></a><br><a href="#LinuxSystopic-103" target="_self"> <k>ps</k></a><br><a href="#LinuxSystopic-104" target="_self"> 基础语法</a><br><a href="#LinuxSystopic-105" target="_self"> 常用参数</a><br><a href="#LinuxSystopic-106" target="_self"> <k>top</k></a><br><a href="#LinuxSystopic-107" target="_self"> <k>kill</k></a><br><a href="#LinuxSystopic-108" target="_self"> <k>管理进程</k></a><br><a href="#LinuxSystopic-109" target="_self"> <k>进程状态</k></a><br><a href="#LinuxSystopic-110" target="_self"> <k>前台进程 &amp; 后台进程</k></a><br><a href="#LinuxSystopic-111" target="_self"> <k>&amp;</k></a><br><a href="#LinuxSystopic-112" target="_self"> <k>nohup</k></a><br><a href="#LinuxSystopic-113" target="_self"> <k>bg</k></a><br><a href="#LinuxSystopic-114" target="_self"> <k>jobs</k></a><br><a href="#LinuxSystopic-115" target="_self"> <k>fg</k></a><br><a href="#LinuxSystopic-116" target="_self"> <k>守护进程</k></a><br><a href="#LinuxSystopic-117" target="_self"> <k>systemd</k></a><br><a href="#LinuxSystopic-118" target="_self"> <k>文件压缩解压</k></a><br><a href="#LinuxSystopic-119" target="_self"> <k>tar</k></a><br><a href="#LinuxSystopic-120" target="_self"> 基础用法</a><br><a href="#LinuxSystopic-121" target="_self"> 常用参数</a><br><a href="#LinuxSystopic-122" target="_self"> <k>gzip / gunzip</k></a><br><a href="#LinuxSystopic-123" target="_self"> <k>tar 归档+压缩</k></a><br><a href="#LinuxSystopic-124" target="_self"> <k>zcat、zless、zmore</k></a><br><a href="#LinuxSystopic-125" target="_self"> <k>zip/unzip</k></a><br><a href="#LinuxSystopic-126" target="_self"> 命令安装</a><br><a href="#LinuxSystopic-127" target="_self"> 基础用法</a><br><a href="#LinuxSystopic-128" target="_self"> <k>编译安装软件</k></a><br><a href="#LinuxSystopic-129" target="_self"> <k>编译安装</k></a><br><a href="#LinuxSystopic-130" target="_self"> 实际案例</a><br><a href="#LinuxSystopic-131" target="_self"> <k>网络</k></a><br><a href="#LinuxSystopic-132" target="_self"> <k>ifconfig</k></a><br><a href="#LinuxSystopic-133" target="_self"> <k>host</k></a><br><a href="#LinuxSystopic-134" target="_self"> 软件安装</a><br><a href="#LinuxSystopic-135" target="_self"> 基础用法</a><br><a href="#LinuxSystopic-136" target="_self"> <k>ssh 连接远程服务器</k></a><br><a href="#LinuxSystopic-137" target="_self"> 配置 ssh</a><br><a href="#LinuxSystopic-138" target="_self"> 免密登录</a><br><a href="#LinuxSystopic-139" target="_self"> <k>wget</k></a><br><a href="#LinuxSystopic-140" target="_self"> 常用参数</a><br><a href="#LinuxSystopic-141" target="_self"> <k>备份</k></a><br><a href="#LinuxSystopic-142" target="_self"> <k>scp</k></a><br><a href="#LinuxSystopic-143" target="_self"> <k>rsync</k></a><br><a href="#LinuxSystopic-144" target="_self"> 软件安装</a><br><a href="#LinuxSystopic-145" target="_self"> 基础用法</a><br><a href="#LinuxSystopic-146" target="_self"> 常用参数</a><br><a href="#LinuxSystopic-147" target="_self"> <k>系统</k></a><br><a href="#LinuxSystopic-148" target="_self"> <k>halt</k></a><br><a href="#LinuxSystopic-149" target="_self"> <k>reboot</k></a><br><a href="#LinuxSystopic-150" target="_self"> <k>poweroff</k></a><br><a href="#LinuxSystopic-151" target="_self"><span class="brown">Vim 编辑器</span></a><br><a href="#LinuxSystopic-152" target="_self"> <k>Vim 是什么？</k></a><br><a href="#LinuxSystopic-153" target="_self"> <k>Vim 常用模式</k></a><br><a href="#LinuxSystopic-154" target="_self"> <k>交互模式</k></a><br><a href="#LinuxSystopic-155" target="_self"> <k>插入模式</k></a><br><a href="#LinuxSystopic-156" target="_self"> <k>命令模式</k></a><br><a href="#LinuxSystopic-157" target="_self"> <k>基本操作</k></a><br><a href="#LinuxSystopic-158" target="_self"> <k>打开 Vim</k></a><br><a href="#LinuxSystopic-159" target="_self"> <k>插入</k></a><br><a href="#LinuxSystopic-160" target="_self"> <k>移动</k></a><br><a href="#LinuxSystopic-161" target="_self"> <k>跳至行首和行末</k></a><br><a href="#LinuxSystopic-162" target="_self"> <k>按单词移动</k></a><br><a href="#LinuxSystopic-163" target="_self"> <k>退出文件</k></a><br><a href="#LinuxSystopic-164" target="_self"> <k>标准操作</k></a><br><a href="#LinuxSystopic-165" target="_self"> <k>删除字符</k></a><br><a href="#LinuxSystopic-166" target="_self"> <k>删除（剪切）单词，行</k></a><br><a href="#LinuxSystopic-167" target="_self"> <k>复制单词，行</k></a><br><a href="#LinuxSystopic-168" target="_self"> <k>粘贴</k></a><br><a href="#LinuxSystopic-169" target="_self"> <k>替换一个字符</k></a><br><a href="#LinuxSystopic-170" target="_self"> <k>撤销操作</k></a><br><a href="#LinuxSystopic-171" target="_self"> <k>重做</k></a><br><a href="#LinuxSystopic-172" target="_self"> <k>跳转到指定行</k></a><br><a href="#LinuxSystopic-173" target="_self"> <k>高级操作</k></a><br><a href="#LinuxSystopic-174" target="_self"> <k>查找</k></a><br><a href="#LinuxSystopic-175" target="_self"> <k>查找并替换</k></a><br><a href="#LinuxSystopic-176" target="_self"> <k>合并文件</k></a><br><a href="#LinuxSystopic-177" target="_self"> <k>分屏</k></a><br><a href="#LinuxSystopic-178" target="_self"> 分屏模式下的快捷键</a><br><a href="#LinuxSystopic-179" target="_self"> <k>运行外部命令 <code>:!</code></k></a><br><a href="#LinuxSystopic-180" target="_self"> <k>可视模式</k></a><br><a href="#LinuxSystopic-181" target="_self"> <k>Vim 配置</k></a><br><a href="#LinuxSystopic-182" target="_self"> <k>选项参数</k></a><br><a href="#LinuxSystopic-183" target="_self"> <k>.vimrc</k></a><br></div></center><br><br>

前言
Linux 的学习对于一个程序员的重要性是不言而喻的。前端开发相比后端开发，接触 <code>Linux</code> 机会相对较少，因此往往容易忽视它。但是学好它却是程序员必备修养之一。
如果本文对你有所帮助，请点个👍 吧。
作者使用的是阿里云服务器 <code>ECS</code> （最便宜的那种） <code>CentOS 7.7</code> 64位。当然你也可以在自己的电脑安装虚拟机，虚拟机中再去安装 <code>CentOS</code> 系统（这就完全免费了）。至于它的安装教程可以去谷歌搜索下，相关教程非常多。
<h3 id="LinuxSystopic-0"><span class="brown">Linux 基础</span></h3>
<h3 id="LinuxSystopic-1"> <k>操作系统</k></h3>
操作系统 <code>Operating System</code> 简称 <code>OS</code> ，是软件的一部分，它是硬件基础上的第一层软件，是硬件和其它软件沟通的桥梁。
操作系统会控制其他程序运行，管理系统资源，提供最基本的计算功能，如管理及配置内存、决定系统资源供需的优先次序等，同时还提供一些基本的服务程序。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c17c21686f21413085f3e32c85a19443~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
<h3 id="LinuxSystopic-2"> <k>什么是 Linux</k></h3>
<h3 id="LinuxSystopic-3"> <k>Linux 系统内核与 Linux 发行套件的区别</k></h3>

<code>Linux</code> 系统内核指的是由 <code>Linus Torvalds</code> 负责维护，提供硬件抽象层、硬盘及文件系统控制及多任务功能的系统核心程序。
<code>Linux</code> 发行套件系统是我们常说的 <code>Linux</code> 操作系统，也即是由 <code>Linux</code> 内核与各种常用软件的集合产品。

<k>总结：真正的 <code>Linux</code> 指的是系统内核，而我们常说的 <code>Linux</code> 指的是“发行版完整的包含一些基础软件的操作系统”。</k>
<h3 id="LinuxSystopic-4"> <k>Linux 对比 Windows</k></h3>

稳定且有效率；
免费（或少许费用）；
漏洞少且快速修补；
多任务多用户；
更加安全的用户与文件权限策略；
适合小内核程序的嵌入系统；
相对不耗资源。

<h3 id="LinuxSystopic-5"> <k>Linux 系统种类</k></h3>

红帽企业版 <code>Linux</code> ： <code>RHEL</code> 是全世界内使用最广泛的 <code>Linux</code> 系统。它具有极强的性能与稳定性，是众多生成环境中使用的（收费的）系统。
<code>Fedora</code> ：由红帽公司发布的桌面版系统套件，用户可以免费体验到最新的技术或工具，这些技术或工具在成熟后会被加入到 <code>RHEL</code> 系统中，因此 <code>Fedora</code> 也成为 <code>RHEL</code> 系统的试验版本。
<code>CentOS</code> ：通过把 <code>RHEL</code> 系统重新编译并发布给用户免费使用的 <code>Linux</code> 系统，具有广泛的使用人群。
<code>Deepin</code> ：中国发行，对优秀的开源成品进行集成和配置。
<code>Debian</code> ：稳定性、安全性强，提供了免费的基础支持，在国外拥有很高的认可度和使用率。
<code>Ubuntu</code> ：是一款派生自 <code>Debian</code> 的操作系统，对新款硬件具有极强的兼容能力。 <code>Ubuntu</code> 与 <code>Fedora</code> 都是极其出色的 <code>Linux</code> 桌面系统，而且 <code>Ubuntu</code> 也可用于服务器领域。

<h3 id="LinuxSystopic-6"> <k>终端连接阿里云服务器</k></h3>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2111613d8ba40059f7351e21f158847~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
通过执行 <code>ssh root@121.42.11.34</code> 命令，然后输入服务器连接密码就可以顺利登陆远程服务器。从现在开始我们就可以在本地电脑操作远程服务器。

这个黑色的面板就是终端也就是 <code>Shell</code> （命令行环境）。
<code>ssh root@xxx</code> 这是一条命令，必须要在 <code>Shell</code> 中才能执行。

<h3 id="LinuxSystopic-7"> <k>Shell</k></h3>
<code>Shell</code> 这个单词的原意是“外壳”，跟 <code>kernel</code>（内核）相对应，比喻内核外面的一层，即用户跟内核交互的对话界面。

<code>Shell</code> 是一个程序，提供一个与用户对话的环境。这个环境只有一个命令提示符，让用户从键盘输入命令，所以又称为命令行环境（ <code>command line interface</code> ，简写为 <code>CLI</code> ）。 <code>Shell</code> 接收到用户输入的命令，将命令送入操作系统执行，并将结果返回给用户。
<code>Shell</code> 是一个命令解释器，解释用户输入的命令。它支持变量、条件判断、循环操作等语法，所以用户可以用 <code>Shell</code> 命令写出各种小程序，又称为 <code>Shell</code> 脚本。这些脚本都通过 <code>Shell</code> 的解释执行，而不通过编译。
<code>Shell</code> 是一个工具箱，提供了各种小工具，供用户方便地使用操作系统的功能。

<h3 id="LinuxSystopic-8"> <k>Shell 的种类</k></h3>
<code>Shell</code> 有很多种，只要能给用户提供命令行环境的程序，都可以看作是 <code>Shell</code> 。
历史上，主要的 <code>Shell</code>  有下面这些：

Bourne Shell（sh）
Bourne Again shell（bash）
C Shell（csh）
TENEX C Shell（tcsh）
Korn shell（ksh）
Z Shell（zsh）
Friendly Interactive Shell（fish）

其中 <code>Bash</code> 是目前最常用的 <code>Shell</code> 。 <code>MacOS</code> 中的默认 <code>Shell</code>  就是 <code>Bash</code> 。
通过执行 <code>echo $SHELL</code> 命令可以查看到当前正在使用的 <code>Shell</code> 。还可以通过 <code>cat /etc/shells</code> 查看当前系统安装的所有 <code>Shell</code>  种类。
<h3 id="LinuxSystopic-9"> <k>命令</k></h3>
<h3 id="LinuxSystopic-10"> <k>命令行提示符</k></h3>
进入命令行环境以后，用户会看到 <code>Shell</code> 的提示符。提示符往往是一串前缀，最后以一个美元符号 <code>$</code> 结尾，用户可以在这个符号后面输入各种命令。
执行一个简单的命令 <code>pwd</code> ：

<code>
[root@iZm5e8dsxce9ufaic7hi3uZ ~]# pwd
/root</code>
命令解析：


<code>root</code>：表示用户名；


<code>iZm5e8dsxce9ufaic7hi3uZ</code>：表示主机名；


<code>~</code>：表示目前所在目录为家目录，其中 <code>root</code> 用户的家目录是 <code>/root</code> 普通用户的家目录在 <code>/home</code> 下；


<code>#</code>：指示你所具有的权限（ <code>root</code> 用户为 <code>#</code> ，普通用户为 <code>$</code> ）。


执行 <code>whoami</code> 命令可以查看当前用户名；


执行 <code>hostname</code> 命令可以查看当前主机名；


关于如何创建、切换、删除用户，在后面的用户与权限会具体讲解，这里先使用 <code>root</code> 用户进行演示。
[备注] <code>root</code>  是超级用户，具备操作系统的一切权限。
<h3 id="LinuxSystopic-11"> <k>命令格式</k></h3>

<code>command parameters（命令 参数）</code>
<h4 id="LinuxSystopic-12"> 长短参数</h4>

<code>单个参数：ls -a（a 是英文 all 的缩写，表示“全部”）
多个参数：ls -al（全部文件 + 列表形式展示）
单个长参数：ls --all
多个长参数：ls --reverse --all
长短混合参数：ls --all -l</code>
<h4 id="LinuxSystopic-13"> 参数值</h4>

<code>短参数：command -p 10（例如：ssh root@121.42.11.34 -p 22）
长参数：command --paramters=10（例如：ssh root@121.42.11.34 --port=22）</code>
<h3 id="LinuxSystopic-14"> <k>快捷方式</k></h3>
在开始学习 <code>Linux</code> 命令之前，有这么一些快捷方式，是必须要提前掌握的，它将贯穿整个 <code>Linux</code> 使用生涯。

通过上下方向键 ↑ ↓ 来调取过往执行过的 <code>Linux</code> 命令；
命令或参数仅需输入前几位就可以用 <code>Tab</code> 键补全；
<code>Ctrl + R</code> ：用于查找使用过的命令（<code>history</code> 命令用于列出之前使用过的所有命令，然后输入 <code>!</code> 命令加上编号( <code>!2</code> )就可以直接执行该历史命令）；
<code>Ctrl + L</code>：清除屏幕并将当前行移到页面顶部；
<code>Ctrl + C</code>：中止当前正在执行的命令；
<code>Ctrl + U</code>：从光标位置剪切到行首；
<code>Ctrl + K</code>：从光标位置剪切到行尾；
<code>Ctrl + W</code>：剪切光标左侧的一个单词；
<code>Ctrl + Y</code>：粘贴 <code>Ctrl + U | K | Y</code> 剪切的命令；
<code>Ctrl + A</code>：光标跳到命令行的开头；
<code>Ctrl + E</code>：光标跳到命令行的结尾；
<code>Ctrl + D</code>：关闭 <code>Shell</code> 会话；

<h3 id="LinuxSystopic-15"> <k>文件和目录</k></h3>
<h3 id="LinuxSystopic-16"> <k>文件的组织</k></h3>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/226f8a87a9804141802d5ba0a55bd1f1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
<h3 id="LinuxSystopic-17"> <k>查看路径</k></h3>
<h4 id="LinuxSystopic-18"> pwd</h4>
显示当前目录的路径
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6fc89d9816a54a428d122abd7616c566~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
<h4 id="LinuxSystopic-19"> which</h4>
查看命令的可执行文件所在路径， <code>Linux</code> 下，每一条命令其实都对应一个可执行程序，在终端中输入命令，按回车的时候，就是执行了对应的那个程序， <code>which</code> 命令本身对应的程序也存在于 <code>Linux</code> 中。
总的来说一个命令就是一个可执行程序。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c0c60677e574aff82a0009339f72fb5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
<h3 id="LinuxSystopic-20"> <k>浏览和切换目录</k></h3>
<h4 id="LinuxSystopic-21"> ls</h4>
列出文件和目录，它是 <code>Linux</code> 最常用的命令之一。
【常用参数】

<code>-a</code> 显示所有文件和目录包括隐藏的
<code>-l</code> 显示详细列表
<code>-h</code> 适合人类阅读的
<code>-t</code> 按文件最近一次修改时间排序
<code>-i</code> 显示文件的 <code>inode</code> （ <code>inode</code> 是文件内容的标识）

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/015b1a4af3c14631a45b92c0f8755ea3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
<h4 id="LinuxSystopic-22"> cd</h4>
<code>cd</code> 是英语 <code>change directory</code> 的缩写，表示切换目录。

<code>cd /	--&gt; 跳转到根目录
cd ~	--&gt; 跳转到家目录
cd ..	--&gt; 跳转到上级目录
cd ./home	--&gt; 跳转到当前目录的home目录下
cd /home/lion	--&gt; 跳转到根目录下的home目录下的lion目录
cd	--&gt; 不添加任何参数，也是回到家目录</code>
[注意] 输入<code>cd /ho</code> + 单次 <code>tab</code> 键会自动补全路径 + 两次 <code>tab</code> 键会列出所有可能的目录列表。
<h4 id="LinuxSystopic-23"> du</h4>
列举目录大小信息。
【常用参数】

<code>-h</code> 适合人类阅读的；
<code>-a</code> 同时列举出目录下文件的大小信息；
<code>-s</code> 只显示总计大小，不显示具体信息。

<h3 id="LinuxSystopic-24"> <k>浏览和创建文件</k></h3>
<h4 id="LinuxSystopic-25"> cat</h4>
一次性显示文件所有内容，更适合查看小的文件。

<code>cat cloud-init.log</code>
【常用参数】

<code>-n</code> 显示行号。

<h4 id="LinuxSystopic-26"> less</h4>
分页显示文件内容，更适合查看大的文件。

<code>less cloud-init.log</code>
【快捷操作】

空格键：前进一页（一个屏幕）；
<code>b</code> 键：后退一页；
回车键：前进一行；
<code>y</code> 键：后退一行；
上下键：回退或前进一行；
<code>d</code> 键：前进半页；
<code>u</code> 键：后退半页；
<code>q</code> 键：停止读取文件，中止 <code>less</code> 命令；
<code>=</code> 键：显示当前页面的内容是文件中的第几行到第几行以及一些其它关于本页内容的详细信息；
<code>h</code> 键：显示帮助文档；
<code>/</code> 键：进入搜索模式后，按 <code>n</code> 键跳到一个符合项目，按 <code>N</code> 键跳到上一个符合项目，同时也可以输入正则表达式匹配。

<h4 id="LinuxSystopic-27"> head</h4>
显示文件的开头几行（默认是10行）

<code>head cloud-init.log</code>
【参数】

<code>-n</code> 指定行数 <code>head cloud-init.log -n 2</code> 

<h4 id="LinuxSystopic-28"> tail</h4>
显示文件的结尾几行（默认是10行）

<code>tail cloud-init.log</code>
【参数】

<code>-n</code> 指定行数 <code>tail cloud-init.log -n 2</code>
<code>-f</code> 会每过1秒检查下文件是否有更新内容，也可以用 <code>-s</code> 参数指定间隔时间 <code>tail -f -s 4 xxx.log</code> 

<h4 id="LinuxSystopic-29"> touch</h4>
创建一个文件

<code>touch new_file</code>
<h4 id="LinuxSystopic-30"> mkdir</h4>
创建一个目录

<code>mkdir new_folder</code>
【常用参数】

<code>-p</code> 递归的创建目录结构 <code>mkdir -p one/two/three</code> 

<h3 id="LinuxSystopic-31"> <k>文件的复制和移动</k></h3>
<h4 id="LinuxSystopic-32"> cp</h4>
拷贝文件和目录

<code>cp file file_copy	--&gt; file 是目标文件，file_copy 是拷贝出来的文件
cp file one	--&gt; 把 file 文件拷贝到 one 目录下，并且文件名依然为 file
cp file one/file_copy	--&gt; 把 file 文件拷贝到 one 目录下，文件名为file_copy
cp *.txt folder	--&gt; 把当前目录下所有 txt 文件拷贝到 folder 目录下</code>
【常用参数】

<code>-r</code> 递归的拷贝，常用来拷贝一整个目录

<h4 id="LinuxSystopic-33"> mv</h4>
移动（重命名）文件或目录，与cp命令用法相似。

<code>mv file one	--&gt; 将 file 文件移动到 one 目录下
mv new_folder one	--&gt; 将 new_folder 文件夹移动到one目录下
mv *.txt folder	--&gt; 把当前目录下所有 txt 文件移动到 folder 目录下
mv file new_file	--&gt; file 文件重命名为 new_file</code>
<h3 id="LinuxSystopic-34"> <k>文件的删除和链接</k></h3>
<h4 id="LinuxSystopic-35"> rm</h4>
删除文件和目录，由于 <code>Linux</code> 下没有回收站，一旦删除非常难恢复，因此需要谨慎操作

<code>rm new_file 	--&gt; 删除 new_file 文件
rm f1 f2 f3 	--&gt; 同时删除 f1 f2 f3 3个文件</code>
【常用参数】

<code>-i</code> 向用户确认是否删除；
<code>-f</code> 文件强制删除；
<code>-r</code> 递归删除文件夹，著名的删除操作 <code>rm -rf</code> 。

<h4 id="LinuxSystopic-36"> ln</h4>
英文 <code>Link</code> 的缩写，表示创建链接。
学习创建链接之前，首先要理解链接是什么，我们先来看看 <code>Linux</code> 的文件是如何存储的：
<code>Linux</code>  文件的存储方式分为3个部分，文件名、文件内容以及权限，其中文件名的列表是存储在硬盘的其它地方和文件内容是分开存放的，每个文件名通过 <code>inode</code> 标识绑定到文件内容。
Linux 下有两种链接类型：硬链接和软链接。
<h5>硬链接</h5>
使链接的两个文件共享同样文件内容，就是同样的 <code>inode</code> ，一旦文件1和文件2之间有了硬链接，那么修改任何一个文件，修改的都是同一块内容，它的缺点是，只能创建指向文件的硬链接，不能创建指向目录的（其实也可以，但比较复杂）而软链接都可以，因此软链接使用更加广泛。

<code>ln file1 file2 	--&gt; 创建 file2 为 file1 的硬链接</code>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a7460133e014a629fd09bbd6416ba6a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
如果我们用 <code>rm file1</code> 来删除 <code>file1</code> ，对 <code>file2</code> 没有什么影响，对于硬链接来说，删除任意一方的文件，共同指向的文件内容并不会从硬盘上删除。只有同时删除了 <code>file1</code> 与 <code>file2</code> 后，它们共同指向的文件内容才会消失。
<h5>软链接</h5>
软链接就类似 <code>windows</code> 下快捷方式。

<code>ln -s file1 file2</code>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/529e1c254dfd489dafbf82326c89abbc~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
执行 <code>ls -l</code> 命名查看当前目录下文件的具体信息

<code>total 0
-rw-r--r-- 1 root root 0 Jan 14 06:29 file1
lrwxrwxrwx 1 root root 5 Jan 14 06:42 file2 -&gt; file1  # 表示file2 指向 file1</code>
其实 <code>file2</code> 只是 <code>file1</code> 的一个快捷方式，它指向的是 <code>file1</code> ，所以显示的是 <code>file1</code> 的内容，但其实 <code>file2</code> 的 <code>inode</code>  与 <code>file1</code> 并不相同。如果我们删除了 <code>file2</code> 的话， <code>file1</code> 是不会受影响的，但如果删除 <code>file1</code> 的话， <code>file2</code> 就会变成死链接，因为指向的文件不见了。
<h3 id="LinuxSystopic-37"> <k>用户与权限</k></h3>
<h3 id="LinuxSystopic-38"> <k>用户</k></h3>
<code>Linux</code> 是一个多用户的操作系统。在 <code>Linux</code> 中，理论上来说，我们可以创建无数个用户，但是这些用户是被划分到不同的群组里面的，有一个用户，名叫 <code>root</code> ，是一个很特殊的用户，它是超级用户，拥有最高权限。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57aa4de6dc7b4bf8839080fbc4fc65ed~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
自己创建的用户是有限权限的用户，这样大大提高了 <code>Linux</code> 系统的安全性，有效防止误操作或是病毒攻击，但是我们执行的某些命令需要更高权限时可以使用 <code>sudo</code> 命令。
<h4 id="LinuxSystopic-39"> sudo</h4>
以 <code>root</code> 身份运行命令

<code>sudo date  --&gt; 当然查看日期是不需要sudo的这里只是演示，sudo 完之后一般还需要输入用户密码的</code>
<h4 id="LinuxSystopic-40"> useradd + passwd</h4>

<code>useradd</code> 添加新用户
<code>passwd</code>  修改用户密码

这两个命令需要 <code>root</code> 用户权限

<code>useradd lion	--&gt; 添加一个lion用户，添加完之后在 /home 路径下可以查看
passwd lion	--&gt; 修改lion用户的密码</code>
<h4 id="LinuxSystopic-41"> userdel</h4>
删除用户，需要 <code>root</code> 用户权限

<code>userdel lion	--&gt; 只会删除用户名，不会从/home中删除对应文件夹
userdel lion -r	--&gt; 会同时删除/home下的对应文件夹</code>
<h4 id="LinuxSystopic-42"> su</h4>
切换用户，需要 <code>root</code> 用户权限

<code>sudo su	--&gt; 切换为root用户（exit 命令或 CTRL + D 快捷键都可以使普通用户切换为 root 用户）
su lion	--&gt; 切换为普通用户
su -	--&gt; 切换为root用户</code>
<h3 id="LinuxSystopic-43"> <k>群组的管理</k></h3>
<code>Linux</code> 中每个用户都属于一个特定的群组，如果你不设置用户的群组，默认会创建一个和它的用户名一样的群组，并且把用户划归到这个群组。
<h4 id="LinuxSystopic-44"> groupadd</h4>
创建群组，用法和 <code>useradd</code> 类似。

<code>groupadd friends</code>
<h4 id="LinuxSystopic-45"> groupdel</h4>
删除一个已存在的群组

<code>groupdel foo 	--&gt; 删除foo群组</code>
<h4 id="LinuxSystopic-46"> groups</h4>
查看用户所在群组

<code>groups lion 	--&gt; 查看 lion 用户所在的群组</code>
<h4 id="LinuxSystopic-47"> usermod</h4>
用于修改用户的账户。
【常用参数】

<code>-l</code> 对用户重命名。需要注意的是 <code>/home</code> 中的用户家目录的名字不会改变，需要手动修改。
<code>-g</code> 修改用户所在的群组，例如 <code>usermod -g friends lion </code> 修改 <code>lion</code> 用户的群组为 <code>friends</code> 。
<code>-G</code> 一次性让用户添加多个群组，例如 <code>usermod -G friends,foo,bar lion</code> 。
<code>-a</code> <code>-G</code> 会让你离开原先的群组，如果你不想这样做的话，就得再添加 <code>-a</code> 参数，意味着 <code>append</code> 追加的意思。

<h4 id="LinuxSystopic-48"> chgrp</h4>
用于修改文件的群组。

<code>chgrp bar file.txt	--&gt; file.txt文件的群组修改为bar</code>
<h4 id="LinuxSystopic-49"> chown</h4>
改变文件的所有者，需要 <code>root</code> 身份才能运行。

<code>chown lion file.txt	--&gt; 把其它用户创建的file.txt转让给lion用户
chown lion:bar file.txt	--&gt; 把file.txt的用户改为lion，群组改为bar</code>
【常用参数】

<code>-R</code> 递归设置子目录和子文件， <code>chown -R lion:lion /home/frank</code> 把 <code>frank</code> 文件夹的用户和群组都改为 <code>lion</code> 。

<h3 id="LinuxSystopic-50"> <k>文件权限管理</k></h3>
<h4 id="LinuxSystopic-51"> chmod</h4>
修改访问权限。

<code>chmod 740 file.txt</code>
【常用参数】

<code>-R</code> 可以递归地修改文件访问权限，例如 <code>chmod -R 777 /home/lion</code>

修改权限的确简单，但是理解其深层次的意义才是更加重要的。下面我们来系统的学习 <code>Linux</code> 的文件权限。

<code>
[root@lion ~]# ls -l
drwxr-xr-x 5 root root 4096 Apr 13  2020 climb
lrwxrwxrwx 1 root root    7 Jan 14 06:41 hello2.c -&gt; hello.c
-rw-r--r-- 1 root root  149 Jan 13 06:14 hello.c</code>
其中 <code>drwxr-xr-x</code> 表示文件或目录的权限。让我们一起来解读它具体代表什么？

<code>d</code> ：表示目录，就是说这是一个目录，普通文件是 <code>-</code> ，链接是 <code>l</code> 。
<code>r</code> ： <code>read</code> 表示文件可读。
<code>w</code> ： <code>write</code> 表示文件可写，一般有写的权限，就有删除的权限。
<code>x</code> ： <code>execute</code> 表示文件可执行。
<code>-</code> ：表示没有相应权限。

权限的整体是按用户来划分的，如下图所示：
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c70007a2d274cfe8e370fa1d66c7560~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
现在再来理解这句权限 <code>drwxr-xr-x</code> 的意思：

它是一个文件夹；
它的所有者具有：读、写、执行权限；
它的群组用户具有：读、执行的权限，没有写的权限；
它的其它用户具有：读、执行的权限，没有写的权限。

现在理解了权限，我们使用 <code>chmod</code> 来尝试修改权限。 <code>chmod</code> 它不需要是 <code>root</code> 用户才能运行的，只要你是此文件所有者，就可以用 <code>chmod</code> 来修改文件的访问权限。
<h5>数字分配权限</h5>





















<table><thead><tr><th align="center">权限</th><th align="center">数字</th></tr></thead><tbody><tr><td align="center">r</td><td align="center">4</td></tr><tr><td align="center">w</td><td align="center">2</td></tr><tr><td align="center">x</td><td align="center">1</td></tr></tbody></table>
因此要改变权限，只要做一些简单的加法就行：

<code>chmod 640 hello.c 

# 分析
6 = 4 + 2 + 0 表示所有者具有 rw 权限
4 = 4 + 0 + 0 表示群组用户具有 r 权限
0 = 0 + 0 + 0 表示其它用户没有权限

对应文字权限为：-rw-r-----</code>
<h5>用字母来分配权限</h5>

<code>u</code> ： <code>user</code> 的缩写，用户的意思，表示所有者。
<code>g</code> ： <code>group</code> 的缩写，群组的意思，表示群组用户。
<code>o</code> ： <code>other</code> 的缩写，其它的意思，表示其它用户。
<code>a</code> ： <code>all</code> 的缩写，所有的意思，表示所有用户。
<code>+</code> ：加号，表示添加权限。
<code>-</code> ：减号，表示去除权限。
<code>=</code> ：等于号，表示分配权限。


<code>chmod u+rx file	--&gt; 文件file的所有者增加读和运行的权限
chmod g+r file	--&gt; 文件file的群组用户增加读的权限
chmod o-r file	--&gt; 文件file的其它用户移除读的权限
chmod g+r o-r file	--&gt; 文件file的群组用户增加读的权限，其它用户移除读的权限
chmod go-r file	--&gt; 文件file的群组和其他用户移除读的权限
chmod +x file	--&gt; 文件file的所有用户增加运行的权限
chmod u=rwx,g=r,o=- file	--&gt; 文件file的所有者分配读写和执行的权限，群组其它用户分配读的权限，其他用户没有任何权限</code>
<h3 id="LinuxSystopic-52"> <k>查找文件</k></h3>
<h3 id="LinuxSystopic-53"> <k>locate</k></h3>
搜索包含关键字的所有文件和目录。后接需要查找的文件名，也可以用正则表达式。
<h4 id="LinuxSystopic-54"> 安装 locate</h4>

<code>yum -y install mlocate	--&gt; 安装包
updatedb	--&gt; 更新数据库</code>

<code>locate file.txt
locate fil*.txt</code>
[注意] <code>locate</code> 命令会去文件数据库中查找命令，而不是全磁盘查找，因此刚创建的文件并不会更新到数据库中，所以无法被查找到，可以执行 <code>updatedb</code> 命令去更新数据库。
<h3 id="LinuxSystopic-55"> <k>find</k></h3>
用于查找文件，它会去遍历你的实际硬盘进行查找，而且它允许我们对每个找到的文件进行后续操作，功能非常强大。

<code>find &lt;何处&gt; &lt;何物&gt; &lt;做什么&gt;</code>

何处：指定在哪个目录查找，此目录的所有子目录也会被查找。
何物：查找什么，可以根据文件的名字来查找，也可以根据其大小来查找，还可以根据其最近访问时间来查找。
做什么：找到文件后，可以进行后续处理，如果不指定这个参数， <code>find</code> 命令只会显示找到的文件。

<h4 id="LinuxSystopic-56"> 根据文件名查找</h4>

<code>find -name "file.txt"	--&gt; 当前目录以及子目录下通过名称查找文件
find . -name "syslog"	--&gt; 当前目录以及子目录下通过名称查找文件
find / -name "syslog"	--&gt; 整个硬盘下查找syslog
find /var/log -name "syslog"	--&gt; 在指定的目录/var/log下查找syslog文件
find /var/log -name "syslog*"	--&gt; 查找syslog1、syslog2 ... 等文件，通配符表示所有
find /var/log -name "*syslog*"	--&gt; 查找包含syslog的文件 </code>
[注意] <code>find</code> 命令只会查找完全符合 “何物” 字符串的文件，而 <code>locate</code> 会查找所有包含关键字的文件。
<h4 id="LinuxSystopic-57"> 根据文件大小查找</h4>

<code>find /var -size +10M	--&gt; /var 目录下查找文件大小超过 10M 的文件
find /var -size -50k	--&gt; /var 目录下查找文件大小小于 50k 的文件
find /var -size +1G	--&gt; /var 目录下查找文件大小查过 1G 的文件
find /var -size 1M	--&gt; /var 目录下查找文件大小等于 1M 的文件</code>
<h4 id="LinuxSystopic-58"> 根据文件最近访问时间查找</h4>

<code>find -name "*.txt" -atime -7 	--&gt; 近 7天内访问过的.txt结尾的文件</code>
<h4 id="LinuxSystopic-59"> 仅查找目录或文件</h4>

<code>find . -name "file" -type f 	--&gt; 只查找当前目录下的file文件
find . -name "file" -type d 	--&gt; 只查找当前目录下的file目录</code>
<h4 id="LinuxSystopic-60"> 操作查找结果</h4>

<code>find -name "*.txt" -printf "%p - %u\n"	--&gt; 找出所有后缀为txt的文件，并按照 %p - %u\n 格式打印，其中%p=文件名，%u=文件所有者
find -name "*.jpg" -delete	--&gt; 删除当前目录以及子目录下所有.jpg为后缀的文件，不会有删除提示，因此要慎用
find -name "*.c" -exec chmod 600 {} \;	--&gt; 对每个.c结尾的文件，都进行 -exec 参数指定的操作，{} 会被查找到的文件替代，\; 是必须的结尾
find -name "*.c" -ok chmod 600 {} \;	--&gt; 和上面的功能一直，会多一个确认提示</code>
<h3 id="LinuxSystopic-61"> <k>软件仓库</k></h3>
<code>Linux</code> 下软件是以包的形式存在，一个软件包其实就是软件的所有文件的压缩包，是二进制的形式，包含了安装软件的所有指令。 <code>Red Hat</code> 家族的软件包后缀名一般为 <code>.rpm</code> ， <code>Debian</code> 家族的软件包后缀是 <code>.deb</code> 。
<code>Linux</code> 的包都存在一个仓库，叫做软件仓库，它可以使用 <code>yum</code> 来管理软件包， <code>yum</code> 是 <code>CentOS</code> 中默认的包管理工具，适用于 <code>Red Hat</code> 一族。可以理解成 <code>Node.js</code> 的 <code>npm</code> 。
<h3 id="LinuxSystopic-62"> <k>yum 常用命令</k></h3>

<code>yum update | yum upgrade</code>  更新软件包
<code>yum search xxx</code> 搜索相应的软件包
<code>yum install xxx</code> 安装软件包
<code>yum remove xxx</code> 删除软件包

<h3 id="LinuxSystopic-63"> <k>切换 CentOS 软件源</k></h3>
有时候 <code>CentOS</code> 默认的 <code>yum</code> 源不一定是国内镜像，导致 <code>yum</code>  在线安装及更新速度不是很理想。这时候需要将 <code>yum</code> 源设置为国内镜像站点。国内主要开源的镜像站点是网易和阿里云。
1、首先备份系统自带 <code>yum</code> 源配置文件 <code>mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</code> 
2、下载阿里云的 <code>yum</code> 源配置文件到 <code>/etc/yum.repos.d/CentOS7</code> 

<code>wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</code>
3、生成缓存

<code>yum makecache</code>
<h3 id="LinuxSystopic-64"> <k>阅读手册</k></h3>
<code>Linux</code>  命令种类繁杂，我们凭借记忆不可能全部记住，因此学会查用手册是非常重要的。
<h3 id="LinuxSystopic-65"> <k>man</k></h3>
<h4 id="LinuxSystopic-66"> 安装更新 man</h4>

<code>sudo yum install -y man-pages	--&gt; 安装
sudo mandb	--&gt; 更新</code>
<h4 id="LinuxSystopic-67"> man 手册种类</h4>

可执行程序或 <code>Shell</code> 命令；
系统调用（ <code>Linux</code> 内核提供的函数）；
库调用（程序库中的函数）；
文件（例如 <code>/etc/passwd</code> ）；
特殊文件（通常在 <code>/dev</code> 下）；
游戏；
杂项（ <code>man(7)</code> ，<code>groff(7)</code> ）；
系统管理命令（通常只能被 <code>root</code> 用户使用）；
内核子程序。

<h4 id="LinuxSystopic-68"> man + 数字 + 命令</h4>
输入 man + 数字 + 命令/函数，可以查到相关的命令和函数，若不加数字， <code>man</code> 默认从数字较小的手册中寻找相关命令和函数

<code>man 3 rand 	--&gt; 表示在手册的第三部分查找 rand 函数
man ls 			--&gt; 查找 ls 用法手册</code>
man 手册核心区域解析：(以 <code>man pwd</code>  为例)

<code>NAME # 命令名称和简单描述
     pwd -- return working directory name

SYNOPSIS # 使用此命令的所有方法
     pwd [-L | -P]

DESCRIPTION # 包括所有参数以及用法
     The pwd utility writes the absolute pathname of the current working directory to the standard output.

     Some shells may provide a builtin pwd command which is similar or identical to this utility.  Consult the builtin(1) manual page.

     The options are as follows:

     -L      Display the logical current working directory.

     -P      Display the physical current working directory (all symbolic links resolved).

     If no options are specified, the -L option is assumed.

SEE ALSO # 扩展阅读相关命令
     builtin(1), cd(1), csh(1), sh(1), getcwd(3)</code>
<h3 id="LinuxSystopic-69"> <k>help</k></h3>
<code>man</code> 命令像新华词典一样可以查询到命令或函数的详细信息，但其实我们还有更加快捷的方式去查询， <code>command --help</code> 或 <code>command -h</code> ，它没有 <code>man</code> 命令显示的那么详细，但是它更加易于阅读。
<h3 id="LinuxSystopic-70"><span class="brown">Linux 进阶</span></h3>
<h3 id="LinuxSystopic-71"> <k>文本操作</k></h3>
<h3 id="LinuxSystopic-72"> <k>grep</k></h3>
全局搜索一个正则表达式，并且打印到屏幕。简单来说就是，在文件中查找关键字，并显示关键字所在行。<br>
<h4 id="LinuxSystopic-73"> 基础语法</h4>

<code>grep text file # text代表要搜索的文本，file代表供搜索的文件

# 实例

[root@lion ~]# grep path /etc/profile
pathmunge () {
    pathmunge /usr/sbin
    pathmunge /usr/local/sbin
    pathmunge /usr/local/sbin after
    pathmunge /usr/sbin after
unset -f pathmunge</code>
<h4 id="LinuxSystopic-74"> 常用参数</h4>

<code>-i</code> 忽略大小写， <code>grep -i path /etc/profile</code> 
<code>-n</code> 显示行号，<code>grep -n path /etc/profile</code>
<code>-v</code> 只显示搜索文本不在的那些行，<code>grep -v path /etc/profile</code>
<code>-r</code> 递归查找， <code>grep -r hello /etc</code> ，Linux 中还有一个 rgrep 命令，作用相当于 <code>grep -r</code> 

<h4 id="LinuxSystopic-75"> 高级用法</h4>
<code>grep</code> 可以配合正则表达式使用。<br>

<code>grep -E path /etc/profile --&gt; 完全匹配path
grep -E ^path /etc/profile --&gt; 匹配path开头的字符串
grep -E [Pp]ath /etc/profile --&gt; 匹配path或Path</code>
<h3 id="LinuxSystopic-76"> <k>sort</k></h3>
对文件的行进行排序。
<h4 id="LinuxSystopic-77"> 基础语法</h4>

<code>sort name.txt # 对name.txt文件进行排序</code>
<h4 id="LinuxSystopic-78"> 实例用法</h4>
为了演示方便，我们首先创建一个文件 <code>name.txt</code> ，放入以下内容：

<code>Christopher
Shawn
Ted
Rock
Noah
Zachary
Bella</code>
执行 <code>sort name.txt</code> 命令，会对文本内容进行排序。<br>
<h4 id="LinuxSystopic-79"> 常用参数</h4>

<code>-o</code> 将排序后的文件写入新文件， <code>sort -o name_sorted.txt name.txt</code> ；
<code>-r</code> 倒序排序， <code>sort -r name.txt</code> ；
<code>-R</code> 随机排序， <code>sort -R name.txt</code> ；
<code>-n</code> 对数字进行排序，默认是把数字识别成字符串的，因此 138 会排在 25 前面，如果添加了 <code>-n</code> 数字排序的话，则 25 会在 138 前面。

<h3 id="LinuxSystopic-80"> <k>wc</k></h3>
<code>word count</code> 的缩写，用于文件的统计。它可以统计单词数目、行数、字符数，字节数等。
<h4 id="LinuxSystopic-81"> 基础语法</h4>

<code>wc name.txt # 统计name.txt</code>
<h4 id="LinuxSystopic-82"> 实例用法</h4>

<code>
[root@lion ~]# wc name.txt 
13 13 91 name.txt</code>

第一个13，表示行数；
第二个13，表示单词数；
第三个91，表示字节数。

<h4 id="LinuxSystopic-83"> 常用参数</h4>

<code>-l</code> 只统计行数， <code>wc -l name.txt</code> ；
<code>-w</code> 只统计单词数， <code>wc -w name.txt</code> ；
<code>-c</code> 只统计字节数， <code>wc -c name.txt</code> ；
<code>-m</code> 只统计字符数， <code>wc -m name.txt</code> 。

<h3 id="LinuxSystopic-84"> <k>uniq</k></h3>
删除文件中的重复内容。<br>
<h4 id="LinuxSystopic-85"> 基础语法</h4>

<code>uniq name.txt # 去除name.txt重复的行数，并打印到屏幕上
uniq name.txt uniq_name.txt # 把去除重复后的文件保存为 uniq_name.txt</code>
【注意】它只能去除连续重复的行数。<br>
<h4 id="LinuxSystopic-86"> 常用参数</h4>

<code>-c</code> 统计重复行数， <code>uniq -c name.txt</code> ；
<code>-d</code> 只显示重复的行数， <code>uniq -d name.txt</code> 。

<h3 id="LinuxSystopic-87"> <k>cut</k></h3>
剪切文件的一部分内容。<br>
<h4 id="LinuxSystopic-88"> 基础语法</h4>

<code>cut -c 2-4 name.txt # 剪切每一行第二到第四个字符</code>
<h4 id="LinuxSystopic-89"> 常用参数</h4>

<code>-d</code> 用于指定用什么分隔符（比如逗号、分号、双引号等等） <code>cut -d , name.txt</code> ；
<code>-f</code> 表示剪切下用分隔符分割的哪一块或哪几块区域， <code>cut -d , -f 1 name.txt</code> 。

<h3 id="LinuxSystopic-90"> <k>重定向 管道 流</k></h3>
在 <code>Linux</code> 中一个命令的去向可以有3个地方：终端、文件、作为另外一个命令的入参。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd7a380444dc46ab9b934ec8a2533625~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"><br>命令一般都是通过键盘输入，然后输出到终端、文件等地方，它的标准用语是 <code>stdin</code> 、 <code>stdout</code> 以及 <code>stderr</code> 。<br>

标准输入 <code>stdin</code> ，终端接收键盘输入的命令，会产生两种输出；
标准输出 <code>stdout</code> ，终端输出的信息（不包含错误信息）；
标准错误输出 <code>stderr</code> ，终端输出的错误信息。

<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/524ef66fc56a4feb8a0ee4c0d5dab1d4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"><br>
<h3 id="LinuxSystopic-91"> <k>重定向</k></h3>
把本来要显示在终端的命令结果，输送到别的地方（到文件中或者作为其他命令的输入）。<br>
<h4 id="LinuxSystopic-92"> 输出重定向 <code>&gt;</code> </h4>
<code>&gt;</code> 表示重定向到新的文件， <code>cut -d , -f 1 notes.csv &gt; name.csv</code> ，它表示通过逗号剪切 <code>notes.csv</code> 文件（剪切完有3个部分）获取第一个部分，重定向到 <code>name.csv</code> 文件。<br>
<br>我们来看一个具体示例，学习它的使用，假设我们有一个文件 <code>notes.csv</code>  ，文件内容如下：

<code>Mark1,951/100,很不错1
Mark2,952/100,很不错2
Mark3,953/100,很不错3
Mark4,954/100,很不错4
Mark5,955/100,很不错5
Mark6,956/100,很不错6</code>
执行命令： <code>cut -d , -f 1 notes.csv &gt; name.csv</code> 最后输出如下内容：

<code>Mark1
...
Mark6</code>
【注意】使用 <code>&gt;</code> 要注意，如果输出的文件不存在它会新建一个，如果输出的文件已经存在，则会覆盖。因此执行这个操作要非常小心，以免覆盖其它重要文件。<br>
<h4 id="LinuxSystopic-93"> 输出重定向 <code>&gt;&gt;</code> </h4>
表示重定向到文件末尾，因此它不会像 <code>&gt;</code> 命令这么危险，它是追加到文件的末尾（当然如果文件不存在，也会被创建）。 <br>
<br>再次执行 <code>cut -d , -f 1 notes.csv &gt;&gt; name.csv</code> ，则会把名字追加到 <code>name.csv</code> 里面。

<code>Mark1
...
Mark6</code>
我们平时读的 <code>log</code> 日志文件其实都是用这个命令输出的。<br>
<h4 id="LinuxSystopic-94"> 输出重定向 <code>2&gt;</code> </h4>
标准错误输出

<code>cat not_exist_file.csv &gt; res.txt 2&gt; errors.log</code>

当我们 <code>cat</code> 一个文件时，会把文件内容打印到屏幕上，这个是标准输出；
当使用了 <code>&gt; res.txt</code> 时，则不会打印到屏幕，会把标准输出写入文件 <code>res.txt</code> 文件中；
<code>2&gt; errors.log</code> 当发生错误时会写入 <code>errors.log</code> 文件中。

<h4 id="LinuxSystopic-95"> 输出重定向 <code>2&gt;&gt;</code> </h4>
标准错误输出（追加到文件末尾）同 <code>&gt;&gt;</code> 相似。<br>
<h4 id="LinuxSystopic-96"> 输出重定向 <code>2&gt;&amp;1</code> </h4>
标准输出和标准错误输出都重定向都一个地方

<code>cat not_exist_file.csv &gt; res.txt 2&gt;&amp;1  # 覆盖输出
cat not_exist_file.csv &gt;&gt; res.txt 2&gt;&amp;1 # 追加输出</code>
<br>目前为止，我们接触的命令的输入都来自命令的参数，其实命令的输入还可以来自文件或者键盘的输入。<br>
<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d10f05e0cdbb413a9ed436ba54af2d60~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"><br>
<h4 id="LinuxSystopic-97"> 输入重定向 <code>&lt;</code> </h4>
<code>&lt;</code> 符号用于指定命令的输入。

<code>cat &lt; name.csv # 指定命令的输入为 name.csv</code>
虽然它的运行结果与 <code>cat name.csv</code> 一样，但是它们的原理却完全不同。<br>

<code>cat name.csv</code> 表示 <code>cat</code> 命令接收的输入是 <code>notes.csv</code> 文件名，那么要先打开这个文件，然后打印出文件内容。
<code>cat &lt; name.csv</code> 表示 <code>cat</code> 命令接收的输入直接是 <code>notes.csv</code> 这个文件的内容， <code>cat</code> 命令只负责将其内容打印，打开文件并将文件内容传递给 <code>cat</code> 命令的工作则交给终端完成。

<h4 id="LinuxSystopic-98"> 输入重定向 <code>&lt;&lt;</code> </h4>
将键盘的输入重定向为某个命令的输入。

<code>sort -n &lt;&lt; END # 输入这个命令之后，按下回车，终端就进入键盘输入模式，其中END为结束命令（这个可以自定义）

wc -m &lt;&lt; END # 统计输入的单词</code>
<h3 id="LinuxSystopic-99"> <k>管道 <code>|</code> </k></h3>
把两个命令连起来使用，一个命令的输出作为另外一个命令的输入，英文是 <code>pipeline</code> ，可以想象一个个水管连接起来，管道算是重定向流的一种。<br>
<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d46b974834864da2a734b42f5703d65c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"><br>
<br>举几个实际用法案例：

<code>cut -d , -f 1 name.csv | sort &gt; sorted_name.txt 
# 第一步获取到的 name 列表，通过管道符再进行排序，最后输出到sorted_name.txt

du | sort -nr | head 
# du 表示列举目录大小信息
# sort 进行排序,-n 表示按数字排序，-r 表示倒序
# head 前10行文件

grep log -Ir /var/log | cut -d : -f 1 | sort | uniq
# grep log -Ir /var/log 表示在log文件夹下搜索 /var/log 文本，-r 表示递归，-I 用于排除二进制文件
# cut -d : -f 1 表示通过冒号进行剪切，获取剪切的第一部分
# sort 进行排序
# uniq 进行去重</code>
<h3 id="LinuxSystopic-100"> <k>流</k></h3>
流并非一个命令，在计算机科学中，流 <code>stream</code> 的含义是比较难理解的，记住一点即可：<k>流就是读一点数据, 处理一点点数据。其中数据一般就是二进制格式。</k> 上面提及的重定向或管道，就是把数据当做流去运转的。<br>
<br>到此我们就接触了，流、重定向、管道等 <code>Linux</code> 高级概念及指令。其实你会发现关于流和管道在其它语言中也有广泛的应用。 <code>Angular</code> 中的模板语法中可以使用管道。 <code>Node.js</code> 中也有 <code>stream</code> 流的概念。<br>
<h3 id="LinuxSystopic-101"> <k>查看进程</k></h3>
在 <code>Windows</code> 中通过 <code>Ctrl + Alt + Delete</code> 快捷键查看软件进程。<br>
<h3 id="LinuxSystopic-102"> <k>w</k></h3>
帮助我们快速了解系统中目前有哪些用户登录着，以及他们在干什么。<br>

<code>
[root@lion ~]# w
 06:31:53 up 25 days,  9:53,  1 user,  load average: 0.00, 0.01, 0.05
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
root     pts/0    118.31.243.53    05:56    1.00s  0.02s  0.00s w
 
06:31:53：表示当前时间
up 25 days, 9:53：表示系统已经正常运行了“25天9小时53分钟”
1 user：表示一个用户
load average: 0.00, 0.01, 0.05：表示系统的负载，3个值分别表示“1分钟的平均负载”，“5分钟的平均负载”，“15分钟的平均负载”

 USER：表示登录的用于
 TTY：登录的终端名称为pts/0
 FROM：连接到服务器的ip地址
 LOGIN@：登录时间
 IDLE：用户有多久没有活跃了
 JCPU：该终端所有相关的进程使用的 CPU 时间，每当进程结束就停止计时，开始新的进程则会重新计时
 PCPU：表示 CPU 执行当前程序所消耗的时间，当前进程就是在 WHAT 列里显示的程序
 WHAT：表示当下用户正运行的程序是什么，这里我运行的是 w</code>
<h3 id="LinuxSystopic-103"> <k>ps</k></h3>
用于显示当前系统中的进程， <code>ps</code> 命令显示的进程列表不会随时间而更新，是静态的，是运行 <code>ps</code> 命令那个时刻的状态或者说是一个进程快照。<br>
<h4 id="LinuxSystopic-104"> 基础语法</h4>

<code>
[root@lion ~]# ps
  PID TTY          TIME CMD
 1793 pts/0    00:00:00 bash
 4756 pts/0    00:00:00 ps
 
 PID：进程号，每个进程都有唯一的进程号
 TTY：进程运行所在的终端
 TIME：进程运行时间
 CMD：产生这个进程的程序名，如果在进程列表中看到有好几行都是同样的程序名，那么就是同样的程序产生了不止一个进程</code>
<h4 id="LinuxSystopic-105"> 常用参数</h4>

<code>-ef</code> 列出所有进程;
<code>-efH</code> 以乔木状列举出所有进程;
<code>-u</code> 列出此用户运行的进程;
<code>-aux</code> 通过 <code>CPU</code> 和内存使用来过滤进程 <code>ps -aux | less</code> ;
<code>-aux --sort -pcpu</code> 按 <code>CPU</code> 使用降序排列， <code>-aux --sort -pmem</code> 表示按内存使用降序排列;
<code>-axjf</code> 以树形结构显示进程， <code>ps -axjf</code> 它和 <code>pstree</code> 效果类似。

<h3 id="LinuxSystopic-106"> <k>top</k></h3>
获取进程的动态列表。<br>

<code>top - 07:20:07 up 25 days, 10:41,  1 user,  load average: 0.30, 0.10, 0.07
Tasks:  67 total,   1 running,  66 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.7 us,  0.3 sy,  0.0 ni, 99.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem :  1882072 total,   552148 free,   101048 used,  1228876 buff/cache
KiB Swap:        0 total,        0 free,        0 used.  1594080 avail Mem 

  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                                                                                       
  956 root      10 -10  133964  15848  10240 S  0.7  0.8 263:13.01 AliYunDun                                                                                                     
    1 root      20   0   51644   3664   2400 S  0.0  0.2   3:23.63 systemd                                                                                                       
    2 root      20   0       0      0      0 S  0.0  0.0   0:00.05 kthreadd                                                                                                      
    4 root       0 -20       0      0      0 S  0.0  0.0   0:00.00 kworker/0:0H    </code>

<code>top - 07:20:07 up 25 days, 10:41,  1 user,  load average: 0.30, 0.10, 0.07</code> 相当 <code>w</code> 命令的第一行的信息。
展示的这些进程是按照使用处理器 <code>%CPU</code> 的使用率来排序的。

<h3 id="LinuxSystopic-107"> <k>kill</k></h3>
结束一个进程， <code>kill + PID</code> 。

<code>kill 956 # 结束进程号为956的进程
kill 956 957 # 结束多个进程
kill -9 7291 # 强制结束进程</code>
<h3 id="LinuxSystopic-108"> <k>管理进程</k></h3>
<h3 id="LinuxSystopic-109"> <k>进程状态</k></h3>
主要是切换进程的状态。我们先了解下 <code>Linux</code> 下进程的五种状态：

状态码 <code>R</code> ：表示正在运行的状态；
状态码 <code>S</code> ：表示中断（休眠中，受阻，当某个条件形成后或接受到信号时，则脱离该状态）；
状态码 <code>D</code> ：表示不可中断（进程不响应系统异步信号，即使用kill命令也不能使其中断）；
状态码 <code>Z</code> ：表示僵死（进程已终止，但进程描述符依然存在，直到父进程调用 <code>wait4()</code> 系统函数后将进程释放）；
状态码 <code>T</code> ：表示停止（进程收到 <code>SIGSTOP</code> 、 <code>SIGSTP</code> 、 <code>SIGTIN</code> 、 <code>SIGTOU</code> 等停止信号后停止运行）。

<h3 id="LinuxSystopic-110"> <k>前台进程 &amp; 后台进程</k></h3>
默认情况下，用户创建的进程都是前台进程，前台进程从键盘读取数据，并把处理结果输出到显示器。例如运行 <code>top</code> 命令，这就是一个一直运行的前台进程。
后台进程的优点是不必等待程序运行结束，就可以输入其它命令。在需要执行的命令后面添加 <code>&amp;</code> 符号，就表示启动一个后台进程。
<h3 id="LinuxSystopic-111"> <k>&amp;</k></h3>
启动后台进程，它的缺点是后台进程与终端相关联，一旦关闭终端，进程就自动结束了。

<code>cp name.csv name-copy.csv &amp;</code>
<h3 id="LinuxSystopic-112"> <k>nohup</k></h3>
使进程不受挂断（关闭终端等动作）的影响。

<code>nohup cp name.csv name-copy.csv</code>
<code>nohup</code> 命令也可以和 <code>&amp;</code> 结合使用。

<code>nohup cp name.csv name-copy.csv &amp;</code>
<h3 id="LinuxSystopic-113"> <k>bg</k></h3>
使一个“后台暂停运行”的进程，状态改为“后台运行”。

<code>bg %1 # 不加任何参数的情况下，bg命令会默认作用于最近的一个后台进程，如果添加参数则会作用于指定标号的进程</code>
实际案例1：

<code>1. 执行 grep -r "log" / &gt; grep_log 2&gt;&amp;1 命令启动一个前台进程，并且忘记添加 &amp; 符号
2. ctrl + z 使进程状态转为后台暂停
3. 执行 bg 将命令转为后台运行</code>
实际案例2：

<code>前端开发时我们经常会执行 yarn start 启动项目
此时我们执行 ctrl + z 先使其暂停
然后执行 bg 使其转为后台运行
这样当前终端就空闲出来可以干其它事情了，如果想要唤醒它就使用 fg 命令即可（后面会讲）</code>
<h3 id="LinuxSystopic-114"> <k>jobs</k></h3>
显示当前终端后台进程状态。

<code>
[root@lion ~]# jobs
[1]+  Stopped                 top
[2]-  Running                 grep --color=auto -r "log" / &gt; grep_log 2&gt;&amp;1 &amp;</code>
<h3 id="LinuxSystopic-115"> <k>fg</k></h3>
<code>fg</code> 使进程转为前台运行，用法和 <code>bg</code> 命令类似。<br>
<br>我们用一张图来表示前后台进程切换：<br>
<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81d8117fea314ddcb70754e15e4b25ad~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"><br>
<br>我们可以使程序在后台运行，成为后台进程，这样在当前终端中我们就可以做其他事情了，而不必等待此进程运行结束。<br>
<h3 id="LinuxSystopic-116"> <k>守护进程</k></h3>
一个运行起来的程序被称为进程。在 <code>Linux</code> 中有些进程是特殊的，它不与任何进程关联，不论用户的身份如何，都在后台运行，这些进程的父进程是 <code>PID</code> 为1的进程， <code>PID</code> 为1的进程只在系统关闭时才会被销毁。它们会在后台一直运行等待分配工作。我们将这类进程称之为守护进程 <code>daemon</code> 。
守护进程的名字通常会在最后有一个 <code>d</code> ，表示 <code>daemon</code> 守护的意思，例如 <code>systemd</code> 、<code>httpd</code> 。<br>
<h3 id="LinuxSystopic-117"> <k>systemd</k></h3>
<code>systemd</code> 是一个 <code>Linux</code> 系统基础组件的集合，提供了一个系统和服务管理器，运行为 <code>PID 1</code> 并负责启动其它程序。

<code>
[root@lion ~]# ps -aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.2  51648  3852 ?        Ss   Feb01   1:50 /usr/lib/systemd/systemd --switched-root --system --deserialize 22</code>
通过命令也可以看到 <code>PID</code> 为1的进程就是 <code>systemd</code> 的系统进程。<br>
<br><code>systemd</code> 常用命令（它是一组命令的集合）：

<code>systemctl start nginx # 启动服务
systemctl stop nginx # 停止服务
systemctl restart nginx # 重启服务
systemctl status nginx # 查看服务状态
systemctl reload nginx # 重载配置文件(不停止服务的情况)
systemctl enable nginx # 开机自动启动服务
systemctl disable nginx # 开机不自动启动服务
systemctl is-enabled nginx # 查看服务是否开机自动启动
systemctl list-unit-files --type=service # 查看各个级别下服务的启动和禁用情况</code>
<h3 id="LinuxSystopic-118"> <k>文件压缩解压</k></h3>

打包：是将多个文件变成一个总的文件，它的学名叫存档、归档。
压缩：是将一个大文件（通常指归档）压缩变成一个小文件。

<br>我们常常使用 <code>tar</code> 将多个文件归档为一个总的文件，称为 <code>archive</code> 。 然后用 <code>gzip</code> 或 <code>bzip2</code> 命令将 <code>archive</code> 压缩为更小的文件。<br>
<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d87434a4c414defb180b05d9bfca4c4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
<h3 id="LinuxSystopic-119"> <k>tar</k></h3>
创建一个 <code>tar</code> 归档。<br>
<h4 id="LinuxSystopic-120"> 基础用法</h4>

<code>tar -cvf sort.tar sort/ # 将sort文件夹归档为sort.tar
tar -cvf archive.tar file1 file2 file3 # 将 file1 file2 file3 归档为archive.tar</code>
<h4 id="LinuxSystopic-121"> 常用参数</h4>

<code>-cvf</code> 表示 <code>create</code>（创建）+ <code>verbose</code>（细节）+ <code>file</code>（文件），创建归档文件并显示操作细节；
<code>-tf</code> 显示归档里的内容，并不解开归档；
<code>-rvf</code> 追加文件到归档， <code>tar -rvf archive.tar file.txt</code> ；
<code>-xvf</code> 解开归档， <code>tar -xvf archive.tar</code> 。

<h3 id="LinuxSystopic-122"> <k>gzip / gunzip</k></h3>
“压缩/解压”归档，默认用 <code>gzip</code> 命令，压缩后的文件后缀名为 <code>.tar.gz</code> 。

<code>gzip archive.tar # 压缩
gunzip archive.tar.gz # 解压</code>
<h3 id="LinuxSystopic-123"> <k>tar 归档+压缩</k></h3>
可以用 <code>tar</code> 命令同时完成归档和压缩的操作，就是给 <code>tar</code> 命令多加一个选项参数，使之完成归档操作后，还是调用 <code>gzip</code> 或 <code>bzip2</code> 命令来完成压缩操作。

<code>tar -zcvf archive.tar.gz archive/ # 将archive文件夹归档并压缩
tar -zxvf archive.tar.gz # 将archive.tar.gz归档压缩文件解压</code>
<h3 id="LinuxSystopic-124"> <k>zcat、zless、zmore</k></h3>
之前讲过使用 <code>cat less more</code> 可以查看文件内容，但是压缩文件的内容是不能使用这些命令进行查看的，而要使用 <code>zcat、zless、zmore</code> 进行查看。

<code>zcat archive.tar.gz</code>
<h3 id="LinuxSystopic-125"> <k>zip/unzip</k></h3>
“压缩/解压” <code>zip</code> 文件（ <code>zip</code> 压缩文件一般来自 <code>windows</code> 操作系统）。<br>
<h4 id="LinuxSystopic-126"> 命令安装</h4>

<code># Red Hat 一族中的安装方式
yum install zip 
yum install unzip </code>
<h4 id="LinuxSystopic-127"> 基础用法</h4>

<code>unzip archive.zip # 解压 .zip 文件
unzip -l archive.zip # 不解开 .zip 文件，只看其中内容

zip -r sort.zip sort/ # 将sort文件夹压缩为 sort.zip，其中-r表示递归</code>
<h3 id="LinuxSystopic-128"> <k>编译安装软件</k></h3>
之前我们学会了使用 <code>yum</code> 命令进行软件安装，如果碰到 <code>yum</code> 仓库中没有的软件，我们就需要会更高级的软件安装“源码编译安装”。
<h3 id="LinuxSystopic-129"> <k>编译安装</k></h3>
简单来说，编译就是将程序的源代码转换成可执行文件的过程。大多数 <code>Linux</code> 的程序都是开放源码的，可以编译成适合我们的电脑和操纵系统属性的可执行文件。<br>
<br>基本步骤如下：

下载源代码
解压压缩包
配置
编译
安装

<h4 id="LinuxSystopic-130"> 实际案例</h4>
<h5>1、下载</h5>
我们来编译安装 <code>htop</code> 软件，首先在它的官网下载源码：<a href="https://link.juejin.cn?target=https%3A%2F%2Fbintray.com%2Fhtop%2Fsource%2Fhtop%23files" target="_blank" rel="nofollow noopener noreferrer" title="https://bintray.com/htop/source/htop#files" ref="nofollow noopener noreferrer">bintray.com/htop/source…</a><br>
<br>下载好的源码在本机电脑上使用如下命令同步到服务器上：

<code>scp 文件名 用户名@服务器ip:目标路径

scp ~/Desktop/htop-3.0.0.tar.gz root@121.42.11.34:.</code>
也可以使用 <code>wegt</code> 进行下载：

<code>wegt+下载地址

wegt https://bintray.com/htop/source/download_file?file_path=htop-3.0.0.tar.gz</code>
<h5>2、解压文件</h5>

<code>tar -zxvf htop-3.0.0.tar.gz # 解压

cd htop-3.0.0 # 进入目录</code>
<h5>3、配置</h5>
执行 <code>./configure</code> ，它会分析你的电脑去确认编译所需的工具是否都已经安装了。<br>
<h5>4、编译</h5>
执行 <code>make</code> 命令<br>
<h5>5、安装</h5>
执行 <code>make install</code> 命令，安装完成后执行 <code>ls /usr/local/bin/</code> 查看是否有 <code>htop</code> 命令。如果有就可以执行 <code>htop</code> 命令查看系统进程了。<br>
<h3 id="LinuxSystopic-131"> <k>网络</k></h3>
<h3 id="LinuxSystopic-132"> <k>ifconfig</k></h3>
查看 <code>ip</code> 网络相关信息，如果命令不存在的话， 执行命令 <code>yum install net-tools</code> 安装。

<code>
[root@lion ~]# ifconfig

eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500
        inet 172.31.24.78  netmask 255.255.240.0  broadcast 172.31.31.255
        ether 00:16:3e:04:9c:cd  txqueuelen 1000  (Ethernet)
        RX packets 1592318  bytes 183722250 (175.2 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 1539361  bytes 154044090 (146.9 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code>
参数解析：

<code>eth0</code> 对应有线连接（对应你的有线网卡），就是用网线来连接的上网。 <code>eth</code> 是 <code>Ethernet</code> 的缩写，表示“以太网”。有些电脑可能同时有好几条网线连着，例如服务器，那么除了 <code>eht0</code> ，你还会看到 <code>eth1</code> 、 <code>eth2</code> 等。
<code>lo</code> 表示本地回环（ <code>Local Loopback</code> 的缩写，对应一个虚拟网卡）可以看到它的 <code>ip</code> 地址是 <code>127.0.0.1</code> 。每台电脑都应该有这个接口，因为它对应着“连向自己的链接”。这也是被称之为“本地回环”的原因。所有经由这个接口发送的东西都会回到你自己的电脑。看起来好像并没有什么用，但有时为了某些缘故，我们需要连接自己。例如用来测试一个网络程序，但又不想让局域网或外网的用户查看，只能在此台主机上运行和查看所有的网络接口。例如在我们启动一个前端工程时，在浏览器输入 <code>127.0.0.1:3000</code> 启动项目就能查看到自己的 <code>web</code> 网站，并且它只有你能看到。
<code>wlan0</code> 表示无线局域网（上面案例并未展示）。

<h3 id="LinuxSystopic-133"> <k>host</k></h3>
<code>ip</code> 地址和主机名的互相转换。
<h4 id="LinuxSystopic-134"> 软件安装</h4>

<code>yum install bind-utils</code>
<h4 id="LinuxSystopic-135"> 基础用法</h4>

<code>
[root@lion ~]# host github.com
baidu.com has address 13.229.188.59
 

[root@lion ~]# host 13.229.188.59
59.188.229.13.in-addr.arpa domain name pointer ec2-13-229-188-59.ap-southeast-1.compute.amazonaws.com.</code>
<h3 id="LinuxSystopic-136"> <k>ssh 连接远程服务器</k></h3>
通过非对称加密以及对称加密的方式（同 <code>HTTPS</code> 安全连接原理相似）连接到远端服务器。

<code>ssh 用户@ip:port

1、ssh root@172.20.10.1:22 # 端口号可以省略不写，默认是22端口
2、输入连接密码后就可以操作远端服务器了</code>
<h4 id="LinuxSystopic-137"> 配置 ssh</h4>
<code>config</code> 文件可以配置 <code>ssh</code> ，方便批量管理多个 <code>ssh</code> 连接。<br>
<br>配置文件分为以下几种：

全局 <code>ssh</code> 服务端的配置： <code>/etc/ssh/sshd_config</code> ；
全局 <code>ssh</code> 客户端的配置： <code>/etc/ssh/ssh_config</code>（很少修改）；
当前用户 <code>ssh</code> 客户端的配置： <code>~/.ssh/config</code> 。

<br>【服务端 <code>config</code> 文件的常用配置参数】





























<table><thead><tr><th>服务端 config 参数</th><th>作用</th></tr></thead><tbody><tr><td>Port</td><td>sshd 服务端口号（默认是22）</td></tr><tr><td>PermitRootLogin</td><td>是否允许以 root 用户身份登录（默认是可以）</td></tr><tr><td>PasswordAuthentication</td><td>是否允许密码验证登录（默认是可以）</td></tr><tr><td>PubkeyAuthentication</td><td>是否允许公钥验证登录（默认是可以）</td></tr><tr><td>PermitEmptyPasswords</td><td>是否允许空密码登录（不安全，默认不可以）</td></tr></tbody></table>
[注意] 修改完服务端配置文件需要重启服务 <code>systemctl restart sshd</code> <br>
<br>【客户端 <code>config</code> 文件的常用配置参数】

























<table><thead><tr><th>客户端 config 参数</th><th>作用</th></tr></thead><tbody><tr><td>Host</td><td>别名</td></tr><tr><td>HostName</td><td>远程主机名（或 IP 地址）</td></tr><tr><td>Port</td><td>连接到远程主机的端口</td></tr><tr><td>User</td><td>用户名</td></tr></tbody></table>
<br>配置当前用户的 <code>config</code> ：

<code># 创建config
vim ~/.ssh/config

# 填写一下内容
Host lion # 别名
	HostName 172.x.x.x # ip 地址
  Port 22 # 端口
  User root # 用户</code>
这样配置完成后，下次登录时，可以这样登录 <code>ssh lion</code> 会自动识别为 <code>root</code> 用户。<br>
<br>[注意] 这段配置不是在服务器上，而是你自己的机器上，它仅仅是设置了一个别名。<br>
<h4 id="LinuxSystopic-138"> 免密登录</h4>
<code>ssh</code> 登录分两种，一种是基于口令（账号密码），另外一种是基于密钥的方式。<br>
<br>基于口令，就是每次登录输入账号和密码，显然这样做是比较麻烦的，今天主要学习如何基于密钥实现免密登录。<br>
<h5>基于密钥验证原理</h5>
客户机生成密钥对（公钥和私钥），把公钥上传到服务器，每次登录会与服务器的公钥进行比较，这种验证登录的方法更加安全，也被称为“公钥验证登录”。<br>
<h5>具体实现步骤</h5>
1、在客户机中生成密钥对（公钥和私钥） <code>ssh-keygen</code>（默认使用 RSA 非对称加密算法）<br>
<br>运行完 <code>ssh-keygen</code> 会在 <code>~/.ssh/</code> 目录下，生成两个文件：

<code>id_rsa.pub</code> ：公钥
<code>id_rsa</code> ：私钥

<br>2、把客户机的公钥传送到服务<br>
<br>执行 <code>ssh-copy-id root@172.x.x.x</code>（<code>ssh-copy-id</code> 它会把客户机的公钥追加到服务器 <code>~/.ssh/authorized_keys</code> 的文件中）。<br>
<br>执行完成后，运行 <code>ssh root@172.x.x.x</code> 就可以实现免密登录服务器了。
配合上面设置好的别名，直接执行 <code>ssh lion</code> 就可以登录，是不是非常方便。
<h3 id="LinuxSystopic-139"> <k>wget</k></h3>
可以使我们直接从终端控制台下载文件，只需要给出文件的HTTP或FTP地址。

<code>wget [参数][URL地址]

wget http://www.minjieren.com/wordpress-3.1-zh_CN.zip</code>
<code>wget</code> 非常稳定，如果是由于网络原因下载失败， <code>wget</code> 会不断尝试，直到整个文件下载完毕。<br>
<h4 id="LinuxSystopic-140"> 常用参数</h4>

<code>-c</code> 继续中断的下载。

<h3 id="LinuxSystopic-141"> <k>备份</k></h3>
<h3 id="LinuxSystopic-142"> <k>scp</k></h3>
它是 <code>Secure Copy</code> 的缩写，表示安全拷贝。 <code>scp</code> 可以使我们通过网络，把文件从一台电脑拷贝到另一台电脑。<br>
<br><code>scp</code> 是基于 <code>ssh</code> 的原理来运作的， <code>ssh</code> 会在两台通过网络连接的电脑之间创建一条安全通信的管道， <code>scp</code> 就利用这条管道安全地拷贝文件。

<code>scp source_file destination_file # source_file 表示源文件，destination_file 表示目标文件</code>
其中 <code>source_file</code> 和 <code>destination_file</code> 都可以这样表示： <code>user@ip:file_name</code> ， <code>user</code> 是登录名， <code>ip</code> 是域名或 <code>ip</code> 地址。 <code>file_name</code> 是文件路径。

<code>scp file.txt root@192.168.1.5:/root # 表示把我的电脑中当前文件夹下的 file.txt 文件拷贝到远程电脑
scp root@192.168.1.5:/root/file.txt file.txt # 表示把远程电脑上的 file.txt 文件拷贝到本机</code>
<h3 id="LinuxSystopic-143"> <k>rsync</k></h3>
<code>rsync</code> 命令主要用于远程同步文件。它可以同步两个目录，不管它们是否处于同一台电脑。它应该是最常用于“增量备份”的命令了。它就是智能版的 <code>scp</code> 命令。<br>
<h4 id="LinuxSystopic-144"> 软件安装</h4>

<code>yum install rsync</code>
<h4 id="LinuxSystopic-145"> 基础用法</h4>

<code>rsync -arv Images/ backups/ # 将Images 目录下的所有文件备份到 backups 目录下
rsync -arv Images/ root@192.x.x.x:backups/ # 同步到服务器的backups目录下</code>
<h4 id="LinuxSystopic-146"> 常用参数</h4>

<code>-a</code> 保留文件的所有信息，包括权限，修改日期等；
<code>-r</code> 递归调用，表示子目录的所有文件也都包括；
<code>-v</code> 冗余模式，输出详细操作信息。

<br>默认地， <code>rsync</code> 在同步时并不会删除目标目录的文件，例如你在源目录中删除一个文件，但是用 <code>rsync</code> 同步时，它并不会删除同步目录中的相同文件。如果向删除也可以这么做： <code>rsync -arv --delete Images/ backups/</code> 。<br>
<h3 id="LinuxSystopic-147"> <k>系统</k></h3>
<h3 id="LinuxSystopic-148"> <k>halt</k></h3>
关闭系统，需要 <code>root</code> 身份。

<code>halt</code>
<h3 id="LinuxSystopic-149"> <k>reboot</k></h3>
重启系统，需要 <code>root</code> 身份。

<code>reboot</code>
<h3 id="LinuxSystopic-150"> <k>poweroff</k></h3>
直接运行即可关机，不需要 <code>root</code> 身份。
<h3 id="LinuxSystopic-151"><span class="brown">Vim 编辑器</span></h3>
<h3 id="LinuxSystopic-152"> <k>Vim 是什么？</k></h3>
<code>Vim</code> 是从 <code>vi</code> 发展出来的一个文本编辑器。其代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。和 <code>Emacs</code> 并列成为类 <code>Unix</code> 系统用户最喜欢的编辑器。<br>
<h3 id="LinuxSystopic-153"> <k>Vim 常用模式</k></h3>

交互模式
插入模式
命令模式
可视模式

<h3 id="LinuxSystopic-154"> <k>交互模式</k></h3>
也成为正常模式，这是 <code>Vim</code> 的默认模式，每次运行 <code>Vim</code> 程序的时候，就会进入这个模式。<br>
<br>例如执行 <code>vim name.txt</code> 则会进入交互模式。<br>
<br>交互模式特征：

在这个模式下，你不能输入文本；
它可以让我们在文本间移动，删除一行文本，复制黏贴文本，跳转到指定行，撤销操作，等等。

<h3 id="LinuxSystopic-155"> <k>插入模式</k></h3>
这个模式是我们熟悉的文本编辑器的模式，就是可以输入任何你想输入的内容。进入这个模式有几种方法，最常用的方法是按字母键 <code>i</code> （ <code>i、I、a、A、o、O</code> 都可以进入插入模式，只是所处的位置不同），退出这种模式，只需要按下 <code>Esc</code> 键。<br>

<code>i, I</code> 进入输入模式 <code>Insert mode</code> ： <code>i</code> 为“从目前光标所在处输入”， <code>I</code> 为“在目前所在行的第一个非空格符处开始输入”；
<code>a, A</code> 进入输入模式 <code>Insert mode</code> ： <code>a</code> 为“从目前光标所在的下一个字符处开始输入”， <code>A</code> 为“从光标所在行的最后一个字符处开始输入”；
<code>o, O</code> 进入输入模式 <code>Insert mode</code> ： <code>o</code> 为“在目前光标所在的下一行处输入新的一行”； <code>O</code> 为在目前光标所在处的上一行输入新的一行。

<h3 id="LinuxSystopic-156"> <k>命令模式</k></h3>
命令模式也称为底线命令模式，这个模式下可以运行一些命令例如“退出”，“保存”，等动作。<br>
<br>也可以用这个模式来激活一些 <code>Vim</code> 配置，例如语法高亮，显示行号，等。甚至还可以发送一些命令给终端命令行，例如 <code>ls、cp</code> 。<br>
<br>为了进入命令模式，首先要进入交互模式，再按下冒号键。<br>
<br>用一张图表示三种模式如何切换：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a06645b200354e56b8295751c8abac3f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"><br>
<h3 id="LinuxSystopic-157"> <k>基本操作</k></h3>
<h3 id="LinuxSystopic-158"> <k>打开 Vim</k></h3>
在终端命令行中输入 <code>vim</code> 回车后 <code>Vim</code> 就会被运行起来，也可以用 <code>Vim</code> 来打开一个文件，只需要在 <code>vim</code> 后面再加文件名。如 <code>vim file.name</code> ，如果文件不存在，那么会被创建。<br>
<h3 id="LinuxSystopic-159"> <k>插入</k></h3>
进入文件之后，此时处于交互模式，可以通过输入 <code>i</code> 进入插入模式。<br>
<h3 id="LinuxSystopic-160"> <k>移动</k></h3>
在 <code>Vim</code> 的交互模式下，我们可以在文本中移动光标。<br>

<code>h</code> 向左移动一个字符
<code>j</code> 向下移动一个字符
<code>k</code> 向上移动一个字符
<code>i</code> 向右移动一个字符

<br>当然也可以使用四个方向键进行移动，效果是一样的。<br>
<h3 id="LinuxSystopic-161"> <k>跳至行首和行末</k></h3>

行首：在交互模式下，为了将光标定位到一行的开始位置，只需要按下数字键 <code>0</code> 即可，键盘上的 <code>Home</code> 键也有相同效果。
行末：在交互模式下，为了将光标定位到一行的末尾，只需要按下美元符号键 <code>$</code> 即可，键盘上的 <code>End</code> 键也有相同效果。

<h3 id="LinuxSystopic-162"> <k>按单词移动</k></h3>
在交互模式下，按字母键 <code>w</code> 可以一个单词一个单词的移动。<br>
<h3 id="LinuxSystopic-163"> <k>退出文件</k></h3>
在交互模式下，按下冒号键 <code>:</code> 进入命令模式，再按下 <code>q</code> 键，就可以退出了。<br>
<br>如果在退出之前又修改了文件，就直接想用 <code>:q</code> 退出 <code>Vim</code> ，那么 <code>Vim</code> 会显示一个红字标明错误信息。此时我们有两个选择：

保存并退出 <code>:wq</code>  或 <code>:x</code> ；
不保存且退出 <code>:q!</code> 。

<h3 id="LinuxSystopic-164"> <k>标准操作</k></h3>
<h3 id="LinuxSystopic-165"> <k>删除字符</k></h3>
在交互模式下，将光标定位到一个你想要删除的字符上，按下字母键 <code>x</code> 你会发现这个字符被删除了。<br>
<br>也可以一次性删除多个字符，只需要在按 <code>x</code> 键之前输入数字即可。<br>
<h3 id="LinuxSystopic-166"> <k>删除（剪切）单词，行</k></h3>

删除一行：连按两次 <code>d</code> 来删除光标所在的那一行。
删除多行：例如先输入数字 <code>2</code> ，再按下 <code>dd</code> ，就会删除从光标所在行开始的两行。
删除一个单词：将光标置于一个单词的首字母处，然后按下 <code>dw</code> 。
删除多个单词：例如先按数字键 <code>2</code> 再按 <code>dw</code> 就可以删除两个单词了。
从光标所在位置删除至行首： <code>d0</code> 。
从光标所在位置删除至行末： <code>d$</code> 。

<h3 id="LinuxSystopic-167"> <k>复制单词，行</k></h3>

复制行：按两次 <code>y</code> 会把光标所在行复制到内存中，和 <code>dd</code> 类似， <code>dd</code> 用于“剪切”光标所在行。
复制单词： <code>yw</code> 会复制一个单词。
复制到行末： <code>y$</code> 是复制从光标所在处到行末的所有字符。
复制到行首： <code>y0</code>  是复制光标所在处到行首的所有字符。

<h3 id="LinuxSystopic-168"> <k>粘贴</k></h3>
如果之前用 <code>dd</code> 或者 <code>yy</code> 剪切复制过来的，可以使用 <code>p</code> 来粘贴。同样也可以使用 <code>数字+p</code> 来表示复制多次。<br>
<h3 id="LinuxSystopic-169"> <k>替换一个字符</k></h3>
在交互模式下，将光标置于想要替换的字符上。按下 <code>r</code> 键，接着输入你要替换的字符即可。<br>
<h3 id="LinuxSystopic-170"> <k>撤销操作</k></h3>
如果要撤销最近的修改，只需要按下 <code>u</code> 键，如果想要撤销最近四次修改，可以按下4，再按下 <code>u</code> 。<br>
<h3 id="LinuxSystopic-171"> <k>重做</k></h3>
取消撤销，也就是重做之前的修改使用 <code>ctrl + r</code> 。<br>
<h3 id="LinuxSystopic-172"> <k>跳转到指定行</k></h3>
<code>Vim</code> 编辑的文件中，每一行都有一个行号，行号从1开始，逐一递增。<br>
<br>行号默认是不显示，如果需要它显示的话，可以进入命令模式，然后输入 <code>set nu</code> ，如果要隐藏行号的话，使用 <code>set nonu</code> 。<br>

跳转到指定行： <code>数字+gg</code> ，例如 <code>7gg</code> ，表示跳转到第7行。
要跳转到最后一行，按下 <code>G</code> 。
要跳转到第一行，按下 <code>gg</code> 。

<h3 id="LinuxSystopic-173"> <k>高级操作</k></h3>
<h3 id="LinuxSystopic-174"> <k>查找</k></h3>
处于交互模式下，按下 <code>/</code> 键，那么就进入查找模式，输入你要查找的字符串，然后按下回车。光标就会跳转到文件中下一个查找到的匹配处。如果字符串不存在，那么会显示 <code>"pattern not found"</code> 。<br>

<code>n</code> 跳转到下一个匹配项；
<code>N</code> 跳转到上一个匹配项。

<br>[注意] 用斜杠来进行的查找是从当前光标处开始向文件尾搜索，如果你要从当前光标处开始，向文件头搜索则使用 <code>?</code> ，当然也可以先按下 <code>gg</code> 跳转到第一行在进行全文搜索。<br>
<h3 id="LinuxSystopic-175"> <k>查找并替换</k></h3>
 <br>替换光标所在行第一个匹配的字符串：

<code># 语法
:s/旧字符串/新字符串

# 实例
:s/one/two</code>
替换光标所在行所有旧字符串为新字符串：

<code># 语法
:s/旧字符串/新字符串/g</code>
替换第几行到第几行中所有字符串：

<code># 语法
:n,m s/旧字符串/新字符串/g

# 实例
:2,4 s/one/two/g</code>
最常用的就是全文替换了：

<code># 语法
:%s/旧字符串/新字符串/g</code>
<h3 id="LinuxSystopic-176"> <k>合并文件</k></h3>
可以用冒号 <code>+r</code>  ( <code>:r</code> ) 实现在光标处插入一个文件的内容。

<code>:r filename # 可以用Tab键来自动补全另外一个文件的路径</code>
<h3 id="LinuxSystopic-177"> <k>分屏</k></h3>
<code>Vim</code> 有一个特别便捷的功能那就是分屏，可以同时打开好几个文件，分屏之后，屏幕每一块被称为一个 <code>viewport</code> ，表示“视口”。<br>

横向分屏 <code>:sp 文件名</code>
垂直分屏 <code>:vsp 文件名</code>

<h4 id="LinuxSystopic-178"> 分屏模式下的快捷键</h4>

<code>Ctrl + w</code> 再加 <code>Ctrl + w</code> ，表示从一个 <code>viewport</code> 移动光标到另外一个 <code>viewport</code> ；
<code>Ctrl + w</code> 再加 “方向键”，就可以移动到这个方向所处的下一个视口了；
<code>Ctrl + w</code> 再加 <code>+</code> 号，表示扩大当前视口；
<code>Ctrl + w</code> 再加 <code>-</code> 号，表示缩小当前视口；
<code>Ctrl + w</code> 再加 <code>=</code> 号，表示平均当前视口；
<code>Ctrl + w</code> 再加 <code>r</code> 键，会反向调换视口位置；
<code>Ctrl + w</code> 再加 <code>q</code> 键，会关闭当前视口；
<code>Ctrl + w</code> 再加 <code>o</code> 键，会关闭除当前视口以外的所有视口；

<h3 id="LinuxSystopic-179"> <k>运行外部命令 <code>:!</code></k></h3>
在 <code>Vim</code> 中可以运行一些终端命令，只要先输入 <code>:!</code> ，然后接命令名称。<br>
<br>例如：

<code>:!ls # 在Vim中打开的文件所在的目录运行ls命令</code>
<h3 id="LinuxSystopic-180"> <k>可视模式</k></h3>
前面只讲了 <code>Vim</code> 的三种模式，其实还有一种模式叫做可视模式。<br>
<br>进入它的三种方式（都是从交互模式开始）：

<code>v</code> 字符可视模式，进入后配合方向键选中字符后，然后再按 <code>d</code> 键可以删除选中。
<code>V</code> 行可视模式，进入后光标所在行默认被选中，然后再按 <code>d</code> 键可以删除所在行。
<code>Ctrl + v</code> 块可视模式，它是可视模式最有用的功能了，配合 <code>d</code>  和 <code>I</code> 键可以实现删除选中的内容和插入内容。

<br>同时选中多行，并在选中行头部插入内容的具体操作步骤：

<code>1. ctrl + v 进入块可视模式
2. 使用方向键进行选中（上下左右）假设选中5行
3. 输入 I 键进行多行同时插入操作
4. 插入完成后连续按两下 esc 键，实现多行同时插入相同字符</code>
进入可视模式之后的操作键：

<code>d</code> 键，表示删除选中；
<code>I</code> 键，表示在选中之前插入；
<code>u</code> 键，表示选中变为小写；
<code>U</code> 键，表示选中变为大写；

<h3 id="LinuxSystopic-181"> <k>Vim 配置</k></h3>
<h3 id="LinuxSystopic-182"> <k>选项参数</k></h3>
在 <code>Vim</code> 被启动后，可以运行一些指令来激活一些选项参数，但是这些选项参数的配置在退出 <code>Vim</code> 时会被忘记，例如前面讲解的激活行号。如果希望所在的配置是永久性的，那么需要在家目录（ <code>cd ~</code> ）创建一个 <code>Vim</code> 的配置文件 <code>.vimrc</code> 。<br>
<h3 id="LinuxSystopic-183"> <k>.vimrc</k></h3>

<code>set number " 显示行号
syntax on " 激活语法高亮
set showcmd " 实时看到输入的命令
set ignorecase " 搜索时不区分大小写
set mouse=a " 激活鼠标，用鼠标选中时相当于进入可视模式</code>
<code>Vim</code> 配置非常丰富，我们可以通过个性化配置把 <code>Vim</code> 打造成属于自己的 <code>IDE</code> 等等。在 <code>github</code> 上也可以搜索到一些强大的 <code>Vim</code> 配置文件。<br>

<h2>Linux Shell感叹号的妙用</h2>

<div id="exclamationtoc" class="toc"><a href="#exclamationtopic-0" target="_self">执行上一条命令</a><br><a href="#exclamationtopic-1" target="_self">使用第一个参数</a><br><a href="#exclamationtopic-2" target="_self">使用最后一个参数</a><br><a href="#exclamationtopic-3" target="_self">去掉最后一个参数</a><br><a href="#exclamationtopic-4" target="_self">使用所有的参数</a><br><a href="#exclamationtopic-5" target="_self">获取指定位置的参数</a><br><a href="#exclamationtopic-6" target="_self">删除尾路径和前导路径</a><br><a href="#exclamationtopic-7" target="_self">使用history中的命令</a><br><a href="#exclamationtopic-8" target="_self">执行倒数第N条命令</a><br><a href="#exclamationtopic-9" target="_self">执行上次指定关键字开头的命令</a><br><a href="#exclamationtopic-10" target="_self">执行包含指定关键字的命令</a><br><a href="#exclamationtopic-11" target="_self">替换上次指令中的关键字</a><br><a href="#exclamationtopic-12" target="_self">只查看不执行命令</a><br><a href="#exclamationtopic-13" target="_self">总结</a><br></div></center><br><br>

<h3 id="exclamationtopic-0">执行上一条命令</h3>如果想执行上次的命令，我们除了可以在控制台输入方向键向上的按键外，还可以使用<k>!!</k>
来执行上一次命令：
<k>
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#lsdump.rdbfilestest.shtmp
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#!!lsdump.rdbfilestest.shtmp</k>
如果我们想查看一个文件内容，但是可能忘记输入其他的管道命令，我们可以如下来使用：

<k>#忘记输入其他命令
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#cat111.txt1234#这一步可以补上
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#!!|grep'2'cat111.txt|grep'2'2</k>
是不是特别的方便。
<h3 id="exclamationtopic-1">使用第一个参数</h3>有时候我们输入了一长串的命令，有可能输入了很长的参数，然后再执行下一个命令的时候需要执行上一次的第一个参数，这个时候我们使用<k>!^</k>，
如下所示：
<k>
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#ls/root/tmp/ttt/temp.txt-al-rw-r--r--1rootroot6Dec110:20/root/tmp/ttt/temp.txt
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#cat!^cat/root/tmp/ttt/temp.txtHello</k>
<h3 id="exclamationtopic-2">使用最后一个参数</h3>与上面的相反，我们也可以使用<k>!$</k>
来获取上一个命令的最后一个参数，如下所示：

<k>
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#cat-A/root/tmp/ttt/temp.txtHello$
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#ls-al!$ls-al/root/tmp/ttt/temp.txt-rw-r--r--1rootroot6Dec110:20/root/tmp/ttt/temp.txt</k>
<h3 id="exclamationtopic-3">去掉最后一个参数</h3>如果想去掉上一个命令的最后一个参数，可以使用<k>!:-</k>，
如下所示：
<k>
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#cat/root/tmp/ttt/temp.txt-AHello$
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#!:-cat/root/tmp/ttt/temp.txtHello</k>
<em>注意：</em>
这个指令会将命令也会输出。
<h3 id="exclamationtopic-4">使用所有的参数</h3>有时候我们不小心将命令输入错误了，但是又不想重复的输入，或者使用退格键按半天，那么就可以使用<k>!*</k>
来获取所有参数，重新输入正确的指令，如下所示：
<k>
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#sl-al/root/tmp/ttt/temp.txt-bash:sl:commandnotfound
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#ls!*ls-al/root/tmp/ttt/temp.txt-rw-r--r--1rootroot6Dec110:20/root/tmp/ttt/temp.txt</k>
<h3 id="exclamationtopic-5">获取指定位置的参数</h3>如果想获取到上一个命令指定第N个参数，可以使用<k>!:N</k>，
如下所示：
<k>
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#ls/root/tmp/ttt/temp.txt-a-l-rw-r--r--1rootroot6Dec110:20/root/tmp/ttt/temp.txt#去除所有参数
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#!:0ls111.txtdump.rdbfilestest.shtmp#获取第一个参数
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#ls!:1ls/root/tmp/ttt/temp.txt/root/tmp/ttt/temp.txt</k>
也可以匹配最近指令的第N个参数，使用<k>!command:N</k>，
如下使用：

<k>
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#ls/root/tmp/ttt/temp.txt-a-l-rw-r--r--1rootroot6Dec110:20/root/tmp/ttt/temp.txt
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#cat/root/tmp/ttt/temp.txt-AHello$
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#ls!ls:3ls-ltotal24-rw-r--r--1rootroot8Dec110:11111.txt-rw-r--r--1rootroot4851Nov2021:42dump.rdbdrwxr-xr-x2rootroot4096Sep2016:21files</k>
相当于查找上一次<k>ls</k>
命令的参数了。
如果想获取多个参数的话，可以使用<k>!:N-M</k>，
如下所示：
<k>
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#cat/root/tmp/ttt/test.txt-A-b1Shell$
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#cat111.txt!:2-3cat111.txt-A-b11$22$33$44$</k>
还有下面的使用方法：

<k>#获取从第1个参数开始所有参数
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#cat!:1*cat111.txt-A-b11$22$33$44$#上同
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#cat!:1-$cat111.txt-A-b11$22$33$44$#
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#cat!:1-cat111.txt-A1$2$3$4$</k>
<h3 id="exclamationtopic-6">删除尾路径和前导路径</h3>我们可以移除路径的文件名，可以使用<k>!:$:h</k>，
如下所示：
<k>
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#ls/root/tmp/ttt/test.txt/root/tmp/ttt/test.txt
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#ls-l!:$:hls-l/root/tmp/ttttotal8-rw-r--r--1rootroot6Dec110:20temp.txt-rw-r--r--1rootroot6Dec111:11test.txt</k>
想删除掉文件后缀，可以使用<k>!:$:r</k>，
如下所示：
<k>
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#ls/root/111.txt/root/111.txt
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#ls-l!:$:rls-l/root/111total4-rw-r--r--1rootroot3Dec113:57hello.txt</k>
<h3 id="exclamationtopic-7">使用history中的命令</h3><k>history</k>
命令可以查看之前执行过的命令，除了使用方向键外，还可以使用感叹号<k>!N</k>，
如下所示：

<k>
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#history...1083ls-l1084ls/root/tmp/ttt/temp.txt-a-l1085cat/root/tmp/ttt/temp.txt-A1086ls-l1087history|more1088history#执行第1086条命令
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#!1086ls-ltotal24-rw-r--r--1rootroot8Dec110:11111.txt-rw-r--r--1rootroot4851Nov2021:42dump.rdbdrwxr-xr-x2rootroot4096Sep2016:21files</k>
<h3 id="exclamationtopic-8">执行倒数第N条命令，可以使用<k>!-N</k>，
如下所示：
</h3><k>
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#cat/root/tmp/ttt/temp.txt-AHello$
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#ls/root/tmp/ttt/temp.txt-a/root/tmp/ttt/temp.txt
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#!-2cat/root/tmp/ttt/temp.txt-AHello$</k>
<h3 id="exclamationtopic-9">执行上次指定关键字开头的命令</h3>如果想执行上一条以指定开头的命令，可以使用<k>!command</k>，
如下所示：
<k>
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#cat/root/tmp/ttt/temp.txt-AHello$
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#ls/root/tmp/ttt/temp.txt-a/root/tmp/ttt/temp.txt
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#!catcat/root/tmp/ttt/temp.txt-AHello$</k>
<h3 id="exclamationtopic-10">执行包含指定关键字的命令</h3>如果想执行上次包含指定关键字的命令，可以使用<k>!?command?</k>，
如下所示：

<k>
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#cat/root/tmp/ttt/temp.txt-AHello$
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#ls/root/tmp/ttt/temp.txt-a/root/tmp/ttt/temp.txt
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#!?at?cat/root/tmp/ttt/temp.txt-AHello$</k>
我们还可以使用<k>%</k>
来获取<k>!?command</k>
匹配的单词，如下所示：
<k>
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#ls/root/tmp/ttt/temp.txt/root/tmp/ttt/temp.txt
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#!?templs/root/tmp/ttt/temp.txt/root/tmp/ttt/temp.txt
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#cat!%cat/root/tmp/ttt/temp.txtHello</k>
<h3 id="exclamationtopic-11">替换上次指令中的关键字</h3>有时候我们输入了指令想重复执行，但是又想替换掉其中某些字符，可以使用<k>!:gs/old/new</k>，
如下所示：
<k>
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#cat/root/tmp/ttt/temp.txt-AHello$
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#!:gs/temp/test/cat/root/tmp/ttt/test.txt-AShell$</k>
如果已经成功执行了如上所示的替换，则可以使用<k>!:g&</k>
再次快速重复相同的替换。

<k>
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#tar-zcvftemp.tar.gz/root/tmp/ttt/test.txttar:Removingleading`/'frommembernames/root/tmp/ttt/test.txt
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#!:g&tar-zcvftest.tar.gz/root/tmp/ttt/test.txttar:Removingleading`/'frommembernames/root/tmp/ttt/test.txt
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#ls</k>
<h3 id="exclamationtopic-12">只查看不执行命令</h3>有时候我们不确定使用感叹号之后获得命令是否正确，可以使用<k>:p</k>
来查看替换后的命令：
<k>
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#tarcvfhome-dir.tar111.txttest.sh111.txttest.sh
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#tarcvfznew-file.tar!tar:3-:ptarcvfznew-file.tar111.txt
[root@iZ2zecnsfqf16bnmk6lrd1Z~]#ls111111.txtdump.rdbfileshome-dir.tartest.shtmp</k>
如上可以看到，真正的压缩命令并没有执行。
<h3 id="exclamationtopic-13">总结</h3>我们这里将上面所有的使用方法在此总结到一个表格中，方便大家查阅使用方法：
命令说明!
!执行上次命令
!^使用上次命令的第一个参数
!$使用上次命令的最后一个参数
!:-使用上次命令（包含命令），但去掉最后一个参数
!*使用上次命令的所有参数
!:N使用上次命令的第N个参数
!command使用上次指令开头的命令
!command:N使用上次指定命令的第N个参数（也可以用于上述命令组合，如!command:^）
!:N-M使用上次命令的第N-M的参数
!:1*使用上次命令的第1个参数开始的所有参数
!:1-$上同，使用上次命令的第1个参数到最后一个参数
!:1-使用上次命令的第1个参数到最后第二个参数的之间的所有参数
!:$:h使用上次命令的最后一个参数并移除尾随路径名
!:$:r使用上次命令的最后一个参数并移除后缀名
!N使用history中的第N个命令
!-N使用history中的最后第N个命令
!?command?使用上次指定关键词的命令
!%使用上次
!?command匹配的完整单词
!:gs/old/new替换上次命令中的关键词
!:g&如果上次替换成功，则使用上次替换的规则替换上一个命令中的关键词:p只查看并不执行感叹号替换后的命令（tar cvfz aaa.tar !tar:3-:p 并不会被执行）

<h2>6款Linux常用远程连接工具</h2>
<h3>Xshell</h3>
xshell 是一个非常强大的安全终端模拟软件，它支持 SSH1, SSH2, 以及 Windows 平台的 TELNET 协议。Xshell 可以在 Windows 界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的。
https://www.xshellcn.com/
<h3>SecureCRT</h3>
SecureCRT 支持 SSH，同时支持 Telnet 和 rlogin 协议。SecureCRT 是一款用于连接运行包括 Windows、UNIX 和 VMS 的理想工具。通过使用内含的 VCP 命令行程序可以进行加密文件的传输，网工应该很熟这个软件，经常使用它连接设备。
https://www.vandyke.com
<h3>WinSCP</h3>
WinSCP 是一个 Windows 环境下使用 SSH 的开源图形化 SFTP 工具客户端。同时支持 SCP 协议。它的主要功能就是在本地与远程计算机间安全地复制传输文件。
https://winscp.net/
<h3>PuTTY</h3>
PuTTY 是 SSH 和 telnet 客户端，最初由 Simon Tatham 为 Windows 平台开发。用 MIT 许可证授权。包含的组件有：PuTTY, PuTTYgen,PSFTP, PuTTYtel, Plink, PSCP, Pageant, 默认登录协议是 SSH，默认的端口为 22。
Putty 主要是用来远程连接服务器，它支持 SSH、Telnet、Serial 等协议的连接。
http://www.putty.org
<h3>MobaXterm</h3>
mobaxterm 的功能非常全面，几乎提供了所有重要的远程网络工具（比如 SSH、X11、RDP、VNC、FTP、MOSH 等），以及 Windows 桌面上的 Unix 命令（bash、ls、cat、sed、grep、awk、rsync 等），登录之后默认开启 sftp 模式。
http://mobaxterm.mobatek.net
大多企业运维都喜欢用它
<h3>FinalShell</h3>
FinalShell 是一体化的服务器网络管理软件 (java 语言编写)，不仅是 ssh 客户端，FinalShell 还是功能强大的开发、运维工具，充分满足用户的开发运维需求。
http://www.hostbuf.com/
可以直观的看出远程服务器的硬件运行情况












<script type='text/javascript' src='readbook.js'></script>
<script>
var lazyLoadInstance = new LazyLoad({
    elements_selector: ".lazy"
    // ... more custom settings?
});
</script>
</pre></body></html>
