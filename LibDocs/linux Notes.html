<base target="_blank"><html><head><title>linux notes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src="../lazyload.min.js"></script>
<script type='text/javascript' src='../mainscript.js'></script>
<script src="D:/Dropbox/Public/commonfunctions.js"></script>
<script>
  var showTopicNumber = true;
  var bookid = "linux notes" 
</script>
<style>
body{width:80%;margin-left: 10%; font-size:22px;}
h1, h2 {color: gold;}
strong {color: orange;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px;}
</style></head><body onkeypress="chkKey()"><center>
<h1></h1>
<a href="#mustWatch" class="red goldbs" target="_self">Must Watch!</a>
<br><br>
<div id="toc"></div></center>
<br><br>
<div id="mustWatch"><center><span class="red">MustWatch</span></center><br>

<a href="https://www.linuxjournal.com/content/diy-build-custom-minimal-linux-distribution-source" class="whitebut ">DIY: Build a Custom Minimal Linux Distribution from Source</a>
<a href="https://www.sohu.com/a/475114085_115128" class="whitebut ">“我花了 5 年时间编写自己的操作系统！” </a>

<a href="http://puppylinux.com/index.html" class="whitebut ">light weight BionicPup 32 Linux distros</a>

<a href="Linux 系统结构详解.html" class="whitebut ">Linux 系统结构详解</a>

<a href="An Introduction to the Linux.html" class="whitebut ">An Introduction to the Linux</a>
<a href="https://www.youtube.com/watch?v=SkB-eRCzWIU" class="whitebut ">Linux Terminal Introduction</a>
</div>
<pre>
<br>
<br>

<h2>#!</h2>
"#!" is an operator called shebang which directs the script to the interpreter location. 
So, if we use"#! /bin/sh" the script gets directed to the bourne-shell.


<a href="https://www.guru99.com/introduction-to-shell-scripting.html" class="whitebut ">Shell Script in Linux/Unix</a>


<a href="http://www.tutorialspoint.com/unix/unix-getting-started.htm" class="bordred1 borRad10">Unix - Getting Started</a>
<a href="http://www.comptechdoc.org/os/linux/usersguide/linux_ugbasics.html">Basic Linux</a>
<a href="http://man.linuxde.net/">Man Linux</a>
<br><br>
<a href="https://forums.linuxmint.com/viewtopic.php?t=97158"><span class="redsha">How to install software on Linux Mint</span></a>
<br>
<a href="https://www.lifewire.com/choose-best-linux-distro-for-needs-2201172">Choose The Best Linux Distro</a>
<a href="https://en.wikipedia.org/wiki/List_of_Linux_distributions">List of Linux distributions</a>
<br>

<a href="http://www.cygwin.com/">Linux Terminal on Windows</a>
<a href="http://ss64.com/bash/">Bash commands</a>


<a href="http://kevinboone.net/kbox.html">KBOX — a miniature Linux</a>

<a href="Convert Android to Linux.html">Convert Android to Linux</a>
<br>
<a href="https://www.androidauthority.com/an-introduction-to-basic4android-678630/">Basic4Android building Android apps</a>
<br>

<a href="http://linux.about.com/od/commands/tp/11-Linux-Terminal-Commands-That-Will-Rock-Your-World.01.htm">15 Linux Terminal Commands</a>



<br>
<a href="http://youtu.be/AO0jzD1hpXc">linux command line</a>
<br>
<a href="http://www.howtogeek.com/howto/14912/create-a-persistent-bootable-ubuntu-usb-flash-drive/">Create a Live Ubuntu USB Drive With Persistent Storage</a>
<br>

<h2>ubuntu KeyboardShortcuts</h2>
<a href="http://help.ubuntu.com/community/KeyboardShortcuts">ubuntu KeyboardShortcuts</a>
<a href="http://help.ubuntu.com/stable/ubuntu-help/shell-keyboard-shortcuts.html">ubuntu键盘快捷键</a>
<br>

<br>

<a href="http://opensource.com/article/17/2/command-line-tools-data-analysis-linux"><i class="redrose">10 Command-line Tools For Data Analysis In Linux</i></a>
<br>
<a href="http://www-uxsup.csx.cam.ac.uk/pub/doc/suse/suse9.0/userguide-9.0/ch24s04.html">Important Linux Commands</a>
<br>

<a href="http://opensource.com/article/17/2/linux-boot-and-startup"><b class="redbord">Introduction To The Linux Boot And Startup Processes</b></a>
<br>
<a href="LibDocs\Useful Shell Commands For Data Science.html">&diams;Useful Shell Commands For Data Science</a><br>
<a href="http://chuansong.me/account/LinuxHub">Linux爱好者</a>
<br>
<a href="http://chuansong.me/n/2274461349222">ln 命令教程</a>
<br>
<a href="https://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&mid=2666542070&idx=1&sn=35edea5336adf8f90edd378990b171a9&chksm=80dcf75db7ab7e4bc7e332a14c0c4d7db0384605956b0747481d9ea8b3f016eeb18e088530b5&scene=0#rd">给初学者的 type 命令教程</a>
<br>

<a href="https://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&mid=2666542083&idx=1&sn=9cf98a54d4cbfb71f28e1a3b859cd06a&chksm=80dcf0a8b7ab79be682047c2e6005658e0902c3319616aaa05d44f3f9262d79b070af9ae7808&mpshare=1&scene=1&srcid=04101cieV7TCBgTlfS8VrLHn&pass_ticket=ffHA2AbUubeZmNO0YwV710%2F%2F4ddlmoyHLacbjI9AFiSmoDbzHsy0wRqDu5yHGUGA#rd">10 个增加 UNIX/Linux Shell 脚本趣味的工具</a>
<br>
<a href="https://mp.weixin.qq.com/s?__biz=MzA4MjEyNTA5Mw==&mid=2652567459&idx=2&sn=234daf978537df5d0ec880b4995ef3f8&chksm=8464dfe9b31356ffe317d3d89adc593c329c215e9f33cc65738fd775bd5be5635adae20728a9&mpshare=1&scene=1&srcid=0410a3J2g7lgX8CNiQATAnzd&pass_ticket=ffHA2AbUubeZmNO0YwV710%2F%2F4ddlmoyHLacbjI9AFiSmoDbzHsy0wRqDu5yHGUGA#rd">Linux 启动过程分析</a>
<br>
<a href="https://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&mid=2666542052&idx=1&sn=1b42479e652f36bc5f3940033531dcc5&chksm=80dcf74fb7ab7e5914ca7edbcf0b22df8d0493d73930900944701b15c98a23f37abc995bdb01&mpshare=1&scene=1&srcid=0410P7JFsjA1mgXsos2RRyoU&pass_ticket=ffHA2AbUubeZmNO0YwV710%2F%2F4ddlmoyHLacbjI9AFiSmoDbzHsy0wRqDu5yHGUGA#rd">为初学者准备的 ln 命令教程（5 个示例）</a>
<br>
<br>
<a href="https://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&mid=2666542070&idx=1&sn=35edea5336adf8f90edd378990b171a9&chksm=80dcf75db7ab7e4bc7e332a14c0c4d7db0384605956b0747481d9ea8b3f016eeb18e088530b5&mpshare=1&scene=1&srcid=0410x0mWVNkLd4fk9xLGMsYs&pass_ticket=ffHA2AbUubeZmNO0YwV710%2F%2F4ddlmoyHLacbjI9AFiSmoDbzHsy0wRqDu5yHGUGA#rd">给初学者的 type 命令教程</a>
<br>
<a href="https://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&mid=2666542041&idx=1&sn=d4688e9df9a33b2c80b8ca2b7d08e508&chksm=80dcf772b7ab7e646985ce289660ed0e1925138a84136bbe0ffe1fc0836716e951fb580bb47a&mpshare=1&scene=1&srcid=0410oxyrfsSgRuesiYKfa8Qk&pass_ticket=ffHA2AbUubeZmNO0YwV710%2F%2F4ddlmoyHLacbjI9AFiSmoDbzHsy0wRqDu5yHGUGA#rd">升级到 Ubuntu 18.04 LTS 的理由，大波新特性到来</a>
<br>
<a href="https://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&mid=2666542031&idx=1&sn=748831d1d635a7873136aeac6ae1828a&chksm=80dcf764b7ab7e729f264f35c24b7992446d16528c29c9c754f8d4e4f7bb09184588ee9677e0&mpshare=1&scene=1&srcid=0410njlSIQFRMdcZ4Jl5hiqS&pass_ticket=ffHA2AbUubeZmNO0YwV710%2F%2F4ddlmoyHLacbjI9AFiSmoDbzHsy0wRqDu5yHGUGA#rd">如何在 Linux 上安装应用程序</a>
<br>
<a href="https://itsfoss.com/things-to-do-after-installing-linux-mint-18/">things-to-do-after-installing-linux-mint</a>
<br>
<a href="https://www.ubuntupit.com/top-10-best-things-installing-linux-mint-18-3-sylvia/">best-things-installing-linux-mint</a>

<h2>Important Linux Commands</h2>
<a href="http://www-uxsup.csx.cam.ac.uk/pub/doc/suse/suse9.0/userguide-9.0/index.html" class="whitebut ">SuSE Linux User Guide</a>
<a href="http://www-uxsup.csx.cam.ac.uk/pub/doc/suse/suse9.0/userguide-9.0/ch24.html" class="whitebut ">Chapter 24. Working with the Shell</a>

This section gives insight into the most important commands of your SuSE Linux system. 
Along with the individual commands, parameters are listed and, where appropriate, a typical sample application is introduced. 
To learn more about the various commands, it is usually possible to get additional information with the <b class="brown">man</b> program followed by the name of the command, for example, <b class="brown">man ls</b>.
In these <a href="http://www-uxsup.csx.cam.ac.uk/pub/doc/suse/suse9.0/userguide-9.0/go01.html#manpage"><i class="glossterm">manual pages</i></a>, move up and down with <b class="keycap">PgUp</b> and <b class="keycap">PgDn</b> and move between the beginning and the end of a document with <b class="keycap">Home</b> and <b class="keycap">End</b>. 
End this viewing mode by pressing <b class="keycap">Q</b>. 
Learn more about the <b class="brown">man</b> command itself with <b class="brown">man</b>.
There are many more commands than listed in this chapter. 
For information about other commands or more detailed information, we recommend the O'Reilly publication <span class="orange">Linux in a Nutshell</span>. 
In the following overview, the individual command elements are written in different typefaces.
<ul type="disc"><li>The actual command is always printed as <b class="brown">command</b>. 
Without this, nothing can function.
</li><li>Options without which the respective program cannot function are printed in <tt class="green">italics</tt>.
</li><li>Further details, like file names, which must be passed to a command for correct functioning, are written in the <span class="texttt">Courier</span> font.
</li><li>Specifications or parameters that are not required are placed in <tt class="green">[brackets]</tt>.
</li></ul>
Adjust possible specifications to your needs. 
It makes no sense to write <b class="brown">ls file(s)</b>, if no file named <tt class="green">file(s)</tt> actually exists. 
You can usually combine several parameters, for example, by writing <b class="brown">ls -la</b> instead of <b class="brown">ls -l -a</b>.

<h2>File Commands</h2><h2>File Administration Commands</h2>
<dl>
<dt><span class="brown"><b class="brown">ls</b> <tt class="green">[option(s)]</tt> <tt class="green">[file(s)]</tt></span> If you run <b class="brown">ls</b> without any additional parameters, the program will list the contents of the current directory in short form.
<dl>
<dt><span class="brown">-l</span> detailed list

<dt><span class="brown">-a</span> displays hidden files
</dd></dl>

<dt><span class="brown"><b class="brown">cp</b> <tt class="green">[option(s)]</tt> <tt class="green">sourcefile targetfile</tt></span> Copies <tt class="green">sourcefile</tt> to <tt class="green">targetfile</tt>.
<dl>
<dt><span class="brown">-i</span> Waits for confirmation, if necessary, before an existing <tt class="green">targetfile</tt> is overwritten

<dt><span class="brown">-r</span> Copies recursively (includes subdirectories)
</dd></dl>

<dt><span class="brown"><b class="brown">mv</b> <tt class="green">[option(s)]</tt> <tt class="green">sourcefile targetfile</tt></span> Copies <tt class="green">sourcefile</tt> to <tt class="green">targetfile</tt> then deletes the original <tt class="green">sourcefile</tt>.
<dl>
<dt><span class="brown">-b</span> Creates a backup copy of the <tt class="green">sourcefile</tt> before moving

<dt><span class="brown">-i</span> Waits for confirmation, if necessary, before an existing <span class="texttt">targetfile</span> is overwritten
</dd></dl>

<dt><span class="brown"><b class="brown">rm</b> <tt class="green">[option(s)]</tt> <tt class="green">file(s)</tt></span> Removes the specified files from the file system. 
Directories are not removed by <b class="brown">rm</b> unless the option <tt class="green">-r</tt> is used.
<dl>
<dt><span class="brown">-r</span> Deletes any existing subdirectories

<dt><span class="brown">-i</span> Waits for confirmation before deleting each file.
</dd></dl>

<dt><span class="brown"><b class="brown">ln</b> <tt class="green">[option(s)]</tt> <tt class="green">sourcefile</tt> <tt class="green">targetfile</tt></span> Creates an internal <a href="http://www-uxsup.csx.cam.ac.uk/pub/doc/suse/suse9.0/userguide-9.0/go01.html#link"><i class="glossterm">link</i></a> from the <tt class="green">sourcefile</tt> to the <tt class="green">targetfile</tt>, under a different name. 
Normally, such a link points directly to the <tt class="green">sourcefile</tt> on one and the same file system. 
However, if <b class="brown">ln</b> is executed with the <tt class="green">-s</tt> option, it creates a symbolic link that only points to the directory where the <tt class="green">sourcefile</tt> is located, thus enabling linking across file systems.
<dl>
<dt><span class="brown">-s</span> Creates a symbolic link
</dd></dl>

<dt><span class="brown"><b class="brown">cd</b> <tt class="green">[options(s)]</tt> <tt class="green">[directory]</tt></span> Changes the current directory. 
<b class="brown">cd</b> without any parameters changes to the user's home directory.

<dt><span class="brown"><b class="brown">mkdir</b> <tt class="green">[option(s)]</tt> <tt class="green">directoryname</tt></span> Creates a new directory.

<dt><span class="brown"><b class="brown">rmdir</b> <tt class="green">[option(s)]</tt> <tt class="green">directoryname</tt></span> Deletes the specified directory, provided it is already empty.

<dt><span class="brown"><b class="brown">chown</b> <tt class="green">[option(s)] username.group</tt> <tt class="green">file(s)</tt></span> Transfers the ownership of a file to the user with the specified user name.
<dl>
<dt><span class="brown">-R</span> Changes files and directories in all subdirectories.
</dd></dl>

<dt><span class="brown"><b class="brown">chgrp</b> <tt class="green">[option(s)] groupname</tt> <tt class="green">file(s)</tt></span> Transfers the group ownership of a given <tt class="green">file</tt> to the group with the specified group name. 
The file owner can only change group ownership if a member of both the existing and the new group.

<dt><span class="brown"><b class="brown">chmod</b> <tt class="green">[options]</tt> <tt class="green">mode</tt> <tt class="green">file(s)</tt></span> Changes the access permissions.
The <tt class="green">mode</tt> parameter has three parts: <tt class="green">group</tt>, <tt class="green">access</tt>, and <tt class="green">access type</tt>. 
<tt class="green">group</tt> accepts the following characters:
<dl>
<dt><span class="brown">u</span> user

<dt><span class="brown">g</span> group

<dt><span class="brown">o</span> others
</dd></dl>
For <tt class="green">access</tt>, access is granted by the <tt class="green">+</tt> symbol and denied by the <tt class="green">-</tt> symbol.
The <tt class="green">access type</tt> is controlled by the following options:
<dl>
<dt><span class="brown">r</span> read

<dt><span class="brown">w</span> write

<dt><span class="brown">x</span> eXecute &#8212; executing files or changing to the directory.

<dt><span class="brown">s</span> Set uid bit &#8212; the application or program is started as if it were started by the owner of the file.
</dd></dl>

<dt><span class="brown"><b class="brown">gzip</b> <tt class="green">[parameters]</tt> <tt class="green">file(s)</tt></span> This program compresses the contents of files, using complex mathematical algorithms. 
Files compressed in this way are given the extension <tt class="green">.gz</tt> and need to be uncompressed before they can be used. 
 To compress several files or even entire directories, use the <b class="brown">tar</b> command.
<dl>
<dt><span class="brown">-d</span> decompresses the packed gzip files so they return to their original size and can be processed normally (like the command <b class="brown">gunzip</b>).
</dd></dl>

<dt><span class="brown"><b class="brown">tar</b> <tt class="green">options</tt> <tt class="green">archive</tt> <tt class="green">file(s)</tt></span> The <b class="brown">tar</b> puts one file or (usually) several files into an archive. 
Compression is optional.
<b class="brown">tar</b> is a quite complex command with a number of options available. 
The most frequently used options are:
<dl>
<dt><span class="brown">-f</span> Writes the output to a file and not to the screen as is usually the case

<dt><span class="brown">-c</span> Creates a new tar archive

<dt><span class="brown">-r</span> Adds files to an existing archive

<dt><span class="brown">-t</span> Outputs the contents of an archive

<dt><span class="brown">-u</span> Adds files, but only if they are newer than the files already contained in the archive

<dt><span class="brown">-x</span> Unpacks files from an archive (<i class="wordasword">extraction</i>)

<dt><span class="brown">-z</span> Packs the resulting archive with <b class="brown">gzip</b>

<dt><span class="brown">-j</span> Compresses the resulting archive with <b class="brown">bzip2</b>

<dt><span class="brown">-v</span> Lists files processed
</dd></dl>
The archive files created by <b class="brown">tar</b> end with <tt class="green">.tar</tt>. 
If the tar archive was also compressed using <b class="brown">gzip</b>, the ending is <tt class="green">.tgz</tt> or <tt class="green">.tar.gz</tt>. 
If it was compressed using <b class="brown">bzip2</b>, <tt class="green">.tar.bz2</tt>.
Application examples can be found in Section <a href="http://www-uxsup.csx.cam.ac.uk/pub/doc/suse/suse9.0/userguide-9.0/ch24s02.html#sec:bash.tar" title="Archives and Data Compression">&#8220;Archives and Data Compression&#8221;</a>.

<dt><span class="brown"><b class="brown">locate</b> <tt class="green">pattern(s)</tt></span> The <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">locate</span></span> command can find in which directory a specified file is located. 
If desired, use <a href="http://www-uxsup.csx.cam.ac.uk/pub/doc/suse/suse9.0/userguide-9.0/go01.html#wildcard"><i class="glossterm">wild cards</i></a> to specify file names. 
The program is very speedy, as it uses a database specifically created for the purpose (rather than searching through the entire file system). 
This very fact, however, also results in a major drawback: <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">locate</span></span> is unable to find any files created after the latest update of its database.
The database can be generated by <tt class="systemitem">root</tt> with <b class="brown">updatedb</b>.

<dt><span class="brown"><b class="brown">updatedb</b> <tt class="green">[options(s)]</tt></span> This command performs an update of the database used by <b class="brown">locate</b>. 
To include files in all existing directories, run the program as <tt class="systemitem">root</tt>. 
It also makes sense to place it in the background by appending an ampersand (<tt class="systemitem">&amp;</tt>), so you can immediately continue working on the same command line (<b class="brown">updatedb &amp;</b>).

<dt><span class="brown"><b class="brown">find</b> <tt class="green">[option(s)]</tt></span> The <b class="brown">find</b> command allows you to search for a file in a given directory. 
The first argument specifies the directory in which to start the search. 
The option <b class="brown">-name</b> must be followed by a search string, which may also include <a href="http://www-uxsup.csx.cam.ac.uk/pub/doc/suse/suse9.0/userguide-9.0/go01.html#wildcard"><i class="glossterm">wild cards</i></a>. 
Unlike <b class="brown">locate</b>, which uses a database, <b class="brown">find</b> scans the actual directory.
</dd></dl>
<h2>Commands to Access File Contents Commands</h2>
<dl>
<dt><span class="brown"><b class="brown">cat</b> <tt class="green">[option(s)]</tt> <tt class="green">file(s)</tt></span> The <b class="brown">cat</b> command displays the contents of a file, printing the entire contents to the screen without interruption.
<dl>
<dt><span class="brown">-n</span> Numbers the output on the left margin
</dd></dl>

<dt><span class="brown"><b class="brown">less</b> <tt class="green">[option(s)]</tt> <tt class="green">file(s)</tt></span> This command can be used to browse the contents of the specified file. 
Scroll half a screen page up or down with <b class="keycap">PgUp</b> and <b class="keycap">PgDn</b> or a full screen page down with <b class="keycap">Space</b>. 
Jump to the beginning or end of a file using <b class="keycap">Home</b> and <b class="keycap">End</b>. 
Press <b class="keycap">Q</b> to exit the program.

<dt><span class="brown"><b class="brown">grep</b> <tt class="green">[option(s)]</tt> <tt class="green">searchstring</tt> <tt class="green">filenames</tt></span> The <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">grep</span></span> command finds a specific <tt class="green">searchstring</tt> in the specified <tt class="green">file(s)</tt>. 
If the search string is found, the command displays the line in which the <tt class="green">searchstring</tt> was found along with the file name.
<dl>
<dt><span class="brown">-i</span> Ignores case

<dt><span class="brown">-l</span> Only displays the names of the respective files, but not the text lines

<dt><span class="brown">-n</span> Additionally displays the numbers of the lines in which it found a hit

<dt><span class="brown">-l</span> Only lists the files in which <span class="orange">searchstring</span> does <span class="textbf">not</span> occur
</dd></dl>

<dt><span class="brown"><b class="brown">diff</b> <tt class="green">[option(s)]</tt> <tt class="green">file1 file2</tt></span> The <b class="brown">diff</b> command compares the contents of any two files. 
The output produced by the program lists all lines that do not match.
This is frequently used by programmers who need only send their program alterations and not the entire source code.
<dl>
<dt><span class="brown">-q</span> Only reports <span class="emphasis"><em>whether</em></span> the two given files differ
</dd></dl>
</dd></dl>
<h2>File Systems Commands</h2>
<dl>
<dt><span class="brown"><b class="brown">mount</b> <tt class="green">[option(s)] [&lt;device&gt;]</tt> <tt class="green">mountpoint</tt></span> This command can be used to mount any data media, such as hard disks, CD-ROM drives, and other drives, to a directory of the Linux file system.
<dl>
<dt><span class="brown">-r</span> mount read-only

<dt><span class="brown">-t filesystem</span> Specifies the file system. 
The most common are <tt class="green">ext2</tt> for Linux hard disks, <tt class="green">msdos</tt> for MS-DOS media, <tt class="green">vfat</tt> for the Windows file system, and <tt class="green">iso9660</tt> for CDs.
</dd></dl>
For hard disks not defined in the file <tt class="green">/etc/fstab</tt>, the device type must also be specified. 
In this case, only <tt class="systemitem">root</tt> can mount. 
If the file system should also be mounted by other users, enter the option <tt class="green">user</tt> in the appropriate line in the <tt class="green">/etc/fstab</tt> file (separated by commas) and save this change. 
Further information is available in <span class="citerefentry"><span class="refentrytitle">mount</span></span>.

<dt><span class="brown"><b class="brown">umount</b> <tt class="green">[option(s)]</tt> <tt class="green">mountpoint</tt></span> This command unmounts a mounted drive from the file system. 
To prevent data loss, run this command before taking a removable data medium from its drive. 
Normally, only <tt class="systemitem">root</tt> is allowed to run the commands <b class="brown">mount</b> and <b class="brown">umount</b>. 
To enable other users to run these commands, edit the <tt class="green">/etc/fstab</tt> file to specify the option <tt class="green">user</tt> for the respective drive.
</dd></dl>


<h2>System Commands</h2><h2>System Information Commands</h2>
<dl>
<dt><span class="brown"><b class="brown">df</b> <tt class="green">[option(s)]</tt> <tt class="green">[directory]</tt></span> The <b class="brown">df</b> (disk free) command, when used without any options, displays information about the total disk space, the disk space currently in use, and the free space on all the mounted drives. 
If a directory is specified, the information is limited to the drive on which that directory is located.
<dl>
<dt><span class="brown">-H</span> shows the number of occupied blocks in gigabytes, megabytes, or kilobytes &#8212; in human-readable format

<dt><span class="brown">-t</span> Type of file system (ext2, nfs, etc.)
</dd></dl>

<dt><span class="brown"><b class="brown">du</b> <tt class="green">[option(s)]</tt> <tt class="green">[path]</tt></span> This command, when executed without any parameters, shows the total disk space occupied by files and subdirectories in the current directory.
<dl>
<dt><span class="brown">-a</span> Displays the size of each individual file

<dt><span class="brown">-h</span> Output in human-readable form

<dt><span class="brown">-s</span> Displays only the calculated total size
</dd></dl>

<dt><span class="brown"><b class="brown">free</b> <tt class="green">[option(s)]</tt></span> The command <b class="brown">free</b> displays information about RAM and swap space usage, showing the total and the used amount in both categories.
<dl>
<dt><span class="brown">-b</span> Output in bytes

<dt><span class="brown">-k</span> Output in kilobytes

<dt><span class="brown">-m</span> Output in megabytes
</dd></dl>

<dt><span class="brown"><b class="brown">date</b> <tt class="green">[option(s)]</tt></span> This simple program displays the current system time. 
If run as <tt class="systemitem">root</tt>, it can also be used to change the system time. 
Details about the program are available in <span class="citerefentry"><span class="refentrytitle">date</span></span>.
</dd></dl>
<h2>Processes Commands</h2>
<dl>
<dt><span class="brown"><b class="brown">top</b> <tt class="green">[options(s)]</tt></span> <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">top</span></span> provides a quick overview of the currently running <a href="http://www-uxsup.csx.cam.ac.uk/pub/doc/suse/suse9.0/userguide-9.0/go01.html#process"><i class="glossterm">processes</i></a>. 
Press <b class="keycap">H</b> to access a page that briefly explains the main options to customize the program.

<dt><span class="brown"><b class="brown">ps</b> <tt class="green">[option(s)] [process ID]</tt></span> If run without any options, this command displays a table of all <i class="wordasword">your own</i> programs or processes &#8212; those you started. 
The options for this command are <span class="textbf">not</span> preceded by hyphen.
<dl>
<dt><span class="brown">aux</span> Displays a detailed list of all processes, independent of the owner.
</dd></dl>

<dt><span class="brown"><b class="brown">kill</b> <tt class="green">[option(s)]</tt> <tt class="green">process ID</tt></span> Unfortunately, sometimes a program cannot be terminated in the normal way. 
However, in most cases, you should still be able to stop such a runaway program by executing the <b class="brown">kill</b> command, specifying the respective process ID (see <b class="brown">top</b> and <b class="brown">ps</b>).
<b class="brown">kill</b> sends a <i class="wordasword">TERM</i> signal that instructs the program to shut itself down. 
If this does not help, the following parameter can be used:
<dl>
<dt><span class="brown">-9</span> Sends a <i class="wordasword">KILL</i> signal instead of a <i class="wordasword">TERM</i> signal, with which the process really is <i class="wordasword">annihilated</i> by the operating system. 
This brings the specific processes to an end in almost all cases.
</dd></dl>

<dt><span class="brown"><b class="brown">killall</b> <tt class="green">[option(s)] processname</tt></span> This command is similar to <b class="brown">kill</b>, but uses the process name (instead of the process ID) as an argument, causing all processes with that name to be killed.
</dd></dl>
<h2>Network Commands</h2>
<dl>
<dt><span class="brown"><b class="brown">ping</b> <tt class="green">[option(s)]</tt> <tt class="green">host name|IP address</tt></span> The <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">ping</span></span> command is the standard tool for testing the basic functionality of TCP/IP networks. 
It sends a small data packet to the destination host, requesting an immediate reply. 
If this works, <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">ping</span></span> displays a message to that effect, which indicates that the network link is basically functioning.
<dl>
<dt><span class="brown">-c</span> <tt class="green">number</tt> Determines the total number of packages to send and ends after they have been dispatched. 
By default, there is no limitation set.

<dt><span class="brown">-f</span> <i class="wordasword">flood ping</i>: sends as many data packages as possible. 
A popular means, reserved to <tt class="systemitem">root</tt>, to test networks.

<dt><span class="brown">-i</span> <tt class="green">value</tt> Specifies the interval between two data packages in seconds. 
Default: one second
</dd></dl>

<dt><span class="brown"><b class="brown">nslookup</b></span> The Domain Name System resolves domain names to IP addresses. 
With this tool, send queries to information servers (DNS servers).

<dt><span class="brown"><b class="brown">telnet</b> <tt class="green">[option(s)] host name or IP address</tt></span> Telnet is actually an Internet protocol that enables you to work on remote hosts across a network. 
<span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">telnet</span></span> is also the name of a Linux program that uses this protocol to enable operations on remote computers. 

<h3>Warning</h3>Do not use telnet over a network on which third parties can <i class="wordasword">eavesdrop.</i> Particularly on the Internet, use encrypted transfer methods, such as <b class="brown">ssh</b>, to avoid the risk of malicious misuse of a password (see the man page for <b class="brown">ssh</b>).

</dd></dl>
<h2>Miscellaneous Commands</h2>
<dl>
<dt><span class="brown"><b class="brown">passwd</b> <tt class="green">[option(s)] [username]</tt></span> Users may change their own passwords at any time using this command. 
Furthermore, the administrator <tt class="systemitem">root</tt> can use the command to change the password of any user on the system.

<dt><span class="brown"><b class="brown">su</b> <tt class="green">[option(s)]</tt> <tt class="green">[username]</tt></span> The <b class="brown">su</b> command makes it possible to log in under a different user name from a running session. 
When using the command without specifying a user name, you will be prompted for the <tt class="systemitem">root</tt> password. 
Specify a user name and the corresponding password to use the environment of the respective user. 
The password is not required from <a href="http://www-uxsup.csx.cam.ac.uk/pub/doc/suse/suse9.0/userguide-9.0/go01.html#root"><i class="glossterm"><tt class="systemitem">root</tt></i></a>, as <tt class="systemitem">root</tt> is authorized to assume the identity of any user.

<dt><span class="brown"><b class="brown">halt</b> <tt class="green">[option(s)]</tt></span> To avoid loss of data, you should always use this program to shut down your system.

<dt><span class="brown"><b class="brown">reboot</b> <tt class="green">[option(s)]</tt></span> Does the same as <b class="brown">halt</b> with the difference that the system performs an immediate reboot.

<dt><span class="brown"><b class="brown">clear</b></span> This command cleans up the visible area of the console. 
It has no options.
</dd></dl>

<h2>Ubuntu vs Fedora</h2>

Ubuntu 和 Fedora 都是最流行的 Linux 发行版之一，在两者之间做出选择实非易事。

在这篇文章里，我会对比一下 Ubuntu 和 Fedora 的不同特点，帮助你进行决策。

请注意，这篇文章主要是从桌面版的角度进行对比的。

Fedora 或者 Ubuntu 针对容器的特殊版本不会被考虑在内。

Ubuntu vs Fedora: 哪一个更好？

不同 Linux 发行版之间的区别主要体现在以下几个方面：

◈基础发行版（Debian、红帽、Arch，或者是从头做起）

◈安装方式

◈支持的桌面环境

◈软件包管理、软件支持和更新

◈硬件支持

◈开发团队（由企业支持，还是由业余爱好者创建）

◈发布周期

◈社区和线上支持

下面我们来看一下 Ubuntu 和 Fedora 之间的相似之处和不同之处。

掌握了这些信息之后，也许就更容易在两者之间做出选择了。
安装方式

Ubuntu 的 Ubiquity 安装器是最好用的安装器之一。

我认为这是让 Ubuntu 如此流行的重要原因之一，因为在 2004 年 Ubuntu 刚刚诞生的时候，安装 Linux 还是一个很庞大的工程。

Ubuntu 安装器可以让你在大约 10 分钟左右完成安装。

大多数情况下，它还可以识别出机器里安装的 Windows 系统，并且只需要几下点击就可以实现 Ubuntu 和 Windows 的双系统启动。

锦上添花的是，在安装 Ubuntu 的过程中你还可以进行系统更新，或者是安装第三方编译码器。

<img class="lazy" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/W9DqKgFsc68kThgIF4b5pq9WhBribLIthXbem58BMia3PjK5U6ick6M0pEDeibvOHxLYcJAlH6RW1wZ7VHfsPtJ0Zg/640">
Ubuntu Installer

Fedora 使用的是 Anaconda 安装器，拥有简单易用的界面，同样简化了安装过程。

<img class="lazy" data-src="https://mmbiz.qpic.cn/mmbiz_png/W9DqKgFsc68kThgIF4b5pq9WhBribLIth6p2BUtjqPQx5lF7cK5OuA7LssRI5EhibHH2rxyZkE8sTQ8lRPZvyEJQ/640">

Fedora Installer | Image Credit Fedora Magazine

Fodora 还提供了一个可以在 Windows 操作系统上下载并创建 Fedora live USB 的写入工具。

不过我在大约两年前尝试使用它的时候并不成功，最后使用了一个常规的创建 live USB 的软件。

根据我的经验，安装 Ubuntu 要比安装 Fedora 容易一些。

不过这并不是说安装 Fedora 有多困难，只是 Ubuntu 更简单而已。
桌面环境

Ubuntu 和 Fedora 默认都使用 GNOME 桌面环境。

<img class="lazy" data-src="https://mmbiz.qpic.cn/mmbiz_png/W9DqKgFsc68kThgIF4b5pq9WhBribLIthFh2duDC9jibEoaKxIdatSKBFzpAEjjzqbQPhZnMkKbM6TCGC6yCByJQ/640">

GNOME Desktop in Fedora

Fedora 使用的是原装的 GNOME 桌面，而 Ubuntu 则在此基础上做了个性化调整，让它看起来就像 Ubuntu 之前使用的 Unity 桌面环境。

<img class="lazy" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/W9DqKgFsc68kThgIF4b5pq9WhBribLIthnLkicPViazT63KwCZ3r1cgic2IOibMYvu2BUGUzQNxED0FUFWq4lksDzJQ/640">

GNOME desktop customized by Ubuntu

除了 GNOME，Ubuntu 和 Fedora 都提供了一些其它桌面环境的版本。

Ubuntu 有 Kubuntu、Xubuntu、Lubuntu 等版本，分别提供不同的桌面环境。

虽然它们都是 Ubuntu 的官方版本，但是却不是由 Canonical 的 Ubuntu 团队直接开发的，而是由另外的团队开发。

Fedora 通过 Fedora Spins 的方式提供了一些不同桌面环境的版本。

和 Kubuntu、Lubuntu 等版本不同的是，这些版本并非由独立团队开发，而是由 Fedora 核心团队开发的。

软件包管理和可用软件数量

Ubuntu 使用 APT 软件包管理器提供软件并进行管理（包括应用程序、库，以及其它所需编解码器），而 Fedora 使用 DNF 软件包管理器。
Ubuntu 拥有庞大的软件仓库，能够让你轻松安装数以千计的程序，包括 FOSS（LCTT 译注：

Free and Open-Source Software 的缩写，自由开源软件）和非 FOSS 的软件。

Fedora 则只专注于提供开源软件。

虽然这一点在最近的版本里有所转变，但是 Fedora 的软件仓库在规模上仍然比 Ubuntu 的要逊色一些。

一些第三方软件开发者为 Linux 提供像 .exe 文件一样可以点击安装的软件包。

在 Ubuntu 里这些软件包是 .deb 格式的，在 Fedora 里是 .rpm 格式的。

大多数软件供应商都为 Linux 用户提供 DEB 和 RPM 文件，但是我也经历过供应商只提供 DEB 文件的情况。

比如说 SEO 工具 Screaming Frog 就只提供 DEB 软件包。

反过来，一个软件只有 RPM 格式但是没有 DEB 格式这种情况就极其罕见了。
硬件支持

一般来说，Linux 在 WiFi 适配器和显卡的兼容性上容易出现问题，Ubuntu 和 Fedora 都受此影响。

以 Nvidia 为例，它的开源驱动程序 Nouveau 经常会引发系统启动时假死机之类的问题。

在 Ubuntu 上你可以轻松安装专有驱动程序作为补充。

在很多情况下，这样可以获得对硬件更好的支持。

<img class="lazy" data-src="https://mmbiz.qpic.cn/mmbiz_png/W9DqKgFsc68kThgIF4b5pq9WhBribLIthqJmD1tE9fWuO3OTtCrsm1eOA4D5aFwyWWmgaLRHJtqs1ROVguK5OcQ/640">

Installing proprietary driver is easier in Ubuntu

Fedora 则坚持使用开源软件，所以在 Fedora 上安装专有驱动程序就比较困难了。
线上支持和用户群

Ubuntu 和 Fedora 都通过社区论坛提供了很好的线上支持。
Ubuntu 主要有两个论坛：

UbuntuForums 和 Ask Ubuntu。

Fedora 主要的论坛则是 Ask Fedora。

就用户群体而言，Fedora 有着庞大的用户数量。

不过 Ubuntu 更为流行，用户数量甚至更为庞大。

Ubuntu 的流行催生了很多专注于 Ubuntu 的网站和博客。

所以相比 Fedora，你可以得到更多关于 Ubuntu 的故障排除指导和学习材料。
发布周期

Fedora 每六个月发布一个新版本，每个版本有九个月的支持周期。

也就是说，你必须在六个月到九个月之间进行一次系统升级。

进行 Fedora 版本升级并不是一件困难的事情，但是需要良好的网络连接。

并非所有人都喜欢每九个月进行一次 1.5 GB 的版本升级。
Ubuntu 有两种版本：

常规发布版本和长期支持（LTS）发布版本。

常规版本和 Fedora 比较类似，每隔六个月发布一次，有九个月的支持周期。

而长期支持发布版本则每两年发布一次，有五年的支持周期。

常规发布版本探索新功能特性和新的软件版本，而长期支持发布版本则支持旧版本软件。

对于不喜欢经常改变、青睐稳定性的人来说，这是一个很好的选择。
强大的基础发行版

Ubuntu 是基于 Debian 发行版的。

Debian 是最大的社区项目之一，并且也是自由软件世界里最受尊敬的项目之一。

Fedora 则是红帽公司的一个社区项目。

红帽公司是一个专注于 Linux 发行版的公司。

Fedora 充当了一个“试验田”的角色（用技术术语来说叫做“上游”），用来在红帽企业级 Linux 发布新功能之前对这些新功能进行试验。
在背后支持的企业

Ubuntu 和 Fedora 都有来自母公司的支持。
Ubuntu 源自 Canonical 公司，而 Fedora 源自红帽公司（现在是 IBM 的一部分）。

背后企业的支持非常重要，因为可以确保 Linux 发行版良好的维护。

有一些发行版是由一群独立的业余爱好者们共同创建的，但是在工作压力之下经常会结束。

你也许见过一些还算比较流行的发行版项目仅仅是因为这个原因而终止了。

很多这样的发行版由于开发者没有足够的业余时间可以投入到项目上而不得不终止，比如 Antergos 和 Korora。

Ubuntu 和 Fedora 的背后都有基于 Linux 的企业的支持，这让它们比其它独立的发行版更胜一筹。
Ubuntu vs Fedora：服务端

到目前为止，我们在 Ubuntu 和 Fedora 之间的对比主要都集中在桌面端。

不过如果不考虑一下服务端的话，对 Linux 的讨论就不能算是完整的。

<img class="lazy" data-src="https://mmbiz.qpic.cn/mmbiz_png/W9DqKgFsc68kThgIF4b5pq9WhBribLIthCB7gKg0g865BaTUTfWBgUh6opNvq0uLyPU85YrGWgQ7L4gjiakNwm5w/640">
Ubuntu Server

Ubuntu 不仅在桌面端很流行，在服务端也有很强的存在感。

如果你能够在桌面端熟练使用 Ubuntu，那么也不会对 Ubuntu 服务器版本感到陌生。

我就是从使用 Ubuntu 桌面端开始的，现在我的网站都运行在 Ubuntu 服务器上。

Fedora 同样有服务端版本，并且也有人在使用。

但是大多数系统管理者不会喜欢一个每九个月就需要重启升级的服务器。

学习 Fedora 可以更好地帮助你使用红帽企业级 Linux（RHEL）。

RHEL 是一个付费产品，你需要购买订阅才可以使用。

如果你希望在服务器上运行一个和 Fedora 或者红帽类似的操作系统，我推荐使用 CentOS。

CentOS 同样是红帽公司附属的一个社区项目，但是专注于服务端。
结论

你可以看到，Ubuntu 和 Fedora 有很多相似之处。

不过就可用软件数量、驱动安装和线上支持来说，Ubuntu 的确更有优势。

Ubuntu 也因此成为了一个更好的选择，尤其是对于没有经验的 Linux 新手而言。

如果你想要熟悉红帽的话，Fedora 是一个很好的开始。

如果你对 Linux 有一定经验，或者是只想要使用开源软件，Fedora 就是一个很棒的选择。

最终还是需要你自己来决定是使用 Fedora 还是 Ubuntu。

我会建议为两个发行版分别创建一个 live USB，并且在虚拟机上体验一下。

<h2>Linux 命令行下搜索工具, CLI search</h2>
grep
使用 grep 的优势是它几乎可以在任意类 Unix 系统上使用。

常用 grep 命令的几种方式。
在 py 文件中找到一个关键字并且输出行号，可以这样操作：
$ grep -rins --include \*.py import .

回忆起部分命令。
通过管道（|）使用 grep 命令来搜索历史记录命令：
$ history | grep "python"

可以找到曾经运行过的所有包含 python 关键字的命令。

$ history | grep “python”
284  python test.py
...    #省略其它结果

$ !284
$ python test.py

ack
一个类似于 grep 并且为程序员优化过的工具
它在默认情况下以递归方式搜索，但是会忽略版本控制工具目录，比如 .git 目录。
并且它自带很多很实用的工具，可以大大提高我们搜索效率。

我们同样再拿出上面的例子来举例，下面我们使用 ack 命令来实现仅在 py 文件中搜索 import 关键字的方法：

# ack 命令实现方式
$ ack import --py

# grep 命令实现方式
$ grep -rins --include \*.py import .
上面是仅在 py 文件进行搜索，那假如我们想搜索除 py 文件类型以外的所有其他类型的文件，要怎么操作？

对于每个文件类型，都有一个对应的 no 标识，来排除对这个文件类型搜索。
比如，想搜索 py 文件的话就使用 --py 选项，而想排除 py 文件的话就使用 --nopy 选项。

$ ack import --nopy
当然文件类型有非常之多，我们还可以通过修改 ~/.ackrc 文件来扩展文件类型。
假如我们现在想搜索 .conf 文件，默认情况下 ack 不支持这种文件：

$ ack hello --conf
Unknown option: conf
ack: Invalid option on command line
要注册 .conf 文件类型，我们可以将以下内容添加到 ~/.ackrc 文件中，之后我们就可以正常搜索 conf 文件了。

--type-set=conf=.conf
配置文件修改之后，我们可以使用 --help-types 选项来确认自定义类型是否已经成功加上。

ack 命令从 .ackrc 文件中获取配置信息，但如何你想脱离 .ackrc 文件来运行 ack 命令的话，可以使用 -noenv 选项。

The Silver Searcher
该搜索器是另一个类似于 ack 的 grep 替代品，其更快的性能让大家很推崇。
它有个非常实用的特点，那就是它会忽略在项目工程中的 .gitignore 文件所指定的文件。
所以如果你想排除搜索一些文件，就可以将那些文件写在 .gitignore 文件里。

ag 命令
在 Ubuntu 系统上可以使用以下命令来安装 ag 命令：

$ apt-get install silversearcher-ag
使用 ag 命令来搜索 py 文件里包含关键字 import 的内容：

$ ag import --py
ag 命令十分强大，限于篇幅本文只介绍它最基本的用法，改天有时间的话再补充一下它其它非常强大的功能用法。

sift
sift 是使用 Golang 编写的 grep 替代品，这意味着它可以在 Linux，Windows，OS X 和其他系统上使用。
它的速度快得离谱，而且有一些很酷的用例来代替 grep + awk 组合来提取数据。

我们再使用 sift 命令来搜索所有 py 文件里包含 import 关键字的内容：

# 只搜索 py 文件：
sift --ext py import

# 排除 py 文件
sift --exclude-ext py import
RipGrep

RipGrep 与 Silver Searcher 类似，可以在 Mac、Linux 和 Windows 上运行。
它的 readme 文件声称，RipGrep 通常比其他任何搜索工具都快，它推崇 Rust 的正则表达式引擎，并像Silver Searcher一样使用 .gitignore 文件来排除一些文件或目录。

RipGrep 通常简称为 rg ，我们再使用 rg 命令来搜索所有 py 文件里包含 import 关键字的内容：
rg --type=py import

<h2>Command Line Tools to Find Files in Linux</h2>
1. Find Command
It supports multiple options to locate files using attributes such as permissions, users, groups, file type, date, size and other possible criteria.

2. Locate Command
instead of searching through the file system when a user initiates a file search operation, locate queries a database which contains bits and parts of files and their corresponding paths on the file system.
This database can be prepared and updated using the updatedb command. 
Note that locate will not report files created after the most recent update of the relevant database.

3. Grep Command
Although grep command is not a tool for directly searching files, you can employ it to locate files. 
For example, if you are looking for a README.md file which contains the phrase “An assortment”, which you suspect should be somewhere in your home directory, possibly in ~/bin.

$ grep -Ri ~/bin -e "An assortment" 
OR
$ grep -Ri ~/bin/ -e "An assortment" | cut -d: -f1
Where the grep flag:

-R – means search the specified directory recursively
-i – means ignore case distinctions
-e – specifies the phrase to be used as a pattern for searching
-d – specifies the delimter
-f – sets the field to be printed

4. Which Command
For example:
$ which find
$ which locate
$ which which

5. Whereis Command
$ whereis find
$ whereis locate
$ whereis which
$ whereis whereis

<h2>Linux notes.txt</h2>
=============
the right-ctrl key
remember to use the right-ctrl key in virtual box to switch out to windows

=============
Linux text editor:
gedit, pluma, vim, gvim, sublime text

=============
install packages from software manager or Synaptic manager 

=============
# to install vim
sudo apt-get install vim

#edit new file test
# https://www.radford.edu/~mhtay/CPSC120/VIM_Editor_Commands.htm
# VIM Editor Commands
https://www.fprintf.net/vimCheatSheet.html


vim test
hit i to insert
hit esc to exit insert mode


<h2>Working with the Shell, Introduction to Bash</h2>

In the KDE taskbar, there is an icon depicting a monitor with a seashell. 
When you click this icon with the mouse, a console window opens in which to enter commands. 
The console normally runs Bash (Bourne again shell), a program developed as part of the GNU  project. 
It is, by far, the most widely used derivative of the Bourne shell (sh). 
Once you have opened the shell, see the prompt on the first line. 
The prompt usually consists of the user name, host name, and current path, but it can be customized. 
When the cursor is behind this prompt, you can send commands directly to your computer system: <b class="brown">tux $ &gt;</b>. 

<h2>Bash: Commands</h2>

A command consists of several elements. 
The first element is always the actual command, followed by parameters or options. 
Commands are executed when you press <b class="orange">Return</b>. 
Before doing so, easily edit the command line, add options, or correct typing errors. 
One of the most frequently used commands is <b class="brown">ls</b>, which can be used with or without arguments. 
Entering the plain <b class="brown">ls</b> command in the console shows the contents of the current directory. 

Options are prefixed with a hyphen. 
The command <b class="brown">ls -l</b>, for instance, shows the contents of the same directory in full detail. 
Next to each file name, see the date when the file was created, the file size in bytes, and further details, which are covered later. 
One very important option that exists for many commands is the <b class="brown">--help</b> option. 
By entering <b class="brown">ls --help</b>, display all the options for the <b class="brown">ls</b> command.
Also use the <b class="brown">ls</b>  command to view the contents of other directories. 
To do so, the directory must be specified as a parameter. 
For example, to see the contents of <tt class="filename">Desktop</tt>, enter <b class="brown">ls -l Desktop</b>.

<h2>Bash: Files and Directories</h2>

To use the shell efficiently, it is really useful to have some knowledge about the file and directory structures of a Linux system. 
You can think of directories as electronic folders where files, programs, and subdirectories are stored. 
The top level directory in the hierarchy is the root directory, referred to as <tt class="filename">/</tt>. 
This is the place from which all other directories can be accessed.
The <tt class="filename">/home</tt> directory contains the directories in which the individual users can store their personal files. 
Figure <a href="http://www-uxsup.csx.cam.ac.uk/pub/doc/suse/suse9.0/userguide-9.0/ch24s02.html#fig:verz.baum" title="Figure 24.1. 
Excerpt from a Standard Directory Tree">24.1: &#8220;Excerpt from a Standard Directory Tree&#8221;</a> shows the standard directory tree in Linux, with the home directories of the example users <tt class="green">xyz</tt>, <tt class="green">linux</tt>, and <tt class="green">tux</tt>. 
The directory tree of a Linux system has a functional structure that follows the <i class="green">File System Standard</i>. 
The following list provides a brief description of the standard directories in Linux. 

<b>Figure 24.1. Excerpt from a Standard Directory Tree</b>

<img class="lazy" data-src="http://www-uxsup.csx.cam.ac.uk/pub/doc/suse/suse9.0/userguide-9.0/verzeichnisse_baum.png" width="NaN" alt="Excerpt from a Standard Directory Tree">

<dl><dt><span class="term"><tt class="filename">/</tt></span></dt><dd>root directory, starting point of the directory tree.
</dd><dt><span class="term"><tt class="filename">/home</tt></span></dt><dd>(private) directories of users.
</dd><dt><span class="term"><tt class="filename">/dev</tt></span></dt><dd>device files that represent hardware components
</dd><dt><span class="term"><tt class="filename">/etc</tt></span></dt><dd>important files for system configuration.
</dd><dt><span class="term"><tt class="filename">/etc/init.d</tt></span></dt><dd>boot scripts
</dd><dt><span class="term"><tt class="filename">/usr/bin</tt></span></dt><dd>generally accessible programs.
</dd><dt><span class="term"><tt class="filename">/bin</tt></span></dt><dd>programs needed early in the boot process.
</dd><dt><span class="term"><tt class="filename">/usr/sbin</tt></span></dt><dd>programs reserved for the system administrator.
</dd><dt><span class="term"><tt class="filename">/sbin</tt></span></dt><dd>programs reserved for the system administrator and needed for booting.
</dd><dt><span class="term"><tt class="filename">/usr/include</tt></span></dt><dd>header files for the C compiler
</dd><dt><span class="term"><tt class="filename">/usr/include/g++</tt></span></dt><dd>header files for the C++ compiler.
</dd><dt><span class="term"><tt class="filename">/usr/share/doc</tt></span></dt><dd>various documentation files.
</dd><dt><span class="term"><tt class="filename">/usr/share/man</tt></span></dt><dd>system manual pages (man pages).
</dd><dt><span class="term"><tt class="filename">/usr/src</tt></span></dt><dd>source code of system software
</dd><dt><span class="term"><tt class="filename">/usr/src/linux</tt></span></dt><dd>kernel source code.
</dd><dt><span class="term"><tt class="filename">/tmp</tt>, <tt class="filename">/var/tmp</tt></span></dt><dd>temporary files.
</dd><dt><span class="term"><tt class="filename">/usr</tt></span></dt><dd>all application programs
</dd><dt><span class="term"><tt class="filename">/var</tt></span></dt><dd>configuration files (e.g., those linked from <tt class="filename">/usr</tt>)
</dd><dt><span class="term"><tt class="filename">/var/log</tt></span></dt><dd>system log files
</dd><dt><span class="term"><tt class="filename">/var/adm</tt></span></dt><dd>system administration data
</dd><dt><span class="term"><tt class="filename">/lib</tt></span></dt><dd>shared libraries (for dynamically linked programs)
</dd><dt><span class="term"><tt class="filename">/proc</tt></span></dt><dd>process file system.
</dd><dt><span class="term"><tt class="filename">/usr/local</tt></span></dt><dd>local, distribution-independent extensions.
</dd><dt><span class="term"><tt class="filename">/opt</tt></span></dt><dd>optional software, larger add-on program packages (such as KDE, GNOME, Netscape).
</dd></dl>

<h2>Bash: Functions</h2>

There are two important functions of the shell that can make your work a lot easier:
<ul type="disc"><li>The history function &#8212; To repeat a command that has been entered before, press <b class="orange">UpArrow</b> until the previous command appears at the prompt. 
Move forward through the list of previously entered commands by pressing <b class="orange">&#8595;</b>. 
To edit the command line, just move the cursor to the desired position using the arrow keys and start typing. 
Use <b class="orange">Ctrl</b> + <b class="orange">R</b> to search in the history.
</li><li>The expansion function &#8212; Expand a file name to its full length after typing its first letters until it can be uniquely identified. 
To do so, type the first letters then hit <b class="orange">Tab</b>. 
If there are several file names starting with the same letters, obtain a list of them by hitting <b class="orange">Tab</b> twice.
</li></ul>
<h4>First Example: Managing Files</h4>

Now that you know what a command looks like, which directories exist in SuSE Linux, and how to speed up things when using Bash, put this knowledge into practice with a small exercise.
<ol type="1"><li>Open a console from the KDE desktop by clicking the shell icon.
</li><li>Enter the <b class="brown">ls</b> command to see the contents of your home directory.
</li><li>Use the command <b class="brown">mkdir</b> (which stands for <i class="green">make directory</i>)  to create a new subdirectory called <tt class="filename">test</tt> by entering <b class="brown">mkdir test</b>.
</li><li>Now launch the <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">KEdit</span></span> editor by pressing <b class="orange">Alt</b> + <b class="orange">F2</b> and entering <i class="green">kedit</i> in the input field. 
Type a few letters in the editor then save the file as <tt class="filename">Testfile</tt> in your home directory. 
Linux distinguishes between uppercase and lowercase. 
For this example, use an uppercase T.
</li><li>View the contents of your home directory again. 
Instead of typing <b class="brown">ls</b> again, just press <b class="orange">UpArrow</b> twice and the <b class="brown">ls</b> command should reappear at the prompt. 
To execute the command, hit <b class="orange">Return</b>. 
The newly created directory <tt class="filename">test</tt> should appear in blue letters and <tt class="filename">Testfile</tt> in black. 
This is how directories and files can be distinguished in a console.
</li><li>Move <tt class="filename">Testfile</tt> into the subdirectory <tt class="filename">test</tt> with the command <b class="brown">mv</b>. 
To speed this up, use the expansion function: just enter <b class="brown">mv T</b> and press <b class="orange">Tab</b>. 
As long as there is no other file beginning with this letter in the directory, the shell expands the file name and adds the string <i class="green">estfile</i>. 
Otherwise, add a letter or two yourself and test <b class="orange">Tab</b> each time to see whether the shell can now expand the name. 
Finally, type a space then <tt class="filename">test</tt> after the expanded file name and press <b class="orange">Return</b> to execute the command.
</li><li>At this point, <tt class="filename">Testfile</tt> should no longer be in the directory. 
Check this by entering <b class="brown">ls</b> again.
</li><li>To see whether the file has been successfully moved, change into the directory <tt class="filename">test</tt> with the command <b class="brown">cd test</b>. 
Now enter <b class="brown">ls</b> again. 
You should see <tt class="filename">Testfile</tt> in the listing. 
Change back to your home directory at any point by entering only <b class="brown">cd</b> (which stands for <i class="green">change directory</i>).
</li><li>To make a copy of a file, use <b class="brown">cp</b>. 
For instance, enter <b class="brown">cp Testfile Testbackup</b> to copy <tt class="filename">Testfile</tt> to <tt class="filename">Testbackup</tt>. 
Once again, the command <b class="brown">ls</b> can be used to see whether both files are in the directory.
</li></ol>

<h2>Bash: Specifying Paths</h2>

When working with files or directories, it is important specify the correct path. 
However, you do not need to enter the entire (absolute) path from the root directory to the respective file. 
Rather, you can start from the current directory. 
Address your home directory directly with <tt class="filename">~</tt>. 
Accordingly, there are two ways to list the file <tt class="filename">Testfile</tt> in the directory <tt class="filename">test</tt>: by entering the relative path with <b class="brown">ls test/*</b> or by specifying the absolute path with <b class="brown">ls ~/test/*</b>. 

To list the contents of home directories of other users, enter <b class="brown">ls ~username</b>. 
In the above-mentioned directory tree, one of the sample users is <tt class="green">tux</tt>. 
Thus, the command <b class="brown">ls ~tux</b> would list the contents of the home directory of <tt class="green">tux</tt>.
Refer to the current directory with a dot. 
The next higher level in the tree is represented by two dots. 
By entering <b class="brown">ls ..</b>, see the contents of the parent directory of the current directory. 
The command <b class="brown">ls ../..</b> shows the contents of the directory two levels higher in the hierarchy.
<h4>Second Example: Working with Paths</h4>

Here is another example to illustrate how to move around in the directories of your SuSE Linux system.
<ul type="disc"><li>Change into your home directory with the command <b class="brown">cd</b>. 
Then create a directory in it with the name <tt class="filename">test2</tt> by entering <b class="brown">mkdir test2</b>.
</li><li>Change into the new directory with <b class="brown">cd test2</b> and create a subdirectory in it with the name <tt class="filename">subdirectory</tt>. 
To change into it, use the expansion function: enter <b class="brown">cd su</b> then press <b class="orange">Tab</b>. 
The shell will expand the rest of the directory name.
</li><li>Now try to move the previously created file <tt class="filename">Testbackup</tt> into the current directory (<tt class="filename">subdirectory</tt>) without changing the directory again. 
To achieve this, specify the relative path to that file: <b class="brown">mv ../../test/Testbackup .</b>. 
The dot at the end of this command is required to tell the shell that the current directory is the destination to which to move the file. 
<b class="brown">../../</b>, in this example, refers to your home directory.
</li></ul>

<h2>Bash: Wild Cards</h2>

Another convenience offered by the shell is wild cards. 
There are four different types of these in Bash:
<dl><dt><span class="term">?</span></dt><dd>Matches exactly one arbitrary character
</dd><dt><span class="term">*</span></dt><dd>Matches an arbitrary number of characters
</dd><dt><span class="term">[set]</span></dt><dd>Matches one of the characters from the group specified inside the square brackets, which is represented here by the string <i class="green">set</i>
</dd><dt><span class="term">[!set]</span></dt><dd>Matches one character other than those identified by <i class="green">set</i>
</dd></dl>
Assuming that your <tt class="filename">test</tt> directory contains the files <tt class="filename">Testfile</tt>, <tt class="filename">Testfile1</tt>, <tt class="filename">Testfile2</tt>, and <tt class="filename">datafile</tt>, the command <b class="brown">ls Testfile?</b> will list the files <tt class="filename">Testfile1</tt> and <tt class="filename">Testfile2</tt>. 
With <b class="brown">ls Test*</b>, the list will also include <tt class="filename">Testfile</tt>. 

The command <b class="brown">ls *fil*</b> shows <span class="emphasis"><em>all</em></span> the sample files. 
Finally, you can use the <tt class="green">set</tt> wild card to address all sample files whose last character is a number: <b class="brown">ls Testfile[1-9]</b>.
Among the four types of wild cards, the most inclusive one is the asterisk. 
It could be used to copy all files contained in one directory to another one or to delete all files with one command. 
The command <b class="brown">rm *fil*</b>, for instance, would delete all files in the current directory whose name includes the string <i class="green">fil</i>.

<h2>Bash: More or Less</h2>

Linux includes two small programs for viewing text files directly in the shell. 
Rather than starting an editor to read a file like <tt class="filename">Readme.txt</tt>, simply enter <b class="brown">less Readme.txt</b> to display the text in the console window. 
Use <b class="orange">Space</b> to scroll down one page. 
Use <b class="orange">PgUp</b> and <b class="orange">PgDown</b> to move forward or backward in the text. 
To exit <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">less</span></span>, press <b class="orange">Q</b>.
The program <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">less</span></span> got its name from the the precept that <i class="green">less is more</i> and can also be used to view the output of commands in a convenient way. 
To see how this works, read Section <a href="http://www-uxsup.csx.cam.ac.uk/pub/doc/suse/suse9.0/userguide-9.0/ch24s02.html#sec:shell.pipes" title="Pipes">&#8220;Pipes&#8221;</a>.

Instead of <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">less</span></span>, you can also use the older program <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">more</span></span>. 
However, it is less convenient because it does not allow you to scroll backwards.

<h2>Bash: Pipes</h2>

Normally, the standard output in the shell is your screen or the console window, and the standard input is the keyboard. 
To forward the output of a command to an application such as <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">less</span></span>, use a <i class="green">pipeline</i>. 

To view the files in the <tt class="filename">test</tt> directory, enter the command <b class="brown">ls test | less</b>. 
The contents of the <tt class="filename">test</tt> directory will be displayed with <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">less</span></span>. 
This only makes sense if the normal output with <b class="brown">ls</b> would be too lengthy. 
For instance, if you view the contents of the <tt class="filename">dev</tt> directory with <b class="brown">ls /dev</b>, you will only see a small portion in the window. 
View the entire list with <b class="brown">ls /dev | less</b>. 

It is also possible to save the output of commands to a file. 
For example, <b class="brown">ls test &gt; Content</b> generates a new file called <tt class="filename">Content</tt> that contains a list of the files and directories in <tt class="filename">test</tt>. 
View the file with <b class="brown">less Content</b>. 

Similarly, you can also use a file as the input for a comand. 
For example, sort the text lines in <tt class="filename">Testfile</tt> with <b class="brown">sort &lt; Testfile</b>. 
The output of the command <b class="brown">sort</b> is sent to the screen. 
The text is sorted by the first letters of the individual lines. 

If you need a new file containing the sorted list, pipe the output of the command <b class="brown">sort</b> to a file. 
To test this, create an unsorted name list in an editor and save it under <tt class="filename">list</tt> in the <tt class="filename">test</tt> directory. 
Then change into <tt class="filename">test</tt> and enter the command <b class="brown">sort &lt; unsortedlist &gt; sortedlist</b>. 
Finally, view the sorted list with <b class="brown">less</b>.
Just like the standard output, the standard error output is sent to the console as well. 
However, to redirect the standard error output to a file named <tt class="filename">errors</tt>, append <b class="brown">2&gt; errors</b> to the corresponding command. 
On the other hand, both standard output and standard error are saved to one file named <tt class="filename">alloutput</tt> if you append <b class="brown">&gt;&amp; alloutput</b>. 
Finally, to append the output of a command to an already existing file, the command must be followed by <b class="brown">&gt;&gt;</b> instead of a single <b class="brown">&gt;</b>.

<h2>Bash: Archives and Data Compression</h2>

Now that you have already created a number of files and directories, consider the subject of archives and data compression. 
Suppose you want to have the entire <tt class="filename">test</tt> directory packed in one file that you can save on a floppy disk as a backup copy or send by e-mail. 
To do so, use the command <b class="brown">tar</b> (for <i class="green">tape archiver</i>). 
With <b class="brown">tar --help</b>, view all the options for the <b class="brown">tar</b> command. 
The most important of these options are explained here:
<dl><dt><span class="term">-c</span></dt><dd>(for create) Create a new archive.
</dd><dt><span class="term">-t</span></dt><dd>(for table) Display the contents of an archive.
</dd><dt><span class="term">-x</span></dt><dd>(for extract) Unpack the archive.
</dd><dt><span class="term">-v</span></dt><dd>(for verbose) Show all files on screen while creating the archive.
</dd><dt><span class="term">-f</span></dt><dd>(for file) Choose a file name for the archive file. 
When creating an archive, this option must always be given as the last one.
</dd></dl>
To pack the <tt class="filename">test</tt> directory with all its files and subdirectories into an archive named <tt class="filename">testarchive.tar</tt>, use the options <b class="brown">-c</b> and <b class="brown">-f</b>. 
For the testing purposes of this example, also add <b class="brown">-v</b> to follow the progress of the archiving, although this option is not mandatory. 
After using <b class="brown">cd</b> to change to your home directory where the <tt class="filename">test</tt> directory is located, enter <b class="brown">tar -cvf testarchive.tar test</b>. 
After that, view the contents of the archive file with <b class="brown">tar -tf testarchive.tar</b>. 
The <tt class="filename">test</tt> directory with all its files and directories has remained unchanged on your hard disk. 
To unpack the archive, enter <b class="brown">tar -xvf testarchive.tar</b>, but do not try this yet.
For file compression, the obvious choice on Linux is the popular <span xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0" class="application"><span class="application">gzip</span></span> program. 
Just enter <b class="brown">gzip testarchive.tar</b>. 
With <b class="brown">ls</b>, now see that the file <tt class="filename">testarchive.tar</tt> is no longer there and that the file <tt class="filename">testarchive.tar.gz</tt> has been created instead. 
This file is much smaller and therefore much better suited for transfer via e-mail or storage on a floppy.
Now, unpack this file in the <tt class="filename">test2</tt> directory created earlier. 
To do so, enter <b class="brown">cp testarchive.tar.gz test2</b> to copy the file to that directory. 
Change to the directory with <b class="brown">cd test2</b>. 
A compressed archive with the <tt class="green">.tar.gz</tt> extension can be <i class="green">unzipped</i>  with the <b class="brown">gunzip</b> command. 
Enter <b class="brown">gunzip testarchive.tar.gz</b>  , which results in the file <tt class="filename">testarchive.tar</tt>, which then needs to be extracted or <i class="green">untarred</i> with <b class="brown">tar -xvf testarchive.tar</b>. 
You can also <i class="green">unzip</i> and extract a compressed archive in one step by adding the <tt class="green">-z</tt> option. 
The complete command would be <b class="brown">tar -xvzf testarchive.tar.gz</b>. 
With <b class="brown">ls</b>, you can see that a new <tt class="filename">test</tt> directory has been created with the same contents as your <tt class="filename">test</tt> directory in your home directory.

<h2>Bash: mtools</h2>

<b class="brown">mtools</b> are a set of commands for working with MS-DOS file systems. 
The commands included in <b class="brown">mtools</b> allow you to address the first floppy drive as <tt class="green">a:</tt>, just like under MS-DOS, and the commands are like MS-DOS commands except they are prefixed with an <tt class="green">m</tt>:
<dl><dt><span class="term">
     <b class="brown">mdir a:</b>
    </span></dt><dd>displays the contents of the floppy disk in drive <tt class="filename">a:</tt>
</dd><dt><span class="term">
     <b class="brown">mcopy Testfile a:</b>
    </span></dt><dd>copies the file <tt class="filename">Testfile</tt> to the floppy disk.
</dd><dt><span class="term">
     <b class="brown">mdel a:Testfile</b>
    </span></dt><dd>deletes <tt class="filename">Testfile</tt> in <tt class="filename">a:</tt>
</dd><dt><span class="term">
     <b class="brown">mformat a:</b>
    </span></dt><dd>formats the floppy disk in MS-DOS format (using the <b class="brown">fdformat</b> command).
</dd><dt><span class="term">
     <b class="brown">mcd a:</b>
    </span></dt><dd>makes <tt class="filename">a:</tt> your current directory
</dd><dt><span class="term">
     <b class="brown">mmd a:test</b>
    </span></dt><dd>creates the subdirectory <tt class="filename">test</tt> on the floppy disk
</dd><dt><span class="term">
     <b class="brown">mrd a:test</b>
    </span></dt><dd>deletes the subdirectory <tt class="filename">test</tt> from the floppy disk
</dd></dl>


<h2>Linux copy and paste</h2>
Use Ctrl+Insert or Ctrl+Shift+C for copying and
Shift+Insert or Ctrl+Shift+V for pasting text in the terminal in Ubuntu.

Right click and selecting the copy/paste option from the context menu is also an option.
I thought of elaborating on this topic specially when there is no single universal way of copy and paste in the Linux terminal.

<a href="https://linuxhandbook.com/linux-shortcuts/" class="whitebut ">Linux Terminal Shortcuts</a>










<script type='text/javascript' src='readbook.js'></script>
<script>
var lazyLoadInstance = new LazyLoad({
    elements_selector: ".lazy"
    // ... more custom settings?
});
</script>
</pre></body></html>
