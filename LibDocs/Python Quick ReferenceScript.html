<base target="_blank">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<style>
body {
 margin: auto;
 width: 80%;
 font-size: 24px;
 background-color: #000000;
 color: #20C030;
}
a { text-decoration: none; 
	color: #28B8B8; }
a:visited {	color: #389898; }
A:hover {	color: yellow; }
A:focus {	color: red; }
code { color: #28B8B8;  background-color: black;  font-size: 18px; }
pre { color: gray;  background-color: #001010;  font-size: 16px; }
img { display: inline-block; width: 900px; margin-top: 2%;margin-bottom: 5%;}
pre { color: gray; background-color: #001010}
div { width: 45%; display: inline-block; padding: 3px; border-radius: 4px; border: 1px solid DarkSlateGray; margin: 3px; vertical-align:top;}

</style>

</head>
<body>
<br><br>
<code>
Python Quick Reference<br>
https://github.com/justmarkham/python-reference<br>
<br>
By Kevin Markham (kevin@dataschool.io)<br>
http://www.dataschool.io<br>
<br>
Table of Contents:<br>
    Imports<br>
    Data Types<br>
    Math<br>
    Comparisons and Boolean Operations<br>
    Conditional Statements<br>
    Lists<br>
    Tuples<br>
    Strings<br>
    Dictionaries<br>
    Sets<br>
    Defining Functions<br>
    Anonymous (Lambda) Functions<br>
    For Loops and While Loops<br>
    Comprehensions<br>
    Map and Filter<br>
&#39;&#39;&#39;<br>


<br>


<br>


<br>
### IMPORTS ###<br>


<br>
# &#39;generic import&#39; of math module<br>
import math
<br>
math.sqrt(25)
<br>


<br>
# import a function<br>
from math import sqrt
<br>
sqrt(25)    # no longer have to reference the module<br>


<br>
# import multiple functions at once<br>
from math import cos, floor
<br>


<br>
# import all functions in a module (generally discouraged)<br>
from csv import *<br>


<br>
# define an alias<br>
import datetime as dt
<br>


<br>
# show all functions in math module<br>
dir(math)
<br>


<br>


<br>


<br>
### DATA TYPES ###<br>


<br>
# determine the type of an object<br>
type(2)         # returns &#39;int&#39;<br>
type(2.0)       # returns &#39;float&#39;<br>
type(&#39;two&#39;)     # returns &#39;str&#39;<br>
type(True)      # returns &#39;bool&#39;<br>
type(None)      # returns &#39;NoneType&#39;<br>


<br>
# check if an object is of a given type<br>
isinstance(2.0, int)            # returns False<br>
isinstance(2.0, (int, float))   # returns True<br>


<br>
# convert an object to a given type<br>
float(2)
<br>
int(2.9)
<br>
str(2.9)
<br>


<br>
# zero, None, and empty containers are converted to False<br>
bool(0)
<br>
bool(None)
<br>
bool(&#39;&#39;)    # empty string<br>
bool([])    # empty list<br>
bool({})    # empty dictionary<br>


<br>
# non-empty containers and non-zeros are converted to True<br>
bool(2)
<br>
bool(&#39;two&#39;)
<br>
bool([2])
<br>


<br>


<br>


<br>
### MATH ###<br>


<br>
# basic operations<br>
10 + 4          # add (returns 14)<br>
10 - 4          # subtract (returns 6)<br>
10 * 4          # multiply (returns 40)<br>
10 ** 4         # exponent (returns 10000)<br>
5 % 4           # modulo (returns 1) - computes the remainder<br>
10 / 4          # divide (returns 2 in Python 2, returns 2.5 in Python 3)<br>
10 / float(4)   # divide (returns 2.5)<br>


<br>
# force &#39;/&#39; in Python 2 to perform &#39;true division&#39; (unnecessary in Python 3)<br>
from __future__ import division
<br>
10 / 4          # true division (returns 2.5)<br>
10 // 4         # floor division (returns 2)<br>


<br>
<br>
<br>
<br>


<br>
<br>
### COMPARISONS AND BOOLEAN OPERATIONS ###<br>
<br>


<br>
<br>
# assignment statement<br>
<br>
x = 5<br>
<br>


<br>
<br>
# comparisons (these return True)<br>
<br>
x &gt; 3<br>
<br>
x &gt;= 3<br>
<br>
x != 3<br>
<br>
x == 5<br>
<br>


<br>
<br>
# boolean operations (these return True)<br>
<br>
5 &gt; 3 and 6 &gt; 3<br>
<br>
5 &gt; 3 or 5 &lt; 3<br>
<br>
not False<br>
<br>
False or not False and True     # evaluation order: not, and, or<br>
<br>


<br>
<br>


<br>
<br>


<br>
<br>
### CONDITIONAL STATEMENTS ###<br>
<br>


<br>
<br>
# if statement<br>
<br>
if x &gt; 0:
<br>
<br>
    print(&#39;positive&#39;)
<br>
<br>


<br>
<br>
# if/else statement<br>
<br>
if x &gt; 0:
<br>
<br>
    print(&#39;positive&#39;)
<br>
<br>
else:
<br>
<br>
    print(&#39;zero or negative&#39;)
<br>
<br>


<br>
<br>
# if/elif/else statement<br>
<br>
if x &gt; 0:
<br>
<br>
    print(&#39;positive&#39;)
<br>
<br>
elif x == 0:
<br>
<br>
    print(&#39;zero&#39;)
<br>
<br>
else:
<br>
<br>
    print(&#39;negative&#39;)
<br>
<br>


<br>
<br>
# single-line if statement (sometimes discouraged)<br>
<br>
if x &gt; 0: print(&#39;positive&#39;)
<br>
<br>


<br>
<br>
# single-line if/else statement (sometimes discouraged)<br>
<br>
# known as a &#39;ternary operator&#39;<br>
<br>
&#39;positive&#39; if x &gt; 0 else &#39;zero or negative&#39;<br>
<br>


<br>
<br>


<br>
<br>


<br>
<br>
### LISTS ###<br>
<br>
## properties: ordered, iterable, mutable, can contain multiple data types<br>
<br>


<br>
<br>
# create an empty list (two ways)<br>
<br>
empty_list = []
<br>
<br>
empty_list = list()
<br>
<br>


<br>
<br>
# create a list<br>
<br>
simpsons = [&#39;homer&#39;, &#39;marge&#39;, &#39;bart&#39;]
<br>
<br>


<br>
<br>
# examine a list<br>
<br>
simpsons[0]     # print element 0 (&#39;homer&#39;)<br>
<br>
len(simpsons)   # returns the length (3)<br>
<br>


<br>
<br>
# modify a list (does not return the list)<br>
<br>
simpsons.append(&#39;lisa&#39;)                 # append element to end<br>
<br>
simpsons.extend([&#39;itchy&#39;, &#39;scratchy&#39;])  # append multiple elements to end<br>
<br>
simpsons.insert(0, &#39;maggie&#39;)            # insert element at index 0 (shifts everything right)<br>
<br>
simpsons.remove(&#39;bart&#39;)                 # search for first instance and remove it<br>
<br>
simpsons.pop(0)                         # remove element 0 and return it<br>
<br>
del simpsons[0]                         # remove element 0 (does not return it)<br>
<br>
simpsons[0] = &#39;krusty&#39;                  # replace element 0<br>
<br>


<br>
<br>
# concatenate lists (slower than &#39;extend&#39; method)<br>
<br>
neighbors = simpsons + [&#39;ned&#39;, &#39;rod&#39;, &#39;todd&#39;]
<br>
<br>


<br>
<br>
# find elements in a list<br>
<br>
simpsons.count(&#39;lisa&#39;)      # counts the number of instances<br>
<br>
simpsons.index(&#39;itchy&#39;)     # returns index of first instance<br>
<br>


<br>
<br>
# list slicing [start:end:step]<br>
<br>
weekdays = [&#39;mon&#39;, &#39;tues&#39;, &#39;wed&#39;, &#39;thurs&#39;, &#39;fri&#39;]
<br>
<br>
weekdays[0]         # element 0<br>
<br>
weekdays[0:3]       # elements 0, 1, 2<br>
<br>
weekdays[:3]        # elements 0, 1, 2<br>
<br>
weekdays[3:]        # elements 3, 4<br>
<br>
weekdays[-1]        # last element (element 4)<br>
<br>
weekdays[::2]       # every 2nd element (0, 2, 4)<br>
<br>
weekdays[::-1]      # backwards (4, 3, 2, 1, 0)<br>
<br>


<br>
<br>
# alternative method for returning the list backwards<br>
<br>
list(reversed(weekdays))
<br>
<br>


<br>
<br>
# sort a list in place (modifies but does not return the list)<br>
<br>
simpsons.sort()
<br>
<br>
simpsons.sort(reverse=True)     # sort in reverse<br>
<br>
simpsons.sort(key=len)          # sort by a key<br>
<br>


<br>
<br>
# return a sorted list (does not modify the original list)<br>
<br>
sorted(simpsons)
<br>
<br>
sorted(simpsons, reverse=True)
<br>
<br>
sorted(simpsons, key=len)
<br>
<br>


<br>
<br>
# insert into an already sorted list, and keep it sorted<br>
<br>
num = [10, 20, 40, 50]
<br>
<br>
from bisect import insort
<br>
<br>
insort(num, 30)
<br>
<br>


<br>
<br>
# create a second reference to the same list<br>
<br>
same_num = num
<br>
<br>
same_num[0] = 0         # modifies both &#39;num&#39; and &#39;same_num&#39;<br>
<br>


<br>
<br>
# copy a list (two ways)<br>
<br>
new_num = num[:]
<br>
<br>
new_num = list(num)
<br>
<br>


<br>
<br>
# examine objects<br>
<br>
num is same_num         # returns True (checks whether they are the same object)<br>
<br>
num is new_num          # returns False<br>
<br>
num == same_num         # returns True (checks whether they have the same contents)<br>
<br>
num == new_num          # returns True<br>
<br>


<br>
<br>


<br>
<br>


<br>
<br>
### TUPLES ###<br>
<br>
## properties: ordered, iterable, immutable, can contain multiple data types<br>
<br>
## like lists, but they don&#39;t change size<br>
<br>


<br>
<br>
# create a tuple<br>
<br>
digits = (0, 1, &#39;two&#39;)          # create a tuple directly<br>
<br>
digits = tuple([0, 1, &#39;two&#39;])   # create a tuple from a list<br>
<br>
zero = (0,)                     # trailing comma is required to indicate it&#39;s a tuple<br>
<br>


<br>
<br>
# examine a tuple<br>
<br>
digits[2]           # returns &#39;two&#39;<br>
<br>
len(digits)         # returns 3<br>
<br>
digits.count(0)     # counts the number of instances of that value (1)<br>
<br>
digits.index(1)     # returns the index of the first instance of that value (1)<br>
<br>


<br>
<br>
# elements of a tuple cannot be modified<br>
<br>
digits[2] = 2       # throws an error<br>
<br>


<br>
<br>
# concatenate tuples<br>
<br>
digits = digits + (3, 4)
<br>
<br>


<br>
<br>
# create a single tuple with elements repeated (also works with lists)<br>
<br>
(3, 4) * 2          # returns (3, 4, 3, 4)<br>
<br>


<br>
<br>
# sort a list of tuples<br>
<br>
tens = [(20, 60), (10, 40), (20, 30)]
<br>
<br>
sorted(tens)        # sorts by first element in tuple, then second element<br>
<br>
                    #   returns [(10, 40), (20, 30), (20, 60)]<br>
<br>


<br>
<br>
# tuple unpacking<br>
<br>
bart = (&#39;male&#39;, 10, &#39;simpson&#39;)  # create a tuple<br>
<br>
(sex, age, surname) = bart      # assign three values at once<br>
<br>


<br>
<br>


<br>
<br>


<br>
<br>
### STRINGS ###<br>
<br>
## properties: iterable, immutable<br>
<br>


<br>
<br>
# create a string<br>
<br>
s = str(42)         # convert another data type into a string<br>
<br>
s = &#39;I like you&#39;<br>
<br>


<br>
<br>
# examine a string<br>
<br>
s[0]                # returns &#39;I&#39;<br>
<br>
len(s)              # returns 10<br>
<br>


<br>
<br>
# string slicing is like list slicing<br>
<br>
s[:6]               # returns &#39;I like&#39;<br>
<br>
s[7:]               # returns &#39;you&#39;<br>
<br>
s[-1]               # returns &#39;u&#39;<br>
<br>


<br>
<br>
# basic string methods (does not modify the original string)<br>
<br>
s.lower()           # returns &#39;i like you&#39;<br>
<br>
s.upper()           # returns &#39;I LIKE YOU&#39;<br>
<br>
s.startswith(&#39;I&#39;)   # returns True<br>
<br>
s.endswith(&#39;you&#39;)   # returns True<br>
<br>
s.isdigit()         # returns False (returns True if every character in the string is a digit)<br>
<br>
s.find(&#39;like&#39;)      # returns index of first occurrence (2), but doesn&#39;t support regex<br>
<br>
s.find(&#39;hate&#39;)      # returns -1 since not found<br>
<br>
s.replace(&#39;like&#39;, &#39;love&#39;)    # replaces all instances of &#39;like&#39; with &#39;love&#39;<br>
<br>


<br>
<br>
# split a string into a list of substrings separated by a delimiter<br>
<br>
s.split(&#39; &#39;)        # returns [&#39;I&#39;, &#39;like&#39;, &#39;you&#39;]<br>
<br>
s.split()           # equivalent (since space is the default delimiter)<br>
<br>
s2 = &#39;a, an, the&#39;<br>
<br>
s2.split(&#39;,&#39;)       # returns [&#39;a&#39;, &#39; an&#39;, &#39; the&#39;]<br>
<br>


<br>
<br>
# join a list of strings into one string using a delimiter<br>
<br>
stooges = [&#39;larry&#39;, &#39;curly&#39;, &#39;moe&#39;]
<br>
<br>
&#39; &#39;.join(stooges)   # returns &#39;larry curly moe&#39;<br>
<br>


<br>
<br>
# concatenate strings<br>
<br>
s3 = &#39;The meaning of life is&#39;<br>
<br>
s4 = &#39;42&#39;<br>
<br>
s3 + &#39; &#39; + s4       # returns &#39;The meaning of life is 42&#39;<br>
<br>


<br>
<br>
# remove whitespace from start and end of a string<br>
<br>
s5 = &#39;  ham and cheese  &#39;<br>
<br>
s5.strip()          # returns &#39;ham and cheese&#39;<br>
<br>


<br>
<br>
# string substitutions: all of these return &#39;raining cats and dogs&#39;<br>
<br>
&#39;raining %s and %s&#39; % (&#39;cats&#39;, &#39;dogs&#39;)                       # old way<br>
<br>
&#39;raining {} and {}&#39;.format(&#39;cats&#39;, &#39;dogs&#39;)                   # new way<br>
<br>
&#39;raining {arg1} and {arg2}&#39;.format(arg1=&#39;cats&#39;, arg2=&#39;dogs&#39;) # named arguments<br>
<br>


<br>
<br>
# string formatting<br>
<br>
# more examples: https://mkaz.tech/python-string-format.html<br>
<br>
&#39;pi is {:.2f}&#39;.format(3.14159)      # returns &#39;pi is 3.14&#39;<br>
<br>


<br>
<br>
# normal strings versus raw strings<br>
<br>
print(&#39;first line\nsecond line&#39;)    # normal strings allow for escaped characters<br>
<br>
print(r&#39;first line\nfirst line&#39;)    # raw strings treat backslashes as literal characters<br>
<br>


<br>
<br>


<br>
<br>


<br>
<br>
### DICTIONARIES ###<br>
<br>
## properties: unordered, iterable, mutable, can contain multiple data types<br>
<br>
## made of key-value pairs<br>
<br>
## keys must be unique, and can be strings, numbers, or tuples<br>
<br>
## values can be any type<br>
<br>


<br>
<br>
# create an empty dictionary (two ways)<br>
<br>
empty_dict = {}
<br>
<br>
empty_dict = dict()
<br>
<br>


<br>
<br>
# create a dictionary (two ways)<br>
<br>
family = {&#39;dad&#39;:&#39;homer&#39;, &#39;mom&#39;:&#39;marge&#39;, &#39;size&#39;:6}
<br>
<br>
family = dict(dad=&#39;homer&#39;, mom=&#39;marge&#39;, size=6)
<br>
<br>


<br>
<br>
# convert a list of tuples into a dictionary<br>
<br>
list_of_tuples = [(&#39;dad&#39;, &#39;homer&#39;), (&#39;mom&#39;, &#39;marge&#39;), (&#39;size&#39;, 6)]
<br>
<br>
family = dict(list_of_tuples)
<br>
<br>


<br>
<br>
# examine a dictionary<br>
<br>
family[&#39;dad&#39;]       # returns &#39;homer&#39;<br>
<br>
len(family)         # returns 3<br>
<br>
&#39;mom&#39; in family     # returns True<br>
<br>
&#39;marge&#39; in family   # returns False (only checks keys)<br>
<br>


<br>
<br>
# returns a list (Python 2) or an iterable view (Python 3)<br>
<br>
family.keys()       # keys: [&#39;dad&#39;, &#39;mom&#39;, &#39;size&#39;]<br>
<br>
family.values()     # values: [&#39;homer&#39;, &#39;marge&#39;, 6]<br>
<br>
family.items()      # key-value pairs: [(&#39;dad&#39;, &#39;homer&#39;), (&#39;mom&#39;, &#39;marge&#39;), (&#39;size&#39;, 6)]<br>
<br>


<br>
<br>
# modify a dictionary (does not return the dictionary)<br>
<br>
family[&#39;cat&#39;] = &#39;snowball&#39;              # add a new entry<br>
<br>
family[&#39;cat&#39;] = &#39;snowball ii&#39;           # edit an existing entry<br>
<br>
del family[&#39;cat&#39;]                       # delete an entry<br>
<br>
family[&#39;kids&#39;] = [&#39;bart&#39;, &#39;lisa&#39;]       # dictionary value can be a list<br>
<br>
family.pop(&#39;dad&#39;)                       # remove an entry and return the value (&#39;homer&#39;)<br>
<br>
family.update({&#39;baby&#39;:&#39;maggie&#39;, &#39;grandpa&#39;:&#39;abe&#39;})   # add multiple entries<br>
<br>


<br>
<br>
# access values more safely with &#39;get&#39;<br>
<br>
family[&#39;mom&#39;]                       # returns &#39;marge&#39;<br>
<br>
family.get(&#39;mom&#39;)                   # equivalent<br>
<br>
family[&#39;grandma&#39;]                   # throws an error since the key does not exist<br>
<br>
family.get(&#39;grandma&#39;)               # returns None instead<br>
<br>
family.get(&#39;grandma&#39;, &#39;not found&#39;)  # returns &#39;not found&#39; (the default)<br>
<br>


<br>
<br>
# access a list element within a dictionary<br>
<br>
family[&#39;kids&#39;][0]                   # returns &#39;bart&#39;<br>
<br>
family[&#39;kids&#39;].remove(&#39;lisa&#39;)       # removes &#39;lisa&#39;<br>
<br>


<br>
<br>
# string substitution using a dictionary<br>
<br>
&#39;youngest child is %(baby)s&#39; % family   # returns &#39;youngest child is maggie&#39;<br>
<br>


<br>
<br>


<br>
<br>


<br>
<br>
### SETS ###<br>
<br>
## properties: unordered, iterable, mutable, can contain multiple data types<br>
<br>
## made of unique elements (strings, numbers, or tuples)<br>
<br>
## like dictionaries, but with keys only (no values)<br>
<br>


<br>
<br>
# create an empty set<br>
<br>
empty_set = set()
<br>
<br>


<br>
<br>
# create a set<br>
<br>
languages = {&#39;python&#39;, &#39;r&#39;, &#39;java&#39;}         # create a set directly<br>
<br>
snakes = set([&#39;cobra&#39;, &#39;viper&#39;, &#39;python&#39;])  # create a set from a list<br>
<br>


<br>
<br>
# examine a set<br>
<br>
len(languages)              # returns 3<br>
<br>
&#39;python&#39; in languages       # returns True<br>
<br>


<br>
<br>
# set operations<br>
<br>
languages &amp; snakes          # returns intersection: {&#39;python&#39;}<br>
<br>
languages | snakes          # returns union: {&#39;cobra&#39;, &#39;r&#39;, &#39;java&#39;, &#39;viper&#39;, &#39;python&#39;}<br>
<br>
languages - snakes          # returns set difference: {&#39;r&#39;, &#39;java&#39;}<br>
<br>
snakes - languages          # returns set difference: {&#39;cobra&#39;, &#39;viper&#39;}<br>
<br>


<br>
<br>
# modify a set (does not return the set)<br>
<br>
languages.add(&#39;sql&#39;)        # add a new element<br>
<br>
languages.add(&#39;r&#39;)          # try to add an existing element (ignored, no error)<br>
<br>
languages.remove(&#39;java&#39;)    # remove an element<br>
<br>
languages.remove(&#39;c&#39;)       # try to remove a non-existing element (throws an error)<br>
<br>
languages.discard(&#39;c&#39;)      # remove an element if present, but ignored otherwise<br>
<br>
languages.pop()             # remove and return an arbitrary element<br>
<br>
languages.clear()           # remove all elements<br>
<br>
languages.update([&#39;go&#39;, &#39;spark&#39;])  # add multiple elements (can also pass a set)<br>
<br>


<br>
<br>
# get a sorted list of unique elements from a list<br>
<br>
sorted(set([9, 0, 2, 1, 0]))    # returns [0, 1, 2, 9]<br>
<br>


<br>
<br>


<br>
<br>


<br>
<br>
### DEFINING FUNCTIONS ###<br>
<br>


<br>
<br>
# define a function with no arguments and no return values<br>
<br>
def print_text():
<br>
<br>
    print(&#39;this is text&#39;)
<br>
<br>


<br>
<br>
# call the function<br>
<br>
print_text()
<br>
<br>


<br>
<br>
# define a function with one argument and no return values<br>
<br>
def print_this(x):
<br>
<br>
    print(x)
<br>
<br>


<br>
<br>
# call the function<br>
<br>
print_this(3)       # prints 3<br>
<br>
n = print_this(3)   # prints 3, but doesn&#39;t assign 3 to n<br>
<br>
                    #   because the function has no return statement<br>
<br>


<br>
<br>
# define a function with one argument and one return value<br>
<br>
def square_this(x):
<br>
<br>
    return x**2<br>
<br>


<br>
<br>
# include an optional docstring to describe the effect of a function<br>
<br>
def square_this(x):
<br>
<br>
    &quot;&quot;&quot;Return the square of a number.&quot;&quot;&quot;<br>
<br>
    return x**2<br>
<br>


<br>
<br>
# call the function<br>
<br>
square_this(3)          # prints 9<br>
<br>
var = square_this(3)    # assigns 9 to var, but does not print 9<br>
<br>


<br>
<br>
# define a function with two &#39;positional arguments&#39; (no default values) and<br>
<br>
# one &#39;keyword argument&#39; (has a default value)<br>
<br>
def calc(a, b, op=&#39;add&#39;):
<br>
<br>
    if op == &#39;add&#39;:
<br>
<br>
        return a + b
<br>
<br>
    elif op == &#39;sub&#39;:
<br>
<br>
        return a - b
<br>
<br>
    else:
<br>
<br>
        print(&#39;valid operations are add and sub&#39;)
<br>
<br>


<br>
<br>
# call the function<br>
<br>
calc(10, 4, op=&#39;add&#39;)   # returns 14<br>
<br>
calc(10, 4, &#39;add&#39;)      # also returns 14: unnamed arguments are inferred by position<br>
<br>
calc(10, 4)             # also returns 14: default for &#39;op&#39; is &#39;add&#39;<br>
<br>
calc(10, 4, &#39;sub&#39;)      # returns 6<br>
<br>
calc(10, 4, &#39;div&#39;)      # prints &#39;valid operations are add and sub&#39;<br>
<br>


<br>
<br>
# use &#39;pass&#39; as a placeholder if you haven&#39;t written the function body<br>
<br>
def stub():
<br>
<br>
    pass<br>
<br>


<br>
<br>
# return two values from a single function<br>
<br>
def min_max(nums):
<br>
<br>
    return min(nums), max(nums)
<br>
<br>


<br>
<br>
# return values can be assigned to a single variable as a tuple<br>
<br>
nums = [1, 2, 3]
<br>
<br>
min_max_num = min_max(nums)         # min_max_num = (1, 3)<br>
<br>


<br>
<br>
# return values can be assigned into multiple variables using tuple unpacking<br>
<br>
min_num, max_num = min_max(nums)    # min_num = 1, max_num = 3<br>
<br>


<br>
<br>


<br>
<br>


<br>
<br>
### ANONYMOUS (LAMBDA) FUNCTIONS ###<br>
<br>
## primarily used to temporarily define a function for use by another function<br>
<br>


<br>
<br>
# define a function the &quot;usual&quot; way<br>
<br>
def squared(x):
<br>
<br>
    return x**2<br>
<br>


<br>
<br>
# define an identical function using lambda<br>
<br>
squared = lambda x: x**2<br>
<br>


<br>
<br>
# sort a list of strings by the last letter (without using lambda)<br>
<br>
simpsons = [&#39;homer&#39;, &#39;marge&#39;, &#39;bart&#39;]
<br>
<br>
def last_letter(word):
<br>
<br>
    return word[-1]
<br>
<br>
sorted(simpsons, key=last_letter)
<br>
<br>


<br>
<br>
# sort a list of strings by the last letter (using lambda)<br>
<br>
sorted(simpsons, key=lambda word: word[-1])
<br>
<br>


<br>
<br>


<br>
<br>


<br>
<br>
### FOR LOOPS AND WHILE LOOPS ###<br>
<br>


<br>
<br>
# range returns a list of integers (Python 2) or a sequence (Python 3)<br>
<br>
range(0, 3)     # returns [0, 1, 2]: includes start value but excludes stop value<br>
<br>
range(3)        # equivalent: default start value is 0<br>
<br>
range(0, 5, 2)  # returns [0, 2, 4]: third argument is the step value<br>
<br>


<br>
<br>
# Python 2 only: use xrange to create a sequence rather than a list (saves memory)<br>
<br>
xrange(100, 100000, 5)
<br>
<br>


<br>
<br>
# for loop (not the recommended style)<br>
<br>
fruits = [&#39;apple&#39;, &#39;banana&#39;, &#39;cherry&#39;]
<br>
<br>
for i in range(len(fruits)):
<br>
<br>
    print(fruits[i].upper())
<br>
<br>


<br>
<br>
# for loop (recommended style)<br>
<br>
for fruit in fruits:
<br>
<br>
    print(fruit.upper())
<br>
<br>


<br>
<br>
# iterate through two things at once (using tuple unpacking)<br>
<br>
family = {&#39;dad&#39;:&#39;homer&#39;, &#39;mom&#39;:&#39;marge&#39;, &#39;size&#39;:6}
<br>
<br>
for key, value in family.items():
<br>
<br>
    print(key, value)
<br>
<br>


<br>
<br>
# use enumerate if you need to access the index value within the loop<br>
<br>
for index, fruit in enumerate(fruits):
<br>
<br>
    print(index, fruit)
<br>
<br>


<br>
<br>
# for/else loop<br>
<br>
for fruit in fruits:
<br>
<br>
    if fruit == &#39;banana&#39;:
<br>
<br>
        print(&#39;Found the banana!&#39;)
<br>
<br>
        break    # exit the loop and skip the &#39;else&#39; block<br>
<br>
else:
<br>
<br>
    # this block executes ONLY if the for loop completes without hitting &#39;break&#39;<br>
<br>
    print(&quot;Can&#39;t find the banana&quot;)
<br>
<br>


<br>
<br>
# while loop<br>
<br>
count = 0<br>
<br>
while count &lt; 5:
<br>
<br>
    print(&#39;This will print 5 times&#39;)
<br>
<br>
    count += 1    # equivalent to &#39;count = count + 1&#39;<br>
<br>


<br>
<br>


<br>
<br>


<br>
<br>
### COMPREHENSIONS ###<br>
<br>


<br>
<br>
# for loop to create a list of cubes<br>
<br>
nums = [1, 2, 3, 4, 5]
<br>
<br>
cubes = []
<br>
<br>
for num in nums:
<br>
<br>
    cubes.append(num**3)
<br>
<br>


<br>
<br>
# equivalent list comprehension<br>
<br>
cubes = [num**3 for num in nums]    # [1, 8, 27, 64, 125]<br>
<br>


<br>
<br>
# for loop to create a list of cubes of even numbers<br>
<br>
cubes_of_even = []
<br>
<br>
for num in nums:
<br>
<br>
    if num % 2 == 0:
<br>
<br>
        cubes_of_even.append(num**3)
<br>
<br>


<br>
<br>
# equivalent list comprehension<br>
<br>
# syntax: [expression for variable in iterable if condition]<br>
<br>
cubes_of_even = [num**3 for num in nums if num % 2 == 0]    # [8, 64]<br>
<br>


<br>
<br>
# for loop to cube even numbers and square odd numbers<br>
<br>
cubes_and_squares = []
<br>
<br>
for num in nums:
<br>
<br>
    if num % 2 == 0:
<br>
<br>
        cubes_and_squares.append(num**3)
<br>
<br>
    else:
<br>
<br>
        cubes_and_squares.append(num**2)
<br>
<br>


<br>
<br>
# equivalent list comprehension (using a ternary expression)<br>
<br>
# syntax: [true_condition if condition else false_condition for variable in iterable]<br>
<br>
cubes_and_squares = [num**3 if num % 2 == 0 else num**2 for num in nums]    # [1, 8, 9, 64, 25]<br>
<br>


<br>
<br>
# for loop to flatten a 2d-matrix<br>
<br>
matrix = [[1, 2], [3, 4]]
<br>
<br>
items = []
<br>
<br>
for row in matrix:
<br>
<br>
    for item in row:
<br>
<br>
        items.append(item)
<br>
<br>


<br>
<br>
# equivalent list comprehension<br>
<br>
items = [item for row in matrix
<br>
<br>
              for item in row]      # [1, 2, 3, 4]<br>
<br>


<br>
<br>
# set comprehension<br>
<br>
fruits = [&#39;apple&#39;, &#39;banana&#39;, &#39;cherry&#39;]
<br>
<br>
unique_lengths = {len(fruit) for fruit in fruits}   # {5, 6}<br>
<br>


<br>
<br>
# dictionary comprehension<br>
<br>
fruit_lengths = {fruit:len(fruit) for fruit in fruits}              # {&#39;apple&#39;: 5, &#39;banana&#39;: 6, &#39;cherry&#39;: 6}<br>
<br>
fruit_indices = {fruit:index for index, fruit in enumerate(fruits)} # {&#39;apple&#39;: 0, &#39;banana&#39;: 1, &#39;cherry&#39;: 2}<br>
<br>


<br>
<br>


<br>
<br>


<br>
<br>
### MAP AND FILTER ###<br>
<br>


<br>
<br>
# &#39;map&#39; applies a function to every element of a sequence<br>
<br>
# ...and returns a list (Python 2) or iterator (Python 3)<br>
<br>
simpsons = [&#39;homer&#39;, &#39;marge&#39;, &#39;bart&#39;]
<br>
<br>
map(len, simpsons)                      # returns [5, 5, 4]<br>
<br>
map(lambda word: word[-1], simpsons)    # returns [&#39;r&#39;, &#39;e&#39;, &#39;t&#39;]<br>
<br>


<br>
<br>
# equivalent list comprehensions<br>
<br>
[len(word) for word in simpsons]
<br>
<br>
[word[-1] for word in simpsons]
<br>
<br>


<br>
<br>
# &#39;filter&#39; returns a list (Python 2) or iterator (Python 3) containing<br>
<br>
# ...the elements from a sequence for which a condition is True<br>
<br>
nums = range(5)
<br>
<br>
filter(lambda x: x % 2 == 0, nums)      # returns [0, 2, 4]<br>
<br>


<br>
<br>
# equivalent list comprehension<br>
<br>
[num for num in nums if num % 2 == 0]
<br>
</table>
