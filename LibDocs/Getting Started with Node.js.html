<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width"/>
<link rel="stylesheet" href="..\maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script>
$(document).ready(function(){
    $('h1, h2, h3, h4, h5, .goldword, .apply, div.title').click(function(){
    parent.history.back();
    return false;
    });
});
</script>
<style>
body{width:80%;margin-left: 10%; font-size:20px; line-height:1.8;}
h1, h2 {color: gold;}
</style>
</head><body>
<center><h1>Getting Started with Node.js</h1>
<div id="toc"></div></center>

<pre>

<h3>Chapter 1: The Fundamentals of Node.js</h3>
<h3>The What and Why</h3>
Let’s start at the very beginning: What exactly is Node.js?
Node is usually defined as "JavaScript on backend servers". 
Before Node, that was not a common or easy thing. 
JavaScript was mainly a frontend thing.

However, this definition isn’t really an accurate one because Node offers a lot more than executing JavaScript on servers. 
In fact, the execution of JavaScript is not done by Node at all. 
It’s done with a Virtual Machine (VM) like <a href="https://developers.google.com/v8/">V8</a> or <a href="https://github.com/Microsoft/ChakraCore">Chakra</a>. 
Node is just the coordinator. 
It’s the one who instructs a VM like V8 to execute your JavaScript.

Node is better defined as "<strong class="markup--strong markup--p-strong">a wrapper around a VM like V8</strong>".

<blockquote>V8 is Google’s open source JavaScript engine. 
It’s written in C++ and it’s used in Google Chrome and in Node.js. 
Both Chrome and Node use V8 to execute JavaScript code. 
V8 is the default VM in Node, but you can run Node with other VMs if you need to.
</blockquote>
When you write JavaScript code and execute it with the <code class="markup--code markup--p-code">node</code> command, Node will pass your JavaScript to V8, V8 will execute that JavaScript and tell Node what the result is, and Node will make the result available to you.

That’s the simple story, but Node.js is more useful than just that. 
Node comes with some handy, built-in modules providing easy-to-use asynchronous APIs. 
Let’s talk about that, and a few other reasons why developers are picking Node.js over many other options when it comes to creating services for their backends.

<h4>1) Native Modules</h4>
Node comes with <a href="https://nodejs.org/api/index.html">feature-rich modules</a> that make it a great platform for hosting and managing servers. 
These modules offer features like reading and writing files, consuming data over the network, and even compressing and encrypting data You don’t need to install these modules. 
They come natively packaged with Node!

The big deal about these modules is that they offer asynchronous APIs that you can just use directly without worrying about threads. 
Yes! You can do asynchronous programming in Node and do things in parallel without needing to deal with threads. 
This is a big deal and it’s probably 
the most common benefit of using a runtime like Node.

The asynchronous nature of these modules works great with VMs like V8 because these VMs are all single-threaded. 
This is true for both Node and Browsers. 
You only get a single precious thread to work with. 
It’s extremely important to not block that thread. 
For example, in your browser, if your website blocks that single thread for, say 2 seconds, the user cannot scroll up and down during these 2 seconds! In Node, if an incoming HTTP connection to your web server was handled synchronously rather than asynchronously, that’ll block the single thread, and your whole web server cannot handle any other connections while the synchronous operation is active. 
That’s very bad.

<blockquote>Working with Node’s modules and their asynchronous nature will be covered in Chapter 3.</blockquote>
If Node’s built-in modules were not enough for you, you can build high-performing packages using C++! Node has <a href="https://nodejs.org/api/addons.html">first-class support for C++ addons</a>
, creating dynamically linked shared objects that you can use directly with Node. 
Of course you can also write your addons in JavaScript if you want.

Node also ships with a powerful <a href="https://nodejs.org/api/debugger.html">debugger</a> and has some other handy, generic utilities that enhance the JavaScript language and provide extra APIs (for example, to create 
<a href="https://medium.freecodecamp.org/javascript-timers-everything-you-need-to-know-5f31eaa37162">timers</a>, work with data types, and process arrays and objects).

Even if you don’t want to host your backend servers in Node, having the powerful, built-in features — and the ease to add more — makes Node a great platform for tools to work with other applications and enhance your work flow.

<a href="https://edgecoders.com/why-react-developers-love-node-83f6053d68" data-href="https://edgecoders.com/why-react-developers-love-node-83f6053d68" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://edgecoders.com/why-react-developers-love-node-83f6053d68">
<strong class="markup--strong markup--mixtapeEmbed-strong">Why React Developers LOVE Node</strong></a>

Some people mistakenly assume that Node is required in order to use React. 
It is not. 
You don’t need Node to run a…
edgecoders.com
<a href="https://edgecoders.com/why-react-developers-love-node-83f6053d68" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="a891cc6e24611eb9753e9eb7c0c31137" data-thumbnail-img-id="1*q7DQs5_xIPAGmMXy1VqETw.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*q7DQs5_xIPAGmMXy1VqETw.png);"></a>
<h4>2) A Package Manager and a Dependency Manager</h4>
Node ships with a powerful package manager (which is called <a href="https://www.npmjs.com/">NPM</a>). 
We did not have a package manager in the JavaScript world before Node. 
NPM was nothing short of revolutionary. 
It changed the way we work and share JavaScript. 
Node was the enabler of this because NPM ships natively with Node.

NPM is basically the world’s largest collection of FREE and reusable code. 
You can make a feature-rich Node application just by using code that’s freely available on NPM. 
NPM is a reliable package manager which comes with a simple CLI (the <code class="markup--code markup--p-code">npm</code> command). 
The <code class="markup--code markup--p-code">npm</code> command makes it really easy to install third-party packages, share your own code, and reuse your own code. 
In addition, <a href="https://www.npmjs.com/">the NPM registry</a>, where the packages get hosted, has so many options. 
By "so many", I mean hundreds of thousands of options of FREE tools that you can just install and use on your Node servers.

The other big thing about Node is that it comes with a reliable <a href="https://nodejs.org/docs/latest/api/modules.html">module dependency manager</a> (different than NPM). 
This module dependency manager is also another thing that we did not have in the JavaScript world.

<blockquote>experimentally-supported in Node.js</a> as well.
</blockquote>
Node’s module dependency manager has been available since Node was released and it opened the door to so much flexibility in how we code JavaScript! It is widely used, even for JavaScript that gets executed in the browser, because NPM has many tools to bridge the gap between modules written in Node and what browsers can work with today.

NPM and Node’s module system together make a big difference when you work with any JavaScript system, not just the JavaScript that you execute on backend servers or web browsers. 
For example, if you have a fancy fridge monitor that happens to run on JavaScript, you can use Node and NPM for the tools to package, organize, and manage dependencies, and then bundle your code, and ship it to your fridge!

<h4>3) One Language to Rule Them All</h4>
By using Node, you’re committing to the flexible JavaScript language, which is used on every website today. 
It is the most popular programming language and that statement will continue to be true for decades to come. 
Despite its problems, JavaScript is actually a good language today.

<a href="https://edgecoders.com/you-dont-hate-javascript-62cd6c609d43" data-href="https://edgecoders.com/you-dont-hate-javascript-62cd6c609d43" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://edgecoders.com/you-dont-hate-javascript-62cd6c609d43">
<strong class="markup--strong markup--mixtapeEmbed-strong">You don’t hate JavaScript</strong>

But something else might make you think you do edgecoders.com</a>
<a href="https://edgecoders.com/you-dont-hate-javascript-62cd6c609d43" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="03e500ccfd2458dec23f298e18e96169" data-thumbnail-img-id="1*rPanv1D_fFShUEpD-WvGZg.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*rPanv1D_fFShUEpD-WvGZg.png);"></a>
With Node, you get to have a single language across the full-stack. 
You use JavaScript in the browser and you use it for the backend as well. 
There are some subtle but great benefits to that:

<ul class="postList">
<li>One language means less syntax to keep in your head, less APIs and tools to work with, and less mistakes over all.</li>
<li>One language means better integrations between your frontend code and your backend code. 
You can actually share code between these 2 sides. 
For example, you can reuse your frontend UI components code to render server-side HTML.
</li>
<li>One language means teams can share responsibilities among different projects. 
Projects don’t need a dedicated team for the frontend and a different team for the backend. 
You would eliminate some dependencies between teams. 
The project can be a single team, The JavaScript People. 
They can develop APIs. 
They can develop web and network servers. 
They can develop rich, interactive websites.
</li>
</ul>
<h4>There will be dragons</h4>
Node is not all rainbows and unicorns. 
It has some disadvantages, which are interestingly the same advantage points if you just look at them with different bias. 
For example, Node’s asynchronous non-blocking nature is just a completely different model of thinking and reasoning about code. 
If you’ve never done it before, it is going to feel weird at first. 
You need time to get your head wrapped around this model and to get used to it.

Having a big package registry offering many options means that for every single thing you need to do you have many options to pick from, and some people hate that. 
You need to constantly research these options and make a mental effort to pick the "better" ones. 
These options usually have big differences and you might end up spending a lot of time researching them.

Also, NPM along with Node’s module manager enabled shipping smaller and smaller code. 
This means you need to use more and more packages. 
It’s not unusual for a Node application to use 300 or more packages. 
This is both a good thing and a bad thing depending on who you ask. 
I think it’s a good thing. 
Smaller packages are easier to control, maintain, and scale, but you do have to make peace with the fact that you’ll be using a lot of them.

<blockquote>Smaller code is actually why Node is named Node! In Node, we build simple small single-process building blocks (nodes) that can be organized with good networking protocols, to have them communicate with each other and scale up to build large, distributed programs.
</blockquote>
<h3>Node’s REPL Mode</h3>
Let’s explore the <code class="markup--code markup--p-code">node</code> command. 
When you type the <code class="markup--code markup--p-code">node</code> command without a script for it to execute, Node will start a REPL session.

REPL stands for Read, Eval, Print, Loop. 
It’s a very convenient way to quickly test simple JavaScript and Node commands. 
You can type any JavaScript code in the REPL. 
For example, type <code class="markup--code markup--p-code">Math.random()</code> and then, press Enter:


<img src="https://cdn-images-1.medium.com/max/800/1*j0Px30UEm4rJijwp6NHliA.png">
<figcaption class="imageCaption">Node’s REPL
</figcaption>

Node will Read your line, Evaluate it, Print the result, and Loop over these 3 things until you exit the session (which you can do with a <code class="markup--code markup--p-code">CTRL+D</code>).

Note how the Print step happened automatically. 
We didn’t need to add any instructions to print the result. 
Node will just print the result of each line you type. 
This is cool, but keep in mind that some lines will not have any results at all. 
The Node REPL will print "undefined" in that case.

For example, if you typed:

<pre>let answer = 42;
</pre>
This is a statement in JavaScript. 
It’s not an expression. 
It does not have any output. 
When you hit Enter, you’ll see that the REPL prints 
undefined as the output of this statement. 
Don’t let that confuse you.


<img src="https://cdn-images-1.medium.com/max/800/1*gnCI7vlv9kGGAS-DSjIPPQ.png">

On the other hand, if you type an expression, for example:

<pre>3 == &#39;3&#39;
</pre>
This is a Boolean expression. 
The REPL will print its result for you:


<img src="https://cdn-images-1.medium.com/max/800/1*cJ-EAq0HhPyplQNsDcMr7Q.png">

Sometimes, the expression that you need to test might need multiple lines. 
For example, say that you want to define a function that generates today’s date and test it out. 
You’ll start with the function name and begin with a curly brace. 
You hit Enter there:


<img src="https://cdn-images-1.medium.com/max/800/1*kv4I7AvBuLQB_iPIOP1xIw.png">

The Node’s REPL is smart enough to detect that your code is not done yet and it will go into a multi-line mode for you to type more. 
If you finish a valid function definition, you’ll get out of this multiline mode:


<img src="https://cdn-images-1.medium.com/max/800/1*5VsES6EozrjBCHBoR8QJDA.png">

This REPL multi-line mode is limited. 
Node has a more featured editor right inside the REPL. 
You type <code class="markup--code markup--p-code">.editor</code> to open it up and when you do, you can type as many lines as you need. 
For example, you can define multiple functions or paste code from the clipboard:


<img src="https://cdn-images-1.medium.com/max/800/1*G04qdgUzOnkw553ZRVFlpQ.png">

When you are done typing, you hit <code class="markup--code markup--p-code">Control+D</code> to have the REPL evaluate your code. 
All the functions you defined in the editor will be available in your REPL session.

The <code class="markup--code markup--p-code">.editor</code> command is a REPL 
special command. 
There are a few other special commands. 
You can see the list by typing the <code class="markup--code markup--p-code">.help</code> command:


<img src="https://cdn-images-1.medium.com/max/800/1*iJvPMol4DbsramYCJZi-FQ.png">

The <code class="markup--code markup--p-code">.break</code> command (or its <code class="markup--code markup--p-code">.clear</code> alias) lets you get out of some weird cases in a REPL session. 
For example, when you paste some code in Node’s multi-line mode and you are not sure how many curly braces you need to get to an executable state. 
You can discard your pasted code by using a <code class="markup--code markup--p-code">.break</code> command. 
This saves you from killing a session to get yourself out of simple situations like this one.


<img src="https://cdn-images-1.medium.com/max/800/1*JcFc9ddiViI4_5Z03uj4Dg.png">

The <code class="markup--code markup--p-code">.load</code> and <code class="markup--code markup--p-code">.save</code> commands can be used to generate and use external Node scripts inside your REPL. 
This can be a great time saver.

<h4>Use The TAB Key!</h4>
I need to emphasize the importance of the TAB key. 
If you are not familiar with this powerful key, you’re in for a treat!

The TAB character itself is not a useful one, but the TAB key is the driver of a very powerful feature called TAB-Completion. 
You might be familiar with that feature in your code editor, but I’d like you to also be aware that it works inside Node’s REPL as well.

A single TAB in Node’s REPL can be used for autocompletion, and a double TAB (which is pressing the TAB key twice) can be used to see a list of possible things you can type from whatever partially-typed string you have.

For example. 
If you type the character <code class="markup--code markup--p-code">c</code> and then double TAB on that, you’ll see all the possible keywords and functions that start with <code class="markup--code markup--p-code">c</code>
:


<img src="https://cdn-images-1.medium.com/max/800/1*a4Y2pPbXPmIue6rHS93LBg.png">

If you single TAB on something that matches only a single option, it’ll be auto-completed. 
For example, <code class="markup--code markup--p-code">crypto</code> in the list above is the only keyword that begins with <code class="markup--code markup--p-code">cr</code>. 
So, if you single TAB after typing <code class="markup--code markup--p-code">cr</code>, <code class="markup--code markup--p-code">crypto</code> will be auto-completed.

This is not about being lazy and not wanting to type the whole thing. 
The usefulness of this TAB-Completion is about avoiding typing mistakes and 
discovering what is available.

This latter point is important. 
For example, say I want to know what API functions and properties I can use on the <code class="markup--code markup--p-code">Array</code> class. 
I can type <code class="markup--code markup--p-code">Array</code> and then I can type the <code class="markup--code markup--p-code">.</code> character and double TAB after that:


<img src="https://cdn-images-1.medium.com/max/800/1*gpM5oNqPjNeGRkdFvy54ag.png">
<figcaption class="imageCaption">All the functions and properties that can be used from the Array class.
</figcaption>

TAB-Completion also works on objects. 
If you have an array object in the REPL session, you can use the same <code class="markup--code markup--p-code">.</code> character then double TAB trick to get a list of all the methods available on that object:


<img src="https://cdn-images-1.medium.com/max/800/1*-Vr1TnSURlpqaBz9w95oVQ.png">
<figcaption class="imageCaption">Can’t remember the name of a method you need? TAB-Completion can help.
</figcaption>

The TAB-completion discoverability works anywhere within the REPL session. 
For example, you can see the special dot commands by double tabbing on a single <code class="markup--code markup--p-code">.</code> character:


<img src="https://cdn-images-1.medium.com/max/800/1*aTgyFw1QftfmLIVQ--KpeQ.png">

This discoverability also works on the global level itself. 
If you double TAB on an empty line, everything that is globally available in Node appears. 
This is a big list, but it’s a useful one:


<img src="https://cdn-images-1.medium.com/max/800/1*dT1TjN1UloivKhatSe74Sw.png">

In this list, you can see all the common globals in the JavaScript language itself, which you’re probably familiar with, like <code class="markup--code markup--p-code">Array</code>, <code class="markup--code markup--p-code">Number</code>, <code class="markup--code markup--p-code">String</code>
, and <code class="markup--code markup--p-code">Object</code> classes, built-in libraries like <code class="markup--code markup--p-code">Math</code> and <code class="markup--code markup--p-code">JSON</code>
, and some other top-level functions. 
This list also has the globals that are available in the Node runtime itself. 
A few of these are truly globals in Node, like the <code class="markup--code markup--p-code">Buffer</code> class, the <code class="markup--code markup--p-code">process</code> object, and the various functions to set and clear timers. 
The lowercase variables in this list (like <code class="markup--code markup--p-code">dns</code>, <code class="markup--code markup--p-code">net</code>, <code class="markup--code markup--p-code">cluster</code>, <code class="markup--code markup--p-code">http</code>
, …) represent the built-in modules in Node. 
These are the powerful libraries that you get out of the box. 
Note that these are available directly in a REPL session, but when working with a regular Node script, you will need to require these modules first to be able to use them.

One of the useful REPL’s features that you can see in the list above is the <code class="markup--code markup--p-code">_</code> (underscore) variable. 
This is similar to the <code class="markup--code markup--p-code">$?</code> feature in Bash. 
It stores the value of the last successfully-evaluated expression. 
For example, say that you executed a <code class="markup--code markup--p-code">Math.random()</code> call, and after you did, you wanted to put that same value in a constant. 
You can do that with <code class="markup--code markup--p-code">_</code> because it automatically stores the last value.


<img src="https://cdn-images-1.medium.com/max/800/1*ivf0yhmfgMDAzUFvgNvJ_A.png">

<h3>Node’s Hello World Example</h3>
Here is Node’s version of a "Hello World" example:

<pre>// server.js
</pre>
<pre>
<strong">const http = require(&#39;http&#39;);</strong>                        // 1


<strong">const server = http.createServer((req, res) =&gt; {</strong>     // 2

<strong">  res.end(&#39;Hello World\n&#39;);</strong>                          // 3

<strong">
});</strong>                                                  // 4


<strong">server.listen(4242, () =&gt; {  </strong>                        // 5

<strong">  console.log(&#39;Server is running...&#39;);</strong>               // 6

<strong">
});                                   </strong>               // 7
</pre>
This script represents a simple Web server. 
You don’t need to install anything to run this script. 
This is all Node’s built-in power.

To execute a script with Node, you just specify the location of that script as the argument for the <code class="markup--code markup--p-code">node</code> command. 
The location can be absolute or relative (to where you are invoking the node command).

<pre>$ node relative/or/absolute/path/to/server.js
</pre>
If you just provide a file name, the <code class="markup--code markup--p-code">node</code> command will look for that file in the current working directory.

If the script has a running task (like a Web server listening for connections, for example), then Node will continue running.

Let’s decipher the simple web server example…

Line <code class="markup--code markup--p-code">#1</code> uses the <code class="markup--code markup--p-code">require</code> function. 
This is the first thing you need to learn about Node’s internal. 
The <code class="markup--code markup--p-code">require</code> function is what you use to manage the dependencies of your programs. 
You can use <code class="markup--code markup--p-code">require</code> to depend on a library, whether this library is a built-in one (like the <code class="markup--code markup--p-code">http</code> one the example is using) or a 3rd-party installed one (like <code class="markup--code markup--p-code">express</code> which you can get with NPM).

This web server example depends on the built-in <code class="markup--code markup--p-code">http</code> module. 
It’s the module that has the feature of creating a web server. 
There are many other libraries that you can use to create a web server, but this one is built-in. 
You don’t need to install anything to use it, but you do need to require it.

<blockquote>In a Node’s REPL session, built-in modules (like http) are available immediately without needing to require them. 
This is not the case with executable scripts. 
You can’t use any dependencies (including built-in ones) without requiring them first.
</blockquote>
Line <code class="markup--code markup--p-code">#2</code> creates a server constant by invoking the <code class="markup--code markup--p-code">createServer</code> function on the <code class="markup--code markup--p-code">http</code> module. 
This function is one of many functions that are available under the <code class="markup--code markup--p-code">http</code> module’s API. 
You can use it to create a web server object. 
It accepts an argument that is known as the Request Listener. 
The request listener is a simple function that Node will invoke every time there is a request to the web server.

This why this listener function receives the request object as an argument (named <code class="markup--code markup--p-code">req</code> above but you can name it whatever you want). 
The other argument this listener function receives, named <code class="markup--code markup--p-code">res</code> in the example, is a response object. 
It’s the other side for a request connection. 
We can use the <code class="markup--code markup--p-code">res</code> object to write things back to the requester. 
It’s exactly what our simple web server is doing. 
It’s writing back — using the <code class="markup--code markup--p-code">.end</code> method — the "Hello World" string.

<blockquote>.end</code> method can be used as a shortcut to write data and then end the request in one line. 
We will be talking more about the <code class="markup--code markup--blockquote-code">http</code> module in Chapter 5.
</blockquote>
The <code class="markup--code markup--p-code">createServer</code> function only 
creates the server object. 
It does not activate it. 
To activate this web server, you need to invoke the <code class="markup--code markup--p-code">listen</code> function on the created server (line #5).

The <code class="markup--code markup--p-code">listen</code> function accepts many arguments, like what OS 
port and host to use for this server. 
The last argument for it is a function that will be invoked once the server is successfully running on the specified port. 
The example above just logs a message to indicate that the server is running successfully at that point.

Execute the <code class="markup--code markup--p-code">server.js</code> script above using the <code class="markup--code markup--p-code">node</code> command. 
While the server is running, if you go to a browser and ask for an http connection on localhost with the port that was used in the script (4242 in this case), you will see the 
Hello World string that this example had in its request listener function.

</pre>
<script>
	var toc = $('#toc');
	$('h3,h4').each(function(i) {
		var topic = $(this), topicNumber = i + 1;
		toc.append('<a href="#topic-'+topicNumber+'" target="_self">'+topic.text()+'</a><br>');
		topic.attr('id', 'topic-' + topicNumber);
	});
</script>

</body>
</html>
