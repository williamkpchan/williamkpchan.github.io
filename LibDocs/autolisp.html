<base target="_blank"><html><head><title>AutoLisp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src="../lazyload.min.js"></script>
<script type='text/javascript' src='../mainscript.js'></script>
<script src="D:/Dropbox/Public/commonfunctions.js"></script>
<script>
  var showTopicNumber = true;
  var bookid = "AutoLisp"
  var markerName = "h2"
</script>
<style>
body{width:80%;margin-left: 10%; font-size:22px;}
h1, h2 {color: gold;}
strong {color: orange;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px;}
</style></head><body onkeypress="chkKey()"><center>
<h1>AutoLisp</h1>
<a href="#mustWatch" class="red goldbs" target="_self">Must Watch!</a>
<br><br>
<div id="toc"></div></center>
<br><br>
<div id="mustWatch"><center><span class="red">MustWatch</span></center><br>
<a href="https://www.afralisp.net/autolisp/tutorials/the-basics-part-1.php" class="whitebut ">basics</a>
<a href="http://www.lee-mac.com/runlisp.html" class="whitebut ">runlisp</a>

</div>
<pre>
<br>
<br>

<h2>The Basics in a Nutshell</h2>

So, you've never programmed in AutoLisp before!

You've tried to decipher some AutoLisp routines but, you are still totally
confused!!!

Let's see if we can't help you out.

This tutorial will try and teach you the very basics of AutoLisp
programming without overwhelming you with double-gook.

Let's start up with something very simple and that will give you
immediate results. Fire up AutoCad and type this at the command prompt:

(alert "Hello and welcome to AutoLISP!")

Now press enter. This should appear on your screen :

<img class="lazy" data-src="https://www.afralisp.net/autolisp/tutorials/images/lisp16a.png">

Well Done, you've just used AutoLisp to make AutoCAD do something.

As you noticed using the (alert) function results in a dialogue box
being displayed on your screen.

Let's try something else. Type this at the command prompt and press
enter :

(setq a (getpoint))

Then choose a point anywhere on the screen.

A "list" of numbers, looking something like this, should appear
in your command window.

(496.0 555.06 0.0)

This list, believe it or not, contains the x, y and z coordinates of
the point you picked.

x = 496.04
y = 555.06
z = 0.0

The AutoLisp coding :

(setq a (getpoint))

Means, in plain English :

Get a point from the user and store the x, y and z
values as a list in variable "a".

Did you notice how everything is enclosed within parenthesis?

All AutoLisp functions are surrounded by parenthesis.

As well, AutoLisp allows you to "nest" your functions.

This lets you write a function that evaluates another function.

Just remember, that you must leave the nest with an equal number of
parenthesis. Here's an example :

(dosomething (dosomethingelse (andanotherthing)))

You could also write the above statement like this to make it more
readable :

(dosomething
	(dosomethingelse
		(andanotherthing)
	)
)

Now you can see why "Lisp" is often known as "Lost in
Stupid Parenthesis"

You can also add comments to your coding. Anything preceded with a
semicolon is not evaluated by Autolisp and is treated as a comment, much the
same way as the REM statement in Basic is used. e.g.

(dosomething
	(dosomethingelse
		(andanotherthing)  ;This is a comment
	)  ;This is another comment
)  ;and another comment

The statement we wrote earlier, told AutoLisp to get a point from the
user and store the value in variable "a".

Now type this at the command line :

!a

The point list should be returned. So, any time that you would like to
inspect a variable, just precede the variable name with "!"

Our getpoint function worked, but it didn't really tell the user what
was expected from him by way of input. Try this now :

(setq a ( getpoint "\nChoose a Point : "))

Did you notice how Autolisp now asks you for input (and what type of
input is expected.)

Let's write a programme.

Type in each of these lines, one at a time, pressing "Enter" at
the end of each line, then choosing a point.

(setq a (getpoint "\nEnter First Point : "))

Press "Enter" then select a point.

(setq b (getpoint "\nEnter Second Point : "))

Again, Press "Enter" then select a second point.

(command "Line" a b ")

Press "Enter" again. A line should be drawn between the two
points.

The (command) function is used to tell AutoCad what you want it to do.

"Line"	Draw a Line
a	From the point stored in variable "a"
b	To the point stored in variable "b"
"	Enter to close the Line command.

Now this is very nice, but do we have to type in all this coding every
time we want to use this routine?
we will discuss how to "store" your programmes in a file.

We now need to be able to "store" our AutoLisp routines in a
file.

AutoLisp files are simple ASCII text files with the extension
"lsp".

Open up Notepad or any other simple text editor and type in the following :

(defun testline ()
;define the function
 
(setq a (getpoint "\nEnter First Point : "))
;get the first point
 
(setq b (getpoint "\nEnter Second Point : "))
;get the second point
 
(command "Line" a b ")
;draw the line
 
)	;end defun

Now, save this file as "testline.lsp" remembering, to save it
as a ASCII Text file and ensuring that it is saved in a directory in your
AutoCAD's search path. Now open AutoCAD and type this :

(load "testline")

This will load the function into memory. (Did you notice that you do
not have to stipulate the "lsp" extension?) Now type this :

(testline)

Your function should now run.

Let's edit this routine so that it acts like a standard AutoCAD command :

(defun c:testline ()
;define the function
 
(setq a (getpoint "\nEnter First Point : "))
;get the first point
 
(setq b (getpoint "\nEnter Second Point : "))
;get the second point
 
(command "Line" a b ")
;draw the line
 
)	;end defun

By preceding the function name with c: we do not have to enclose the
name with brackets when running. Re-load the function and run it again.

(load "testline")
testline

Much better, Hey?

We do have one problem though. Did you notice that when we loaded the
routine, an annoying "nil" kept on popping up. We also got the
same "nil" returned to us when we ran the routine. To suppress
this "nil" when loading or running, we can use the (princ) function. Here's what your routine would
look like :

(defun c:testline ()
;define the function
 
(setq a (getpoint "\nEnter First Point : "))
;get the first point
 
(setq b (getpoint "\nEnter Second Point : "))
;get the second point
 
(command "Line" a b ")
;draw the line
 
(princ)
;clean running
 
)	;end defun
(princ)
;clean loading

For more details on the (defun) function, refer to The AfraLisp
Tutorial : &lt;a href="/autolisp/tutorials/the-define-function.php">Define Function (defun)&lt;/a>.

And for a more detailed explanation of loading AutoLisp routines, refer
to the AfraLisp tutorial : &lt;a href="/autolisp/tutorials/loading-autolisp-files.php">Loading AutoLisp Files&lt;/a>.

Now it's time to make AutoLisp do some calculations for us.

Let's say we wanted AutoLisp to draw a beam, in elevation, for us.

First of all we would start by getting input from the user regarding
certain parameters that we would need to draw the beam.

Here's what we are trying to draw, along with the values that the user

needs to input.

<img class="lazy" data-src="https://www.afralisp.net/autolisp/tutorials/images/lisp16b.gif">

The values that we need to retrieve from the user are as follows :

Insertion Point		ip
Length of Beam		lb
Height of Beam		hb
Flange Thickness	wt
End Plate Thickness	ep
Length of Notch		nl
Depth of Notch		nd

Let's write a routine to retrieve these values first.

(defun c:testbeam ()
;define the function
 
;********************************************************
;Get User Inputs	

(setq lb (getdist "\nLength of Beam : "))
;get the length of the beam
 
(setq hb (getdist "\nHeight of Beam : "))
;get the height of the beam
 
(setq wt (getdist "\nFlange Thickness : "))
;get the thickness of the flange
 
(setq ep (getdist "\nEnd Plate Thickness : "))
;get the thickness of the end plate
 
(setq nl (getdist "\nLength of Notch : "))
;get the length of notch
 
(setq nd (getdist "\nDepth of Notch : "))
;get the depth of the notch
 
;End of User Inputs
;*********************************************************
;Get Insertion Point
 
(setq ip (getpoint "\nInsertion Point : "))
;get the insertion point
 
;********************************************************
(princ)
;finish cleanly
 
)	;end of defun
 
;**********************************************************
(princ)	;load cleanly
;**********************************************************

Load and run the routine. You will be prompted for all the values
listed above. Enter some numbers and then check the value of all the
variables by preceeding the value names with "!" (e.g. !ip).

O.K. we've got all the values we need from the user.

But first we need to do some calculations to determine the other points
required before we can draw the beam.

Well, as you can see in the image below, we have quite a few points that we need to calculate.

Fortunately, AutoLisp has a function to help us, the (polar) function.

The (polar) function works like this :

You pass it a point, an angle and a distance and (polar) will return a
second point at the specified angle and distance from the first point.

But, we have one problem. All angles in AutoLisp &lt;strong>must&lt;/strong> be given in
radians.

&lt;strong>What is a Radian?&lt;/strong> A radian is the angle subtended at the centre of a circle by an arc with a length equal to the radius of that circle. It works out at 180/Pi degrees. See the &lt;a href="http://en.wikipedia.org/wiki/Radian">Wikipedia article&lt;/a> for more information.

<img class="lazy" data-src="https://www.afralisp.net/autolisp/tutorials/images/lisp16c.gif">

Let's quickly write a function to do that. Add this function to your
Testbeam.lsp file :

(defun dtr (x)
;define degrees to radians function
 
(* pi (/ x 180.0))
;divide the angle by 180 then
;multiply the result by the constant PI
 
)	;end of function

O.K. thats our "degrees to radians" function taken care of.

Now we'll have a look at the (polar) function in action.

(setq p2 (polar ip (dtr 180.0) (- (/ lb 2) nl)))

What we are saying here is :

"Set the variable "p2" to a point that, from the
insertion point "ip", at an angle of 180.0 degrees (converted to
radians), is at a distance of the length of the beam divided by 2, minus
the length of the notch."

This will calculate and return the point "p2". Let's do the rest :

(defun c:testbeam ()
;define the function
 
;********************************************************
;Get User Inputs	

(setq lb (getdist "\nLength of Beam : "))
;get the length of the beam
 
(setq hb (getdist "\nHeight of Beam : "))
;get the height of the beam
 
(setq wt (getdist "\nFlange Thickness : "))
;get the thickness of the flange
 
(setq ep (getdist "\nEnd Plate Thickness : "))
;get the thickness of the end plate
 
(setq nl (getdist "\nLength of Notch : "))
;get the length of notch
 
(setq nd (getdist "\nDepth of Notch : "))
;get the depth of the notch
 
;End of User Inputs
;*********************************************************
;Get Insertion Point
 
(setq ip (getpoint "\nInsertion Point : "))
;get the insertion point
 
;********************************************************

;Start of Polar Calculations
 
(setq p2  (polar ip (dtr 180.0) (- (/ lb 2) nl)))
(setq p3  (polar p2 (dtr 270.0) wt))
(setq p4  (polar p2 (dtr 270.0) nd))
(setq p5  (polar p4 (dtr 180.0) nl))
(setq p6  (polar p5 (dtr 180.0) ep))
(setq p7  (polar p6 (dtr 270.0) (- hb nd)))
(setq p8  (polar p7 (dtr 0.0) ep))
(setq p9  (polar p8 (dtr 90.0) wt))
(setq p10 (polar p9 (dtr 0.0) lb))
(setq p11 (polar p8 (dtr 0.0) lb))
(setq p12 (polar p11 (dtr 0.0) ep))
(setq p13 (polar p12 (dtr 90.0) (- hb nd)))
(setq p14 (polar p13 (dtr 180.0) ep))
(setq p15 (polar p14 (dtr 180.0) nl))
(setq p16 (polar p15 (dtr 90.0) (- nd wt)))
(setq p17 (polar p16 (dtr 90.0) wt))
;End of Polar Calculations

;**********************************************************
 
(princ)
;finish cleanly
 
)	;end of defun
 
;**********************************************************

;This function converts Degrees to Radians.
 
(defun dtr (x)
;define degrees to radians function
 
(* pi (/ x 180.0))
;divide the angle by 180 then
;multiply the result by the constant PI
 
)	;end of function

;**********************************************************
(princ)	;load cleanly
;**********************************************************

Right, now that we've calculated all the points required to draw the beam,
let us add a (command) function to do this task for us.

(defun c:testbeam ()
;define the function
;********************************************************
 
;Get User Inputs	

(setq lb (getdist "\nLength of Beam : "))
;get the length of the beam
 
(setq hb (getdist "\nHeight of Beam : "))
;get the height of the beam
 
(setq wt (getdist "\nFlange Thickness : "))
;get the thickness of the flange
 
(setq ep (getdist "\nEnd Plate Thickness : "))
;get the thickness of the end plate
 
(setq nl (getdist "\nLength of Notch : "))
;get the length of notch
 
(setq nd (getdist "\nDepth of Notch : "))
;get the depth of the notch
 
;End of User Inputs
;*********************************************************
;Get Insertion Point
 
(setq ip (getpoint "\nInsertion Point : "))
;get the insertion point
 
;********************************************************
;Start of Polar Calculations
 
(setq p2  (polar ip (dtr 180.0) (- (/ lb 2) nl)))
(setq p3  (polar p2 (dtr 270.0) wt))
(setq p4  (polar p2 (dtr 270.0) nd))
(setq p5  (polar p4 (dtr 180.0) nl))
(setq p6  (polar p5 (dtr 180.0) ep))
(setq p7  (polar p6 (dtr 270.0) (- hb nd)))
(setq p8  (polar p7 (dtr 0.0) ep))
(setq p9  (polar p8 (dtr 90.0) wt))
(setq p10 (polar p9 (dtr 0.0) lb))
(setq p11 (polar p8 (dtr 0.0) lb))
(setq p12 (polar p11 (dtr 0.0) ep))
(setq p13 (polar p12 (dtr 90.0) (- hb nd)))
(setq p14 (polar p13 (dtr 180.0) ep))
(setq p15 (polar p14 (dtr 180.0) nl))
(setq p16 (polar p15 (dtr 90.0) (- nd wt)))
(setq p17 (polar p16 (dtr 90.0) wt))
;End of Polar Calculations
;**********************************************************

;Start of Command Function
 
(command "Line" ip p2 p4 p6 p7 p12 p13 p15 p17 "c"
	 "Line" p3 p16 "
	 "Line" p9 p10 "
	 "Line" p5 p8 "
	 "Line" p11 p14 "
)  ;End Command
;End of Command Function

;*********************************************************
(princ)
;finish cleanly
 
)	;end of defun
 
;**********************************************************
;This function converts Degrees to Radians.
 
(defun dtr (x)
;define degrees to radians function
 
(* pi (/ x 180.0))
;divide the angle by 180 then
;multiply the result by the constant PI
 
)	;end of function
 
;**********************************************************
(princ)	;load cleanly
;**********************************************************
 

O.K. Let's load the program and run it.

Now, depending on how your snap is set, the beam might be drawn correctly,
or it may not. On my system it doesn't draw properly. This is because my snap defaults to intersection and AutoCAD keeps on
snapping to the wrong point. I also have lot's of annoying
"blips" on my screen. In &lt;a href="/autolisp/tutorials/the-basics-part-4.php">Part 4&lt;/a> we'll discuss how to get
around these problems. See you there&hellip;

Snap settings in AutoCad can cause havoc with an AutoLisp routine.&lt;br>
Therefore, it's a very good idea to switch off the snap at the beginning
of any AutoLisp routine and only switch it on when it is required.
Blips
on your screen are also very annoying, so switch them off too.
Please,
always remember to return the AutoCad settings that you change, back to
their original state before exiting your routine.

Let's edit our routine to include this :

(defun c:testbeam ()
;define the function
;********************************************************

;Save System Variables
 
(setq oldsnap (getvar "osmode"))
;save snap settings
 
(setq oldblipmode (getvar "blipmode"))
;save blipmode setting
 
;********************************************************
;Switch OFF System Variables
 
(setvar "osmode" 0)
;Switch OFF snap
 
(setvar "blipmode" 0)
;Switch OFF Blipmode

;********************************************************
;Get User Inputs	

(setq lb (getdist "\nLength of Beam : "))
;get the length of the beam
 
(setq hb (getdist "\nHeight of Beam : "))
;get the height of the beam
 
(setq wt (getdist "\nFlange Thickness : "))
;get the thickness of the flange
 
(setq ep (getdist "\nEnd Plate Thickness : "))
;get the thickness of the end plate
 
(setq nl (getdist "\nLength of Notch : "))
;get the length of notch
 
(setq nd (getdist "\nDepth of Notch : "))
;get the depth of the notch
 
;End of User Inputs
;*********************************************************
;Get Insertion Point

(setvar "osmode" 32)
;switch ON snap

(setq ip (getpoint "\nInsertion Point : "))
;get the insertion point

(setvar "osmode" 0)
;switch OFF snap

;********************************************************
;Start of Polar Calculations
 
(setq p2  (polar ip (dtr 180.0) (- (/ lb 2) nl)))
(setq p3  (polar p2 (dtr 270.0) wt))
(setq p4  (polar p2 (dtr 270.0) nd))
(setq p5  (polar p4 (dtr 180.0) nl))
(setq p6  (polar p5 (dtr 180.0) ep))
(setq p7  (polar p6 (dtr 270.0) (- hb nd)))
(setq p8  (polar p7 (dtr 0.0) ep))
(setq p9  (polar p8 (dtr 90.0) wt))
(setq p10 (polar p9 (dtr 0.0) lb))
(setq p11 (polar p8 (dtr 0.0) lb))
(setq p12 (polar p11 (dtr 0.0) ep))
(setq p13 (polar p12 (dtr 90.0) (- hb nd)))
(setq p14 (polar p13 (dtr 180.0) ep))
(setq p15 (polar p14 (dtr 180.0) nl))
(setq p16 (polar p15 (dtr 90.0) (- nd wt)))
(setq p17 (polar p16 (dtr 90.0) wt))
;End of Polar Calculations
;**********************************************************
;Start of Command Function
 
(command "Line" ip p2 p4 p6 p7 p12 p13 p15 p17 "c"
	 "Line" p3 p16 "
	 "Line" p9 p10 "
	 "Line" p5 p8 "
	 "Line" p11 p14 "
)  ;End Command
;End of Command Function
;**********************************************************

;Reset System Variable
 
(setvar "osmode" oldsnap)
;Reset snap
 
(setvar "blipmode" oldblipmode)
;Reset blipmode

;*********************************************************
(princ)
;finish cleanly
 
)	;end of defun
 
;**********************************************************
;This function converts Degrees to Radians.
 
(defun dtr (x)
;define degrees to radians function
 
(* pi (/ x 180.0))
;divide the angle by 180 then
;multiply the result by the constant PI
 
)	;end of function
 
;**********************************************************
(princ)	;load cleanly
;**********************************************************
 

Load and run the program. If you were having problems, they should now
have disappeared. (I hope!!). Did you notice how we switched on the snap
just before asking for the insertion point?&lt;br>
This, of course, is to allow the user to snap to an insertion point.

We still have another problem though. What would happen if the user
entered an illegal value, such as zero, or a negative number?&lt;br>
This could cause very strange results. To guard against this we will use the (initget) function.

Here's how it works :

(initget (+ 1 2 4))
(setq lb (getdist "\nLength of Beam : "))

This function works on the "sum of the bits" system.

1 = Disallows the user from pressing "Enter".
2 = Disallows the user from entering "Zero".
4 = Disallows the user from entering a "Negative Number".

The same function could have been written like this :

(initget 7)
(setq lb (getdist "\nLength of Beam : "))

Let's add this function to our routine :

(defun c:testbeam ()
;define the function
;********************************************************
;Save System Variables
 
(setq oldsnap (getvar "osmode"))
;save snap settings
 
(setq oldblipmode (getvar "blipmode"))
;save blipmode setting
 
;********************************************************
;Switch OFF System Variables
 
(setvar "osmode" 0)
;Switch OFF snap
 
(setvar "blipmode" 0)
;Switch OFF Blipmode
 
;********************************************************
;Get User Inputs	

(initget (+ 1 2 4))
;check user input

(setq lb (getdist "\nLength of Beam : "))
;get the length of the beam

(initget (+ 1 2 4))
;check user input

(setq hb (getdist "\nHeight of Beam : "))
;get the height of the beam

(initget (+ 1 2 4))
;check user input

(setq wt (getdist "\nFlange Thickness : "))
;get the thickness of the flange

(initget (+ 1 2 4))
;check user input

(setq ep (getdist "\nEnd Plate Thickness : "))
;get the thickness of the end plate

(initget (+ 1 2 4))
;check user input

(setq nl (getdist "\nLength of Notch : "))
;get the length of notch

(initget (+ 1 2 4))
;check user input

(setq nd (getdist "\nDepth of Notch : "))
;get the depth of the notch
 
;End of User Inputs
;*********************************************************
;Get Insertion Point
 
(setvar "osmode" 32)
;switch ON snap
 
(setq ip (getpoint "\nInsertion Point : "))
;get the insertion point
 
(setvar "osmode" 0)
;switch OFF snap
 
;********************************************************
;Start of Polar Calculations
 
(setq p2  (polar ip (dtr 180.0) (- (/ lb 2) nl)))
(setq p3  (polar p2 (dtr 270.0) wt))
(setq p4  (polar p2 (dtr 270.0) nd))
(setq p5  (polar p4 (dtr 180.0) nl))
(setq p6  (polar p5 (dtr 180.0) ep))
(setq p7  (polar p6 (dtr 270.0) (- hb nd)))
(setq p8  (polar p7 (dtr 0.0) ep))
(setq p9  (polar p8 (dtr 90.0) wt))
(setq p10 (polar p9 (dtr 0.0) lb))
(setq p11 (polar p8 (dtr 0.0) lb))
(setq p12 (polar p11 (dtr 0.0) ep))
(setq p13 (polar p12 (dtr 90.0) (- hb nd)))
(setq p14 (polar p13 (dtr 180.0) ep))
(setq p15 (polar p14 (dtr 180.0) nl))
(setq p16 (polar p15 (dtr 90.0) (- nd wt)))
(setq p17 (polar p16 (dtr 90.0) wt))
;End of Polar Calculations
;**********************************************************
;Start of Command Function
 
(command "Line" ip p2 p4 p6 p7 p12 p13 p15 p17 "c"
	 "Line" p3 p16 "
	 "Line" p9 p10 "
	 "Line" p5 p8 "
	 "Line" p11 p14 "
)  ;End Command
;End of Command Function
;**********************************************************
;Reset System Variable
 
(setvar "osmode" oldsnap)
;Reset snap
 
(setvar "blipmode" oldblipmode)
;Reset blipmode
 
;*********************************************************
(princ)
;finish cleanly
 
)	;end of defun
 
;**********************************************************
;This function converts Degrees to Radians.
 
(defun dtr (x)
;define degrees to radians function
 
(* pi (/ x 180.0))
;divide the angle by 180 then
;multiply the result by the constant PI
 
)	;end of function
 
;**********************************************************
(princ)	;load cleanly
;**********************************************************
 

Now, everything should be running fine except for one thing.

What happens if we want to draw two beams with exactly the same values? We
would have to go through the whole routine again, entering exactly the
same inputs. We could, of course, set up each variable to default to the
last value used, but we would still have to run through the whole routine.
Here's a better way. We'll enclose the complete routine in a (while) loop.
Have a look :

(defun c:testbeam ()
;define the function
;********************************************************
;Save System Variables
 
(setq oldsnap (getvar "osmode"))
;save snap settings
 
(setq oldblipmode (getvar "blipmode"))
;save blipmode setting
 
;********************************************************
;Switch OFF System Variables
 
(setvar "osmode" 0)
;Switch OFF snap
 
(setvar "blipmode" 0)
;Switch OFF Blipmode
 
;********************************************************
;Get User Inputs	

(initget (+ 1 2 4))
;check user input
(setq lb (getdist "\nLength of Beam : "))
;get the length of the beam
 
(initget (+ 1 2 4))
;check user input
(setq hb (getdist "\nHeight of Beam : "))
;get the height of the beam
 
(initget (+ 1 2 4))
;check user input
(setq wt (getdist "\nFlange Thickness : "))
;get the thickness of the flange
 
(initget (+ 1 2 4))
;check user input
(setq ep (getdist "\nEnd Plate Thickness : "))
;get the thickness of the end plate
 
(initget (+ 1 2 4))
;check user input
(setq nl (getdist "\nLength of Notch : "))
;get the length of notch
 
(initget (+ 1 2 4))
;check user input
(setq nd (getdist "\nDepth of Notch : "))
;get the depth of the notch
 
;End of User Inputs
;*********************************************************
;Get Insertion Point
 
(setvar "osmode" 32)
;switch ON snap

(while
;start of while loop	

(setq ip (getpoint "\nInsertion Point : "))
;get the insertion point
 
(setvar "osmode" 0)
;switch OFF snap
 
;********************************************************
;Start of Polar Calculations
 
(setq p2  (polar ip (dtr 180.0) (- (/ lb 2) nl)))
(setq p3  (polar p2 (dtr 270.0) wt))
(setq p4  (polar p2 (dtr 270.0) nd))
(setq p5  (polar p4 (dtr 180.0) nl))
(setq p6  (polar p5 (dtr 180.0) ep))
(setq p7  (polar p6 (dtr 270.0) (- hb nd)))
(setq p8  (polar p7 (dtr 0.0) ep))
(setq p9  (polar p8 (dtr 90.0) wt))
(setq p10 (polar p9 (dtr 0.0) lb))
(setq p11 (polar p8 (dtr 0.0) lb))
(setq p12 (polar p11 (dtr 0.0) ep))
(setq p13 (polar p12 (dtr 90.0) (- hb nd)))
(setq p14 (polar p13 (dtr 180.0) ep))
(setq p15 (polar p14 (dtr 180.0) nl))
(setq p16 (polar p15 (dtr 90.0) (- nd wt)))
(setq p17 (polar p16 (dtr 90.0) wt))
;End of Polar Calculations
;**********************************************************
;Start of Command Function
 
(command "Line" ip p2 p4 p6 p7 p12 p13 p15 p17 "c"
	 "Line" p3 p16 "
	 "Line" p9 p10 "
	 "Line" p5 p8 "
	 "Line" p11 p14 "
)  ;End Command
;End of Command Function
;**********************************************************

(setvar "osmode" 32)
;Switch ON snap
 
);end of while loop

;**********************************************************
;Reset System Variable
 
(setvar "osmode" oldsnap)
;Reset snap
 
(setvar "blipmode" oldblipmode)
;Reset blipmode
 
;*********************************************************
(princ)
;finish cleanly
 
)	;end of defun
 
;**********************************************************
;This function converts Degrees to Radians.
 
(defun dtr (x)
;define degrees to radians function
 
(* pi (/ x 180.0))
;divide the angle by 180 then
;multiply the result by the constant PI
 
)	;end of function
 
;**********************************************************
(princ)	;load cleanly
;**********************************************************
 

The programme will now repeat itself indefinetly, asking for an
insertion point and drawing a beam, until the user presses enter.

This is how it works. The (while) function will continue to evaluate an
expression until the expression evaluates to nil. As long as the user
selects a point, the expression is true. But, when the user selects
"Enter" the expression returns "nil" and the programme
moves out of the loop. (AutoLisp evaluates "Enter" as
"nil")

   I hope you have understood this tutorial and that it has given you a
better understanding of AutoLisp. You will find a more detailed
explanation of many of the functions used here in other tutorials on this
site.

If you would like the source coding for this AutoLisp tutorial then &lt;a href="files/lisp16.zip">Click Here.&lt;/a> Cheers for Now&hellip;

<h2>Loading AutoLISP Files</h2>

&lt;strong>Note:&lt;/strong> One of the most important things to remember about loading AutoLisp
Routines is to ensure that your Lisp files and any support files (i.e DCL
Files; DAT Files; etc) are in your AutoCad search path. (I dedicate a
directory to all my Lisp files and relevant support files.

There are numerous ways of loading AutoLisp Files :

<h2>Command Line Loading</h2>
The simplest is from the AutoCad command line.&lt;br>
The syntax for loading AutoLisp files is :

(load "filename")
The.lsp extension is not required.

<h2>Menu Loading</h2>
The following code samples are one way of loading AutoLisp files from a
menu.

<h3>Pull Down Menu's :</h3>
***POP12
T_Steel [Steel Menu]
T_Beams [Drawing Setup]^C^C^P+
(cond ((null C:DDSTEEL) (prompt "Please Wait...")(load "DDSTEEL")))
DDSTEEL

<h3>Toolbars :</h3>
***TOOLBARS
**STEEL
TB_DDSTEEL [_Button("Steel", "STEEL.bmp",
"STEEL32.bmp")]^C^C^P+
(cond ((null C:ddsteel) (prompt "Please Wait...")(load "ddsteel"))) ddsteel

This method of loading Lisp files first checks to see if the routine is
already loaded. If it is, it runs the routine. If it is not, it first
loads the routine, then runs it. Clever Hey?

<h2>Acad.Lsp File</h2>
The Acad.Lsp file is a useful way of loading a library of AutoLisp
routines.&lt;br>
Each time you start a drawing AutoCad searches the library path for an
Acad.Lsp file. If it finds one, it loads the file into memory.

You could use the normal load function (load "filename") in
your Acad.Lsp file but if an error occurs whilst attempting to load one of
your routines, the remainder of the file is ignored and is not loaded.&lt;br>
Therefore, you must use the &lt;em>on failure&lt;/em> argument with the load
function :

(load "Lispfile1" "\nLispfile1 not loaded")
(load "Lispfile2" "\nLispfile2 not loaded")
(load "Lispfile3" "\nLispfile3 not loaded")
<h2>The .MNL File</h2>
The other type of file that AutoCad loads automatically is the .MNL
file.

If you have a partial menu file it can also have it's own .MNL file. Just remember that the .MNL file must have exactly the same name as your
partial menu file. (except for the .MNL extension, of course.)

You can load Lisp files from this file using the load function exactly the
same as you did in the Acad.Lsp file.

<h2>Command Autoloader</h2>
When you automatically load a command from your Acad.Lsp file (or a .MNL
file) the commands definition consumes your systems resources whether you
actually use the command or not. The Autoload function makes a command
available without loading the entire routine into memory.

(Autoload "Utils" '("Utils1" Utils2" "Utils3"))
(Autoload "DDSteel" '("DDSteel"))
This would automatically load the commands Utils1, Utils2 and Utils3
from the Utils.Lsp file and DDSteel from the DDSteel.Lsp file.

<h2>S::Startup Function</h2>
If the user defined function S::Startup is included in the Acad.lsp or
a .MNL file, it is called when you enter a new drawing or open an existing drawing.

For example, say that you wanted to override the standard AutoCad LINE and COPY
commands with versions of your own, your Acad.Lsp file would something like this :

(defun C:LINE ()
 .....Your Definition.....
)
(defun C:COPY ()
 .....Your Definition.....
)
(defun S::Startup ()
  (command "Undefine" "LINE")
  (command "Undefine" "COPY")
)

Before the drawing is initialised, new definitions for LINE and COPY
are defined. After the drawing is initialised, the S::Startup function is
called and the standard definitions of LINE and COPY are undefined.

<h2>AutoLISP Quick Start</h2>

&lt;h2 id="Intro">Introduction</h2>

This tutorial is aimed at the AutoCAD users who would like to start learning AutoLISP. I suggest that you go through this tutorial along with the AutoCAD Programmers Reference Guide. You can then lookup the relevant AutoLisp commands for a more detailed explanation. Hope this helps you and Good Luck in your Lisping - &lt;em>Kenny Ramage&lt;/em>

&lt;h2 id="Principles">Principles of Programming</h2>
All AutoLisp programs must contain the suffix ".LSP" otherwise AutoCAD will not access them when loading. (eg. CHTEXT.LSP).

<img src="https://www.afralisp.net/autolisp/tutorials/images/qs-101.gif">

Use a simple text processor such as Notepad to create and edit your lisp files.

<h3>Function (which is simply the program)</h3>
Is a pre-defined set of instructions that describes a set of actions that AutoLisp is to perform, divided into three sections:

&lt;ul class="simple">
OPERATOR - Getting input.
ARGUMENT - Manipulating the input.
COMMAND - Using the manipulated input.
&lt;/ul>

<h3>Charting</h3>
Draw out or write out in English what you want your program to do.

<h3>Variables</h3>
These are like empty boxes in which to store data, to be used later. In AutoLisp, variables may be a collection of letters or numbers as long as they begin with the letters.

Example of legal variables are as follows:

&lt;ul class="simple">
A
ARC1
POINT1
PNT1
D3
&lt;/ul>

An AutoLisp variable may contain more than one value in a single variable. A value can be anything, such as :

&lt;ul class="simple">
Real number
String
Integer
Pickset
&lt;/ul>

Therefore a variable can store just about anything.

<h3>Structuring</h3>
Structure your program in such a way that it is easy to understand, by yourself and everyone else. e.g. Keep input statements together. Keep your arguments together. Keep your commands together. Track your work with the semicolon. When you begin a line with a semicolon, anything you write after will be ignored by AutoLisp. It is used for documentation and explanation of your program. Write notes about your program, what you are doing and what the variables are. A semicolon does not have to begin the line.

&lt;code>(prompt "This line will print"); This is a comment&lt;/code>

From where the semicolon begins, the remainder of the line is a comment statement.

<h3>Parentheses ( )</h3>
Parentheses are vital to writing AutoLisp programs. All commands are surrounded by parentheses. AutoLisp uses parentheses to nest, allowing you to write a command that acts on (evaluates) another command. In turn, that command can act on another. As you add parentheses, you're nesting commands become deeper and deeper. Remember to come out of the nest with an equal number of parentheses.

&lt;strong>Note:&lt;/strong> Always close what you open.

&lt;h2 id="defun">Defun (Define Function)</h2>
In AutoLisp the name of the program or function must be defined in the first statement, which is done by using the command:

(defun functionname ()

&lt;em>body of program&lt;/em>

)

Defun is the first actual command and is followed by the name of the function (or program). Defun encloses the entire program and its closing bracket comes after the main body of the program There are different ways of starting a function for example:


&lt;code>(defun drawline ()&lt;/code>
The first way, you are saying that all variables you plan to use in the program are GLOBAL, which are variables that do not lose their value after the program ends.
&lt;code>(defun drawline (/ pntl pnt2)&lt;/code>
The second way, you are saying that the variables you are using are LOCAL variables, which are variables that have value only for that program and while that program is running.
&lt;code>(defun C:drawline ()&lt;/code>
The third way, as the first BUT the C: tells AutoCAD to treat that function as any other AutoCAD command.
&lt;code>(defun C:drawline (/ pntl pnt2)&lt;/code>
The fourth way, as the second, but an AutoCAD command.
&lt;code>(defun drawline (a / pntl pnt2)&lt;/code>
The last, variable &lt;code>a&lt;/code> receives the first value to it from outside the program.
&lt;/ol>

&lt;h2 id="data">Data Types</h2>
<h3>Integers</h3>
Are numbers ranging between -32768 and +32767 without decimal points eg: 1

<h3>Reals</h3>
Are numbers with a decimal point eg: 1.0

<h3>Strings</h3>
Strings are bits of text and can be up to a maximum length of 100 characters eg: Point 1

<h3>Lists</h3>
A list is a variable that has more than one element. A point in your drawing is described by the value of the X co-ordinate and the value of the Y co-ordinate. In AutoLisp, that point can be described by a single variable, a list of two elements, the first being the X value and the second being the Y value eg: ( 7 10 ). The following are also examples of lists: ( 5 9 7 2 ) and ( 1.5 2.3 4.9 ).

<h3>Atoms</h3>
If a variable has a single indivisible value it is an atom. For example, each element in the lists above is an atom e.g. 6 or A

The &lt;code>type&lt;/code> function will return the data type of a variable. For example:

(type "My name")

Will return STR meaning "string". In fact, you can try this for yourself now. Type the code above at the AutoCAD command prompt and hit enter.

<img src="https://www.afralisp.net/autolisp/tutorials/images/qs-102.gif" width="245" height="78">

&lt;h2 id="input">Input Commands (getting info from the user)</h2>

AutoLisp provides a number of options for getting different types of data from the user.

&lt;table class="data">
&lt;tr>
	&lt;th colspan="2">Input Commands&lt;/th>
&lt;/tr>
&lt;tr class="row1">
  &lt;td>getpoint&lt;/td>
  &lt;td>Needs you to pick a point on the screen.&lt;/td>
&lt;/tr>
&lt;tr class="row2">
  &lt;td>getint&lt;/td>
  &lt;td>Needs an Integer eg: 1.&lt;/td>
&lt;/tr>
&lt;tr class="row1">
  &lt;td>getreal&lt;/td>
  &lt;td>Needs a real number eg: 10.00.&lt;/td>
&lt;/tr>
&lt;tr class="row2">
  &lt;td>getcorner&lt;/td>
  &lt;td>Needs a second point on the screen and draws an elastic window from a previous point.&lt;/td>
&lt;/tr>
&lt;tr class="row1">
  &lt;td>getstring&lt;/td>
  &lt;td>Needs a string of text.&lt;/td>
&lt;/tr>
&lt;tr class="row2">
  &lt;td>getdist&lt;/td>
  &lt;td>Needs a value either by picking on the screen or a number from the keyboard.&lt;/td>
&lt;/tr>
&lt;tr class="row1">
  &lt;td>getangle&lt;/td>
  &lt;td>Needs an angle either by pointing on the screen or by typing an angle, which will be returned in radians.&lt;/td>
&lt;/tr>
&lt;tr class="row2">
  &lt;td>getkword&lt;/td>
  &lt;td>Needs a keyword from the user.&lt;/td>
&lt;/tr>
&lt;tr class="row1">
  &lt;td>getvar&lt;/td>
  &lt;td>Will get the value of an AutoCAD system variable.&lt;/td>
&lt;/tr>
&lt;tr class="row2">
  &lt;td>initget&lt;/td>
  &lt;td>Establishes various options for use by the next getxxx function.&lt;/td>
&lt;/tr>
&lt;tr class="row1">
  &lt;td>getorient&lt;/td>
  &lt;td>Is similar to the GETANGLE but is affected by the zero-degree base and the direction. It will always give you the absolute angle using 0 degree base as EAST.&lt;/td>
&lt;/tr>
&lt;/table>

<h3>Input Command Examples</h3>
In each of the following examples, enter the code at the AutoCAD prompt to see what happens.


&lt;code>(getpoint "\nPick a POINT on the screen:")&lt;/code> Pick a point when prompted and AutoCAD will return the value (X Y Z) of that point.
&lt;/ol>

&lt;strong>Tip:&lt;/strong> &lt;code>\n&lt;/code> is a special escaped character that takes you to the next line (like a carriage return). The forward slash character tells AutoLisp to interpret the following character as a special character rather than just as a letter "n". The "n" must be always be lower case. The use of "\n" is purely cosmetic (it doesn't change the way the program works) but it does make everything much easier to read for the user by starting each prompt on a new line.

&lt;strong>Caution:&lt;/strong> Your prompt must always be between quotes, "&lt;em>prompt&lt;/em>" otherwise you will get an error.

&lt;ol start="2">
&lt;code>(getint "\nEnter your age :")&lt;/code> Type an integer (such as 34) and AutoLisp will return that number.

&lt;code>(getreal "\nEnter a number :")&lt;/code> Type a real number (such as 10.51) and AutoLisp will return that number.

&lt;code>(getcorner pnt1 "\nPick second point :")&lt;/code> Will create an elastic window from the variable called "pnt1", which must already be defined.

&lt;code>(getstring "\nWhat is the day today? :")&lt;/code> Type some text and Autolisp will return that text.

Or&hellip;

&lt;code>(getstring T "\nWhat is your full name? :")&lt;/code> This prompt allows you to enter a string of words separated by spaces. Ordinarily, AutoCAD will interpret a space in the same way it interprets a carriage return. The &lt;code>T&lt;/code> is a special AutoLisp symbol that means "true" it is used to allow spaces in string input. In fact, you can use any positive integer (such as 1) in place of T but the T symbol helps to make the code more understandable.

&lt;code>(getdist "\nHow long is the line? :")&lt;/code> Pick two points or type a length and AutoLisp will return that length.

&lt;code>(getangle "\nWhat is the angle? :")&lt;/code> Pick two points for the angle or type an angle and AutoLisp will return that angle in radians.

&lt;code>(initget 1 "Yes NO")

(getkword "\nAre you going? (Yes or NO):")&lt;/code> Initget will control the next getxxx function and is used to specify a list of valid options or keywords, getkword will accept only one of the words specifies using initget. In this case, the options are "Yes" or "No". The &lt;code>1&lt;/code> is an initget bitcode and it means that a null response is not allowed. See the section below for more details.
&lt;/ol>

&lt;strong>Tip:&lt;/strong> Just as in native AutoCAD commands, any valid option keyword can be entered simply by typing the upper case part of the keyword. So, in the example above, to answer Yes to the prompt, you need only type "y" but to answer NO, you must type "no". This is used to avoid potential ambiguities when 2 or more options begin with the same letter.

&lt;ol start="9">
&lt;code>(getvar "FILLETRAD")&lt;/code> Would return the set value of the FILLETRAD system variable (fillet radius) eg : 0. 5

&lt;code>(getorient "\nWhat is the angle? :")&lt;/code> Pick two points for the angle or type an angle and AutoLisp will return an angle in radians relative to 0 degrees at East.
&lt;/ol>

<h3>Initget Bit Codes</h3>
The number &lt;code>1&lt;/code> after the &lt;code>initget&lt;/code> function in code example 8, above is known as an initget bit code. Initget bit codes can be used to control what type of inputs are allowed. In this example, 1 is used to disallow a null input. This forces the user to enter one of the specified option keywords rather than just hitting carriage return.

&lt;table class="data">
&lt;tr>
  &lt;th colspan="2">Initget Bit Codes&lt;/th>
&lt;/tr>
&lt;tr class="row1">
  &lt;td>1&lt;/td>
  &lt;td>Disallow null input.&lt;/td>
&lt;/tr>
&lt;tr class="row2">
  &lt;td>2&lt;/td>
  &lt;td>Disallow zero values.&lt;/td>
&lt;/tr>
&lt;tr class="row1">
  &lt;td>4&lt;/td>
  &lt;td>Disallow negative values.&lt;/td>
&lt;/tr>
&lt;tr class="row2">
  &lt;td>8&lt;/td>
  &lt;td>DO not check limits, even if LIMECHECK is on.&lt;/td>
&lt;/tr>
&lt;tr class="row1">
  &lt;td>16&lt;/td>
  &lt;td>Return 3D points rather than 2D points.&lt;/td>
&lt;/tr>
&lt;tr class="row2">
  &lt;td>32&lt;/td>
  &lt;td>Use dashed lines when drawing rubber band or box.&lt;/td>
&lt;/tr>
&lt;/table>

Example:

(initget (+ 1 2 4))

(getint "\nHow old are you?:")

Will only accept a positive, non-zero Integer eg: 21

&lt;h2 id="setq">Setq Command</h2>
Short for (Set Equal) or make one thing equal to another.

(setq) is an assignment command, eg : it assigns the value of one variable or constant to another variable.

&lt;strong>Note:&lt;/strong> (setq) is the primary assignment command in AutoLisp. The "=" (equals character) is not used as an assignment in AutoLisp. The equals character is used, but only as a non assignment statement. It does not have the ability to make one variable equal to another as it does in some other programming languages (it is used for a comparison of variables, numbers or strings).

&lt;code>(setq a b)&lt;/code>

This statement assigns the value of &lt;code>b&lt;/code> to the variable &lt;code>a&lt;/code> so that &lt;code>a&lt;/code> becomes the same as &lt;code>b&lt;/code> and &lt;code>b&lt;/code> is unchanged.

&lt;strong>Note:&lt;/strong> The first variable after the (setq) is the one that receives the value. Watch out for this because it is a potential cause of confusion.

&lt;h2 id="print">Print Commands</h2>
<h3>Prompt</h3>

(prompt "Maybe you need a rest")

This command is used simply to print a message on the command line. A line feed (&lt;code>\n&lt;/code>) is not included so two consecutive prompt commands will print both messages on the same line and without any spaces between them. Therefore, any printing after the prompt must be preceeded by the &lt;code>(terpri)&lt;/code> function or &lt;code>\n&lt;/code>.

<h3>Terpri</h3>
This is a line feed that causes the next printed text to appear on the next line. It generally follows the prompt command. eg:

&lt;code>(prompt "Hello, how are you?")(terpri)
&lt;/code>
or

&lt;code>(prompt "\nHello, how are you?")&lt;/code>

<h3>Prin1</h3>
This function prints the expression on the screen and returns the expression. It can be any expression and need not only be a string. The expression can also be written to a file and will appear in the file exactly as it would on the screen.

&lt;code>(prin1 "Hello")&lt;/code> would print "Hello".

&lt;code>(prin1 a)&lt;/code> would print the value of variable &lt;code>a&lt;/code>.

&lt;code>(prin1 a f)&lt;/code> would print the value of variable &lt;code>a&lt;/code> to an open file named in variable &lt;code>f&lt;/code>.

<h3>Princ</h3>
Is the same as prin1 except that the control characters (") are not printed. Can also be used to print a blank line by using no statement after princ.

&lt;code>(princ "Hello")&lt;/code> would print Hello.

<h3>Print</h3>
Same as prin1 except that a new line is printed before the expression and a space is printed after the expression.

&lt;h2 id="setvar">Setvar</h2>
This function sets an AutoCAD system variable to a given value and returns that value. The variable name must be in double quotes. eg:

&lt;code>(setvar "blipmode" 0)&lt;/code> returns 0 and will switch blipmode off. 1 would switch it on again.

&lt;h2 id="math">Doing Arithmetic</h2>
AutoLisp provides a number of arithmetic functions and although the format of these functions is consistent with other AutoLisp functions (function first, followed by values), it is not one we are familiar with from school. The important thing to remember is that the order of the values is consistent with what we already know. In other words &lt;code>(/ 27 3)&lt;/code> is the same as 27 divided by 3.

&lt;code>(+ 1 1)&lt;/code> returns 2.

&lt;code>(- 2 1)&lt;/code> returns 1.

&lt;code>(* 2 2)&lt;/code> returns 4.

&lt;code>(/ 2 1)&lt;/code> returns 2.

&lt;code>(1+ 1)&lt;/code> returns 2 (Incremented).

&lt;code>(1- 2)&lt;/code> returns 1 (Decremented).

<h3>Polar</h3>
This function returns the point at an angle (in radians) and distance from a given point.

&lt;code>(polar pnt1 ang1 dist1)&lt;/code> where pnt1, ang1 and dist1 are 3 previously assigned variables.

<h3>Inters</h3>
Examines two lines and returns the point where they intersect even if they do not physically cross one another.

&lt;code>(inters pnt1 pnt2 pnt3 pnt4)&lt;/code> where pnt1 and pnt2 are the end points of one line and pnt3 and pnt4 are the end points of another.

&lt;h2 id="autocad">AutoCAD commands in AutoLISP</h2>
Any AutoCAD command can be used inside your lisp program BUT one must remember that they have to be used exactly as you would in AutoCAD and your RETURN is a double set of Quotes ("). eg:

&lt;code>(command "line" pnt1 pnt2 ")&lt;/code> draws a line from pnt1 to pnt2 and the " acts as a return to terminate the command.

Not all commands require termination since some, like &lt;em>circle&lt;/em> are self terminating.

&lt;code>(command "circle" cen cir)&lt;/code> where cen is the centre of the circle and cir is a point on the circumference.

You can try this out using some values at the command prompt to see how this works:

(command "circle" "100,100" "150,150")

&lt;strong>Note:&lt;/strong> values in expressions must be enclosed in quotes whereas variable names are not.

The following code will draw a square using a polyline, specifying 4 points and then C to close:

(command "pline" "50,50" "50,70"  "70,70" "70,50" "c")

&lt;h2 id="list-elements">Elements from a List</h2>
When you used &lt;code>(setq a (getpoint))&lt;/code> you assigned the X and Y coordinate numbers to variable &lt;code>a&lt;/code>. That Variable now is a list that may look like (5 10). If you want to look at the list in variable &lt;code>a&lt;/code>, AutoLISP gives you a convenient way to do that from the command line.

&lt;code>!a&lt;/code> Placing the &lt;code>!&lt;/code> (exclamation mark character) in front of the variable will display the value or values of that variable.

<h3>Car (X co-ordinate or 1st element)</h3>

The primary command for taking a list apart, &lt;code>(car)&lt;/code> gives you the first element of a list. If the value of variable &lt;code>a&lt;/code> is the list (5 10), then:

&lt;code>(setq b (car a))&lt;/code> would assign to the variable &lt;code>b&lt;/code> the value of the first element in &lt;code>a&lt;/code> which is 5.

<h3>Cdr (second and remaining elements)</h3>
This is the secondary command for taking a list apart. &lt;code>(cdr)&lt;/code> gives you the second and remaining elements of the list, in other words; everything after the first element. If the value of variable &lt;code>a&lt;/code> is the list (2 5 7 9 11), then:

&lt;code>(setq b (cdr a))&lt;/code> would assign to variable &lt;code>b&lt;/code> the second and remaining elements of the list in variable &lt;code>a&lt;/code> which is (5 7 9 11).

<h3>Cadr (Y co-ordinate or 2nd element)</h3>
This always produces the second element of a list. Assuming the value of variable &lt;code>a&lt;/code> is the list (5 10), then:

&lt;code>(setq b (cadr a))&lt;/code> would give &lt;code>b&lt;/code> the value 10.

<h3>Caddr (Z co-ordinate or 3rd element)</h3>
This always produces the third element of a list. Assuming the value of variable &lt;code>a&lt;/code> is the list (3 7 5) then:

&lt;code>(setq c (caddr a))&lt;/code> would assign the value 5 to variable &lt;code>c&lt;/code>.

&lt;h2 id="example">Example Programs</h2>
<h3>Drawing things</h3>
&lt;h4>This program draws a rectangle by pointing to two points&lt;/h4>

(defun c:retan (/ pl p2 p3 p4)
(setq pl (getpoint "\nfirst corner of rectangle: "))
(setq p3 (getcorner "\nsecond corner of rectangle: "))
(setq p2 (list (car pl)(cadr p3)))
(setq p4 (list (car p3)(cadr pl)))
(command "line" pl p2 p3 p4 "c")
(princ)
)

<h3>Converting data</h3>
&lt;h4>(dtr) converts degrees to radians&lt;/h4>
(defun dtr (a)
(* pi (/ a 180)) )

&lt;h4>(rtd) converts radians to degrees&lt;/h4>
(defun rtd (a)
(/ (* a 180) pi)

<h3>Things to strings</h3>
strcase (string case)
Changes a string of text from lower case to upper case, leaving upper case characters as they are. eg:

&lt;code>(strcase "Hello")&lt;/code> returns "HELLO"

&lt;code>(strcase a)&lt;/code> returns the alphabetic characters in variable &lt;code>a&lt;/code> from lower case to upper case.

strcat (string cat)
Returns two or more separate strings as one. eg:

&lt;code>(strcat "H" "ello")&lt;/code> returns "Hello"

&lt;code>(strcat a b)&lt;/code> returns two strings in variable &lt;code>a&lt;/code> &amp; &lt;code>b&lt;/code> as one.

strlen (string length)
Returns the length, of the characters of a string. eg:

&lt;code>(strlen "hello")&lt;/code> returns 5.

&lt;code>(strlen a)&lt;/code> returns the length of a string in variable &lt;code>a&lt;/code>.

substr (substitute string)
Returns a part of a string, from a specified position, ending either at the end or another specified position. eg:

&lt;code>(substr "Hello 2)&lt;/code> returns "ello".

&lt;code>(substr "Hello 2 1)&lt;/code> returns "e".

&lt;code>(substr "Hello" 3 2)&lt;/code> returns "ll"

&lt;h2 id="list">List Manipulation</h2>
The apostrophe character, &lt;code>'&lt;/code> serves a special function in AutoLISP. For example, if a group of items is preceded by an apostrophe, it is treated as a list. eg:

&lt;code>'(20 10 5)&lt;/code> is treated as a list.

<h3>Angle</h3>
Returns an angle between two points in radians. To use that angle in AutoCAD you have to convert it back to decimal degrees. eg:
&lt;code>(setq a (angle pnt1 pnt2))&lt;/code> sets the angle between &lt;code>pnt1&lt;/code> and &lt;code>pnt2&lt;/code> to the variable &lt;code>a&lt;/code>.

To use &lt;code>a&lt;/code>:

&lt;code>(command "text" pnt1 "40" a t)&lt;/code> The text command with a height of 40, rotation angle assigned to variable &lt;code>a&lt;/code> and a text string to variable &lt;code>t&lt;/code>. But &lt;code>a&lt;/code> is not the correct rotation angle because it is in radians.

<h3>Append</h3>
Takes any number of specified lists and joins them together as one list. eg:

&lt;code>(append '(10 20) '(30 40))&lt;/code> returns the list: (10 20 30 40).

&lt;code>(append a b)&lt;/code> returns the list in variable &lt;code>a&lt;/code> and the list in variable &lt;code>b&lt;/code> as one.

<h3>Distance</h3>
Measures the distance from two known points. eg:

&lt;code>(setq dist1 (distance pnt1 pnt2))&lt;/code> returns the distance between &lt;code>pnt1&lt;/code> and &lt;code>pnt2&lt;/code> and assigns the distance to a variable called &lt;code>dist1&lt;/code>.

<h3>Length</h3>
Returns the number of elements in a list. eg:

&lt;code>(length '(a b c d))&lt;/code> returns 4.

<h3>Member</h3>
Looks for a match and returns that and the rest of the list eg:

&lt;code>(member 'c '(a b c d e))&lt;/code> returns (c d e).

<h3>Nth</h3>
Returns the nth element in a list, where n is the number of the element to return. (Zero is the first element). eg:

&lt;code>(nth 3 '(a b c d))&lt;/code> returns d.

<h3>Assoc (associative)</h3>
Often used with the &lt;code>(subst)&lt;/code> function; the &lt;code>(assoc)&lt;/code> function lets you search for a specific element, then assign that element to a variable.

Lets assume variable &lt;code>b&lt;/code> is the list ((10 5.5 2.7)(40 5)) and you are looking for a value 40. You want to pull out the entire element and assign it to a variable &lt;code>c&lt;/code>. eg:

(setq c (assoc 40 b))
This assigns the entire element containing the 40 in the list &lt;code>b&lt;/code> to variable &lt;code>c&lt;/code>. Now &lt;code>c&lt;/code> is a list that looks like this: (40 5).

<h3>Subst (subsitute)</h3>
Allows you to substitute one aspect for another. When substituting ALWAYS substitute the new item for the old in the list. Now lets substitute 20 for the 5 in the variable &lt;code>c&lt;/code>.

(setq b1 (subst '(40 20) c b))
Now b1 is the new list.

&lt;code>'(40 20)&lt;/code> is the new element substituted for the old element (40 5) &lt;code>c&lt;/code>, found in list &lt;code>b&lt;/code>.

If you want to use a variable which represents the value&hellip;

&lt;code>(setq bl (subst '(40 h) c b))&lt;/code> &hellip; looks like it should work, but it does not. The new element will look like this: (40 h).

&lt;code>(subst)&lt;/code> cannot interpret variables. You need to construct a new variable containing the entire list element, then use the new variable in the &lt;code>(subst)&lt;/code> function.

<h3>Cons (construct)</h3>
Constructs a new list with the new element placed at the begining. Assume variable &lt;code>c&lt;/code> contains the following list: (40 5). Also, assume variable &lt;code>h&lt;/code> contains the real number 20.0 then:

&lt;code>(setq d (cons (car c) h))&lt;/code> Remember, &lt;code>(car c)&lt;/code> gives you 40. Therefore, &lt;code>(car c)&lt;/code> is the new first element, followed by the value of &lt;code>h&lt;/code>. Thus it produces a new list &lt;code>d&lt;/code> (40 20.0).

Now we substitute:

&lt;code>(setq b1 (subst d c b))&lt;/code> That substitutes the new element found in variable &lt;code>d&lt;/code> for the old element found in variable &lt;code>c&lt;/code>. (In the list found in variable &lt;code>b&lt;/code>) and assigns the new list to &lt;code>b1&lt;/code>.

&lt;h2 id="convert">Conversions</h2>
<h3>Angtos (angle to string)</h3>
Takes an angle in radians and converts it into a string, using a specific format. Angtos has two arguments, the first controls the format and the second controls the precision.

&lt;table class="data">
&lt;tr>
  &lt;th colspan="2">Angtos Mode Format&lt;/th>
&lt;/tr>
&lt;tr class="row1">
  &lt;td>0&lt;/td>
  &lt;td>Degrees&lt;/td>
&lt;/tr>
&lt;tr class="row2">
  &lt;td>1&lt;/td>
  &lt;td>Degrees/minutes/seconds&lt;/td>
&lt;/tr>
&lt;tr class="row1">
  &lt;td>2&lt;/td>
  &lt;td>Grads&lt;/td>
&lt;/tr>
&lt;tr class="row2">
  &lt;td>3&lt;/td>
  &lt;td>Radians&lt;/td>
&lt;/tr>
&lt;tr class="row1">
  &lt;td>4&lt;/td>
  &lt;td>Surveyor's units&lt;/td>
&lt;/tr>
&lt;/table>

Assuming variable &lt;code>a&lt;/code> has an angle in radians. eg:

&lt;code>(angtos a 0 4)&lt;/code> returns "180.0000" where &lt;code>0&lt;/code> is the format (degrees) and &lt;code>4&lt;/code> is the precision, in this case, 4 decimal places.

&lt;code>(angtos a 0 0)&lt;/code> returns "180"

&lt;code>(angtos a 1 4)&lt;/code> returns "180d0"0"

<h3>Fix</h3>
This function returns the convertion of a real number to an integer and drops the remainder. eg:

&lt;code>(fix 8)&lt;/code> returns 8

&lt;code>(fix 8.6)&lt;/code> returns 8

<h3>Float</h3>
This function returns the convertion of an integer to a real number. (One can use either real or an integer.) eg:

&lt;code>(float 8)&lt;/code> returns 8.0000

&lt;code>(float 8.6)&lt;/code> returns 8.6000

<h3>Ascii</h3>
Returns the convertion of the first character of a string into its ASCII character code. (an integer) eg:

&lt;code>(ascii "a")&lt;/code> returns 97

&lt;code>(ascii "A")&lt;/code> returns 65, upper and lower case characters have different ascii character codes.

&lt;code>(ascii "BLUE")&lt;/code> returns 66

&lt;code>(ascii "BALL")&lt;/code> returns 66, only the first character is evaluated.

<h3>Chr</h3>
Returns the convertion of an Integer representing an ASCII character code into a single character string. eg:

&lt;code>(chr 65)&lt;/code> returns "A"

&lt;code>(chr 66)&lt;/code> returns "B"

<h3>Atof (ascii to float)</h3>
Returns the convertion of a string into a real number. eg:

&lt;code>(atof "9.3")&lt;/code> returns 9.3000

&lt;code>(atof "2")&lt;/code> returns 2.0000

<h3>Rtos (real to string)</h3>
Returns the convertion of a real number to a string with a specified format.

&lt;table class="data">
&lt;tr>
  &lt;th colspan="2">Rtos Mode Format&lt;/th>
&lt;/tr>
&lt;tr class="row1">
  &lt;td>1&lt;/td>
  &lt;td>Scientific&lt;/td>
&lt;/tr>
&lt;tr class="row2">
  &lt;td>2&lt;/td>
  &lt;td>Decimal&lt;/td>
&lt;/tr>
&lt;tr class="row1">
  &lt;td>3&lt;/td>
  &lt;td>Engineering (feet &amp; decimal inches)&lt;/td>
&lt;/tr>
&lt;tr class="row2">
  &lt;td>4&lt;/td>
  &lt;td>Architectural (feet &amp; fractional inches)&lt;/td>
&lt;/tr>
&lt;tr class="row1">
  &lt;td>5&lt;/td>
  &lt;td>Arbituary fractional units&lt;/td>
&lt;/tr>
&lt;/table>

The real number can be set according to mode and precision. eg:

&lt;code>(rtos 7.2 1 4)&lt;/code> returns "7.200OE+00"

&lt;code>(rtos 7.2 2 2)&lt;/code> returns "7.20"

<h3>Itoa (integer to ascii)</h3>
Returns the convertion of an integer into a string. eg:

&lt;code>(itoa 25)&lt;/code> returns "25"

<h3>Atoi (ascii to integer)</h3>
Returns the convention of a string into an integer. eg:

&lt;code>(atoi "25")&lt;/code> returns 25

&lt;h2 id="conditionals">Conditionals</h2>
In AutoLisp, the equals character (&lt;code>=&lt;/code>) is not an assignment function. In other words, it is not used to assign a value to a variable as it is in some other programming languages. AutoLisp uses the &lt;code>(setq)&lt;/code> function to perform this task. In AutoLisp, the equals character is used to test if items are equal, it does not make them equal. This is very useful if we are trying to test certain conditions. For example, we can begin to construct tests with an outcome such as "if one thing is equal to another thing, do something". That's what conditionals are all about; they allow your program to make decisions.

<h3>If</h3>
&lt;code>(if)&lt;/code> is the standard if-then-else statement. In AutoLISP you may only match one if statement with a then statement. eg:

(if (= a b) (setq b 5 (setq b 6))
If &lt;code>a&lt;/code> is equal to &lt;code>b&lt;/code>, then &lt;code>b&lt;/code> will be assigned the value 5. If it is not, then &lt;code>b&lt;/code> will be assigned the value 6.

<h3>Cond (conditional)</h3>
This function accepts any number of lists as arguments. It evaluates the first item in each list (in order supplied) until one of these items is a value other than nil. eg: A user's response string is variable &lt;code>s&lt;/code>.

(cond
((= s "Y") 1)
((= s "y") 1)
((= s "N") 0)
((= s "n") 0)
(t nil)
)

This function tests the response and returns 1 if it is "Y" or "y", and 0 if it is "N" or "n", and nil otherwise.

<h3>Repeat</h3>
Similar to a loop but repeat will only go through the commands as many times as is told. eg:

(setq a 10)
(setq b 100)
(repeat 3
(setq a (+ a 10))
)
(setq b (+ b a))
)

Returns 140.

<h3>While</h3>
Is another loop control command available in AutoLISP. A loop is necessary if you want to repeat a command. However, unless you have a way of controlling it, the program will run forever and hang you up. eg:

&lt;code>(setq a "w")&lt;/code> Sets up the controlling variable to a value other than nil.

&lt;code>(while a&lt;/code> The loop will continue, begining with the commands that follow, until the variable &lt;code>a&lt;/code> is set to nil.

&nbsp;&nbsp;&lt;code>(&hellip;some functions&hellip;)&lt;/code> Are the functions that are performed in the loop.

&nbsp;&nbsp;&lt;code>(if (= c d) (setq a nil))&lt;/code> Evaluates if &lt;code>c&lt;/code> is equal to &lt;code>d&lt;/code>, and if so, sets the loop controlling variable &lt;code>a&lt;/code> to nil to end the loop.

&lt;code>)&lt;/code> A closing parenthesis closes the loop, and program will continue with the commands after this.

&lt;h2 id="entities">Entities</h2>
An entity is the smallest object you can place on your screen. The following are entities: LINE, CIRCLE, ARC, TEXT, POLYLINES, etc. Entities are stored and referenced in the drawing database. They can be changed and manipulated using AutoLISP to suit your needs. Each entity has a massive definition in AutoCAD's database. eg: The data for a single line contains the following info:

Entity name, Entity type, Layer, Color, Beginning X Y coordinate, Ending X Y coordinate, Line type, etc. You can modify any of the above aspects. An example of an entity list:

( - 1 &lt;Entity name: 60000014) (0 "CIRCLE") (8 . "LAYER1")
(10 . 50.000 100.000) (40 . 60.000)
It is an entity list of a circle on layer LAYER1, center point relative to 0,0 of 50.0,100.0 , and a radius of 60.0

<h3>Entsel and Ssget (select entities and selection sets)</h3>
Both give you a way of selecting the entities for the selection set. &lt;code>(entsel)&lt;/code> only selects one entity at a time. You may not use WINDOW or CROSSING to select entities. &lt;code>(ssget)&lt;/code> however lets use WINDOW or CROSSING as well as other selection techniques. You will mostly be using &lt;code>(ssget)&lt;/code>.

&lt;code>(setq a (ssget))&lt;/code> will prompt you to select objects. You have now created a selection set with a specific name, &lt;Selection set:l&gt; ,assigned to variable &lt;code>a&lt;/code>, or use filter option &lt;code>(setq a (ssget "X" '((0 . "TEXT"))))&lt;/code> to search database for certain entities or codes.

<h3>Ssname (get entity name)</h3>
Lets you secure the name of the entity. The name of the entity is realy a hexadecimal number, therefore don't expect to see a name like LINE, or CIRCLE etc. The name of your entity might be 60000018.

Lets assume variable &lt;code>a&lt;/code> is the selection set and variable &lt;code>i&lt;/code> is set to &lt;code>0&lt;/code>. &lt;code>(setq i 0)&lt;/code> To set Counter variable. &lt;code>(setq na (ssname a i))&lt;/code>. This assigns &lt;code>na&lt;/code> the entity name found in the selection set &lt;code>a&lt;/code> at index number &lt;code>i&lt;/code>. Remember that a selection set may contain more than one entity name. You can point to each entity by using its relative number in the selection set. eg: Entity 1 is Index 0 , Entity 2 is Index 1 , etc.

<h3>Entget (get entity list)</h3>
This command actually pulls out, or extracts, the entity list. The entity list can be assigned to a variable. &lt;code>(setq b (entget na))&lt;/code> That assigns to &lt;code>b&lt;/code> the entire entity list for that entity name.

<h3>Subst (substitute new for old)</h3>
Allows you to substitute one aspect for another. Assume variable &lt;code>b&lt;/code> is the name of the list and variable &lt;code>c&lt;/code> contains the value of the element: &lt;code>(40 . 60.0000) (setq bl (subst '(40 . 30.0000) c b))&lt;/code> ;&lt;code>bl&lt;/code> is now the new list. &lt;code>'(40 . 30.0000)&lt;/code> is the new element substituted for the old element &lt;code>c&lt;/code> found in list &lt;code>b&lt;/code>.

<h3>Sslength</h3>
Gives you the length or number of selections made.

<h3>Entmod (entity modification)</h3>
Gives you the ability to take the newly modified entity list and write it back to the database to update the drawing. Now that you have a new list in the variable &lt;code>b1&lt;/code>, you want to make &lt;code>bl&lt;/code> the permanent list in your drawing database. &lt;code>(entmod bl)&lt;/code> You should  see the change appear on the screen.

&lt;h2 id="more">More Examples</h2>
<h3>Change Cross Hair Angle</h3>
This program permits you to draw lines perpendicular to other lines. The program measures the angle of the line chosen, and shifts the SNAP ANGLE to the angle of that line. Use ORTHO ON and draw perpendicular to your chosen line.

(defun c:perpdon (/ a b  pntl pnt2 angl)
(graphscr)
(setq a (entsel))
(setq b (entget (car a)))
(setq pntl (cdr (assoc 10 b)))
(setq pnt2 (cdr (assoc 11 b)))
(setq angl (angle pntl pnt2))
(setvar "snapang" ang1)
(princ)
)

(defun c:perpdoff
(setvar "snapang" 0)
(princ)
)

<h3>Erase Screen</h3>
Erases everything on the drawing screen. If you are in a ZOOM ALL position, the program erases everything within the limits of the drawing.

&lt;strong>Note:&lt;/strong> if you accidentally invoke this command, you can recover with OOPS.

(defun c:erasescr (/ l u)
(setq l (getvar "limmin"))
(setq u (getvar "limmax"))
(command "erase" "w" l u ")
(princ)
)

<h3>Change Layer</h3>
Lets you select objects by any selection method and change their layer. The target layer is chosen by simply pointing to an object on the desired layer. All objects selected will then change to that target layer. To test this program, you will need to create a drawing with objects on different layers.

(defun c:chlayer (/ a1 a2 n index b1 b2 d1 d2 b3)
(graphscr)
(prompt "\nselect entities to be changed: ")
(setq a1 (ssget))
(prompt "\npoint to entity on target layer: ")
(setq a2 (entsel))
(setq n (sslength a1))
(setq index 0)
(setq b2 (entget (car a2)))
(setq d2 (assoc 8 b2))
(repeat n
(setq b1 (entget (ssname a1 index)))
(setq d1 (assoc 8 b1))
(setq b3 (subst d2 d1 b1))
(entmod b3)
(setq index (+ index 1))
)
(princ)
)

Now let's examine the program line by line.

(defun c:chlayer (/ a1 a2 n index b1 b2 d1 d2 b3)
Defines the function with all local variables.

(graphscr)
Changes to graphics screen.

(prompt "\nSelect entities to be changed: ")
This is a prompt statement.

(setq a1 (ssget))
Allows you to select the objects to be changed. The selection set is assigned to variable &lt;code>al&lt;/code>.

(prompt "\npoint to entity on target layer: ")
This is a prompt statement.

(setq a2 (entsel))
This is a special type of selection statement that allows you to select only one entity.

(setq n (sslength a1))
Measures the number of entities in the selection set in variable &lt;code>a1&lt;/code>.

(setq index 0)
Sets the variable called &lt;code>index&lt;/code> to &lt;code>0&lt;/code>.

(setq b2 (entget (car a2)))
This statement gets the entity list from &lt;code>a2&lt;/code>. Thus, &lt;code>a2&lt;/code> is assigned the entity list.

(setq d2 (assoc 8 b2))
This looks for the code &lt;code>8&lt;/code> in entity list &lt;code>a2&lt;/code>, then assigns the sublist to &lt;code>d2&lt;/code>.

(repeat n
This begins the loop that pages through the selection set.

(setq bl (entget (ssname a1 index)))
This gets the entity list and assigns it to &lt;code>b1&lt;/code>.

(setq d1 (assoc 8 b1))
Gets the sublist code &lt;code>8&lt;/code> (the layer).

(setq b3 (subst d2 d1 b1))
Substitutes the new &lt;code>d2&lt;/code> layer for the old &lt;code>d1&lt;/code> layer in the entity list &lt;code>a1&lt;/code>, and assigns it to the new entity list &lt;code>b3&lt;/code>.

(entmod b3)
Updates the new entity list in the database.

(setq index (+ index 1))
Increases the index variable by &lt;code>1&lt;/code>, making it ready for the next loop. The first &lt;code>)&lt;/code> closes the repeat loop. &lt;code>(princ)&lt;/code> exits quietly. The second &lt;code>)&lt;/code> closes the function.

<h3>Substitute text</h3>
This program lets you choose a line of text and substitute another line at exactly the same place.

(defun c:subtext (/ a b d e d1 b1 y)
(prompt "\nSelect text line: ")
(setq a (entsel))
(setq b (entget (car a)))
(setq d (assoc 1 b))
(prompt (cdr d))(terpri)
(setq e (getstring 1))
(setq d1 (cons (car d) e))
(setq b1 (subst d1 d b))
(entmod b1)
(setq y (getstring "\nIs this correct - Y : "))
(if (= (srtcase y) "N") (entmod b))
(princ)
)

<h3>Text - Own Distance, Own Height</h3>
This program lets you change the distance between multiple text lines. In addition to the standard start point and height, you are asked to enter the distance between text lines. You may enter as many text lines as you wish. To stop the program, enter an asterix (*).

(defun tex (/ p1 a b c d e f)
(setq pl (getpoint "\nStarting point: "))
(setq a (getdist p1 "\nEnter height: "))
(setq c (getdist p1 "\nline spacing: "))
(setq d "T")
(while d
(setq e (getstring 1 "Text: "))
(command "text" pl a "0" e)
(setq pl (list (car p1)(- (cadr p1) c)))
(setq f (getstring))
(if (= f "*")(setq d nil))
)
(princ)
)

<h3>Global Text Height Change</h3>
This program allows you to globally change the size of text within a WINDOW or CROSSING without affecting other entities.

(defun chtext (/ a ts n index b1 b c d b2)
(setq a (ssget))
(setq ts (getreal "\nEnter new text size"))
(setq n (sslength a))
(setq index 0)
(repeat n
(setq b1 (entget (ssname a index)))
(setq index (1+ index))
(setq b (assoc 0 b1))
(if (= "TEXT" (cdr b))
  (progn
(setq c (assoc 40 b1))
(setq d (cons (car c) ts))
(setq b2 (subst d c b1))
(entmod b2)
  )
)
)
(princ)
)

<h2>The Define Function (defun)</h2>

We've all seen something like this :

(defun C:DDSTEEL ( / t1 t2 h2 h2 ang)
This, of course, is the first line of an AutoLISP routine.&lt;br/>
&lt;em>But, do you know what it all means?&lt;/em>&lt;br/>
When I started writing AutoLISP code, I was totally confused!!&lt;br/>
The more I read, the more in a muddle I got.&lt;br/>
Global, Local, Argument, Define, Aghhh&hellip;&lt;br/>
So, if you are as confused as I was, read on.

Let's start at the very beginning. (A very good place to start, say
you!)&lt;br/>
The name of a program, or function, must be defined in the first
statement, which is done by using the command :
(defun &lt;em>[Define Function]&lt;/em>

&lt;em>Why is there not a closing parenthesis after the (defun command?&lt;/em>&lt;br/>
There is! In fact the last parenthesis in the program is the one that
closes (defun.

Anyway, let's carry on.&lt;br/>
After (defun must come the name of the program :

(defun DDSTEEL

You do realise that the name of the AutoLISP file, is not necessarily
the name of the program. In fact, one AutoLISP file can have several
programs inside.

Hey, that was easy, I hear you say. Now comes the hard part!!&lt;br/>
After you've named your program you have three choices.

First, do nothing by using ( ) :

(defun DDSTEEL ( )

What you are saying here is that every variable that you use in your
function is GLOBAL. A GLOBAL variable is one that doesn't lose it's value
when the program ends. For example, if PT3 was defined as 45.2 in your
program, it would still have the value of 45.2 when your program ends and
would retain that value until you replace it with another value or, start
a new drawing.
Secondly, you can declare your variables as LOCAL.&lt;br/>
To do this you precede your variables with / :
(defun DDSTEEL ( / p1 p2 p3)

The following example shows the use of LOCAL symbols :

(defun TEST ( / ANG1 ANG2)
 
     (setq ANG1 "Monday")
     (setq ANG2 "Tuesday")
 
     (princ (strcat "\nANG1 has the value " ANG1))
     (princ (strcat "\nANG2 has the value " ANG2))
   (princ)
);defun

Now, at the AutoCAD command line, assign the variables ANG1 and ANG2 to
values other than those used by the TEST function :

Command: (setq ANG1 45)&lt;br/>
Command: (setq ANG2 90)

Verify their values :

Command: !ANG1 [Should return 45.0]&lt;br/>
Command: !ANG2 [Should return 90.0]

Now run our function :

Command: (load "TEST")&lt;br/>
Command: (TEST)

The function should return :

ANG1 has the value Monday&lt;br/>
ANG2 has the value Tuesday

Now check the current values of ANG1 and ANG2 :

Command: !ANG1&lt;br/>
Command: !ANG2

You will find that they still have the values of 45.0. and 90.0
respectively.

&lt;em>A LOCAL variable is one that has a value only for that program while
the program is running.&lt;/em>
The third option is to list a variable without the /.&lt;br/>
This means that a variable is set up to receive a value passed to it from
outside the program. eg :

(defun DTR (a)
   

  (* PI (/a 180.0))
)

To use this, we must pass the value of the argument to the function :

(DTR 90.0)

Here is another example :

Let us write a function that calculates the area of a circle.&lt;br/>
The formulae for calculating the area of a circle is:

Area = PI x radius squared or, PI x r x r

Our program would look like this :

(defun acirc (r)
 
   (setq a (* (* r r) PI))

   (setq a (rtos a))

   (princ (strcat "\nArea = " a))
 
 (princ)
 
)

Now try it :

Command: (load "acirc")&lt;br/>
Command: (acirc 24)

It should return :

Area = 1809.6

You can, of course combine all three options, for example :

(defun DDSTEEL ( a / b c d)

DDSTEEL is the name of the function. Variable a is an argument and
receives the first value passed to it from outside the program.&lt;br/>
Variables b, c, and d are all locals and lose their values once the
program has ended.

Another option that can be used with (defun is if the name of the
function is preceded with C:

(defun C:DDSTEEL ()

Because of the C: you don't have to use parenthesis to call the
function.&lt;br/>
AutoCAD now thinks of that function as an AutoCAD command.&lt;br/>
This is only true if you call the function from the AutoCAD command line.&lt;br/>
If you call the function from within another function you must precede it
with C:

(C:DDSTEEL)

It's a good idea to leave all variables as global whilst you are
writing your&lt;br/>
program so that you can check their values during debugging.

<h2>SET and SETQ</h2>

In AutoLISP, the process of establishing a value for a symbol is called  assignment. The common way to do assignment is to use SETQ. An  assignment causes the value of its second argument to become the value  of its first argument, which has to be a symbol. A symbol is a lexical  variable, declared implicitly.

SET is somewhat like SETQ except that SET does evaluate its first  argument. Therefore the first argument must evaluate to the name of a  dynamic variable (one whose value is to be created dynamically). The  only other difference is that SET takes only two arguments.

Consider the following assignments:

  
&lt;code>(setq a var)&lt;/code> Sets symbol A to VAR. Symbol VAR is not defined.

 
&lt;code>(set a 2)&lt;/code> Evaluates A and sets the result of this evaluation to 2.

 
&lt;code>(princ var)&lt;/code> Returns 2. Symbol VAR is now defined and set to 2.

A common use of  the SET assignment is to define symbols at runtime,  and is sometimes more efficient than list construction when the number of items is not known in advance. As an illustration of this, the following lisp routine example takes a variable  number of points, sorts them by their Y coordinate and draws a line using  the sorted points.

(defun c:test ( / j lpt symb) 
 
 (setq j 1) 
 (while (set (read (strcat "point_" (itoa j))) 
(getpoint "\nPoint : ") 
) 
(setq j (1+ j)) 
 ) 
 ;; Last point is nil. 
 (setq j (1- j)) 
 ;; Sort the points. See function "sortpoints" below. 
 (sortpoints j) 
 ;; Initialize the list of points to be passed to (command "_line") 
 (setq lpt (list ")) 
 ;; Construct the list and set each of our  
 ;; "on the fly" symbols to nil 
  (while (&gt; j 0) 
(setq  
 symb (read (strcat "point_" (itoa j))) 
 lpt (cons (eval symb) lpt) 
) 
(set symb nil) 
(setq j (1- j)) 
 ) 
 ;; draw the line 
 (command "_line") 
 (mapcar 'command lpt) 
 (princ) 
) 
 
 
;; This function sorts the points by their Y coordinate 
(defun sortpoints (j / i cur_y prev_y cur_symb prev_symb point) 
 (setq i 2) 
 (while (&lt;= i j) 
(setq 
 cur_symb (read (strcat "point_" (itoa i))) 
 prev_symb (read (strcat "point_" (itoa (1- i)))) 
 cur_y (cadr (eval cur_symb)) 
 prev_y (cadr (eval prev_symb)) 
) 
(if (&gt; cur_y prev_y) 
 (progn 
(setq   point (eval prev_symb)) 
(set    prev_symb (eval cur_symb))  
(set    cur_symb point) 
(if (/= i 2) (setq i (1- i))) 
 ) 
(setq i (1+ i)) 
) 
 ) 
) 

<h2>Program Looping</h2>

AutoLisp uses 2 kinds of loops, namely (repeat) and (while).&lt;br/>
Let's have a look at the (repeat) function first :

<h2>(repeat)</h2>
The (repeat) function is a simple looping structure. It executes any
number of statements a specific number of times. Like the (progn) function, all
of it's expressions get evaluated, but they get evaluated once each loop.&lt;br/>
Here's a simple example :

(defun c:loop ()
(setq pt (getpoint "\nCentre of Rotation : "))
(setq n  (getint "\nEnter Number of Steps : "))
 
(repeat n
	(command "Rotate" "L" " pt "20")
)
 (princ)
)

Now draw a circle anywhere on the screen and then run the routine.&lt;br/>
The circle should move around.&lt;br/>
Note that the variable that controls the number of loops must be an
integer.

<h2>(while)</h2>
The (while) function loops like (repeat) except that (while) has a conditional test. (while) will continue looping through a series of statements until the condition is nil. Here's an example :

(defun c:loop1 ()
(while
	(setq pt (getpoint "\nChoose a point : "))
	(command "point" pt)
)
(princ)
)

In this example, you can continue to pick points until you press Enter.&lt;br/>
(AutoLisp treats Enter as nil). When you press enter the loop will
terminate.

Here's another example :

(defun c:loop2 () 
(setq ptlist nil)
(while
	(setq pt (getpoint "\nEnter Point or RETURN when done: "))
	(setq ptlist (append ptlist (list pt)))
)
(princ)
)

This example keeps on asking for a point and adding the point to a list
of points, called ptlist. It uses the (append) function to merge the new
point list to ptlist. As soon as you hit Enter the loop stops.&lt;br/>
Run the routine, choose a few points and check the value of ptlist.&lt;br/>
It should contain a long list of points.

The (while) function can also be used for programme iteration.&lt;br/>
This means that a loop is continued until the results of one or more
expressions, calculated within the loop, determine whether the loop is
terminated. A common use of iteration is to increment a counter.&lt;br/>
Have look at this example :

(defun c:loop3 ()
(setq count 0)
(while (&lt; count 10)
	(princ count)
	(setq count (1+ count))
)
(princ)
)

You should get :

012345678910
If you know the number of times you want to loop, use (repeat), a much simpler command than (while).

 
&lt;strong>Hint :&lt;/strong> Have you ever wondered how to make an AutoLisp routine Auto-Repeat?&lt;br/>
Enclose the whole function or sub-function in a (while) loop.&lt;br/>
This way, the function will keep on repeating until Enter or Cancel is
hit.

Enough for now, my brain hurts&hellip;&lt;br/>
In fact, I think I'm going "Loopy-Loo"&lt;br/>
Cheers&hellip;

<h2>Conditionals</h2>

(If) is probably the most important and widely use condition
statement.&lt;br/>
Unlike other languages though, you can match only one (if) statement with
a &lt;em>then&lt;/em> statement. The syntax is as follows :

(if xyz
(then do this)
(else do this)
)

Let's look at a simple example :

(defun c:testif ()
(setq a (getreal "\nEnter a Number : ")
b (getreal "\nEnter Second Number : ")
);setq
(if (= a b)
	(prompt "\nBoth Numbers are equal")
	(prompt "\nBoth numbers are not equal")
);if
 (princ)
);defun
(princ)

If you need to evaluate more than one &lt;em>then,&lt;/em> or &lt;em>else&lt;/em>
statement, you must use the (progn) function. Here's another example :

(defun c:testprogn ()
(setq a (getreal "\nEnter a Number : ")
b (getreal "\nEnter Second Number : ")
);setq
(if (= a b)
(progn
	(prompt "\nBoth Numbers are equal")
	(prompt "\nHere is Another statement")
	(prompt "\nAnd Another One")
);progn
	(prompt "\nBoth numbers are not equal")
);if
 (princ)
);defun
(princ)

You can use as many statements as you like within the (progn) function.

You can also use (if) along with logical operators. They are functions
that determine how two or more items are compared. The available logical
operators are :

AND     ORNOT

AND returns true if all arguments are true.&lt;br/>
OR returns true if any of the arguments are true.&lt;br/>
NOT returns true if it's argument is false and returns false if it's
argument is true. Let's look at some examples :

(defun c:testand ()
(setq a (getreal "\nEnter a Number : "))
(if
    (and
	(&gt;= a 5.0)
	(&lt;= a 10.0)
    );and
	(prompt "\nNumber is between 5 and 10")
	(prompt "\nNumber is less than 5 or greater than 10")
);if
 (princ)
);defun
(princ)

(defun c:testor ()
(setq a (getstring "\nAre you Male? Y/N : "))
(if 
    (or
	(= a "y")
	(= a "Y")
    );or
	(prompt "\nHello Sir")
	(prompt "\nHello Madam")
);if
  (princ)
);defun
(princ)

A Relation Operator is a function that evaluates the relationship between
two or more items. Relationship Operators available are :

&lt;	less than
&gt;	greater than
&lt;=	less than or equal to
&gt;=	greater than or equal to
=	equal to
/=	not equal to
eq	are two expressions identical
equal	are two expressions equal

Let's look a bit closer at the (eq) and the (equal) functions.&lt;br/>
The (eq) function determines whether two expressions are bound to the same
object.

(setq a '(x y z))
(setq b '(x y z))
(setq c b)
 
(eq a c) would return nil, a and c are not the same list.
(eq c b) would return true, b and c are exactly the same list.

The (equal) function determines whether two expressions evaluate to the
same thing. You can use the optional numeric argument, &lt;em>fuzz, &lt;/em>to
specify the maximum amount by which both expressions can differ and still
be considered equal.

(setq a '(x y z))
(setq b '(x y z))
(setq c b)
(setq m 1.123456))
(setq n 1.123457))
 
(equal a c) would return true.
(equal c b) would return true.
(equal m n) would return nil.
(equal m n 0.000001) would return true.

What about a Multiple (if) function. The (cond) function works very much
like (if), except (cond) can evaluate any number of test conditions.&lt;br/>
Once (cond) finds the first condition that is true, it processes the
statements associated with that condition. (It only processes the first
true condition). Here's an example :

(defun c:testcond ()
(setq a
   (strcase (getstring "\nSize of Bolt (M10,M12,M16): ")
   );strcase
);setq
(cond
	((= a "M10") (prompt "\nYou have choosen M10"))
	((= a "M12") (prompt "\nYou have choosen M12"))
	((= a "M16") (prompt "\nYou have choosen M16"))
	(T (prompt "\nUnknown Bolt Size"))
);cond
 (princ)
);defun
(princ)

The (cond) function takes any number of &lt;em>lists&lt;/em> as it's arguments.&lt;br/>
Each argument must be a list containing a test followed by any number of
expressions to be evaluated.

<h2>COND vs. IF</h2>

  Written by David Hoekstra&lt;br/>
  Published on AfraLisp with kind permission.

  &lt;em>"IF I had a nickel
  for every COND statement that I ever wrote in lisp, I'd be rich!"&lt;/em>&lt;br/>

  I see lots of lisp routines that use only the IF function for
  conditional statements. I think this has a lot to do with the fact that most
  new AutoLISP programmers start out with IF, and never proceed on to COND. I
  have talked to several lisp programmers who state that they never learnt how
  to use COND, and seemed to think it was useless.&lt;br/>
  &lt;br/>
  COND is a thing of beauty, and let me tell you why.&lt;br/>
  &lt;br/>
  The basic syntax of COND is:

  
(cond ((predicate1) (then do something 1))    ;if this predicate is true,
  ;do something1
 
((predicate2) (then do something 2))    ;if this predicate is true,
  ;do something2,
  ;each predicate and action
  ;following the
  ;first one is optional
 
(t (else do this))    ;else, if none of the
  ;predicates returns
  ;T, do this
)
&lt;b>
Compare that to the syntax of IF:&lt;/b>
  (if (only one predicate)    ;must return T, even if it is a double negative
(then do something) ;if the predicate is true, then do this
  ;prescribed something
 
(else do this);this is optional, if there is an else, then
  ;this is what happens
  ;if the predicate is not true
)

  With IF, there is only one predicate (or
  grouped predicate), one then (or grouped then), and one optional else (or
  grouped else) statement. When these are all you need, then IF works quite
  nicely, i.e., logically. Where I find IF to be distasteful is when it is
  used with grouped then or else statements; and also if you need more than
  one predicate, it requires several IF statements in combination.

  
  Because IF can only accept one statement for the then and else clause, you
  must use the PROGN to group several statements as one statement:

  
  (if (&gt; angle 90)
(progn  ;then clause
  (setq ed (subst (cons 8 "somelayer") (assoc 8 ed) ed))
  (entmod ed)
  (entupd en)
) ;_ progn
(princ "\nNothing changed.")    ;optional else clause
) ;_ if

  The "then" clause needs to run
  several statements if the predicate is true (&gt; angle 90), if the symbol
  "angle" is greater than 90. Because IF only accepts one statement
  for a then clause, you must artificially wrap the three statements into a
  grouped statement by use of PROGN. Now let's compare this to the same
  operation, but written with COND instead:

  
  (cond ((&lt; angle 90)
 (setq ed (subst (cons 8 "somelayer") (assoc 8 ed) ed))
 (entmod ed)
 (entupd en)
) ;_ end of the first then condition
(t
 (princ "\nNothing changed.")
) ;_ end of optional else condition
) ;_ end of cond statement

  Here there is no artificial wrapping of
  several statements into one group. This COND statement will not fail if you
  forget to add a PROGN wrapper! In the case above, I consider COND to be a
  more logical implementation, and therefore &lt;i>"the right thing to
  do."&lt;/i> Remember, programmers live and die by the logic in their code.
  This is certainly one reason to consider using COND instead of IF, but let
  me give another one: multiple predicates in one COND statement!

  
  (cond ((and (&gt;= angle 0) (&lt;= angle 90)
 (setq ed (subst (cons 8 "somelayer") (assoc 8 ed) ed))
 (entmod ed)
 (entupd en)
) ;_ end of the first then condition
 ((and (&gt; angle 90) (&lt;= angle 180)
 (statement 1)
 (statement 2)
 (statement 3)
 (statement 4)
) ;_ end of the second then condition
((and (&gt; angle 180) (&lt;= angle 270)
 (statement a)
 (statement b)
 (statement c)
 (statement d)
) ;_ end of the third then condition
((and (&gt; angle 270) (&lt; angle 360)
 (statement x)
 (statement y)
 (statement z)
 (statement 0)
) ;_ end of the third then condition
) ;_ end of cond statement

  In this one COND statement, there are four
  separate conditions that could be met, the equivalent IF statement would
  require four separate IF statements. Furthermore, because the predicates are
  evaluated sequentially, you can use that to your advantage. In some cases
  you may not have to exactly define every detail for each predicate:

  
  (setq angdir 354)
(cond ((&lt; angdir 90)
 (princ "\ncond1")
)
((&lt; angdir 180)
 (princ "\ncond2")
)
((&lt; angdir 270)
 (princ "\ncond3")
)
((&lt; angdir 360)
 (princ "\ncond4")
)
) ;_ cond

  And finally, another reason to use COND as
  much as possible. Have you ever written a lisp routine that is entirely
  dependent on a condition being met right at the start? Consider putting the
  majority of the code inside a COND statement. Then if that condition is not
  met, the routine will quietly exit without the need to run the EXIT or QUIT
  function, which can force an error call. I might want to perform several
  things in a drawing, but the whole process is dependent on having a
  particular drawing format block inserted:

  
  (defun C:TEST (/)
 
(setq ss (ssget "X" '((0 . "insert")(2 . "e1_title"))))
(cond (ss    ;if there is a selection set, then proceed
 (statement 1)
 (statement 2)
 ... ad infinitum
 (statement 455)
)
(t     ;else exit the routine without forcing an error call
 (princ "\nNo E1_TITLE format found, cannot continue, exiting!")
)
) ;_ cond
(princ)
) ;_ C:TEST

  To be sure, IF statements have their place.
  There is no reason to write a COND statement when a simple IF statement
  makes more logical sense:

  
  (if (null tfstd)
(load "tfstd" "\nTFSTD.LSP was not found in any of the paths.")
)
(tfstd)

  The above example would not be very logical
  if it were forced into a COND statement. As we can see there are times when
  only an IF statement will do the trick nicely, and other times when only
  COND will. The problem is when AutoLISP programmers attempt deal with every
  conditional logic by the IF function. Of course, I could cite other examples
  of the same sorts of functional fallacies, but suffice to say, the best
  method to avoid such traps is to experiment, experiment, experiment, and
  read other people's code with an eye to learning something new.

<h2>Error Trapping</h2>

This was another area that caused me quite a bit of confusion when I
was first learning AutoLISP. All AutoLISP routines should contain Error
Trapping. There is nothing worse than running a routine and finding out
that once it has run, or been cancelled, your system variables, etc. have
all changed and nothing works the same any more.

I am going to look at two types of Error Trapping here. Firstly, an
Error Trapping routine build into a function, and secondly, a Global Error
Trapping function. But first, some background on the AutoCAD *error*
function.

AutoLISP provides a method for dealing with user (or program errors).&lt;/br>
It is one of the only AutoLISP functions that is user-definable.&lt;/br>
This is the *error* function.

(*error* &lt;em>string&lt;/em>)

It is executed as a function whenever an AutoLISP error condition
exists.&lt;/br>

If there is an error, AutoCAD passes one argument to *error*, which is a
string containing a description of the error.

The following function does the same thing that the AutoLISP standard
error handler does. Print error and the description.&nbsp;
(defun *error* (errmsg)
 (princ "error: ")
 (princ errmsg)
 (princ)
)
Before designing an Error Trapping function there is a couple of things to
keep in mind.&lt;/br>
First, the Error-Trap function must be called *error*. It also must have
an argument passing variable. Our variable is called &lt;em>errmsg&lt;/em>.

You can call this variable anything you like. Now, you can put anything
you like in the body of this function. For example :

(defun *error* (errmsg)
 (princ "\nAn error has occurred in the programme. ")
 (terpri)
 (prompt errmsg)
 (princ)
)

To test this error trap, create a lisp file with the preceding code and
load the file. Begin running any program or command that you like. In the
middle of the program hit ESC or Ctrl C. (AutoCAD thinks that this is an
error.)&lt;/br>
Control should be passed to the Error Trap.

It is important to note, and courteous, that you should never change a
users settings, including an existing Error Trap, without first saving it
as a variable and then replacing it at the end of the program.&lt;/br>
Remember, as well, to place the replacement of this Error Trap in your
Error Trap routine as your program could also crash.

Here is an example of Error Trap build into an AutoLISP routine :

(defun c:drawline ()					;define function
(setq temperr *error*)				;store *error*
(setq *error* trap1)				;re-assign *error*
(setq oldecho (getvar "cmdecho"))		;store variables			
(setq oldlayer (getvar "clayer"))
(setq oldsnap (getvar "osmode"))
(setvar "cmdecho" 0)				;set variables
(setvar "osmode" 32)
(command "undo" "m")				;undo mark
(setq pt1 (getpoint "\nPick First Point: "))	;get points
(setq pt2 (getpoint pt1 "\nPick Second Point: "))
(command "LAYER" "M" "2" ")			;change layer
(command "Line" pt1 pt2 ")			;draw line
(setq pt3 (getpoint pt2 "\nPick Third Point: "));get 3rd point
(setvar "osmode" 0)				;switch off snap
(command "Line" pt2 pt3 ")			;draw line
(setvar "clayer" oldlayer)			;reset variables
(setvar "osmode" oldsnap)
(setvar "cmdecho" oldecho)
(setq *error* temperr)				;restore *error*
 (princ)
)

(defun trap1 (errmsg)					;define function
(command "u" "b")				;undo back
(setvar "osmode" oldsnap)			;restore variables
(setvar "clayer" oldlayer)
(setvar "cmdecho" oldecho)
(setq *error* temperr)				;restore *error*
(prompt "\nResetting System Variables ")	;inform user
 (princ)
)

This routine simply asks for 3 points then draws a line, on layer 2,
between them. As you can see, the existing (*error*) error trap is saved
to the variable temperr. *error* is then re-assigned to the error trap,
called trap1.

Any system variables such as object snaps and command echo, are saved as
well as the current layer. An UNDO MARK is then put in place.&lt;/br>
When an error occurs, the error trap first performs an UNDO BACK before
resetting the drawing back to it's original settings.&lt;/br>
Try choosing the first two points and then hitting ESC or Ctrl C.&lt;/br>
Did you see what happened? The first line that was drawn was erased and
your settings have been returned to their initial state.

The following is an example of an Error Trap using a Global Function :

Our &lt;em>drawline&lt;/em> routine with some differences!!

(defun c:drawline ()					;define function
(initerr)					;intit error
(setvar "cmdecho" 0)				;reset variables
(setvar "osmode" 32)
(command "undo" "m")				;set mark
(setq pt1 (getpoint "\nPick First Point: "))	;get points
(setq pt2 (getpoint pt1 "\nPick Second Point: "))
(command "LAYER" "M" "2" ")			;change layer
(command "Line" pt1 pt2 ")			;draw line
(setq pt3 (getpoint pt2 "\nPick Third Point: "));get 3rd point
(setvar "osmode" 0)				;reset snap
(command "Line" pt2 pt3 ")			;draw line
(reset)						;reset variables
 (princ)
)

(princ)

Now our Global Error Trap named Error.Lsp

(defun error()						;load function
(prompt "\nGlobal Error Trap Loaded")			;inform user
(princ)
);defun
;;;*==========================================================
(defun initerr ()					;init error
(setq oldlayer (getvar "clayer"))			;save settings
(setq oldsnap (getvar "osmode"))
(setq oldpick (getvar "pickbox"))
(setq temperr *error*)				;save *error*
(setq *error* trap)					;reassign *error*
(princ)
);defun
;;;*===========================================================
(defun trap (errmsg)					;define trap
(command nil nil nil)
(if (not (member errmsg '("console break" "Function Cancelled"))
)
  (princ (strcat "\nError: " errmsg))			;print message
)     
(command "undo" "b")					;undo back
(setvar "clayer" oldlayer)				;reset settings
(setvar "blipmode" 1)
(setvar "menuecho" 0)
(setvar "highlight" 1)
(setvar "osmode" oldsnap)
(setvar "pickbox" oldpick)
(princ "\nError Resetting Enviroment ")		;inform user
(terpri)
(setq *error* temperr)				;restore *error*
(princ)
);defun
;;;*===========================================================
(defun reset ()						;define reset
(setq *error* temperr)				;restore *error*
(setvar "clayer" oldlayer)				;reset settings
(setvar "blipmode" 1)
(setvar "menuecho" 0)
(setvar "highlight" 1)
(setvar "osmode" oldsnap)
(setvar "pickbox" oldpick)
(princ)
);defun
;;;*======================================================
(princ)

To run and test this you must load Error.Lsp before you load
Drawline.Lsp.

As you can see, by using a Global Error routine you can save yourself the
bother of writing individual error traps for each of your programs.&lt;/br>
Error.Lsp could easily be loaded from your Acad.Lsp and would then be
available whenever one of your routines wishes to call upon it.

Happy Error Trapping!!!!

<h2>Calculating Points (Polar)</h2>

The Polar function is defined in the AutoCAD Customization manual as follows :

&lt;strong>POLAR :&lt;/strong> Returns the UCS 3D point at a specified angle and distance from a point.

&lt;em>(polar pt ang dist)&lt;/em>

This, I believe, is one of the most useful functions in the AutoCAD stable.

In a nutshell, you feed it a point, tell it the angle and distance from
that point that you want to be, and it will return the second point.&lt;br/>
Can you imagine having to do that using car, cadr, etc.&lt;br/>
First you would have to break the list down into each separate component,
do all the calculations on each individual item, and then re-construct the
list.

What a pain!!

Following is an example of how to use POLAR to construct a simple square or rectangle from values input by the user :

(defun DTR (a)				;degrees to radians function

(* PI (/ a 180.0))
);defun
;=========================================
(defun C:BOX1 (/ IP P1 P2 P3 LENGTH HEIGHT	;define function and declare

	OLDSNAP OLDBLIP OLDLIGHT)	;variables as local

(setq OLDSNAP (getvar "OSMODE")			;store system variables

OLDBLIP (getvar "BLIPMODE")
   OLDLIGHT (getvar "HIGHLIGHT")
);setq

;=========================================
(setvar "CMDECHO" 0)				;change system variables
(setvar "BLIPMODE" 0)

(setq IP (getpoint "\nInsertion Point: "))	;get insertion point
(setvar "OSMODE" 0)				;switch off snap

(setq LENGTH (getreal "\nEnter Length: ")	;get length of box
HEIGHT (getreal "\nEnter Height: ")	;get height of box

);setq
;=========================================
(setq P1 (polar IP (DTR 0.0) LENGTH)		;calculate first corner

P2 (polar P1 (DTR 90.0) HEIGHT)		;calculate second corner

P3 (polar P2 (DTR 180.0) LENGTH)		;calculate third corner

);setq
;=========================================
(command "PLINE" IP "W" " "
 P1 P2 P3 "C"

);command					;draw the box
;=========================================
(prompt "\nRotation Angle: ")			;prompt the user for rotation
(command "ROTATE" "LAST" " IP pause)		;rotate the box

;=========================================
(setvar "OSMODE" OLDSNAP)			;reset system variables
(setvar "BLIPMODE" OLDBLIP)

(setvar "HIGHLIGHT" OLDLIGHT)
(princ)						;exit quietly
);defun

To save you typing here's the source code : &lt;a href="files/box1.zip">Box1
Lisp&lt;/a> (1 Kb)

As you can see, we first need to write a function to convert radians to
degrees. This is because when we deal with angles in AutoLISP they must be
in Radians.

Hint : This could be a Global function loaded from your Acad Lisp file.

Now to our main routine.

The first thing that we do is define the function and declare all the
variables as local. (Only used within this program.)&lt;br/>
Then we save certain system variables, before changing them, so that we
can reset them later.&lt;br/>
Next we ask the user for Insertion Point, Length and Height of the box.

We then use the POLAR function to calculate the remaining 3 corners of the
box. (PT1, PT2 and PT3).&lt;br/>
Then, just to be kind, we allow the user to rotate the box.&lt;br/>
(That's why we drew the box using a Pline.)&lt;br/>
Lastly, we reset all the system variables that we changed back to their
original state.

<h2>Locating Files</h2>

AutoLISP has two functions available to help us locate files.&lt;br/>

They are the (findfile) function and the (getfiled) function.

<h2>(findfile)</h2>
The (findfile) function will only search the current AutoCAD search
path if a drive/directory prefix is not supplied.&lt;br/>
If the file is found, the full directory path is returned.

If no file is found, (findfile) returns nil.&lt;br/>
The syntax of this function is as follows :

(findfile "filename")

Say you were looking for the file ACADR14.LSP.

(findfile "ACADR14.LSP)

Would return :

"C:\\ACADR14\\SUPPORT\\ACADR14.LSP"

&lt;strong>Note :&lt;/strong> AutoLisp allows you to use / or \\ for directory descriptors.

<h2>(getfiled)</h2>
The (getfiled) function will prompt the user for a file name using the
standard AutoCAD file dialogue box. It will then return the file name
either with the full path name or with the path name stripped.&lt;br/>
The syntax of the (getfiled) function is as follows :

(getfiled "Title" "Directory Path and/or File name" "File Extension" Flag)

The "Title" argument is simply the name that will appear in
the Title Bar of the dialogue box.

The "Directory Path and/or File Name" argument is the default
directory path that the dialogue box will use. If a file name is included
this name will appear in the File Name edit box. This can be null.

The "File Extension" function is the default file name
extension. If it is null, it defaults to * (all file types). If the file
type "dwg" is part of the "File Extension", an image
preview is displayed.

There are four possible flags and they make use of the "sum of the
flags" concept.

To combine any of the flags, just add them together. The flags are :

Flag 1.	If you set this flag, the function will prompt for the name of a
NEW file to create.
Flag 4.	This flag will disable the "Type it" button. The user must then
pick from the listed files rather than type a file name.
If this flag is not set and the user selects the "Type it" button,
the dialogue box disappears and (getfiled) returns a value of 1.
Flag 3.	This flag allows the user to enter a file extension.
If the flag is not set, only the extension used in the extension
edit box will be used.
The extension is also added to the file name if the user does not
enter it in the File Name edit box.
Flag 8.	If this flag is set and flag 1 is not set, (getfiled) searches in 
accordance to the AutoCAD library search path. It also strips the
path and only returns the file name.
If it is not set, it returns the entire path name.

Let's look at an example. We want to open a directory on c:/ called
"Slides" containing a list of file that we would like to view.
Our routine would look like this :

(defun c:slv ( / sl)
(setq sl (getfiled "Pick a slide to view"
		   "C:/SLIDES/"
		   "sld"
		   10
	 );getfiled
);setq
(command "vslide" sl)
 (princ)
);defun
(princ)

Your dialogue box should look like this :

<img src="https://www.afralisp.net/autolisp/tutorials/images/getfiled.gif">

Take note of a couple of things.&lt;br/>
See how it defaults to the C:/SLIDES directory;&lt;br/>
The "Type it" button has been disabled; (Flag 2 was set.)&lt;br/>
The full path name of the file was returned. (Flag 8 was set)&lt;br/>
This is because C:/SLIDES is not in my AutoCAD search path.

As you can see, this is quite a useful function in that it can restrict
your user to only certain directories and file types whilst still leaving
them some flexiblity in their choice.

<h2>File Handling</h2>

AutoLisp can only deal with one type of external file, namely an ASCII
text file.&lt;br/>
As well as this, AutoLisp can only read a file in sequential order. (It
does not have random access.)&lt;br/>
Despite these drawbacks, AutoLisp has certain basic tools that allow you
to read and write one character at a time, or a full line at a time.&lt;br/>
You can also append data to an existing file.

Working with external files is very simple.&lt;br/>
First you "Open" the file.&lt;br/>
Then you process the file by "Reading", "Writing" or
"Appending" to it.&lt;br/>
You then "Close" the file.&lt;br/>
When you "Open" a file, Autolisp returns a file handle. This
file handle is a name supplied by the operating system that let's you
inform AutoLisp which file you want to work with.

Let's look at some examples.

(setq file (open "Testfile.txt" "w"))

AutoLisp should return something like this :

File: #28a27d2

This is the file handle returned by the operating system and stored in
variable "file".&lt;br/>
Try this now :

(write-line "This is some test data." file)

This "writes" a line of data to the file with handle
"file".

(write-line "This is some more test data." file)

Let's write some characters to the same file :

(write-char 79 file)

This would write the ASCII character "O" to the file.

(write-char 75 file)

This would write the letter "K"&lt;br/>
Now let's close the file :

(close file)

To read a file is just as simple :

(setq file (open "testfile.txt" "r"))

Open "Testfile.txt" to "Read".

(read-line file)

Read the first line.&lt;br/>
Lisp should return :

"This is some test data "

Read the next line :

(read-line file)

Lisp should return :

"This is some more test data."

Let's read a character :

(read-char file)

Lisp will return :

79

It has returned the ASCII number.

(chr (read-char file))

Read the character AND convert it.&lt;br/>
Lisp should return :

"K"

(read-line file)

Lisp should return "nil" as we have reached the end of the
file.

Before moving on, you should always make sure that you close
your files.

(close file)

Append is very similar to writing to a file except the file must already&lt;br/>
exist if you want to append to it.

There are three other functions that write to an external file.&lt;br/>
They are (princ), (prin1) and (print).&lt;br/>
Let's have a look at them :

(setq file (open "afile.txt" "w"))
(princ "This is the (princ) function" file)
(prin1 "This is the (prin1) function" file)
(print "This is the (print) function" file)
(close file)

Open the file "afile.txt". You should have the following :

This is the (princ) function"This is the (prin1) function"
"This is the (print) function" 

All 3 functions display the result at the prompt line and send the&lt;br/>
output to a file. Here are the differences :
(princ) displays strings without quotation marks.&lt;br/>
(prin1) displays strings with quotation marks.&lt;br/>
(print) displays strings with quotation marks and places a blank line&lt;br/>
before the expression and a space afterwards.

Now we will look at a practical example :

The following is a Drawing Log Routine that logs the date, time, &amp;&lt;br/>
Drawing Name of each Drawing Session. It writes a report&lt;br/>
to an ASCII Text file (Log.Txt).

(defun C:LOGIN ( / a c d file fp)
 (setq file (findfile "LOG.TXT"))
 (if (not file)
(open "LOG.TXT" "w")
 );if
 (setq a (TODAY)
TIME1 (TIME)
c (getvar "DWGNAME")
d (strcat "Drg Start   " a "  -  " TIME1 "  -  " c)
 );setq
 (if (/= c "Drawing.dwg")
(progn  
 (setq file (findfile "LOG.TXT")
fp (open file "a")
 );setq
 (princ d fp)
 (princ "\n" fp)
 (close fp)
 (princ (strcat "\nLogged in at : " TIME1))
);progn
 );if
 (princ)
);defun
;;;*-------------------------------------------------
(defun C:LOGOUT ( / a c d file fp)
 (setq a (TODAY)
TIME2 (TIME)
c (getvar "DWGNAME")
d (strcat "Drg Exit    " a "  -  " TIME2 "  -  " c)
 );setq
 (if (/= c "Drawing.dwg")
(progn  
 (setq file (findfile "LOG.TXT")
fp (open file "a")
 );setq
 (princ d fp)
 (princ "\n" fp)
 (close fp)
 (princ (strcat "\nLogged out at : " TIME2))
 (etime)
);progn
 );if
 (princ)
);defun
;;;*-------------------------------------------------
(defun ETIME ( / hr1 m1 s1 tot1 hr2 m2 s2 tot2 total ht mt file fp)
 (setq hr1 (* 60 (* 60 (atof (substr time1 1 2))))
m1 (* 60 (atof (substr time1 4 2)))
s1 (atof (substr time1 7 2))
tot1 (+ hr1 m1 s1)
hr2 (* 3600 (atof (substr time2 1 2)))
m2 (* 60 (atof (substr time2 4 2)))
s2 (atof (substr time2 7 2))
tot2 (+ hr2 m2 s2)
total (- tot2 tot1)
hr1 (/ total 3600)
ht (fix hr1)
hr1 (- hr1 ht)
mt (* hr1 60)
ht (rtos ht)
mt (rtos mt) 
 );setq
 (setq d (strcat "Editing Time This Session :
" ht " Hours and " mt " minutes"))
 (setq file (findfile "LOG.TXT")
fp (open file "a")
 );setq
 (princ d fp)
 (princ "\n" fp)
 (princ "==========================
====================================" fp)
 (princ "\n" fp)
 (close fp)
 (princ)
);defun
;;;*-------------------------------------------
;;;*Calculates the Current Date
(defun TODAY ( / d yr mo day)
   (setq d (rtos (getvar "CDATE") 2 6)
  yr (substr d 3 2)
  mo (substr d 5 2)
 day (substr d 7 2)
   );setq
   (strcat day "/" mo "/" yr)
);defun
;;;*-------------------------------------------
;;;*Calculates the Current Time
(defun TIME ( / d hr m s)
   (setq d (rtos (getvar "CDATE") 2 6)
  hr (substr d 10 2)
   m (substr d 12 2)
   s (substr d 14 2)
   );setq
   (strcat hr ":" m ":" s)
);defun
(princ)

Load the file and type "Login" to run it. Leave it for a
minute or so and then type "Logout" to exit the routine.&lt;br/>
Have a look at the file Log.txt. It should look something like this :

Drg Start   07/12/98  -  15:36:31  -  F4443.dwg
Drg Exit    07/12/98  -  15:36:34  -  F4443.dwg
Editing Time This Session :  0 Hours and 0.05 minutes
==============================================================

Every time you log on and off the Starting Time, Ending Time and Total
Editing Time will be appended to this file.

If you wish you can load Login.Lsp from your AcadDoc.Lsp file, and edit the
Acad.mnu to call the Logout.Lsp routine before Exiting, Quiting or
Starting a new drawing.

To download the source coding for this routine, just place you mouse&lt;br/>
pointer &lt;a href="files/log.zip">here &lt;/a>and click. (Gently please, I've
got a hangover.)

For more information on this topic, refer to the &lt;a href="external-data.php">External
Data Tutorial.&lt;/a>

<h2>External Data</h2>

Do you have a library full of blocks taking up vast amounts of disk
space?&lt;br/>
Do you find it difficult to locate a specific block because you've got so
many or cannot remember what you called it?&lt;br/>
By using external data you can parametrically draw these objects. If you
look at my Structural Steel Programme DDSTEEL you will notice that every
section is drawn using data retrieved from an external data file.&lt;br/>
The following tutorial will show you how to retrieve external data, format
it into something that Autolisp can use, then place the data into
individual variables.

First of all you need to create the external data file.&lt;br/>
Create a text file called Test.dat and type in the following data :

*6&lt;br/>
152.0,10.0,124.0&lt;br/>
*7&lt;br/>
178.0,12.0,135.0&lt;br/>
*8&lt;br/>
203.0,14.0,146.0&lt;br/>
*9&lt;br/>
229.0,16.0,158.0
This type of data file is known as a comma deliminating text file.&lt;br/>
The data represents values that we would use to draw a specific object.&lt;br/>
The first line (*6) represents the name of the object&lt;br/>
and the second line (152.0,10.0,124.0) are the values that we are&lt;br/>
attempting to retrieve.
Next, create a Lisp file called Test.Lsp and type in the following :

(defun C:Test (/ item data dline maxs 
count chrct numb size)
(setq size 
  (getstring "\nEnter Size &lt;6, 7, 8 or 9&gt;: "))	;enter size req'd
(setq	dlist nil
size  (strcat "*" size)				;add asterix to size
file  (findfile "test.dat")			;find data file
fp    (open file "r")				;open file to read
item  (read-line fp)				;first line is label for file
);setq
(while item						;process each line of file
  (if	(= item size)					;compare values
(setq data (read-line fp)				;read a line
    item nil					;stop searching for item
);setq
(setq item (read-line fp))			;keep searching for item
  );if
);while
(if data						;if the size has been found
  (progn
(setq maxs  (strlen data)				;establish length of input
    count 1					;initiliaze count
    chrct 1					;initiliaze char position
);setq
(while (&lt; count maxs)				;process string one chr at a time
(if (/= "," (substr data count 1))		;look for the commas
  (setq chrct (1+ chrct))			;increment to next position
  (setq	numb  (atof 
 (substr data 
	  (1+ (- count chrct)) chrct))  	;convert to real
	dlist (append dlist (list numb))	;add it to the list
	chrct 1					;resets field ct
  );setq
);if
(setq count (1+ count))				;increment the counter
);while
(setq numb  (atof 
   (substr data 
(1+ (- count chrct))))  	;convert to real
    dlist (append dlist (list numb))		;add it to the list
);setq
  );progn
);if data
(close fp)						;close data file
(mapcar 'set '(a b c) dlist)				;allocate to variables
);defun
The programme basically does the following :

&lt;ul>

Gets the name of the object who's data we want to retrieve.(eg 6)

  Adds a * to the front of it. (eg *6)

Searches for the Data file (Test.Dat) and opens it to read.

Reads each line of the file until it finds one matching our objects
  name.

  Reads the next line and stores the data.

&lt;/ul>
Unfortunately, the data we have looks something like this :

(152.0,10.0,124.0)

Oh No, Commas...Don't worry the next section of the program deals with
them. It parses the data and removes all commas so that we end up with a
LIST looking like this :

(152.0 10.0 124.0)

Now by using the mapcar function we can allocate each item in the list
to its own variable.
(mapcar 'set '(a b c) dlist)
I have deliberately not declared these variables as locals so that you
can view them within AutoCAD.

Type &lt;em>!dlist&lt;/em> to view the data list.&lt;br/>
Type &lt;em>!a&lt;/em> to see the first item in the list.&lt;br/>
Type &lt;em>!b&lt;/em> to see the second item in the list.&lt;br/>
Type &lt;em>!c&lt;/em> to see the third item in the list.

You can now use this data to draw your object.

As you can see, this is a much more efficient way of drawing objects
that are the same shape but have differing dimensions.

To save you having to type here is the source code for the whole&lt;br/>
of this routine. Now don't you think I'm good to you?

&lt;a href="files/test.zip">Test Zip&lt;/a> (7 Kb)

<h2>List Manipulation</h2>

<h2>List Manipulation - Part 1</h2>
As you are probably well aware, LISP stands for "List Processing".

(Not "Lost in Stupid Parenthesis")

A list is a group of elements consisting of any data type and is stored as a single variable. A list can contain any number of Reals, Integers, Strings, Variables and even other Lists.

Let's have a look at a list. Type this :

(setq pt1 (getpoint "\nChoose a Point : "))

AutoLisp should return something like this :

(127.34 35.23 0.0)

Fine, you say, I've got a list but what do I do with it?&lt;br>
AutoLisp has many functions available to manipulate lists.&lt;br>
Let's have a look at them.

<h3>Car</h3>
The primary command for taking a list apart is the "Car" function. This function returns the first element of a list. (The x coordinate.)

For example :

(setq a (car pt1))

Would return :

(127.34)

<h3>Cdr</h3>
This function returns the second element plus the remaining elements of a list. For example :

(setq b (cdr pt1))

Would return :

(35.23 0.0)

But what if we only wanted the second element? We could write :

(setq b (car (cdr pt1)))

But there is a better way. AutoLisp has provided the "Cadr" function which is basically an abbreviation of a nested command.

<h3>Cadr</h3>
This returns the second element of a list. (The y coordinate)

(setq b (cadr pt1))

This would return :

(35.23)

Likewise, there is another abbreviated function to return the third element.

<h3>Caddr</h3>
This returns the third element of a list. (The z coordinate)

(setq c (caddr pt1))

Would return :

(0.0)

AutoLisp has other functions that will retrieve values from lists of more than three elements. (Caar, cadar, etc). You can, though, us another function to access any element of a list. This is the "nth" function.

<h3>nth</h3>
The syntax for the nth function is as follows :

(nth num list)

"num" is the number of the element to return. Just remember that zero is the first element. For example given the list :

(setq d '("M10" "M20" "M30" 10.25))
(setq e (nth 0 d))

Would return :

("M10")

And likewise :

(setq f (nth 3 d))

Would return :

(10.25)

In part 2 we will look at a practical example of using these functions.

<h2>List Manipulation - Part 2</h2>
We've now managed to extract elements from a list, but what do you do if you want to create a new list. Let's say you have two elements :

(setq a 200.0)
(setq b 400.0)

You want to combine them to create a new list. To do this you would use the "List" function. For example :

(setq c (list a b))

Would return :

(200.0 400.0)

You could also write the function like this :

(setq c '(a b))

Here's an example of List Manipulation. We are going to use the (car), (cadr) and (list) function to draw a rectangle.

(defun c:rec ( / pt1 pt2 pt3 pt4)
 
(setq pt1 (getpoint "\nSelect First Corner: "))
;get the first point
 
(setq pt3 (getcorner pt1 "\nSelect Second Corner: "))
;get the third point
 
(setq pt2 (list (car pt1) (cadr pt3)))
;construct the second point
 
(setq pt4 (list (car pt3) (cadr pt1)))
;construct the fourth point
 
(command "Line" pt1 pt2 pt3 pt4 "c")
;draw the rectangle
 
(princ)
 
);defun
;**********************************************************

Let's look closer at the line :

(setq pt2 (list (car pt1) (cadr pt3)))

This function retrieves the first element (x coordinate) from the list pt1, the second element (y coordinate) from the list pt3, creates a list from these elements and stores the list in the variable pt2.

The following diagram should help you to better understand this.

<img class="lazy" data-src="https://www.afralisp.net/autolisp/tutorials/images/lisp17.gif">

AutoLisp provides other functions to manipulate lists. Let's have a look at some of them.

<h3>Append</h3>
This takes any number of lists and runs them together as one list :

(append '(12.0 15.5) '("M20" "M30))
 
Would return :

(12.0 15.5 "M20" "M30")

<h3>Last</h3>
Will return the last element of a list :

(last '("M20" "M24" "M30"))
 
Would return :

 
("M30")

<h3>Length</h3>
This returns an integer indicating the number of elements in a list :

(length '("M20" "M24" "M30"))
 
Would return :

 
(3)

<h3>Member</h3>
This function searches a list for a specific element. If found it returns the element plus the remainder of the list :

(member 'c '(a b c d e f))
 
Would return :

 
(c d e f)

<h3>Reverse</h3>
Returns a list with it's elements reversed :

(reverse '(a b c d e f))
 
Would return :

 
(f e d c b a)

<h3>Subst</h3>
Searches a list for an old element and returns a copy of the list with the new item substituted in place of every occurrence of the old item :

Syntax : (subst newitem olditem lst)
 
(setq lst '(a b c d e c)))
 
(subst 'f 'c lst)
 
Would return :

 
(a b f d e f)

In part 3 we will have a look at a more advanced List Manipulation Example.

<h2>List Manipulation - Part 3</h2>
It is good practice (and manners) when writing Lisp routines to restore the system environment to the state that your program found it in on completion of your application. Most AutoLisp routines start and end like this :

(defun c:example ()
(setq oldhigh (getvar "Highlight")
oldsnap (getvar "Osmode")
oldblip (getvar "BlipMode")
oldecho (getvar "Cmdecho")
);setq
 
(setvar "Highlight" 0)
(setvar "Osmode" 517)
(setvar "Blipmode" 0)
(setvar "Cmdecho" 0)
 
Programme statements.............
.................................
 
(setvar "Highlight" oldhigh)
(setvar "Osmode" oldsnap)
(setvar "Blipmode "oldblip)
(setvar "Cmdecho" oldecho)
(princ)
);defun
;******************************************************

I must have written statements like this a thousand times in my Lisp routines.

The following example is designed to act as a global routine that first stores, then changes specific system variables. On completion of the routine, the function is then called again and all system variables are returned to their previous settings.

(defun varget ()
 
(setq lis '("HIGHLIGHT" "BLIPMODE" "CMDECHO"
	    "BLIPMODE" "OSMODE"))
;store names of system variables
 
(setq  var (mapcar 'getvar lis))
;get the value of the system variables and
;store them as a list
 
(setq var1 '(0 0 0 0 517))
;store the new values of the system variables
 
(setq no 0)
;set counter to zero
 
(repeat (length lis)
;get the number of variables in the list
;to use as the counter control number
 
	(setvar (nth no lis) (nth no var1))
	;set the variables to their new values
 
	(setq no (1+ no))
	;move up one in the list
 
);repeat
 
(princ);finish quietly
 
);defun
 
;***************************************************************
 
(defun varset ()
 
(setq no 0)
;set counter to zero
 
(repeat (length lis)
;get the number of variables in the list
 
	(setvar (nth no lis) (nth no var))
	;reset the variables to their original values
 
	(setq no (1+ no))
	;move up one in the list
 
);repeat
 
(princ);finish quietly
 
);defun
 
;***************************************************************
 
(princ);load quietly

Our Autolisp routine could now look like this :

(defun c:example ()
 
(varget)
;store system variables and then reset them
 
Programme statements.............
.................................
 
(varset)
;restore system variables
 
(princ)
);defun
;******************************************************

As you can see, we have reduced the size of our routine by a lot and saved ourselves quite a bit of typing. These two routines could both be loaded from our Acad.Lsp file so that they would be available to all of your routines.

If you would like the source coding for this AutoLisp Tutorial then &lt;a href="files/lisp17.zip">Click Here.&lt;/a> Ta Ta for Now&hellip;

<h2>Into the Database</h2>

<h2>Into the Database - Part 1</h2>

Hold onto your hat because we're going to dive straight in here.

Fire up AutoCad and draw a line anywhere on the screen.

Now type this then press Enter:

(setq a (entlast))

Lisp should return something like this:

&lt;Entity name: 2680880&gt;

This is the Entity Name of the Line that you have just drawn.

Now type "Erase" then !a and press Enter twice.

The line should disappear. Type "OOPS" to bring it back.

You have just modified the AutoCAD Database.

Now type this :

(setq b (entget a))

This will retrieve the Entity Data. It should look something like this:

((-1 . &lt;Entity name: 2680880&gt;) (0 . "LINE") (5 . "270")
(100 . "AcDbEntity") (67 . 0) (8 . "0") (100 . "AcDbLine") 
(10 400.378 621.82 0.0) (11 740.737 439.601 0.0) 
(210 0.0 0.0 1.0))

Now type this line:

(setq c (cdr (assoc 10 b)))

Lisp should return:

(400.378 621.82 0.0)

Before you type the next few lines, make sure that your snap is turned off.

Command: circle
3P/2P/TTR/&lt;Center point&gt;: !c
Diameter/&lt;Radius&gt; &lt;10.0&gt;: 20

A circle should be drawn at the end of the line.

This exercise was just to show you the ability of AutoLisp to go behind
your drawing, into the database, and manage graphic and non-graphic
information. This tutorial will show you how entities are stored and
referenced in the database.

It will show you how AutoLisp reveals data about entities and how they can
be modified and manipulated. Say au revoir to your wife and kid's and
let's visit the AutoCad Database. (Star Trek theme music now starts&hellip;)

<h2>Into the Database - Part 2</h2>
When you first start to delve into the AutoCAD database it is, I
admit, quite daunting. But, although entity access and manipulation is
fairly complex, it can be divided into component parts that make it much
easier to understand.

Let's have a look at an AutoLisp routine that can be used, as a sort of
template

which you can apply to numerous, similar applications. Have a close look
at this coding :

(defun C:CHLAYER ( / a1 a2 n index b1 b2 b3 d1 d2)
	
(prompt "\nSelect Entities to be Changed : ")
(setq a1 (ssget))
(prompt "\nPoint to Entity on Target Layer : ")
(setq a2 (entsel))
(setq n (sslength a1))
(setq index 0)
(setq b2 (entget (car a2)))
(setq d2 (assoc 8 b2))
(repeat n
	(setq b1 (entget (ssname a1 index)))
	(setq d1 (assoc 8 b1))
	(setq b3 (subst d2 d1 b1))
	(entmod b3)
	(setq index (1+ index))
);repeat
 (princ)
);defun
(princ)

This routine allows you to select any number of objects and change them
to a different layer. The target layer is choosen by simply pointing to an
object on the desired layer. (To test this routine, you will need to
create a drawing with objects on different layers.) Let's have a look line
by line :

(defun C:CHLAYER ( / a1 a2 n index b1 b2 b3 d1 d2)

Defines the function and declares all variables as local.

(prompt "\nSelect Entities to be Changed : ")

Prompts the user.

(setq a1 (ssget))

Allows the user to select the objects to be changed. The selection set
is assigned to variable 'a1'.

(prompt "\nPoint to Entity on Target Layer : ")

Prompts the user to select the Target Layer.

(setq a2 (entsel))

This is a special type of selection statement that only allows you to

select one entity.

(setq n (sslength a1))

Counts the number of entities in the selection set 'a1' and stores this
number in variable 'n'.

(setq index 0)

Sets the loop control variable 'index' to zero.

(setq b2 (entget (car a2)))

This statement retrieves the entity list from 'a2' and assigns it to 'b2'.

(setq d2 (assoc 8 b2))

This looks for the code 8 in the entity list 'a2', and then assigns the sub list to 'd2'.

(repeat n

This begins the loop that pages through the selection set.

	(setq b1 (entget (ssname a1 index)))

This gets the entity list and assigns it to 'b1'.

	(setq d1 (assoc 8 b1))

Gets the sublist code 8. (The Layer)

	(setq b3 (subst d2 d1 b1))

Substitutes the new 'd2' layer for the old 'd1' layer in the entity list 'a1', and assigns it to the new entity list 'b3'.

	(entmod b3)

Updates the new entity list in the database.

	(setq index (1+ index))

Increases the 'index' variable by 1, priming it for the next loop.

);repeat

Closes the repeat loop.

   (princ)

Finish cleanly.

);defun
Closes the function.

(princ)

Clean Loading.

Listed below is another routine that allows you to globally change the
height of text without affecting other entities. As you will see, the only
difference is, is that we have added a conditional filter to the routine.

(defun C:CHGTEXT ( / a ts n index b1 b2 b c d)

(setq a (ssget))
(setq ts (getreal "\nEnter New Text Height : "))
(setq n (sslength a))
(setq index 0)
(repeat n
	(setq b1 (entget (ssname a index)))
	(setq index (index+ 1))
	(setq b (assoc 0 b1))
	(if (= "TEXT" (cdr b))
		(progn
			(setq c (assoc 40 b1))
			(setq d (cons (car c) ts))
			(setq b2 (subst d c b1))
			(entmod b2)
		);progn
	);if
);repeat
 (princ)
);defun
(princ)

Well I bet your brain hurts after that lot!!!

On the text page we'll have a quick look at Tables.

<h2>Into the Database - Part 3</h2>
The AutoCad Database does not only consist of entities but also
includes several other sections, such as the Tables Section.

Tables store information about entities that are maintained globally
within the drawing. For example, when you insert a block into a drawing,
how does AutoCAD know what the block looks like? The definition of a block
is stored in the Block Table. What happens, for example, if you need to
create a layer? You have to know if the layer already exist because if you
try to create a layer that already exists your program will crash.
Therefore, you would search the Layers Table first to see if the layer
exists.

There are nine (9) Tables that you can access :

Layer Table				"LAYER"
Linetype Table				"LTYPE"
Named View Table			"VIEW"
Text Style Table			"STYLE"
Block Table				"BLOCK"
Named UCS Table				"UCS"
Named Application ID Table		"APPID"
Named Dimension Style Table		"DIMSTYLE"
Vport Configuration Table		"VPORT"

A Table is split into 2 parts: The 'names' of the entries in the Table
and the 'details' of each entry. For example, in the Layers Table, the
name of the entries would be the names of the layers that exist. The
details of an individual layer would be colour, linetype, on, off, frozen,
thawed, locked, unlocked or current.

To access a Table we would use the (tblsearch) function. Let's have a look at an example :

Assume that you want to know whether a layer called STEEL exists in your drawing. First create the layer STEEL then type the following :

(setq t (tblsearch "LAYER" "STEEL"))

The entity list of the layer STEEL should be returned :

((0 . "LAYER") (2 . "STEEL") (70 . 64) (62 . 7) (6 . "CONTINOUS"))

The first part of the entity list is '0', indicating Associative 0.

In this case it's an entry in the "LAYER" Table.

Associative 2 indicates the name of the layer. STEEL in our case.

Associative 70 is the state of the entity. 1 is Frozen, 2 is Frozen on new
paper space view ports and 4 is locked. These numbers are added to 64. In
this case the layer is neither frozen nor locked.

Associative 62 is the colour of the layer. Ours is white which is colour
number 7. If the colour number is a negative number then the layer is off.

Associative 6 is the linetype of the layer, in this case,
"CONTINUOUS".

If the (tblsearch) had not found the layer then it would have returned
'nil' and you would know that the layer did not exist.

Sometimes you don't know the name of a layer or a block but you need a
list of them. This is when the (tblnext) function comes into play.
Let's assume that 4 layers exist in your drawing. The layer names are
MECH, STEEL, PIPE and TXT. Enter the following :

(tblnext "Layer")

AutoLISP should return something like this :

((0 . "LAYER") (2 . "PIPE") (70 . 0) (62 . 7) (6 . "CONTINUOUS"))

Repeat the same command four additional times. You will get a new entity list for each of the layers. The last time you type the command AutoLISP will return 'nil' because there are no more additional layers.

Let's have a look at this in action. We are going to design a dialogue
box that displays a drop down list of all the available layers in a
specific drawing. The user can then choose any layer which can then be
used within his routine.

<img class="lazy" data-src="https://www.afralisp.net/autolisp/tutorials/images/lisp18.gif">

The Dialogue Coding looks like this :

getlay  : dialog {				//dialog name
 
label = "Get Layer" ;			//give it a label
 
 
: popup_list {				//define list box
 
key = "sel1";				//give it a name
 
value = "0";				//initial value
 
}					//end list
 
 
ok_cancel ;				//predifined OK/Cancel
 
   					
}						//end dialog
 

Now the AutoLisp Coding :

(defun c:getlay ( / NAMES SIZ1)
;define funcion
 
(setvar "cmdecho" 0)
;switch off command echo
 
 	(setq siz1 "0")
;initiliase variable
 
(setq userclick T)
;set flag
 
(setq f 1)
;rewind pointer
 
(while
;start while loop
 
 	  (setq t1 (tblnext "Layer" f))
  ;get the next layer
 
  (setq f nil)
  ;reset pointer
 
  (setq b (cdr (assoc 2 t1)))
  ;get the layer name
 
    (if (/= b "DEFPOINTS")
    ;if name is not equal to DEFPOINTS
 
 (setq NAMES (append NAMES (list b)))
 ;Add the layer name to the list
 
    );if
 
);while
 
 
(setq dcl_id (load_dialog "getlay.dcl"))
;load dialogue
 
(if (not (new_dialog "getlay" dcl_id)
;check for errors
 
);not
 
     (exit)
     ;if problem exit
 
);if

(set_tile "sel1" "0")
;initilise list box
 
(start_list "sel1")
;start the list
 
(mapcar 'add_list NAMES)
;add the layer names
 
(end_list)
;end the list
 
  (action_tile
 
  "cancel"	
 
  "(done_dialog) (setq userclick nil)"
 
  );action_tile
  ;if cancel set flag to nil
 
(action_tile
 
  "accept"	
 
  (strcat	
 
"(progn 
 
(setq SIZ1 (get_tile \"sel1\"))"	
 
 " (done_dialog)(setq userclick T))"	
 
  );strcat
 
);action tile
;if OK get the layer selected
 
(start_dialog)	
 
(unload_dialog dcl_id)	
 
 (if userclick	
 ;if flag true
 
  (progn
 
   (setq SIZ1 (nth (atoi SIZ1) NAMES))
   ;get the name of the layer from the list
 
   (alert (strcat "\nYou Selected Layer  " SIZ1))
   ;display the name
 
  );end progn
 
 );end if
 
(princ)
 
);defun C:getlay
 
(princ)

If you would like the source coding for this AutoLisp Routine then simply &lt;a href="files/lisp18.zip">Click Here.&lt;/a> Cheers and keep well&hellip;

<h2>Selection Sets</h2>

When you work with AutoCAD, you very seldom work with only one entity
or, for that matter, one type of entity. To be able to work efficiently
with a group, or selection set, of entities, you need to be able to place
them in one place and work on them as a group. You might also want to
filter the entities so that only a certain type is within the group.

The AutoLisp function that enables you to do this is the &lt;em>(ssget)&lt;/em>
function.

(setq sel1 (ssget))

This function allows you to select as many entities as you like using any
selection method, such as Window, Crossing, Fence, etc.

You can also include a selection set filter within the function.

(setq sel1 (ssget "x"))

The "x" following the &lt;em>(ssget)&lt;/em> is the most basic of
filters. This filter selects ALL. This is quite sufficient in some
circumstances but you can filter the entities further by following the
"x" with a list of associative codes. For example :

(setq sel1 (ssget "x" '((8 . "STEEL"))))

This expression would create a selection set containing only entities that
are on the STEEL layer. (Associative code 8 refers to the Layer.)

You can use more than one associative code if you desire :

(setq sel1 (ssget "x" '((0 . "CIRCLE")(8 . "STEEL"))))

The above example would create a selection set of all CIRCLES on the
Layer STEEL.

If you don't want to search the entire drawing for a selection set, but
would rather use a select by Window or Crossing, then just omit the
"x" option.

(setq sel1 (ssget '((0 . "CIRCLE")(8 . "STEEL"))))

This example permits the user to select entities using any selection method he prefers but, will only create a selection set of CIRCLES on Layer STEEL.

Try this next :

(setq sel1 (ssget "w" "\nSelect Objects by Window: "))

Doesn't work, does it?

You cannot use prompts within the &lt;i>(ssget)&lt;/i> function. But, you can
use other AutoCad functions to feed the required information to the &lt;em>(ssget)&lt;/em>
function.

(prompt "\nSelect Objects by Window")
(setq p1 (getpoint "\nFirst Corner: "))
(setq p2 (getpoint p1 "\nSecond Corner: "))
(setq sel1 (ssget "w" p1 p2))

You can also use other selection options with (ssget)

(setq sel1 (ssget "P"))

This will create a selection set of all "Previous" entities.

Other options available are "L" for "Last" and
"I" for "Implied".

You can also use logical filters when creating selection sets.

Have a look at a previous example :

(setq sel1 (ssget '((0 . "CIRCLE")(8 . "STEEL"))))

What we are saying here is :

"Create a selection set of all the CIRCLES from the entities selected AND they must be on Layer "STEEL".
AND is the default logical filter when you string associative codes
together.

You can also use the OR logical filter, but to do this you must inform AutoLisp first. To do this you use a special type of associative code, the -4.

(setq sel1 (ssget '((-4 . "&lt;OR")(8 . "STEEL")(8 . "PIPE")(-4 . "OR&gt;"))))

This would create a selection set of all entities on Layer STEEL
"OR" on Layer PIPE.

As well as logical filters, you can also have relation filters :

(setq sel1 (ssget '(0 . "CIRCLE")(-4 . "&gt;=")(40 . 2.0)))

This would create a selection set of all CIRCLES with a RADIUS (group 40) of greater or equal to 2.0.

All of these different types of filters can be nested.

You can also Add and Delete entities from selection sets. Three guesses what these function names are? You were right first time, &lt;em>(ssadd)&lt;/em> and &lt;em>(ssdel).&lt;/em>

(setq sel1 (ssget))
;create the first selection set
 
(setq ent (car (entsel))
;select an entity and use (car (ensel))
; to retrieve the entity name
 
(setq sel1 (ssadd ent sel1))
;add the entity to the selection set

To delete an entity is exactly the same except for the last line :

(setq sel1 (ssdel ent sel1))

But what would you do if you wanted to add two selection sets together?
The following explains how to create a "Union" between 2
selection sets :

(setq ct 0)
;set counter to zero
 
(repeat (sslength sel2)
;get the number of items in selection set 2
;and loop that number of times
 
(ssadd (ssname sel2 ct) sel1)
;get the name of the entity from selection set 2
;by using the counter index number and add it to
;selection set 1
 
(setq ct (1+ ct))
;increment the counter by 1

);end repeat

Here's an example of a simple routine that will count the number of blocks
contained within a drawing :

(defun c:bcount ( / p1 b a n)
 
(setq p1 (getstring "\Name of Block : "))
;get the name of the block
 
(setq b (cons 2 p1))
;construct a dotted pair - code 2 is for blocks
 
(setq a (ssget "x" (list b)))
;filter for the block name
 
(if (/= a nil)
;check if there are any blocks of that name
 
   (progn
   ;if there is&hellip;
 
	(setq n (sslength a))
	;count the number of blocks
 
	(alert (strcat "\nThere are " (itoa n) " in the DataBase"))
	;display the result
 
   );progn
   ;if there are no blocks
 
	(alert "\nThere are none in the DataBase")
	;inform the user
 
);if
 
 (princ)
 
);defun
 
(princ)

Well that's about it with selection sets. Just remember that you can save yourself an awful lot of work by using selection sets with filters. Filter at the source rather than programmatically trying to filter out the undesirable entities at a later stage. Ta Ta for now&hellip;

<h2>Selection Set Filters</h2>
by Jarvis Fosdick

Very often I will want to select all items on a layer and move them off to the right hand side of my workspace, but what happens if I want to select two layers? There are always several ways to do things. I have found that using the &lt;strong>filter&lt;/strong> command is somewhat cumbersome. Another way to use these filters is from the ssget function.

Command: copy

Select objects:
(ssget '((8 . "mylayer") (0 . "circle") ))

  
This will only allow you to select circles on mylayer. If you wanted to select all the circles on layers mylayer and mylayer2 it would look as follows :

Command: copy

Select objects:
(ssget '((0 . circle) (-4 . "&lt;or") (8 . "mylayer") (8 . "mylayer2") (-4 . "or&gt;")))

The –4 dxf group code &lt;code>(-4 . "&lt;or")&lt;/code> begins the conditional operator. The less than or open alligator symbol &lt;code>&lt;&lt;/code> tells AutoCad to evaluate the conditional until it finds a closing alligator &lt;code>&gt;&lt;/code>. We use &lt;code>(-4 . "or&gt;")&lt;/code> to end the conditional.

Conditionals can be used together :

(ssget '(
 (-4 . "&lt;or") 
 (8 . "notes") (0 . "circle")
 (-4 . "&lt;and")
 (8 . "s-boundary")(0 . "line")
 (-4 . "and&gt;")
 (-4 . "or&gt;")
))

This would select only those entities that are on the layer notes or are circles and entities that are both lines on the layer s-boundary.

<h2>The Conditional Operators</h2>
Conditional operators -- AND, OR, XOR, and NOT -- must be paired and balanced correctly in the filter list. The number of operands you can enclose depends on the operation. Here is a list of the Conditionals or "selection set filters" you can use :

<h3>AND</h3>
&lt;code>"&lt;AND"&lt;/code> (One or more operands) &lt;code>"AND&gt;"&lt;/code>

(ssget '((-4 . "&lt;and") (0 . "line") (8 . "text") (62 . 3) (-4 . "and&gt;") ))
 Selects entities that match all conditions.

<h3>OR</h3>    
&lt;code>"&lt;OR"&lt;/code> (One or more operands) &lt;code>"OR&gt;"&lt;/code>

(ssget '((-4 . "&lt;or") (0 . "line") (8 . "text") (62 . 3) (-4 . "or&gt;") ))
Selects entities that match any of the conditions.

  
<h3>XOR</h3>
&lt;code>"&lt;XOR"&lt;/code> (Two operands) &lt;code>quot;XOR&gt;"&lt;/code>

(ssget '((-4 . "&lt;xor") (8 . "text") (62 . 3) (-4 . "xor&gt;") ))
Selects entities that match one or the other condition.

  
<h3>NOT</h3>
&lt;code>"&lt;NOT"&lt;/code> (One operand) &lt;code>"NOT&gt;"&lt;/code>

(ssget '((-4 . "&lt;not") (0 . "line") (-4 . "not&gt;") ))
Selects entities that do not match one condition.

The XOR conditional works as an exclusive OR operator. For instance, using OR we may select entities that are text and are either on the layer notes or have the color 3 or both.&lt;span style="mso-spacerun:
yes">

(ssget '((0 . "text") (-4 . "&lt;or") (8. "notes) (62 . 3) (-4 . "or&gt;") ))

However, using XOR we may select only entities that are text and on layer notes or entities that are text and the color 3. We cannot select entities that are text on the layer notes and the color 3.

(ssget '((0 . "text") (-4 . "&lt;xor") (8. "notes) (62 . 3) (-4 . "xor&gt;") ))

If we wish to select text that is both on the layer notes and the color 3 using XOR we must group these properties with another conditional.

(ssget '(
 (0 . "text")
 (-4 . "&lt;xor") 
 (-4 . "&lt;and") (8 . "notes") (62 . 3) (-4 . "and&gt;") 
 (-4 . "xor&gt;") 
))

We can nest all sorts of conditionals into a selection set filter :

(ssget '(
 (-4 . "&lt;xor") (8 . "mylayer") 
 (-4 . "&lt;or") (0 . "text") 
 (-4 . "&lt;xor") (8 . "notes") 
 (-4 . "&lt;and") (62 . 2) (0 . "line") (-4 . "and&gt;") 
 (-4 . "xor&gt;") 
 (-4 . "or&gt;") 
 (-4 . "xor&gt;")
))
    

This is probably not practical, but it will work. See if you can figure out what it would select. There is not really all that much to these conditionals and they are very handy. I use them mostly at the command prompt to copy several layers at once, which tends to be easier then using the filter dialog box. The following lisp routine will let you copy all the objects from two layers.

(defun c:layer_copy ( / laa la p1 p2 ss )
(princ "\n Choose an object on desired layer: ")
 (setq laa (assoc 8 (entget (car (entsel)))))
 (princ "\n Choose another object a different desired layer: ")
 (setq la (assoc 8 (entget (car (entsel)))))
 (setq ss (ssget "x" (list (cons -4 "&lt;or") laa la (cons -4 "or&gt;") )))
 (command "copy" ss )
 );defun
(princ)

<h2>Working with Layers and Styles</h2>

I've had a lot of queries from people asking me how to create layers, change layers, change text styles, etc. using AutoLisp. This tutorial will take you through the steps of doing just that.

Before you do anything in regards to layers and styles, it's always best to retrieve the current layer, or text style, so that you can restore it. To retrieve the current layer, use the following coding :

(setq oldlayer (getvar "CLAYER"))

This will retrieve the name of the current layer and store it in variable "oldlayer". To restore the previous layer is just as simple:

(setvar "CLAYER" oldlayer)

This will set the current layer to the previous layer name stored in variable "oldlayer".

You would use exactly the same syntax for retrieving and restoring the name of the current Text Style :

(setq oldstyle (getvar "TEXTSTYLE")) (setvar "TEXTSTYLE" oldstyle)

You might think that this would be a good way of changing layers and style. The problem here, is that if the layer name you want to change to does not exist your program will crash.

You can use the "tblsearch" function to test if a layer or style exists :

(tblsearch "LAYER" "TESTLAYER")
(tblsearch "STYLE" "MYSTYLE")

If Layer "TESTLAYER" or Style "MYSTYLE" exists in your drawing, tblsearch will return "True", otherwise it will return "Nil". 

Here's an example that tests if a layer exist, and if it does, sets the current layer to that layer :

(setq oldlayer (getvar "clayer"))
;retrieve the current layer
 
(setq flag (tblsearch "LAYER" "NEWLAYER"))
;find out if the layer exists

(if flag
;if the layer exists
 
	(setvar "CLAYER" "NEWLAYER")
	;set current layer to "NEWLAYER"
 
);end if

This though, is quite a lot of coding just to check if a layer exists. A better way, that applies to both Layers and Text Styles is to use the command function :

(command "Layer" "M" "NEWLAYER" ")
(command "Style" "Italict" "Italict.shx" " " " " " ")

Both of these examples will change the layer or style, but will also create a new layer or text style if the layer or style does not exist within the drawing. (The style .shx file must exist and be within the AutoCad search path.)

I've also been asked that when I want to place text, dimensions, etc. into my drawing, how do I ensure that they are drawn on a particular layer? Now, you could modify the AutoCad Menu to achieve this, but I prefer to create a partial menu with the modified macros in place.

The way to go about this is to simply prefix the menu macro with one that changes to the specific layer :

[Dtext]^C^C^CLayer;M;5;;_Dtext

This ensures that I am on Layer 5 when I add text to a drawing.

Well, I hope this has helped you. Keep well&hellip;

<h2>Polylines and Blocks</h2>

Polylines and Blocks! Come back&hellip; Don't run away&hellip;

Honestly, they are a lot easier to deal with than you think. I know that they are called "complex entities", but the only difference between them and other entities is that we just have to dig a bit deeper to get to what we want. In fact, once we get there I'll show you a couple of things that you swear is magic. So bear with me, take your time, and hang on for a ride on the magic carpet&hellip;

<h2>Polylines</h2>
The LwPolyline (Light Weight Polyline) entity, or "optimized polyline," was introduced with Release 14. A lwpolyline is defined in the drawing database as a single graphic entity. This is different than a standard polyline, which is defined as a group of subentities. Lwpolylines display faster and consume less disk space and RAM.

In Release 14 and above, 3D polylines are always created as standard polyline entities. 2D polylines are created as lwpolyline entities by default  unless they have been curved or fitted with the PEDIT command. When a drawing from a previous release is opened in Release 14 and above, all 2D polylines convert to lwpolylines automatically unless they have been curved or fitted or contain xdata.

We will have a look at the R13 and below Polyline first. To start, draw 3 joined polylines. (3DPoly if you are using R14 and above). Then type this :

Command: (setq e (entget (car (entsel))))

AutoLisp should return something like this :

Select object: ((-1 . &lt;Entity name: 26508d8&gt;) (0 . "POLYLINE") (5 . "27B")
(100 . "AcDbEntity") (67 . 0) (8 . "0") (100 . "AcDb3dPolyline") (66 . 1)
(10 0.0 0.0 0.0) (70 . 8) (40 . 0.0) (41 . 0.0) (210 0.0 0.0 1.0) (71 . 0)
(72 . 0) (73 . 0) (74 . 0) (75 . 0))

Hey, wait a minute!&hellip; AutoLisp has returned the entity list, and I can see that it's a Polyline, but there are no co-ordinates, and where does AutoLisp get the co-ordinates for all the vertices?

As I said earlier, we need to dig a little bit deeper to get the information we require. This is where the &lt;code>(entnext)&lt;/code> function comes into play.

Now type the following 5 code segments :

Command: (setq e1 (entget (entnext (cdr (car e)))))
 ((-1 . &lt;Entity name: 26508e0&gt;) (0 . "VERTEX") (5 . "27C") (100 . "AcDbEntity") 
(67 . 0) (8 . "0") (100 . "AcDbVertex") (100 . "AcDb3dPolylineVertex")
(10 391.774 521.633 0.0) (40 . 0.0) (41 . 0.0) (42 . 0.0) (70 . 32)
(50 . 0.0) (71 . 0) (72 . 0) (73 . 0) (74 . 0))
 
Command: (setq e2 (entget (entnext (cdr (car e1)))))
 ((-1 . &lt;Entity name: 26508e8&gt;) (0 . "VERTEX") (5 . "27D") (100 . "AcDbEntity") 
(67 . 0) (8 . "0") (100 . "AcDbVertex") (100 . "AcDb3dPolylineVertex")
(10 758.971 383.418 0.0) (40 . 0.0) (41 . 0.0) (42 . 0.0) (70 . 32)
(50 . 0.0) (71 . 0) (72 . 0) (73 . 0) (74 . 0))
 
Command: (setq e3 (entget (entnext (cdr (car e2)))))
 ((-1 . &lt;Entity name: 26508f0&gt;) (0 . "VERTEX") (5 . "27E") (100 . "AcDbEntity") 
(67 . 0) (8 . "0") (100 . "AcDbVertex") (100 . "AcDb3dPolylineVertex")
(10 257.549 377.344 0.0) (40 . 0.0) (41 . 0.0) (42 . 0.0) (70 . 32)
(50 . 0.0) (71 . 0) (72 . 0) (73 . 0) (74 . 0))
 
Command: (setq e4 (entget (entnext (cdr (car e3)))))
 ((-1 . &lt;Entity name: 26508f8&gt;) (0 . "VERTEX") (5 . "27F") (100 . "AcDbEntity") 
(67 . 0) (8 . "0") (100 . "AcDbVertex") (100 . "AcDb3dPolylineVertex")
(10 391.774 521.633 0.0) (40 . 0.0) (41 . 0.0) (42 . 0.0) (70 . 32)
(50 . 0.0) (71 . 0) (72 . 0) (73 . 0) (74 . 0))
 
Command: (setq e5 (entget (entnext (cdr (car e4)))))
 ((-1 . &lt;Entity name: 2650900&gt;) (0 . "SEQEND") (5 . "280") (100 . "AcDbEntity") 
(67 . 0) (8 . "0") (-2 . &lt;Entity name: 26508d8&gt;))

The &lt;code>(cdr (car e))&lt;/code> returns the entity name of entity list e. Each code segment then uses the &lt;code>(entnext entity name)&lt;/code> of the entity that precedes it.

Take note of the entity type of each variable :

e	(0 . "POLYLINE")
e1	(0 . "VERTEX")
e2	(0 . "VERTEX")
e3	(0 . "VERTEX")
e4	(0 . "VERTEX")
e5	(0 . "SEQEND")

Do you see that a 3 line Polyline consists of a master or, parent list, 4 vertex and an end-of sequence (&lt;code>"SEQEND"&lt;/code>) list.

To extract the entitity list for each vertex is therefore, quite easy. We just need to loop through the sequence of vertices until we reach the SEQEND list.

Here's an example of a function that will print the coordinates for each vertex of a Polyline :

(defun c:coord ( / e r)
 
(setq e (entget (car (entsel))))
;get the parent entity list
 
(setq r 1)
;set loop control number to 1
 
(while r
;while loop control is not nil, carry on looping
 
   (setq e (entget (entnext (cdr (car e)))))
   ;get the vertex entity list
 
   (if (/= (cdr (assoc 0 e)) "SEQEND")
   ;if it is not "end-of-sequence
 
	(progn
	;do the following
 
	  (terpri)
	  ;new line
 
	  (princ (cdr (assoc 10 e)))
	  ;print the co-ordinates
	  
	);progn
 
  (setq r nil)
	;if end of sequence, stop looping
 
   );if
 
);while
 
(princ)
 
);defun
 
(princ)

There is a quicker way of retrieving the entity list of a Polyline vertex. The function &lt;code>(nentsel)&lt;/code> let's you select an entity and returns the name of the entity even if it belongs to a polyline. Try it for yourself. Type this, then select any vertex of a polyline.

(setq e (entget (car (nentsel))))

AutoLisp should return something like this :

Select object: ((-1 . &lt;Entity name: 2100880&gt;) (0 . "POLYLINE") (5 . "270")
(100 . "AcDbEntity") (67 . 0) (8 . "0") (100 . "AcDb3dPolyline") (66 . 1)
(10 0.0 0.0 0.0) (70 . 9) (40 . 0.0) (41 . 0.0) (210 0.0 0.0 1.0) (71 . 0)
(72 . 0) (73 . 0) (74 . 0) (75 . 0))

How's that? Straight to the entity list!

Now, while we're here, let's have a quick look at blocks&hellip;

<h2>Blocks</h2>
Create a block consisting of a couple of lines and a circle with a radius of 20. Now type this :

(setq e (entget (car (nentsel))))

Now pick the circle. AutoLisp should return something like this:

Select object: ((-1 . &lt;Entity name: 2100910&gt;) (0 . "CIRCLE") (5 . "282")
(100 . "AcDbEntity") (67 . 0) (8 . "0") (100 . "AcDbCircle") (10 0.0 -1.51849 0.0)
(40 . 20.0) (210 0.0 0.0 1.0))

Hey, hang about. It's returned the entity list of the circle even though it's part of a block! Now type the following:

(setq d (assoc 40 e))
(setq e1 (subst '(40 . 50.0) d e))
(entmod e1)

Now REGEN the drawing. Did you noticed what happened? The radius of the circle has change even though it's part of a block. Not only that, it has also redefined the block definition. In other words, every block in the drawing with the same name would have changed. I told you it was magic&hellip;

Let's change the layer of the circle:

(setq d (assoc 8 e1))
(setq e2 (subst '(8 . "STEEL") d e1))
(entmod e2)

Again, REGEN the drawing. The circle has changed to Layer "STEEL". Now do you see what I mean by magic. I bet you never thought you would be able to modify a block without exploding it. Well you can now&hellip;

<h2>LwPolylines</h2>
As we mentioned earlier, LwPolylines were introduced with AutoCAD Release 14. They differ in that they are defined as a single entity. Let's have a look at a LwPolylines entity list. Draw a LwPolyline and enter this:

(setq e (entget (car (entsel))))

AutoLisp should return something like this:

Select object: ((-1 . &lt;Entity name: 2100938&gt;) (0 . "LWPOLYLINE") (5 . "287") 
(100 . "AcDbEntity") (67 . 0) (8 . "0") (100 . "AcDbPolyline") (90 . 3) (70 . 1)
(43 . 0.0) (38 . 0.0) (39 . 0.0) (10 597.908 661.3) (40 . 0.0) (41 . 0.0) 
(42 . 0.0) (10 1179.86 476.045) (40 . 0.0) (41 . 0.0) (42 . 0.0) (10 479.39 397.084)
(40 . 0.0) (41 . 0.0) (42 . 0.0) (210 0.0 0.0 1.0))

As you can see, there is no need to use &lt;code>(entnext)&lt;/code> to step through the vertex entities as the group 10 entity code is already part of the parent list. But, we do have another problem!! There are numerous group 10 entity codes. (As well as Group 40 - Start Width; Group 41 - End Width and Group 42 - Bulge) To extract these, we need to first, find the length of the list. Then we must loop through each code entity in the list searching for a group 10. Once found, we can easily extract the vertex co-ordinates. The following function does just that:

(defun c:lwcoord (/ e len n e1)
 
(setq e (entget (car (entsel))))
;get the entity list
 
(setq len (length e))
;get the length of the list
 
(setq n 0)
;set counter to zero
 
(repeat len
;repeat for the length of the entity list
 
  (setq e1 (car (nth n e)))
  ;get each item in the entity list
  ;and strip the entity code number
 
  (if (= e1 10)
  ;check for code 10 (vertex)
 
    (progn
    ;if it's group 10 do the following
 
	(terpri)
	  ;new line
 
	  (princ (cdr (nth n e)))
	  ;print the co-ordinates
	  
    );progn
 
  );if
  (setq n (1+ n))
  ;increment the counter
 
);repeat
 
(princ)
);defun
(princ)

Well, that's it concerning Polylines and Blocks. I told you it was easy! Remember, I've only scratched the surface with the things that you can do once you dig into entity lists, especially with complex entities. One last thing. Want to create your own entity? Normally, in AutoLISP you would draw a line like this:

(command "Line" pt1 pt2 ")

Now, create you own line by doing this:

(setq e '((0 . "LINE")(8 . "0")(10  50.0 50.0 0.0)(11 100.0 100.0 0.0)))
(entmake e)

Makes you think, doesn't it?

Cheers for now&hellip;

<h2>Extended Entity Data - Part 1</h2>

<h2>What is Extended Entity Data?</h2>
For years AutoCAD has had the ability to store user information within a drawing by utilising attributes. But, attributes have got their limitations. They've got to be a block, or part of a block. They can be difficult to use. They can be exploded or modified by the user and they can only hold certain types of information.

Extended Entity Data though, allows you to attach up to 16K of information to each and every entity in the drawing. You can also keep it totally separate from other information and, because it uses a uniquely registered name, can be kept relatively safe from being overwritten. You can also store lot's of different types of information in Extented Entity Data.

Extended Entity Data is attached to an entity as an associated list with a code number of -3. The simplest form of an Xdata Associative list would look something like this :

((-3 ("AFRALISP" (1000 . "Kenny is great"))))

Firstly, let's look at some of the different types of xdata that you can attach to an entity :

&lt;table class="data">
&lt;tr>&lt;th>Data Type&lt;/th>&lt;th>Code&lt;/th>&lt;th>Description&lt;/th>&lt;/tr>
 &lt;tr class="row1">
&lt;td>String&lt;/td>
&lt;td>1000&lt;/td>
&lt;td>A string of up to 255 characters.&lt;/td>
 &lt;/tr>
 &lt;tr>
&lt;td>Application Name&lt;/td>
&lt;td>1001&lt;/td>
&lt;td>An Application Name.&lt;/td>
 &lt;/tr>
 &lt;tr class="row1">
&lt;td>Layer Name&lt;/td>
&lt;td>1003&lt;/td>
&lt;td>The name of a Layer.&lt;/td>
 &lt;/tr>
 &lt;tr>
&lt;td>DataBase Handle&lt;/td>
&lt;td>1005&lt;/td>
&lt;td>The handle of an entity.&lt;/td>
 &lt;/tr>
 &lt;tr class="row1">
&lt;td>3D Point&lt;/td>
&lt;td>1010&lt;/td>
&lt;td>A 3D Coordinate value.&lt;/td>
 &lt;/tr>
 &lt;tr>
&lt;td>Real&lt;/td>
&lt;td>1040&lt;/td>
&lt;td>A real value.&lt;/td>
 &lt;/tr>
 &lt;tr class="row1">
&lt;td>Integer&lt;/td>
&lt;td>1070&lt;/td>
&lt;td>A 16 bit integer (signed or unsigned).&lt;/td>
 &lt;/tr>
 &lt;tr>
&lt;td>Long&lt;/td>
&lt;td>1071&lt;/td>
&lt;td>A 32 bit signed (long) integer.&lt;/td>
 &lt;/tr>
 &lt;tr class="row1">
&lt;td>Control String&lt;/td>
&lt;td>1002&lt;/td>
&lt;td>A control code to set off nested list.&lt;/td>
 &lt;/tr>
 &lt;tr>
&lt;td>World Space Position&lt;/td>
&lt;td>1011&lt;/td>
&lt;td>A 3D coordinate point that is moved, scaled rotated, streched and mirrored along with the entity.&lt;/td>
 &lt;/tr>
 &lt;tr class="row1">
&lt;td>World Space Displacement&lt;/td>
&lt;td>1012&lt;/td>
&lt;td>A 3D coordinate point that is scaled, rotated or mirrored along with the entity. It cannot be stretched.&lt;/td>
 &lt;/tr>
 &lt;tr>
&lt;td>World Space Direction&lt;/td>
&lt;td>1013&lt;/td>
&lt;td>A 3D coordinate point that is rotated or mirrored along with the entity. It cannot be scaled, streched or moved.&lt;/td>
 &lt;/tr>
 &lt;tr class="row1">
&lt;td>Distance&lt;/td>
&lt;td>1041&lt;/td>
&lt;td>A real value that is scaled along with the entity. Used for distance.&lt;/td>
 &lt;/tr>
 &lt;tr>
&lt;td>Scale Factor&lt;/td>
&lt;td>1042&lt;/td>
&lt;td>A real value that is scaled along with the entity. Used as a scale factor.&lt;/td>
 &lt;/tr>
&lt;/table>

Another important thing to remember about Xdata is that you can have more than one of the same associative code.

Let's attach some xdata to an entity in a drawing. Draw a line then type this:

(regapp "AFRALISP")

AutoLisp should return :

"AFRALISP"

You have now registered your external entity data name. This name is a unique identifier to your own extended entity data. Next we need to get the entity data list of the entity that we want to add exdata to. Type this :

(setq oldlist (entget (car (entsel))))

AutoLisp should return something like this :

Select object: ((-1 . &lt;Entity name: 2100888&gt;) (0 . "LINE") (5 . "271")
(100 . "AcDbEntity") (67 . 0) (8 . "0") (100 . "AcDbLine") (10 336.561 591.45 0.0)
(11 672.362 497.304 0.0) (210 0.0 0.0 1.0))

Now, let's create the exdata that we want to add to the entity :

(setq thedata '((-3 ("AFRALISP" (1000 . "Kenny is handsome") (1000 . "And intelligent")))))

Append it to the entity data list :

(setq newlist (append oldlist thedata))

Now, update the entity :

(entmod newlist)

We have now attached the xdata to the entity. To retrieve it we would type this :

(setq elist (entget (car (entsel)) '("AFRALISP")))

This would return the modified entity list. It should look something like this :

Select object: ((-1 . &lt;Entity name: 2100888&gt;) (0 . "LINE") (5 . "271")
(100 . "AcDbEntity") (67 . 0) (8 . "0") (100 . "AcDbLine") (10 336.561 591.45 0.0)
(11 672.362 497.304 0.0) (210 0.0 0.0 1.0) (-3 ("AFRALISP" (1000 . "Kenny is handsome")
(1000 . "And intelligent"))))

To retrieve the xdata we would type this :

(setq exlist (assoc -3 elist))

This gets the xdata list from the entity list.

(-3 ("AFRALISP" (1000 . "Kenny is handsome") (1000 . "And intelligent")))

To retrieve the xdata itself we would type this :

(setq thexdata (car (cdr exlist)))

Now, we should have this :

("AFRALISP" (1000 . "Kenny is handsome") (1000 . "And intelligent"))

We now have an ordinary list. Because we created the xdata list, and we know in what order we created it, it's very simple to retrieve each individual part :

(setq data1 (cdr (nth 1 thexdata)))
(setq data2 (cdr (nth 2 thexdata)))

This should return :

"Kenny is handsome"
"And intelligent"

This, of course, is a factual statement.

In &lt;a href="/autolisp/tutorials/extended-entity-data-part-2.php">Part 2&lt;/a> we will have a look at a practical example using Xdata. Come on, don't be scared&hellip;

<h2>Extended Entity Data - Part 2</h2>

<h2>Using Extended Entity Data</h2>
We are now going to write an application that attaches, as Extended Entity Data, bolt details to holes in a drawing. The details we will store will be Bolt Size, Bolt Length and Bolt Grade. We will design a dialogue box to enter this data. If no data has been attached, the application will firstly attach some default data and then allow you to edit this. If data has been already attached, it will display this data and then allow you to change it, if you so wish.

<img src="https://www.afralisp.net/autolisp/tutorials/images/lisp21.gif">

Let's look at the Dialogue Box Coding first :

exbolt : dialog {				//dialog name
 
label = "Bolt Details";			//give it a label
 
: boxed_row {				//start boxed row
 
label = "Choose Size and Length";	//give it a label

: popup_list {				//define list box
 
key = "sel1";				//give it a name
 
}					//end list
 
: popup_list {				//define list box
 
key = "sel2";				//give it a name
 
}					//end list
 
}					//end boxed row
 
: boxed_radio_row {			//start boxed radio row
 
label = "Choose Grade";			//give it a label
 
: radio_button {			//define radio button
 
key = "rb1";				//give it a name
 
label = "4,6";				//give it a label
 
} 					//end radio button
 
: radio_button {			//define radio button
 
key = "rb2";				//give it a name
 
label = "8,8";				//give it a label
 
} 					//end radio button
: radio_button {			//define radio button
 
key = "rb3";				//give it a name
 
label = "H.S.F.G.";			//give it a label
 
} 					//end radio button
 
}					//end boxed radio row
 
 
ok_cancel ;				//predifined OK/Cancel
 
   					
}						//end dialog

And now the AutoLisp code:

(defun c:exbolt ( / )
;define function
 
(setvar "cmdecho" 0)
;switch off command echo
 
(prompt "\nSelect the Hole to Add/Modify Xdata : ")
;prompt the user

(setq e (entget (car (entsel)) '("AFRALISP")))
;get the associative code list
 
(setq e1 (assoc -3 e))
;get the xdata
 
(if (not e1)
;if there is no exdata
 
(progn
;do the following
 
(if (not (tblsearch "APPID" "AFRALISP"))
;check if the application has been registered
	
	(regapp "AFRALISP")
	;if not, register it
 
);if
 
	(setq e1 '((-3 ("AFRALISP"
		  (1000 . "3")
		  (1000 . "3")
	 	  (1000 . "8,8")
	))))
	;create a default xdata list
	
	(setq e (append e e1))
	;append to to the main list
 
	(entmod e)
	;modify the entity
	
);progn

);if

(setq e2 (assoc -3 e))
;get the code -3 list
 
(setq e3 (car (cdr e2)))
;get the exdata list

(setq SIZ (cdr (nth 1 e3)))
;get the bolt size index number
 
(setq SIZ1 (cdr (nth 2 e3)))
;get the bolt length index number
 
(setq gr (cdr (nth 3 e3)))
;get the bolt grade
 
(setq userclick T)
;set flag
 
(setq NAMES '("M6" "M8" "M10" "M12" "M16" "M20" "M24" "M30" "M36"))
;create list of bolt sizes

 
(setq LEN '("10" "15" "20" "25" "30" "35" "40" "45" "50" "55" "60"))
;create list of bolt lengths

(setq dcl_id (load_dialog "exbolt.dcl"))
;load dialogue
 
(if (not (new_dialog "exbolt" dcl_id)
;check for errors
 
);not
 
     (exit)
     ;if problem exit
 
);if

(set_tile "sel1" SIZ)
;initilise list box
 
(set_tile "sel2" SIZ1)
;initilise list box
 
(start_list "sel1")
;start the list
 
(mapcar 'add_list NAMES)
;add the bolt size
 
(end_list)
;end the list
 
(start_list "sel2")
;start the list
 
(mapcar 'add_list LEN)
;add the lengths
 
(end_list)
;end the list
 
(cond
;on condition
 
((= gr "4,6") (set_tile "rb1" "1"))
;if GR 4,6 switch on radio button rb1
 
((= gr "8,8") (set_tile "rb2" "1"))
;if GR 8,8 switch on radio button rb2
 
((= gr "HSFG") (set_tile "rb3" "1"))
;if GR HSFG switch on radio button rb3
 
);end cond
 
(action_tile "rb1"
;if radio button rb1 selected
 
  	"(setq gr \"4,6\")"
;set grade of bolt
 
);action_tile
 
(action_tile "rb2"
;if radio button rb2 selected
 
  	"(setq gr \"8,8\")"
;set grade of bolt
 
);action_tile
 
(action_tile "rb3"
;if radio button rb3 selected
 
  	"(setq gr \"HSFG\")"
;set grade of bolt
 
);action_tile
 
  (action_tile "cancel"	
  ;if cancel selected
 
 	"(done_dialog)
;end dialog
 
 (setq userclick nil)"
 ;set flag to nill
 
  );action_tile
  ;if cancel set flag to nil
 
(action_tile "accept"	
 
 "(setq siz (get_tile \"sel1\"))
 ;get the bolt size
 
 (setq siz1 (get_tile \"sel2\"))
 ;get the bolt length
 
 (done_dialog)
 ;end the dialog
 
 (setq userclick T)"
 ;set the flag to true
 
);action tile
 
(start_dialog)	
;start the dialogue
 
(unload_dialog dcl_id)	
;unload the dialogue
 
 (if userclick	
 ;if OK has been selected
 
  (progn
  ;do the following
 
(setq NSIZ (cons 1000 SIZ))
;construct a new bolt size list
 
(setq NSIZ1 (cons 1000 SIZ1))
;construct a new bolt length list
 
(setq NGR (cons 1000 gr))
;construct a new bolt grade list
 
(setq e4 (chnitem NSIZ 2 e3))
;change the existing bolt size list
 
(setq e5 (chnitem NSIZ1 3 e4))
;change the existing bolt length list
 
(setq e6 (chnitem NGR 4 e5))
;change the existing bolt grade list
 
(setq e7 (subst e6 e3 e2))
;update list
 
(setq e8 (subst e7 e2 e))
;update list
 
(entmod e8)
;update the entity
 
   (setq SIZ (nth (atoi SIZ) NAMES))
   ;get the size of the bolt from the list
 
   (setq SIZ1 (nth (atoi SIZ1) LEN))
   ;get the length of the bolt from the list
 
   (alert (strcat "The size of bolt is " SIZ "\n"
    "The length of bolt is " SIZ1 "\n"
    "The grade of bolt is " GR)
   );alert
 
 
  );end progn
 
 );end if
 
(princ)
;finish cleanly
 
);end defun
 
 
;;This function replaces any element in a list with another element
;;It requires 3 parameters (chnitem value itemnumber list)
 
(defun chnitem (value num lst)
   (setq num (- num 1))
   (setq tmplt (list nil))
   (setq tmplt2 (list nil))
   (setq counter 0)
   (repeat  num
  (setq tmplt (append tmplt (list (nth counter lst))))
  (setq counter (+ counter 1))
   )
   (setq counter (+ counter 1))
   (repeat (- (length lst) (+ num 1))
  (setq tmplt2 (append tmplt2 (list (nth counter lst))))
  (setq counter (+ counter 1))
   )
   (setq tmplt (cdr tmplt))
   (setq tmplt2 (cdr tmplt2))
   (setq lst (append tmplt (list value) tmplt2))
)
(princ)
;load cleanly

Draw a few circles representing holes on your drawing and run this application. Clever, hey?

Now, let's write a routine that extracts this data from the drawing and saves it, in a space deliminating format, to an external text file.

(defun C:exfile ()
;define the function
 
(setq NAMES '("M6" "M8" "M10" "M12" "M16" "M20" "M24" "M30" "M36"))
;create list of bolt sizes
 
(setq LEN '("10" "15" "20" "25" "30" "35" "40" "45" "50" "55" "60"))
;create list of bolt lengths
 
(setq fname (getstring "\nEnter file name: "))
;get the file name
 
(setq fn (open fname "w"))
;open it to write
 
(setq a (ssget "x" '((-3 ("AFRALISP")))))
;get all the bolt exdata in the drawing
 
(setq lg (sslength a))
;get the number of bolts
 
(setq i 0)
;set counter to zero
 
(repeat lg
;repeat for the number of entities with bolt xdata
 
  (setq e (entget (ssname a i) '("AFRALISP")))
  ;get the entity list
 
  (setq i (1+ i))
  ;increment the counter
 
  (setq d (assoc -3 e))
  ;get the xdata list
 
  (setq d1 (cdr (car (cdr d))))
  ;get just the xdata
 
  (mapcar 'set '(SIZ SIZ1 GR) d1)
  ;put each of the lists into variables
 
  (setq SIZ (cdr SIZ))
  ;get the index number of the bolt size
 
  (setq SIZ (nth (atoi SIZ) NAMES))
  ;retrieve the bolt size from the master list
 
  (setq SIZ1 (cdr SIZ1))
  ;get the index number of the bolt length
 
  (setq SIZ1 (nth (atoi SIZ1) LEN))
  ;retrieve the bolt size from the master list
 
  (setq GR (cdr GR))
  ;retrieve the bolt grade
 
  (princ SIZ fn)
  ;print bolt size
 
  (princ " " fn)
  ;print a space
 
  (princ SIZ1 fn)
  ;print bolt length
 
  (princ " " fn)
  ;print a space
 
  (princ GR fn)
  ;print the bolt grade
 
  (princ "\n" fn)
  ;print a new line
 
);end repeat
 
(close fn)
;close the file
 
(alert (strcat "Exported Details of\n"
 (itoa lg)
 " Bolts to file : \n"
 (strcase fname))
);alert
;inform the user
 
(princ)
;finish cleanly
 
);end defun
 
(princ)
;load cleanly

As you can see, you can attach xdata to any type of entity, and attach all sorts of different types of information.

Well, that's about it for now. If you would like the source coding for the applications written on this page, then just &lt;a href="files/xdata.zip">click here.&lt;/a>

<h2>(mapcar) and (lambda)</h2>

As you know, LISP stands for "List Processing". There are quite a few commands in AutoLisp that allow you to manipulate lists. (subst, append, etc.) But what about commands that will allow you to apply a function to items in a list. Let's look at (mapcar) first.

<h2>(mapcar)</h2>
The function (mapcar) allows you to perform a "function" on each element of the list. Let's try a simple example :

What we want to do is add 1 to each element of a list.

(setq a 1)
(mapcar '1+ (list a))

This will return 2.

This is what happened :

&lt;code>mapcar&lt;/code> adds 1 to the &lt;code>(list a)&lt;/code> to make 2.

Now a longer list :

(setq a '(1 2 3 4 5 6 7 8 9 10))
(mapcar '1+ a)

This will return :

(2 3 4 5 6 7 8 9 10 11)

Just a few words on creating lists in AutoLisp: there are two ways to create lists. The first way is to use a command that will create a list. Examples of this are &lt;code>(getpoint)&lt;/code> and &lt;code>(entget)&lt;/code>. Both of these commands will return a list.

Secondly, you could use the &lt;code>(list)&lt;/code> command. For example :

(setq a (list 1 2 3 4 5))

If you looked at variable a it would look like this :

(1 2 3 4 5)

The other way of writing this is :

(setq a '(1 2 3 4 5))

Both methods do the same thing, create a list.

Here is another example using &lt;code>(mapcar)&lt;/code> :

Say you have a list of data stored in variable &lt;var>arglist&lt;/var>.

(setq arglist '(12.0 145.8 67.2 "M20"))

You want to place each item in the list in it's own variable to use in your routine. One way to do it would be as follows :

 (setq a (nth 0 arglist))
 (setq b (nth 1 arglist))
 (setq c (nth 2 arglist))
 (setq d (nth 3 arglist))

This works, but is an extremely slow way of processing the data as each variable requires a program statement. A much more efficient way is to use the MAPCAR technique.

(mapcar 'set '(a b c d) arglist)

This routine maps the SET function to each element of the first list and it's corresponding element of the second list. SET is used instead of SETQ to evaluate each quoted element of the first list. With the currently set list c, it sets a to 12.0, b to 145.8, c to 67.2 and d to "M20".

If you are reading a list from an external file, your routine may not read back the elements of the list as they once were. Your routine will read them back as strings. For example :

Your list should look like this :

(10 20 30 40 50)

But after reading the list in from the file, it looks like this :

("10" "20" "30" "40" "50")

You can use (mapcar) to convert the list from strings to integers :

(setq b (mapcar '(atoi) thelist))&nbsp;

Now this works fine if you are using an AutoLisp function, but how would you use &lt;code>(mapcar)&lt;/code> with a user defined function? Let's look at this example :

What we have is a list of angles that we want to convert to Radians.

(setq c '(23.0 47.8 52.1 35.6))

Firstly we would write a function to convert degrees to radians :

(defun dtr (a)
(* pi (/ a 180.0))
)

Our function to convert our list would look like this :

(setq d (mapcar 'dtr c))

This function will run the &lt;code>(dtr)&lt;/code> function against each element of list c. In other words, the value of each element is passed to the (dtr) function.

The function could also be written like this :

(setq d (mapcar (quote dtr) c))

<h2>(lambda)</h2>
Now this is where the &lt;code>(lambda)&lt;/code> function comes into play. &lt;code>(lambda)&lt;/code> allows you to write the &lt;code>(dtr)&lt;/code> function "in-line" within the &lt;code>(mapcar)&lt;/code> expression without having to define a separate function.

(setq d (mapcar (quote (lambda (a) (* pi (/ a 180.0)))) c))

or

(setq d (mapcar '(lambda (a) (* pi (/ a 180.0))) c))

This function will convert all the angles in the list c to radians and store them in variable d.

Let's look a bit closer at the &lt;code>(lambda)&lt;/code> function.

(lambda (a) (* pi (/ a 180.0)))

&hellip;is the same as&hellip;

(defun (a) (* pi (/ a 180.0)))

Let's write a function to test this :

(defun c:test ()
(setq c '(23.0 47.8 52.1 35.6))
(setq d (mapcar '(lambda (a) (* pi (/ a 180.0))) c))
(mapcar 'set '(w x y z) d)
 (princ)
)

!c should return &lt;code>(23.0 47.8 52.1 35.6)&lt;/code>

!d should return &lt;code>(0.401426 0.834267 0.909317 0.621337)&lt;/code>

!w should return &lt;code>0.401426&lt;/code>

!x should return &lt;code>0.834267&lt;/code>

!y should return &lt;code>0.909317&lt;/code>

!z should return &lt;code>0.621337&lt;/code>

To quote the AutoCad Customization Manual :

"Use the (lambda) function when the overhead of defining a new function is not justified. It also makes the programmer's intention more apparent by laying out the function at the spot where it is to be used."

In practice, &lt;code>(lambda)&lt;/code> can be used anywhere you need a speedy function and you don't want the trouble of writing and making sure a &lt;code>(defun)&lt;/code> function is loaded.

There are another two AutoLisp commands that can apply a function to a list. They are &lt;code>(apply)&lt;/code> and &lt;code>(foreach)&lt;/code>. Let's have a quick look at them.

<h2>(apply)</h2>

This function differs from (mapcar) in that it applies a function to the whole list and not to the individual items in the list. Here's a couple of examples :

(apply '+ '(1 2 3))

This will return 6.

(apply 'strcat '("a" "b" "c"))

This will return "abc"

You can also use &lt;code>(apply)&lt;/code> in comjunction with &lt;code>(lambda)&lt;/code> :

(apply '(lambda (x y z)
	(* x (- y z))
	)
	'(5 20 14)
)

This will return 30 (20-14*5=30).

<h2>(foreach)</h2>
The syntax for this is: &lt;code>(foreach name list expression&hellip;)&lt;/code>

This function steps through list, assigning each element to name, and evaluates each expression for every element in the list. For example :

(foreach n a (princ n) (terpri))

If you had a list :

(setq a (1 2 3 4 5))

The previous expression would print vertically :

1
2
3
4
5

Right, I don't know about you, but my brain is full. Time for a couple of beers. Cheers for Now&hellip;

<h2>The (eval) Function</h2>

The &lt;code>(eval)&lt;/code> function is another the seldom used but very powerful AutoLisp functions. It is defined in the AutoCad Customization Guide as follows :

Eval - Returns the result of evaluating an AutoLisp expression.

Syntax : &lt;code>(eval &lt;em>expr&lt;/em>)&lt;/code>

For example, have a look at the following code segment :

(eval (ascii "A"))

Which simply means, &lt;em>Evaluate the expression (ascii "A")&lt;/em>. This should return "65", the ASCII character code for "A".

Fine, I understand that, but where would I use it? Here's a simple example.

Say we had a whole lot of distances that we had to measure and then come up with an accumulative total. We could measure each one, write it down, and then, manually add them up. Here's a better way. We are now going to write an AutoLisp routine that allows us to measure each distance, and then return a total of all the distances. Here we will use the &lt;code>(eval)&lt;/code> function to perform the final total calculation for us.

Here's the coding :

;Program to measure non-sequential distances
 
(Defun C:ADIST ( / dst dstlst adist)
;define the function and declare variables
 
(setq dstlst '(+ )) 
;create list with plus
 
  (while
  ;while a return is not entered
 
 	(setq dst (getdist "\nPick point or Return to exit: "))
;get the distance
 
 	(setq dstlst (append dstlst (list dst)))
;append the distance to the list
 
(setq adist (eval dstlst))
;calculate the running total
 
(setq dst (rtos dst 2 2))
;convert to string
 
(setq adist (rtos adist 2 2))
;convert to string
 
(princ (strcat "\nDistance = " dst "  Accum Dist = " adist))
;display the distance and the running total
 
  );end while
 
(prompt (strcat "\nTotal Distance = " adist))
;display the total distance
 
 (princ)
 ;clean finish
 
);defun
 
(princ)
;clean loading

We start of the function by defining a list that only contains the '+' function. The heart of the routine is nested in a 'while' loop. As long as the user keeps on adding distances, the routine runs, but as soon as he hits a return, 'while' evaluates to nil and the loop is ended. The first line within the loop simply gets the required distance. The second line appends the distances to the list. Thirdly, we evaluate the list adding all of the distances together. We then format the distance and the running total and display them to the user. Once the user has finished selecting the distances, we display the final total. Simple really!

&lt;strong>Hint:&lt;/strong> Have you ever thought of building a macro recorder similar to that used in Excel. By storing the users AutoCAD commands in a list along with the AutoLisp command function, you could use the 'eval' function to 'playback' the list of commands. For example :

(setq lst '(command "circle" pt2 rad))
(eval lst)

Here's another example of using the &lt;code>(eval)&lt;/code> function, but this time we'll use it to replace the &lt;code>(cond)&lt;/code> function. The following coding is a small application that converts various values. It uses the (cond) function to determine which radio button was selected and then uses that information to run the relevant sub-routine.

First the DCL coding :

//DCL CODING STARTS HERE
conversion   : dialog {
 label = "Conversion" ;
 
: radio_button {
   	  key = "rb1" ;
   	  label = "&amp;Inches to Millimetres" ;
   	  value = "1" ;
}
 
   	: radio_button {
   	  key = "rb2" ;
   	  label = "&amp;Millimetres to Inches" ;
   	}
 
   	: radio_button {
   	  key = "rb3" ;
   	  label = "M&amp;iles to Kilometres" ;
   	  }
 
   	: radio_button {
   	  key = "rb4" ;
   	  label = "&amp;Kilometres to Miles" ;
   	}
 
: edit_box {
  key = "eb1";
  label = "Value";
  value = "1.0";
}
 
 
ok_cancel ;
 
}
//DCL CODING ENDS HERE

Save this as "Conversion.dcl".

And now the AutoLisp Coding :

;AUTOLISP CODING STARTS HERE
(defun C:Conversion ()
 
(setq retval "IM")
 
(setq edval 1.0)
 
(setq dcl_id (load_dialog "conversion.dcl"))
 
(if (not (new_dialog "conversion" dcl_id)
;test for dialog
 
);not
 
  (exit)
  ;exit if no dialog
 
);if
 
(mode_tile "eb1" 2)
 
(action_tile "rb1" "(setq retval \"IM\")")
(action_tile "rb2" "(setq retval \"MI\")")
(action_tile "rb3" "(setq retval \"MK\")")
(action_tile "rb4" "(setq retval \"KM\")")
 
(action_tile
  "accept"
  (strcat
  "(progn (setq edval (atof (get_tile \"eb1\")))"
  "(done_dialog) (setq userclick T))")
);action tile
 
  (action_tile
  "cancel"
  "(done_dialog) (setq userclick nil)"	
  );action_tile
 
(start_dialog)	
			
(unload_dialog dcl_id)
 
 (if userclick
 
  (cond
 
   ((= retval "IM") (IM edval))
   ((= retval "MI") (MI edval))
   ((= retval "MK") (MK edval))
   ((= retval "KM") (KM edval))
 
  );cond
   
);if userclick
 
(alert (strcat "Value = " (rtos ans)))
 
 (princ)
 
);defun
 
;-------------------------
(defun IM (val)
 (setq ans (* val 25.4))
)
;-------------------------
(defun MI (val)
 (setq ans (/ val 25.4))
)
;-------------------------
(defun MK (val)
 (setq ans (* val 1.609344))
)
;-------------------------
(defun KM (val)
 (setq ans (/ val 1.609344))
)
;-------------------------
(princ)
;AUTOLISP CODING ENDS HERE

Save this a "Conversion.lsp" then load and run it.

As you will see, it's just a simple little conversion routine.

Now replace these lines :

  (cond
 
   ((= retval "IM") (IM edval))
   ((= retval "MI") (MI edval))
   ((= retval "MK") (MK edval))
   ((= retval "KM") (KM edval))
 
  );cond

with this line :

((eval (read retval)) edval)

This one line replaces the whole of the &lt;code>(cond)&lt;/code> section.

Cheers for now and happy evaluating&hellip;

<h2>Redefining Commands</h2>

Most AutoCAD users know that it is possible to undefine an AutoCAD command and then redefine it to do something else. But, very few people seem to use this very useful feature. I find it very handy to stop people changing system settings that divert from drawing office standards. Let's have a look at an example of this. Say we had a block inserted into the drawing that we did not want to be exploded because it contains attributes. This is how we would go about using AutoLisp to undefine and then redefine the Explode command.

First, we would create an AutoLisp file called 'Redefs.Lsp'. Then we would add the following coding :

(command "UNDEFINE" "EXPLODE")
;undefine the Explode command

After undefining the explode command we would then redefine it :

(defun C:EXPLODE ( / lst1 en typ)
 
 (setq lst1 (list "DRGTITLE1" "DRGTITLE2"))
 ;list of block names that must NOT be exploded
 
 ;If you wish to add additional block names, and want an easy way to
 ;figure out which ones you screened for each release, use this line with
 ;your block names.
 ;(setq lst1 (append lst1 (list "DRGTITLE2" "DRGTITLE3" "DRGTITLE4")))
 
 (setq en (car (entsel "\n Select block reference, polyline, dimension,
or mesh: ")))
 ;gets the block and mimics the explode prompt
 
 (setq typ (entget en))
 ;get the entity data
 
 (setq typ (cdr (assoc 2 typ)))
 ;get the block name
 
 (if (member typ lst1)
 ;if the selected block name is a member of our list
 
 (alert "\nThis Block Cannot be Exploded. 
   \n    Refer to System Manager")
 ;inform the user

 ;if it is not
 (progn
 ;do the following
 
 (command ^c^c) 
 ;cancel any commands
 
 (command ".EXPLODE" en)
 ;explode the block
 
);progn
 
 )
 ;if
 
(princ)
;finish clean
 
);defun
(princ)
;load clean

We would, of course, load Redefs.Lsp from our Acad.Lsp file to ensure that it would be available all of the time. Just please note, that because this routine uses the 'Command' function, we would have to load it from the S::STARTUP section of the Acad.Lsp file. It would look something like this :

(defun S::STARTUP ()
 (prompt "\nAfraLisp Custom Utilities Loaded....\n")
 (load "REDEFS" "\nREDEFS.LSP not found")
  (princ)
);defun

I'll tell you what we'll do next. Let's create our own Drawing AutoSave. First of all we need a way to check when a certain amount of time has elapsed. One of the simplest ways of doing this is to use one of the commonest used commands as a trigger. We'll use the Line command.

Add the following coding to Redefs.Lsp :

Firstly we need to undefine the Line command :

 (command "UNDEFINE" "LINE")
 ;undefine the Line command

The we need to redefine it :

(defun C:LINE ()
;define the function
 
  (autosave)
  ;call the Autosave function
 
  (command ".LINE")
  ;call the line command
 
(princ)
 
);defun

Next we need to write our Autosave function :

(defun AUTOSAVE ( / T1 ECC)
;define the function
 
(setq ECC (getvar "CMDECHO"))
;get the value of the CMDECHO system variable
 
(setvar "CMDECHO" 0)
;switch it off
 
(if (not T3) (setq T3 (getvar "TDUSRTIMER")))
;check if we have the value of the drawing timer
;if we haven't got it, then get it.
 
(if (not T2) (setq T2 (getreal "\nHow many minutes between saves? : ")))
;check if we have an AutoSave time.
;if we haven't got it, then get it.
 
(setq T1 (getvar "TDUSRTIMER"))
;get the drawing timer again for comparison purposes.
 
(if (&gt; (- T1 T3) (/ T2 60.0 24.0))
;compare the drawing timer values
 
(progn
;if it is time to save
 
(prompt "\nAutoSaving Drawing, Please Wait&hellip;")
;inform the user
 
(command "QSAVE")
;save the drawing
 
(setq T3 (getvar "TDUSRTIMER"))
;reset the timer
 
);progn
 
);if
 
(setvar "CMDECHO" ECC)
;reset CMDECHO
 
 (princ)
 
);defun

The first time you select the Line command, this function will ask you for an interval between saves. From then on, every time you use the Line command the function will check to see if you have exceeded the time interval. If you haven't, it will do nothing. But if you have, it will first inform you, and then save your drawing. Handy little thing, Hey?

To download source coding for Redefs.lsp &lt;a href="files/redefs.zip">click here.&lt;/a> (1Kb)

<h2>Efficient Variables</h2>

Every variable used in an AutoLisp routine uses up system resources. You've probably been advised before now, not to use too many SETQ's. LISP, itself was originally a functional language, without any variables. Here is a typical example of how we all go about collecting the values required for our routines.

(setq "oldecho" (getvar "CMDECHO"))
(setq "oldhigh" (getvar "HIGHLIGHT"))
(setq "oldsnap" (getvar "OSMODE"))
(setq pt1 (getpoint "\Enter First Point : "))
(setq pt2 (getpoint "\Enter Second Point : "))
(setq thk (getdist "\Enter Thickness : "))
(setq qty (getint "\Enter Number Required : "))

Programmatically, there is nothing wrong with this coding, except that seven (7) variables are used, each of which takes up system resources. As well as this, each variable will need to be declared as Local to prevent a scattering of loose variables all over the place.

A much better way of storing your variables is to place them in a list. Here's one way of doing this :

(setq AList (append (list (getvar "CMDECHO")) AList))
(setq AList (append (list (getvar "HIGHLIGHT")) AList))
(setq AList (append (list (getvar "OSMODE")) AList))
(setq AList (append (list (getpoint "\Enter First Point : ")) AList))
(setq AList (append (list (getpoint "\Enter Second Point : ")) AList))
(setq AList (append (list (getdist "\Enter Thickness : ")) AList))
(setq AList (append (list (getint "\Enter Number Required : ")) AList)) 

If we ran this sequence of coding, the variable &lt;em>AList&lt;/em> would contain something like this :

(5 10.0 (660.206 391.01 0.0) (411.014 548.932 0.0) 32 1 0)

Now this is a lot better. Every variable stored in one list and only one variable to declare. To retrieve any of the values, we would simply do the following :

(setvar "OSMODE" (nth 4 AList))

This, of course would return 32, the value of the Snap that we previously saved.

The problem with this though, is remembering which value belongs to what. To achieve this we would need to keep track of the order in which we passed the values to our list. Wouldn't it be great if we could pass a label along with each value so that we could easily retrieve the value by just quoting the label. By using &lt;em>'Associative Lists'&lt;/em> we can do just that.

Have a look at this :

(setq AList (append (list (cons "OLDECHO" (getvar "CMDECHO"))) AList))
(setq AList (append (list (cons "OLDHIGH" (getvar "HIGHLIGHT"))) AList))
(setq AList (append (list (cons "OLDSNAP" (getvar "OSMODE"))) AList))
(setq AList (append (list (cons "PT1" (getpoint "\Enter First Point : "))) AList))
(setq AList (append (list (cons "PT2" (getpoint "\Enter Second Point : "))) AList))
(setq AList (append (list (cons "THK" (getdist "\Enter Thickness : "))) AList))
(setq AList (append (list (cons "QTY" (getint "\Enter Number Required : "))) AList)) 

This coding would return something like this :

(("QTY" . 6) ("THK" . 12.0) ("PT2" 809.113 523.118 0.0) ("PT1" 356.314 646.115 0.0)
("OLDSNAP" . 32) ("OLDHIGH" . 1) "OLDECHO" 0)

Now, to retrieve any value from this list, irrespective of it's position in the list, we would simply do something like this :

(setvar "OSMODE" (cdr (assoc "OLDSNAP" AList)))

This, again would return 32.

Now, by converting the construction of the list, and the retrieving of values from the list, into functions, we have an elegant and sophisticated way of storing our variables in an efficient and practical manner. Following, is an AutoLisp routine that can be used, with just a wee bit of modification, in any situation to make the storage of your variable much more efficient :

(defun c:efflist ( / AnItem item MainList)
 
(setq AnItem (getvar "OSMODE"))
;get the snap setting
 
(AList "OLDSNAP" AnItem)
;add it to the list
 
(setq AnItem (getvar "HIGHLIGHT"))
;get the highlight setting
 
(AList "OLDHIGH" AnItem)
;add it to the list
 
(setq AnItem (getvar "CMDECHO"))
;get the command echo setting
 
(AList "OLDECHO" AnItem)
;add it to the list
 
(setvar "Osmode" 32)
;reset snap to intersection
 
(setvar "Highlight" 0)
;switch off highlight
 
(setvar "Cmdecho" 0)
;switch off command echo
 
(setq AnItem (getpoint "\nSelect First Point : "))
;get the first point
 
(AList "FirstPoint" AnItem)
;add it to the list
 
(setq AnItem (getpoint AnItem "\nSelect Second Point : "))
;get the second point
 
(AList "SecondPoint" AnItem)
;add it to the list
 
(setq AnItem (getpoint AnItem "\nSelect Third Point : "))
;get the third point
 
(AList "ThirdPoint" AnItem)
;add it to the list
 
(setq AnItem (getpoint AnItem "\nSelect Fourth Point : "))
;get the fourth point
 
(AList "FourthPoint" AnItem)
;add it to the list
 
(command "Line" (RList "FirstPoint")
		(RList "SecondPoint")
		(RList "ThirdPoint")
		(RList "FourthPoint")
		"C"
)
;retrieve all the point values and draw the shape
 
(setvar "OSMODE" (RList "OLDSNAP"))
;retrieve and reset snap
 
(setvar "HIGHLIGHT" (RList "OLDHIGH"))
;retrieve and reset highlight
 
(setvar "CMDECHO" (RList "OLDECHO"))
;retrieve and reset command echo
 
(princ)
 
);defun
 
;This function constructs the list and adds it to the main list
(defun AList (Name Val)
 
(setq item (list (cons Name Val)))
;construct list
 
(setq MainList (append item Mainlist))
;add it to the main list
 
);defun
 
;This function retrieves the values from the main list
(defun RList (TheName)
 
(cdr (assoc TheName MainList))
;retrieve value from list
 
);defun
(princ)

After running this routine, the value of the variable &lt;var>MainList&lt;/var> would look something like this :

(("FourthPoint" 456.598 514.007 0.0) ("ThirdPoint" 676.92 293.827 0.0) 
("SecondPoint" 1030.95 526.155 0.0) ("FirstPoint" 576.636 732.669 0.0) 
("OLDECHO" . 0) ("OLDHIGH" . 1) ("OLDSNAP" . 32))

<h2>The DIR Command</h2>

&lt;strong>Important note:&lt;/strong> Before proceeding with this tutorial, ensure that the following is set correctly within your Acad.pgp file (AutoCAD Program Parameters File.)

&lt;pre class="highlight">DIR, DIR, 1,File specification: ,

You will find the "DIR" parameters&nbsp; under the &lt;em>"Examples of external commands for command windows"&lt;/em> section within your Acad.pgp file.

The Acad.pgp file can normally be found within your AutoCAD Support directory, for example: &lt;code>C:/Program Files/Autocad 2002/Support/Acad.pgp&lt;/code>. You can simply open and edit this file using Notepad.

The "DIR" command is a DOS (remember that dark place) command that displays a list of a directories files and subdirectories. But did you know that you can use the "DIR" command from within AutoLisp? This is a great function for obtaining a list of files in a directory, especially useful for Batch Processing Routines.

Let's have a look at it. Fire up AutoCAD and type this at the Command prompt :

Command: (command "dir" "*.* &gt; Temp.txt")

What this statement is asking for is a directory listing of all the files in the current directory output to the file Temp.txt.

Now open Temp.txt and you should have something like this :

 Volume in drive O has no label
 Directory of O:\E51D\E51D1
 
.     &lt;DIR&gt;     09-11-99  3:13p .
..    &lt;DIR&gt;     09-11-99  3:13p ..
9961     DXF 345,167  08-05-99 12:14p 9961.DXF
9962     DXF     8,246,298  08-05-99 12:14p 9962.DXF
Antexe 701,121  08-05-99 11:36a Ant.exe
batchp1  exe  11,776  01-18-99 11:23a batchp1.exe
BATCHP1 EXE  13,312   01-19-99  8:19a BatchPurge.Exe
DCLTUT   GIF   2,635  08-01-99 11:19p DCLTUT.GIF
debex &lt;DIR&gt;     07-28-99  7:04a debex
N1 dxf 245,702  08-02-99  3:23p N1.dxf
NAMDEB   DXF    28,320,177  07-30-99 12:29p NAMDEB.DXF
projair  dwg 120,055  07-06-99  3:11p projair.dwg
R12K471 DWG 421,118   07-02-99 10:28a R12K47646.dwg
sort     dwg 125,471  07-26-99  1:17p sort.dwg
SORTER   dwg  27,981  07-27-99 10:35a SORTER.dwg
temp  &lt;DIR&gt;     09-11-99  3:13p temp
temp     txt 0  09-11-99  3:13p temp.txt
test &lt;DIR&gt;08-20-99 11:15a test
title    dwg  99,381  08-02-99  2:30p title.dwg
truss1   dwg  84,382  07-09-99 11:13a truss1.dwg
truss2   dwg  88,296  07-09-99 11:13a truss2.dwg
uniglide dwg 205,715  07-19-99  9:09a uniglide.dwg
VALVE    dwg  24,693  07-29-99 11:31a VALVE.dwg
18 file(s)     39,083,280 bytes
 5 dir(s)   2,147,450,880 bytes free

This is a listing of all the files and sub directories contained in your current working directory. OK, I know, it's not quite formatted the way we would want it to be. So, let's use a couple "DIR" switches to format the file list the way that we would like it. Try this :

Command: (command "dir" " /b *.* &gt;temp.txt")

That's better, we've now got just the file names. The &lt;code>/b&lt;/code> switch limits the list to only file names. Temp.txt should now look something like this :

9961.DXF
9962.DXF
Ant.exe
batchp1.exe
BatchPurge.Exe
DCLTUT.GIF
debex
N1.dxf
NAMDEB.DXF
projair.dwg
R12K47646.dwg
sort.dwg
SORTER.dwg
temp
temp.txt
test
title.dwg
truss1.dwg
truss2.dwg
uniglide.dwg
VALVE.dwg

Right, now retrieve just the DWG filenames : 

Command: (command "dir" " /b *.dwg &gt; temp.txt")

Temp.txt should now look something like this :

projair.dwg
R12K47646.dwg
sort.dwg
SORTER.dwg
title.dwg
truss1.dwg
truss2.dwg
uniglide.dwg
VALVE.dwg

That's it, we have now got our required file listing in the format that we require. The "DIR" command has got a lot more switches that you can use to restrict your listings to whatever you desire. I suggest you dust off one of your old DOS Reference Manuals and look "DIR" up.

Hint : Would you like a listing of all the files in the current directory AND all sub-directories? Use the &lt;code>/s&lt;/code> switch :

Command: (command "dir" " /b/s *.dwg &gt;temp.txt")

You should get a listing something like this :

O:\E51D\E51D1\projair.dwg
O:\E51D\E51D1\R12K47646.dwg
O:\E51D\E51D1\sort.dwg
O:\E51D\E51D1\SORTER.dwg
O:\E51D\E51D1\title.dwg
O:\E51D\E51D1\truss1.dwg
O:\E51D\E51D1\truss2.dwg
O:\E51D\E51D1\uniglide.dwg
O:\E51D\E51D1\VALVE.dwg
O:\E51D\E51D1\test\SCANNEX1.dwg
O:\E51D\E51D1\test\SCANNEX2.dwg
O:\E51D\E51D1\test\SCANNEX3.dwg
O:\E51D\E51D1\test\SCANNEX4.dwg

<h2>Colours and Linetypes ByLayer</h2>

Each layer in an AutoCAD drawing has a default colour and a default
linetype. Thus, the term "Bylayer" means that an object drawn on
a particular layer has the default colour and linetype of that layer.

You can, if you wish, change the colour and linetype of an object drawn
on a layer to suit your requirements. A good example of this is when
dimensioning. Your dimensions reside on say layer "Dim" which
has a default color of "1" and a default linetype of
"Continuous". The extension lines though, are also on layer
"Dim" but have a color of say "9". When you plot,
colour "1" has a pen width 0f 0.35mm but colour "9"
has a pen width of 0.15mm which will plot out the extension lines thinner.

Often though, you have to deal with a total mismatch of Layers, Colours
and Linetypes and would like to convert all objects back to their "Bylayer"
default values. Let's have a look at how we would go about this.

First of all, open a new, blank drawing and setup a Layer with the
following properties :

Layer Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"2"

Layer Colour&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 -
"Yellow"

Layer Linetype&nbsp;&nbsp;&nbsp; Dashed2

Now, draw a line on Layer "2" anywhere in the drawing then enter the following :

Command: (setq sel (ssget)) Select the Line
Select objects: 1 found
Select objects: &lt;enter&gt;
&lt;Selection set: 8&gt;

Command: (setq entity (ssname sel 0))
&lt;Entity name: 1838e10&gt;

Command: (setq name (entget entity))
((-1 . &lt;Entity name: 1838e10&gt;) (0 . "LINE") (330 . &lt;Entity name: 18388c0&gt;) (5 . "95A")
(100 . "AcDbEntity") (67 . 0) (410 . "Model") (8 . "2")(100 . "AcDbLine")
(10 319.65 364.538 0.0) (11 338.809 500.026 0.0) (210 0.0 0.0 1.0))

We have just retrieved the entity list of the line object. The DXF Group Code 8, is the layer name. Group Code 62 is the colour of the object, but where is it?

Let's have a look for it. Type this :

Command: (setq layer (cdr (assoc 62 name)))
nil

It returns "nil". Hey Kenny, what's going here?

If an object is drawn on a layer using colour "Bylayer", no
Group Code 62 exists as AutoCAD already knows what colour to draw the
object with.

<h2>Changing the colour</h2>
O.K. let's mess AutoCAD around and change the colour :

Command: change
Select objects: 1 found
Select objects: &lt;enter&gt;
Specify change point or [Properties]: p
Enter property to change [Color/Elev/LAyer/LType/ltScale/LWeight/Thickness]: c
Enter new color &lt;ByLayer&gt;: 4
Enter property to change [Color/Elev/LAyer/LType/ltScale/LWeight/Thickness]: &lt;enter&gt;

Ha, take that you bounder. Let's look at the entity list again :

Command: (setq sel (ssget))
Select objects: 1 found
Select objects: &lt;enter&gt;
&lt;Selection set: a&gt;

Command: (setq entity (ssname sel 0))
&lt;Entity name: 1838e10&gt;

Command: (setq name (entget entity))
((-1 . &lt;Entity name: 1838e10&gt;) (0 . "LINE") (330 . &lt;Entity name: 18388c0&gt;)
(5 . "95A") (100 . "AcDbEntity") (67 . 0) (410 . "Model") (8 . "2") (62 . 4)
(100 . "AcDbLine") (10 319.65 364.538 0.0) (11 338.809 500.026 0.0) (210 0.0 0.0 1.0))

Hey, Group Code 62 has suddenly appeared in our list and tells us that the object is now colour 4! Jeepers, AutoCAD is only clever.

But what happens if we want to change the line back to it's "Bylayer" colour and Linetype?

Have a look at the following :

Select the object :

&lt;code>Command: (setq sel (ssget))

Select objects: 1 found

Select objects: &lt;enter&gt;

&lt;Selection set: 4&gt;&lt;/code>

Get it's name :

&lt;code>Command: (setq entity (ssname sel 0))

&lt;Entity name: 1803610&gt;&lt;/code>

Retrieve the entity list :

&lt;code>Command: (setq name (entget entity))

((-1 . &lt;Entity name: 1803610&gt;) (0 . "LINE") (330 . &lt;Entity name: 18030c0&gt;) (5 . "95A") (100 . "AcDbEntity") (67 . 0) (410 . "Model") (8 . "2") (62 . 4) (100 . "AcDbLine") (10 275.439 544.206 0.0) (11 357.967 544.206 0.0) (210 0.0 0.0 1.0))&lt;/code>

Get the layer name :

&lt;code>Command: (setq layer (cdr (assoc 8 name)))

"2"&lt;/code>

Use "&lt;i>tblsearch&lt;/i>" to get the layer default details :

&lt;code>Command: (setq layerinf (tblsearch "LAYER" layer))

((0 . "LAYER") (2 . "2") (70 . 0) (62 . 2) (6 . "DASHED2"))&lt;/code>

Retrieve the "Bylayer" colour :

&lt;code>Command: (setq layercol (cdr (assoc 62 layerinf)))

2&lt;/code>

Construct a new list and append it to the entity list

&lt;code>Command: (setq name (append name (list (cons 62 layercol))))

((-1 . &lt;Entity name: 1803610&gt;) (0 . "LINE") (330 . &lt;Entity name: 18030c0&gt;) (5 . "95A") (100 . "AcDbEntity") (67 . 0) (410 . "Model") (8 . "2") (62 . 4) (100 . "AcDbLine") (10 275.439 544.206 0.0) (11 357.967 544.206 0.0) (210 0.0 0.0 1.0) (62 . 2))&lt;/code>

Now modify the definition data of an object :

&lt;code>Command: (entmod name)

((-1 . &lt;Entity name: 1803610&gt;) (0 . "LINE") (330 . &lt;Entity name: 18030c0&gt;) (5 . "95A") (100 . "AcDbEntity") (67 . 0) (410 . "Model") (8 . "2") (62 . 4) (100 . "AcDbLine") (10 275.439 544.206 0.0) (11 357.967 544.206 0.0) (210 0.0 0.0 1.0) (62 . 2))&lt;/code>

And finally, update the object :

&lt;code>Command: (entupd entity)

&lt;Entity name: 1803610&gt;&lt;/code>

Your line should have changed back to colour Yellow.

Let's check if our entity list has been changed :

Command: (setq sel (ssget))
Select objects: 1 found
Select objects: &lt;enter&gt;
&lt;Selection set: 6&gt;

Command: (setq entity (ssname sel 0))
&lt;Entity name: 1803610&gt;

Command: (setq name (entget entity))
((-1 . &lt;Entity name: 1803610&gt;) (0 . "LINE") (330 . &lt;Entity name: 18030c0&gt;)
(5 . "95A") (100 . "AcDbEntity") (67 . 0) (410 . "Model") (8 . "2")
(62 . 2) (100 . "AcDbLine") (10 275.439 544.206 0.0)
(11 357.967 544.206 0.0) (210 0.0 0.0 1.0))

Yep, everything is hunky dory! Our entity list has been updated with the correct values.

<h2>Changing Linetypes</h2>
Hey, this is great. Let's try the same thing, but this time with Linetypes.

Change your line to Linetype "CENTER2" :

Command: CHANGE
Select objects: 1 found
Select objects: &lt;enter&gt;
Specify change point or [Properties]: P
Enter property to change [Color/Elev/LAyer/LType/ltScale/LWeight/Thickness]: LT
Enter new linetype name &lt;ByLayer&gt;: CENTER2
Enter property to change [Color/Elev/LAyer/LType/ltScale/LWeight/Thickness]: &lt;enter&gt;

Now let's change it back to it's "Bylayer" Linetype :

Command: (setq sel (ssget))
Select objects: 1 found
Select objects: &lt;enter&gt;
&lt;Selection set: 4&gt;

Command: (setq entity (ssname sel 0))
&lt;Entity name: 17db268&gt;

Command: (setq name (entget entity))
((-1 . &lt;Entity name: 17db268&gt;) (0 . "LINE") (330 . &lt;Entity name: 17dacc0&gt;) (5 . "965")
(100 . "AcDbEntity") (67 . 0) (410 . "Model") (8 . "2") (62 . 2) (6 ."CENTER2")
(100 . "AcDbLine") (10 170.804 532.425 0.0) (11 237.122 628.15 0.0) (210 0.0 0.0 1.0))

Command: (setq layer (cdr (assoc 8 name)))
"2"

Command: (setq layerinf (tblsearch "LAYER" layer))
((0 . "LAYER") (2 . "2") (70 . 0) (62 . 2) (6 . "DASHED2"))

This time select Group Code 6 for the default Linetype :

Command: (setq layerltype (cdr (assoc 6 layerinf)))
"DASHED2"

Command: (setq name (append name (list (cons 6 layerltype))))
((-1 . &lt;Entity name: 17db268&gt;) (0 . "LINE") (330 . &lt;Entity name: 17dacc0&gt;) (5 . "965")
(100 . "AcDbEntity") (67 . 0) (410 . "Model") (8 . "2") (62 . 2) (6 ."CENTER2")
(100 . "AcDbLine") (10 170.804 532.425 0.0) (11 237.122 628.15 0.0) (210 0.0 0.0 1.0)
(6 . "DASHED2"))

Command: (entmod name)
(-1 . &lt;Entity name: 17db268&gt;) (0 . "LINE") (330 . &lt;Entity name: 17dacc0&gt;) (5 . "965")
(100 . "AcDbEntity") (67 . 0) (410 . "Model") (8 . "2") (62 . 2) (6 ."CENTER2")
(100 . "AcDbLine") (10 170.804 532.425 0.0) (11 237.122 628.15 0.0) (210 0.0 0.0 1.0)
(6 . "DASHED2"))

Command: (entupd entity)
&lt;Entity name: 17db268&gt;

<h2>An Example Program</h2> 
Now, is that not interesting? Let's put it into practice. Open Notepad and paste this coding into it, saving it as "ColorToLayer.Lsp" :

;CODING BEGINS HERE

(defun c:ColorToLayer ()

;clear the loop control variables
(setq i 0 n 0)

;prompt the user
(prompt "\n Select entities to analyze ")

;get the selection set
(setq sel (ssget))

;get the number of objects
(setq n (sslength sel))

 ;start the loop
 (repeat n

;get the entity name
(setq entity (ssname sel i))

;now get the entity list
(setq name (entget entity))

;if not Bylayer
(if (not (assoc 6 name))

 ;do the following
 (progn

;retrieve the layer name
(setq layer (cdr (assoc 8 name)))

;get the layer data
(setq layerinf (tblsearch "LAYER" layer))
 
;extract the default layer colour
(setq layercol (cdr (assoc 62 layerinf)))

;construct an append the new list
(setq name (append name (list (cons 62 layercol))))

;update the entity
(entmod name)

;update the screen
(entupd entity)

 );progn

);if

;increment the counter
(setq i (1+ i))

 ;loop
 );repeat

 (princ)

);defun

(princ)

;CODING END HERE

You can easily write coding that will do exactly the same for Linetypes and even incorporate the two if you wish. You could even take it a step further and develop a fully fledged Layer Mapping Application Manager. Makes you think doesn't it?

No, I haven't forgotten! The source coding is &lt;a href="files/clay.zip">here.&lt;/a>

<h2>Debugging</h2>

Screams, intermittent yells and bangs, kid's and dogs cowering in the
corner. What is going on? Have I gone nuts? Have I finally cracked and
lost my mind? No, it's just me trying to debug my latest program. Go on laugh, but I'll
guarantee we've all done it, and we'll all do it again.

Debugging can be a real pain. "But it worked just now!"
"Why did it crash?" "The coding looks perfect. I've checked
it line by line 23 times." "There must be something wrong with
my computer."

This tutorial will start off by showing you some of the more common
AutoLisp bugs that I've come across, and then show you a couple of things
to assist you in your debugging efforts. Let's start with some common
bugs.

<h2>Common AutoLISP Bugs</h2>
The simplest and most common is yourself. I don't know if you are aware
of the fact that most programming errors occur between the seat and the
keyboard. Yes, sad but true. So, how do we fix you up? A couple of tips :

&lt;ul>
Don't program or debug when you're tired. Walk away from it. Have a
  break, go shopping. You'll be amazed at how a break from a program
  clears the mind.

Very rarely will it be a computer or system bug. 99.99999 times out
  of a hundred, it's YOU.

The computer or any other sinister source will not change&nbsp; your
  program coding or the variable values therein. YOU DO.
&lt;/ul>

The second type of bug is the &lt;em>syntax&lt;/em> bug. A syntax bug is where
the command is in error. For example when you've miss-spelt an AutoLisp
function or command. e.g. &lt;em>(setq ang1 (angl pt1 pt2))&lt;/em> This is normally quite easy to spot and rectify as AutoLisp will not
recognise the command and your program will stop.

Another VERY common syntax bug is naming variables after an AutoLisp
function or command. The most common? Angle and T ( &lt;em>angle&lt;/em> and &lt;em>t &lt;/em>).
I must have seen these two used as variables a thousand times. Length (&lt;em>length&lt;/em>)
is another very common one.

The third type of bug is the &lt;em>logical&lt;/em> bug. Now this little
beastie has numerous faces and comes in all shapes and forms. The simplest form is when you pass incorrect information to a function.

(setq ang (angle pt1 pt2))

But what happens if pt1 is &lt;em>nil&lt;/em>. Crash! Another good example is trying to pass string values to a function that expects numbers. (and vice-a-versa.) Again, Crash! Check your variable values and data types. To check if a variable is a list, you can use the &lt;em>(type)&lt;/em> command, which returns a variable type. But since a list is not a string you must test it :

( if ( = ( eval v ) LIST)&hellip;

You could also use &lt;em>(listp)&lt;/em> to see whether a variable is a list :

( if ( = T ( listp a ) )&hellip;

&lt;em>(listp)&lt;/em> returns T if it is a list and nil if it isn't.

To test whether a variable is a number, use the same test as earlier
but test for REAL or INT. You can also use &lt;em>(numberp)&lt;/em>, which works
the same as &lt;em>(listp)&lt;/em> on lists. If the variable is a real number or
an integer, it returns T. If not, it returns nil.

To test for a positive or negative number use &lt;em>(minusp)&lt;/em>. This
returns T if a number is negative&nbsp; and nil if it is positive.

Oh, and before I forget, another good example of wrong data types is
confusing radians with degrees. AutoLisp functions use radians, AutoCAD
commands expect degrees.

Loops are another area that seem extremely susceptible to attracting bugs. Have a look at this :

 (while flag
(+ cntr 1)
(program statements here)
( if ( = cntr 5)
 (setq flag nil)
);if
 );while

What is supposed to happen here is that the program will
loop until &lt;em>flag&lt;/em> is set to &lt;em>nil&lt;/em>. &lt;em>cntr&lt;/em> is supposed to be
incremented by one at each loop. But, as you can see from this coding, (at
least I hope you can see), &lt;em>cntr&lt;/em> will never reach the value of 5. It
will always be equal to 1. The correct coding should be :

(setq cntr (+ cntr 1))

System variables can also create untold problems, especially Snaps.
Switch them On only when you need them and Off once finished or you'll
find yourself snapping to some weird and wonderful parts of your drawing. And please remember the golden rule. "Reset the system back to the
way you found it." Before changing system variables, save their
existing values then reset them back at the end of your program. And don't
forget to to include these settings in your error traps so that if
something untoward does happen, your error trap will reset them back to
their original values.

<h2>DCL Bugs</h2>
Now let's have a quick look at some DCL coding bugs.

Have a look at the first one :

(action_tile "cancel" "(done_dialog) (setq bryt 1) (exit)")

I was told that every time the user clicked the "Cancel" button, AutoCAD would freeze. Any idea why? The second example has a similar error :

(action_tile
"accept"
"(progn
(setq rimel (get_tile \"ebrim\"))
(setq maxel (get_tile \"ebmax\"))
(done_dialog)
(setq flag T) (cutt))"
)

The answer to both examples is that they were trying to call a function (exit) and (cutt) from within a dialog. In other words, the dialog was still open when they called the function. An easy error to make and one to look out for. Please everybody, be careful out there!

<h2>Easier Debugging</h2>
Now we'll look at a couple of handy ideas for making your debugging alittle be easier.

When writing an AutoLisp routine it's quite handy to
have the program stop if it encounters an error. It's also nice to be able
to view the variables whilst the program is running to ensure that they
contain the correct values.

In Visual Lisp and Visual Basic you can insert "&lt;em>breakpoints&lt;/em>"
into your coding that do just that and use the Watch window to check on
their values.&nbsp; If you are not using Visual Lisp or Visual Basic this
can still easily be accomplished. Place the following statement within
your coding where you would like your program to stop :

(setq bp (getstring))

This statement will stop your program and only continue once you hit the space bar.

To print the variables, put a &lt;em>(princ)&lt;/em> statement to print the variable before the break point.

(princ variablename)
(setq bp (getstring))

Do remember to remove your print statements and breakpoints on completion of debugging.

You could if you wish turn this little trick into a sub
function. This would be quite handy if you have a large program and can
foresee a lot of debugging. Have a look at this small AutoLisp routine
that changes an objects colour to "Bylayer."

;CODING BEGINS HERE
 
(defun c:clay ()
 
;clear the loop control variables
(setq	i 0 n 0)
 
;prompt the user
(prompt "\n Select entities to analyze ")
 
;get the selection set
(setq sel (ssget))
 
;get the number of objects
(setq n (sslength sel))
 
;start the loop
(repeat n
 
  	;get the entity name
(setq entity (ssname sel i))
 
;now get the entity list
  	(setq name (entget entity))
 
;retrieve the layer name
(setq layern (cdr (assoc 8 name)))
 
;get the layer data
(setq layerinf (tblsearch "LAYER" layern))
 
;extract the default layer colour
(setq layercol (cdr (assoc 62 layerinf)))
  
(bpt)
 
(setq bp (getstring))
 
;construct an append the new list
(setq name (append name (list (cons 62 layercol))))
 
;update the entity
(entmod name)
 
;update the screen
(entupd entity)
 
;increment the counter
(setq i (1+ i))
 
;loop
);repeat
 
(bpt)
 
(setq bp (getstring))
 
(princ)
 
);defun
 
(defun bpt ()
 
(princ i)
(princ "\n")
(princ n)
(princ "\n")
(princ sel)
(princ "\n")
(princ layern)
(princ "\n")
(princ layercol)
(princ "\n")
(princ i)
 
);defun

(princ)
 
;CODING END HERE

I included a sub routine that simply stops the program and lists the
values of selected variables at two places, one within the loop and one at
the end of the program. This way you can easily track the value of the
variables whilst your program is in progress. You could even include this
type of breakpoint function within your error trap whilst debugging.

Another good trick is to always make your variables
"global" at the beginning of a program. If you make them
"local", they may have no value at the end of the program and
you won't be able to see what was in them. The same as for the
breakpoints, remember to declare your variables as "local" after
debugging.

Leaving your variables "global" can though,
create it's own problems whilst debugging. You run various programs that
use the same variable names and suddenly you find your variables
"tripping" all over themselves. This can be difficult to find as
sometimes your program runs perfectly well and the next minute Crash!!
Look out for this one.

I also found this little tit bit at AcadX, which I'm sure they won't mind me sharing with you. Prior to A2K, AutoLisp would dump a bug trace to the command line when an error was encountered. While developers went out of their way to suppress this behavior in a released product, it was a handy tool during the debugging cycle. To get that same behavior in A2K and higher, replace the standard error handler with this one :

(defun errdump (s)
 (vl-bt)
 (princ)
)

Oh, and one more thing! Please remember the power of
your eyes. Watch the screen as your program runs. You can pick up a lot of
clues from watching what happens to entities whilst your program runs.

Well, that's it for debugging. I hope this helped you
and didn't leave you even more frustrated than before. Remember, test, test, test and test.

If you would like to know how "NOT" to write your AutoLisp coding, then &lt;a href="http://mindprod.com/jgloss/unmain.html">check this out&lt;/a>.

<h2>Dictionaries and XRecords</h2>
by Stig Madsen

<h2>Introduction</h2>
Since the dawn of times we've had at least 10 options to save private data
with an AutoCAD drawing. Those were and are the system variables USERI1-5
and USERR1-5 that holds integers and real numbers, respectively. The idea
is OK but the variables are exposed for everyone to use and you shouldn't
assume that your private data will stay intact. Somewhere around release 10 came XData (Extended Entity Data) which is a
rather clever invention. With XData you can attach intelligent information
to entities, and it works flawlessly. There aren't really drawbacks to the
technique, but there are limitations that has to do with the amount and
type of data you can attach.

During release 13 new forms of entities hit the deck in order to keep and
maintain all sorts of data. Among those were Dictionaries and XRecords.
Like XData, Dictionaries can be attached to any kind of entity and you can
even attach XData to them. Additionally, with Dictionaries/Xrecords you
can tell the drawing itself to keep your data because the drawing
maintains a dictionary in which you can save all the data you want.

<h2>Dictionaries</h2>
So what is a Dictionary and how does it work? Instead of lengthy
explanations, it'll be much easier to look at one of the many Dictionaries
that AutoCAD itself uses. Later we''ll briefly look at how to make our own
simple Dictionary, add an Xrecord to it and save them both with the
drawing.

So, fire up AutoCAD and pay attention. As mentioned, the drawing maintains
a Dictionary that is always present. This is known as the 'named object
dictionary' (although I prefer the term 'main dictionary'). In VBA lingo
it's a collection object and like all other collections it just holds a
series of other objects. In VBA it is accessed through the document object
and in AutoLISP it's accessed by one function only, NAMEDOBJDICT :

Command: (setq mainDict (namedobjdict))
&lt;Entity name: 16a9860&gt;

Command: (entget mainDict)
((-1 . &lt;Entity name: 16a9860&gt;) (0 ."DICTIONARY")
(330 . &lt;Entity name: 0&gt;) (5 . "C") (100 . "AcDbDictionary")
(280 . 0) (281 . 1) (3 . "ACAD_GROUP")(350 . &lt;Entity name: 16a9868&gt;)
(3 . "ACAD_LAYOUT") (350 . &lt;Entity name: 16a98d0&gt;)
(3 . "ACAD_MLINESTYLE") (350 . &lt;Entity name: 16a98b8&gt;)
(3 . "ACAD_PLOTSETTINGS") (350 . &lt;Entity name: 16a98c8&gt;)
(3 . "ACAD_PLOTSTYLENAME") (350 . &lt;Entity name: 16a9870&gt;))

By looking at the entity list of the main Dictionary, the most important
thing about Dictionaries becomes clear: they are complete entities by
themselves. They are not fragments of data attached to other entities like
XData are.

However, the Dictionary itself is not where you will store your raw data,
- it is merely a container for other objects that in turn can hold the
data. The main dictionary above shows 5 such objects. Its components are
given by a unique name in group 3. Corresponding entity names are given by
groups 350 that follow, but when referencing an object in a Dictionary it
should be done by name only. For example, to reference the "ACAD_MLINESTYLE"
object, use DICTSEARCH :

Command: (setq mlineDict (dictsearch (namedobjdict) "ACAD_MLINESTYLE"))
((-1 . &lt;Entity name: 16a98b8&gt;) (0 . "DICTIONARY") (5 . "17")
(102 . "{ACAD_REACTORS") (330 . &lt;Entity name: 16a9860&gt;) (102 . "}")
(330 . &lt;Entity name: 16a9860&gt;) (100 . "AcDbDictionary") (280 . 0)
(281 . 1) (3 . "Standard") (350 . &lt;Entity name: 16a98c0&gt;))

This member of the main Dictionary is a Dictionary itself. It holds all
the mline styles that are available. Any style that is created with
MLSTYLE is added to the "ACAD_MLINESTYLE" Dictionary. To explore
a specific style we have to dig deeper and because we are dealing with
Dictionaries we can use DICTSEARCH again - this time by searching the
recently returned Dictionary :

Command: (setq mlineStd (dictsearch (cdr (assoc -1 mlineDict)) "Standard"))
((-1 . &lt;Entity name: 16a98c0&gt;) (0 . "MLINESTYLE") (5 . "18")
(102 . "{ACAD_REACTORS") (330 . &lt;Entity name: 16a98b8&gt;) (102 . "}")
(330 . &lt;Entity name: 16a98b8&gt;) (100 . "AcDbMlineStyle") (2 . "STANDARD")
(70 . 0) (3 . ") (62 . 256) (51 . 1.5708) (52 . 1.5708) (71 . 2) (49 . 0.5)
(62 . 256) (6 . "BYLAYER") (49 . -0.5) (62 . 256) (6 . "BYLAYER"))

Now we are getting somewhere! All properties of the mline style
"Standard" are exposed in all their glory. Feel free to look up
all properties in the DXF Reference. Want to change the color of
multilines? Just SUBSTitute group 62 and ENTMOD the style as usual :

Command: (entmod (subst (cons 62 2)(assoc 62 mlineStd) mlineStd))
((-1 . &lt;Entity name: 16a98c0&gt;) &hellip;etc&hellip; (62 . 2) &hellip;etc&hellip; (62 . 2) &hellip;etc&hellip;)

Ok, so a Dictionary is a container that can hold a number of objects. Why
not use existing structures like symbol tables instead of complicating
things? Many reasons, but two reasons come to mind. Symbol tables are
maintained by the people who implemented them and to expand them to hold
every possible custom object is not an option. Secondly, Dictionaries can
be customized in a way that is not possible with symbol tables, and that
opens a range of possibilities only limited by imagination.

Dictionaries and XRecords go hand in hand. Like Dictionaries, XRecords are
handled as named objects and can be manipulated by the same functions that
handle Dictionaries. In the following, we'll try to add our own Dictionary
to the main dictionary. We will also create an XRecord to hold various
informations and add it to our Dictionary.

When dealing with Dictionaries, at one point you will have to consider
ownership. Which object is going to own the Dictionary? Will it hold
generic data for your application or will it hold data that is specific
for some entity or entities? In the first case you will probably use the
main dictionary to save your data with the drawing. If your application is
maintaining data for linetypes, you will probably add an extension
dictionary to the linetype symbol table. Whatever the ownership, the Dictionary is initially created without
ownership and for that purpose we'll use the function ENTMAKEX. It works
like ENTMAKE, but it creates the entity without an owner - and it returns
an entity name instead of an entity list. Let's make a function that adds
our own Dictionary to the main dictionary. In this example we will name it
"OUR_DICT" :

(defun get-or-create-Dict (/ adict)
 
;;test if "OUR_DICT" is already present in the main dictionary
(if (not (setq adict (dictsearch (namedobjdict) "OUR_DICT")))
 
  ;;if not present then create a new one and set the main
  ;; dictionary as owner
  (progn
 
(setq adict (entmakex '((0 . "DICTIONARY")(100 . "AcDbDictionary"))))
 
;;if succesfully created, add it to the main dictionary
(if adict (setq adict (dictadd (namedobjdict) "OUR_DICT" adict)))
  )
 
  ;;if present then just return its entity name
  (setq adict (cdr (assoc -1 adict)))
 
)
 
)

If you want to see what happens to the dictionary when
added to an owner, then stop the routine right after ENTMAKEX and use
ENTGET to investigate the newly created entity. Notice that the owner in
group code 330 will not be specified. After using DICTADD the owner in
group 330 will be the main dictionary.&lt;br>
Right now we have placed a Dictionary named "OUR_DICT" in the
main dictionary. To check if it succeeded we can investigate the main
dictionary :

Command: (entget (namedobjdict))
((-1 . &lt;Entity name: 16a9860&gt;) (0 . "DICTIONARY") &hellip;etc&hellip;
(3 . "ACAD_PLOTSTYLENAME") (350 . &lt;Entity name: 16a9870&gt;)
(3 . "OUR_DICT") (350 . &lt;Entity name: 16a8da0&gt;))

And there it is! But what good does it do us? It just sits there and
doesn't hold any data. Well, let's say we want to save data for a routine
that creates annotations - for example a text style, a layer name and a
text height. Simple stuff, but it'll suffice for the purpose of
illustration. With XRecords we can create an entity that can hold any
possible data within the range of defined data types. Unlike XData it uses
regular group codes to save data. All group codes (except internal data like code 5 and the negative codes)
can be used. Of course, the data types that are defined for the specific
group codes have to be respected. This means that, for example, a code 70
cannot hold anything else than a 16-bit integer and so on. Code values can
be examined in the DXF Reference.

<h2>XRecords</h2>
An XRecord is created in much the same way as a Dictionary. First we'll
see if it already exists, then create it without an owner with ENTMAKEX
and lastly add it to our custom Dictionary. Again, we will name it in
order to retrieve it by name. In this example it will be called "OUR_DICT".
Both name and initial values are hardcoded into the function - in the real
world we would probably make this a generic function and specify name and
values as arguments.

(defun get-or-make-Xrecord (/ adict anXrec)
 
(cond
 
  ;;first get our dictionary. Notice that "OUR_DICT" will be
  ;;created here in case it doesn't exist
  ((setq adict (get-or-create-Dict))
 
   (cond
 
 ;;if "OUR_DICT" is now valid then look for "OUR_VARS" Xrecord
 ((not (setq anXrec (dictsearch adict "OUR_VARS")))
 
;;if "OUR_VARS" was not found then create it
(setq anXrec (entmakex '((0 . "XRECORD")
(100 . "AcDbXrecord")
(7 . "Arial")
(8 . "A09--T-")
(40 . 2.0)
)
 )
)
 
;;if creation succeeded then add it to our dictionary
(if anXrec (setq anXrec (dictadd adict "OUR_VARS" anXrec)))
 )
 
 ;;if it's already present then just return its entity name
 (setq anXrec
 
(cdr (assoc -1 (dictsearch adict "OUR_VARS")))
 )
   )
  )
)
)

Now we have an XRecord that contains three different data:
a text style name in group code 7, a layer name in group code 8 and a text
height in group code 40. All codes are chosen with respect to normal
convention, but any code that can be associated with the data type in
question can be used. The structure from which to access our data will now
be like this :

Named object dictionary=  Dictionary (owner = the drawing)
&gt; OUR_DICT     =  Dictionary (owner = named object dictionary)
&gt; OUR_VARS =  Xrecord    (owner = OUR_DICT)
   (7 . "Arial")     =    Egenskab i Xrecord
   (8 . "A09-T-")    =    Egenskab i Xrecord
   (40 . 2.0)  =    Egenskab i Xrecord

The only thing that remains is to read the data :

(defun getvars (/ vars varlist)
 
;;retrieve XRecord "OUR_VARS" from dictionary "OUR_DICT"
;;which in turn calls both functions above
(setq vars (get-or-make-Xrecord))
 
;;if our Xrecord is found, then get values in group code 7, 8 and 40
(cond (vars
 (setq varlist  (entget vars))
 (setq txtstyle (cdr (assoc 7 varlist)))
 (setq txtlayer (cdr (assoc 8 varlist)))
 (setq txtsize  (cdr (assoc 40 varlist)))
)
 
;;otherwise return nil
(T nil)
)
)

Because of the naming scheme, Dictionaries work much like symbol tables
in terms of accessing entries. In addition to DICTSEARCH there's also a
function, DICTNEXT, to iterate through all entries in a Dictionary. It
works like TBLNEXT - here shown by iterating through the main dictionary :

(defun C:LISTDICTS (/ maindict adict)
 
(setq maindict (namedobjdict))
 
(while (setq adict (dictnext maindict (not adict)))
 
  (princ (cdr (assoc -1 adict)))
 
  (princ (strcat "\t(type = " (cdr (assoc 0 adict)) ")\n")
 
  )
 
)
 
(princ)
 
)

Command: listdicts
&lt;Entity name: 185c0d0&gt; (type = DICTIONARY)
&lt;Entity name: 185f4b8&gt; (type = DICTIONARY)
&lt;Entity name: 185c0d8&gt; (type = DICTIONARY)
&lt;Entity name: 185f4a8&gt; (type = ACDBDICTIONARYWDFLT)
&lt;Entity name: 18c4320&gt; (type = DICTIONARY)
&lt;Entity name: 18c3d10&gt; (type = XRECORD)

There're also functions to rename a Dictionary, DICTRENAME, and to remove
a Dictionary, DICTREMOVE. The latter simply removes its entry from the
owner, or in other words: detaches it from the owner. It doesn't delete it
unless the owner is "ACAD_GROUP" or "ACAD_MLINESTYLE".
Sometimes when updating a Dictionary it's easier to remove/delete it and
replace it with a new entry, but that will be for your pleasure to
explore.

If you gained some understanding of Dictionaries and XRecords by now then
I'll throw in a little assignment: Figure out how you can add the XRecord
directly to the main dictionary without first creating a Dictionary!

<h2>Tool System Primer</h2>
by Chris Yanchar

You need to be careful in your customizations of tools and tool palettes. Here are some basics&hellip;

<h2>Stock Tool Catalog (aka. Registered Tools)</h2>
In your C:\Documents and Settings\&lt;Username&gt;\Application Data\Autodesk\AutoCAD 2004\R16.0\enu\Support\RegisteredTools\ folder there is a file called AcTpTools.atc. This is the catalog of registered tools for the application. For AutoCAD I believe there are currently three "tool types" (Hatch Tool, Block Tool, and the internal/unofficial Command Tool). ADT expands on this with about 30 different tool types.

When a new tool type is added to the system it will be added into the stock tool catalog and registered with the system. Each application, including 3&lt;sup>rd&lt;/sup> parties, will have their own stock tool catalog.

Here is what one of the stock tools in the AutoCAD stock catalog looks like :

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;StockTool&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ItemID
idValue="{AF0F641B-9CCE-4474-8582-EFE0A38410FC}"/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Properties&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ItemName
src="AcTpCatalogRes.dll"
resource="185"/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/Properties&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Source
idValue="59a63456-0025-4ea0-9cb2-608916d5177c"/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Object&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ComClass&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;CLSID
idValue="{AF0F641B-9CCE-4474-8582-EFE0A38410FC}"/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/ComClass&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Module&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;File&gt;AcTcTools.arx&lt;/File&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/Module&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/Object&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/StockTool&gt;

ItemID: is a unique GUID for that tool type. Every instance of that tool type (e.g. Hatch Tool) will refer to that stock tool by its GUID.

Properties: is that basic set of data you see when you look at the Tool Editor in the UI. In the above case I believe the name of the tool type is in a resource dll for easy localization purposes, and then gets created into the tool name you see for your locale. Of course when you manually rename a tool, that name is saved instead for that instance. This dll also holds the default image for the tool.

The ComClass value is the GUID in your registry that points AutoCAD to the right dlls to actually run the code for the tool.

Below is a typical stock tool from ADT. There are some similarities.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--AEC
Door--&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;StockTool&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ItemID
idValue="6A56F31F-3F7B-4f8e-B10D-39433621B3C0"/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Properties&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ItemName&gt;Door&lt;/ItemName&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Description&gt;Creates
a Door&lt;/Description&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/Properties&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Object&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ComClass&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;CLSID
idValue="6A56F31F-3F7B-4f8e-B10D-39433621B3C0"/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/ComClass&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/Object&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/StockTool&gt;

<h2>Tool Instance</h2>
Every tool in the system is unique. When you copy a tool through the UI it will be assigned a unique GUID, or Item ID. Be careful just blindly cutting and pasting xml to create new tools. Either do it through the UI or get a hold of a GUID generator program. 

As for the Stock Tools, the &lt;Properties/&gt; node contains all the basic tool info that you assign from the Tool Editor. Only those elements that are actually in use are written out.

Each time you copy a tool through the UI a unique image is created in the form &lt;tool type&gt;_&lt;Tool GUID&gt;.ext. Since the image is auto-generated from the tool data it is really just a visual expression of that data. So, if you manually specify several tools to point to the same image, don't be surprised if deleting one suddenly renders the others with a blank image.

Image format: We chose to use PNGs because they have an alpha channel to support the tool images having a transparent background. They are also a lossless compression format.

In the example below you will see how this tool instance refers to the StockTool. This is the same one from above.

The &lt;Data\&gt; node is just that, all the data that you specify for that tool; in the example below it is all the data to describe the solid fill Pantone hatch.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Tool&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ItemID
idValue="{74CC8347-BEA2-46D7-B855-86700A2FD640}"/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Properties&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ItemName&gt;PANTONE
15-0525 TP&lt;/ItemName&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Images&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Image
cx="32"
cy="32"
src="Images\Hatch
tool_8FC7645E-5F37-4200-8D7A-086354BBFB76.PNG"/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Image
cx="64"
cy="64"
src="Images\Hatch
tool_8FC7645E-5F37-4200-8D7A-086354BBFB76 (1).PNG"/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/Images&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Description&gt;Creates
a solid fill hatch using PANTONE 15-0525 TP&lt;/Description&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Time
createdUniversalDateTime="2002-11-06T04:06:28"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
modifiedUniversalDateTime="2002-11-06T04:06:28"/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/Properties&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Source/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;StockToolRef
idValue="{AF0F641B-9CCE-4474-8582-EFE0A38410FC}"/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Data&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;GeneralProperties&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Color&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;BasicPropInfo&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;PropValue
unspecified="FALSE"
valueType="2"
value="0"/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/BasicPropInfo&gt;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;CreateInfo&gt;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;AcCmColor
mRGB="3266557304"&gt;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ColorName&gt;PANTONE
15-0525 TP&lt;/ColorName&gt;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;BookName&gt;PANTONE(R)
a &amp;amp; i-paper&lt;/BookName&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/AcCmColor&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/CreateInfo&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/Color&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Layer&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;BasicPropInfo&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;PropValue
unspecified="TRUE"
valueType="1"/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/BasicPropInfo&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/Layer&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Linetype&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;BasicPropInfo&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;PropValue
unspecified="TRUE"
valueType="1"/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/BasicPropInfo&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/Linetype&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;LinetypeScale&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;BasicPropInfo&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;PropValue
unspecified="TRUE"
valueType="3"
value="0"/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/BasicPropInfo&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/LinetypeScale&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;PlotStyle&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;BasicPropInfo&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;PropValue
unspecified="TRUE"
valueType="1"/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/BasicPropInfo&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/PlotStyle&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;LineWeight&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;BasicPropInfo&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;PropValue
unspecified="TRUE"
valueType="2"
value="0"/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/BasicPropInfo&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/LineWeight&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/GeneralProperties&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Hatch&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;HatchType&gt;Predefined&lt;/HatchType&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;PatternName&gt;SOLID&lt;/PatternName&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;SourceFile&gt;%INSTALL_DIR%\UserDataCache\Support\acad.pat&lt;/SourceFile&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Angle&gt;0&lt;/Angle&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Scale&gt;1&lt;/Scale&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Spacing&gt;1&lt;/Spacing&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;PenWidth&gt;100&lt;/PenWidth&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Double&gt;0&lt;/Double&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;BlockExtent&gt;0.5&lt;/BlockExtent&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/Hatch&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/Data&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/Tool&gt;

<h2>Tool Palettes</h2>
Tool palettes essentially have the same structure: a unique ItemID, a Properties node for the name/etc., and then all the tools contained on it.

&lt;b style="mso-bidi-font-weight: normal">&nbsp;&lt;/b>&lt;Palette&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ItemID
idValue="{EAAE2E08-02C4-4ABC-9B91-AF4C209CEAC9}"/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Properties&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ItemName&gt;General
Drafting&lt;/ItemName&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Images/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Description&gt;This
palette contains a sampling of basic 2D drafting tools&lt;/Description&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Time
createdUniversalDateTime="2002-11-06T21:45:34"
modifiedUniversalDateTime="2002-11-06T21:45:34"/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/Properties&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Source/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Tools&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Tool&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ItemID
idValue="{2DDBB344-97D8-4085-84FD-1552F2F67430}"/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Properties&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ItemName&gt;PANTONE
8001 C&lt;/ItemName&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Images&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Image
cx="32"
cy="32"
src="Images\Hatch
tool_FEDCC8B5-B55A-441D-8CA4-4720592B0494.PNG"/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Image
cx="64"
cy="64"
src="Images\Hatch
tool_FEDCC8B5-B55A-441D-8CA4-4720592B0494 (1).PNG"/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/Images&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Description&gt;Creates
a solid fill hatch using PANTONE 8001 C&lt;/Description&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Time
createdUniversalDateTime="2002-11-06T04:06:28"
modifiedUniversalDateTime="2002-11-06T04:06:28"/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/Properties&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Source/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;StockToolRef
idValue="{AF0F641B-9CCE-4474-8582-EFE0A38410FC}"/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Data&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;GeneralProperties&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Color&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;BasicPropInfo&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;PropValue
unspecified="FALSE"
valueType="2"
value="0"/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/BasicPropInfo&gt;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;CreateInfo&gt;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;AcCmColor
mRGB="3263463287"&gt;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ColorName&gt;PANTONE
8001 C&lt;/ColorName&gt;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;BookName&gt;PANTONE(R)
metallic coated&lt;/BookName&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/AcCmColor&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/CreateInfo&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/Color&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Layer&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;BasicPropInfo&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;PropValue
unspecified="TRUE"
valueType="1"/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/BasicPropInfo&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/Layer&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Linetype&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;BasicPropInfo&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;PropValue
unspecified="TRUE"
valueType="1"/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/BasicPropInfo&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/Linetype&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;LinetypeScale&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;BasicPropInfo&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;PropValue
unspecified="TRUE"
valueType="3"
value="0"/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/BasicPropInfo&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/LinetypeScale&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;PlotStyle&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;BasicPropInfo&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;PropValue
unspecified="TRUE"
valueType="1"/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/BasicPropInfo&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/PlotStyle&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;LineWeight&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;BasicPropInfo&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;PropValue
unspecified="TRUE"
valueType="2"
value="0"/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/BasicPropInfo&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/LineWeight&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/GeneralProperties&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Hatch&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;HatchType&gt;Predefined&lt;/HatchType&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;PatternName&gt;SOLID&lt;/PatternName&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;SourceFile&gt;%INSTALL_DIR%\UserDataCache\Support\acad.pat&lt;/SourceFile&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Angle&gt;0&lt;/Angle&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Scale&gt;1&lt;/Scale&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Spacing&gt;1&lt;/Spacing&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;PenWidth&gt;100&lt;/PenWidth&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Double&gt;0&lt;/Double&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;BlockExtent&gt;0.5&lt;/BlockExtent&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/Hatch&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/Data&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/Tool&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/Tools&gt;
&lt;/Palette&gt;

&nbsp;

<h2>Profiles and the Internal Workspace Catalog</h2>
Each AutoCAD Profile has associated with it an .aws file. This xml file specifies :

&lt;ul>
where to store the tools and palettes associated with that profile (WorkspaceCatalogPath)
all the tool palettes associated with the Tool Palette Set
the UI info specific to that user :
&lt;ul style="font-size:100%;list-style:circle">
  current tab
  palette set transparency
  size and position of the palette set
  title bar justification and docked state
  auto-hide state
  &lt;/ul>

the GUID of each tool palette
the order of each tool within the palette
&lt;/ul>

All this allows you to set up Profiles where each user can be pointing to the same tool palettes, but each user stores their own UI/personal preferences.

In the Options dialog under Files, you will see that you can change the location from which to store/retrieve tool palettes from. One use-case would be a different profile for different projects, each pointing to a unique folder in which to store your project-specific tool palettes.

<h2>Adding Tools and Tool Palettes from Outside AutoCAD</h2>
In AutoCAD, via the Customize dialog you can export out a palette and import it into another profile. An .xtp file is essentially a tool palette file with the UI info saved with it that was from the workspace catalog.

You can also import a single tool or tool palette by dropping the .atc file from File Explorer.

Lastly, you can package tools and tool palettes in i-Drop packages and deliver them over the web. The i-Drop object in your main html file would be something like :

&nbsp;&nbsp;&nbsp;&nbsp;&lt;object
name="idrop"
classid="clsid:21E0CB95-1198-4945-A3D2-4BF804295F78"
width="16"

&nbsp;&nbsp;&nbsp;height="16"
align="right"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;param
name="background"
value="../images/background.jpg"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;param
name="proxyrect"
value="0,0,
16,16"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;param
name="griprect"
value="0,
0, 16,16"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;param
name="package"
value="./Tool
Palettes/Idrop-Annotation.xml"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;param
name="validate"
value="1"&gt;
&nbsp;&nbsp;&nbsp;&lt;/object&gt;

The i-Drop package that is referred to above "./Tool Palettes/Idrop-Annotation.xml" would be something like the following, where the dataset and datafile refers to the actual .atc file for the individual palette. For tools the clipformat is :

"CF_IDROP.XML_ACTCUI_TOOL"

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--
xmlns="x-schema:idrop-schema.xml"&nbsp;--&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;proxy
defaultsrc="../images/iDropButton.gif"
/&gt;

&nbsp;&nbsp;&nbsp;&nbsp;&lt;dataset
defaultsrc="Tool
Palettes/Annotation_0656B653-D7C2-41BE-B55B-ADFAFD56E6E3.atc
"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;datasrc
clipformat="CF_IDROP.XML_ACTCUI_PALETTE"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;datafile
src="Tool
Palettes/Annotation_0656B653-D7C2-41BE-B55B-ADFAFD56E6E3.atc"/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&lt;/datasrc&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/dataset&gt;
&lt;/package&gt;

<h2>Adding a New Tool Type</h2>
This aspect is probably beyond the main user group here, but there is also functionality in the 3&lt;sup>rd&lt;/sup> Party API's that will allow 3&lt;sup>rd&lt;/sup> parties to create new tool types, which can also be delivered via the  web. The process goes something like this :


User drops a tool from a 3&lt;sup>rd&lt;/sup> Party's website that is actual new functionality, in other words an "unregistered" tool. All that is downloaded is the basic tool properties: name, image, etc. and a link to an MSIEXEC file back on the vendor's website.

AutoCAD will inform the user that it is a new tool and do they wish to install now or defer to later.

When they choose to install the new tool, the system will download the MSI installer and install the tool. Now that tool is registered with the tool system and part of the user's stock tool catalog.
&lt;/ol>

And, that's all. I hope this explains a bit more of the details and gets you all even more excited about the possibilities ahead.

<h2>Polyline Bulges - Part 1</h2>

Bulges are something that women have (mostly to please the opposite sex it seems) and something that guys try to get by placing socks in strategic places. At least until they get older. Which is the time they tend to develop bulges in not so strategic places. In other words: bulges are all about curvature.

In AutoCAD, bulges are used in shapes and in arc segments of polylines. This article only deals with polyline bulges, and because polyline bulges are describing circular arcs, let's first look at the geometry of a circular arc.

<img src="/autolisp/tutorials/images/angle_1.jpg">

Because a circular arc describes a portion of the circumference of a circle, it has all the attributes of a circle:

&lt;ul>
Radius (r) is the same as in the circle the arc is a portion of.
Center point (P) is also the same as in the circle.
Included angle (&theta;). In a circle, this angle is 360 degrees.
Arc length (le). The arc length is equal to the perimeter in a full circle.
&lt;/ul>

Adding to these attributes are some that are specific for an arc:

&lt;ul>
Start point and end point (P1 and P2) a.k.a. vertices (although sometimes it is practical to talk about specific points that a circle passes through, there are no distinct vertices on the circumference of a circle).
Chord length (c). An infinite amount of chords can be described by both circles and arcs, but for an arc there is only one distinct chord that passes through its vertices (for a circle, there is only one distinct chord that passes through the center, the diameter, but it doesn't describe any specific vertices).
Given two fixed vertices, there is also a specific midpoint (P3) of an arc.
The apothem (a). This line starts at the center and is perpendicular to the chord.
The sagitta (s) a.k.a. height of the arc. This line is drawn from the midpoint of an arc and perpendicular to its chord.
&lt;/ul>

Except for the arc itself, an arc can describe two distinct geometric forms: Circular segment and circular sector. Both figures includes all of the attributes above, but for doing calculations with bulges, we'll mostly use the piece of pie that the arc cuts out of a circle, the circular sector.

So, what is a bulge for a circular arc and how is it defined? In AutoCAD's online help reference, it says about bulges for polylines:

&lt;blockquote>The bulge is the tangent of 1/4 of the included angle for the arc between the selected vertex and the next vertex in the polyline's vertex list. A negative bulge value indicates that the arc goes clockwise from the selected vertex to the next vertex. A bulge of 0 indicates a straight segment, and a bulge of 1 is a semicircle.&lt;/blockquote>

What does this mean and how can an arc be defined without even knowing the radius - or at least a chord length? It says that the only information given for arc segments in polylines are two vertices and a bulge.

Well, it also says that the bulge has something to do with the tangent of a quarter of the included angle of an arc. That must be a clue of how to obtain the angle. In fact, once you have a bulge value, you can very quickly retrieve the included angle by inverting the above statement. Simply use the built-in function ATAN to get an angle and multiply it by 4 in order to get the included angle:

(* 4.0 (atan 0.57735))
2.09439

So, a bulge of 0.57735 is describing an included angle of 2.09439 radians (which is 120.0 degrees, by the way). Try it out for yourself. Start drawing a lightweight polyline, type "A" for arc, then "A" again for Angle and "120.0" for the included angle. Drop the endpoint somewhere, leave the polyline command and type this at the command line:

Command: (setq ent (entget (entlast)))
((-1 . &lt; Entity name: 7ef844f8&gt;) (0 . "LWPOLYLINE") (330 . &lt; Entity name: 
7ef5ccf8&gt;) (5 . "31F") (100 . "AcDbEntity") (67 . 0) (410 . "Model") (8 . "0") 
(100 . "AcDbPolyline") (90 . 2) (70 . 0) (43 . 0.0) (38 . 0.0) (39 . 0.0) (10 
-566.044 916.408) (40 . 0.0) (41 . 0.0) (42 . 0.57735) (10 -485.424 1075.7) (40 
. 0.0) (41 . 0.0) (42 . -7.40144) (210 0.0 0.0 1.0))

Command: (setq bulge (cdr (assoc 42 ent)))
0.57735

Now you have a bulge value for the arc segment in the polyline, and you can try out the formula above.

OK, fine. But why is the bulge 1/4 of the included angle and where does the tangent fit in? There are many ways to explain this. One is shown below. The figures show a circle with a central angle describing an arc and we'll try to show that the yellow angles &epsilon; and &sigma; are exactly one quarter of the cyan central angle &theta;.

<img src="/autolisp/tutorials/images/bulge_1.jpg" width="731" height="290">

If the full angle is cut in half - as shown with the blue angle &eta; at figure 2 - we get an isosceles triangle (green) where the angles &phi; and &tau; are equal. Because the sum of angles in a triangle is always 180 degrees, we now know that the angles &phi; and &tau; are:

&#966; = &#964; = (180 - &#952;/2)/2  =&gt;  &#966; = 90 - &#952;/4

Now look at the chord from P1 to P2 in figure 3. Together with the red legs of angle &theta; it also forms an isosceles triangle, and therefore &gamma; is equal to &xi;. The top angle is the full angle of &theta;, so &gamma; and &xi; become equal to:

&#947; = &#958; = (180 - &#952;)/2  =&gt;   &#947; = 90 - &#952;/2

Thus, the yellow angle &epsilon; must be the magenta angle &phi; minus the orange angle &gamma;. In other words, &epsilon; is a quarter of the included angle &theta;:

&#949; = (90 - &#952;/4) - (90 - &#952;/2)  =&gt;  &#949; = &#952;/2 - &#952;/4 = &lt;strong>&#952;/4&lt;/strong>

The bulge is describing how much the arc "bulges out" from the vertices, i.e. the height of the arc (the sagitta (s), or the distance P3 to P4 in figure 4). The height forms a leg of a right-angled triangle that has an exact angle of 1/4 of the included angle (see the yellow triangle P-P2-P3 in figure 4) and because tangent is describing the ratio between the legs in a right-angled triangle, it's easy to describe the geometry with this one angle:

sin &#949;/cos &#949; = &lt;strong>tan &#949;&lt;/strong>

<img src="/autolisp/tutorials/images//bulge_2.jpg">

We could also find tangent of angle &epsilon; by simply dividing the opposite leg with the adjacant leg &mdash; which means the sagitta, s, divided by half the distance of the chord, c, &mdash; but not knowing s and having the tangent of &epsilon; already, we would rather want to find s:

s = c/2 * tan(&#949;)

Given that  bulge = tan(&epsilon;), we get

s = c/2 * bulge

Radius of the arc can now be found with this formula:

r = ((c/2)&lt;sup>2&lt;/sup>+s&lt;sup>2&lt;/sup>)/2*s

The sign of a particular bulge is important for the way it's defined in relation to the vertices. If a bulge is positive it means that the arc is measured counterclockwise from the starting vertex to the end vertex. If a bulge is negative it means that the arc runs the other way round, &mdash; it's measured clockwise. The system variable ANGDIR has no influence on this.

Therefore all the formulas above has to be concerned about the absolute value of the bulge instead of the actual value &mdash; or you might end up with a negative radius. In the code below we will find the center point. There are many ways to do this, but the method that is chosen here relies on the angles that were defined previously. Subsequently, we will need it to test whether the bulge is postive or negative and act accordingly.

Remember that the orange angle &gamma; in fig. 3 was found to be 90 degrees minus half of the included angle? What happens if we add (or subtract, depending on the arc direction) this angle to the angle between the two known vertices P1 and P2? We get the angle towards the center. Knowing the angle, the radius and the start point of the arc we can find the center point with POLAR.

(setq gamma (/ (- pi theta) 2.0)
phi   (if (&gt;= bulge 0)
(+ (angle p1 p2) gamma)
(- (angle p1 p2) gamma)
)
p     (polar p1 phi r)
)

Another way to find the direction towards the center is to use good old Pythagorus. We already know radius and the chord length, so by using radius as the hypothenuse and half the chord length as a leg in a right-angled triangle, where the apothem is the second leg, it's possible to draw the apothem and find the center point.

(setq c|2  (/ c 2.0))
(setq a    (sqrt (- (expt r 2.0) (expt c|2 2.0)))
midp (polar p1 (angle p1 p2) c|2)
p2   (if (&gt;= bulge 0)
 (polar midp (+ (angle p1 p2) (/ pi 2.0)) a)
 (polar midp (- (angle p1 p2) (/ pi 2.0)) a)
   )
)

By now, enough angles and distances are known to also use other trigonometric functions in order to find the center point without using POLAR, but that has to remain a home assignment for now. Let's get some code up'n'running, utilizing the formulas and methods we just went over. Later we will repeat some of the formulas to use with bulges.

First function will be an ordinary pick-a-polyline function. It contains no magic. The user is merely asked to pick a lightweight polyline and, if successful, it returns a list of all segments on the form (vertex1 bulge vertex2). These segments will later be used to analyze each arc segment in the polyline. Although it only accepts lightweight polylines, there's nothing to prevent you from adjusting it to also accept &lt;a href="/autolisp/tutorials/polylines-and-blocks.php">old-style polylines&lt;/a>.

(defun getPolySegs (/ ent entl p1 pt bulge seg ptlst)
(setvar "ERRNO" 0)
;; repeat request for polyline until user either picks
;; a polyline or exits without picking
(while (and (not ent) (/= (getvar "ERRNO") 52))
  (if (and (setq ent (car (entsel "\nSelect polyline: ")))
 (/= (cdr (assoc 0 (setq entl (entget ent)))) "LWPOLYLINE")
)
(setq ent nil)
  )
)
(cond (ent
 ;; save start point if polyline is closed
 (if (= (logand (cdr (assoc 70 entl)) 1) 1)
   (setq p1 (cdr (assoc 10 entl)))
 )
 ;; run thru entity list to collect list of segments
 (while (setq entl (member (assoc 10 entl) entl))
   ;; if segment then add to list
   (if (and pt bulge)
 (setq seg (list pt bulge))
   )
   ;; save next point and bulge
   (setq pt    (cdr (assoc 10 entl))
   bulge (cdr (assoc 42 entl))
   )
   ;; if segment is build then add last point to segment
   ;; and add segment to list
   (if seg
 (setq seg (append seg (list pt))
 ptlst (cons seg ptlst))
   )
   ;; reduce list and clear temporary segment
   (setq entl  (cdr entl)
   seg   nil
   )
 )
)
)
;; if polyline is closed then add closing segment to list
(if p1 (setq ptlst (cons (list pt bulge p1) ptlst)))
;; reverse and return list of segments
(reverse ptlst)
)

Next function will be our workhorse. It will use everything we now know about retrieving included angle, height of arc, chord length, radius and center point.&lt;br>
The function accepts a list of arguments on the form that corresponds to the segment sublists from the previous function - (vertex1 bulge vertex2). If the argument is acceptable, it will print out information about the arc segment. We'll let the comments in the code take over any further explanation.

(defun getArcInfo (segment / a p1 bulge p2 c c|2 gamma midp p phi r r2 s theta)
;; assign variables to values in argument
(mapcar 'set '(p1 bulge p2) segment)
;; find included angle
;; remember that bulge is negative if drawn clockwise
(setq theta (* 4.0 (atan (abs bulge))))
;; output included angle
(princ (strcat "\n Included angle: "
   (rtos theta)
   " rad ("
   (angtos theta 0)
   " degrees)"
 )
)
;; find height of the arc
(setq c (distance p1 p2)
s (* (/ c 2.0) (abs bulge))
)
;; output height of arc
(princ (strcat "\n Height of arc:  " (rtos s)))
;; output chord length
(princ (strcat "\n Chord length:   " (rtos c)))
;; If this function is used without making sure that the segment
;; is not simply a line segment (bulge = 0.0), it will produce
;; a division-by-zero error in the following. Therefore we want
;; to be sure that it doesn't process line segments.
(cond ((not (equal bulge 0.0 1E-6))
 ;; find radius of arc
 ;; first find half the chord length
 (setq c|2 (/ c 2.0)
 ;; find radius with Pythagoras (used as output)
 r   (/ (+ (expt c|2 2.0) (expt s 2.0)) (* s 2.0))
 ;; find radius with trigonometry
 r2  (/ c|2 (sin (/ theta 2.0)))
 )
 (princ (strcat "\n Radius of arc:  " (rtos r)))
 ;; find center point of arc with angle arithmetic
 ;; (used as output)
 (setq gamma (/ (- pi theta) 2.0)
 phi   (if (&gt;= bulge 0)
   (+ (angle p1 p2) gamma)
   (- (angle p1 p2) gamma)
 )
 p     (polar p1 phi r)
 )
 ;; find center point of arc with Pythagoras
 (setq a    (sqrt (- (expt r 2.0) (expt c|2 2.0)))
 midp (polar p1 (angle p1 p2) c|2)
 p2   (if (&gt;= bulge 0)
  (polar midp (+ (angle p1 p2) (/ pi 2.0)) a)
  (polar midp (- (angle p1 p2) (/ pi 2.0)) a)
)
 )
 ;; output coordinates of center point
 (princ (strcat "\n Center of arc:  "
(rtos (car p))
","
(rtos (cadr p))
  )
 )
)
(T (princ "\n Segment has no arc info"))
)
(princ)
)

To try out these two functions, first draw a lightweight polyline with a couple of arc segments. At the command line, call getPolysegs and assign a variable to the returned list:

Command: (setq myPoly (getPolySegs))
Select polyline: [select a polyline]

If a lightweight polyline was selected, it will return a list of segments. If, for example, the second segment contains a bulge value different from 0.0 then you can call the latter function like this:

Command: (getArcInfo (nth 1 myPoly))
 Included angle: 1.9265 rad (110.3830 degrees)
 Height of arc:  855.2904
 Chord length:   3272.6317
 Radius of arc:  1992.9203
 Center of arc:  34915.2223,21409.8733
 
The last function in this article will bind the two functions together and explore each arc segment in the selected polyline. It will appear in &lt;a href="/autolisp/tutorials/polyline-bulges-part-2.php">part two&lt;/a> &mdash; along with some useful formulas for dealing with bulges.

<h2>Polyline Bulges - Part 2</h2>

Given the two functions getPolySegs and getArcInfo we can now put together a command that inspects all bulges in a polyline.

(defun C:POLYARCS (/ a polysegs seg)
;; make a list of polyline segments of a
;; selected polyline
(cond ((setq polysegs (getPolySegs))
 ;; a is just an informative counter
 (setq a 0)
		;; run thru each segment
 (foreach seg polysegs
   (setq a (1+ a))
		  ;; only process the segment if it's an arc
		  ;; i.e. bulge /= 0.0
   (cond ((not (zerop (cadr seg)))
(princ (strcat "\nSegment " (itoa a) ": "))
					;;
(getArcInfo seg)
   )
   )
 )
)
)
)

Example:

Command: polyarcs
Select polyline:
Segment 2:
 Included angle: 2.9932 rad (171.4974 degrees)
 Height of arc:  1.1422
 Chord length:   2.4605
 Radius of arc:  1.2336
 Center of arc:  -9.4965,14.9290
Segment 4:
 Included angle: 0.9844 rad (56.3997 degrees)
 Height of arc:  0.4201
 Chord length:   3.3447
 Radius of arc:  3.5390
 Center of arc:  -5.8690,19.3390
Segment 5:
 Included angle: 1.6177 rad (92.6872 degrees)
 Height of arc:  0.5787
 Chord length:   2.7043
 Radius of arc:  1.8689
 Center of arc:  -2.1545,17.4054

This concludes the code for now. Below are some useful formulas for dealing with bulges. The picture recaps some geometric details of the circular arc.

<img src="/autolisp/tutorials/images/bulge_3.jpg">

&#952; = (* 4.0 (atan bulge))

&#951; = (/ &#952; 2.0)

&#966; = (+ &#947; &#949;)
= (- (/ pi 2.0)(/ &#952; 4.0))
= (/ (- (* pi 2.0) &#952;) 4.0)
= (- (/ pi 2.0)(atan bulge))

&#947; = (/ (- pi &#952;) 2.0)
= (- (/ pi 2.0)(* 2.0 (atan bulge)))
= (atan (/ a c))

&#949; = (/ &#952; 4.0)
= (atan bulge)
= (atan (/ s c))

c = (distance p1 p2)
= (* 2.0 r (cos &#947;))
= (* 2.0 r (sin (/ &#952; 2.0)))

s = (* (/ c 2.0) bulge)

a = (sqrt (- (expt r 2.0) (expt (/ c 2.0) 2.0)))
  (* r (cos &#951;))

r = (/ (+ (expt (/ c 2.0) 2.0)(expt s 2.0))(* 2.0 s))
= (/ s (* 2.0 (sin &#949;)(cos &#966;)))
= (/ a (cos &#951;))

The center point is found in the code by calculating angles and distances in order to use POLAR. In function getArcInfo are given two methods. One is calculating the apothem as a leg in the triangle P-P2-P4 and setting out the center point from P4. The other is using the angle &gamma; and the radius to set out the point from P1. Both methods have to read the sign of the bulge to know in which direction the center point has to be set out.

Another method could be to view the arc as a part of the circumcircle to triangle P1-P2-P3. The medians to the lines P1-P3 and P2-P3 intersect in the center point. We know the gradients for these medians because both angles are known. E.g. any perpendicular to the line P1-P3 has the gradient (- (/ 1.0 gr)), where gr is the gradient of P1-P3. Once having a point of the median (midpoint of P1-P3) and the grade, it's possible to find the Y-interception and thereby the equation for the median. Doing this for both medians we can use the following formulas for finding the intersection point &mdash; which is the center point for the arc:

xi = - (m1 - m2)/(n1 - n2)
yi = m1 + n1*xi
where
m1 = gradient for median to P1-P3
n1 = Y-interception for median to P1-P3
m2 = gradient for median to P2-P3
n2 = Y-interception for median to P2-P3

There are many other solutions for finding the center point &mdash; among those some shorter trigonometric methods &mdash; but this will have to do for now.

Because the geometry described by the 2 vertices and the bulge is relatively simple, there are many other formulas than those depicted here. The important part is to understand how the bulge is defined and how it relates to the only other two pieces of data given - the vertices. Hopefully this was able to shed a light on some of the definitions.

For more information, refer to : &lt;a href="/reference/sine-and-cosine-functions.php">Unit Circle Definition of Sine and Cosine Functions&lt;/a>

<h2>Saving and Restoring System Variables</h2>

It is good practice (and manners) when writing Lisp routines to restore the system environment to the state that your program found it in on completion of your application. Most AutoLisp routines start and end like this :

(defun c:example ()
(setq oldhigh (getvar "Highlight")
oldsnap (getvar "Osmode")
oldblip (getvar "BlipMode")
oldecho (getvar "Cmdecho")
);setq
 
(setvar "Highlight" 0)
(setvar "Osmode" 517)
(setvar "Blipmode" 0)
(setvar "Cmdecho" 0)
 
Programme statements&hellip;
 
(setvar "Highlight" oldhigh)
(setvar "Osmode" oldsnap)
(setvar "Blipmode "oldblip)
(setvar "Cmdecho" oldecho)
(princ)
);defun
;******************************************************

I must have written statements like this a thousand times in my Lisp routines. The following example is designed to act as a global routine that first stores, then changes specific system variables. On completion of the routine, the function is then called again and all system variables are returned to their previous settings.

(defun varget ()
 
(setq lis '("HIGHLIGHT" "BLIPMODE" "CMDECHO"
	    "BLIPMODE" "OSMODE"))
;store names of system variables
 
(setq  var (mapcar 'getvar lis))
;get the value of the system variables and
;store them as a list
 
(setq var1 '(0 0 0 0 517))
;store the new values of the system variables
 
(setq no 0)
;set counter to zero
 
(repeat (length lis)
;get the number of variables in the list
;to use as the counter control number
 
	(setvar (nth no lis) (nth no var1))
	;set the variables to their new values
 
	(setq no (1+ no))
	;move up one in the list
 
);repeat
 
(princ);finish quietly
 
);defun
 
;***************************************************************
 
(defun varset ()
 
(setq no 0)
;set counter to zero
 
(repeat (length lis)
;get the number of variables in the list
 
	(setvar (nth no lis) (nth no var))
	;reset the variables to their original values
 
	(setq no (1+ no))
	;move up one in the list
 
);repeat
 
(princ);finish quietly
 
);defun
 
;***************************************************************
 
(princ);load quietly

Our Autolisp routine could now look like this :

(defun c:example ()
 
(varget)
;store system variables and then reset them
 
Programme statements&hellip;
 
(varset)
;restore system variables
 
(princ)
);defun
;******************************************************

As you can see, we have reduced the size of our routine by a lot and saved ourselves quite a bit of typing. These two routines could both be loaded from our Acad.Lsp file so that they would be available to all of your routines.

<h2>Date and Time Stamping</h2>

When you plot a drawing (or insert an Xref, etc), it's nice to have
the Date and Time of the plot stamped on the plotted drawing. This is
easily done manually, but wouldn't it be nice to use AutoLisp and have the
Time and Date automatically added to your plots? Here's how you would go
about it.

First, we need to write a few functions that will calculate the Date
and Time and then format them into readable text. Try out the following
functions :

(defun TODAY ( / d yr mo day)
;define the function and declare all variabled local
 
   (setq d (rtos (getvar "CDATE") 2 6)
   ;get the date and time and convert to text
 
  yr (substr d 3 2)
  ;extract the year
 
  mo (substr d 5 2)
  ;extract the month
 
 day (substr d 7 2)
 ;extract the day
 
   );setq
 
   (strcat day "/" mo "/" yr)
   ;string 'em together
 
(princ)
 
);defun
;;;*-------------------------------------------
(defun TIME ( / d hr m s)
;define the function and declare all variables as local
 
   (setq d (rtos (getvar "CDATE") 2 6)
   ;get the date and time and convert to text
 
  hr (substr d 10 2)
  ;extract the hour
 
  m (substr d 12 2)
  ;extract the minute
 
  s (substr d 14 2)
  ;extract the second
 
   );setq
 
   (strcat hr ":" m ":" s)
   ;string 'em together
 
(princ)
 
);defun
;;;*-------------------------------------------

Try the two functions out. Load the functions and type :
&lt;code>(today)&lt;/code>

Lisp should return today's date :
&lt;code>"23/03/99"&lt;/code>

Now try the next function. Type :
&lt;code>(time)&lt;/code>

AutoLisp should return something like :
&lt;code>"11:36:21"&lt;/code>

OK great, we've got the date and time but now we need to add it to
our drawing. The simplest way of doing this is by making use of
attributes.

First we need to create a block containing 3 attributes, namely Date,
Time and Who By. (If you don't know how to create a block with attributes,
please refer to the AutoCad Reference Manual.)

Once you have created your attribute block, it is very easy to write an
AutoLisp routine that inserts the block and automatically calculates and
fills in the attribute data. The following example does just that.

(defun C:TIMESTAMP (/ ss1 count emax en ed blkn found thedate thetime plotby)
;define function and declare variables as local
 
(setvar "HIGHLIGHT" 0)
;switch off highlight
 
(setvar "CMDECHO" 0)
;switch off command echo
 
(setq ss1 (ssget "X" '((0 . "INSERT")(66 . 1))))
;filter for all blocks with attributes
 
(if ss1
;if any are found
 
  (progn
  ;do the following
 
	(setq count 0
	;set the counter to zero
 
   	emax  (sslength ss1)
	;get the number of blocks
 
	);setq
 
	(while (&lt; count emax)
	;while the counter is less than the
	;number of blocks
 
		(setq en   (ssname ss1 count)
		;get the entity name
 
		ed (entget en)
		;get the entity list
 
		blkn (dxf 2 ed)
		;get the block name
 
		);setq
 
		(if (= "STAMP")
		;if the block name is "STAMP"
 
  			(setq	count emax
			;stop the loop
 
			found T
			;set the flag
 
  			);setq
 
  			(setq count (1+ count))
			;if not increment the counter
 
		);end if
 
	);while &amp; if
 
	(if found
	;if the flag is set
 
	(command "ERASE" en ")
	;erase the block
 
	);if
 
   );progn
 
);if
 
(setvar "ATTDIA" 0)
;switch off dialogue boxes
 
(setq thedate (today))
;calculate and format date
 
(setq thetime (time))
;calculate and format time
 
(setq plotby (getvar "LOGINNAME"))
;get the users name

(command "Insert" "Stamp" "0,0" " " " thedate thetime plotby)
;insert the block and fill in the attribute data
 
(setvar "ATTDIA" 1)
;switch the dialogues back on
 
(setvar "HIGHLIGHT" 1)
;switch Highlight On
 
(setvar "CMDECHO" 1)
;switch Cmdecho On
 
(princ)
 
);defun
 
;===============================================================
(defun dxf(code elist)
 
(cdr (assoc code elist))
;finds the association pair, strips 1st element
 
);defun
;===============================================================
(defun TODAY ( / d yr mo day)
   (setq d (rtos (getvar "CDATE") 2 6)
  yr (substr d 3 2)
  mo (substr d 5 2)
 day (substr d 7 2)
   );setq
   (strcat day "/" mo "/" yr)
);defun
;;;*-----------------------------------------------------------
(defun TIME ( / d hr m s)
   (setq d (rtos (getvar "CDATE") 2 6)
  hr (substr d 10 2)
   m (substr d 12 2)
   s (substr d 14 2)
   );setq
   (strcat hr ":" m ":" s)
);defun
;;;*------------------------------------------------------------
(princ)

This routine basically does the following :

First of all, it checks if there are any blocks in the drawing that
contain attributes. If there are, it loops through each block checking if
it has the name "STAMP". If it has, it deletes the block. The
routine then inserts a new "STAMP" block with the updated
attribute data.

After running this routine, you should have a block similar to this in the lower left hand corner of your drawing.

<img src="https://www.afralisp.net/autolisp/tutorials/images/lisp40a.gif">

You can now plot your drawing with the new or updated Date and Time stamp.

You should find it relatively easy to modify this routine to suit any
kind of Date/Time stamp that you would wish to add to a drawing. You could
add a stamp that places the name and path of all Xrefs attached to the
drawing, along with, the date they where added and who added them.

If you would like the source coding for the the Timestamp routine, just
place your mouse &lt;a href="files/lisp40a.zip">here,&lt;/a> say a prayer, and
click&hellip; Enjoy.

<h2>Loading VBA Projects with AutoLISP</h2>

When you load an AutoLisp file you just type (load "MYLISPFILE")
and AutoCAD will find the file and load it, as long as it is located
within the AutoCAD search path.

Loading a VBA Project file though, is slightly different. AutoCAD will
only search the current working directory for the VBA file. The way to get
around this, and to force AutoCAD into searching the AutoCAD search path,
is to use the "Findfile" function.

The following AutoLisp coding will load any VBA Project file that is
within the AutoCAD search path, run the Project and then unload it on
completion.

Thanks to Randall Rath of VBDesign for this idea.

(defun c:ldvb ()
;define function
 
(setvar "CMDECHO" 0)
;switch off command echo
 
(if (findfile "yourproject.dvb")
;if the project file is found
;in your AutoCAD search path
 
   (progn
   ;do the following
 
	(setvar "FILEDIA" 0)
	;switch off dialogue boxes
 
	(command "_vbaload" 
	(findfile "yourproject.dvb"))
	;load the project file
 
	(command "-vbarun" "yourprojectmacro")
	;run the project macro
 
	(command "_vbaunload")
	;unload the file
 
	(setvar "FILEDIA" 1)
	;switch dialogues back on
 
  );progn
 
  (princ "\nyourproject.dvb not found")
  ;if project not found, inform the user
 
);if
 
(setvar "CMDECHO" 1)
;switch command echo back on
 
 (princ)
 ;finish clean
 
);defun
 
(princ "\nyourproject.dvb Loaded")
;inform user
 
(princ "\nType 'Ldvb' to Run")
;tell him how to run it
 
(princ)
;load clean

<h2>Application Data</h2>

Have you ever looked at the ACAD14.CFG (Autocad Configuration) file?

This is simply a text file divided into sections. The only section that you have control over is the [AppData] section. Let's do something with it.

Say you wanted to store 2 bits of information that you use in one of your AutoLisp routines. You would store them like this :

(setcfg "appdata/test/bolt" "M24")
(setcfg "appdata/test/length "90")

After (setcfg must come "appdata" followed by your application name, which must be unique. Following this is the variable tag and then the information you wish to store. If you open the ACAD14.CFG file, this is what the [AppData] section will look like :

[AppData/test]
bolt=4
length=90

To retrieve this data you would use the following syntax :

(setq a (getcfg "appdata/test/bolt"))
(setq b (getcfg "appdata/test/length"))

This would set a to "M24" and b to "90". Now this is great, I hear you say, but were would you use it. Here's a good example for you :

Say you've written a routine that you would like other people to use on
a trial basis, say 5 times. After the 5 times they either pay up, or the
routine ceases to work.

What we are going to do is first write a simple routine.&lt;br>
Then we will write a sub-routine that stores the number of times the
routine is run in the [AppData] section. Next, we will check the number of
times it has been run and then decide whether the limit has expired or
not. Have a look :

;Main function
 
(defun c:test8 ()
(register)
(if flagset
	(alert "\nThe programme will now run.")
);if
 (princ)
)defun
 
;Sub-function
 
(defun register ()
(setq v1 (getcfg "AppData/CadKen/test"))
   (if (= v1 nil)
 (progn
   (setcfg "AppData/CadKen/test" "1")
   (setq v1 (getcfg "AppData/CadKen/test"))
 );progn
   );if
(setq v2 5)
(setq v1 (atoi v1))
   (if (&lt; v1 v2)
 (progn
  (setq v1 (+ v1 1))
  (cond
 		((= v1 1)  (setcfg "AppData/CadKen/test" "1"))
 		((= v1 2)  (setcfg "AppData/CadKen/test" "2"))
 		((= v1 3)  (setcfg "AppData/CadKen/test" "3"))
 		((= v1 4)  (setcfg "AppData/CadKen/test" "4"))
 		((= v1 5)  (setcfg "AppData/CadKen/test" "5"))
 		  );cond
 		  (setq v3 v1)
 		  (setq v3 (rtos (- v2 v1)))
 		  (alert (strcat "\n You Have " v3 " more Loadings Left"))
	  (setq flagset T)  
   	    );progn
    (progn
 		(alert "\nEvalution Period has Expired
 		\n   Contact Kenny Ramage
 		\nndbe51d1@db.za
 		\n     For Licensed Copy")
	(setq flagset nil)
    );progn
   	);if
  (princ)    
);defun
(princ)  

This is a very simple but usefull routine that demonstrates the use of
[AppData]. You would still, of course, have to encrypt or compile your
routine to stop the user simply changing the variable that contains the
usage control number. If you would like the source code, I have included
it &lt;a href="files/test8.zip">here.&lt;/a>

<h2>Macro Recorder</h2>

Another useful aspect to programs such as AutoLISP is their ability to
perform repetitive tasks. For example, suppose you want to be able to record a
series of keyboard entries as a macro. One way to do this would be to use
a series of Getstring functions as in the following :

 (Setq str1 (getstring "\nEnter macro: "))
 
 (Setq str2 (getstring "\nEnter macro: "))
 
 (Setq str3 (getstring "\nEnter macro: "))
 
 (Setq str4 (getstring "\nEnter macro: "))

Each of the str variables would then be combined to form a variable
storing the keystrokes. Unfortunately, this method is inflexible. It
requires that the user input a fixed number of entries, no more and no
less. Also, this method would use memory storing each keyboard entry as a
single variable.

It would be better if you had some facility to continually read keyboard
input regardless of how few or how many different keyboard entries are
supplied. The While function can be used to repeat a prompt and obtain
data from the user until some test condition is met.

Here is the coding for our Macro Recorder :

(defun C:MACRO (/ str1 macro macname)
 
(setq macro '(command))
;start list with command
 
(setq macname (getstring "\nEnter name of macro: "))
;get name of macro
 
  	(while (/= str1 "/")
  	;do while str1 not equal to /
 
 	(setq str1 (getstring "\nEnter macro or / to exit: " ))
 	;get keystrokes
 
(if (= str1 "/")
 
  	(princ "\nEnd of macro ") 
  	;if / then print message
 
  	(Setq macro (append macro (list str1)))
  	;else append keystrokes to list
  ) 
  ;end if macro list
 
 );end while
 
(eval (list 'defun (read macname) '() macro))
;create function
 
 (princ)
 
);end macro
 
(princ)

Now we will use the macro program to create a keyboard macro that changes the last object drawn to layer 3. Do the following :


Draw a diagonal line from the lower left corner of the drawing area to the upper right corner.
 
Load the Macro.lsp file.
 
Enter Macro at the command prompt.
 
At the following prompt:

 
&lt;code>Enter name of macro:&lt;/code>
 
Enter the word "CHLA".

 
At the prompt:

 
&lt;code>Enter macro or / to exit:&lt;/code>
 
Enter the word "CHANGE"

&lt;/ol>
 
The Enter macro prompt appears again. Enter the following series of
words at each Enter macro prompt:

 
Enter macro or / to exit: L
 
Enter macro or / to exit: press return
 
Enter macro or / to exit: P
 
Enter macro or / to exit: LA
 
Enter macro or / to exit: 3
 
Enter macro or / to exit: press return
 
Enter macro or / to exit: press return
 
Enter macro or / to exit: /

This is where the &lt;code>while&lt;/code> function takes action. As you enter each
response to the Enter macro prompt, &lt;code>while&lt;/code> tests to see if you entered a
forward slash. If not, it evaluates the expressions included as its arguments. Once you
enter the backslash, &lt;code>while&lt;/code> stops its repetition. You get the prompt :

End of macro

The input you gave to the Enter macro prompt is exactly what you would
enter if you had used the change command normally. Now run your macro by
entering :

(chla)

The line you drew should change to layer 3.

When Macro starts, it first defines two variables def and macro.

(setq def "defun ")
 
(setq macro '(command))

Def is a string variable that is used later to define the macro. Macro
is the beginning of a list variable which is used to store the keystrokes
of the macro. The next line prompts the user to enter a name for the
macro.

(setq macname (getstring "\nEnter name of macro: "))

The entered name is then stored with the variable macname.

Finally, we come to the &lt;code>while&lt;/code> function.

(while (/= str1 "/")

The &lt;code>while&lt;/code> expression is broken into several lines. The first line
contains the actual while function along with the test expression. In this case, the test compares the variable str1 with the string
"/" to see if they are not equal. So long as str1 is not equal
to "/", &lt;code>while&lt;/code> will execute the arguments that follow the test.
The next four lines are the expressions to be evaluated. The first of
these lines prompts the user to enter the text that compose the macro.

(setq str1 (getstring "\nEnter macro or / to exit: " ))

When the user enters a value at this prompt, it is assigned to the variable str1.

The next line uses an if function to test if str1 is equal to "/".

(if (= str1 "/")

If the test results in T, the next line prints the string :

End of macro
 
(princ "\nEnd of macro ")

This expression prints the prompt End of macro to the prompt line. If the test results in nil, the following line appends the value of str1
to the existing list macro.

(Setq macro (append macro (list str1)))

The &lt;code>append&lt;/code> function takes one list and appends its contents to the
end of another list. In this case, whatever is entered at the Enter macro
prompt is appended to the variable macro. Each time a new value is entered
at the Enter macro prompt, it is appended to the variable macro creating a
list of keyboard entries to be saved.

The next two lines close the if and while expressions.

);end if
 
);end while

The last line combines all the elements of the program into an
expression that, when evaluated, creates a new macro program.

(eval (list (read def) (read macname) '() macro))

The read function used in this expression is a special function that
converts a string value into a symbol. If a string argument to read
contains spaces, read will convert the first part of the string and ignore
everything after the space.

<h2>Working with Areas - Part 1</h2>

The easiest way of calculating areas in AutoCAD is to simply use the Area command. This command though, leaves a lot to be desired when in comes to usage. And the resulting format? Well I'm not going to even mention that. (Hang on, you've got to. That's what this tutorial is all about.) Oops, silly me.

As you have probably noticed, when you use the Area command, it returns the result in the square units of whatever units you are drawing in. eg. If you are drawing in millimeters, it returns the result in square millimeters. No more, and no less. Now this may suit some folk, but me, no way. Even though I work in millimeters, I want the result returned in square meters AND I want to be able to place the area as text, anywhere in the drawing that suits me AND nicely formatted with a little square meter thingymebob at the end.

So, what do we do? Easy, we open notepad and start banging away on the keyboard.

;;;M2 Lisp - Version 1.0 - 2nd August 2001
;;;=============================================================
;;;This function will calculate the area (m2) from
;;;points input by the user. The user then has the
;;;option of placing a text label into the drawing using
;;;the current text style/height at a user defined
;;;insertion point.
;;;=============================================================
;;;Written by Kenny Ramage August 2001
;;;=============================================================
;;;=============================================================
;;;Define Main Function
;;;=============================================================
 
(defun C:M2 ( / os oom laag oec oudosmode p q opp oppm oppma oppmat
	tekst pos pos2 flag1 antw lw)
 
 (setvar "cmdecho" 0)
 
 (command "undo" "m")
 
 (setq oom (getvar "orthomode")
 laag (getvar "clayer")
 oudosmode (getvar "osmode")
 olderr *error*
 *error* opperr
 );setq
 
 (setvar "orthomode" 0)
 (print)
 (prompt "\nArea Lisp V-1.0 Written by Kenny Ramage")
 (prompt "\nPick the corners of the area you want to calculate : ")
 
 (initget 1)
 (setq p (getpoint "\nFrom point : ")
 q (list (car p)(cadr p))
 );setq
 
 (command "layer" "m" "5" "
"pline" q "w" "0" "
 );command
 
 (while (= (getvar "cmdnames") "PLINE")
   (redraw (entlast) 3)
   (prompt "\nTo point [Close/Undo] : ")
   (command pause)
 );while
 
 (command "area" "e" "l")
 
 (setq opp (getvar "area")
 oppm (/ opp 1000000.0)
 oppma (rtos oppm 2 3)
 oppmat (strcat oppma "m")
 tekst (strcat "\nArea = " oppmat "2")
 );setq
 
 (setq lw (entlast))
 
 (command "layer" "m" laag ")
 
 (prompt tekst)
 
 (setq flag1 T)
 
 (while flag1
 
 (setq antw (getstring "\nInsert Area Label? [y/n] &lt;y> : "))
 
 (setq antw (strcase antw))
 
 (if (or (= antw "Y")(= antw "))
 
 (progn
 (if (not (tblsearch "layer" "4"))
   (command "layer" "m" "4" "c" "4" "4" ")
   (command "layer" "t" "4" "on" "4" "u" "4" "s" "4" ")
 );if
 
 (setvar "osmode" 0)
 (setq pos (getpoint "\nInsertion Point : "))
 
 (if (= (cdr (assoc 40 (tblsearch "style"
	 (getvar "textstyle")))) 0)
   (command "text" "j" "c" pos " "0" oppmat)
   (command "text" "j" "c" pos "0" oppmat)
 );if
 
 (setq pos2 (cadr (textbox (entget (entlast))))
 pos2 (list (+ (car pos)(/ (car pos2) 2.0))(+ (cadr pos)(cadr pos2)))
 );setq
 
 (if (= (cdr (assoc 40 (tblsearch "style" 
	 (getvar "textstyle")))) 0)
   (command "text" "j" "tl" pos2 " "0" "2")
   (command "text" "j" "tl" pos2 "0" "2")
 );if
 
 (command "scale" "l" " pos2 ".5")
 
 );progn
 
 );if
 
(if (or (or (= antw "Y")(= antw "N")(= antw ")))
	
	(setq flag1 nil)
);if
 
 );while
 
 (command "erase" lw "
"redrawall"
 );command
 
;;;==================================================
;;;Reset System Variables and Restore Error Handler
;;;=================================================
 
 (setq *error* olderror)
 (command "layer" "m" laag ")
 (setvar "osmode" oudosmode)
 (setvar "orthomode" oom)
 
 (princ)
);defun C:M2
;;;===================================================
;;;Define Error Trap
;;;===================================================
 
(defun opperr (s)
 
(if (/= s "Function cancelled") 
  (princ (strcat "\nError: " s))
);if
 
(setq *error* olderr)
(setvar "osmode" oudosmode)
(setvar "orthomode" oom)
(command "undo" "b"
 "layer" "m" laag "
 "redrawall"
);command
 
);defun opperr
;;;===================================================
(princ)
;;;End Area Lisp
;;;===================================================
;;;==================================================

Load the application and then type "M2" to run. Select the area that you would like to calculate by picking selected points. A polyline will be traced from each point&nbsp; that you have selected. When you have finished, select "C" (Close).

The area will now be displayed at the command line. You will now be given the option to add a label to your drawing if you so wish.

But now we'll get really clever and try and fool AutoCAD into working out the area that we want automatically. Interested? See you in &lt;a href="/autolisp/tutorials/working-with-areas-part-2.php">Part 2&lt;/a>&hellip;

<h2>Working with Areas - Part 2</h2>

Nice to see you back and glad that you could make it.

Where were we? Oh yes. We were going to try and make AutoCAD determine the area to be calculated. Let's see! We could try bribes! We could threaten! Naaw, back to the keyboard&hellip;

;;;M2 Lisp - Version 1.0 - 17th October 2001
;;;=============================================================
;;;This function will calculate an irregular area (m2)
;;;using boundary detection. The user then has the
;;;option of placing a text label into the drawing using
;;;the current text style/height at a user defined
;;;insertion point.
;;;=============================================================
;;;Written by Kenny Ramage October 2001
;;;=============================================================
;;;=============================================================
;;;Define Main Function
;;;=============================================================
 
(defun C:M2A ( / os oom laag oec oudosmode p q opp opp1 oppm oppma oppmat
 tekst pos pos2 flag1 antw lw a b)
 
 (setvar "cmdecho" 0)
 
 (command "undo" "m")
 
 (setq oom (getvar "orthomode")
 laag (getvar "clayer")
 oudosmode (getvar "osmode")
 olderr *error*
 *error* opperr
 );setq
 
 (setvar "orthomode" 0)
 (print)
 (prompt "\nIrregular Area Lisp V-1.0 Written by Kenny Ramage")
  
(setq opp 0.0)
 
(command "Layer" "m" "2" ")
 
(while
 
(setq a (getpoint "\nSelect Internal Point: "))
 
(command "-Boundary" a ")
 
(setq b (entlast))
 
(redraw b 1)
 
 	(command "area" "O" "L")
 
 	(setq opp1 (getvar "area"))
 
(setq opp (+ opp opp1))
 
(redraw b 4)
 
);while
 
 
 (setq oppm (/ opp 1000000.0)
 oppma (rtos oppm 2 3)
 oppmat (strcat oppma "m")
 tekst (strcat "\nArea = " oppmat "2")
 );setq
 
 (command "layer" "m" laag ")
 
 (prompt tekst)
 
 (setq flag1 T)
 
 (while flag1
 
 (setq antw (getstring "\nInsert Area Label? [y/n] &lt;y&gt; : "))
 
 (setq antw (strcase antw))
 
 (if (or (= antw "Y")(= antw "))
 
 (progn
 (if (not (tblsearch "layer" "4"))
   (command "layer" "m" "4" "c" "4" "4" ")
   (command "layer" "t" "4" "on" "4" "u" "4" "s" "4" ")
 );if
 
 (setvar "osmode" 0)
 (setq pos (getpoint "\nInsertion Point : "))
 
 (if (= (cdr (assoc 40 (tblsearch "style"
	 (getvar "textstyle")))) 0)
   (command "text" "j" "c" pos " "0" oppmat)
   (command "text" "j" "c" pos "0" oppmat)
 );if
 
 (setq pos2 (cadr (textbox (entget (entlast))))
 pos2 (list (+ (car pos)(/ (car pos2) 2.0))(+ (cadr pos)(cadr pos2)))
 );setq
 
 (if (= (cdr (assoc 40 (tblsearch "style" 
	(getvar "textstyle")))) 0)
   (command "text" "j" "tl" pos2 " "0" "2")
   (command "text" "j" "tl" pos2 "0" "2")
 );if
 
 (command "scale" "l" " pos2 ".5")
 
 );progn
 
 );if
 
(if (or (or (= antw "Y")(= antw "N")(= antw ")))
	
	(setq flag1 nil)
);if
 
 );while
 
 
;;;========================================================
;;;Reset System Variables and Restore Error Handler
;;;=======================================================
 (setq *error* olderror)
 (command "layer" "m" laag ")
 (setvar "osmode" oudosmode)
 (setvar "orthomode" oom)
 
 (princ)
);defun C:M2A
;;;========================================================
;;;Define Error Trap
;;;========================================================
 
(defun opperr (s)
 
(if (/= s "Function cancelled") 
  (princ (strcat "\nError: " s))
);if
 
(setq *error* olderr)
(setvar "osmode" oudosmode)
(setvar "orthomode" oom)
(command "undo" "b"
 "layer" "m" laag "
 "redrawall"
);command
 
);defun opperr
;;;========================================================
(princ)
;;;End Area Lisp
;;;=======================================================
;;;=======================================================

This time, select a point within the area that you would like to calculate. A boundary box will be drawn around the area you have chosen. You can add to the area if you wish by selecting more points resulting in an accumulation of areas. Again, you have the option of a label being added.

Would you like the source coding for both of these applications? Go on, I bet you do? OK then, position you mouse &lt;a href="files/area.zip">here&lt;/a> and go for it.

<h2>Drawing Setup - Part 1</h2>

This to me, is the one area that all AutoLispers, especially AutoLISP beginners, should be spending their time and energy. A good, well written setup routine can saves hours of draughting time, as well as enforcing drawing office standards.

This tutorial will take you step by step through a simple drawing setup routine which, I hope, you will be able to build on to suit your requirements.

We will start by designing a dialogue interface to choose the type of drawing sheet the draughtsman would like to use. Let's look at the coding for the dialogue box :

setup1 : dialog {				//dialogue name
label = "Initial Drawing Setup";	//label
: boxed_radio_column {			//start radio column
label = "Choose Sheet";			//label
: radio_button {			//radio button
  label = "&amp;Engineering Sheets";	//label
  key = "rb1";				//key
  value = "1";				//make it default
}					//end radio button
: radio_button {			//another radio button
  label = "&amp;Architectural Sheets";	//label
  key = "rb2"; 				//key
}					//end radio button
: radio_button {			//another radio button
  label = "&amp;Civil Sheets";		//label
  key = "rb3"; 				//key
}					//end radio button
: radio_button {			//another radio button
  label = "&amp;Electrical Sheets";		//label
  key = "rb4"; 				//key
}					//end radio button
: radio_button {			//another radio button
  label = "&amp;Blank Sheets";		//label
  key = "rb5"; 				//key
}					//end radio button
}						//end radio column
ok_cancel ;				//OK/Cancel Tile
: paragraph {				//begin paragraph
   : text_part {			//a bit of text
 label = "Designed and Created";	//text
   }					//end text
   : text_part {			//another bit of text
 label = "by Kenny Ramage";		//credits
   }					//end text
}					//end paragraph
}						//end dialogue

Now, let's write some lisp to display the dialogue box :

(defun C:SETUP1 ()				;define function
   (setvar "BLIPMODE" 0)			;switch off variables
   (setvar "CMDECHO" 0)
   (setvar "OSMODE" 0)
   (setq typ "e")				;set default
   (setq dcl_id (load_dialog "setup1.dcl"))	;load dialogue
   (if (not 					;test if loaded
   (new_dialog "setup1" dcl_id)		;new dialogue
 )					;end not
   (exit)				;if not loaded, exit
   )						;end if
   (set_tile "rb1" "1")			;switch on radio button
   (action_tile "rb1"				;if button selected
 "(setq typ \"e\")")			;store sheet type
   (action_tile "rb2"				;if button selected
 "(setq typ \"a\")")			;store sheet type
   (action_tile "rb3"				;if button selected
 "(setq typ \"c\")")			;store sheet type
   (action_tile "rb4"				;if button selected
 "(setq typ \"el\")")			;store sheet type
   (action_tile "rb5"				;if button selected
 "(setq typ \"b\")")			;store sheet type
   (action_tile "cancel"			;if Cancel selected
 "(done_dialog)(setq userclick nil)")	;close dialogue, clear flag
   (action_tile "accept"			;if OK selected
 "(done_dialog) (setq userclick T)")	;close dialogue, set flag
   (start_dialog)				;start dialogue
   (unload_dialog dcl_id)			;unload dialogue
 (princ)					;finish clean
)						;end function
(princ)

Your dialogue box should look like this :

<img src="https://www.afralisp.net/autolisp/tutorials/images/setup1.gif">

We've now designed a dialogue box that enables us to choose the type of drawing sheet that we would like to use. But, we still need to be able to choose the size of sheet and the scale that we would like to draw with. Let's modify our dialogue box and add these functions :

&lt;strong>Note&lt;/strong> : New lines of code are highlighted.

setup2 : dialog {				//dialogue name
label = "Initial Drawing Setup";	//label
: row {					//start row
: boxed_radio_column {			//start radio column
label = "Choose Sheet";			//label
: radio_button {			//radio button
  label = "&amp;Engineering Sheets";	//label
  key = "rb1";				//key
  value = "1";				//make it default
}					//end radio button
: radio_button {			//another radio button
  label = "&amp;Architectural Sheets";	//label
  key = "rb2"; 				//key
}					//end radio button
: radio_button {			//another radio button
  label = "&amp;Civil Sheets";		//label
  key = "rb3"; 				//key
}					//end radio button
: radio_button {			//another radio button
  label = "&amp;Electrical Sheets";		//label
  key = "rb4"; 				//key
}					//end radio button
: radio_button {			//another radio button
  label = "&amp;Blank Sheets";		//label
  key = "rb5"; 				//key
}					//end radio button
}						//end radio column
   : boxed_radio_column {			//start radio column
label = "Choose Size :";			//label
: radio_button {			//radio button
  label = "A&amp;0 - 1189 x 841";		//label
  key = "rb6";				//key
  value = "1";				//make it default
}					//end radio button
: radio_button {			//radio button
  label = "A&amp;1 -   841 x 594";		//label
  key = "rb7"; 				//key
}					//end radio button
: radio_button {			//radio button
  label = "A&amp;2 -   594 x 420";		//label
  key = "rb8"; 				//key
}					//end radio button
: radio_button {			//radio button
  label = "A&amp;3 -   420 x 297";		//label
  key = "rb9"; 				//key
}					//end radio button
: radio_button {			//radio button
  label = "A&amp;4 -   297 x 210";		//label
  key = "rb10";				//key
}					//end radio button
}						//end radio column
}						//end row
: edit_box {				//start edit box
  label = "&amp;Enter Drawing Scale :" ;	//label
  key = "eb1" ;				//key
  edit_width = 8 ;			//width of box
}					//end edit box
:spacer { width = 1;}			//spacer
ok_cancel ;				//OK/Cancel Tile
: paragraph {				//begin paragraph
   : text_part {			//a bit of text
 label = "Designed and Created";	//text
   }					//end text
   : text_part {			//another bit of text
 label = "by Kenny Ramage";		//credits
   }					//end text
}					//end paragraph
}						//end dialogue

And now the Autolisp Coding :

(defun C:SETUP2 ()				;define function
   (setvar "BLIPMODE" 0)			;switch off variables
   (setvar "CMDECHO" 0)
   (setvar "OSMODE" 0)
   (setq typ "e")				;set default
   (setq dcl_id (load_dialog "setup2.dcl"))	;load dialogue
   (if (not 					;test if loaded
   (new_dialog "setup2" dcl_id)		;new dialogue
 )					;end not
   (exit)				;if not loaded, exit
   )						;end if
   (set_tile "rb1" "1")			;switch on radio button
   (action_tile "rb1"				;if button selected
 "(setq typ \"e\")			;store sheet type
  (mode_tile \"eb1\" 2)")		;set focus to edit box
   (action_tile "rb2"				;if button selected
 "(setq typ \"a\")			;store sheet type
  (mode_tile \"eb1\" 2)")		;set focus to edit box
   (action_tile "rb3"				;if button selected
 "(setq typ \"c\")			;store sheet type
  (mode_tile \"eb1\" 2)")		;set focus to edit box
   (action_tile "rb4"				;if button selected
 "(setq typ \"el\")			;store sheet type
  (mode_tile \"eb1\" 2)")		;set focus to edit box
   (action_tile "rb5"				;if button selected
 "(setq typ \"b\")			;store sheet type
  (mode_tile \"eb1\" 2)")		;set focus to edit box
 
   (set_tile "rb6" "1")			;make default
   (set_tile "eb1" "1")			;initial edit box value
   (mode_tile "eb1" 2)			;set focus to edit box
   (action_tile "rb6"				;if button selected
 "(setq siz \"A0\")			;store sheet size
  (mode_tile \"eb1\" 2)")		;set focus to edit box
   (action_tile "rb7"				;if button selected
 "(setq siz \"A1\")			;store sheet size
  (mode_tile \"eb1\" 2)")		;set focus to edit box
   (action_tile "rb8"				;if button selected
 "(setq siz \"A2\")			;store sheet size
  (mode_tile \"eb1\" 2)")		;set focus to edit box
   (action_tile "rb9"				;if button selected
 "(setq siz \"A3\")			;store sheet size
  (mode_tile \"eb1\" 2)")		;set focus to edit box
   (action_tile "rb10"			;if button selected
 "(setq siz \"A4\")			;store sheet size
  (mode_tile \"eb1\" 2)")		;set focus to edit box
 
   (action_tile "cancel"			;if Cancel selected
 "(done_dialog)(setq userclick nil)")	;close dialogue, clear flag
   (action_tile "accept"			;if OK selected
 (strcat					;string 'em together
"(progn (setq #dwgsc			;store value
(atof (get_tile \"eb1\")))"	;get edit box value
"(done_dialog) (setq userclick T))" ;close dialogue, set flag
 )					;end progn
   )						;end action_tile
 
   (start_dialog)				;start dialogue
   (unload_dialog dcl_id)			;unload dialogue
 (princ)					;finish clean
)						;end function
(princ)

Here's what your dialogue should look like :

<img src="https://www.afralisp.net/autolisp/tutorials/images/setup2.gif">

We've now completed our dialogue box. In &lt;a href="/autolisp/tutorials/drawing-setup-part-2.php">Part 2&lt;/a> we'll try and get it to do something. See you there&hellip;

<h2>Drawing Setup - Part 2</h2>

<h2>Drawing Templates</h2>
As you can see from the dialogue box, we have 5 different types of drawing sheets and 5 sizes. Because of space constraints, I cannot post all 25 template drawings. Therefore, I will only supply the 5 Blank drawing templates. All of the template drawings should be named thus :

<h3>Engineering Drawings</h3>
&lt;ul>
EA0.DWG
EA1.DWG
EA2.DWG
EA3.DWG
EA4.DWG
&lt;/ul>

<h3>Architectural Drawings</h3>
&lt;ul>
AA0.DWG
AA1.DWG
AA2.DWG
AA3.DWG
AA4.DWG
&lt;/ul>

<h3>Civil</h3>
&lt;ul>
CA0.DWG
CA1.DWG
CA2.DWG
CA3.DWG
CA4.DWG
&lt;/ul>

<h3>Electrical Drawings</h3>
&lt;ul>
ELA0.DWG
ELA1.DWG
ELA2.DWG
ELA3.DWG
ELA4.DWG
&lt;/ul>

<h3>Blank Drawings</h3>
&lt;ul>
BA0.DWG
BA1.DWG
BA2.DWG
BA3.DWG
BA4.DWG
&lt;/ul>

I will leave it up to you to produce the rest of the template drawings. For your information, here is the dimensions of the most common Metric Drawing Sheets :

A0 - 1189 mm x 841 mm

A1 -  841 mm x 594 mm

A2 -  594 mm x 420 mm

A3 -  420 mm x 297 mm

A4 -  297 mm x 210 mm

Right, let's get down to writing some more code. The dialogue box we have designed will return 3 values :

TYP - Type of Sheet (eg. EL for Electrical)

SIZ - Size of Sheet (eg. A3 for A3 size sheet)

#DWGSC - Drawing Scale (eg. 25 for 1 in 25)

We can now use these values to set up our drawing sheet. Have a look at the following coding :

(defun C:SETUP3 ()				;define function
   (setvar "BLIPMODE" 0)			;switch off variables
   (setvar "CMDECHO" 0)
   (setvar "OSMODE" 0)
   (setq typ "e")				;set default
   (setq dcl_id (load_dialog "setup3.dcl"))	;load dialogue
   (if (not 					;test if loaded
   (new_dialog "setup3" dcl_id)		;new dialogue
 )					;end not
   (exit)				;if not loaded, exit
   )						;end if
   (set_tile "rb1" "1")			;switch on radio button
   (action_tile "rb1"				;if button selected
 "(setq typ \"e\")			;store sheet type
  (mode_tile \"eb1\" 2)")		;set focus to edit box
   (action_tile "rb2"				;if button selected
 "(setq typ \"a\")			;store sheet type
  (mode_tile \"eb1\" 2)")		;set focus to edit box
   (action_tile "rb3"				;if button selected
 "(setq typ \"c\")			;store sheet type
  (mode_tile \"eb1\" 2)")		;set focus to edit box
   (action_tile "rb4"				;if button selected
 "(setq typ \"el\")			;store sheet type
  (mode_tile \"eb1\" 2)")		;set focus to edit box
   (action_tile "rb5"				;if button selected
 "(setq typ \"b\")			;store sheet type
  (mode_tile \"eb1\" 2)")		;set focus to edit box
 
   (set_tile "rb6" "1")			;make default
   (setq SIZ "A0")				;default sheet size
   (set_tile "eb1" "1")			;initial edit box value
   (mode_tile "eb1" 2)			;set focus to edit box
   (action_tile "rb6"				;if button selected
 "(setq siz \"A0\")			;store sheet size
  (mode_tile \"eb1\" 2)")		;set focus to edit box
   (action_tile "rb7"				;if button selected
 "(setq siz \"A1\")			;store sheet size
  (mode_tile \"eb1\" 2)")		;set focus to edit box
   (action_tile "rb8"				;if button selected
 "(setq siz \"A2\")			;store sheet size
  (mode_tile \"eb1\" 2)")		;set focus to edit box
   (action_tile "rb9"				;if button selected
 "(setq siz \"A3\")			;store sheet size
  (mode_tile \"eb1\" 2)")		;set focus to edit box
   (action_tile "rb10"			;if button selected
 "(setq siz \"A4\")			;store sheet size
  (mode_tile \"eb1\" 2)")		;set focus to edit box
 
   (action_tile "cancel"			;if Cancel selected
 "(done_dialog)(setq userclick nil)")	;close dialogue, clear flag
   (action_tile "accept"			;if OK selected
 (strcat					;string 'em together
"(progn (setq #dwgsc			;store value
(atof (get_tile \"eb1\")))"	;get edit box value
"(done_dialog) (setq userclick T))" ;close dialogue, set flag
 )					;end progn
   )						;end action_tile
 
   (start_dialog)				;start dialogue
   (unload_dialog dcl_id)			;unload dialogue
 
(if userclick					;if flag is true
  (progn					;do the following
   (if (eq siz "A0")			;If size is A0
 (progn				;Do the following
	(setq x 1189.0			;Set x limits
  y 841.0			;Set y limits
  )				;End setq
 )					;End progn
)  					;End If
   (if (eq siz "A1")			;If size is A1
 (progn				;Do the following
	(setq x 841.0			;Set x limits
  y 594.0			;Set y limits
  )				;End setq
 )					;End progn
)  					;End If
   (if (eq siz "A2")			;If size is A2
 (progn				;Do the following
	(setq x 594.0			;Set x limits
  y 420.0			;Set y limits
  )				;End setq
 )					;End progn
)  					;End If
   (if (eq siz "A3")			;If size is A3
 (progn				;Do the following
	(setq x 420.0			;Set x limits
  y 297.0			;Set y limits
  )				;End setq
 )					;End progn
)  					;End If
   (if (eq siz "A4")			;If size is A4
 (progn				;Do the following
	(setq x 297.0			;Set x limits
  y 210.0			;Set y limits
  )				;End setq
 )					;End progn
)  					;End If
 
   (setq SIZE (strcat TYP SIZ))		;Construct name of Template
 
   (if (eq typ "e") (eng))		;Run Engineering Setup
   (if (eq typ "a") (arch))		;Run Architectural Setup
   (if (eq typ "c") (civil))		;Run Civil Setup
   (if (eq typ "el") (elec))		;Run Electrical Setup
   (if (eq typ "b") (blank))		;Run Blank Setup
 
  )						;End progn
)						;End If
 
 (princ)					;finish clean
)						;end function
;;;----------------------------------------------------------------------------
(defun blank ()					;Define function
 
(setvar "DIMSCALE" #DWGSC)		;Set Dimscale
(setvar "USERR1" #DWGSC)			;Store Scale for future
(setvar "LTSCALE" ( #DWGSC 10))		;Set Ltscale
(setvar "REGENMODE" 1)			;Regen ON
(setvar "TILEMODE" 1)			;Tilemode ON
(setq n ( 3.5 #DWGSC))			;Store Text Height
 
(setq L (list ( X #DWGSC) ( Y #DWGSC))	;Calculate Limits
)
 
(command "LIMITS" "0,0" L 
 "ZOOM" "W" "0,0" L
 "STYLE" "italict"
 "italict" N " " " " "
 "INSERT" SIZE "0,0" #DWGSC " "
)						;Set Up Drawing
 (prompt "\n ")				;Blank Line
(prompt "\nOK Setup Routine Complete")	;Inform User
 
 (princ)					;Exit Quietly
)						;End Function
;;;----------------------------------------------------------------------------
(princ)						;Clean Loading
;;;-----------------------------------------------------------------------------

First of all, we check that the OK button has been selected. If the user Cancels, nothing happens and we quietly exit the routine.

If OK has been selected, we first check the size of sheet chosen then, set our x and y limits depending on what size sheet was chosen. Next, we take the type and size of sheet and string them together. This gives us the name of the Template Drawing that we need to insert. Clever, Hey?

Following this, we test to see what type of sheet was chosen. Depending on the type, we run a sub-routine to set up our drawing.

I have deliberate allowed different setup routines for each type of drawing. This makes the program fully customisable and flexible. Please note that these setup routines are set to my standards and may not suit the way you want to setup a drawing.

Did you notice how I stored the scale factor into USERR1? This allows you to retrieve the scale factor for later use. (The value in USERR1 is saved with the drawing.)

In &lt;a href="/autolisp/tutorials/drawing-setup-part-3.php">Part 3&lt;/a> we will list the complete coding for all Sheet Types.

<h2>Drawing Setup - Part 3</h2>

<h2>AutoLISP Coding</h2>
Here is the complete AutoLISP Coding :

(defun C:SETUP ()				;define function
   (setvar "BLIPMODE" 0)			;switch off variables
   (setvar "CMDECHO" 0)
   (setvar "OSMODE" 0)
   (setq typ "e")				;set default
   (setq dcl_id (load_dialog "setup.dcl"))	;load dialogue
   (if (not 					;test if loaded
   (new_dialog "setup" dcl_id)		;new dialogue
 )					;end not
   (exit)				;if not loaded, exit
   )						;end if
   (set_tile "rb1" "1")			;switch on radio button
   (action_tile "rb1"				;if button selected
 "(setq typ \"e\")			;store sheet type
  (mode_tile \"eb1\" 2)")		;set focus to edit box
   (action_tile "rb2"				;if button selected
 "(setq typ \"a\")			;store sheet type
  (mode_tile \"eb1\" 2)")		;set focus to edit box
   (action_tile "rb3"				;if button selected
 "(setq typ \"c\")			;store sheet type
  (mode_tile \"eb1\" 2)")		;set focus to edit box
   (action_tile "rb4"				;if button selected
 "(setq typ \"el\")			;store sheet type
  (mode_tile \"eb1\" 2)")		;set focus to edit box
   (action_tile "rb5"				;if button selected
 "(setq typ \"b\")			;store sheet type
  (mode_tile \"eb1\" 2)")		;set focus to edit box
 
   (set_tile "rb6" "1")			;make default
   (setq SIZ "A0")				;Default sheet size
   (set_tile "eb1" "1")			;initial edit box value
   (mode_tile "eb1" 2)			;set focus to edit box
   (action_tile "rb6"				;if button selected
 "(setq siz \"A0\")			;store sheet size
  (mode_tile \"eb1\" 2)")		;set focus to edit box
   (action_tile "rb7"				;if button selected
 "(setq siz \"A1\")			;store sheet size
  (mode_tile \"eb1\" 2)")		;set focus to edit box
   (action_tile "rb8"				;if button selected
 "(setq siz \"A2\")			;store sheet size
  (mode_tile \"eb1\" 2)")		;set focus to edit box
   (action_tile "rb9"				;if button selected
 "(setq siz \"A3\")			;store sheet size
  (mode_tile \"eb1\" 2)")		;set focus to edit box
   (action_tile "rb10"			;if button selected
 "(setq siz \"A4\")			;store sheet size
  (mode_tile \"eb1\" 2)")		;set focus to edit box
 
   (action_tile "cancel"			;if Cancel selected
 "(done_dialog)(setq userclick nil)")	;close dialogue, clear flag
   (action_tile "accept"			;if OK selected
 (strcat					;string 'em together
"(progn (setq #dwgsc			;store value
(atof (get_tile \"eb1\")))"	;get edit box value
"(done_dialog) (setq userclick T))" ;close dialogue, set flag
 )					;end progn
   )						;end action_tile
 
   (start_dialog)				;start dialogue
   (unload_dialog dcl_id)			;unload dialogue
 
(if userclick					;if flag is true
  (progn					;do the following
   (if (eq siz "A0")			;If size is A0
 (progn				;Do the following
	(setq x 1189.0			;Set x limits
  y 841.0			;Set y limits
  )				;End setq
 )					;End progn
)  					;End If
   (if (eq siz "A1")			;If size is A1
 (progn				;Do the following
	(setq x 841.0			;Set x limits
  y 594.0			;Set y limits
  )				;End setq
 )					;End progn
)  					;End If
   (if (eq siz "A2")			;If size is A2
 (progn				;Do the following
	(setq x 594.0			;Set x limits
  y 420.0			;Set y limits
  )				;End setq
 )					;End progn
)  					;End If
   (if (eq siz "A3")			;If size is A3
 (progn				;Do the following
	(setq x 420.0			;Set x limits
  y 297.0			;Set y limits
  )				;End setq
 )					;End progn
)  					;End If
   (if (eq siz "A4")			;If size is A4
 (progn				;Do the following
	(setq x 297.0			;Set x limits
  y 210.0			;Set y limits
  )				;End setq
 )					;End progn
)  					;End If
 
   (setq SIZE (strcat TYP SIZ))		;Construct name of Template
 
   (if (eq typ "e") (eng))		;Run Engineering Setup
   (if (eq typ "a") (arch))		;Run Architectural Setup
   (if (eq typ "c") (civil))		;Run Civil Setup
   (if (eq typ "el") (elec))		;Run Electrical Setup
   (if (eq typ "b") (blank))		;Run Blank Setup
 
  )						;End progn
)						;End If
 
 (princ)					;finish clean
)						;end function
;;;----------------------------------------------------------------------------
(defun blank ()					;Define function
 
(setvar "DIMSCALE" #DWGSC)		;Set Dimscale
(setvar "USERR1" #DWGSC)			;Store Scale for future
(setvar "LTSCALE" ( #DWGSC 10))		;Set Ltscale
(setvar "REGENMODE" 1)			;Regen ON
(setvar "TILEMODE" 1)			;Tilemode ON
(setq n ( 3.5 #DWGSC))			;Store Text Height
 
(setq L (list ( X #DWGSC) ( Y #DWGSC))	;Calculate Limits
)
 
(command "LIMITS" "0,0" L 
 "ZOOM" "W" "0,0" L
 "STYLE" "italict"
 "italict" N " " " " "
 "INSERT" SIZE "0,0" #DWGSC " "
)						;Set Up Drawing
 (prompt "\n ")				;Blank Line
(prompt "\nO.K Setup Routine Complete")	;Inform User
 
 (princ)					;Exit Quietly
)						;End Function
;;;----------------------------------------------------------------------------
(defun eng ()					;Define function
 
(setvar "DIMSCALE" #DWGSC)		;Set Dimscale
(setvar "USERR1" #DWGSC)			;Store Scale for future
(setvar "LTSCALE" ( #DWGSC 10))		;Set Ltscale
(setvar "REGENMODE" 1)			;Regen ON
(setvar "TILEMODE" 1)			;Tilemode ON
(setq n ( 3.5 #DWGSC))			;Store Text Height
 
(setq L (list ( X #DWGSC) ( Y #DWGSC))	;Calculate Limits
)
 
(command "LIMITS" "0,0" L 
 "ZOOM" "W" "0,0" L
 "STYLE" "italict"
 "italict" N " " " " "
 "INSERT" SIZE "0,0" #DWGSC " "
)						;Set Up Drawing
 (prompt "\n ")				;Blank Line
(prompt "\nO.K Setup Routine Complete")	;Inform User
 
 (princ)					;Exit Quietly
)						;End Function
;;;----------------------------------------------------------------------------
(defun arch ()					;Define function
 
(setvar "DIMSCALE" #DWGSC)		;Set Dimscale
(setvar "USERR1" #DWGSC)			;Store Scale for future
(setvar "LTSCALE" ( #DWGSC 10))		;Set Ltscale
(setvar "REGENMODE" 1)			;Regen ON
(setvar "TILEMODE" 1)			;Tilemode ON
(setq n ( 3.5 #DWGSC))			;Store Text Height
 
(setq L (list ( X #DWGSC) ( Y #DWGSC))	;Calculate Limits
)
 
(command "LIMITS" "0,0" L 
 "ZOOM" "W" "0,0" L
 "STYLE" "italict"
 "italict" N " " " " "
 "INSERT" SIZE "0,0" #DWGSC " "
)						;Set Up Drawing
 (prompt "\n ")				;Blank Line
(prompt "\nO.K Setup Routine Complete")	;Inform User
 
 (princ)					;Exit Quietly
)						;End Function
;;;----------------------------------------------------------------------------
(defun civil ()					;Define function
 
(setvar "DIMSCALE" #DWGSC)		;Set Dimscale
(setvar "USERR1" #DWGSC)			;Store Scale for future
(setvar "LTSCALE" ( #DWGSC 10))		;Set Ltscale
(setvar "REGENMODE" 1)			;Regen ON
(setvar "TILEMODE" 1)			;Tilemode ON
(setq n ( 3.5 #DWGSC))			;Store Text Height
 
(setq L (list ( X #DWGSC) ( Y #DWGSC))	;Calculate Limits
)
 
(command "LIMITS" "0,0" L 
 "ZOOM" "W" "0,0" L
 "STYLE" "italict"
 "italict" N " " " " "
 "INSERT" SIZE "0,0" #DWGSC " "
)						;Set Up Drawing
 (prompt "\n ")				;Blank Line
(prompt "\nO.K Setup Routine Complete")	;Inform User
 
 (princ)					;Exit Quietly
)						;End Function
;;;----------------------------------------------------------------------------
(defun elec ()					;Define function
 
(setvar "DIMSCALE" #DWGSC)		;Set Dimscale
(setvar "USERR1" #DWGSC)			;Store Scale for future
(setvar "LTSCALE" ( #DWGSC 10))		;Set Ltscale
(setvar "REGENMODE" 1)			;Regen ON
(setvar "TILEMODE" 1)			;Tilemode ON
(setq n ( 3.5 #DWGSC))			;Store Text Height
 
(setq L (list ( X #DWGSC) ( Y #DWGSC))	;Calculate Limits
)
 
(command "LIMITS" "0,0" L 
 "ZOOM" "W" "0,0" L
 "STYLE" "italict"
 "italict" N " " " " "
 "INSERT" SIZE "0,0" #DWGSC " "
)						;Set Up Drawing
 (prompt "\n ")				;Blank Line
(prompt "\nO.K Setup Routine Complete")	;Inform User
 
 (princ)					;Exit Quietly
)						;End Function
;;;----------------------------------------------------------------------------
 (princ)					;Clean Loading
;;;-----------------------------------------------------------------------------

To download the source coding and template files &lt;a href="files/setup.zip">Click Here.&lt;/a>

Please remember that you will need to create some of the template files yourself.

<h2>AutoLISP Tips'n'Tricks</h2>

Below are listed the most recent AutoLISP tips'n'tricks.

<h3>Breaking a Circle</h3>

Have you ever tried breaking a Circle into 2 separate parts using the Break command? It doesn't work does it? This routine allows you to separate a circle into two arcs by picking two points on the circle.

(defun c:bcirc (/ os pt1 pt2 a pt3)
(setq os (getvar "osmode"))
(setvar "osmode" 512)
(setq pt1 (getpoint "\nFirst Break in Circle : "))
(setq pt2 (getpoint "\nSecond Break in Cricle : "))
(setq a (entget (ssname (ssget pt1) 0)))
(setq pt3 (cdr (assoc 10 a)))
(command "break" pt1 pt2)
(command "arc" pt1 "e" pt2 pt3)
(setvar "osmode" os)
(princ)
)
(princ)

Pick any 2 points on the a Circle. The circle will look the same, but it will be broken into two arcs.

<h3>Converting Strings to Uppercase</h3>

There are many occasions when you'll need to convert a string variable to uppercase, especially when you've requested a response and need to test it. It's much easier to test it against all-uppercase than to try to test for every combination of uppercase and lowercase. The command for the conversion is (strcase) :

(setq uc (strcase lc))

This converts the value of the string variable lc to uppercase and assigns the new value to the variable uc.

<h3>Default Values</h3>

In many AutoCAD commands, AutoCAD remembers the last entry and puts that entry between angle brackets (&lt;&gt;). Then all you have to do is press Enter, and that value is used. You should use that technique whenever you're creating your own defaults in AutoLISP. First make sure that you haven't declared as local the variable that will hold the value. Then follow a three-step process :


Require input from the user and assign that input to a second variable.

Test to see if the input is nil, and if it is nil, assign a global variable to the real variable.

Finally, assign the real variable to the global variable.
&lt;/ol>

You're then ready for the next sequence.

  
Here's an example :

(defun c:prog1 (/ a)
(if (= gv nil)
	(setq gv 1.0)
);end if
 
(princ "\nEnter Distance &lt;")
(princ gv)
(princ "&gt; ")
(setq a (getdist))
(if (= a nil)
	(setq a gv)
);end if
 
(setq gv a)
(princ "\nThe Distance is ")
(princ a)
(princ)
);defun

gv is the global variable. No matter how often you run this routine while in the same drawing, it will maintain the last entry as the default. The first time through the routine, gv is tested to see if it has a value. If it doesn't, the routine assigns 1.0 as the default value.

<h3>Extent Points</h3>

by Roger Farley

These four lines will give you the extreme four values in a points list, where PointList is a list of 2D or 3D points (like a list of pline vertex points) :

(setq X1 (apply 'min (mapcar 'car PointList)))
; The smallest 'X' value
(setq Y1 (apply 'min (mapcar 'cadr PointList)))
; The smallest 'Y' value
(setq X2 (apply 'max (mapcar 'car PointList)))
; The largest 'X' value
(setq Y2 (apply 'max (mapcar 'cadr PointList)))
; The largest 'Y' value

Then assemble like :

(setq LowerLeft (List X1 Y1))
(setq LowerRight (List X2 Y1))
(setq UpperRight (List X2 Y2))
(setq UpperLeft (List X1 Y2))

or

(setq CPWin (list (List X1 Y1) (list X2 Y1)
    (list X2 Y2) (list X1 Y2)))
;A list of 4 points, can be passed to a 'ssget' function

I use the trick in finding an extents boundary around the objects I am working with, or performing a zoom window around the work area.

<h3>Random Number Generator</h3>

Random number generation function - based on the linear congruential method as presented in Doug Cooper's book Condensed Pascal, pp. 116-117.

Returns a random number between 0 and 1 :

(defun randnum (/ modulus multiplier increment random)
(if (not seed)
  (setq seed (getvar "DATE"))
)
(setq modulus    65536
multiplier 25173
increment  13849
seed  (rem (+ (* multiplier seed) increment) modulus)
random     (/ seed modulus)
)
)


<h2>AutoLISP Functions</h2>

An alphabetic list of AutoLISP functions.

<h3>Symbol</h3>
<span class="brown">(*error* &lt;STRING&gt;)</span>
User-definable error function.
<span class="brown">(+ &lt;NUMBER&gt; &lt;NUMBER&gt; ...)</span>
Returns the sum of two or more numbers.
<span class="brown">(- &lt;NUMBER&gt; &lt;NUMBER&gt; ...)</span>
Returns the difference of two or more numbers.
<span class="brown">(* &lt;NUMBER&gt; &lt;NUMBER&gt; ...)</span>
Returns the product of two or more numbers.
<span class="brown">(/ &lt;NUMBER&gt; &lt;NUMBER&gt; ...)</span>
Returns the quotient of two or more numbers.
<span class="brown">(= &lt;NUMBER&gt; &lt;NUMBER&gt; ...)</span>
Returns T if the numbers are equal, nil if not.
<span class="brown">(/= &lt;NUMB1&gt; &lt;NUMB2&gt;)</span>
Returns T if the numbers are not equal, nil if they are.
<span class="brown">(&lt; &lt;NUMB1&gt; &lt;NUMB2&gt;)</span>
Returns T if &lt;NUMB1&gt; is less than &lt;NUMB2&gt;.
<span class="brown">(&lt;= &lt;NUMB1&gt; &lt;NUMB2&gt;)</span>
Returns T if &lt;NUMB1&gt; is equal to or less than &lt;NUMB2&gt;.
<span class="brown">(&gt; &lt;NUMB1&gt; &lt;NUMB2&gt;)</span>
Returns T if &lt;NUMB1&gt;is greater than &lt;NUMB2&gt;.
<span class="brown">(&gt;= &lt;NUMB1&gt; &lt;NUMB2&gt;)</span>
Returns T if &lt;NUMB1&gt; is equal to or greater than &lt;NUMB2&gt;.
<span class="brown">(~ &lt;NUMBER&gt;)</span>
Returns the bitwise of &lt;NUMBER&gt;.
<span class="brown">(1+ &lt;NUMBER&gt;)</span>
Returns the &lt;NUMBER&gt; increased by one.
<span class="brown">(1- &lt;NUMBER&gt;)</span>
Returns the &lt;NUMBER&gt; decreased by one.

<span class="brown">(abs &lt;NUMBER&gt;)</span>
Returns the absolute value of &lt;NUMBER&gt;.
<span class="brown">(and &lt;EXPR&gt; ...)</span>
Returns the logical AND of a list of expressions. Returns nil if expressions are nil.
<span class="brown">(angle &lt;PT1&gt; &lt;PT2&gt;)</span>
Returns the angle in radians between two points.
<span class="brown">(angtos &lt;ANGLE&gt;[&lt;MODE&gt;&lt;PRECIS.&gt;])</span>
Returns the angle as a string. Mode 0=Degrees,1=Deg Min Sec, 2=Grads,3=Radians,4=Surveyor
<span class="brown">(append &lt;EXPR&gt; ....)</span>
Returns a number of lists as one list.
<span class="brown">(apply &lt;FUNCTION&gt; &lt;LIST&gt;)</span>
Executes function with the arguments given as a list.
<span class="brown">(ascii &lt;STRING&gt;)</span>
Returns ascii value of first character of a string.
<span class="brown">(assoc &lt;ITEM&gt;&lt;ALIST&gt;)</span>
Searches &lt;ALIST&gt; for &lt;ITEM&gt;.
<span class="brown">(atan &lt;NUM1&gt; [&lt;NUM2&gt;])</span>
Returns the arctangent of &lt;NUM1&gt; or &lt;NUM1&gt;/&lt;NUM2&gt;.
<span class="brown">(atof &lt;STRING&gt;)</span>
Returns the conversion of a string into a real.
<span class="brown">(atoi &lt;STRING&gt;)</span>
Returns the conversion of a string into an integer.
<span class="brown">(atom &lt;ITEM&gt;)</span>
Returns T if &lt;ITEM&gt; is not a list.

<span class="brown">(Boole &lt;FUNC&gt; &lt;NUMB1&gt; &lt;NUMB2)</span>
Returns Boolean bitwise truth comparisons. &lt;NUMB&gt;'s must be integers.
<span class="brown">(boundp &lt;ATOM&gt;)</span>
Returns T if &lt;ATOM&gt; has a value bound to it.</p>              


<span class="brown">(car &lt;LIST&gt;)</span>
Returns the first element of a list.
<span class="brown">(caar &lt;LIST&gt;)</span>
Returns first element of the first element of a list.
<span class="brown">(cadar &lt;LIST&gt;)</span>
Returns last element of the first element of a list.
<span class="brown">(cadr &lt;LIST&gt;)</span>
Returns the second element of a list.
<span class="brown">(caddr &lt;LIST&gt;)</span>
Returns the third element of a list.
<span class="brown">(cdr &lt;LIST&gt;)</span>
Returns all but the first element of a list.
<span class="brown">(cdar &lt;LIST&gt;)</span>
Returns second element of the first element of list.
<span class="brown">(cddr &lt;LIST&gt;)</span>
Returns all but first element of last element list.
<span class="brown">(chr &lt;NUMBER&gt;)</span>
Returns the string represented by an ascii value.
<span class="brown">(close &lt;FILENAME&gt;)</span>
Closes a file.
<span class="brown">(command &lt;ARGS&gt;...)</span>
Executes an AutoCAD command.
<span class="brown">(cond (&lt;TEST1&gt;&lt;RESULT1&gt;)...)</span>
Evaluates any number of lists as arguments.
<span class="brown">(cons &lt;NEW FIRST ELEMENT&gt;&lt;LIST&gt;)</span>
Contructs a new list.
<span class="brown">(cos &lt;ANGLE&gt;)</span>
Returns the cosine of an angle.


<span class="brown">(defun &lt;SYM&gt;&lt;ARG LIST&gt;&lt;EXPR&gt;...)</span>
Defines an AutoLISP function.
<span class="brown">(distance &lt;PT1&gt; &lt;PT2&gt;)</span>
Returns the distance between two points.

<span class="brown">(entnext [&lt;ENAME&gt;])</span>
Returns the first non-deleted entity after &lt;ENAME&gt;.
<span class="brown">(entlast)</span>
Returns the last non-deleted entity in the database.
<span class="brown">(entsel [&lt;PROMPT&gt;])</span>
Selects a single entity by a point pick.
<span class="brown">(entdel &lt;ENAME&gt;)</span>
Deletes the entity &lt;ENAME&gt; or undeletes it if it
has already been deleted.
<span class="brown">(entget &lt;ENAME&gt;)</span>
Returns &lt;ENAME&gt; from the database as a list.
<span class="brown">(entmod &lt;ENAME&gt;)</span>
Updates &lt;ENAME&gt; in the database. NOT for blocks or polylines
<span class="brown">(entupd &lt;ENAME&gt;)</span>
Updates &lt;ENAME&gt; in the database. Use for polylines or blocks.
<span class="brown">(eq &lt;EXPR1&gt; &lt;EXPR2&gt;)</span>
Returns T if expressions are bound to same object.
<span class="brown">(equal &lt;EXPR1&gt; &lt;EXPR2&gt;)</span>
Returns T if the expressions are equal.
<span class="brown">(eval &lt;EXPR&gt;)</span>
Evalutes an expression.
<span class="brown">(exp &lt;NUMBER&gt;)</span>
Returns E to the power &lt;NUMBER&gt;.
<span class="brown">(expt &lt;BASE&gt; &lt;NUMBER&gt;)</span>
Returns &lt;BASE&gt; to the power &lt;NUMBER&gt;.

<span class="brown">(findfile &lt;FILENAME&gt;)</span>
Searches all paths to find &lt;FILENAME&gt;.
<span class="brown">(fix &lt;NUMBER&gt;)</span>
Converts &lt;NUMBER&gt; to an integer.
<span class="brown">(float &lt;NUMBER&gt;)</span>
Converts &lt;NUMBER&gt; to a real.
<span class="brown">(foreach &lt;NAME&gt;&lt;LIST&gt;&lt;EXPR&gt;)</span>
Evaluates &lt;EXPR&gt; for each element in the &lt;LIST&gt; and assigns to &lt;NAME&gt;.

<span class="brown">(gcd &lt;NUM1&gt; &lt;NUM2&gt;)</span>
Returns the greatest common denominator.
<span class="brown">(getangle [&lt;PT&gt;][&lt;PROMPT&gt;])</span>
Pauses for input of an angle at optional starting point &lt;PT&gt;.
<span class="brown">(getcorner [&lt;PT&gt;][&lt;PROMPT&gt;])</span>
Getpoint function - draws triangle as crosshairs move.
<span class="brown">(getdist [&lt;PT&gt;][&lt;PROMPT&gt;])</span>
Pauses for input of distance at optional start point.
<span class="brown">(getenv [&lt;VARIABLE&gt;])</span>
Returns string value assigned to a system variable.
<span class="brown">(getkword [&lt;PROMPT&gt;])</span>
Requests a keyword from the user.
<span class="brown">(getorient [&lt;PT&gt;][&lt;PROMPT&gt;])</span>
Returns angle in radians from current orientation.
<span class="brown">(getpoint [&lt;PT&gt;][&lt;PROMPT&gt;])</span>
Pauses for input of an angle at optional point &lt;PT&gt;.
<span class="brown">(getreal [&lt;PROMPT&gt;])</span>
Pauses for input of a real number.
<span class="brown">(getstring [&lt;CR&gt;][&lt;PROMPT&gt;])</span>
Pauses for input of a string.
<span class="brown">(getvar &lt;varname&gt;)</span>
Retrieves the value of an AutoCAD system variable.
<span class="brown">(graphscr)</span>
Flips from text screen to graphics screen.
<span class="brown">(grclear)</span>
Clears the graphics screen.
<span class="brown">(grdraw &lt;from&gt;&lt;to&gt;&lt;color&gt;[&lspan;highlight&gt;])
Draws a vector between two points.
<span class="brown">(grtext &lt;box&gt;&lt;text&gt;&lt;highlight&gt;])</span>
Write to text portion of graphics screen.
<span class="brown">(grread &lt;track&gt;)</span>
Allows AutoLISP to read AutoCADs input devices.

<span class="brown">(if &lt;testexpr&gt;&lt;thenexpr&gt;[&lt;elseexpr&gt;])</span>
Conditionally evaluates expressions.
<span class="brown">(inters &lt;pt1&gt;&lt;pt2&gt;&lt;pt3&gt;&lt;pt4&gt;[&spant;onseg&gt;])
Returns the intersection point of two lines. If &lt;ONSEG&gt; is greater than 0 the intersection may lie past the endpoints of the lines.
<span class="brown">(itoa &lt;number&gt;)</span>
Returns the conversion of an integer to a string.</p> 

<span class="brown">(lambda &lt;arguments&gt;&lt;expr&gt;...)</span>
Defines an &quot;anonymous&quot; function.
<span class="brown">(last &lt;list&gt;)</span>
Returns the last element in &lt;LIST&gt;.
<span class="brown">(length &lt;list&gt;)</span>
Returns the number of elements in &lt;LIST&gt;.
<span class="brown">(list &lt;expr&gt;)</span>
Returns the list of a number of expressions.
<span class="brown">(listp &lt;list&gt;)</span>
Returns T if the item is a list.
<span class="brown">(load &lt;filename&gt;)</span>
Loads an AutoLISP program in memory.
<span class="brown">(log &lt;number&gt;)</span>
Returns natural log of &lt;NUMBER&gt; as a real.
<span class="brown">(logand &lt;number&gt;&lt;number&gt;...)</span>
Returns the logical bitwise AND of a list of numbers.
<span class="brown">(logior &lt;number&gt;&lt;number&gt;...)</span>
Returns the logical bitwise OR of a list of numbers.
<span class="brown">(lsh &lt;numb1&gt;&lt;numbits&gt;)</span>
Returns the logical bitwise SHIFT operator of &lt;NUM1&gt; by &lt;NUMBITS&gt;

<span class="brown">(mapcar &lt;function&gt;&lt;list1&gt;...&lt;listn&gt;)</span>
Executes &lt;FUNCTION&gt; on the elements of &lt;LIST1&gt; through &lt;LIST2&gt;.
<span class="brown">(max &lt;number&gt;&lt;number&gt;...)</span>
Returns the maximum of the numbers given.
<span class="brown">(member &lt;expr&gt;&lt;list&gt;)</span>
Searches &lt;LIST&gt; for first occurence of &lt;EXPR&gt; and returns the remainder of the list.
<span class="brown">(menucmd &lt;string&gt;)</span>
Switch between pages in an AutoCAD menu.
<span class="brown">(min &lt;NUMBER&gt;&lt;NUMBER&gt;...)</span>
Returns the smallest of the numbers given.
<span class="brown">(minusp &lt;ITEM&gt;)</span>
Returns T if the item is negative.

<span class="brown">(not &lt;ITEM&gt;)</span>
Returns T if the expression is nil.
<span class="brown">(nth &lt;n&gt;&lt;LIST&gt;)</span>
Returns the &quot;nth&quot; element of &lt;LIST&gt;.
<span class="brown">(null &lt;ITEM&gt;)</span>
Returns T if &lt;ITEM&gt; is bound to nil.
<span class="brown">(numberp &lt;ITEM&gt;)</span>
Returns T if &lt;ITEM&gt; is an integer or a real.

<span class="brown">(open &lt;FILENAME&gt;&lt;MODE&gt;)</span>
Opens a file.
<span class="brown">(or &lt;EXPR&gt;...)</span>
Returns the logical OR of a list of expressions.
<span class="brown">(osnap &lt;PT&gt;&lt;MODE-STRING&gt;)</span>
Returns a point by applying the osnap command.

<span class="brown">(polar &lt;PT&gt;&lt;ANGLE&gt;&lt;DISTANCE&gt;)</span>
Returns point at &lt;ANGLE&gt; and &lt;DISTANCE&gt; from &lt;PT&gt;.
<span class="brown">(prin1 &lt;EXPR&gt;[&lt;FILENAME&gt;])</span>
Prints &lt;EXPR&gt; on the screen or to &lt;FILENAME&gt;.
<span class="brown">(princ &lt;EXPR&gt;[&lt;FILENAME&gt;])</span>
Same as prin1 except control character are printed without expansion.
<span class="brown">(print &lt;EXPR&gt;[&lt;FILENAME&gt;])</span>
Same as prin1 except a new line is printed before &lt;EXPR&gt; and a space is printed after.
<span class="brown">(progn &lt;EXPR&gt;...)</span>
Evalutes each expression sequentially.
<span class="brown">(prompt &lt;MSG&gt;)</span>
Displays &lt;MSG&gt; on the screen PROMPT area.

<h2 id="quote">Q</h2>

<span class="brown">(quote &lt;EXPR&gt;)</span>
Returns &lt;EXPR&gt; unevaluated.</p>            


<span class="brown">(read &lt;STRING&gt;)</span>
Returns the first LIST obtained from &lt;STRING&gt;.
<span class="brown">(read-char [&lt;FILENAME&gt;])</span>
Returns a character from the keyboard buffer or from &lt;FILENAME&gt;.
<span class="brown">(read-line [&lt;FILENAME&gt;])</span>
Returns a string from the keyboard buffer or from &lt;FILENAME&gt;.
<span class="brown">(redraw [&lt;ENAME&gt;][&lt;MODE&gt;])</span>
Redraws either entire drawing, or &lt;ENAME&gt; in &lt;MODE&gt;.
<span class="brown">(rem &lt;NUM1&gt; &lt;NUM2&gt; ...)</span>
Returns the remainder of &lt;NUM1&gt;/&lt;NUM2&gt;.
<span class="brown">(repeat &lt;NUMBER&gt; &lt;EXPR&gt; ...)</span>
Evaluates each expression &lt;NUMBER&gt; times.
<span class="brown">(reverse &lt;LIST&gt;)</span>
Returns a list reversed.
<span class="brown">(rtos &lt;NUMBER&gt; [&lt;MODE&gt;&lt;PRECIS&gt;])</span>
Returns a real number as a string.

<span class="brown">(set &lt;SYM&gt;&lt;EXPR&gt;)</span>
Sets the value of a sysmbol name.
<span class="brown">(setq &lt;SYM1&gt;&lt;EXPR1&gt;...)</span>
Sets the value of &lt;SYM1&gt; to &lt;EXPR1&gt;.
<span class="brown">(setvar &lt;VARNAME&gt;&lt;VALUE&gt;)</span>
Sets a system variable to &lt;VALUE&gt;.
<span class="brown">(sin &lt;ANGLE&gt;)</span>
Returns the sine of an angle.
<span class="brown">(sqrt &lt;NUMBER&gt;)</span>
Returns the square root of &lt;NUMBER&gt;.
<span class="brown">(ssget [&lt;MODE&gt;][&lt;PT1&gt;&lt;PT2&gt;])</span>
Returns a selection set.
<span class="brown">(sslength &lt;SS&gt;)</span>
Returns the number of entities in selection set &lt;SS&gt;.
<span class="brown">(ssname &lt;SS&gt;&lt;INDEX&gt;)</span>
Returns the name of the &lt;INDEX&gt;th entity in selection set &lt;SS&gt;.
<span class="brown">(ssadd [&lt;ENAME&gt;][&lt;SS&gt;])</span>
Adds entities to selections sets.
<span class="brown">(ssdel [&lt;ENAME&gt;][&lt;SS&gt;])</span>
Deletes entities from selections sets.
<span class="brown">(ssmemb [&lt;ENAME&gt;][&lt;SS&gt;])</span>
Returns &lt;ENAME&gt; if &lt;ENAME&gt; is a member of selections set &lt;SS&gt;.
<span class="brown">(strcase &lt;STRING&gt;[&lt;WHICH&gt;)]</span>
Returns &lt;STRING&gt; as upper case if &lt;WHICH&gt; is nill. If &lt;WHICH&gt; is not nill the returned string will be all lower case.
<span class="brown">(strcat &lt;STRING1&gt;&lt;STRING2&gt;..)</span>
Concatenates a series of strings.
<span class="brown">(strlen &lt;STRING&gt;)</span>
Returns the number of characters in a string.
<span class="brown">(subst &lt;NEWITEM&gt;&lt;OLDITEM&gt;&lt;LIST&gt;)</span>
Substitutes &lt;NEWITEM&gt; for &lt;OLDITEM&gt; in &lt;LIST&gt;.
<span class="brown">(substr &lt;STRING&gt;&lt;START&gt;&lt;LENGTH&gt;)</span>
Returns a substring of &lt;STRING&gt; begining at &lt;START&gt; of &lt;LENGTH&gt; characters.


<span class="brown">(tblnext &lt;NAME&gt; [&lt;rewind&gt;])</span>
Scans symbol table for next entity.
<span class="brown">(tblsearch &lt;NAME&gt;&lt;SYM&gt;[&lt;setnext&gt;])</span>
Searches entire symbol table for &lt;NAME&gt;.
<span class="brown">(terpri)</span>
Prints a new line on the screen.
<span class="brown">(textscr)</span>
Flips from graphics screen to text screen.
<span class="brown">(trace &lt;FUNCTIONS&gt;...)</span>
Debugging aid that returns the last function name.
<span class="brown">(trans &lt;PT&gt;&lt;FROM&gt;&lt;TO&gt;[&lt;DISP&gt;])span/p>
Translates a point &lt;PT&gt; from one coordinate system to another.
<span class="brown">(type &lt;ITEM&gt;)</span>
Returns the type of &lt;ITEM&gt;.

<span class="brown">(untrace &lt;FUNCTIONS&gt;...)</span>
Clears the trace floag for &lt;FUNCTIONS&gt;.

<span class="brown">(ver)</span>
Returns AutoLISP version number.
<span class="brown">(vmon)</span>
Enables AutoLISP virtual function pager.
<span class="brown">(vports)</span>
Returns a list of currently active viewports.

<span class="brown">(while &lt;TESTEXPR&gt;&lt;EXPR&gt;)</span>
Evaluates &lt;TESTEXPR&gt; and if not nill executes &lt;EXPR&gt;.
<span class="brown">(write-char &lt;NUM&gt; [&lt;FILENAME&gt;])</span>
Writes the character represented by the ASCII value of
&lt;NUM&gt; to the screen or to &lt;FILENAME&gt;.
<span class="brown">(write-line &lt;STRING&gt; [&lt;FILENAME&gt;])</span>
Writes &lt;STRING&gt; to the screen or to &lt;FILENAME&gt;.

<span class="brown">(zerop &lt;ITEM&gt;)</span>
Returns T if &lt;ITEM&gt; evaluates to zero.

<script type='text/javascript' src='readbook.js'></script>
<script>
var lazyLoadInstance = new LazyLoad({
    elements_selector: ".lazy"
    // ... more custom settings?
});
</script>
</pre></body></html>
