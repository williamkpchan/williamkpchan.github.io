<base target="_blank"><html><head><title>Programming Maths</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src="https://williamkpchan.github.io/lazyload.min.js"></script>
<script src='https://williamkpchan.github.io/mainscript.js'></script>
<script src="https://williamkpchan.github.io/commonfunctions.js"></script>
<script>
  var showTopicNumber = false;
  var topicEnd = "<br>";
  var bookid = "Programming Maths"
  var markerName = "h2, h3"
</script>
<style>
body{width:80%;margin-left: 10%; font-size:24px;}
h1, h2 {color: gold;}
strong {color: orange;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px;}
</style></head><body onkeypress="chkKey()"><center>
<h1>Programming Maths</h1>
<a href="#mustWatch" class="red goldbs" target="_self">Must Watch!</a>
<div id="toc"></div></center>
<div id="mustWatch"><center><span class="red">MustWatch</span></center></div>
<pre>
<h2><span class="brown">1. Sets</span></h2>
Sets are collections of objects.
Georg Cantor, a German mathematician initiated the development of set theory.
A set is mathematically represented by items inside curly braces (<code>{}</code>).
For example:
a set of natural numbers (N): <code>{1, 2, 3,  }</code>
a set of whole numbers : <code>{0,1, 2, 3,  }</code>
a set of all numbers: consisting of a set of real numbers and complex numbers

<h3>&emsp;Notations</h3>
 is a Null set i.e. A set that does not have any elements.
is the Universal Set i.e. the set of all the elements of all the sets which are being considered for set operations
A is the complement of a Set: A set that includes all the elements that are not part of the universal set i.e. (A =   A)
x  A represents that x is a member of A. \nFor example, a person (x) in a set of the population of France (A).
A   B represents that A is a subset of B. \nFor example, the set of the population of France (A) is a subset of the set of the population of Europe (B).
represents the Union of two sets i.e. the combination of all the elements of two sets into a single set
represents the Intersection of two sets i.e. combining the common elements of the two sets into a new set
<h2><span class="brown">2. Venn Diagrams</span></h2>
These are a scheme of representing sets and their operations diagrammatically.
<h3>&emsp;Intersection of Two Sets</h3>
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/0*7AoJL7niukRQNH20.png">
Intersection of two sets (A  B)
<h3>&emsp;Union of Two Sets</h3>
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/0*iH9T0miifX6FaxCq.png">
Union of two sets (A  B)

<h2><span class="brown">3. Prime Numbers &amp; Riemann Hypothesis</span></h2>
A Prime Number is any natural number greater than 1, that can only be divided exactly by itself or 1.
A set of Prime numbers can be represented as <code>{2,3,5,7,11,13,17,...}</code>.
<h3>&emsp;Riemann Hypothesis</h3>
It is a hypothesis that suggests that the distribution of prime numbers can be predicted and the frequency of prime numbers is very closely related to the behavior of the Reimann Zeta function.
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/1*ElywEnVrerdxLkJgCYzKAg.png">
The Reimann Zeta FunctionTo be precise, this conjecture tells that the Riemann zeta function has its zeros only at:
the negative even integers (trivial zeros) and
complex numbers with real part 1/2 (non-trivial zeros)
This is one of the unsolved Millennium problems in mathematics and the first person to provide acceptable proof will be given a $1 million prize by the Clay Mathematics Institute.
<h3>&emsp;Millennium Problems</h3>
If it is easy to check that a solution to a problem is correct, is it also easy to solve the problem? This is the
www.claymath.org
</a>
<h2><span class="brown">4. Probability</span></h2>
It is a mathematical branch that deals with the likelihood of an event occurrence.
Mathematically represented by P, theprobability of an event X occurring is P(X).
<blockquote>P<!-- --> (X) = Number of events where X occurs / Total number of possible outcomes</blockquote>
For example, the probability of getting heads in a coin toss is 1/2 or 50%.
<h3>&emsp;Rules of Probability</h3>
The probability of an event can only be between 0 and 1.
If two events are independent of each others occurrence, then the probability of both happening is given by multiplying their individual probabilities.
<blockquote>P (X and Y) = P (X) * P (Y)</blockquote>
If two events are mutually exclusive, the probability of either one occurring is given by adding their individual probabilities.</li>
<blockquote>P (X or Y) = P (X) + P (Y)</blockquote>

<h2><span class="brown">5. Differential Calculus</span></h2>
It is a mathematical branch that is concerned with continuous change.
Its two major branches deal with:
the rate of change/ gradient of a quantity (differential calculus)
summation of infinitely many small quantities to calculate the whole (integral calculus)
<h3>&emsp;Differentiation</h3>
It is used to calculate the gradient/ slope/ tangent of a mathematical curve.
It can also be used to find the smallest (minima) and largest value (maxima) of a function.
For a curve with an equation of <code>y= x^n</code>, the gradient of y with respect to x (<code>dy/dx</code>) is given by <code>n * x^(n-1)</code> .
<h3>&emsp;Rules of Differentiation</h3>
<code>d(n)/dx = 0</code>
<code>d(x)/dx = 1</code>
<code>d(x^n)/dx = n * x^(n-1)</code>
<code>d(e^x)/dx = e^x</code>
<code>d(ln x)/dx = 1/x</code>
<code>d(n^x)/dx = n^x * ln(x)</code>
<code>d(sin x)/dx = cos x</code>
<code>d(cos x)/dx =  sin x</code>
<h3>&emsp;Integration</h3>
It is the inverse of differentiation.
It is commonly used for calculating areas and volumes of shapes.
For an equation <code>y = x^n</code> , the integral of y is given by:
<blockquote>y dx =  (x^n) dx = (1/n+1) * (x^n+1) + C</blockquote>
where C is a numerical constant.

<h2><span class="brown">6. Correlation</span></h2>
A term introduced by Francis Galton, Correlation is a property that demonstrates how two variables are associated with each other.
It determines how varying one variable changes the other.
The Pearson correlation coefficient / Pearsons r () measures this correlation on a scale from -1 to 1 where:
0  No correlation
-1  Anti-correlation
1  Perfect correlation
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/0*IpQUbT2vqGLJPD4q.png">
Pearsons coefficient
Remember that:
<blockquote>
Correlation does not imply causation.
The number of ice creams sold on a particular day and the number of children born on that day may correlate but this does not mean that one is the cause of another.
</blockquote>
<h2><span class="brown">7. Regression</span></h2>
It is a process of mathematically estimating the relationships between a dependent variable and one or more independent variables.
Two types of regression models are explained below.
<h2><span class="brown">8. Linear Regression</span></h2>
It is an approach to modeling the linear relationship between different variables.
This relation can be between:
two variables (plotted on a 2-D plane) or
multiple variables (plotted on a multi-dimensional plane)
The relation between two variables can be represented as:
<blockquote><code>y = m*x + c</code></blockquote>
where x is the independent variable and y is the dependent variable.
The line that minimizes the sum of the squared vertical distance between the data points is considered the best-fitting line for linear regression.
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/0*TjghIizdo54S0Hhz.png">
Line of best fit in Linear Regression
Linear regression as a machine learning model can be used to predict continuous variables as opposed to classification.
For example, estimating the temperature (a continuous variable) at a particular time of the day.
<h3>&emsp;Coefficient Of Determination (R2)</h3>
It is the proportion of the variation in the dependent variable that is predictable from the independent variable.
R2 is calculated as follows where:
SS(res) is the sum of squares of residuals (the sum of squared distance between the line of best fit and observations)
SS(tot) is the total sum of squares (the sum over all squared differences between the observations and their overall mean)
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/1*ygeptDI5s_TCHZxFg7-fWA.png">
Formula for calculating R2<blockquote>Note that R2 should not be confused with the square of Pearsons coefficient.</blockquote>
s coefficient.
To learn more, check out this great article by Krishna Rao:
<h3>&emsp;r2 or R2  When to Use What</h3>
Graphical explanation of the squared Pearson correlation coefficient and coefficient of determination
towardsdatascience.com
</a>
R2 can range between any negative number to +1, where
+1 indicates a perfect match of observations to predictions
0 indicates that predictions are random
a negative number indicates that the predictions are worse than random

<h2><span class="brown">9. Logistic Regression</span></h2>
This approach estimates the probability of an event occurring (that lies between 0 and 1) based on given independent variables.
Logistic Regression as a machine learning model is used for classification tasks (as opposed to regression tasks).
These classification tasks can either be:
binary (classification between 2 outcomes)
multi-class (classification between more than 2 outcomes)
The Logistic function is written as follows where :
 is a location parameter or the midpoint of the logistic curve (0.5 in the plot below)
s is a scale parameter

<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/1*EadvSHScQPMN6o2yyuaopQ.png">
Logistic FunctionThe following logistic plot is used to classify the probability of passing the exam based on the number of hours of study.
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/0*_skqKO_eaoLDO9fx.png">
The Logistic Regression Plot


<h2><span class="brown">10. Matrices</span></h2>
A Matrix is an array/table of numbers.
They are extensively used in algebra to perform operations in a condensed manner.
An <code>m * n</code> matrix has <code>m</code> rows (horizontal) and <code>n</code> columns (vertical).
The elements in a matrix are notated as follows where for element <code>a</code> :
the first number in the subscript is the row number and,
the second number in the subscript is the column number
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/0*_ptvPkbtqWApO2xA.png">
An m*n matrix with a(mn) elements
<h3>&emsp;Matrix Arithmetic</h3>
<h3>&emsp;Addition &amp; Subtraction</h3>
Prerequisite: \nTwo matrices must have the same dimensions i.e. with the same number of rows and columns for them to be added or subtracted.
The number at a location can be added/ subtracted from a similarly located element in another matrix as follows:
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/0*irFBTc4ZxODs8CWu.png">
Graphical representation of Matrix Addition

<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/1*RxahIq68zidR2-E1RB2-GQ.png">
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/1*OwY4d6pQPqsQAl2IxAIEdg.png">
Numerical Representation of Matrix Subtraction (Example from Wikipedia)<h3>&emsp;Matrix Multiplication</h3>
Prerequisite:\nTwo matrices A &amp; B can only be multiplied if A has the same number of columns as the number of rows in B.
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/0*RT5elPfhdeZt33YR.png">
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/1*arZTSgBzxh5wdcV8gmmhqA.png">
Numerical Representation of Matrix Multiplication<h3>&emsp;Matrix Transposition</h3>
Matrix transposition flips a matrix over its diagonal.
This operation switches the row and column indices of matrix A by producing another matrix, denoted by A^T.
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/0*m1Agbb7G8JVuIWR7.gif">Graphical Representation of Matrix Multiplication
<h3>&emsp;Matrix Inversion</h3>
In number multiplication, if <code>x = 10</code>, then the inverse of x (x-1)i.e. <code>1/x = 1/10</code>
Hence, the following holds true:
<blockquote><code>x * x^-1 = 1</code></blockquote>
For matrices, the inverse of a matrix <code>A</code> must satisfy the above condition.
<blockquote><code>A * A^-1 = 1</code></blockquote>
For example, the inverse of a 2x2 matrix can be demonstrated below:
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/1*tWnGZWQsW-kCcZ_hNsEDTQ.png">
Numerical Representation of Matrix InversionThis is because <code>A</code> multiplied by its inverse <code>A^-1</code> returns the following:
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/1*G8TEQ6FFdxBGBoPdOlWHsA.png">
Numerical Representation of calculating the Identity Matrix<h3>&emsp;Identity Matrix (I)</h3>
It is the matrix counterpart of 1.
The identity matrix of size <code>n x n</code> square matrix is one with ones on the main diagonal and zeros elsewhere.
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/1*_bGYEtLzW56DAwbxDzYn_g.png">
Identity Matrix
<h3>&emsp;Matrix Division</h3>
Two matrices <code>A</code> and <code>B</code> can be divided as follows:
<blockquote>A<code> / B = A * B^-1</code></blockquote>
Remember that this will only be true if matrix <code>B</code> has a possible inverse.
Also,
<blockquote>A<code>^-1 * B</code> is not equal to <code>A * B^-1</code> as for numbers.</blockquote>
<h3>&emsp;Matrix Properties</h3>
Matrix multiplication is non-commutative
</li>
<blockquote>A<code> X B</code> is not equal to <code>B X A</code></blockquote>
Matrix multiplication is distributive with respect to matrix addition</li>
For matrix <code>A</code> of size <code>m  n</code> and <code>B</code> of size <code>n  p</code> :
<blockquote><code>A(B+C) = AB + AC</code> (left distributivity)</blockquote>
For matrix <code>C</code> of size <code>n  p </code>and <code>D</code> of size <code>p  q</code> :
<blockquote><code>(B+C)D = BD + CD</code> (right distributivity)</blockquote>
If <code>A</code> is a matrix and <code>c</code> a scalar, then the matrices <code>cA</code> and <code>Ac</code> are obtained by left and right multiplying the entries of <code>A</code> with <code>c</code> .</li>
<h2><span class="brown">11. Vectors</span></h2>
A Vector is a one-dimensional matrix.
It can be written as a list of numbers.
Matrices with a single row are called row vectors (<code>1 x n</code> dimensional).
Matrices with a single column are called column vectors (<code>n x 1</code> dimensional).

<h2><span class="brown">12. Fibonacci Numbers</span></h2>
Fibonacci numbers were first described in India by Pingala.
<blockquote><code>1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...</code></blockquote>
It is a sequence of whole numbers that can be obtained by adding the previous two numbers in the series.
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/1*8SEz70-yOlLKpbMUndZphg.png">
Calculation of nth Fibonacci NumberThis sequence commonly occurs in nature in form of:
branching in trees
the arrangement of leaves on a stem
number of spirals formed from the number of seeds in the spirals of a sunflower
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/0*sK2hzGY66fsYyWo4.png">
The Fibonacci SpiralApplications of Fibonacci numbers in Computer science include:
Fibonacci Search
Fibonacci Heap
Fibonacci Cubes
Fibonacci Coding
Check out one of my articles below to read more about recursion explained with the use of Fibonacci numbers:
<a rel="noopener  ugc nofollow" target="_blank" href="/understanding-recursion-by-dropping-it-eventually-be442c8141f2">
<h3>&emsp;Understanding Recursion By Dropping It Eventually</h3>
Lets understand Recursion--a junior developers nightmare!
levelup.gitconnected.com
</a>
<h2><span class="brown">13. The Golden Ratio ()
</h2>
If we divide a line into two segments of different lengths i.e. <code>A</code> and <code>B</code>, both of these are in a golden ratio (<code></code>; phi) if:
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/0*-kqwSoq307IbJW6L.png">
The Golden Ratio LineThis equation can be rearranged into a quadratic equation as follows:The positive solution of the quadratic equation is:
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/1*Xp6DjGlPGj8EyjEHf71p9A.png">
Value of  (Golden Ratio/ Mean)The Golden Ratio (<code></code>) can also be obtained by dividing a number in the Fibonacci sequence by the number behind it (especially true for large Fibonacci numbers)
For example, the two subsequent Fibonacci numbers <code>233</code> and <code>114</code> when divided:
<blockquote><code>233 / 144 = 1.618 = </code></blockquote>
Interesting, isnt it?
<h2><span class="brown">13. The Super-Golden Ratio ()</span></h2>
The Super-golden ratio comes from Narayanas cows sequence (which represents the breeding of the cattle population)
This sequence is similar to the Fibonacci sequence and is obtained as follows:
<code>a(0) = a(1) = a(2) = 1</code>, thereafter:
<blockquote><code>a(n) = a(n-1) + a(n-3)</code></blockquote>
The first few numbers in the sequence are:
<blockquote>1, 1, 1, 2, 3, 4, 6, 9, 13, 19, 28, 41, 60, 88, </blockquote>
Similar to the Golden ratio, the super-golden ratio can be calculated by dividing two subsequent numbers in this series.
This ratio is represented by psi (<code>\n</code>).
<blockquote>\n = 1.465571231876768026</blockquote>
<h2><span class="brown">14. Factorials</span></h2>
The Factorial of a number <code>n</code> is represented by <code>n!</code>.
It is the product of all positive integers less than or equal to n.
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/1*4Hvojuwohut3cid5xpUM5g.png">
Calculation of Factorial
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/1*smaH6sFlMKCmyclD3eW1RA.png">
Calculation of Factorial<blockquote>Note that the value of the factorial of 0 i.e.<code>0! = 1</code></blockquote>
<h2><span class="brown">15. Permutations</span></h2>
It is the number of ways in which items can be arranged in a particular order.
For given <code>n</code> items, there are <code>n!</code> possible permutations.
If picking <code>k</code> items from a total of <code>n</code> items, the possible permutations are <code>n! / (n-k)!</code>.
For example, there are six permutations of the set <code>{1, 2, 3}</code>:
<code>(1, 2, 3)</code>
<code>(1, 3, 2)</code>
<code>(2, 1, 3)</code>
<code>(2, 3, 1)</code>
<code>(3, 1, 2)</code>
<code>(3, 2, 1)</code>

<h2><span class="brown">16. Combinations</span></h2>
It is the number of ways in which items can be arranged without particular order.
If picking <code>k</code> items from a total of <code>n</code> items, the possible combinations (<code>C (n, k)</code>) are:
<blockquote><code>n! / (k! * (n-k)!)</code></blockquote>
For example, when picking up two items from the set <code>{1, 2, 3}</code>, there are three combinations of :
<code>(1, 2)</code>
<code>(1, 3)</code>
<code>(2, 3)</code>
<h2><span class="brown">17. Modulo Arithmetic</span></h2>
Modulo arithmetic can be represented by the word:
<blockquote>Wraparound</blockquote>
Imagine a clock.
When the 12-hour clock hand completes a circle and moves on 2, the time is still 2 and not 14.

In Python, the modulo of a number can be calculated as below.
This is the remainder left after dividing 12 by 2.
<h3>&emsp;Congruence</h3>
Given two numbers <code>a</code> and <code>b</code>, if the difference of these numbers ( <code>k = a-b</code> ) is exactly divisible by another number <code>n</code> :
<blockquote><code>a</code> and <code>b</code> are said to be congruent modulo n</blockquote>
<blockquote>a  b (mod n)</blockquote>
<h3>&emsp;Applications</h3>
Modulo Arithmetic is used in:
Public Key Cryptography uses Modular Exponentiation
Bitwise Operations (e.g. XOR sums 2 bits, modulo 2)
International Bank Account Numbers (IBANs) use modulo 97 arithmetic to spot user input errors in bank account numbers
Computer algebra algorithms (e.g. Polynomial Factorisation)
<h2><span class="brown">18. Elliptic Curve</span></h2>
An elliptic curve is defined using the following equation:
<img class="lazy" data-src="https://miro.medium.com/max/640/1*klxNtS9lC7sFUxXHPvp10A.png">
The equation for an Elliptic curveAn elliptic curve used in the Bitcoin software is called secp256k1.
This curve is represented by the equation below where <code>a = 0</code> and <code>b = 7</code>.
<blockquote>y2 = x3 + 7</blockquote>
When plotted over real numbers, this curve looks as below.
<img class="lazy" data-src="https://miro.medium.com/max/640/0*eJBdtMybZ964-Kje.png">
The plot of secp256k1 over the real numbers ( Source: Bitcoin Wikipedia )
<h2><span class="brown">19. Field</span></h2>
A field is a set of numbers along with its two defined operations:
Addition (+) and
Multiplication (<U+22C5>)
These operations are should satisfy certain properties called field axioms.
Associativity of addition and multiplication
Commutativity of addition and multiplication
Additive and Multiplicative identity
Additive and Multiplicative inverses
Distributivity of multiplication over addition
For example, there can be fields of:
real numbers
complex numbers (i.e. real + imaginary numbers)
rational numbers, and more
<blockquote>N<!-- -->ote that: All of these fields contain infinite elements.</blockquote>

<h2><span class="brown">20. Finite Field</span></h2>
It is a field with finite elements.
The order of the field is the number of elements contained in the field.
The order of a finite field is a prime number or a positive power of a prime number.
The result of the addition or multiplication of two elements in the set is always within the set.
To ensure the above,
For a finite field F(n) of order <code>n</code> with two of its elements <code>a</code> and <code>b</code> , their:
Addition is defined as <code>( a + b ) mod n</code>
Multiplication is defined as <code>( a * b) mod n</code>

The order of F(2) is two (a prime number).
This field is used extensively in computer science as the two possible values of a bit.
Elliptic curves, Finite fields along with their modular arithmetic operations lead to Public Key Cryptography (explained in depth in the article below).
<a rel="noopener  ugc nofollow" target="_blank" href="/the-mathematics-behind-bitcoin-522f72ed87b7">
<h3>&emsp;The Mathematics Behind Bitcoin</h3>
levelup.gitconnected.com
</a>

<h2><span class="brown">21. Decimal Numbers</span></h2>
The numbers that we use on a day-to-day basis are Decimals, which is also called the Base(10) number system.
This number system has numbers between <code>0</code> and <code>9</code>.
<h3>&emsp;Number Representation</h3>
To represent a number in the Decimal number system, we use the Base(10) notation as follows:
<blockquote>
1 = <code>1</code> x 10<U+2070>
<code>25</code> = <code>2</code> x 101 + <code>5</code> x 10<U+2070>
<code>200</code> = <code>2</code> x 102 + <code>0</code> x 101 + <code>0</code> x 10<U+2070>
</blockquote>
<h2><span class="brown">22. Binary Numbers</span></h2>
Binary is the Base(2) number system with two possibilities : <code>0</code> and <code>1</code>.
Binary was developed by an Indian mathematician called Pingala within Sanskrit poetry.
Now, almost all modern-day computers (except quantum computers that follow the Qubit system) rely on Binary bits, which represent the on (<code>1</code>) and off (<code>0</code>) state of a switch.
<h3>&emsp;Binary To Decimal Number Conversion</h3>
To convert a Decimal number to the Binary number system, we use the Base(2) notation as follows:
<blockquote>
<code>1</code> (binary) = <code>1</code> x 2<U+2070> = <code>1</code> (decimal)
<code>1010</code> (binary) = <code>1</code> x 23 + <code>0</code> x 22 + <code>1</code> x 21 + <code>0</code> x 2<U+2070> = <code>10</code> (decimal)
</blockquote>
<h3>&emsp;Decimal To Binary Number Conversion</h3>
To convert a decimal number <code>N</code> to binary, the steps are as follows:
Divide the number <code>N</code> by 2 and store the remainder in a list.
Keep doing this till you reach <code>0</code>
At this point reserve your list of remainders, which will be the resultant binary number
For example, 88 can be converted to binary as:
<code>88/2 = 44</code> (remainder = <code>0</code>)
<code>44/2 = 22</code> (remainder = <code>0</code>)
<code>22/2 = 11</code> (remainder = <code>0</code>)
<code>11/2 = 5</code> (remainder = <code>1</code>)
<code>5/2 = 2</code> (remainder = <code>1</code> )
<code>2/2 = 1</code>(remainder = <code>0</code>)
<code>1/2 = 0</code> (remainder = <code>1</code>)
The remainder can be written as <code>0001101</code>.
To get the result, change the least significant bit to the most significant bit i.e. <code>1011000</code>
<h3>&emsp;Addition</h3>
When adding binary numbers, the result is the largest number out of the two added.
<code>0</code> + <code>0</code> = <code>0</code>
<code>1</code> + <code>0</code> = <code>1</code>
<code>0</code> + <code>1</code> = <code>1</code>

In the case of <code>1</code> + <code>1</code>, the result is <code>0</code> and we carry over <code>1</code>.

The 1's complement of a binary number is calculated by substitution of all its ones with zeros and vice versa.
For example, the 1s complement of <code>10101</code> is <code>01010</code>.
<blockquote>1s complement represents the bitwise <code>NOT</code> logical operation.</blockquote>
<h3>&emsp;2s Compliment of Binary Numbers</h3>
The 2s complement of a binary number is calculated by calculating the 1s complement and adding 1 to the least significant bit (LSB) of the given result.
For example:
The 2s complement of <code>1010</code> is:
Step 1: Calculate the 1s complement i.e. <code>0101</code>
Step 2: Add 1 to the LSB i.e. <code>0101</code> + <code>0001</code> = <code>0110</code>

<blockquote>2s complements are used to represent signed integers.</blockquote>
<h3>&emsp;Subtraction</h3>
The following rules apply when subtracting two binary numbers:
<code>0</code>C<code>0</code> = <code>0</code>
<code>1</code>C<code>0</code>= <code>1</code>
<code>1</code>C<code>1</code>= <code>0</code>

If the case of <code>0</code>C<code>1</code> the result is <code>1</code> and we borrow <code>1</code> from the next higher order number.
For example:
<code>1111</code>  <code>1010</code> = <code>0101</code>
<h3>&emsp;Multiplication</h3>
The following rules apply when multiplying two binary numbers:
<code>0</code> x <code>0</code> = <code>0</code>
<code>0</code>  <code>1</code> = <code>0</code>
<code>1</code>  <code>0</code> = <code>0</code>
<code>1</code>  <code>1</code> = <code>1</code>

Heres a short video from Khan Academy on YouTube that better explains multiplication than just reading it.
<h3>&emsp;Division</h3>
Binary division again is very tough to understand just by reading.
Check out this great video by Neso Academy on YouTube that explains it best.
<h2><span class="brown">23. Hexadecimal Numbers</span></h2>
There are numbers that follow the Base(16) number system.
These are represented by the set below:
<code>{0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F}</code>
Hexadecimal numbers are commonly used:
To represent memory addresses
To represent Media Access Control (MAC) addresses
To define colors
<h3>&emsp;Conversion of Hexadecimal To Decimal</h3>
To convert a Hexadecimal number to a Decimal, we use the Base(16) notation as follows:
<blockquote>
<code>1</code> (hexadecimal) = <code>1</code> x 16<U+2070>= <code>1</code> (decimal)
<code>1ED2</code> (hexadecimal) = <code>1</code> x 163+ <code>E</code> x 162+ <code>D</code> x 161+ <code>2</code>x 16<U+2070>= <code>7890</code> (decimal)
</blockquote>
<h3>&emsp;Conversion of Hexademical To Binary</h3>
The steps to perform this are as follows:
Split the hexadecimal number into single values
Convert each value to a decimal number
Convert the decimal number to a binary number with 4 bits
Combine them all together
For example, <code>1ED2</code> is binary is:
<code>1</code> -&gt; <code>1</code> (decimal) -&gt; <code>0001</code> (binary)
<code>E</code> -&gt; <code>14</code> (decimal) -&gt; <code>1110</code> (binary)
<code>D</code> -&gt; <code>13</code> (decimal) -&gt; <code>1101</code> (binary)
<code>2</code> -&gt; <code>2</code> (decimal) -&gt; <code>0010</code> (binary)
Combine them all to get the result: <code>0001111011010010</code> or <code>1111011010010</code> (removing <code>0</code>s at the beginning)
<h2><span class="brown">24. Endianness</span></h2>
It is the order or sequence of bytes used when storing data in computer memory.
<h3>&emsp;Big-endian System</h3>
Here, the most significant byte of multi-byte data is stored at the smallest memory address and the least significant byte at the largest.
Before transferring data on a network, data is first converted to big-endian.
<img class="lazy" data-src="https://miro.medium.com/max/640/0*nXLsjMDYBPYhJSUI.png">
Big-endian Memory Storage
<h3>&emsp;Little-endian System</h3>
In this system, the least-significant byte is stored at the smallest memory address and vice versa.
Intel-based processors are little-endians.
<img class="lazy" data-src="https://miro.medium.com/max/640/0*Ywu9NH4_lzeRWYme.png">
Little-endian Memory Storage
Note that Bi-endian processors can run in both little and big endian modes.

<h2><span class="brown">25. Boolean Logic</span></h2>
Developed by George Boole, it is a systematic way of encoding Boolean values ( <code>True</code> and <code>False</code>) into variables and performing operations on them (like in algebra).
Boolean variables can be combined using Logic Gates.
Logic Gates perform a logical operation on one or more binary inputs and produce a single binary output.
In a computer, logic gates are implemented using diodes and transistors.
Such logic gates can be combined to form Logic circuits in devices such as multiplexers, registers, arithmetic logic units (ALUs), computer memory, and microprocessors.
<blockquote>0 and <code>1</code> in a Truth table represent the off and on states respectively.</blockquote>
The commonly used logic gates are as follows:
<h3>&emsp;NOT Gate/ Inverter</h3>
It negates/ inverts the input passed to it.
It is a gate that requires only one input.
The <code>NOT</code> logical operation is represented by the negation operator (<code><U+00AC></code>).
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/0*y4Cht5hilTp8A8SP.png">
NOT gate
The <code>NOT</code> gate truth table is as follows:
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/1*JQRmKhdLr22BVuLF3VGHDw.png">
NOT gate Truth table<h3>&emsp;AND Gate</h3>
This gate performs the logical conjunction operation.
This operation is represented by <code></code>.
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/0*cHeqys8_E1yW7iTp.png">
AND Gate
The <code>AND</code> gate truth table is as follows:
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/1*bXSjYBBY_BMhjsjsHTHkzQ.png">
AND gate Truth Table<h3>&emsp;OR Gate</h3>
This gate performs the logical disjunction operation.
This operation is represented by <code></code>.
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/0*cxBWMZoCkJf0VwXi.png">
OR Gate Truth Table
The <code>OR</code> gate truth table is as follows:
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/1*PqdkWXX6_EynmQWra0_19Q.png">
OR gate Truth Table<h3>&emsp;NAND Gate</h3>
It is the complement of the <code>AND</code> gate.
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/0*JqPe9VXGHwf_-Gu-.png">
NAND Gate
<h3>&emsp;NOR Gate</h3>
It is the complement of the <code>OR</code> gate.
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/0*Ngvb-7dm4ZUczBIf.png">
NOR Gate
<h3>&emsp;XOR Gate</h3>
Also called the Exclusive OR gate, it represents the inequality function, (the output is <code>True</code> if the inputs are not equal and vice versa).
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/0*58Q0q6xlLSS5774o.png">
XOR Gate
<h3>&emsp;XNOR Gate</h3>
It is the complement of the <code>XOR</code> gate.
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/0*ooRSKXEo3bitL5JK.png">
XNOR Gate
The truth tables for all the gates described above can be summarized as:
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/1*2pe7VH1_lsHrsisCwaRJjA.png">
Truth table of Logic Gates

<h2><span class="brown">26. De Morgans Laws</span></h2>
Named after Augustus De Morgan, these laws are as follows:
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/1*XuJE1cmdqlQ0NWOT09ASaQ.png">
Law 1: Not (A and B) is the same as Not A or Not B
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/1*ba4EyhFONqQGIQFPBAl8Ng.png">
Law 2: Not (A or B) is the same as Not A and Not BIn the above laws,
<code>.</code> represents the logical <code>AND</code> operation
<code>+</code> represents the logical <code>OR</code> operation
overbar represents the <code>NOT</code> operation
<code></code> means identical to
In view of sets, De Morgans laws can be represented using Venn Diagrams as follows:
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/0*MXJJhvvMCAD3baDM.png">
De Morgans laws in view of Sets represented with Venn diagrams


<h2><span class="brown">27. Eulers Theorem &amp; Graph Theory</span></h2>
The Graph theory originated in the 18th century with an interesting story.
K<U+00F6>nigsberg was a city in historic Prussia (modern-day Russia) with 7 bridges that crossed river Pregel.
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/0*A4jspKOvmA4CG1DV.png">
The map of K<U+00F6>nigsberg
It was asked:<blockquote>Is it possible to walk around K<U+00F6>nigsberg crossing each bridge exactly once?</blockquote>
Note that it did not matter that we finished exactly where we started.
We will come back to this after learning a few terminologies.
<h3>&emsp;Graph</h3>
A Graph is a mathematical structure that consists of:
vertices (also called nodes or points) (V) which are connected by
edges (also called links or lines) (E)
It is represented as:
<blockquote>G = (V, E)</blockquote>
<h3>&emsp;Degree</h3>
The number of edges of a particular vertex is called its Degree.
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/0*HWKVHIPC1HjiFDd9.png">
A graph with 6 vertices and 7 edges
Graphs are commonly used in computer science to describe relationships between different objects.
For example, Facebook as a graph represents different people (vertices) and their relationships (edges).
Similarly, Wikipedia editors (edges) contributing to different Wikipedia language versions (vertices) during one month in summer, can be described as a graph as below.
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/0*YnO5GjRBx-fLG2V0.png">
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/0*SYdvNS8DZfFJdfzZ.png">
Diagramatic representation of River Pregel in K<U+00F6>nigsberg
Euler first represented the above diagram using a Graph as below.
He described each land mass using a vertex or node, and each bridge with an edge.
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/0*p2IjcZ8C2IjXyvjU.png">
Graph representation of River Pregel in K<U+00F6>nigsberg
Euler came up with a theorem that states that:<blockquote>The bridges of a city can be transversed exactly once if apart from at most two, all points have an even degree.</blockquote>
Looking at the graph representing K<U+00F6>nigsberg, each vertex has an odd degree and hence it is not possible to walk around the city crossing each bridge exactly once.
This theorem gave rise to the modern graph theory i.e. the study of graphs.
<h2><span class="brown">28. Graphs &amp; Types</span></h2>
<h3>&emsp;Directed Graph/ Digraph</h3>
A graph in which edges have orientations.
This means that an edge can only be transversed in one direction.
For example, a graph representing a Medium newsletter and its subscribers.
<h3>&emsp;Undirected Graph</h3>
A graph in which edges do not have orientations.
This means that an edge can be transversed bidirectionally.
For example, a graph representing the relationship between friends on Facebook.
<h3>&emsp;Cycle</h3>
A cycle is a graph with some of its vertices (at least 3) connected in a closed chain.
<h3>&emsp;Cyclic Graph</h3>
It is a graph with at least one cycle.
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/0*6be6VGnaUanCnrqb.png">
A Directed Cyclic Graph
<h3>&emsp;Acyclic Graph</h3>
It is a graph with no cycles.
<h3>&emsp;Connected Graph</h3>
It is a graph with an edge from any vertex to another.
It can be:
Strongly connected: if there any bi-directional edge connections between all vertices
Weakly connected: if there are no bi-directional connections between all vertices
<h3>&emsp;Disconnected Graph</h3>
A graph with no connected vertices is called to be disconnected.
<h2><span class="brown">29. Graph Transversal Algorithms</span></h2>
<h3>&emsp;Depth-first Search</h3>
Depth-first search (DFS) is an algorithm for searching graph data structures.
The algorithm starts at the root node and explores as far as possible along each branch before going back to the start.
Depth-first Search can be defined in Python as below.
Here we define a <code>Node</code> class where its constructor defines its <code>children</code> (connected vertices) and <code>name</code>.
The <code>addChild</code> method adds new children to a node.
The <code>depthFirstSeach</code> method recursively implements the Depth First Search algorithm.
<h3>&emsp;Breadth-first Search</h3>
Breadth-first search (BFS) is another algorithm for searching a graph data structure.
It starts at the root node and explores all nodes at a present branch prior to moving on to the nodes in the other branches.
The algorithm can be defined below using the <code>breadthFirstSearch</code> method of the <code>Node</code> class.
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/0*NJf3dWtUkEdjxfcn.jpg">Portrait of Euclid
<h2><span class="brown">30. Benfords Law</span></h2>
It is an observation followed by many real-life numerical datasets.
In datasets that follow the law, the leading digits are more likely to be small than large.
For example, the number <code>1</code> appears as the leading significant digit about 30% of the time, while 9 appears as the leading significant digit less than 5% of the time.
Benfords law applies to a surprisingly large number of datasets including:
stock prices
population numbers
death rates
physical and mathematical constants etc.
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/0*Jia4Il5pUeym1CsE.png">
Benfords law: The height of the bar is the percentage of numbers that start with that digit
Benfords Law for numbers expressed in base 10, can be mathematically represented as :
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/1*5oAxJIXJfIbxWh5k-iMFJw.png">
where,
<code>P(d)</code> = Probability of occurrence of a leading digit (<code>d</code>)</li>
This law is commonly used to detect fake/ randomly generated datasets (e.g. randomly generated population datasets) as these datasets will not follow Benfords law.
<h2><span class="brown">31. Zipfs Law</span></h2>
It states that the rank-frequency distribution is an inverse relation.
Applied to natural language, it states the frequency of any word is inversely proportional to its rank in the frequency table.
For example, the most frequent word will occur approximately twice as often as the second most frequent word, and three times as often as the third most frequent word.
<blockquote>The <code>n</code>th most common word will occur with a probability proportional to <code>1/n</code>.</blockquote>
Similarly, the law holds true for other datasets such as:
mathematical expressions
ranks of notes in music
income rankings
ranks of the number of people watching the same TV channel
A great video describing Zipfs law can be found below:
<h2><span class="brown">32. Pareto Principle</span></h2>
This principle states that for many real-world outcomes, roughly <code>80%</code> of consequences come from <code>20%</code> of causes.
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/0*_WivJdlpYXUAdzO4.png">
When raising funds, 20% of the donors contribute 80% of the total
Observations following the Pareto principle can be represented by Pareto distributions.
<h3>&emsp;Pareto distribution - Wikipedia</h3>
The Pareto distribution, named after the Italian civil engineer, economist, and sociologist Vilfredo Pareto (
en.wikipedia.org
</a>
Surprisingly, the Pareto principle holds true in computer science as well.
Microsoft noted that by fixing the top 20% of the most-reported bugs, 80% of the related errors and crashes in a given system would be eliminated.
<h2><span class="brown">33. Prices Law</span></h2>
It states that 50% of any given result is generated by the square root of the number of those who contribute to it.
For example, 50% of all publications on a given subject are published by the square root of all authors.
Or, in a company with 100 employees, 10 will produce 50% of all the output.
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*b-EqIsPU9hETs2Mi.jpg"><img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/0*b-EqIsPU9hETs2Mi.jpg">
Portrait of Indian Mathematician Srinivasa Ramanujan

<h2><span class="brown">34. Exponentiation</span></h2>
It is a mathematical operation of raising a number <code>b</code>, called the base, to another number <code>n</code>, called the exponent or power.
When <code>n</code> is a positive number in <code>b^n</code>, it is similar to multiplying <code>n</code> factors of <code>b</code>.</li>
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/1*Mobrmly_95um8PfzvEsAgw.png">
When <code>n</code> is <code>0</code>, <code>b^n</code> is <code>1</code>.
When <code>n</code> is negative, it denotes an inverse i.e. <code>b^-n = 1 / b^n</code>.
When <code>n</code> is a fractional number, it denotes a root i.e.<code> b^1/n = nb</code>

<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/0*6JAf8UFtrX5UFogc.png">
Image from Wikipedia<h3>&emsp;Exponent Rules</h3>
The following identities apply to exponentiation.
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/1*bzK0bRa9y5PgV6sSsqYknA.png">

<h2><span class="brown">37. Infinite Series</span></h2>
It is an ordered sum of infinite terms represented as follows:
<img class="lazy" data-src="https://miro.medium.com/max/640/1*9H7Zny4nlHrKCuM6PpLdWQ.png">
It can also be represented using the \n (sigma) symbol, where the:
subscript represents the lower limit of the series
superscript represents the upper limit of the series
<img class="lazy" data-src="https://miro.medium.com/max/640/1*tm8ih92APPWiG_RQP3l06w.png">
<h3>&emsp;Convergent Series</h3>
It is a series whose partial sums (the sum of the first nth terms) tend to a specific number (limit).
<img class="lazy" data-src="https://miro.medium.com/max/640/1*on5DZzS48FnPcIxy0CAD0g.png">
A Convergent Series with a limit of 1In the above, the sum of the first:
two terms is: <code>1/2</code>
three terms is: <code>3/4</code>
four terms is: <code>7/8</code>

One can see that these sums are approaching <code>1</code> (i.e. the limit).
<h3>&emsp;Divergent Series</h3>
It is a series whose partial sums do tend to a specific number and it has a limit of <code></code> or <code>-</code>.
<img class="lazy" data-src="https://miro.medium.com/max/640/1*kwj_4CzIgbSUtY4Qk0UvNg.png">
Here, the nth partial sums do not tend to a finite limit and keep on growing.
<h3>&emsp;Ramanujan Summation</h3>
It is a technique by the mathematician Srinivasa Ramanujan for assigning a value to divergent series.
Note that partial sums of these series do not converge to the Ramanujan sum (denoted by <code>R</code>).
<img class="lazy" data-src="https://miro.medium.com/max/640/1*AlG7Ou_aicWPEcTjMoFB2g.png">
<img class="lazy" data-src="https://miro.medium.com/max/640/1*-s-DzCI2J5DoiMUbqCXLAw.png">
Ramanujan Summation of a divergent series (2)
<img class="lazy" data-src="https://miro.medium.com/max/640/1*MlEkE4W_LkI_OACWZwyrMg.png">
Ramanujan Summation of a divergent series (3)<h3>&emsp;Geometric Series</h3>It is a series where each successive term is obtained by multiplying the previous term by a constant number (called the common ratio).
<img class="lazy" data-src="https://miro.medium.com/max/640/1*X9smLX3rAO8MTbWKhDBuHg.png">
Geometric series with a common ratio of 1/2<h3>&emsp;Harmonic Series</h3>
It is an infinite series formed by summing all positive unit fractions.
It is always Divergent.
<img class="lazy" data-src="https://miro.medium.com/max/640/1*HGKRlnF5dinukComD4yZhw.png">
<img class="lazy" data-src="https://miro.medium.com/max/640/1*-QMXtxOWMbjuL0yaL_lXuQ.png">
Also, <code>e</code> can be represented as:
<img class="lazy" data-src="https://miro.medium.com/max/640/1*DVvzERt9S8xuL1vfx5A5kA.png">
<h2><span class="brown">38. Taylor Series</span></h2>
It is a series that can represent a mathematical function <code>f(x)</code> at a point <code>a</code> , using polynomials as follows:
<img class="lazy" data-src="https://miro.medium.com/max/640/1*MxFBvFRSTLRTrrAKRC-kpQ.png">
or,
<img class="lazy" data-src="https://miro.medium.com/max/640/1*wyfGSOBkPVJoTTHgzCJbyA.png">
<img class="lazy" data-src="https://miro.medium.com/max/640/0*CCHd9nruqvEeA-5q.png">
sin (x) and its Taylor approximations by polynomials of degrees 1, 3, 5, 7, 9, 11, and 13 at x = 0
As the degree of the Taylor polynomial rises, it approaches the correct function.
Below-mentioned is a beautiful demonstration of the Taylor series and a highly recommended video.
<h2><span class="brown">39. Eulers Formula</span></h2>
This formula forms a link between trigonometry and complex exponential functions.
<img class="lazy" data-src="https://miro.medium.com/max/640/1*WHYmPGfOx3L-u26G-Dcc-g.png">
<img class="lazy" data-src="https://miro.medium.com/max/640/1*Yn43n88Z2RbYG56_rDQKDQ.png">
Eulers identitywhere:
<code>e</code> is Eulers number
<code>i</code> is the imaginary unit
<code></code> is the ratio of the circumference of a circle to its diameter
<h2><span class="brown">40. Quantum Algorithms</span></h2>
Classical computers understand instructions represented in the form of binary bits ( <code>0</code> and <code>1</code>).
On the other hand, quantum computers work on instructions represented by Qubits.
A Qubit represents <code>0</code> and <code>1</code> at the same time (called Superposition).
A Quantum algorithm is a finite sequence of instructions for solving a problem using a Quantum computer (machines that follow principles of Quantum Superposition &amp; Entanglement).

It is a quantum algorithm that is used to find the prime factors of an integer (<code>N</code>) in Polylogarithmic time (<code>O((log(N))c) where c is a constant</code>).
<blockquote>Note that there is no classical computer algorithm known that can factor integers in polynomial time.</blockquote>
Shors algorithm can break public-key cryptography (e.g. the RSA scheme) but if this happens, this can be replaced by quantum-resistant cryptographic techniques.
<h3>&emsp;Grovers algorithm</h3>
It is a quantum algorithm used to search unstructured data in <code>O(N)</code>time.
<blockquote>Note that classical computer algorithms usually perform search operations in <code>O(N)</code> time.</blockquote>
<h2><span class="brown">41. P vs. NP Problem</span></h2>
A problem that can be solved in the polynomial time complexity is called to be a problem of type/class <code>P</code> or polynomial time.
On the other hand, a problem whose solution can be verified in polynomial time is of the type/class <code>NP</code> or nondeterministic polynomial time.
It remains one of the largest unsolved problems in mathematics and computer science whether <code>P = NP</code>.
In other words:
<blockquote>If the solution to a problem is easy to verify, must the problem be easy to solve?</blockquote>
For example, Sudoku is in <code>NP</code> (quickly checkable) but does not seem to be in <code>P</code> (quickly solvable).
Similarly finding Proof of Work for a blockchain network, is an <code>NP</code> type problem.
If you are new to the concept of Proof of Work, check it out here:
<a rel="noopener  ugc nofollow" target="_blank" href="/100-essential-web-3-concepts-that-one-should-know-about-part-2-11-20-ec997ef6dffd">
<h3>&emsp;100 Essential Web-3 Concepts That One Should Know About (Part 2: 11C20)</h3>
Your guide to demystifying Web-3
levelup.gitconnected.com
</a>
<h3>&emsp;NP-Complete Problems</h3>
These are problems that do not have a polynomial-time algorithm to solve them to date nor is proof available that no polynomial-time algorithm exists to solve them.
Interestingly, one <code>NP</code>-complete problem can simulate every other i.e. if any one of the <code>NP</code>-complete problems can be solved in polynomial time, then all of them could be.
To prove that a problem is <code>NP</code>-complete:
first, prove that it is in <code>NP</code>,
then to reduce a known <code>NP</code>-complete problem to it
Some common <code>NP</code>-complete problems are:
Boolean satisfiability problem (SAT)
Knapsack problem
Hamiltonian path problem
Travelling salesman problem
Subgraph isomorphism problem
Subset sum problem
Clique problem
Vertex cover problem
Independent set problem
Dominating set problem
Graph coloring problem
<h2><span class="brown">42. Optimization</span></h2>
It is a technique for finding the parameters that maximize or minimize the value of a mathematical function.
<h3>&emsp;The Diet Problem</h3>
It is a real-world optimization problem proposed by George Stigler that states:
<blockquote>What is the cheapest combination of 77 available foods to feed a moderately active man on a daily basis so that his recommended dietary intake of 9 key nutrients is satisfied?</blockquote>
This is a problem to which Linear Optimization can be applied.
In other words, the problem can be represented using linear functions.
According to Stiglers calculations, the annual cost of his solution was <code>$39.93</code>.
<h3>&emsp;Gradient Descent</h3>
Shown below is Gradient descent, an optimization algorithm commonly used to train machine learning models and neural networks.
The algorithm aims to minimize the loss function associated with a machine learning model with respect to its parameters, to make it more accurate.
<img class="lazy" data-src="https://miro.medium.com/v2/resize:fit:640/0*12_0NEkOFL4GkzGj.png">
Gradient Descent Optimization Algorithm (Source: https://www.ibm.com/topics/gradient-descent)
<img class="lazy" data-src="https://miro.medium.com/max/640/1*YY1--D_CrMfSDKL6wg7cCw.jpeg">Image by Freepik
<h2><span class="brown">43. Chaos Theory</span></h2>
It is a branch of mathematics that deals with apparently random or unpredictable behavior in deterministic systems.
Chaotic behavior is commonly seen around us in flowing fluids, weather, road traffic, swinging pendulums, and more.
Founder of the modern chaos theory, Edward Lorenz noticed that minute differences in initial conditions can yield widely diverging outcomes for deterministic systems (systems whose future behavior is fully determined by their initial conditions)
This makes them unpredictable in the long term.
Lorenz noticed this during his weather prediction computations if the initial conditions were entered with 6 decimal places, the results were massively different from when 3 decimal places were used.

<img class="lazy" data-src="https://miro.medium.com/max/640/0*yOFBht1VrxfQ9lZ1.gif">Starting the pendulum from a slightly different initial condition results in a vastly different trajectory
<h3>&emsp;Butterfly Effect</h3>
It is an important principle of the Chaos theory that states that tiny changes in the initial conditions can lead to drastic changes in the long-term state of a system.
As Lorenz metaphorically stated, a butterfly flapping its wings in Brazil can influence a tornado in Texas.

An attractor a set of states towards which neighboring states eventually approach in their course.
In the example of a swinging pendulum, the point towards which the pendulum eventually goes stationary is the attractor of this dynamic system.
Lorenz described the earths atmosphere with rolling fluid convection using three nonlinear equations.
<img class="lazy" data-src="https://miro.medium.com/max/640/1*k1m6PpBeZVhVkCOH5ahlQw.png">
Lorenz EquationsThe outputs of these equations form a mysterious curve that never crosses itself, never reaches equilibrium, and demonstrates chaos.
This curve is called the Lorenz Attractor.
<img class="lazy" data-src="https://miro.medium.com/max/640/0*4QHmPO9HSprL1qMZ.gif">Solution of Lorenz equations plotted in the form of the Lorenz attractor with  = 28,  = 10, and  = 8/3

<h2><span class="brown">44. Knapsack Problem</span></h2>
Lets say that there is a thief who has a knapsack/ backpack that can hold a limited amount of weight.
Which boxes from the following should be chosen to maximize the monetary value of stolen goods while keeping the overall weight under or equal to 15 kg?
<img class="lazy" data-src="https://miro.medium.com/max/640/0*35zom5JHnq4jr3dX.png">
Image from WikipediaThis is an optimization problem commonly encountered during resource allocation under constraints.
There is no known algorithm that can give the correct and fastest (polynomial-time) solution to all cases of the problem (The problem is <a rel="noopener ugc nofollow" target="_blank" href="/50-mathematical-concepts-for-better-programming-part-12-5ddb98bd7398">NP-complete).
If we check all possible combinations to find the optimal solution to the problem, this brute-force algorithm takes <code>O(2^n)</code> time i.e. non-polynomial time.
<h2><span class="brown">45. Travelling Salesman Problem</span></h2>
Imagine that there is a salesperson with a list of cities for package delivery.
The problem starts with a question:
<blockquote>What should be the order for them to travel to different cities so that they minimize their total distance?</blockquote>
<h3>&emsp;A Crazy Difficult Algorithmic Problem: Can You Help This Person?</h3>
Solving this better will probably get you the Turning Award!
medium.com
</a>
The solutions to the problem have been described in this wonderful article by Pedram Ataee, in Towards Data Science:
<h3>&emsp;How to Solve Traveling Salesman Problem  A Comparative Analysis</h3>
Through 3 optimization methods: dynamic programming, simulated annealing, and 2-opt
towardsdatascience.com
</a>
A new solution to this problem was recently published and is well explained in the article below:
<h3>&emsp;Computer Scientists Break Traveling Salesperson Record</h3>
"This is a result I have wanted all my career," said David Williamson of Cornell University, who has been studying the
www.quantamagazine.org
</a>
The problem has also been applied in other areas such as astronomy &amp; DNA synthesis.
<h3>&emsp;Mathematicians have found the shortest route to visit 2 million stars</h3>
We have found the best path to take between the stars. The travelling salesman problem, an infamous mathematical puzzle
www.newscientist.com
</a>
<h3>&emsp;Traveling Salesman Applied To DNA Synthesis</h3>
One of the fun things about being a programmer is that algorithms that you know can often be applied in unexpected ways
www.i-programmer.info
</a>

<h2><span class="brown">46. Transcendental Numbers</span></h2>
These are numbers that are not the root of any integer polynomial.
(In contrary to <code>2</code> that can be written as <code>2 = 1.4142..</code>, where<code>2</code> is a rational number and<code>2</code> is an irrational number)
They are also called non-algebraic numbers.
Some important transcendental numbers are:
<code></code> (Pi)
<code>e</code> (Eulers number)
<code>sin(x)</code>
<code>cos(x)</code>
<code>tan(x)</code>
<code>ln(x)</code>
In the above examples, <code>x</code> is algebraic and non-zero.
<h2><span class="brown">47. Picks Theorem</span></h2>
It is a theorem in Discrete Geometry by Georg Pick that is used to calculate the area of an arbitrarily shaped polygon.
To calculate the area, lay the polygon on a grid of points where every point is separated by a unit length.
Next, count the points on the interior (<code>i</code>) and on the boundary of the polygon (including both vertices and points along the sides) (<code>b</code>).
The area of the polygon is given by:
<img class="lazy" data-src="https://miro.medium.com/max/640/1*ww4ApVpwRlY9HoAnK06MwA.png">
Picks theoremIn the example below, <code>i = 7</code> and <code>b = 8</code>.
<img class="lazy" data-src="https://miro.medium.com/max/640/0*1xUcD79UVSLxaGJU.png">
Polygon on a grid with internal points in red and boundary points in green
Hence, its area is calculated as:
<blockquote><code>A = i + b/2 <U+2212> 1 = 7 + 8/2  1 = 10</code></blockquote>
Picks theorem is popularly used in the field of Computer Graphics.
<h2><span class="brown">48. Imaginary &amp; Complex Numbers</span></h2>
Imaginary numbers are real numbers multiplied by <code>i</code>(the imaginary unit or iota).
<blockquote><code>i2 = <U+2212>1</code> or <code>i = -1</code></blockquote>
Complex numbers (<code>z</code>) are a combination of real and imaginary numbers represented as:
<blockquote><code>z = a + i * b</code></blockquote>
where<code>a</code>,<code>b</code> are real numbers and <code>i</code>is the imaginary unit.
<h2><span class="brown">49. Argand Diagram</span></h2>
It is a diagram that represents a complex number on a 2D plane.
Its vertical axis corresponds to the imaginary part and the horizontal axis corresponds to the real part of the complex number.
It is also called the Complex plane.
<img class="lazy" data-src="https://miro.medium.com/max/640/0*Z7tzhYyrTOrJteZ1.png">
The Complex Plane (The distance from the origin to the point z is the modulus or absolute value of z &amp; angle  is the argument of z)

<h2><span class="brown">50. Quaternions</span></h2>
Irish mathematician William Rowan Hamilton extended the Argand Diagram to add two more imaginary components and represented the complex numbers as follows:
<blockquote><code>z = a + bi + cj + dk</code></blockquote>
where <code>a</code>, <code>b</code>, <code>c</code>, and <code>d </code>are real numbers and <code>i</code>, <code>j</code>, <code>k</code> are different imaginary units/ basis vectors.
<blockquote><code>i2 = j2 = k2 = ijk = -1</code></blockquote>
These 4D complex numbers are called Quaternions.
Multiplication of quaternion units represents 90 rotations in the planes of 4-dimensional space.
<img class="lazy" data-src="https://miro.medium.com/max/640/0*LZEQyeaemJc4qwZ9.png">
Multiplication of quaternion units
Complex numbers are extensively used in Quantum Mechanics, a branch of Physics essential in building Quantum computers.
<img class="lazy" data-src="https://miro.medium.com/max/640/0*EiI8hdgP1Q5SO7hg.jpg">IBM Quantum System One Quantum Computer

<script src='https://williamkpchan.github.io/LibDocs/readbook.js'></script>
<script>
var lazyLoadInstance = new LazyLoad({
    elements_selector: ".lazy"
});
</script>
