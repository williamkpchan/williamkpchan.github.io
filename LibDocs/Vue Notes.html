<base target="_blank"><html><head><title>Vue Notes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script type='text/javascript' src='../mainscript.js'></script>
<script>
  var showTopicNumber = false;
</script>
<style>
body{width:80%;margin-left: 10%; font-size:22px;}
strong, h1, h2 {color: gold;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px;}
code{color:#496;}
</style></head><body onkeypress="chkKey()"><center>
<h1>Getting Started with Vue</h1>
<div id="toc"></div></center>
<pre>

<h2>Setup and Installation</h2>
There are two main ways to set up Vue - in a Node project, or directly injected into a static HTML file. 
I'd first like to take a look at setting up Vue in an HTML file, as it's the simplest setup and introduction. 
Those who have only ever used a library like jQuery will be most familiar with this method. 
If you've already used React or another JavaScript framework, feel free to skip to the next section.

We can just create a basic HTML file and add a link to a Vue CDN in the head, and create a <code>&lt;div&gt;</code> with an id of <code>app</code>.

<h3>Static HTML File</h3>
index.html

<code>&lt;!DOCTYPE html>
&lt;html lang="en">
  &lt;head>
    &lt;meta charset="utf-8" />
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge" />
    &lt;meta name="viewport" content="width=device-width,initial-scale=1" />
    &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js">&lt;/script>

    &lt;title>Vue App&lt;/title>
  &lt;/head>

  &lt;body>
    &lt;div id="app">&lt;/div>
  &lt;/body>
&lt;/html></code>

We can create a simple "Hello World" with Vue. 
Using double brackets, we'll render <code>message</code> in <code>app</code>. 
In the <code>&lt;script&gt;</code> tag, we'll link the data and the DOM. 
We create a new <code>Vue</code>, and the <code>message</code> property on <code>data</code> will

index.html

<code>&lt;html lang="en">
  &lt;head>
    &lt;meta charset="utf-8" />
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge" />
    &lt;meta name="viewport" content="width=device-width,initial-scale=1" />
    &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js">&lt;/script>

    &lt;title>Vue App&lt;/title>
  &lt;/head>

  &lt;body>
    &lt;div id="app">{{message}}&lt;/div>

    &lt;script>
      const App = new Vue({
        el: '#app',
        data: {
          message: 'Hello Vue!',
        },
      })
    &lt;/script>
  &lt;/body>
&lt;/html></code>

We can see the data render.


<img src="https://www.taniarascia.com/static/1196b1563a48f699ca40439dd8413cfc/86210/vue1.png">

At this point, it's not very impressive, and it's what you'll learn in <a href="https://vuejs.org/v2/guide/">the introduction of the documentation</a>, but it drives home the important point that Vue is just JavaScript, and there's no need to get nervous about Node, Babel, Webpack, and so on.

<h3>Vue CLI</h3>
More often, you won't be injecting Vue into a static HTML file, but you'll be taking advantage of the Node ecosystem. 
The easiest way we can do this is vue <a href="https://cli.vuejs.org/">Vue CLI</a>, or the Vue Command Line Interface. 
As mentioned in the prerequisites, you should be familiar with Node and npm/yarn and how to work with local and global packages.

First, we'll install Vue CLI.

<code># install with npm
npm i -g @vue/cli @vue/cli-service-global

# install with yarn
yarn global add @vue/cli @vue/cli-service-global</code>

Now that we have Vue CLI installed globally, we can use the <code>vue</code> command anywhere. 
We'll use <a href="https://cli.vuejs.org/guide/creating-a-project.html#vue-create">vue create</a> to start a new project.

<blockquote>
<code>vue create</code> is the equivalent to <code>create-react-app</code>.

</blockquote>
<code>vue create vue-app</code>

You'll be given an option to do default or manual, and we can just select default.

<code>Vue CLI v3.7.0
? Please pick a preset: (Use arrow keys)
❯ default (babel, eslint)
  Manually select features</code>

Once that's done, you can move to the new app that's been created and <code>serve</code> to run the dev server.

<code>cd vue-app
npm run serve
# or
yarn serve</code>

Once that's done, you can navigate to <code>http://localhost:8080/</code> to see the default page.
<img src="https://www.taniarascia.com/static/5cd35242c76a022104f9ab8762a0e8e1/6ab21/vue2.png">

At this point, you're all set up and ready to go with Vue. 
If you're using Visual Studio Code, install the <a href="https://marketplace.visualstudio.com/items?itemName=octref.vetur">Vetur</a> plugin for syntax highlighting, formatting, and so on.

<h3>Vue DevTools</h3>
One final thing to have in your toolbelt while working with Vue is Vue DevTools. 
It's an add-on to regular DeveloperTools which will show you all the information about your components - their state, methods, etc.

<a href="https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?hl=en">Vue DevTools on Chrome</a>

<a href="https://addons.mozilla.org/en-US/firefox/addon/vue-js-devtools/">Vue DevTools on FireFox</a>

<img src="https://www.taniarascia.com/static/d34ebca09bd90df7fe20e5fb4494819a/a4bf0/vue3.png">

<h2>Getting Started</h2>
Congrats, you're all set up! You have a new Vue boilerplate app. 
In the project files, you have a <code>public</code> folder which contains <code>index.html</code>, and an <code>src</code> folder with <code>main.js</code> as the entry point. 
We're introduced to <code>.vue</code> files, with the <code>HelloWorld.vue</code> and <code>App.vue</code> components.

<img src="https://www.taniarascia.com/static/5ca780d4da294dbfdbcfb1ce88d04007/9ae15/vue4.png">

<h3>Entry point</h3>
In <code>main.js</code>, we're bringing in <code>Vue</code> and rendering the App to our app div in <code>index.html</code>. 
This file won't need to change.

src/main.js

<code>import Vue from 'vue'
import App from './App.vue'

Vue.config.productionTip = false

new Vue({
  render: h => h(App),
}).$mount('#app')</code>

<h2>Anatomy of a Vue file</h2>
Anything else we make will be a <code>.vue</code> file, which always consists of three things:

<code>&lt;template&gt;</code>

<code>&lt;script&gt;</code>

<code>&lt;style&gt;</code>

And looks like this:

example.vue

<code>&lt;template>&lt;/template>

&lt;script>
  export default {
    name: 'component-name',
  }
&lt;/script>

&lt;style scoped>&lt;/style></code>

This may seem strange to you, as it did to me at first. 
I originally learned front end coding with a focus on separation of concerns for HTML, CSS, and JavaScript, and here we have all three together. 
Yet JavaScript and the way we design apps has evolved, and keeping our styles and view and component coupled together is generally considered an advantage and improves maintainability.

The data and logic for the component goes in the <code>&lt;script&gt;</code> tag, but only <code>name</code> is required. 
The <code>&lt;style&gt;</code> tag is just CSS. 
We have the advantage of being able to scope the CSS so it only applies to this component and not globally with the <code>scoped</code> attribute.

Now let's start actually building this app.

As always, this tutorial is about functionality, not styles, so I'm just going to link to <a href="https://github.com/taniarascia/primitive">Primitive UI</a> in the <code>index.html</code> file to add some easy default styles.

<code>&lt;link rel="stylesheet" href="https://unpkg.com/primitive-ui/dist/css/main.css" /></code>

<h2>Creating a Component</h2>
Create a file called <code>EmployeeTable.vue</code> in <code>src/components</code>. 
We're going to create a table with some static data in here.

src/components/EmployeeTable.vue

<code>&lt;template>
  &lt;div id="employee-table">
    &lt;table>
      &lt;thead>
        &lt;tr>
          &lt;th>Employee name&lt;/th>
          &lt;th>Employee email&lt;/th>
        &lt;/tr>
      &lt;/thead>
      &lt;tbody>
        &lt;tr>
          &lt;td>Richard Hendricks&lt;/td>
          &lt;td>richard@piedpiper.com&lt;/td>
        &lt;/tr>
        &lt;tr>
          &lt;td>Bertram Gilfoyle&lt;/td>
          &lt;td>gilfoyle@piedpiper.com&lt;/td>
        &lt;/tr>
        &lt;tr>
          &lt;td>Dinesh Chugtai&lt;/td>
          &lt;td>dinesh@piedpiper.com&lt;/td>
        &lt;/tr>
      &lt;/tbody>
    &lt;/table>
  &lt;/div>
&lt;/template>

&lt;script>
  export default {
    name: 'employee-table',
  }
&lt;/script>

&lt;style scoped>&lt;/style></code>

In Vue, the convention is that the filename and import will be in PascalCase, such as <code>EmployeeTable</code>, but when used in a template, this will translate to kebab-case, <code>&lt;employee-table&gt;</code>. 
This uses the proper conventions for JavaScript and HTML respectively.

<blockquote>
I'm wrapping the template in a <code>div</code> which isn't strictly necessary, but a template can only have one root child element, so this makes it easy to add additional elements going forward.

</blockquote>
We're exporting <code>EmployeeTable</code> and importing it into <code>App.vue</code>. 
In our <code>import</code>, we can use <code>@</code> to reference the <code>src</code> folder. 
<code>App.vue</code> knows which components it can use via the <code>components</code> property. 
All imported components must be added there. 
I've also added in some global styles.

src/App.vue

<code>&lt;template>
  &lt;div id="app" class="small-container">
    &lt;h1>Employees&lt;/h1>

    &lt;employee-table />
  &lt;/div>
&lt;/template>

&lt;script>
  import EmployeeTable from '@/components/EmployeeTable.vue'

  export default {
    name: 'app',
    components: {
      EmployeeTable,
    },
  }
&lt;/script>

&lt;style>
  button {
    background: #009435;
    border: 1px solid #009435;
  }

  .small-container {
    max-width: 680px;
  }
&lt;/style></code>

So here's what we have so far.

<img src="https://www.taniarascia.com/static/6c537c31085146adfee3e555bcd1680e/6acbb/vue5.png">

We want to refactor this already to use data in the form of arrays and object as opposed to hard coding all our values into the table. 
So let's add a <code>data()</code> method, and return an <code>employees</code> array. 
We're also going to add IDs to each one to make them uniquely identifiable.

App.vue

<code>import EmployeeTable from '@/components/EmployeeTable.vue'

export default {
  name: 'app',
  components: {
    EmployeeTable,
  },
  data() {
    return {
      employees: [
        {
          id: 1,
          name: 'Richard Hendricks',
          email: 'richard@piedpiper.com',
        },
        {
          id: 2,
          name: 'Bertram Gilfoyle',
          email: 'gilfoyle@piedpiper.com',
        },
        {
          id: 3,
          name: 'Dinesh Chugtai',
          email: 'dinesh@piedpiper.com',
        },
      ],
    }
  },
}</code>

<blockquote>
Data is like React state.

</blockquote>
Now we have this data on <code>App.vue</code>, but we want to pass it to <code>EmployeeTable</code>. 
We can do that by passing the data down as a property. 
An attribute that begins with a colon <code>:</code> will allow you to pass data. 
The more verbose version would be <code>v-bind</code>. 
In this case we'll pass our <code>employees</code> array.

<code>&lt;employee-table :employees="employees" />

&lt;!-- this is the same thing -->
&lt;employee-table v-bind:employees="employees" /></code>

Now on the <code>EmployeeTable</code> side, we want to retrieve that data, so we tell the component that it will receive props, in this case an <code>Array</code>.

EmployeeTable.vue

<code>export default {
  name: 'employee-table',
  props: {
    employees: Array,
  },
}</code>

<blockquote>
You might also see an array of strings instead of each value and type for props, like <code>props: [ &#39;employees&#39; ]</code>, which also works but is less explicit.

</blockquote>
<h3>Loops</h3>
Now that we have the data, we want to loop through the data and display the DOM nodes accordingly. 
We'll do this with the <code>v-for</code> attribute. 
Now that we can retrieve <code>employees</code> in <code>EmployeeTable</code>, we'll display one table row per employee.

EmployeeTable.vue

<code>&lt;template>
  &lt;div id="employee-table">
    &lt;table>
      &lt;!-- ...thead... 
-->
      &lt;tbody>
        &lt;tr v-for="employee in employees" :key="employee.id">
          &lt;td>{{ employee.name }}&lt;/td>
          &lt;td>{{ employee.email }}&lt;/td>
        &lt;/tr>
      &lt;/tbody>
    &lt;/table>
  &lt;/div>
&lt;/template></code>

Vue (like React) has a requirement for uniquely identifying any element in an array, so we'll use <code>:key</code> on the table row and set it to a unique value.

Now our table hasn't changed from a view perspective, but it is now set up to work with data more efficiently.

<img src="https://www.taniarascia.com/static/6c537c31085146adfee3e555bcd1680e/6acbb/vue5.png">

<h2>Working with Forms</h2>
Now we're successfully accomplishing the "Read" portion of a CRUD app, but the next most important thing to do is add the ability to create a new employee. 
We're going to create an add employee form.

Make <code>EmployeeForm.vue</code> and set it up a field to enter name, email, and a button to submit. 
I'll go ahead and create an <code>employee</code> data property with <code>name</code> and <code>email</code> on it.

src/components/EmployeeForm.vue

<code>&lt;template>
  &lt;div id="employee-form">
    &lt;form>
      &lt;label>Employee name&lt;/label>
      &lt;input type="text" />
      &lt;label>Employee Email&lt;/label>
      &lt;input type="text" />
      &lt;button>Add Employee&lt;/button>
    &lt;/form>
  &lt;/div>
&lt;/template>

&lt;script>
  export default {
    name: 'employee-form',
    data() {
      return {
        employee: {
          name: '',
          email: '',
        },
      }
    },
  }
&lt;/script>

&lt;style scoped>
  form {
    margin-bottom: 2rem;
  }
&lt;/style></code>

We'll also need to add this to App.vue

src/components/App.vue

<code>&lt;template>
  &lt;div id="app" class="small-container">
    &lt;h1>Employees&lt;/h1>

    &lt;employee-form />
    &lt;employee-table :employees="employees"/>
  &lt;/div>
&lt;/template>

&lt;script>
  import EmployeeTable from '@/components/EmployeeTable.vue'
  import EmployeeForm from '@/components/EmployeeForm.vue'

  export default {
    name: 'app',
    components: {
      EmployeeTable,
      EmployeeForm,
    },
    data: {
      // ...
    }
  }
&lt;/script></code>

<img src="https://www.taniarascia.com/static/6540a3e97e627d03403ae8f1cced5cac/75719/vue6.png">

Now we have to figure out how to get the data that we're writing in the input into Vue's component state. 
To do that we'll use <code>v-model</code>. 
<a href="https://vuejs.org/v2/guide/forms.html">v-model</a> is some built-in Vue syntactic sugar for updating an input value with an onchange event.

EmployeeForm.vue

<code>&lt;template>
  &lt;div id="employee-form">
    &lt;form>
      &lt;label>Employee name&lt;/label>
      &lt;input v-model="employee.name" type="text" />
      &lt;label>Employee Email&lt;/label>
      &lt;input v-model="employee.email" type="text" />
      &lt;button>Add Employee&lt;/button>
    &lt;/form>
  &lt;/div>
&lt;/template></code>

Now that you've added this, you can see in Vue DevTools that the state of the component changes. 
We just need to submit these values and update the parent (App) state with the new employee object.

<h3>Event listeners</h3>
We want to do an <code>onsubmit</code> event on the form. 
We can do that with <code>v-on:submit</code>, or <code>@submit</code> for short. 
This convention will be the same for <code>@click</code>/<code>v-on:click</code> or any other similar event. 
The <code>submit</code> event also has a handy <code>prevent</code> we can add to it, which is the same as putting <code>event.preventDefault()</code> inside the submit function, since we won't be using the default GET/POST methods provided by forms.

Let's add this to the form, and reference a <code>handleSubmit</code> method we'll make.

EmployeeForm.vue

<code>&lt;form @submit.prevent="handleSubmit">&lt;/form></code>

<h3>Methods</h3>
Now we're going to create our first method on a component. 
Below <code>data()</code>, we can create a <code>methods</code> object, which will contain all the custom methods we create. 
Let's add <code>handleSubmit</code> there.

EmployeeForm.vue

<code>export default {
  name: 'employee-form',
  data() {
    return {
      employee: {
        name: '',
        email: '',
      },
    }
  },
  methods: {
    handleSubmit() {
      console.log('testing handleSubmit')
    },
  },
}</code>

<h3>Emitting events to the parent</h3>
Now if you try to submit the form, you'll see the message logged in the console. 
We know the form submit method is working properly, so we can pass the data up to <code>App</code> now. 
We'll do this using <code>$emit</code>.

Emit broadcasts a name of an event and data to its parent component, like so.

<code>this.$emit('name-of-emitted-event', dataToPass)</code>

In our case, we'll create an event called <code>add:employee</code>, and pass <code>this.employee</code>.

EmployeeForm.vue

<code>handleSubmit() {
  this.$emit('add:employee', this.employee)
}</code>

<blockquote>
The <code>add:employee</code> syntax (as opposed to <code>add-employee</code> or something else) is recommended in <a href="https://vuejs.org/v2/guide/components-custom-events.html#sync-Modifier">the Vue documentation</a>

</blockquote>
Once you add this, click to add form button and go to Vue DevTools. 
You'll see a notification for a new event, and it will tell you the name, source, and payload, which in this case is an object we created.

<img src="https://www.taniarascia.com/static/1a946bea1d7845c8a003af21f6fb2088/9c6b1/vue7.png">

<h3>Retrieving events from the child</h3>
Now <code>employee-form</code> is broadcasting its emitted event, but we need to capture the event and value in the parent to work with it.

The first thing we need to do is make <code>employee-form</code> acknowledge and handle the emitted event, and invoke a new method. 
It will look like this:

<code>&lt;component @name-of-emitted-event="methodToCallOnceEmitted">&lt;/component></code>

So let's add that to <code>App.vue</code>.

App.vue

<code>&lt;employee-form @add:employee="addEmployee" /></code>

Now we just have to create the <code>addEmployee</code> method on <code>App.vue</code>, which will modify the employees array by adding a new item to it. 
That will essentially look like this:

App.vue

<code>methods: {
  addEmployee(employee) {
    this.employees = [...this.employees, employee]
  }
}</code>

Since I have to make an <code>id</code> as well, I'll just write some code to get the new employees ID based on number of items in the array. 
Note that in a real database, this ID would be uniquely generated or auto incremented.

<code>addEmployee(employee) {
  const lastId =
    this.employees.length > 0
      ? this.employees[this.employees.length - 1].id
      : 0;
  const id = lastId + 1;
  const newEmployee = { ...employee, id };

  this.employees = [...this.employees, newEmployee];
}</code>

Now with this, you can add new employees. 
Note that the new employee will not persist, as it is front end only and not connected to a database.

<img src="https://www.taniarascia.com/static/d952f412385fe8e8181ff72201f0aaf6/233cd/vue8.png">

<h2>Basic form validation</h2>
This technically works, but we can clean it up a little. 
We want to...

Show a success message if everything went through

Show an error message if something was missing

Highlight the inputs that have invalid data

Clear the inputs after the form is done submitting properly, and

Focus on the first item in the input after successful submission

<h3>Computed properties</h3>
In Vue, we can use <a href="https://vuejs.org/v2/guide/computed.html">computed properties</a>, which are functions that are automatically computed when something changes. 
This way we can avoid putting complex logic in the Vue template itself. 
I'm just going to put a basic check to make sure the field isn't empty for both fields.

EmployeeForm.vue

<code>computed: {
  invalidName() {
    return this.employee.name === ''
  },

  invalidEmail() {
    return this.employee.email === ''
  },
},</code>

To set all this up, I'm going to add a <code>submitting</code> state, to check whether or not the form is currently being submitted, an <code>error</code> state if something went wrong, and a <code>success</code> state if it went through properly.

EmployeeForm.vue

<code>data() {
  return {
    submitting: false,
    error: false,
    success: false,
    employee: {
      name: '',
      email: '',
    }
  }
}</code>

The submit function will first clear whether or not <code>success</code> or <code>error</code> have been set, the start submitting. 
It'll check our computed properties, and if either is true, an <code>error</code> will be set. 
If not, we can submit, and set all the states back to default.

EmployeeForm.vue

<code>methods: {
  handleSubmit() {
    this.submitting = true
    this.clearStatus()

    if (this.invalidName || this.invalidEmail) {
      this.error = true
      return
    }

    this.$emit('add:employee', this.employee)
    this.employee = {
      name: '',
      email: '',
    }
    this.error = false
    this.success = true
    this.submitting = false
  },

  clearStatus() {
    this.success = false
    this.error = false
  }
}</code>

Since we want an error message and a success message, I'll set up the CSS for that.

EmployeeForm.vue

<code>&lt;style scoped>
  form {
    margin-bottom: 2rem;
  }

  [class*='-message'] {
    font-weight: 500;
  }

  .error-message {
    color: #d33c40;
  }

  .success-message {
    color: #32a95d;
  }
&lt;/style></code>

Finally, we'll set up the form. 
If the form is submitting and one of the computed properties is invalid, we want to set a <code>has-error</code> class on the input. 
Using <code>:class=</code> ensures that the class will be treated as JavaScript instead of a plain string. 
We can make sure the statuses get cleared on focus and keypress events, and we have success and error messages displayed accordingly at the bottom.

EmployeeForm.vue

<code>&lt;form @submit.prevent="handleSubmit">
  &lt;label>Employee name&lt;/label>
  &lt;input
    type="text"
    :class="{ 'has-error': submitting &amp;&amp; invalidName }"
    v-model="employee.name"
    @focus="clearStatus"
    @keypress="clearStatus"
  />
  &lt;label>Employee Email&lt;/label>
  &lt;input
    type="text"
    :class="{ 'has-error': submitting &amp;&amp; invalidEmail }"
    v-model="employee.email"
    @focus="clearStatus"
  />
  &lt;p v-if="error &amp;&amp; submitting" class="error-message">
    ❗Please fill out all required fields
  &lt;/p>
  &lt;p v-if="success" class="success-message">
    ✅ Employee successfully added
  &lt;/p>
  &lt;button>Add Employee&lt;/button>
&lt;/form></code>

<h3>Conditonals</h3>
You'll notice a <code>v-if</code> property. 
This is a <a href="https://vuejs.org/v2/guide/conditional.html">conditional in Vue</a>. 
In this case, the <code>&lt;p&gt;</code> element will only be displayed if the condition is true.

There is also a <code>v-else-if</code>, and <code>v-else</code> property, which work the same as their vanilla JS counterparts.

Now that that's complete, we can see these conditionally rendered elements. 
Here's the error message on a missing field.

<img src="https://www.taniarascia.com/static/ef397872f6bf5b99852e420da96d46e9/995af/vue9.png">

And here's the success message.

<img src="https://www.taniarascia.com/static/825ca1993d6c1c1ff8bf8f35789f9bad/bda01/vue10.png">

<h3>Adding a reference</h3>
There's one more small improvement we can make. 
After submitting the form, it would be nice if the focus went back on the first item to make it easy to add many items without clicking around. 
We can do that with <a href="https://vuejs.org/v2/api/#vm-refs">refs</a>, which we can use to target a specific element.

We can just add a ref to the first input...

EmployeeForm.vue

<code>&lt;input ref="first" ... /></code>

And <code>focus</code> that ref after submitting the form in <code>handleSubmit</code>.

EmployeeForm.vue

<code>this.$emit('add:employee', this.employee)
this.$refs.first.focus()</code>

Now after you submit the focus will automatically go to the first field in the form. 
The <code>@keypress</code> event to <code>clearStatus</code> we added to it before will ensure the success or error message goes away once you start typing.

<blockquote>
Our <code>EmployeeForm</code> file is complete, and you can <a href="https://github.com/taniarascia/vue-tutorial/blob/master/src/components/EmployeeForm.vue">view the source</a> of the completed file in case you got lost along the way.

</blockquote>
<h2>Deleting Items</h2>
Now that the form is done, we have to finish the other actions on the table - editing and deleting. 
We'll start with deleting, which is an easier operation.

First, we'll update the table to have an "Actions" row, and add buttons for editing and deleting.

EmployeeTable.vue

<code>&lt;template>
  &lt;div id="employee-table">
    &lt;table>
      &lt;thead>
        &lt;tr>
          &lt;th>Employee name&lt;/th>
          &lt;th>Employee email&lt;/th>
          &lt;th>Actions&lt;/th>
        &lt;/tr>
      &lt;/thead>
      &lt;tbody>
        &lt;tr v-for="employee in employees" :key="employee.id">
          &lt;td>{{ employee.name }}&lt;/td>
          &lt;td>{{ employee.email }}&lt;/td>
          &lt;td>
            &lt;button>Edit&lt;/button>
            &lt;button>Delete&lt;/button>
          &lt;/td>
        &lt;/tr>
      &lt;/tbody>
    &lt;/table>
  &lt;/div>
&lt;/template>

&lt;style scoped>
  button {
    margin: 0 0.5rem 0 0;
  }
&lt;/style></code>

We'll emit an event like before, this time called <code>deleteEmployee</code>. 
We can pass the <code>id</code> of the employee as the payload.

EmployeeTable.vue

<code>&lt;button @click="$emit('delete:employee', employee.id)">Delete&lt;/button></code>

Back in <code>App.vue</code>, we have to tell <code>employee-table</code> to perform an action on <code>delete-employee</code>...

App.vue

<code>&lt;employee-table :employees="employees" @delete:employee="deleteEmployee" /></code>

And we'll filter the deleted row out.

App.vue

<code>methods: {
  addEmployee(employee) {...},
  deleteEmployee(id) {
    this.employees = this.employees.filter(
      employee => employee.id !== id
    )
  }
}</code>

Now you'll notice you can delete items. 
Let's just add a message in case there are no employees.

EmployeeTable.vue

<code>&lt;div id="employee-table">
  &lt;p v-if="employees.length &lt; 1" class="empty-table">
    No employees
  &lt;/p>
  &lt;table v-else>
    ...
  &lt;/table>
&lt;/div></code>

We can successfully add and delete employees now.

<img src="https://www.taniarascia.com/static/e80f851c9e6132a6169c28249c0d7eb2/5b9b6/vue11.png">

<h3>Editing Items</h3>
Editing is a little more complex than deleting. 
The setup from <code>App.vue</code> is simple though, so we'll do that first. 
Just add the <code>edit:employee</code> event that we'll be making:

App.vue

<code>&lt;employee-table
  :employees="employees"
  @delete:employee="deleteEmployee"
  @edit:employee="editEmployee"
/></code>

And create the <code>editEmployee</code> method, which will take <code>id</code> and <code>updatedEmployee</code> parameters, map through the <code>employees</code> array, and update the correct employee.

App.vue

<code>editEmployee(id, updatedEmployee) {
  this.employees = this.employees.map(employee =>
    employee.id === id ? updatedEmployee : employee
  )
}</code>

Simple enough.

Now back in <code>EmployeeTable.vue</code>, we'll basically want to make an "edit mode" that is enabled when the button is pressed.

EmployeeTable.vue

<code>&lt;button @click="editMode(employee.id)">Edit&lt;/button></code>

We'll create an <code>editing</code> state that will get set to the <code>id</code> of the row that's currently being edited when <code>editMode</code> is enabled. 
<code>EmployeeTable</code> will have it's own local <code>editEmployee</code> method, which emits <code>edit:employee</code> to <code>App</code> if the fields aren't empty, and resets the <code>editing</code> state.

EmployeeTable.vue

<code>data() {
  return {
    editing: null,
  }
},
methods: {
  editMode(id) {
    this.editing = id
  },

  editEmployee(employee) {
    if (employee.name === '' || employee.email === '') return
    this.$emit('edit:employee', employee.id, employee)
    this.editing = null
  }
}</code>

Here's the current state of our table row - we're just displaying the values.

<code>&lt;tr v-for="employee in employees" :key="employee.id">
  &lt;td>{{ employee.name }}&lt;/td>
  &lt;td>{{ employee.email }}&lt;/td>
  &lt;td>
    &lt;button @click="editMode(employee.id)">Edit&lt;/button>
    &lt;button @click="$emit('delete:employee', employee.id)">
      Delete
    &lt;/button>
  &lt;/td>
&lt;/tr></code>

To make it editable, we'll check if <code>editing === employee.id</code> is true for a particular row, and display and input instead. 
We'll also add a cancel button that will cancel the editing by setting it to null.

<code>&lt;tr v-for="employee in employees" :key="employee.id">
  &lt;td v-if="editing === employee.id">
    &lt;input type="text" v-model="employee.name" />
  &lt;/td>
  &lt;td v-else>{{employee.name}}&lt;/td>
  &lt;td v-if="editing === employee.id">
    &lt;input type="text" v-model="employee.email" />
  &lt;/td>
  &lt;td v-else>{{employee.email}}&lt;/td>
  &lt;td v-if="editing === employee.id">
    &lt;button @click="editEmployee(employee)">Save&lt;/button>
    &lt;button class="muted-button" @click="editing = null">Cancel&lt;/button>
  &lt;/td>
  &lt;td v-else>
    &lt;button @click="editMode(employee.id)">Edit&lt;/button>
    &lt;button @click="$emit('delete:employee', employee.id)">Delete&lt;/button>
  &lt;/td>
&lt;/tr></code>

And now I can edit a single row at a time!

<img src="https://www.taniarascia.com/static/ed682041260a6a0bb0c07cb51f805d21/f4ad5/vue12.png">

Editing works, but you still can't cancel the state from updating with this code, even if the new values don't get sent to the API call. 
We'll create <code>cancelEdit</code>, and make the cancel button call <code>@click=&quot;cancelEdit(employee)&quot;</code> and remove <code>.id</code> from the edit button. 
We'll make a cached employee that we can return to.

<code>editMode(employee) {
  this.cachedEmployee = Object.assign({}, employee)
  this.editing = employee.id
},
cancelEdit(employee) {
  Object.assign(employee, this.cachedEmployee)
  this.editing = null;
}</code>

At this point, the app is technically complete, but a real production app will probably be making API calls to a back end database, so we'll make a mock version of that.

<blockquote>
If you'd like to view a completed version of the app before we get into the API calls, you can <a href="https://codesandbox.io/s/m3126z3w8p">view this CodeSandbox demo</a>].

</blockquote>
<h2>Making Asynchronous REST API Calls</h2>
We're going to use <a href="https://jsonplaceholder.typicode.com">JSON Placeholder</a> to make fake API calls that will give us real responses. 
We can <code>GET</code> values (for example, visit <a href="https://jsonplaceholder.typicode.com/users">https://jsonplaceholder.typicode.com/users</a> to see the <code>users</code> JSON we'll be using), and we can make <code>POST</code>, <code>PUT</code>, and <code>DELETE</code> requests. 
These requests will not persist in a real database because they're for example purposes.

<blockquote>
If you're not familiar with REST, please <a href="https://code.tutsplus.com/tutorials/code-your-first-api-with-nodejs-and-express-understanding-rest-apis--cms-31697">read this article</a>

</blockquote>
An asynchronous method with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">async/await</a> will look something like this, using a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch">try/catch</a> block.

<blockquote>
We'll use the built-in <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a> that Node and the browser have access to, however other options like <a href="https://github.com/axios/axios">Axios</a> are available and popular. 
I just prefer to use Fetch because it's one less dependency to install for example purposes.

</blockquote>
<code>async asynchronousMethod() {
  try {
    const response = await fetch('url')
    const data = await response.json()

    // do something with `data`
  } catch (error) {
    // do something with `error`
  }
}</code>

So at this point, I'll replace all our CRUD methods with <code>async</code> methods, and update the data via the API as well as the front end.

<h3>Lifecycle methods</h3>
With GET, we'll want to remove all the pre-populated data we have in the <code>employees</code> array, and replace it with the data from the API. 
We'll call that <code>GET</code> in the <code>mounted</code> <a href="https://vuejs.org/v2/guide/instance.html#Lifecycle-Diagram">lifecycle method</a>.

<blockquote>
If you're familiar with React, you'll know about lifecycle methods already, and this is the Vue equivalent of <code>componentDidMount</code>.

</blockquote>
<a href="https://vuejs.org/v2/api/#mounted"><code>mounted</code></a> tells our component to perform the action once the component is actually inserted to the DOM. 
This is a common way to display data from an API. 
(Some use the <code>created</code> lifecycle for this task.)

App.vue

<code>export default {
  name: 'app',
  components: {
    EmployeeTable,
    EmployeeForm,
  },
  data() {
    return {
      employees: [],
    }
  },

  mounted() {
    this.getEmployees()
  },
}</code>

So now we can update all our CRUD methods with their asynchronous API-call equivalents.

<h3>GET</h3>
Retrieve a resource.

App.vue

<code>async getEmployees() {
  try {
    const response = await fetch('https://jsonplaceholder.typicode.com/users')
    const data = await response.json()
    this.employees = data
  } catch (error) {
    console.error(error)
  }
}</code>

<h3>POST</h3>
Create a new resource (non-idempotent).

App.vue

<code>async addEmployee(employee) {
  try {
    const response = await fetch('https://jsonplaceholder.typicode.com/users', {
      method: 'POST',
      body: JSON.stringify(employee),
      headers: { 'Content-type': 'application/json; charset=UTF-8' },
    })
    const data = await response.json()
    this.employees = [...this.employees, data]
  } catch (error) {
    console.error(error)
  }
}</code>

<h3>PUT</h3>
Update an exiting resource (idempotent).

App.vue

<code>async editEmployee(id, updatedEmployee) {
  try {
    const response = await fetch(`https://jsonplaceholder.typicode.com/users/${id}`, {
      method: 'PUT',
      body: JSON.stringify(updatedEmployee),
      headers: { 'Content-type': 'application/json; charset=UTF-8' },
    })
    const data = await response.json()
    this.employees = this.employees.map(employee => (employee.id === id ? data : employee))
  } catch (error) {
    console.error(error)
  }
}</code>

<h3>DELETE</h3>
Remove an existing resource.

App.vue

<code>async deleteEmployee(id) {
  try {
    await fetch(`https://jsonplaceholder.typicode.com/users/${id}`, {
      method: "DELETE"
    });
    this.employees = this.employees.filter(employee => employee.id !== id);
  } catch (error) {
    console.error(error);
  }
}</code>

Okay, all API calls should be working properly, and we're getting data from JSON Placeholder instead of our own, static data.

<img src="https://www.taniarascia.com/static/5183a389429e3e57c5cea4314fdc21b5/a81ca/vue13.png">

And the app is complete! You can <a href="https://taniarascia.github.io/vue-tutorial/">check out the live demo</a> or <a href="https://github.com/taniarascia/vue-tutorial">view the source</a>.

<h2>Deploying a Build to GitHub Pages</h2>
You might want to deploy your newly completed app to GitHub pages, a static site host. 
Assuming you've already created a repository and committed to master, using the steps below...

<code>git remote add origin https://github.com/username/vue-app
git add .
git commit -m "initial commit"
git push -u origin master</code>

You can commit the build with the following steps:

Create a <code>gh-pages</code> branch.

<code>git checkout -b gh-pages</code>

Remove the <code>dist</code> directory from <code>.gitignore</code>.

Create <code>vue.config.js</code> and add the <code>publicPath</code> of your GitHub

vue.config.js

<code>module.exports = {
  publicPath: 'vue-app',
}</code>

Create a build, which will output the <code>dist</code> folder.

<code>npm run build
# or
yarn build</code>

Add the build, commit, and send it to <code>gh-pages</code> on GitHub.

<code>git add dist
git commit -m "gh-pages commit"
git subtree push --prefix dist origin gh-pages</code>

And within a minute or two, it should be all hosted!

<h2>Conclusion</h2>
Wow, that was a lot. 
We learned what Vue is, how to set up a Vue project via static HTML or Vue Cli, and how to make a complete CRUD app in Vue. 
We learned about Vue components, data, methods, computed methods, lifecycles, conditionals, events, form handling, and building. 
If you went through and did this whole tutorial, you should feel pretty good starting to build your own apps from scratch in Vue.

From here, you might want to look into <a href="https://vuex.vuejs.org/">Vuex</a> for state management (similar to React's Redux), and <a href="https://router.vuejs.org/">Vue Router</a> for front-end routing (similar to React Router DOM). 
The great part about the Vue environment is that it's batteries optional, but official batteries also included should you need it.

A lot of work went into creating this app and tutorial, and if you enjoyed it I hope you share it with anyone you think might benefit from it! If you see any mistakes, please let me know.

<a href="https://github.com/taniarascia/vue-tutorial">View Source</a>

<a href="https://taniarascia.github.io/vue-tutorial/">View Demo</a>

<h2></h2>
<h2>Vue.js 3 Tutorial - Build An App with New Features of Vue 3</h2>

Vue.js 3 has not officially been released yet, but the maintainers have released experimental "alpha" versions. 
These cannot be used in production apps, but are great for you to try out and learn some of the new features.
The only problem is that the Vue docs haven't been updated for version 3, so it takes a bit of digging around to figure out exactly what's different.
In this article, I'll walk you through the creation of a simple app using an alpha version of Vue 3, with the specific intention of highlighting new features.
<em>Note that this article is current for alpha version 8. 
Some of the syntax shown could change in later versions.</em>
<h3>Should you wait for the v3 release before learning Vue?</h3>
If you're new to Vue.js, you'll need to start by learning version 2, as that is presumed knowledge for this tutorial.
However, don't feel like you're wasting your time learning Vue 2 when Vue 3 is on the horizon. 
While some APIs will be added or changed, almost all of the key features and patterns of Vue 2 will still be used in Vue 3.
<blockquote>I have an <a href="https://courses.vuejsdevelopers.com/p/build-your-first-vue-js-app">introductory course on Vue 2</a> which is a great place to start.
</blockquote> 

<h2>Vue 3 installation and setup</h2>
Rather than installing Vue 3 directly, let's clone the project <code>vue-next-webpack-preview</code> which will give us a minimal Webpack setup including Vue 3.

<code>$ git clone https://github.com/vuejs/vue-next-webpack-preview.git vue3-experiment
$ cd vue3-experiment
$ npm i
</code>
Once that's cloned and the NPM modules are installed, all we need to do is remove the boilerplate files and create a fresh <code>main.js</code> file so we can create our Vue app from scratch.

<code>$ rm -rf src/*
$ touch src/main.js
</code>
Now we'll run the dev server:

<code>$ npm run dev
</code>
<h2>Creating a new Vue app</h2>
Straight off the bat, the way we bootstrap a new Vue app has changed. 
Rather than using <code>new Vue()</code>, we now need to import the new <code>createApp</code> method.
We then call this method, passing our Vue instance definition object, and assign the return object to a variable <code>app</code>.
Next, we'll call the <code>mount</code> method on <code>app</code> and pass a CSS selector indicating our mount element, just like we did with the <code>$mount</code> instance method in Vue 2.
<em>main.js</em>

<code>import { createApp } from "vue";

const app = createApp({
 // root instance definition
});

app.mount("#app");
</code>
<h4>Reason for change</h4>
With the old API, any global configuration we added (plugins, mixins, prototype properties etc) would <em>permanently mutate global state</em>. 
For example:
<em>main.js</em>

<code>// Affects both instances
Vue.mixin({ ... 
})

const app1 = new Vue({ el: '#app-1' })
const app2 = new Vue({ el: '#app-2' })
</code>
This really shows up as an issue in unit testing, as it makes it tricky to ensure that each test is isolated from the last.
Under the new API, calling <code>createApp</code> returns a fresh app instance that will not be polluted by any global configuration applied to other instances.
Learn more: <a href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0009-global-api-change.md">Global API change RFC</a>.
<h2>Adding state properties</h2>
In this tutorial, we'll create a classic "counter" app that allows a user to click a button to increment a displayed integer.
So let's add a new state property <code>count</code> which we'll give an initial value of <code>0</code>.
Under Vue 2, we could do this by creating a <code>data</code> property on our app instance and assigning an object to this where our <code>count</code> property would be declared i.e.:
<em>main.js</em>

<code>const app = createApp({
 data: {
   count: 0
 }
});
</code>
This is no longer allowed. 
Instead, <code>data</code> must be assigned a <em>factory function which returns the state object</em>.
This is what you had to do for Vue components, but now it's enforced for Vue app instances as well.
<em>main.js</em>

<code>const app = createApp({
 data: () => ({
   count: 0
 })
});
</code>
<h4>Reason for change</h4>
The advantage of using an object for data rather than a factory function is that, firstly, it was syntactically simpler, and secondly, you could share top-level state between multiple root instances e.g.:
<em>main.js</em>

<code>const state = {
 sharedVal: 0
};

const app1 = new Vue({ state });
const app2 = new Vue({ state });

// Affects both instances
app1._data.sharedVal = 1;
</code>
The use case for this is rare and can be worked around. 
Since having two types of declarations is not beginner-friendly, it was decided to remove this feature.
Learn more: <a href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0019-remove-data-object-declaration.md">Data object declaration removed RFC</a>
Before we move on, let's also add a method to increment the <code>count</code> value. 
This is no different from Vue 2.
<em>main.js</em>

<code>const app = createApp({
 data: () => ({
   count: 0  
 }),
 methods: {
   inc() {
     this.count++;
   }
 }
});
</code>
<h2>Using a root component</h2>
If you go to the browser now and check the console, you'll see the warning "Component is missing render function", since we haven't yet defined a template for the root instance.
The best practice for Vue 2 is to create a minimal template for the root instance and create an <code>App</code> component where the main app markup will be declared.
Let's do that here, as well.

<code>$ touch src/App.vue
</code>
Now we can get the root instance to render that component. 
The difference is that with Vue 2, we'd normally use a render function for doing this:
<em>main.js</em>

<code>import App from "./App.vue";

const app = createApp({
 ...
 render: h => h(App)
});

app.mount("#app");
</code>
We can still do that, but Vue 3 has an even easier way - making <code>App</code> a <em>root component</em>. 
To do this, we can remove the root instance definition and instead pass the <code>App</code> component.
<em>main.js</em>

<code>import App from "./App.vue";

const app = createApp(App);

app.mount("#app");
</code>
This means the <code>App</code> component is not just rendered by the root instance but <em>is</em> the root instance.
While we're at it, let's simply the syntax a little by removing the <code>app</code> variable:
<em>main.js</em>

<code>createApp(App).mount("#app");
</code>
Moving over to the root component now, let's re-add the state and method to this component:
<em>App.vue</em>

<code>&lt;script>
export default {
 data: () => ({
   count: 0  
 }),
 methods: {
   inc() {
     this.count++;
   }
 }
};
&lt;/script>
</code>

<h2>Creating a template</h2>
Let's now create a template for our root component. 
We'll use a text interpolation to display the count, and we'll add a button with a click handler to increment our counter.
<em>App.vue</em>

<code>&lt;template>
 &lt;span>Button clicked {{ count }} times.&lt;/span>
 &lt;button @click="inc">Inc&lt;/button>
&lt;/template>
&lt;script>
...
&lt;/script>
</code>
Notice anything odd about this template? Look again. 
I'll wait.
That's right - there are two root elements. 
In Vue 3, thanks to a feature called <em>fragments</em>, it is no longer compulsory to have a single root element.
<h2>Composition API</h2>
The flagship feature of Vue 3 is the <em>Composition API</em>. 
This new API allows you to define component functionality using a <code>setup</code> function rather than with properties you add to the component definition object.
Let's now refactor our <em>App</em> component to use the Composition API.
Before I explain the code, be clear that all we're doing is <em>refactoring</em> - the functionality of the component not changed at all. 
Also note that the template is not changed as the Composition API only affects the way we define the component functionality, not the display.
<em>App.vue</em>

<code>&lt;template>
 &lt;span>Button clicked {{ count }}&lt;/span>
 &lt;button @click="inc">Inc&lt;/button>
&lt;/template>
&lt;script>
import { ref } from "vue";
export default {
 setup () {
   const count = ref(0);
   const inc = () => {
     count.value++;
   };
   return {
     count,
     inc
   }
 }
};
&lt;/script>
</code>
<h4><code>setup</code> method</h4>
Firstly, notice we import the <code>ref</code> function which allows us to define a reactive variable <code>count</code>. 
This variable is equivalent to <code>this.count</code>.
The <code>inc</code> method is just a plain JavaScript function. 
However, notice that to change the value of <code>count</code> in the method body, we need to change its sub-property <code>value</code>. 
That's because reactive variables created using <code>ref</code> are wrapped in an object. 
This is necessary to retain their reactivity as they're passed around.
<blockquote>It's best to consult the <a href="https://vue-composition-api-rfc.netlify.com/#api-introduction">Vue Composition API docs</a> if you want a detailed explanation of how <code>refs</code> work.
</blockquote> Finally, we return <code>count</code> and <code>increment</code> from the <code>setup</code> method, as these are the values that get passed to the template when it's rendered.
<h4>Reason for change</h4>
Keep in mind that the Composition API is not a <em>change</em> as it's purely optional to use. 
The main motivation is to allow for better code organization and the reuse of code between components (as mixins are essentially an anti-pattern).
You'd be correct in thinking that refactoring the <code>App</code> component to use the Composition API is unnecessary. 
But, if this were a much larger component, or we needed to share its features with other components, that's when you'd see its usefulness.
Providing a more in-depth example is beyond the scope of this blog post, so if you're interested to learn more about uses of the new API, check out my article <a href="/2020/02/17/vue-composition-api-when-to-use">When To Use The New Vue Composition API (And When Not To)</a>.
<h2>What's in the next update</h2>
I've only had time to include about half of the new changes I wanted to cover in this tutorial. 
Here are some other new features that I'll be including in the next update:
Changes to slots
Changes to events
Changes to transitions
Portals

<script type='text/javascript' src='readbook.js'></script>
</pre>
</body>
</html>
