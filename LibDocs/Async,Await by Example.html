<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width"/>
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script>
$(document).ready(function(){
    $('h1, h2, h3, h4, h5, .goldword, strong,  div.title').click(function(){
    parent.history.back();
    return false;
    });
});
</script>
<style>
body{width:80%;margin-left: 10%}
strong, h1, h2 {color: gold;}
</style>
</head><body>
<center><h1>Async,Await by Example</h1>
<div id="toc"></div></center>
<br>
<br>
<br>

<h2>Async/Await explained through a clear example.</h2>
<h4>Prerequisites</h4>
ES 2017 introduced <strong>Asynchronous</strong> functions. <br>
Async functions are essentially a cleaner way to work with asynchronous code in JavaScript. <br>
In order to understand exactly what these are, and how they work, we first need to understand <strong>Promises</strong>.
If you don’t know what Promises are, you should<strong> </strong>
<a href="https://codeburst.io/javascript-learn-promises-f1eaa00c5461" target="_blank">
<strong>read this article I published on Promises</strong>
</a>
<strong> before proceeding</strong>. <br>
<strong>You will not understand Async/Await in JavaScript until you understand Promises.</strong>

<h4>What is Async/Await?</h4>
<ul>
<li>The newest way to write asynchronous code in JavaScript.</li>
<li>It is non blocking (just like promises and callbacks).</li>
<li>Async/Await was created to simplify the process of working with and writing chained promises.</li>
<li>Async functions return a Promise. <br>
If the function throws an error, the Promise will be rejected. <br>
If the function returns a value, the Promise will be resolved.</li>
</ul>
<h4>Syntax</h4>
Writing an async function is quite simple. <br>
You just need to add the <code>async</code> keyword prior to <code>function</code>:
<pre>
<strong>// Normal Function</strong>
</pre>
<pre>function add(x,y){<br>  return x + y;<br>}</pre>
<pre>
<strong>// Async Function</strong>
</pre>
<pre>async function add(x,y){<br>  return x + y;<br>}</pre>
<h4>Await</h4>
Async functions can make use of the <code>await</code> expression. <br>
This will pause the <code>async</code> function and wait for the Promise to resolve prior to moving on.
<h4>Example Time</h4>
Enough talk. <br>
To understand what all of this means, lets look at an example! First we’re going to create some code using promises. <br>
Once we’ve got something working, we’ll rewrite our function using async/await so you can see just how much simpler it is!
<blockquote>If you’re using Google Chrome, be sure to follow along by typing in the code into your developer console. <br>
You can open the console by pressing Ctrl+Shift+J (Windows / Linux) or Cmd+Opt+J (Mac).</blockquote>
Consider the below code:
<pre>function doubleAfter2Seconds(x) {<br>  return new Promise(resolve =&gt; {<br>    setTimeout(() =&gt; {<br>      resolve(x * 2);<br>    }, 2000);<br>  });<br>}</pre>
In this code we have a function called <code>doubleAfter2Seconds</code>. <br>
This function will take a number as input and will resolve two seconds later with the number doubled.
We can invoke our function and pass in the number 10 to try it out. <br>
To do this, we’ll call our function while passing in <code>10</code>. <br>
Then, after the promise has resolved, we’ll take our returned value and log it to the console. <br>
Here’s what this would look like:
<pre>doubleAfter2Seconds(10).then((r) =&gt; {<br>  console.log(r);<br>});</pre>
Awesome!
But what if we want to run a few different values through our function and add the result? Unfortunately, we cant just add our invocations together and log them:
<pre>let sum =   doubleAfter2Seconds(10)<br>          + doubleAfter2Seconds(20)<br>          + doubleAfter2Seconds(30);<br>console.log(sum);</pre>
<pre>// undefined</pre>
The problem with the above code is it doesn’t actually wait for our promises to resolve before logging to the console.
One possible solution is to set up a promise chain. <br>
To do this we’ll create a new function called <code>addPromise</code>. <br>
Our function will take an input value, and will return a Promise. <br>
Here’s what the boilerplate code looks like:
<pre>function addPromise(x){<br>  return new Promise(resolve =&gt; {</pre>
<pre>    // Code goes here... <br>
  <br>    // resolve()</pre>
<pre>  });<br>}</pre>
Awesome. <br>
Now we can add in our calls to our <code>doubleAfter2Seconds</code> function. <br>
Once we’re done, we can resolve with our new sum. <br>
In this example we should be returning <code>x + 2*a + 2*b + 2*c</code>. <br>
Here’s the code:
<pre>function addPromise(x){<br>  return new Promise(resolve =&gt; {<br>    doubleAfter2Seconds(10).then((a) =&gt; {<br>      doubleAfter2Seconds(20).then((b) =&gt; {<br>        doubleAfter2Seconds(30).then((c) =&gt; {<br>          resolve(x + a + b + c);<br>        })<br>      })<br>    })<br>  });<br>}</pre>
Lets walk through the code again, line by line.
<ul>
<li>First, we create our function <code>addPromise</code>. <br>
This function accepts one parameter.</li>
<li>Next, we create our <code>new Promise</code> that we’ll be returning. <br>
Note that for the sake of simplicity, we’re not handling rejections/errors.</li>
<li>Next we invoke <code>doubleAfter2Seconds</code> for the first time, passing in a value of <code>10</code>. <br>
Two seconds later, the return value of <code>20</code> will be returned to the <code>a</code> variable.</li>
<li>We invoke <code>doubleAfter2Seconds</code> again, this time passing in a value of <code>20</code>. <br>
Two seconds later, the return value of <code>40</code> will be returned to the <code>b</code> variable.</li>
<li>We invoke <code>doubleAfter2Seconds</code> one final time, this time passing in a value of <code>30</code>. <br>
Two seconds later, the return value of <code>60</code> will be returned to the <code>c</code> variable.</li>
<li>Finally, we resolve our Promise with the value of <code>10 + 20 + 40 + 60</code> or <code>130</code>.</li>
</ul>
When we put all of the code together, here’s what it looks like:

<img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars1.githubusercontent.com%2Fu%2F5618806%3Fs%3D400%26v%3D4&amp;key=a19fcc184b9711e1b4764040d3dc5c07">

<IFRAME width="700" height="250" data-src="/media/02c80e8d8f181f398059e723522d9297?postId=48acc58bad65" data-media-id="02c80e8d8f181f398059e723522d9297" data-thumbnail="https://i.embed.ly/1/image?url=https%3A%2F%2Favatars1.githubusercontent.com%2Fu%2F5618806%3Fs%3D400%26v%3D4&amp;key=a19fcc184b9711e1b4764040d3dc5c07" class="progressiveMedia-iframe js-progressiveMedia-iframe" allowfullscreen frameborder="0">
</IFRAME>

<h4>Switching from Promises to Async/Await.</h4>
Awesome! Now lets see just how much easier we could write the above code with Async/Await!
Remove the <code>addPromise</code> function, and create a new function named <code>addAsync</code>. <br>
This function will have the exact same purpose as our <code>addPromise</code> did. <br>
When you create your <code>addPromise</code> function, make use of the <code>async</code> keyword. <br>
Here’s what that looks like:
<pre>async function addAsync(x) {</pre>
<pre>  // code here...</pre>
<pre>}</pre>
Now that you’ve created an async function, we can make use of the <code>await</code> keyword which will pause our code until the Promise has resolved. <br>
Here’s how easy that is:
<pre>async function addAsync(x) {<br>  const a = await doubleAfter2Seconds(10);<br>  const b = await doubleAfter2Seconds(20);<br>  const c = await doubleAfter2Seconds(30);<br>  return x + a + b + c;<br>}</pre>
And here’s the full code:

<img src="https://i.embed.ly/1/display/resize?url=https%3A%2F%2Favatars1.githubusercontent.com%2Fu%2F5618806%3Fs%3D400%26v%3D4&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;width=40" crossorigin="anonymous" class="progressiveMedia-thumbnail js-progressiveMedia-thumbnail">


<IFRAME width="700" height="250" src="/media/78f20ff677add615fde3269870a1142c?postId=48acc58bad65" data-media-id="78f20ff677add615fde3269870a1142c" data-thumbnail="https://i.embed.ly/1/image?url=https%3A%2F%2Favatars1.githubusercontent.com%2Fu%2F5618806%3Fs%3D400%26v%3D4&amp;key=a19fcc184b9711e1b4764040d3dc5c07" allowfullscreen frameborder="0">
</IFRAME>

As you can see, we’re still making use of the same <code>doubleAfter2Seconds</code> function. <br>
Similarly, we’ll be invoking our <code>addAsync()</code> function and passing in the value of <code>10</code>. <br>
Upon completion, we log the resulting value. <br>
Let’s walk through this step-by-step:
<ul>
<li>First we call <code>addAsync(10)</code> passing in the value of <code>10</code>.</li>
<li>Next, we get the value of <code>a</code> on line 10. <br>
Since the <code>await</code> keyword is used, our function pauses for two seconds while we wait for the promise to resolve. <br>
Once the promise resolves, <code>a = 20</code>.</li>
</ul>
<pre>
<code>const a = await </code>doubleAfter2Seconds<code>(10);</code>
</pre>
<ul>
<li>Next, we get the value of <code>b</code> on line 11. <br>
Since the <code>await</code> keyword is used, our function pauses for two seconds while we wait for the promise to resolve. <br>
Once the promise resolves, <code>b = 40</code>.</li>
</ul>
<pre>
<code>const b = await </code>doubleAfter2Seconds<code>(20);</code>
</pre>
<ul>
<li>Next, we get the value of <code>c</code> on line 12. <br>
Since the <code>await</code> keyword is used, our function pauses for two seconds while we wait for the promise to resolve. <br>
Once the promise resolves, <code>c = 60</code>.</li>
</ul>
<pre>
<code>const c = await </code>doubleAfter2Seconds<code>(30);</code>
</pre>
<ul>
<li>Finally, we can return the value of <code>x + a + b + c</code>. <br>
Since we passed in <code>10</code> as our single parameter, we are returning the value of <code>10 + 20 + 40 + 60</code>.</li>
<li>A full six seconds later, our <code>console.log(sum)</code>is finally run. <br>
The value of <code>10 + 20 + 40 + 60</code> is passed in, and <code>130</code> is logged to the console.</li>
</ul>
And that’s it! You’ve just created an asynchronous function in JavaScript!

<strong>As you can see, since Async functions return a Promise, they can be used interchangeably with Promises very easily. <br>
Our code is also so much cleaner and easier to read when we use Async/Await instead of long Promise chain.</strong>

<h3>Closing Notes:</h3>
Thanks for reading, and hopefully this was helpful. <br>
There is much more to Async/Await — including error handling — that we didn’t cover in this article.
If you’re still having trouble understanding what Async/Await is, it’s probably because you don’t fully understand how Promises work. <br>
Promises are key to understanding this topic. <br>
Additional information can be found on Promises <a href="https://developers.google.com/web/fundamentals/primers/promises" target="_blank">here</a>.
<br>
<br>
<br>
<br>

<script>
	var toc = $('#toc');
	$('h2,h4').each(function(i) {
		var topic = $(this), topicNumber = i + 1;
		toc.append('<a href="#topic-'+topicNumber+'" target="_self">'+topic.text()+'</a><br>');
		topic.attr('id', 'topic-' + topicNumber);
	});
</script>

</body>
</html>
