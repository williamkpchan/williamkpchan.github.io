<base target="_blank"><html><head><title>demo2s-4</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src="https://williamkpchan.github.io/lazyload.min.js"></script>
<script src='https://williamkpchan.github.io/mainscript.js'></script>
<script src="https://williamkpchan.github.io/commonfunctions.js"></script>
<script>
  var showTopicNumber = true;
  var topicEnd = "<br>";
  var bookid = "demo2s-4"
  var markerName = "h2"
</script>
<style>
body{width:80%;margin-left: 10%; font-size:24px;}
h1, h2 {color: gold;}
strong {color: orange;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px;}
</style></head><body onkeypress="chkKey()"><center>
<h1>demo2s-4</h1>
<a href="#mustWatch" class="red goldbs" target="_self">Must Watch!</a><br><br>
<div id="toc"></div></center><br><br>
<div id="mustWatch"><center><span class="red">MustWatch</span></center><br></div>
<pre><br><br>

<h2>Proxy Traps And Reflect Methods deleteProperty()</h2>

The <i>deleteProperty</i>() trap is called inside the delete operator. 

Its corresponding Reflect API method is Reflect.<i>deleteProperty</i>().

<h3>Example</h3>

<b>const</b> myTarget = {};

<b>const</b> proxy = new Proxy(myTarget, {
  deleteProperty(target, property) {
    console.log('deleteProperty()');
    return Reflect.deleteProperty(...<b>arguments</b>)
  }
 });

delete proxy.foo

Output:

<h3>Return value</h3>
<i>deleteProperty</i>() must return a Boolean indicating if the property was successfully deleted or not.

Non-Boolean return values will be coerced into a Boolean.

<h3>Intercepted operations</h3>

delete proxy.property
delete proxy[property]
Reflect.deleteProperty(proxy, property)

<h3>Trap handler parameters</h3>
target - Target object
property - String key property being referenced on target object

<h3>Trap invariants</h3>
If an own target.property exists and is non-configurable, the handler cannot delete the property.

<h2>Proxy Traps And Reflect Methods ownKeys()</h2>

The <i>ownKeys</i>() trap is called inside Object.<i>keys</i>() and similar methods. 

Its corresponding Reflect API method is Reflect.<i>ownKeys</i>().

<h3>Example</h3>

<b>const</b> myTarget = {};

<b>const</b> proxy = new Proxy(myTarget, {
 ownKeys(target) {
   console.log('ownKeys()');
   return Reflect.ownKeys(...<b>arguments</b>)
 }
});

<b>Object</b>.keys(proxy);

Output:

<h3>Return value</h3>
<i>ownKeys</i>() must return an enumerable object that contains either strings or symbols.

<h3>Intercepted operations</h3>

<b>Object</b>.getOwnPropertyNames(proxy)
<b>Object</b>.getOwnPropertySymbols(proxy)
<b>Object</b>.keys(proxy)
Reflect.ownKeys(proxy)

<h3>Trap handler parameters</h3>
<ul style="font-size:19px;">target - Target object
<h3>Trap invariants</h3>
The returned enumerable object must contain all non-configurable own properties of target.

If target is non-extensible, the returned enumerable object must exactly contain the own property
keys of target.

<h2>Proxy Traps And Reflect Methods getPrototypeOf()</h2>

The <i>getPrototypeOf</i>() trap is called inside Object.<i>getPrototypeOf</i>(). 

Its corresponding Reflect API method is Reflect.<i>getPrototypeOf</i>().

<h3>Example</h3>

<b>const</b> myTarget = {};

<b>const</b> proxy = new Proxy(myTarget, {
  getPrototypeOf(target) {
    console.log('getPrototypeOf()');
    return Reflect.getPrototypeOf(...<b>arguments</b>)
  }
});

<b>Object</b>.getPrototypeOf(proxy);

Output:

<h3>Return value</h3>
<i>getPrototypeOf</i>() must return an object or null.

<h3>Intercepted operations</h3>

<b>Object</b>.getPrototypeOf(proxy)
Reflect.getPrototypeOf(proxy)
proxy.__proto__
<b>Object</b>.<b>prototype</b>.isPrototypeOf(proxy)
proxy instanceof <b>Object</b>

<h3>Trap handler parameters</h3>
<ul style="font-size:19px;">target - Target object
<h3>Trap invariants</h3>
If target is non-extensible, the only valid return value of Object.<i>getPrototypeOf</i>(proxy) is the
value returned from Object.<i>getPrototypeOf</i>(target).

<h2>Proxy Traps And Reflect Methods setPrototypeOf()</h2>

The <i>setPrototypeOf</i>() trap is called inside Object.<i>setPrototypeOf</i>(). 

Its corresponding Reflect API method is Reflect.<i>setPrototypeOf</i>().

<h3>Example</h3>

<b>const</b> myTarget = {};

<b>const</b> proxy = new Proxy(myTarget, {
  setPrototypeOf(target, <b>prototype</b>) {
    console.log('setPrototypeOf()');
    return Reflect.setPrototypeOf(...<b>arguments</b>)
  }
});

<b>Object</b>.setPrototypeOf(proxy, <b>Object</b>);

Output:

<h3>Return value</h3>
<i>setPrototypeOf</i>() must return a Boolean indicating if the prototype assignment was successful or
not. Non-Boolean return values will be coerced into a Boolean.

<h3>Intercepted operations</h3>

<b>Object</b>.setPrototypeOf(proxy)
Reflect.setPrototypeOf(proxy)

<h3>Trap handler parameters</h3>
target - Target object
prototype - The intended replacement prototype for target, or null if this is to be a top-
level prototype

<h3>Trap invariants</h3>
If target is non-extensible, the only valid prototype parameter is the value returned from Object.
<i>getPrototypeOf</i>(target).

<h2>Proxy Traps And Reflect Methods isExtensible()</h2>

The <i>isExtensible</i>() trap is called inside Object.<i>isExtensible</i>(). 

Its corresponding Reflect API method is Reflect.<i>isExtensible</i>().

<h3>Example</h3>

<b>const</b> myTarget = {};

<b>const</b> proxy = new Proxy(myTarget, {
  isExtensible(target) {
    console.log('isExtensible()');
    return Reflect.isExtensible(...<b>arguments</b>)
  }
});

<b>Object</b>.isExtensible(proxy);

Output:

<h3>Return value</h3>
<i>isExtensible</i>() must return a Boolean indicating if the prototype assignment was successful or not.

Non-Boolean return values will be coerced into a Boolean.

<h3>Intercepted operations</h3>

<b>Object</b>.isExtensible(proxy)
Reflect.isExtensible(proxy)

<h3>Trap handler parameters</h3>
<ul style="font-size:19px;">target - Target object
<h3>Trap invariants</h3>
If target is extensible, the handler must return true.

If target is non-extensible, the handler must return false.

<h2>Proxy Traps And Reflect Methods preventExtensions()</h2>

The <i>preventExtensions</i>() trap is called inside Object.<i>preventExtensions</i>(). 

Its corresponding Reflect API method is Reflect.<i>preventExtensions</i>().

<h3>Example</h3>

<b>const</b> myTarget = {};

<b>const</b> proxy = new Proxy(myTarget, {
  preventExtensions(target) {
    console.log('preventExtensions()');
    return Reflect.preventExtensions(...<b>arguments</b>)
  }
});

<b>Object</b>.preventExtensions(proxy);

Output:

<h3>Return value</h3>
<i>preventExtensions</i>() must return a Boolean indicating if target is already non-extensible. 

Non-Boolean return values will be coerced into a Boolean.

<h3>Intercepted operations</h3>

<b>Object</b>.preventExtensions(proxy)
Reflect.preventExtensions(proxy)

<h3>Trap handler parameters</h3>
<ul style="font-size:19px;">target - Target object
<h3>Trap invariants</h3>
If Object.<i>isExtensible</i>(proxy) is false, the handler must return true.

<h2>Proxy Traps And Reflect Methods apply()</h2>

The <i>apply</i>() trap is called on function calls. 

Its corresponding Reflect API method is Reflect.<i>apply</i>().

<h3>Example</h3>

<b>const</b> myTarget = () => {};
 <b>const</b> proxy = new Proxy(myTarget, {
  apply(target, thisArg, ...argumentsList) {
    console.log('apply()');
    return Reflect.apply(...<b>arguments</b>)
  }
});

proxy();

Output:

<h3>Return value</h3>
The return value is unrestricted.

<h3>Intercepted operations</h3>

proxy(...argumentsList)
Function.<b>prototype</b>.apply(thisArg, argumentsList)
Function.<b>prototype</b>.call(thisArg, ...argumentsList)
Reflect.apply(target, thisArgument, argumentsList)

<h3>Trap handler parameters</h3>

<i>target</i> - Target object

<i>thisArg</i> - this argument for the function call

<i>argumentsList</i> - List of arguments for the function call

<h3>Trap invariants</h3>
target must be a function object.

<h2>Proxy Traps And Reflect Methods construct()</h2>

The <i>construct</i>() trap is called inside the new operator. 

Its corresponding Reflect API method is Reflect.<i>construct</i>().

<h3>Example</h3>

<b>const</b> myTarget = function() {};

<b>const</b> proxy = new Proxy(myTarget, {
 construct(target, argumentsList, newTarget) {
   console.log('construct()');
   return Reflect.construct(...<b>arguments</b>)
 }
});

new proxy;

Output:

<h3>Return value</h3>
<i>construct</i>() must return an object.

<h3>Intercepted operations</h3>

new proxy(...argumentsList)
Reflect.construct(target, argumentsList, newTarget)

<h3>Trap handler parameters</h3>

<i>target</i> - Target constructor

<i>argumentsList</i> - List of arguments passed to the target constructor

<i>newTarget</i> - The originally called constructor

<h3>Trap invariants</h3>
target must be able to be used as a constructor.

<h2>Tracking Property Access via Proxy</h2>

The Proxy <i>get</i>() and <i>set</i>() can provide insight into when object properties are being
accessed and inspected. 

If you provide a trapped proxy to an object throughout your application, you
will be able to see exactly when and where this object is accessed:

<b>const</b> user = {
  <b>name</b>: 'CSS'
};

<b>const</b> proxy = new Proxy(user, {
  get(target, property, receiver) {
    console.log(`Getting roperty`);

    return Reflect.get(...<b>arguments</b>);
  },
  set(target, property, value, receiver) {
    console.log(`Setting ${property}=${value}`);

    return Reflect.set(...<b>arguments</b>);
  }
});

proxy.<b>name</b>;      // Getting name
proxy.age = 27;  // Setting age=27

Output:



<h2>Hide Properties via Proxy</h2>

We can use proxy to hide properties on the target object. 

For example:

<b>const</b> hiddenProperties = ['foo', 'bar'];
<b>const</b> targetObject = {//    w  w  w  .d    em   o  2 s  .   c  o  m 
  foo: 1,
  bar: 2,
  baz: 3
};
<b>const</b> proxy = new Proxy(targetObject, {
  get(target, property) {
    if (hiddenProperties.includes(property)) {
      return undefined;
    } else {
      return Reflect.get(...<b>arguments</b>);
    }
  },
  has(target, property) {
    if (hiddenProperties.includes(property)) {
      return false;
    } else {
      return Reflect.has(...<b>arguments</b>);
    }
  }
});

// get()
console.log(proxy.foo);  // undefined
console.log(proxy.bar);  // undefined
console.log(proxy.baz);  // 3

// has()
console.log('foo' in proxy);  // false
console.log('bar' in proxy);  // false
console.log('baz' in proxy);  // true

Output:



<h2>Property Validation via Proxy</h2>

Because all assignments must go through the <i>set</i>() trap, you can allow or reject assignments based
on the content of the intended value:

<b>const</b> target = {
  MyNumber: 0
};

<b>const</b> proxy = new Proxy(target, {
  set(target, property, value) {
    if (<b>typeof</b> value !== 'number') {
      return false;
    } else {
      return Reflect.set(...<b>arguments</b>);
    }
  }
});
proxy.MyNumber = 1;
console.log(proxy.MyNumber);  // 1
proxy.MyNumber = '2';
console.log(proxy.MyNumber);  // 1

Output:



<h2>Function and Constructor Parameter Validation via Proxy</h2>

We can use Proxy to validate function and constructor
parameters. 

For example, a function can ensure that it is only provided values of a certain type:

function median(...nums) {
  return nums.sort()[<b>Math</b>.floor(nums.<b>length</b> / 2)];
}

<b>const</b> proxy = new Proxy(median, {
  apply(target, thisArg, ...argumentsList) {
    console.log('parameter is');
    console.log(argumentsList);
    return Reflect.apply(...<b>arguments</b>);
  }
});

console.log(proxy(4, 7, 1));    
console.log(proxy(4, '7', 1));

Output:

Similarly, a constructor can enforce the presence of constructor parameters:

<b>class</b> User {/* w   w  w.  d    e m   o2  s    . c o   m */
  <b>constructor</b>(id) {
    this.id_ = id;
  }
}

<b>const</b> proxy = new Proxy(User, {
  construct(target, argumentsList, newTarget) {
    if (argumentsList[0] === undefined) {
      <b>throw</b> 'User cannot be instantiated without id';
    } else {
      return Reflect.construct(...<b>arguments</b>);
    }
  }
});

new proxy(1);
new proxy();

Output:



<h2>Data Binding and Observable via Proxy</h2>

Proxying can use the existence of various parts of the runtime that would otherwise
be disparate. 

For example, a proxied class can be bound to a global collection of instances so that every created
instance is added to that collection:

<b>const</b> userList = [];//  w    w w .    d e   mo  2   s .  c  o  m  

<b>class</b> User {
  <b>constructor</b>(<b>name</b>) {
    this.<b>name</b>_ = <b>name</b>;
  }
 }

<b>const</b> proxy = new Proxy(User, {
  construct() {
    <b>const</b> newUser = Reflect.construct(...<b>arguments</b>);
    userList.push(newUser);
    return newUser;
  }
 });

new proxy('CSS1');
new proxy('CSS2');
new proxy('CSS3');

console.log(userList); // [User {}, User {}, User{}]

Output:

Alternately, a collection can be bound to an emitter, which will fire each time a new instance
is inserted:

<b>const</b> userList = [];//   w  w  w  .   d  e m  o   2s   .  c  o m  

function emit(newValue) {
  console.log(newValue);
 }

<b>const</b> proxy = new Proxy(userList, {
  set(target, property, value, receiver) {
    <b>const</b> result = Reflect.set(...<b>arguments</b>);
    if (result) {
      emit(Reflect.get(target, property, receiver));
    }
    return result;
  }
 });

proxy.push('CSS1');

proxy.push('CSS2');

Output:



<h2>Introduction To Asynchronous Programming</h2>

ECMAScript 6 introduces a formal <b>Promise</b> reference type,
allowing for elegant definition and organization of asynchronous behavior.

Later editions also
extended the language to support asynchronous functions with the <i>async</i> and <i>await</i> keywords.

<h3>Synchronous </h3>
Synchronous behavior is analogous to sequential processor instructions.

Each instruction
is executed in the order in which it appears, and each instruction can 
get information stored locally within the system.

It is easy to get the program state at any given time.

<h3>Asynchronous</h3>
Asynchronous behavior is analogous to interrupts, where an entity external to the current
process is able to trigger code execution.

An asynchronous operation can avoid waiting for operations which can take 
a long time to finish.

The following JavaScript code performs an arithmetic operation inside a timeout:

let x = 3;
<b>setTimeout</b>(() => x = x + 4, 1000);

For the value of x to become useful, this asynchronously executed function would need to signal to
the rest of the program that it has updated the value of x.

However, if the program does not need this
value, then it is free to proceed and do other work instead of waiting for the result.

<h2>Promise Introductions</h2>

ECMAScript 6 introduced a first-class implementation of a Promise type to handle async 
operations.

ECMAScript 6 Promise is a reference type and can be instantiated with the <i>new</i>
operator.

We need to pass an executor function parameter,
which here is an empty function object:

let p = new Promise(() => {});
<b>setTimeout</b>(console.log, 0, p);  // Promise &lt;pending>

Output:

If an executor function is not provided, a <b>SyntaxError</b> will be thrown.

<h3>State</h3>
There are two primary reasons the Promise construct is useful.

The first is to abstractly represent a
block of asynchronous execution.

The state of the promise tells whether or not the promise has yet to complete execution.

The pending state indicates that execution has not yet begun or is still in progress.

The fulfilled state tells that the execution has completed successfully.

The rejected state tells that the execution did not complete successfully.

<h2>Promise State Machine</h2>

When passing a promise instance to console.log, the console output indicates that this promise instance is pending.

let p = new Promise(() => {});
<b>setTimeout</b>(console.log, 0, p);  // Promise &lt;pending>

Output:

A promise is a stateful object that can exist in one of three states:

Pending
Fulfilled (or resolved)
Rejected

A pending state is the initial state a promise begins in.

From a pending state, a promise can become
settled by turning to a fulfilled state to indicate success, or a rejected state to indicate failure.

This transition to a settled state is irreversible; once a transition to either fulfilled or rejected occurs,
the state of the promise can never change.

It is not guaranteed that a promise will ever leave the pending state.

Therefore, well-structured code should behave properly if the promise 
successfully resolves, if the promise rejects, or if it never exits the pending state.

The state of a promise is private and cannot be directly inspected in JavaScript.

The state of a promise cannot be mutated by external JavaScript.

The promise intentionally encapsulates a block of asynchronous behavior, and external code performing synchronous definition of its
state would be antithetical to its purpose.

<h2>Controlling Promise State with the Executor</h2>

Because the state of a promise is private, it can only be manipulated internally.

This internal manipulation
is performed inside the promise's executor function.

The executor function has two primary duties: 
initializing the asynchronous behavior of the promise, and controlling any eventual state transition.

Control of the state transition is accomplished by invoking one of its two function parameters, typically named
<i>resolve</i> and <i>reject</i>.

Invoking <i>resolve</i> will change the state to fulfilled; invoking <i>reject</i> will change the
state to rejected.

Invoking <i>rejected</i>() will also throw an error.

let p1 = new Promise((resolve, reject) => resolve());
<b>setTimeout</b>(console.log, 0, p1);  // Promise &lt;resolved>

let p2 = new Promise((resolve, reject) => reject());
<b>setTimeout</b>(console.log, 0, p2);  // Promise &lt;rejected>
// Uncaught error (in promise)

The executor function will execute synchronously, as it acts as the initializer for the promise.

This order of execution is demonstrated here:

new Promise(() => <b>setTimeout</b>(console.log, 0, 'executor'));
<b>setTimeout</b>(console.log, 0, 'promise initialized');

Output:

You can delay the state transition by adding a <i>setTimeout</i>:

let p = new Promise((resolve, reject) => <b>setTimeout</b>(resolve, 1000));

// When this console.log executes, 
// the timeout callback has not yet executed:
<b>setTimeout</b>(console.log, 0, p);  // Promise &lt;pending>

Once either resolve or reject is invoked, the state transition cannot be undone.

Attempts to further mutate the state will silently be ignored.

This is demonstrated here:

let p = new Promise((resolve, reject) => {
   resolve();
   reject();  // No effect
});

<b>setTimeout</b>(console.log, 0, p);  // Promise &lt;resolved>

You can avoid promises getting stuck in a pending state by adding timed exit behavior.

For example, you can set a timeout to reject the promise after 10 seconds:

let p = new Promise((resolve, reject) => {
    <b>setTimeout</b>(reject, 10000);  // After 10 seconds, invoke reject()
    // Do executor things
});

<b>setTimeout</b>(console.log, 0, p);      // Promise &lt;pending>
<b>setTimeout</b>(console.log, 11000, p);  // Check state after 11 seconds

Output:

Because a promise can only change state a single time, this timeout behavior allows you to safely set
a maximum on the amount of time a promise can remain in the pending state.

If the code inside the
executor were to resolve or reject prior to the timeout, the timeout handler's attempt to reject the
promise will be silently ignored.

<h2>Promise Casting with Promise.resolve()</h2>

We can instantiate a promise in the "resolved" state by invoking the Promise.<i>resolve</i>() static method.

The following two promise instantiations are effectively equivalent:

let p1 = new Promise((resolve, reject) => resolve());
let p2 = Promise.resolve();

The value of this resolved promise will become the first argument passed to Promise.<i>resolve</i>().

This effectively allows you to "cast" any value into a promise:

<b>setTimeout</b>(console.log, 0, Promise.resolve());
// Promise &lt;resolved>: undefined

<b>setTimeout</b>(console.log, 0, Promise.resolve(3));
// Promise &lt;resolved>: 3

// Additional arguments are ignored
<b>setTimeout</b>(console.log, 0, Promise.resolve(4, 5, 6));
// Promise &lt;resolved>: 4

This static method can act as a pass through when the
argument is already a promise.

Calling Promise.<i>resolve</i>() more than once returns the same result, as demonstrated here:

let p = Promise.resolve(7);

<b>setTimeout</b>(console.log, 0, p === Promise.resolve(p));
// true

<b>setTimeout</b>(console.log, 0, p === Promise.resolve(Promise.resolve(p)));
// true

Promise.<i>resolve</i>() will respect the state of the promise passed to it:

let p = new Promise(() => {});

<b>setTimeout</b>(console.log, 0, p);                   // Promise &lt;pending>
<b>setTimeout</b>(console.log, 0, Promise.resolve(p));  // Promise &lt;pending>

<b>setTimeout</b>(console.log, 0, p === Promise.resolve(p));  // true

Promise.<i>resolve</i>() can wrap any non-promise, including an error object, as a
resolved promise, which might lead to unintended behavior:

let p = Promise.resolve(new Error('foo'));

<b>setTimeout</b>(console.log, 0, p);
// Promise &lt;resolved>: Error: foo

<h2>Promise Rejection with Promise.reject()</h2>

Promise.<i>reject</i>() instantiates a rejected promise and
throws an asynchronous error.

The asynchronous error will not be caught by try/catch and can only be caught by a
rejection handler.

The following two promise instantiations are effectively equivalent:

let p1 = new Promise((resolve, reject) => reject());
let p2 = Promise.reject();

The 'reason' field of this resolved promise will be the first argument passed to Promise.<i>reject</i>().

This will also be the error passed to the reject handler:

let p = Promise.reject(3);
<b>setTimeout</b>(console.log, 0, p);  // Promise &lt;rejected>: 3

p.then(null, (e) => <b>setTimeout</b>(console.log, 0, e));  // 3

<h2>Promise then() method</h2>

The method Promise.prototype.<i>then</i>() is used to attach handlers to a
promise instance.

The <i>then</i>() method accepts up to two arguments: an optional <i>onResolved</i> handler
function, and an optional <i>onRejected</i> handler function.

Each will execute only when the promise
upon which they are defined reaches its respective "fulfilled" or "rejected" state.

function onResolved(id) {
  <b>setTimeout</b>(console.log, 0, id, 'resolved');
}
function onRejected(id) {
  <b>setTimeout</b>(console.log, 0, id, 'rejected');
}

let p1 = new Promise((resolve, reject) => <b>setTimeout</b>(resolve, 3000));
let p2 = new Promise((resolve, reject) => <b>setTimeout</b>(reject, 3000));

p1.then(() => onResolved('p1'),
         () => onRejected('p1'));
p2.then(() => onResolved('p2'),
         () => onRejected('p2'));

Output:

Because a promise can only transition to a final state a single time, you are guaranteed that execution
of these handlers is mutually exclusive.

Both handler arguments are completely optional.

Any non-function type provided as an argument to <i>then</i>() will be ignored.

If you wish to explicitly provide only an
<i>onRejected</i> handler, providing <i>undefined</i> as the <i>onResolved</i> argument is the canonical choice.

function onResolved(id) {
  <b>setTimeout</b>(console.log, 0, id, 'resolved');
}
function onRejected(id) {
  <b>setTimeout</b>(console.log, 0, id, 'rejected');
}

let p1 = new Promise((resolve, reject) => <b>setTimeout</b>(resolve, 3000));
let p2 = new Promise((resolve, reject) => <b>setTimeout</b>(reject, 3000));

// Non-function handlers are ignored, not recommended
p1.then('do this');

// Canonical form of explicit onResolved handler skipping
p2.then(null, () => onRejected('p2'));

// p2 rejected (after 3s)

The Promise.prototype.<i>then</i>() method returns a new promise instance:

let p1 = new Promise(() => {});
let p2 = p1.then();
<b>setTimeout</b>(console.log, 0, p1);         // Promise &lt;pending>
<b>setTimeout</b>(console.log, 0, p2);         // Promise &lt;pending>
<b>setTimeout</b>(console.log, 0, p1 === p2);  // false

This new promise instance is derived from the return value of the <i>onResolved</i> handler. 

The return value
of the handler is wrapped in Promise.<i>resolve</i>() to generate a new promise. 

If no handler function is
provided, the method acts as a pass through for the initial promise's resolved value. 

If there is no explicit
return statement, the default return value is <i>undefined</i> and wrapped in a Promise.<i>resolve</i>().

let p1 = Promise.resolve('foo');

// Calling then() with no handler function acts as a pass through
let p2 = p1.then();
<b>setTimeout</b>(console.log, 0, p2);  // Promise &lt;resolved>: foo

// These are equivalent
let p3 = p1.then(() => undefined);
let p4 = p1.then(() => {});
let p5 = p1.then(() => Promise.resolve());

<b>setTimeout</b>(console.log, 0, p3);  // Promise &lt;resolved>: undefined
<b>setTimeout</b>(console.log, 0, p4);  // Promise &lt;resolved>: undefined
<b>setTimeout</b>(console.log, 0, p5);  // Promise &lt;resolved>: undefined

These are equivalent:

let p6 = p1.then(() => 'bar');
let p7 = p1.then(() => Promise.resolve('bar'));

<b>setTimeout</b>(console.log, 0, p6);  // Promise &lt;resolved>: bar
<b>setTimeout</b>(console.log, 0, p7);  // Promise &lt;resolved>: bar

Promise.<i>resolve</i>() preserves the returned promise

let p8 = p1.then(() => new Promise(() => {}));
let p9 = p1.then(() => Promise.reject());
// Uncaught (in promise): undefined

<b>setTimeout</b>(console.log, 0, p8);  // Promise &lt;pending>
<b>setTimeout</b>(console.log, 0, p9);  // Promise &lt;rejected>: undefined

Throwing an exception will return a rejected promise:

let p10 = p1.then(() => { <b>throw</b> 'baz'; });
// Uncaught (in promise) baz

<b>setTimeout</b>(console.log, 0, p10);  // Promise &lt;rejected> baz

Returning an error will not trigger the same rejection behavior, and will instead wrap the
error object in a resolved promise:

let p11 = p1.then(() => Error('qux'));

<b>setTimeout</b>(console.log, 0, p11);  // Promise &lt;resolved>: Error: qux

The <i>onRejected</i> handler behaves in the same way: values returned from the <i>onRejected</i> handler
are wrapped in Promise.<i>resolve</i>().

The <i>onRejected</i> handler is doing its job to catch an asynchronous error.

This rejection handler completing
execution without throwing an additional error should be considered expected promise behavior and
therefore return a resolved promise.

<h3>Using Promise.resolve()</h3>

let p1 = Promise.reject('foo');

Calling <i>then</i>() with no handler function acts as a pass through

let p2 = p1.then();
// Uncaught (in promise) foo

<b>setTimeout</b>(console.log, 0, p2);  // Promise &lt;rejected>: foo

These are equivalent

let p3 = p1.then(null, () => undefined);
let p4 = p1.then(null, () => {});
let p5 = p1.then(null, () => Promise.resolve());

<b>setTimeout</b>(console.log, 0, p3);  // Promise &lt;resolved>: undefined
<b>setTimeout</b>(console.log, 0, p4);  // Promise &lt;resolved>: undefined
<b>setTimeout</b>(console.log, 0, p5);  // Promise &lt;resolved>: undefined

These are equivalent

let p6 = p1.then(null, () => 'bar');
let p7 = p1.then(null, () => Promise.resolve('bar'));

<b>setTimeout</b>(console.log, 0, p6);  // Promise &lt;resolved>: bar
<b>setTimeout</b>(console.log, 0, p7);  // Promise &lt;resolved>: bar

Promise.<i>resolve</i>() preserves the returned promise

let p8 = p1.then(null, () => new Promise(() => {}));
let p9 = p1.then(null, () => Promise.reject());
// Uncaught (in promise): undefined

<b>setTimeout</b>(console.log, 0, p8);  // Promise &lt;pending>
<b>setTimeout</b>(console.log, 0, p9);  // Promise &lt;rejected>: undefined
let p10 = p1.then(null, () => { <b>throw</b> 'baz'; });
// Uncaught (in promise) baz

<b>setTimeout</b>(console.log, 0, p10);  // Promise &lt;rejected>: baz

let p11 = p1.then(null, () => Error('qux'));

<b>setTimeout</b>(console.log, 0, p11);  // Promise &lt;resolved>: Error: qux

<h2>Promise catch() method</h2>

The Promise.prototype.<i>catch</i>() method can attach a reject handler to a promise.

It only takes a single argument, the <i>onRejected</i> handler function. 

The method is the same as <b>Promise.prototype.then(null,onRejected)</b>.

The following code demonstrates this equivalence:

let p = Promise.reject();
let onRejected = function(e) {
    <b>setTimeout</b>(console.log, 0, 'rejected');
};

// These two reject handlers behave identically:
p.then(null, onRejected);  // rejected
p.<b>catch</b>(onRejected);       // rejected

The Promise.prototype.<i>catch</i>() method returns a new promise instance:

let p1 = new Promise(() => {});
let p2 = p1.<b>catch</b>();
<b>setTimeout</b>(console.log, 0, p1);         // Promise &lt;pending>
<b>setTimeout</b>(console.log, 0, p2);         // Promise &lt;pending>
<b>setTimeout</b>(console.log, 0, p1 === p2);  // false

With respect to creation of the new promise instance, Promise.prototype.<i>catch</i>() behaves 
identically to the <i>onRejected</i> handler of Promise.prototype.<i>then</i>().

<h2>Promise finally() method</h2>

The Promise.prototype.<i>finally</i>() method can be used to attach an <i>onFinally</i> handler, which
executes when the promise reaches either a resolved or a rejected state. 

This is useful for avoiding
code duplication between <i>onResolved</i> and <i>onRejected</i> handlers. 

The handler cannot determine if the promise was resolved or rejected, so this method is 
used for things like cleanup.

let p1 = Promise.resolve();
let p2 = Promise.reject();
let onFinally = function() {
    <b>setTimeout</b>(console.log, 0, 'Finally!')
}

p1.<b>finally</b>(onFinally);  // Finally
p2.<b>finally</b>(onFinally);  // Finally

The Promise.prototype.<i>finally</i>() method returns a new promise instance:

let p1 = new Promise(() => {});
let p2 = p1.<b>finally</b>();
<b>setTimeout</b>(console.log, 0, p1);         // Promise &lt;pending>
<b>setTimeout</b>(console.log, 0, p2);         // Promise &lt;pending>
<b>setTimeout</b>(console.log, 0, p1 === p2);  // false

This new promise instance is derived in a different manner than <i>then</i>() or <i>catch</i>(). 

Because <i>onFinally</i> is intended to be a state-agnostic method, in most cases it will behave as a pass through
for the parent promise. 

This is true for both the resolved and rejected states.

let p1 = Promise.resolve('foo');

// These all act as a pass through
let p2 = p1.<b>finally</b>();
let p3 = p1.<b>finally</b>(() => undefined);
let p4 = p1.<b>finally</b>(() => {});
let p5 = p1.<b>finally</b>(() => Promise.resolve());
let p6 = p1.<b>finally</b>(() => 'bar');
let p7 = p1.<b>finally</b>(() => Promise.resolve('bar'));
let p8 = p1.<b>finally</b>(() => Error('qux'));

<b>setTimeout</b>(console.log, 0, p2);  // Promise &lt;resolved>: foo
<b>setTimeout</b>(console.log, 0, p3);  // Promise &lt;resolved>: foo
<b>setTimeout</b>(console.log, 0, p4);  // Promise &lt;resolved>: foo
<b>setTimeout</b>(console.log, 0, p5);  // Promise &lt;resolved>: foo
<b>setTimeout</b>(console.log, 0, p6);  // Promise &lt;resolved>: foo
<b>setTimeout</b>(console.log, 0, p7);  // Promise &lt;resolved>: foo
<b>setTimeout</b>(console.log, 0, p8);  // Promise &lt;resolved>: foo

The only exceptions are when it returns a pending promise, or an error is thrown via an
explicit throw or returning a rejected promise.

In these cases, the corresponding promise is returned pending or rejected, as shown here:

// Promise.resolve() preserves the returned promise
let p9 = p1.<b>finally</b>(() => new Promise(() => {}));
let p10 = p1.<b>finally</b>(() => Promise.reject());
// Uncaught (in promise): undefined

<b>setTimeout</b>(console.log, 0, p9);  // Promise &lt;pending>
<b>setTimeout</b>(console.log, 0, p10);  // Promise &lt;rejected>: undefined

let p11 = p1.<b>finally</b>(() => { <b>throw</b> 'baz';});
// Uncaught (in promise) baz

<b>setTimeout</b>(console.log, 0, p11);  // Promise &lt;rejected>: baz

<h2>Promise Example</h2>

Javascript Promise always run some code when a promise is fulfilled
Javascript Promise and alias
Javascript Promise async change background
Javascript Promise Async promises recursion with unknow supply of async values
Javascript Promise await Promises.all
Javascript Promise break a promise chain
Javascript Promise catch 'Uncaught (in promise) Error'
Javascript Promise catch ES6 Promise rejections and completely stop flow
Javascript Promise Catch UnhandledPromiseRejectionWarning during fetch
Javascript Promise Chaining async Promises with 1 resolve and 1 reject
Javascript Promise Composing Promises and non-promise values
Javascript Promise create a promise chain shaped like a diamond
Javascript Promise create Promises and non-promise values
Javascript Promise Creating a promise without starting to resolve it
Javascript Promise deferred pattern
Javascript Promise Delays between promises in promise chain
Javascript Promise ECMAScript 6 promises
Javascript Promise element animation
Javascript Promise example
Javascript Promise freezing browser until .then is called
Javascript Promise generators yield the data passed normally to a callback/promise
Javascript Promise get promise value
Javascript Promise handle asynchronous code
Javascript Promise ignore errors in Promise.<i>all</i>()
Javascript Promise ignore errors using async/await syntax in Promise.<i>all</i>()
Javascript Promise in promise
Javascript Promise make multiple promise
Javascript Promise make recursive promise
Javascript Promise Multiple <i>fetch</i>() in Promise.all
Javascript Promise Nestled API calls returning the right promise
Javascript Promise on yield and promises
Javascript Promise Promise Retry Design Patterns
Javascript Promise Promise.all to resolve fetch requests
Javascript Promise Promise.all with predicate
Javascript Promise Promise.then being resolved before previous .then with foreach
Javascript Promise Promises then/catch
Javascript Promise Q Promise resolve/reject logic
Javascript Promise rerun Promise until a condition
Javascript Promise Resolve
Javascript Promise Retry Design Patterns 2
Javascript Promise Retry Design Patterns 3
Javascript Promise return a boolean after promise has been resolved/rejected
Javascript Promise return data in Promise
Javascript Promise return from a Promise's catch/then block
Javascript Promise return from a Promise's catch/then block 2
Javascript Promise Return promise from promise
Javascript Promise returning expected value
Javascript Promise reuse
Javascript Promise run promises in parallel
Javascript Promise Sequentially running Q Promises
Javascript Promise set background color
Javascript Promise Simple new + then for Q promises
Javascript Promise take the first N Promises that pass a filter
Javascript Promise Understanding Promises
Javascript Promise use Promises correctly with multiple requests
Javascript Promise Using Promise.all to resolve fetch requests
Javascript Promise using promises with timeout
Javascript Promise View all pending promises
Javascript Promise wait 5 seconds once print out value
Javascript Promise wait for a callback to resolve a promise
Javascript Promise wait for promise before continue
Javascript Promise waiting to resolve before next then
Javascript Promise with <i>resolve</i>()
Javascript Promise with <i>setTimeout</i>


<h2>BOM Window Object</h2>

The Browser Object Model (BOM) is the core of using JavaScript on the web.

The BOM provides objects that expose browser
functionality independent of any web page content.

<h3>Window Object</h3>
At the core of the BOM is the window object, which represents an instance of the browser.

The window object acts as the JavaScript interface to the browser window and the ECMAScript Global object.

Every object, variable, and function defined
in a web page uses window as its Global object and has access to methods like <i>parseInt</i>().

<h3>Global Scope</h3>
Because the window object doubles as the ECMAScript Global object, all variables and 
functions declared globally with var become properties and methods of the window object.

Consider this example:

var age = 9;
var sayAge = () => console.log(this.age);

console.log(<b>window</b>.age);  // 9
sayAge();           // 9
<b>window</b>.sayAge();    // 9

Output:

Here, a variable named <i>age</i> and a function named <i>sayAge</i>() are defined in the global scope, which
automatically places them on the window object.

Thus, the variable <i>age</i> is also accessible as window.age, and the function <i>sayAge</i>() is also accessible via window.<i>sayAge</i>().

Because <i>sayAge</i>() exists in the global scope, this.age maps to window.age, and the correct result is displayed.

If <i>let</i> or <i>const</i> is substituted for <i>var</i>, the default attachment to the global object does
not occur:

let age = 29;
<b>const</b> sayAge = () => console.log(this.age);

console.log(<b>window</b>.age);  // undefined
sayAge();           // undefined
<b>window</b>.sayAge();    // TypeError: window.sayAge is not a function

<h2>BOM Window Relationships</h2>

The <i>top</i> object always points to the very top outer most window, which is the browser window
itself.

Another window object is called <i>parent</i>.

The <i>parent</i> object always points to the current window's immediate parent window.

For the top most browser window, <i>parent</i> is equal to <i>top</i> and both are equal to <i>window</i>.

The top most window has no value <i>name</i> unless the window
was opened using window.<i>open</i>().

window property <i>self</i> always points to <i>window</i>.

We can chain window objects together, such as window.parent.parent.

<h2>BOM Window Position</h2>

The position of a window object can be retrieved and changed using various properties and 
methods.

Modern browsers all provide <i>screenLeft</i> and <i>screenTop</i> properties that indicate the window's
location in relation to the left and top of the screen, respectively, in CSS pixels.

We can move the window to a new position using the <i>moveTo</i>() and <i>moveBy</i>() methods.

Each method accepts two arguments.

<i>moveTo</i>() expects the x and y coordinates to move to an absolute coordinate, and 
<i>moveBy</i>() expects the number of pixels to move relative to the current coordinate.

These methods are demonstrated here:

move the window to the upper-left coordinate

move the window down by 100 pixels

move the window to position (200, 300).

<b>window</b>.<b>moveTo</b>(200, 300);

move the window left by 50 pixels.

<b>window</b>.<b>moveBy</b>(-50, 0);

Depending on the browser, these methods may be conditionally or completely disabled.

<h2>BOM Window Size</h2>

Determining the size of a window cross-browser is not easy.

All modern browsers provide four properties: 
<i>innerWidth</i>, <i>innerHeight</i>, <i>outerWidth</i>, and <i>outerHeight</i>.

<i>outerWidth</i> and <i>outerHeight</i> return the dimensions of the browser window itself regardless of whether it's used on
the top most window object or on a frame.

The <i>innerWidth</i> and <i>innerHeight</i> properties tell the
size of the page viewport inside the browser window minus borders and toolbars.

The <i>document.documentElement.clientWidth</i> and 
<i>document.documentElement.clientHeight</i>
properties provide the width and height of the page viewport.

There's no accurate way to get the size of the browser window itself, but
we get the dimensions of the page viewport, as shown in the following example:

let pageWidth = <b>window</b>.<b>innerWidth</b>,
    pageHeight = <b>window</b>.<b>innerHeight</b>;

if (<b>typeof</b> pageWidth != "number") {
  if (<b>document</b>.compatMode == "CSS1Compat"){
    pageWidth = <b>document</b>.documentElement.clientWidth;
    pageHeight = <b>document</b>.documentElement.clientHeight;
  } else {
    pageWidth = <b>document</b>.body.clientWidth;
    pageHeight = <b>document</b>.body.clientHeight;
  }
}

In this code, <i>pageWidth</i> and <i>pageHeight</i> are assigned initial values of 
<i>window.innerWidth</i> and <i>window.innerHeight</i>, respectively.

For mobile devices, <i>window.innerWidth</i> and <i>window.innerHeight</i> are the dimensions of the visual
viewport, which is the visible area of the page on the screen.

These values change as you zoom in or out of a page.

In other mobile browsers, the measurements of <i>document.documentElement</i> provide measurements
for the layout viewport, which are the actual dimensions of the rendered page as opposed to the
visual viewport, which is only a small portion of the entire page.

Because of these differences from desktop browsers, you may need to first determine if the user is on
a mobile device before deciding which measurements to use and honor.

<h2>BOM Window resize</h2>

The browser window can be resized using the <i>resizeTo</i>() and <i>resizeBy</i>() methods.

Each method accepts two arguments: <i>resizeTo</i>() expects a new width and height, and <i>resizeBy</i>() expects the
differences in each dimension.

resize to 100 x 100.

<b>window</b>.<b>resizeTo</b>(100, 100);

resize to 200 x 150.

<b>window</b>.<b>resizeBy</b>(100, 50);

resize to 300 x 300.

<b>window</b>.<b>resizeTo</b>(300, 300);

The resize methods may be disabled by the browser and are disabled by default in some browsers.

These methods apply only to the topmost window object.

<h2>BOM Window Viewport Position Scroll</h2>

We can scroll around the document with a limited viewport inside window.

The CSS pixel offset of the current viewport is available as an X and Y pair, representing the number of pixels
the viewport is currently scrolled in that direction.

The X and Y offsets are each accessible via two
properties, which return identical values: <i>window.pageXoffset</i> / 
<i>window.scrollX</i>, and <i>window.pageYoffset</i> / <i>window.scrollY</i>.

We can scroll the page by a certain amount using several different window methods.

These methods are passed two coordinates indicating how far in the X and Y direction the
viewport should scroll.window.<i>scroll</i>(x, y) will scroll the viewport by a relative amount.

window.<i>scrollBy</i>(x, y) behaves identically.

window.<i>scrollTo</i>(x, y) scrolls the viewport to an absolute offset.

Scroll down 100px relative to the current viewport.

<b>window</b>.<b>scroll</b>(0, 100);

Scroll right 40px relative to the current viewport.

<b>Window</b>.<b>scroll</b>(40, 0);

Scroll to the top left corner of the page.

<b>window</b>.<b>scrollTo</b>(0, 0);

Scroll to 100px from the top and left of the page.

<b>window</b>.<b>scrollTo</b>(100, 100);

These methods also accept a <b>ScrollToOptions</b> dictionary, 
which in addition to holding the offset
values can instruct the browser to smooth the scroll via the behavior property.

normal scroll.

<b>window</b>.<b>scrollTo</b>({
  left: 100,
  <b>top</b>: 100,
  behavior: 'auto'
 });

smooth scroll.

<b>window</b>.<b>scrollTo</b>({
  left: 100,
  <b>top</b>: 100,
  behavior: 'smooth'
});

<h2>BOM Window Open</h2>

The window.<i>open</i>() method can navigate to a particular URL and to open a new
browser window.

This method accepts four arguments: 

the URL to load,
the window target,
a string of features, and
a Boolean value indicating that the new page should take the place of the currently
loaded page in the browser history.

Typically only the first three arguments are used; the last argument applies only when not opening a new window.

If the second argument passed to window.<i>open</i>() is the name of a window or frame that already
exists, then the URL is loaded into the window or frame with that name.

Here's an example:

<b>window</b>.<b>open</b>("https://www.demo2s.com/", "topFrame");

It is the same as 

&lt;a href="http://www.demo2s.com" target="topFrame"/>

This line of code acts as if the user clicked a link with the <i>href</i> 
attribute set to "https://www.demo2s.com" and the target attribute set to  <i>topFrame</i>.

If there is a window named <i>topFrame</i>, then the
URL will be loaded there; otherwise, a new window is created and given the name  <i>topFrame</i>.

The second argument may be any of the special window names: 

_self,
_parent,
_top, or
_blank.

<h3>Popping Up Windows</h3>
When the second argument doesn't identify an existing window, a new window or tab is created
based on a string passed in as the third argument.

If the third argument is missing, a new browser
window or tab is opened with all of the default browser window settings.

Toolbars, the location bar, and the status bar are all set based on the browser's default settings.

The third argument is ignored when not opening a new window.

The third argument is a comma-delimited string of settings indicating display information for the new
window.

The following table describes the various options.

<table>
<thead><tr><th>   Setting</th><th>   <b>Value</b>(S)</th><th>   Description</th></tr></thead>
<tbody>
<tr><td>   height</td><td>   Number</td><td>   The initial height of the new window.<br>   This cannot be less than 100.        </td></tr>
<tr><td>   left</td><td>   Number</td><td>   The initial left coordinate of the new window.<br>   This cannot be a negative number.             </td></tr>
<tr><td>   location</td><td>   "yes" or  "no"</td><td>   Indicates if the location bar should be displayed.                   <br>   The default varies based on the browser.                             <br>   When set to  "no", the location bar may be either hidden or disabled.</td></tr>
<tr><td>   menubar</td><td>   "yes" or  "no"</td><td>   Indicates if the menu bar should be displayed.<br>   The default is  "no".                         </td></tr>
<tr><td>   resizable</td><td>   "yes" or  "no"</td><td>   Indicates if the new window can be resized by dragging its border.<br>   The default is "no".                                              </td></tr>
<tr><td>   scrollbars</td><td>   "yes" or  "no"</td><td>   Indicates if the new window allows scrolling if the content cannot fit in the viewport.<br>   The default is  "no".                                                                  </td></tr>
<tr><td>   status</td><td>   "yes" or  "no"</td><td>   Indicates if the status bar should be displayed.<br>   The default varies based on the browser.        </td></tr>
<tr><td>   toolbar</td><td>   "yes" or  "no"</td><td>   Indicates if the toolbar should be displayed.<br>   The default is  "no".                        </td></tr>
<tr><td>   top</td><td>   Number</td><td>   The initial top coordinate of the new window.<br>   This cannot be a negative number.            </td></tr>
<tr><td>   width</td><td>   Number</td><td>   The initial width of the new window.<br>   This cannot be less than 100.       </td></tr>
</tbody></table>
Any or all of these settings may be specified as a comma-delimited set of name-value pairs.

The name-value pairs are indicated by an equal sign.

No white space is allowed in the feature string.

Consider the following example:

<b>window</b>.<b>open</b>("https://www.demo2s.com/",
           "myWindow",
           "height=400,width=400,top=10,left=10,resizable=yes");

This code opens a new resizable window that's 400x400 and positioned 10 pixels from the top and
left of the screen.

<h3>Return</h3>
The window.<i>open</i>() method returns a reference to the newly created window.

This object is the same as
any other window object except that you typically have more control over it.

For instance, some browsers that don't allow you to resize or move the main browser window by default may allow you to resize
or move windows that you've created using window.<i>open</i>().

This object can be used to manipulate the
newly opened window in the same way as any other window, as shown in this example:

let myWin = <b>window</b>.<b>open</b>("https://www.demo2s.com/",
              "myWindow",
              "height=400,width=400,top=10,left=10,resizable=yes");

// resize it
myWin.<b>resizeTo</b>(500, 500);

// move it
myWin.<b>moveTo</b>(100, 100);

We can close the newly opened window by calling the <i>close</i>() method as follows:

myWin.<b>close</b>();

This method works only for pop-up windows created by window.<i>open</i>().

It's not possible to close the main browser window without confirmation from the user.

It is possible, however, for the pop-up window
to close itself without user confirmation by calling top.<i>close</i>().

Once the window has been closed, the
window reference still exists but cannot be used other than to check the closed property, as shown here:

myWin.<b>close</b>();
console.log(myWin.<b>closed</b>);  // true

The newly created window object has a reference back to the window that opened it via the <i>opener</i>
property.

This property is defined only on the topmost window object (top) of the pop-up window
and is a pointer to the window or frame that called window.<i>open</i>().

For example:

let myWin = <b>window</b>.<b>open</b>("https://www.demo2s.com/",
              "myWindow",
              "height=400,width=400,top=10,left=10,resizable=yes");

console.log(myWin.<b>opener</b> === <b>window</b>);  // true

Even though there is a pointer from the pop-up window back to the window that opened it, there is
no reverse relationship.

Windows do not keep track of the pop-ups that they spawn, so it's up to you
to keep track if necessary.

Depend on browsers, some allow you to indicate that the newly created tab should be run in a
separate process by setting the <i>opener</i> property to <i>null</i>, as in the following example:

let myWin = <b>window</b>.<b>open</b>("https://www.demo2s.com/",
              "myWindow",
              "height=400,width=400,top=10,left=10,resizable=yes");

myWin.<b>opener</b> = null;

Setting opener to null indicates to the browser that the newly created tab doesn't need to 
communicate with the tab that opened it, so it may be run in a separate process.

<h2>BOM Window Pop-up Blockers</h2>

All modern browsers have pop-up-blocking software built in.

Most unexpected pop-ups are blocked.

When a pop-up is blocked, one of two things happens.

If the browser's built-in
pop-up blocker stopped the pop-up, then window.<i>open</i>() will most likely return null.

In that case,
you can tell if a pop-up was blocked by checking the return value, as shown in the following example:

let myWin = <b>window</b>.<b>open</b>("https://www.demo2s.com", "_blank");
if (myWin == null){
  console.log("The popup was blocked!");
}

When a browser add-on or other program blocks a pop-up, window.<i>open</i>() typically throws an
error.

So to accurately detect when a pop-up has been blocked, you must check the return value and
wrap the call to window.<i>open</i>() in a try-catch block, as in this example:

let blocked = false;

<b>try</b> {
  let myWin = <b>window</b>.<b>open</b>("https://www.demo2s.com", "_blank");
  if (myWin == null){
    blocked = true;
  }
} <b>catch</b> (ex){
  blocked = true;
}
if (blocked){
  console.log("The popup was blocked!");
}

This code accurately detects if a pop-up blocker has blocked the call to window.<i>open</i>(), regardless of
the method being used.

<h2>Using Timers from Window Object</h2>

A useful feature provided by the Window object is the ability to set one-off and recurring timers.

These  timers are used to execute a function after a preset period.

The following table summarizes the methods that  support this feature.

<table>
<thead><tr><th> Name</th><th>   Description</th><th>   Returns</th></tr></thead>
<tbody>
<tr><td> <i>clearInterval</i>(&lt;id>)</td><td>   Cancels an interval timer</td><td>   void</td></tr>
<tr><td> <i>clearTimeout</i>(&lt;id>)</td><td>   Cancels a timeout timer</td><td>   void</td></tr>
<tr><td> <i>setInterval</i>(&lt;function>, &lt;time>)</td><td>   Creates a timer that will call the specified<br>   function every time milliseconds            </td><td>   int</td></tr>
<tr><td> <i>setTimeout</i>(&lt;function>, &lt;time>)</td><td>   Creates a timer that will call the specified<br>   function once after time milliseconds       </td><td>   int</td></tr>
</tbody></table>
The <i>setTimeout</i>() method creates a timer that executes the specified function just once, whereas the
 <i>setInterval</i>() method creates a timer that executes a function repeatedly.

These methods return a unique identifier that can later be used as an argument to the <i>clearTimeout</i>()
 and <i>clearInterval</i>() methods to cancel the timer.

The following code shows the use of the timer methods.

let buttons = <b>document</b>.getElementsByTagName("button");
for (let i = 0; i &lt; buttons.<b>length</b>; i++) {
    buttons[i].onclick = handleButtonPress;
}

let timeID;/* w   ww  .  d   e m  o  2  s   . c  o    m*/
let intervalID;
let count = 0;

function handleButtonPress(e) {
    if (e.target.id == "settime") {
        timeID = <b>window</b>.<b>setTimeout</b>(function() {
            displayMsg("Timeout Expired");
        }, 5000);
        displayMsg("Timeout Set");
    } else if (e.target.id == "cleartime") {
        <b>window</b>.<b>clearTimeout</b>(timeID);
        displayMsg("Timeout Cleared");
    } else if (e.target.id == "setinterval") {
        intervalID = <b>window</b>.<b>setInterval</b>(function() {
             displayMsg("Interval expired. Counter: " + count++);
        }, 2000);
        displayMsg("Interval Set");
    } else if (e.target.id == "clearinterval") {
        <b>window</b>.<b>clearInterval</b>(intervalID);
        displayMsg("Interval Cleared");
    }
}

function displayMsg(msg) {
    <b>document</b>.getElementById("msg").innerHTML = msg;
}

<iframe onload="resizeIframe(this)" style="border:1px solid #f1f1f1;margin:10px 0 10px 0;background-color:#ffffff;" frameborder="0" seamless width="100%" height="350" src="javascript-using-timers-from-window-object-demo-e7943.htm"></iframe><br><a href="javascript-using-timers-from-window-object-demo-e7943.htm">Open in separate window</a><br><a type="button" data-toggle="collapse" style="padding:2px;" role="button" aria-expanded="false" aria-controls="VMR" href="#VMR">View full source code</a>

 &lt;html>
    &lt;body>
        &lt;p <b>id</b>="msg">&lt;/p>
        &lt;p>
            &lt;button <b>id</b>="settime">Set Time&lt;/button>
            &lt;button <b>id</b>="cleartime">Clear Time&lt;/button>
            &lt;button <b>id</b>="setinterval">Set Interval&lt;/button>
            &lt;button <b>id</b>="clearinterval">Clear Interval&lt;/button>
        &lt;/p>

        &lt;script>
            let buttons = <b>document</b>.getElementsByTagName("button");
            for (let i = 0; i &lt; buttons.length; i++) {
                buttons[i].<b>onclick</b> = handleButtonPress;
            }&lt;!--   w  w  w.    de  m  o  2  s  .  c   o  m -->

            let timeID;
            let intervalID;
            let count = 0;

            <b>function</b> handleButtonPress(e) {
                if (e.target.<b>id</b> == "settime") {
                    timeID = window.setTimeout(<b>function</b>() {
                        displayMsg("Timeout Expired");
                    }, 5000);
                    displayMsg("Timeout Set");
                } else if (e.target.<b>id</b> == "cleartime") {
                    window.clearTimeout(timeID);
                    displayMsg("Timeout Cleared");
                } else if (e.target.<b>id</b> == "setinterval") {
                    intervalID = window.setInterval(<b>function</b>() {
                         displayMsg("Interval expired. Counter: " + count++);
                    }, 2000);
                    displayMsg("Interval Set");
                } else if (e.target.<b>id</b> == "clearinterval") {
                    window.clearInterval(intervalID);
                    displayMsg("Interval Cleared");
                }
            }

            <b>function</b> displayMsg(msg) {
                <b>document</b>.getElementById("msg").innerHTML = msg;
            }

        &lt;/script>
    &lt;/body>
&lt;/html>

<script>function resizeIframe(iframe) {let h = iframe.contentWindow.document.body.scrollHeight;if (h<200){h=220;}iframe.style.height = h + 'px'; console.log(h + 'px');}</script>
The script in this example sets and cancels timers and intervals that call the
<i>displayMsg</i>() function to set the content of a &lt;p> element.

<h2>BOM Window Timeouts setTimeout()</h2>

JavaScript execution in a browser is single-threaded.

It does allow for the scheduling of code to run
at specific points in time through the use of timeouts and intervals.

Timeouts execute some code after
a specified amount of time, whereas intervals execute code repeatedly, waiting a specific amount of
time in between each execution.

You set a timeout using the window's <i>setTimeout</i>() method, which accepts two arguments: 
the code to execute and the time in milliseconds to wait before scheduling the callback function to be
executed.

The first argument can be either a string 
containing JavaScript code or a function.

For example: schedules an alert to show after 1 second

<b>setTimeout</b>(() => console.log("Hello world!"), 1000);

The second argument, the number of milliseconds to wait, is not necessarily when the specified
code will execute.

JavaScript is single-threaded and, as such, can execute only one piece of code at a time.

The second argument of <i>setTimeout</i>() tells
the JavaScript engine to add this task onto the queue after a set number of milliseconds.

If the
queue is empty, then that code is executed immediately; if the queue is not empty, the code must
wait its turn.

<h3>Time out ID</h3>
When <i>setTimeout</i>() is called, it returns a numeric ID for the timeout.

The timeout ID is a unique
identifier for the scheduled code that can be used to cancel the timeout.

To cancel a pending timeout,
use the <i>clearTimeout</i>() method and pass in the timeout ID, as in the following example:

// set the timeout
let timeoutId = <b>setTimeout</b>(() => console.log("Hello world!"), 1000);
// cancel it
<b>clearTimeout</b>(timeoutId);

As long as <i>clearTimeout</i>() is called before the specified amount of time has passed, a 
timeout can be canceled completely.

Calling <i>clearTimeout</i>() after the code has been executed has no effect.

All code executed by a timeout using a conventional anonymous function
runs in the global scope, so the value of <i>this</i> inside the function will always
point to <i>window</i> when running in non strict mode and <i>undefined</i> when running
in strict mode.

When <i>setTimeout</i> is instead provided an arrow function, this
preserves the lexical scope in which it was defined.

<h2>BOM Window setInterval()</h2>

Intervals work in the same way as timeouts except that they schedule the code for execution 
repeatedly at specific time intervals until the interval is canceled or the page is unloaded.

The <i>setInterval</i>() method lets you set up intervals, and it accepts the two arguments: 

the code to execute as string or function and
the milliseconds to wait between addition of the callback function to the execution queue.

Here's an example:

<b>setInterval</b>(() => console.log("Hello world!"), 10000);

The time interval specified with the second argument represents the 
amount of time the browser will wait in between adding a new callback
execution onto the queue.

The browser doesn't care when the callback
executes or how long it takes.

The short and non-blocking callback functions are ideal for <i>setInterval</i>.

The <i>setInterval</i>() method also returns an interval ID that can be used to cancel the interval at
some point in the future.

The <i>clearInterval</i>() method can be used with this ID to cancel all pending intervals.

If left unchecked, they continue to execute until the page is unloaded.

Here is a common example of interval usage:

let num = 0, intervalId = null;
let max = 10;

let incrementNumber = function() {
  num++;
  // if the max has been reached, cancel all pending executions
  if (num == max) {
    <b>clearInterval</b>(intervalId);
    console.log("Done");
  }
}
intervalId = <b>setInterval</b>(incrementNumber, 500);

In this example, the variable <i>num</i> is incremented every half second until it finally reaches the 
maximum number, at which point the interval is canceled.

This pattern can also be implemented using timeouts, as shown here:

let num = 0;
let max = 10;

let incrementNumber = function() {
  num++;

  //if the max has not been reached, set another timeout
  if (num &lt; max) {
    <b>setTimeout</b>(incrementNumber, 500);
  } else {
    console.log("Done");
  }
}
<b>setTimeout</b>(incrementNumber, 500);

When you're using timeouts, it is unnecessary to track the timeout ID because the 
execution will stop on its own and continue only if another timeout is set.

This pattern is considered a best
practice for setting intervals without actually using intervals.

<h2>BOM System Dialogs</h2>

The Window object contains a set of methods for prompting the user in different ways.

The browser can invoke system dialogs to display to the user through the <i>alert</i>(),
<i>confirm</i>(), and <i>prompt</i>() methods.

<table>
<thead><tr><th>Name</th><th>   Description</th><th>   Returns</th></tr></thead>
<tbody>
<tr><td><i>alert</i>(&lt;msg>)</td><td>   Displays a dialog window to the user and waits for it to<br>   be dismissed                                            </td><td>   void</td></tr>
<tr><td><i>confirm</i>(&lt;msg>)</td><td>   Displays a dialog window with an OK/Cancel prompt</td><td>   boolean</td></tr>
<tr><td><i>prompt</i>(&lt;msg>, &lt;val>)</td><td>   Displays a dialog prompting the user to enter a value</td><td>   string</td></tr>
<tr><td><i>showModalDialog</i>(&lt;url>)</td><td>   Displays a popup window showing the specified URL</td><td>   void</td></tr>
</tbody></table>
These dialogs are not related to the web page being displayed
in the browser and do not contain HTML.

Their appearance is determined by operating system and / or browser settings rather than CSS.

Additionally, each of these dialogs is synchronous and modal,
meaning code execution stops when a dialog is displayed, and resumes after it has been dismissed.

<h3>Alert</h3>
The <i>alert</i>() method accepts a string to display to the user.

<i>alert</i>() expects only one argument.

When <i>alert</i>() is called, a system message box displays the
specified text to the user, followed by a single OK button.

If <i>alert</i>() is passed an argument that is
not a string primitive, it will coerce the argument into a string with its.<i>toString</i>() method.

Alert dialogs are typically used when users must be made aware of something that they have no
control over, such as an error.

A user's only choice is to dismiss the dialog after reading the message.

<h3>Confirm</h3>
The second type of dialog is invoked by calling <i>confirm</i>().

A confirm dialog displays a message to the user.

A confirmation dialog has a Cancel button along with the OK button,
which allows the user to indicate if a given action should be taken.

To determine if the user clicked OK or Cancel, the <i>confirm</i>() method returns a Boolean value: true
if OK was clicked, or false if Cancel was clicked or the dialog box was closed by clicking the X in
the corner.

Typical usage of a confirm dialog looks like this:

if (<b>confirm</b>("Are you sure?")) {
   console.log("yes");
} else {
   console.log("not sure.");
}

In this example, the confirm dialog is displayed to the user in the first line, which is a condition of the
if statement.

<h3>Prompt</h3>
The final type of dialog is displayed by calling <i>prompt</i>(), which prompts the user
for input.

Along with OK and Cancel buttons, this dialog has a text box where the
user may enter some data.

The <i>prompt</i>() method accepts two arguments: the text to display to the user, and the default
value for the text box. The default value can be an empty string.

If the OK button is clicked, <i>prompt</i>() returns the value in the text box; if Cancel is clicked or the
dialog is otherwise closed without clicking OK, the function returns null.

Here's an example:

let result = <b>prompt</b>("What is your name? ", "");
if (result !== null) {
   console.log("Welcome, " + result);
}

These system dialogs can be helpful for displaying information to the user and asking for 
confirmation of decisions.

<h3>find and print</h3>
Two other types of dialogs can be displayed from JavaScript: find and print.

Both of these dialogs
are displayed asynchronously, returning control to the script immediately.

The dialogs are the same
as the ones the browser employs when the user selects either Find or Print from the browser's menu.

These are displayed using the <i>find</i>() and <i>print</i>() methods on the window object as follows:

// display print dialog
<b>window</b>.<b>print</b>();

// display find dialog
<b>window</b>.<b>find</b>();

These two methods give no indication as to whether the user has done anything with the dialog,
so it is difficult to make good use of them.

Prompting the User.

let buttons = <b>document</b>.getElementsByTagName("button");
for (let i = 0 ; i &lt; buttons.<b>length</b>; i++) {
    buttons[i].onclick = handleButtonPress;
}

function handleButtonPress(e) {
    if (e.target.id == "alert") {
        <b>window</b>.<b>alert</b>("This is an alert");
    } else if (e.target.id == "confirm") {
        let confirmed
           = <b>window</b>.<b>confirm</b>("This is a confirm - do you want to proceed?");
        <b>alert</b>("Confirmed? " + confirmed);
    } else if (e.target.id == "prompt") {
        let response = <b>window</b>.<b>prompt</b>("Enter a word", "hello");
        <b>alert</b>("The word was " + response);
    } else if (e.target.id == "modal") {
        <b>window</b>.showModalDialog("https://demo2s.com");
    }
}

<iframe onload="resizeIframe(this)" style="border:1px solid #f1f1f1;margin:10px 0 10px 0;background-color:#ffffff;" frameborder="0" seamless width="100%" height="350" src="javascript-bom-system-dialogs-demo-16373.htm"></iframe><br><a href="javascript-bom-system-dialogs-demo-16373.htm">Open in separate window</a><br><a type="button" data-toggle="collapse" style="padding:2px;" role="button" aria-expanded="false" aria-controls="PJO" href="#PJO">View full source code</a>

&lt;html>
    &lt;head>
        &lt;style>
            table { <font color="black"><b>border</b></font>-collapse: collapse; <font color="black"><b>border</b></font>: thin solid black;}
            th, td { <font color="black"><b>padding</b></font>: 4px; }
        &lt;/style>
    &lt;/head>
    &lt;body>
        &lt;button <b>id</b>="alert">Alert&lt;/button>
        &lt;button <b>id</b>="confirm">Confirm&lt;/button>
        &lt;button <b>id</b>="prompt">Prompt&lt;/button>
        &lt;button <b>id</b>="modal">Modal Dialog&lt;/button>

        &lt;script type="text/javascript">

            let buttons = <b>document</b>.getElementsByTagName("button");
            for (let i = 0 ; i &lt; buttons.length; i++) {
                buttons[i].<b>onclick</b> = handleButtonPress;
            }&lt;!--   w  w w  . d    e  m o  2  s .  c   o m  -->

            <b>function</b> handleButtonPress(e) {
                if (e.target.<b>id</b> == "alert") {
                    window.alert("This is an alert");
                } else if (e.target.<b>id</b> == "confirm") {
                    let confirmed
                       = window.confirm(
                          "This is a confirm - do you want to proceed?");
                    alert("Confirmed? " + confirmed);
                } else if (e.target.<b>id</b> == "prompt") {
                    let response = window.prompt("Enter a word", "hello");
                    alert("The word was " + response);
                } else if (e.target.<b>id</b> == "modal") {
                    window.showModalDialog("https://demo2s.com");
                }
            }
        &lt;/script>
    &lt;/body>
&lt;/html>

<script>function resizeIframe(iframe) {let h = iframe.contentWindow.document.body.scrollHeight;if (h<200){h=220;}iframe.style.height = h + 'px'; console.log(h + 'px');}</script>

<h2>BOM Location Object</h2>

The <i>document.location</i> property returns a  <b>Location</b> object that gives you 
fine-grained information about the document's address and allows you to navigate to other documents.

BOM <i>location</i> object provides information about the document
that is currently loaded in the window, as well as general navigation functionality.

The <i>location</i> object is a property of both window and document; 
both <i>window.location</i> and <i>document.location</i> point to the same object.

The <i>location</i> object knows about the currently
loaded document, and it also parses the URL into discrete segments that can be accessed via a series of
properties.

The following table describes the functions and properties of the  <b>Location</b> object.

<table>
<thead><tr><th>Property</th><th>   Description</th><th>   Returns</th></tr></thead>
<tbody>
<tr><td>protocol</td><td>   Gets or sets  the protocol component of the document URL</td><td>   string</td></tr>
<tr><td>host</td><td>   Gets or sets the host component of the document URL</td><td>   string</td></tr>
<tr><td>href</td><td>   Gets or sets the current document's location</td><td>   string</td></tr>
<tr><td>hostname</td><td>   Gets or sets the host name component of the document URL</td><td>   string</td></tr>
<tr><td>port</td><td>   Gets or sets the port component of the document URL</td><td>   string</td></tr>
<tr><td>pathname</td><td>   Gets or sets the path component of the document URL</td><td>   string</td></tr>
<tr><td>search</td><td>   Gets or sets the query  component of the document URL</td><td>   string</td></tr>
<tr><td>hash</td><td>   Gets or sets the hash component of the document URL</td><td>   string</td></tr>
<tr><td><i>assign</i>(&lt;URL>)</td><td>   Navigates to the specified URL</td><td>   void</td></tr>
<tr><td><i>replace</i>(&lt;URL>)</td><td>   Removes the current document and navigates to the one<br>   specified by the URL.                                </td><td>   void</td></tr>
<tr><td><i>reload</i>()</td><td>   Reloads the current document</td><td>   void</td></tr>
<tr><td><i>resolveURL</i>(&lt;URL>)</td><td>   Resolves the specified relative URL to an absolute one</td><td>   string</td></tr>
</tbody></table>
These properties are enumerated in the following table.

If the browser was currently located at 

http://userName:usrPas@www.demo2s.com:80/html-folder/?q=javascript#contents

then the location object would behave as follows:

<table>
<thead><tr><th>   Property Name</th><th>   Return Value</th><th>   Description</th></tr></thead>
<tbody>
<tr><td>   location.hash</td><td>   "#contents"</td><td>   The URL hash, or an empty string if the URL does not have a hash.</td></tr>
<tr><td>   location.host</td><td>   "www.demo2s.com:80"</td><td>   The name of the server and port number if present.</td></tr>
<tr><td>   location.hostname</td><td>   "www.demo2s.com"</td><td>   The name of the server without the port number.</td></tr>
<tr><td>   location.href</td><td>    "http://www.demo2s.  <br>   com:80/html-folder/?q=<br>   javascript#contents"  </td><td>    The full URL of the currently loaded page.          <br>   The <i>toString</i>() method of location returns this value.</td></tr>
<tr><td>   location.pathname</td><td>   "/html-folder/"</td><td>   The directory and/or filename of the URL.</td></tr>
<tr><td>   location.port</td><td>   "80"</td><td>   The port of the request if specified in the URL.                             <br>   If a URL does not contain a port, then this property returns an empty string.</td></tr>
<tr><td>location.protocol</td><td>   "http:"</td><td>   The protocol used by the page. <br>   Typically "http:" or  "https:".</td></tr>
<tr><td>location.search</td><td>   "?q=javascript"</td><td>   The query string of the URL.                       <br>   It returns a string beginning with a question mark.</td></tr>
<tr><td>location.username</td><td>   "userName"</td><td>   The username specified before the domain name.</td></tr>
<tr><td>location.password</td><td>   "<i>usrPas</i>"</td><td>   The password specified before the domain name.</td></tr>
<tr><td>location.origin</td><td>   "http:// www.demo2s.com"</td><td>   The origin of the URL.<br>   Read only.            </td></tr>
</tbody></table>

<h2>BOM Location Query String Arguments</h2>

Most of the information in location is accessible from properties of <i>location</i> object.

Though <i>location.search</i> returns everything
from the question mark until the end of the URL, there is no immediate access to query-string 
arguments on a one-by-one basis.

The following function parses the query string and returns an object
with entries for each argument:

let getQueryStringArgs = function() {
  // get query string without the initial '?'
  let qs = (<b>location</b>.search.<b>length</b> > 0 ? <b>location</b>.search.substring(1) : ""),
      // object to hold data
      args = {};

  // assign each item onto the args object
  for (let item of qs.split("&amp;").map(kv => kv.split("="))) {
    let <b>name</b> = decodeURIComponent(item[0]),
      value = decodeURIComponent(item[1]);
    if (<b>name</b>.<b>length</b>) {
      args[<b>name</b>] = value;
    }
  }

  return args;
}

The first step in this function is to strip off the question mark from the beginning of the query string.

This happens only if location.search has one or more characters.

The arguments will be stored on the <i>args</i> object, which is created using object-literal format.

Next, the query string is split on the <i>ampersand</i> character, returning an array of strings in the format name=value.

The <i>for</i> loop iterates over this array and then splits each item on the equal sign, returning an array where the first item is
    the name of the argument and the second item is the value.

The <i>name</i> and <i>value</i> are each decoded using <i>decodeURIComponent</i>().

Last, the <i>name</i> is assigned as a property on the <i>args</i> object, and its value is set to value.

This function is used as follows: assume query string of ?q=javascript&amp;num=10

let args = getQueryStringArgs();

console.log(args["q"]);    // "javascript"
console.log(args["num"]);  // "10"

Each of the query-string arguments is now a property on the returned object, which provides fast
access to each argument.

<h2>Use URLSearchParams to parse search URL</h2>

<b>URLSearchParams</b> offers a collection of utility methods which allow you to inspect and modify query
parameters using a standardized API.

A <b>URLSearchParams</b> instance is created by passing a query
string to the constructor.

The instance exposes various methods like <i>get</i>(), <i>set</i>(), and <i>delete</i>() to
perform query string operations.

These are demonstrated here:

let qs = "?q=css&amp;num=10";

let searchParams = new URLSearchParams(qs);

console.log(searchParams.<b>toString</b>());  // " q=css&amp;num=10"
searchParams.has("num");               // true
searchParams.get("num");               // 10

searchParams.set("page", "3");
console.log(searchParams.<b>toString</b>());  // " q=css&amp;num=10&amp;page=3"

searchParams.delete("q");
console.log(searchParams.<b>toString</b>());  // " num=10&amp;page=3"

Most browsers that support <b>URLSearchParams</b> also support using the <b>URLSearchParams</b> as an 
iterable object:

let qs = "?q=css&amp;num=10";

let searchParams = new URLSearchParams(qs);

for (let param of searchParams) {
   console.log(param);
}

Output:



<h2>BOM Manipulating the Location</h2>

The browser location can be changed in a number of ways using the <i>location</i> object.

The first we use the <i>assign</i>() method and pass in a URL, as in the following example:

<b>location</b>.<b>assign</b>("https://www.demo2s.com");

This immediately starts the process of navigating to the new URL and makes an entry in the browser's history stack.

If <i>location.href</i> or <i>window.location</i> is set to a URL, the <i>assign</i>() method
is called with the value.

For example, both of the following perform the same behavior as calling
<i>assign</i>() explicitly:

<b>window</b>.<b>location</b> = "http://www.demo2s.com";
<b>location</b>.href = "http://www.demo2s.com";

Of these three approaches to changing the browser location, setting <i>location.href</i> is most often
used.

<h2>BOM Location properties</h2>

Changing various properties on the location object can also modify the currently loaded page.

The <i>hash</i>, <i>search</i>, <i>hostname</i>, <i>pathname</i>, and <i>port</i> properties can be set with new values that alter the
current URL, as in this example:

Assume starting at https://www.demo2s.com/css/

changes URL to "https://www.demo2s.com/css/#section1"

<b>location</b>.hash = "#section1";

changes URL to "https://www.demo2s.com/css/?q=javascript"

<b>location</b>.search = "?q=javascript";

changes URL to "http://www.yahoo.com/css/"

<b>location</b>.hostname = "www.yahoo.com";

changes URL to "http://www.yahoo.com/my_dir/"

<b>location</b>.pathname = "my_dir";

changes URL to "http://www.yahoo.com:8080/css/"

<b>Location</b>.port = 8080;

Each time a property on location is changed, with the exception of hash, the page reloads with
the new URL.

Changing the value of hash causes a new entry in the browser's history to be recorded.

<h3>Example</h3>
The simplest use for the document.location property is to get information about the location of the
current object.

Using the Location Object to Get Information About the Document.

<b>document</b>.writeln("protocol: " + <b>document</b>.<b>location</b>.protocol);
<b>document</b>.writeln("host: " + <b>document</b>.<b>location</b>.host);
<b>document</b>.writeln("hostname: " + <b>document</b>.<b>location</b>.hostname);
<b>document</b>.writeln("port: " + <b>document</b>.<b>location</b>.port);
<b>document</b>.writeln("pathname: " + <b>document</b>.<b>location</b>.pathname);
<b>document</b>.writeln("search: " + <b>document</b>.<b>location</b>.search);
<b>document</b>.writeln("hash: " + <b>document</b>.<b>location</b>.hash);

<iframe onload="resizeIframe(this)" style="border:1px solid #f1f1f1;margin:10px 0 10px 0;background-color:#ffffff;" frameborder="0" seamless width="100%" height="350" src="javascript-bom-location-properties-demo-d5c42.htm"></iframe><br><a href="javascript-bom-location-properties-demo-d5c42.htm">Open in separate window</a><br><a type="button" data-toggle="collapse" style="padding:2px;" role="button" aria-expanded="false" aria-controls="VTC" href="#VTC">View full source code</a>

&lt;html>
    &lt;body>
        &lt;script>
            <b>document</b>.writeln("&lt;pre>");

            <b>document</b>.writeln("protocol: " + <b>document</b>.location.protocol);
            <b>document</b>.writeln("host: " + <b>document</b>.location.host);
            <b>document</b>.writeln("hostname: " + <b>document</b>.location.hostname);
            <b>document</b>.writeln("port: " + <b>document</b>.location.port);
            <b>document</b>.writeln("pathname: " + <b>document</b>.location.pathname);
            <b>document</b>.writeln("search: " + <b>document</b>.location.search);
            <b>document</b>.writeln("hash: " + <b>document</b>.location.hash);

            <b>document</b>.write("&lt;/pre>");
        &lt;/script>
    &lt;/body>
&lt;/html>

<script>function resizeIframe(iframe) {let h = iframe.contentWindow.document.body.scrollHeight;if (h<200){h=220;}iframe.style.height = h + 'px'; console.log(h + 'px');}</script>
The <i>search</i> property returns the query string portion of the URL, and 
the hash property returns the
URL fragment. 

<h2>BOM Location replace</h2>

When the URL is changed in location object, an entry is made in
the browser's history stack so the user may click the Back button to navigate to the previous page.

It is possible to disallow this behavior by using the <i>replace</i>() method.

This method accepts a single
argument, the URL to navigate to, but does not make an entry in the history stack.

After calling <i>replace</i>(), the user cannot go back to the previous page.

Consider this example:

&lt;!DOCTYPE html>
&lt;html>
&lt;head>
  &lt;title>You won't be able to get back here&lt;/title>
&lt;/head>
&lt;body>
  &lt;p>Enjoy this page for a second, because you won't be coming back here.&lt;/p>
  &lt;script>
    <b>setTimeout</b>(() => <b>location</b>.replace("https://www.demo2s.com/"), 1000);
  &lt;/script>
&lt;/body>
&lt;/html>

If this page is loaded into a web browser, it will redirect to www.demo2s.com after a second.

At that point, the Back button will be disabled, and you won't be able to navigate back to this example page
without typing in the complete URL again.

<h2>BOM Location Reload</h2>

The location <i>reload</i>() method reloads the currently displayed page.

When <i>reload</i>() is called with no argument, the page is reloaded in the most efficient way possible, which is to say
that the page may be reloaded from the browser cache if it hasn't changed since the last request.

To force a reload from the server, pass in true as an argument like this:

<b>location</b>.reload();      // reload - possibly from cache
<b>location</b>.reload(true);  // reload - go back to the server

Any code located after a <i>reload</i>() call may or may not be executed, depending on factors such
as network latency and system resources.

We should have <i>reload</i>() as the last line of code.

<h2>BOM Navigator Object</h2>

Navigator object is the standard for browser identification on the client.

The navigator object is common among all JavaScript-enabled web browsers.

Each browser supports its own set of properties.

The <i>navigator</i> object implements methods and properties defined in the following 
interfaces: 

NavigatorID, 
NavigatorLanguage, 
NavigatorOnLine, 
NavigatorContentUtils, 
NavigatorStorage, 
NavigatorStorageUtils, 
NavigatorConcurrentHardware, 
NavigatorPlugins, and 
NavigatorUserMedia 

The following table lists each available property and method:

<table>
<thead><tr><th>Property/Method</th><th>   Description</th></tr></thead>
<tbody>
<tr><td><i>activeVrDisplays</i></td><td>   Returns an array of every <b>VRDisplay</b> instance with its  <i>ispresenting</i> property set to true.</td></tr>
<tr><td><i>appCodeName</i></td><td>   Returns "Mozilla" even in non-Mozilla browsers.</td></tr>
<tr><td><i>appName</i></td><td>   Full browser name.</td></tr>
<tr><td><i>appVersion</i></td><td>    Browser version.                                           <br>   Typically does not correspond to the actual browser version.</td></tr>
<tr><td>battery</td><td>   Returns a <b>BatteryManager</b> object to interact with the Battery Status API.</td></tr>
<tr><td><i>buildId</i></td><td>   Build number for the browser.</td></tr>
<tr><td>connection</td><td>   Returns a <b>NetworkInformation</b> object to interact with the Network Information API.</td></tr>
<tr><td><i>cookieEnabled</i></td><td>   Indicates if cookies are enabled.</td></tr>
<tr><td>credentials</td><td>   A <b>CredentialsContainer</b> to interact with the Credentials Management API.</td></tr>
<tr><td><i>deviceMemory</i></td><td>   The amount of device memory in gigabytes.</td></tr>
<tr><td><i>doNotTrack</i></td><td>   The user's do-not-track preference.</td></tr>
<tr><td><i>geolocation</i></td><td>   A <b>Geolocation</b> object to interact with the <b>Geolocation</b> API.</td></tr>
<tr><td><i>getVRDisplays</i>()</td><td>   Returns an array of every <b>VRDisplay</b> instance available.</td></tr>
<tr><td><i>getUserMedia</i>()</td><td>   Returns the stream associated with the available media device hardware.</td></tr>
<tr><td><i>hardwareConcurrency</i></td><td>   The device's number of processor cores.</td></tr>
<tr><td><i>javaEnabled</i></td><td>   Indicates if Java is enabled in the browser.</td></tr>
<tr><td>language</td><td>   The browser's primary language.</td></tr>
<tr><td>languages</td><td>   An array of all the browser's preferred languages.</td></tr>
<tr><td>locks</td><td>   A <b>LockManager</b> object to interact with the Web Locks API.</td></tr>
<tr><td><i>mediaCapabilities</i></td><td>   A <b>MediaCapabilities</b> object to interact with the Media Capabilities API.</td></tr>
<tr><td><i>mediaDevices</i></td><td>   The available media devices.</td></tr>
<tr><td><i>maxTouchPoints</i></td><td>   The maximum number of supported touch points for the device's touch screen.</td></tr>
<tr><td><i>mimeTypes</i></td><td>   Array of MIME types registered with the browser.</td></tr>
<tr><td><i>onLine</i></td><td>   Indicates if the browser is connected to the Internet.</td></tr>
<tr><td><i>oscpu</i></td><td>   The operating system and/or CPU on which the browser is running.</td></tr>
<tr><td>permissions</td><td>   A Permissions object to interact with the Permissions API.</td></tr>
<tr><td>platform</td><td>   The system platform on which the browser is running.</td></tr>
<tr><td>plugins</td><td>   Array of plug-ins installed on the browser.</td></tr>
<tr><td>product</td><td>   The name of the product, typically <b>Gecko</b>.</td></tr>
<tr><td><i>productSub</i></td><td>   Extra information about the product (typically <b>Gecko</b> version information).</td></tr>
<tr><td><i>registerProtocolHandler</i>()</td><td>   Registers a website as a handler for a particular protocol.</td></tr>
<tr><td><i>requestMediaKeySystemAccess</i>()</td><td>   Returns a Promise which resolves to a <b>MediaKeySystemAccess</b> object.</td></tr>
<tr><td><i>sendBeacon</i>()</td><td>   Asynchronously transmits a small payload.</td></tr>
<tr><td><i>serviceWorker</i></td><td>   The <b>ServiceWorkerContainer</b> used to interact with <b>ServiceWorker</b> objects.</td></tr>
<tr><td><i>share</i>()</td><td>   If available, invokes the current platform's native sharing mechanism.</td></tr>
<tr><td>storage</td><td>   Returns the <b>StorageManager</b> object to interact with the Storage API.</td></tr>
<tr><td><i>userAgent</i></td><td>   The user-agent string for the browser.</td></tr>
<tr><td>vendor</td><td>   The brand name of the browser.</td></tr>
<tr><td><i>vendorSub</i></td><td>   Extra information about the vendor.</td></tr>
<tr><td><i>vibrate</i>()</td><td>   Triggers the device to vibrate if vibration is supported.</td></tr>
<tr><td><i>webdriver</i></td><td>   Indicates if the browser is controlled by automation.</td></tr>
</tbody></table>
The navigator object's properties are typically used to determine the type of browser that is running a web page.

<h2>BOM navigator Registering Handlers</h2>

Modern browsers formally support the <i>registerProtocolHandler</i>() method to the <i>navigator</i>
object.

These methods allow a website to indicate that it can handle specific types of information.

We can handle protocols by using <i>registerProtocolHandler</i>(), which accepts three 
arguments: 

the protocol to handle (i.e.,  "mailto" or  "ftp"),
the URL of the page that handles the protocol, and
the name of the application.

For example, to register a web application as the default mail client, you can use the following:

<b>navigator</b>.registerProtocolHandler("mailto",
                                  "http://www.example.com?cmd=%s",
                                  "Some Mail Client");

In this example, a handler is registered for the <i>mailto</i> protocol, 
which will now point to a web-based e-mail client.

Once again, the second argument is the URL that should handle the request, and %s
represents the original request.

<h2>BOM Screen Object</h2>

The screen object as a property of window is used as an indication of client capabilities.

This object provides
information about the client's display outside the browser window, including information such as
pixel width and height.

Each browser provides different properties on the screen object.

The following table describes each of the properties.

<table>
<thead><tr><th>Property</th><th>   Description</th></tr></thead>
<tbody>
<tr><td><i>availHeight</i></td><td>   The pixel height of the screen minus system elements such as Windows (read only).</td></tr>
<tr><td><i>availLeft</i></td><td>   The first pixel from the left that is not taken up by system elements (read only).</td></tr>
<tr><td><i>availTop</i></td><td>   The first pixel from the top that is not taken up by system elements (read only).</td></tr>
<tr><td><i>availWidth</i></td><td>   The pixel width of the screen minus system elements (read only).</td></tr>
<tr><td><i>colorDepth</i></td><td>   The number of bits used to represent colors; for most systems, 32 (read only).</td></tr>
<tr><td><i>height</i></td><td>   The pixel height of the screen.</td></tr>
<tr><td><i>left</i></td><td>   The pixel distance of the current screen's left side.</td></tr>
<tr><td><i>pixelDepth</i></td><td>   The bit depth of the screen (read only).</td></tr>
<tr><td><i>top</i></td><td>   The pixel distance of the current screen's top.</td></tr>
<tr><td><i>width</i></td><td>   The pixel width of the screen.</td></tr>
<tr><td><i>orientation</i></td><td>   Returns the screen orientation as specified in the Screen Orientation API.</td></tr>
</tbody></table>

<h2>BOM History Object</h2>

The <i>window.history</i> property returns a <b>History</b> object, which you can use to perform basic operations on
the browser history.

The <i>history</i> object represents the user's navigation history since the given window was first used.

Because <i>history</i> is a property of <i>window</i>, each browser window object has its own history object.

For security reasons, it's not possible to determine the URLs that the user has visited.

We can navigate backwards and forwards through the list of
places the user has been without knowing the exact URL.

The following table describes the properties and methods that the History object defines.

<table>
<thead><tr><th>Name</th><th>   Description</th><th>   Returns</th></tr></thead>
<tbody>
<tr><td><i>back</i>()</td><td>   Goes one step back in the history</td><td>   void</td></tr>
<tr><td><i>forward</i>()</td><td>   Goes one step forward in the history</td><td>   void</td></tr>
<tr><td><i>go</i>(&lt;index>)</td><td>   Goes to a position in the history relative to the<br>   current document; positive values are forward,   <br>   and negative values are backward                 </td><td>   void</td></tr>
<tr><td>length</td><td>   Returns the number of items in the history</td><td>   number</td></tr>
<tr><td><i>pushState</i>(&lt;state>, &lt;title>,<br>    &lt;url>)                 </td><td>   Adds an entry to the browser history</td><td>   void</td></tr>
<tr><td><i>replaceState</i>(&lt;state>, &lt;title>,<br>    &lt;url>)                    </td><td>   Replaces the current entry in the browser<br>   history                                  </td><td>   void</td></tr>
<tr><td>state</td><td>   Returns the state data associated with the<br>    current document in the browser history  </td><td>   object</td></tr>
</tbody></table>
<h3>Navigation</h3>
The <i>go</i>() method navigates through the user's history in either direction, backward or forward.

This method accepts a single argument, which is an integer representing the number of pages to go 
backward or forward.

A negative number moves backward in history, similar to clicking the browser's
Back button.

A positive number moves forward, similar to clicking the browser's Forward button.

Here's an example: go back one page

<b>history</b>.go(-1);

go forward one page.

<b>history</b>.go(1);

go forward two pages.

<b>history</b>.go(2);

The <i>go</i>() method argument can also be a string, in which case the browser navigates to the first 
location in history that contains the given string.

The closest location may be either backward or forward.

If there's no entry in history matching the string, then the method does nothing, as in this example:

go to nearest demo2s.com page

<b>history</b>.go("demo2s.com");

Two shortcut methods, <i>back</i>() and <i>forward</i>(), may be used in place of <i>go</i>(). 

These mimic the browser Back and Forward buttons as follows:

go back one page.

<b>history</b>.back();

go forward one page.

<b>history</b>.forward();

The <i>history</i> object also has a property, <i>length</i>, which indicates how many items are in the history
stack.

This property reflects all items in the history stack, both those going backward and those going
forward.

For the first page loaded into a window or tab, history.length is equal to 0.

By testing for this value as shown here, we can determine if the user's start point was your page:

if (<b>history</b>.<b>length</b> == 0){
   //this is the first page in the user's window
}

The history object typically is used to create custom Back and Forward buttons and to determine if
the page is the first in the user's history.

Entries are made in the history stack whenever the page's URL changes.

This includes changes to the URL hash, thus setting location.hash causes a new entry to be inserted into the history
stack for these browsers.

This behavior is commonly used by single-page application frameworks, 
which wish to simulate Back and Forward button functionality without 
causing full page reloads upon each navigation event.

<h2>Location Object</h2>

The <i>location</i> object contains information about the current URL.

The <i>location</i> object is part of the window object and 
is accessed through the <i>window.location</i> property.

There is no public standard that applies to the location object, 
but all major browsers support it.

<h3>Method List</h3>
<table>
<thead><tr><th>Method</th><th>Description</th></tr></thead>
<tbody>
<tr><td><a href="location-assign-method.html">assign()</a></td><td>   Location assign new value Method</td></tr>
<tr><td><a href="location-reload-method.html">reload()</a></td><td> Location reload url Method</td></tr>
<tr><td><a href="location-replace-method.html">replace()</a></td><td>   Location replace url Method</td></tr>
</tbody></table>
<h3>Property List</h3>
<table>
<thead><tr><th>Property</th><th>Description</th></tr></thead>
<tbody>
<tr><td><a href="location-hash-property.html">hash</a></td><td> Location Get and Set url hash Property</td></tr>
<tr><td><a href="location-host-property.html">host</a></td><td> Location Get and Set host Property</td></tr>
<tr><td><a href="location-hostname-property.html">hostname</a></td><td>Location Get and Set host name Property</td></tr>
<tr><td><a href="location-href-property.html">href</a></td><td> Location Get and Set href URL Property</td></tr>
<tr><td><a href="location-origin-property.html">origin</a></td><td> Location Get and Set URL origin Property</td></tr>
<tr><td><a href="location-pathname-property.html">pathname</a></td><td>Location Get and Set URL path name Property</td></tr>
<tr><td><a href="location-port-property.html">port</a></td><td> Location Get and Set URL port Property</td></tr>
<tr><td><a href="location-protocol-property.html">protocol</a></td><td> Location Get and Set URL protocol Property</td></tr>
<tr><td><a href="location-search-property.html">search</a></td><td>Location Get and Set URL search part Property</td></tr>
</tbody></table>

<h2>History Object</h2>

The <i>history</i> object contains the URLs visited by the 
user within a browser window.

The <i>history</i> object is part of the window object and is 
accessed through the <i>window.history</i> property.

<h3>Property List</h3>
<table>
<thead><tr><th>Property</th><th>   Description</th></tr></thead>
<tbody><tr><td><a href="javascript-history-length-property.html">length</a></td><td>   History length Property</td></tr></tbody></table>
<h3>Method List</h3>
<table>
<thead><tr><th>Method</th><th>   Description</th></tr></thead>
<tbody>
<tr><td><a href="javascript-history-back-method.html">back()</a></td><td>  History go back Method</td></tr>
<tr><td><a href="javascript-history-forward-method.html">forward()</a></td><td>History go forward Method</td></tr>
<tr><td><a href="javascript-history-go-method.html">go()</a></td><td>   History go to a history step Method</td></tr>
</tbody></table>

<h2>Navigator Object</h2>

The navigator object contains information about the browser.

<table>
<thead><tr><th>Property</th><th>   Description</th></tr></thead>
<tbody>
<tr><td><a href="navigator-appcodename-property.html">appCodeName</a></td><td>Javascript Navigator Get appCodeName Property</td></tr>
<tr><td><a href="navigator-appname-property.html">appName</a></td><td>Javascript Navigator Get appName Property</td></tr>
<tr><td><a href="navigator-appversion-property.html">appVersion</a></td><td>  Javascript Navigator Get appVersion Property</td></tr>
<tr><td><a href="navigator-cookieenabled-property.html">cookieEnabled</a></td><td>Javascript Navigator Get cookieEnabled Property</td></tr>
<tr><td><a href="navigator-geolocation-property.html">geolocation</a></td><td>Javascript Navigator Get geolocation Property</td></tr>
<tr><td><a href="navigator-language-property.html">language</a></td><td>  Javascript Navigator Get language Property</td></tr>
<tr><td><a href="navigator-online-property.html">Navigator check if browser is on Line</a></td><td>  Javascript Navigator check if browser is on Line</td></tr>
<tr><td><a href="navigator-platform-property.html">platform</a></td><td>  Javascript Navigator Get platform Property</td></tr>
<tr><td><a href="navigator-product-property.html">product</a></td><td>Javascript Navigator Get product Property</td></tr>
<tr><td><a href="navigator-useragent-property.html">userAgent</a></td><td>Javascript Navigator Get userAgent Property</td></tr>
<tr><td><a href="navigator-javaenabled-method.html">javaEnabled()</a></td><td>  Javascript Navigator Check if java is Enabled Method</td></tr>
<tr><td><a href="navigator-taintenabled-method.html">taintEnabled()</a></td><td>  Javascript Navigator is taint Enabled Method</td></tr>
</tbody></table>

<h2>Screen Get available Height Property</h2>

<h3>Example</h3>
Get the available height of your screen:

let x = "Available Height: " + screen.availHeight;

<iframe onload="resizeIframe(this)" style="border:1px solid #f1f1f1;margin:10px 0 10px 0;background-color:#ffffff;" frameborder="0" seamless width="100%" height="350" src="javascript-screen-get-available-height-property-demo-0a9c3.htm"></iframe><br><a href="javascript-screen-get-available-height-property-demo-0a9c3.htm">Open in separate window</a><br><a type="button" data-toggle="collapse" style="padding:2px;" role="button" aria-expanded="false" aria-controls="VOT" href="#VOT">View full source code</a>

&lt;html>
&lt;body>

&lt;p>Click the button to <font color="black"><b>display</b></font> the available <font color="black"><b>height</b></font> of your screen.&lt;/p>

&lt;button <b>onclick</b>="myFunction()">Test&lt;/button>

&lt;p <b>id</b>="demo">&lt;/p>

&lt;script>
<b>function</b> myFunction() {
  let x = "Available Height: " + screen.availHeight + "px";
  <b>document</b>.getElementById("demo").innerHTML = x;
}
&lt;/script>

&lt;/body>
&lt;/html>

<script>function resizeIframe(iframe) {let h = iframe.contentWindow.document.body.scrollHeight;if (h<200){h=220;}iframe.style.height = h + 'px'; console.log(h + 'px');}</script>
<h3>Description</h3>
The <i>availHeight</i> property returns the height of the user's screen, 
in pixels, minus interface features like the Windows Taskbar.

To get the width of the screen excluding the Windows Taskbar, 
use the <i>availWidth</i> property.

<h3>Browser Compatibility</h3>
<table class="table"><tbody>
<tr><th></th>    <th><img alt="Chrome.png" src="data:image/png;base64,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"></th>    <th><img alt="Node.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAFcklEQVR42qWXy1NTdxTHfzAMiw4bu2odu7szrnRvNS8gucnNA00gN09iAoRXtDo8pFM7XbQKRlEwKo8EElBRUbFAFXx31ZX+A6Uu6uKyYqau1AVz+v1dDVAaBLzMfE7uzf3NPZ97zvndIYx9xl/ndHRH51Rde8ed+sUj1yKLdcO+NrADsO2yrcXt9wOlJ36LiF0z0fkT9+reQ4CO34pRfCTwHtfn69N+sSHjLwVsq2xpUWLOVdQ2593b8SCQ6bpf+6ZrNkoQIC7QNllHiau1VDfsJwi8acgEMhDaGx8NFgG2GZsuOPrYtfPYI/fJtofe1x1zAYIArRc4diNKjaNBSPgIwrwir3H+Y1M2uBOwT7HhhZZnlrLEU1vo6BPny+OPDy1DgDYUuBml1tUqQCJAjSPBZdznZXM2FG7OhcoAK8T/v3wqlrQ8E42tz8WZxDPbOwgQBGgzgaPXIytV4BJxLoFzCLxryYVmWsbCxpbxcAlga1k5+OnPiiIk3Q1SYAkQBGjLAhMRwn1UAbUVabUV1MQlciGCwFLreDiFedndcjVcBBhHDfsb3cX+rBRrfiK+4onzbEsAFeBtiI8GKDbkU9vxcR4IrVAlWsfCfGBf1Y/66r6If1UMGOPB0+/aVZ1yLsSmbNT6uzaBprGQWgEusTIPqEJTVq0CRILkvGBd2Pfzvl2AMR5qLlUJ1akqxZ9xUvNjq2aBBjx1dEhenYeRj/OAKgQGDpGhW6/oTusEwBgP3isuoeayS4EIRe9ImgXiWQgMy6iCvHZrUj0+xbMVhJyKHgJ6LsCDd9ApeAecCkSIV6HpoVW7QFqmw4PeD60Y/rAralJOQj7OOoEhCAxBYNBJEKHDk3bNAofTXgoNVKsSvAqRwRqqTJYXFpDTDgEo3mEHQYR8GQc1zlsp8VybQGDATaErHooOyuTud5Cx28D7X0BgxC4ARUZiiEDCQbU3pQ8VePq5AjL5MXBezJX/0iH0vpIqzpiovMdIpm6DYuzWC4AxHuSsJMhZCIzaCSKkiuCzYdZG32kU8Fx0YNvZVAFzskJtA0QUiAiAMR58Y5Lgy0mKnJMIIsRFqi6L5Boqp8QjhyYBNwTs50WynTOTFXARS7JCMSfLBcAYD76rNsE3blMAQYZqRm1Uec5Ihh4dRW5bIeDWLMCTS71cxMKPFYgIgDEefNetgu+aVYEIcZyXK9Vp1Z3SkZQy0ZG5g5oF8KCqgOO8ley9oiL1WgTAGA/+G6Lgn7AqgKpzIpUnDfntgqnVUfi6pFmADyCXcGEeMBMKRATAGA/+WxC4KSoQIdsl00ryfBWsfajCrIc6NQhUJk3qFsTT08E+u1LVJwmAMR78kxYhMGlR3LlKMvbo/yOQJ4AB1SrA78MrwQXc/U4BMMZD8K5Z8E2aFUu/kfSndAUFzL2owj0vdT2IaBLgYBCVmlSVABjjITxt2eXKmBZ4vwslV1sB5LREJ7S04OO98O5ZwPB/s7ILEn9IxaakPoaLf20koJYvaaTEbR99PxvTIsBzxPb/8m0xYIyHPKjAbly8CJYKVgHt8QygCjOowK/bFljCEKZwH56D5WFrTzh4+ZTou3UGHE+Dt+slTD0GapqQqWvrAm8hMG0+W27AA5YAtha2/os1lCFhCLwAy6tVOEBVKSu1T0Wp4+4nBZbx388LT8oZcvZZywArBNvoQh6IfI3EP4C/V19Oeqob81LnxgKvoxn5ZHDQsxOwT8E2W8AxntEVoS17kDwD/uGzYL9gwe/C6HqBN81joUw8G9wDgSLANoNtZVEeVKMUAhYwD96F0568wHv8LnjYeq1WbB4PlQK2Vdh2FueByA7d6QNttvPmxSMTtYuoRDsEvgRsu/wLzSrXEyKHba8AAAAASUVORK5CYII="></th>    <th><img alt="Firefox.png" src="data:image/png;base64,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"></th>    <th><img alt="Safari.png" src="data:image/png;base64,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"></th>    <th><img alt="Edge.png" src="data:image/png;base64,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"></th>    <th><img alt="Opera.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAFUklEQVR42tWXaWwUZRzGd46dnd3uTveg2z265+zO7G63e3XdttDaiy6UcLSoVRKgqUpQJMYGQf1AiAmGQ2JiQsInTTXBIJp4ICgB6okkoFyFkhpoCVA5mkJpS48t9PXdtuC2M7NTQD/wJr/MZOf/PP9n3rnelUietOHNVmuXRF2lb8XD9Ztri17fAlkXDy+vi9DFrD5T9f80zaKU78bDq46snPv78NrakburqsFIQyUYWVo2TsNscPe1eWBgbe1g88vxA2+W+pc4NUrpYzfWK2RIYwG79PKr1Z0jy8pBYlGBODWFY4FaV8xprQ/YKx+5uU1JynZW53+cWF4xOjw/BlLpqwiC035HzyfW7JNNFv3x47n2m71lgUk1wwtiYOjFqrvbnvavNypk6EM1zyYJ/Kuq8JfDi2eBoeroJHpK/KONWqoJk0issJSEJN3NKzKV22/OzB2dWp+oKwEfzvRuzZJJkWkH2BKi3xtaWASG4vljDE5sB2ZHwA7TjB9hQ/lUDXQnNus13wxUhsfqB1O08ERGGz05K6bVvFxHxfrnFySSRlPpjnlG/QReJaS14FjsRpS9l6oZnNh2zYv1FqiVzrTNVRiK7MlnDg6Uh8CdMi6HGcsVKc/Z3x9wZoi9TtM5Pu1ARRh8GqQ/SxsgqpSH+8tC9/pLAoCPDwy6r8VmcMMMdVN/Mb++pzSUCGaQtKB4ozV7W9+sAOidmcfhdpEfrFKrNooFeEGpWNNTmMvr0QeDrc/Rb+AVyhEEbfY5Wm4X+AEfN6NesChD/pJYgBJS9kx3xAOEfPZ57EcpFOU+EZkoqr0WYhO3oj7AR1eIBcWkbL5YAJ9UWnwjwAAhn84QO6TF0EyOME9GFHQFWdAd9o4Tmcy1PAaECGmJWAALhvmv5rrHdfd9Uvy6gh4QkhFRjrBCTtbeyGNBV8DLy98+N3DjeFQsgBZF6U6PS9DnOuwRV8hrOMK5Cnn9VR8Drud6wHW/59/tBJdZF6BxPDiNANZLDD2uT/WY2E/2WKBQLOcIZ5Nk/RXWDa56WV4uuenkDEwrwEWXU9An2WOunKznCAsJouaiiwadLMNL8hiL4/liAbLgJeignWl9ZsFe3JsHRSN/2RzwTBleOmgXiBCE6E1ox3B/u5MW9Gmz2YENw8IcIQ6fxMNGc99FGqbkod3pBmUycqFYgICUKLngcAEhn18N5l5CIqH43uPoVkrzc7sz2YzLBQcDnlMoV4oFqCTldecdbiDks4lSN+NjH0+eEZfKGlstNDhvZ3hZQ2m2igVoUFLvCOnPWpygSipbLSiGqwvjPp2xp82WvFZctusM+8UCbNLqP2+zsbz6b3WGbthDn9bgWUK+7ZSJBucsDIcjZvoWfMwyhLQKBCEOGB1X+LQnTU6wiCBFP2YSeINkfUTN6DhjhlOWM5lzFg9YrKDqhLRlZEY8WTNV12J2gx0qXRtcS2intSqyo9ic7zWmwdMmBqTSYmbBXqO7xY4TCs4KGsOlXxjoI8maqbo9GmN/DoqVPsy6FIlg0pX7NebESQOcvhTOmn1gt8nzXZRUme4X+2UZWU1GZlcrPJZaewKyT20a9GP4MonQnZ9moLko3rCbyr79h94NTmQzD2gxekGHPTr0kzV8qtkaOtFuf2rgjMk3qeaY3gV2qvTdbhR//lGaP5gJDYLE1pHUb80a6+ixLDf4U8+k5SisOai23HtDpjpESZCg5D8aCic8k9WE6uBuleHOIbUV/KJ1gMM6eozkfvK3XSpD3yuE8gcrgtVK0ixeH2dI4RvTbkOwxUUY8XYcJ99PUgj3LQhWg4z/WZFKnqTxDxwbxiury+q5AAAAAElFTkSuQmCC"></th>  </tr>
<tr><td><code>availHeight

</code></td>    <td>Yes</td>    <td>Yes</td>    <td>Yes</td>    <td>Yes</td>    <td>Yes</td>    <td>Yes</td>  </tr>
</tbody></table>
<h3>Syntax</h3>

let a = screen.availHeight;

<h3>Return Value</h3>
A Number, representing the height of the user's screen, in pixels.

<h3>More Examples</h3>
All screen properties in one example:

let txt = "";
txt += "&lt;p>Total width/height: " + screen.width + "*" + 
        screen.height + "&lt;/p>";
txt += "&lt;p>Available width/height: " + screen.availWidth + "*" + 
      screen.availHeight + "&lt;/p>";
txt += "&lt;p>Color depth: " + screen.colorDepth + "&lt;/p>";
txt += "&lt;p>Color resolution: " + screen.pixelDepth + "&lt;/p>";

<iframe onload="resizeIframe(this)" style="border:1px solid #f1f1f1;margin:10px 0 10px 0;background-color:#ffffff;" frameborder="0" seamless width="100%" height="350" src="javascript-screen-get-available-height-property-demo-a63a8.htm"></iframe><br><a href="javascript-screen-get-available-height-property-demo-a63a8.htm">Open in separate window</a><br><a type="button" data-toggle="collapse" style="padding:2px;" role="button" aria-expanded="false" aria-controls="UMX" href="#UMX">View full source code</a>

&lt;html>
&lt;body>

&lt;h3>Your Screen:&lt;/h3>

&lt;div <b>id</b>="demo">&lt;/div>

&lt;script>
let txt = "";&lt;!-- w   w w   .  d   e m  o  2 s    .c  o    m-->
txt += "&lt;p>Total width/height: " + screen.<font color="black"><b>width</b></font> + "*" + 
          screen.<font color="black"><b>height</b></font> + "&lt;/p>";
txt += "&lt;p>Available width/height: " + screen.availWidth + "*" + 
          screen.availHeight + "&lt;/p>";
txt += "&lt;p>Color depth: " + screen.colorDepth + "&lt;/p>";
txt += "&lt;p>Color resolution: " + screen.pixelDepth + "&lt;/p>";

<b>document</b>.getElementById("demo").innerHTML = txt;
&lt;/script>

&lt;/body>
&lt;/html>

<script>function resizeIframe(iframe) {let h = iframe.contentWindow.document.body.scrollHeight;if (h<200){h=220;}iframe.style.height = h + 'px'; console.log(h + 'px');}</script>
<h3>Property List </h3>
<table>
<thead><tr><th>Property</th><th>  Description</th></tr></thead>
<tbody>
<tr><td><a href="screen-availwidth-property.html">available Width</a></td><td> Screen Get available Width Property</td></tr>
<tr><td><a href="screen-colordepth-property.html">color Depth</a></td><td> Screen Get color Depth Property</td></tr>
<tr><td><a href="screen-height-property.html">height</a></td><td>   Screen Get height Property</td></tr>
<tr><td><a href="screen-pixeldepth-property.html">pixel Depth</a></td><td> Screen Get pixel Depth Property</td></tr>
<tr><td><a href="screen-width-property.html">width</a></td><td> Screen Get width Property</td></tr>
</tbody></table>

<h2>Window Object Reference</h2>

The window object represents an open window in a browser.

If a document contain frames (&lt;iframe> tags), the browser creates 
one window object for the HTML document, and one additional window 
object for each frame.

Note: There is no public standard that applies to the Window object, 
but all major browsers support it.

<h3>Method List</h3>
<table>
<thead><tr><th>Method</th><th>   Description</th></tr></thead>
<tbody>
<tr><td><a href="javascript-window-alert-method.html">alert()</a></td><td> displays an alert box with a specified message and an OK button</td></tr>
<tr><td><a href="javascript-window-atob-method.html">atob()</a></td><td> decodes a base-64 encoded string</td></tr>
<tr><td><a href="javascript-window-blur-method.html">blur()</a></td><td>  removes focus from the current window</td></tr>
<tr><td><a href="javascript-window-btoa-method.html">btoa()</a></td><td>encodes a string in base-64</td></tr>
<tr><td><a href="javascript-window-clearinterval-method.html">clearInterval()</a></td><td>clears a timer set with the <i>setInterval</i> method</td></tr>
<tr><td><a href="javascript-window-cleartimeout-method.html">clearTimeout()</a></td><td>clears a timer set with the <i>setTimeout</i> method</td></tr>
<tr><td><a href="javascript-window-close-method.html">close()</a></td><td> closes the current window</td></tr>
<tr><td><a href="javascript-window-confirm-method.html">confirm()</a></td><td>  displays a dialog box with a specified message</td></tr>
<tr><td><a href="javascript-window-focus-method.html">focus()</a></td><td>  sets focus to the current window</td></tr>
<tr><td><a href="javascript-window-matchmedia-method.html">matchMedia()</a></td><td>match media query</td></tr>
<tr><td><a href="javascript-window-moveby-method.html">moveBy()</a></td><td>   moves a window relative to its current coordinates</td></tr>
<tr><td><a href="javascript-window-moveto-method.html">moveTo()</a></td><td>  moves a window's left and top edge to the specified coordinates</td></tr>
<tr><td><a href="javascript-window-open-method.html">open()</a></td><td> opens a new browser window</td></tr>
<tr><td><a href="javascript-window-print-method.html">print()</a></td><td> prints the contents of the current window</td></tr>
<tr><td><a href="javascript-window-prompt-method.html">prompt()</a></td><td>displays a dialog box that prompts the user for input</td></tr>
<tr><td><a href="javascript-window-resizeby-method.html">resizeBy()</a></td><td>   resizes a window by the specified amount</td></tr>
<tr><td><a href="javascript-window-resizeto-method.html">resizeTo()</a></td><td> resizes a window to the specified width and height</td></tr>
<tr><td><a href="javascript-window-scrollby-method.html">scrollBy()</a></td><td> scrolls the document by the specified number of pixels</td></tr>
<tr><td><a href="javascript-window-scrollto-method.html">scrollTo()</a></td><td>  scrolls the document to the specified coordinates</td></tr>
<tr><td><a href="javascript-window-setinterval-method.html">setInterval()</a></td><td> calls a function at specified intervals in milliseconds</td></tr>
<tr><td><a href="javascript-window-settimeout-method.html">setTimeout()</a></td><td>calls a function after a specified number of milliseconds</td></tr>
<tr><td><a href="javascript-window-stop-method.html">stop()</a></td><td>   stops window loading</td></tr>
</tbody></table>
<h3>Property List</h3>
<table>
<thead><tr><th>Property</th><th>  Description</th></tr></thead>
<tbody>
<tr><td><a href="javascript-window-closed-property.html">closed</a></td><td>checks whether a window is closed</td></tr>
<tr><td><a href="javascript-window-defaultstatus-property.html">defaultStatus</a></td><td>   Get and Set default Status text</td></tr>
<tr><td><a href="javascript-window-frameelement-property.html">frameElement</a></td><td>  returns the &lt;iframe> element where current window is inserted</td></tr>
<tr><td><a href="javascript-window-frames-property.html">frames</a></td><td>  get all iframe elements</td></tr>
<tr><td><a href="javascript-window-innerwidth-and-innerheight-property.html">innerWidth and innerHeight</a></td><td>   innerWidth and innerHeight get client size</td></tr>
<tr><td><a href="javascript-window-length-property.html">length</a></td><td>get the number of iframe elements</td></tr>
<tr><td><a href="javascript-window-localstorage-property.html">localStorage</a></td><td> Get local Storage Property</td></tr>
<tr><td><a href="javascript-window-name-property.html">name</a></td><td>  Get and Set name Property</td></tr>
<tr><td><a href="javascript-window-opener-property.html">opener</a></td><td>   Get the window that created current window</td></tr>
<tr><td><a href="javascript-window-outerwidth-and-outerheight-property.html">outerWidth and outerHeight</a></td><td> Get size</td></tr>
<tr><td><a href="javascript-window-pagexoffset-and-pageyoffset-property.html">pageXOffset and pageYOffset</a></td><td> Get the scrolled offset</td></tr>
<tr><td><a href="javascript-window-parent-property.html">parent</a></td><td> get the parent window of the current window.</td></tr>
<tr><td><a href="javascript-window-screenleft-and-screentop-property.html">screenLeft and screenTop</a></td><td>   Get coordinates of the window relative to the screen</td></tr>
<tr><td><a href="javascript-window-screenleft-and-screentop-property.html">screenX and screenY</a></td><td>   Get coordinates of the window relative to the screen.</td></tr>
<tr><td><a href="javascript-window-self-property.html">self</a></td><td> returns the current window</td></tr>
<tr><td><a href="javascript-window-sessionstorage-property.html">sessionStorage</a></td><td> Get session Storage Property</td></tr>
<tr><td><a href="javascript-window-status-property.html">status</a></td><td>  Get and Set status text</td></tr>
<tr><td><a href="javascript-window-top-property.html">top</a></td><td>Get the topmost browser window of the current window</td></tr>
</tbody></table>
<ul style="font-size:19px;">Get coordinates of the window relative to the screen. (2)

<h2>DOM Create Dynamic Scripts</h2>

The &lt;script> element is used to insert JavaScript code into the page, either by using the src 
attribute to include an external file or by including text inside the element itself.

Dynamic scripts are those 
that don't exist when the page is loaded but are included later by using the DOM.

There are two ways to do this: 

pulling in an external file or
inserting text directly.

<h3>External</h3>
Dynamically loading an external JavaScript file works as you would expect.

Consider the following &lt;script> element:

&lt;script src="foo.js">&lt;/script>

The DOM code to create this node is as follows:

let script = <b>document</b>.createElement("script");
script.src = "foo.js";
<b>document</b>.body.appendChild(script);

The DOM code mirrors the HTML code that it represents.

The external file is not downloaded until the &lt;script> element is added to the page on the last line.

The element could be added to the &lt;head> element as well, though this has the 
same effect.

This process can be generalized into the following function:

function loadScript(url) {
  let script = <b>document</b>.createElement("script");
  script.src = url;
  <b>document</b>.body.appendChild(script);
}

This function can now be used to load external JavaScript files via the following call:

loadScript("client.js");

Once loaded, the script is fully available to the rest of the page.

There is no standard way to handle when the script has been fully loaded.

<h3>Inline</h3>
The other way to specify JavaScript code is inline, as in this example:

&lt;script>
function sayHi() {
    console.log("hi");
}
&lt;/script>

Using the DOM, it would be logical for the following to work:

let script = <b>document</b>.createElement("script");
script.appendChild(<b>document</b>.createTextNode(
             "function sayHi(){console.log('hi');}"));
<b>document</b>.body.appendChild(script);

This works in Firefox, Safari, Chrome, and Opera.

A property called <i>text</i> exists on all &lt;script> elements that can be used
specifically to assign JavaScript code to, as in the following example:

var script = <b>document</b>.createElement("script");
script.text = "function sayHi(){console.log('hi');}";
<b>document</b>.body.appendChild(script);

This updated code works in Internet Explorer, Firefox, Opera, and Safari 3 and later.

This can be generalized into the following function:

function loadScriptString(code){
  var script = <b>document</b>.createElement("script");
  script.type = "text/javascript";
  <b>try</b> {
    script.appendChild(<b>document</b>.createTextNode(code));
  } <b>catch</b> (ex){
    script.text = code;
  }
  <b>document</b>.body.appendChild(script);
}

The function is called as follows:

loadScriptString("function sayHi(){console.log('hi');}");

Code loaded in this manner is executed in the global scope and is available immediately after
the script finishes executing.

<b>Note:</b> all &lt;script> elements created with <i>innerHTML</i> will never execute.

<h2>DOM Create Dynamic Styles</h2>

CSS styles are included in HTML pages using one of two elements.

The &lt;link> element is used to
include CSS from an external file, whereas the &lt;style> element is used to specify inline styles.

The dynamic styles don't exist on the page when it is loaded initially and they are
added after the page has been loaded.

<h3>Link Element</h3>
Consider this typical &lt;link> element:

&lt;link rel="stylesheet" type="text/css" href="styles.css">

This element can just as easily be created using the following DOM code:

let link = <b>document</b>.createElement("link");
link.rel = "stylesheet";
link.type = "text/css";
link.href = "styles.css";
let head = <b>document</b>.getElementsByTagName("head")[0];
head.appendChild(link);

This code works in all major browsers without any issue.

Note that &lt;link> elements should be added
to the &lt;head> instead of the body for this to work properly in all browsers.

The technique can be generalized into the following function:

function loadStyles(url){
  let link = <b>document</b>.createElement("link");
  link.rel = "stylesheet";
  link.type = "text/css";
  link.href = url;
  let head = <b>document</b>.getElementsByTagName("head")[0];
  head.appendChild(link);
}

The <i>loadStyles</i>() function can then be called like this:

loadStyles("styles.css");

Loading styles via an external file is asynchronous, so the styles will load out of order with the JavaScript
code being executed.

Typically, it's not necessary to know when the styles have been fully loaded.

<h3>Inline</h3>
The other way to define styles is using the &lt;style> element and including inline CSS, such as this:

&lt;style type="text/css">
body {
   background-color: red;
}
&lt;/style>

The following DOM code should work:

let style = <b>document</b>.createElement("style");
style.type = "text/css";
style.appendChild(<b>document</b>.createTextNode("body{background-color:red}"));
let head = <b>document</b>.getElementsByTagName("head")[0];
head.appendChild(style);

This code works in Firefox, Safari, Chrome, and Opera but not in Internet Explorer.

The workaround for Internet Explorer is to access the element's <i>styleSheet</i>
property, which in turn has a property called <i>cssText</i> that may be set to CSS code as this code
sample shows:

let style = <b>document</b>.createElement("style");
style.type = "text/css";
<b>try</b>{
  style.appendChild(<b>document</b>.createTextNode("body{background-color:red}"));
} <b>catch</b> (ex){
  style.styleSheet.cssText = "body{background-color:red}";
}
let head = <b>document</b>.getElementsByTagName("head")[0];
head.appendChild(style);

This new code uses a try-catch statement
to catch the error that Internet Explorer throws and then responds by using the 
Internet Explorer-specific way of setting styles.

The generic solution is as follows:

function loadStyleString(css){
  let style = <b>document</b>.createElement("style");
  style.type = "text/css";
  <b>try</b>{
    style.appendChild(<b>document</b>.createTextNode(css));
  } <b>catch</b> (ex){
    style.styleSheet.cssText = css;
  }
  let head = <b>document</b>.getElementsByTagName("head")[0];
  head.appendChild(style);
}

The function can be called as follows:

loadStyleString("body{background-color:red}");

Styles specified in this way are added to the page instantly, so changes should be seen immediately.

<h2>DOM Manipulating Tables</h2>

To facilitate building tables, the HTML DOM
adds several properties and methods to the &lt;table>, &lt;tbody>, and &lt;tr> elements.

The &lt;table> element adds the following:

<table>
<thead><tr><th>Item</th><th>   Meaning</th></tr></thead>
<tbody>
<tr><td>caption</td><td>   Pointer to the &lt;caption> element (if it exists).</td></tr>
<tr><td><i>tBodies</i></td><td>   An HTMLCollection of &lt;tbody> elements.</td></tr>
<tr><td><i>tFoot</i></td><td>   Pointer to the &lt;tfoot> element (if it exists).</td></tr>
<tr><td><i>tHead</i></td><td>   Pointer to the &lt;<i>thead</i>> element (if it exists).</td></tr>
<tr><td>rows</td><td>   An HTMLCollection of all rows in the table.</td></tr>
<tr><td><i>createTHead</i>()</td><td>   Creates a &lt;<i>thead</i>> element, places it into the table, and returns a reference.</td></tr>
<tr><td><i>createTFoot</i>()</td><td>   Creates a &lt;<i>tfoot</i>> element, places it into the table, and returns a reference.</td></tr>
<tr><td><i>createCaption</i>()</td><td>   Creates a &lt;caption> element, places it into the table, and returns a reference.</td></tr>
<tr><td><i>deleteTHead</i>()</td><td>   Deletes the &lt;<i>thead</i>> element.</td></tr>
<tr><td><i>deleteTFoot</i>()</td><td>   Deletes the &lt;<i>tfoot</i>> element.</td></tr>
<tr><td><i>deleteCaption</i>()</td><td>   Deletes the &lt;caption> element.</td></tr>
<tr><td><i>deleteRow</i>(pos)</td><td>   Deletes the row in the given position.</td></tr>
<tr><td><i>insertRow</i>(pos)</td><td>   Inserts a row in the given position in the rows collection.</td></tr>
</tbody></table>
The &lt;tbody> element adds the following:

<table>
<thead><tr><th>Item</th><th>   Meaning</th></tr></thead>
<tbody>
<tr><td>rows</td><td>   An HTMLCollection of rows in the &lt;tbody> element.</td></tr>
<tr><td><i>deleteRow</i>(pos)</td><td>   Deletes the row in the given position.</td></tr>
<tr><td><i>insertRow</i>(pos)</td><td>   Inserts a row in the given position in the rows collection and returns a reference to the new row.</td></tr>
</tbody></table>
The &lt;tr> element adds the following:

<table>
<thead><tr><th>Item</th><th>   Meaning</th></tr></thead>
<tbody>
<tr><td>cells</td><td>   An HTMLCollection of cells in the &lt;tr> element.</td></tr>
<tr><td><i>deleteCell</i>(pos)</td><td>   Deletes the cell in the given position.</td></tr>
<tr><td><i>insertCell</i>(pos)</td><td>   Inserts a cell in the given position in the cells collection and returns a reference to the new cell.</td></tr>
</tbody></table>
Suppose you want to create the following HTML table using the DOM:

&lt;table border="1" width="100%">
 &lt;tbody>
   &lt;tr>
     &lt;td>Cell 1,1&lt;/td>
     &lt;td>Cell 2,1&lt;/td>
   &lt;/tr>
   &lt;tr>
     &lt;td>Cell 1,2&lt;/td>
     &lt;td>Cell 2,2&lt;/td>
   &lt;/tr>
 &lt;/tbody>
&lt;/table>

For example, the following code shows how to create above table:

// create the table
let table = <b>document</b>.createElement("table");
table.border = 1;/*  w  ww    . d   e m   o 2 s    .c  o   m */
table.width = "100%";

// create the tbody
let tbody = <b>document</b>.createElement("tbody");
table.appendChild(tbody);

// create the first row
tbody.insertRow(0);
tbody.rows[0].insertCell(0);
tbody.rows[0].cells[0].appendChild(<b>document</b>.createTextNode("Cell 1,1"));
tbody.rows[0].insertCell(1);
tbody.rows[0].cells[1].appendChild(<b>document</b>.createTextNode("Cell 2,1"));

// create the second row
tbody.insertRow(1);
tbody.rows[1].insertCell(0);
tbody.rows[1].cells[0].appendChild(<b>document</b>.createTextNode("Cell 1,2"));
tbody.rows[1].insertCell(1);
tbody.rows[1].cells[1].appendChild(<b>document</b>.createTextNode("Cell 2,2"));

// add the table to the document body
<b>document</b>.body.appendChild(table);

To create the first row, the <i>insertRow</i>() method is called on the &lt;tbody> element with
an argument of 0, which indicates the position in which the row should be placed.

After that point,
the row can be referenced by tbody.rows[0] because it is automatically created and added into the
&lt;tbody> element in position 0.

Creating a cell is done by calling <i>insertCell</i>() on the &lt;tr> element and passing in 
the position in which the cell should be placed.

The cell can then be referenced by tbody.rows[0].cells[0] because the cell has been created and inserted into the row in position 0.

<h2>DOM Mutation Observers Introduction</h2>

The <b>MutationObserver</b> API allows you to
asynchronously execute a callback when the DOM is modified.

With a <b>MutationObserver</b>, you are
able to observe an entire document, a DOM subtree, or just a single element.

You can observe changes to element attributes, child nodes, text, or any combination of the three.

<h3>Basic usage</h3>
A MutationObserver instance is created by calling the MutationObserver constructor and passing a
callback function:

let observer = new MutationObserver(() => console.log('DOM was mutated!'));

To link this observer with the DOM, the <i>observe</i>() method is used.

This method accepts two required arguments: 

the target DOM node which is observed for changes, and
the <b>MutationObserverInit</b> object.

The <b>MutationObserverInit</b> object is used to control what changes the observer should watch for.

It takes the form of a dictionary of key/value configuration options.

For example, the following code
creates an observer and configures it to watch for attribute changes on the body element:

let observer = new MutationObserver(() => 
                 console.log('&lt;body> attributes changed'));

observer.observe(<b>document</b>.body, { attributes: true });

At this point, any attribute changes to the &lt;body> element will be detected by the <b>MutationObserver</b>
instance, and the callback will asynchronously execute.

Modifications to children or other non-attribute DOM mutations will not schedule a callback.

This behavior is demonstrated here:

let observer = new MutationObserver(() => 
                 console.log('&lt;body> attributes changed'));

observer.observe(<b>document</b>.body, { attributes: true });

<b>document</b>.body.className = 'foo';
console.log('Changed body class');

Output:

Note that the callback console.log executes second, indicating that the callback does not 
synchronously execute with the actual DOM mutation.

<h2>DOM Working with Callbacks and MutationRecord</h2>

Each callback is provided with an array of <b>MutationRecord</b> instances.

Each instance contains information about what kind of mutation occurred and what part of the DOM was affected.

The MutationRecord array for a single attribute mutation is shown here:

let observer = new MutationObserver(
     (mutationRecords) => console.log(mutationRecords));

observer.observe(<b>document</b>.body, { attributes: true });

<b>document</b>.body.setAttribute('foo', 'bar');

Output:

A similar mutation involving a namespace is shown here:

let observer = new MutationObserver(
    (mutationRecords) => console.log(mutationRecords));

observer.observe(<b>document</b>.body, { attributes: true });

<b>document</b>.body.setAttributeNS('baz', 'foo', 'bar');

Output:

Sequential modifications will generate multiple <b>MutationRecord</b> instances, 
and the next callback invocation will be passed all the pending instances in the 
order they were enqueued:

let observer = new MutationObserver(
    (mutationRecords) => console.log(mutationRecords));

observer.observe(<b>document</b>.body, { attributes: true });

<b>document</b>.body.className = 'foo';
<b>document</b>.body.className = 'bar';
<b>document</b>.body.className = 'baz';

Output:

A MutationRecord instance will have the following properties:

<table>
<thead><tr><th>   Key</th><th>   Value</th></tr></thead>
<tbody>
<tr><td>   target</td><td>   The node that was affected by the mutation.</td></tr>
<tr><td>   type</td><td>   A string indicating what type of mutation occurred.  <br>   Can be "attributes", "characterData", or "childList".</td></tr>
<tr><td>   oldValue</td><td>   When enabled in the MutationObserverInit object, attributes or characterData mutations will set this field to the value that was replaced.<br>   This value is only provided when <i>attributeOldValue</i> or <i>characterDataOldValue</i> is true, otherwise this value is null.                    <br>   A childList mutation will always set this field to  null.                                                                                 </td></tr>
<tr><td>   <i>attributeName</i></td><td>     For attributes mutations, the string name of the attribute which was modified.<br>   For all other mutations, this field is set to null.                             </td></tr>
<tr><td>   <i>attributeNamespace</i></td><td>     For attributes mutations which make use of namespaces, the string namespace of the attribute which was modified.<br>   For all other mutations, this field is set to null.                                                               </td></tr>
<tr><td>   <i>addedNodes</i></td><td>     For childList mutations, returns a NodeList of nodes added in the mutation.<br>   Defaults to an empty NodeList.                                               </td></tr>
<tr><td>   <i>removedNodes</i></td><td>     For childList mutations, returns a NodeList of nodes removed in the mutation.<br>   Defaults to an empty NodeList.                                                 </td></tr>
<tr><td>   <i>previousSibling</i></td><td>     For childList mutations, returns the previous sibling Node of the mutated node.<br>   Defaults to null.                                                                </td></tr>
<tr><td>   <i>nextSibling</i></td><td>     For childList mutations, returns the next sibling Node of the mutated node.<br>   Defaults to null.                                                            </td></tr>
</tbody></table>
The second argument to the callback is the <b>MutationObserver</b> instance that 
detected the mutation, demonstrated here:

let observer = new MutationObserver(
    (mutationRecords, mutationObserver) => 
              console.log(mutationRecords, mutationObserver));

observer.observe(<b>document</b>.body, { attributes: true });

<b>document</b>.body.className = 'foo';

Output:



<h2>DOM MutationObserver disconnect() method</h2>

By default, a MutationObserver callback will execute for every DOM mutation in its designated
purview until the element is garbage collected.

To terminate callback execution early, use the <i>disconnect</i>() method.

This example demonstrates how invoking <i>disconnect</i>() synchronously will halt 
callbacks.

It will discard any pending asynchronous callbacks, even if they were
from a DOM mutation during the observation window:

let observer = new MutationObserver(() => 
               console.log('&lt;body> attributes changed'));
observer.observe(<b>document</b>.body, { attributes: true });
<b>document</b>.body.className = 'foo';
observer.disconnect();
<b>document</b>.body.className = 'bar';

To allow for these queued callbacks to execute before invoking <i>disconnect</i>(), a <i>setTimeout</i> could
be employed to allow for pending callbacks to execute:

let observer = new MutationObserver(() =>
             console.log('&lt;body> attributes changed'));
observer.observe(<b>document</b>.body, { attributes: true });
<b>document</b>.body.className = 'foo';
<b>setTimeout</b>(() => {
  observer.disconnect();
  <b>document</b>.body.className = 'bar';
}, 0);

Output:



<h2>DOM Register a MutationObserver to many targets</h2>

A <b>MutationObserver</b> can be associated with many different target elements by calling <i>observe</i>()
multiple times.

The target property on the MutationRecord can identify which element was subject
to that particular mutation.

This behavior is demonstrated here:

let observer = new MutationObserver(
                 (mutationRecords) => console.log(mutationRecords.map((x) =>
x.target)));

// Append two children to body
let childA = <b>document</b>.createElement('div'),
    childB = <b>document</b>.createElement('span');
<b>document</b>.body.appendChild(childA);
<b>document</b>.body.appendChild(childB);

// Observe both children
observer.observe(childA, { attributes: true });
observer.observe(childB, { attributes: true });

// Perform mutation on each child
childA.setAttribute('foo', 'bar');
childB.setAttribute('foo', 'bar');

Output:

The <i>disconnect</i>() method will disconnect all observed nodes:

let observer = new MutationObserver(
                 (mutationRecords) => console.log(mutationRecords.map((x) =>
x.target)));

// Append two children to body
let childA = <b>document</b>.createElement('div'),
    childB = <b>document</b>.createElement('span');
<b>document</b>.body.appendChild(childA);
<b>document</b>.body.appendChild(childB);

// Observe both children
observer.observe(childA, { attributes: true });
observer.observe(childB, { attributes: true });

observer.disconnect();

// Perform mutation on each child
childA.setAttribute('foo', 'bar');
childB.setAttribute('foo', 'bar');

<h2>DOM Reusing a MutationObserver</h2>

After calling <i>disconnect</i>() from MutationObserver, we can 
reattach the same instance to a node.

The following example demonstrates this behavior by disconnecting and then
reconnecting in two consecutive async blocks:

let observer = new MutationObserver(() => 
               console.log('&lt;body> attributes changed'));

observer.observe(<b>document</b>.body, { attributes: true });
// This will register as a mutation
<b>document</b>.body.setAttribute('foo', 'bar');

<b>setTimeout</b>(() => {//   w w   w   .d   e  m  o 2  s   .   co  m  
  observer.disconnect();

   // This will not register as a mutation
   <b>document</b>.body.setAttribute('bar', 'baz');
}, 0);

<b>setTimeout</b>(() => {
 // Reattach
 observer.observe(<b>document</b>.body, { attributes: true });

 // This will register as a mutation
 <b>document</b>.body.setAttribute('baz', 'qux');
}, 0);

Output:



<h2>DOM Controlling the Observer scope with MutationObserverInit</h2>

The <b>MutationObserverInit</b> object controls which elements the observer 
should care about, and what kinds of changes it should care about.

The observer can
watch for attribute changes, text changes, or child node changes.

The following are the properties in the <b>MutationObserverInit</b> object:

<table>
<thead><tr><th>   Key</th><th>   Type</th><th>   Value</th></tr></thead>
<tbody>
<tr><td>   subtree<br></td><td>   Boolean<br></td><td>   Indicating if the target element's node subtree should be watched in addition to the target element.<br>   When false, only the target element will be observed for designated mutations.                      <br>   When true, the target element and its entire node subtree will be watched for designated mutations. <br>   Defaults to false.                                                                                  </td></tr>
<tr><td>   attributes</td><td>   Boolean</td><td>   Indicating if modifications to node attributes should register as a mutation.<br>   Defaults to false.                                                           </td></tr>
<tr><td>   <i>attributeFilter</i></td><td>   Array of string values</td><td>     Indicating which specific attributes should be observed for mutations.    <br>   Setting this value to true will also coerce the value of attributes to true.<br>     Defaults to observing all attributes.                                     </td></tr>
<tr><td><i>attributeOldValue</i></td><td>   Boolean</td><td>    Indicating if the character data prior to mutation should be recorded in the MutationRecord.<br>   Setting this value to an array will also coerce the value of attributes to true.             <br>    Defaults to false.                                                                          </td></tr>
<tr><td><i>characterData</i></td><td>   Boolean</td><td>    Indicating if modifications to character data should register as a mutation.<br>   Defaults to false.                                                           </td></tr>
<tr><td><i>characterDataOldValue</i></td><td>   Boolean</td><td>     Indicating if the character data prior to mutation should be recorded in the MutationRecord.<br>   Setting this value to true will also coerce the value of characterData to true.               <br>   Defaults to false.                                                                            </td></tr>
<tr><td><i>childList</i></td><td>   Boolean</td><td>     Indicating if modifications to the target node's child nodes should register as a mutation.<br>   Defaults to false.                                                                           </td></tr>
</tbody></table>
When calling <i>observe</i>(), the <b>MutationObserverInit</b> object must specify
at least one of <i>attributes</i>, <i>characterData</i>, or <i>childList</i> to be true either
explicitly or implicitly via an associated property such as <i>attributeOldValue</i>.

Otherwise, an error will be thrown since there is no mutation that will trigger a
callback to be invoked.

<h2>DOM Observing attribute mutations via MutationObserver</h2>

A <b>MutationObserver</b> can monitor changes 
when a node attribute is added, removed, or changed.

Registering a callback is accomplished by setting the attributes property inside the 
<b>MutationObserverInit</b> object to true, as demonstrated here:

let observer = new MutationObserver(
    (mutationRecords) => console.log(mutationRecords));

observer.observe(<b>document</b>.body, { attributes: true });

// Add attribute
<b>document</b>.body.setAttribute('foo', 'bar');

// Modify existing attribute
<b>document</b>.body.setAttribute('foo', 'baz');

// Remove attribute
<b>document</b>.body.removeAttribute('foo');

Output:

The default behavior is to observe all attribute changes and to not record the old value inside the
MutationRecord.

To observe a subset of attributes, the <i>attributeFilter</i> property can
be used as a white list of attribute names:

let observer = new MutationObserver(
    (mutationRecords) => console.log(mutationRecords));

observer.observe(<b>document</b>.body, { attributeFilter: ['foo'] });

// Add whitelisted attribute
<b>document</b>.body.setAttribute('foo', 'bar');

// Add excluded attribute
<b>document</b>.body.setAttribute('baz', 'qux');

Only a single mutation record is created for the 'foo' attribute mutation

Output:

To preserve the old value inside the mutation record, the attributeOldValue can be
set to true:

let observer = new MutationObserver(
    (mutationRecords) => console.log(mutationRecords .map((x) => x.oldValue)));

observer.observe(<b>document</b>.body, { attributeOldValue: true });

<b>document</b>.body.setAttribute('foo', 'bar');
<b>document</b>.body.setAttribute('foo', 'baz');
<b>document</b>.body.setAttribute('foo', 'qux');

Each mutation records the previous value

Output:



<h2>DOM Observing character data mutations via MutationObserver</h2>

A MutationObserver can monitor changes when a textual node, 
such as Text, Comment, or
ProcessingInstruction nodes, has its character data added, removed, or changed.

This is accomplished by setting the <i>characterData</i> property inside 
the <b>MutationObserverInit</b> object to true, as
demonstrated here:

let observer = new MutationObserver(
    (mutationRecords) => console.log(mutationRecords));

// Create an initial text node to observe
<b>document</b>.body.innerText = 'foo';

observer.observe(<b>document</b>.body.firstChild, { characterData: true });

// Identical string assignment
<b>document</b>.body.innerText = 'foo';

// New string assignment

<b>document</b>.body.innerText = 'bar';

 // Node setter assignment
<b>document</b>.body.firstChild.textContent = 'baz';

// All three are recorded as mutations

Output:

The default behavior is to not record the old value inside the MutationRecord.

To preserve the old value inside the mutation record, 
the <i>attributeOldValue</i> can be set to true:

let observer = new MutationObserver(
   (mutationRecords) => console.log(mutationRecords .map((x) => x.oldValue)));

<b>document</b>.body.innerText = 'foo';

observer.observe(<b>document</b>.body.firstChild, { characterDataOldValue: true });

<b>document</b>.body.innerText = 'foo';
<b>document</b>.body.innerText = 'bar';
<b>document</b>.body.firstChild.textContent = 'baz';

Each mutation records the previous value

Output:



<h2>DOM Observing child mutations via MutationObserver</h2>

A MutationObserver can monitor changes 
when an element has a child node added or removed.

This is accomplished by setting the <i>childList</i> property inside the <b>MutationObserverInit</b>
object to true.

A child node addition is demonstrated here:

// clear body
<b>document</b>.body.innerHTML = '';

let observer = new MutationObserver(
    (mutationRecords) => console.log(mutationRecords));

observer.observe(<b>document</b>.body, { childList: true });

<b>document</b>.body.appendChild(<b>document</b>.createElement('div'));

A child node removal is demonstrated here:

// clear body
<b>document</b>.body.innerHTML = '';

let observer = new MutationObserver(
    (mutationRecords) => console.log(mutationRecords));

observer.observe(<b>document</b>.body, { childList: true });

<b>document</b>.body.appendChild(<b>document</b>.createElement('div'));

A child reordering will register as two separate
mutations since it is technically a node removal and subsequent re-addition:

// clear body
<b>document</b>.body.innerHTML = '';

let observer = new MutationObserver(
     (mutationRecords) => console.log(mutationRecords));

// Create two initial children
<b>document</b>.body.appendChild(<b>document</b>.createElement('div'));
<b>document</b>.body.appendChild(<b>document</b>.createElement('span'));

observer.observe(<b>document</b>.body, { childList: true });

// Reorder children
<b>document</b>.body.insertBefore(<b>document</b>.body.lastChild, <b>document</b>.body.firstChild);

<h2>DOM Observing subtree mutations via MutationObserver</h2>

By default, the MutationObserver is scoped to only observe modifications to a single element and its
child node list.

This scope can be expanded to the entirety of its DOM subtree by setting the <i>subtree</i>
property inside the <b>MutationObserverInit</b> object to true.

Watching a subtree for attribute mutations can be accomplished in the following code:

// clear body
<b>document</b>.body.innerHTML = '';

let observer = new MutationObserver(
(mutationRecords) => console.log(mutationRecords));

// Create initial element
<b>document</b>.body.appendChild(<b>document</b>.createElement('div'));

// Observe the &lt;body> subtree
observer.observe(<b>document</b>.body, { attributes: true, subtree: true });

// Modify &lt;body> subtree
<b>document</b>.body.firstChild.setAttribute('foo', 'bar');

After a subtree node is removed, mutations which are
now outside the observed subtree will still register as qualified mutations.

This behavior is demonstrated here:

// clear body//   w  w w    .  d e  m   o2   s   .  c  om  
<b>document</b>.body.innerHTML = '';

let observer = new MutationObserver(
(mutationRecords) => console.log(mutationRecords));

let subtreeRoot = <b>document</b>.createElement('div'),
subtreeLeaf = <b>document</b>.createElement('span');

// Create initial subtree of height 2
<b>document</b>.body.appendChild(subtreeRoot);
subtreeRoot.appendChild(subtreeLeaf);

// Observe the subtree
observer.observe(subtreeRoot, { attributes: true, subtree: true });

// Move node in subtree outside of observed subtree
<b>document</b>.body.insertBefore(subtreeLeaf, subtreeRoot);

subtreeLeaf.setAttribute('foo', 'bar');

subtree modification still registers as mutation

Output:



<h2>DOM Clear Queue from MutationObserver</h2>

We can clear a MutationObserver's record queue with the <i>takeRecords</i>() method.

This will return the array of MutationRecord instances which exist in the queue, and empty the
queue itself.

This is demonstrated here:

let observer = new MutationObserver(
(mutationRecords) => console.log(mutationRecords));

observer.observe(<b>document</b>.body, { attributes: true });

<b>document</b>.body.className = 'foo';
<b>document</b>.body.className = 'bar';
<b>document</b>.body.className = 'baz';

console.log(observer.takeRecords());
console.log(observer.takeRecords());

Output:

We can use <i>takeRecords</i>() 
when you would like to call <i>disconnect</i>() but wish to handle all pending 
MutationRecord instances in the queue which are discarded by calling <i>disconnect</i>().

<h2>DOM XML XHTML Namespaces Introduction</h2>

XML namespaces allow elements from different XML-based languages to be mixed together in a
single, well-formed document without fear of element name clashes.

Technically, XML namespaces
are not supported by HTML but supported in XHTML; therefore, the examples in this section
are in XHTML.

Namespaces are specified using the <i>xmlns</i> attribute.

The namespace for XHTML is <i>http://www.w3.org/1999/xhtml</i> and should be included on the &lt;html> element of any well-formed XHTML
page, as shown in the following example:

&lt;html xmlns="http://www.w3.org/1999/xhtml">
 &lt;head>
   &lt;title>Example XHTML page&lt;/title>
 &lt;/head>
 &lt;body>
   Hello world!
 &lt;/body>
&lt;/html>

For this example, all elements are considered to be part of the XHTML namespace by default.

You
can explicitly create a prefix for an XML namespace using <i>xmlns</i>, followed by a colon, followed by
the prefix, as in this example:

&lt;xhtml:html xmlns:xhtml="http://www.w3.org/1999/xhtml">
  &lt;xhtml:head>
    &lt;xhtml:title>Example XHTML page&lt;/xhtml:title>
  &lt;/xhtml:head>
  &lt;xhtml:body>
    Hello world!
  &lt;/xhtml:body>
&lt;/xhtml:html>

Here, the namespace for XHTML is defined with a prefix of <i>xhtml</i>, requiring all XHTML elements
to begin with that prefix.

Attributes may be qualified by namespace to avoid confusion between languages,
as shown in the following example:

&lt;xhtml:html xmlns:xhtml="http://www.w3.org/1999/xhtml">
  &lt;xhtml:head>
    &lt;xhtml:title>Example XHTML page&lt;/xhtml:title>
  &lt;/xhtml:head>
  &lt;xhtml:body xhtml:<b>class</b>="home">
    Hello world!
  &lt;/xhtml:body>
&lt;/xhtml:html>

The class attribute in this example is prefixed with xhtml.

Adding namespace isn't really necessary when
only one XML-based language is being used in a document; it is, however, very useful when mixing
two languages together.

Consider the following document containing both XHTML and SVG:

&lt;html xmlns="http://www.w3.org/1999/xhtml">
  &lt;head>
    &lt;title>Example XHTML page&lt;/title>
  &lt;/head>
  &lt;body>
    &lt;svg xmlns="http://www.w3.org/2000/svg" version="1.1"
       viewBox="0 0 100 100" style="width:100%; height:100%">
      &lt;rect x="0" y="0" width="100" height="100" style="fill:red" />
     &lt;/svg>
  &lt;/body>
&lt;/html>

In this example, the &lt;svg> element is indicated as foreign to the containing document by setting its
own namespace.

All children of the &lt;svg> element, as well as all attributes of the elements, are 
considered to be in the <i>http://www.w3.org/2000/svg</i> namespace.

Even though the document is technically an XHTML document, the SVG code is considered valid because of the use of namespaces.

<h2>DOM Styles Introduction</h2>

Styles are defined in HTML in three ways: 

including an external style sheet via the &lt;link> element,
defining inline styles using the &lt;style> element, and
defining element-specific styles using the style attribute.

DOM Styles provides an API around all three of these styling mechanisms.

<h3>Accessing Element Styles</h3>
Any HTML element that supports the style attribute also has a style property exposed in 
JavaScript.

The style object is an instance of <b>CSSStyleDeclaration</b> and contains all stylistic 
information specified by the HTML style attribute but no information about styles that have cascaded from
either included or inline style sheets.

Any CSS property specified in the style attribute are represented as properties on the style object.

Because CSS property names use dash case, such as background-image, the names 
must be converted into camel case in order
to be used in JavaScript.

The following table lists some common CSS properties and the equivalent
property names on the style object.

<table>
<thead><tr><th>Css Property</th><th>Javascript Property</th></tr></thead>
<tbody>
<tr><td>background-image</td><td>style.backgroundImage</td></tr>
<tr><td>color</td><td>   style.color</td></tr>
<tr><td>display</td><td> style.display</td></tr>
<tr><td>font-family</td><td> style.fontFamily</td></tr>
</tbody></table>
The one CSS property float, which is a reserved word in JavaScript, 
is converted to be <i>cssFloat</i>.

Styles can be set using JavaScript at any time as long as a valid DOM element reference is available.

Here are some examples:

let myDiv = <b>document</b>.getElementById("myDiv");

// set the background color
myDiv.style.backgroundColor = "red";

// change the dimensions
myDiv.style.width = "100px";
myDiv.style.height = "200px";

// assign a border
myDiv.style.border = "1px solid black";

When styles are changed in this manner, the display of the element is automatically updated.

When in standards mode, all measurements have to include a unit of measure.

In quirks mode, you can set style.width to be  "20" and it will assume
that you mean  "20px"; in standards mode, setting style.width to  "20" will be
ignored because it has no unit of measure.

In practice, it's best to always include the unit of measurement.

Styles specified in the style attribute can also be retrieved using the style object.

Consider the following HTML:

&lt;div id="myDiv" style="background-color: blue; width: 10px; height: 25px">&lt;/div>

The information from this element's style attribute can be retrieved via the following code:

console.log(myDiv.style.backgroundColor);   // "blue"
console.log(myDiv.style.width);             // "10px"
console.log(myDiv.style.height);            // "25px"

If no style attribute is specified on an element, the style object will contain empty values for all
possible CSS properties.

<h2>DOM Style Properties and Methods</h2>

The DOM Style specification defines several properties and methods on the style
object.

These properties and methods provide information about the contents of the element's style
attribute and enabling changes.

They are as follows:

<table>
<thead><tr><th>Name   <br>cssText</th><th>   Description                                              <br>     provides access to the CSS code of the style attribute.</th></tr></thead>
<tbody>
<tr><td>length</td><td>   The number of CSS properties applied to the element.</td></tr>
<tr><td>parentRule</td><td>   The CSSRule object representing the CSS information.</td></tr>
<tr><td><i>getPropertyCSSValue</i>(propertyName)</td><td>   Returns a CSSValue object containing the value of the given property.</td></tr>
<tr><td><i>getPropertyPriority</i>(propertyName)</td><td>   Returns  "important" if the given property is set using  !important; otherwise, it returns an empty string.</td></tr>
<tr><td><i>getPropertyValue</i>(propertyName)</td><td>   Returns the string value of the given property.</td></tr>
<tr><td><i>item</i>(index)</td><td>   Returns the name of the CSS property at the given position.</td></tr>
<tr><td><i>removeProperty</i>(propertyName)</td><td>   Removes the given property from the style.</td></tr>
<tr><td><i>setProperty</i>(propertyName, value, priority)</td><td>   Sets the given property to the given value with a priority (either  "important" or an empty string).</td></tr>
</tbody></table>
<h3>cssText</h3>
The <i>cssText</i> property allows access to the CSS code of the style.

When used in read mode, <i>cssText</i>
returns the browser's internal representation of the CSS code in the style attribute.

When used in
write mode, the value assigned to <i>cssText</i> overwrites the entire value of the style attribute, meaning
that all previous style information specified using the attribute is lost.

For instance, if the element has
a border specified via the style attribute and you overwrite <i>cssText</i> with rules that don't include
the border, it is removed from the element.

The <i>cssText</i> property is used as follows:

myDiv.style.cssText = "width: 25px; height: 100px; background-color: red";
console.log(myDiv.style.cssText);

Setting the <i>cssText</i> property is the fastest way to make multiple changes to an element's style.

<h3>Length</h3>
The <i>length</i> property is designed for use in conjunction with the <i>item</i>() method for iterating over the
CSS properties defined on an element.

With these, the style object effectively becomes a collection,
and bracket notation can be used in place of <i>item</i>() to retrieve the CSS property name in the given
position, as shown in the following example:

for (let i = 0, len = myDiv.style.<b>length</b>; i &lt; len; i++) {
  console.log(myDiv.style[i]);   // alternately, myDiv.style.item(i)
}

Using either bracket notation or <i>item</i>(), you can retrieve the CSS property name ( "background-color", not  "backgroundColor").

This property name can then be used in <i>getPropertyValue</i>() to
retrieve the actual value of the property, as shown in the following example:

let prop, value, i, len;
for (i = 0, len = myDiv.style.<b>length</b>; i &lt; len; i++) {
   prop = myDiv.style[i];   // alternately, myDiv.style.item(i)
   value = myDiv.style.getPropertyValue(prop);
   console.log('prop: ${value}');
}

The <i>getPropertyValue</i>() method always retrieves the string representation of the CSS property value.

If you need more information, <i>getPropertyCSSValue</i>() returns a <b>CSSValue</b> object that has two properties: <i>cssText</i> and <i>cssValueType</i>.

The <i>cssText</i> property is the same as the value returned from <i>getPropertyValue</i>().

The <i>cssValueType</i> property is a numeric constant indicating the type
of value being represented: 

0 for an inherited value,
1 for a primitive value,
2 for a list, or
3 for a custom value.

The following code outputs the CSS property value and the value type:

let prop, value, i, len;
for (i = 0, len = myDiv.style.<b>length</b>; i &lt; len; i++) {
   prop = myDiv.style[i];   // alternately, myDiv.style.item(i)
   value = myDiv.style.getPropertyCSSValue(prop);
   console.log(`prop: ${value.cssText} (${value.cssValueType})`);
}

The <i>removeProperty</i>() method is used to remove a specific CSS property from the element's styling.

Removing a property using this method means that any default styling for that property cascading from other style sheets will be applied.

For instance, to remove a border property that was set in the
style attribute, you can use the following code:

myDiv.style.removeProperty("border");

This method is helpful when you're not sure what the default value for a given css property is.

Simply removing the property allows the default value to be used.

<h2>DOM Computed Styles</h2>

DOM Style augments <i>document.defaultView</i> to provide a method called <i>getComputedStyle</i>().

This method accepts two arguments: the element to get the computed style for and a
pseudo-element string, such as ":after".

The second argument can be null if no pseudo-element information is necessary.

The <i>getComputedStyle</i>() method returns a <b>CSSStyleDeclaration</b> object, 
which the same type as the style property, containing all computed styles for the element.

Consider the following HTML page:

&lt;!DOCTYPE html>
&lt;html>
&lt;head>
  &lt;title>Computed Styles Example&lt;/title>
  &lt;style type="text/css">
    #myDiv {
      background-color: blue;
      width: 100px;
      height: 200px;
    }
  &lt;/style>
&lt;/head>
&lt;body>
  &lt;div id="myDiv" style="background-color: red; border: 1px solid black">&lt;/div>
&lt;/body>
&lt;/html>

In this example, the &lt;div> element has styles applied to it both from an inline style sheet and from the style attribute.

The style object has values for <i>backgroundColor</i>
and <i>border</i>, but nothing for width and height, which are applied through a style sheet rule.

The following code retrieves the computed style for the element:

let myDiv = <b>document</b>.getElementById("myDiv");
let computedStyle = <b>document</b>.defaultView.getComputedStyle(myDiv, null);

console.log(computedStyle.backgroundColor);  // "red"
console.log(computedStyle.width);            // "100px"
console.log(computedStyle.height);           // "200px"
console.log(computedStyle.border);// "1px solid black" in some browsers

When retrieving the computed style of this element, the background color is reported as  "red", the
width as  "100px", and the height as  "200px".

The background color is not "blue" because
that style is overridden on the element itself.

The border property may or may not return the exact border rule from the style sheet.

You should test your code on a number of browsers when using <i>getComputedStyle</i>().

The computed styles in all browsers are read-only;
you cannot change CSS properties on a computed style object.

Sny CSS property that has a default value will be represented in the computed style.

For instance, the visibility property always
has a default value in all browsers, but this value differs per implementation.

<h2>DOM Working with CSS Style Sheets</h2>

The <b>CSSStyleSheet</b> type represents a CSS style sheet as included using a &lt;link> element or defined
in a &lt;style> element.

The elements themselves are represented by the <b>HTMLLinkElement</b>
and <b>HTMLStyleElement</b> types, respectively.

The <b>CSSStyleSheet</b> type is generic enough to represent
a style sheet no matter how it is defined in HTML.

The <b>CSSStyleSheet</b> type inherits from <b>StyleSheet</b>, which can be used as a base to define non-CSS
style sheets.

The following properties are inherited from <b>StyleSheet</b>:

<table>
<thead><tr><th>Property</th><th>   Description</th></tr></thead>
<tbody>
<tr><td>disabled</td><td>   A Boolean value indicating if the style sheet is disabled.                           <br>   This property is read/write, so setting its value to true will disable a style sheet.</td></tr>
<tr><td>href</td><td>   The URL of the style sheet if it is included using &lt;link>;<br>   otherwise, this is null.                                  </td></tr>
<tr><td>media<br></td><td>   A collection of media types supported by this style sheet.                                          <br>   The collection has a length property and <i>item</i>() method, as with all DOM collections.                <br>   Like other DOM collections, you can use bracket notation to access specific items in the collection.<br>   An empty list indicates that the style sheet should be used for all media.                          </td></tr>
<tr><td><i>ownerNode</i></td><td>     Pointer to the node that owns the style sheet, which is either a &lt;link> or a &lt;style> element in HTML.<br>   This property is null if a style sheet is included in another style sheet using @import.               </td></tr>
<tr><td><i>parentStyleSheet</i></td><td>   When a style sheet is included via @import, this is a pointer to the style sheet that imported it.</td></tr>
<tr><td>title</td><td>   The value of the title attribute on the <i>ownerNode</i>.</td></tr>
<tr><td>type</td><td>   A string indicating the type of style sheet.<br>   For CSS style sheets, this is  "text/css".  </td></tr>
</tbody></table>
With the exception of <i>disabled</i>, the rest of these properties are read-only.

The <b>CSSStyleSheet</b> type
supports all of these properties and the following properties and methods:

<table>
<thead><tr><th>Property</th><th>   Description</th></tr></thead>
<tbody>
<tr><td><i>cssRules</i></td><td>   A collection of rules contained in the style sheet.</td></tr>
<tr><td><i>ownerRule</i></td><td>   If the style sheet was included using @import, this is a pointer to the rule representing the import; otherwise, this is null.</td></tr>
<tr><td><i>deleteRule</i>(index)</td><td>   Deletes the rule at the given location in the <i>cssRules</i> collection.</td></tr>
<tr><td><i>insertRule</i>(rule, index)</td><td>   Inserts the given string rule at the position specified in the <i>cssRules</i> collection.</td></tr>
</tbody></table>
The list of style sheets available on the document is represented by the <i>document.styleSheets</i> collection.

The number of style sheets on the document can be retrieved using the <i>length</i> property, and
each individual style sheet can be accessed using either the <i>item</i>() method or bracket notation.

Here is an example:

let sheet = null;
for (let i = 0, len = <b>document</b>.styleSheets.<b>length</b>; i &lt; len; i++) {
   sheet = <b>document</b>.styleSheets[i];
   console.log(sheet.href);
}

This code outputs the <i>href</i> property of each style sheet used in the document.

&lt;style> elements have no <i>href</i>.

The style sheets returned in <i>document.styleSheets</i> vary from browser to browser.

We can retrieve the <b>CSSStyleSheet</b> object directly from the &lt;link> or &lt;style> element.

The DOM specifies a property called <i>sheet</i> that contains the <b>CSSStyleSheet</b> object.

<h2>DOM CSS Rule Object</h2>

A <b>CSSRule</b> object represents each rule in a style sheet.

The <b>CSSRule</b> type is a base type from
which several other types inherit, but the most often used is <b>CSSStyleRule</b>, which represents styling information.

The following properties are available on a <b>CSSStyleRule</b> object:

<table>
<thead><tr><th>Property</th><th>   Meaning</th></tr></thead>
<tbody>
<tr><td>cssText</td><td>   Returns the text for the entire rule.                                                                                              <br>   This text may be different from the actual text in the style sheet because of the way that browsers handle style sheets internally;<br>   Safari always converts everything to all lowercase.                                                                                </td></tr>
<tr><td><i>parentRule</i></td><td>      If this rule is imported, this is the import rule;<br>   otherwise, this is null.                             </td></tr>
<tr><td><i>parentStyleSheet</i></td><td>   The style sheet that this rule is a part of.</td></tr>
<tr><td><i>selectorText</i><br></td><td>     Returns the selector text for the rule.                                                                                          <br>   This text may be different from the actual text in the style sheet because of the way that browsers handle style sheets internally.<br>   This property is read-only in Firefox, Safari, Chrome, and Internet Explorer (where it throws an error).                           <br>   Opera allows <i>selectorText</i> to be changed.                                                                                         </td></tr>
<tr><td>style</td><td>   A <b>CSSStyleDeclaration</b> object that allows the setting and getting of specific style values for the rule.</td></tr>
<tr><td>type</td><td>   A constant indicating the type of rule. For style rules, this is always  1.</td></tr>
</tbody></table>
The three most frequently used properties are <i>cssText</i>, <i>selectorText</i>, and <i>style</i>.

The <i>cssText</i> property is similar to the <i>style.cssText</i> property but not exactly the same.

The former includes the
selector text and the braces around the style information; the latter contains only the style information, similar to <i>style.cssText</i> on an element.

<i>cssText</i> is read-only, whereas <i>style.cssText</i> may be overwritten.

The style property is all that is required to manipulate style rules.

This object can be used just like the one on each element to read or change the style information for a rule.

Consider the following CSS rule:

div.box {
   background-color: blue;
   width: 100px;
   height: 200px;
}

Assuming that this rule is in the first style sheet on the page and is the only style in that style sheet,
the following code can be used to retrieve all of its information:

let sheet = <b>document</b>.styleSheets[0];
let rules = sheet.cssRules || sheet.rules;  // get rules list
let rule = rules[0];              // get first rule
console.log(rule.selectorText);           // "div.box"
console.log(rule.style.cssText);          // complete CSS code
console.log(rule.style.backgroundColor);  // "blue"
console.log(rule.style.width);            // "100px"
console.log(rule.style.height);           // "200px"

Using this technique, we can determine the style information related to a rule in the same way you can determine the inline style information for an element.

As with elements, we can change the style information, as shown in the following example:

let sheet = <b>document</b>.styleSheets[0];
let rules = sheet.cssRules || sheet.rules;  // get rules list
let rule = rules[0];                        // get first rule
rule.style.backgroundColor = "red"

Changing a rule in this way affects all elements on the page for which the rule applies.

If there are two &lt;div> elements that have the box class, they will both be affected by this change.

<h2>DOM Creating CSS Rules</h2>

We can add new rules to existing style sheets using the <i>insertRule</i>() method.

This method expects two arguments: the text of the rule and the index at which to insert the rule.

Here is an example:

sheet.insertRule("body { background-color: silver }", 0);  // DOM method

This example inserts a rule that changes the document's background color.

The rule is inserted as the
first rule in the style sheet (position 0).

The order is important in determining how the rule cascades
into the document.

<h2>DOM Deleting CSS Rules</h2>

We can delete rules from a style sheet using <i>deleteRule</i>() method, which accepts a single argument: the index of the rule to remove.

To remove the first rule in a style sheet, you can use the following code:

sheet.deleteRule(0);  // DOM method

Deleting rules can affect the cascading effect of CSS.

<h2>DOM Range Introduction</h2>

A range can be used to select a section of a document regardless of node boundaries.

A DOM range can be created using <i>createRange</i>() from Document type, as shown here:

let range = <b>document</b>.createRange();

The newly created range is linked to the document on which it was created
and cannot be used on other documents.

This range can then be used to select specific parts of the
document behind the scenes.

Once a range has been created and its position set, a number of different
operations can be performed on the range.

Each range is represented by an instance of the <b>Range</b> type, 
which has a number of properties and methods.

The following properties provide information about the range:

<table>
<thead><tr><th>Property</th><th>   Meaning</th></tr></thead>
<tbody>
<tr><td><i>startContainer</i></td><td>      The node within which the range starts.    <br>   The parent of the first node in the selection.</td></tr>
<tr><td><i>startOffset</i></td><td>     The offset within the <i>startContainer</i> where the range starts.                                                                                 <br>   If <i>startContainer</i> is a text node, comment node, or <b>CData</b> node, the <i>startOffset</i> is the number of characters skipped before the range starts;<br>   otherwise, the offset is the index of the first child node in the range.                                                                         </td></tr>
<tr><td><i>endContainer</i></td><td>    The node within which the range ends.       <br>   The parent of the last node in the selection.</td></tr>
<tr><td><i>endOffset</i></td><td>   The offset within the <i>endContainer</i> where the range ends.<br>   It follows the same rules as <i>startOffset</i>.               </td></tr>
<tr><td><i>commonAncestorContainer</i></td><td>   The deepest node in the document that has both <i>startContainer</i> and <i>endContainer</i> as descendants.</td></tr>
</tbody></table>
These properties are filled when the range is placed into a specific position in the document.

<h2>DOM Simple Selection in DOM Ranges</h2>

To select a part of the document using a range is use either <i>selectNode</i>() or
<i>selectNodeContents</i>().

These methods each accept one argument, a DOM node, and fill a range
with information from that node.

The <i>selectNode</i>() method selects the entire node, including its
children, whereas <i>selectNodeContents</i>() selects only the node's children.

For example, consider the following HTML:

&lt;!DOCTYPE html>
&lt;html>
  &lt;body>
    &lt;p id="p1">&lt;b>Hello&lt;/b> world!&lt;/p>
  &lt;/body>
&lt;/html>

This code can be accessed using the following JavaScript:

let range1 = <b>document</b>.createRange(),
    range2 = <b>document</b>.createRange(),
    p1 = <b>document</b>.getElementById("p1");
range1.selectNode(p1);
range2.selectNodeContents(p1);

The two ranges in this example contain different
sections of the document: range1 contains the &lt;p>
element and all its children, whereas range2 contains 
the &lt;b> element, the text node  "Hello", and the text 
node  "world!".

<center><img alt="DOM-Range.png" src="data:image/png;base64,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"></center>
<br>When <i>selectNode</i>() is called, <i>startContainer</i>,
<i>endContainer</i>, and <i>commonAncestorContainer</i> are all equal to the parent node of the node that
was passed in; in this example, these would all be equal to document.body.

The <i>startOffset</i> property is equal to the index of the given node within the parent's childNodes collection which is
1 in this example.

The <i>endOffset</i> is equal to the <i>startOffset</i> plus one because only one node is selected.

When <i>selectNodeContents</i>() is called, <i>startContainer</i>, <i>endContainer</i>, and 
<i>commonAncestorContainer</i>
 are equal to the node that was passed in, which is the &lt;p> element in this example.

The <i>startOffset</i> property is always equal to  0, because the range begins with the first child of the
given node, whereas <i>endOffset</i> is equal to the number of child nodes as <i>node.childNodes.length</i>,
which is 2 in this example.

We can get more fine-grained control over which nodes are included in the selection by using
the following range methods:

<table>
<thead><tr><th>Method</th><th>   Meaning</th></tr></thead>
<tbody>
<tr><td><i>setStartBefore</i>(<i>refNode</i>)</td><td>   Sets the starting point of the range to begin before <i>refNode</i>, so <i>refNode</i> is the first node in the selection.                                                          <br>   The <i>startContainer</i> property is set to <i>refNode.parentNode</i>, and the <i>startOffset</i> property is set to the index of <i>refNode</i> within its parent's <i>childNodes</i> collection.</td></tr>
<tr><td><i>setStartAfter</i>(<i>refNode</i>)</td><td>    Sets the starting point of the range to begin after <i>refNode</i>, so <i>refNode</i> is not part of the selection; rather, its next sibling is the first node in the selection.            <br>   The <i>startContainer</i> property is set to <i>refNode.parentNode</i>, and the <i>startOffset</i> property is set to the index of <i>refNode</i> within its parent's <i>childNodes</i> collection plus one.</td></tr>
<tr><td><i>setEndBefore</i>(<i>refNode</i>)</td><td>      Sets the ending point of the range to begin before <i>refNode</i>, so <i>refNode</i> is not part of the selection; its previous sibling is the last node in the selection.   <br>   The <i>endContainer</i> property is set to <i>refNode.parentNode</i>, and the <i>endOffset</i> property is set to the index of <i>refNode</i> within its parent's <i>childNodes</i> collection.</td></tr>
<tr><td><i>setEndAfter</i>(<i>refNode</i>)</td><td>      Sets the ending point of the range to begin before <i>refNode</i>, so <i>refNode</i> is the last node in the selection.                                                                <br>   The <i>endContainer</i> property is set to *refNode. parentNode*, and the <i>endOffset</i> property is set to the index of <i>refNode</i> within its parent's <i>childNodes</i> collection plus one.</td></tr>
</tbody></table>
When you use any of these methods, all properties are assigned for you.

However, it is possible to
assign these values directly in order to make complex range selections.

<h2>DOM Complex Selection in DOM Ranges</h2>

Creating complex ranges requires the use of the <i>setStart</i>() and <i>setEnd</i>() methods 
from <b>Range</b> object.

Both methods accept two arguments: a reference node and an offset.

For <i>setStart</i>(), the reference node becomes
the <i>startContainer</i>, and the offset becomes the <i>startOffset</i>.

For <i>setEnd</i>(), the reference node
becomes the <i>endContainer</i>, and the offset becomes the <i>endOffset</i>.

With these methods, it is possible to mimic <i>selectNode</i>() and <i>selectNodeContents</i>().

Here is
an example:

let range1 = <b>document</b>.createRange(),
    range2 = <b>document</b>.createRange(),
    p1 = <b>document</b>.getElementById("p1"),
    p1Index = -1,
    i,
    len;
for (i = 0, len = p1.parentNode.childNodes.<b>length</b>; i &lt; len; i++) {
  if (p1.parentNode.childNodes[i] === p1) {
    p1Index = i;
    break;
  }
}

range1.setStart(p1.parentNode, p1Index);
range1.setEnd(p1.parentNode, p1Index + 1);
range2.setStart(p1, 0);
range2.setEnd(p1, p1.childNodes.<b>length</b>);

Note that to select the node, you must first determine the index of the given 
node (p1) in its parent node's <i>childNodes</i> collection.

To select the node contents using range2, you do
not need calculations; <i>setStart</i>() and <i>setEnd</i>() can be set with default values.

<h3>Partial Selection</h3>
<i>setStart</i>() and <i>setEnd</i>() can do partial selection of nodes.

For example, consider the following HTML:

&lt;!DOCTYPE html>
&lt;html>
  &lt;body>
    &lt;p id="p1">&lt;b>Hello&lt;/b> world!&lt;/p>
  &lt;/body>
&lt;/html>

Suppose that you want to select only from the  "llo" in  "Hello" to the  "o" in  "world!" in the previous HTML code.

The first step is to get references to all of the relevant nodes, as shown in the following example:

let p1 = <b>document</b>.getElementById("p1"),
    helloNode = p1.firstChild.firstChild,
    worldNode = p1.lastChild

The  "Hello" text node is actually a grandchild of &lt;p> because it's a child of &lt;b>, 
so you can use <i>p1.firstChild</i> to get &lt;b> and <i>p1.firstChild.firstChild</i> to get the 
text node.

The  "world!" text node is the second and the last child of &lt;p>, so you can use 
<i>p1.lastChild</i> to retrieve it.

Next, the range must be created and its boundaries defined, as shown in the 
following example:

let range = <b>document</b>.createRange();
range.setStart(helloNode, 2);
range.setEnd(worldNode, 3);

Because the selection should start after the  "e" in
"Hello", <i>helloNode</i> is passed into <i>setStart</i>() with                   
an offset of 2, the position after the  "e" where  "H"              
is in position 0. 

To set the end of the selection, pass            
<i>worldNode</i> into <i>setEnd</i>() with an offset of 3, 
indicating the first character that should not be selected,
which is  "r" in position 3.

There is actually a space in
position 0. 

<center><img alt="DOM-Range-Index.png" src="data:image/png;base64,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"></center>
<br>Because both <i>helloNode</i> and <i>worldNode</i> are text nodes, they become 
the <i>startContainer</i> and
<i>endContainer</i> for the range so that the <i>startOffset</i> and <i>endOffset</i> accurately look 
at the text
contained within each node rather than look for child nodes.

The <i>commonAncestorContainer</i> is the &lt;p> element, which is the first ancestor that
contains both nodes.

<h2>DOM Delete DOM Range Content</h2>

When a range is created, internally it creates a document fragment node where all of the nodes
in the selection are attached.

The range contents must be well formed in order for this process to take place.

The range does not represent a well-formed DOM structure 
if the selection begins inside one text node and ends in another.

Ranges can recognize missing opening and closing tags and can 
reconstruct a valid DOM structure to operate on.

With the range created, the contents of the range can be manipulated using a variety of methods.

<h3>Delete</h3>
For example, consider the following HTML:

&lt;!DOCTYPE html>
&lt;html>
  &lt;body>
    &lt;p id="p1">&lt;b>Hello&lt;/b> world!&lt;/p>
  &lt;/body>
&lt;/html>

The method <i>deleteContents</i>() simply
deletes the contents of the range from the document.

Here is an example:

let p1 = <b>document</b>.getElementById("p1"),
    helloNode = p1.firstChild.firstChild,
    worldNode = p1.lastChild,
    range = <b>document</b>.createRange();

range.setStart(helloNode, 2);
range.setEnd(worldNode, 3);

range.deleteContents();

Executing this code results in the following HTML being shown on the page:

&lt;p>&lt;b>He&lt;/b>rld!&lt;/p>

Because the range selection process altered the underlying DOM structure to remain well formed, 
the resulting DOM structure is well formed even after removing 
the contents.

<h2>DOM Extract DOM Range Content</h2>

<i>extractContents</i>() is similar to <i>deleteContents</i>() since it removes the range selection from
the document.

The <i>extractContents</i>() returns the range's document fragment to the caller.
This allows you to insert the contents of the range somewhere else.

For example, consider the following HTML:

&lt;!DOCTYPE html>
&lt;html>
  &lt;body>
    &lt;p id="p1">&lt;b>Hello&lt;/b> world!&lt;/p>
  &lt;/body>
&lt;/html>

Here is an example:

let p1 = <b>document</b>.getElementById("p1"),
    helloNode = p1.firstChild.firstChild,
    worldNode = p1.lastChild,
    range = <b>document</b>.createRange();

range.setStart(helloNode, 2);
range.setEnd(worldNode, 3);

let fragment = range.extractContents();
p1.parentNode.appendChild(fragment);

In this example, the fragment is extracted and added to the end of the document's &lt;body> element.

When a document fragment is passed into <i>appendChild</i>(), only the fragment's 
children are added, not the fragment itself.

<h2>DOM Clone DOM Range Content</h2>

The range can create a clone of itself and can be inserted else where in
the document by using <i>cloneContents</i>().

For example, consider the following HTML:

&lt;!DOCTYPE html>
&lt;html>
  &lt;body>
    &lt;p id="p1">&lt;b>Hello&lt;/b> world!&lt;/p>
  &lt;/body>
&lt;/html>

let p1 = <b>document</b>.getElementById("p1"),
    helloNode = p1.firstChild.firstChild,
    worldNode = p1.lastChild,
    range = <b>document</b>.createRange();

range.setStart(helloNode, 2);
range.setEnd(worldNode, 3);

let fragment = range.cloneContents();
p1.parentNode.appendChild(fragment);

<i>cloneContents</i>() method returns a document fragment.

The document fragment returned by <i>cloneContents</i>() contains 
clones of the nodes contained in the range instead of the actual nodes.

The splitting of nodes ensures that a well-formed document isn't produced
until one of these methods is called.

The original HTML remains intact right up until the point that
the DOM is modified.

<h2>DOM Inserting DOM Range Content</h2>

The <i>insertNode</i>() method can insert a node at the beginning of the range selection.

For example, consider the following HTML:

&lt;!DOCTYPE html>
&lt;html>
  &lt;body>
    &lt;p id="p1">&lt;b>Hello&lt;/b> world!&lt;/p>
  &lt;/body>
&lt;/html>

Suppose that you want to insert the following HTML:

&lt;span style="color: red">Inserted text&lt;/span>

The following code accomplishes this:

let p1 = <b>document</b>.getElementById("p1"),
   helloNode = p1.firstChild.firstChild,
   worldNode = p1.lastChild,
   range = <b>document</b>.createRange();

range.setStart(helloNode, 2);
range.setEnd(worldNode, 3);

let span = <b>document</b>.createElement("span");
span.style.color = "red";
span.appendChild(<b>document</b>.createTextNode("Inserted text"));

range.insertNode(span);

Running this JavaScript effectively creates the following HTML code:

&lt;p id="p1">&lt;b>He&lt;span style="color: red">Inserted text&lt;/span>llo&lt;/b> world&lt;/p>

&lt;span> is inserted just before the  "llo" in  "Hello", which is the first 
part of the range selection.

We can insert content surrounding the range by using the <i>surroundContents</i>() method.

This method accepts the node that surrounds the range contents as the argument.

The following code highlights certain words in a web page, as shown here:

let p1 = <b>document</b>.getElementById("p1"),
   helloNode = p1.firstChild.firstChild,
   worldNode = p1.lastChild,
   range = <b>document</b>.createRange();

range.selectNode(helloNode);
let span = <b>document</b>.createElement("span");
span.style.backgroundColor = "yellow";
range.surroundContents(span);

This code highlights the range selection with a yellow background.

The resulting HTML is as follows:

&lt;p>&lt;b>&lt;span style="background-color:yellow">Hello&lt;/span>&lt;/b> world!&lt;/p>

In order to insert the &lt;span>, the range has to contain a whole DOM selection.

It can't have only partially selected DOM nodes.

<h2>DOM Collapsing a DOM Range</h2>

When a range isn't selecting any part of a document, it is said to be collapsed.

When you collapse a range, its location is set between parts of
a document, either at the beginning of the range selection or at the end.

You can collapse a range by using the <i>collapse</i>() method, which accepts a single argument: 
a Boolean value indicating which end of the range to collapse to.

If the argument is true, then the
range is collapsed to its starting point; if it is false, the range is collapsed to its ending point.

To determine if a range is already collapsed, you can use the collapsed property as follows:

range.collapse(true);    // collapse to the starting point
console.log(range.collapsed);  // outputs "true"

We can find out if two tags are next to each other 
by testing whether a range is collapsed. 

For example, consider this HTML code:                 

&lt;p id="p1">Paragraph 1&lt;/p>
&lt;p id="p2">Paragraph 2&lt;/p>

We can create the following range:

let p1 = <b>document</b>.getElementById("p1"),
p2 = <b>document</b>.getElementById("p2"),                          
range = <b>document</b>.createRange();
range.setStartAfter(p1);
range.setStartBefore(p2);
console.log(range.collapsed);  // true

Since the the created range is collapsed then we know that 
there is nothing between the end of p1 and the beginning of p2.

<h2>DOM Comparing DOM Ranges</h2>

We can use the <i>compareBoundaryPoints</i>() method to 
determine if the ranges have any boundaries in common between two range objects.

The method accepts two arguments: the range to compare to and how to compare.

It is one of the following constant values:

<table>
<thead><tr><th>Value</th><th>   Number</th><th>   Meaning</th></tr></thead>
<tbody><tr><td>Range.START_TO_START<br>Range.START_TO_END  <br>Range.END_TO_END    <br>Range.END_TO_START  </td><td>   0  <br>   1  <br>   2  <br>     3</td><td>   Compares the starting point of the first range to the starting point of the second.       <br>      Compares the starting point of the first range to the end point of the second.         <br>      Compares the end point of the first range to the end point of the second.              <br>               Compares the end point of the first range to the starting point of the second.</td></tr></tbody></table>
The <i>compareBoundaryPoints</i>() method returns 

-1 if the point from the first range comes before the point from the second range,
0 if the points are equal, or
1 if the point from the first range comes after the point from the second range.

Consider the following example:

let range1 = <b>document</b>.createRange();
let range2 = <b>document</b>.createRange();
let p1 = <b>document</b>.getElementById("p1");

range1.selectNodeContents(p1);
range2.selectNodeContents(p1);
range2.setEndBefore(p1.lastChild);

console.log(range1.compareBoundaryPoints(Range.START_TO_START, range2));  
console.log(range1.compareBoundaryPoints(Range.END_TO_END, range2));      

<h2>DOM Cloning DOM Ranges</h2>

Ranges can be cloned by calling the <i>cloneRange</i>() method.

For example, consider the following HTML:

&lt;!DOCTYPE html>
&lt;html>
  &lt;body>
    &lt;p id="p1">&lt;b>Hello&lt;/b> world!&lt;/p>
  &lt;/body>
&lt;/html>

This method creates an exact duplicate of the range on which it is called:

let p1 = <b>document</b>.getElementById("p1"),
   helloNode = p1.firstChild.firstChild,
   worldNode = p1.lastChild,
   range = <b>document</b>.createRange();

range.setStart(helloNode, 2);
range.setEnd(worldNode, 3);

let newRange = range.cloneRange();

The new range contains all of the same properties as the original, and its end points can be modified
without affecting the original in any way.

<h2>DOM Range Cleanup</h2>

When you are done using a range, we should call the <i>detach</i>() method, which detaches 
the range from the document on which it was created.

After calling <i>detach</i>(), the range can be safely 
dereferenced, so the memory can be reclaimed through garbage collection.

For example, consider the following HTML:

&lt;!DOCTYPE html>
&lt;html>
  &lt;body>
    &lt;p id="p1">&lt;b>Hello&lt;/b> world!&lt;/p>
  &lt;/body>
&lt;/html>

Here is an example:

let p1 = <b>document</b>.getElementById("p1"),
   helloNode = p1.firstChild.firstChild,
   worldNode = p1.lastChild,
   range = <b>document</b>.createRange();

range.setStart(helloNode, 2);
range.setEnd(worldNode, 3);

range.detach();  // detach from document
range = null;        //  dereferenced

Following these two steps is the most appropriate way to finish using a range.

Once it is detached, a range can no longer be used.

<h2>Document Object Model Introduction</h2>

The Document Object Model (DOM) is an application programming interface (API) for HTML
and XML documents.

The DOM represents a document as a hierarchical tree of nodes, allowing developers to add, remove, and modify individual parts of the page.

The DOM is a collection of objects representing the elements in your HTML document. 

Evolving out of early Dynamic HTML (DHTML), the DOM is now a truly
cross-platform, language-independent way of representing and manipulating pages for markup.

DOM Level 1 became a W3C recommendation in October 1998, providing interfaces for basic
document structure and querying.

Given the following html code:

&lt;!DOCTYPE HTML>
&lt;html>
    &lt;body>
        &lt;p id="myId">
            test&lt;span id="myId2">span&lt;/span> 
            test
        &lt;/p>
        &lt;p id="LEGO">
            test 
        &lt;/p>
    &lt;/body>
&lt;/html>

As part of the process of displaying your HTML document, the browser parses the HTML and
creates a model.

The model preserves the hierarchy of the HTML elements, and
each element is represented by a JavaScript object.

<center><img alt="dom-tree.png" src="data:image/png;base64,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"></center>
<br>You can use the DOM to get information about the
document or to make changes to it.

This is the foundation of modern web applications.

Each model object in the model has properties and methods.

When you use these to change the
state of the object, the browser reflects the changes in the corresponding HTML element and updates
your document.

All of the DOM objects that represent elements support the same set of basic features.

<h2>Testing for DOM Features</h2>

We can test for the presence of the property or method on the DOM object that is
associated with a feature.

let images;
if (<b>document</b>.querySelectorAll) {
    images = <b>document</b>.querySelectorAll("#paratext > img");
} else {
    images = <b>document</b>.getElementById("paratext").getElementsByTagName("img");
}

for (let i = 0; i &lt; images.<b>length</b>; i++) {
    images[i].style.border = "thick solid black";
    images[i].style.padding = "4px";
}

<iframe onload="resizeIframe(this)" style="border:1px solid #f1f1f1;margin:10px 0 10px 0;background-color:#ffffff;" frameborder="0" seamless width="100%" height="350" src="javascript-testing-for-dom-features-demo-4d1ce.htm"></iframe><br><a href="javascript-testing-for-dom-features-demo-4d1ce.htm">Open in separate window</a><br><a type="button" data-toggle="collapse" style="padding:2px;" role="button" aria-expanded="false" aria-controls="MON" href="#MON">View full source code</a>

&lt;html>
    &lt;body>
        &lt;p <b>id</b>="paratext">
            This is a test.
            &lt;img src="html.png" alt="myId3"/>
        &lt;/p>
        &lt;script>
            let images;&lt;!-- w    ww   .  d e    mo    2  s.    c o  m -->
            if (<b>document</b>.querySelectorAll) {
                images = <b>document</b>.querySelectorAll("#paratext > img");
            } else {
                images = <b>document</b>.getElementById("paratext").
                         getElementsByTagName("img");
            }

            for (let i = 0; i &lt; images.length; i++) {
                images[i].style.<font color="black"><b>border</b></font> = "thick solid black";
                images[i].style.<font color="black"><b>padding</b></font> = "4px";
            }
        &lt;/script>
    &lt;/body>
&lt;/html>

<script>function resizeIframe(iframe) {let h = iframe.contentWindow.document.body.scrollHeight;if (h<200){h=220;}iframe.style.height = h + 'px'; console.log(h + 'px');}</script>
In this example, the script uses an <i>if</i> clause to determine whether
the <i>document</i> object defines a method called <i>querySelectorAll</i>.

If the clause evaluates to true, then the browser supports the feature,
and we can go on and use it.

If the clause evaluates to false, then we can take an alternative approach to
achieve the same goal.

<h2>DOM Hierarchy Of Nodes</h2>

Any HTML or XML document can be represented as a hierarchy of nodes using the DOM.

There are several node types, each representing different information and/or markup in the document.

Each node type has different characteristics, data, and methods, and each may have relationships with
other nodes.

These relationships create a hierarchy that allows markup to be represented as a tree,
rooted at a particular node.

For instance, consider the following HTML:

&lt;html>
  &lt;head>
    &lt;title>Sample Page&lt;/title>
  &lt;/head>
  &lt;body>
    &lt;p>Hello World!&lt;/p>
  &lt;/body>
&lt;/html>

This simple HTML document can be represented
in a hierarchy, as illustrated in the following tree.

<b>Document</b>
 |
 +---<b>Element</b> html
      |
      +---<b>Element</b> head
      |    |
      |    +---<b>Element</b> title
      |         |
      |         +---<b>Text</b> Sample Page
      |
      +---<b>Element</b> body
           |
           +---<b>Element</b> p
                |
                +----<b>Text</b> Hello world!

A document node represents every document as the root.

In this example, the only child of the document node is the &lt;html> element, which is
called the document element.

The document element is the outermost element in the document
within which all other elements exist.

There can be only one document element per document.

In HTML pages, the document element is always the &lt;html> element. 

In XML, where there are no predefined elements, any element may be the document element.

Every piece of markup can be represented by a node in the tree: 

HTML elements are represented by element nodes,
attributes are represented by attribute nodes,
the document type is represented by a document type node, and
comments are represented by comment nodes.

In total, there are 12 node types, all of which inherit from a base type. 

<h2>DOM Node Type</h2>

DOM Level 1 describes an interface called <b>Node</b> that is to be implemented by all node types in the DOM.

The <b>Node</b> interface is implemented in JavaScript as the <b>Node</b> type, which is accessible in all
browsers.

All node types inherit from <b>Node</b> in JavaScript, so all node types
share the same basic properties and methods.

Every node has a <i>nodeType</i> property that indicates the type of node that it is.

Node types are represented by one of the following 12 numeric constants on the Node type:

<table>
<thead><tr><th>Type</th><th>   Number Value</th></tr></thead>
<tbody>
<tr><td>Node.ELEMENT_NODE</td><td>   1</td></tr>
<tr><td>Node.ATTRIBUTE_NODE</td><td>   2</td></tr>
<tr><td>Node.TEXT_NODE</td><td>   3</td></tr>
<tr><td>Node.CDATA_SECTION_NODE</td><td>   4</td></tr>
<tr><td>Node.ENTITY_REFERENCE_NODE</td><td>   5</td></tr>
<tr><td>Node.ENTITY_NODE</td><td>   6</td></tr>
<tr><td>Node.PROCESSING_INSTRUCTION_NODE</td><td>   7</td></tr>
<tr><td>Node.COMMENT_NODE</td><td>   8</td></tr>
<tr><td>Node.DOCUMENT_NODE</td><td>   9</td></tr>
<tr><td>Node.DOCUMENT_TYPE_NODE</td><td>   10</td></tr>
<tr><td>Node.DOCUMENT_FRAGMENT_NODE</td><td>   11</td></tr>
<tr><td>Node.NOTATION_NODE</td><td>   12</td></tr>
</tbody></table>
A node's type is easy to determine by comparing against one of these constants, as shown here:

if (someNode.nodeType == Node.ELEMENT_NODE){
  console.log("Node is an element.");
}

This example compares the <i>someNode.nodeType</i> to the <b>Node.ELEMENT_NODE</b> constant.

If they're equal, it means <i>someNode</i> is actually an element.

Not all node types are supported in web browsers.

Developers most often work with element and text nodes.

<h2>DOM node Name and node Value Properties</h2>

Two properties, <i>nodeName</i> and <i>nodeValue</i>, give specific information about the node.

The values of these properties are completely dependent on the node type.

We need to test the node type before using one of these values, as the following code shows:

if (someNode.nodeType == 1){
  value = someNode.nodeName;   // will be the element's tag name
}

In this example, the node type is checked to see if the node is an element.

If so, the <i>nodeName</i> value is assigned to a variable.

For elements, <i>nodeName</i> is always equal to the element's tag name, and 
<i>nodeValue</i> is always null.

<h2>DOM Node Relationships</h2>

All nodes in a document have relationships to other nodes.

For instance, consider the following HTML:

&lt;html>
  &lt;head>
    &lt;title>Sample Page&lt;/title>
  &lt;/head>
  &lt;body>
    &lt;p>Hello World!&lt;/p>
  &lt;/body>
&lt;/html>

In HTML, the &lt;body>
element is a child of the &lt;html> element; 
likewise the &lt;html> element is the parent of the &lt;body> element.

The &lt;head> element is a sibling of the &lt;body> element,
because they both share the same immediate parent, the &lt;html> element.

This simple HTML document can be represented
in a hierarchy, as illustrated in the following tree.

<b>Document</b>
 |
 +---<b>Element</b> html
      |
      +---<b>Element</b> head
      |    |
      |    +---<b>Element</b> title
      |         |
      |         +---<b>Text</b> Sample Page
      |
      +---<b>Element</b> body
           |
           +---<b>Element</b> p
                |
                +----<b>Text</b> Hello world!

<h2>DOM Node List Object</h2>

Each node has a <i>childNodes</i> property containing a <b>NodeList</b>.

A <b>NodeList</b> is an array-like object used
to store an ordered list of nodes that are accessible by position.

A <b>NodeList</b> is not an
instance of Array even though its values can be accessed using bracket notation and the <i>length</i> 
property is present.

<b>NodeList</b> objects are unique in that they are actually queries being run against the DOM
structure, so changes will be reflected in <b>NodeList</b> objects automatically.

A <b>NodeList</b> is a living object rather than a snapshot of what happened at the time it was first accessed.

The following example shows how nodes stored in a <b>NodeList</b> may be accessed via bracket notation
or by using the <i>item</i>() method:

let firstChild = someNode.childNodes[0];
let secondChild = someNode.childNodes.item(1);
let count = someNode.childNodes.<b>length</b>;

Using bracket notation and using the <i>item</i>() method are both acceptable practices.

The <i>length</i> property indicates the number of nodes in the <b>NodeList</b> at that time.

We can convert <b>NodeList</b> objects into arrays using Array.prototype.<i>slice</i>().

Consider the following example:

let arrayOfNodes = <b>Array</b>.<b>prototype</b>.slice.call(
                     someNode.childNodes,0);

<h2>DOM Parent child Node</h2>

Each node has a <i>parentNode</i> property pointing to its parent in the document tree.

All nodes contained within a <i>childNodes</i> list have the same parent, so each 
of their <i>parentNode</i> properties points to the same node.

Each node within a <i>childNodes</i> list is considered to be a sibling of the
other nodes in the same list.

We can navigate from one node in the list to another by using the
<i>previousSibling</i> and <i>nextSibling</i> properties.

The first node in the list has <i>null</i> for the value of its
<i>previousSibling</i> property, and the last node in the list has <i>null</i> for 
the value of its <i>nextSibling</i> property, as shown in the following example:

if (someNode.nextSibling === null){
  console.log("Last node in the parent's childNodes list.");
} else if (someNode.previousSibling === null){
  console.log("First node in the parent's childNodes list.");
}

If there's only one child node, both <i>nextSibling</i> and <i>previousSibling</i> will be null.

Another relationship exists between a parent node and its first and last child nodes.

The <i>firstChild</i>
and <i>lastChild</i> properties point to the first and last node in the <i>childNodes</i> list, respectively.

The value of <i>someNode.firstChild</i> is always equal to <i>someNode.childNodes[0]</i>, 
and the value of <i>someNode.lastChild</i> is always equal 
to <i>someNode.childNodes[someNode.childNodes.length-1]</i>.

If there is only one child node, <i>firstChild</i> and <i>lastChild</i> point to the same node.

If there are no children, then <i>firstChild</i> and <i>lastChild</i> are both null.

All of these relationships help
to navigate easily between nodes in a document structure.

<i>hasChildNodes</i>() returns true if the node has one
or more child nodes and is more efficient than querying the length of the <i>childNodes</i> list.

The <i>ownerDocument</i> property is a pointer to the document node that represents the entire document.

Nodes are considered to be owned by the document
in which they were created, because nodes cannot exist
simultaneously in two or more documents.

This property provides a quick way to access the 
document node without needing to traverse the node hierarchy back up to the top.

Not all node types can have child nodes even though all node types
inherit from Node.

<h2>DOM Manipulating Nodes</h2>

Several methods are available to manipulate nodes.

<h3>Append</h3>
The <i>appendChild</i>() method adds a node to the end of the <i>childNodes</i> list.

Doing so updates all of the relationship pointers in the newly added node, 
the parent node, and the previous last child in the <i>childNodes</i> list.

When complete, <i>appendChild</i>() returns the newly added node.

Here is an example:

let returnedNode = someNode.appendChild(newNode);
console.log(returnedNode == newNode);         // true
console.log(someNode.lastChild == newNode);   // true

If the node passed into <i>appendChild</i>() is already part of the document, it is removed from its
previous location and placed at the new location.

No DOM node may exist in more than one location in a document.

If you call <i>appendChild</i>() and pass in the first child of a parent, it will end up
as the last child:

// assume multiple children for someNode
let returnedNode = someNode.appendChild(someNode.firstChild);
console.log(returnedNode == someNode.firstChild);  // false
console.log(returnedNode == someNode.lastChild);   // true

<h3>Insert</h3>
When a node needs to be placed in a specific location within the <i>childNodes</i> list, 
use the <i>insertBefore</i>() method.

The <i>insertBefore</i>() method accepts two arguments: 

the node to insert and
a reference node.

The node to insert becomes the previous sibling of the
reference node and is ultimately returned by the method.

If the reference node is null, then <i>insertBefore</i>() acts the same as <i>appendChild</i>(), as this example shows:

insert as last child

returnedNode = someNode.insertBefore(newNode, null);
console.log(newNode == someNode.lastChild);   // true

insert as the new first child.

returnedNode = someNode.insertBefore(newNode, someNode.firstChild);
console.log(returnedNode == newNode);         // true
console.log(newNode == someNode.firstChild);  // true

insert before last child.

returnedNode = someNode.insertBefore(newNode, someNode.lastChild);
console.log(newNode == someNode.childNodes[someNode.childNodes.<b>length</b> - 2]);
// true

Both <i>appendChild</i>() and <i>insertBefore</i>() insert nodes without removing any.

<h3>Replace</h3>
The <i>replaceChild</i>() method accepts two arguments: 

the node to insert and
the node to replace.

The node to replace is returned by the function and is removed from the document tree completely while the
inserted node takes its place.

Here is an example:replace first child

let returnedNode = someNode.replaceChild(newNode, someNode.firstChild);

replace last child

returnedNode = someNode.replaceChild(newNode, someNode.lastChild);

When a node is inserted using <i>replaceChild</i>(), all of its relationship pointers are duplicated from
the node it is replacing.

The replaced node no longer has a specific location in the document.

<h3>Remove</h3>
To remove a node without replacing it, you can use the <i>removeChild</i>() method.

This method accepts a single argument, which is the node to remove.

The removed node is then returned as the function value, as this example shows:

Remove first child

let formerFirstChild = someNode.removeChild(someNode.firstChild);

remove last child.

let formerLastChild = someNode.removeChild(someNode.lastChild);

A node removed via <i>removeChild</i>() is still owned by the document but
doesn't have a specific location in the document.

To use the above method you must know the immediate parent node,
which is accessible via the <i>parentNode</i> property.

Not all node types can have child nodes, and these methods will throw errors
if you attempt to use them on nodes that don't support children.

<h2>DOM Clone Node</h2>

DOM <i>cloneNode</i>() method creates an exact clone of the node on which it's called.

The <i>cloneNode</i>() method accepts a single Boolean argument indicating whether to do a deep copy.

When the argument is true, a deep copy is used, cloning
the node and its entire subtree; when false, only the initial node is cloned.

The cloned node that
is returned is owned by the document but has no parent node assigned.

The cloned node is
an orphan and doesn't exist in the document until added via <i>appendChild</i>(), <i>insertBefore</i>(), or
<i>replaceChild</i>().

For example, consider the following HTML:

&lt;ul>
  &lt;li>item 1&lt;/li>
  &lt;li>item 2&lt;/li>
  &lt;li>item 3&lt;/li>
&lt;/ul>

If a reference to this &lt;ul> element is stored in a variable named <i>myList</i>, 
the following code shows the two modes of the <i>cloneNode</i>() method:

Deep clone:

let deepList = myList.cloneNode(true);
console.log(deepList.childNodes.<b>length</b>);     

Shallow clone:

let shallowList = myList.cloneNode(false);
console.log(shallowList.childNodes.<b>length</b>);  

In this example, <i>deepList</i> is filled with a deep copy of <i>myList</i>.

This means <i>deepList</i> has three list
items, each of which contains text.

The variable <i>shallowList</i> contains a shallow copy of <i>myList</i>, so
it has no child nodes.

The <i>cloneNode</i>() method doesn't copy JavaScript properties that you
add to DOM nodes, such as event handlers.

This method copies only attributes and, optionally, child nodes.

Everything else is lost.

<h2>DOM Node normalize</h2>

The method <i>normalize</i>() deals with text nodes in a document subtree.

After DOM node manipulations, we can have text nodes 
that contain no text or text nodes that are siblings.

When <i>normalize</i>() is called on a
node, that node's descendants are searched for both of these circumstances.

If an empty text node is
found, it is removed; if text nodes are immediate siblings, they are joined into a single text node.

<h2>DOM Node Compare</h2>

We can use Node <i>isSameNode</i>() and <i>isEqualNode</i>() to help compare nodes.

Both methods accept a single node as an argument and return true if that node is the same as or
equal to the reference node.

Two nodes are the same when they reference the same object.

Two nodes are equal when they are of the same type and have properties that are equal 
(<i>nodeName</i>, <i>nodeValue</i>, and so on), and their attributes and 
<i>childNodes</i> properties are equivalent.

Here is an example:

let div1 = <b>document</b>.createElement("div");
div1.setAttribute("class", "box");

let div2 = <b>document</b>.createElement("div");
div2.setAttribute("class", "box");

console.log(div1.isSameNode(div1));   // true
console.log(div1.isEqualNode(div2));  // true
console.log(div1.isSameNode(div2));   // false

Here, two &lt;div> elements are created with the same attributes.

The two elements are equivalent to one another but are not the same.

<h2>DOM Node NodeIterator</h2>

The <b>NodeIterator</b> type can be created using the document.<i>createNodeIterator</i>() method. 

This method accepts the following four arguments:

<table>
<thead><tr><th>Parameter</th><th>   Description</th></tr></thead>
<tbody>
<tr><td>root</td><td>   The node in the tree that you want to start searching from.</td></tr>
<tr><td><i>whatToShow</i></td><td>   A numerical code indicating which nodes should be visited.</td></tr>
<tr><td>filter</td><td>   A NodeFilter object or a function indicating whether a particular node should be accepted or rejected.</td></tr>
<tr><td><i>entityReferenceExpansion</i></td><td>     A Boolean value indicating whether entity references should be expanded.    <br>   This has no effect in HTML pages because entity references are never expanded.</td></tr>
</tbody></table>
The <i>whatToShow</i> argument is a bit mask that determines which nodes to visit by applying one or more
filters.

Possible values for this argument are included as constants on the <b>NodeFilter</b> type as follows:

<table>
<thead><tr><th>Value</th><th>   Meaning</th></tr></thead>
<tbody>
<tr><td>NodeFilter.SHOW_ALL</td><td>   Show all node types.</td></tr>
<tr><td>NodeFilter.SHOW_ELEMENT</td><td>   Show element nodes.</td></tr>
<tr><td>NodeFilter.SHOW_ATTRIBUTE</td><td>   Show attribute nodes.                                    <br>   This can't actually be used because of the DOM structure.</td></tr>
<tr><td>NodeFilter.SHOW_TEXT</td><td>   Show text nodes.</td></tr>
<tr><td>NodeFilter.SHOW_CDATA_SECTION</td><td>   Show CData section nodes.      <br>   This is not used in HTML pages.</td></tr>
<tr><td>NodeFilter.SHOW_ENTITY_REFERENCE</td><td>   Show entity reference nodes.   <br>   This is not used in HTML pages.</td></tr>
<tr><td>NodeFilter.SHOW_ENTITY</td><td>   Show entity nodes.             <br>   This is not used in HTML pages.</td></tr>
<tr><td>NodeFilter.SHOW_PROCESSING_INSTRUCTION</td><td>   Show PI nodes.                 <br>   This is not used in HTML pages.</td></tr>
<tr><td>NodeFilter.SHOW_COMMENT</td><td>   Show comment nodes.</td></tr>
<tr><td>NodeFilter.SHOW_DOCUMENT</td><td>   Show document nodes.</td></tr>
<tr><td>NodeFilter.SHOW_DOCUMENT_TYPE</td><td>   Show document type nodes.</td></tr>
<tr><td>NodeFilter.SHOW_DOCUMENT_FRAGMENT</td><td>   Show document fragment nodes.  <br>   This is not used in HTML pages.</td></tr>
<tr><td>NodeFilter.SHOW_NOTATION</td><td>   Show notation nodes.           <br>   This is not used in HTML pages.</td></tr>
</tbody></table>
With the exception of NodeFilter.SHOW_ALL, you can combine multiple options using the bitwise OR operator, as shown in the following example:

let whatToShow = NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT;

The filter argument of <i>createNodeIterator</i>() can be used to specify a custom <b>NodeFilter</b>
object or a function that acts as a node filter.

A <b>NodeFilter</b> object has only one method, <i>acceptNode</i>(), which returns <b>NodeFilter.FILTER_ACCEPT</b> if the given node should be visited or 
<b>NodeFilter.FILTER_SKIP</b> if the given node should not be visited.

Because <b>NodeFilter</b> is an abstract type, it's not possible to create an instance of it.

Instead, just create an object with an <i>acceptNode</i>() method and pass the object into <i>createNodeIterator</i>().

The following code accepts only &lt;p> elements:

let filter = {
  acceptNode(node) {
    return node.tagName.toLowerCase() == "p" ?
         NodeFilter.FILTER_ACCEPT :
         NodeFilter.FILTER_SKIP;
  }
 };

let iterator = <b>document</b>.createNodeIterator(root, NodeFilter.SHOW_ELEMENT,
                                           filter, false);

The third argument can also be a function that takes the form of the <i>acceptNode</i>() method, as
shown in this example:

let filter = function(node) {
    return node.tagName.toLowerCase() == "p" ?
         NodeFilter.FILTER_ACCEPT :
         NodeFilter.FILTER_SKIP;
};

let iterator = <b>document</b>.createNodeIterator(root, NodeFilter.SHOW_ELEMENT,
                                           filter, false);

If no filter is required, the third argument should be set to null.

To create a simple <b>NodeIterator</b> that visits all node types, use the following code:

let iterator = <b>document</b>.createNodeIterator(<b>document</b>, NodeFilter.SHOW_ALL,
                                           null, false);

The two primary methods of <b>NodeIterator</b> are <i>nextNode</i>() and <i>previousNode</i>().

The <i>nextNode</i>()
method moves one step forward in the depth-first traversal of the DOM subtree, and <i>previousNode</i>() moves one step backward in the traversal.

When the <b>NodeIterator</b> is first created, an internal pointer points to the root, so the first call to <i>nextNode</i>() returns the root.

When the traversal has reached the last node in the DOM subtree, <i>nextNode</i>() returns null.

The <i>previousNode</i>() method works in a similar way.

When the traversal has reached the last node in the DOM subtree, after 
<i>previousNode</i>() has returned the root of the traversal, it will return null.

Consider the following HTML fragment:

&lt;div id="div1">
  &lt;p>&lt;b>Hello&lt;/b> world!&lt;/p>
  &lt;ul>
    &lt;li>List item 1&lt;/li>
    &lt;li>List item 2&lt;/li>
    &lt;li>List item 3&lt;/li>
  &lt;/ul>
&lt;/div>

Suppose that you would like to traverse all elements inside of the &lt;div> element.

This can be accomplished using the following code:

let div = <b>document</b>.getElementById("div1");
let iterator = <b>document</b>.createNodeIterator(div, NodeFilter.SHOW_ELEMENT,
                                           null, false);
let node = iterator.nextNode();
while (node !== null) {
  console.log(node.tagName);     // output the tag name
  node = iterator.nextNode();
}

The first call to <i>nextNode</i>() in this example returns the &lt;p> element.

Because <i>nextNode</i>() returns
null when it has reached the end of the DOM subtree, a while loop checks to see when null has been returned as it calls <i>nextNode</i>() each time through.

When this code is executed, logs are displayed with the following tag names:

This can be accomplished by using a filter, as shown in the following example:

let div = <b>document</b>.getElementById("div1");
let filter = function(node) {
 return node.tagName.toLowerCase() == "li" ?
   NodeFilter.FILTER_ACCEPT :
   NodeFilter.FILTER_SKIP;
};

let iterator = <b>document</b>.createNodeIterator(div, NodeFilter.SHOW_ELEMENT,
      filter, false);

let node = iterator.nextNode();
while (node !== null) {
    console.log(node.tagName);     // output the tag name
    node = iterator.nextNode();
}

In this example, only &lt;li> elements will be returned from the iterator.

The <i>nextNode</i>() and <i>previousNode</i>() methods work with NodeIterator's internal pointer in the
DOM structure, so changes to the structure are represented appropriately in the traversal.

<h2>DOM Node Tree Visitor</h2>

DOM traversals are a depth-first traversal of the DOM structure that allows
movement in at least two directions depending on the type being used.

<b>NodeIterator</b> and <b>TreeWalker</b> perform depth-first traversals of a
DOM structure given a certain starting point.

A traversal is rooted at a given node, and it cannot go any further up the DOM tree than the starting root.

Consider the following HTML page:

&lt;!DOCTYPE html>
&lt;html>
  &lt;head>
    &lt;title>Example&lt;/title>
  &lt;/head>
  &lt;body>
    &lt;p>&lt;b>Hello&lt;/b> world!&lt;/p>
  &lt;/body>
&lt;/html>

Any node can be the root of the traversals.

Suppose, for example, that the &lt;body> element is the traversal root.

The traversal can then visit the &lt;p> element, the &lt;b> element, and the two text nodes that
are descendants of &lt;body>.

The traversal can never reach the &lt;html> element, the &lt;head>
element, or any other node that isn't in the &lt;body> element's subtree.

A traversal that has its root at
document can access all of the nodes in document.

Starting at document and moving sequentially, the first node visited is document and the last node
visited is the text node containing  " world!" from the very last text node at the end of the document.

The traversal can be reversed to go back up the tree.

In that case, the first node visited is the text
node containing  " world!" and the last one visited is the document node itself.

Both <b>NodeIterator</b> and <b>TreeWalker</b> perform traversals in this manner.

<h2>DOM Node TreeWalker</h2>

<b>TreeWalker</b> has the same functionality as  <b>NodeIterator</b>, including
<i>nextNode</i>() and <i>previousNode</i>(), and adds the following methods to traverse a DOM structure in different directions:

<table>
<thead><tr><th>Method</th><th>   Description</th></tr></thead>
<tbody>
<tr><td><i>parentNode</i>()</td><td>   Travels to the current node's parent.</td></tr>
<tr><td><i>firstChild</i>()</td><td>   Travels to the first child of the current node.</td></tr>
<tr><td><i>lastChild</i>()</td><td>   Travels to the last child of the current node.</td></tr>
<tr><td><i>nextSibling</i>()</td><td>   Travels to the next sibling of the current node.</td></tr>
<tr><td><i>previousSibling</i>()</td><td>   Travels to the previous sibling of the current node.</td></tr>
</tbody></table>

the root to traverse from,
which node types to show,
a filter, and
a Boolean value indicating if entity references should be expanded.

Because
of these similarities, <b>TreeWalker</b> can always be used in place of <b>NodeIterator</b>, as in this example:

let div = <b>document</b>.getElementById("div1");
let filter = function(node) {
  return node.tagName.toLowerCase() == "li" ?
    NodeFilter.FILTER_ACCEPT :
    NodeFilter.FILTER_SKIP;
};

let walker = <b>document</b>.createTreeWalker(div, NodeFilter.SHOW_ELEMENT,
                                       filter, false);

let node = iterator.nextNode();
while (node !== null) {
  console.log(node.tagName);     // output the tag name
  node = iterator.nextNode();
}

In addition to NodeFilter.FILTER_ACCEPT and NodeFilter.FILTER_SKIP, there is NodeFilter.FILTER_REJECT.

When used with a <b>NodeIterator</b> object, NodeFilter.FILTER_SKIP and NodeFilter.FILTER_REJECT do the same thing: they skip over the node.

When used with a <b>TreeWalker</b> object, NodeFilter.FILTER_SKIP skips over the node and goes on to the next node in the subtree, whereas NodeFilter.FILTER_REJECT skips over that node and that node's entire subtree.

TreeWalker can move around the DOM structure.

Consider the following HTML fragment:

&lt;div id="div1">
  &lt;p>&lt;b>Hello&lt;/b> world!&lt;/p>
  &lt;ul>
    &lt;li>List item 1&lt;/li>
    &lt;li>List item 2&lt;/li>
    &lt;li>List item 3&lt;/li>
  &lt;/ul>
&lt;/div>

Instead of specifying filter, it's possible to get at the &lt;li> elements by navigating through the DOM tree using <b>TreeWalker</b>, as shown here:

let div = <b>document</b>.getElementById("div1");
let walker = <b>document</b>.createTreeWalker(div, 
                       NodeFilter.SHOW_ELEMENT, null, false);

walker.firstChild();   // go to &lt;p>
walker.nextSibling();  // go to &lt;ul>

let node = walker.firstChild();  // go to first &lt;li>
while (node !== null) {
  console.log(node.tagName);
  node = walker.nextSibling();
}

<b>TreeWalker</b> from above code is
returning only elements because of the second argument passed in to <i>createTreeWalker</i>().

The <b>TreeWalker</b> type also has a property called <i>currentNode</i> that indicates the node that was last
returned from the traversal via any of the traversal methods.

This property can also be set to change
where the traversal continues from when it resumes, as shown in this example:

let node = walker.nextNode();
console.log(node === walker.currentNode);  // true
walker.currentNode = <b>document</b>.body;        // change where to start from

Compared to <b>NodeIterator</b>, the <b>TreeWalker</b> type allows greater flexibility when traversing the DOM.

<h2>DOM Node Get and Set User Data</h2>

The <i>setUserData</i>() method assigns data to a node and accepts three arguments: 

the key to set,
the actual data, and
a handler function.

You can assign data to a node using the following code:

<b>document</b>.body.setUserData("name", "CSS", function() {});

You can then retrieve the information using <i>getUserData</i>() and passing in the same key, as
shown here:

let value = <b>document</b>.body.getUserData("name");

The handler function for <i>setUserData</i>() is called whenever the node with the data is cloned,
removed, renamed, or imported into another document.

It gives you the opportunity to determine
what should happen to the user data in each of those cases.

The handler function accepts five arguments: 

a number indicating the type of operation (1 for clone, 2 for import, 3 for delete, or 4 for rename),
the data key,
the data value,
the source node, and
the destination node.

The source node is null when the node is being deleted, and the destination node is null unless the node is being
cloned.

You can then determine how to store the data.

Here is an example:

let div = <b>document</b>.createElement("div");
div.setUserData("name", "CSS", function(operation, key, value, src, dest) {
  if (operation == 1) {
    dest.setUserData(key, value, function() {});  }
});

let newDiv = div.cloneNode(true);
console.log(newDiv.getUserData("name"));  // "CSS"

Here, a &lt;div> element is created and has some data assigned to it, including some user data.

When the element is cloned via <i>cloneNode</i>(), the handler function is called and the data is automatically
assigned to the clone.

When <i>getUserData</i>() is called on the clone, it returns the same value that
was assigned to the original.

<h2>DOM Using NodeList</h2>

NodeList object, NamedNodeMap and 
HTMLCollection are three important collections in DOM.

Each of these collections is considered "live".

They are updated when the document structure changes so they are always
showing the most accurate information.

In reality, all <b>NodeList</b> objects are queries that are run against the DOM document.

Any time you want to iterate over a NodeList, 
we should initialize a second variable with the <i>length</i>
and then compare the iterator to that variable, as shown in the following example:

let divs = <b>document</b>.getElementsByTagName("div");

for (let i = 0, len = divs.<b>length</b>; i &lt; len; ++i) {
    let div = <b>document</b>.createElement("div");
    <b>document</b>.body.appendChild(div);
}

In this example, a second variable, <i>len</i>, is initialized.

Because <i>len</i> contains a snapshot of <i>divs.length</i> at the time the loop began, 
it prevents the infinite loop.

Generally speaking, we should limit the number of times you interact with a NodeList.

Because a query
is run against the document each time, try to cache frequently used values retrieved from a <b>NodeList</b>.

<h2>DOM Node namespace properties and methods</h2>

The Node type includes the following namespace-specific properties:

<table>
<thead><tr><th>Property</th><th> Meaning</th></tr></thead>
<tbody>
<tr><td><i>localName</i></td><td>   The node name without the namespace prefix.</td></tr>
<tr><td><i>namespaceURI</i></td><td>The namespace URI of the node or null if not specified.</td></tr>
<tr><td><i>prefix</i></td><td>  The namespace prefix or null if not specified.</td></tr>
</tbody></table>
When a node uses a namespace prefix, the <i>nodeName</i> is equivalent to <i>prefix</i> + ":" + <i>localName</i>.

Consider the following example:

&lt;html xmlns="http://www.w3.org/1999/xhtml">
 &lt;head>
   &lt;title>Example XHTML page&lt;/title>
 &lt;/head>
 &lt;body>
   &lt;s:svg xmlns:s="http://www.w3.org/2000/svg" version="1.1"
      viewBox="0 0 100 100" style="width:100%; height:100%">
     &lt;s:rect x="0" y="0" width="100" height="100" style="fill:red" />
   &lt;/s:svg>
 &lt;/body>
&lt;/html>

For the &lt;html> element, the <i>localName</i> and <i>tagName</i> is  "html", 
the <i>namespaceURI</i> is  "http://www.w3.org/1999/xhtml", and the <i>prefix</i> is null. 

For the &lt;s:svg> element, the <i>localName</i> is  "svg", the <i>tagName</i> is  "s:svg", 
the <i>namespaceURI</i> is  "http://www.w3.org/2000/svg", and the prefix is  "s".

DOM Level 3 introduces the following methods to work with namespaces:

<table>
<thead><tr><th>Method</th><th>   Meaning</th></tr></thead>
<tbody>
<tr><td><i>isDefaultNamespace</i>(namespaceURI)</td><td>   Returns true when the specified <i>namespaceURI</i> is the default namespace for the node.</td></tr>
<tr><td><i>lookupNamespaceURI</i>(prefix )</td><td>   Returns the namespace URI for the given prefix.</td></tr>
<tr><td><i>lookupPrefix</i>(namespaceURI)</td><td>   Returns the prefix for the given <i>namespaceURI</i>.</td></tr>
</tbody></table>
In the previous example, the following code can be executed:

console.log(<b>document</b>
             .body
             .isDefaultNamespace("http://www.w3.org/1999/xhtml"));// true

// assume svg contains a reference to &lt;s:svg>
console.log(svg.lookupPrefix("http://www.w3.org/2000/svg"));  // "s"
console.log(svg.lookupNamespaceURI("s"));  // "http://www.w3.org/2000/svg"

These methods are useful when you have a reference to a node without knowing its 
relationship to the rest of the document.

<h2>DOM Working with the Document Object</h2>

You access the <b>Document</b> object through the global <i>document</i> variable;
this is one of the key objects that the browser creates for us.

The <b>Document</b> object provides you with information about the document
as a whole and gives you access to the individual objects in the model.

The following example demonstrates some basic DOM features.

&lt;p id="myId">
    test&lt;span id="mySpan">mySpan&lt;/span>test
&lt;/p>
&lt;p id="LEGO">
    This is a test.
&lt;/p>
&lt;script>
    <b>document</b>.writeln("&lt;pre>URL: " + <b>document</b>.URL);
    let elems = <b>document</b>.getElementsByTagName("p");
    for (let i = 0; i &lt; elems.<b>length</b>; i++) {
        <b>document</b>.writeln("Element ID: " + elems[i].id);
        elems[i].style.border = "medium double black";
        elems[i].style.padding = "4px";
    }
    <b>document</b>.write("&lt;/pre>");
&lt;/script>

<iframe onload="resizeIframe(this)" style="border:1px solid #f1f1f1;margin:10px 0 10px 0;background-color:#ffffff;" frameborder="0" seamless width="100%" height="350" src="javascript-dom-working-with-the-document-object-demo-d2837.htm"></iframe><br><a href="javascript-dom-working-with-the-document-object-demo-d2837.htm">Open in separate window</a><br><a type="button" data-toggle="collapse" style="padding:2px;" role="button" aria-expanded="false" aria-controls="IAO" href="#IAO">View full source code</a>

&lt;html>
    &lt;body>
        &lt;p <b>id</b>="myId">
            test&lt;span <b>id</b>="mySpan">mySpan&lt;/span>test
        &lt;/p>
        &lt;p <b>id</b>="LEGO">
            This is a test.
        &lt;/p>
        &lt;script>
            <b>document</b>.writeln("&lt;pre>URL: " + <b>document</b>.URL);
            let elems = <b>document</b>.getElementsByTagName("p");
            for (let i = 0; i &lt; elems.length; i++) {
                <b>document</b>.writeln("Element ID: " + elems[i].<b>id</b>);
                elems[i].style.<font color="black"><b>border</b></font> = "medium double black";
                elems[i].style.<font color="black"><b>padding</b></font> = "4px";
            }&lt;!--  w  w   w.    d  e m   o  2  s  .  c o   m-->
            <b>document</b>.write("&lt;/pre>");
        &lt;/script>
    &lt;/body>
&lt;/html>

<script>function resizeIframe(iframe) {let h = iframe.contentWindow.document.body.scrollHeight;if (h<200){h=220;}iframe.style.height = h + 'px'; console.log(h + 'px');}</script>
The <b>Document</b> object captures information about the HTML document
that we are working with.

The first line in the script does just that:

<b>document</b>.writeln("&lt;pre>URL: " + <b>document</b>.URL);

In this case, we have read the value of the <i>document.URL</i> property,
which returns the URL of the current document.

This is the URL that the browser used to load the document in which the script is running.

The statement also calls the writeln method:

<b>document</b>.writeln("&lt;pre>URL: " + <b>document</b>.URL);

This method appends content to the end of the HTML document.

In this case, we have written the
opening tag of a pre element and the value of the URL property.

This is a very simple example of
modifying the DOM, meaning that I have changed the structure of the document.

Next, we select some elements from the document:

let elems = <b>document</b>.getElementsByTagName("p");

There is a range of methods for selecting elements.

The <i>getElementsByTagName</i> selects all of the elements of a
given type, in this case, &lt;p> elements.

Any &lt;p> elements that are contained in the document are returned
from the method and placed in the variable called <i>elems</i>.

All elements are represented by the <b>HTMLElement</b> object, which provides the basic functionality
to represent HTML elements.

The result from the <i>getElementsByTagName</i> method is a collection
of <b>HTMLElement</b> objects.

Now that we have a collection of <b>HTMLElement</b> objects to work with, we use a
for loop to enumerate the contents of the collection and process each &lt;p> element that the browser has
found in the HTML document:

for (let i = 0; i &lt; elems.<b>length</b>; i++) {
    <b>document</b>.writeln("Element ID: " + elems[i].id);
    elems[i].style.border = "medium double black";
    elems[i].style.padding = "4px";
}

For each <b>HTMLElement</b> in the collection, we read the <i>id</i> property to get
the value of the  <i>id</i> attribute and use the <i>document.writeln</i> method to append the result to the contents of the <i>pre</i> element
 that we started earlier:

for (let i = 0; i &lt; elems.<b>length</b>; i++) {
    <b>document</b>.writeln("Element ID: " + elems[i].id);
    elems[i].style.border = "medium double black";
    elems[i].style.padding = "4px";
}

The <i>id</i> property is one of a number of properties defined by <b>HTMLElement</b>.

You can use these properties to obtain information about an element or to
modify it.

In this case, we have used the style
property to change the value of the CSS border and padding properties:

for (let i = 0; i &lt; elems.<b>length</b>; i++) {
    <b>document</b>.writeln("Element ID: " + elems[i].id);
    elems[i].style.border = "medium double black";
    elems[i].style.padding = "4px";
}

These changes create an inline style for each of the elements that you found using the
<i>getElementsByTagName</i> earlier.

When you change an object, the
browser applies the change to the corresponding element immediately, in this case, by adding padding
 and a border to the &lt;p> elements.

The last line of the script writes the end tag for the &lt;pre> element that we opened back at the start of the
script.

We use the write method to do this, which is just like writeln but doesn't append end-of-line
 characters to the string that is added to the document.

The use of the &lt;pre> element means that the end-of-line characters added by the writeln method will
be used to structure the content.

<h2>DOM Document Quick Reference</h2>

<h3>The Document Members</h3>
The following table summarizes the members from Document object.

<table>
<thead><tr><th>Name</th><th>   Description</th><th>   Returns</th></tr></thead>
<tbody>
<tr><td>activeElement</td><td>   Returns an object representing the currently<br>   focused element in the document.            </td><td>   HTMLElement</td></tr>
<tr><td>    <br>body</td><td>   Returns an object representing the body<br>   element in the document.               </td><td>              <br>   HTMLElement</td></tr>
<tr><td>characterSet</td><td>   Returns the document character set     <br>   encoding. This is a read-only property.</td><td>   string</td></tr>
<tr><td>charset</td><td>   Gets or sets the document character set<br>   encoding.                              </td><td>   string</td></tr>
<tr><td>childNodes</td><td>   Returns the set of child elements.</td><td>   HTMLElement[]</td></tr>
<tr><td><i>compatMode</i></td><td>   Gets compatibility mode for the document.</td><td>   string</td></tr>
<tr><td>cookie</td><td>   Gets or sets the cookies for the current<br>     document.                             </td><td>   string</td></tr>
<tr><td><i>defaultCharset</i></td><td>     Gets the default character encoding used by<br>   the browser.                                 </td><td>   string</td></tr>
<tr><td>defaultView</td><td>    Returns the Window object for the current<br>   document.                                 </td><td>   Window</td></tr>
<tr><td>dir</td><td>    Gets or sets the text direction for the<br>   document.                               </td><td>   string</td></tr>
<tr><td>      <br>domain</td><td>   Gets or sets the domain for the current<br>   document.                              </td><td>         <br>   string</td></tr>
<tr><td>embeds</td><td>   Returns objects representing all the embed<br>   elements in the document.                 </td><td>   HTMLCollection</td></tr>
<tr><td>firstChild</td><td>   Returns the first child element of an element.</td><td>   HTMLElement</td></tr>
<tr><td>forms</td><td>   Returns objects representing all the form<br>   elements in the document.                </td><td>   HTMLCollection</td></tr>
<tr><td>                    <br><i>getElementById</i>(&lt;id>)</td><td>   Returns the element with the specified id<br>   value.                                   </td><td>              <br>   HTMLElement</td></tr>
<tr><td><i>getElementsByClassName</i>(&lt;class>)</td><td>     Returns the elements with the specified class<br>   value.                                         </td><td>   HTMLElement[]</td></tr>
<tr><td>                         <br><i>getElementsByName</i>(&lt;name>)</td><td>   Returns the elements with the specified name<br>   value.                                      </td><td>                <br>   HTMLElement[]</td></tr>
<tr><td><i>getElementsByTagName</i>(&lt;tag>)</td><td>   Returns the elements of the specified type.</td><td>   HTMLElement[]</td></tr>
<tr><td><i>hasChildNodes</i>()</td><td>   Returns true if the current element has child<br>   elements.                                    </td><td>   boolean</td></tr>
<tr><td>head</td><td>   Returns an object representing the head<br>   element.                               </td><td>   HTMLHeadElement</td></tr>
<tr><td>images</td><td>   Returns objects representing all the img<br>       elements.                           </td><td>   HTMLCollection</td></tr>
<tr><td>implementation</td><td>   Provides information about the DOM features<br>    that are available.                       </td><td>   DOMImplementation</td></tr>
<tr><td>lastChild</td><td>   Returns the last child element.</td><td>   HTMLElement</td></tr>
<tr><td>lastModified</td><td>    Returns the last modified time of the<br>   document.                             </td><td>   string</td></tr>
<tr><td>links</td><td>   Returns objects representing all the a and   <br>    area elements in the document that have href<br>      attributes.                               </td><td>   HTMLCollection</td></tr>
<tr><td>location</td><td>   Provides information about the URL of the<br>   current document.                        </td><td>   Location</td></tr>
<tr><td>nextSibling</td><td>   Returns the sibling element defined after the<br>   current element.                             </td><td>   HTMLElement</td></tr>
<tr><td>parentNode</td><td>   Returns the parent element.</td><td>   HTMLElement</td></tr>
<tr><td>               <br>previousSibling</td><td>   Returns the sibling element defined before<br>   the current element.                      </td><td>              <br>   HTMLElement</td></tr>
<tr><td>                         <br><i>querySelector</i>(&lt;selector>)</td><td>   Returns the first element that matches the<br><br>   specified CSS selector.                   </td><td>              <br>   HTMLElement</td></tr>
<tr><td><i>querySelectorAll</i>(&lt;selector>)</td><td>    Returns all of the elements that match the<br>   specified CSS selector.                    </td><td>   HTMLElement[]</td></tr>
<tr><td>readyState</td><td>   Returns the state of the current document.</td><td>   string</td></tr>
<tr><td>referrer</td><td>    Returns the URL of the document that linked <br>   to the current document (this is the value of<br>    the corresponding HTTP header).             </td><td>   string</td></tr>
<tr><td>scripts</td><td>   Returns objects representing all the script<br>     elements.                                </td><td>   HTMLCollection</td></tr>
<tr><td>title</td><td>   Gets or sets the title of the current document.</td><td>   string</td></tr>
</tbody></table>

<h2>DOM Working with Document Metadata</h2>

<b>Document</b> object provides you with information  about the document.

The following table describes the properties you can use to get document metadata.

<table>
<thead><tr><th>Property</th><th>   Description</th><th>   Returns</th></tr></thead>
<tbody>
<tr><td><i>characterSet</i></td><td>    Returns the document character set encoding. This is a<br>   read-only property.                                    </td><td>   string</td></tr>
<tr><td>charset</td><td>   Gets or sets the document character set encoding.</td><td>   string</td></tr>
<tr><td><i>compatMode</i></td><td>   Gets the compatibility mode for the document.</td><td>   string</td></tr>
<tr><td>cookie</td><td>   Gets or sets the cookies for the current document.</td><td>   string</td></tr>
<tr><td><i>defaultCharset</i></td><td>   Gets the default character encoding used by the browser.</td><td>   string</td></tr>
<tr><td><i>defaultView</i></td><td>   Returns the Window object for the current document</td><td>   Window</td></tr>
<tr><td>dir</td><td>   Gets or sets the text direction for the document.</td><td>   string</td></tr>
<tr><td>domain</td><td>   Gets or sets the domain for the current document.</td><td>   string</td></tr>
<tr><td>implementation</td><td>   Provides information about the DOM features that are<br>   available.                                          </td><td>   DOMImplementation</td></tr>
<tr><td><i>lastModified</i></td><td>     Returns the last modified time of the document (or the<br>   current time if no modification time is available).     </td><td>   string</td></tr>
<tr><td>location</td><td>   Provides information about the URL of the current<br>   document.                                        </td><td>   Location</td></tr>
<tr><td>readyState</td><td>   Returns the state of the current document. This is a read-<br>   only property.                                            </td><td>   string</td></tr>
<tr><td>referrer</td><td>   Returns the URL of the document that linked to the current<br>   document (this is the value of the corresponding HTTP     <br>   header).                                                  </td><td>   string</td></tr>
<tr><td>title</td><td>   Gets or sets  the title of the current document (the contents<br>   of the title element, described in Chapter 7).               </td><td>   string</td></tr>
</tbody></table>
<h3>Getting Information from the Document</h3>
You can get some useful information about the document using the metadata properties.

Using the Document Object to Obtain Metadata.

<b>document</b>.writeln("characterSet: " + <b>document</b>.characterSet);
<b>document</b>.writeln("charset: " + <b>document</b>.charset);
<b>document</b>.writeln("compatMode: " + <b>document</b>.compatMode);
<b>document</b>.writeln("defaultCharset: " + <b>document</b>.defaultCharset);
<b>document</b>.writeln("dir: " + <b>document</b>.dir);
<b>document</b>.writeln("domain: " + <b>document</b>.domain);
<b>document</b>.writeln("lastModified: " + <b>document</b>.lastModified);
<b>document</b>.writeln("referrer: " + <b>document</b>.referrer);
<b>document</b>.writeln("title: " + <b>document</b>.title);

<iframe onload="resizeIframe(this)" style="border:1px solid #f1f1f1;margin:10px 0 10px 0;background-color:#ffffff;" frameborder="0" seamless width="100%" height="350" src="javascript-dom-working-with-document-metadata-demo-e5131.htm"></iframe><br><a href="javascript-dom-working-with-document-metadata-demo-e5131.htm">Open in separate window</a><br><a type="button" data-toggle="collapse" style="padding:2px;" role="button" aria-expanded="false" aria-controls="ULS" href="#ULS">View full source code</a>

&lt;html>
    &lt;body>
        &lt;script>
            <b>document</b>.writeln("&lt;pre>");

            <b>document</b>.writeln("characterSet: " + <b>document</b>.characterSet);
            <b>document</b>.writeln("charset: " + <b>document</b>.charset);
            <b>document</b>.writeln("compatMode: " + <b>document</b>.compatMode);
            <b>document</b>.writeln("defaultCharset: " + <b>document</b>.defaultCharset);
            <b>document</b>.writeln("dir: " + <b>document</b>.dir);
            <b>document</b>.writeln("domain: " + <b>document</b>.domain);
            <b>document</b>.writeln("lastModified: " + <b>document</b>.lastModified);
            <b>document</b>.writeln("referrer: " + <b>document</b>.referrer);
            <b>document</b>.writeln("title: " + <b>document</b>.title);

            <b>document</b>.write("&lt;/pre>");
        &lt;/script>
    &lt;/body>
&lt;/html>

<script>function resizeIframe(iframe) {let h = iframe.contentWindow.document.body.scrollHeight;if (h<200){h=220;}iframe.style.height = h + 'px'; console.log(h + 'px');}</script>
These properties provide you with some useful insights into the document that you are working
with.

You can see the values for these properties.

<h2>Using the Location Object to Navigate Elsewhere</h2>

You can also use the  <b>Location</b> object available through the document.location property to navigate
else where.

There are a couple of different ways of doing this.

First, you can assign a new value to one of the properties.

Navigating to a Document by Assigning a New Value to a Location Property.

<b>document</b>.<b>location</b>.href = "https://demo2s.com";

<iframe onload="resizeIframe(this)" style="border:1px solid #f1f1f1;margin:10px 0 10px 0;background-color:#ffffff;" frameborder="0" seamless width="100%" height="350" src="javascript-using-the-location-object-to-navigate-elsewhere-demo-75a92.htm"></iframe><br><a href="javascript-using-the-location-object-to-navigate-elsewhere-demo-75a92.htm">Open in separate window</a><br><a type="button" data-toggle="collapse" style="padding:2px;" role="button" aria-expanded="false" aria-controls="LUZ" href="#LUZ">View full source code</a>

&lt;html>
    &lt;body>
        &lt;p>
            This is a test.
        &lt;/p>
        &lt;button <b>id</b>="pressme">Press Me&lt;/button>
        &lt;p>
            This is a test.  Test Test Test Test.

        &lt;/p>
        &lt;script>
            <b>document</b>.getElementById("pressme").<b>onclick</b> = <b>function</b>() {
                <b>document</b>.location.href = "https://demo2s.com";
            }
        &lt;/script>

    &lt;/body>
&lt;/html>

<script>function resizeIframe(iframe) {let h = iframe.contentWindow.document.body.scrollHeight;if (h<200){h=220;}iframe.style.height = h + 'px'; console.log(h + 'px');}</script>
This example contains a button element that, when clicked, causes a new value to be assigned to the
<i>document.location.href</i> property.

The association between the button and the JavaScript function that
will be executed when it is clicked is made using an event.

You can also use the  methods that the  Location object defines.

The difference between the <i>assign</i>() and <i>replace</i>() methods is that replace removes the
current document from the browser's history, meaning that when the user clicks the back button, for example,
the browser will skip over the current document, as though it had never been visited.

The following code shows the use of the assign method.

Navigating Using the assign Method of the Location Object.

<b>document</b>.<b>location</b>.<b>assign</b>("https://demo2s.com");

<iframe onload="resizeIframe(this)" style="border:1px solid #f1f1f1;margin:10px 0 10px 0;background-color:#ffffff;" frameborder="0" seamless width="100%" height="350" src="javascript-using-the-location-object-to-navigate-elsewhere-demo-927dd.htm"></iframe><br><a href="javascript-using-the-location-object-to-navigate-elsewhere-demo-927dd.htm">Open in separate window</a><br><a type="button" data-toggle="collapse" style="padding:2px;" role="button" aria-expanded="false" aria-controls="WWZ" href="#WWZ">View full source code</a>

&lt;html>
    &lt;body>
        &lt;button <b>id</b>="pressme">Press Me&lt;/button>
        &lt;script>
            <b>document</b>.getElementById("pressme").<b>onclick</b> = <b>function</b>() {
                <b>document</b>.location.assign("https://demo2s.com");
            }
        &lt;/script>
    &lt;/body>
&lt;/html>

<script>function resizeIframe(iframe) {let h = iframe.contentWindow.document.body.scrollHeight;if (h<200){h=220;}iframe.style.height = h + 'px'; console.log(h + 'px');}</script>
When the user clicks the  button element, the browser will navigate to the specified URL, which in
this case is https://demo2s.com.

<h2>Document Object Reading and Writing Cookies</h2>

The <i>cookie</i> property allows you to read, add to, and update the cookies associated with the document.

Reading and Creating Cookies.

function readCookies() {
    <b>document</b>.getElementById("cookiedata").innerHTML = <b>document</b>.cookie;
}

function createCookie() {
    cookieCount++;
    <b>document</b>.cookie = "Cookie_" + cookieCount + "=Value_" + cookieCount;
    readCookies();
}

function updateCookie() {
    <b>document</b>.cookie = "Cookie_" + cookieCount + "=Updated_" + cookieCount;
    readCookies();
}

<iframe onload="resizeIframe(this)" style="border:1px solid #f1f1f1;margin:10px 0 10px 0;background-color:#ffffff;" frameborder="0" seamless width="100%" height="350" src="javascript-document-object-reading-and-writing-cookies-demo-a80ba.htm"></iframe><br><a href="javascript-document-object-reading-and-writing-cookies-demo-a80ba.htm">Open in separate window</a><br><a type="button" data-toggle="collapse" style="padding:2px;" role="button" aria-expanded="false" aria-controls="ODQ" href="#ODQ">View full source code</a>

&lt;html>
    &lt;body>
        &lt;p <b>id</b>="cookiedata">

        &lt;/p>
        &lt;button <b>id</b>="write">Add Cookie&lt;/button>
        &lt;button <b>id</b>="update">Update Cookie&lt;/button>
        &lt;script>

            let cookieCount = 0;&lt;!--   ww   w   .d  e  m    o2   s  . c   o  m -->
            <b>document</b>.getElementById("update").<b>onclick</b> = updateCookie;
            <b>document</b>.getElementById("write").<b>onclick</b> = createCookie;
            readCookies();

            <b>function</b> readCookies() {
                <b>document</b>.getElementById("cookiedata").innerHTML =
                         <b>document</b>.cookie;
            }

            <b>function</b> createCookie() {
                cookieCount++;
                <b>document</b>.cookie =
                       "Cookie_" + cookieCount + "=Value_" + cookieCount;
                readCookies();
            }

            <b>function</b> updateCookie() {
                <b>document</b>.cookie =
                       "Cookie_" + cookieCount + "=Updated_" + cookieCount;
                readCookies();
            }
        &lt;/script>
    &lt;/body>
&lt;/html>

<script>function resizeIframe(iframe) {let h = iframe.contentWindow.document.body.scrollHeight;if (h<200){h=220;}iframe.style.height = h + 'px'; console.log(h + 'px');}</script>
The <i>cookie</i> property works in a slightly odd way.

When you read the value of the property, you get
back all of the cookies that are associated with the document.Cookies are name/value pairs in the form
name=value.

If multiple cookies are available, all are returned as the result of the <i>cookie</i> property,
separated by a semicolon, for example: name1=value1;name2=value2.

By contrast, when you want to create a new cookie, you assign a new name/value pair as the value of
the cookie property, and it is added to the set of cookies for the document.

You can set only one cookie at a time.

If you set a value whose name portion corresponds to an existing cookie, then the value
portion is used to update the cookie.

To demonstrate this, the code above contains a script that reads, creates, and updates cookies.

The <i>readCookies</i>() function reads the value of the <i>document.cookie</i> property and sets the result as the content
of a paragraph (p) element.

There are two button elements in the document.

When the Add Cookie button is clicked, the
<i>createCookie</i>() function assigns a new value to the cookie property, which will be added to the cookie
collection.

The Update Cookie button causes the <i>updateCookie</i>() function to be invoked.

This function
provides a new value for an existing cookie.

Although the  name=value form is the default for adding cookies, you can apply some additional data that
changes the way the cookie is handled.

These additions are described in the following table.

The Additional Fields That Can Be Added to a Cookie.

<table>
<thead><tr><th>Addition</th><th>   Description</th></tr></thead>
<tbody>
<tr><td>path=&lt;path></td><td>   Sets the path associated with the cookie; this default to the path of the current document if not specified.</td></tr>
<tr><td>domain=&lt;domain></td><td>   Sets the domain associated with the cookie; this defaults to the domain of the current document if not specified.</td></tr>
<tr><td>max-age=&lt;seconds></td><td>   Sets the life of the cookie in terms of the number of seconds from the moment it was created.</td></tr>
<tr><td>expires=&lt;date></td><td>   Sets the life of the cookie using a GMT-format date.</td></tr>
<tr><td>secure</td><td>   The cookie will be sent only over a secure (HTTPS) connection.</td></tr>
</tbody></table>
Each of these additional items is prepended to the name/value pair and separated with a semicolon,
like this:

<b>document</b>.cookie = "MyCookie=MyValue;max-age=10";

<h2>Document Object Getting DOM Implementation Details</h2>

The <i>document.implementation</i> property provides you with information about the browser
implementation of the DOM features.

This property returns a <b>DOMImplementation</b> object, which has one
method that you are interested in: the <i>hasFeature</i> method.

You can use this method to determine which
DOM features are implemented.

Using the document.implementation.<i>hasFeature</i>() Method.

let features = ["Core", "HTML", "CSS", "Selectors-API"];
let levels = ["1.0", "2.0", "3.0"];

<b>document</b>.writeln("&lt;pre>");
for (let i = 0; i &lt; features.<b>length</b>; i++) {
    <b>document</b>.writeln("Checking for feature: " + features[i]);
    for (let j = 0; j &lt; levels.<b>length</b>; j++) {
        <b>document</b>.write(features[i] + " Level " + levels[j] + ": ");
        <b>document</b>.writeln(<b>document</b>.implementation.hasFeature(features[i],
            levels[j]));
    }
}
<b>document</b>.write("&lt;/pre>")

<iframe onload="resizeIframe(this)" style="border:1px solid #f1f1f1;margin:10px 0 10px 0;background-color:#ffffff;" frameborder="0" seamless width="100%" height="350" src="javascript-document-object-getting-dom-implementation-details-demo-421db.htm"></iframe><br><a href="javascript-document-object-getting-dom-implementation-details-demo-421db.htm">Open in separate window</a><br><a type="button" data-toggle="collapse" style="padding:2px;" role="button" aria-expanded="false" aria-controls="CZI" href="#CZI">View full source code</a>

&lt;html>
    &lt;body>
        &lt;script>

            let features = ["Core", "HTML", "CSS", "Selectors-API"];
            let levels = ["1.0", "2.0", "3.0"];

            <b>document</b>.writeln("&lt;pre>");
            for (let i = 0; i &lt; features.length; i++) {
                <b>document</b>.writeln("Checking for feature: " + features[i]);
                for (let j = 0; j &lt; levels.length; j++) {
                    <b>document</b>.write(features[i] + " Level " + levels[j] + ": ");
                    <b>document</b>.writeln(
                      <b>document</b>.implementation.hasFeature(features[i],
                        levels[j]));&lt;!--  w w   w .    de   m o   2  s .    c o  m -->
                }
            }
            <b>document</b>.write("&lt;/pre>")
        &lt;/script>
    &lt;/body>
&lt;/html>

<script>function resizeIframe(iframe) {let h = iframe.contentWindow.document.body.scrollHeight;if (h<200){h=220;}iframe.style.height = h + 'px'; console.log(h + 'px');}</script>
This script checks some of the different DOM features and the defined feature levels.

This isn't as useful as it might appear.

First, browsers don't always report the features they implement correctly.

Some implement features but don't report them through the <i>hasFeature</i>() method, and others claim to
implement features but don't.

Second, a browser reporting that a feature doesn't mean that it is
implemented in a useful way.

<h2>Obtaining HTML Element Objects as HTMLCollection</h2>

We can use the following Element Properties of the Document Object to get elements from
document.

<table>
<thead><tr><th>Property</th><th>   Description</th><th>   Returns</th></tr></thead>
<tbody>
<tr><td>activeElement</td><td>   Returns an object representing the currently focused<br>   element                                             </td><td>   HTMLElement</td></tr>
<tr><td>body</td><td>   Returns an object representing the body element</td><td>   HTMLElement</td></tr>
<tr><td>embeds <br>plugins</td><td>   Returns objects representing all the embed elements</td><td>   HTMLCollection</td></tr>
<tr><td>forms</td><td>   Returns objects representing all the form elements</td><td>   HTMLCollection</td></tr>
<tr><td>head</td><td>   Returns an object representing the head element</td><td>   HTMLHeadElement</td></tr>
<tr><td>images</td><td>   Returns objects representing all the img elements</td><td>   HTMLCollection</td></tr>
<tr><td>links</td><td>   Returns objects representing all the a and area elements in<br>      the document that have href attributes                  </td><td>   HTMLCollection</td></tr>
<tr><td>scripts</td><td>   Returns objects representing all the script elements</td><td>   HTMLCollection</td></tr>
</tbody></table>
Most of the properties described in table return an <b>HTMLCollection</b> object.

This is the way that the DOM represents a collection of objects that represent elements.

The following code demonstrates the two
ways in which you can access the objects contained in the <b>HTMLCollection</b> Object.

let resultsElement = <b>document</b>.getElementById("results");

let elems = <b>document</b>.images;

for (let i = 0; i &lt; elems.<b>length</b>; i++) {
    resultsElement.innerHTML += "Image Element: " + elems[i].id + "\n";
}

let srcValue = elems.namedItem("myId3").src;
resultsElement.innerHTML += "Src for myId3 element is: " + srcValue + "\n";

<iframe onload="resizeIframe(this)" style="border:1px solid #f1f1f1;margin:10px 0 10px 0;background-color:#ffffff;" frameborder="0" seamless width="100%" height="350" src="javascript-obtaining-html-element-objects-as-htmlcollection-demo-33184.htm"></iframe><br><a href="javascript-obtaining-html-element-objects-as-htmlcollection-demo-33184.htm">Open in separate window</a><br><a type="button" data-toggle="collapse" style="padding:2px;" role="button" aria-expanded="false" aria-controls="TBL" href="#TBL">View full source code</a>

&lt;html>
    &lt;head>
        &lt;style>
            pre {<font color="black"><b>border</b></font>: medium double black;}
        &lt;/style>
    &lt;/head>
    &lt;body>
        &lt;pre <b>id</b>="results">&lt;/pre>
        &lt;img <b>id</b>="js" src="javascript.png" alt="javascript"/>
        &lt;p>
            This is a test.
        &lt;/p>
        &lt;img <b>id</b>="myId3" src="html.png" alt="myId3"/>
        &lt;p>
            This is a test.  Test Test Test Test.

        &lt;/p>
        &lt;img <b>id</b>="myImage" src="css.png" alt="css"/>
        &lt;script>
            let resultsElement = <b>document</b>.getElementById("results");

            let elems = <b>document</b>.images;

            for (let i = 0; i &lt; elems.length; i++) {
                resultsElement.innerHTML +=
                           "Image Element: " + elems[i].<b>id</b> + "\n";
            }&lt;!-- w   w   w .   d  em    o  2s  .    co  m  -->

            let srcValue = elems.namedItem("myId3").src;
            resultsElement.innerHTML +=
                        "Src for myId3 element is: " + srcValue + "\n";
        &lt;/script>
    &lt;/body>
&lt;/html>

<script>function resizeIframe(iframe) {let h = iframe.contentWindow.document.body.scrollHeight;if (h<200){h=220;}iframe.style.height = h + 'px'; console.log(h + 'px');}</script>
The first way of working with an <b>HTMLCollection</b> is to treat it like an array.

The <i>length</i> property
returns the number of items in the collection, and the standard JavaScript array indexer is supported
(the element[i] notation) to provide direct access to individual objects in the collection.

This is the first approach we use in the example, having used the document.images
property to get an HTMLCollection containing object representing all of the &lt;img> elements in the document.

Notice that we used the <i>innerHTML</i> property to set the contents of the &lt;pre> element.

The second approach is to use the <i>namedItem</i>() method, which returns the item in the collection that
has the specified id or name attribute value (if there is one).

This is the second approach we use in the
example, where we use the <i>namedItem</i>() method to retrieve the object representing the  &lt;img> element with the
id attribute value.

Notice that we read the value of the <i>src</i> property on one of the objects.

This is a property that is implemented
by <b>HTMLImageElement</b> objects, which are used to represent &lt;img> elements.

The other property we use, <i>id</i>, is part of <b>HTMLElement</b> and so
is available for all types of element.

<h3>Using Array Notation to Obtain a Named Element</h3>
You can also use array-style notation to obtain an object representing a named element.

This is an element that has an <i>id</i> or <i>name</i> attribute value.

Obtaining Named Element Objects.

let resultsElement = <b>document</b>.getElementById("results");
let elems = <b>document</b>["html"];

if (elems.namedItem) {
    for (let i = 0; i &lt; elems.<b>length</b>; i++) {
        resultsElement.innerHTML += "Image Element: " + elems[i].id + "\n";
    }
} else {
    resultsElement.innerHTML += "Src for element is: " + elems.src + "\n";
}

<iframe onload="resizeIframe(this)" style="border:1px solid #f1f1f1;margin:10px 0 10px 0;background-color:#ffffff;" frameborder="0" seamless width="100%" height="350" src="javascript-obtaining-html-element-objects-as-htmlcollection-demo-06721.htm"></iframe><br><a href="javascript-obtaining-html-element-objects-as-htmlcollection-demo-06721.htm">Open in separate window</a><br><a type="button" data-toggle="collapse" style="padding:2px;" role="button" aria-expanded="false" aria-controls="LDK" href="#LDK">View full source code</a>

&lt;html>
    &lt;head>
        &lt;style>
            pre {<font color="black"><b>border</b></font>: medium double black;}
        &lt;/style>
    &lt;/head>
    &lt;body>
        &lt;pre <b>id</b>="results">&lt;/pre>
        &lt;img <b>id</b>="js" name="image" src="javascript.png" alt="js"/>
        &lt;p>
            This is a test.
        &lt;/p>
        &lt;img <b>id</b>="html" name="image" src="html.png" alt="html"/>
        &lt;p>
            This is a test.  Test Test Test Test.

        &lt;/p>
        &lt;img <b>id</b>="myImage" src="css.png" alt="css"/>
        &lt;script>
            let resultsElement = <b>document</b>.getElementById("results");
            let elems = <b>document</b>["html"];

            if (elems.namedItem) {&lt;!--  w   w w .  d  e    m  o 2  s .   c  o m  -->
                for (let i = 0; i &lt; elems.length; i++) {
                    resultsElement.innerHTML +=
                       "Image Element: " + elems[i].<b>id</b> + "\n";
                }
            } else {
                resultsElement.innerHTML +=
                    "Src for element is: " + elems.src + "\n";
            }
        &lt;/script>
    &lt;/body>
&lt;/html>

<script>function resizeIframe(iframe) {let h = iframe.contentWindow.document.body.scrollHeight;if (h<200){h=220;}iframe.style.height = h + 'px'; console.log(h + 'px');}</script>
You can see how we have used the array-style indexer to obtain an object representing the element
with an  id value.

An oddity of obtaining elements this way is that you can get different kinds of
results, depending on the contents of the document and the order of the elements.

The browser looks at all of the elements in the document in a depth-first order, trying to match
either the id or name attribute to the specified value.

If the first match is an  id attribute, then the browser
stops searching (because id values must be unique in documents) and returns an <b>HTMLElement</b>
representing the matched element.

If the first match is against a name attribute value, then you will receive either an <b>HTMLElement</b> (if
there is only one matching element) or an <b>HTMLCollection</b> (if there is more than one).

The browser won't match <i>id</i> values once it has started to match <i>name</i> values.

You can see how we use the  <i>namedItem</i> property as a test to see which kind of result we have received.

In the example we receive an <b>HTMLElement</b> because the value we specified matches an id value.

You can also refer to named elements as properties.

So, for example, <i>document['yourId']</i> and <i>document.yourId</i> have the same meaning.

We tend to prefer the dot-notation format because it makes it clearer that
we are trying to obtain element objects, but it is a matter of personal preference.

<h2>DOM Document Object Searching for Elements</h2>

The <b>Document</b> object defines a number of methods that you can use to search for elements in the
document.

These methods are described in the following table.

<table>
<thead><tr><th>Property</th><th>   Description</th><th>   Returns</th></tr></thead>
<tbody>
<tr><td><i>getElementById</i>(&lt;id>)</td><td>   Returns the element with the specified id<br>   value                                    </td><td>   HTMLElement</td></tr>
<tr><td><i>getElementsByClassName</i>(&lt;class>)</td><td>   Returns the elements with the specified class<br>   value                                        </td><td>   HTMLElement[]</td></tr>
<tr><td><i>getElementsByName</i>(&lt;name>)</td><td>   Returns the elements with the specified name<br>   value                                       </td><td>   HTMLElement[]</td></tr>
<tr><td><i>getElementsByTagName</i>(&lt;tag>)</td><td>   Returns the elements of the specified type</td><td>   HTMLElement[]</td></tr>
<tr><td><i>querySelector</i>(&lt;selector>)</td><td>   Returns the first element that matches the<br>   specified CSS selector                    </td><td>   HTMLElement</td></tr>
<tr><td><i>querySelectorAll</i>(&lt;selector>)</td><td>   Returns all of the elements that match the<br>   specified CSS selector                    </td><td>   HTMLElement[]</td></tr>
</tbody></table>
As you might expect, some of these methods return multiple elements.

In fact, these methods
return a NodeList, which is part of the underlying DOM specification that deals with generic structured
document formats and not just HTML.

However, for these purposes, you can treat them like arrays and
keep the focus on HTML5.

The search methods can be broken into two categories.

The following code demonstrates the first
of these categories-those methods whose name begins with <i>getElement</i>.

let resultsElement = <b>document</b>.getElementById("results");

let pElems = <b>document</b>.getElementsByTagName("p");
resultsElement.innerHTML += "There are " + pElems.<b>length</b> + " p elements\n";

let myClassElems = <b>document</b>.getElementsByClassName("myClass");
resultsElement.innerHTML += "There are " + myClassElems.<b>length</b>
    + " elements in the myClass class\n";

let nameElems = <b>document</b>.getElementsByName("myId");
resultsElement.innerHTML += "There are " + nameElems.<b>length</b>
    + " elements with the name 'myId'";

<iframe onload="resizeIframe(this)" style="border:1px solid #f1f1f1;margin:10px 0 10px 0;background-color:#ffffff;" frameborder="0" seamless width="100%" height="350" src="javascript-dom-document-object-searching-for-elements-demo-cf8e2.htm"></iframe><br><a href="javascript-dom-document-object-searching-for-elements-demo-cf8e2.htm">Open in separate window</a><br><a type="button" data-toggle="collapse" style="padding:2px;" role="button" aria-expanded="false" aria-controls="PPB" href="#PPB">View full source code</a>

&lt;html>
    &lt;head>
        &lt;style>
            pre {<font color="black"><b>border</b></font>: medium double black;}
        &lt;/style>
    &lt;/head>
    &lt;body>
        &lt;pre <b>id</b>="results">&lt;/pre>

        &lt;img <b>id</b>="js" class="myClass" name="myId" src="javascript.png" alt="js"/>
        &lt;p>
            This is a test.
        &lt;/p>
        &lt;img <b>id</b>="myId" class="myClass images"
             name="myId"  src="html.png" alt="myId"/>
        &lt;p>
            This is a test.  Test Test Test Test.

        &lt;/p>
        &lt;img <b>id</b>="myImage" src="css.png" alt="css"/>
        &lt;script>
            let resultsElement = <b>document</b>.getElementById("results");

            let pElems = <b>document</b>.getElementsByTagName("p");
            resultsElement.innerHTML +=&lt;!--  w w    w .   de   m   o 2  s   . c  o m  -->
                    "There are " + pElems.length + " p elements\n";

            let myClassElems = <b>document</b>.getElementsByClassName("myClass");
            resultsElement.innerHTML += "There are " + myClassElems.length
                + " elements in the myClass class\n";

            let nameElems = <b>document</b>.getElementsByName("myId");
            resultsElement.innerHTML += "There are " + nameElems.length
                + " elements with the name 'myId'";
        &lt;/script>
    &lt;/body>
&lt;/html>

<script>function resizeIframe(iframe) {let h = iframe.contentWindow.document.body.scrollHeight;if (h<200){h=220;}iframe.style.height = h + 'px'; console.log(h + 'px');}</script>
When using the <i>getElementById</i>() method, the browser will return null if no element can be found with the specified
<i>id</i> value.

By contrast, the other methods will always return an array of <b>HTMLElement</b> objects, but the
<i>length</i> property will return 0 to indicate no matches.

<h3>Searching with CSS Selectors</h3>
A useful alternative is to search using CSS selectors.

Selectors allow you to find a broader range of elements in the document.

Obtaining Element Objects Using CSS Selectors.

let resultsElement = <b>document</b>.getElementById("results");

let elems = <b>document</b>.querySelectorAll("p, img#myId")
resultsElement.innerHTML += "The selector matched " + elems.<b>length</b>
    + " elements\n";

<iframe onload="resizeIframe(this)" style="border:1px solid #f1f1f1;margin:10px 0 10px 0;background-color:#ffffff;" frameborder="0" seamless width="100%" height="350" src="javascript-dom-document-object-searching-for-elements-demo-bc74d.htm"></iframe><br><a href="javascript-dom-document-object-searching-for-elements-demo-bc74d.htm">Open in separate window</a><br><a type="button" data-toggle="collapse" style="padding:2px;" role="button" aria-expanded="false" aria-controls="XRR" href="#XRR">View full source code</a>

&lt;html>
    &lt;head>
        &lt;style>
            pre {<font color="black"><b>border</b></font>: medium double black;}
        &lt;/style>
    &lt;/head>
    &lt;body>
        &lt;pre <b>id</b>="results">&lt;/pre>
        &lt;img <b>id</b>="js"
             class="myClass"
             name="myId"
             src="javascript.png" alt="js"/>
        &lt;p>
            This is a test.
        &lt;/p>
        &lt;img <b>id</b>="myId"
             class="myClass images" name="myId"  src="html.png" alt="myId"/>
        &lt;p>
            This is a test.  Test Test Test Test.

        &lt;/p>
        &lt;img <b>id</b>="myImage" src="css.png" alt="css"/>
        &lt;script>
            let resultsElement = <b>document</b>.getElementById("results");

            let elems = <b>document</b>.querySelectorAll("p, img#myId")
            resultsElement.innerHTML += "The selector matched " + elems.length
                + " elements\n";
        &lt;/script>
    &lt;/body>
&lt;/html>&lt;!--  w w    w.  d   e   m o  2   s.    c  o  m-->

<script>function resizeIframe(iframe) {let h = iframe.contentWindow.document.body.scrollHeight;if (h<200){h=220;}iframe.style.height = h + 'px'; console.log(h + 'px');}</script>
In this example, we have used a selector that will match all &lt;p> elements and
the &lt;img> element that has an id value.

<h3>Chaining Searches Together</h3>
A nice DOM feature is that all but one of the search methods the  Document object implements are also
implemented by <b>HTMLElement</b> objects, allowing you to chain searches together.

The exception is the
<i>getElementById</i> method, which is available only through the Document object.

Chaining Searches Together.

let resultsElement = <b>document</b>.getElementById("results");

let elems = <b>document</b>.getElementById("tblock")
                  .getElementsByTagName("span");
resultsElement.innerHTML +=
   "There are " + elems.<b>length</b> + " span elements\n";

let elems2 = <b>document</b>.getElementById("tblock")
                     .querySelectorAll("span");
resultsElement.innerHTML += "There are " + elems2.<b>length</b>
    + " span elements (Mix)\n";

let selElems = <b>document</b>.querySelectorAll("#tblock > span");
resultsElement.innerHTML += "There are " + selElems.<b>length</b>
    + " span elements (CSS)\n";

<iframe onload="resizeIframe(this)" style="border:1px solid #f1f1f1;margin:10px 0 10px 0;background-color:#ffffff;" frameborder="0" seamless width="100%" height="350" src="javascript-dom-document-object-searching-for-elements-demo-1ddea.htm"></iframe><br><a href="javascript-dom-document-object-searching-for-elements-demo-1ddea.htm">Open in separate window</a><br><a type="button" data-toggle="collapse" style="padding:2px;" role="button" aria-expanded="false" aria-controls="STI" href="#STI">View full source code</a>

&lt;html>
    &lt;head>
        &lt;style>
            pre {<font color="black"><b>border</b></font>: medium double black;}
        &lt;/style>
    &lt;/head>
    &lt;body>
        &lt;pre <b>id</b>="results">&lt;/pre>
        &lt;p <b>id</b>="tblock">
            test&lt;!--   w w   w.   d  e   m o 2  s   .   c  om  -->
            &lt;span <b>id</b>="mySpan">mySpan&lt;/span>

            test&lt;span <b>id</b>="apple">LEGO&lt;/span>,
            &lt;span="orange">Star War&lt;/span>
        &lt;/p>
        &lt;script>
            let resultsElement = <b>document</b>.getElementById("results");

            let elems = <b>document</b>.getElementById("tblock")
                              .getElementsByTagName("span");
            resultsElement.innerHTML +=
               "There are " + elems.length + " span elements\n";

            let elems2 = <b>document</b>.getElementById("tblock")
                                 .querySelectorAll("span");
            resultsElement.innerHTML += "There are " + elems2.length
                + " span elements (Mix)\n";

            let selElems = <b>document</b>.querySelectorAll("#tblock > span");
            resultsElement.innerHTML += "There are " + selElems.length
                + " span elements (CSS)\n";

        &lt;/script>
    &lt;/body>
&lt;/html>

<script>function resizeIframe(iframe) {let h = iframe.contentWindow.document.body.scrollHeight;if (h<200){h=220;}iframe.style.height = h + 'px'; console.log(h + 'px');}</script>
There are two chained searches in this example, both of which we have started with the
<i>getElementById</i>() method which gives me a single object to work with.

In the first example, we chain a
search using the <i>getElementsByTagName</i> method, and in the second we use a very simple CSS selector
through the querySelectorAll method.

Each of these examples returns the collection of span elements
contained in the p element whose id is <i>tblock</i>.

<h2>DOM Element Navigating the DOM Tree</h2>

We can search for elements to treat the DOM like a tree and navigate its
hierarchical structure.

There are a set of properties and methods that are supported by all DOM objects
that let us do just that; they are described in the following table.

Tree navigation Properties and Methods.

<table>
<thead><tr><th>Property</th><th>   Description</th><th>   Returns</th></tr></thead>
<tbody>
<tr><td>childNodes</td><td>   Returns the set of child elements</td><td>   HTMLElement[]</td></tr>
<tr><td>firstChild</td><td>   Returns the first child element</td><td>   HTMLElement</td></tr>
<tr><td><i>hasChildNodes</i>()</td><td>   Returns true if the current element has child elements</td><td>   boolean</td></tr>
<tr><td>lastChild</td><td>   Returns the last child element</td><td>   HTMLElement</td></tr>
<tr><td>nextSibling</td><td>   Returns the sibling element defined after the current<br>   element                                              </td><td>   HTMLElement</td></tr>
<tr><td>parentNode</td><td>   Returns the parent element</td><td>   HTMLElement</td></tr>
<tr><td>previousSibling</td><td>   Returns the sibling element defined before the current<br>   element                                               </td><td>   HTMLElement</td></tr>
</tbody></table>
The following code shows a script that lets you navigate around the document, displaying information
about the currently selected element in a pre element.

Navigating the DOM Tree.

let resultsElem = <b>document</b>.getElementById("results");
let element = <b>document</b>.body;

let buttons = <b>document</b>.getElementsByTagName("button");
for (let i = 0; i &lt; buttons.<b>length</b>; i++) {
    buttons[i].onclick = handleButtonClick;
}

processNewElement(element);/*  w  ww    .d  e   m o    2 s  .   c  o m */

function handleButtonClick(e) {
    if (element.style) {
        element.style.backgroundColor = "white";
    }

    if (e.target.id == "parent" &amp;&amp; element != <b>document</b>.body) {
        element = element.parentNode;
    } else if (e.target.id == "child" &amp;&amp; element.hasChildNodes()) {
        element = element.firstChild;
    } else if (e.target.id == "prev" &amp;&amp; element.previousSibling) {
        element = element.previousSibling;
    } else if (e.target.id == "next" &amp;&amp; element.nextSibling) {
        element = element.nextSibling;
    }
    processNewElement(element);
    if (element.style) {
        element.style.backgroundColor = "lightgrey";
    }
}

function processNewElement(elem) {
    resultsElem.innerHTML = "Element type: " + elem + "\n";
    resultsElem.innerHTML += "Element id: " + elem.id + "\n";
    resultsElem.innerHTML += "Has child nodes: "
        + elem.hasChildNodes() + "\n";
    if (elem.previousSibling) {
        resultsElem.innerHTML += ("Prev sibling is: "
             + elem.previousSibling + "\n");
    } else {
        resultsElem.innerHTML += "No prev sibling\n";
    }
    if (elem.nextSibling) {
        resultsElem.innerHTML += "Next sibling is: "
            + elem.nextSibling + "\n";
    } else {
        resultsElem.innerHTML += "No next sibling\n";
    }
}

<iframe onload="resizeIframe(this)" style="border:1px solid #f1f1f1;margin:10px 0 10px 0;background-color:#ffffff;" frameborder="0" seamless width="100%" height="350" src="javascript-dom-element-navigating-the-dom-tree-demo-eb755.htm"></iframe><br><a href="javascript-dom-element-navigating-the-dom-tree-demo-eb755.htm">Open in separate window</a><br><a type="button" data-toggle="collapse" style="padding:2px;" role="button" aria-expanded="false" aria-controls="ZYH" href="#ZYH">View full source code</a>

&lt;html>
    &lt;head>
        &lt;style>
            pre {<font color="black"><b>border</b></font>: medium double black;}
        &lt;/style>
    &lt;/head>
    &lt;body>
        &lt;pre <b>id</b>="results">&lt;/pre>
        &lt;p <b>id</b>="tblock">
            test&lt;!--  w  w w    .d   e   m  o  2s    .c  o   m -->
            &lt;span <b>id</b>="mySpan">mySpan&lt;/span>
            test&lt;span <b>id</b>="apple">LEGO&lt;/span>,
            &lt;span="orange">Star War&lt;/span>
            test
        &lt;/p>
        &lt;img <b>id</b>="apple"
             class="myClass images" name="apple"  src="html.png" alt="apple"/>
        &lt;img <b>id</b>="myImage" src="css.png" alt="css"/>
        &lt;p>
            This is a test.  Test Test Test Test.
        &lt;/p>
        &lt;p>
            &lt;button <b>id</b>="parent">Parent&lt;/button>
            &lt;button <b>id</b>="child">First Child&lt;/button>
            &lt;button <b>id</b>="prev">Prev Sibling&lt;/button>
            &lt;button <b>id</b>="next">Next Sibling&lt;/button>
        &lt;/p>

        &lt;script>
            let resultsElem = <b>document</b>.getElementById("results");
            let element = <b>document</b>.body;

            let buttons = <b>document</b>.getElementsByTagName("button");
            for (let i = 0; i &lt; buttons.length; i++) {
                buttons[i].<b>onclick</b> = handleButtonClick;
            }

            processNewElement(element);

            <b>function</b> handleButtonClick(e) {
                if (element.style) {
                    element.style.backgroundColor = "white";
                }

                if (e.target.<b>id</b> == "parent" &amp;&amp; element != <b>document</b>.body) {
                    element = element.parentNode;
                } else if (e.target.<b>id</b> == "child" &amp;&amp; element.hasChildNodes()) {
                    element = element.firstChild;
                } else if (e.target.<b>id</b> == "prev" &amp;&amp; element.previousSibling) {
                    element = element.previousSibling;
                } else if (e.target.<b>id</b> == "next" &amp;&amp; element.nextSibling) {
                    element = element.nextSibling;
                }
                processNewElement(element);
                if (element.style) {
                    element.style.backgroundColor = "lightgrey";
                }
            }

            <b>function</b> processNewElement(elem) {
                resultsElem.innerHTML = "Element type: " + elem + "\n";
                resultsElem.innerHTML += "Element id: " + elem.<b>id</b> + "\n";
                resultsElem.innerHTML += "Has child nodes: "
                    + elem.hasChildNodes() + "\n";
                if (elem.previousSibling) {
                    resultsElem.innerHTML += ("Prev sibling is: "
                         + elem.previousSibling + "\n");
                } else {
                    resultsElem.innerHTML += "No prev sibling\n";
                }
                if (elem.nextSibling) {
                    resultsElem.innerHTML += "Next sibling is: "
                        + elem.nextSibling + "\n";
                } else {
                    resultsElem.innerHTML += "No next sibling\n";
                }
            }
        &lt;/script>
    &lt;/body>
&lt;/html>

<script>function resizeIframe(iframe) {let h = iframe.contentWindow.document.body.scrollHeight;if (h<200){h=220;}iframe.style.height = h + 'px'; console.log(h + 'px');}</script>

<h2>Obtaining a Window Object</h2>

You can get a Window object in two ways.

The official HTML5 way is to use the <i>defaultView</i> property on the <b>Document</b> object.

Another approach is to use the <i>window</i> global variable, which all of the browsers
support.

The following code demonstrates both techniques.

Obtaining a Window Object.

<b>document</b>.getElementById("owidth").innerHTML = <b>window</b>.<b>outerWidth</b>;
<b>document</b>.getElementById("oheight").innerHTML
    = <b>document</b>.defaultView.<b>outerHeight</b>;

<iframe onload="resizeIframe(this)" style="border:1px solid #f1f1f1;margin:10px 0 10px 0;background-color:#ffffff;" frameborder="0" seamless width="100%" height="350" src="javascript-obtaining-a-window-object-demo-2f63b.htm"></iframe><br><a href="javascript-obtaining-a-window-object-demo-2f63b.htm">Open in separate window</a><br><a type="button" data-toggle="collapse" style="padding:2px;" role="button" aria-expanded="false" aria-controls="VND" href="#VND">View full source code</a>

&lt;html>
    &lt;body <b>id</b>="bod">
        &lt;table>
            &lt;tr>&lt;th>outerWidth:&lt;/th>&lt;td <b>id</b>="owidth">&lt;/td>&lt;/tr>
            &lt;tr>&lt;th>outerHeight:&lt;/th>&lt;td <b>id</b>="oheight">&lt;/td>&lt;/tr>
        &lt;/table>

        &lt;script type="text/javascript">
            <b>document</b>.getElementById("owidth").innerHTML = window.outerWidth;
            <b>document</b>.getElementById("oheight").innerHTML
                = <b>document</b>.defaultView.outerHeight;
        &lt;/script>
    &lt;/body>
&lt;/html>

<script>function resizeIframe(iframe) {let h = iframe.contentWindow.document.body.scrollHeight;if (h<200){h=220;}iframe.style.height = h + 'px'; console.log(h + 'px');}</script>
In the script we use the <b>Window</b> object to read the value of a pair of properties,
<i>outerWidth</i> and <i>outerHeight</i>.

<h3>Getting Information about the Window</h3>
The basic functionality of the Window object relates to the window in which the
document is currently displayed.

The following table lists the properties and methods that handle this functionality.

For the purposes of HTML, tabs within a browser window are treated as windows in their
own right.

<table>
<thead><tr><th>Name</th><th>   Description</th><th>   Returns</th></tr></thead>
<tbody>
<tr><td>innerHeight</td><td>   Gets the height of the window content area</td><td>   number</td></tr>
<tr><td>innerWidth</td><td>   Gets the width of the window content area</td><td>   number</td></tr>
<tr><td>outerHeight</td><td>    Gets the height of the window, including borders, menu bars, and<br>   so on                                                            </td><td>   number</td></tr>
<tr><td>outerWidth</td><td>   Gets the width of the window, including borders, menu bars, and<br>   so on                                                          </td><td>   number</td></tr>
<tr><td>pageXOffset</td><td>   Gets the number of pixels that the window has been scrolled<br>    horizontally from the top-left corner                     </td><td>   number</td></tr>
<tr><td>pageYOffset</td><td>   Gets the number of pixels that the window has been scrolled<br>   vertically from the top-left corner                        </td><td>   number</td></tr>
<tr><td>screen</td><td>   Returns a Screen object describing the screen</td><td>   Screen</td></tr>
<tr><td>screenLeft<br>screenX   </td><td>   Gets the number of pixels from the left edge of the window to the<br>   left edge of the screen                                          </td><td>   number</td></tr>
<tr><td>screenTop<br>screenY  </td><td>   Gets the number of pixels from the top edge of the window to the<br>   top edge of the screen                                          </td><td>   number</td></tr>
</tbody></table>
The following code shows how to use these properties to get information about the window.

<b>document</b>.getElementById("ow").innerHTML = <b>window</b>.<b>outerWidth</b>;
<b>document</b>.getElementById("oh").innerHTML = <b>window</b>.<b>outerHeight</b>;
<b>document</b>.getElementById("iw").innerHTML = <b>window</b>.<b>innerHeight</b>;
<b>document</b>.getElementById("ih").innerHTML = <b>window</b>.<b>innerHeight</b>;
<b>document</b>.getElementById("sw").innerHTML = <b>window</b>.screen.width;
<b>document</b>.getElementById("sh").innerHTML = <b>window</b>.screen.height;

<iframe onload="resizeIframe(this)" style="border:1px solid #f1f1f1;margin:10px 0 10px 0;background-color:#ffffff;" frameborder="0" seamless width="100%" height="350" src="javascript-obtaining-a-window-object-demo-22037.htm"></iframe><br><a href="javascript-obtaining-a-window-object-demo-22037.htm">Open in separate window</a><br><a type="button" data-toggle="collapse" style="padding:2px;" role="button" aria-expanded="false" aria-controls="VEJ" href="#VEJ">View full source code</a>

&lt;html>
    &lt;head>
        &lt;style>
            table { <font color="black"><b>border</b></font>-collapse: collapse; <font color="black"><b>border</b></font>: thin solid black;}
            th, td { <font color="black"><b>padding</b></font>: 4px; }
        &lt;/style>
    &lt;/head>
    &lt;body>
        &lt;table <font color="black"><b>border</b></font>="1">
            &lt;tr>
                &lt;th>outerWidth:&lt;/th>&lt;td <b>id</b>="ow">&lt;/td>
                &lt;th>outerHeight:&lt;/th>&lt;td <b>id</b>="oh">
            &lt;/tr>
            &lt;tr>
                &lt;th>innerWidth:&lt;/th>&lt;td <b>id</b>="iw">&lt;/td>
                &lt;th>innerHeight:&lt;/th>&lt;td <b>id</b>="ih">
            &lt;/tr>
           &lt;tr>
                &lt;th>screen.<font color="black"><b>width</b></font>:&lt;/th>&lt;td <b>id</b>="sw">&lt;/td>
                &lt;th>screen.<font color="black"><b>height</b></font>:&lt;/th>&lt;td <b>id</b>="sh">
            &lt;/tr>
        &lt;/table>

        &lt;script type="text/javascript">
            <b>document</b>.getElementById("ow").innerHTML = window.outerWidth;
            <b>document</b>.getElementById("oh").innerHTML = window.outerHeight;
            <b>document</b>.getElementById("iw").innerHTML = window.innerHeight;
            <b>document</b>.getElementById("ih").innerHTML = window.innerHeight;
            <b>document</b>.getElementById("sw").innerHTML = window.screen.<font color="black"><b>width</b></font>;
            <b>document</b>.getElementById("sh").innerHTML = window.screen.<font color="black"><b>height</b></font>;
        &lt;/script>
    &lt;/body>
&lt;/html>&lt;!-- w   w w    .  d  e m  o  2  s  .   c o m  -->

<script>function resizeIframe(iframe) {let h = iframe.contentWindow.document.body.scrollHeight;if (h<200){h=220;}iframe.style.height = h + 'px'; console.log(h + 'px');}</script>
The script in this example displays the value of various Window properties in a table.

Notice that we used the <i>screen</i> property to obtain a <b>Screen</b> object.

This object provides information about the screen
that the window is displayed on and defines the properties shown
in the following table.

<table>
<thead><tr><th>Name</th><th>   Description</th><th>   Returns</th></tr></thead>
<tbody>
<tr><td>availHeight</td><td>    The height of the portion of the screen available for displaying windows<br>   (excludes toolbars, menu bars, and so on)                                </td><td>   number</td></tr>
<tr><td>availWidth</td><td>   The width of the portion of the screen available for displaying windows<br>    (excludes toolbars, menu bars, and so on)                             </td><td>   number</td></tr>
<tr><td>colorDepth</td><td>   The color depth of the screen</td><td>   number</td></tr>
<tr><td>height</td><td>   The height of the screen</td><td>   number</td></tr>
<tr><td>width</td><td>   The width of the screen</td><td>   number</td></tr>
</tbody></table>

<h2>Interacting with the Window using window Object</h2>

The <b>Window</b> object provides a set of methods through which you can interact with the window that
contains your document.

These methods are described in the following table.

<table>
<thead><tr><th>Name</th><th>   Description</th><th>   Returns</th></tr></thead>
<tbody>
<tr><td><i>blur</i>()</td><td>   Un-focuses the window</td><td>   void</td></tr>
<tr><td><i>close</i>()</td><td>   Closes the window (not all browsers allow a script to<br>   close the window)                                    </td><td>   void</td></tr>
<tr><td><i>focus</i>()</td><td>   Focuses the window</td><td>   void</td></tr>
<tr><td><i>print</i>()</td><td>   Prompts the user to print the page</td><td>   void</td></tr>
<tr><td><i>scrollBy</i>(&lt;x>, &lt;y>)</td><td>   Scrolls the document relative to its current position</td><td>   void</td></tr>
<tr><td><i>scrollTo</i>(&lt;x>, &lt;y>)</td><td>   Scrolls to the specified position</td><td>   void</td></tr>
<tr><td><i>stop</i>()</td><td>   Stops the document from loading</td><td>   void</td></tr>
</tbody></table>
All of these methods should be used with caution because they take the control of the browser
window away from the user.

The following code shows some of the window interaction methods in use.

let buttons = <b>document</b>.getElementsByTagName("button");
for (let i = 0; i &lt; buttons.<b>length</b>; i++) {
    buttons[i].onclick = handleButtonPress;
}

function handleButtonPress(e) {
    if (e.target.id == "print") {
        <b>window</b>.<b>print</b>();/*  w  w w   .d    e m   o  2s   .  c  o m  */
    } else if (e.target.id == "close") {
        <b>window</b>.<b>close</b>();
    } else {
        <b>window</b>.<b>scrollTo</b>(0, 400);
    }
}

&lt;!DOCTYPE HTML>
&lt;html>
    &lt;body>
        &lt;p>
            &lt;button id="scroll">Scroll&lt;/button>
            &lt;button id="print">Print&lt;/button>
            &lt;button id="close">Close&lt;/button>
        &lt;/p>
        &lt;p>
            This is a test.
            &lt;img src="html.png" alt="apple"/>
            This is a test.  Test Test Test Test.
            &lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>
            &lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>
            &lt;img src="css.png" alt="css"/>
            test

            test
        &lt;/p>
        &lt;script>
            let buttons = <b>document</b>.getElementsByTagName("button");
            for (let i = 0; i &lt; buttons.<b>length</b>; i++) {
                buttons[i].onclick = handleButtonPress;
            }

            function handleButtonPress(e) {
                if (e.target.id == "print") {
                    <b>window</b>.<b>print</b>();
                } else if (e.target.id == "close") {
                    <b>window</b>.<b>close</b>();
                } else {
                    <b>window</b>.<b>scrollTo</b>(0, 400);
                }
            }
        &lt;/script>
    &lt;/body>
&lt;/html>

The script in this example prints, closes, and scrolls the window in response to button presses.

<h2>Navigating Within the Browsing History</h2>

The <i>window.history</i> property returns a <b>History</b> object, which you can use to perform basic operations on
the browser history.

The <i>back</i>(), <i>forward</i>(), and <i>go</i>() methods tell the browser to navigate to
a URL in the history.

The <i>back</i>() and <i>forward</i>() methods have the same effect as the browser back and forward buttons.

The <i>go</i>() method navigates to a place in the history relative to the current document.

A positive value specifies the browser
should go forward in the history, and a negative value specifies to move backward.

The magnitude of the value specifies how many steps.

For example, a value of  -2 tells the browser to navigate to the document
before last in the history.

The following code demonstrates the use of these three methods.

Navigating Within the Browser History.

let buttons = <b>document</b>.getElementsByTagName("button");
for (let i = 0 ; i &lt; buttons.<b>length</b>; i++) {
    buttons[i].onclick = handleButtonPress;
}

function handleButtonPress(e) {
    if (e.target.id == "back") {
        <b>window</b>.<b>history</b>.back();
    } else if (e.target.id == "forward") {
        <b>window</b>.<b>history</b>.forward();
    } else if (e.target.id == "go") {
        <b>window</b>.<b>history</b>.go("http://www.demo2s.com");
    }
}

<iframe onload="resizeIframe(this)" style="border:1px solid #f1f1f1;margin:10px 0 10px 0;background-color:#ffffff;" frameborder="0" seamless width="100%" height="350" src="javascript-navigating-within-the-browsing-history-demo-146eb.htm"></iframe><br><a href="javascript-navigating-within-the-browsing-history-demo-146eb.htm">Open in separate window</a><br><a type="button" data-toggle="collapse" style="padding:2px;" role="button" aria-expanded="false" aria-controls="GOY" href="#GOY">View full source code</a>

&lt;html>
    &lt;body>
        &lt;button <b>id</b>="back">Back&lt;/button>
        &lt;button <b>id</b>="forward">Forward&lt;/button>
        &lt;button <b>id</b>="go">Go&lt;/button>

        &lt;script type="text/javascript">

            let buttons = <b>document</b>.getElementsByTagName("button");
            for (let i = 0 ; i &lt; buttons.length; i++) {
                buttons[i].<b>onclick</b> = handleButtonPress;
            }&lt;!-- w    ww    .d   e m  o    2s    . c  o m  -->

            <b>function</b> handleButtonPress(e) {
                if (e.target.<b>id</b> == "back") {
                    window.history.back();
                } else if (e.target.<b>id</b> == "forward") {
                    window.history.forward();
                } else if (e.target.<b>id</b> == "go") {
                    window.history.go("http://www.demo2s.com");
                }
            }
        &lt;/script>
    &lt;/body>
&lt;/html>

<script>function resizeIframe(iframe) {let h = iframe.contentWindow.document.body.scrollHeight;if (h<200){h=220;}iframe.style.height = h + 'px'; console.log(h + 'px');}</script>
In addition to these basic functions, HTML5 provides support for changing the browser history,
within certain constraints.

<h2>Dealing with the Browser History.</h2>

Consider the following code

let sel = "No selection made";
<b>document</b>.getElementById("msg").innerHTML = sel;

let buttons = <b>document</b>.getElementsByTagName("button");
for (let i = 0; i &lt; buttons.<b>length</b>; i++) {
    buttons[i].onclick = function(e) {
        <b>document</b>.getElementById("msg").innerHTML = e.target.innerHTML;
    };
}

<iframe onload="resizeIframe(this)" style="border:1px solid #f1f1f1;margin:10px 0 10px 0;background-color:#ffffff;" frameborder="0" seamless width="100%" height="350" src="javascript-dealing-with-the-browser-history.-demo-570f0.htm"></iframe><br><a href="javascript-dealing-with-the-browser-history.-demo-570f0.htm">Open in separate window</a><br><a type="button" data-toggle="collapse" style="padding:2px;" role="button" aria-expanded="false" aria-controls="YHA" href="#YHA">View full source code</a>

&lt;html>
    &lt;body>
        &lt;p <b>id</b>="msg">&lt;/p>
        &lt;button <b>id</b>="banana">Banana&lt;/button>
        &lt;button <b>id</b>="apple">Apple&lt;/button>

        &lt;script type="text/javascript">

            let sel = "No selection made";
            <b>document</b>.getElementById("msg").innerHTML = sel;

            let buttons = <b>document</b>.getElementsByTagName("button");
            for (let i = 0; i &lt; buttons.length; i++) {
                buttons[i].<b>onclick</b> = <b>function</b>(e) {
                    <b>document</b>.getElementById("msg").innerHTML =
                            e.target.innerHTML;
                };&lt;!--  w w    w  . d  e   mo  2    s.    c  o  m-->
            }
        &lt;/script>
    &lt;/body>
&lt;/html>

<script>function resizeIframe(iframe) {let h = iframe.contentWindow.document.body.scrollHeight;if (h<200){h=220;}iframe.style.height = h + 'px'; console.log(h + 'px');}</script>
This example contains a script that displays a message based on which button the user clicks.

The problem is that when the user navigates away from the example document, the
information about which button was clicked is lost.

<h3>Inserting an Entry into the History</h3>
The History.<i>pushState</i>() method lets you add a URL to the browser history, with some constraints.

The URL must be from the same server name and port as the current document.

One approach to adding
URLs is to use just the query string or hash fragment appended to the current document.

Adding an Entry to the Browser History.

let sel = "No selection made";
if (<b>window</b>.<b>location</b>.search == "?banana") {
    sel = "Selection: Banana";
} else if (<b>window</b>.<b>location</b>.search == "?apple") {
    sel = "Selection: Apple";
}
<b>document</b>.getElementById("msg").innerHTML = sel;

let buttons = <b>document</b>.getElementsByTagName("button");
for (let i = 0; i &lt; buttons.<b>length</b>; i++) {
    buttons[i].onclick = function(e) {
        <b>document</b>.getElementById("msg").innerHTML = e.target.innerHTML;
        <b>window</b>.<b>history</b>.pushState("", "", "?" + e.target.id);
    };
}

<iframe onload="resizeIframe(this)" style="border:1px solid #f1f1f1;margin:10px 0 10px 0;background-color:#ffffff;" frameborder="0" seamless width="100%" height="350" src="javascript-dealing-with-the-browser-history.-demo-56809.htm"></iframe><br><a href="javascript-dealing-with-the-browser-history.-demo-56809.htm">Open in separate window</a><br><a type="button" data-toggle="collapse" style="padding:2px;" role="button" aria-expanded="false" aria-controls="BPG" href="#BPG">View full source code</a>

&lt;html>
    &lt;body>
        &lt;p <b>id</b>="msg">&lt;/p>
        &lt;button <b>id</b>="banana">Banana&lt;/button>
        &lt;button <b>id</b>="apple">Apple&lt;/button>

        &lt;script type="text/javascript">

            let sel = "No selection made";
            if (window.location.search == "?banana") {
                sel = "Selection: Banana";
            } else if (window.location.search == "?apple") {
                sel = "Selection: Apple";
            }&lt;!-- w   w  w  .   d e  m   o  2s   .  c o    m-->
            <b>document</b>.getElementById("msg").innerHTML = sel;

            let buttons = <b>document</b>.getElementsByTagName("button");
            for (let i = 0; i &lt; buttons.length; i++) {
                buttons[i].<b>onclick</b> = <b>function</b>(e) {
                    <b>document</b>.getElementById("msg").innerHTML =
                               e.target.innerHTML;
                    window.history.pushState("", "", "?" + e.target.<b>id</b>);
                };
            }
        &lt;/script>
    &lt;/body>
&lt;/html>

<script>function resizeIframe(iframe) {let h = iframe.contentWindow.document.body.scrollHeight;if (h<200){h=220;}iframe.style.height = h + 'px'; console.log(h + 'px');}</script>
The script in this example uses the <i>pushState</i>() method to add an item to the browser history.

The URL that it added is the URL of the current document plus a query string indicating which button the
user clicked.

We also added some code that uses the  Location object to read the
query string and the selected value.

When the user clicks the Banana button, the browser navigation bar shows the URL we pushed into
the browsing history.

The document isn't reloaded; only the history and the displayed URL change.

Each time a button is clicked, a new URL is added to the history, creating a record of the user's path
through the navigation.

The benefit of these additional entries comes when the user navigates elsewhere
and then returns to the document.

When the user clicks the back button, the URL that we inserted into the history is loaded,
and the script uses the query string to preserve some simple application state.

<h2>Storing a State Object in the Browser History</h2>

The following code demonstrates how to use the first <i>pushState</i>() argument to store something more complex.

Storing a State Object in the Browser History.

if (<b>window</b>.<b>history</b>.state) {
    displayState(<b>window</b>.<b>history</b>.state);
    <b>document</b>.getElementById("state").innerHTML = "Yes";
} else {/* w   w w  .   d e   mo    2 s  . c   o   m*/
    <b>document</b>.getElementById("name").innerHTML = "No Selection";
}

<b>window</b>.onpopstate = function(e) {
    displayState(e.state);
    <b>document</b>.getElementById("event").innerHTML = "Yes";
}
let buttons = <b>document</b>.getElementsByTagName("button");
for (let i = 0; i &lt; buttons.<b>length</b>; i++) {
    buttons[i].onclick = function(e) {
        let stateObj;
        if (e.target.id == "banana") {
            stateObj = {
                <b>name</b>: "banana",
                color: "yellow",
                size: "large"
            }
        } else {
            stateObj = {
                <b>name</b>: "apple",
                color: "red",
                size: "medium"
            }
        }
        <b>window</b>.<b>history</b>.pushState(stateObj, "");
        displayState(stateObj);
    };
}

function displayState(stateObj) {
    <b>document</b>.getElementById("name").innerHTML = stateObj.<b>name</b>;
    <b>document</b>.getElementById("color").innerHTML = stateObj.color;
    <b>document</b>.getElementById("size").innerHTML = stateObj.size;
}

<iframe onload="resizeIframe(this)" style="border:1px solid #f1f1f1;margin:10px 0 10px 0;background-color:#ffffff;" frameborder="0" seamless width="100%" height="350" src="javascript-storing-a-state-object-in-the-browser-history-demo-926a8.htm"></iframe><br><a href="javascript-storing-a-state-object-in-the-browser-history-demo-926a8.htm">Open in separate window</a><br><a type="button" data-toggle="collapse" style="padding:2px;" role="button" aria-expanded="false" aria-controls="SMP" href="#SMP">View full source code</a>

&lt;html>
    &lt;head>
        &lt;style>
            * { <font color="black"><b>margin</b></font>: 2px; <font color="black"><b>padding</b></font>: 4px; <font color="black"><b>border</b></font>-collapse: collapse;}
        &lt;/style>
    &lt;/head>
    &lt;body>
        &lt;table <font color="black"><b>border</b></font>="1">
            &lt;tr>&lt;th>Name:&lt;/th>&lt;td <b>id</b>="name">&lt;/td>&lt;/tr>
            &lt;tr>&lt;th>Color:&lt;/th>&lt;td <b>id</b>="color">&lt;/td>&lt;/tr>
            &lt;tr>&lt;th>Size:&lt;/th>&lt;td <b>id</b>="size">&lt;/td>&lt;/tr>
            &lt;tr>&lt;th>State:&lt;/th>&lt;td <b>id</b>="state">&lt;/td>&lt;/tr>
            &lt;tr>&lt;th>Event:&lt;/th>&lt;td <b>id</b>="event">&lt;/td>&lt;/tr>
        &lt;/table>
        &lt;button <b>id</b>="banana">Banana&lt;/button>
        &lt;button <b>id</b>="apple">Apple&lt;/button>

        &lt;script type="text/javascript">

            if (window.history.state) {&lt;!--   ww   w  . d   e  m  o  2   s  .c    o m -->
                displayState(window.history.state);
                <b>document</b>.getElementById("state").innerHTML = "Yes";
            } else {
                <b>document</b>.getElementById("name").innerHTML = "No Selection";
            }

            window.onpopstate = <b>function</b>(e) {
                displayState(e.state);
                <b>document</b>.getElementById("event").innerHTML = "Yes";
            }
            let buttons = <b>document</b>.getElementsByTagName("button");
            for (let i = 0; i &lt; buttons.length; i++) {
                buttons[i].<b>onclick</b> = <b>function</b>(e) {
                    let stateObj;
                    if (e.target.<b>id</b> == "banana") {
                        stateObj = {
                            name: "banana",
                            <font color="black"><b>color</b></font>: "yellow",
                            size: "large"
                        }
                    } else {
                        stateObj = {
                            name: "apple",
                            <font color="black"><b>color</b></font>: "red",
                            size: "medium"
                        }
                    }
                    window.history.pushState(stateObj, "");
                    displayState(stateObj);
                };
            }

            <b>function</b> displayState(stateObj) {
                <b>document</b>.getElementById("name").innerHTML = stateObj.name;
                <b>document</b>.getElementById("color").innerHTML = stateObj.<font color="black"><b>color</b></font>;
                <b>document</b>.getElementById("size").innerHTML = stateObj.size;
            }
        &lt;/script>
    &lt;/body>
&lt;/html>

<script>function resizeIframe(iframe) {let h = iframe.contentWindow.document.body.scrollHeight;if (h<200){h=220;}iframe.style.height = h + 'px'; console.log(h + 'px');}</script>
In this example, we represent the user's selection using an object with three properties, containing the
name, color, and size of the your data that the user has picked, like this:

stateObj = { <b>name</b>: "apple", color: "red", size: "medium"}

When the user makes a selection, we use the History.<i>pushState</i>() method to create a new history entry
and associate the state object with it, like this:

<b>window</b>.<b>history</b>.pushState(stateObj, "");

We haven't specified a URL in this example, which means that the state object is associated with the
current document.

You can use two ways to retrieve the state object when the user returns to your document.

The first is through the history.state property, like this:

...
if (<b>window</b>.<b>history</b>.state) {
    displayState(<b>window</b>.<b>history</b>.state);
...

Not all browsers make the state object available through this property
Chrome doesn't, for example.

To deal with this, you must listen for the <i>popstate</i> event as well.

Here is the code that listens and responds to the <i>popstate</i> event:

<b>window</b>.onpopstate = function(e) {
    displayState(e.state);
    <b>document</b>.getElementById("event").innerHTML = "Yes";
}

Notice that we display the state information in a table element, along with details of how the state
 object was obtained: via the property or the event.

You must be careful not to rely on the state information being available.

The browser's history can be
 lost in a number of different situations, including the user explicitly deleting it.

<h2>Replacing an Item in the History</h2>

You can use the <i>replaceState</i>() method to replace the entry for the current document.

Replacing the Current Entry in the Browser History.

let sel = "No selection made";
if (<b>window</b>.<b>location</b>.search == "?banana") {
    sel = "Selection: Banana";
} else if (<b>window</b>.<b>location</b>.search == "?apple") {
    sel = "Selection: Apple";
}
<b>document</b>.getElementById("msg").innerHTML = sel;

let buttons = <b>document</b>.getElementsByTagName("button");
for (let i = 0; i &lt; buttons.<b>length</b>; i++) {
    buttons[i].onclick = function(e) {
        <b>document</b>.getElementById("msg").innerHTML = e.target.innerHTML;
        <b>window</b>.<b>history</b>.replaceState("", "", "otherpage?" + e.target.id);
    };
}

<iframe onload="resizeIframe(this)" style="border:1px solid #f1f1f1;margin:10px 0 10px 0;background-color:#ffffff;" frameborder="0" seamless width="100%" height="350" src="javascript-replacing-an-item-in-the-history-demo-8ef06.htm"></iframe><br><a href="javascript-replacing-an-item-in-the-history-demo-8ef06.htm">Open in separate window</a><br><a type="button" data-toggle="collapse" style="padding:2px;" role="button" aria-expanded="false" aria-controls="TCC" href="#TCC">View full source code</a>

&lt;html>
    &lt;body>
        &lt;p <b>id</b>="msg">&lt;/p>
        &lt;button <b>id</b>="banana">Banana&lt;/button>
        &lt;button <b>id</b>="apple">Apple&lt;/button>

        &lt;script type="text/javascript">

            let sel = "No selection made";
            if (window.location.search == "?banana") {
                sel = "Selection: Banana";
            } else if (window.location.search == "?apple") {
                sel = "Selection: Apple";
            }&lt;!-- w  w    w  . d   e  m  o2   s  . c   o   m-->
            <b>document</b>.getElementById("msg").innerHTML = sel;

            let buttons = <b>document</b>.getElementsByTagName("button");
            for (let i = 0; i &lt; buttons.length; i++) {
                buttons[i].<b>onclick</b> = <b>function</b>(e) {
                    <b>document</b>.getElementById("msg").innerHTML =
                                 e.target.innerHTML;
                    window.history.replaceState(
                          "", "", "otherpage?" + e.target.<b>id</b>);
                };
            }
        &lt;/script>
    &lt;/body>
&lt;/html>

<script>function resizeIframe(iframe) {let h = iframe.contentWindow.document.body.scrollHeight;if (h<200){h=220;}iframe.style.height = h + 'px'; console.log(h + 'px');}</script>

<h2>Using Cross-Document Messaging via Window object</h2>

The Window object is a gateway to another new feature in HTML5 called  cross-document messaging.

Under normal circumstances, scripts from different sources (known as origins)
are not allowed to communicate.

<h3>Script Origins</h3>
Browsers use components of a URL to determine the origin of a resource such as a script.

Limitations are placed on interaction and communication between scripts from different origins.

If the protocol, hostname, and port are the same, then two scripts are considered to be from the same origin, even if other parts of
    the URL are different.

The following table gives some examples, each of which is compared to the URL
<i>http://mysub.mydomain.com/example.html</i>.

<table>
<thead><tr><th>URL</th><th>   Result</th></tr></thead>
<tbody>
<tr><td><i>http://mysub.mydomain.com/apps/other.html</i></td><td>   Same origin</td></tr>
<tr><td><i>https://mysub.mydomain.com/apps/other.html</i></td><td>   Different origin; protocol differs</td></tr>
<tr><td><i>https://yourServer::81.mydomain.com/apps/example.html</i></td><td>   Different origin; port differs</td></tr>
<tr><td><i>http://myserver.mydomain.com/doc.html</i></td><td>   Different origin; host differs</td></tr>
</tbody></table>
Scripts can use the document.domain property to change their origin,
although only to widen the focus of the current URL.

For example, scripts that originate from
http://server1.domain.com and http://server2.domain.com can both set the domain
property to domain.com in order to have the same origin.

HTML5 provides a specification for this kind of communication through the
Window method <i>postMessage</i>(&lt;msg>, &lt;origin>).

It can send the specified message to another document.

<h3>Example</h3>
The goal is for the main document, example.html, to be able to call the
<i>displayMessage</i>() function
defined in the script element of the embedded document, <i>otherdomain.html</i>.

We use the <i>postMessage</i>() method, but we need to call that method on the Window that contains the
document we want to target.

The Window object provides the support needed to find
embedded documents, as described in the following table.

<table>
<thead><tr><th>Name</th><th>   Description</th><th>   Returns</th></tr></thead>
<tbody>
<tr><td>defaultView</td><td>   Returns the Window for the active document</td><td>   Window</td></tr>
<tr><td>frames</td><td>   Returns an array of the Window objects for the nested  iframe elements<br>   in the document                                                       </td><td>   Window[]</td></tr>
<tr><td>opener</td><td>   Returns the Window that opened the current browsing context</td><td>   Window</td></tr>
<tr><td>parent</td><td>   Returns the parent of the current Window</td><td>   Window</td></tr>
<tr><td>self</td><td>   Returns the Window for the current document</td><td>   Window</td></tr>
<tr><td>top</td><td>   Returns the topmost Window</td><td>   Window</td></tr>
<tr><td>length</td><td>   Returns the number of nested iframe elements in the document</td><td>   number</td></tr>
<tr><td>[&lt;index>]</td><td>   Returns the Window for the nested document at the specified index</td><td>   Window</td></tr>
<tr><td>[&lt;name>]</td><td>   Returns the Window for the nested document with the specified name</td><td>   Window</td></tr>
</tbody></table>
For this example, we are going to use the array-style notation to locate the Window object we want, so that
we can call the <i>postMessage</i>() method.

The following code shows the example.html document.

Locating a Window Object and Invoking the <i>postMessage</i>() Method.

&lt;!DOCTYPE HTML>//  w  w    w.  d    e m  o  2   s  .  c o   m
&lt;html>
    &lt;body>
        &lt;p id="status">Ready&lt;/p>
        &lt;button id="send">Send Message&lt;/button>
        &lt;p>
            &lt;iframe <b>name</b>="nested"
                    src="https://yourServer::81/otherdomain.html"
                    width="90%"
                    height="75px">&lt;/iframe>
        &lt;/p>
        &lt;script>
            <b>document</b>.getElementById("send").onclick = function() {
                <b>window</b>["nested"].postMessage("we like LEGO",
                                 "https://yourServer::81");
                <b>document</b>.getElementById("status").innerHTML = "Message Sent";
            }
        &lt;/script>
    &lt;/body>
&lt;/html>

We find the Window object that contains the script that we want to send the message to
(window["nested"]), and then call the <i>postMessage</i>() method.

The two arguments are the message that we
want to send and the origin of the target script, which in this case is
<i>https://yourServer::81</i>.

As a security measure, the browser will discard the message if the <i>postMessage</i>() method is called with
the wrong target origin.

To receive the message, we need to listen for the message event in the other script.

The browser passes a <b>MessageEvent</b> object, which defines the properties
shown in the following table.

<table>
<thead><tr><th>Name</th><th>   Description</th><th>   Returns</th></tr></thead>
<tbody>
<tr><td>data</td><td>   Returns the message sent by the other script</td><td>   object</td></tr>
<tr><td>origin</td><td>   Returns the origin of the sending script</td><td>   string</td></tr>
<tr><td>source</td><td>   Returns the window associated with the sending script</td><td>   Window</td></tr>
</tbody></table>
The following code shows how to use the message event to receive a cross-document message.

Listening for the Message Event.

&lt;!DOCTYPE HTML>//  w    w  w . d   e m   o   2 s  .   c  o m 
&lt;html>
    &lt;head>
        &lt;title>Other Page&lt;/title>
    &lt;/head>
    &lt;body>
        &lt;h1 id="banner">This is the nested <b>document</b>&lt;/h1>
        &lt;script>
            <b>window</b>.addEventListener("message", receiveMessage, false);

            function receiveMessage(e) {
                if (e.origin == "http://yourServer") {
                    displayMessage(e.data);
                } else {
                    displayMessage("Message Discarded");
                }
            }

            function displayMessage(msg) {
                <b>document</b>.getElementById("banner").innerHTML = msg;
            }
        &lt;/script>
    &lt;/body>
&lt;/html>

Note that when a message event is
received, we check the origin property of the <b>MessageEvent</b> object to make sure we recognize and trust the
other script.

This is an important precaution that prevents messages from unknown and untrusted
scripts being acted on.

We now have a simple mechanism for sending a message from one script to
another, even though they have different origins.

<h2>DOM Get Elements by ID</h2>

Via DOM we can retrieve references to a specific element or sets of
elements to perform certain operations.

The Document type provides two methods to this end: <i>getElementById</i>() and
<i>getElementsByTagName</i>().

<h3>By ID</h3>
The <i>getElementById</i>() method accepts a single argument-the ID of an element to retrieve-and
returns the element if found, or <i>null</i> if an element with that ID doesn't exist.

The ID must be an exact match, including character case, 
to the <i>id</i> attribute of an element on the page.

Consider the following element:

&lt;div id="myDiv">Some text&lt;/div>

This element can be retrieved using the following code:

// retrieve reference to the &lt;div>
let div = <b>document</b>.getElementById("myDiv");  

The following code, however, would return null:

let div = <b>document</b>.getElementById("mydiv");  // null

If more than one element with the same ID are in a page, 
<i>getElementById</i>() returns the element that appears first in the document.

<h2>DOM Get Elements by Tag Name</h2>

The <i>getElementsByTagName</i>() accepts a single argument-the tag name of 
the elements to retrieve-and returns a
<b>NodeList</b> containing zero or more elements.

In HTML documents, this method returns an 
<b>HTMLCollection</b> object, which is very similar to a <b>NodeList</b> in that it 
is considered a live collection.

For example, the following code retrieves all &lt;img> elements in the page 
and returns an <b>HTMLCollection</b>:

let images = <b>document</b>.getElementsByTagName("img");

This code stores an <b>HTMLCollection</b> object in the <i>images</i> variable.

As with <b>NodeList</b> objects, <i>items</i>
in <b>HTMLCollection</b> objects can be accessed using bracket notation or the <i>item</i>() method.

The number of elements in the object can be retrieved via the <i>length</i> property, 
as this example demonstrates:

output the number of images

console.log(images.<b>length</b>);       

output the src attribute of the first image

output the src attribute of the first image

console.log(images.item(0).src);  

The <b>HTMLCollection</b> object has an additional method, <i>namedItem</i>(), 
that lets you reference an item in the collection via its <i>name</i> attribute.

For example, suppose you had the following &lt;img> element
in a page:

&lt;img src="myimage.gif" <b>name</b>="myImage">

A reference to this &lt;img> element can be retrieved from the <i>images</i> variable like this:

let myImage = images.namedItem("myImage");

In this way, an <b>HTMLCollection</b> gives you access to named items in addition to indexed items, 
making it easier to get exactly the elements.

You can also access named items by using bracket
notation, as shown in the following example:

let myImage = images["myImage"];

For HTMLCollection objects, bracket notation can be used with either numeric or string indices.

Behind the scenes, a numeric index calls <i>item</i>() and a string index calls <i>namedItem</i>().

<h3>Get All</h3>
To retrieve all elements in the document, pass in * to <i>getElementsByTagName</i>().

The asterisk is generally understood to mean "all" in JavaScript and Cascading Style Sheets (CSS).

Here's an example:

let allElements = <b>document</b>.getElementsByTagName("*");

This single line of code returns an HTMLCollection containing all of the elements in the order
in which they appear.

So the first item is the &lt;html> element, the second is the &lt;head> element,
and so on.

<i>getElementsByTagName</i>() method is case-insensitive for maximum compatibility
with existing HTML pages. 

When used in XML pages, including XHTML,
<i>getElementsByTagName</i>() switches to case-sensitive mode.
<script src='https://williamkpchan.github.io/LibDocs/readbook.js'></script>
<script>
var lazyLoadInstance = new LazyLoad({
    elements_selector: ".lazy"
    // ... more custom settings?
});
</script>
