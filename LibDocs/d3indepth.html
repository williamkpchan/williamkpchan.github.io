<html>
<head>
<title>D3 in Depth</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script type='text/javascript' src='../mainscript.js'></script>

<script>
$(document).ready(function(){
    $('h1, h2, h3, h4, h5, .goldword, strong,  div.title').click(function(){
    parent.history.back();
    return false;
    });
});
</script>
<style>
body{width:80%;margin-left: 10%; font-size:22px;}
strong, h1, h2 {color: gold;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px;}
iframe {background-color: #222;}
</style>
</head>
<body onkeypress="chkKey()">
<center>
<h1>D3 in Depth
</h1>
<div id="toc"></div></center>

<pre>
<br>
<br>
<br>
https://www.d3indepth.com/introduction/
<h2>Introduction to D3</h2>

D3 is a JavaScript library used to create bespoke, interactive charts and maps on the web.

While most charting libraries (such as Chart.js and Highcharts) provide ready made charts D3 consists of a large set of building blocks from which custom charts or maps can be constructed.

D3’s approach is much lower level than other charting libraries. 
Creating a bar chart with Chart.js is just a <a href="https://codepen.io/createwithdata/pen/axgoaQ">few lines of code</a>.

Creating the same chart with D3 you need to:
. create SVG <code class="highlighter-rouge">rect</code> elements and join them to the data
. position the <code class="highlighter-rouge">rect</code> elements
. size the <code class="highlighter-rouge">rect</code> elements according to the data
. add axes

You might also want to:
. animate the bars when the chart first loads
. adapt the chart to the container size
. add a tooltip

This is all additional effort but it gives you complete control over the chart’s appearance and behaviour.

If a standard bar, line or pie chart is sufficient you should consider a library such as Chart.js. 
However if you wish to create a bespoke chart to an exact specification then D3 is worth considering.

D3’s features include:

. data-driven modification of HTML/SVG elements
. loading and transforming data (e.g. CSV data)
. generation of complex charts such as treemaps, packed circles and networks
. a powerful transition system for animating between views
. powerful user interaction support, including panning, zooming and dragging

<h3>Data-driven modification of HTML/SVG elements</h3>

Given an array of objects such as:

<pre><code class="language-json" data-lang="json"><span>[
  {
    "name": "Andy",
    "score": 37
  },
  {
    "name": "Beth",
    "score": 39
  },
  {
    "name": "Craig",
    "score": 31
  },
  {
    "name": "Diane",
    "score": 35
  },
  {
    "name": "Evelyn",
    "score": 38
  }
]</span></code></pre>

With D3 we can:

. add/remove <code class="highlighter-rouge">div</code> elements based on the array length
. add a label and bar to each <code class="highlighter-rouge">div</code> element
. update the width of the bar based on the person’s score


<iframe class="db center" src="https://www.d3indepth.com/blocks/introduction/dom/" marginwidth="0" marginheight="0" style="width: 400px; height: 260px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/e890d5ad36af3d949f275e35b41a99d6" target="_blank">View source</a>
	| <a href="https://gist.run/?id=e890d5ad36af3d949f275e35b41a99d6" target="_blank">Edit in GistRun</a>

<h3>Data transformation</h3>

D3 provides many functions for manipulating data. 
For example it has functions to request CSV (comma separated value) data and transform it into an array of objects.

Suppose you have a CSV file named films.csv on your server:

<pre><code class="language-csv" data-lang="csv">Film,Genre,Lead Studio,Audience score %,Worldwide Gross,Year
27 Dresses,Comedy,Fox,71,160.308654,2008
(500) Days of Summer,Comedy,Fox,81,60.72,2009
A Dangerous Method,Drama,Independent,89,8.972895,2011
A Serious Man,Drama,Universal,64,30.68,2009
Across the Universe,Romance,Independent,84,29.367143,2007
Beginners,Comedy,Independent,80,14.31,2011</code></pre>

you can request it using:

<pre><code><span>d3.csv('films.csv',function(err,data){</span>
  <span>// Do something with the data</span>
<span>})</span></code></pre>

D3 transforms the CSV data into an array of objects:

<pre><code class="language-json" data-lang="json"><span>[
  {
    "Film": "27 Dresses",
    "Genre": "Comedy",
    "Lead Studio": "Fox",
    "Audience score %": "71",
    "Worldwide Gross": "160.308654",
    "Year": "2008"
  },
  {
    "Film": "(500) Days of Summer",
    "Genre": "Comedy",
    "Lead Studio": "Fox",
    "Audience score %": "81",
    "Worldwide Gross": "60.72",
    "Year": "2009"
  },
  {
    "Film": "A Dangerous Method",
    "Genre": "Drama",
    "Lead Studio": "Independent",
    "Audience score %": "89",
    "Worldwide Gross": "8.972895",
    "Year": "2011"
  },
  {
    "Film": "A Serious Man",
    "Genre": "Drama",
    "Lead Studio": "Universal",
    "Audience score %": "64",
    "Worldwide Gross": "30.68",
    "Year": "2009"
  },
  {
    "Film": "Across the Universe",
    "Genre": "Romance",
    "Lead Studio": "Independent",
    "Audience score %": "84",
    "Worldwide Gross": "29.367143",
    "Year": "2007"
  },
  {
    "Film": "Beginners",
    "Genre": "Comedy",
    "Lead Studio": "Independent",
    "Audience score %": "80",
    "Worldwide Gross": "14.31",
    "Year": "2011"
  }
]</span></code></pre>

Notice that D3 has used the CSV column names (<code>Film</code>, <code>Genre</code>, <code>Lead Studio</code> etc.) as property names for each object.

(The CSV file is from <a href="https://docs.google.com/spreadsheets/d/1RMBdXYCrI_8S6wlTicmGbAXuh1TnnbCG6vQkZ6hOyf8/edit?authkey=CPuZiLcG#gid=29">Information is Beautiful</a>.)

<h3>Shape generation</h3>

D3 is probably best known for its role in producing interactive data visualisations. 
These are typically made of up SVG (Scalable Vector Graphic) elements such as <code class="highlighter-rouge">line</code>, <code class="highlighter-rouge">circle</code>, <code class="highlighter-rouge">path</code> and <code class="highlighter-rouge">text</code>.

Suppose you have co-ordinates

<pre><code><span>var data=[[0,50],[100,80],[200,40],[300,60],[400,30]];</span></code></pre>

which you’d like to connect with lines. 
D3 can generate the SVG:

<iframe class="db center" src="https://www.d3indepth.com/blocks/introduction/shape-line/" marginwidth="0" marginheight="0" style="width: 100%; height: 120px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/e312c205b6b07757551bffafb265589b" target="_blank">View source</a>

You can choose to interpolate the points with a curve:

<iframe class="db center" src="https://www.d3indepth.com/blocks/introduction/shape-line-curve/" marginwidth="0" marginheight="0" style="width: 100%; height: 120px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/2bfe90c7603a062644fc14a866c13f79" target="_blank">View source</a>

D3 can also create axes:

<iframe class="db center" src="https://www.d3indepth.com/blocks/introduction/shape-axis/" marginwidth="0" marginheight="0" style="width: 700px; height: 50px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/91a677b1246d2bfe28a6d27adf522d70" target="_blank">View source</a>

As with most D3 elements, you have a lot of configuration available. 
For example you can change the axis orientation as well as the number and format of the tick marks:

<iframe class="db center" src="https://www.d3indepth.com/blocks/introduction/shape-axis-modified/" marginwidth="0" marginheight="0" style="width: 700px; height: 50px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/65fec76009499a2cd17d902021528e23" target="_blank">View source</a>

<h3>Layouts</h3>

D3 provides a number of <strong>layouts</strong> which are functions that help transform your data into a visual layout. 
For example, if we have hierarchical (or tree shaped) data, we can use layouts to create a tree view:

<iframe class="db center" src="https://www.d3indepth.com/blocks/introduction/layout-tree/" marginwidth="0" marginheight="0" style="width: 800px; height: 950px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/2815bd8c7d0f00580a64bdea6c8513f6" target="_blank">View source</a>

a packed circle view (with leaf nodes sized by revenue):

<iframe class="db center" src="https://www.d3indepth.com/blocks/introduction/layout-packing/" marginwidth="0" marginheight="0" style="width: 820px; height: 840px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/e3b16f8ca441adfe4ffcd2f6d7b0bba5" target="_blank">View source</a>

and a treemap:

<iframe class="db center" src="https://www.d3indepth.com/blocks/introduction/layout-treemap/" marginwidth="0" marginheight="0" style="width: 920px; height: 640px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/502c024a398dc772fe947905f217dab3" target="_blank">View source</a>

Under the hood, a layout adds properties (such as position, radius, width and height) to each data element. 
These properties can then be used when updating the DOM elements.

<h3>Transitions</h3>

D3 makes it easy to introduce a transition effect between DOM states. 
Not only can position and size (e.g. 
width, height, radius) be smoothly transitioned, but also colours:

<iframe class="db center" src="https://www.d3indepth.com/blocks/introduction/transitions/" marginwidth="0" marginheight="0" style="width: 780px; height: 540px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/16c3036242d93526f3e18c60266b154e" target="_blank">View source</a>

As well as producing pleasing visual effects, transitions help users keep track of elements between different states.

<h3>User interaction</h3>

D3 has some useful tools to enable effect user interaction such as voronoi grids (to optimise hover/click/touch areas), brushing, zooming and dragging.

For example, suppose we have a number of small points with a hover-over effect, it’s quite hard to position the mouse pointer exactly over a circle:

<iframe class="db center" src="https://www.d3indepth.com/blocks/introduction/voronoi/" marginwidth="0" marginheight="0" style="width: 800px; height: 640px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/ee5a4b110b9841cc55dbba0716343143" target="_blank">View source</a>

However if the voronoi grid is enabled (click ‘Enable Voronoi’ above) polygons are enabled which help determine the closest point to the user’s hover/click/touch. 
It’s now <strong>much</strong> easier to locate a point. 
(Click ‘View Voronoi’ to see the underlying polygons.)

<h2>Selections</h2>

D3 selections allow DOM elements to be selected in order to do something with them, be it changing style, modifying their attributes, performing data-joins or inserting/removing elements.

For example, given 5 circles:

<!-- 
<pre><code class="language-html" data-lang="html"><span>&lt;svgwidth="760"height="140"&gt;</span>
  <span>&lt;gtransform="translate(70, 70)"&gt;</span>
    <span>&lt;circler="40"/&gt;</span>
    <span>&lt;circler="40"cx="120"/&gt;</span>
    <span>&lt;circler="40"cx="240"/&gt;</span>
    <span>&lt;circler="40"cx="360"/&gt;</span>
    <span>&lt;circler="40"cx="480"/&gt;</span>
  <span>&lt;/g&gt;</span>
<span>&lt;/svg&gt;</span></code></pre>

 -->

<iframe class="db center" src="https://www.d3indepth.com/blocks/selections/circles-1/" marginwidth="0" marginheight="0" style="width: 100%; height: 160px;" scrolling="yes"></iframe>

we can use <code>d3.selectAll</code> to select the circles and <code>.style</code> and <code>.attr</code> to modify them:

<pre><code><span>d3.selectAll('circle')</span>
  <span>.style('fill','orange')</span>
  <span>.attr('r',function(){</span>
    <span>return10+Math.random()*40;</span>
  <span>});</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/selections/circles-2/" marginwidth="0" marginheight="0" style="width: 100%; height: 160px;" scrolling="yes"></iframe>

<h3></a>Making selections</h3>

D3 has two functions to make selections <code>d3.select</code> and <code>d3.selectAll</code>.

<code>d3.select</code> selects the first matching element whilst <code>d3.selectAll</code> selects all matching elements. 
Each function takes a single argument which specifies the <a href="https://www.w3.org/TR/selectors-api/">selector string</a>.

For example to select all elements with class <code>item</code> use <code>d3.selectAll('.item')</code>.

<h3>Modifying elements</h3>

Once we’ve made a selection we can modify the elements in it using the following functions:

<table class="table table-bordered">
	<tr>
		<th>Name</th><th>Behaviour</th><th>Example</th>
	</tr>
	<tr>
		<td>.style</td><td>Update the style</td><td>d3.selectAll('circle').style('fill', 'red')</td>
	</tr>
	<tr>
		<td>.attr</td><td>Update an attribute</td><td>d3.selectAll('rect').attr('width', 10)</td>
	</tr>
	<tr>
		<td>.classed</td><td>Add/remove a class attribute</td><td>d3.select('.item').classed('selected', true)</td>
	</tr>
	<tr>
		<td>.property</td><td>Update an element's property</td><td>d3.selectAll('.checkbox').property('checked', false)</td>
	</tr>
	<tr>
		<td>.text</td><td>Update the text content</td><td>d3.select('div.title').text('My new book')</td>
	</tr>
	<tr>
		<td>.html</td><td>Change the html content</td><td>d3.select('.legend').html('&lt;div class="block"&gt;&lt;/div&gt;&lt;div&gt;0 - 10&lt;/div&gt;')</td>
	</tr>
</table>

<!-- <code>.style</code>, <code>.attr</code>, <code>.classed</code> and <code>.text</code> are probably the most commonly used selection functions. 
-->

Whether <code>.select</code> or <code>.selectAll</code> is used, all elements in the selection will be modified.

Here’s an example of all of these functions in use:

<iframe class="db center" src="https://www.d3indepth.com/blocks/selections/properties/" marginwidth="0" marginheight="0" style="width: 100%; height: 180px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/3236a4658005ab78d60816b74830694b" target="_blank">View source</a>

<h3>Updating selections with functions</h3>

In addition to passing constant values such as <code>red</code>, <code>10</code> and <code>true</code> to <code>.style</code>, <code>.attr</code>, <code>.classed</code>, <code>.property</code>, <code>.text</code> and <code>.html</code> we can pass in a function:

<pre><code><span>d3.selectAll('circle')</span>
  <span>.attr('cx',function(d,i){</span>
    <span>returni*100;</span>
  <span>});</span></code></pre>

The function typically accepts two arguments <code>d</code> and <code>i</code>. 
The first argument <code>d</code> is the joined data (see the <a href="/datajoins">data joins section</a>) and <code>i</code> is the index of the element within the selection.

If we want to update elements in a selection according to their position within the selection, we can use the <code>i</code> argument. 
For example to position some <code>rect</code> elements horizontally we can use:

<pre><code><span>d3.selectAll('rect')</span>
  <span>.attr('x',function(d,i){</span>
    <span>returni*40;</span>
  <span>});</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/selections/function-i/" marginwidth="0" marginheight="0" style="width: 100%; height: 220px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/9c59fb1fe6e914538341308340296885" target="_blank">View source</a>

In the majority of cases when functions are passed in, anonymous functions are used. 
However we can also use named functions e.g.

<pre><code><span>functionpositionRects(d,i){</span>
  <span>returni*40;</span>
<span>}</span>

<span>d3.selectAll('rect')</span>
  <span>.attr('x',positionRects);</span></code></pre>

<h3>Handling events</h3>

We can add event handlers to selected elements using <code>.on</code> which expects a callback function into which is passed two arguments <code>d</code> and <code>i</code>. 
As before, <code>d</code> is the joined data (see the <a href="/datajoins">data joins section</a>) and <code>i</code> is the index of the element within the selection.)

The most common events include (see <a href="https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events">MDN event reference</a> for more details):

<table class="table table-bordered">
	<tr>
		<th>Event name</th><th>Description</th>
	</tr>
	<tr>
		<td>click</td><td>Element has been clicked</td>
	</tr>
	<tr>
		<td>mouseenter</td><td>Mouse pointer has moved onto the element</td>
	</tr>
	<tr>
		<td>mouseover</td><td>Mouse pointer has moved onto the element or its children</td>
	</tr>
	<tr>
		<td>mouseleave</td><td>Mouse pointer has moved off the element</td>
	</tr>
	<tr>
		<td>mouseout</td><td>Mouse pointer has moved off the element or its children</td>
	</tr>
	<tr>
		<td>mousemove</td><td>Mouse pointer has moved over the element</td>
	</tr>
</table>

Let’s set up an event handler to update a status element with the index of the clicked element:

<pre><code><span>d3.selectAll('circle')</span>
  <span>.on('click',function(d,i){</span>
    <span>d3.select('.status')</span>
      <span>.text('You clicked on circle '+i);</span>
  <span>});</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/selections/events/" marginwidth="0" marginheight="0" style="width: 100%; height: 170px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/f2a877c38e52f54c2f4243695ca4d967" target="_blank">View source</a>

In the event callback function the <code>this</code> variable is bound to the DOM element. 
This allows us to do things such as:

<pre><code><span>d3.selectAll('circle')</span>
  <span>.on('click',function(d,i){</span>
    <span>d3.select(this)</span>
      <span>.style('fill','orange');</span>
  <span>});</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/selections/events-this/" marginwidth="0" marginheight="0" style="width: 100%; height: 170px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/b18879fe295375bb0e0b77cf21d11675" target="_blank">View source</a>

Note that <code>this</code> is a DOM element and not a D3 selection so if we wish to modify it using D3 we must first select it using <code>d3.select(this)</code>.

<h3>Inserting and removing elements</h3>

Elements can be added to a selection using <code>.append</code> and <code>.insert</code> whilst elements can be removed using <code>.remove</code>.

<code>.append</code> appends an element to the children of each element in the selection. 
The first argument specifies the type of element.

As an example let’s start with 3 <code>g</code> elements, each containing a <code>circle</code>:

<pre><code class="language-html" data-lang="html"><span>&lt;gclass="item"transform="translate(0, 0)"&gt;</span>
  <span>&lt;circler="40"/&gt;</span>
<span>&lt;/g&gt;</span>
<span>&lt;gclass="item"transform="translate(120, 0)"&gt;</span>
  <span>&lt;circler="40"/&gt;</span>
<span>&lt;/g&gt;</span>
<span>&lt;gclass="item"transform="translate(240, 0)"&gt;</span>
  <span>&lt;circler="40"/&gt;</span>
<span>&lt;/g&gt;</span></code></pre>

We can append a <code>text</code> element to each using:

<pre><code><span>d3.selectAll('g.item')</span>
  <span>.append('text')</span>
  <span>.text(function(d,i){</span>
    <span>returni+1;</span>
  <span>});</span></code></pre>

resulting in a <code>text</code> being added to each <code>g.item</code>:

<pre><code class="language-html" data-lang="html"><span>&lt;gclass="item"transform="translate(0, 0)"&gt;</span>
  <span>&lt;circler="40"/&gt;</span>
  <span>&lt;text&gt;</span>1<span>&lt;/text&gt;</span>
<span>&lt;/g&gt;</span>
<span>&lt;gclass="item"transform="translate(120, 0)"&gt;</span>
  <span>&lt;circler="40"/&gt;</span>
  <span>&lt;text&gt;</span>2<span>&lt;/text&gt;</span>
<span>&lt;/g&gt;</span>
<span>&lt;gclass="item"transform="translate(240, 0)"&gt;</span>
  <span>&lt;circler="40"/&gt;</span>
  <span>&lt;text&gt;</span>3<span>&lt;/text&gt;</span>
<span>&lt;/g&gt;</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/selections/append/" marginwidth="0" marginheight="0" style="width: 100%; height: 170px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/15daaf6e65f1937c890aab8a1b94ce3a" target="_blank">View source</a>

(<code>.append</code> is commonly used in the context of <a href="/enterexit">enter/exit</a> where it has different behaviour.)

<code>.insert</code> is similar to <code>.append</code> but it allows us to specify a <code>before</code> element to which, you guessed it, the new element is attached.

Therefore if we run the same example again, but choosing to insert the text element <strong>before</strong> the circle element we get:

<pre><code><span>d3.selectAll('g.item')</span>
  <span>.insert('text','circle')</span>
  <span>.text(function(d,i){</span>
    <span>returni+1;</span>
  <span>});</span></code></pre>

and the DOM will look like:

<pre><code class="language-html" data-lang="html"><span>&lt;gclass="item"transform="translate(0, 0)"&gt;</span>
  <span>&lt;text&gt;</span>1<span>&lt;/text&gt;</span>
  <span>&lt;circler="40"/&gt;</span>
<span>&lt;/g&gt;</span>
<span>&lt;gclass="item"transform="translate(120, 0)"&gt;</span>
  <span>&lt;text&gt;</span>2<span>&lt;/text&gt;</span>
  <span>&lt;circler="40"/&gt;</span>
<span>&lt;/g&gt;</span>
<span>&lt;gclass="item"transform="translate(240, 0)"&gt;</span>
  <span>&lt;text&gt;</span>3<span>&lt;/text&gt;</span>
  <span>&lt;circler="40"/&gt;</span>
<span>&lt;/g&gt;</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/selections/insert/" marginwidth="0" marginheight="0" style="width: 100%; height: 170px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/6e320e0fb89e5bc8bdde468d301880e5" target="_blank">View source</a>

<code>.remove</code> removes all the elements in a selection. 
For example, given some circles, we can remove them using:

<pre><code><span>d3.selectAll('circle')</span>
  <span>.remove();</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/selections/remove/" marginwidth="0" marginheight="0" style="width: 100%; height: 170px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/cd21d0522fc6f48e3fb88c7f770eb008" target="_blank">View source</a>

<h3>Chaining</h3>

Most selection functions return the selection, meaning that selection functions such as <code>.style</code>, <code>.attr</code> and <code>.on</code> can be chained:

<pre><code><span>d3.selectAll('circle')</span>
  <span>.style('fill','orange')</span>
  <span>.attr('r',20)</span>
  <span>.on('click',function(d,i){</span>
    <span>d3.select('.status')</span>
      <span>.text('You clicked on circle '+i);</span>
  <span>});</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/selections/chaining/" marginwidth="0" marginheight="0" style="width: 100%; height: 170px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/a8eb48f2add08e8f010c829863101773" target="_blank">View source</a>

<h3>Each and call</h3>

<code>.each</code> allows a function to be called on <strong>each element of a selection</strong> and <code>.call</code> allows a function to be called on the <strong>selection itself</strong>.

In the case of <code>.each</code> D3 passes in the joined datum (usually represented by <code>d</code>) and the index (usually represented by <code>i</code>). 
Not only can <code>.each</code> enable <a href="/reusable-components">reusable components</a> but it also allows computations to be shared across calls to <code>.style</code>, <code>.attr</code> etc.

Here’s an example of using <code>.each</code> to call a reusable component:

<pre><code><span>functionaddNumberedCircle(d,i){</span>
  <span>d3.select(this)</span>
    <span>.append('circle')</span>
    <span>.attr('r',40);</span>

  <span>d3.select(this)</span>
    <span>.append('text')</span>
    <span>.text(i+1)</span>
    <span>.attr('y',50)</span>
    <span>.attr('x',30);</span>
<span>}</span>

<span>d3.selectAll('g.item')</span>
  <span>.each(addNumberedCircle);</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/selections/each-reusable-component/" marginwidth="0" marginheight="0" style="width: 100%; height: 170px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/a3da017386189aec222e95a82c5f985e" target="_blank">View source</a>

Here’s an example of <code>.each</code> used for the latter:

<pre><code><span>d3.selectAll('circle')</span>
  <span>.each(function(d,i){</span>
    <span>var odd=i%2===1;</span>

    <span>d3.select(this)</span>
      <span>.style('fill',odd?'orange':'#ddd')</span>
      <span>.attr('r',odd?40:20);</span>
  <span>});</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/selections/each-shared/" marginwidth="0" marginheight="0" style="width: 100%; height: 170px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/7126f834e490b29c9cc26df71c1c1f69" target="_blank">View source</a>

In the case of <code>.call</code> D3 passes in the selection itself. 
This is a common pattern for <a href="/reusable-components">reusable components</a>.

In the following example we create a similar component to before using <code>.call</code>. 
This time the selection gets passed into the component (rather than <code>d</code> and <code>i</code>):

<pre><code><span>functionaddNumberedCircle(selection){</span>
  <span>selection</span>
    <span>.append('circle')</span>
    <span>.attr('r',40);</span>

  <span>selection</span>
    <span>.append('text')</span>
    <span>.text(function(d,i){</span>
      <span>returni+1;</span>
    <span>})</span>
    <span>.attr('y',50)</span>
    <span>.attr('x',30);</span>
<span>}</span>

<span>d3.selectAll('g.item')</span>
  <span>.call(addNumberedCircle);</span></code></pre>

<h3>Filtering and sorting selections</h3>

We can filter a selection using <code>.filter</code>. 
A function is usually passed into <code>.filter</code> which returns <code>true</code> if the element should be included. 
<code>.filter</code> returns the filtered selection.

In this example we filter through even-numbered elements and colour them orange:

<pre><code><span>d3.selectAll('circle')</span>
  <span>.filter(function(d,i){</span>
    <span>returni%2===0;</span>
  <span>})</span>
  <span>.style('fill','orange');</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/selections/filter/" marginwidth="0" marginheight="0" style="width: 100%; height: 170px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/57a3707ec2931ced16939000d113e8d4" target="_blank">View source</a>

Sorting only really makes sense if data has been joined to the selection, so please read up on <a href="/datajoins">data joins</a> first.

We can sort elements in a selection by calling <code>.sort</code> and passing in a comparator function. 
The comparator function has two arguments, usually <code>a</code> and <code>b</code>, which represent the datums on the two elements being compared. 
If the comparator function returns a negative number, <code>a</code> will be placed before <code>b</code> and if positive, <code>a</code> will be placed after <code>b</code>.

Thus if we have the following data joined to a selection:

<pre><code class="language-json" data-lang="json"><span>[
  {
    "name": "Andy",
    "score": 37
  },
  {
    "name": "Beth",
    "score": 39
  },
  {
    "name": "Craig",
    "score": 31
  },
  {
    "name": "Diane",
    "score": 35
  },
  {
    "name": "Evelyn",
    "score": 38
  }
]</span></code></pre>

we can sort by <code>score</code> using:

<pre><code>  <span>d3.selectAll('.person')</span>
    <span>.sort(function(a,b){</span>
      <span>returnb.score-a.score;</span>
    <span>});</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/selections/sort/" marginwidth="0" marginheight="0" style="width: 100%; height: 150px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/961bb0efe94bde8b2b6fe2957ccb632f" target="_blank">View source</a>

<!-- ### Nested selections -->
<!-- <div class="disqus-wrapper">
	<h2>Comments</h2>
	<div id="disqus_thread"></div>
	<script>

	/**
	 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
	 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
	var disqus_config = function () {
	    this.page.url = 'https://www.d3indepth.com/selections/';  // Replace PAGE_URL with your page's canonical URL variable
	    this.page.identifier = 'Selections'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
	};
	
	(function() { // DON'T EDIT BELOW THIS LINE
	    var d = document, s = d.createElement('script');
	    s.src = '//d3indepth.disqus.com/embed.js';
	    s.setAttribute('data-timestamp', +new Date());
	    (d.head || d.body).appendChild(s);
	})();
	</script>
	<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
	                                    
</div> -->


  </div>
</div>

      </div>

      
      <div class="mt4 pt4 bt b--black-10">
        <div class="black-70 f6 ph3 ph5-ns">


<h2>Data joins</h2>

Given an array of data and a <a href="/selections">D3 selection</a> we can attach or ‘join’ each array element to each element of the selection.

This creates a close relationship between your data and graphical elements which makes data-driven modification of the elements straightforward.

For example if we have some SVG circles:

<pre><code class="language-html" data-lang="html"><span>&lt;circler="40"/&gt;</span>
<span>&lt;circler="40"cx="120"/&gt;</span>
<span>&lt;circler="40"cx="240"/&gt;</span>
<span>&lt;circler="40"cx="360"/&gt;</span>
<span>&lt;circler="40"cx="480"/&gt;</span></code></pre>

and some data:

<pre><code><span>var scores=[</span>
  <span>{</span>
    <span>"name":"Andy",</span>
    <span>"score":25</span>
  <span>},</span>
  <span>{</span>
    <span>"name":"Beth",</span>
    <span>"score":39</span>
  <span>},</span>
  <span>{</span>
    <span>"name":"Craig",</span>
    <span>"score":42</span>
  <span>},</span>
  <span>{</span>
    <span>"name":"Diane",</span>
    <span>"score":35</span>
  <span>},</span>
  <span>{</span>
    <span>"name":"Evelyn",</span>
    <span>"score":48</span>
  <span>}</span>
<span>]</span></code></pre>

we can select the circles and then join the array to it:

<pre><code><span>d3.selectAll('circle')</span>
  <span>.data(scores);</span></code></pre>

We can now manipulate the circles according to the joined data:

<pre><code><span>d3.selectAll('circle')</span>
  <span>.attr('r',function(d){</span>
    <span>returnd.score;</span>
  <span>});</span></code></pre>

The above code sets the radius of each circle to each person’s score.

<iframe class="db center" src="https://www.d3indepth.com/blocks/datajoins/example/" marginwidth="0" marginheight="0" style="width: 100%; height: 170px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/1316222b296ed9fd572978d90cde0971" target="_blank">View source</a>

<h3>Making a data join</h3>

Given an array <code>myData</code> and a selection <code>s</code> a data join is created using the function <code>.data</code>:

<pre><code><span>var myData=[10,40,20,30];</span>

<span>var s=d3.selectAll('circle');</span>

<span>s.data(myData);</span></code></pre>

The array can contain any type e.g. 
<strong>objects</strong>:

<pre><code><span>var cities=[</span>
  <span>{name:'London',population:8674000},</span>
  <span>{name:'New York',population:8406000},</span>
  <span>{name:'Sydney',population:4293000}</span>
<span>];</span>

<span>var s=d3.selectAll('circle');</span>

<span>s.data(cities);</span></code></pre>

Although a couple of things occur when <code>.data</code> is called (see Under the Hood and <a href="/enterexit">Enter/Exit</a>) you probably won’t notice much change after joining your data.

The real magic happens when you want to modify the elements in your selection according to your data.

<h3>Data-driven modification of elements</h3>

Once we’ve joined data to a selection we can modify elements by <strong>passing a function</strong> into the likes of <code>.style</code> and <code>.attr</code> (which we covered in <a href="/selections">Selections</a>):

<pre><code><span>d3.selectAll('circle')</span>
  <span>.attr('r',function(d){</span>
    <span>returnd;</span>
  <span>});</span></code></pre>

For <strong>each element</strong> in the selection D3 will call this function, passing in the element’s joined data as the first argument <code>d</code>. 
The function’s return value is used to set the style or attribute value.

For example, given some circles:

<pre><code class="language-html" data-lang="html"><span>&lt;circle/&gt;</span>
<span>&lt;circle/&gt;</span>
<span>&lt;circle/&gt;</span>
<span>&lt;circle/&gt;</span>
<span>&lt;circle/&gt;</span></code></pre>

and some data:

<pre><code><span>var myData=[10,40,20,30,50];</span></code></pre>

let’s perform the data join:

<pre><code><span>var s=d3.selectAll('circle');</span>

<span>// Do the join</span>
<span>s.data(myData);</span></code></pre>

Now let’s update the radius of each circle in the selection to be equal to the corresponding data values:

<pre><code><span>s.attr('r',function(d){</span>
  <span>returnd;</span>
<span>});</span></code></pre>

The function that’s passed into <code>.attr</code> is called 5 times (once for each element in the selection). 
The first time round <code>d</code> will be 10 and so the circle’s radius will be set to 10. 
The second time round it’ll be 40 and so on.

In the above example the function simply returns <code>d</code> meaning that the first circle’s radius will be set to 10, the second’s radius to 40 and so.

We can return anything we like from the function, so long as it’s a valid value for the style, attribute etc. 
that we’re modifying. 
(It’s likely that some expression involving <code>d</code> will be returned.)

For example we can set the radius to twice <code>d</code> using:

<pre><code><span>s.attr('r',function(d){</span>
  <span>return2*d;</span>
<span>});</span></code></pre>

Now let’s set a class on each element if the value is greater or equal to 40:

<pre><code><span>s.classed('high',function(d){</span>
  <span>returnd&gt;=40;// returns true or false</span>
<span>});</span></code></pre>

and finally we’ll position the circles horizontally using the <code>i</code> argument (see <a href="/selections">Selections</a>):

<pre><code><span>s.attr('cx',function(d,i){</span>
  <span>returni*120;</span>
<span>});</span></code></pre>

Putting this all together we get:

<pre><code><span>var myData=[10,40,20,30,50];</span>

<span>var s=d3.selectAll('circle');</span>

<span>// Do the data join</span>
<span>s.data(myData);</span>

<span>// Modify the selected elements</span>
<span>s.attr('r',function(d){</span>
  <span>returnd;</span>
  <span>})</span>
  <span>.classed('high',function(d){</span>
    <span>returnd&gt;=40;</span>
  <span>})</span>
  <span>.attr('cx',function(d,i){</span>
    <span>returni*120;</span>
  <span>});</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/datajoins/data-driven-modification/" marginwidth="0" marginheight="0" style="width: 100%; height: 170px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/84111379a0387b2e6fa901babdbd6035" target="_blank">View source</a>

<h3>Arrays of objects</h3>

If we have an array of objects we can join it in the usual manner:

<pre><code><span>var cities=[</span>
  <span>{name:'London',population:8674000},</span>
  <span>{name:'New York',population:8406000},</span>
  <span>{name:'Sydney',population:4293000},</span>
  <span>{name:'Paris',population:2244000},</span>
  <span>{name:'Beijing',population:11510000}</span>
<span>];</span>

<span>var s=d3.selectAll('circle');</span>

<span>s.data(cities);</span></code></pre>

Now when we modify elements based on the joined data, <code>d</code> will represent the joined <strong>object</strong>. 
Thus for the first element in the selection, <code>d</code> will be <code>{ name: 'London', population: 8674000}</code>.

Let’s set the circle radii proportionally to each city’s population:

<pre><code><span>s.attr('r',function(d){</span>
    <span>var scaleFactor=0.000005;</span>
    <span>returnd.population*scaleFactor;</span>
  <span>})</span>
  <span>.attr('cx',function(d,i){</span>
    <span>returni*120;</span>
  <span>});</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/datajoins/arrays-of-objects/" marginwidth="0" marginheight="0" style="width: 100%; height: 170px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/053a606c7c488cdc0f0eabeaf85ec1dc" target="_blank">View source</a>

Of course, we not restricted to modifying <code>circle</code> elements. 
Supposing we had some <code>rect</code> and <code>text</code> elements, we can build a simple bar chart using what we’ve learnt:

<pre><code><span>var cities=[</span>
  <span>{name:'London',population:8674000},</span>
  <span>{name:'New York',population:8406000},</span>
  <span>{name:'Sydney',population:4293000},</span>
  <span>{name:'Paris',population:2244000},</span>
  <span>{name:'Beijing',population:11510000}</span>
<span>];</span>

<span>// Join cities to rect elements and modify height, width and position</span>
<span>d3.selectAll('rect')</span>
  <span>.data(cities)</span>
  <span>.attr('height',19)</span>
  <span>.attr('width',function(d){</span>
    <span>var scaleFactor=0.00004;</span>
    <span>returnd.population*scaleFactor;</span>
  <span>})</span>
  <span>.attr('y',function(d,i){</span>
    <span>returni*20;</span>
  <span>})</span>

<span>// Join cities to text elements and modify content and position</span>
<span>d3.selectAll('text')</span>
  <span>.data(cities)</span>
  <span>.attr('y',function(d,i){</span>
    <span>returni*20+13;</span>
  <span>})</span>
  <span>.attr('x',-4)</span>
  <span>.text(function(d){</span>
    <span>returnd.name;</span>
  <span>});</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/datajoins/rect/" marginwidth="0" marginheight="0" style="width: 100%; height: 170px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/90b992355b91f33db7c23e69cda98b5c" target="_blank">View source</a>

<h3>Under the hood</h3>

When D3 performs a data join it adds an attribute <code>__data__</code> to each DOM element in the selection and assigns the joined data to it.

We can inspect this in Google Chrome by right clicking on an element and choosing Inspect.

This’ll reveal Chrome’s debug window. 
Look for a tab named ‘Properties’ and open it. 
Expand the element then expand the <code>__data__</code> attribute. 
This is the data that D3 has joined to the element. 
(<a href="https://www.youtube.com/watch?v=LJAOk7IxDPs" target="_blank">See screencast</a>.)

<img src="/img/datajoins/inspect.png" />

Being able to check the joined data in this manner is particularly useful when debugging as it allows us to check whether our data join is behaving as expected.

<h3>What if our array’s longer (or shorter) than the selection?</h3>

So far we’ve looked at data joins where the selection is <strong>exactly</strong> the same length as the data array. 
Clearly this won’t always be the case and D3 handles this using <strong>enter</strong> and <strong>exit</strong>. 
To learn more see the <a href="/enterexit">enter and exit</a> section.

<h3>What’s .datum for?</h3>

There are a few instances (such as when dealing with <a href="/geographic">geographic visualisations</a>) where it’s useful to join a single bit of data with a selection (usually containing a single element). 
Supposing we have an object:

<pre><code><span>var featureCollection={type:'FeatureCollection',features:features};</span></code></pre>

we can join it to a single element using <code>.datum</code>:

<pre><code><span>d3.select('path#my-map')</span>
  <span>.datum(featureCollection);</span></code></pre>

This just adds a <code>__data__</code> attribute to the element and assigns the joined data (<code>featureCollection</code> in this case) to it. 
See the <a href="/geographic">geographic visualisations</a> section for a deeper look at this.

Most of the time <code>.data</code> will be used for data joins. 
<code>.datum</code> is reserved for special cases such as the above.

<!-- <div class="disqus-wrapper">
	<h2>Comments</h2>
	<div id="disqus_thread"></div>
	<script>

	/**
	 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
	 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
	var disqus_config = function () {
	    this.page.url = 'https://www.d3indepth.com/datajoins/';  // Replace PAGE_URL with your page's canonical URL variable
	    this.page.identifier = 'Data joins'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
	};
	
	(function() { // DON'T EDIT BELOW THIS LINE
	    var d = document, s = d.createElement('script');
	    s.src = '//d3indepth.disqus.com/embed.js';
	    s.setAttribute('data-timestamp', +new Date());
	    (d.head || d.body).appendChild(s);
	})();
	</script>
	<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
	                                    
</div> -->


  </div>
</div>

      </div>

      
      <div class="mt4 pt4 bt b--black-10">
        <div class="black-70 f6 ph3 ph5-ns">


<h2>Enter and exit</h2>

In the <a href="/datajoins">Data joins</a> section we show how to join an array of data to a D3 selection.

To recap, given some DOM elements:

<pre><code class="language-html" data-lang="html"><span>&lt;divid="content"&gt;</span>
  <span>&lt;div&gt;&lt;/div&gt;</span>
  <span>&lt;div&gt;&lt;/div&gt;</span>
  <span>&lt;div&gt;&lt;/div&gt;</span>
<span>&lt;/div&gt;</span></code></pre>

and some data:

<pre><code><span>var myData=[10,40,20];</span></code></pre>

we join the array to the <code>div</code> elements using:

<pre><code><span>d3.select('#content')</span>
  <span>.selectAll('div')</span>
  <span>.data(myData);</span></code></pre>

In this example <code>myData</code> is the same length as the selection.

However, what happens if the array has more (or less) elements than the selection?

. if the array is <strong>longer</strong> than the selection there’s a <strong>shortfall</strong> of DOM elements and we need to <strong>add</strong> elements
. if the array is <strong>shorter</strong> than the selection there’s a <strong>surplus</strong> of DOM elements and we need to <strong>remove</strong> elements

Fortunately D3 can help in adding and removing DOM elements using two functions <code>.enter</code> and <code>.exit</code>.

<h3>.enter</h3>

<code>.enter</code> identifies any DOM elements that need to be added when the joined array is longer than the selection. 
It’s defined on an <strong>update selection</strong> (the selection returned by <code>.data</code>):

<pre><code><span>d3.select('#content')</span>
  <span>.selectAll('div')</span>
  <span>.data(myData)</span>
  <span>.enter();</span></code></pre>

<code>.enter</code> returns an <strong>enter selection</strong> which basically represents the elements that need to be added. 
It’s usually followed by <code>.append</code> which adds elements to the DOM:

<pre><code><span>d3.select('#content')</span>
  <span>.selectAll('div')</span>
  <span>.data(myData)</span>
  <span>.enter()</span>
  <span>.append('div');</span></code></pre>

Let’s look at an example. 
Suppose we have the following <code>div</code> elements:

<pre><code class="language-html" data-lang="html"><span>&lt;divid="content"&gt;</span>
  <span>&lt;div&gt;&lt;/div&gt;</span>
  <span>&lt;div&gt;&lt;/div&gt;</span>
  <span>&lt;div&gt;&lt;/div&gt;</span>
<span>&lt;/div&gt;</span></code></pre>

and this data:

<pre><code><span>var myData=['A','B','C','D','E'];</span></code></pre>

we use <code>.enter</code> and <code>.append</code> to add <code>div</code> elements for D and E:

<pre><code>  <span>d3.select('#content')</span>
    <span>.selectAll('div')</span>
    <span>.data(myData)</span>
    <span>.enter()</span>
    <span>.append('div');</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/enterexit/enter/" marginwidth="0" marginheight="0" style="width: 100%; height: 130px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/1450ba61704293ce528646a1cf02fd85" target="_blank">View source</a>

Note that we can join an array to an empty selection which is a very common pattern in the examples on the D3 website.

<iframe class="db center" src="https://www.d3indepth.com/blocks/enterexit/emptyselection/" marginwidth="0" marginheight="0" style="width: 100%; height: 130px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/8c88eef33524c142152038fc14798fd2" target="_blank">View source</a>

<h3>.exit</h3>

<code>.exit</code> returns an <strong>exit selection</strong> which consists of the elements that need to be removed from the DOM. 
It’s usually followed by <code>.remove</code>:

<pre><code><span>d3.select('#content')</span>
  <span>.selectAll('div')</span>
  <span>.data(myData)</span>
  <span>.exit()</span>
  <span>.remove();</span></code></pre>

Let’s repeat the example above, but using <code>.exit</code>. 
Starting with elements:

<pre><code class="language-html" data-lang="html"><span>&lt;divid="content"&gt;</span>
  <span>&lt;div&gt;&lt;/div&gt;</span>
  <span>&lt;div&gt;&lt;/div&gt;</span>
  <span>&lt;div&gt;&lt;/div&gt;</span>
<span>&lt;/div&gt;</span></code></pre>

and data (notice that it’s shorter than the selection):

<pre><code><span>var myData=['A'];</span></code></pre>

we use <code>.exit</code> and <code>.remove</code> to remove the surplus elements:

<pre><code><span>d3.select('#content')</span>
  <span>.selectAll('div')</span>
  <span>.data(myData)</span>
  <span>.exit()</span>
  <span>.remove();</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/enterexit/exit/" marginwidth="0" marginheight="0" style="width: 100%; height: 130px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/3a7df9b204de85aa0993ab87cd196ec0" target="_blank">View source</a>

<h3>Putting it all together</h3>

So far in this section we’ve not concerned ourselves with modifying elements using functions such as <code>.style</code>, <code>.attr</code> and <code>.classed</code>.

D3 allows us to be specific about which elements are modified when new elements are entering. 
We can modify:

. the existing elements
. the entering elements
. both existing and entering elements

(Most of the time the last option is sufficient, but sometimes we might want to style entering elements differently.)

The existing elements are represented by the <strong>update selection</strong>. 
This is the selection returned by <code>.data</code> and is assigned to <code>u</code> in this example:

<pre><code><span>var myData=['A','B','C','D','E'];</span>

<span>var u=d3.select('#content')</span>
  <span>.selectAll('div')</span>
  <span>.data(myData);</span>

<span>u.enter()</span>
  <span>.append('div');</span>

<span>u.text(function(d){</span>
  <span>returnd;</span>
<span>});</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/enterexit/update-existing/" marginwidth="0" marginheight="0" style="width: 100%; height: 150px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/2b99df70ff7209fa3a373ddf95f06a9d" target="_blank">View source</a>

When the button is clicked, new elements are added, but because <code>.text</code> is only called on the update selection, it’s only the existing elements that are modified. 
(Note that if the button is clicked a second time, all the elements are modified. 
This is because the selection will contain all 5 <code>div</code> elements. 
Don’t worry about this too much if you’re new here!)

The entering elements are represented by the <strong>enter selection</strong>. 
This is the selection returned by <code>.enter</code>. 
We can modify the enter selection using:

<pre><code><span>var myData=['A','B','C','D','E'];</span>

<span>var u=d3.select('#content')</span>
  <span>.selectAll('div')</span>
  <span>.data(myData);</span>

<span>u.enter()</span>
  <span>.append('div')</span>
  <span>.text(function(d){</span>
    <span>returnd;</span>
  <span>});</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/enterexit/update-entering/" marginwidth="0" marginheight="0" style="width: 100%; height: 150px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/9c415c514c2efd693edc26a722b1b973" target="_blank">View source</a>

When the button is clicked, new elements are added and their text content is updated. 
Only the entering elements have their text updated because we call <code class="highlighter-rouge">.text</code> on the enter selection.

If we want to modify the existing <strong>and</strong> entering elements we could call <code>.text</code> on the update and enter selections.

However D3 has a function <code>.merge</code> which can merge selections together. 
This means we can do the following:

<pre><code><span>var myData=['A','B','C','D','E'];</span>

<span>var u=d3.select('#content')</span>
  <span>.selectAll('div')</span>
  <span>.data(myData);</span>

<span>u.enter()</span>
  <span>.append('div')</span>
  <span>.merge(u)</span>
  <span>.text(function(d){</span>
    <span>returnd;</span>
  <span>});</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/enterexit/update-all/" marginwidth="0" marginheight="0" style="width: 100%; height: 120px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/79c8655fbd9a886b8ef8d36e00b9074b" target="_blank">View source</a>

<blockquote>This is a big departure from v3. 
The entering elements were implicitly included in the update selection so there was no need for <code>.merge</code>.</blockquote>

<h3>General update pattern</h3>

A common pattern (<a href="https://bl.ocks.org/mbostock/3808218">proposed</a> by D3’s creator Mike Bostock) is to encapsulate the above behaviour of adding, removing and updating DOM elements in a single function:

<pre><code><span>functionupdate(data){</span>
  <span>var u=d3.select('#content')</span>
    <span>.selectAll('div')</span>
    <span>.data(data);</span>

  <span>u.enter()</span>
    <span>.append('div')</span>
    <span>.merge(u)</span>
    <span>.text(function(d){</span>
      <span>returnd;</span>
    <span>});</span>

  <span>u.exit().remove();</span>
<span>}</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/enterexit/update-pattern/" marginwidth="0" marginheight="0" style="width: 100%; height: 120px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/e25e81566cea413de9873b9339fa7518" target="_blank">View source</a>

Typically the update function is called whenever the data changes.

Here’s another example where we colour entering elements orange:

<pre><code><span>functionupdate(data){</span>
  <span>var u=d3.select('#content')</span>
    <span>.selectAll('div')</span>
    <span>.data(data);</span>

  <span>u.enter()</span>
    <span>.append('div')</span>
    <span>.classed('new',true)</span>
    <span>.text(function(d){</span>
      <span>returnd;</span>
    <span>});</span>

  <span>u.text(function(d){</span>
      <span>returnd;</span>
    <span>})</span>
    <span>.classed('new',false);</span>

  <span>u.exit().remove();</span>
<span>}</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/enterexit/update-pattern-highlight-entering/" marginwidth="0" marginheight="0" style="width: 100%; height: 120px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/bdc412597d64502e7ab82d8ff0d56bb7" target="_blank">View source</a>

<h3>Data join key function</h3>

When we do a data join D3 binds the first array element to the first element in the selection, the second array element to the second element in the selection and so on.

However, if the order of array elements changes (such as during element sorting, insertion or removal), the array elements might get joined <strong>to different DOM elements</strong>.

We can solve this problem by providing <code class="highlighter-rouge">.data</code> with a <strong>key function</strong>. 
This function should return a unique id value for each array element, allowing D3 to make sure each array element stays joined to the same DOM element.

Let’s look at an example, first using a key function, and then without.

We start with an array <code class="highlighter-rouge">['Z']</code> and each time the button is clicked a new letter is added at the start of the array.

Because of the key function <strong>each letter will stay bound to the same DOM element</strong> meaning that when a new letter is inserted each existing letter transitions into a new position:

<iframe class="db center" src="https://www.d3indepth.com/blocks/enterexit/key/" marginwidth="0" marginheight="0" style="width: 100%; height: 130px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/5e721266739f8324213171e2ef535c54" target="_blank">View source</a>

Without a key function the DOM elements’ text is updated (rather than position) meaning we lose a meaningful transition effect:

<iframe class="db center" src="https://www.d3indepth.com/blocks/enterexit/without-key/" marginwidth="0" marginheight="0" style="width: 100%; height: 130px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/00bd03fa9ddf292a856a734102e74d9d" target="_blank">View source</a>

There’s many instances when key functions are not required but if there’s any chance that your data elements can change position (e.g. 
through insertion or sorting) and you’re using transitions then you should probably use them.


  </div>
</div>

      </div>

      
      <div class="mt4 pt4 bt b--black-10">
        <div class="black-70 f6 ph3 ph5-ns">


<h2>Scale functions</h2>

Scale functions are JavaScript functions that:

. take an input (usually a number, date or category) and
. return a value (such as a coordinate, a colour, a length or a radius)

They’re typically used to transform (or ‘map’) data values into visual variables (such as position, length and colour).

For example, suppose we have some data:

<pre><code><span>[0,2,3,5,7.5,9,10]</span></code></pre>

we can create a scale function using:

<pre><code><span>var myScale=d3.scaleLinear()</span>
  <span>.domain([0,10])</span>
  <span>.range([0,600]);</span></code></pre>

D3 creates a function <code class="highlighter-rouge">myScale</code> which accepts input between 0 and 10 (the <strong>domain</strong>) and maps it to output between 0 and 600 (the <strong>range</strong>).

We can use <code class="highlighter-rouge">myScale</code> to calculate positions based on the data:

<pre><code><span>myScale(0);</span>   <span>// returns 0</span>
<span>myScale(2);</span>   <span>// returns 120</span>
<span>myScale(3);</span>   <span>// returns 180</span>
<span>...</span>
<span>myScale(10);</span>  <span>// returns 600</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/scales/example/" marginwidth="0" marginheight="0" style="width: 100%; height: 50px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/2d51279bdad4a553b2005af680108257" target="_blank">View source</a>

Scales are mainly used for transforming data values to visual variables such as position, length and colour.

For example they can transform:

. data values into lengths between 0 and 500 for a bar chart
. data values into positions between 0 and 200 for line charts
. % change data (+4%, +10%, -5% etc.) into a continuous range of colours (with red for negative and green for positive)
. dates into positions along an x-axis.

<h3>Constructing scales</h3>

(In this section we’ll just focus on linear scales as these are the most commonly used scale type. 
We’ll cover other types later on.)

To create a linear scale we use:

<pre><code><span>var myScale=d3.scaleLinear();</span></code></pre>

<blockquote>Version 4 uses a different naming convention to v3. 
We use d3.scaleLinear() in v4 and d3.scale.linear() in v3.</blockquote>

As it stands the above function isn’t very useful so we can configure the input bounds (the <code class="highlighter-rouge">domain</code>) as well as the output bounds (the <code class="highlighter-rouge">range</code>):

<pre><code><span>myScale</span>
  <span>.domain([0,100])</span>
  <span>.range([0,800]);</span></code></pre>

Now <code class="highlighter-rouge">myScale</code> is a function that accepts input between 0 and 100 and linearly maps it to between 0 and 800.

<pre><code><span>myScale(0);</span>    <span>// returns 0</span>
<span>myScale(50);</span>   <span>// returns 400</span>
<span>myScale(100);</span>  <span>// returns 800</span></code></pre>

<blockquote>Try experimenting with scale functions by copying code fragments and pasting them into the <a href="https://developers.google.com/web/tools/chrome-devtools/console/">console</a> or using a web-based editor such as <a href="https://jsbin.com/?html,output">JS Bin</a>.</blockquote>

<h3>D3 scale types</h3>

D3 has around 12 different scale types (scaleLinear, scalePow, scaleQuantise, scaleOrdinal etc.) and broadly speaking they can be classified into 3 groups:

. <a href="#scales-with-continuous-input-and-continuous-output">scales with continuous input and continuous output</a>
. <a href="#scales-with-continuous-input-and-discrete-output">scales with continuous input and discrete output</a>
. <a href="#scales-with-discrete-input-and-discrete-output">scales with discrete input and discrete output</a>

We’ll now look at these 3 categories one by one.

<h3>Scales with continuous input and continuous output</h3>

In this section we cover scale functions that map from a <strong>continuous input domain</strong> to a <strong>continuous output range</strong>.

<h4 id="scalelinear">scaleLinear</h4>

Linear scales are probably the most commonly used scale type as they are the most suitable scale for transforming data values into positions and lengths. 
If there’s one scale type to learn about this is the one.

They use a linear function (<code class="highlighter-rouge">y = m * x + b</code>) to interpolate across the domain and range.

<pre><code><span>var linearScale=d3.scaleLinear()</span>
  <span>.domain([0,10])</span>
  <span>.range([0,600]);</span>

<span>linearScale(0);</span>   <span>// returns 0</span>
<span>linearScale(5);</span>   <span>// returns 300</span>
<span>linearScale(10);</span>  <span>// returns 600</span></code></pre>

Typical uses are to transform data values into positions and lengths, so when creating bar charts, line charts (as well as many other chart types) they are the scale to use.

The output range can also be specified as colours:

<pre><code><span>var linearScale=d3.scaleLinear()</span>
  <span>.domain([0,10])</span>
  <span>.range(['yellow','red']);</span>

<span>linearScale(0);</span>   <span>// returns "rgb(255, 255, 0)"</span>
<span>linearScale(5);</span>   <span>// returns "rgb(255, 128, 0)"</span>
<span>linearScale(10);</span>  <span>// returns "rgb(255, 0, 0)"</span></code></pre>

This can be useful for visualisations such as choropleth maps, but also consider <code class="highlighter-rouge">scaleQuantize</code>, <code class="highlighter-rouge">scaleQuantile</code> and <code class="highlighter-rouge">scaleThreshold</code>.

<h4 id="scalepow">scalePow</h4>

More included for completeness, rather than practical usefulness, the power scale interpolates using a power (<code class="highlighter-rouge">y = m * x^k + b</code>) function. 
The exponent <code class="highlighter-rouge">k</code> is set using <code class="highlighter-rouge">.exponent()</code>:

<pre><code><span>var powerScale=d3.scalePow()</span>
  <span>.exponent(0.5)</span>
  <span>.domain([0,100])</span>
  <span>.range([0,30]);</span>

<span>powerScale(0);</span>   <span>// returns 0</span>
<span>powerScale(50);</span>  <span>// returns 21.21...</span>
<span>powerScale(100);// returns 30</span></code></pre>

<h4 id="scalesqrt">scaleSqrt</h4>

The <code class="highlighter-rouge">scaleSqrt</code> scale is a special case of the power scale (where <em>k</em> = 0.5) and is useful for sizing circles by area (rather than radius). 
(When using circle size to represent data, it’s considered better practice to <a href="https://eagereyes.org/blog/2008/linear-vs-quadratic-change">set the area, rather than the radius</a> proportionally to the data.)

<pre><code><span>var sqrtScale=d3.scaleSqrt()</span>
  <span>.domain([0,100])</span>
  <span>.range([0,30]);</span>

<span>sqrtScale(0);</span>   <span>// returns 0</span>
<span>sqrtScale(50);</span>  <span>// returns 21.21...</span>
<span>sqrtScale(100);// returns 30</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/scales/sqrt/" marginwidth="0" marginheight="0" style="width: 100%; height: 90px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/775cf431e64b6718481c06fc45dc34f9" target="_blank">View source</a>

<h4 id="scalelog">scaleLog</h4>

Log scales interpolate using a log function (<code class="highlighter-rouge">y = m * log(x) + b</code>) and can be useful when the data has an exponential nature to it.

<pre><code><span>var logScale=d3.scaleLog()</span>
  <span>.domain([10,100000])</span>
  <span>.range([0,600]);</span>

<span>logScale(10);</span>     <span>// returns 0</span>
<span>logScale(100);</span>    <span>// returns 150</span>
<span>logScale(1000);</span>   <span>// returns 300</span>
<span>logScale(100000);// returns 600</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/scales/log/" marginwidth="0" marginheight="0" style="width: 100%; height: 90px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/30d31098b607b669a7874bf4ab3c9595" target="_blank">View source</a>

<h4 id="scaletime">scaleTime</h4>

<code class="highlighter-rouge">scaleTime</code> is similar to <code class="highlighter-rouge">scaleLinear</code> except the domain is expressed as an array of dates. 
(It’s <strong>very</strong> useful when dealing with time series data.)

<pre><code><span>timeScale=d3.scaleTime()</span>
  <span>.domain([newDate(2016,0,1),newDate(2017,0,1)])</span>
  <span>.range([0,700]);</span>

<span>timeScale(newDate(2016,0,1));</span>   <span>// returns 0</span>
<span>timeScale(newDate(2016,6,1));</span>   <span>// returns 348.00...</span>
<span>timeScale(newDate(2017,0,1));</span>   <span>// returns 700</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/scales/time/" marginwidth="0" marginheight="0" style="width: 100%; height: 90px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/8948c9936c71e63ef2647bc4cc2ebf78" target="_blank">View source</a>

<h4 id="scalesequential">scaleSequential</h4>

<code class="highlighter-rouge">scaleSequential</code> is used for mapping continuous values to an output range determined by a preset (or custom) <strong>interpolator</strong>. 
(An interpolator is a function that accepts input between 0 and 1 and outputs an interpolated value between two numbers, colours, strings etc.)

D3 provides a number of preset interpolators including many colour ones. 
For example we can use <code class="highlighter-rouge">d3.interpolateRainbow</code> to create the well known rainbow colour scale:

<pre><code><span>var sequentialScale=d3.scaleSequential()</span>
  <span>.domain([0,100])</span>
  <span>.interpolator(d3.interpolateRainbow);</span>

<span>sequentialScale(0);</span>   <span>// returns 'rgb(110, 64, 170)'</span>
<span>sequentialScale(50);</span>  <span>// returns 'rgb(175, 240, 91)'</span>
<span>sequentialScale(100);// returns 'rgb(110, 64, 170)'</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/scales/sequential/" marginwidth="0" marginheight="0" style="width: 100%; height: 90px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/de07fcf34538cd6f8459e17038563ed3" target="_blank">View source</a>

Note that the interpolator determines the output range so you don’t need to specify the range yourself.

The example below shows some of the other colour interpolators provided by D3:

<iframe class="db center" src="https://www.d3indepth.com/blocks/scales/sequential-options/" marginwidth="0" marginheight="0" style="width: 100%; height: 600px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/89ced137bece23b908cf51580d5e082d" target="_blank">View source</a>

There’s also a plug-in <a href="https://github.com/d3/d3-scale-chromatic">d3-scale-chromatic</a> which provides the well known <a href="http://colorbrewer2.org/#type=sequential&amp;scheme=BuGn&amp;n=3">ColorBrewer</a> colour schemes.

<h4 id="clamping">Clamping</h4>

By default <code class="highlighter-rouge">scaleLinear</code>, <code class="highlighter-rouge">scalePow</code>, <code class="highlighter-rouge">scaleSqrt</code>, <code class="highlighter-rouge">scaleLog</code>, <code class="highlighter-rouge">scaleTime</code> and <code class="highlighter-rouge">scaleSequential</code> allow input outside the domain. 
For example:

<pre><code><span>var linearScale=d3.scaleLinear()</span>
  <span>.domain([0,10])</span>
  <span>.range([0,100]);</span>

<span>linearScale(20);</span>  <span>// returns 200</span>
<span>linearScale(-10);// returns -100</span></code></pre>

In this instance the scale function uses extrapolation for values outside the domain.

If we’d like the scale function to be restricted to input values inside the domain we can ‘clamp’ the scale function using <code class="highlighter-rouge">.clamp()</code>:

<pre><code><span>linearScale.clamp(true);</span>

<span>linearScale(20);</span>  <span>// returns 100</span>
<span>linearScale(-10);// returns 0</span></code></pre>

We can switch off clamping using <code class="highlighter-rouge">.clamp(false)</code>.

<h4 id="nice">Nice</h4>

If the domain has been computed automatically from real data (e.g. 
by using <code class="highlighter-rouge">d3.extent</code>) the start and end values might not be round figures. 
This isn’t necessarily a problem, but if using the scale to define an axis, it can look a bit untidy:

<pre><code><span>var data=[0.243,0.584,0.987,0.153,0.433];</span>
<span>var extent=d3.extent(data);</span>

<span>var linearScale=d3.scaleLinear()</span>
  <span>.domain(extent)</span>
  <span>.range([0,100]);</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/scales/axis/" marginwidth="0" marginheight="0" style="width: 100%; height: 110px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/21354e1a7c753624e0a76b7984ae65c1" target="_blank">View source</a>

Therefore D3 provides a function <code class="highlighter-rouge">.nice()</code> on the scales in this section which will round the domain to ‘nice’ round values:

<pre><code><span>linearScale.nice();</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/scales/nice/" marginwidth="0" marginheight="0" style="width: 100%; height: 110px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/31a6253a01d29e99fa2daf0364b59019" target="_blank">View source</a>

Note that <code class="highlighter-rouge">.nice()</code> must be called each time the domain is updated.

<h4 id="multiple-segments">Multiple segments</h4>

The domain and range of <code class="highlighter-rouge">scaleLinear</code>, <code class="highlighter-rouge">scalePow</code>, <code class="highlighter-rouge">scaleSqrt</code>, <code class="highlighter-rouge">scaleLog</code> and <code class="highlighter-rouge">scaleTime</code> usually consists of two values, but if we provide 3 or more values the scale function is subdivided into multiple segments:

<pre><code><span>var linearScale=d3.scaleLinear()</span>
  <span>.domain([-10,0,10])</span>
  <span>.range(['red','#ddd','blue']);</span>

<span>linearScale(-10);</span>  <span>// returns "rgb(255, 0, 0)"</span>
<span>linearScale(0);</span>    <span>// returns "rgb(221, 221, 221)"</span>
<span>linearScale(5);</span>    <span>// returns "rgb(111, 111, 238)"</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/scales/multisegment/" marginwidth="0" marginheight="0" style="width: 100%; height: 90px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/55f3253d6232f682708a3db0da207e65" target="_blank">View source</a>

Typically multiple segments are used for distinguishing between negative and positive values (such as in the example above). 
We can use as many segments as we like as long as the domain and range are of the same length.

<h4 id="inversion">Inversion</h4>

The <code class="highlighter-rouge">.invert()</code> method allows us to determine a scale function’s <strong>input</strong> value given an <strong>output</strong> value (provided the scale function has a numeric domain):

<pre><code><span>var linearScale=d3.scaleLinear()</span>
  <span>.domain([0,10])</span>
  <span>.range([0,100]);</span>

<span>linearScale.invert(50);</span>   <span>// returns 5</span>
<span>linearScale.invert(100);</span>  <span>// returns 10</span></code></pre>

A common use case is when we want to convert a user’s click along an axis into a domain value:

<iframe class="db center" src="https://www.d3indepth.com/blocks/scales/invert/" marginwidth="0" marginheight="0" style="width: 100%; height: 100px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/12af91c5f58bc9eedf96f7c0a9f5622f" target="_blank">View source</a>

<h3>Scales with continuous input and discrete output</h3>

<h4 id="scalequantize">scaleQuantize</h4>

<code class="highlighter-rouge">scaleQuantize</code> accepts continuous input and outputs a number of discrete quantities defined by the range.

<pre><code><span>var quantizeScale=d3.scaleQuantize()</span>
  <span>.domain([0,100])</span>
  <span>.range(['lightblue','orange','lightgreen','pink']);</span>

<span>quantizeScale(10);</span>   <span>// returns 'lightblue'</span>
<span>quantizeScale(30);</span>  <span>// returns 'orange'</span>
<span>quantizeScale(90);</span>  <span>// returns 'pink'</span></code></pre>

Each range value is mapped to an equal sized chunk in the domain so in the example above:

. 0 ≤ <em>u</em> &lt; 25 is mapped to ‘lightblue’
. 25 ≤ <em>u</em> &lt; 50 is mapped to ‘orange’
. 50 ≤ <em>u</em> &lt; 75 is mapped to ‘lightgreen’
. 75 ≤ <em>u</em> &lt; 100 is mapped to ‘pink’

where <em>u</em> is the input value.

<iframe class="db center" src="https://www.d3indepth.com/blocks/scales/quantize/" marginwidth="0" marginheight="0" style="width: 100%; height: 60px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/d22a326dc44b2d47d9f18815fbccf178" target="_blank">View source</a>

Note also that input values outside the domain are clamped so in our example <code class="highlighter-rouge">quantizeScale(-10)</code> returns ‘lightblue’ and <code class="highlighter-rouge">quantizeScale(110)</code> returns ‘pink’.

<h4 id="scalequantile">scaleQuantile</h4>

<code class="highlighter-rouge">scaleQuantile</code> maps continuous numeric input to discrete values. 
The domain is defined by <strong>an array of numbers</strong>:

<pre><code><span>var myData=[0,5,7,10,20,30,35,40,60,62,65,70,80,90,100];</span>

<span>var quantileScale=d3.scaleQuantile()</span>
  <span>.domain(myData)</span>
  <span>.range(['lightblue','orange','lightgreen']);</span>

<span>quantileScale(0);</span>   <span>// returns 'lightblue'</span>
<span>quantileScale(20);</span>  <span>// returns 'lightblue'</span>
<span>quantileScale(30);</span>  <span>// returns 'orange'</span>
<span>quantileScale(65);</span>  <span>// returns 'lightgreen'</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/scales/quantile/" marginwidth="0" marginheight="0" style="width: 100%; height: 90px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/28a4d5956b1318b4a007b10c3820f544" target="_blank">View source</a>

The (sorted) domain array is divided into <em>n</em> equal sized groups where <em>n</em> is the number of range values.

Therefore in the above example the domain array is split into 3 groups where:

. the first 5 values are mapped to ‘lightblue’
. the next 5 values to ‘orange’ and
. the last 5 values to ‘lightgreen’.

The split points of the domain can be accessed using <code class="highlighter-rouge">.quantiles()</code>:

<pre><code><span>quantileScale.quantiles();</span>  <span>// returns [26.66..., 63]</span></code></pre>

If the range contains 4 values <code class="highlighter-rouge">quantileScale</code> computes the <strong>quartiles</strong> of the data. 
In other words, the lowest 25% of the data is mapped to <code class="highlighter-rouge">range[0]</code>, the next 25% of the data is mapped to <code class="highlighter-rouge">range[1]</code> etc.

<h4 id="scalethreshold">scaleThreshold</h4>

<code class="highlighter-rouge">scaleThreshold</code> maps continuous numeric input to discrete values defined by the range. 
<em>n-1</em> domain split points are specified where <em>n</em> is the number of range values.

In the following example we split the domain at <code class="highlighter-rouge">0</code>, <code class="highlighter-rouge">50</code> and <code class="highlighter-rouge">100</code>

. <em>u</em> &lt; 0 is mapped to ‘#ccc’
. 0 ≤ <em>u</em> &lt; 50 to ‘lightblue’
. 50 ≤ <em>u</em> &lt; 100 to ‘orange’
. <em>u</em> ≥ 100 to ‘#ccc’

where <em>u</em> is the input value.

<pre><code><span>var thresholdScale=d3.scaleThreshold()</span>
  <span>.domain([0,50,100])</span>
  <span>.range(['#ccc','lightblue','orange','#ccc']);</span>

<span>thresholdScale(-10);</span>  <span>// returns '#ccc'</span>
<span>thresholdScale(20);</span>   <span>// returns 'lightblue'</span>
<span>thresholdScale(70);</span>   <span>// returns 'orange'</span>
<span>thresholdScale(110);</span>  <span>// returns '#ccc'</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/scales/threshold/" marginwidth="0" marginheight="0" style="width: 100%; height: 90px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/40fea6694f84dfda46b00ea6ce2cf919" target="_blank">View source</a>

<h3>Scales with discrete input and discrete output</h3>

<h4 id="scaleordinal">scaleOrdinal</h4>

<code class="highlighter-rouge">scaleOrdinal</code> maps discrete values (specified by an array) to discrete values (also specified by an array). 
The domain array specifies the possible input values and the range array the output values. 
The range array will repeat if it’s shorter than the domain array.

<pre><code><span>var myData=['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec']</span>

<span>var ordinalScale=d3.scaleOrdinal()</span>
  <span>.domain(myData)</span>
  <span>.range(['black','#ccc','#ccc']);</span>

<span>ordinalScale('Jan');</span>  <span>// returns 'black';</span>
<span>ordinalScale('Feb');</span>  <span>// returns '#ccc';</span>
<span>ordinalScale('Mar');</span>  <span>// returns '#ccc';</span>
<span>ordinalScale('Apr');</span>  <span>// returns 'black';</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/scales/ordinal/" marginwidth="0" marginheight="0" style="width: 100%; height: 80px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/fabe4d1adbf658c0b73c74d3ea36d465" target="_blank">View source</a>

By default if a value that’s not in the domain is used as input, the scale will implicitly add the value to the domain:

<pre><code><span>ordinalScale('Monday');</span>  <span>// returns 'black';</span></code></pre>

If this isn’t the desired behvaiour we can specify an output value for unknown values using <code class="highlighter-rouge">.unknown()</code>:

<pre><code><span>ordinalScale.unknown('Not a month');</span>
<span>ordinalScale('Tuesday');// returns 'Not a month'</span></code></pre>

D3 can also provide preset colour schemes (from <a href="http://colorbrewer2.org/#type=sequential&amp;scheme=BuGn&amp;n=3">ColorBrewer</a>):

<pre><code><span>var ordinalScale=d3.scaleOrdinal()</span>
  <span>.domain(myData)</span>
  <span>.range(d3.schemePaired);</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/scales/ordinal-scheme/" marginwidth="0" marginheight="0" style="width: 100%; height: 80px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/ab3336867f7469e0f4608b59b8aa125c" target="_blank">View source</a>

(Note that the Brewer colour schemes are defined within a separate file d3-scale-chromatic.js.)

<h4 id="scaleband">scaleBand</h4>

When creating bar charts <code class="highlighter-rouge">scaleBand</code> helps to determine the geometry of the bars, taking into account padding between each bar. 
The domain is specified as an array of values (one value for each band) and the range as the minimum and maximum extents of the bands (e.g. 
the total width of the bar chart).

In effect <code class="highlighter-rouge">scaleBand</code> will split the range into <em>n</em> bands (where <em>n</em> is the number of values in the domain array) and compute the positions and widths of the bands taking into account any specified padding.

<pre><code><span>var bandScale=d3.scaleBand()</span>
  <span>.domain(['Mon','Tue','Wed','Thu','Fri'])</span>
  <span>.range([0,200]);</span>

<span>bandScale('Mon');// returns 0</span>
<span>bandScale('Tue');// returns 40</span>
<span>bandScale('Fri');// returns 160</span></code></pre>

The width of each band can be accessed using <code class="highlighter-rouge">.bandwidth()</code>:

<pre><code><span>bandScale.bandwidth();</span>  <span>// returns 40</span></code></pre>

Two types of padding may be configured:

. <code class="highlighter-rouge">paddingInner</code> which specifies (as a percentage of the band width) the amount of padding between each band
. <code class="highlighter-rouge">paddingOuter</code> which specifies (as a percentage of the band width) the amount of padding before the first band and after the last band

Let’s add some inner padding to the example above:

<pre><code><span>bandScale.paddingInner(0.05);</span>

<span>bandScale.bandWidth();</span>  <span>// returns 38.38...</span>
<span>bandScale('Mon');</span>       <span>// returns 0</span>
<span>bandScale('Tue');</span>       <span>// returns 40.40...</span></code></pre>

Putting this all together we can create this bar chart:

<iframe class="db center" src="https://www.d3indepth.com/blocks/scales/band/" marginwidth="0" marginheight="0" style="width: 100%; height: 250px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/1aef77d17863e603ff4e84226db5b227" target="_blank">View source</a>

<h4 id="scalepoint">scalePoint</h4>

<code class="highlighter-rouge">scalePoint</code> creates scale functions that map from a discrete set of values to equally spaced points along the specified range:

<pre><code><span>var pointScale=d3.scalePoint()</span>
  <span>.domain(['Mon','Tue','Wed','Thu','Fri'])</span>
  <span>.range([0,500]);</span>

<span>pointScale('Mon');</span>  <span>// returns 0</span>
<span>pointScale('Tue');</span>  <span>// returns 125</span>
<span>pointScale('Fri');</span>  <span>// returns 500</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/scales/point/" marginwidth="0" marginheight="0" style="width: 100%; height: 90px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/4ed842af47f23eeb5cf1755d4bb67073" target="_blank">View source</a>

The distance between the points can be accessed using <code class="highlighter-rouge">.step()</code>:

<pre><code><span>pointScale.step();</span>  <span>// returns 125</span></code></pre>

Outside padding can be specified as the ratio of the padding to point spacing. 
For example, for the outside padding to be a quarter of the point spacing use a value of 0.25:

<pre><code><span>pointScale.padding(0.25);</span>

<span>pointScale('Mon');</span>  <span>// returns 27.77...</span>
<span>pointScale.step();</span>  <span>// returns 111.11...</span></code></pre>

<h4 id="further-reading">Further reading</h4>

<a href="https://github.com/d3/d3-scale-chromatic">ColorBrewer schemes for D3</a>

<a href="https://medium.com/@mbostock/introducing-d3-scale-61980c51545f#.lk2cs7x7k">Mike Bostock on d3-scale</a>

<!-- <div class="disqus-wrapper">
	<h2>Comments</h2>
	<div id="disqus_thread"></div>
	<script>

	/**
	 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
	 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
	var disqus_config = function () {
	    this.page.url = 'https://www.d3indepth.com/scales/';  // Replace PAGE_URL with your page's canonical URL variable
	    this.page.identifier = 'Scale functions'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
	};
	
	(function() { // DON'T EDIT BELOW THIS LINE
	    var d = document, s = d.createElement('script');
	    s.src = '//d3indepth.disqus.com/embed.js';
	    s.setAttribute('data-timestamp', +new Date());
	    (d.head || d.body).appendChild(s);
	})();
	</script>
	<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
	                                    
</div> -->


  </div>
</div>

      </div>

      
      <div class="mt4 pt4 bt b--black-10">
        <div class="black-70 f6 ph3 ph5-ns">


<h2>Shapes</h2>

This chapter looks at the functions D3 provides for taking the effort out of creating vector shapes such as lines:

<iframe class="db center" src="https://www.d3indepth.com/blocks/shapes/line-example/" marginwidth="0" marginheight="0" style="width: 100%; height: 120px;" scrolling="yes"></iframe>

curves:

<iframe class="db center" src="https://www.d3indepth.com/blocks/shapes/curve-example/" marginwidth="0" marginheight="0" style="width: 100%; height: 120px;" scrolling="yes"></iframe>

pie chart segments:

<iframe class="db center" src="https://www.d3indepth.com/blocks/shapes/pie-example/" marginwidth="0" marginheight="0" style="width: 100%; height: 140px;" scrolling="yes"></iframe>

and symbols:

<iframe class="db center" src="https://www.d3indepth.com/blocks/shapes/symbol/" marginwidth="0" marginheight="0" style="width: 100%; height: 130px;" scrolling="yes"></iframe>

<h3>SVG</h3>

First a little background on Scalable Vector Graphics (SVG). 
The shapes in the examples above are made up of SVG <code class="highlighter-rouge">path</code> elements. 
Each of them has a <code class="highlighter-rouge">d</code> attribute (path data) which defines the shape of the path. 
The path data consists of a list of commands (e.g. 
<code class="highlighter-rouge">M0,80L100,100L200,30L300,50L400,40L500,80</code>) such as ‘move to’ and ‘draw a line to’ (see the <a href="https://www.w3.org/TR/SVG/paths.html">SVG specification</a> for more detail).

We could create path data ourselves but D3 can help us using functions known as generators. 
These come in various forms:

<table class="table table-bordered">
  <tr><td><a href="#line-generator">line</a></td><td>Generates path data for a multi-segment line (typically for line charts)</td></tr>
  <tr><td><a href="#area-generator">area</a></td><td>Generates path data for an area (typically for stacked line charts and streamgraphs)</td></tr>
  <tr><td><a href="#stack-generator">stack</a></td><td>Generates stack data from multi-series data</td></tr>
  <tr><td><a href="#arc-generator">arc</a></td><td>Generates path data for an arc (typically for pie charts)</td></tr>
  <tr><td><a href="#pie-generator">pie</a></td><td>Generates pie angle data from array of data</td></tr>
  <tr><td><a href="#symbols">symbol</a></td><td>Generates path data for symbols such as plus, star, diamond</td></tr>
</table>

<h3>Line generator</h3>

D3’s line generator produces a <strong>path data string</strong> given an <strong>array of co-ordinates</strong>.

We start by constructing a line generator using <code class="highlighter-rouge">d3.line()</code>:

<pre><code><span>var lineGenerator=d3.line();</span></code></pre>

<code class="highlighter-rouge">lineGenerator</code> is just a function that accepts an array of co-ordinates and outputs a path data string.

So let’s go ahead and define an array of co-ordinates:

<pre><code><span>var points=[</span>
  <span>[0,80],</span>
  <span>[100,100],</span>
  <span>[200,30],</span>
  <span>[300,50],</span>
  <span>[400,40],</span>
  <span>[500,80]</span>
<span>];</span></code></pre>

and now call <code class="highlighter-rouge">lineGenerator</code>, passing in our array:

<pre><code><span>var pathData=lineGenerator(points);</span>
<span>// pathData is "M0,80L100,100L200,30L300,50L400,40L500,80"</span></code></pre>

All <code class="highlighter-rouge">lineGenerator</code> has done is create a string of <code class="highlighter-rouge">M</code> (move to) and <code class="highlighter-rouge">L</code> (line to) commands from our array of points. 
We can now use <code class="highlighter-rouge">pathData</code> to set the <code class="highlighter-rouge">d</code> attribute of a <code class="highlighter-rouge">path</code> element:

<pre><code><span>d3.select('path')</span>
  <span>.attr('d',pathData);</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/shapes/line/" marginwidth="0" marginheight="0" style="width: 100%; height: 120px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/dd0e2e52b32f5c646b75acdfcb46864e" target="_blank">View source</a>

We can also configure our line generator in a number of ways:

. <code class="highlighter-rouge">.x()</code> and <code class="highlighter-rouge">.y()</code> accessor functions,
. <code class="highlighter-rouge">.defined()</code> (to handle missing data),
. <code class="highlighter-rouge">.curve</code> (to specify how the points are interpolated) and
. <code class="highlighter-rouge">.context()</code> to render to a canvas element.

<h4 id="x-and-y-accessor-functions">.x() and .y() accessor functions</h4>

By default each array element represents a co-ordinate defined by a 2-dimensional array (e.g. 
<code class="highlighter-rouge">[0, 100]</code>). 
However we can specify how the line generator interprets each array element using accessor functions <code class="highlighter-rouge">.x()</code> and <code class="highlighter-rouge">.y()</code>.

For example suppose our data is an array of objects:

<pre><code><span>var data=[</span>
  <span>{value:10},</span>
  <span>{value:50},</span>
  <span>{value:30},</span>
  <span>{value:40},</span>
  <span>{value:20},</span>
  <span>{value:70},</span>
  <span>{value:50}</span>
<span>];</span></code></pre>

We can define the accessors like so:

<pre><code><span>lineGenerator</span>
  <span>.x(function(d,i){</span>
    <span>returnxScale(i);</span>
  <span>})</span>
  <span>.y(function(d){</span>
    <span>returnyScale(d.value);</span>
  <span>});</span></code></pre>

In this example we’re using the index of the array to define the x position. 
Note also that we’re using <a href="../scales">scale functions</a>:

<iframe class="db center" src="https://www.d3indepth.com/blocks/shapes/line-with-scales/" marginwidth="0" marginheight="0" style="width: 100%; height: 170px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/5df095dd1604b08541ac6bd62adce3a0" target="_blank">View source</a>

<h4 id="defined">.defined()</h4>

We can configure the behaviour when there’s missing data. 
Suppose our data has a gap in it:

<pre><code><span>var points=[</span>
  <span>[0,80],</span>
  <span>[100,100],</span>
  <span>null,</span>
  <span>[300,50],</span>
  <span>[400,40],</span>
  <span>[500,80]</span>
<span>];</span></code></pre>

we can tell our line generator that each co-ordinate is valid only if it’s non-null:

<pre><code><span>lineGenerator</span>
  <span>.defined(function(d){</span>
    <span>returnd!==null;</span>
  <span>});</span></code></pre>

Now when we call <code class="highlighter-rouge">lineGenerator</code> it leaves a gap in the line:

<iframe class="db center" src="https://www.d3indepth.com/blocks/shapes/line-defined/" marginwidth="0" marginheight="0" style="width: 100%; height: 120px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/93903fe3ff9d31b7bbdd3f6b443aa8f6" target="_blank">View source</a>

(Without configuring <code class="highlighter-rouge">.defined</code> this last call returns an error.)

<h4 id="curve">.curve()</h4>

We can also configure how the points are interpolated. 
For example we can interpolate each data point with a B-spline:

<pre><code><span>var lineGenerator=d3.line()</span>
  <span>.curve(d3.curveCardinal);</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/shapes/line-curve/" marginwidth="0" marginheight="0" style="width: 100%; height: 120px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/64be9fc39a92ef074034e9a8fb29dcce" target="_blank">View source</a>

Although there’s a multitude of different curve types available they can be divided into two camps: those which pass through the points (<code class="highlighter-rouge">curveLinear</code>, <code class="highlighter-rouge">curveCardinal</code>, <code class="highlighter-rouge">curveCatmullRom</code>, <code class="highlighter-rouge">curveMonotone</code>, <code class="highlighter-rouge">curveNatural</code> and <code class="highlighter-rouge">curveStep</code>) and those that don’t (<code class="highlighter-rouge">curveBasis</code> and <code class="highlighter-rouge">curveBundle</code>).

See the <a href="http://bl.ocks.org/d3indepth/raw/b6d4845973089bc1012dec1674d3aff8/" target="_blank">curve explorer</a> for more information.

<h4 id="rendering-to-canvas">Rendering to canvas</h4>

By default the shape generators output SVG path data. 
However they can be configured to draw to a canvas element using the <code class="highlighter-rouge">.context()</code> function:

<pre><code><span>var context=d3.select('canvas').node().getContext('2d');</span>

<span>lineGenerator.context(context);</span>

<span>context.strokeStyle='#999';</span>
<span>context.beginPath();</span>
<span>lineGenerator(points);</span>
<span>context.stroke();</span></code></pre>

	<a href="https://bl.ocks.org/d3indepth/90851f3bd602f17a7f32691819e2ed2e" target="_blank">View source</a>

<h4 id="radial-line">Radial line</h4>

The radial line generator is similar to the line generator but the points are transformed by <strong>angle</strong> (working clockwise from 12 o’clock) and <strong>radius</strong>, rather than <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code>:

<pre><code><span>var radialLineGenerator=d3.radialLine();</span>

<span>var points=[</span>
  <span>[0,80],</span>
  <span>[Math.PI*0.25,80],</span>
  <span>[Math.PI*0.5,30],</span>
  <span>[Math.PI*0.75,80],</span>
  <span>[Math.PI,80],</span>
  <span>[Math.PI*1.25,80],</span>
  <span>[Math.PI*1.5,80],</span>
  <span>[Math.PI*1.75,80],</span>
  <span>[Math.PI*2,80]</span>
<span>];</span>

<span>var pathData=radialLineGenerator(points);</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/shapes/radial-line/" marginwidth="0" marginheight="0" style="width: 100%; height: 210px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/39d798286a4bf92cee446add65290d70" target="_blank">View source</a>

Accessor functions <code class="highlighter-rouge">.angle()</code> and <code class="highlighter-rouge">.radius()</code> are also available:

<pre><code><span>radialLineGenerator</span>
  <span>.angle(function(d){</span>
    <span>returnd.a;</span>
  <span>})</span>
  <span>.radius(function(d){</span>
    <span>returnd.r;</span>
  <span>});</span>

<span>var points=[</span>
  <span>{a:0,r:80},</span>
  <span>{a:Math.PI*0.25,r:80},</span>
  <span>{a:Math.PI*0.5,r:30},</span>
  <span>{a:Math.PI*0.75,r:80},</span>
  <span>...</span>
<span>];</span>

<span>var pathData=radialLineGenerator(points);</span></code></pre>

<h3>Area generator</h3>

The area generator outputs path data that defines an area between two lines. 
By default it generates the area between <code class="highlighter-rouge">y=0</code> and a multi-segment line defined by an array of points:

<pre><code><span>var areaGenerator=d3.area();</span>

<span>var points=[</span>
  <span>[0,80],</span>
  <span>[100,100],</span>
  <span>[200,30],</span>
  <span>[300,50],</span>
  <span>[400,40],</span>
  <span>[500,80]</span>
<span>];</span>

<span>var pathData=areaGenerator(points);</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/shapes/area/" marginwidth="0" marginheight="0" style="width: 100%; height: 110px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/a87bb6104d85931611e2ec9bacf5ea3a" target="_blank">View source</a>

We can configure the baseline using the <code class="highlighter-rouge">.y0()</code> accessor function:

<pre><code><span>areaGenerator.y0(150);</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/shapes/area-baseline/" marginwidth="0" marginheight="0" style="width: 100%; height: 160px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/1b232d99622717cc02794ffb3ff66ee8" target="_blank">View source</a>

We can also feed a function into the <code class="highlighter-rouge">.y0()</code> accessor, likewise the <code class="highlighter-rouge">.y1()</code> accessor:

<pre><code><span>areaGenerator</span>
  <span>.x(function(d){</span>
    <span>returnd.x;</span>
  <span>})</span>
  <span>.y0(function(d){</span>
    <span>returnyScale(d.low);</span>
  <span>})</span>
  <span>.y1(function(d){</span>
    <span>returnyScale(d.high);</span>
  <span>});</span>

<span>var points=[</span>
  <span>{x:0,low:30,high:80},</span>
  <span>{x:100,low:80,high:100},</span>
  <span>{x:200,low:20,high:30},</span>
  <span>{x:300,low:20,high:50},</span>
  <span>{x:400,low:10,high:40},</span>
  <span>{x:500,low:50,high:80}</span>
<span>];</span></code></pre>

Typically <code class="highlighter-rouge">.y0()</code> defines the baseline and <code class="highlighter-rouge">.y1()</code> the top line. 
Note that we’ve also used the <code class="highlighter-rouge">.x()</code> accessor to define the x co-ordinate.

<iframe class="db center" src="https://www.d3indepth.com/blocks/shapes/area-y0-and-y1-accessors/" marginwidth="0" marginheight="0" style="width: 100%; height: 210px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/f238d652d30f3fa2b8deda39e1a1eee4" target="_blank">View source</a>

As with the line generator we can specify the way in which the points are interpolated (<code class="highlighter-rouge">.curve()</code>), handle missing data (<code class="highlighter-rouge">.defined()</code>) and render to canvas (<code class="highlighter-rouge">.context()</code>);

<h4 id="radial-area">Radial area</h4>

The radial area generator is similar to the area generator but the points are transformed by <strong>angle</strong> (working clockwise from 12 o’clock) and <strong>radius</strong>, rather than <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code>:

<pre><code><span>var radialAreaGenerator=d3.radialArea()</span>
  <span>.angle(function(d){</span>
    <span>returnd.angle;</span>
  <span>})</span>
  <span>.innerRadius(function(d){</span>
    <span>returnd.r0;</span>
  <span>})</span>
  <span>.outerRadius(function(d){</span>
    <span>returnd.r1;</span>
  <span>});</span>

<span>var points=[</span>
  <span>{angle:0,r0:30,r1:80},</span>
  <span>{angle:Math.PI*0.25,r0:30,r1:70},</span>
  <span>{angle:Math.PI*0.5,r0:30,r1:80},</span>
  <span>{angle:Math.PI*0.75,r0:30,r1:70},</span>
  <span>{angle:Math.PI,r0:30,r1:80},</span>
  <span>{angle:Math.PI*1.25,r0:30,r1:70},</span>
  <span>{angle:Math.PI*1.5,r0:30,r1:80},</span>
  <span>{angle:Math.PI*1.75,r0:30,r1:70},</span>
  <span>{angle:Math.PI*2,r0:30,r1:80}</span>
<span>];</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/shapes/radial-area/" marginwidth="0" marginheight="0" style="width: 100%; height: 210px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/7bb7f2e389d0bf2ff1a622c4c7833a80" target="_blank">View source</a>

<h3>Stack generator</h3>

The stack generator takes an array of <strong>multi-series data</strong> and generates an array for each series where each array contains <strong>lower and upper values</strong> for each data point. 
The lower and upper values are computed so that each series is stacked on top of the previous series.

<pre><code><span>var data=[</span>
  <span>{day:'Mon',apricots:120,blueberries:180,cherries:100},</span>
  <span>{day:'Tue',apricots:60,</span>  <span>blueberries:185,cherries:105},</span>
  <span>{day:'Wed',apricots:100,blueberries:215,cherries:110},</span>
  <span>{day:'Thu',apricots:80,</span>  <span>blueberries:230,cherries:105},</span>
  <span>{day:'Fri',apricots:120,blueberries:240,cherries:105}</span>
<span>];</span>

<span>var stack=d3.stack()</span>
  <span>.keys(['apricots','blueberries','cherries']);</span>

<span>var stackedSeries=stack(data);</span>

<span>// stackedSeries = [</span>
<span>//   [ [0, 120],   [0, 60],   [0, 100],    [0, 80],    [0, 120] ],   // Apricots</span>
<span>//   [ [120, 300], [60, 245], [100, 315],  [80, 310],  [120, 360] ], // Blueberries</span>
<span>//   [ [300, 400], [245, 350], [315, 425], [310, 415], [360, 465] ]  // Cherries</span>
<span>// ]</span></code></pre>

The <code class="highlighter-rouge">.keys()</code> configuration function specifies which series are included in the stack generation.

The data output by the stack generator can be used however you like, but typically it’ll be used to produce stacked bar charts:

<iframe class="db center" src="https://www.d3indepth.com/blocks/shapes/stack-bar/" marginwidth="0" marginheight="0" style="width: 100%; height: 110px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/30a7091e97b03eeba2a6a3ca1067ca92" target="_blank">View source</a>

or when used in conjunction with the area generator, stacked line charts:

<iframe class="db center" src="https://www.d3indepth.com/blocks/shapes/stack/" marginwidth="0" marginheight="0" style="width: 100%; height: 210px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/e4efd402b4d9fdb2088ccdf3135745c3" target="_blank">View source</a>

<h4 id="order">.order()</h4>

The order of the stacked series can be configured using <code class="highlighter-rouge">.order()</code>:

<pre><code><span>stack.order(d3.stackOrderInsideOut);</span></code></pre>

Each series is summed and then sorted according to the chosen order. 
The possible orders are:

<table class="table table-bordered">
  <tr><td>stackOrderNone</td><td>(Default) Series in same order as specified in .keys()</td></tr>
  <tr><td>stackOrderAscending</td><td>Smallest series at the bottom</td></tr>
  <tr><td>stackOrderDescending</td><td>Largest series at the bottom</td></tr>
  <tr><td>stackOrderInsideOut</td><td>Largest series in the middle</td></tr>
  <tr><td>stackOrderReverse</td><td>Reverse of stackOrderNone</td></tr>
</table>

<h4 id="offset">.offset()</h4>

By default the stacked series have a baseline of zero. 
However we can configure the offset of the stack generator to achieve different effects. 
For example we can normalise the stacked series so that they fill the same height:

<pre><code><span>stack.offset(d3.stackOffsetExpand);</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/shapes/stack-offset-expand/" marginwidth="0" marginheight="0" style="width: 100%; height: 160px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/aef57694ac8f711ab2e8a5c96a349ea1" target="_blank">View source</a>

The available offsets are:

<table class="table table-bordered">
  <tr><td>stackOffsetNone</td><td>(Default) No offset</td></tr>
  <tr><td>stackOffsetExpand</td><td>Sum of series is normalised (to a value of 1)</td></tr>
  <tr><td>stackOffsetSilhouette</td><td>Center of stacks is at y=0</td></tr>
  <tr><td>stackOffsetWiggle</td><td>Wiggle of layers is minimised (typically used for streamgraphs)</td></tr>
</table>

Here’s a streamgraph example using <code class="highlighter-rouge">stackOffsetWiggle</code>:

<iframe class="db center" src="https://www.d3indepth.com/blocks/shapes/stack-stream/" marginwidth="0" marginheight="0" style="width: 100%; height: 180px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/3c7cb147aab8cf0cdbfb83b4ee7a847c" target="_blank">View source</a>

<h3>Arc generator</h3>

Arc generators produce path data from angle and radius values. 
An arc generator is created using:

<pre><code><span>var arcGenerator=d3.arc();</span></code></pre>

It can then be passed an object containing <code class="highlighter-rouge">startAngle</code>, <code class="highlighter-rouge">endAngle</code>, <code class="highlighter-rouge">innerRadius</code> and <code class="highlighter-rouge">outerRadius</code> properties to produce the path data:

<pre><code><span>var pathData=arcGenerator({</span>
  <span>startAngle:0,</span>
  <span>endAngle:0.25*Math.PI,</span>
  <span>innerRadius:50,</span>
  <span>outerRadius:100</span>
<span>});</span>

<span>// pathData is "M6.123233995736766e-15,-100A100,100,0,0,1,70.71067811865476,-70.710678</span>
<span>// 11865474L35.35533905932738,-35.35533905932737A50,50,0,0,0,3.061616997868383e-15,-50Z"</span></code></pre>

(<code class="highlighter-rouge">startAngle</code> and <code class="highlighter-rouge">endAngle</code> are measured clockwise from the 12 o’clock in radians.)

<iframe class="db center" src="https://www.d3indepth.com/blocks/shapes/arc/" marginwidth="0" marginheight="0" style="width: 100%; height: 120px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/3bb2dc908c090e8d2405257caadb20fa" target="_blank">View source</a>

<h4 id="configuration">Configuration</h4>

We can configure <code class="highlighter-rouge">innerRadius</code>, <code class="highlighter-rouge">outerRadius</code>, <code class="highlighter-rouge">startAngle</code>, <code class="highlighter-rouge">endAngle</code> so that we don’t have to pass them in each time:

<pre><code><span>arcGenerator</span>
  <span>.innerRadius(20)</span>
  <span>.outerRadius(100);</span>

<span>pathData=arcGenerator({</span>
  <span>startAngle:0,</span>
  <span>endAngle:0.25*Math.PI</span>
<span>});</span>

<span>// pathData is "M6.123233995736766e-15,-100A100,100,0,0,1,70.71067811865476,-70.71067811</span>
<span>// 865474L14.142135623730951,-14.14213562373095A20,20,0,0,0,1.2246467991473533e-15,-20Z"</span></code></pre>

	<a href="https://bl.ocks.org/d3indepth/b52f9ab1dde3a1953367395d10483be4" target="_blank">View source</a>

We can also configure corner radius (<code class="highlighter-rouge">cornerRadius</code>) and the padding between arc segments (<code class="highlighter-rouge">padAngle</code> and <code class="highlighter-rouge">padRadius</code>):

<pre><code><span>arcGenerator</span>
  <span>.padAngle(.02)</span>
  <span>.padRadius(100)</span>
  <span>.cornerRadius(4);</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/shapes/arc-padding-and-radius/" marginwidth="0" marginheight="0" style="width: 100%; height: 230px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/ef3c33c21668db4217bf538cff522d5b" target="_blank">View source</a>

Arc padding takes two parameters <code class="highlighter-rouge">padAngle</code> and <code class="highlighter-rouge">padRadius</code> which when multiplied together define the distance between adjacent segments. 
Thus in the example above, the padding distance is <code class="highlighter-rouge">0.02 * 100 = 2</code>. 
Note that the padding is calculated to maintain (where possible) parallel segment boundaries.

<blockquote>You might ask why there isn't a single parameter padDistance for defining the padding distance. 
It's split into two parameters so that the pie generator (see later) doesn't need to concern itself with radius.</blockquote>

<h4 id="accessor-functions">Accessor functions</h4>

We also define accessor functions for <code class="highlighter-rouge">startAngle</code>, <code class="highlighter-rouge">endAngle</code>, <code class="highlighter-rouge">innerRadius</code> and <code class="highlighter-rouge">outerRadius</code> e.g.

<pre><code><span>arcGenerator</span>
  <span>.startAngle(function(d){</span>
    <span>returnd.startAngleOfMyArc;</span>
  <span>})</span>
  <span>.endAngle(function(d){</span>
    <span>returnd.endAngleOfMyArc;</span>
  <span>});</span>

<span>arcGenerator({</span>
  <span>startAngleOfMyArc:0,</span>
  <span>endAngleOfMyArc:0.25*Math.PI</span>
<span>});</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/shapes/arc-accessor/" marginwidth="0" marginheight="0" style="width: 100%; height: 230px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/3d912bbaaebcf01a05b75d088a1c9976" target="_blank">View source</a>

<h4 id="centroid">Centroid</h4>

It’s sometimes useful to calculate the centroid of an arc, such as when positioning labels, and D3 has a function <code class="highlighter-rouge">.centroid()</code> for doing this:

<pre><code><span>arcGenerator.centroid({</span>
  <span>startAngle:0,</span>
  <span>endAngle:0.25*Math.PI</span>
<span>});</span>
<span>// returns [22.96100594190539, -55.43277195067721]</span></code></pre>

Here’s an example where <code class="highlighter-rouge">.centroid()</code> is used to compute the label positions:

<iframe class="db center" src="https://www.d3indepth.com/blocks/shapes/arc-centroid/" marginwidth="0" marginheight="0" style="width: 100%; height: 230px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/c9fd848b9410cc543a437b34c266ac64" target="_blank">View source</a>

<h3>Pie generator</h3>

The pie generator goes hand in hand with the arc generator. 
Given an array of data, the pie generator will output an array of objects containing the original data augmented by <strong>start</strong> and <strong>end angles</strong>:

<pre><code><span>var pieGenerator=d3.pie();</span>
<span>var data=[10,40,30,20,60,80];</span>
<span>var arcData=pieGenerator(data);</span>

<span>// arcData is an array of objects: [</span>
<span>//   {</span>
<span>//     data: 10,</span>
<span>//     endAngle: 6.28...,</span>
<span>//     index: 5,</span>
<span>//     padAngle: 0,</span>
<span>//     startAngle: 6.02...,</span>
<span>//     value: 10</span>
<span>//   },</span>
<span>//   ...</span>
<span>// ]</span></code></pre>

We can then use an arc generator to create the path strings:

<pre><code><span>var arcGenerator=d3.arc()</span>
  <span>.innerRadius(20)</span>
  <span>.outerRadius(100);</span>

<span>d3.select('g')</span>
  <span>.selectAll('path')</span>
  <span>.data(arcData)</span>
  <span>.enter()</span>
  <span>.append('path')</span>
  <span>.attr('d',arcGenerator);</span></code></pre>

<!-- There's a few things happening here:

1. 
The `arcData` array is joined to path elements
2. 
The `d` attribute of each path is then updated using `.attr('d', arcGenerator)`. 
This bit of code will call `arcGenerator(d)` for each path where `d` is the joined data (e.g. 
`{data: 10, endAngle: 6.28, startAngle: 6.02, ...}`)
3. 
Each time `arcGenerator` is called it'll return a path data string which will be assigned to the `d` attribute on the path
 -->
Notice that the output of <code class="highlighter-rouge">pieGenerator</code> contains the properties <code class="highlighter-rouge">startAngle</code> and <code class="highlighter-rouge">endAngle</code>. 
These are the same properties required by <code class="highlighter-rouge">arcGenerator</code>.

<iframe class="db center" src="https://www.d3indepth.com/blocks/shapes/pie/" marginwidth="0" marginheight="0" style="width: 100%; height: 230px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/25efacedfc463eead5e77fb336a90caa" target="_blank">View source</a>

The pie generator has a number of configuration functions including <code class="highlighter-rouge">.padAngle()</code>, <code class="highlighter-rouge">.startAngle()</code>, <code class="highlighter-rouge">.endAngle()</code> and <code class="highlighter-rouge">.sort()</code>. 
<code class="highlighter-rouge">.padAngle()</code> specifies an angular padding (in radians) between neighbouring segments.

<code class="highlighter-rouge">.startAngle()</code> and <code class="highlighter-rouge">.endAngle()</code> configure the start and end angle of the pie chart. 
This allows, for example, the creation of semi-circular pie charts:

<pre><code><span>var pieGenerator=d3.pie()</span>
  <span>.startAngle(-0.5*Math.PI)</span>
  <span>.endAngle(0.5*Math.PI);</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/shapes/pie-start-end-angle/" marginwidth="0" marginheight="0" style="width: 100%; height: 120px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/5cc68ffe573562772bed1e394b50f7dc" target="_blank">View source</a>

By default the segment start and end angles are specified such that the segments are in descending order. 
However we can change the sort order using <code class="highlighter-rouge">.sort</code>:

<pre><code><span>var pieGenerator=d3.pie()</span>
  <span>.value(function(d){returnd.quantity;})</span>
  <span>.sort(function(a,b){</span>
    <span>returna.name.localeCompare(b.name);</span>
  <span>});</span>

<span>var fruits=[</span>
  <span>{name:'Apples',quantity:20},</span>
  <span>{name:'Bananas',quantity:40},</span>
  <span>{name:'Cherries',quantity:50},</span>
  <span>{name:'Damsons',quantity:10},</span>
  <span>{name:'Elderberries',quantity:30},</span>
<span>];</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/shapes/pie-sort/" marginwidth="0" marginheight="0" style="width: 100%; height: 230px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/62b1c3bbe89a48f986e334a971e4825f" target="_blank">View source</a>

<h3>Symbols</h3>

The symbol generator produces path data for symbols commonly used in data visualisation:

<pre><code><span>var symbolGenerator=d3.symbol()</span>
  <span>.type(d3.symbolStar)</span>
  <span>.size(80);</span>

<span>var pathData=symbolGenerator();</span></code></pre>

We can then use pathData to define the <code class="highlighter-rouge">d</code> attribute of a path element:

<pre><code><span>d3.select('path')</span>
  <span>.attr('d',pathData);</span></code></pre>

Here’s a simple chart using the symbol generator:

<iframe class="db center" src="https://www.d3indepth.com/blocks/shapes/symbol/" marginwidth="0" marginheight="0" style="width: 100%; height: 130px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/a1fea300b04eaee5abbf58236fe01705" target="_blank">View source</a>

D3 provides a number of symbol types:

<iframe class="db center" src="https://www.d3indepth.com/blocks/shapes/symbol-types/" marginwidth="0" marginheight="0" style="width: 100%; height: 80px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/bae221df69af953fb06351e1391e89a0" target="_blank">View source</a>

<!-- <div class="disqus-wrapper">
	<h2>Comments</h2>
	<div id="disqus_thread"></div>
	<script>

	/**
	 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
	 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
	var disqus_config = function () {
	    this.page.url = 'https://www.d3indepth.com/shapes/';  // Replace PAGE_URL with your page's canonical URL variable
	    this.page.identifier = 'Shapes'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
	};
	
	(function() { // DON'T EDIT BELOW THIS LINE
	    var d = document, s = d.createElement('script');
	    s.src = '//d3indepth.disqus.com/embed.js';
	    s.setAttribute('data-timestamp', +new Date());
	    (d.head || d.body).appendChild(s);
	})();
	</script>
	<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
	                                    
</div> -->


  </div>
</div>

      </div>

      
      <div class="mt4 pt4 bt b--black-10">
        <div class="black-70 f6 ph3 ph5-ns">


<h2>Layouts</h2>

D3 layouts help you create more advanced visualisations such as treemaps:

<iframe class="db center" src="https://www.d3indepth.com/blocks/layouts/treemap-labels/" marginwidth="0" marginheight="0" style="width: 420px; height: 240px;" scrolling="yes"></iframe>

packed circles:

<iframe class="db center" src="https://www.d3indepth.com/blocks/layouts/pack-labels/" marginwidth="0" marginheight="0" style="width: 320px; height: 350px;" scrolling="yes"></iframe>

and network graphs:

<iframe class="db center" src="https://www.d3indepth.com/blocks/layouts/force-layout-example/" marginwidth="0" marginheight="0" style="width: 400px; height: 420px;" scrolling="yes"></iframe>

In essence a layout is just a <strong>JavaScript function</strong> that takes your data as input and adds visual variables such as position and size to it.

For example the tree layout takes a hierarchical data structure and adds <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code> values to each node such that the nodes form a tree-like shape:

<img src="/img/layouts/layouts.png" />

D3 has a number of <strong>hierarchy layouts</strong> for dealing with hierarchical (or tree) data as well as a <strong>chord layout</strong> (for network flows) and a general purpose <strong>force layout</strong> (physics-based simulation). 
We’ll cover the force layout in a separate chapter.

(It’s also possible to create your own layouts. 
For example a simple function that adds positional information to an array of data can be considered a layout.)

<h3>Hierarchical layouts</h3>

D3 has a number of hierarchical layouts to help with visualising hierarchies (or trees) e.g.

<pre><code class="language-json" data-lang="json"><span>{
  "name": "A1",
  "children": [
    {
      "name": "B1",
      "children": [
        {
          "name": "C1",
          "value": 100
        },
        {
          "name": "C2",
          "value": 300
        },
        {
          "name": "C3",
          "value": 200
        }
      ]
    },
    {
      "name": "B2",
      "value": 200
    }
  ]
}</span></code></pre>

In this section we’ll look at the <code class="highlighter-rouge">tree</code>, <code class="highlighter-rouge">cluster</code>, <code class="highlighter-rouge">treemap</code>, <code class="highlighter-rouge">pack</code> and <code class="highlighter-rouge">partition</code> layouts. 
Note that <code class="highlighter-rouge">treemap</code>, <code class="highlighter-rouge">pack</code> and <code class="highlighter-rouge">partition</code> are designed to lay out hierarchies where the nodes have an associated numeric value (e.g. 
revenue, population etc.).

D3 version 4 requires the hierarchical data to be in the form of a <code class="highlighter-rouge">d3.hierarchy</code> object which we’ll cover next.

<h4 id="d3hierarchy">d3.hierarchy</h4>

A <code class="highlighter-rouge">d3.hierarchy</code> object is a data structure that represents a hierarchy. 
It has a number of functions defined on it for retrieving things like ancestor, descendant and leaf nodes and for computing the path between nodes. 
It can be created from a nested JavaScript object such as:

<pre><code><span>var data={</span>
  <span>"name":"A1",</span>
  <span>"children":[</span>
    <span>{</span>
      <span>"name":"B1",</span>
      <span>"children":[</span>
        <span>{</span>
          <span>"name":"C1",</span>
          <span>"value":100</span>
        <span>},</span>
        <span>{</span>
          <span>"name":"C2",</span>
          <span>"value":300</span>
        <span>},</span>
        <span>{</span>
          <span>"name":"C3",</span>
          <span>"value":200</span>
        <span>}</span>
      <span>]</span>
    <span>},</span>
    <span>{</span>
      <span>"name":"B2",</span>
      <span>"value":200</span>
    <span>}</span>
  <span>]</span>
<span>}</span>

<span>var root=d3.hierarchy(data)</span></code></pre>

Typically you don’t need to operate on the hierarchy object itself but there are some useful functions defined on it such as:

<pre><code><span>root.descendants();</span>
<span>root.links()</span></code></pre>

<code class="highlighter-rouge">root.descendants()</code> returns a <strong>flat array</strong> of <code class="highlighter-rouge">root</code>’s descendants and <code class="highlighter-rouge">root.links()</code> returns a <strong>flat array</strong> of objects containing all the parent-child links.

<a href="https://bl.ocks.org/d3indepth/9f6c5dc874d6f21462f308f9e11ebf3c">More examples of hierarchy functions</a>

We’ll now look at the <code class="highlighter-rouge">tree</code>, <code class="highlighter-rouge">cluster</code>, <code class="highlighter-rouge">treemap</code>, <code class="highlighter-rouge">pack</code> and <code class="highlighter-rouge">partition</code> layouts.

<h4 id="tree-layout">tree layout</h4>

The <code class="highlighter-rouge">tree</code> layout arranges the nodes of a hierarchy in a <strong>tree like arrangement</strong>.

<iframe class="db center" src="https://www.d3indepth.com/blocks/layouts/tree/" marginwidth="0" marginheight="0" style="width: 100%; height: 230px;" scrolling="yes"></iframe>

We start by creating the tree layout using:

<pre><code><span>var treeLayout=d3.tree();</span></code></pre>

We can configure the tree’s size using <code class="highlighter-rouge">.size</code>:

<pre><code><span>treeLayout.size([400,200]);</span></code></pre>

We can then call <code class="highlighter-rouge">treeLayout</code>, passing in our hierarchy object <code class="highlighter-rouge">root</code>:

<pre><code><span>treeLayout(root);</span></code></pre>

This’ll write <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code> values on each node of <code class="highlighter-rouge">root</code>.

We can now:

. use <code class="highlighter-rouge">root.descendants()</code> to get an array of all the nodes
. join this array to circles (or any other type of SVG element)
. use <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code> to position the circles

and

. use <code class="highlighter-rouge">root.links()</code> to get an array of all the links
. join the array to line (or path) elements
. use <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code> of the link’s source and target to position the line

(In the case of <code class="highlighter-rouge">root.links()</code> each array element is an object containing two properties <code class="highlighter-rouge">source</code> and <code class="highlighter-rouge">target</code> which represent the link’s source and target nodes.)

<pre><code><span>// Nodes</span>
<span>d3.select('svg g.nodes')</span>
  <span>.selectAll('circle.node')</span>
  <span>.data(root.descendants())</span>
  <span>.enter()</span>
  <span>.append('circle')</span>
  <span>.classed('node',true)</span>
  <span>.attr('cx',function(d){returnd.x;})</span>
  <span>.attr('cy',function(d){returnd.y;})</span>
  <span>.attr('r',4);</span>

<span>// Links</span>
<span>d3.select('svg g.links')</span>
  <span>.selectAll('line.link')</span>
  <span>.data(root.links())</span>
  <span>.enter()</span>
  <span>.append('line')</span>
  <span>.classed('link',true)</span>
  <span>.attr('x1',function(d){returnd.source.x;})</span>
  <span>.attr('y1',function(d){returnd.source.y;})</span>
  <span>.attr('x2',function(d){returnd.target.x;})</span>
  <span>.attr('y2',function(d){returnd.target.y;});</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/layouts/tree/" marginwidth="0" marginheight="0" style="width: 100%; height: 230px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/f349b9aedec5206fbb9e83a6e246304a" target="_blank">View source</a>

<h3>cluster layout</h3>

The <code class="highlighter-rouge">cluster</code> layout is very similar to the <code class="highlighter-rouge">tree</code> layout the main difference being <strong>all leaf nodes are placed at the same depth</strong>.

<pre><code><span>var clusterLayout=d3.cluster()</span>
  <span>.size([400,200])</span>

<span>var root=d3.hierarchy(data)</span>

<span>clusterLayout(root)</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/layouts/cluster/" marginwidth="0" marginheight="0" style="width: 100%; height: 230px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/ceb8d9e5ded610a9df1e0adb98efd748" target="_blank">View source</a>

<h3>treemap layout</h3>

Treemaps were invented by <a href="https://en.wikipedia.org/wiki/Ben_Shneiderman">Ben Shneiderman</a> to visually represent hierarchies where <strong>each item has an associated value</strong>.

For example, we can think of country population data as a hierarchy where the first level represents the region and the next level represents each country. 
A treemap will represent each country as a rectangle (sized proportionally to the population) and group each region together:

<img src="/img/layouts/treemap.png" />

D3’s <code class="highlighter-rouge">treemap</code> layout is created using:

<pre><code><span>var treemapLayout=d3.treemap();</span></code></pre>

As usual we can configure our layout e.g.

<pre><code><span>treemapLayout</span>
  <span>.size([400,200])</span>
  <span>.paddingOuter(10);</span></code></pre>

Before applying this layout to our hierarchy <strong>we must run <code class="highlighter-rouge">.sum()</code> on the hierarchy</strong>. 
This traverses the tree and sets <code class="highlighter-rouge">.value</code> on each node to the sum of its children:

<pre><code><span>root.sum(function(d){</span>
  <span>returnd.value;</span>
<span>});</span></code></pre>

Note that we pass an accessor function into <code class="highlighter-rouge">.sum()</code> to specify which property to sum.

We can now call <code class="highlighter-rouge">treemapLayout</code>, passing in our hierarchy object:

<pre><code><span>treemapLayout(root);</span></code></pre>

The layout adds 4 properties <code class="highlighter-rouge">x0</code>, <code class="highlighter-rouge">x1</code>, <code class="highlighter-rouge">y0</code> and <code class="highlighter-rouge">y1</code> to each node which specify the dimensions of each rectangle in the treemap.

Now we can join our nodes to <code class="highlighter-rouge">rect</code> elements and update the <code class="highlighter-rouge">x</code>, <code class="highlighter-rouge">y</code>, <code class="highlighter-rouge">width</code> and <code class="highlighter-rouge">height</code> properties of each <code class="highlighter-rouge">rect</code>:

<pre><code><span>d3.select('svg g')</span>
  <span>.selectAll('rect')</span>
  <span>.data(root.descendants())</span>
  <span>.enter()</span>
  <span>.append('rect')</span>
  <span>.attr('x',function(d){returnd.x0;})</span>
  <span>.attr('y',function(d){returnd.y0;})</span>
  <span>.attr('width',function(d){returnd.x1-d.x0;})</span>
  <span>.attr('height',function(d){returnd.y1-d.y0;})</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/layouts/treemap/" marginwidth="0" marginheight="0" style="width: 100%; height: 230px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/d4f8938a1fd0914b41ea7cb4e2480ca8" target="_blank">View source</a>

If we’d like labels in each rectangle we could join <code class="highlighter-rouge">g</code> elements to the array and add <code class="highlighter-rouge">rect</code> and <code class="highlighter-rouge">text</code> elements to each <code class="highlighter-rouge">g</code>:

<pre><code><span>var nodes=d3.select('svg g')</span>
  <span>.selectAll('g')</span>
  <span>.data(rootNode.descendants())</span>
  <span>.enter()</span>
  <span>.append('g')</span>
  <span>.attr('transform',function(d){return'translate('+[d.x0,d.y0]+')'})</span>

<span>nodes</span>
  <span>.append('rect')</span>
  <span>.attr('width',function(d){returnd.x1-d.x0;})</span>
  <span>.attr('height',function(d){returnd.y1-d.y0;})</span>

<span>nodes</span>
  <span>.append('text')</span>
  <span>.attr('dx',4)</span>
  <span>.attr('dy',14)</span>
  <span>.text(function(d){</span>
    <span>returnd.data.name;</span>
  <span>})</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/layouts/treemap-labels/" marginwidth="0" marginheight="0" style="width: 100%; height: 230px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/96649ce5ef72d53386790908fe785a6a" target="_blank">View source</a>

<code class="highlighter-rouge">treemap</code> layouts can be configured in a number of ways:

. the padding around a node’s children can be set using <code class="highlighter-rouge">.paddingOuter</code>
. the padding between sibling nodes can be set using <code class="highlighter-rouge">.paddingInner</code>
. outer and inner padding can be set at the same time using <code class="highlighter-rouge">.padding</code>
. the outer padding can also be fine tuned using <code class="highlighter-rouge">.paddingTop</code>, <code class="highlighter-rouge">.paddingBottom</code>, <code class="highlighter-rouge">.paddingLeft</code> and <code class="highlighter-rouge">.paddingRight</code>.

<iframe class="db center" src="https://www.d3indepth.com/blocks/layouts/treemap-padding/" marginwidth="0" marginheight="0" style="width: 100%; height: 230px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/a6ca05860b7249ebe163a212a4abd9cf" target="_blank">View source</a>

In the example above <code class="highlighter-rouge">paddingTop</code> is 20 and <code class="highlighter-rouge">paddingInner</code> is 2.

Treemaps can use different tiling strategies and D3 has several built in (<code class="highlighter-rouge">treemapBinary</code>, <code class="highlighter-rouge">treemapDice</code>, <code class="highlighter-rouge">treemapSlice</code>, <code class="highlighter-rouge">treemapSliceDice</code>, <code class="highlighter-rouge">treemapSquarify</code>) and the configuration function <code class="highlighter-rouge">.tile</code> is used to select one:

<pre><code><span>treemapLayout.tile(d3.treemapDice)</span></code></pre>

<code class="highlighter-rouge">treemapBinary</code> strives for a balance between horizontal and vertical partitions, <code class="highlighter-rouge">treemapDice</code> partitions horizontally, <code class="highlighter-rouge">treemapSlice</code> partitions vertically, <code class="highlighter-rouge">treemapSliceDice</code> alternates between horizontal and vertical partioning and <code class="highlighter-rouge">treemapSquarify</code> allows the aspect ratio of the rectangles to be influenced.

<iframe class="db center" src="https://www.d3indepth.com/blocks/layouts/treemap-tiling/" marginwidth="0" marginheight="0" style="width: 100%; height: 1040px;" scrolling="yes"></iframe>

The effect of different squarify ratios can be seen <a href="https://bl.ocks.org/d3indepth/ad85385d9085b94dbf3c1cc1bbef3717">here</a>.

<h3>pack layout</h3>

The pack layout is similar to the tree layout <strong>but circles instead of rectangles</strong> are used to represent nodes. 
In the example below each country is represented by a circle (sized according to population) and the countries are grouped by region.

<img src="/img/layouts/pack.png" />

D3’s <code class="highlighter-rouge">pack</code> layout is created using:

<pre><code><span>var packLayout=d3.pack();</span></code></pre>

As usual we can configure its size:

<pre><code><span>packLayout.size([300,300]);</span></code></pre>

As with the <code class="highlighter-rouge">treemap</code> we must <strong>call <code class="highlighter-rouge">.sum()</code> on the hierarchy object <code class="highlighter-rouge">root</code></strong> before applying the <code class="highlighter-rouge">pack</code> layout:

<pre><code><span>rootNode.sum(function(d){</span>
  <span>returnd.value;</span>
<span>});</span>

<span>packLayout(rootNode);</span></code></pre>

The <code class="highlighter-rouge">pack</code> layout adds <code class="highlighter-rouge">x</code>, <code class="highlighter-rouge">y</code> and <code class="highlighter-rouge">r</code> (for radius) properties to each node.

Now we can add <code class="highlighter-rouge">circle</code> elements for each descendant of <code class="highlighter-rouge">root</code>:

<pre><code><span>d3.select('svg g')</span>
  <span>.selectAll('circle')</span>
  <span>.data(rootNode.descendants())</span>
  <span>.enter()</span>
  <span>.append('circle')</span>
  <span>.attr('cx',function(d){returnd.x;})</span>
  <span>.attr('cy',function(d){returnd.y;})</span>
  <span>.attr('r',function(d){returnd.r;})</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/layouts/pack/" marginwidth="0" marginheight="0" style="width: 100%; height: 330px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/6f592569629eaa241e755d4de1aed509" target="_blank">View source</a>

Labels can be added by creating <code class="highlighter-rouge">g</code> elements for each descendant:

<pre><code><span>var nodes=d3.select('svg g')</span>
  <span>.selectAll('g')</span>
  <span>.data(rootNode.descendants())</span>
  <span>.enter()</span>
  <span>.append('g')</span>
  <span>.attr('transform',function(d){return'translate('+[d.x,d.y]+')'})</span>

<span>nodes</span>
  <span>.append('circle')</span>
  <span>.attr('r',function(d){returnd.r;})</span>

<span>nodes</span>
  <span>.append('text')</span>
  <span>.attr('dy',4)</span>
  <span>.text(function(d){</span>
    <span>returnd.children===undefined?d.data.name:'';</span>
  <span>})</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/layouts/pack-labels/" marginwidth="0" marginheight="0" style="width: 100%; height: 330px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/e9e845cb419049497369af4347e4348a" target="_blank">View source</a>

The padding around each circle can be configured using <code class="highlighter-rouge">.padding()</code>:

<pre><code><span>packLayout.padding(10)</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/layouts/pack-padding/" marginwidth="0" marginheight="0" style="width: 100%; height: 330px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/582b86d5ec3e3a0885d9add68fd837ad" target="_blank">View source</a>

<h3>partition layout</h3>

The <code class="highlighter-rouge">partition</code> layout subdivides a rectangular space into a layer for each layer of the hierarchy. 
Each layer is subdivided for each node in the layer:

<img src="/img/layouts/partition.png" />

D3’s <code class="highlighter-rouge">partition</code> layout is created using:

<pre><code><span>var partitionLayout=d3.partition();</span></code></pre>

As usual we can configure its size:

<pre><code><span>partitionLayout.size([400,200]);</span></code></pre>

As with the <code class="highlighter-rouge">treemap</code> we must call <code class="highlighter-rouge">.sum()</code> on the hierarchy object <code class="highlighter-rouge">root</code> and before applying the <code class="highlighter-rouge">partition</code> layout:

<pre><code><span>rootNode.sum(function(d){</span>
  <span>returnd.value;</span>
<span>});</span>

<span>partitionLayout(rootNode);</span></code></pre>

The <code class="highlighter-rouge">partition</code> layout adds <code class="highlighter-rouge">x0</code>, <code class="highlighter-rouge">x1</code>, <code class="highlighter-rouge">y0</code> and <code class="highlighter-rouge">y1</code> properties to each node.

We can now add <code class="highlighter-rouge">rect</code> elements for each descendant of <code class="highlighter-rouge">root</code>:

<pre><code><span>d3.select('svg g')</span>
  <span>.selectAll('rect')</span>
  <span>.data(rootNode.descendants())</span>
  <span>.enter()</span>
  <span>.append('rect')</span>
  <span>.attr('x',function(d){returnd.x0;})</span>
  <span>.attr('y',function(d){returnd.y0;})</span>
  <span>.attr('width',function(d){returnd.x1-d.x0;})</span>
  <span>.attr('height',function(d){returnd.y1-d.y0;});</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/layouts/partition/" marginwidth="0" marginheight="0" style="width: 100%; height: 230px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/c4eb1f1a888c94bcd3f57df805a34cc4" target="_blank">View source</a>

Padding can be added between nodes using <code class="highlighter-rouge">.padding()</code>:

<pre><code><span>partitionLayout.padding(2)</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/layouts/partition-padding/" marginwidth="0" marginheight="0" style="width: 100%; height: 230px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/f30f900b9534c7caa509eb5219bfa6bc" target="_blank">View source</a>

If we’d like to change the orientation of the partition layout so that the layers run left to right we can swap <code class="highlighter-rouge">x0</code> with <code class="highlighter-rouge">y0</code> and <code class="highlighter-rouge">x1</code> with <code class="highlighter-rouge">y1</code> when defining the <code class="highlighter-rouge">rect</code> elements:

<pre><code>  <span>.attr('x',function(d){returnd.y0;})</span>
  <span>.attr('y',function(d){returnd.x0;})</span>
  <span>.attr('width',function(d){returnd.y1-d.y0;})</span>
  <span>.attr('height',function(d){returnd.x1-d.x0;});</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/layouts/partition-rotated/" marginwidth="0" marginheight="0" style="width: 100%; height: 230px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/379926741d6600ab6c8af7f5f8707373" target="_blank">View source</a>

We can also map the <code class="highlighter-rouge">x</code> dimension into a rotation angle and <code class="highlighter-rouge">y</code> into a radius to create a sunburst partition:

<iframe class="db center" src="https://www.d3indepth.com/blocks/layouts/partition-sunburst/" marginwidth="0" marginheight="0" style="width: 100%; height: 330px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/2b928885e915471e5c12d2b8cea948c9" target="_blank">View source</a>

<h3>chord layout</h3>

Chord diagrams visualise links (or flows) between a group of nodes, where each flow has a numeric value. 
For example, they can show <a href="http://www.global-migration.info/">migration flows</a> between countries. 
(Personally I find them difficult to interpret!)

The data needs to be in the form of an n x n matrix (where n is the number of items):

<pre><code><span>var data=[</span>
  <span>[10,20,30],</span>
  <span>[40,60,80],</span>
  <span>[100,200,300]</span>
<span>];</span></code></pre>

The first row represents flows from the 1st item to the 1st, 2nd and 3rd items etc.

We create the layout using:

<pre><code><span>var chordGenerator=d3.chord();</span></code></pre>

and we configure it using <code class="highlighter-rouge">.padAngle()</code> (to set the angle between adjacent groups in radians), <code class="highlighter-rouge">.sortGroups()</code> (to specify the order of the groups), <code class="highlighter-rouge">.sortSubgroups()</code> (to sort within each group) and <code class="highlighter-rouge">.sortChords()</code> to determine the z order of the chords.

We apply the layout using:

<pre><code><span>var chords=chordGenerator(data);</span></code></pre>

which returns an array of chords. 
Each element of the array is an object with <code class="highlighter-rouge">source</code> and <code class="highlighter-rouge">target</code> properties. 
Each <code class="highlighter-rouge">source</code> and <code class="highlighter-rouge">target</code> has <code class="highlighter-rouge">startAngle</code> and <code class="highlighter-rouge">endAngle</code> properties which will define the shape of each chord.

We use the <code class="highlighter-rouge">ribbon</code> shape generator which converts the chord properties into path data (see the <a href="/shapes">Shapes chapter</a> for more information on shape generators).

<pre><code><span>var ribbonGenerator=d3.ribbon().radius(200);</span>

<span>d3.select('g')</span>
  <span>.selectAll('path')</span>
  <span>.data(chords)</span>
  <span>.enter()</span>
  <span>.append('path')</span>
  <span>.attr('d',ribbonGenerator)</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/layouts/chord/" marginwidth="0" marginheight="0" style="width: 100%; height: 520px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/d4eb9c450e955225900ed73606a13b25" target="_blank">View source</a>


  </div>
</div>

      </div>

      
      <div class="mt4 pt4 bt b--black-10">
        <div class="black-70 f6 ph3 ph5-ns">


<h2>Force layout</h2>

D3’s force layout uses a <strong>physics based simulator</strong> for positioning visual elements. 
Forces can be set up between elements, for example:

. all elements repel one another
. elements are attracted to center(s) of gravity
linked elements (e.g. 
. friendship) are a fixed distance apart (network visualisation)
. elements may not overlap (collision detection)

The force layout allows us to position elements in a way that would be difficult to achieve using other means.

As an example we have a number of circles (each of which has a category <code class="highlighter-rouge">A</code>, <code class="highlighter-rouge">B</code> or <code class="highlighter-rouge">C</code>) and add the following forces:

. all circles attract one another (to clump circles together)
. collision detection (to stop circles overlapping)
. circles are attracted to one of three centers, depending on their category

<iframe class="db center" src="https://www.d3indepth.com/blocks/layouts/force-foci/" marginwidth="0" marginheight="0" style="width: 100%; height: 400px;" scrolling="yes"></iframe>

The force layout requires a larger amount of computation (typically requiring a few seconds of time) than other D3 layouts and and the solution is calculated in a <strong>step by step (iterative)</strong> manner. 
Usually the positions of the SVG/HTML elements are updated as the simulation iterates, which is why we see the circles jostling into position.

<h3>Setting up a force simulation</h3>

Broadly speaking there are 4 steps to setting up a force simulation:

. create an array of objects
. call <code class="highlighter-rouge">forceSimulation</code>, passing in the array of objects
add one or more force functions (e.g. 
. <code class="highlighter-rouge">forceManyBody</code>, <code class="highlighter-rouge">forceCenter</code>, <code class="highlighter-rouge">forceCollide</code>) to the system
. set up a callback function to update the element positions after each tick

Let’s start with a minimal example:

<pre><code><span>var width=300,height=300</span>
<span>var nodes=[{},{},{},{},{}]</span>

<span>var simulation=d3.forceSimulation(nodes)</span>
  <span>.force('charge',d3.forceManyBody())</span>
  <span>.force('center',d3.forceCenter(width/2,height/2))</span>
  <span>.on('tick',ticked);</span></code></pre>

Here we’ve created a simple array of 5 objects and have added two force functions <code class="highlighter-rouge">forceManyBody</code> and <code class="highlighter-rouge">forceCenter</code> to the system. 
(The first of these makes the elements repel each other while the second attracts the elements towards a centre point.)

Each time the simulation iterates the function <code class="highlighter-rouge">ticked</code> will be called. 
This function joins the <code class="highlighter-rouge">nodes</code> array to <code class="highlighter-rouge">circle</code> elements and updates their positions:

<pre><code><span>functionticked(){</span>
  <span>var u=d3.select('svg')</span>
    <span>.selectAll('circle')</span>
    <span>.data(nodes)</span>

  <span>u.enter()</span>
    <span>.append('circle')</span>
    <span>.attr('r',5)</span>
    <span>.merge(u)</span>
    <span>.attr('cx',function(d){</span>
      <span>returnd.x</span>
    <span>})</span>
    <span>.attr('cy',function(d){</span>
      <span>returnd.y</span>
    <span>})</span>

  <span>u.exit().remove()</span>
<span>}</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/layouts/force/" marginwidth="0" marginheight="0" style="width: 100%; height: 320px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/181b398d5305cefcd10186617cb9250c" target="_blank">View source</a>

The power and flexibility of the force simulation is centred around <strong>force functions</strong> which adjust the position and velocity of elements to achieve a number of effects such as attraction, repulstion and collision detection. 
We can define our own force functions but D3 comes with a number of useful ones built in:

. <code class="highlighter-rouge">forceCenter</code> (for setting the center of gravity of the system)
. <code class="highlighter-rouge">forceManyBody</code> (for making elements attract or repel one another)
. <code class="highlighter-rouge">forceCollide</code> (for preventing elements overlapping)
. <code class="highlighter-rouge">forceX</code> and <code class="highlighter-rouge">forceY</code> (for attracting elements to a given point)
. <code class="highlighter-rouge">forceLink</code> (for creating a fixed distance between connected elements)

Force functions are added to the simulation using <code class="highlighter-rouge">.force()</code> where the first argument is a user defined id and the second argument the force function:

<pre><code><span>simulation.force('charge',d3.forceManyBody())</span></code></pre>

Let’s look at the inbuilt force functions one by one.

<h3>forceCenter</h3>

<code class="highlighter-rouge">forceCenter</code> is useful (if not essential) for centering your elements as a whole about a center point. 
(Without it elements might disappear off the page.)

It can either be initialised with a center position:

<pre><code><span>d3.forceCenter(100,100)</span></code></pre>

or using the configuration functions <code class="highlighter-rouge">.x()</code> and <code class="highlighter-rouge">.y()</code>:

<pre><code><span>d3.forceCenter().x(100).y(100)</span></code></pre>

We add it to the system using:

<pre><code><span>simulation.force('center',d3.forceCenter(100,100))</span></code></pre>

See below for usage examples.

<h3>forceManyBody</h3>

<code class="highlighter-rouge">forceManyBody</code> causes all elements to attract or repel one another. 
The strength of the attraction or repulsion can be set using <code class="highlighter-rouge">.strength()</code> where a positive value will cause elements to attract one another while a negative value causes elements to repel each other. 
The default value is <code class="highlighter-rouge">-30</code>.

<pre><code><span>simulation.force('charge',d3.forceManyBody().strength(-20))</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/layouts/force/" marginwidth="0" marginheight="0" style="width: 100%; height: 320px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/181b398d5305cefcd10186617cb9250c" target="_blank">View source</a>

As a rule of thumb, when creating network diagrams we want the elements to repel one another while for visualisations where we’re clumping elements together, attractive forces are necessary.

<h3>forceCollide</h3>

<code class="highlighter-rouge">forceCollide</code> is used to stop elements overlapping and is particularly useful when ‘clumping’ circles together.

We must specify the radius of the elements using <code class="highlighter-rouge">.radius()</code>:

<pre><code><span>var numNodes=100</span>
<span>var nodes=d3.range(numNodes).map(function(d){</span>
  <span>return{radius:Math.random()*25}</span>
<span>})</span>

<span>var simulation=d3.forceSimulation(nodes)</span>
  <span>.force('charge',d3.forceManyBody().strength(5))</span>
  <span>.force('center',d3.forceCenter(width/2,height/2))</span>
  <span>.force('collision',d3.forceCollide().radius(function(d){</span>
    <span>returnd.radius</span>
  <span>}))</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/layouts/force-collision/" marginwidth="0" marginheight="0" style="width: 100%; height: 420px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/9d9f03a0016bc9df0f13b0d52978c02f" target="_blank">View source</a>

<h3>forceX and forceY</h3>

<code class="highlighter-rouge">forceX</code> and <code class="highlighter-rouge">forceY</code> cause elements <strong>to be attracted towards</strong> specified position(s). 
We can use a single center for all elements or apply the force on a per-element basis. 
The strength of attraction can be configured using <code class="highlighter-rouge">.strength()</code>.

As an example suppose we have a number of elements, each of which has a category <code class="highlighter-rouge">0</code>, <code class="highlighter-rouge">1</code> or <code class="highlighter-rouge">2</code>. 
We can add a <code class="highlighter-rouge">forceX</code> force function to attract the elements to an x-coordinate <code class="highlighter-rouge">100</code>, <code class="highlighter-rouge">300</code> or <code class="highlighter-rouge">500</code> based on the element’s category:

<pre><code><span>simulation.force('x',d3.forceX().x(function(d){</span>
  <span>returnxCenter[d.category];</span>
<span>}))</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/layouts/force-foci/" marginwidth="0" marginheight="0" style="width: 100%; height: 420px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/9491e05b23ca7a02fca8d4ddf12df5df" target="_blank">View source</a>

Note the above example also uses <code class="highlighter-rouge">forceCollide</code>.

If our data has a numeric dimension we can use <code class="highlighter-rouge">forceX</code> or <code class="highlighter-rouge">forceY</code> to position elements along an axis:

<pre><code><span>simulation.force('x',d3.forceX().x(function(d){</span>
  <span>returnxScale(d.value);</span>
<span>}))</span>
<span>.force('y',d3.forceY().y(function(d){</span>
  <span>return0;</span>
<span>}))</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/layouts/force-x/" marginwidth="0" marginheight="0" style="width: 100%; height: 220px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/fee5ce57c3fc3e94c3332577d1415df4" target="_blank">View source</a>

Do use the above with caution as the x position of the elements is only approximate.

<h3>forceLink</h3>

<code class="highlighter-rouge">forceLink</code> pushes linked elements to be a <strong>fixed distance apart</strong>. 
It requires an <strong>array of links</strong> that specify which elements we want to link together. 
Each link object specifies a source and target element, where the value is the element’s array index:

<pre><code><span>var links=[</span>
  <span>{source:0,target:1},</span>
  <span>{source:0,target:2},</span>
  <span>{source:0,target:3},</span>
  <span>{source:1,target:6},</span>
  <span>{source:3,target:4},</span>
  <span>{source:3,target:7},</span>
  <span>{source:4,target:5},</span>
  <span>{source:4,target:7}</span>
<span>]</span></code></pre>

We can then pass our links array into the <code class="highlighter-rouge">forceLink</code> function using <code class="highlighter-rouge">.links()</code>:

<pre><code><span>simulation.force('link',d3.forceLink().links(links))</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/layouts/force-links/" marginwidth="0" marginheight="0" style="width: 100%; height: 320px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/c48022f55ebc76e6adafa77cf466da35" target="_blank">View source</a>

The distance and strength of the linked elements can be configured using <code class="highlighter-rouge">.distance()</code> (default value is 30) and <code class="highlighter-rouge">.strength()</code>.


  </div>
</div>

      </div>

      
      <div class="mt4 pt4 bt b--black-10">
        <div class="black-70 f6 ph3 ph5-ns">


<h2>Geographic</h2>

This chapter looks at D3’s approach to rendering geographic information. 
For example:

<iframe class="db center" src="https://www.d3indepth.com/blocks/geo/spinning/" marginwidth="0" marginheight="0" style="width: 100%; height: 460px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/f28e1c3a99ea6d84986f35ac8646fac7" target="_blank">View source</a>

D3’s approach differs to so called raster methods such as <a href="http://leafletjs.com/">Leaflet</a> and Google Maps. 
These <strong>pre-render map features as image tiles</strong> and these are served up and pieced together in the browser to form a map. 
Typically D3 requests <strong>vector geographic information</strong> in the form of GeoJSON and <strong>renders this to SVG or Canvas</strong> in the browser.

Raster maps often look more like traditional print maps where a lot of detail (e.g. 
place names, roads, rivers etc.) can be shown without an impact on performance. 
However, dynamic content such as animation and interaction is more easily implemented using a vector approach. 
(It’s also quite common to combine the two approaches.)

<h3>D3 mapping concepts</h3>

The 3 concepts that are key to understanding map creation using D3 are:

. <strong>GeoJSON</strong> (a JSON-based format for specifying geographic data)
. <strong>projections</strong> (functions that convert from latitude/longitude co-ordinates to x &amp; y co-ordinates)
. <strong>geographic path generators</strong> (functions that convert GeoJSON shapes into SVG or Canvas paths)

Let’s look at these one by one.

<h4 id="geojson">GeoJSON</h4>

GeoJSON is a standard for representing geographic data using the JSON format and the full specification is at <a href="http://geojson.org/">geojson.org</a>.

It’s fairly straightforward to get the hang of and the example below shows a typical GeoJSON object:

<pre><code class="language-json" data-lang="json"><span>{
  "type": "FeatureCollection",
  "features": [
    {
      "type": "Feature",
      "properties": {
        "name": "Africa"
      },
      "geometry": {
        "type": "Polygon",
        "coordinates": [[[-6, 36], [33, 30], </span><span class="err">... , [-6, 36]]]
      }
    },
    {
      "type": "Feature",
      "properties": {
        "name": "Australia"
      },
      "geometry": {
        "type": "Polygon",
        "coordinates": [[[143, -11], [153, -28], </span><span class="err">... , [143, -11]]]
      }
    },
    {
      "type": "Feature",
      "properties": {
        "name": "Timbuktu"
      },
      "geometry": {
        "type": "Point",
        "coordinates": [-3.0026, 16.7666]
      }
    }
  ]
}</span></code></pre>

In the above example we have a FeatureCollection containing an array of 3 features:

. Africa
. Australia
. the city of Timbuktu

Each feature consists of <strong>geometry</strong> (simple polygons in the case of the countries and a point for Timbuktu) and <strong>properties</strong>.

Properties can contain any information about the feature such as name, id, and other data such as population, GDP etc.

As we’ll see later, D3 takes care of most of the detail when rendering GeoJSON so you only need a basic understanding of GeoJSON to get started with D3 mapping.

<h4 id="projections">Projections</h4>

A projection function takes a longitude and latitude co-ordinate (in the form of an array <code class="highlighter-rouge">[lon, lat]</code>) and transforms it into an x and y co-ordinate:

<pre><code><span>functionprojection(lonLat){</span>
  <span>var x=...// some formula here to calculate x</span>
  <span>var y=...// some formula here to calculate y</span>
  <span>return[x,y];</span>
<span>}</span>

<span>projection([-3.0026,16.7666])</span>
<span>// returns [474.7594743879618, 220.7367625635119]</span></code></pre>

Projection mathematics can get quite complex but fortunately D3 provides a large number of projection functions.

For example we can create an equi-rectangular projection function using:

<pre><code><span>var projection=d3.geoEquirectangular();</span>

<span>projection([-3.0026,16.7666])</span>
<span>// returns [474.7594743879618, 220.7367625635119]</span></code></pre>

We’ll look at projections in much more detail later.

<h4 id="geographic-path-generators">Geographic path generators</h4>
A geographic path generator is a function that takes a GeoJSON object and converts it into an SVG path string. 
(In fact, it’s just another type of <a href="/shapes">shape generator</a>.)

We create a generator using the method <code class="highlighter-rouge">.geoPath()</code> and configure it with a projection function:

<pre><code><span>var projection=d3.geoEquirectangular();</span>

<span>var geoGenerator=d3.geoPath()</span>
  <span>.projection(projection);</span>

<span>var geoJson={</span>
  <span>"type":"Feature",</span>
  <span>"properties":{</span>
    <span>"name":"Africa"</span>
  <span>},</span>
  <span>"geometry":{</span>
    <span>"type":"Polygon",</span>
    <span>"coordinates":[[[-6,36],[33,30],...,[-6,36]]]</span>
  <span>}</span>
<span>}</span>

<span>geoGenerator(geoJson);</span>
<span>// returns "M464.0166237760863,154.09974265651798L491.1506253268278,154.8895088551978 ... 
L448.03311471280136,183.1346693994119Z"</span></code></pre>

As usual with <a href="/shapes">shape generators</a> the generated path string is used to set the <code class="highlighter-rouge">d</code> attribute on an SVG <code class="highlighter-rouge">path</code> element.

<h4 id="putting-it-all-together">Putting it all together</h4>

Once we have some <strong>GeoJSON</strong>, a <strong>projection function</strong> and a <strong>geographic path generator</strong> we can use them together to create a basic map:

<pre><code><span>var geoJson={</span>
  <span>"type":"FeatureCollection",</span>
  <span>"features":[</span>
    <span>{</span>
      <span>"type":"Feature",</span>
      <span>"properties":{</span>
        <span>"name":"Africa"</span>
      <span>},</span>
      <span>"geometry":{</span>
        <span>"type":"Polygon",</span>
        <span>"coordinates":[[[-6,36],[33,30],...,[-6,36]]]</span>
      <span>}</span>
    <span>},</span>
    <span>...</span>
  <span>]</span>
<span>}</span>

<span>var projection=d3.geoEquirectangular();</span>

<span>var geoGenerator=d3.geoPath()</span>
  <span>.projection(projection);</span>

<span>// Join the FeatureCollection's features array to path elements</span>
<span>var u=d3.select('#content g.map')</span>
  <span>.selectAll('path')</span>
  <span>.data(geojson.features);</span>

<span>// Create path elements and update the d attribute using the geo generator</span>
<span>u.enter()</span>
  <span>.append('path')</span>
  <span>.attr('d',geoGenerator);</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/geo/basic/" marginwidth="0" marginheight="0" style="width: 100%; height: 420px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/c6df643a689ce9278b3341f87b6fcf04" target="_blank">View source</a>

(Note that to keep things simple the GeoJSON in the above example uses just a few co-ordinates to define the country boundaries.)

The above example shows the essence of creating maps using D3 and I recommend spending time to understand each concept (GeoJSON, projections and geo generators) and how they fit together.

Now that we’ve covered the basics we’ll look at each concept in more detail.

<h3>GeoJSON</h3>

GeoJSON is a JSON-based structure for specifying geographic data. 
More often than not it’s converted from shapefile data (a geospatial vector data format widely used in the GIS field) using tools such as <a href="http://mapshaper.org/">mapshaper</a>, <a href="http://www.gdal.org/ogr2ogr.html">ogr2ogr</a>, <a href="https://github.com/mbostock/shapefile">shp2json</a> or <a href="http://www.qgis.org/en/site/">QGIS</a>.

A popular source of world map shapefiles is <a href="http://www.naturalearthdata.com/">Natural Earth</a> and if starting out I recommend trying out <a href="http://mapshaper.org/">mapshaper</a> for importing shapefiles and exporting as GeoJSON. 
It can also filter by properties (e.g. 
if you wanted to filter countries by continent). 
For a more in depth look at conversion look at Mike Bostock’s <a href="https://bost.ocks.org/mike/map/">Let’s Make a Map</a> tutorial.

You can create maps without understanding the GeoJSON specification in minute detail because tools such as mapshaper and D3 do such a good job of abstracting away the detail. 
However, if you did want to understand GeoJSON in greater depth I recommend checking out the <a href="http://geojson.org/">official specification</a>.

So far we’ve embedded a GeoJSON object in our example files. 
In practice the GeoJSON would be in a separate file and loaded using an ajax request. 
We cover requests in more detail in the <a href="/requests">requests chapter</a> but for the remainder of this chapter we’ll load a GeoJSON file using:

<pre><code><span>d3.json('ne_110m_land.json',function(err,json){</span>
  <span>createMap(json);</span>
<span>})</span></code></pre>

It’s worth mentioning TopoJSON which is another JSON based standard for describing geographic data and tends to result in significantly smaller file sizes. 
It requires a bit more work to use, and we don’t cover it in this chapter. 
However for further information check out the <a href="https://github.com/topojson/topojson">documentation</a>.

<h3>Projections</h3>

There are numerous (if not infinite) ways of converting (or ‘projecting’) a point on a sphere (e.g. 
the earth) to a point on a flat surface (e.g. 
a screen) and people have written countless articles (such as <a href="http://www.progonos.com/furuti/MapProj/Normal/TOC/cartTOC.html">this</a> one) on the pros and cons of different projections.

In short there is no perfect projection as every projection will distort shape, area, distance and/or direction. 
Choosing a projection is a case of choosing which property you don’t want to be distorted and accepting that there’ll be distortion in the other properties (or choose a projection that strives for a balanced approach). 
For example, if it’s important that the size of countries are represented accurately then  choose a projection that strives to preserve area (probably to the cost of shape, distance and direction).

D3 has a number of core projections that should cover most use cases:

. <code class="highlighter-rouge">geoAzimuthalEqualArea</code>
. <code class="highlighter-rouge">geoAzimuthalEquidistant</code>
. <code class="highlighter-rouge">geoGnomonic</code>
. <code class="highlighter-rouge">geoOrthographic</code>
. <code class="highlighter-rouge">geoStereographic</code>
. <code class="highlighter-rouge">geoAlbers</code>
. <code class="highlighter-rouge">geoConicConformal</code>
. <code class="highlighter-rouge">geoConicEqualArea</code>
. <code class="highlighter-rouge">geoConicEquidistant</code>
. <code class="highlighter-rouge">geoEquirectangular</code>
. <code class="highlighter-rouge">geoMercator</code>
. <code class="highlighter-rouge">geoTransverseMercator</code>

Some projections preserve area (e.g. 
<code class="highlighter-rouge">geoAzimuthalEqualArea</code> &amp; <code class="highlighter-rouge">geoConicEqualArea</code>), others distance (e.g. 
<code class="highlighter-rouge">geoAzimuthalEquidistant</code> &amp; <code class="highlighter-rouge">geoConicEquidistant</code>) and others relative angles (e.g. 
<code class="highlighter-rouge">geoEquirectangular</code> &amp; <code class="highlighter-rouge">geoMercator</code>). 
For a more in depth discussion of the pros and cons of each projection try resources such as Carlos A. 
Furuti’s <a href="http://www.progonos.com/furuti/MapProj/Normal/TOC/cartTOC.html">Map Projection Pages</a>.

The grid below shows each core projection on a world map together with a longitude/latitude grid and equal radius circles.

<iframe class="db center" src="https://www.d3indepth.com/blocks/geo/projection-types/" marginwidth="0" marginheight="0" style="width: 100%; height: 660px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/8fe422f6d5f6999c931f942d93035aba" target="_blank">View source</a>

<h4 id="projection-functions">Projection functions</h4>

A projection function takes input <code class="highlighter-rouge">[longitude, latitude]</code> and outputs a pixel co-ordinate <code class="highlighter-rouge">[x, y]</code>.

You’re free to write your own projection functions but much easier is to ask D3 to make one for you. 
To do this  choose a projection method (e.g. 
<code class="highlighter-rouge">d3.geoAzimuthalEqualArea</code>), call it and it’ll return a projection function:

<pre><code><span>var projection=d3.geoAzimuthalEqualArea();</span>

<span>projection([-3.0026,16.7666]);</span>
<span>// returns [473.67353385539417, 213.6120079887163]</span></code></pre>

The core projections have configuration functions for setting the following parameters:

<table class="table table-bordered">
  <tr><td><a href="#scale">scale</a></td><td>Scale factor of the projection</td></tr>
  <tr><td><a href="#center">center</a></td><td>Projection center [longitude, latitude]</td></tr>
  <tr><td><a href="#translate">translate</a></td><td>Pixel [x,y] location of the projection center</td></tr>
  <tr><td><a href="#rotate">rotate</a></td><td>Rotation of the projection [lambda, phi, gamma] (or [yaw, pitch, roll])</td></tr>
</table>

The precise meaning of each parameter is dependent on the mathematics behind each projection but broadly speaking:

scale specifies the <strong>scale factor</strong> of the projection. 
. The higher the number the larger the map.
. center specifies the <strong>center of projection</strong> (with a <code class="highlighter-rouge">[lon, lat]</code> array)
. translate specifies where the <strong>center of projection is located on the screen</strong> (with a <code class="highlighter-rouge">[x, y]</code> array)
. rotate specifies the <strong>rotation of the projection</strong> (with a <code class="highlighter-rouge">[λ, φ, γ]</code> array)  where the parameters correspond to yaw, pitch and roll, respectively:

<img width="300px" src="/img/geo/projection-rotation.svg" />

For example we might create and configure a projection function such that Timbuktu is centred in a 960x500 map using:

<pre><code><span>var projection=d3.geoAzimuthalEqualArea()</span>
  <span>.scale(300)</span>
  <span>.center([-3.0026,16.7666])</span>
  <span>.translate([480,250]);</span></code></pre>

To get a feel for how each parameter behaves use the projection explorer below. 
The (equal radius) circles and grid allow you to assess the projection’s distortion of area and angle.

<iframe class="db center" src="https://www.d3indepth.com/blocks/geo/projection-configuration/" marginwidth="0" marginheight="0" style="width: 100%; height: 560px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/f7ece0ab9a3df06a8cecd2c0e33e54ef" target="_blank">View source</a>

<h4 id="invert">.invert()</h4>

We can convert from a pixel co-ordinate <code class="highlighter-rouge">[x, y]</code> back to <code class="highlighter-rouge">[longitude, latitude]</code> using the projection’s <code class="highlighter-rouge">.invert()</code> method:

<pre><code><span>var projection=d3.geoAzimuthalEqualArea();</span>

<span>projection([-3.0026,16.7666])</span>
<span>// returns [473.67353385539417, 213.6120079887163]</span>

<span>projection.invert([473.67353385539417,213.6120079887163])</span>
<span>// returns [-3.0026, 16.766]</span></code></pre>

<h4 id="fitting">Fitting</h4>

Given a GeoJSON object, a projection’s <code class="highlighter-rouge">.fitExtent()</code> method sets the projection’s <strong>scale</strong> and <strong>translate</strong> such that the geometry fits within a given bounding box:

<pre><code><span>projection.fitExtent([[0,0],[900,500]],geojson);</span></code></pre>

In the example below the canvas element has a light grey background and the bounding box into which we’re fitting the geoJSON is shown as a dotted outline:

<iframe class="db center" src="https://www.d3indepth.com/blocks/geo/fit-extent/" marginwidth="0" marginheight="0" style="width: 100%; height: 480px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/73dc5ae176b2268563526cf4acdf1df7" target="_blank">View source</a>

If our bounding box’s top left corner is at <code class="highlighter-rouge">[0, 0]</code> we can use the shorthand:

<pre><code><span>projection.fitSize([900,500],geojson);</span></code></pre>

<h3>Geographic path generators</h3>

A geographic path generator is a function that transforms <strong>GeoJSON into an SVG path string</strong> (or into canvas element calls):

<pre><code><span>geoGenerator(geoJson);</span>
<span>// e.g. 
returns a SVG path string "M464.01,154.09L491.15,154.88 ... 
L448.03,183.13Z"</span></code></pre>

We create the generator using <code class="highlighter-rouge">d3.geoPath()</code> and usually configure it’s projection type:

<pre><code><span>var projection=d3.geoEquirectangular();</span>

<span>var geoGenerator=d3.geoPath()</span>
  <span>.projection(projection);</span></code></pre>

We can now use the generator to help us create an SVG or canvas map. 
The SVG option is a bit easier to implement, especially when it comes to user interaction as event handlers and hover states can be added. 
The canvas approach requires a bit more work, but is typically quicker (and more memory efficient) to render.

<h4 id="rendering-svg">Rendering SVG</h4>
To render SVG we typically <a href="/datajoins">join</a> a GeoJSON features array to SVG <code class="highlighter-rouge">path</code> elements and update the <code class="highlighter-rouge">d</code> attribute using the geographic path generator:

<pre><code><span>var geoJson={</span>
  <span>"type":"FeatureCollection",</span>
  <span>"features":[</span>
    <span>{</span>
      <span>"type":"Feature",</span>
      <span>"properties":{</span>
        <span>"name":"Africa"</span>
      <span>},</span>
      <span>"geometry":{</span>
        <span>"type":"Polygon",</span>
        <span>"coordinates":[[[-6,36],[33,30],...,[-6,36]]]</span>
      <span>}</span>
    <span>},</span>
    <span>...</span>
  <span>]</span>
<span>}</span>

<span>var projection=d3.geoEquirectangular();</span>

<span>var geoGenerator=d3.geoPath()</span>
  <span>.projection(projection);</span>

<span>// Join the FeatureCollection's features array to path elements</span>
<span>var u=d3.select('#content g.map')</span>
  <span>.selectAll('path')</span>
  <span>.data(geojson.features);</span>

<span>// Create path elements and update the d attribute using the geo generator</span>
<span>u.enter()</span>
  <span>.append('path')</span>
  <span>.attr('d',geoGenerator);</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/geo/basic/" marginwidth="0" marginheight="0" style="width: 100%; height: 420px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/c6df643a689ce9278b3341f87b6fcf04" target="_blank">View source</a>

<h4 id="rendering-to-canvas">Rendering to canvas</h4>

To render to a canvas element we need to configure the context of the geo generator with the canvas’s element:

<pre><code><span>var context=d3.select('#content canvas')</span>
  <span>.node()</span>
  <span>.getContext('2d');</span>

<span>var geoGenerator=d3.geoPath()</span>
  <span>.projection(projection)</span>
  <span>.context(context);</span></code></pre>

We can then begin a canvas path and call <code class="highlighter-rouge">geoGenerator</code> which will produce the necessary canvas calls for us:

<pre><code><span>context.beginPath();</span>
<span>geoGenerator({type:'FeatureCollection',features:geojson.features})</span>
<span>context.stroke();</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/geo/basic-canvas/" marginwidth="0" marginheight="0" style="width: 100%; height: 420px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/c62b6ce6625b69f6007cea5fccdd4599" target="_blank">View source</a>

<h4 id="lines-and-arcs">Lines and arcs</h4>

The geographic path generator is clever enough to distinguish between polygonal (typically for geographic areas) and point (typically for lon/lat locations) features. 
As can be seen in the above examples it renders polygons as line segments and points as arcs.

We can set the radius of the circles using <code class="highlighter-rouge">.pointRadius()</code>:

<pre><code><span>var geoGenerator=d3.geoPath()</span>
  <span>.pointRadius(5)</span>
  <span>.projection(projection);</span></code></pre>

<h4 id="path-geometry">Path geometry</h4>

The geographic path generator can also be used to compute the <strong>area</strong> (in pixels), <strong>centroid</strong>, <strong>bounding box</strong> and <strong>path length</strong> (in pixels) of a projected GeoJSON feature:

<pre><code><span>var feature=geojson.features[0];</span>

<span>// Compute the feature's area (in pixels)</span>
<span>geoGenerator.area(feature);</span>
<span>// returns 30324.86518469876</span>

<span>// Compute the feature's centroid (in pixel co-ordinates)</span>
<span>geoGenerator.centroid(feature);</span>
<span>// returns [266.9510120424504, 127.35819206325564]</span>

<span>// Compute the feature's centroid (in pixel co-ordinates)</span>
<span>geoGenerator.bounds(feature);</span>
<span>// returns [[140.6588054321928, 24.336293856408275], [378.02358370342165, 272.17304763960306]]</span>

<span>// Compute the path length (in pixels)</span>
<span>geoGenerator.measure(feature);</span>
<span>// returns 775.7895349902461</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/geo/geopath-measures/" marginwidth="0" marginheight="0" style="width: 100%; height: 650px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/3ccd770923a61f26f55156657e2f51e8" target="_blank">View source</a>

<h3>Shapes</h3>

If we need to add lines and/or circles to a map we can achieve it by adding features to our GeoJSON.

Lines can be added as a LineString feature and will be projected into great-arcs (i.e. 
the shortest distance across the surface of the globe). 
Here’s an example where we add a line between London and New York:

<pre><code><span>geoGenerator({</span>
  <span>type:'Feature',</span>
  <span>geometry:{</span>
    <span>type:'LineString',</span>
    <span>coordinates:[[0.1278,51.5074],[-74.0059,40.7128]]</span>
  <span>}</span>
<span>});</span></code></pre>

Circle features can be generated using <code class="highlighter-rouge">d3.geoCircle()</code>. 
Typically the center (<code class="highlighter-rouge">[lon, lat]</code>) and the angle (degrees) between the points are set:

<pre><code><span>var circle=d3.geoCircle()</span>
  <span>.center([0.1278,51.5074])</span>
  <span>.radius(5);</span>

<span>circle();</span>
<span>// returns a GeoJSON object representing a circle</span>

<span>geoGenerator(circle());</span>
<span>// returns a path string representing the projected circle</span></code></pre>

A GeoJSON grid of longitude and latitude lines (known as a graticule) can be generated using <code class="highlighter-rouge">d3.graticule()</code>:

<pre><code><span>var graticule=d3.geoGraticule();</span>

<span>graticule();</span>
<span>// returns a GeoJSON object representing the graticule</span>

<span>geoGenerator(graticule());</span>
<span>// returns a path string representing the projected graticule</span></code></pre>

(See the <a href="https://github.com/d3/d3-geo#geoGraticule">official documentation</a> for detailed information on graticule configuration.)

Here’s an example using all three shapes:

<iframe class="db center" src="https://www.d3indepth.com/blocks/geo/geo-shapes/" marginwidth="0" marginheight="0" style="width: 100%; height: 420px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/60f490c6abd7be53d4aa39818e11d273" target="_blank">View source</a>

<h3>Spherical geometry</h3>

There’s a handful of D3 methods that may come in useful from time to time. 
The first of these <code class="highlighter-rouge">.geoArea()</code>, <code class="highlighter-rouge">.geoBounds()</code>, <code class="highlighter-rouge">.geoCentroid()</code>, <code class="highlighter-rouge">.geoDistance()</code> and <code class="highlighter-rouge">geoLength()</code> are similar to the path geometry methods described above but operate in spherical space.

<h4 id="interpolation">Interpolation</h4>

The <code class="highlighter-rouge">d3.geoInterpolate()</code> method creates a function that accepts input between 0 and 1 and interpolates between two <code class="highlighter-rouge">[lon, lat]</code> locations:

<pre><code><span>var londonLonLat=[0.1278,51.5074];</span>
<span>var newYorkLonLat=[-74.0059,40.7128];</span>
<span>var geoInterpolator=d3.geoInterpolate(londonLonLat,newYorkLonLat);</span>

<span>geoInterpolator(0);</span>
<span>// returns [0.1278, 51.5074]</span>

<span>geoInterpolator(0.5);</span>
<span>// returns [-41.182023242967695, 52.41428456719971] (halfway between the two locations)</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/geo/geo-interpolator/" marginwidth="0" marginheight="0" style="width: 100%; height: 420px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/aa1f036f6a0356cb1152c4b836e93990" target="_blank">View source</a>

<h4 id="geocontains">geoContains</h4>

If we’re using the canvas element to render our geometry we don’t have the luxury of being able to add event handlers onto path objects. 
Instead we need to check whether mouse or touch events occur inside the boundary of a feature. 
We can do this using <code class="highlighter-rouge">d3.geoContains</code> which accepts a GeoJSON feature and a <code class="highlighter-rouge">[lon, lat]</code> array and returns a boolean:

<pre><code><span>d3.geoContains(ukFeature,[0.1278,51.5074]);</span>
<span>// returns true</span></code></pre>

<iframe class="db center" src="https://www.d3indepth.com/blocks/geo/geo-contains/" marginwidth="0" marginheight="0" style="width: 100%; height: 430px;" scrolling="yes"></iframe>

	<a href="https://bl.ocks.org/d3indepth/c7dabcad61f8c4398130305a2035decd" target="_blank">View source</a>
<br>
<br>
<br>
<br>

<script>
	var toc = $('#toc');
	$('h2').each(function(i) {
		var topic = $(this), topicNumber = i + 1;
		toc.append(topicNumber +' <a href="#topic-'+topicNumber+'" target="_self">'+topic.html()+'</a><br>');
		topic.attr('id', 'topic-' + topicNumber);
	});
</script>
