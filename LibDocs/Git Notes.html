<base target="_blank"><html><head><title>Git Notes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src="https://williamkpchan.github.io/lazyload.min.js"></script>
<script src='https://williamkpchan.github.io/mainscript.js'></script>
<script src="https://williamkpchan.github.io/commonfunctions.js"></script>
<script>
  var showTopicNumber = false;
  var topicEnd = "<br>";
  var bookid = "Git Notes"
  var markerName = "h2"
</script>
<style>
body{width:80%;margin-left: 10%; font-size:24px;}
h1, h2 {color: gold;}
strong {color: orange;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px;}
</style></head><body onkeypress="chkKey()"><center>
<h1>Git Notes</h1>
<a href="#mustWatch" class="red goldbs" target="_self">Must Watch!</a><br><br>
<div id="toc"></div></center><br><br>
<div id="mustWatch"><center><span class="red">MustWatch</span></center><br>
<a href="https://docs.github.com/en/get-started/getting-started-with-git" class="whitebut ">Getting started with Git</a>

<a href="https://www.youtube.com/watch?v=HfTXHrWMGVY" class="whitebut ">setup github password</a>
<a href="https://www.youtube.com/watch?v=i_23KUAEtUM" class="whitebut ">Using Git with Visual Studio Code</a>

<a href="gitTutorials.html" class="whitebut ">gitTutorials</a>
<a href="git-config.html" class="whitebut ">git-config</a>
<a href="git exercise.html" class="whitebut ">git exercise</a>
<a href="https://www.youtube.com/watch?v=R8_veQiYBjI" class="whitebut ">GitHub Actions Tutorial</a>
<br>

</div>
<pre><br><br>
<h2>github get started</h2>
<a href=".\github get started.html" class="goldb">github get started</span></a> 

<h2>LF will be replaced by CRLF</h2>
<a href="https://stackoverflow.com/questions/5834014/lf-will-be-replaced-by-crlf-in-git-what-is-that-and-is-it-important">LF will be replaced by CRLF</a>
<br>
Git can auto-converting CRLF line endings into LF when you add a file to the index. Turn on this functionality with the core.autocrlf setting. 
If you’re on a Windows machine, set it to true – this converts LF endings into CRLF when you check out code:

git config --global core.autocrlf true
git config --global core.autocrlf false
<br>
<h2>Git for Absolute Beginners</h2>
<a href="Git for Absolute Beginners.html">Git for Absolute Beginners</a>

<h2>Activity: Use the GitHub Desktop client</h2>
<a href="https://idratherbewriting.com/learnapidoc/pubapis_version_control.html" class="whitebut ">Version control systems</a>
<a href="https://idratherbewriting.com/learnapidoc/pubapis_github_desktop_client.html" class="whitebut ">Use the GitHub Desktop client</a>

<div id="GitHubDesktoptoc" class="toc"><a href="#GitHubDesktoptopic-0" target="_self">Follow a typical workflow with a GitHub project</a><br><a href="#GitHubDesktoptopic-1" target="_self">Create a branch</a><br><a href="#GitHubDesktoptopic-2" target="_self">Merge the development branch into master</a><br><a href="#GitHubDesktoptopic-3" target="_self">Merge the branch through a pull request</a><br><a href="#GitHubDesktoptopic-4" target="_self">Managing merge conflicts</a><br><a href="#GitHubDesktoptopic-5" target="_self">Conclusion</a><br></div></center><br><br>
Although most developers use the command line when working with version control systems, there are many GUI clients available that can potentially simplify the process. 

GUI clients might be especially helpful when you’re trying to see what has changed in a file since the GUI can quickly 
<h3 id="GitHubDesktoptopic-0">Follow a typical workflow with a GitHub project</h3>
In this tutorial, you’ll use GitHub Desktop to manage the Git workflow.
Rather than working in a GitHub wiki (as you did in the <a href="https://idratherbewriting.com/learnapidoc/pubapis_github_wikis.html">previous GitHub tutorial</a>), you’ll work in a regular Git repository. 

This is because GitHub wikis have some limitations when it comes to making pull requests.
To set up your Git repo using the GitHub Desktop client:
First, download and install <a href="https://desktop.github.com/">GitHub Desktop</a>. 

Launch the app and sign in. 
(You should already have a GitHub account from <a href="https://idratherbewriting.com/learnapidoc/pubapis_github_wikis.html">previous tutorials</a>, but if not, create one.)
Go to <a href="https://github.com">Github.com</a> and browse to the repository you created in the <a href="https://idratherbewriting.com/learnapidoc/pubapis_github_wikis.html">GitHub tutorial</a>, but not the wiki. 

Just go to the main repo. 
(If you didn’t do the previous activity, just create a new repository.)
While viewing your GitHub repo in the browser, click Clone or download and select Open in Desktop.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://idratherbewritingmedia.com/images/api/open-in-github-desktop.png">
Open in GitHub Desktop
Open GitHub Desktop client and go to File > Clone Repository.
In the confirmation dialog, select Open GitHub Desktop.app. 

GitHub Desktop should launch with a “Clone a Repository” dialog box about where to clone the repository. 

If desired, you can change the Local Path.
Click the URL tab, and then paste in the clone URL. 

In the Local Path field, select where you want the repo cloned. 

For example:
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://idratherbewritingmedia.com/images/api/localpathgithubdesktop.png">
Selecting paths for the repo in GitHub Desktop
Click Clone.
Go into the repository where GitHub Desktop cloned the repo (use your Finder or browse the folders with Finder or Explorer) and either add a simple text file with some content or make a change to an existing file.
Go back to GitHub Desktop. 

You’ll see the new file you added in the list of uncommitted changes on the left.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://idratherbewritingmedia.com/images/api/github-desktop-file-uncommitted-changes.png">
Uncommitted changes shown
In the list of changed files, the green + means you’ve added a new file. 

A yellow circle means you’ve modified an existing file.
In the lower-left corner of the GitHub Desktop client (where it says “Summary” and “Description”), type a commit message, and then click Commit to master.
When you commit the changes, the left pane no longer shows the list of uncommitted changes. 

However, you’ve committed the changes only locally. 

You still have to push the commit to the remote (origin) repository. 

(“origin” is the alias name that refers to the remote repository.)
Click Push origin at the top.
You’ll see GitHub Desktop show that it’s “Pushing to origin.”
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://idratherbewritingmedia.com/images/api/pushingtoorigin.png">
If you view your repository online, you’ll see that the change you made has been pushed to the master branch on origin. 

You can also click the History tab in the GitHub Desktop client (instead of the Changes tab), or go to View > Show History to see the changes you previously committed.
Although I prefer to use the terminal instead of the GitHub Desktop GUI, the GUI gives you an easier visual experience to see the changes made to a repository. 

You can use both the command line and Desktop client in combination, if you want.
<h3 id="GitHubDesktoptopic-1">Create a branch</h3>
Now let’s create a branch, make some changes, and see how the changes are specific to that branch.
In the GitHub Desktop client, go to Branch > New Branch and create a new branch. 

Call it “development” branch, and click Create Branch.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://idratherbewritingmedia.com/images/api/creatingnewbranchgithubdesktop.png">
Creating a new branch
When you create the branch, you’ll see the Current branch drop-down menu indicate that you’re working in that branch. 

Creating a branch copies the existing content (from the branch you’re currently in, <em>master</em>) into the new branch (<em>development</em>).
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://idratherbewritingmedia.com/images/api/github-desktop-current-branch.png">
Working in a branch
Using Finder or Explorer, browse to the file you created earlier and make a change to it, such as adding a new line with some text. 

Save the changes.
Return to GitHub Desktop and notice that on the Changes tab, you have new modified files.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://idratherbewritingmedia.com/images/api/github-desktop-file-changes.png">
New files modified
The file changes show deleted lines in red and new lines in green. 

The colors help you see what changed.
Commit the changes using the options in the lower-left corner, and click Commit to development.
Click Publish branch (on the top of the GitHub Desktop window) to make the local branch also available on origin (GitHub). 

(Remember, there are usually two versions of a branch — the local version and the remote version.)
Switch back to your master branch (using the Branch drop-down option at the top of the GitHub Desktop client). 

Then look at your file (in your text editor, such as Sublime text). 

Note how the file changes you made while editing in the development branch don’t appear in your master branch.
You usually create a new branch when you’re making extensive changes to your content. 

For example, suppose you want to revamp a section (“Section X”) in your docs. 

However, you might want to publish other updates before publishing the extensive changes in Section X. 

If you were working in the same branch, it would be difficult to selectively push updates on a few files outside of Section X without pushing updates you’ve made to files in Section X as well.
Through branching, you can confine your changes to a specific version that you don’t push live until you’re ready to merge the changes into your master branch.
<h3 id="GitHubDesktoptopic-2">Merge the development branch into master</h3>
Now let’s merge the development branch into the master branch.
In the GitHub Desktop client, switch to the branch you want to merge the development branch into. 

From the branch selector, select the master branch.
Go to Branch > Merge into Current Branch.
In the merge window, select the development branch, and then click Merge development into master.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://idratherbewritingmedia.com/images/api/mergeintomastergithubclient.png">
Merging into master
If you look at your changed file, you should see the changes in the master branch.
Then click Push origin to push the changes to origin.
You will now see the changes reflected on the file on GitHub.
<h3 id="GitHubDesktoptopic-3">Merge the branch through a pull request</h3>
Now let’s merge the development branch into the master using a pull request workflow. 

We’ll pretend that we’ve cloned a repo managed by engineers, and we want to have the engineers merge in the development branch. 

(In other words, we might not have rights to merge branches into the master.) To do this, we’ll create a pull request.
Just as you did in the previous section, switch to the development branch, make some updates to the content in a file, and then save and commit the changes. 

After committing the changes, click Push origin to push your changes to the remote version of the development branch on GitHub.
In the GitHub Desktop client, while you have development branch selected, go to Branch > Create Pull Request.
GitHub opens in the browser with the Pull Request form opened.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://idratherbewritingmedia.com/images/api/mergepullrequestgithubdesktop.png">
Pull request
The left-facing arrow (pointing from the development branch towards the master) indicates that the pull request (“PR”) wants to merge the development branch into the master branch.
Describe the pull request, and then click Create pull request.
At this point, engineers would get an email request asking for them to merge in the edits. 

Play the part of the engineer by going to the Pull requests tab (on GitHub) to examine and confirm the merge request. 

As long as the merge request doesn’t pose any conflicts, you’ll see a Merge pull request button.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://idratherbewritingmedia.com/images/api/mergepullrequest.png">
Confirm merge request
To see what changes you’re merging into master, you can click the Files changed tab (which appears on the secondary navigation bar near the top). 

Then click Merge pull request to merge in the branch, and click Confirm merge to complete the merge.
Now let’s get the updates you merged into the masterbranch online into your local copy. 

In your GitHub Desktop GUI client, select the master branch, and then click the Fetch origin button. 

Fetch gets the latest updates from origin but doesn’t update your local working copy with the changes.
After you click Fetch origin, the button changes to Pull Origin.
Click Pull Origin to update your local working copy with the fetched updates.
Now check your files and notice that the updates that were originally in the development branch now appear in master.
For a more detailed tutorial in making pull requests using the GitHub interface, see <a href="https://idratherbewriting.com/learnapidoc/pubapis_github_pull_requests.html">Pull request workflows through GitHub</a>. 

I include an extensive tutorial with pull requests because it will likely be a common workflow if you are <a href="https://idratherbewriting.com/learnapidoc/docapis_find_open_source_project.html">contributing to an open-source project</a>.
<h3 id="GitHubDesktoptopic-4">Managing merge conflicts</h3>
Suppose you make a change on your local copy of a file in the repository, and someone else changes the same file using the online GitHub.com browser interface. 

The changes conflict with each other. 

What happens?
When you click Push origin from the GitHub Desktop client, you’ll see a message saying that the repository has been updated since you last pulled:
<blockquote>
“The repository has been updated since you last pulled. 

Try pulling before pushing.”
</blockquote>
The button that previously said “Push origin” now says “Pull origin.” Click Pull origin. 

You now get another error message that says,
<blockquote>
“We found some conflicts while trying to merge. 

Please resolve the conflicts and commit the changes.”
</blockquote>
If you decide to commit your changes, you’ll see a message that says:
<blockquote>
“Please resolve all conflicted files, commit, and then try syncing again.”
</blockquote>
The GitHub Desktop client displays an exclamation mark next to files with merge conflicts. 

Open up a conflict file and look for the conflict markers (&lt;&lt;&lt;&lt;&lt;&lt;&lt; and >>>>>>>). 

For example, you might see this:
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
This is an edit I made locally.
=======
This is an edit I made from the browser.
>>>>>>> c163ead57f6793678dd41b5efeef372d9bd81035
(From the command line, you can also run git status to see which files have conflicts.) The content in HEAD shows your local changes. 

The content below the ======= shows changes made by elsewhere.
Fix all the conflicts by adjusting the content between the content markers and then deleting the content markers. 

For example, update the content to this:
This is an edit I made locally.
Now you need to re-add the file to Git again. 

In the GitHub Desktop client, commit your changes to the updated files. 

Then click Push origin. 

The updates on your local get pushed to the remote without any more conflicts.
<h3 id="GitHubDesktoptopic-5">Conclusion</h3>
The more you use GitHub, the more familiar you’ll become with the workflows you need. 

Git is a robust, powerful collaboration platform, and there are many commands and workflows and features that you could adopt for a variety of scenarios. 

Despite Git’s variety of commands and workflows, most likely the scenarios you’ll actually use are somewhat limited in scope and learnable without too much effort. 

Pretty soon, these workflows will become automatic.
Although we’ve been using the GitHub Desktop client for this exercise, you can do all of this through the command line, and you’ll probably find it preferable that way. 

However, the GitHub Desktop client can be a good starting point as you transition into becoming more of a Git power user.

<h2>git always asking for user credentials</h2>
<a href="https://www.freecodecamp.org/news/how-to-fix-git-always-asking-for-user-credentials/" class="whitebut ">fix git always asking for user credentials</a>

git remote set-url origin git@github.com:williamkpchan

Look in Git configuration file.
git config --list

<h2>Git error: </h2>
“Please make sure you have the correct access rights and the repository exists”

reason: git URL might have changed. 

action:
# View existing remotes
git remote -v

# Change the 'origin' remote's URL
git remote set-url origin https://github.com/williamkpchan/williamkpchan.github.io

<h2>update an existing github repo from a different computer</h2>

Run
git clone https://github.com/your/repo
to clone your project on your computer.
It will create a new folder containing your Android project

Copy your changed files in this new folder

You can now commit your changes from this folder

If it is your repository
If the repository belongs to you, you can start committing changes on the new computer and then pushing them to master:

git push -u origin master
The origin is the name of the remote directory.
If you use the clone command on your own repository the origin of the cloned repository will automatically be your github repository.

It is essential that if you clone a repository so that it is on two different computers, you use the pull command (see below) before you start working. Otherwise, you will put one of your repositories out of synch with the “master” repository and you will need to use the “merge” command, which can be rather tedious.

<h2>Git server</h2>
<a href="https://stackoverflow.com/questions/8390828/how-can-i-have-github-on-my-own-server" class="whitebut ">Github on my own server</a>
<a href="https://github.com/patrikf/glip" class="whitebut ">Glip for PHP to view a git repo</a>

<h2>GitHub Actions</h2>
<a href="https://docs.github.com/en/actions" class="whitebut ">GitHub Actions</a>

usage: git [--version] [--help] [-C &lt;path>] [-c name=value]
           [--exec-path[=&lt;path>]] [--html-path] [--man-path] [--info-path]
           [-p | --paginate | --no-pager] [--no-replace-objects] [--bare]
           [--git-dir=&lt;path>] [--work-tree=&lt;path>] [--namespace=&lt;name>]
           &lt;command> [&lt;args>]

These are common Git commands used in various situations:

start a working area (see also: git help tutorial)
   clone      Clone a repository into a new directory
   init       Create an empty Git repository or reinitialize an existing one

work on the current change (see also: git help everyday)
   add        Add file contents to the index
   mv         Move or rename a file, a directory, or a symlink
   reset      Reset current HEAD to the specified state
   rm         Remove files from the working tree and from the index

examine the history and state (see also: git help revisions)
   bisect     Use binary search to find the commit that introduced a bug
   grep       Print lines matching a pattern
   log        Show commit logs
   show       Show various types of objects
   status     Show the working tree status

grow, mark and tweak your common history
   branch     List, create, or delete branches
   checkout   Switch branches or restore working tree files
   commit     Record changes to the repository
   diff       Show changes between commits, commit and working tree, etc
   merge      Join two or more development histories together
   rebase     Reapply commits on top of another base tip
   tag        Create, list, delete or verify a tag object signed with GPG

collaborate (see also: git help workflows)
   fetch      Download objects and refs from another repository
   pull       Fetch from and integrate with another repository or a local branch
   push       Update remote refs along with associated objects

'git help -a' and 'git help -g' list available subcommands and some
concept guides. See 'git help &lt;command>' or 'git help &lt;concept>'
to read about a specific subcommand or concept.

<h2>batch file push to github with username and password</h2>
https://coolaj86.com/articles/vanilla-devops-git-credentials-cheatsheet/

git config --global user.name "williamkpchan"
git config --global user.email "williamkpchan@gmail.com"
git init
git status
git push
pause

<h2>Git to avoid typing username password</h2>
Two approaches can be used. 

SSH keys are a way to identify trusted computers, without involving passwords. 
One needs to generate an SSH key and add the public key to your GitHub account. 
A guide on how to set up SSH key can be found <a href="https://help.github.com/articles/generating-ssh-keys/" rel="noopener nofollow">here</a>
But this is not the main focus for this article. 

The key question remains:
<strong>Is there a way to skip typing my username and/password when using HTTPS in GitHub?</strong>
The answer is yes. 
This is done by using <em>credential helpers. 
</em>And this is the second approach. 
Credential helpers basically tells Git to remember your GitHub username and password every time it talks to GitHub. 
The syntax is given by:
git config credential.https://example.com.username myusername
git config credential.helper “$helper $options”
Therefore, credential helpers are external programs from which Git can request both usernames and passwords. 
Credential helpers are in two forms: <em>cache</em> which caches credentials in memory for a short period of time, and <em>store</em> which basically stores credentials indefinitely on disk.
Once you have selected the helper, you can tell Git to use it by putting its name into the credential.helper variable.

Find a helper:
git help -a | grep credential-credential-foo
2. Read its description.
 git help credential-foo
3. Tell Git to use it.
git config — global credential.helper foo
Assuming you have a remote with the following URL<strong><em> https://github.com/adambajumba/MestEIT</em></strong>, update the Git configuration to use the helper whenever it needs authentication steps:
$ git config --global \credential.https://github.com/myusername/mysecretproject.username \your_github_account_name$ git config --global \credential.https://github.com/adambajumba/MestEIT.adambajumba \IsaacJumba
Note that the remote URL is appended with a trailing .username fragment which becomes the key and the GitHub username becomes the value.Once the username is set, map the helper: And you are done! That easy, right?
$ git config --global core.askpass ~/.git_credential_helper.rb
An example of how it works would be:
$ git config credential.helper store
$ git push http://example.com/repo.git
Username: &lt;type your username>
Password: &lt;type your password><strong>[several days later]</strong>
$ git push http://example.com/repo.git
[your credentials are used automatically]
In conclusion, the credential helper does not work in all versions of git but from version 1.8 and above.

<a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh/working-with-ssh-key-passphrases" class="whitebut ">Working with SSH key passphrases</a>

<h2>Git Tools - Credential Storage</h2>
If you use the SSH transport for connecting to remotes, it’s possible for you to have a key without a passphrase, which allows you to securely transfer data without typing in your username and password.
However, this isn’t possible with the HTTP protocols – every connection needs a username and password.
This gets even harder for systems with two-factor authentication, where the token you use for a password is randomly generated and unpronounceable.

Fortunately, Git has a credentials system that can help with this.
Git has a few options provided in the box:
The default is not to cache at all.
Every connection will prompt you for your username and password.

The “cache” mode keeps credentials in memory for a certain period of time.
None of the passwords are ever stored on disk, and they are purged from the cache after 15 minutes.
The “store” mode saves the credentials to a plain-text file on disk, and they never expire.
This means that until you change your password for the Git host, you won’t ever have to type in your credentials again.

The downside of this approach is that your passwords are stored in cleartext in a plain file in your home directory.
If you’re using a Mac, Git comes with an “osxkeychain” mode, which caches credentials in the secure keychain that’s attached to your system account.
This method stores the credentials on disk, and they never expire, but they’re encrypted with the same system that stores HTTPS certificates and Safari auto-fills.
If you’re using Windows, you can install a helper called “Git Credential Manager for Windows.”

This is similar to the “osxkeychain” helper described above, but uses the Windows Credential Store to control sensitive information.
It can be found at <a href="https://github.com/Microsoft/Git-Credential-Manager-for-Windows">https://github.com/Microsoft/Git-Credential-Manager-for-Windows</a>.
You can choose one of these methods by setting a Git configuration value:
<code>$ git config --global credential.helper cache</code>

Some of these helpers have options.
The “store” helper can take a <code>--file &lt;path></code> argument, which customizes where the plain-text file is saved (the default is <code>~/.git-credentials</code>).
The “cache” helper accepts the <code>--timeout &lt;seconds></code> option, which changes the amount of time its daemon is kept running (the default is “900”, or 15 minutes).
Here’s an example of how you’d configure the “store” helper with a custom file name:

<code>$ git config --global credential.helper 'store --file ~/.my-credentials'</code>
Git even allows you to configure several helpers.
When looking for credentials for a particular host, Git will query them in order, and stop after the first answer is provided.
When saving credentials, Git will send the username and password to <strong>all</strong> of the helpers in the list, and they can choose what to do with them.

Here’s what a <code>.gitconfig</code> would look like if you had a credentials file on a thumb drive, but wanted to use the in-memory cache to save some typing if the drive isn’t plugged in:
<code>[credential]
    helper = store --file /mnt/thumbdrive/.git-credentials
    helper = cache --timeout 30000</code>

<h3>Under the Hood</h3>
How does this all work?
Git’s root command for the credential-helper system is <code>git credential</code>, which takes a command as an argument, and then more input through stdin.
This might be easier to understand with an example.

Let’s say that a credential helper has been configured, and the helper has stored credentials for <code>mygithost</code>.
Here’s a session that uses the “fill” command, which is invoked when Git is trying to find credentials for a host:
<code>$ git credential fill <b>(1)</b>
protocol=https <b>(2)</b>
host=mygithost
<b>(3)</b>
protocol=https <b>(4)</b>
host=mygithost
username=bob
password=s3cre7

$ git credential fill <b>(5)</b>
protocol=https
host=unknownhost
Username for 'https://unknownhost': bob
Password for 'https://bob@unknownhost':
protocol=https
host=unknownhost
username=bob
password=s3cre7</code>

This is the command line that initiates the interaction.
Git-credential is then waiting for input on stdin.
We provide it with the things we know: the protocol and hostname.
A blank line indicates that the input is complete, and the credential system should answer with what it knows.
Git-credential then takes over, and writes to stdout with the bits of information it found.

If credentials are not found, Git asks the user for the username and password, and provides them back to the invoking stdout (here they’re attached to the same console).
The credential system is actually invoking a program that’s separate from Git itself; which one and how depends on the <code>credential.helper</code> configuration value.
There are several forms it can take:
<table>
<colgroup><col style="width: 50%;"><col style="width: 50%;">
</colgroup>
<thead><tr><th>Configuration Value</th><th>Behavior</th></tr></thead>
<tbody>
<tr><td><code>foo</code></td><td>Runs <code>git-credential-foo</code></td></tr>
<tr><td><code>foo -a --opt=bcd</code></td><td>Runs <code>git-credential-foo -a --opt=bcd</code></td></tr>
<tr><td><code>/absolute/path/foo -xyz</code></td><td>Runs <code>/absolute/path/foo -xyz</code></td></tr>
<tr><td><code>!f() { echo "password=s3cre7"; }; f</code></td><td>Code after <code>!</code> evaluated in shell</td></tr>
</tbody>
</table>

So the helpers described above are actually named <code>git-credential-cache</code>, <code>git-credential-store</code>, and so on, and we can configure them to take command-line arguments.
The general form for this is “git-credential-foo [args] &lt;action>.”
The stdin/stdout protocol is the same as git-credential, but they use a slightly different set of actions:
<code>get</code> is a request for a username/password pair.
<code>store</code> is a request to save a set of credentials in this helper’s memory.
<code>erase</code> purge the credentials for the given properties from this helper’s memory.
For the <code>store</code> and <code>erase</code> actions, no response is required (Git ignores it anyway).
For the <code>get</code> action, however, Git is very interested in what the helper has to say.

If the helper doesn’t know anything useful, it can simply exit with no output, but if it does know, it should augment the provided information with the information it has stored.
The output is treated like a series of assignment statements; anything provided will replace what Git already knows.
Here’s the same example from above, but skipping git-credential and going straight for git-credential-store:
<code>$ git credential-store --file ~/git.store store <b>(1)</b>

protocol=https
host=mygithost
username=bob
password=s3cre7
$ git credential-store --file ~/git.store get <b>(2)</b>
protocol=https
host=mygithost
username=bob <b>(3)</b>
password=s3cre7</code>

Here we tell <code>git-credential-store</code> to save some credentials: the username “bob” and the password “s3cre7” are to be used when <code><a href="https://mygithost">https://mygithost</a></code> is accessed.
Now we’ll retrieve those credentials.
We provide the parts of the connection we already know (<code><a href="https://mygithost">https://mygithost</a></code>), and an empty line.

<code>git-credential-store</code> replies with the username and password we stored above.
Here’s what the <code>~/git.store</code> file looks like:
<code>https://bob:s3cre7@mygithost</code>
It’s just a series of lines, each of which contains a credential-decorated URL.

The <code>osxkeychain</code> and <code>wincred</code> helpers use the native format of their backing stores, while <code>cache</code> uses its own in-memory format (which no other process can read).
<h3>A Custom Credential Cache</h3>
Given that <code>git-credential-store</code> and friends are separate programs from Git, it’s not much of a leap to realize that <em>any</em> program can be a Git credential helper.
The helpers provided by Git cover many common use cases, but not all.

For example, let’s say your team has some credentials that are shared with the entire team, perhaps for deployment.
These are stored in a shared directory, but you don’t want to copy them to your own credential store, because they change often.
None of the existing helpers cover this case; let’s see what it would take to write our own.
There are several key features this program needs to have:

The only action we need to pay attention to is <code>get</code>; <code>store</code> and <code>erase</code> are write operations, so we’ll just exit cleanly when they’re received.
The file format of the shared-credential file is the same as that used by <code>git-credential-store</code>.
The location of that file is fairly standard, but we should allow the user to pass a custom path just in case.
Once again, we’ll write this extension in Ruby, but any language will work so long as Git can execute the finished product.

Here’s the full source code of our new credential helper:
<code>#!/usr/bin/env ruby
require 'optparse'
path = File.expand_path '~/.git-credentials' # <b>(1)</b>

OptionParser.new do |opts|
    opts.banner = 'USAGE: git-credential-read-only [options] &lt;action>'
    opts.on('-f', '--file PATH', 'Specify path for backing store') do |argpath|
        path = File.expand_path argpath
    end
end.parse!
exit(0) unless ARGV[0].downcase == 'get' # <b>(2)</b>
exit(0) unless File.exists? path

known = {} # <b>(3)</b>
while line = STDIN.gets
    break if line.strip == ''
    k,v = line.strip.split '=', 2
    known[k] = v
end
File.readlines(path).each do |fileline| # <b>(4)</b>
    prot,user,pass,host = fileline.scan(/^(.*?):\/\/(.*?):(.*?)@(.*)$/).first

    if prot == known['protocol'] and host == known['host'] and user == known['username'] then
        puts "protocol=#{prot}"
        puts "host=#{host}"
        puts "username=#{user}"
        puts "password=#{pass}"
        exit(0)
    end
end</code>

Here we parse the command-line options, allowing the user to specify the input file.
The default is <code>~/.git-credentials</code>.
This program only responds if the action is <code>get</code> and the backing-store file exists.
This loop reads from stdin until the first blank line is reached.

The inputs are stored in the <code>known</code> hash for later reference.
This loop reads the contents of the storage file, looking for matches.
If the protocol, host, and username from <code>known</code> match this line, the program prints the results to stdout and exits.
We’ll save our helper as <code>git-credential-read-only</code>, put it somewhere in our <code>PATH</code> and mark it executable.

Here’s what an interactive session looks like:
<code>$ git credential-read-only --file=/mnt/shared/creds get
protocol=https
host=mygithost
username=bob
protocol=https
host=mygithost
username=bob
password=s3cre7</code>

Since its name starts with “git-”, we can use the simple syntax for the configuration value:
<code>$ git config --global credential.helper 'read-only --file /mnt/shared/creds'</code>
As you can see, extending this system is pretty straightforward, and can solve some common problems for you and your team.


<h2>use a github repo from a same account but different computers</h2>

supplying --force as an argument to the git push command

first fetch those changes from the remote, and then pull them into your local repository on computer 1. 

$ git fetch origin
$ git pull origin master
In these commands, origin is the name of your github remote and master is the name of the branch you are currently tracking. 

These names can be changed, but these are the defaults which appear to be the names in your case.

Note, you will likely need to revert the new changes you made to computer 1. 

Git will have a hard time trying to merge the changes from computer 2 with the changes you made to computer 1 when you were trying to commit the second time.

pull is fetch + merge.
If you've already run fetch, there's no need to run pull, merge should be enough.
Or just run pull without fetching first, as it fetches on its own.
<h2>Multiple Github Accounts on a single Machine</h2>
Let suppose I have two github accounts, <k>https://github.com/rahul-office</k> and <k>https://github.com/rahul-personal</k>. Now i want to setup my mac to easily talk to both the github accounts.
NOTE: This logic can be extended to more than two accounts also. :)
The setup can be done in 5 easy steps:
<k>Step 1: Create SSH keys for all accounts
Step 2: Add SSH keys to SSH Agent
Step 3: Add SSH public key to the Github
Step 4: Create a Config File and Make Host Entries
Step 5: Cloning GitHub repositories using different accounts</k>
<h3>Create SSH keys for all accounts</h3>
First make sure your current directory is your <k>.ssh</k> folder.
     $ cd ~/.ssh

Syntax for generating unique ssh key for ann account is:
     ssh-keygen -t rsa -C "your-email-address" -f "github-username"
here,

<k>-C</k> stands for comment to help identify your ssh key
<k>-f</k> stands for the file name where your ssh key get saved
<h4>Now generating SSH keys for my two accounts</h4>
     ssh-keygen -t rsa -C "my_office_email@gmail.com" -f "github-rahul-office"
     ssh-keygen -t rsa -C "my_personal_email@gmail.com" -f "github-rahul-personal"

Notice here <k>rahul-office</k> and <k>rahul-work</k> are the username of my github accounts corresponding to <k>my_office_email@gmail.com</k> and <k>my_personal_email@gmail.com</k> email ids respectively.
After entering the command the terminal will ask for passphrase, leave it empty and proceed.
<a target="_blank" href="https://raw.githubusercontent.com/rahularity/github-essentials/bc3dafc37b36f5fb4ebcffcba63a7689a36fc7ff/screenshots/passphrase.png"><img src="https://raw.githubusercontent.com/rahularity/github-essentials/bc3dafc37b36f5fb4ebcffcba63a7689a36fc7ff/screenshots/passphrase.png" alt="Passphrase Image" style="max-width: 100%;"></a>

Now after adding keys , in your .ssh folder, a public key and a private will get generated.

The public key will have an extention <k>.pub</k> and private key will be there without any extention both having same name which you have passed after <k>-f</k> option in the above command. (in my case <k>github-rahul-office</k> and <k>github-rahu-personal</k>)
<a target="_blank" href="https://raw.githubusercontent.com/rahularity/github-essentials/master/screenshots/ssh_keys_added.png"><img src="https://raw.githubusercontent.com/rahularity/github-essentials/master/screenshots/ssh_keys_added.png" alt="Added Key Image" style="max-width: 100%;"></a>
<h3>Add SSH keys to SSH Agent</h3>
Now we have the keys but it cannot be used until we add them to the SSH Agent.
     ssh-add -K ~/.ssh/github-rahul-office
     ssh-add -K ~/.ssh/github-rahul-personal

You can read more about adding keys to SSH Agent <a href="https://help.github.com/en/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent">here.</a>
<h3>Add SSH public key to the Github</h3>
For the next step we need to add our public key (that we have generated in our previous step) and add it to corresponding github accounts.
For doing this we need to:
<k>1. Copy the public key</k>
<dg> We can copy the public key either by opening the github-rahul-office.pub file in vim and then copying the content of it.
</dg>
     vim ~/.ssh/github-rahul-office.pub
     vim ~/.ssh/github-rahul-personal.pub

<p align="center">OR
We can directly copy the content of the public key file in the clipboard.
     pbcopy &lt; ~/.ssh/github-rahul-office.pub
     pbcopy &lt; ~/.ssh/github-rahul-personal.pub

<k>2. Paste the public key on Github</k>
<ul>
<li>Sign in to Github Account
<li>Goto <k>Settings</k> &gt; <k>SSH and GPG keys</k> &gt; <k>New SSH Key</k>
<li>Paste your copied public key and give it a Title of your choice.
</ul>
<em><k>OR</k></em>
<ul>
<li>Sign in to Github
<li>Paste this link in your browser (<a href="https://github.com/settings/keys">https://github.com/settings/keys</a>) or click <a href="https://github.com/settings/keys">here</a>
<li>Click on <k>New SSH Key</k> and paste your copied key.
</ul>
<h3>Create a Config File and Make Host Entries</h3>
The <k>~/.ssh/config</k> file allows us specify many config options for SSH.
If <k>config</k> file not already exists then create one (make sure you are in <k>~/.ssh</k> directory)
     touch config

The commands below opens config in your default editor....Likely TextEdit, VS Code.
     open config

Now we need to add these lines to the file, each block corresponding to each account we created earlier.
<dg>     #rahul-office account
     Host github.com-rahul-office
          HostName github.com
          User git
          IdentityFile ~/.ssh/github-rahul-office

     #rahul-personal account
     Host github.com-rahul-personal
          HostName github.com
          User git
          IdentityFile ~/.ssh/github-rahul-personal
</dg>
<h3>Cloning GitHub repositories using different accounts</h3>
So we are done with our setups and now its time to see it in action. We will clone a repository using one of the account we have added.
Make a new project folder where you want to clone your repository and go to that directory from your terminal.
For Example:
I am making a repository on my personal github account and naming it <k>TestRepo</k>
Now for cloning the repo use the below command:
<dg>    git clone git@github.com-{your-username}:{owner-user-name}/{the-repo-name}.git

    [e.g.] git clone git@github.com-rahul-personal:rahul-personal/TestRepo.git
</dg>
 
<h3>Finally</h3>
From now on, to ensure that our commits and pushes from each repository on the system uses the correct GitHub user — we will have to configure <k>user.email</k> and <k>user.name</k> in every repository freshly cloned or existing before.
To do this use the following commands.
<dg>     git config user.email "my_office_email@gmail.com"
     git config user.name "Rahul Pandey"
     
     git config user.email "my-personal-email@gmail.com"
     git config user.name "Rahul Pandey"
</dg>
Pick the correct pair for your repository accordingly.
To push or pull to the correct account we need to add the remote origin to the project
<dg>     git remote add origin git@github.com-rahul-personal:rahul-personal
     
     git remote add origin git@github.com-rahul-office:rahul-office
</dg>
Now you can use:
<dg>     git push
     
     git pull
</dg>

P.S: <br> If this gist has been helpful to you, kindly consider leaving a star.
<br>   If you'd like, let's connect on <a href="https://www.linkedin.com/in/rahularity" rel="nofollow">LinkedIn</a> and build a supportive community together.


<h2>Use Multiple GitHub Accounts With One Computer</h2>
<h3>How to set up and change SSH keys to use multiple GitHub accounts on one machine</h3>
I currently have two GitHub accounts: a personal and a work one. 
Obviously, my work computer is set up with my work account. 

I wanted to figure out how to push to GitHub with my personal account whenever I’m working on side projects via my work computer.
At first glance, for the seemingly simple task of switching between two accounts, the process seemed a little involved. 

But once you break things down into steps, it’s less daunting.
<h3>Quick Note on <strong><em>SSH</em></strong></h3>
<a href="https://www.ssh.com/ssh/protocol/#strong-authentication-with-ssh-keys">SSH</a><strong> </strong>(or secure shell) is a network protocol which, among <a href="https://www.ssh.com/ssh/protocol/#typical-uses-of-the-ssh-protocol">other things</a>, allows one computer to communicate with another over an unsecured network like the internet.
Without encryption, data travels over the web in plain text form. 
Consequently, it would be easy for someone to intercept valuable data, like user names or passwords, for wicked intent.SSH allows encryption of your data by way of a <a href="https://www.ssh.com/ssh/tunneling/"><em>tunnel</em></a>, which permits your computer to securely connect to another.
This is done via the use of <a href="https://www.ssh.com/ssh/key/">SSH keys</a> and <a href="https://en.wikipedia.org/wiki/Public-key_cryptography">public-key cryptography </a>(aka asymmetric cryptography) which are used for authentication purposes between said computers, in order to decrypt the information being shared.
<a href="https://www.youtube.com/watch?v=AQDCe585Lnc">Here’s a great video</a> explaining the concept of asymmetric cryptography further.SSH is commonly implemented using the client-server model.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://miro.medium.com/max/1400/1*On6fpv0NVHnmqZs7Dn6DqQ.png">
Client-server model with asymmetric cryptography
When running any remote commands from our computer(e.g., git push or git pull) to a remote repository (GitHub), it’s this protocol that enables us to do so without having to supply a password and username each time.
Let’s now look at the configuration for it.
<h3>Configuration</h3>The configuration can essentially be broken down into four steps:
Generate an SSH key for the new account.
Attach this new key to your GitHub account.
Register the new key with the SSH agent.
Create an SSH config file.

<h3><strong>Step 1. Generate an <em>SSH</em> key for the new account</strong></h3>Using the SSH protocol, we’ll have to generate a key for any new account we’d like to use.
Hop onto your terminal, run the following command, and attach your GitHub email address:$ ssh-keygen -t rsa -C "uremail@gmail.com" A new key pair will be generated. 
At this point, you want to be careful not to overwrite your existing key pair, which would look like the following:({your home Directory}/.ssh/id_rsa):Instead, you can copy the directory and modify the file name to include your account name, as in the screenshot below:
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://miro.medium.com/max/875/1*tKXjK-bNH8wwkKOFJT_6tg.png">
You will then be prompted to enter a passphrase. 
Your new SSH key will be found at a directory similar to this:{your home Directory}/.ssh/id_rsa_uraccount
<h3><strong>Step 2. Attach the new key to your GitHub account</strong></h3>We’ve just created a public key, and now we need to allow our GitHub account to trust it. 
This allows you to not have to authenticate every time you run a remote command (git push, git pull).
Copy the public key via the following command <code>pbcopy &lt; ~/.ssh/id_rsa.pub</code> and then log in to your personal GitHub account:
Go to <code>Settings</code>.
From the left side navigation, click <code>SSH and GPG keys</code>.
Click on <code>New SSH key</code>, name it (it's a good idea to name it after the computer you’re using it in), and paste the key you previously copied.
Click <code>Add key</code>.

<h3><strong>Step 3. Register the new key with the <em>SSH agent</em></strong></h3>We now need to register our key with the <a href="https://www.ssh.com/ssh/agent">SSH agent</a>. 

The SSH agent keeps track of user identity keys and passphrases and works as an additional layer of security.
In your terminal, write the command <code>ssh-add</code> and add the path to the files containing your keys. 
As shown below, we are adding keys for our main account and the second account we just created.ssh-add ~/.ssh/id_rsassh-add ~/.ssh/id_rsa_uraccount
<h3><strong>Step 4. Create an <em>SSH</em> config file</strong></h3>The SSH config file allows us to set configuration rules that will specify when we want to push to our work account versus our personal account. 

This is done by defining which identity file to use ( the ones we’ve added to our SSH agent ) on which domain.
If the file has already been created, it should be at <code>~/.ssh/config</code>. 
But by default, it will not exist, so we’ll need to create it by running the command <code>touch ~/.ssh/config</code>.
You can use any text editor or IDE to open and edit the file. 
I went with the terminal’s text editor <a href="https://www.vim.org/">vim</a><strong>. 

</strong>I don’t use it frequently, and it does have a bit of a learning curve, so I tend to use a <a href="https://devhints.io/vim">cheat sheet</a> to navigate through it<strong>.
</strong>To open the file, use <code>vim config</code>.# Account 1 (work or personal) - the default configHost github.com   HostName github.com   User git   IdentityFile ~/.ssh/id_rsa   # Account 2 (work or personal) - the config we are addingHost github-uraccount      HostName github.com   User git   IdentityFile ~/.ssh/id_rsa_uraccountThe top part is the default configuration. 
It comprises the following:<ul><li>the<strong> host</strong>(<code>github.com</code>)
Its <strong>host name </strong>(<code>github.com</code>)
a <strong>user ID </strong>(<code>git</code>)
its<strong> identity file</strong> (<code>~/.ssh/id_rsa</code>)</li></ul>We can basically duplicate the default configuration; we’ll only need to changes two things: the host (<code>github-uraccount</code>) and the identity file (to the key we created earlier, <code>~/.ssh/id_rsa_uraccount</code>).
And that should do it. 
Save and close the file using <code>:wq</code> (if you are using vim).
<h3>Create a new repository</h3>Now that we’re done with the configuration, let’s push to GitHub with our new account.
In your project’s working directory, start by initializing git using <code>git init </code>then go to GitHub and create a new repository.
When you get to the instructions under Existing Git Repo, you’d normally just copy and paste the commands to your terminal to add the repo as the remote to your local repo, but for this case, we need to replace “github.com” with the host we set up in our config file earlier. 

So instead of the default host <code>git@github.com</code>, we use <code>git@github-uraccount</code>.git remote add origin git@github-uraccount:uraccount/repo_name.gitNow you can push to GitHub using, for example, the following:git add .git commit -m "Initial commit"git push -u origin master
<h3>Associate your commits with a particular username</h3>For a single repository, if you’d like to change the name associated with your commits, you’ll also need to change your user name and email to reflect the GitHub account you want the repository to be associated with by using <code><a href="https://help.github.com/en/github/using-git/setting-your-username-in-git">git config</a></code> as shown below (to do it globally, add the flag <code>-g</code> before <code>user</code>).git config user.name "uraccount"git config user.email "uraccount@gmail.com"

<h2>Quickstart for Codespaces</h2>
In this guide, you'll create a codespace from a <a href="https://github.com/2percentsilk/haikus-for-codespaces">template repository</a> and explore some of the essential features available to you within the codespace.
From this quickstart, you will learn how to create a codespace, connect to a forwarded port to view your running application, use version control in a codespace, and personalize your setup with extensions.

For more information on exactly how Codespaces works, see the companion guide "<a href="https://docs.github.com/en/codespaces/getting-started/deep-dive">Deep dive into Codespaces</a>."
<h3>Creating your codespace</h3>
Navigate to the <a href="https://github.com/2percentsilk/haikus-for-codespaces">template repository</a> and select <strong>Use this template</strong>. 

Name your repository, select your preferred privacy setting, and click <strong>Create repository from this template</strong>.
Navigate to the main page of the newly created repository. 
Under the repository name, use the <strong> Code</strong> drop-down menu, and in the <strong>Codespaces</strong> tab, click  <strong>New codespace</strong>.

<h3>Running the application</h3>
Once your codespace is created, your repository will be automatically cloned into it. 
Now you can run the application and launch it in a browser.

Since this example uses a Node.js project, start the application by entering <code>npm run dev</code> in the terminal. 
This command executes the <code>dev</code> script in the package.json file and starts up the web application defined in the sample repository.
If you're following along with a different application type, enter the corresponding start command for that project.

When your application starts, the codespace recognizes the port the application is running on and displays a prompt to forward that port so you can connect to it. 
Click <strong>Open in Browser</strong> to view your running application in a new tab.
<h3>Edit the application and view changes</h3>

Switch back to your codespace and open the <code>haikus.json</code> file by double-clicking it in the File Explorer.
Edit the <code>text</code> field of the first haiku to personalize the application with your own haiku.
Go back to the running application tab in your browser and refresh to see your changes.

If you've closed the tab, open the Ports panel and click the <strong>Open in browser</strong> icon for the running port.
<h3>Committing and pushing your changes</h3>
Now that you've made a few changes, you can use the integrated terminal or the source view to commit and push the changes back to the remote.

In the Activity Bar, click the <strong>Source Control</strong> view.
To stage your changes, click  <strong>+</strong> next to the file you've changed, or next to <strong>Changes</strong> if you've changed multiple files and you want to stage them all.
Type a commit message describing the change you've made.

To commit your staged changes, click the check mark at the top the source control side bar.
You can push the changes you've made. 
This applies those changes to the upstream branch on the remote repository. 

You might want to do this if you're not yet ready to create a pull request, or if you prefer to create a pull request on GitHub.
At the top of the side bar, click the ellipsis (<strong>...</strong>).
In the drop-down menu, click <strong>Push</strong>.

<h3>Personalizing with an extension</h3>
Within a codespace, you have access to the Visual Studio Code Marketplace. 
For this example, you'll install an extension that alters the theme, but you can install any extension that is useful for your workflow.

In the left sidebar, click the Extensions icon.
In the search bar, enter <code>fairyfloss</code> and install the fairyfloss extension.
Select the <code>fairyfloss</code> theme by selecting it from the list.

Changes you make to your editor setup in the current codespace, such as theme and keyboard bindings, are synced automatically via <a href="https://code.visualstudio.com/docs/editor/settings-sync">Settings Sync</a> to any other codespaces you open and any instances of Visual Studio Code that are signed into your GitHub account.
<h3>Next Steps</h3>
You've successfully created, personalized, and run your first application within a codespace but there's so much more to explore! Here are some helpful resources for taking your next steps with Codespaces.

<a href="https://docs.github.com/en/codespaces/getting-started/deep-dive">Deep dive</a>: This quickstart presented some of the features of Codespaces. 
The deep dive looks at these areas from a technical standpoint.
<a href="https://docs.github.com/en/codespaces/getting-started-with-codespaces">Setting up your project for Codespaces</a>: These guides provide information on setting up your project to use Codespaces with specific languages

<a href="https://docs.github.com/en/codespaces/setting-up-your-codespace/configuring-codespaces-for-your-project">Configuring Codespaces for your project</a>: This guide provides details on creating a custom configuration for Codespaces for your project.
<h3>Further reading</h3>
<a href="https://docs.github.com/en/codespaces/managing-codespaces-for-your-organization/enabling-codespaces-for-your-organization">Enabling Codespaces for your organization</a>

<h2>Deep dive into Codespaces</h2>
Understand how Codespaces works.
Codespaces is an instant, cloud-based development environment that uses a container to provide you with common languages, tools, and utilities for development. 

Codespaces is also configurable, allowing you to create a customized development environment for your project. 
By configuring a custom development environment for your project, you can have a repeatable codespace configuration for all users of your project.
<h3>Creating your codespace</h3>
There are a number of entry points to create a codespace.
From your repository for new feature work.
From an open pull request to explore work-in-progress.

From a commit in the repository's history to investigate a bug at a specific point in time.
From Visual Studio Code.
Your codespace can be ephemeral if you need to test something or you can return to the same codespace to work on long-running feature work. 

For more information, see "<a href="https://docs.github.com/en/codespaces/developing-in-codespaces/creating-a-codespace">Creating a codespace</a>."
Once you've selected the option to create a new codespace, some steps happen in the background before the codespace is available to you.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://docs.github.com/assets/cb-155258/images/help/codespaces/new-codespace-button.png" >

<h3>Step 1: VM and storage are assigned to your codespace</h3>
When you create a codespace, a <a href="https://github.blog/2020-12-21-get-up-to-speed-with-partial-clone-and-shallow-clone/">shallow clone</a> of your repository is made on a Linux virtual machine that is both dedicated and private to you. 
Having a dedicated VM ensures that you have the entire set of compute resources from that machine available to you. 
If necessary, this also allows you to have full root access to your container.
<h3>Step 2: Container is created</h3>
Codespaces uses a container as the development environment. 

This container is created based on the configurations that you can define in a <code>devcontainer.json</code> file and/or Dockerfile in your repository. 
If you don't <a href="https://docs.github.com/en/codespaces/customizing-your-codespace/configuring-codespaces-for-your-project">configure a container</a>, Codespaces uses a <a href="https://docs.github.com/en/codespaces/customizing-your-codespace/configuring-codespaces-for-your-project#using-the-default-configuration">default image</a>, which has many languages and runtimes available. 
For information on what the default image contains, see the <a href="https://github.com/microsoft/vscode-dev-containers/tree/main/containers/codespaces-linux"><code>vscode-dev-containers</code></a> repository.

<strong>Note:</strong> If you want to use Git hooks in your codespace and apply anything in the <a href="https://git-scm.com/docs/git-init#_template_directory">git template directory</a> to your codespace, then you must set up hooks during step 4 after the container is created.
Since your repository is cloned onto the host VM before the container is created, anything in the <a href="https://git-scm.com/docs/git-init#_template_directory">git template directory</a> will not apply in your codespace unless you set up hooks in your <code>devcontainer.json</code> configuration file using the <code>postCreateCommand</code> in step 4. 
For more information, see "<a href="#step-4-post-creation-setup">Step 4: Post-creation setup</a>."

<h3>Step 3: Connecting to the codespace</h3>
When your container has been created and any other initialization has run, you'll be connected to your codespace. 
You can connect to it through the web or via <a href="https://docs.github.com/en/codespaces/developing-in-codespaces/using-codespaces-in-visual-studio-code">Visual Studio Code</a>, or both, if needed.

<h3>Step 4: Post-creation setup</h3>
Once you are connected to your codespace, your automated setup may continue to build based on the configuration you specified in your <code>devcontainer.json</code> file. 
You may see <code>postCreateCommand</code> and <code>postAttachCommand</code> run.

If you want to use Git hooks in your codespace,  set up hooks using the <a href="https://code.visualstudio.com/docs/remote/devcontainerjson-reference#_lifecycle-scripts"><code>devcontainer.json</code> lifecycle scripts</a>, such as <code>postCreateCommand</code>. 
For more information, see the <a href="https://code.visualstudio.com/docs/remote/devcontainerjson-reference#_devcontainerjson-properties"><code>devcontainer.json</code> reference</a> in the Visual Studio Code documentation.
If you have a public dotfiles repository for Codespaces, you can enable it for use with new codespaces. 

When enabled, your dotfiles will be cloned to the container and the install script will be invoked. 
For more information, see "<a href="https://docs.github.com/en/github/developing-online-with-codespaces/personalizing-codespaces-for-your-account#dotfiles">Personalizing Codespaces for your account</a>." 
Finally, the entire history of the repository is copied down with a full clone.

During post-creation setup you'll still be able to use the integrated terminal and make edits to your files, but take care to avoid any race conditions between your work and the commands that are running.
<h3>Codespaces lifecycle</h3>
<h3>Saving files in your codespace</h3>
As you develop in your codespace, it will save any changes to your files every few seconds. 
Your codespace will keep running for 30 minutes after the last activity. 
After that time it will stop running but you can restart it from either from the existing browser tab or the list of existing codespaces. 

File changes from the editor and terminal output are counted as activity and so your codespace will not stop if terminal output is continuing.
<strong>Note:</strong> Changes in a codespace in Visual Studio Code are not saved automatically, unless you have enabled <a href="https://code.visualstudio.com/docs/editor/codebasics#_save-auto-save">Auto Save</a>.
<h3>Closing or stopping your codespace</h3>
To stop your codespace you can <a href="https://docs.github.com/en/codespaces/codespaces-reference/using-the-vs-code-command-palette-in-codespaces#suspending-or-stopping-a-codespace">use the VS Code Command Palette</a> (<code>Shift + Command + P</code> (Mac) / <code>Ctrl + Shift + P</code> (Windows)). 
If you exit your codespace without running the stop command (for example, closing the browser tab), or if you leave the codespace running without interaction, the codespace and its running processes will continue until a window of inactivity occurs, after which the codespace will stop. 
By default, the window of inactivity is 30 minutes. 

When you close or stop your codespace, all uncommitted changes are preserved until you connect to the codespace again.
<h3>Running your application</h3>
Port forwarding gives you access to TCP ports running within your codespace. 

For example, if you're running a web application on port 4000 within your codespace, you can automatically forward that port to make the application accessible from your browser.
Port forwarding determines which ports are made accessible to you from the remote machine. 
Even if you do not forward a port, that port is still accessible to other processes running inside the codespace itself.

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://docs.github.com/assets/cb-55542/images/help/codespaces/port-forwarding.png" >
When an application running inside Codespaces outputs a port to the console, Codespaces detects the localhost URL pattern and automatically forwards the port. 
You can click on the URL in the terminal or in the toast message to open the port in a browser. 

By default, Codespaces forwards the port using HTTP. 
For more information on port forwarding, see "<a href="https://docs.github.com/en/codespaces/developing-in-codespaces/forwarding-ports-in-your-codespace">Forwarding ports in your codespace</a>."
While ports can be forwarded automatically, they are not publicly accessible to the internet. 

By default, all ports are private, but you can manually make a port available to your organization or public, and then share access through a URL. 
For more information, see "<a href="https://docs.github.com/en/codespaces/developing-in-codespaces/forwarding-ports-in-your-codespace#sharing-a-port">Sharing a port</a>."
Running your application when you first land in your codespace can make for a fast inner dev loop. 

As you edit, your changes are automatically saved and available on your forwarded port. 
To view changes, go back to the running application tab in your browser and refresh it.
<h3>Committing and pushing your changes</h3>
Git is available by default in your codespace and so you can rely on your existing Git workflow. 
You can work with Git in your codespace either via the Terminal or by using <a href="https://code.visualstudio.com/docs/editor/versioncontrol">Visual Studio Code</a>'s source control UI. 
For more information, see "<a href="https://docs.github.com/en/codespaces/developing-in-codespaces/using-source-control-in-your-codespace">Using source control in your codespace</a>"

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://docs.github.com/assets/cb-76209/images/help/codespaces/git-status.png" >
You can create a codespace from any branch, commit, or pull request in your project, or you can switch to a new or existing branch from within your active codespace. 
Because Codespaces is designed to be ephemeral, you can use it as an isolated environment to experiment, check a teammate's pull request, or fix merge conflicts. 

You can create more than one codespace per repository or even per branch. 
However, each user account has a limit of 10 codespaces. 
If you've reached the limit and want to create a new codespace, you must delete a codespace first.

<strong>Note:</strong> Commits from your codespace will be attributed to the name and public email configured at <a href="https://github.com/settings/profile">https://github.com/settings/profile</a>. 
A token scoped to the repository, included in the environment as <code>GITHUB_TOKEN</code>, and your GitHub credentials will be used to authenticate.
<h3>Personalizing your codespace with extensions</h3>
Using Visual Studio Code in your codespace gives you access to the Visual Studio Code Marketplace so that you can add any extensions you need. 
For information on how extensions run in Codespaces, see <a href="https://code.visualstudio.com/api/advanced-topics/remote-extensions">Supporting Remote Development and GitHub Codespaces</a> in the Visual Studio Code docs. 
If you already use Visual Studio Code, you can use <a href="https://code.visualstudio.com/docs/editor/settings-sync">Settings Sync</a> to automatically sync extensions, settings, themes, and keyboard shortcuts between your local instance and any Codespaces you create.

<h2>20 Git Commands</h2>
<div id="gitCommandtoc" class="toc"><a href="#gitCommandtopic-0" target="_self"><span class="orange">Git Commands</span></a> <a href="#gitCommandtopic-1" target="_self">git config</a> <a href="#gitCommandtopic-2" target="_self"> git init</a> <a href="#gitCommandtopic-3" target="_self">git clone</a> <a href="#gitCommandtopic-4" target="_self">git add</a> <a href="#gitCommandtopic-5" target="_self">git commit</a> <a href="#gitCommandtopic-6" target="_self">git diff</a> <a href="#gitCommandtopic-7" target="_self"><br><span class="orange">Git Commands With Examples</span></a> <a href="#gitCommandtopic-8" target="_self">git reset</a> <a href="#gitCommandtopic-9" target="_self">git status</a> <a href="#gitCommandtopic-10" target="_self">git rm</a> <a href="#gitCommandtopic-11" target="_self">git log</a> <a href="#gitCommandtopic-12" target="_self">git show</a> <a href="#gitCommandtopic-13" target="_self">git tag</a> <a href="#gitCommandtopic-14" target="_self">git branch</a> <a href="#gitCommandtopic-15" target="_self">git checkout</a> <a href="#gitCommandtopic-16" target="_self">git merge</a> <a href="#gitCommandtopic-17" target="_self">git remote</a> <a href="#gitCommandtopic-18" target="_self">git push</a> <a href="#gitCommandtopic-19" target="_self">git pull</a> <a href="#gitCommandtopic-20" target="_self">git stash</a> </div></center>
<h3 id="gitCommandtopic-0"><span class="orange">Git Commands</span></h3>
<h3 id="gitCommandtopic-1">git config</h3>
Usage: git config -global user.name "[name]"
Usage: git config -global user.email "[email address]"
This command sets the author name and email address respectively to be used with your commits.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/1-9.png">
<h3 id="gitCommandtopic-2"> git init</h3>
Usage: git init [repository name]
This command is used to start a new repository.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/2-6.png">
<h3 id="gitCommandtopic-3">git clone</h3>
Usage: git clone [url]
This command is used to obtain a repository from an existing URL.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/4-4.png">
<h3 id="gitCommandtopic-4">git add</h3>
Usage: git add [file]
This command adds a file to the staging area.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/5-4.png">
Usage: git add *
This command adds one or more to the staging area.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/6-3.png">
<h3 id="gitCommandtopic-5">git commit</h3>
Usage: git commit -m "[ Type in the commit message]"
This command records or snapshots the file permanently in the version history.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/7-3.png">
Usage: git commit -a
This command commits any files you’ve added with the git add command and also commits any files you’ve changed since then.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/8-2.png">
<h3 id="gitCommandtopic-6">git diff</h3>
Usage: git diff
This command shows the file differences which are not yet staged.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/9-2.png">
Usage: git diff -staged
This command shows the differences between the files in the staging area and the latest version present.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/10-2.png">
Usage: git diff [first branch] [second branch]
This command shows the differences between the two branches mentioned.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/43.png">
<h3 id="gitCommandtopic-7"><br><span class="orange">Git Commands With Examples</span></h3>
<h3 id="gitCommandtopic-8">git reset</h3>
Usage: git reset [file]
This command unstages the file, but it preserves the file contents.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/11-1.png">
Usage: git reset [commit]
This command undoes all the commits after the specified commit and preserves the changes locally.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/14-1.png">
Usage: git reset -hard [commit]
This command discards all history and goes back to the specified commit.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/13-1.png">
<h3 id="gitCommandtopic-9">git status</h3>
Usage: git status
This command lists all the files that have to be committed.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/15-1.png">
<h3 id="gitCommandtopic-10">git rm</h3>
Usage: git rm [file]
This command deletes the file from your working directory and stages the deletion.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/16-2.png">
<h3 id="gitCommandtopic-11">git log</h3>
Usage: git log
This command is used to list the version history for the current branch.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/18.png">
Usage: git log -follow[file]
This command lists version history for a file, including the renaming of files also.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/19.png">
<h3 id="gitCommandtopic-12">git show</h3>
Usage: git show [commit]
This command shows the metadata and content changes of the specified commit.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/20.png">
<h3 id="gitCommandtopic-13">git tag</h3>
Usage: git tag [commitID]
This command is used to give tags to the specified commit.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/22.png">
<h3 id="gitCommandtopic-14">git branch</h3>
Usage: git branch
This command lists all the local branches in the current repository.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/23.png">
Usage: git branch [branch name]
This command creates a new branch.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/24.png">
Usage: git branch -d [branch name]
This command deletes the feature branch.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/25.png">
<h3 id="gitCommandtopic-15">git checkout</h3>
Usage: git checkout [branch name]
This command is used to switch from one branch to another.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/27.png">
Usage: git checkout -b [branch name]
This command creates a new branch and also switches to it.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/28.png">
<h3 id="gitCommandtopic-16">git merge</h3>
Usage: git merge [branch name]
This command merges the specified branch’s history into the current branch.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/31-1.png">
<h3 id="gitCommandtopic-17">git remote</h3>
Usage: git remote add [variable name] [Remote Server Link]
This command is used to connect your local repository to the remote server.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/32.png">
<h3 id="gitCommandtopic-18">git push</h3>
Usage: git push [variable name] master
This command sends the committed changes of master branch to your remote repository.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/33.png">
Usage: git push [variable name] [branch]
This command sends the branch commits to your remote repository.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/34.png">
Usage: git push -all [variable name]
This command pushes all branches to your remote repository.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/36.png">
Usage: git push [variable name] :[branch name]
This command deletes a branch on your remote repository.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/37.png">
<h3 id="gitCommandtopic-19">git pull</h3>
Usage: git pull [Repository Link]
This command fetches and merges changes on the remote server to your working directory.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/38.png">
<h3 id="gitCommandtopic-20">git stash</h3>
Usage: git stash save
This command temporarily stores all the modified tracked files.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/39.png">
Usage: git stash pop
This command restores the most recently stashed files.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/40.png">
Usage: git stash list
This command lists all stashed changesets.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/44.png">
Usage: git stash drop
This command discards the most recently stashed changeset.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/42.png">

<h2>git - the simple guide</h2>
<div id="gitGuidetoc" class="toc"><a href="#gitGuidetopic-0" target="_self">create a new repository</a> <a href="#gitGuidetopic-1" target="_self">checkout a repository</a> <a href="#gitGuidetopic-2" target="_self">workflow</a> <a href="#gitGuidetopic-3" target="_self">add &amp; commit</a> <a href="#gitGuidetopic-4" target="_self">pushing changes</a> <a href="#gitGuidetopic-5" target="_self">branching</a> <a href="#gitGuidetopic-6" target="_self">update &amp; merge</a> <a href="#gitGuidetopic-7" target="_self">tagging</a> <a href="#gitGuidetopic-8" target="_self">log</a> <a href="#gitGuidetopic-9" target="_self">replace local changes</a> <a href="#gitGuidetopic-10" target="_self">useful hints</a> </div></center>
<h3 id="gitGuidetopic-0">create a new repository</h3>
create a new directory, open it and perform a 
<code>git init</code>
to create a new git repository.
<h3 id="gitGuidetopic-1">checkout a repository</h3>
create a working copy of a local repository by running the command
<code>git clone /path/to/repository</code>
when using a remote server, your command will be
<code>git clone username@host:/path/to/repository</code>
<h3 id="gitGuidetopic-2">workflow</h3>
your local repository consists of three "trees" maintained by git.
the first one is your <code>Working Directory</code> which holds the actual files.
the second one is the <code>Index</code> which acts as a staging area and
finally the <code>HEAD</code> which points to the last commit you've made.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://rogerdudler.github.io/git-guide/img/trees.png">
<h3 id="gitGuidetopic-3">add &amp; commit</h3>
You can propose changes (add it to the <b>Index</b>) using
<code>git add &lt;filename></code>
<code>git add *</code>
This is the first step in the basic git workflow. To actually commit these changes use
<code>git commit -m "Commit message"</code>
Now the file is committed to the <b>HEAD</b>, but not in your remote repository yet.
<h3 id="gitGuidetopic-4">pushing changes</h3>
Your changes are now in the <b>HEAD</b> of your local working copy. To send those changes to your remote repository, execute 
<code>git push origin master</code>
Change <i>master</i> to whatever branch you want to push your changes to.
If you have not cloned an existing repository and want to connect your repository to a remote server, you need to add it with
<code>git remote add origin &lt;server></code>
Now you are able to push your changes to the selected remote server
<h3 id="gitGuidetopic-5">branching</h3>
Branches are used to develop features isolated from each other. The <i>master</i> branch is the "default" branch when you create a repository. Use other branches for development and merge them back to the master branch upon completion.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://rogerdudler.github.io/git-guide/img/branches.png">
create a new branch named "feature_x" and switch to it using
<code>git checkout -b feature_x</code>
switch back to master
<code>git checkout master</code>
and delete the branch again
<code>git branch -d feature_x</code>
a branch is <i>not available to others</i> unless you push the branch to your remote repository
<code>git push origin &lt;branch></code>
<h3 id="gitGuidetopic-6">update &amp; merge</h3>
to update your local repository to the newest commit, execute 
<code>git pull</code>
in your working directory to <i>fetch</i> and <i>merge</i> remote changes.
to merge another branch into your active branch (e.g. master), use
<code>git merge &lt;branch></code>
in both cases git tries to auto-merge changes. Unfortunately, this is not always possible and results in <i>conflicts</i>.
You are responsible to merge those <i>conflicts</i>
manually by editing the files shown by git. After changing, you need to mark them as merged with
<code>git add &lt;filename></code>
before merging changes, you can also preview them by using
<code>git diff &lt;source_branch> &lt;target_branch></code>
<h3 id="gitGuidetopic-7">tagging</h3>
it's recommended to create tags for software releases. this is a known concept, which also exists in SVN. You can create a new tag named <i>1.0.0</i> by executing
<code>git tag 1.0.0 1b2e1d63ff</code>
the <i>1b2e1d63ff</i> stands for the first 10 characters of the commit id you want to reference with your tag. You can get the commit id by looking at the... 
<h3 id="gitGuidetopic-8">log</h3>
in its simplest form, you can study repository history using..
<code>git log</code>
You can add a lot of parameters to make the log look like what you want. To see only the commits of a certain author:
<code>git log --author=bob</code>
To see a very compressed log where each commit is one line:
<code>git log --pretty=oneline</code>
Or maybe you want to see an ASCII art tree of all the branches, decorated with the names of tags and branches: 
<code>git log --graph --oneline --decorate --all</code>
See only which files have changed: 
<code>git log --name-status</code>
These are just a few of the possible parameters you can use. For more, see
<code>git log --help</code>
<h3 id="gitGuidetopic-9">replace local changes</h3>
In case you did something wrong, which for sure never happens ;), you can replace local changes using the command
<code>git checkout -- &lt;filename></code>
this replaces the changes in your working tree with the last content in HEAD. Changes already added to the index, as well as new files, will be kept.
If you instead want to drop all your local changes and commits, fetch the latest history from the server and point your local master branch at it like this
<code>git fetch origin</code>
<code>git reset --hard origin/master</code>
<h3 id="gitGuidetopic-10">useful hints</h3>
built-in git GUI
<code>gitk</code>
use colorful git output
<code>git config color.ui true</code>
show log on just one line per commit
<code>git config format.pretty oneline</code>
use interactive adding
<code>git add -i</code>


<h2>Working on Git Bash</h2>
<div id="GitBashtoc" class="toc"><a href="#GitBashtopic-0" target="_self">Working on Git Bash</a><br><a href="#GitBashtopic-1" target="_self"> What is Git?</a><br><a href="#GitBashtopic-2" target="_self"> Installing Git Bash</a><br><a href="#GitBashtopic-3" target="_self"><span class="orange">Navigate in Git Bash</span></a><br><a href="#GitBashtopic-4" target="_self"> cd command</a><br><a href="#GitBashtopic-5" target="_self"> ls command</a><br><a href="#GitBashtopic-6" target="_self"> Set your global username/email configuration</a><br><a href="#GitBashtopic-7" target="_self"> Initializing a Local repository</a><br><a href="#GitBashtopic-8" target="_self"> Push files to your Git repository</a><br><a href="#GitBashtopic-9" target="_self"> Saving changes to local repository</a><br><a href="#GitBashtopic-10" target="_self"><span class="orange">Branching through Git Bash</span></a><br><a href="#GitBashtopic-11" target="_self"> Branching in Github</a><br><a href="#GitBashtopic-12" target="_self"> Navigating between Branches</a><br><a href="#GitBashtopic-13" target="_self"> Merge any two branches</a><br><a href="#GitBashtopic-14" target="_self"> Cloning Repository to system</a><br><a href="#GitBashtopic-15" target="_self"> Undoing commits</a><br><a href="#GitBashtopic-16" target="_self"> Conclusion</a><br><a href="#GitBashtopic-17" target="_self">What is Git Bash?</a><br><a href="#GitBashtopic-18" target="_self">Downloading and Installing Git (Bash)</a><br><a href="#GitBashtopic-19" target="_self">Running Git Commands in Different Terminals</a><br><a href="#GitBashtopic-20" target="_self">Running Linux Commands in Git Bash</a><br></div></center>
Git Bash is an application that provides Git command line experience on the Operating System. 
It is a command-line shell for enabling git with the command line in the system. 
A shell is a terminal application used to interface with an operating system through written commands. 
Git Bash is a package that installs Bash, some common bash utilities, and Git on a Windows operating system. 
In Git Bash the user interacts with the repository and git elements through the commands.
<h4 id="GitBashtopic-1"> What is Git?</h4>
<a href="https://www.geeksforgeeks.org/git-lets-get-into-it/" rel="noopener" target="_blank">Git</a> is version-control system for tracking changes in source code during software development.
It is designed for coordinating work among programmers, but it can be used to track changes in any set of files.
Its goal is to increase efficiency, speed and easily manage large projects through version controlling.
Every git working directory is a full-fledged repository with complete history and full version-tracking capabilities, independent of network access or a central server.
Git helps the team cope up with the confusion that tends to happen when multiple people are editing the same files.

<h4 id="GitBashtopic-2"> Installing Git Bash</h4>
Follow the steps given below to install Git Bash on Windows:
Step 1: The .exe file installer for Git Bash can be downloaded from <a href="https://gitforwindows.org/">https://gitforwindows.org/</a>
Once downloaded execute that installer, following window will occur:-

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200420211335/GitInstall.jpg" alt="" width="588" height="478" class="aligncenter size-full wp-image-1675377">

Step 2: Select the components that you need to install and click on the Next button.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200420212305/git-1.jpg" alt="" width="581" height="477" class="aligncenter size-full wp-image-1675417">



Step 3: Select how to use the Git from command-line and click on Next to begin the installation process.

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200420212300/git22.jpg" alt="" width="585" height="475" class="aligncenter size-full wp-image-1675413">

Step 4: Let the installation process finish to begin using Git Bash.

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200420212254/git3.jpg" alt="" width="581" height="479" class="aligncenter size-full wp-image-1675411">
To open Git Bash navigate to the folder where you have installed the git otherwise just simply search in your OS for git bash.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200421160427/Screenshot-2920.png" alt="" width="803" height="765" class="aligncenter size-full wp-image-1678357">
<h3 id="GitBashtopic-3"><span class="orange">Navigate in Git Bash</span></h3>
<h4 id="GitBashtopic-4"> cd command</h4>
cd command refers to change directory and is used to get into the desired directory.To navigate between the folders the cd command is used
Syntax:
cd folder_name

<h4 id="GitBashtopic-5"> ls command</h4>
ls command is used to list all the files and folders in the current directory.
Syntax:
ls

<h4 id="GitBashtopic-6"> Set your global username/email configuration</h4>
Open Git Bash and begin creating a username and email for working on Git Bash.Set your username:
git config --global user.name "FIRST_NAME LAST_NAME"
Set your email address:
git config --global user.email "MY_NAME@example.com"

<h4 id="GitBashtopic-7"> Initializing a Local repository</h4>
Follow the steps given below to initialize your Local Repository with Git:
Step 1: Make a repository on <a href="www.github.com">Github</a>

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200421144627/git-4.jpg" alt="" width="510" height="233" class="aligncenter size-full wp-image-1677989">

Step 2: Give a suitable name of your repository and create the repository
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200421145045/git5.jpg" alt="" width="932" height="838" class="aligncenter size-full wp-image-1678005">
Note: You can choose to initialize your git repository with a README file, and further, you can mention your project details in it. 
It helps people know what this repository is about. 
However, it’s absolutely not necessary. 
But if you do initialize your repo with a README file using interface provided by GitHub, then your local repository won’t have this README file. 
So to avoid running into a snag while trying to push your files (as in step 3 of next section), after step 5 (where you initialize your local folder as your git repository), do following to pull that file to your local folder:
git pull <repository_url>

Step 3: The following will appear after creating the repository
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200421145943/git6.jpg" alt="" width="1320" height="798" class="aligncenter size-full wp-image-1678043">

Step 4: Open Git Bash and change the current working directory to your local project by use of cd command.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200421151907/git-7.jpg" alt="" width="743" height="439" class="aligncenter size-full wp-image-1678146">

Step 5: Initialize the local directory as a Git repository.
 git init 

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200421152107/git-8.jpg" alt="" width="745" height="450" class="aligncenter size-full wp-image-1678156">

Step 6: Stage the files for the first commit by adding them to the local repository
git add .

Step 7: By “git status” you can see the staged files

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200421152939/git9.jpg" alt="" width="740" height="448" class="aligncenter size-full wp-image-1678200">

Step 8: Commit the files that you’ve staged in your local repository.
git commit -m "First commit"

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200421153825/git10.jpg" alt="" width="745" height="451" class="aligncenter size-full wp-image-1678232">
Now After “git status” command it can be seen that nothing to commit is left, Hence all files have been committed.
<h4 id="GitBashtopic-8"> Push files to your Git repository</h4>

Step 1: Go to Github repository and in code section copy the URL.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200421154837/git11.jpg" alt="" width="1253" height="594" class="aligncenter size-full wp-image-1678273">

Step 2: In the Command prompt, add the URL for your repository where your local repository will be pushed.
git remote add origin repository_URL

Step 3: Push the changes in your local repository to GitHub.
git push origin master
Here the files have been pushed to the master branch of your repository.

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200421155539/git12.png" alt="" width="742" height="449" class="aligncenter size-full wp-image-1678303">

Now in the GitHub repository, the pushed files can be seen.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200421155736/git13.png" alt="" width="1284" height="593" class="aligncenter size-full wp-image-1678317">

<h4 id="GitBashtopic-9"> Saving changes to local repository</h4>
Suppose the files are being changed and new files are added to local repository.
To save the changes in the git repository:

Step 1: Changes have to be staged for the commit.
git add .
or
git add file_name

Step 2: Now commit the staged files.
git commit -m "commit_name"

Step 3: Push the changes.
git push origin master

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200421165540/git-14.png" alt="" width="743" height="451" class="aligncenter size-full wp-image-1678619">
New changes can be seen

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200421170052/git-15.png" alt="" width="1323" height="598" class="aligncenter size-full wp-image-1678646">
<h3 id="GitBashtopic-10"><span class="orange">Branching through Git Bash</span></h3>
<h4 id="GitBashtopic-11"> Branching in Github</h4>
Suppose if a team is working on a project and a branch is created for every member working on the project.
Hence every member will work on their branches hence every time the best branch is merged to the master branch of the project.
The branches make it version controlling system and makes it very easy to maintain a project source code.Syntax:List all of the branches in your repository.
git branch

Create a new branch
git branch branch_name

Safe Delete the specified branch
git branch -d branch_name

Force delete the specified branch
git branch -D branch_name


<h4 id="GitBashtopic-12"> Navigating between Branches</h4>
To navigate between the branches git checkout is used.To create create a new branch and switch on it:
git checkout -b new_branch_name
To simply switch to a branch
git checkout branch_name
After checkout to branch you can see a * on the current branch

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200421182445/git-17.png" alt="" width="748" height="449" class="aligncenter size-full wp-image-1679040">
Now the same <code>commit add</code> and <code>commit actions</code> can be performed on this branch also.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200421183255/git-18.png" alt="" width="609" height="163" class="aligncenter size-full wp-image-1679074">

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200421183253/git19.png" alt="" width="648" height="266" class="aligncenter size-full wp-image-1679073">

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200421183249/git-20.png" alt="" width="1335" height="724" class="aligncenter size-full wp-image-1679071">

<h4 id="GitBashtopic-13"> Merge any two branches</h4>
To merge a branch in any branch:First reach to the target branch
git checkout branch_name

Merge the branch to target branch
git merge new_branch


<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200421233834/gi21.png" alt="" width="704" height="258" class="aligncenter size-full wp-image-1680678">

<h4 id="GitBashtopic-14"> Cloning Repository to system</h4>
Cloning is used to get a copy of the existing git repository.
When you run the git clone command it makes the zip folder saved in your default location
git clone url
This command saves the directory as the default directory name of the git repository
To save directory name as your custom name an additional argument is to be passed for your custom name of directory
git clone url custom_name

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200421234934/git22.png" alt="" width="715" height="202" class="aligncenter size-full wp-image-1680706">

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200421234938/git-23.png" alt="" width="1252" height="84" class="aligncenter size-full wp-image-1680707">

<h4 id="GitBashtopic-15"> Undoing commits</h4>
When there is a situation when you forget to add some files to commit and want to undo any commit, it can be commit again using <code>--ammend</code>Syntax:
git commit --amend

<h4 id="GitBashtopic-16"> Conclusion</h4>
To conclude it can be said that git bash is a command line platform which helps in enabling git and its elements in your system.
There are a bunch of commands which are used in git bash.
Git Bash is very easy to use and makes it easy to work on repositories and projects.

<h3 id="GitBashtopic-17">What is Git Bash?</h3>
Before you look at what Git Bash is, let's go over what <a href="https://en.wikipedia.org/wiki/Git" target="_blank" rel="noreferrer noopener nofollow">Git</a> is. 
Git is a version control system for controlling changes in software development. 
Like macOS and Linux, operating systems already have a command-line terminal where you can run Git and Linux commands directly. 
But for Windows, you have the Windows command prompt, which is a non-Unix terminal.
How can you run Git and Linux commands in Windows? Git Bash will do the trick. 
Git Bash is an <a href="https://en.wikipedia.org/wiki/Emulator" target="_blank" rel="noreferrer noopener nofollow">emulator</a> that provides an emulation layer for Git to run Linux commands on Windows PCs. 
An emulator enables one specific system to behave like another computer system.
<h3 id="GitBashtopic-18">Downloading and Installing Git (Bash)</h3>
Now that you know a little about Git Bash let's see how you can download and install it. 
There are three different ways of downloading the Git software for Windows OS, as shown below.
Through <a href="https://git-scm.com/download/win" target="_blank" rel="noreferrer noopener nofollow">Git's official website</a>
Through a separate project on GitHub called <a href="https://git-for-windows.github.io/" target="_blank" rel="noreferrer noopener nofollow">Git for Windows.</a>
Through a software package manager like <a href="https://chocolatey.org/" target="_blank" rel="noreferrer noopener nofollow">Chocolatey</a>

Download Git with any of the three ways you prefer, but this tutorial will use the official website.
After downloading Git, let's start installing it on your Windows PC.
1. Launch the installer you downloaded and click <strong>Next</strong> through the steps until you get to the <strong>Select Components</strong> screen.
2. Now, check the boxes of additional components you want to include in the installation. 
Leave the ones selected by default, as shown below, and click <strong>Next</strong>. 

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://adamtheautomator.com/wp-content/uploads/2021/08/Untitled-2021-08-31T160017.819.png">
 Selecting Additional Components To Install

3. Leave the default for creating a shortcut in the start menu folder, and click <strong>Next</strong>. 

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://adamtheautomator.com/wp-content/uploads/2021/08/Untitled-2021-08-31T160058.642.png">
 Selecting Start menu folder name

4. Select <strong>Use Notepad as Git's default editor</strong> from the drop-down list as a default editor to use with Git, and click <strong>Next</strong>. 
Now Git files like <em><a href="https://www.atlassian.com/git/tutorials/setting-up-a-repository/git-config" target="_blank" rel="noreferrer noopener nofollow">~./gitconfig</a></em> will open in Notepad by default. 

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://adamtheautomator.com/wp-content/uploads/2021/08/Untitled-2021-08-31T160129.657.png">
 Selecting Git's Default Editor

5. Select the <strong>Override the default branch name for new repositories</strong> option as the default branch name (<strong>main</strong>) for Git to use. 
When you initialize a Git repository, Git will use this branch name by default. 

The default branch name used to be “master” for Git repositories. 
But many people found “master” an offensive word. 
So GitHub followed the <a href="https://sfconservancy.org/news/2020/jun/23/gitbranchname/" target="_blank" rel="noreferrer noopener nofollow">Software Freedom Conservancy's</a> suggestion and provided an option to override the default branch name when initializing a Git repository. 

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://adamtheautomator.com/wp-content/uploads/2021/08/Untitled-2021-08-31T160213.065.png">
 Selecting Default Branch Name

6. Now, select <strong>Git from the command line and also from 3rd-party software</strong> option so that Git command can be executed from different tools. 
Some of those tools are Command Prompt, PowerShell or any other 3rd party software tools, along with the Git Bash console. 

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://adamtheautomator.com/wp-content/uploads/2021/08/Untitled-2021-08-31T160304.183.png">
 Selecting a Console Where Git Commands Can Run

7. Select the <strong>Use the <a href="https://en.wikipedia.org/wiki/OpenSSL" target="_blank" rel="noreferrer noopener nofollow">OpenSSL</a> library</strong> option to let Git validate certificates with OpenSSL, and click <strong>Next</strong>. 
OpenSSL is a cryptographic library that contains open-source implementation of SSL and TLS protocols. 

If you are using Git in an organization with enterprise-managed certificates, select the <strong>User the native Windows Secure Channel library</strong> option instead. 

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://adamtheautomator.com/wp-content/uploads/2021/08/Untitled-2021-08-31T160352.415.png">
 Selecting SSL/TLS library for HTTPS connections

8. Leave the default <strong>Checkout Windows-style, commit Unix-style line endings</strong> option selected, and click <strong>Next</strong>. 

If you configure “Windows-style” line ending conversions, when you hit return on your keyboard after executing a Git command, Git will insert an invisible character called <a href="https://docs.github.com/en/get-started/getting-started-with-git/configuring-git-to-handle-line-endings#about-line-endings" target="_blank" rel="noopener">line ending</a>. 
When different contributors make changes from different operating systems, Git might produce unexpected results. 

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://adamtheautomator.com/wp-content/uploads/2021/08/Untitled-2021-08-31T160446.764.png">
 Selecting line endings option

9. Select the <strong>Use Mintty (the default terminal of MSYS2)</strong> option as the default terminal emulator to run commands, and click <strong>Next</strong>. 
Mintty is the default terminal of <a href="https://www.msys2.org/wiki/MSYS2-introduction/" target="_blank" rel="noreferrer noopener nofollow">MSYS2</a>. 
MSYS2 is a collection of tools and libraries that provides a Unix-like environment for software distribution and a building platform for Windows. 

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://adamtheautomator.com/wp-content/uploads/2021/08/Untitled-2021-08-31T160521.451.png">
 Selecting a default terminal emulator

10. Select the <strong>Default (fast-forward or merge)</strong> option below as <code><a href="https://github.com/git-guides/git-pull" target="_blank" rel="noreferrer noopener nofollow">git pull</a></code> command's default behavior. 
The <code>git pull</code> command is the shorthand for <code><a href="https://git-scm.com/docs/git-fetch" target="_blank" rel="noreferrer noopener nofollow">git fetch</a></code> and <code><a href="https://git-scm.com/docs/git-merge" target="_blank" rel="noreferrer noopener nofollow">git merge</a></code>, which fetches and incorporates changes from a remote repository into the current branch. 

Perhaps you want to merge a new branch to the master. 
If so, Git would directly merge using fast-forward without going through <code>git fetch</code> and <code>git merge</code> commands. 
The merge is only possible if there are no commits on master from when you've created the new branch. 

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://adamtheautomator.com/wp-content/uploads/2021/08/Untitled-2021-08-31T160617.398.png">
 Selecting Default Behavior for <code>git pull</code> Command

11. Select the <strong>Git Credential Manager Core</strong> as the default <a href="https://git-scm.com/docs/gitcredentials" target="_blank" rel="noreferrer noopener nofollow">Git credential helper</a>, and click <strong>Next</strong>. 
Git credential helpers are external programs that Git can prompt for input data, like usernames and passwords. 
These input data can be stored in memory for a limited time or stored on the disk. 

Git Credential Manager Core is based on the .NET framework and will provide multi-factor HTTPS authentication with Git. 

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://adamtheautomator.com/wp-content/uploads/2021/08/Untitled-2021-08-31T160805.216.png">
 Selecting Default Credential Manager

12. Leave the extra features on default, as shown below, and click <strong>Next</strong>. 
The <strong>Enable file system caching</strong> option is checked to provide quick results when executing Git commands. 

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://adamtheautomator.com/wp-content/uploads/2021/08/Untitled-2021-08-31T161004.649.png">
 Enabling extra options

13. Ensure to leave both options below at default (<strong><a href="https://docs.microsoft.com/en-us/windows/console/pseudoconsoles" target="_blank" rel="noopener">pseudo console</a></strong> and <strong><a href="https://github.com/git-for-windows/git/discussions/3251" target="_blank" rel="noopener">built-in file system monitor</a></strong>) as they are still in an experimental stage, and click <strong>Install</strong>. 

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://adamtheautomator.com/wp-content/uploads/2021/08/Untitled-2021-08-31T161045.192.png">
 Experimental options support

14. Complete the installation and close the installation wizard by clicking on <strong>Finish</strong>. 

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://adamtheautomator.com/wp-content/uploads/2021/08/Untitled-2021-08-31T161121.891.png">
 Git setup wizard complete screen

15. Finally, right-click on your desktop and select <strong>Git Bash Here</strong> from the context menu, as shown below, to launch Git Bash terminal. 
Launching Git Bash from your desktop is one of the quickest ways to do so, but the same process goes when you right-click on a folder. 

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://adamtheautomator.com/wp-content/uploads/2021/08/version-1.png">
 Launching Git Bash from Desktop Context Menu

16. Run the <code>git</code> command below to verify Git Bash is installed and its current version (<code>--version</code>). 

<code>git --version</code></repository_url>
You can see below the current Git version in this tutorial is <strong>version 2.32.0.windows.2.</strong> 
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://adamtheautomator.com/wp-content/uploads/2021/08/version.png">
 Verifying Git Bash installation

<h3 id="GitBashtopic-19">Running Git Commands in Different Terminals</h3>
Now that you have Git Bash on your PC, it's time to learn some Git commands. 
Running Git commands isn't limited to Git Bash console only. 
Did you know you can run Git commands in the command prompt too? Yes!
Let's run Git commands both on Git Bash console and command prompt to declare variables accessible in both terminals.
1. Launch Git Bash console by clicking on the Start button, type <strong>git</strong>, and click on <strong>Git Bash</strong>. 

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://adamtheautomator.com/wp-content/uploads/2021/08/open-git.png">
Launching Git Bash from Start Button

2. Run the below <code><a href="https://git-scm.com/book/en/v2/Getting-Started-First-Time-Git-Setup" target="_blank" rel="noreferrer noopener nofollow">git config</a></code> command to add your name (<code>YourName</code>) as your <a href="https://docs.github.com/en/get-started/getting-started-with-git/setting-your-username-in-git" target="_blank" rel="noreferrer noopener nofollow">git username</a> (<code>user.name</code>). 
The <code>git config</code> command administers configuration variables that control how Git looks and operates. 

Pass the <code>--global</code> option to the <code>git config</code> command to define the configuration variable (<code>YourName</code>) in the <em>~/.gitconfig</em> file specifically. 

<code>git config --global user.name "YourName"</code>
3. Now open the command prompt and run the below <code>git config</code> command to add your email (<code>"<a href="/cdn-cgi/l/email-protection" data-cfemail="96c2f3e5e2d3fbf7fffad6fbf7fffab8f5f9fb">[email&nbsp;protected]</a>"</code>) as your <a href="https://docs.github.com/en/account-and-profile/setting-up-and-managing-your-github-user-account/managing-email-preferences/setting-your-commit-email-address" target="_blank" rel="noreferrer noopener nofollow">git user email</a> (<code>--global user.email</code>) in the <em>~/.gitconfig</em> file. 

<code>git config --global user.email "<a href="/cdn-cgi/l/email-protection" data-cfemail="a4f0c1d7d0e1c9c5cdc8e4c9c5cdc88ac7cbc9">[email&nbsp;protected]</a>"</code>
4. In the same command prompt window, run the below <code>git config</code> command to list (<code>--list</code>) all the configuration variables in Git. 

<code>git config --list</code>
You can see below that even though you've added variables in the <em>~/.gitconfig</em> file via different consoles, the variables are accessible and displayed in the command prompt. 

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://adamtheautomator.com/wp-content/uploads/2021/08/cmd-displayed.png">
Viewing Global Variables Added via Different Consoles

<h3 id="GitBashtopic-20">Running Linux Commands in Git Bash</h3>
As you can tell, all Git commands work in both Git Bash and the command prompt. 
And since Git is delivered as a Unix-style command-line environment, let's try running a Linux command on the Git Bash console!
Run the <code>ls</code> command both in Git Bash console and command prompt to list the files and folders in the working directory.
In the screenshots below, you can see that the Git Bash console returns an output, while the command prompt throws an error, saying the <strong>‘ls'</strong> command is not recognized.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://adamtheautomator.com/wp-content/uploads/2021/08/gitbash.png">
 Running Linux Command in Git Bash Returns a Result

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://adamtheautomator.com/wp-content/uploads/2021/08/cmd.png">
 Running Linux Command in Command Prompt Returns an Error

You can run Linux commands on the command prompt so long as you change the directory to <em>C:\Program Files\Git\usr\bin</em> first.
In the command prompt, run the commands below to change the working directory to <code>C:\Program Files\Git\usr\bin</code> and run the <code>ls</code> command.

<code>cd C:\Program Files\Git\usr\bin # Change directory to where Linux utilities are stored
ls # Linux command that lists all files and folders in the working directory</code>
Below, you can see that you didn't get an error after running the <code>ls</code> command this time, but the command returned results instead.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://adamtheautomator.com/wp-content/uploads/2021/08/Untitled-2021-08-31T161830.266.png">
 Running Linux Commands in Command Prompt

<h2>Git Viewing the Commit History</h2>
$ git log
to exit git log or git diff
Type q to exit this screen.
Type h to get help.

Actually, there are three ways to do it, precisely.
:q
:z or
Ctrl + z

Reverting a commit that has been pushed to the remote
git checkout [commit ID] filename

<h2>git push --set-upstream origin branch</h2>
If you do not have upstream for the current branch, Git changes its behavior on <code>git push</code>, and on other commands as well.

The complete push story here is long and boring.  
To shorten it a whole lot, <code>git push</code> was implemented poorly.
<h3>What is an upstream?</h3>
An <em>upstream</em> is simply another branch name, usually a remote-tracking branch, associated with a (regular, local) branch.

Every branch has the option of having one (1) upstream set.  
That is, every branch either has an upstream, or does not have an upstream.  
No branch can have more than one upstream.

The upstream <em>should</em>, but does not have to be, a valid branch (whether remote-tracking like <code>origin/<em>B</em></code> or local like <code>master</code>).  
That is, if the current branch <em>B</em> has upstream <em>U</em>, <code>git rev-parse <em>U</em></code> <em>should</em> work.  
If it does not work—if it complains that <em>U</em> does not exist—then most of Git acts as though the upstream is not set at all.  
A few commands, like <code>git branch -vv</code>, will show the upstream setting but mark it as "gone".

<h3>What good is an upstream?</h3>
If your <code>push.default</code> is set to <code>simple</code> or <code>upstream</code>, the upstream setting will make <code>git push</code>, used with no additional arguments, just work.

That's it—that's all it does for <code>git push</code>.  
But that's fairly significant, since <code>git push</code> is one of the places where a simple typo causes major headaches.

If your <code>push.default</code> is set to <code>nothing</code>, <code>matching</code>, or <code>current</code>, setting an upstream does nothing at all for <code>git push</code>.

(All of this assumes your Git version is at least 2.0.)

<h3>The upstream affects <code>git fetch</code></h3>

If you run <code>git fetch</code> with no additional arguments, Git figures out <em>which</em> remote to fetch from by consulting the current branch's upstream.  
If the upstream is a remote-tracking branch, Git fetches from that remote.  
(If the upstream is not set or is a local branch, Git tries fetching <code>origin</code>.)

<h3>The upstream affects <code>git merge</code> and <code>git rebase</code> too</h3>

If you run <code>git merge</code> or <code>git rebase</code> with no additional arguments, Git uses the current branch's upstream.  
So it shortens the use of these two commands.

<h3>The upstream affects <code>git pull</code></h3>

You should never
2. use <code>git pull</code> anyway, but if you do, <code>git pull</code> uses the upstream setting to figure out which remote to fetch from, and then which branch to merge or rebase with.  
That is, <code>git pull</code> does the same thing as <code>git fetch</code>—because it actually <em>runs</em> <code>git fetch</code>—and then does the same thing as <code>git merge</code> or <code>git rebase</code>, because it actually <em>runs</em> <code>git merge</code> or <code>git rebase</code>.

(You should usually just do these two steps manually, at least until you know Git well enough that when either step fails, which they will eventually, you recognize what went wrong and know what to do about it.)

<h3>The upstream affects <code>git status</code></h3>

This may actually be the most important.  
Once you have an upstream set, <code>git status</code> can report the difference between your current branch and its upstream, in terms of commits.

If, as is the normal case, you are on branch <em><code>B</code></em> with its upstream set to <code>origin/<em>B</em></code>, and you run <code>git status</code>, you will immediately see whether you have commits you can push, and/or commits you can merge or rebase onto.

This is because <code>git status</code> runs:

<code>git rev-list --count @{u}..HEAD</code>: how many commits do you have on <em><code>B</code></em> that are not on <code>origin/<em>B</em></code>?

<code>git rev-list --count HEAD..@{u}</code>: how many commits do you have on <code>origin/<em>B</em></code> that are not on <em><code>B</code></em>?

Setting an upstream gives you all of these things.

<h3>How come <code>master</code> already has an upstream set?</h3>

When you first clone from some remote, using:

<code>$ git clone git://some.host/path/to/repo.git</code>

or similar, the last step Git does is, essentially, <code>git checkout master</code>.  
This checks out your local branch <code>master</code>—only you don't <em>have</em> a local branch <code>master</code>.

On the other hand, you <em>do</em> have a remote-tracking branch named <code>origin/master</code>, because you just cloned it.

Git guesses that you must have meant: "make me a new local <code>master</code> that points to the same commit as remote-tracking <code>origin/master</code>, and, while you're at it, set the upstream for <code>master</code> to <code>origin/master</code>."

This happens for <em>every</em> branch you <code>git checkout</code> that you do not already have.  
Git creates the branch <em>and</em> makes it "track" (have as an upstream) the corresponding remote-tracking branch.

<h3>But this doesn't work for <em>new</em> branches, i.e., branches with no remote-tracking branch <em>yet</em>.</h3>

If you create a <em>new</em> branch:

<code>$ git checkout -b solaris</code>

there is, as yet, no <code>origin/solaris</code>.  
Your local <code>solaris</code> <em>cannot</em> track remote-tracking branch <code>origin/solaris</code> because it does not exist.

When you first push the new branch:

<code>$ git push origin solaris</code>

that <em>creates</em> <code>solaris</code> on <code>origin</code>, and hence also creates <code>origin/solaris</code> in your own Git repository.  
But it's too late: you already have a local <code>solaris</code> that <em>has no upstream</em>.

3.
<h3>Shouldn't Git just set that, now, as the upstream automatically?</h3>

Probably.  
See "implemented poorly" and footnote 1.  
It's hard to change <em>now</em>: There are millions

4. of scripts that use Git and some may well depend on its current behavior.  
Changing the behavior requires a new major release, nag-ware to force you to set some configuration field, and so on.  
In short, Git is a victim of its own success: whatever mistakes it has in it, today, can only be fixed if the change is either mostly invisible, clearly-much-better, or done slowly over time.

The fact is, it doesn't today, <em>unless</em> you use <code>--set-upstream</code> or <code>-u</code> during the <code>git push</code>.  
That's what the message is telling you.

You don't have to do it like that.  
Well, as we noted above, you don't have to do it at all, but let's say you <em>want</em> an upstream.  
You have already created branch <code>solaris</code> on <code>origin</code>, through an earlier push, and as your <code>git branch</code> output shows, you already <em>have</em> <code>origin/solaris</code> in your local repository.

You just don't have it set as the upstream for <code>solaris</code>.

To set it now, rather than during the first push, use <code>git branch --set-upstream-to</code>.  
The <code>--set-upstream-to</code> sub-command takes the name of any existing branch, such as <code>origin/solaris</code>, and sets the current branch's upstream to that other branch.

That's it—that's all it does—but it has all those implications noted above.  
It means you can just run <code>git fetch</code>, then look around, then run <code>git merge</code> or <code>git rebase</code> as appropriate, then make new commits and run <code>git push</code>, without a bunch of additional fussing-around.

1.To be fair, it was not clear back then that the initial implementation was error-prone.  
That only became clear when every new user made the same mistakes every time.  
It's now "less poor", which is not to say "great".

2."Never" is a bit strong, but I find that Git newbies understand things a lot better when I separate out the steps, especially when I can show them what <code>git fetch</code> actually did, and they can then see what <code>git merge</code> or <code>git rebase</code> will do next.

3.If you run your <em>first</em> <code>git push</code> as <code>git push -u origin solaris</code>—i.e., if you add the <code>-u</code> flag—Git will set <code>origin/solaris</code> as the upstream for your current branch if (and only if) the push succeeds.  
So you should supply <code>-u</code> on the <em>first</em> push.  
In fact, you can supply it on any later push, and it will set <em>or change</em> the upstream at that point.  
But I think <code>git branch --set-upstream-to</code> is easier, if you forgot.

4.Measured by the Austin Powers / Dr Evil method of simply saying "one MILLLL-YUN", anyway.

<h2>Push to github without typing user name / password</h2>
<h3><strong>1. Using SSH</strong></h3>If you need to do a push without username and password prompt, but you are always prompted, then your origin remote is pointing at the https url rather than the ssh url.
A way to skip typing my username/password when using https://github, is by changing the HTTPs origin remote which pointing to an HTTP url into an SSH url.

For example,
<k>https url: https://github.com/&lt;Username>/&lt;Project>.git
ssh url: git@github.com:&lt;Username>/&lt;Project>.git</k>
You can do:
<k>git remote set-url origin git@github.com:&lt;Username>/&lt;Project>.git</k>
to change the url.

<strong>Switching remote URLs from HTTPS to SSH</strong>
Open Terminal (for Mac and Linux users) or the command prompt (for Windows).
Change the current working directory to your local project.
List your existing remotes in order to get the name of the remote you want to change.
git remote -v
$ origin https://github.com/USERNAME/REPOSITORY.git (fetch)
$ origin https://github.com/USERNAME/REPOSITORY.git (push)
Change your remote’s URL from HTTPS to SSH with the git remote set-url command.
git remote set-url origin git@github.com:USERNAME/OTHERREPOSITORY.git
Verify that the remote URL has changed.

git remote -v
$ Verify new remote URL
$ origin git@github.com:USERNAME/OTHERREPOSITORY.git (fetch)
$ origin git@github.com:USERNAME/OTHERREPOSITORY.git (push)

<h3><strong>2. Using Static configuration</strong></h3>Static configuration of usernames for a given authentication context.
It is generally configured by adding this to your config:

[credential “https://example.com&quot;] username = me

The password was not declared because of security reasons. It is not advisable to store your password on an unsecure storage.

<h3>3. <strong>Credential helpers to cache or store passwords, or to interact with a system password wallet or keychain</strong>.</h3>These are external programs from which Git can request both usernames and passwords
To use a helper, you must first select one to use. Git currently includes the following helpers:
cache: Cache credentials in memory for a short period of time.
store: Store credentials indefinitely on disk.

Steps:
a.Find a helper.
$ git help -a | grep credential-credential-foo

b.Read its description.
$ git help credential-foo

c.Tell Git to use it.
$ git config — global credential.helper foo


<h2>Multiple Branches in Git</h2>
<div id="MultipleBranchestoc" class="toc"><a href="#MultipleBranchestopic-0" target="_self"><span class="orange">Introduction</span></a><br><a href="#MultipleBranchestopic-1" target="_self"><span class="orange">Worktree</span></a><br><a href="#MultipleBranchestopic-2" target="_self"><span class="orange">Example</span></a><br><a href="#MultipleBranchestopic-3" target="_self">Create a new repo</a><br><a href="#MultipleBranchestopic-4" target="_self">Create a new branch</a><br><a href="#MultipleBranchestopic-5" target="_self">Create new worktree branch</a><br><a href="#MultipleBranchestopic-6" target="_self">Make changes in new worktree branch</a><br><a href="#MultipleBranchestopic-7" target="_self">Merge my hotfix back into master</a><br><a href="#MultipleBranchestopic-8" target="_self">Removing the worktree</a><br><a href="#MultipleBranchestopic-9" target="_self">Continuing working on my feature branch</a><br></div>
<h3 id="MultipleBranchestopic-0"><span class="orange">Introduction</span></h3>
There are times where you might be working from a particular git branch and need to quickly jump over to a different branch to do some urgent work.

Typically you would need to first <code>git stash</code> anything you were working on (as it's unlikely to be in a state where it can be committed), and then you'd have to leave your current branch to create a new branch from <code>master</code> and thus begin working on your new urgent task.

This is a fairly straightforward workflow, but there is a mild annoyance which is that I happen to <code>git stash</code> <em>a lot</em> and I find when jumping over to a new branch to do some urgent work that I might end up <code>git stash</code>‘ing a few more times along the way.

Ultimately, when I'm done with my urgent task and ready to go back to my other branch, I then have to sift through my stash to find the relevant one I want to pop. 
OK so not that tragic considering <code>git stash list</code> will indicate the branch on which the stash was taken (which helps), but I do then need to Google what the syntax is for popping a specific stash (e.g. 
it's <code>git stash apply stash@{n}</code> where <code>n</code> is the index you want to apply.)

Note: for the life of me I wish I could remember the syntax but it just eludes me every time.

Oh, and then you have to think about whether you actually want to use <code>apply</code>, which leaves the stashed changes in the stack, or if you meant to actually <code>pop</code> the stashed content (<code>git stash pop stash@{n}</code>) so it's properly removed from the stack.

This is where I was recently introduced to a concept in git referred to as a ‘worktree' (thanks Kiran).

<h3 id="MultipleBranchestopic-1"><span class="orange">Worktree</span></h3>
Git offers a feature referred to as a <a href="https://git-scm.com/docs/git-worktree">worktree</a>, and what it does is allow you to have multiple branches running at the same time.

It does this by creating a new directory for you with a copy of your git repository that is synced between the two directories where they are stored.

This is different to manually creating a new directory and git cloning your repo down, because with the worktree model the two sub directories are aware of each other.

Note: as you'll see, although this workflow is pretty cool, you <em>could</em> argue that <code>git stash</code> is just plain simpler and easier for a human mind to reason about. 
I'll leave that up to the reader to decide.

<h3 id="MultipleBranchestopic-2"><span class="orange">Example</span></h3>
In the following example I'm going to create a new git repo. 
I'll make a change in <code>master</code>, then create a new branch for doing some work. 
We'll then imagine that I have been given an urgent task that I must complete <em>now</em> and yet my current non-master branch is in such a state that I want to avoid just stashing everything.

Note: I use tmux to split my terminal into multiple windows, and this demonstration will require two windows (or two separate terminal instances if you're not using a screen multiplexer) for the sake of demonstration.

<h3 id="MultipleBranchestopic-3">Create a new repo</h3>
<code>mkdir foo_project
cd foo_project
touch foo
git add foo
git commit -m "created foo file"</code>

<h3 id="MultipleBranchestopic-4">Create a new branch</h3>
<code>git checkout -b foo_contents
echo 123 > foo
git add -u
git commit -m "added content to foo"</code>

Now I'll create a new file and stage it for committing, but I won't commit it (this is where we pretend my branch is in some hideously complex state).

<h3 id="MultipleBranchestopic-5">Create new worktree branch</h3>
<code>git worktree add ../foo_hotfix</code>

Note: you'll want to create the new worktree in a directory outside of your current repo's directory (just so there's a clear distinction).

At this point you'll find your current terminal is still in the same <code>foo_contents</code>, but there is now a new directory called <code>foo_hotfix</code> outside your current repo's directory.

<h3 id="MultipleBranchestopic-6">Make changes in new worktree branch</h3>
Open up a new terminal (or split window) and run through the following steps:

<code>cd ./foo_hotfix</code> (or <code>cd ../foo_hotfix</code> if your new terminal is currently set to your main git repo directory)
<code>git log</code>

OK, so if you do a <code>git log</code> you'll find that the worktree has a branch automatically created and named after the worktree (so the branch is called <code>foo_hotfix</code> in my case).

The important thing to realize is that <code>git worktree add</code> is a bit like <code>git branch</code> in that it creates the new worktree from the current branch you're in. 
Meaning that my <code>foo_hotfix</code> branch has the "added content to foo" commit from the <code>foo_contents</code> branch as that's where I ran the <code>git worktree add</code> command from.

This is what <code>git log</code> looks like for me in this new worktree:

<code>* d374dcb (Integralist) - (HEAD -> foo_hotfix, foo_contents) added content to foo (2 minutes ago)
* 9ae3a7f (Integralist) - (master) created foo file (3 minutes ago)
</code>
 don't want the commit <code>d374dcb</code> in there as it's coming from a branch (<code>foo_contents</code>) that's still in progress, and so I'll need to rebase out that commit:

<code>git rebase -i 9ae3a7f</code>

Note: the rebase editor opens and I change <code>pick</code> to <code>drop</code> to get rid of the commit.

Now at this point I have a new working directory that I can work in:

<code>echo hotfix > baz
git add baz
git commit -m "some hotfix"</code>

<h3 id="MultipleBranchestopic-7">Merge my hotfix back into master</h3>
I'm going to change into my <code>master</code> branch, but remember I'm still in the <code>foo_hotfix</code> directory, so my main repo directory <code>foo_project</code> (open in another terminal window) is still in the <code>foo_contents</code> branch).

<code>git checkout master
git merge foo_hotfix</code>

<h3 id="MultipleBranchestopic-8">Removing the worktree</h3>
OK, so at this point we've merged our hotfix into <code>master</code>. 
I want to go back to my original repo directory and make sure I have the latest <code>master</code> rebased in before continuing on with my <code>foo_contents</code> work.

To remove the worktree you can either remove it using the git interface (e.g. 
<code>git worktree remove foo_hotfix</code>) or manually remove it (e.g. 
<code>cd ../ &amp;&amp; rm ./foo_hotfix</code>), where git will, at some point in the future, internally run a prune and remove any references to this orphaned branch/working tree (you could also manually trigger that prune using <code>git worktree prune</code>).

Note: if I do <code>git worktree remove foo_hotfix</code> while currently residing inside the <code>foo_hotfix</code> directory, I'll find that the <code>.git</code> repository is removed from the directory.

<h3 id="MultipleBranchestopic-9">Continuing working on my feature branch</h3>
Presuming I'm still in the <code>foo_hotfix</code> directory and that's where I ran <code>git worktree remove foo_hotfix</code>:

<code>cd ../foo_project
git rebase master</code> &lt; whoops! I need to stash my changes first †
<code>git stash pop</code>

† why yes, this does seem a bit strange considering that's what I was trying to avoid in the first place, but in this case it's a single ‘stash' and so a simple <code>git stash pop</code> will suffice to get me back to where I need to be.

I can now continue working on my <code>foo_contents</code> branch.


<h2>Adding multiple remotes</h2>
<div id="multiRemotestoc" class="toc"><a href="#multiRemotestopic-1" target="_self">Configure primary remote</a><br><a href="#multiRemotestopic-2" target="_self">Change remote URL</a><br><a href="#multiRemotestopic-3" target="_self">List all remotes</a><br><a href="#multiRemotestopic-4" target="_self">Remove a remote</a><br><a href="#multiRemotestopic-5" target="_self">Push to multiple remotes</a><br><a href="#multiRemotestopic-6" target="_self">Pull from multiple remotes</a><br><a href="#multiRemotestopic-7" target="_self">Conclusion</a><br></div>
When you do <code>git init</code>, you initialize a local Git repository. 
In general, the purpose is to synchronize this repo with a remote Git repo. 

To be able to synchronize code with a remote repo, you need to specify where the remote repo exists.
The first step is to add remote repos to your project.
<code># Syntax to add a git remote
git remote add REMOTE-ID REMOTE-URL</code>
By convention, the original / primary remote repo is called <code>origin</code>. 
Here’s a real example:

<code># Add remote 1: GitHub.
git remote add origin git@github.com:jigarius/toggl2redmine.git
# Add remote 2: BitBucket.
git remote add upstream git@bitbucket.org:jigarius/toggl2redmine.git</code>
In the above example, we add the remote repository of a project called <a href="https://github.com/jigarius/toggl2redmine">Toggl 2 Redmine</a> found on GitHub. 
Use the above command to add one or more remote Git repos – make sure that each repo has its unique ID, i.e. 
<code>origin</code>, <code>upstream</code> in the above example.
<h3 id="multiRemotestopic-1">Configure primary remote</h3>
Though you can add multiple remotes, usually, each branch of your project can be configured to track a single remote branch. 
You can setup a branch to track a remote branch as follows:
<code># Change local branch.
git checkout BRANCH

# Configure local branch to track a remote branch.
git branch -u origin/BRANCH</code>
Here, <code>BRANCH</code> is the name of the remote branch, which is usually the same as your local branch.

<h3 id="multiRemotestopic-2">Change remote URL</h3>
If you want to change the URL associated to a remote that you’ve already added, you can do it with the following command:
<code># The syntax is: git remote set-url REMOTE-ID REMOTE-URL

git remote set-url upstream git@foobar.com:jigarius/toggl2redmine.git</code>
<h3 id="multiRemotestopic-3">List all remotes</h3>
To see a list of all remotes, simply use the following command:

<code>$git remote -v
origin	    git@github.com:jigarius/toggl2redmine.git (fetch)
origin	    git@github.com:jigarius/toggl2redmine.git (push)
upstream    git@bitbucket.org:jigarius/toggl2redmine.git (fetch)
upstream    git@bitbucket.org:jigarius/toggl2redmine.git (push)</code>
<h3 id="multiRemotestopic-4">Remove a remote</h3>
If you’ve added a remote which you no longer require, you can remove it as follows:
<code># The syntax is: git remote remove REMOTE-ID
git remote remove upstream</code>

<h3 id="multiRemotestopic-5">Push to multiple remotes</h3>
Now that you have a primary remote repo and other remotes as well, it’s time to configure the push. 
The objective is to <em>push to multiple Git remotes</em> with a single <code>git push</code> command.

To do this, choose a remote ID which will refer to all the remotes. 
I usually call it <code>all</code>, but there are developers who prefer <code>origin</code>. 
The idea is to add all the remote repo URLs as  “push URLs” to this remote. 

Here’s what you do:
<code># Create a new remote called "all" with the URL of the primary repo.
git remote add all git@github.com:jigarius/toggl2redmine.git

# Re-register the remote as a push URL.
git remote set-url --add --push all git@github.com:jigarius/toggl2redmine.git
# Add a push URL to a remote. 

This means that "git push" will also push to this git URL.
git remote set-url --add --push all git@bitbucket.org:jigarius/toggl2redmine.git</code>
If you don’t want to create an extra remote named <code>all</code>, you can skip the first command and use the remote <code>origin</code> instead of <code>all</code> in the subsequent command(s).

Now, you can push to all remote repositories with a single command!
<code># Replace BRANCH with the name of the branch you want to push.
git push all BRANCH</code>

<h3 id="multiRemotestopic-6">Pull from multiple remotes</h3>
It is not possible to <code>git pull</code> from multiple repos. 
However, you can <code>git fetch</code> from multiple repos with the following command:

<code>git fetch --all</code>
This will <em>fetch</em> information from all remote repos. 
You can switch to the latest version of a branch on a particular remote with the command:

<code># Checkout the branch you want to work with.
git checkout BRANCH
# Reset the branch to match the state as on a specific remote.

git reset --hard REMOTE-ID/BRANCH</code>
<h3 id="multiRemotestopic-7">Conclusion</h3>
It is easy to synchronize code between multiple git repositories, especially, pushing to multiple remotes. 

This is helpful when you’re maintaining mirrors / copies of the same repository. 
All you need to do is set up multiple push URLs on a remote and then perform <code>git push</code> to that remote as you usually do.


<h2>branch operations</h2>
rename a branch while pointed to any branch, do:
git branch -m oldname newname

rename the current branch, you can do:
git branch -m newname

push the local branch and reset the upstream branch:
git push origin -u newname

Delete the remote branch:
git push origin --delete oldname

A way to remember this is -m is for "move" (or mv), which is how you rename files. 
Adding an alias could also help. 

To do so, run the following:
git config --global alias.rename 'branch -m'

If you are on Windows or another case-insensitive filesystem, and there are only capitalization changes in the name, you need to use -M, otherwise, git will throw branch already exists error:
git branch -M newname

Switch to the branch which needs to be renamed
git branch -m new_name
git push origin :old_name
git push origin new_name:refs/heads/new_name

delete a local branch in Git
git branch -d local-branch

To delete a remote branch, you need to use the "git push" command:
git push origin --delete remote-branch-name

(https://github.com/williamkpchan/williamkpchan.github.io.git

?? git@github.com:williamkpchan/williamkpchan.github.io.git
?? git remote add origin git@github.com:williamkpchanHP/williamkpchan.github.io.git
)

git remote add origin git@github.com:williamkpchanHP/newDoc.git
git add *.bat
git push --set-upstream origin master

git branch -d newDoc
git commit -m "update"

git remote -vgit remote add origin <url>git remote set-url origin <url>

git remote -v

git@github.com:williamkpchanHP/newDoc.git
git branch -M main
git remote add origin git@github.com:williamkpchanHP/newDoc.git
git push -u origin main

<h2>ssh-keygen</h2>
git bash
ssh-keygen -t rsa -C williamkpchanHP@gmail.com
eval "$(ssh-agent -s)"
ssh-add ~/.ssh/id_rsa

to preview HTML files on GitHub is to go to https://htmlpreview.github.io/ or just prepend it to the original URL, i.e.: 
https://htmlpreview.github.io/?https://github.com/williamkpchanHP/newDoc/blob/main/inkscapeTutorial.html

<h2>Permanently authenticating with Git repositories</h2>
https://stackoverflow.com/questions/6565357/git-push-requires-username-and-password

Run the following command to enable credential caching:

git config credential.helper store
git push https://github.com/owner/repo.git

e.g.
git push https://github.com/williamkpchanHP/newDoc.git

if using ssh:
use SSH URL instead of HTTPS one:
ssh://git@github.com/username/repo.git

git push git@github.com:williamkpchanHP/newDoc.git

git config --global credential.helper 'cache --timeout 7200'
After enabling credential caching, it will be cached for 7200 seconds (2 hour).

<h2>git error "No such remote 'origin'</h2>

You haven't set up the remote repository
You then ran
git remote add origin https://github.com/williamkpchanHP/newDoc.git

After that, your local repository should be able to communicate with the remote repository that resides at the specified URL (https://github.com/williamkpchanHP/newDoc.git)... provided that remote repo actually exists!

Before attempting to push to that remote repository, you need to make sure that the latter actually exists. So go to GitHub and create the remote repo in question. Then and only then will you be able to successfully push with

git push -u origin master

<h2>delete branches in Git</h2>
Deleting <b>local branches</b>
First, we print out all the branches (local as well as remote), using the git branch command with -a (all) flag.

To delete the local branch, just run the git branch command again, this time with the -d (delete) flag, followed by the name of the branch you want to delete (test branch in this case).
Note: Comments are the output produced as a result of running these git commands

git branch -a
# *master
#  test
#  remote/origin/master
#  remote/origin/test

git branch -d test
# Deleted branch test (was ########).

Note: You can also use the -D flag which is synonymous with --delete --force instead of -d. This will delete the branch regardless of its merge status.

<b>Deleting remote branches</b>
To delete a remote branch, you can’t use the git branch command. Instead, use the git push command with --delete flag, followed by the name of the branch you want to delete. You also need to specify the remote name (origin in this case) after git push.

git branch -a
# *master
#  test
#  remote/origin/master
#  remote/origin/test

git push origin --delete test
# To <URL of your repository>.git
#  - [deleted]         test

Delete this branch: remote/devs/JunitTest
git push devs --delete JunitTest

<h2>show my global Git configuration</h2>
git config --list
or look at your ~/.gitconfig file.
The local configuration will be in your repository's .git/config file.

Use:
git config --list --show-origin
to see where that setting is defined (global, user, repo, etc...)

The shortest,
git config -l
shows all inherited values from: system, global and local

edit my global Git configuration
Short answer:
git config --edit --global

1. System level (applied to every user on the system and all their repositories)
to view, git config --list --system (may need sudo)
to set, git config --system color.ui true
to edit system config file, git config --edit --system

2. Global level (values specific personally to you, the user).
to view, git config --list --global
to set, git config --global user.name xyz
to edit global config file, git config --edit --global

3. Repository level (specific to that single repository)
to view, git config --list --local
to set, git config --local core.ignorecase true (--local optional)
to edit repository config file, git config --edit --local (--local optional)

view all settings
Run git config --list, showing system, global, and (if inside a repository) local configs
Run git config --list --show-origin, also shows the origin file of each config item

read one particular configuration
Run git config user.name to get user.name, for example.
You may also specify options --system, --global, --local to read that value at a particular level.


<h2>save username and password in Git</h2>
Attention: This method saves the credentials in plaintext on your PC's disk. Everyone on your computer can access it, e.g. malicious NPM modules.

git CLI can store your user name/password in a secure, encrypted store called the Windows Credential Store.
This is what you told git to do when you entered
<k>git config --global credential.helper wincred</k>

You can use the git config to enable credentials storage in Git.
Run
<k>git config --global credential.helper store</k>

then
git pull

provide a username and password and those details will then be remembered later.
The credentials are stored in a file on the disk, with the disk permissions of "just user readable/writable" but still in plaintext.

When running this command,
git config --global credential.helper store

the first time you pull or push from the remote repository, you'll get asked about the username and password.

Afterwards, for consequent communications with the remote repository you don't have to provide the username and password.

The storage format is a .git-credentials file, stored in plaintext.

Also, you can use other helpers for the git config credential.helper, namely memory cache:
git config credential.helper 'cache --timeout=&lt;timeout>'

which takes an optional timeout parameter, determining for how long the credentials will be kept in memory.
Using the helper, the credentials will never touch the disk and will be erased after the specified timeout. The default value is 900 seconds (15 minutes).

If you want to change the password later
git pull
Will fail, because the password is incorrect, git then removes the offending user+password from the ~/.git-credentials file, so now re-run

git pull
to provide a new password so it works as earlier.

<h2>Git credential helper - update password</h2>
https://stackoverflow.com/questions/25845963/git-credential-helper-update-password

To update your credentials, go to Control Panel → Credential Manager → Generic Credentials.
Find the credentials related to your Git account and edit them to use the updated password.

Note that to use the Windows Credential Manager for Git you need to configure the credential helper like so:

git config --global credential.helper wincred

If you have multiple GitHub accounts that you use for different repositories, then you should configure credentials to use the full repository path (rather than just the domain, which is the default):
git config --global credential.useHttpPath true


<h2>git to revert to last version</h2>
git checkout master~1 pictList.js

<h2>Work With Multiple Github Accounts on a single Machine</h2>
https://gist.github.com/rahularity/86da20fe3858e6b311de068201d279e3
<a href="https://gist.github.com/starred" class="whitebut ">GitHub Gist</a>
<a href="https://gist.github.com/search?q=multiple+accounts" class="whitebut ">multiple accounts</a>

<div id="multiGittoc" class="toc"><a href="#multiGittopic-0" target="_self">Create SSH keys for all accounts</a><br><a href="#multiGittopic-1" target="_self"> Now generating SSH keys for my two accounts</a><br><a href="#multiGittopic-2" target="_self">Add SSH keys to SSH Agent</a><br><a href="#multiGittopic-3" target="_self">Add SSH public key to the Github</a><br><a href="#multiGittopic-4" target="_self">Create a Config File and Make Host Entries</a><br><a href="#multiGittopic-5" target="_self">Cloning GitHub repositories using different accounts</a><br><a href="#multiGittopic-6" target="_self">Finally</a><br></div></center><br><br>

Let suppose I have two github accounts, <b>https://github.com/rahul-office</b> and <b>https://github.com/rahul-personal</b>. 

Now i want to setup my mac to easily talk to both the github accounts.
NOTE: This logic can be extended to more than two accounts also. 
:)

The setup can be done in 5 easy steps:
Step 1: Create SSH keys for all accounts
Step 2: Add SSH keys to SSH Agent
Step 3: Add SSH public key to the Github
Step 4: Create a Config File and Make Host Entries
Step 5: Cloning GitHub repositories using different accounts

<h3 id="multiGittopic-0">Create SSH keys for all accounts</h3>
First make sure your current directory is your <b>.ssh</b> folder.

$ cd ~/.ssh
Syntax for generating unique ssh key for ann account is:
ssh-keygen -t rsa -C "your-email-address" -f "github-username"

here,
<b>-C</b> stands for comment to help identify your ssh key
<b>-f</b> stands for the file name where your ssh key get saved

<h4 id="multiGittopic-1"> Now generating SSH keys for my two accounts</h4>
ssh-keygen -t rsa -C "my_office_email@gmail.com" -f "github-rahul-office"
ssh-keygen -t rsa -C "my_personal_email@gmail.com" -f "github-rahul-personal"

Notice here <b>rahul-office</b> and <b>rahul-work</b> are the username of my github accounts corresponding to <b>my_office_email@gmail.com</b> and <b>my_personal_email@gmail.com</b> email ids respectively.
After entering the command the terminal will ask for passphrase, leave it empty and proceed.

<img class="lazy" data-src="https://github.com/rahularity/github-essentials/raw/master/screenshots/passphrase.png">

Now after adding keys , in your .ssh folder, a public key and a private will get generated.
The public key will have an extention <b>.pub</b> and private key will be there without any extention both having same name which you have passed after <b>-f</b> option in the above command. 
(in my case <b>github-rahul-office</b> and <b>github-rahu-personal</b>)

<img class="lazy" data-src="https://github.com/rahularity/github-essentials/raw/master/screenshots/ssh_keys_added.png">
<h3 id="multiGittopic-2">Add SSH keys to SSH Agent</h3>
Now we have the keys but it cannot be used until we add them to the SSH Agent.
ssh-add -K ~/.ssh/github-rahul-office
ssh-add -K ~/.ssh/github-rahul-personal

You can read more about adding keys to SSH Agent <a href="https://help.github.com/en/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent">here.</a>

<h3 id="multiGittopic-3">Add SSH public key to the Github</h3>
For the next step we need to add our public key (that we have generated in our previous step) and add it to corresponding github accounts.
For doing this we need to:
<b>1. Copy the public key</b>
<code> We can copy the public key either by opening the github-rahul-office.pub file in vim and then copying the content of it.
</code>

vim ~/.ssh/github-rahul-office.pub
vim ~/.ssh/github-rahul-personal.pub
OR

We can directly copy the content of the public key file in the clipboard.
pbcopy &lt; ~/.ssh/github-rahul-office.pub
pbcopy &lt; ~/.ssh/github-rahul-personal.pub

<b>2. Paste the public key on Github</b>
Sign in to Github Account
Goto <b>Settings</b> > <b>SSH and GPG keys</b> > <b>New SSH Key</b>
Paste your copied public key and give it a Title of your choice.

<em><b>OR</b></em>

Sign in to Github
Paste this link in your browser (<a href="https://github.com/settings/keys">https://github.com/settings/keys</a>) or click <a href="https://github.com/settings/keys">here</a>
Click on <b>New SSH Key</b> and paste your copied key.

<h3 id="multiGittopic-4">Create a Config File and Make Host Entries</h3>

The <b>~/.ssh/config</b> file allows us specify many config options for SSH.
If <b>config</b> file not already exists then create one (make sure you are in <b>~/.ssh</b> directory)
touch config

The commands below opens config in your default editor....Likely TextEdit, VS Code.
open config
Now we need to add these lines to the file, each block corresponding to each account we created earlier.

<code>     #rahul-office account
Host github.com-rahul-office
HostName github.com

User git
IdentityFile ~/.ssh/github-rahul-office
#rahul-personal account

Host github.com-rahul-personal
HostName github.com
User git

IdentityFile ~/.ssh/github-rahul-personal
</code>

<h3 id="multiGittopic-5">Cloning GitHub repositories using different accounts</h3>
So we are done with our setups and now its time to see it in action. 
We will clone a repository using one of the account we have added.

Make a new project folder where you want to clone your repository and go to that directory from your terminal.
For Example:
I am making a repository on my personal github account and naming it <b>TestRepo</b>

Now for cloning the repo use the below command:
<code>    git clone git@github.com-{your-username}:{owner-user-name}/{the-repo-name}.git
[e.g.] git clone git@github.com-rahul-personal:rahul-personal/TestRepo.git
</code>

<h3 id="multiGittopic-6">Finally</h3>
From now on, to ensure that our commits and pushes from each repository on the system uses the correct GitHub user — we will have to configure <b>user.email</b> and <b>user.name</b> in every repository freshly cloned or existing before.

To do this use the following commands.
<code>     git config user.email "my_office_email@gmail.com"
git config user.name "Rahul Pandey"

git config user.email "my-personal-email@gmail.com"
git config user.name "Rahul Pandey"
</code>

Pick the correct pair for your repository accordingly.
To push or pull to the correct account we need to add the remote origin to the project
<code>     git remote add origin git@github.com-rahul-personal:rahul-personal
git remote add origin git@github.com-rahul-office:rahul-office
</code>
Now you can use:

<code>     git push
git pull</code>

<h2>put multiple projects in a git repository</h2>
<h3>Solution 1</h3>
A single repository can contain multiple <em>independent</em> branches, called <i>orphan branches</i>. 
Orphan branches are completely separate from each other; they do not share histories.
<code>git checkout --orphan BRANCHNAME</code>
This creates a new branch, unrelated to your current branch. 
Each project should be in its own orphaned branch.
Now for whatever reason, git needs a bit of cleanup after an orphan checkout.
<code>rm .git/index
rm -r *</code>
<i>Make sure everything is committed before deleting</i>
Once the orphan branch is clean, you can use it normally.
<h3>Solution 2</h3>
Avoid all the hassle of orphan branches. 
Create two independent repositories, and push them to the same remote. 
Just use different branch names for each repo.
<code># repo 1
git push origin master:master-1
# repo 2
git push origin master:master-2</code>
<h3>Solution 3</h3>
This is for using a single directory for multiple projects. 
I use this technique for some closely related projects where I often need to pull changes from one project into another. 
It's similar to the orphaned branches idea but the branches don't need to be orphaned. 
Simply start all the projects from the same empty directory state.
<h4>Start all projects from one committed empty directory</h4>
Don't expect wonders from this solution. 
As I see it, you are always going to have annoyances with untracked files. 
Git doesn't really have a clue what to do with them and so if there are intermediate files generated by a compiler and ignored by your .gitignore file, it is likely that they will be left hanging some of the time if you try rapidly swapping between - for example - your software project and a PH.D thesis project.
However here is the plan. 
Start as you ought to start any git projects, by committing the empty repository, and then start all your projects from the same empty directory state. 
That way you are certain that the two lots of files are fairly independent. 
Also, give your branches a proper name and don't lazily just use "master". 
Your projects need to be separate so give them appropriate names.
Git commits (and hence tags and branches) basically store the state of a directory and its subdirectories and <i>Git has no idea whether these are parts of the same or different projects</i> so really there is no problem for git storing different projects in the same repository. 
The problem is then for you clearing up the untracked files from one project when using another, or separating the projects later.
<h3>Create an empty repository</h3>
<code>cd some_empty_directory
git init
touch .gitignore
git add .gitignore
git commit -m empty
git tag EMPTY</code>
Start your projects from empty.
<h4>Work on one project.</h4>
<code>git branch software EMPTY
git checkout software
echo "array board[8,8] of piece" > chess.prog
git add chess.prog 
git commit -m "chess program"</code>
<h4>Start another project</h4>
whenever you like.
<code>git branch thesis EMPTY
git checkout thesis
echo "the meaning of meaning" > philosophy_doctorate.txt
git add philosophy_doctorate.txt 
git commit -m "Ph.D"</code>
<h4>Switch back and forth</h4>
Go back and forwards between projects whenever you like.
This example goes back to the chess software project.
<code>git checkout software
echo "while not end_of_game do make_move()" >> chess.prog
git add chess.prog 
git commit -m "improved chess program"</code>
<h3>Untracked files are annoying</h3>
You will however be annoyed by untracked files when swapping between projects/branches.
<code>touch untracked_software_file.prog
git checkout thesis 
ls
    philosophy_doctorate.txt  untracked_software_file.prog</code>
<h4>It's not an insurmountable problem</h4>
Sort of by definition, git doesn't really know what to do with untracked files and it's up to you to deal with them. 
You can stop untracked files from being carried around from one branch to another as follows.
<code>git checkout EMPTY 
ls
    untracked_software_file.prog
rm -r *
    (directory is now really empty, apart from the repository stuff!)
git checkout thesis
ls
    philosophy_doctorate.txt</code>
By ensuring that the directory was empty before checking out our new project we made sure there were no hanging untracked files from another project.
<h4>A refinement</h4>
<code>$ GIT_AUTHOR_DATE='2001-01-01:T01:01:01' GIT_COMMITTER_DATE='2001-01-01T01:01:01' git commit -m empty</code>
If the same dates are specified whenever committing an empty repository, then independently created empty repository commits can have the same SHA1 code. 
<i>This allows two repositories to be created independently and then merged together into a single tree with a common root in one repository later.</i>
<h4>Example</h4>
<code># Create thesis repository. 
# Merge existing chess repository branch into it
mkdir single_repo_for_thesis_and_chess
cd single_repo_for_thesis_and_chess
git init
touch .gitignore
git add .gitignore
GIT_AUTHOR_DATE='2001-01-01:T01:01:01' GIT_COMMITTER_DATE='2001-01-01:T01:01:01' git commit -m empty
git tag EMPTY
echo "the meaning of meaning" > thesis.txt
git add thesis.txt
git commit -m "Wrote my PH.D"
git branch -m master thesis
# It's as simple as this ...
git remote add chess ../chessrepository/.git
git fetch chess chess:chess</code>
<h4>Result</h4>
<a href="https://i.stack.imgur.com/i94dQ.png" rel="noreferrer"><img class="lazy" data-src="https://i.stack.imgur.com/i94dQ.png" alt="Diagram of merged repositories"></a>
<h3>Use subdirectories per project?</h3>
It may also help if you keep your projects in subdirectories where possible, e.g. 
instead of having files
<code>chess.prog
philosophy_doctorate.txt </code>
have 
<code>chess/chess.prog
thesis/philosophy_doctorate.txt </code>
In this case your untracked software file will be <code>chess/untracked_software_file.prog</code>. 
When working in the <code>thesis</code> directory you should not be disturbed by untracked chess program files, and you may find occasions when you can work happily without deleting untracked files from other projects.
Also, if you want to remove untracked files from other projects, it will be quicker (and less prone to error) to dump an unwanted directory than to remove unwanted files by selecting each of them.
<h3>Branch names can include '/' characters</h3>
So you might want to name your branches something like
<code>project1/master
project1/featureABC
project2/master
project2/featureXYZ</code>

<h2>Creating a personal access token</h2>
<div id="pcttoc" class="toc"><a href="#pcttopic-0" target="_self">About personal access tokens</a><br><a href="#pcttopic-1" target="_self"> Types of personal access tokens</a><br><a href="#pcttopic-2" target="_self"> Keeping your personal access tokens secure</a><br><a href="#pcttopic-3" target="_self">Creating a fine-grained personal access token</a><br><a href="#pcttopic-4" target="_self">Creating a personal access token (classic)</a><br><a href="#pcttopic-5" target="_self">Using a personal access token on the command line</a><br></div></center><br><br>

Use a personal access token in place of a password when authenticating to GitHub in the command line or with the API.

<k>Warning</k>: Treat your access tokens like passwords.
For more information, see "<a href="#keeping-your-personal-access-tokens-secure">Keeping your personal access tokens secure</a>."

<h3 id="pcttopic-0">About personal access tokens</h3>
Personal access tokens are an alternative to using passwords for authentication to GitHub when using the <a href="https://docs.github.com/en/rest/overview/other-authentication-methods#via-oauth-and-personal-access-tokens">GitHub API</a> or the <a href="#using-a-token-on-the-command-line">command line</a>.

Personal access tokens are intended to access GitHub resources on behalf of yourself.
To access resources on behalf of an organization, or for long-lived integrations, you should use a GitHub App.
For more information, see "<a href="https://docs.github.com/en/apps/creating-github-apps/creating-github-apps/about-apps">About apps</a>."

<h3 id="pcttopic-1"> Types of personal access tokens</h3>
GitHub currently supports two types of personal access tokens: fine-grained personal access tokens and personal access tokens (classic).
GitHub recommends that you use fine-grained personal access tokens instead of personal access tokens (classic) whenever possible.

Organization owners can set a policy to restrict the access of personal access tokens (classic) to their organization.
For more information, see "<a href="https://docs.github.com/en/organizations/managing-programmatic-access-to-your-organization/setting-a-personal-access-token-policy-for-your-organization#restricting-access-by-personal-access-tokens-classic">Setting a personal access token policy for your organization</a>."

<h4>Fine-grained personal access tokens</h4>
Fine-grained personal access tokens have several security advantages over personal access tokens (classic):

Each token can only access resources owned by a single user or organization.
Each token can only access specific repositories.
Each token is granted specific permissions, which offer more control than the scopes granted to personal access tokens (classic).
Each token must have an expiration date.
Organization owners can require approval for any fine-grained personal access tokens that can access resources in the organization.

<h4>Personal access tokens (classic)</h4>
Personal access tokens (classic) are less secure.
However, some features currently will only work with personal access tokens (classic):

Only personal access tokens (classic) have write access for public repositories that are not owned by you or an organization that you are not a member of.
Outside collaborators can only use personal access tokens (classic) to access organization repositories that they are a collaborator on.
Only personal access tokens (classic) can access the GraphQL API.
Some REST API operations are not available to fine-grained personal access tokens.
For a list of REST API operations that are supported for fine-grained personal access tokens, see "<a href="https://docs.github.com/en/rest/overview/endpoints-available-for-fine-grained-personal-access-tokens">Endpoints available for fine-grained personal access tokens</a>".

If you choose to use a personal access token (classic), keep in mind that it will grant access to all repositories within the organizations that you have access to, as well as all personal repositories in your personal account.

As a security precaution, GitHub automatically removes personal access tokens that haven't been used in a year.
To provide additional security, we highly recommend adding an expiration to your personal access tokens.

<h3 id="pcttopic-2"> Keeping your personal access tokens secure</h3>
Personal access tokens are like passwords, and they share the same inherent security risks.
Before creating a new personal access token, consider if there is a more secure method of authentication available to you:

To access GitHub from the command line, you can use <a href="https://docs.github.com/en/github-cli/github-cli/about-github-cli">GitHub CLI</a> or <a href="https://github.com/GitCredentialManager/git-credential-manager/blob/main/README.md">Git Credential Manager</a> instead of creating a personal access token.
When using a personal access token in a GitHub Actions workflow, consider whether you can use the built-in <code>GITHUB_TOKEN</code> instead.
For more information, see "<a href="https://docs.github.com/en/actions/security-guides/automatic-token-authentication">Automatic token authentication</a>."

If these options are not possible, and you must create a personal access token, consider using another service such as the <a href="https://developer.1password.com/docs/cli/secret-references/">1Password CLI</a> to store your token securely, or 1Password's <a href="https://developer.1password.com/docs/cli/shell-plugins/github/">GitHub shell plugin</a> to securely authenticate to GitHub CLI.

When using a personal access token in a script, you can store your token as a secret and run your script through GitHub Actions.
For more information, see "<a href="https://docs.github.com/en/actions/security-guides/encrypted-secrets">Encrypted secrets</a>." You can also store your token as a Codespaces secret and run your script in Codespaces.
For more information, see "<a href="https://docs.github.com/en/codespaces/managing-your-codespaces/managing-encrypted-secrets-for-your-codespaces">Managing encrypted secrets for your codespaces</a>."

<h3 id="pcttopic-3">Creating a fine-grained personal access token</h3>

<k>Note</k>: Fine-grained personal access token are currently in beta and subject to change.
To leave feedback, see <a href="https://github.com/community/community/discussions/36441">the feedback discussion</a>.

<a href="https://docs.github.com/en/get-started/signing-up-for-github/verifying-your-email-address">Verify your email address</a>, if it hasn't been verified yet.

In the upper-right corner of any page, click your profile photo, then click <k>Settings</k>.

<img class="lazy" data-src="https://docs.github.com/assets/cb-34573/images/help/settings/userbar-account-settings.png">

In the left sidebar, click <k> Developer settings</k>.

In the left sidebar, under <k> Personal access tokens</k>, click <k>Fine-grained tokens</k>.

Click <k>Generate new token</k>.

Under <k>Token name</k>, enter a name for the token.

Under <k>Expiration</k>, select an expiration for the token.

Optionally, under <k>Description</k>, add a note to describe the purpose of the token.

Under <k>Resource owner</k>, select a resource owner.
The token will only be able to access resources owned by the selected resource owner.
Organizations that you are a member of will not appear unless the organization opted in to fine-grained personal access tokens.
For more information, see "<a href="https://docs.github.com/en/organizations/managing-programmatic-access-to-your-organization/setting-a-personal-access-token-policy-for-your-organization">Setting a personal access token policy for your organization</a>."

Optionally, if the resource owner is an organization that requires approval for fine-grained personal access tokens, below the resource owner, in the box, enter a justification for the request.

Under <k>Repository access</k>, select which repositories you want the token to access.
You should choose the minimal repository access that meets your needs.
Tokens always include read-only access to all public repositories on GitHub.

If you selected <k>Only select repositories</k> in the previous step, under the <k>Selected repositories</k> dropdown, select the repositories that you want the token to access.

Under <k>Permissions</k>, select which permissions to grant the token.
Depending on which resource owner and which repository access you specified, there are repository, organization, and account permissions.
You should choose the minimal permissions necessary for your needs.
For more information about what permissions are required for each REST API operation, see "<a href="https://docs.github.com/en/rest/overview/permissions-required-for-fine-grained-personal-access-tokens">Permissions required for fine-grained personal access tokens</a>."

Click <k>Generate token</k>.

If you selected an organization as the resource owner and the organization requires approval for fine-grained personal access tokens, then your token will be marked as <code>pending</code> until it is reviewed by an organization administrator.
Your token will only be able to read public resources until it is approved.
If you are an owner of the organization, your request is automatically approved.
For more information, see "<a href="https://docs.github.com/en/organizations/managing-programmatic-access-to-your-organization/reviewing-and-revoking-personal-access-tokens-in-your-organization">Reviewing and revoking personal access tokens in your organization</a>".

<h3 id="pcttopic-4">Creating a personal access token (classic)</h3>

<k>Note</k>: Organization owners can restrict the access of personal access token (classic) to their organization.
If you try to use a personal access token (classic) to access resources in an organization that has disabled personal access token (classic) access, your request will fail with a 403 response.
Instead, you must use a GitHub App, OAuth App, or fine-grained personal access token.

<k>Note</k>: Your personal access token (classic) can access every repository that you can access.
GitHub recommends that you use fine-grained personal access tokens instead, which you can restrict to specific repositories.
Fine-grained personal access tokens also enable you to specify fine-grained permissions instead of broad scopes.

<a href="https://docs.github.com/en/get-started/signing-up-for-github/verifying-your-email-address">Verify your email address</a>, if it hasn't been verified yet.

In the upper-right corner of any page, click your profile photo, then click <k>Settings</k>.

<img class="lazy" data-src="https://docs.github.com/assets/cb-34573/images/help/settings/userbar-account-settings.png">

In the left sidebar, click <k> Developer settings</k>.

In the left sidebar, under <k> Personal access tokens</k>, click <k>Tokens (classic)</k>.

Select <k>Generate new token</k>, then click <k>Generate new token (classic)</k>.

Give your token a descriptive name.
<img class="lazy" data-src="https://docs.github.com/assets/cb-3880/images/help/settings/token_description.png">

To give your token an expiration, select the <k>Expiration</k> drop-down menu, then click a default or use the calendar picker.
<img class="lazy" data-src="https://docs.github.com/assets/cb-39847/images/help/settings/token_expiration.png">

Select the scopes you'd like to grant this token.
To use your token to access repositories from the command line, select <k>repo</k>.
A token with no assigned scopes can only access public information.
For more information, see "<a href="https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/scopes-for-oauth-apps#available-scopes">Scopes for OAuth Apps</a>".

<img class="lazy" data-src="https://docs.github.com/assets/cb-43299/images/help/settings/token_scopes.gif">

Click <k>Generate token</k>.
<img class="lazy" data-src="https://docs.github.com/assets/cb-10912/images/help/settings/generate_token.png">

<img class="lazy" data-src="https://docs.github.com/assets/cb-33474/images/help/settings/personal_access_tokens.png">

To use your token to access resources owned by an organization that uses SAML single sign-on, authorize the token.
For more information, see "<a href="https://docs.github.com/en/enterprise-cloud@latest/authentication/authenticating-with-saml-single-sign-on/authorizing-a-personal-access-token-for-use-with-saml-single-sign-on">Authorizing a personal access token for use with SAML single sign-on</a>" in the GitHub Enterprise Cloud documentation.

<h3 id="pcttopic-5">Using a personal access token on the command line</h3>
Once you have a token, you can enter it instead of your password when performing Git operations over HTTPS.

For example, on the command line you would enter the following:

<code>$ git clone https://github.com/USERNAME/REPO.git
Username: YOUR_USERNAME
Password: <k>YOUR_TOKEN</k></code>

Personal access tokens can only be used for HTTPS Git operations.
If your repository uses an SSH remote URL, you will need to <a href="https://docs.github.com/en/get-started/getting-started-with-git/managing-remote-repositories#switching-remote-urls-from-ssh-to-https">switch the remote from SSH to HTTPS</a>.

If you are not prompted for your username and password, your credentials may be cached on your computer.
You can <a href="https://docs.github.com/en/get-started/getting-started-with-git/updating-credentials-from-the-macos-keychain">update your credentials in the Keychain</a> to replace your old password with the token.

Instead of manually entering your personal access token for every HTTPS Git operation, you can cache your personal access token with a Git client.
Git will temporarily store your credentials in memory until an expiry interval has passed.
You can also store the token in a plain text file that Git can read before every request.
For more information, see "<a href="https://docs.github.com/en/get-started/getting-started-with-git/caching-your-github-credentials-in-git">Caching your GitHub credentials in Git</a>."

<h2>Caching your GitHub credentials in Git</h2>
<div id="Cachingtoc" class="toc"><a href="#Cachingtopic-0" target="_self">GitHub CLI</a><br><a href="#Cachingtopic-1" target="_self">Git Credential Manager</a><br></div></center><br><br>

If you're <a href="https://docs.github.com/en/github/getting-started-with-github/about-remote-repositories">cloning GitHub repositories using HTTPS</a>, we recommend you use GitHub CLI or Git Credential Manager (GCM) to remember your credentials.

<k>Tip:</k> If you clone GitHub repositories using SSH, then you  can authenticate using an SSH key instead of using other credentials.
For information about setting up an SSH connection, see "<a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh">Connecting to GitHub with SSH</a>."

<h3 id="Cachingtopic-0">GitHub CLI</h3>
GitHub CLI will automatically store your Git credentials for you when you choose <code>HTTPS</code> as your preferred protocol for Git operations and answer "yes" to the prompt asking if you would like to authenticate to Git with your GitHub credentials.

<a href="https://github.com/cli/cli#installation">Install</a> GitHub CLI on macOS, Windows, or Linux.
In the command line, enter <code>gh auth login</code>, then follow the prompts.

When prompted for your preferred protocol for Git operations, select <code>HTTPS</code>.
When asked if you would like to authenticate to Git with your GitHub credentials, enter <code>Y</code>.

For more information about authenticating with GitHub CLI, see <a href="https://cli.github.com/manual/gh_auth_login"><code>gh auth login</code></a>.
<h3 id="Cachingtopic-1">Git Credential Manager</h3>
<a href="https://github.com/GitCredentialManager/git-credential-manager">Git Credential Manager</a> (GCM) is another way to store your credentials securely and connect to GitHub over HTTPS.
With GCM, you don't have to manually <a href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token">create and store a personal access token</a>, as GCM manages authentication on your behalf, including 2FA (two-factor authentication).

Install Git using <a href="https://brew.sh/">Homebrew</a>:
<code>$ brew install git</code>

Install GCM using Homebrew:
<code>$ brew tap microsoft/git
$ brew install --cask git-credential-manager-core</code>
For MacOS, you don't need to run <code>git config</code> because GCM automatically configures Git for you.

The next time you clone an HTTPS URL that requires authentication, Git will prompt you to log in using a browser window.
You may first be asked to authorize an OAuth app.
If your account or organization requires <a href="https://docs.github.com/en/authentication/securing-your-account-with-two-factor-authentication-2fa">two-factor auth</a>, you'll also need to complete the 2FA challenge.
Once you've authenticated successfully, your credentials are stored in the macOS keychain and will be used every time you clone an HTTPS URL.
Git will not require you to type your credentials in the command line again unless you change your credentials.

Install Git for Windows, which includes GCM.
For more information, see "<a href="https://github.com/git-for-windows/git/releases/latest">Git for Windows releases</a>" from its <a href="https://github.com/git-for-windows/git/releases/latest">releases page</a>.

We recommend always installing the latest version.
At a minimum, install version 2.29 or higher, which is the first version offering OAuth support for GitHub.
The next time you clone an HTTPS URL that requires authentication, Git will prompt you to log in using a browser window.
You may first be asked to authorize an OAuth app.
If your account or organization requires <a href="https://docs.github.com/en/authentication/securing-your-account-with-two-factor-authentication-2fa">two-factor auth</a>, you'll also need to complete the 2FA challenge.
Once you've authenticated successfully, your credentials are stored in the Windows credential manager and will be used every time you clone an HTTPS URL.
Git will not require you to type your credentials in the command line again unless you change your credentials.

<k>Warning:</k> Older versions of Git for Windows came with Git Credential Manager for Windows.
This older product is no longer supported and cannot connect to GitHub via OAuth.
We recommend you upgrade to <a href="https://github.com/git-for-windows/git/releases/latest">the latest version of Git for Windows</a>.

<k>Warning:</k> If you cached incorrect or outdated credentials in Credential Manager for Windows, Git will fail to access GitHub.
To reset your cached credentials so that Git prompts you to enter your credentials, access the Credential Manager in the Windows Control Panel under User Accounts > Credential Manager.
Look for the GitHub entry and delete it.

For Linux, install Git and GCM, then configure Git to use GCM.

Install Git from your distro's packaging system.
Instructions will vary depending on the flavor of Linux you run.

Install GCM.
See the <a href="https://github.com/GitCredentialManager/git-credential-manager#linux-install-instructions">instructions in the GCM repo</a>, as they'll vary depending on the flavor of Linux you run.

Configure Git to use GCM.
There are several backing stores that you may choose from, so see the GCM docs to complete your setup.
For more information, see "<a href="https://aka.ms/gcmcore-linuxcredstores">GCM Linux</a>."

The next time you clone an HTTPS URL that requires authentication, Git will prompt you to log in using a browser window.
You may first be asked to authorize an OAuth app.
If your account or organization requires <a href="https://docs.github.com/en/authentication/securing-your-account-with-two-factor-authentication-2fa">two-factor auth</a>, you'll also need to complete the 2FA challenge.
Once you've authenticated successfully, your credentials are stored on your system and will be used every time you clone an HTTPS URL.
Git will not require you to type your credentials in the command line again unless you change your credentials.
For more options for storing your credentials on Linux, see <a href="https://git-scm.com/bookhttps://docs.github.com/en/v2/Git-Tools-Credential-Storage">Credential Storage</a> in Pro Git.

<h2>Using Git with RStudio</h2>
<div id="gitrstudiotoc" class="toc"><a href="#gitrstudiotopic-1" target="_self"><span class="orange">Intro to practical version control for scientists</span></a><br><a href="#gitrstudiotopic-2" target="_self"><span class="orange">Installation and configuration of git</span></a><br><a href="#gitrstudiotopic-3" target="_self"> Install git</a><br><a href="#gitrstudiotopic-4" target="_self"> Install git using </a><a href="http://brew.sh">Homebrew</a><br><a href="#gitrstudiotopic-5" target="_self"> Configure git</a><br><a href="#gitrstudiotopic-6" target="_self"> Configure RStudio to use git</a><br><a href="#gitrstudiotopic-7" target="_self"><span class="orange">Learn to use git with RStudio</span></a><br><a href="#gitrstudiotopic-8" target="_self"> Create a new project</a><br><a href="#gitrstudiotopic-9" target="_self"> Open an existing project</a><br><a href="#gitrstudiotopic-10" target="_self"> Create and commit a file</a><br><a href="#gitrstudiotopic-11" target="_self"> Knit the HTML report</a><br><a href="#gitrstudiotopic-12" target="_self"> Change the plot</a><br><a href="#gitrstudiotopic-13" target="_self"> Make a change and revert it</a><br><a href="#gitrstudiotopic-14" target="_self"> Delete a file</a><br><a href="#gitrstudiotopic-15" target="_self"> Inspect your work</a><br><a href="#gitrstudiotopic-16" target="_self"> Use the git command line</a><br><a href="#gitrstudiotopic-17" target="_self"> Learn more about the git command line</a><br></div></center><br><br>

Git allows groups of people to work on the same documents (often code) at the same time, and without stepping on each other's toes.
It's a distributed version control system.
(cribbed from <a href="http://try.github.io">tryGit</a>)

<h3 id="gitrstudiotopic-1"><span class="orange">Intro to practical version control for scientists</span></h3>
These <a href="http://htmlpreview.github.io/?https://github.com/BernhardKonrad/2014-02-22-SFU/blob/gh-pages/BK-slides/git-intro.slides.html">slides</a> are courtesy of <a href="https://github.com/BernhardKonrad">Bernhard Konrad</a>.

<h3 id="gitrstudiotopic-2"><span class="orange">Installation and configuration of git</span></h3>
If you've already installed and configured <a href="http://git-scm.com">git</a>, skip ahead to
<a href="#learngit">Learn to use git with RStudio</a>.

<h3 id="gitrstudiotopic-3"> Install git</h3>
Mac OS 10.9 Mavericks comes with git installed.
To check that git is installed, open a Terminal and run…
<z>which git
git --version</z>

These commands should display something similar to this:
<z>➜  which git
/usr/bin/git
➜  git --version
git version 1.9.3</z>

For all other operating systems, go to the <a href="http://git-scm.com/downloads">Git downloads</a> web site, and click on the appropriate icon for your operating system.

If on a Mac the official Git package gives you any trouble, use the following instructions to install Git using Homebrew.

<h3 id="gitrstudiotopic-4"> Install git using <a href="http://brew.sh">Homebrew</a></h3>
<a href="http://brew.sh">Homebrew</a> is the missing package manager for Mac OS X.
To install Homebrew and use <z>brew</z> to install Git, run…
<z>ruby -e "$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)" brew install git</z>
Test that git is installed and working by running…
<z>which git
git --version</z>

<h3 id="gitrstudiotopic-5"> Configure git</h3>
Git associates your name and e-mail address with each commit, which helps when multiple people collaborate on a project.
To configure your name and e-mail address in git, open the Terminal and run…
<z>git config --global user.name 'Your Name'
git config --global user.email 'your@email.com'</z>

On a Mac, configure git to remember your password.
<z>git config --global credential.helper osxkeychain</z>

<h3 id="gitrstudiotopic-6"> Configure RStudio to use git</h3>
Open RStudio
Click <k>Tools -> Global Options -> Git/SVN</k>
If <k>Git executable</k> shows <k>(none)</k>, click <k>Browse</k> and select the git executable installed on your system

On a Mac, this will likely be one of
<z>/usr/bin/git</z>
<z>/usr/local/bin/git</z>
<z>/usr/local/git/bin/git</z>
On Windows, <z>git.exe</z> will likely be somewhere in <z>Program Files</z> Click <k>OK</k>

<h3 id="gitrstudiotopic-7"><span class="orange">Learn to use git with RStudio</span></h3>
<h3 id="gitrstudiotopic-8"> Create a new project</h3>
Or if you prefer, see below for instructions to open an existing project.

Open RStudio
Create a new project

Click <k>File -> New Project -> New Directory -> Empty Project</k>
Check <k>Create a git repository for this project</k>

<h3 id="gitrstudiotopic-9"> Open an existing project</h3>
Open an existing project

Click <k>File -> Open Project</k>

If you already have a tab labeled <k>Git</k> next to the tabs <k>Environment</k> and
<k>History</k>, skip these instructions.

Enable git for this project

Click <k>Tools -> Version Control -> Project Setup</k>
Click the dropdown box <k>Version control system</k> and select <k>Git</k>
If you don't have a <k>Git</k> option go back to <a href="#configurerstudio">Configure RStudio</a>.
Do not pass Go.
Do not collect $200

<h3 id="gitrstudiotopic-10"> Create and commit a file</h3>
Make your first commit

Click the <k>Git</k> tab
Check <k>Staged</k> next to <z>.gitignore</z> and <z>hello.Rproj</z>
Click <k>Commit</k>
Type a message in <k>Commit message</k>
Click <k>Commit</k>
Create a new Rmd file

Click <k>File -> New File -> R Markdown</k>
Edit the file and change the title
Save the file
Commit the new Rmd file

Check <k>Staged</k> and click <k>Commit</k>

<h3 id="gitrstudiotopic-11"> Knit the HTML report</h3>
Knit the Rmd file to generate an HTML report

Click <k>Knit HTML</k>
Commit the generated report

Check <k>Staged</k> for the <k>md</k> and <k>html</k> files and the <k>figures</k> directory
Click <k>Commit</k>

<h3 id="gitrstudiotopic-12"> Change the plot</h3>
Replace the <k>plot</k> with <k>ggplot</k> or <k>qplot</k> and save your changes
Commit the change
Knit the report
Commit all the modified files

<h3 id="gitrstudiotopic-13"> Make a change and revert it</h3>
Make an erroneous change to the file and save it
Click <k>Diff</k> and then <k>Revert</k>
The erroneous change has been undone and the previous version restored

<h3 id="gitrstudiotopic-14"> Delete a file</h3>
Create a new file named <z>doomed.md</z>
Enter some text and save it
Delete this doomed file

Under the <k>Files</k> tab check the box next to <z>doomed.md</z>
Click <k>Delete</k>
Under the <k>Git</k> tab, a red <z>D</z> appears next to the deleted file
Stage the change by clicking the checkbox and commit it

<h3 id="gitrstudiotopic-15"> Inspect your work</h3>
Make a few more changes and commits
Click <k>History</k> under the <k>Git</k> tab to review your day's work
Git has recorded a complete history of your work
In the event of impish gnomes introducing errors into your work, you can browse through your history, find the gnome to blame, and restore your previous good work.
Gnomes be damned.

<h3 id="gitrstudiotopic-16"> Use the git command line</h3>
There are many graphical interfaces for git—RStudio is one—but there is only one git command line interface, which is the common engine being used behind the scenes.
If your graphical interface ever lets you down, it's useful to peak under the hood.

Click <k>File -> New File -> Text File</k>
Describe your project in this new file
Save this file and name it <z>README.md</z>

Case matters! Name the file <z>README.md</z> and not <z>readme.md</z> or any other variation
Don't be imaginative.
Get used to being pedantic.
Foster your inner OCD
md is the extension of a <a href="markdown">Markdown</a> file
Note the yellow question marks indicating the new file that's not being tracked by git
Open a shell (also known as a Terminal)

Under the <k>Git</k> tab, click <k>More -> Shell</k>
Stage <z>README.md</z> using the git command line

Run <z>git add README.md</z>
The yellow question mark changes to a green <k>A</k>
Checking the <k>Staged</k> check box in fact runs <z>git add</z>
Unstage <z>README.md</z>

Run <z>git reset README.md</z>
The green <k>A</k> changes back to a yellow question mark
Unchecking the <k>Staged</k> check box in fact runs <z>git reset</z>
Stage and commit <z>README.md</z>

Run…
<z>git add README.md
git commit -m 'Add README.md'</z>

The <z>-m</z> option of <z>git commit</z> specifies the git log message
Browse the git history in RStudio, and inspect this commit

<h3 id="gitrstudiotopic-17"> Learn more about the git command line</h3>
Go to <a href="http://try.github.io">tryGit</a> and learn more about the git command line!

<h2>git remote add origin command to push remotely</h2>

<div id="gitremotetoc" class="toc"><a href="#gitremotetopic-0" target="_self">Create the remote origin on GitHub</a><br><a href="#gitremotetopic-1" target="_self">Copy and edit GitHub's remote add URL</a><br><a href="#gitremotetopic-2" target="_self">Run the git remote add origin command</a><br><a href="#gitremotetopic-3" target="_self">Perform a git push to the remote</a><br><a href="#gitremotetopic-4" target="_self">Verify the git remote add push on GitHub</a><br><a href="#gitremotetopic-5" target="_self">Overview of git remote add origin and push steps</a><br></div></center><br><br>
<iframe src="https://www.youtube.com/embed/uJ3T0VpibWg?autoplay=0&amp;modestbranding=1&amp;rel=0&amp;widget_referrer=https://www.theserverside.com/video/How-to-use-the-git-remote-add-origin-command-to-push-remotely&amp;enablejsapi=1&amp;origin=https://www.theserverside.com" type="text/html" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe> 

When developers want to take their local Git repository, use the git remote add origin command. 

The git reflog command shows how many commits are in the local repository before the git remote add origin call.

execute the git reflog command
<em>Reflog</em> is an abbreviation of reference logs. 

<h3 id="gitremotetopic-0">Create the remote origin on GitHub</h3><a href="#top" target="_self"><b>⇧</b></a><br> 
After the local repository is validated, the next step is to create a remote repository that the local repository will connect to. 

It's easy to create a remote repository. 
Log into GitHub and use the "<a href="https://www.theserverside.com/blog/Coffee-Talk-Java-News-Stories-and-Opinions/Create-a-GitHub-repository-with-this-step-by-step-tutorial">Create a new repository</a>" wizard. 
In this example, I named the GitHub repository <em>my-github-repo</em> to clearly differentiate it from the Git repository that is stored locally in a folder named <em>my-local-repo</em>. 
<img class="lazy loaded" data-src="https://cdn.ttgtmedia.com/rms/onlineImages/SideCOM_remote-repo-for-git-add-remote-command_002.jpg" src="https://cdn.ttgtmedia.com/rms/onlineImages/SideCOM_remote-repo-for-git-add-remote-command_002.jpg" data-was-processed="true">

Set up the remote origin repository on the GitHub server.

Since you will transfer information to the GitHub repository, do not initialize it with a README, configure a gitignore file or add a license. 
All of those things will exist in the local repository and will be subsequently pushed into the remote GitHub one. 

If those resources exist in both repositories before the git remote add origin command runs, it will create extra merge and conflict resolution steps that are easily avoided. 
<h3 id="gitremotetopic-1">Copy and edit GitHub's remote add URL</h3><a href="#top" target="_self"><b>⇧</b></a><br> 
When GitHub creates your repository, it presents an HTTP link, which is required as part of the git remote add origin command. 

The URL provided that uniquely identifies the GitHub repository I created is: 
http://github.com/cameronmcnz/my-github-repo.git 
Copy and paste this URL into a text editor and then add your username and password to the start of the URL: 

http://<strong>cameronmcnz:<a href="/cdn-cgi/l/email-protection" data-cfemail="92c6a7a7e6e7e6fde0fbf3fed2">[email&nbsp;protected]</a></strong>github.com/cameronmcnz/my-github-repo.git 
This URL setup lets you authenticate the file without using a credential manager or other password management tool. 
<h3 id="gitremotetopic-2">Run the git remote add origin command</h3><a href="#top" target="_self"><b>⇧</b></a><br> 

With the GitHub URL saved to the clipboard in the folder that contains your local Git repository, open a terminal window and run the following git remote add origin command: 
git remote add origin http://<strong>cameronmcnz:<a href="/cdn-cgi/l/email-protection" data-cfemail="3f6b0a0a4b4a4b504d565e537f">[email&nbsp;protected]</a></strong>github.com/cameronmcnz/my-github-repo.git 
This command will execute, but the system won't provide any feedback to the terminal window. 

To verify that the remote repo was added to your configuration, use the git remote –v command. 
This command will show that GitHub is the fetch and push targets of the local repository. 
<h3 id="gitremotetopic-3">Perform a git push to the remote</h3><a href="#top" target="_self"><b>⇧</b></a><br> 

Finally, with the GitHub service configured, push all your local code changes, commits and revision history to the remote server with a git push command. 
Make sure you specify the --set-upstream option, otherwise the remote server will reject the operation. 
Also include the name of the branch to push, which in this case is master. 

<img class="lazy" data-src="https://cdn.ttgtmedia.com/rms/onlineImages/SideCOM_git-remote-add-remote-push_003.jpg">

Push changes to the remote server with the git push command.

git push --set-upstream origin master 

As this action completes, the terminal window lists the number of objects <a href="https://www.theserverside.com/blog/Coffee-Talk-Java-News-Stories-and-Opinions/How-a-git-reset-and-push-to-remote-works-on-previous-local-commits">pushed to the server</a> and indicates that your local repository is set to track to a branch named <em>master </em>on the GitHub server. 
<h3 id="gitremotetopic-4">Verify the git remote add push on GitHub</h3><a href="#top" target="_self"><b>⇧</b></a><br> 
After the git remote add and push commands complete, go back to the <a href="https://github.com/cameronmcnz/my-github-repo">GitHub instance</a> and look at the contents of the recently created repository. 

<img class="lazy" data-src="https://cdn.ttgtmedia.com/rms/onlineImages/SideCOM_github-remote-add-origin-success_004.jpg">

The result of the local git remote add and push command is reflected in the remote GitHub repository.


The remote GitHub repository should contain all the files that make up your local repository and at the same time, maintain a copy of your commit history. 

If you look at my GitHub repository, you will see the HelloWorld.java, index.html and style.css files, along with an indication that the repository contains two commits. 
These files and commits are consistent with the output from the git reflog command from the start of this tutorial. 
<h3 id="gitremotetopic-5">Overview of git remote add origin and push steps</h3><a href="#top" target="_self"><b>⇧</b></a><br> 

In review, these are the five steps to successfully perform a git remote add origin and push to a remote repository: 

<li>Validate the existence of your local Git repository.</li> 
<li>Create a new, empty Git repository on your remote server.</li> 
<li>Obtain the git remote add URL for the remote repository and add credentials if needed.</li> 
<li>Run the git remote add origin command from your local repository with the --set-upstream and the name of the active branch to push.</li> 
<li>View the pushed files on the remote Git repository to verify that the git remote add and push commands ran successfully.</li> 

Now that the remote and local repositories can interact seamlessly, you can continue to <a href="https://www.theserverside.com/video/Follow-these-git-commit-message-guidelines">commit code</a> locally, push changes to the remote GitHub server, and begin to manage your source code in a distributed manner.

<h2>SSH Keys</h2>

<div id="SSHKeystoc" class="toc"><a href="#SSHKeystopic-0" target="_self">Generating SSH Keys</a><br><a href="#SSHKeystopic-1" target="_self"> Uploading and Installing the public key</a><br><a href="#SSHKeystopic-2" target="_self">Using the SSH Key</a><br><a href="#SSHKeystopic-3" target="_self"> SSH config file</a><br><a href="#SSHKeystopic-4" target="_self"> SSH Agent</a><br></div></center>
SSH key pairs allow users to connect to remote accounts without having to use the password of the remote account. This is useful if you'd like to not have to enter the password to an account you own and access frequently, or if you need to connect to a shared account where you are not its owner and do not know its password. You create a pair of files known as "keys", one private and one public, to facilitate this process. The private key stays on the machine you will connect from which is usually the machine where it is created (for example, your laptop). The other key, the public key, is put into the remote account by the owner of that account (which may be you) or by the server administrator. Think of this process as leaving a real key (the public key) in a remote door. The door will only open if you have the associated private key as you approach. This is why you must keep the private key to yourself, otherwise people who have a copy of it can pass through all the doors in which you left your public key.
The most popular Windows SSH client today is Putty which is available from <a href="http://www.chiark.greenend.org.uk/%7Esgtatham/putty">http://www.chiark.greenend.org.uk/~sgtatham/putty</a>. Download the complete Windows installer rather than just the putty.exe file. You may choose to follow the thorough Putty documentation directly on how to <a href="http://the.earth.li/%7Esgtatham/putty/0.60/htmldoc/Chapter8.html#pubkey-puttygen">create an SSH keypair on Windows</a>. Otherwise see the more brief step-by-step instructions below.

<b id="SSHKeystopic-0">Generating SSH Keys</b>
Start the puttygen.exe program included with the Putty installer.
In the <em>Parameters</em> section choose SSH3 RSA as the key type and press <k>Generate</k>. You will need to move your mouse about in the small window area in order to generate randomness that the process requires.
You may choose to enter a key comment which can be used by you to identify the key (useful when you use several SSH keys).
Type in a passphrase and confirm it. The passphrase is used to protect your key and you will be asked for it when you connect via SSH using public key authentication.
Click <k>Save private key</k> to save your private key. A common name is <k>id_rsa</k>.
Click <k>Save public key</k> to save your public key.  A common name is <k>id_rsa.pub</k>.

<b id="SSHKeystopic-1"> Uploading and Installing the public key</b>
See the UNIX instructions for these steps above as they are identical.

<h3 id="SSHKeystopic-2">Using the SSH Key</h3>
<b id="SSHKeystopic-3"> SSH config file</b>
You can explicitly tell your ssh program to use your ssh key and not your password with `ssh -o preferredauthentications=publickey ...`. Since you may not want to type that every time, you can configure an ssh host alias. Create and/or append to the file ~/.ssh/config on your local computer and enter the following:

<code>Host somename
HostName your.favorite.machine.berkeley.edu
User theuser
PreferredAuthentications publickey</code>
Then you can invoke `ssh somename` and it will pass in all of the above options.

<b id="SSHKeystopic-4"> SSH Agent</b>
If you do not want to have to type your key's passphrase every time, you can load the key into your SSH agent once. The ssh-agent is usually automatically started on Linux, and you can load the key into your agent by typing `ssh-add`. If your key is in a non-standard location, you can manually specify it with `ssh-add /path/to/the/ssh/key`. On macOS, your agent uses your keychain, so pass in `-K` to ssh-add, e.g. `ssh-add -K` or `ssh-add -K /path/to/the/ssh/key`.

<h2>What is ed25519?</h2>

<div id="ed25519toc" class="toc"><a href="#ed25519topic-0" target="_self">Why ed25519 Key is a Good Idea</a><br><a href="#ed25519topic-1" target="_self">Generate ed25519 SSH Key</a><br></div></center>
<k>ed25519</k> is a relatively new cryptography solution implementing Edwards-curve Digital Signature Algorithm (EdDSA).

I say <em>relatively</em>, because <k>ed25519</k> is supported by OpenSSH for about 5 years now – so it wouldn’t be considered a cutting edge.
Still, people are such creatures of habits that many IT professionals daily using SSH/SCP haven’t even heard of this key type.

Similarly, not all the software solutions are supporting <k>ed25519</k> right now – but SSH implementations in most modern Operating Systems certainly support it.

<h3 id="ed25519topic-0">Why ed25519 Key is a Good Idea</h3>
Compared to the most common type of SSH key – RSA – <k>ed25519</k> brings a number of cool improvements:

it’s faster: to generate and to verify
it’s more secure
collision resilience – this means that it’s more resilient against hash-function collision attacks (types of attacks where large numbers of keys are generated with the hope of getting two different keys have matching hashes)
keys are smaller – this, for instance, means that it’s easier to transfer and to copy/paste them

<h3 id="ed25519topic-1">Generate ed25519 SSH Key</h3>
Here’s the command to generate an ed25519 SSH key:

$ ssh-keygen -t ed25519 -C "[email@protected]"
Generating public/private ed25519 key pair.
Enter file in which to save the key (/Users/greys/.ssh/id_ed25519):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /Users/greys/.ssh/id_ed25519.
Your public key has been saved in /Users/greys/.ssh/id_ed25519.pub.
The key fingerprint is:
SHA256:FHsTyFHNmvNpw4o7+rp+M1yqMyBF8vXSBRkZtkQ0RKY

The key's randomart image is:
+--[ED25519 256]--+
|       */Xoo     |
|  . . .===..o    |
|   + .Eo+.oo     |
|    o ..o.+.     |
|   .   .S  + .   |
|  . .     . *    |
|   . . . + o .   |
|      o O .      |
|     .*Xo=       |
+----[SHA256]-----+
That’s it – this keypair is ready to be deployed to SSH servers, GitHub or any other service that can use them.

Check out how short the public key is:

ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIK0wmN/Cr3JXqmLW7u+g9pTh+wyqDHpSQEIQczXkVx9q

<h2>SSH Keys for GitHub</h2>
<h4>Objectives</h4>
<li>Explain what an SSH key is</li>
<li>Generate your own SSH key pair</li>
<li>Add your SSH key to your GitHub account</li>
<li>Learn how to use your SSH key in your GitHub workflow</li>
<h4>Why Use an SSH Key?</h4>
When working with a GitHub repository, you'll often need to identify yourself to GitHub using your username and password.
An SSH key is an alternate way to identify yourself that doesn't require you to enter you username and password every time.

SSH keys come in pairs, a public key that gets shared with services like GitHub, and a private key that is stored only on your computer.
If the keys match, you're granted access.

The cryptography behind SSH keys ensures that no one can reverse engineer your private key from the public one.

<h4>Generating an SSH key pair</h4>
The first step in using SSH authorization with GitHub is to generate your own key pair.

You might already have an SSH key pair on your machine.
You can check to see if one exists by moving to your <code>.ssh</code> directory and listing the contents.
<code>$ cd ~/.ssh
$ ls</code>
If you see <code>id_rsa.pub</code>, you already have a key pair and don't need to create a new one.

If you don't see <code>id_rsa.pub</code>, use the following command to generate a new key pair.
Make sure to replace <code>your@email.com</code> with your own email address.
<code>$ ssh-keygen -o -t rsa -C "your@email.com"</code>
(The <code>-o</code> option was added in 2014; if this command fails for you, just remove the <code>-o</code> and try again)

When asked where to save the new key, hit enter to accept the default location.
<code>Generating public/private rsa key pair.
Enter file in which to save the key (/Users/username/.ssh/id_rsa):</code>
You will then be asked to provide an optional passphrase.
This can be used to make your key even more secure, but for this lesson you can skip it by hitting enter twice.
<code>Enter passphrase (empty for no passphrase):</code>

<code>Enter same passphrase again:</code>
When the key generation is complete, you should see the following confirmation:
<code>Your identification has been saved in /Users/username/.ssh/id_rsa.
Your public key has been saved in /Users/username/.ssh/id_rsa.pub.
The key fingerprint is:
01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your@email.com
The key's randomart image is:
+--[ RSA 2048]----+
|                 |
|                 |
|        . E +    |
|       . o = .   |
|      . S =   o  |
|       o.O . o   |
|       o .+ .    |
|      . o+..     |
|       .+=o      |
+-----------------+</code>
The random art image is an alternate way to match keys but we won't be needing this.

<h4>Add your public key to GitHub</h4>
We now need to tell GitHub about your public key.
 Display the contents of your new public key file with <code>cat</code>:
<code>$ cat ~/.ssh/id_rsa.pub</code>
The output should look something like this:
<code>ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEA879BJGYlPTLIuc9/R5MYiN4yc/YiCLcdBpSdzgK9Dt0Bkfe3rSz5cPm4wmehdE7GkVFXrBJ2YHqPLuM1yx1AUxIebpwlIl9f/aUHOts9eVnVh4NztPy0iSU/Sv0b2ODQQvcy2vYcujlorscl8JjAgfWsO3W4iGEe6QwBpVomcME8IU35v5VbylM9ORQa6wvZMVrPECBvwItTY8cPWH3MGZiK/74eHbSLKA4PY3gM4GHI450Nie16yggEg2aTQfWA1rry9JYWEoHS9pJ1dnLqZU3k/8OWgqJrilwSoC5rGjgp93iu0H8T6+mEHGRQe84Nk1y5lESSWIbn6P636Bl3uQ== your@email.com</code>
Copy the contents of the output to your clipboard.

Login to github.com and bring up your account settings by clicking the tools icon.
<img src="https://jdblischak.github.io/2014-09-18-chicago/novice/git/img/github-account-settings.png" />

Select <k>SSH Keys</k> from the side menu, then click the <k>Add SSH key</k> button.

<img src="https://jdblischak.github.io/2014-09-18-chicago/novice/git/img/github-ssh-keys.png" />

Name your key something whatever you like, and paste the contents of your clipboard into the <k>Key</k> text box.

<img src="https://jdblischak.github.io/2014-09-18-chicago/novice/git/img/github-add-ssh-key.png" />

Finally, hit <k>Add key</k> to save.
Enter your github password if prompted.

####Using Your SSH Key

Going forward, you can use the SSH clone URL when copying a repo to your local machine.

<img src="https://jdblischak.github.io/2014-09-18-chicago/novice/git/img/github-ssh-clone-url.png" />

This will allow you to bypass entering your username and password for future GitHub commands.

<h4>Key Points</h4>
<li>SSH is a secure alternative to username/password authorization</li>
<li>SSH keys are generated in public / private pairs.
Your public key can be shared with others.
The private keys stays on your machine only.</li>
<li>You can authorize with GitHub through SSH by sharing your public key with GitHub.</li>


git remote set-url origin git@github.com:williamkpchan/williamkpchan.github.io.git
git push --set-upstream origin master

<h2>Start a new git repository </h2>
Your first instinct, when you start to do something new, should be <code>git init</code>. 

<h3>A new repo from scratch</h3>
Create a directory to contain the project.
Go into the new directory.

Type <code>git init</code>.
Write some code.
Type <code>git add</code> to add the files.
Type <code>git commit</code>.

<h3>A new repo from an existing project</h3>
Say you've got an existing project that you want to start tracking with git.

Go into the directory containing the project.
Type <code>git init</code>.
Type <code>git add</code> to add all of the relevant files.
You'll probably want to create a <code>.gitignore</code> file right away, to indicate all of the files you don't want to track. 
Use <code>git add .gitignore</code>, too.

Type <r>git commit</r>.
git remote add origin https://github.com/williamkpchan/stdrvest.git
git branch -M main
git push -u origin main

<a href="https://www.youtube.com/watch?v=QyFcl_Fba-k" class="whitebut ">Getting Started with GitHub Pages</a>

<h3>Connect it to github</h3>
You've now got a local git repository. 
You can use git locally, like that, if you want. 

But if you want the thing to have a home on github, do
the following.

Go to <a href="https://github.com">github</a>.
Log in to your account.
Click the <a href="https://github.com/new">new repository</a> button in the top-right. 
You'll have an option there to initialize the repository with a README file, but I don't.

Click the “Create repository” button.

Now, follow the second set of instructions, “Push an existing repository…”
<code>$ git remote add origin git@github.com:username/new_repo
$ git push -u origin master
</code>
Actually, the first line of the instructions will say
<code>$ git remote add origin https://github.com/username/new_repo</code>
But I use <code>git@github.com:username/new_repo</code> rather than <code>https://github.com/username/new_repo</code>, as the former is for use with

<a href="https://en.wikipedia.org/wiki/Secure_Shell">ssh</a> (if you set up ssh as I mentioned in “<a href="first_time.html">Your first time</a>”, then you won't have to type your password every time you push things to github). 

If you use the latter construction, you'll have to type your github password every time you push to github.

<h2>See What Branch You're On</h2>
Run this command: git status
<h2>List All Branches</h2>
<k>NOTE: </k>The current local branch will be marked with an asterisk (*).</p>
To see <k>local branches</k>, run this command: <k>git branch </k>
To see <k>remote branches</k>, run this command: <k>git branch -r </k>
To see <k>all local and remote branches</k>, run this command: <k>git branch -a </k>
<h2>Create a New Branch</h2>
Run this command (replacing <k>my-branch-name </k> with whatever name you want):
<k>git checkout -b my-branch-name </k>
You're now ready to commit to this branch.
<h2>Switch to a Branch In Your Local Repo</h2>
Run this command:<k>git checkout my-branch-name </k>

<h2>Switch to a Branch That Came From a Remote Repo</h2>
To get a list of all branches from the remote, run this command: <k>git pull </k>
Run this command to switch to the branch:
<k>git checkout --track origin/my-branch-name </k>

<h2>Push to a Branch</h2>
If your local branch <k>does not exist </k> on the remote, run either of these commands:
<k>git push -u origin my-branch-name </k>
<k>git push -u origin HEAD </k>
<k>NOTE: </k>HEAD is a reference to the top of the current branch, so it's an easy way to push to a branch of the same name on the remote. This saves you from having to type out the exact name of the branch!</p>
If your local branch <k>already exists </k> on the remote, run this command: <k>git push </k>

<h2>Merge a Branch</h2>
You'll want to make sure your working tree is clean and see what branch you're on. Run this command:
<k>git status </k>
First, you must check out the branch that you want to merge another branch into (changes will be merged into this branch). If you're not already on the desired branch, run this command: <k>git checkout master </k>
<k>NOTE:</k> Replace <k>master </k>with another branch name as needed.
Now you can merge another branch into the current branch. Run this command:
<k>git merge my-branch-name </k>
<k>NOTE:</k> When you merge, there may be a conflict. Refer to <k>Handling Merge Conflicts </k> (the next exercise) to learn what to do.

<h2>Delete Branches</h2>
To delete a <k>remote branch</k>, run this command: <k>git push origin --delete my-branch-name </k>
To delete a <k>local branch</k>, run either of these commands:
<k>git branch -d my-branch-name </k>
<k>git branch -D my-branch-name </k>
<k>NOTE:</k> The -d option only deletes the branch if it has already been merged. The -D option is a shortcut for --delete --force, which deletes the branch irrespective of its merged status.

<h2>Working with Remotes</h2>

<div id="withRemotestoc" class="toc"><a href="#withRemotestopic-0" target="_self">Showing Your Remotes</a><br><a href="#withRemotestopic-1" target="_self">Adding Remote Repositories</a><br><a href="#withRemotestopic-2" target="_self">Fetching and Pulling from Your Remotes</a><br><a href="#withRemotestopic-3" target="_self">Pushing to Your Remotes</a><br><a href="#withRemotestopic-4" target="_self">Inspecting a Remote</a><br><a href="#withRemotestopic-5" target="_self">Renaming and Removing Remotes</a><br></div></center>

Remote repositories are versions of your project that are hosted on the Internet or network somewhere.
You can have several of them, each of which generally is either read-only or read/write for you.
Collaborating with others involves managing these remote repositories and pushing and pulling data to and from them when you need to share work.

Managing remote repositories includes knowing how to add remote repositories, remove remotes that are no longer valid, manage various remote branches and define them as being tracked or not, and more.
In this section, we’ll cover some of these remote-management skills.
Note

Remote repositories can be on your local machine.
It is entirely possible that you can be working with a “remote” repository that is, in fact, on the same host you are.
The word “remote” does not necessarily imply that the repository is somewhere else on the network or Internet, only that it is elsewhere.

Working with such a remote repository would still involve all the standard pushing, pulling and fetching operations as with any other remote.
<h3 id="withRemotestopic-0">Showing Your Remotes</h3>
To see which remote servers you have configured, you can run the <k>git remote</k> command.

It lists the shortnames of each remote handle you’ve specified.
If you’ve cloned your repository, you should at least see <k>origin</k> — that is the default name Git gives to the server you cloned from:
<k>$ git clone https://github.com/schacon/ticgit</k>

Cloning into 'ticgit'...
remote: Reusing existing pack: 1857, done.
remote: Total 1857 (delta 0), reused 0 (delta 0)

Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.
Resolving deltas: 100% (772/772), done.
Checking connectivity... 

done.
$ cd ticgit
$ git remote

origin
You can also specify <k>-v</k>, which shows you the URLs that Git has stored for the shortname to be used when reading and writing to that remote:
<k>$ git remote -v</k>
origin	https://github.com/schacon/ticgit (fetch)
origin	https://github.com/schacon/ticgit (push)
If you have more than one remote, the command lists them all.

For example, a repository with multiple remotes for working with several collaborators might look something like this.
<k>$ cd grit
$ git remote -v</k>

bakkdoor  https://github.com/bakkdoor/grit (fetch)
bakkdoor  https://github.com/bakkdoor/grit (push)
cho45     https://github.com/cho45/grit (fetch)

cho45     https://github.com/cho45/grit (push)
defunkt   https://github.com/defunkt/grit (fetch)
defunkt   https://github.com/defunkt/grit (push)

koke      git://github.com/koke/grit.git (fetch)
koke      git://github.com/koke/grit.git (push)
origin    git@github.com:mojombo/grit.git (fetch)
origin    git@github.com:mojombo/grit.git (push)

This means we can pull contributions from any of these users pretty easily.
We may additionally have permission to push to one or more of these, though we can’t tell that here.

Notice that these remotes use a variety of protocols; we’ll cover more about this in <a href="ch00/_getting_git_on_a_server">Getting Git on a Server</a>.
<h3 id="withRemotestopic-1">Adding Remote Repositories</h3>
We’ve mentioned and given some demonstrations of how the <k>git clone</k> command implicitly adds the <k>origin</k> remote for you.

Here’s how to add a new remote explicitly.
To add a new remote Git repository as a shortname you can reference easily, run <k>git remote add &lt;shortname&gt; &lt;url&gt;</k>:
<k>$ git remote</k>

origin
$ git remote add pb https://github.com/paulboone/ticgit
$ git remote -v

origin	https://github.com/schacon/ticgit (fetch)
origin	https://github.com/schacon/ticgit (push)
pb	https://github.com/paulboone/ticgit (fetch)
pb	https://github.com/paulboone/ticgit (push)

Now you can use the string <k>pb</k> on the command line in lieu of the whole URL.
For example, if you want to fetch all the information that Paul has but that you don’t yet have in your repository, you can run <k>git fetch pb</k>:

<k>$ git fetch pb</k>
remote: Counting objects: 43, done.
remote: Compressing objects: 100% (36/36), done.

remote: Total 43 (delta 10), reused 31 (delta 5)
Unpacking objects: 100% (43/43), done.
From https://github.com/paulboone/ticgit

* [new branch]      master     -&gt; pb/master
* [new branch]      ticgit     -&gt; pb/ticgit
Paul’s <k>master</k> branch is now accessible locally as <k>pb/master</k> — you can merge it into one of your branches, or you can check out a local branch at that point if you want to inspect it.

We’ll go over what branches are and how to use them in much more detail in <a href="ch00/ch03-git-branching">Git Branching</a>.
<h3 id="withRemotestopic-2">Fetching and Pulling from Your Remotes</h3>
As you just saw, to get data from your remote projects, you can run:

<k>$ git fetch &lt;remote&gt;</k>
The command goes out to that remote project and pulls down all the data from that remote project that you don’t have yet.
After you do this, you should have references to all the branches from that remote, which you can merge in or inspect at any time.

If you clone a repository, the command automatically adds that remote repository under the name “origin”.
So, <k>git fetch origin</k> fetches any new work that has been pushed to that server since you cloned (or last fetched from) it.
It’s important to note that the <k>git fetch</k> command only downloads the data to your local repository — it doesn’t automatically merge it with any of your work or modify what you’re currently working on.

You have to merge it manually into your work when you’re ready.
If your current branch is set up to track a remote branch (see the next section and <a href="ch00/ch03-git-branching">Git Branching</a> for more information), you can use the <k>git pull</k> command to automatically fetch and then merge that remote branch into your current branch.
This may be an easier or more comfortable workflow for you; and by default, the <k>git clone</k> command automatically sets up your local <k>master</k> branch to track the remote <k>master</k> branch (or whatever the default branch is called) on the server you cloned from.

Running <k>git pull</k> generally fetches data from the server you originally cloned from and automatically tries to merge it into the code you’re currently working on.
Note
From Git version 2.27 onward, <k>git pull</k> will give a warning if the <k>pull.rebase</k> variable is not set.

Git will keep warning you until you set the variable.
If you want the default behavior of Git (fast-forward if possible, else create a merge commit):
<k>git config --global pull.rebase "false"</k>

If you want to rebase when pulling:
<k>git config --global pull.rebase "true"</k>
<h3 id="withRemotestopic-3">Pushing to Your Remotes</h3>

When you have your project at a point that you want to share, you have to push it upstream.
The command for this is simple: <k>git push &lt;remote&gt; &lt;branch&gt;</k>.
If you want to push your <k>master</k> branch to your <k>origin</k> server (again, cloning generally sets up both of those names for you automatically), then you can run this to push any commits you’ve done back up to the server:

<k>$ git push origin master</k>
This command works only if you cloned from a server to which you have write access and if nobody has pushed in the meantime.
If you and someone else clone at the same time and they push upstream and then you push upstream, your push will rightly be rejected.

You’ll have to fetch their work first and incorporate it into yours before you’ll be allowed to push.
See <a href="ch00/ch03-git-branching">Git Branching</a> for more detailed information on how to push to remote servers.
<h3 id="withRemotestopic-4">Inspecting a Remote</h3>

If you want to see more information about a particular remote, you can use the <k>git remote show &lt;remote&gt;</k> command.
If you run this command with a particular shortname, such as <k>origin</k>, you get something like this:
<k>$ git remote show origin</k>

* remote origin
Fetch URL: https://github.com/schacon/ticgit
Push  URL: https://github.com/schacon/ticgit

HEAD branch: master
Remote branches:
master                               tracked

dev-branch                           tracked
Local branch configured for 'git pull':
master merges with remote master

Local ref configured for 'git push':
master pushes to master (up to date)
It lists the URL for the remote repository as well as the tracking branch information.

The command helpfully tells you that if you’re on the <k>master</k> branch and you run <k>git pull</k>, it will automatically merge the remote’s <k>master</k> branch into the local one after it has been fetched.
It also lists all the remote references it has pulled down.
That is a simple example you’re likely to encounter.

When you’re using Git more heavily, however, you may see much more information from <k>git remote show</k>:
<k>$ git remote show origin</k>
* remote origin

URL: https://github.com/my-org/complex-project
Fetch URL: https://github.com/my-org/complex-project
Push  URL: https://github.com/my-org/complex-project

HEAD branch: master
Remote branches:
master                           tracked

dev-branch                       tracked
markdown-strip                   tracked
issue-43                         new (next fetch will store in remotes/origin)

issue-45                         new (next fetch will store in remotes/origin)
refs/remotes/origin/issue-11     stale (use 'git remote prune' to remove)
Local branches configured for 'git pull':

dev-branch merges with remote dev-branch
master     merges with remote master
Local refs configured for 'git push':

dev-branch                     pushes to dev-branch                     (up to date)
markdown-strip                 pushes to markdown-strip                 (up to date)
master                         pushes to master                         (up to date)

This command shows which branch is automatically pushed to when you run <k>git push</k> while on certain branches.
It also shows you which remote branches on the server you don’t yet have, which remote branches you have that have been removed from the server, and multiple local branches that are able to merge automatically with their remote-tracking branch when you run <k>git pull</k>.
<h3 id="withRemotestopic-5">Renaming and Removing Remotes</h3>

You can run <k>git remote rename</k> to change a remote’s shortname.
For instance, if you want to rename <k>pb</k> to <k>paul</k>, you can do so with <k>git remote rename</k>:
<k>$ git remote rename pb paul</k>

$ git remote
origin
paul

It’s worth mentioning that this changes all your remote-tracking branch names, too.
What used to be referenced at <k>pb/master</k> is now at <k>paul/master</k>.
If you want to remove a remote for some reason — you’ve moved the server or are no longer using a particular mirror, or perhaps a contributor isn’t contributing anymore — you can either use <k>git remote remove</k> or <k>git remote rm</k>:

<k>$ git remote remove paul</k>
$ git remote
origin

Once you delete the reference to a remote this way, all remote-tracking branches and configuration settings associated with that remote are also deleted.

<h2>remotes and pushing to multiple Git repositories</h2>

<div id="multipleGittoc" class="toc"><a href="#multipleGittopic-0" target="_self">Two Minute Version</a><br><a href="#multipleGittopic-1" target="_self">Prerequisites</a><br><a href="#multipleGittopic-2" target="_self">Adding multiple remotes</a><br><a href="#multipleGittopic-3" target="_self">Configure primary remote</a><br><a href="#multipleGittopic-4" target="_self">Change remote URL</a><br><a href="#multipleGittopic-5" target="_self">List all remotes</a><br><a href="#multipleGittopic-6" target="_self">Remove a remote</a><br><a href="#multipleGittopic-7" target="_self">Push to multiple remotes</a><br><a href="#multipleGittopic-8" target="_self">Pull from multiple remotes</a><br></div></center>
Working with two or more Git repositories? No problem! In this tutorial, you’ll first learn to setup multiple Git remotes. 
Next, you’ll also learn to perform a “git push” to multiple Git repositories with a single command.

As a programmer, one of the best things that has happened to me is Git! If you don’t know what Git is, you should probably read a paragraph about it before you continue. 
Git allows you to synchronize the code on your computer with code on a remote repo shared with other developers – usually team members. 
In this tutorial we will learn to configure one or more Git remotes and pushing code to them with a single command.


<h3 id="multipleGittopic-0">Two Minute Version</h3>
Define a git remote which will point to multiple git remotes.
Say, we call it “all”: <dg>git remote add all REMOTE-URL-1</dg>.

Register 1<sup>st</sup> push URL: <dg>git remote set-url --add --push all REMOTE-URL-1</dg>.
Register 2<sup>nd</sup> push URL: <dg>git remote set-url --add --push all REMOTE-URL-2</dg>.
Push a branch to all the remotes with <dg>git push all BRANCH</dg> – replace <dg>BRANCH</dg> with a real branch name.

You cannot pull from multiple remotes, but you can fetch updates from multiple remotes with <dg>git fetch --all</dg>.

<h3 id="multipleGittopic-1">Prerequisites</h3>
Working knowledge of Git – <dg>git init</dg>, <dg>git pull</dg>, <dg>git commit</dg> and <dg>git push</dg>.

Have write access to one or more remote Git repositories.

<h3 id="multipleGittopic-2">Adding multiple remotes</h3>
When you do <dg>git init</dg>, you initialize a local Git repository. 

In general, the purpose is to synchronize this repo with a remote Git repo. 
To be able to synchronize code with a remote repo, you need to specify where the remote repo exists.
The first step is to add remote repos to your project.

<dg># Syntax to add a git remote
git remote add REMOTE-ID REMOTE-URL</dg>
By convention, the original / primary remote repo is called <dg>origin</dg>. 

Here’s a real example:
<dg># Add remote 1: GitHub.
git remote add origin git@github.com:jigarius/toggl2redmine.git

# Add remote 2: BitBucket.
git remote add upstream git@bitbucket.org:jigarius/toggl2redmine.git</dg>
In the above example, we add the remote repository of a project called  found on GitHub. 

Use the above command to add one or more remote Git repos – make sure that each repo has its unique ID, i.e. 
<dg>origin</dg>, <dg>upstream</dg> in the above example.

<h3 id="multipleGittopic-3">Configure primary remote</h3>

Though you can add multiple remotes, usually, each branch of your project can be configured to track a single remote branch. 
You can setup a branch to track a remote branch as follows:
<dg># Change local branch.

git checkout BRANCH
# Configure local branch to track a remote branch.
git branch -u origin/BRANCH</dg>

Here, <dg>BRANCH</dg> is the name of the remote branch, which is usually the same as your local branch.

<h3 id="multipleGittopic-4">Change remote URL</h3>
If you want to change the URL associated to a remote that you’ve already added, you can do it with the following command:

<dg># The syntax is: git remote set-url REMOTE-ID REMOTE-URL
git remote set-url upstream git@foobar.com:jigarius/toggl2redmine.git</dg>
<h3 id="multipleGittopic-5">List all remotes</h3>
To see a list of all remotes, simply use the following command:

<dg>$git remote -v
origin	    git@github.com:jigarius/toggl2redmine.git (fetch)
origin	    git@github.com:jigarius/toggl2redmine.git (push)

upstream    git@bitbucket.org:jigarius/toggl2redmine.git (fetch)
upstream    git@bitbucket.org:jigarius/toggl2redmine.git (push)</dg>
<h3 id="multipleGittopic-6">Remove a remote</h3>
If you’ve added a remote which you no longer require, you can remove it as follows:

<dg># The syntax is: git remote remove REMOTE-ID
git remote remove upstream</dg>
<h3 id="multipleGittopic-7">Push to multiple remotes</h3>
Now that you have a primary remote repo and other remotes as well, it’s time to configure the push. 

The objective is to <dg>push to multiple Git remotes</dg> with a single <dg>git push</dg> command.
To do this, choose a remote ID which will refer to all the remotes. 
I usually call it <dg>all</dg>, but there are developers who prefer <dg>origin</dg>. 

The idea is to add all the remote repo URLs as  “push URLs” to this remote. 
Here’s what you do:
<dg># Create a new remote called "all" with the URL of the primary repo.

git remote add all git@github.com:jigarius/toggl2redmine.git
# Re-register the remote as a push URL.
git remote set-url --add --push all git@github.com:jigarius/toggl2redmine.git

# Add a push URL to a remote. 
This means that "git push" will also push to this git URL.
git remote set-url --add --push all git@bitbucket.org:jigarius/toggl2redmine.git</dg>

If you don’t want to create an extra remote named <dg>all</dg>, you can skip the first command and use the remote <dg>origin</dg> instead of <dg>all</dg> in the subsequent command(s).
Now, you can push to all remote repositories with a single command!
<dg># Replace BRANCH with the name of the branch you want to push.

git push all BRANCH</dg>
<h3 id="multipleGittopic-8">Pull from multiple remotes</h3>
It is not possible to <dg>git pull</dg> from multiple repos. 
However, you can <dg>git fetch</dg> from multiple repos with the following command:

<dg>git fetch --all</dg>
This will <dg>fetch</dg> information from all remote repos. 
You can switch to the latest version of a branch on a particular remote with the command:

# Checkout the branch you want to work with.
<dg>git checkout BRANCH</dg>
# Reset the branch to match the state as on a specific remote.

<dg>git reset --hard REMOTE-ID/BRANCH</dg>

<h2>Bad git config file .git/config</h2>
run command:
git config --global user.name "williamkpchan"
git config --global user.email williamkpchan@gmail.com

<h2>The "fatal: 'origin' does not appear</h2>
https://github.com/williamkpchan/stdrvest

The "fatal: 'origin' does not appear to be a git repository" error occurs when you try to push code to a remote Git repository without telling Git the location of the remote repository.

To solve this error, use the git remote add command to add a remote to your project.

Manually tell Git where the remote version of our repository exists.
Do this using the git remote add command:

git remote add origin https://github.com/williamkpchan/stdrvest

Let’s try to push our code again:
git push -u origin main

<h2>Git Error - Unable to resolve reference refs/remotes/origin/master reference broken</h2>
To fix this error, remove the following file YOURPROJECT/.git/refs/remotes/origin/master, and then run git fetch to download it again.

Execute the following command within your project’s directory.

rm .git/refs/remotes/origin/master 
git fetch


<h2>fatal: the remote end hung up unexpectedly</h2>
This is due to git/https buffer settings.

Solution: Navigate to repo.
Run this to increase the buffer to 500MB:

git config http.postBuffer 524288000
Then, run your original command again.


<h2>git ls-remote</h2>
remote: error: File big.html is 229.72 MB; this exceeds GitHub's file size limit of 100.00 MB
remote: error: GH001: Large files detected.
You may want to try Git Large File Storage - https://git-lfs.github.com.
error: failed to push some refs

Displays references available in a remote repository along with the associated commit IDs

git ls-remote
From https://github.com/williamkpchan/stdrvest
73f683026f1b7eb75f457ee38b0f07d323dec7e5        HEAD
73f683026f1b7eb75f457ee38b0f07d323dec7e5        refs/heads/

git show-ref
Displays references available in a local repository along with the associated commit IDs.

git show-ref
454b0b3be972a18fdeedad5bca50c6b60ace6cd7 refs/heads/main
73f683026f1b7eb75f457ee38b0f07d323dec7e5 refs/remotes/origin/main

<h2>把檔案從 Git 裡拔掉</h2>
用 filter-branch 指令應該是相對較方便的。

舉例來說，目前的 Commit 紀錄是這樣：
current commits
我想要把所有 Commit 的 config/database.yml 這個檔案刪掉：

git filter-branch --tree-filter "rm -f config/database.yml"
Rewrite 27f6ed6da50dbee5adbb68102266a91dc097ad3f (7/7) (0 seconds passed, remaining 0 predicted)
Ref 'refs/heads/master' was rewritten

這樣看起來好像刪掉了…假的，其實那些東西都還在，隨時都可以取消剛剛這個指令，把剛剛被刪的檔案救回來：
$ git reset refs/original/refs/heads/master --hard
HEAD is now at 27f6ed6 add dog 2

全部斷乾淨！
再重頭來一次：
git filter-branch -f --tree-filter "rm -f config/database.yml"
Rewrite 27f6ed6da50dbee5adbb68102266a91dc097ad3f (7/7) (1 seconds passed, remaining 0 predicted)
Ref 'refs/heads/master' was rewritten

跟前面不太一樣，這次多加了 -f 參數，是因為要強制覆寫 filter-branch 的備份點。

這邊使用 filter-branch 指令把檔案從工作目錄裡移掉，這時候 database.yml 的確已不見，但還有好幾個跟資源回收有關的事情需要處理一下：
$ rm .git/refs/original/refs/heads/master
這個檔案還對剛剛做的 filter-branch 動作念念不忘（也就是備份點啦），隨時可以透過它再跳回去，所以先斷這條線。

再來，念念不忘的還有 Reflog，所以它也要清一下：
$ git reflog expire --all --expire=now
這個指令是要求 Reflog 現在立刻過期（不然預設要等 30 天）。

接著再用 git fsck 指令就可以看到很多 Unreachable 的物件了：
$ git fsck --unreachable
Checking object directories: 100% (256/256), done.

unreachable tree c8da8b6accf7029a2fb89eed130365822692b603
unreachable commit ca40fc9b31c777b1d3434453448c945fa2ffae11
unreachable commit cd82f29acbdce60c7f5f6894619585bd445797b5

unreachable tree 9e941fe91d47bf5174bd5a3d3e73ff257598b0ca
unreachable tree 5e01e02411507c504c77bca53c508a3174c9a06f
unreachable tree 607f055180d1195c81e0534d264d131d5abfdc27
unreachable commit 1de207637a6eed2cc86507dca37a38c7a932e53c
unreachable tree a21100f9f3aae37858cc84fd402663992ccca681
unreachable commit 27f6ed6da50dbee5adbb68102266a91dc097ad3f
unreachable tree a618ce33da8d21bca841f18e6432fcabf15d4477
unreachable commit 2bab3e7aff03a30ed9f53b5a7d3e02e1c0fc8c7c
unreachable tree 70c6b4db190a452b22c28998d7c2487efb8026b2
unreachable commit 382a2a5cec96b94e9c5cb42bf92b4b236f4ad8ac

最後，啟動 Git 的資源回收機制，請垃圾車來立刻把它們載走：
$ git gc --prune=now

Counting objects: 14, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (12/12), done.

Writing objects: 100% (14/14), done.
Total 14 (delta 5), reused 0 (delta 0)
檢查一下：

$ git fsck
Checking object directories: 100% (256/256), done.
Checking objects: 100% (14/14), done.

看來垃圾都載走了。
我們試試看用偷吃步能不能 Reset 得回去：
$ git reset 27f6ed6 --hard

fatal: ambiguous argument '27f6ed6': unknown revision or path not in the working tree.
Use '--' to separate paths from revisions, like this:
'git &lt;command> [&lt;revision>...] -- [&lt;file>...]'

看來不行了，Git 已經找不到原來的那個 SHA-1 值了。
提醒一下，如果這些內容已經推出去的話，別忘了最後再加一步 git push -f 把線上的紀錄蓋掉喔。

小結
檔案進了 Git 就跟得罪方丈一樣，想走沒那麼容易，需要全部都斷乾淨才行。
關於 Git 的資源回收的相關介紹，請參閱
https://stackoverflow.com/questions/31648386/how-to-trash-all-local-git-changes-and-revert-to-old-commit

<h2>revert Git LFS file</h2>
To revert a file tracked by Git LFS (Large File Storage) back to its original state, you'll need to follow these general steps:

Ensure you have the necessary access and permissions:
Make sure you have write access to the repository and the necessary permissions to modify files.

Determine the original version:
Identify the commit or version of the file that you want to revert to.
You can use Git commands such as git log or a Git client to view the commit history and find the desired version.

Retrieve the original version:
Use Git to retrieve the original version of the file.
You can do this using the git checkout command, specifying the commit or version you want to revert to, and the path to the file.

For example:
applescript
git checkout <commit> -- <file_path>
```

Replace `<commit>` with the commit hash or the branch/tag name, and `<file_path>` with the path to the file within the repository.

Note:
This command will update the file in your local working directory to the specified version.
If you want to revert the file for others as well, you'll need to push the changes back to the remote repository.

Stage and commit the changes (optional):
If you want to keep a record of the reversion, you can stage and commit the changes using Git.
This step is optional but can be useful for tracking the history of the file or collaborating with others.

git add <file_path>
git commit -m "Revert file to original version"
```

Replace `<file_path>` with the path to the file you reverted.

Push the changes (optional):
If you've made a commit in the previous step and want to share the reversion with others, you need to push the changes to the remote repository using the appropriate Git command (e.g., git push).

By following these steps, you should be able to revert the LFS file back to its original version.
Remember to exercise caution when modifying files, especially if you're working in a collaborative environment.

<h2>to revert the LFS file back to the original one</h2>
<a href="https://git-scm.com/docs/gitattributes" class="whitebut ">gitattributes</a>
used <k>git lfs pull</k> to download original file then <k>git lfs uninstall,</k> after that removed the <k>.gitattributes</k> file and commit again.

git lfs uninstall
this removes hooks and smudge/clean filter configuration
and this is only the beginning.

<k">git lfs ls-files</k> — view lfs filesfor each file, use globs if you can:
<k>git rm --cached myfile.psd</k> — "remove" the lfs file
<k>git add myfile.psd</k> — add the "normal" file
<k>git commit -m "restore files from lfs"</k>

gitattributes - Defining attributes per path
$GIT_DIR/info/attributes, .gitattributes

DESCRIPTION
A <k>gitattributes</k> file is a simple text file that gives <k>attributes</k> to pathnames.
.gitattributes 是用來告訴 Git 此專案要客製化的部份，為什麼要客製呢，因為 LFS 的使用條件就是你必須要告訴 Git，”這個檔案是 LFS 檔，請用 LFS 的方式處理“，但我們不需要自己設定，透過 git lfs 指令操作即可。

其實不只大型檔案，所有的檔案都可以用 .gitattributes 來告訴 Git 該怎麼處理這個檔案。
<a href="https://haway.30cm.gg/git-lfs/" class="whitebut ">Git LFS 原理</a>

Each line in <k>gitattributes</k> file is of form:

<k>pattern attr1 attr2 ...</k>

That is, a pattern followed by an attributes list,
separated by whitespaces.
Leading and trailing whitespaces are ignored.
Lines that begin with <em>#</em> are ignored.
Patterns that begin with a double quote are quoted in C style.
When the pattern matches the path in question, the attributes listed on the line are given to the path.


<h2>展示 10 大 Git 命令</h2>

<div id="show10gitstoc" class="toc"><a href="#show10gitstopic-0" target="_self">合并</a><br><a href="#show10gitstopic-1" target="_self">Fast-forward (—ff)</a><br><a href="#show10gitstopic-2" target="_self">No-fast-foward (—no-ff)</a><br><a href="#show10gitstopic-3" target="_self">合并冲突</a><br><a href="#show10gitstopic-4" target="_self">变基（Rebasing）</a><br><a href="#show10gitstopic-5" target="_self">交互式变基（Interactive Rebase）</a><br><a href="#show10gitstopic-6" target="_self">重置（Resetting）</a><br><a href="#show10gitstopic-7" target="_self">软重置</a><br><a href="#show10gitstopic-8" target="_self">硬重置</a><br><a href="#show10gitstopic-9" target="_self">还原（Reverting）</a><br><a href="#show10gitstopic-10" target="_self">拣选（Cherry-picking）</a><br><a href="#show10gitstopic-11" target="_self">取回（Fetching）</a><br><a href="#show10gitstopic-12" target="_self">拉取（Pulling）</a><br><a href="#show10gitstopic-13" target="_self">Reflog</a><br></div></center>

链接：
https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1

git merge、
git rebase、
git reset、
git revert、
git fetch、
git pull、
git reflog……
这些 git 命令执行的究竟是什么任务吗？

<img src="https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicpG4ibricDjhseFOGY3Qnc47QerrsJKNIjX2kiaUcH5vgEhxWiavM0YewFoJF5EicMrkf03sibglPia8esQ/640">

使用 Git 时，在头脑里可视化地想象它会非常有用：
当我执行一个特定命令时，这些分支会如何交互，又会怎样影响历史记录？
为什么当我在 master 上执行硬重启，force push 到原分支以及 rimraf 我们的 .git 文件夹时，我的同事哭了？
我觉得创建一些最常用且最有用的 Git 命令的可视化示例会是一个完美的用例！下面我将介绍的很多命令都有可选参数——你可以使用这些参数来改变对应命令的行为。

而我的示例只会涵盖命令的默认行为，而不会添加（或添加太多）可选配置！
<h3 id="show10gitstopic-0">合并</h3>
拥有多个分支是很方便的，这样可以将不同的新修改互相隔离开，而且还能确保你不会意外地向生产代码推送未经许可或破损的代码修改。

但一旦这些修改得到了批准许可，我们就需要将其部署到我们的生产分支中！
可将一个分支的修改融入到另一个分支的一种方式是执行 git merge。

Git 可执行两种类型的合并：
fast-forward 和 no-fast-forward。

现在你可能分不清，但我们马上就来看看它们的差异所在。

<h3 id="show10gitstopic-1">Fast-forward (—ff)</h3>
在当前分支相比于我们要合并的分支没有额外的提交（commit）时，可以执行 fast-forward 合并。

Git 很懒，首先会尝试执行最简单的选项：
fast-forward！这类合并不会创建新的提交，而是会将我们正在合并的分支上的提交直接合并到当前分支。

<img src="https://mmbiz.qpic.cn/mmbiz_gif/KmXPKA19gWicpG4ibricDjhseFOGY3Qnc47Kz7RJZr7Ixu1VbjVwTqIiactHDBAvQK7P5R1B60sic3XYd9SzXpo55cg/640">

完美！现在，我们在 dev 分支上所做的所有改变都合并到了 master 分支上。

那么 no-fast-forward 又是什么意思呢？
<h3 id="show10gitstopic-2">No-fast-foward (—no-ff)</h3>
如果你的当前分支相比于你想要合并的分支没有任何提交，那当然很好，但很遗憾现实情况很少如此！如果我们在当前分支上提交我们想要合并的分支不具备的改变，那么 git 将会执行 no-fast-forward 合并。

使用 no-fast-forward 合并时，Git 会在当前活动分支上创建新的 merging commit。

这个提交的父提交（parent commit）即指向这个活动分支，也指向我们想要合并的分支！
<img src="https://mmbiz.qpic.cn/mmbiz_gif/KmXPKA19gWicpG4ibricDjhseFOGY3Qnc47ql3frSRERzLickHicN04LoI3M9wYriac2wzJhQAyxJMKvC5rXdGoO4LRg/640">

没什么大不了的，完美的合并！现在，我们在 dev 分支上所做的所有改变都合并到了 master 分支上。

<h3 id="show10gitstopic-3">合并冲突</h3>
尽管 Git 能够很好地决定如何合并分支以及如何向文件添加修改，但它并不总是能完全自己做决定。

当我们想要合并的两个分支的同一文件中的同一行代码上有不同的修改，或者一个分支删除了一个文件而另一个分支修改了这个文件时，Git 就不知道如何取舍了。

在这样的情况下，Git 会询问你想要保留哪种选择？假设在这两个分支中，我们都编辑了 README.md 的第一行。

<img src="https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWicpG4ibricDjhseFOGY3Qnc475FpViatGnClianJn5r0Jbw6OQcueK4qy2PTEiaPjATdPg33BDmF4xbZkA/640">

如果我们想把 dev 合并到 master，就会出现一个合并冲突：
你想要标题是 Hello! 还是 Hey!？
当尝试合并这些分支时，Git 会向你展示冲突出现的位置。

我们可以手动移除我们不想保留的修改，保存这些修改，再次添加这个已修改的文件，然后提交这些修改。

<img src="https://mmbiz.qpic.cn/mmbiz_gif/KmXPKA19gWicpG4ibricDjhseFOGY3Qnc47CCw7uLSaAYZWvaf9uic6Lgiaic6oicPTiaWwJdBdj2gnu8kN9Jknib1hXgUQ/640">

完成！尽管合并冲突往往很让人厌烦，但这是合理的：
Git 不应该瞎猜我们想要保留哪些修改。

<h3 id="show10gitstopic-4">变基（Rebasing）</h3>
我们刚看到可通过执行 git merge 将一个分支的修改应用到另一个分支。

另一种可将一个分支的修改融入到另一个分支的方式是执行 git rebase。

git rebase 会将当前分支的提交复制到指定的分支之上。

<img src="https://mmbiz.qpic.cn/mmbiz_gif/KmXPKA19gWicpG4ibricDjhseFOGY3Qnc47FiaRJ1xKcJMYB3pBQMgiaLBzK6iaOLbuR4gH7BuBhPiaaiahmookDvqgpiaw/640">

完美，现在我们在 dev 分支上获取了 master 分支上的所有修改。

变基与合并有一个重大的区别：
Git 不会尝试确定要保留或不保留哪些文件。

我们执行 rebase 的分支总是含有我们想要保留的最新近的修改！这样我们不会遇到任何合并冲突，而且可以保留一个漂亮的、线性的 Git 历史记录。

上面这个例子展示了在 master 分支上的变基。

但是，在更大型的项目中，你通常不需要这样的操作。

git rebase 在为复制的提交创建新的 hash 时会修改项目的历史记录。

如果你在开发一个 feature 分支并且 master 分支已经更新过，那么变基就很好用。

你可以在你的分支上获取所有更新，这能防止未来出现合并冲突。

<h3 id="show10gitstopic-5">交互式变基（Interactive Rebase）</h3>
在为提交执行变基之前，我们可以修改它们！我们可以使用交互式变基来完成这一任务。

交互式变基在你当前开发的分支上以及想要修改某些提交时会很有用。

在我们正在 rebase 的提交上，我们可以执行以下 6 个动作：

reword：
修改提交信息；
edit：
修改此提交；
squash：
将提交融合到前一个提交中；
fixup：
将提交融合到前一个提交中，不保留该提交的日志消息；
exec：
在每个提交上运行我们想要 rebase 的命令；
drop：
移除该提交。

很棒！这样我们就能完全控制我们的提交了。

如果你想要移除一个提交，只需 drop 即可。

<img src="https://mmbiz.qpic.cn/mmbiz_gif/KmXPKA19gWicpG4ibricDjhseFOGY3Qnc47FDicRVQzOh1vlCQqE23BENZgIicDq2muUskwgibkZria8mlWEVb4pzicGbg/640">

如果你想把多个提交融合到一起以便得到清晰的提交历史，那也没有问题！
<img src="https://mmbiz.qpic.cn/mmbiz_gif/KmXPKA19gWicpG4ibricDjhseFOGY3Qnc47Sc3LdpTun3jytlmFwzxgCfZeQ5M0VyUH2CsCUbjlIM8hFBiabSqSpibw/640">

交互式变基能为你在 rebase 时提供大量控制，甚至可以控制当前的活动分支。

<h3 id="show10gitstopic-6">重置（Resetting）</h3>
当我们不想要之前提交的修改时，就会用到这个命令。

也许这是一个 WIP 提交或者可能是引入了 bug 的提交，这时候就要执行 git reset。

git reset 能让我们不再使用当前台面上的文件，让我们可以控制 HEAD 应该指向的位置。

<h3 id="show10gitstopic-7">软重置</h3>
软重置会将 HEAD 移至指定的提交（或与 HEAD 相比的提交的索引），而不会移除该提交之后加入的修改！
假设我们不想保留添加了一个 style.css 文件的提交 9e78i，而且我们也不想保留添加了一个 index.js 文件的提交 035cc。

但是，我们确实又想要保留新添加的 style.css 和 index.js 文件！这是软重置的一个完美用例。

<img src="https://mmbiz.qpic.cn/mmbiz_gif/KmXPKA19gWicpG4ibricDjhseFOGY3Qnc478EJlujcsicVPVaJJdS5IJxsWibc4Cx1gHwJfKZiciawXOyv7a00pXlJfFQ/640">

输入 git status 后，你会看到我们仍然可以访问在之前的提交上做过的所有修改。

这很好，这意味着我们可以修复这些文件的内容，之后再重新提交它们！
<h3 id="show10gitstopic-8">硬重置</h3>
有时候我们并不想保留特定提交引入的修改。

不同于软重置，我们应该再也无需访问它们。

Git 应该直接将整体状态直接重置到特定提交之前的状态：
这甚至包括你在工作目录中和暂存文件上的修改。

<img src="https://mmbiz.qpic.cn/mmbiz_gif/KmXPKA19gWicpG4ibricDjhseFOGY3Qnc47LykI1SUAn2jH2ap0PAwrkS56v1cI2iahkgc6xtjzQZxmJZ6XVzGzXTA/640">

Git 丢弃了 9e78i 和 035cc 引入的修改，并将状态重置到了 ec5be 的状态。

<h3 id="show10gitstopic-9">还原（Reverting）</h3>
另一种撤销修改的方法是执行 git revert。

通过对特定的提交执行还原操作，我们会创建一个包含已还原修改的新提交。

假设 ec5be 添加了一个 index.js 文件。

但之后我们发现其实我们再也不需要由这个提交引入的修改了。

那就还原 ec5be 提交吧！
<img src="https://mmbiz.qpic.cn/mmbiz_gif/KmXPKA19gWicpG4ibricDjhseFOGY3Qnc47pTrKzKv4jkibqvicsfSAPiaEQsn9sFIxlCo3D2uEXfupoztIpN6lTAgCQ/640">

完美！提交 9e78i 还原了由提交 ec5be 引入的修改。

在撤销特定的提交时，git revert 非常有用，同时也不会修改分支的历史。

<h3 id="show10gitstopic-10">拣选（Cherry-picking）</h3>
当一个特定分支包含我们的活动分支需要的某个提交时，我们对那个提交执行 cherry-pick！对一个提交执行 cherry-pick 时，我们会在活动分支上创建一个新的提交，其中包含由拣选出来的提交所引入的修改。

假设 dev 分支上的提交 76d12 为 index.js 文件添加了一项修改，而我们希望将其整合到 master 分支中。

我们并不想要整个 dev 分支，而只需要这个提交！
<img src="https://mmbiz.qpic.cn/mmbiz_gif/KmXPKA19gWicpG4ibricDjhseFOGY3Qnc47AuQfYgNQZReR1KdnSOcYCmRk64Cq7S46cqSiaTuCsKG3w0m8FiagfxFQ/640">

现在 master 分支包含 76d12 引入的修改了。

<h3 id="show10gitstopic-11">取回（Fetching）</h3>
如果你有一个远程 Git 分支，比如在 GitHub 上的分支，当远程分支上包含当前分支没有的提交时，可以使用取回。

比如当合并了另一个分支或你的同事推送了一个快速修复时。

通过在这个远程分支上执行 git fetch，我们就可在本地获取这些修改。

这不会以任何方式影响你的本地分支：
fetch 只是单纯地下载新的数据而已。

<img src="https://mmbiz.qpic.cn/mmbiz_gif/KmXPKA19gWicpG4ibricDjhseFOGY3Qnc47Bx4YIoUIIhIGEF5tXxJHSa5Xf0YnYFptBcZUSMjABVict7u4uNkPK0Q/640">

现在我们可以看到自上次推送以来的所有修改了。

这些新数据也已经在本地了，我们可以决定用这些新数据做什么了。

<h3 id="show10gitstopic-12">拉取（Pulling）</h3>
尽管 git fetch 可用于获取某个分支的远程信息，但我们也可以执行 git pull。

git pull 实际上是两个命令合成了一个：
git fetch 和 git merge。

当我们从来源拉取修改时，我们首先是像 git fetch 那样取回所有数据，然后最新的修改会自动合并到本地分支中。

<img src="https://mmbiz.qpic.cn/mmbiz_gif/KmXPKA19gWicpG4ibricDjhseFOGY3Qnc47NETOdP0oAicDBxb8z19moncy4NyzBbHpz8QnNFFWRNy2M9OUcrSvfCQ/640">

很好，我们现在与远程分支完美同步了，并且也有了所有最新的修改！
<h3 id="show10gitstopic-13">Reflog</h3>
每个人都会犯错，但犯错其实没啥！有时候你可能感觉你把 git repo 完全搞坏了，让你想完全删了了事。

git reflog 是一个非常有用的命令，可以展示已经执行过的所有动作的日志。

包括合并、重置、还原，基本上包含你对你的分支所做的任何修改。

<img src="https://mmbiz.qpic.cn/mmbiz_gif/KmXPKA19gWicpG4ibricDjhseFOGY3Qnc474QeRST8xHPslv0faicoHF7k1PsvgAzIfFw5qocicNuLA0HS19ORdQyGQ/640">

如果你犯了错，你可以根据 reflog 提供的信息通过重置 HEAD 来轻松地重做！
假设我们实际上并不需要合并原有分支。

当我们执行 git reflog 命令时，我们可以看到这个 repo 的状态在合并前位于 HEAD@{1}。

那我们就执行一次 git reset，将 HEAD 重新指向在 HEAD@{1} 的位置。

<img src="https://mmbiz.qpic.cn/mmbiz_gif/KmXPKA19gWicpG4ibricDjhseFOGY3Qnc47zdHjpJwlq4oLrOBmMgJLNGSjKXpJQvIzzPnrw2pbtF1X4aDcdxW11w/640">

我们可以看到最新的动作已被推送给 reflog。





<br><br>
<br>
<br>
<br>
<script type='text/javascript' src='readbook.js'></script>
<script>
var lazyLoadInstance = new LazyLoad({
    elements_selector: ".lazy"
    // ... more custom settings?
});
</script>

</body>
</html>
