<base target="_blank"><html><head><title>Git Notes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script type='text/javascript' src='../mainscript.js'></script>
<style>
body{width:80%;margin-left: 10%; font-size:22px;}
strong, h1, h2 {color: gold;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px;}
</style></head><body onkeypress="chkKey()"><center>
<h1>Git Notes</h1>
<a href="git-config.html" class="whitebut ">git-config</a>
<a href="git exercise.html" class="whitebut ">git exercise</a>
<br>
<div id="toc"></div></center>
<pre>
<br>
<h2>LF will be replaced by CRLF</h2>
<a href="https://stackoverflow.com/questions/5834014/lf-will-be-replaced-by-crlf-in-git-what-is-that-and-is-it-important">LF will be replaced by CRLF</a>
<br>
Git can auto-converting CRLF line endings into LF when you add a file to the index. Turn on this functionality with the core.autocrlf setting. 
If you’re on a Windows machine, set it to true – this converts LF endings into CRLF when you check out code:

git config --global core.autocrlf true
git config --global core.autocrlf false
<br>
<h2>Git for Absolute Beginners</h2>
<a href="Git for Absolute Beginners.html">Git for Absolute Beginners</a>

<h2>Activity: Use the GitHub Desktop client</h2>
<a href="https://idratherbewriting.com/learnapidoc/pubapis_version_control.html" class="whitebut ">Version control systems</a>
<a href="https://idratherbewriting.com/learnapidoc/pubapis_github_desktop_client.html" class="whitebut ">Use the GitHub Desktop client</a>

Although most developers use the command line when working with version control systems, there are many GUI clients available that can potentially simplify the process. 
GUI clients might be especially helpful when you’re trying to see what has changed in a file since the GUI can quickly highlight and indicate the changes taking place.

<a href="#Follow">Follow a typical workflow with a GitHub project</a>
<a href="#Create">Create a branch</a>
<a href="#Merge development">Merge the development branch into master</a>
<a href="#Merge">Merge the branch through a pull request</a>
<a href="#Managing">Managing merge conflicts</a>
<a href="#Conclusion">Conclusion</a>

<h3 id="Follow">Follow a typical workflow with a GitHub project</h3>
In this tutorial, you’ll use GitHub Desktop to manage the Git workflow.

Rather than working in a GitHub wiki (as you did in the <a href="https://idratherbewriting.com/learnapidoc/pubapis_github_wikis.html">previous GitHub tutorial</a>), you’ll work in a regular Git repository. 
This is because GitHub wikis have some limitations when it comes to making pull requests.

To set up your Git repo using the GitHub Desktop client:

<ol>
First, download and install <a href="https://desktop.github.com/">GitHub Desktop</a>. 
Launch the app and sign in. 
(You should already have a GitHub account from <a href="https://idratherbewriting.com/learnapidoc/pubapis_github_wikis.html">previous tutorials</a>, but if not, create one.)
Go to <a href="https://github.com">Github.com</a> and browse to the repository you created in the <a href="https://idratherbewriting.com/learnapidoc/pubapis_github_wikis.html">GitHub tutorial</a>, but not the wiki. 
Just go to the main repo. 
(If you didn’t do the previous activity, just create a new repository.)

While viewing your GitHub repo in the browser, click Clone or download and select Open in Desktop.

<img src="https://idratherbewritingmedia.com/images/api/open-in-github-desktop.png">
Open in GitHub Desktop

Open GitHub Desktop client and go to File &gt; Clone Repository.
In the confirmation dialog, select Open GitHub Desktop.app. 
GitHub Desktop should launch with a “Clone a Repository” dialog box about where to clone the repository. 
If desired, you can change the Local Path.

Click the URL tab, and then paste in the clone URL. 
In the Local Path field, select where you want the repo cloned. 
For example:

<img src="https://idratherbewritingmedia.com/images/api/localpathgithubdesktop.png">
Selecting paths for the repo in GitHub Desktop

Click Clone.
Go into the repository where GitHub Desktop cloned the repo (use your Finder or browse the folders with Finder or Explorer) and either add a simple text file with some content or make a change to an existing file.

Go back to GitHub Desktop. 
You’ll see the new file you added in the list of uncommitted changes on the left.

<img src="https://idratherbewritingmedia.com/images/api/github-desktop-file-uncommitted-changes.png">
Uncommitted changes shown
In the list of changed files, the green + means you’ve added a new file. 
A yellow circle means you’ve modified an existing file.



In the lower-left corner of the GitHub Desktop client (where it says “Summary” and “Description”), type a commit message, and then click Commit to master.

When you commit the changes, the left pane no longer shows the list of uncommitted changes. 
However, you’ve committed the changes only locally. 
You still have to push the commit to the remote (origin) repository. 
(“origin” is the alias name that refers to the remote repository.)



Click Push origin at the top.

You’ll see GitHub Desktop show that it’s “Pushing to origin.”

<img src="https://idratherbewritingmedia.com/images/api/pushingtoorigin.png">


</ol>
If you view your repository online, you’ll see that the change you made has been pushed to the master branch on origin. 
You can also click the History tab in the GitHub Desktop client (instead of the Changes tab), or go to View &gt; Show History to see the changes you previously committed.

Although I prefer to use the terminal instead of the GitHub Desktop GUI, the GUI gives you an easier visual experience to see the changes made to a repository. 
You can use both the command line and Desktop client in combination, if you want.

<h3 id="Create">Create a branch</h3>
Now let’s create a branch, make some changes, and see how the changes are specific to that branch.

<ol>

In the GitHub Desktop client, go to Branch &gt; New Branch and create a new branch. 
Call it “development” branch, and click Create Branch.

<img src="https://idratherbewritingmedia.com/images/api/creatingnewbranchgithubdesktop.png">
Creating a new branch
When you create the branch, you’ll see the Current branch drop-down menu indicate that you’re working in that branch. 
Creating a branch copies the existing content (from the branch you’re currently in, <em>master</em>) into the new branch (<em>development</em>).

<img src="https://idratherbewritingmedia.com/images/api/github-desktop-current-branch.png">
Working in a branch

Using Finder or Explorer, browse to the file you created earlier and make a change to it, such as adding a new line with some text. 
Save the changes.

Return to GitHub Desktop and notice that on the Changes tab, you have new modified files.

<img src="https://idratherbewritingmedia.com/images/api/github-desktop-file-changes.png">
New files modified
The file changes show deleted lines in red and new lines in green. 
The colors help you see what changed.



Commit the changes using the options in the lower-left corner, and click Commit to development.



Click Publish branch (on the top of the GitHub Desktop window) to make the local branch also available on origin (GitHub). 
(Remember, there are usually two versions of a branch — the local version and the remote version.)


Switch back to your master branch (using the Branch drop-down option at the top of the GitHub Desktop client). 
Then look at your file (in your text editor, such as Sublime text). 
Note how the file changes you made while editing in the development branch don’t appear in your master branch.
</ol>
You usually create a new branch when you’re making extensive changes to your content. 
For example, suppose you want to revamp a section (“Section X”) in your docs. 
However, you might want to publish other updates before publishing the extensive changes in Section X. 
If you were working in the same branch, it would be difficult to selectively push updates on a few files outside of Section X without pushing updates you’ve made to files in Section X as well.

Through branching, you can confine your changes to a specific version that you don’t push live until you’re ready to merge the changes into your master branch.

<h3 id="Merge development">Merge the development branch into master</h3>
Now let’s merge the development branch into the master branch.

<ol>
In the GitHub Desktop client, switch to the branch you want to merge the development branch into. 
From the branch selector, select the master branch.
Go to Branch &gt; Merge into Current Branch.

In the merge window, select the development branch, and then click Merge development into master.

<img src="https://idratherbewritingmedia.com/images/api/mergeintomastergithubclient.png">
Merging into master
If you look at your changed file, you should see the changes in the master branch.



Then click Push origin to push the changes to origin.

You will now see the changes reflected on the file on GitHub.


</ol>



<h3 id="Merge">Merge the branch through a pull request</h3>
Now let’s merge the development branch into the master using a pull request workflow. 
We’ll pretend that we’ve cloned a repo managed by engineers, and we want to have the engineers merge in the development branch. 
(In other words, we might not have rights to merge branches into the master.) To do this, we’ll create a pull request.

<ol>
Just as you did in the previous section, switch to the development branch, make some updates to the content in a file, and then save and commit the changes. 
After committing the changes, click Push origin to push your changes to the remote version of the development branch on GitHub.

In the GitHub Desktop client, while you have development branch selected, go to Branch &gt; Create Pull Request.

GitHub opens in the browser with the Pull Request form opened.

<img src="https://idratherbewritingmedia.com/images/api/mergepullrequestgithubdesktop.png">
Pull request
The left-facing arrow (pointing from the development branch towards the master) indicates that the pull request (“PR”) wants to merge the development branch into the master branch.



Describe the pull request, and then click Create pull request.



At this point, engineers would get an email request asking for them to merge in the edits. 
Play the part of the engineer by going to the Pull requests tab (on GitHub) to examine and confirm the merge request. 
As long as the merge request doesn’t pose any conflicts, you’ll see a Merge pull request button.

<img src="https://idratherbewritingmedia.com/images/api/mergepullrequest.png">
Confirm merge request


To see what changes you’re merging into master, you can click the Files changed tab (which appears on the secondary navigation bar near the top). 
Then click Merge pull request to merge in the branch, and click Confirm merge to complete the merge.



Now let’s get the updates you merged into the masterbranch online into your local copy. 
In your GitHub Desktop GUI client, select the master branch, and then click the Fetch origin button. 
Fetch gets the latest updates from origin but doesn’t update your local working copy with the changes.

After you click Fetch origin, the button changes to Pull Origin.



Click Pull Origin to update your local working copy with the fetched updates.

Now check your files and notice that the updates that were originally in the development branch now appear in master.


</ol>
For a more detailed tutorial in making pull requests using the GitHub interface, see <a href="https://idratherbewriting.com/learnapidoc/pubapis_github_pull_requests.html">Pull request workflows through GitHub</a>. 
I include an extensive tutorial with pull requests because it will likely be a common workflow if you are <a href="https://idratherbewriting.com/learnapidoc/docapis_find_open_source_project.html">contributing to an open-source project</a>.



<h3 id="Managing">Managing merge conflicts</h3>
Suppose you make a change on your local copy of a file in the repository, and someone else changes the same file using the online GitHub.com browser interface. 
The changes conflict with each other. 
What happens?

When you click Push origin from the GitHub Desktop client, you’ll see a message saying that the repository has been updated since you last pulled:

<blockquote>
“The repository has been updated since you last pulled. 
Try pulling before pushing.”

</blockquote>
The button that previously said “Push origin” now says “Pull origin.” Click Pull origin. 
You now get another error message that says,

<blockquote>
“We found some conflicts while trying to merge. 
Please resolve the conflicts and commit the changes.”

</blockquote>
If you decide to commit your changes, you’ll see a message that says:

<blockquote>
“Please resolve all conflicted files, commit, and then try syncing again.”

</blockquote>
The GitHub Desktop client displays an exclamation mark next to files with merge conflicts. 
Open up a conflict file and look for the conflict markers (&lt;&lt;&lt;&lt;&lt;&lt;&lt; and &gt;&gt;&gt;&gt;&gt;&gt;&gt;). 
For example, you might see this:

&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
This is an edit I made locally.
=======
This is an edit I made from the browser.
&gt;&gt;&gt;&gt;&gt;&gt;&gt; c163ead57f6793678dd41b5efeef372d9bd81035

(From the command line, you can also run git status to see which files have conflicts.) The content in HEAD shows your local changes. 
The content below the ======= shows changes made by elsewhere.

Fix all the conflicts by adjusting the content between the content markers and then deleting the content markers. 
For example, update the content to this:

This is an edit I made locally.

Now you need to re-add the file to Git again. 
In the GitHub Desktop client, commit your changes to the updated files. 
Then click Push origin. 
The updates on your local get pushed to the remote without any more conflicts.

<h3 id="Conclusion">Conclusion</h3>
The more you use GitHub, the more familiar you’ll become with the workflows you need. 
Git is a robust, powerful collaboration platform, and there are many commands and workflows and features that you could adopt for a variety of scenarios. 
Despite Git’s variety of commands and workflows, most likely the scenarios you’ll actually use are somewhat limited in scope and learnable without too much effort. 
Pretty soon, these workflows will become automatic.

Although we’ve been using the GitHub Desktop client for this exercise, you can do all of this through the command line, and you’ll probably find it preferable that way. 
However, the GitHub Desktop client can be a good starting point as you transition into becoming more of a Git power user.

<h2>git always asking for user credentials</h2>
<a href="https://www.freecodecamp.org/news/how-to-fix-git-always-asking-for-user-credentials/" class="whitebut ">fix git always asking for user credentials</a>

git remote set-url origin git@github.com:williamkpchan

Look in Git configuration file.
git config --list

<h2>Git error: </h2>
“Please make sure you have the correct access rights and the repository exists”

reason: git URL might have changed. 

action:
# View existing remotes
git remote -v

# Change the 'origin' remote's URL
git remote set-url origin https://github.com/williamkpchan/williamkpchan.github.io

<h2>update an existing github repo from a different computer</h2>

Run
git clone https://github.com/your/repo
to clone your project on your computer.
It will create a new folder containing your Android project

Copy your changed files in this new folder

You can now commit your changes from this folder

If it is your repository
If the repository belongs to you, you can start committing changes on the new computer and then pushing them to master:

git push -u origin master
The origin is the name of the remote directory.
If you use the clone command on your own repository the origin of the cloned repository will automatically be your github repository.

It is essential that if you clone a repository so that it is on two different computers, you use the pull command (see below) before you start working. Otherwise, you will put one of your repositories out of synch with the “master” repository and you will need to use the “merge” command, which can be rather tedious.

<h2>Git server</h2>
<a href="https://stackoverflow.com/questions/8390828/how-can-i-have-github-on-my-own-server" class="whitebut ">Github on my own server</a>
<a href="https://github.com/patrikf/glip" class="whitebut ">Glip for PHP to view a git repo</a>

<h2>GitHub Actions</h2>
<a href="https://docs.github.com/en/actions" class="whitebut ">GitHub Actions</a>

usage: git [--version] [--help] [-C &lt;path>] [-c name=value]
           [--exec-path[=&lt;path>]] [--html-path] [--man-path] [--info-path]
           [-p | --paginate | --no-pager] [--no-replace-objects] [--bare]
           [--git-dir=&lt;path>] [--work-tree=&lt;path>] [--namespace=&lt;name>]
           &lt;command> [&lt;args>]

These are common Git commands used in various situations:

start a working area (see also: git help tutorial)
   clone      Clone a repository into a new directory
   init       Create an empty Git repository or reinitialize an existing one

work on the current change (see also: git help everyday)
   add        Add file contents to the index
   mv         Move or rename a file, a directory, or a symlink
   reset      Reset current HEAD to the specified state
   rm         Remove files from the working tree and from the index

examine the history and state (see also: git help revisions)
   bisect     Use binary search to find the commit that introduced a bug
   grep       Print lines matching a pattern
   log        Show commit logs
   show       Show various types of objects
   status     Show the working tree status

grow, mark and tweak your common history
   branch     List, create, or delete branches
   checkout   Switch branches or restore working tree files
   commit     Record changes to the repository
   diff       Show changes between commits, commit and working tree, etc
   merge      Join two or more development histories together
   rebase     Reapply commits on top of another base tip
   tag        Create, list, delete or verify a tag object signed with GPG

collaborate (see also: git help workflows)
   fetch      Download objects and refs from another repository
   pull       Fetch from and integrate with another repository or a local branch
   push       Update remote refs along with associated objects

'git help -a' and 'git help -g' list available subcommands and some
concept guides. See 'git help &lt;command>' or 'git help &lt;concept>'
to read about a specific subcommand or concept.

<h2>batch file push to github with username and password</h2>
https://coolaj86.com/articles/vanilla-devops-git-credentials-cheatsheet/

git config --global user.name "williamkpchan"
git config --global user.email "williamkpchan@gmail.com"
git init
git status
git push
pause

<h2>Git to avoid typing username password</h2>
Two approaches can be used. 

SSH keys are a way to identify trusted computers, without involving passwords. 
One needs to generate an SSH key and add the public key to your GitHub account. 
A guide on how to set up SSH key can be found <a href="https://help.github.com/articles/generating-ssh-keys/" rel="noopener nofollow">here</a>
But this is not the main focus for this article. 

The key question remains:
<strong>Is there a way to skip typing my username and/password when using HTTPS in GitHub?</strong>
The answer is yes. 
This is done by using <em>credential helpers. 
</em>And this is the second approach. 
Credential helpers basically tells Git to remember your GitHub username and password every time it talks to GitHub. 
The syntax is given by:
git config credential.https://example.com.username myusername
git config credential.helper “$helper $options”
Therefore, credential helpers are external programs from which Git can request both usernames and passwords. 
Credential helpers are in two forms: <em>cache</em> which caches credentials in memory for a short period of time, and <em>store</em> which basically stores credentials indefinitely on disk.
Once you have selected the helper, you can tell Git to use it by putting its name into the credential.helper variable.

Find a helper:
git help -a | grep credential-credential-foo
2. Read its description.
 git help credential-foo
3. Tell Git to use it.
git config — global credential.helper foo
Assuming you have a remote with the following URL<strong><em> https://github.com/adambajumba/MestEIT</em></strong>, update the Git configuration to use the helper whenever it needs authentication steps:
$ git config --global \credential.https://github.com/myusername/mysecretproject.username \your_github_account_name$ git config --global \credential.https://github.com/adambajumba/MestEIT.adambajumba \IsaacJumba
Note that the remote URL is appended with a trailing .username fragment which becomes the key and the GitHub username becomes the value.Once the username is set, map the helper: And you are done! That easy, right?
$ git config --global core.askpass ~/.git_credential_helper.rb
An example of how it works would be:
$ git config credential.helper store
$ git push http://example.com/repo.git
Username: &lt;type your username&gt;
Password: &lt;type your password&gt;<strong>[several days later]</strong>
$ git push http://example.com/repo.git
[your credentials are used automatically]
In conclusion, the credential helper does not work in all versions of git but from version 1.8 and above.

<h2>Git Tools - Credential Storage</h2>
If you use the SSH transport for connecting to remotes, it’s possible for you to have a key without a passphrase, which allows you to securely transfer data without typing in your username and password.
However, this isn’t possible with the HTTP protocols – every connection needs a username and password.
This gets even harder for systems with two-factor authentication, where the token you use for a password is randomly generated and unpronounceable.

Fortunately, Git has a credentials system that can help with this.
Git has a few options provided in the box:
The default is not to cache at all.
Every connection will prompt you for your username and password.

The “cache” mode keeps credentials in memory for a certain period of time.
None of the passwords are ever stored on disk, and they are purged from the cache after 15 minutes.
The “store” mode saves the credentials to a plain-text file on disk, and they never expire.
This means that until you change your password for the Git host, you won’t ever have to type in your credentials again.

The downside of this approach is that your passwords are stored in cleartext in a plain file in your home directory.
If you’re using a Mac, Git comes with an “osxkeychain” mode, which caches credentials in the secure keychain that’s attached to your system account.
This method stores the credentials on disk, and they never expire, but they’re encrypted with the same system that stores HTTPS certificates and Safari auto-fills.
If you’re using Windows, you can install a helper called “Git Credential Manager for Windows.”

This is similar to the “osxkeychain” helper described above, but uses the Windows Credential Store to control sensitive information.
It can be found at <a href="https://github.com/Microsoft/Git-Credential-Manager-for-Windows">https://github.com/Microsoft/Git-Credential-Manager-for-Windows</a>.
You can choose one of these methods by setting a Git configuration value:
<code>$ git config --global credential.helper cache</code>

Some of these helpers have options.
The “store” helper can take a <code>--file &lt;path&gt;</code> argument, which customizes where the plain-text file is saved (the default is <code>~/.git-credentials</code>).
The “cache” helper accepts the <code>--timeout &lt;seconds&gt;</code> option, which changes the amount of time its daemon is kept running (the default is “900”, or 15 minutes).
Here’s an example of how you’d configure the “store” helper with a custom file name:

<code>$ git config --global credential.helper 'store --file ~/.my-credentials'</code>
Git even allows you to configure several helpers.
When looking for credentials for a particular host, Git will query them in order, and stop after the first answer is provided.
When saving credentials, Git will send the username and password to <strong>all</strong> of the helpers in the list, and they can choose what to do with them.

Here’s what a <code>.gitconfig</code> would look like if you had a credentials file on a thumb drive, but wanted to use the in-memory cache to save some typing if the drive isn’t plugged in:
<code>[credential]
    helper = store --file /mnt/thumbdrive/.git-credentials
    helper = cache --timeout 30000</code>

<h3>Under the Hood</h3>
How does this all work?
Git’s root command for the credential-helper system is <code>git credential</code>, which takes a command as an argument, and then more input through stdin.
This might be easier to understand with an example.

Let’s say that a credential helper has been configured, and the helper has stored credentials for <code>mygithost</code>.
Here’s a session that uses the “fill” command, which is invoked when Git is trying to find credentials for a host:
<code>$ git credential fill <b>(1)</b>
protocol=https <b>(2)</b>
host=mygithost
<b>(3)</b>
protocol=https <b>(4)</b>
host=mygithost
username=bob
password=s3cre7

$ git credential fill <b>(5)</b>
protocol=https
host=unknownhost
Username for 'https://unknownhost': bob
Password for 'https://bob@unknownhost':
protocol=https
host=unknownhost
username=bob
password=s3cre7</code>

This is the command line that initiates the interaction.
Git-credential is then waiting for input on stdin.
We provide it with the things we know: the protocol and hostname.
A blank line indicates that the input is complete, and the credential system should answer with what it knows.
Git-credential then takes over, and writes to stdout with the bits of information it found.

If credentials are not found, Git asks the user for the username and password, and provides them back to the invoking stdout (here they’re attached to the same console).
The credential system is actually invoking a program that’s separate from Git itself; which one and how depends on the <code>credential.helper</code> configuration value.
There are several forms it can take:
<table>
<colgroup><col style="width: 50%;"><col style="width: 50%;">
</colgroup>
<thead><tr><th>Configuration Value</th><th>Behavior</th></tr></thead>
<tbody>
<tr><td><code>foo</code></td><td>Runs <code>git-credential-foo</code></td></tr>
<tr><td><code>foo -a --opt=bcd</code></td><td>Runs <code>git-credential-foo -a --opt=bcd</code></td></tr>
<tr><td><code>/absolute/path/foo -xyz</code></td><td>Runs <code>/absolute/path/foo -xyz</code></td></tr>
<tr><td><code>!f() { echo "password=s3cre7"; }; f</code></td><td>Code after <code>!</code> evaluated in shell</td></tr>
</tbody>
</table>

So the helpers described above are actually named <code>git-credential-cache</code>, <code>git-credential-store</code>, and so on, and we can configure them to take command-line arguments.
The general form for this is “git-credential-foo [args] &lt;action&gt;.”
The stdin/stdout protocol is the same as git-credential, but they use a slightly different set of actions:
<code>get</code> is a request for a username/password pair.
<code>store</code> is a request to save a set of credentials in this helper’s memory.
<code>erase</code> purge the credentials for the given properties from this helper’s memory.
For the <code>store</code> and <code>erase</code> actions, no response is required (Git ignores it anyway).
For the <code>get</code> action, however, Git is very interested in what the helper has to say.

If the helper doesn’t know anything useful, it can simply exit with no output, but if it does know, it should augment the provided information with the information it has stored.
The output is treated like a series of assignment statements; anything provided will replace what Git already knows.
Here’s the same example from above, but skipping git-credential and going straight for git-credential-store:
<code>$ git credential-store --file ~/git.store store <b>(1)</b>

protocol=https
host=mygithost
username=bob
password=s3cre7
$ git credential-store --file ~/git.store get <b>(2)</b>
protocol=https
host=mygithost
username=bob <b>(3)</b>
password=s3cre7</code>

Here we tell <code>git-credential-store</code> to save some credentials: the username “bob” and the password “s3cre7” are to be used when <code><a href="https://mygithost">https://mygithost</a></code> is accessed.
Now we’ll retrieve those credentials.
We provide the parts of the connection we already know (<code><a href="https://mygithost">https://mygithost</a></code>), and an empty line.

<code>git-credential-store</code> replies with the username and password we stored above.
Here’s what the <code>~/git.store</code> file looks like:
<code>https://bob:s3cre7@mygithost</code>
It’s just a series of lines, each of which contains a credential-decorated URL.

The <code>osxkeychain</code> and <code>wincred</code> helpers use the native format of their backing stores, while <code>cache</code> uses its own in-memory format (which no other process can read).
<h3>A Custom Credential Cache</h3>
Given that <code>git-credential-store</code> and friends are separate programs from Git, it’s not much of a leap to realize that <em>any</em> program can be a Git credential helper.
The helpers provided by Git cover many common use cases, but not all.

For example, let’s say your team has some credentials that are shared with the entire team, perhaps for deployment.
These are stored in a shared directory, but you don’t want to copy them to your own credential store, because they change often.
None of the existing helpers cover this case; let’s see what it would take to write our own.
There are several key features this program needs to have:

The only action we need to pay attention to is <code>get</code>; <code>store</code> and <code>erase</code> are write operations, so we’ll just exit cleanly when they’re received.
The file format of the shared-credential file is the same as that used by <code>git-credential-store</code>.
The location of that file is fairly standard, but we should allow the user to pass a custom path just in case.
Once again, we’ll write this extension in Ruby, but any language will work so long as Git can execute the finished product.

Here’s the full source code of our new credential helper:
<code>#!/usr/bin/env ruby
require 'optparse'
path = File.expand_path '~/.git-credentials' # <b>(1)</b>

OptionParser.new do |opts|
    opts.banner = 'USAGE: git-credential-read-only [options] &lt;action&gt;'
    opts.on('-f', '--file PATH', 'Specify path for backing store') do |argpath|
        path = File.expand_path argpath
    end
end.parse!
exit(0) unless ARGV[0].downcase == 'get' # <b>(2)</b>
exit(0) unless File.exists? path

known = {} # <b>(3)</b>
while line = STDIN.gets
    break if line.strip == ''
    k,v = line.strip.split '=', 2
    known[k] = v
end
File.readlines(path).each do |fileline| # <b>(4)</b>
    prot,user,pass,host = fileline.scan(/^(.*?):\/\/(.*?):(.*?)@(.*)$/).first

    if prot == known['protocol'] and host == known['host'] and user == known['username'] then
        puts "protocol=#{prot}"
        puts "host=#{host}"
        puts "username=#{user}"
        puts "password=#{pass}"
        exit(0)
    end
end</code>

Here we parse the command-line options, allowing the user to specify the input file.
The default is <code>~/.git-credentials</code>.
This program only responds if the action is <code>get</code> and the backing-store file exists.
This loop reads from stdin until the first blank line is reached.

The inputs are stored in the <code>known</code> hash for later reference.
This loop reads the contents of the storage file, looking for matches.
If the protocol, host, and username from <code>known</code> match this line, the program prints the results to stdout and exits.
We’ll save our helper as <code>git-credential-read-only</code>, put it somewhere in our <code>PATH</code> and mark it executable.

Here’s what an interactive session looks like:
<code>$ git credential-read-only --file=/mnt/shared/creds get
protocol=https
host=mygithost
username=bob
protocol=https
host=mygithost
username=bob
password=s3cre7</code>

Since its name starts with “git-”, we can use the simple syntax for the configuration value:
<code>$ git config --global credential.helper 'read-only --file /mnt/shared/creds'</code>
As you can see, extending this system is pretty straightforward, and can solve some common problems for you and your team.


<h2>use a github repo from a same account but different computers</h2>

supplying --force as an argument to the git push command

first fetch those changes from the remote, and then pull them into your local repository on computer 1. 

$ git fetch origin
$ git pull origin master
In these commands, origin is the name of your github remote and master is the name of the branch you are currently tracking. 

These names can be changed, but these are the defaults which appear to be the names in your case.

Note, you will likely need to revert the new changes you made to computer 1. 

Git will have a hard time trying to merge the changes from computer 2 with the changes you made to computer 1 when you were trying to commit the second time.

pull is fetch + merge.
If you've already run fetch, there's no need to run pull, merge should be enough.
Or just run pull without fetching first, as it fetches on its own.

<h2>Use Multiple GitHub Accounts With One Computer</h2>
<h3>How to set up and change SSH keys to use multiple GitHub accounts on one machine</h3>
I currently have two GitHub accounts: a personal and a work one. 
Obviously, my work computer is set up with my work account. 

I wanted to figure out how to push to GitHub with my personal account whenever I’m working on side projects via my work computer.
At first glance, for the seemingly simple task of switching between two accounts, the process seemed a little involved. 

But once you break things down into steps, it’s less daunting.
<h3>Quick Note on <strong><em>SSH</em></strong></h3>
<a href="https://www.ssh.com/ssh/protocol/#strong-authentication-with-ssh-keys">SSH</a><strong> </strong>(or secure shell) is a network protocol which, among <a href="https://www.ssh.com/ssh/protocol/#typical-uses-of-the-ssh-protocol">other things</a>, allows one computer to communicate with another over an unsecured network like the internet.
Without encryption, data travels over the web in plain text form. 
Consequently, it would be easy for someone to intercept valuable data, like user names or passwords, for wicked intent.SSH allows encryption of your data by way of a <a href="https://www.ssh.com/ssh/tunneling/"><em>tunnel</em></a>, which permits your computer to securely connect to another.
This is done via the use of <a href="https://www.ssh.com/ssh/key/">SSH keys</a> and <a href="https://en.wikipedia.org/wiki/Public-key_cryptography">public-key cryptography </a>(aka asymmetric cryptography) which are used for authentication purposes between said computers, in order to decrypt the information being shared.
<a href="https://www.youtube.com/watch?v=AQDCe585Lnc">Here’s a great video</a> explaining the concept of asymmetric cryptography further.SSH is commonly implemented using the client-server model.
<img src="https://miro.medium.com/max/1400/1*On6fpv0NVHnmqZs7Dn6DqQ.png">
Client-server model with asymmetric cryptography
When running any remote commands from our computer(e.g., git push or git pull) to a remote repository (GitHub), it’s this protocol that enables us to do so without having to supply a password and username each time.
Let’s now look at the configuration for it.
<h3>Configuration</h3>The configuration can essentially be broken down into four steps:
Generate an SSH key for the new account.
Attach this new key to your GitHub account.
Register the new key with the SSH agent.
Create an SSH config file.

<h3><strong>Step 1. Generate an <em>SSH</em> key for the new account</strong></h3>Using the SSH protocol, we’ll have to generate a key for any new account we’d like to use.
Hop onto your terminal, run the following command, and attach your GitHub email address:$ ssh-keygen -t rsa -C "uremail@gmail.com" A new key pair will be generated. 
At this point, you want to be careful not to overwrite your existing key pair, which would look like the following:({your home Directory}/.ssh/id_rsa):Instead, you can copy the directory and modify the file name to include your account name, as in the screenshot below:
<img src="https://miro.medium.com/max/875/1*tKXjK-bNH8wwkKOFJT_6tg.png">
You will then be prompted to enter a passphrase. 
Your new SSH key will be found at a directory similar to this:{your home Directory}/.ssh/id_rsa_uraccount
<h3><strong>Step 2. Attach the new key to your GitHub account</strong></h3>We’ve just created a public key, and now we need to allow our GitHub account to trust it. 
This allows you to not have to authenticate every time you run a remote command (git push, git pull).
Copy the public key via the following command <code>pbcopy &lt; ~/.ssh/id_rsa.pub</code> and then log in to your personal GitHub account:
Go to <code>Settings</code>.
From the left side navigation, click <code>SSH and GPG keys</code>.
Click on <code>New SSH key</code>, name it (it's a good idea to name it after the computer you’re using it in), and paste the key you previously copied.
Click <code>Add key</code>.

<h3><strong>Step 3. Register the new key with the <em>SSH agent</em></strong></h3>We now need to register our key with the <a href="https://www.ssh.com/ssh/agent">SSH agent</a>. 

The SSH agent keeps track of user identity keys and passphrases and works as an additional layer of security.
In your terminal, write the command <code>ssh-add</code> and add the path to the files containing your keys. 
As shown below, we are adding keys for our main account and the second account we just created.ssh-add ~/.ssh/id_rsassh-add ~/.ssh/id_rsa_uraccount
<h3><strong>Step 4. Create an <em>SSH</em> config file</strong></h3>The SSH config file allows us to set configuration rules that will specify when we want to push to our work account versus our personal account. 

This is done by defining which identity file to use ( the ones we’ve added to our SSH agent ) on which domain.
If the file has already been created, it should be at <code>~/.ssh/config</code>. 
But by default, it will not exist, so we’ll need to create it by running the command <code>touch ~/.ssh/config</code>.
You can use any text editor or IDE to open and edit the file. 
I went with the terminal’s text editor <a href="https://www.vim.org/">vim</a><strong>. 

</strong>I don’t use it frequently, and it does have a bit of a learning curve, so I tend to use a <a href="https://devhints.io/vim">cheat sheet</a> to navigate through it<strong>.
</strong>To open the file, use <code>vim config</code>.# Account 1 (work or personal) - the default configHost github.com   HostName github.com   User git   IdentityFile ~/.ssh/id_rsa   # Account 2 (work or personal) - the config we are addingHost github-uraccount      HostName github.com   User git   IdentityFile ~/.ssh/id_rsa_uraccountThe top part is the default configuration. 
It comprises the following:<ul><li>the<strong> host</strong>(<code>github.com</code>)
Its <strong>host name </strong>(<code>github.com</code>)
a <strong>user ID </strong>(<code>git</code>)
its<strong> identity file</strong> (<code>~/.ssh/id_rsa</code>)</li></ul>We can basically duplicate the default configuration; we’ll only need to changes two things: the host (<code>github-uraccount</code>) and the identity file (to the key we created earlier, <code>~/.ssh/id_rsa_uraccount</code>).
And that should do it. 
Save and close the file using <code>:wq</code> (if you are using vim).
<h3>Create a new repository</h3>Now that we’re done with the configuration, let’s push to GitHub with our new account.
In your project’s working directory, start by initializing git using <code>git init </code>then go to GitHub and create a new repository.
When you get to the instructions under Existing Git Repo, you’d normally just copy and paste the commands to your terminal to add the repo as the remote to your local repo, but for this case, we need to replace “github.com” with the host we set up in our config file earlier. 

So instead of the default host <code>git@github.com</code>, we use <code>git@github-uraccount</code>.git remote add origin git@github-uraccount:uraccount/repo_name.gitNow you can push to GitHub using, for example, the following:git add .git commit -m "Initial commit"git push -u origin master
<h3>Associate your commits with a particular username</h3>For a single repository, if you’d like to change the name associated with your commits, you’ll also need to change your user name and email to reflect the GitHub account you want the repository to be associated with by using <code><a href="https://help.github.com/en/github/using-git/setting-your-username-in-git">git config</a></code> as shown below (to do it globally, add the flag <code>-g</code> before <code>user</code>).git config user.name "uraccount"git config user.email "uraccount@gmail.com"


<h2>git token authentication</h2>
<a href="https://docs.github.com/cn/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token" class="whitebut ">github Creating a personal access token</a>










<br><br>
<br>
<br>
<br>
<script type='text/javascript' src='readbook.js'></script>
</body>
</html>
