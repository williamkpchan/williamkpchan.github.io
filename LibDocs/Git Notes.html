<base target="_blank"><html><head><title>Git Notes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src="https://williamkpchan.github.io/lazyload.min.js"></script>
<script src='https://williamkpchan.github.io/mainscript.js'></script>
<script src="https://williamkpchan.github.io/commonfunctions.js"></script>
<script>
  var showTopicNumber = false;
  var topicEnd = "<br>";
  var bookid = "Git Notes"
  var markerName = "h2"
</script>
<style>
body{width:80%;margin-left: 10%; font-size:24px;}
h1, h2 {color: gold;}
strong {color: orange;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px;}
</style></head><body onkeypress="chkKey()"><center>
<h1>Git Notes</h1>
<a href="#mustWatch" class="red goldbs" target="_self">Must Watch!</a><br><br>
<div id="toc"></div></center><br><br>
<div id="mustWatch"><center><span class="red">MustWatch</span></center><br>
<a href="https://docs.github.com/en/get-started/getting-started-with-git" class="whitebut ">Getting started with Git</a>

<a href="https://www.youtube.com/watch?v=HfTXHrWMGVY" class="whitebut ">setup github password</a>
<a href="https://www.youtube.com/watch?v=i_23KUAEtUM" class="whitebut ">Using Git with Visual Studio Code</a>

<a href="gitTutorials.html" class="whitebut ">gitTutorials</a>
<a href="git-config.html" class="whitebut ">git-config</a>
<a href="git exercise.html" class="whitebut ">git exercise</a>
<a href="https://www.youtube.com/watch?v=R8_veQiYBjI" class="whitebut ">GitHub Actions Tutorial</a>
<br>

</div>
<pre><br><br>
<h2>github get started</h2>
<a href=".\github get started.html" class="goldb">github get started</span></a> 

<h2>LF will be replaced by CRLF</h2>
<a href="https://stackoverflow.com/questions/5834014/lf-will-be-replaced-by-crlf-in-git-what-is-that-and-is-it-important">LF will be replaced by CRLF</a>
<br>
Git can auto-converting CRLF line endings into LF when you add a file to the index. Turn on this functionality with the core.autocrlf setting. 
If you’re on a Windows machine, set it to true – this converts LF endings into CRLF when you check out code:

git config --global core.autocrlf true
git config --global core.autocrlf false
<br>
<h2>Git for Absolute Beginners</h2>
<a href="Git for Absolute Beginners.html">Git for Absolute Beginners</a>

<h2>Activity: Use the GitHub Desktop client</h2>
<a href="https://idratherbewriting.com/learnapidoc/pubapis_version_control.html" class="whitebut ">Version control systems</a>
<a href="https://idratherbewriting.com/learnapidoc/pubapis_github_desktop_client.html" class="whitebut ">Use the GitHub Desktop client</a>

<div id="GitHubDesktoptoc" class="toc"><a href="#GitHubDesktoptopic-0" target="_self">Follow a typical workflow with a GitHub project</a><br><a href="#GitHubDesktoptopic-1" target="_self">Create a branch</a><br><a href="#GitHubDesktoptopic-2" target="_self">Merge the development branch into master</a><br><a href="#GitHubDesktoptopic-3" target="_self">Merge the branch through a pull request</a><br><a href="#GitHubDesktoptopic-4" target="_self">Managing merge conflicts</a><br><a href="#GitHubDesktoptopic-5" target="_self">Conclusion</a><br></div></center><br><br>
Although most developers use the command line when working with version control systems, there are many GUI clients available that can potentially simplify the process. 

GUI clients might be especially helpful when you’re trying to see what has changed in a file since the GUI can quickly 
<h3 id="GitHubDesktoptopic-0">Follow a typical workflow with a GitHub project</h3>
In this tutorial, you’ll use GitHub Desktop to manage the Git workflow.
Rather than working in a GitHub wiki (as you did in the <a href="https://idratherbewriting.com/learnapidoc/pubapis_github_wikis.html">previous GitHub tutorial</a>), you’ll work in a regular Git repository. 

This is because GitHub wikis have some limitations when it comes to making pull requests.
To set up your Git repo using the GitHub Desktop client:
First, download and install <a href="https://desktop.github.com/">GitHub Desktop</a>. 

Launch the app and sign in. 
(You should already have a GitHub account from <a href="https://idratherbewriting.com/learnapidoc/pubapis_github_wikis.html">previous tutorials</a>, but if not, create one.)
Go to <a href="https://github.com">Github.com</a> and browse to the repository you created in the <a href="https://idratherbewriting.com/learnapidoc/pubapis_github_wikis.html">GitHub tutorial</a>, but not the wiki. 

Just go to the main repo. 
(If you didn’t do the previous activity, just create a new repository.)
While viewing your GitHub repo in the browser, click Clone or download and select Open in Desktop.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://idratherbewritingmedia.com/images/api/open-in-github-desktop.png">
Open in GitHub Desktop
Open GitHub Desktop client and go to File > Clone Repository.
In the confirmation dialog, select Open GitHub Desktop.app. 

GitHub Desktop should launch with a “Clone a Repository” dialog box about where to clone the repository. 

If desired, you can change the Local Path.
Click the URL tab, and then paste in the clone URL. 

In the Local Path field, select where you want the repo cloned. 

For example:
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://idratherbewritingmedia.com/images/api/localpathgithubdesktop.png">
Selecting paths for the repo in GitHub Desktop
Click Clone.
Go into the repository where GitHub Desktop cloned the repo (use your Finder or browse the folders with Finder or Explorer) and either add a simple text file with some content or make a change to an existing file.
Go back to GitHub Desktop. 

You’ll see the new file you added in the list of uncommitted changes on the left.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://idratherbewritingmedia.com/images/api/github-desktop-file-uncommitted-changes.png">
Uncommitted changes shown
In the list of changed files, the green + means you’ve added a new file. 

A yellow circle means you’ve modified an existing file.
In the lower-left corner of the GitHub Desktop client (where it says “Summary” and “Description”), type a commit message, and then click Commit to master.
When you commit the changes, the left pane no longer shows the list of uncommitted changes. 

However, you’ve committed the changes only locally. 

You still have to push the commit to the remote (origin) repository. 

(“origin” is the alias name that refers to the remote repository.)
Click Push origin at the top.
You’ll see GitHub Desktop show that it’s “Pushing to origin.”
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://idratherbewritingmedia.com/images/api/pushingtoorigin.png">
If you view your repository online, you’ll see that the change you made has been pushed to the master branch on origin. 

You can also click the History tab in the GitHub Desktop client (instead of the Changes tab), or go to View > Show History to see the changes you previously committed.
Although I prefer to use the terminal instead of the GitHub Desktop GUI, the GUI gives you an easier visual experience to see the changes made to a repository. 

You can use both the command line and Desktop client in combination, if you want.
<h3 id="GitHubDesktoptopic-1">Create a branch</h3>
Now let’s create a branch, make some changes, and see how the changes are specific to that branch.
In the GitHub Desktop client, go to Branch > New Branch and create a new branch. 

Call it “development” branch, and click Create Branch.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://idratherbewritingmedia.com/images/api/creatingnewbranchgithubdesktop.png">
Creating a new branch
When you create the branch, you’ll see the Current branch drop-down menu indicate that you’re working in that branch. 

Creating a branch copies the existing content (from the branch you’re currently in, <em>master</em>) into the new branch (<em>development</em>).
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://idratherbewritingmedia.com/images/api/github-desktop-current-branch.png">
Working in a branch
Using Finder or Explorer, browse to the file you created earlier and make a change to it, such as adding a new line with some text. 

Save the changes.
Return to GitHub Desktop and notice that on the Changes tab, you have new modified files.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://idratherbewritingmedia.com/images/api/github-desktop-file-changes.png">
New files modified
The file changes show deleted lines in red and new lines in green. 

The colors help you see what changed.
Commit the changes using the options in the lower-left corner, and click Commit to development.
Click Publish branch (on the top of the GitHub Desktop window) to make the local branch also available on origin (GitHub). 

(Remember, there are usually two versions of a branch — the local version and the remote version.)
Switch back to your master branch (using the Branch drop-down option at the top of the GitHub Desktop client). 

Then look at your file (in your text editor, such as Sublime text). 

Note how the file changes you made while editing in the development branch don’t appear in your master branch.
You usually create a new branch when you’re making extensive changes to your content. 

For example, suppose you want to revamp a section (“Section X”) in your docs. 

However, you might want to publish other updates before publishing the extensive changes in Section X. 

If you were working in the same branch, it would be difficult to selectively push updates on a few files outside of Section X without pushing updates you’ve made to files in Section X as well.
Through branching, you can confine your changes to a specific version that you don’t push live until you’re ready to merge the changes into your master branch.
<h3 id="GitHubDesktoptopic-2">Merge the development branch into master</h3>
Now let’s merge the development branch into the master branch.
In the GitHub Desktop client, switch to the branch you want to merge the development branch into. 

From the branch selector, select the master branch.
Go to Branch > Merge into Current Branch.
In the merge window, select the development branch, and then click Merge development into master.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://idratherbewritingmedia.com/images/api/mergeintomastergithubclient.png">
Merging into master
If you look at your changed file, you should see the changes in the master branch.
Then click Push origin to push the changes to origin.
You will now see the changes reflected on the file on GitHub.
<h3 id="GitHubDesktoptopic-3">Merge the branch through a pull request</h3>
Now let’s merge the development branch into the master using a pull request workflow. 

We’ll pretend that we’ve cloned a repo managed by engineers, and we want to have the engineers merge in the development branch. 

(In other words, we might not have rights to merge branches into the master.) To do this, we’ll create a pull request.
Just as you did in the previous section, switch to the development branch, make some updates to the content in a file, and then save and commit the changes. 

After committing the changes, click Push origin to push your changes to the remote version of the development branch on GitHub.
In the GitHub Desktop client, while you have development branch selected, go to Branch > Create Pull Request.
GitHub opens in the browser with the Pull Request form opened.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://idratherbewritingmedia.com/images/api/mergepullrequestgithubdesktop.png">
Pull request
The left-facing arrow (pointing from the development branch towards the master) indicates that the pull request (“PR”) wants to merge the development branch into the master branch.
Describe the pull request, and then click Create pull request.
At this point, engineers would get an email request asking for them to merge in the edits. 

Play the part of the engineer by going to the Pull requests tab (on GitHub) to examine and confirm the merge request. 

As long as the merge request doesn’t pose any conflicts, you’ll see a Merge pull request button.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://idratherbewritingmedia.com/images/api/mergepullrequest.png">
Confirm merge request
To see what changes you’re merging into master, you can click the Files changed tab (which appears on the secondary navigation bar near the top). 

Then click Merge pull request to merge in the branch, and click Confirm merge to complete the merge.
Now let’s get the updates you merged into the masterbranch online into your local copy. 

In your GitHub Desktop GUI client, select the master branch, and then click the Fetch origin button. 

Fetch gets the latest updates from origin but doesn’t update your local working copy with the changes.
After you click Fetch origin, the button changes to Pull Origin.
Click Pull Origin to update your local working copy with the fetched updates.
Now check your files and notice that the updates that were originally in the development branch now appear in master.
For a more detailed tutorial in making pull requests using the GitHub interface, see <a href="https://idratherbewriting.com/learnapidoc/pubapis_github_pull_requests.html">Pull request workflows through GitHub</a>. 

I include an extensive tutorial with pull requests because it will likely be a common workflow if you are <a href="https://idratherbewriting.com/learnapidoc/docapis_find_open_source_project.html">contributing to an open-source project</a>.
<h3 id="GitHubDesktoptopic-4">Managing merge conflicts</h3>
Suppose you make a change on your local copy of a file in the repository, and someone else changes the same file using the online GitHub.com browser interface. 

The changes conflict with each other. 

What happens?
When you click Push origin from the GitHub Desktop client, you’ll see a message saying that the repository has been updated since you last pulled:
<blockquote>
“The repository has been updated since you last pulled. 

Try pulling before pushing.”
</blockquote>
The button that previously said “Push origin” now says “Pull origin.” Click Pull origin. 

You now get another error message that says,
<blockquote>
“We found some conflicts while trying to merge. 

Please resolve the conflicts and commit the changes.”
</blockquote>
If you decide to commit your changes, you’ll see a message that says:
<blockquote>
“Please resolve all conflicted files, commit, and then try syncing again.”
</blockquote>
The GitHub Desktop client displays an exclamation mark next to files with merge conflicts. 

Open up a conflict file and look for the conflict markers (&lt;&lt;&lt;&lt;&lt;&lt;&lt; and >>>>>>>). 

For example, you might see this:
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
This is an edit I made locally.
=======
This is an edit I made from the browser.
>>>>>>> c163ead57f6793678dd41b5efeef372d9bd81035
(From the command line, you can also run git status to see which files have conflicts.) The content in HEAD shows your local changes. 

The content below the ======= shows changes made by elsewhere.
Fix all the conflicts by adjusting the content between the content markers and then deleting the content markers. 

For example, update the content to this:
This is an edit I made locally.
Now you need to re-add the file to Git again. 

In the GitHub Desktop client, commit your changes to the updated files. 

Then click Push origin. 

The updates on your local get pushed to the remote without any more conflicts.
<h3 id="GitHubDesktoptopic-5">Conclusion</h3>
The more you use GitHub, the more familiar you’ll become with the workflows you need. 

Git is a robust, powerful collaboration platform, and there are many commands and workflows and features that you could adopt for a variety of scenarios. 

Despite Git’s variety of commands and workflows, most likely the scenarios you’ll actually use are somewhat limited in scope and learnable without too much effort. 

Pretty soon, these workflows will become automatic.
Although we’ve been using the GitHub Desktop client for this exercise, you can do all of this through the command line, and you’ll probably find it preferable that way. 

However, the GitHub Desktop client can be a good starting point as you transition into becoming more of a Git power user.

<h2>git always asking for user credentials</h2>
<a href="https://www.freecodecamp.org/news/how-to-fix-git-always-asking-for-user-credentials/" class="whitebut ">fix git always asking for user credentials</a>

git remote set-url origin git@github.com:williamkpchan

Look in Git configuration file.
git config --list

<h2>Git error: </h2>
“Please make sure you have the correct access rights and the repository exists”

reason: git URL might have changed. 

action:
# View existing remotes
git remote -v

# Change the 'origin' remote's URL
git remote set-url origin https://github.com/williamkpchan/williamkpchan.github.io

<h2>update an existing github repo from a different computer</h2>

Run
git clone https://github.com/your/repo
to clone your project on your computer.
It will create a new folder containing your Android project

Copy your changed files in this new folder

You can now commit your changes from this folder

If it is your repository
If the repository belongs to you, you can start committing changes on the new computer and then pushing them to master:

git push -u origin master
The origin is the name of the remote directory.
If you use the clone command on your own repository the origin of the cloned repository will automatically be your github repository.

It is essential that if you clone a repository so that it is on two different computers, you use the pull command (see below) before you start working. Otherwise, you will put one of your repositories out of synch with the “master” repository and you will need to use the “merge” command, which can be rather tedious.

<h2>Git server</h2>
<a href="https://stackoverflow.com/questions/8390828/how-can-i-have-github-on-my-own-server" class="whitebut ">Github on my own server</a>
<a href="https://github.com/patrikf/glip" class="whitebut ">Glip for PHP to view a git repo</a>

<h2>GitHub Actions</h2>
<a href="https://docs.github.com/en/actions" class="whitebut ">GitHub Actions</a>

usage: git [--version] [--help] [-C &lt;path>] [-c name=value]
           [--exec-path[=&lt;path>]] [--html-path] [--man-path] [--info-path]
           [-p | --paginate | --no-pager] [--no-replace-objects] [--bare]
           [--git-dir=&lt;path>] [--work-tree=&lt;path>] [--namespace=&lt;name>]
           &lt;command> [&lt;args>]

These are common Git commands used in various situations:

start a working area (see also: git help tutorial)
   clone      Clone a repository into a new directory
   init       Create an empty Git repository or reinitialize an existing one

work on the current change (see also: git help everyday)
   add        Add file contents to the index
   mv         Move or rename a file, a directory, or a symlink
   reset      Reset current HEAD to the specified state
   rm         Remove files from the working tree and from the index

examine the history and state (see also: git help revisions)
   bisect     Use binary search to find the commit that introduced a bug
   grep       Print lines matching a pattern
   log        Show commit logs
   show       Show various types of objects
   status     Show the working tree status

grow, mark and tweak your common history
   branch     List, create, or delete branches
   checkout   Switch branches or restore working tree files
   commit     Record changes to the repository
   diff       Show changes between commits, commit and working tree, etc
   merge      Join two or more development histories together
   rebase     Reapply commits on top of another base tip
   tag        Create, list, delete or verify a tag object signed with GPG

collaborate (see also: git help workflows)
   fetch      Download objects and refs from another repository
   pull       Fetch from and integrate with another repository or a local branch
   push       Update remote refs along with associated objects

'git help -a' and 'git help -g' list available subcommands and some
concept guides. See 'git help &lt;command>' or 'git help &lt;concept>'
to read about a specific subcommand or concept.

<h2>batch file push to github with username and password</h2>
https://coolaj86.com/articles/vanilla-devops-git-credentials-cheatsheet/

git config --global user.name "williamkpchan"
git config --global user.email "williamkpchan@gmail.com"
git init
git status
git push
pause

<h2>Git to avoid typing username password</h2>
Two approaches can be used. 

SSH keys are a way to identify trusted computers, without involving passwords. 
One needs to generate an SSH key and add the public key to your GitHub account. 
A guide on how to set up SSH key can be found <a href="https://help.github.com/articles/generating-ssh-keys/" rel="noopener nofollow">here</a>
But this is not the main focus for this article. 

The key question remains:
<strong>Is there a way to skip typing my username and/password when using HTTPS in GitHub?</strong>
The answer is yes. 
This is done by using <em>credential helpers. 
</em>And this is the second approach. 
Credential helpers basically tells Git to remember your GitHub username and password every time it talks to GitHub. 
The syntax is given by:
git config credential.https://example.com.username myusername
git config credential.helper “$helper $options”
Therefore, credential helpers are external programs from which Git can request both usernames and passwords. 
Credential helpers are in two forms: <em>cache</em> which caches credentials in memory for a short period of time, and <em>store</em> which basically stores credentials indefinitely on disk.
Once you have selected the helper, you can tell Git to use it by putting its name into the credential.helper variable.

Find a helper:
git help -a | grep credential-credential-foo
2. Read its description.
 git help credential-foo
3. Tell Git to use it.
git config — global credential.helper foo
Assuming you have a remote with the following URL<strong><em> https://github.com/adambajumba/MestEIT</em></strong>, update the Git configuration to use the helper whenever it needs authentication steps:
$ git config --global \credential.https://github.com/myusername/mysecretproject.username \your_github_account_name$ git config --global \credential.https://github.com/adambajumba/MestEIT.adambajumba \IsaacJumba
Note that the remote URL is appended with a trailing .username fragment which becomes the key and the GitHub username becomes the value.Once the username is set, map the helper: And you are done! That easy, right?
$ git config --global core.askpass ~/.git_credential_helper.rb
An example of how it works would be:
$ git config credential.helper store
$ git push http://example.com/repo.git
Username: &lt;type your username>
Password: &lt;type your password><strong>[several days later]</strong>
$ git push http://example.com/repo.git
[your credentials are used automatically]
In conclusion, the credential helper does not work in all versions of git but from version 1.8 and above.

<h2>Git Tools - Credential Storage</h2>
If you use the SSH transport for connecting to remotes, it’s possible for you to have a key without a passphrase, which allows you to securely transfer data without typing in your username and password.
However, this isn’t possible with the HTTP protocols – every connection needs a username and password.
This gets even harder for systems with two-factor authentication, where the token you use for a password is randomly generated and unpronounceable.

Fortunately, Git has a credentials system that can help with this.
Git has a few options provided in the box:
The default is not to cache at all.
Every connection will prompt you for your username and password.

The “cache” mode keeps credentials in memory for a certain period of time.
None of the passwords are ever stored on disk, and they are purged from the cache after 15 minutes.
The “store” mode saves the credentials to a plain-text file on disk, and they never expire.
This means that until you change your password for the Git host, you won’t ever have to type in your credentials again.

The downside of this approach is that your passwords are stored in cleartext in a plain file in your home directory.
If you’re using a Mac, Git comes with an “osxkeychain” mode, which caches credentials in the secure keychain that’s attached to your system account.
This method stores the credentials on disk, and they never expire, but they’re encrypted with the same system that stores HTTPS certificates and Safari auto-fills.
If you’re using Windows, you can install a helper called “Git Credential Manager for Windows.”

This is similar to the “osxkeychain” helper described above, but uses the Windows Credential Store to control sensitive information.
It can be found at <a href="https://github.com/Microsoft/Git-Credential-Manager-for-Windows">https://github.com/Microsoft/Git-Credential-Manager-for-Windows</a>.
You can choose one of these methods by setting a Git configuration value:
<code>$ git config --global credential.helper cache</code>

Some of these helpers have options.
The “store” helper can take a <code>--file &lt;path></code> argument, which customizes where the plain-text file is saved (the default is <code>~/.git-credentials</code>).
The “cache” helper accepts the <code>--timeout &lt;seconds></code> option, which changes the amount of time its daemon is kept running (the default is “900”, or 15 minutes).
Here’s an example of how you’d configure the “store” helper with a custom file name:

<code>$ git config --global credential.helper 'store --file ~/.my-credentials'</code>
Git even allows you to configure several helpers.
When looking for credentials for a particular host, Git will query them in order, and stop after the first answer is provided.
When saving credentials, Git will send the username and password to <strong>all</strong> of the helpers in the list, and they can choose what to do with them.

Here’s what a <code>.gitconfig</code> would look like if you had a credentials file on a thumb drive, but wanted to use the in-memory cache to save some typing if the drive isn’t plugged in:
<code>[credential]
    helper = store --file /mnt/thumbdrive/.git-credentials
    helper = cache --timeout 30000</code>

<h3>Under the Hood</h3>
How does this all work?
Git’s root command for the credential-helper system is <code>git credential</code>, which takes a command as an argument, and then more input through stdin.
This might be easier to understand with an example.

Let’s say that a credential helper has been configured, and the helper has stored credentials for <code>mygithost</code>.
Here’s a session that uses the “fill” command, which is invoked when Git is trying to find credentials for a host:
<code>$ git credential fill <b>(1)</b>
protocol=https <b>(2)</b>
host=mygithost
<b>(3)</b>
protocol=https <b>(4)</b>
host=mygithost
username=bob
password=s3cre7

$ git credential fill <b>(5)</b>
protocol=https
host=unknownhost
Username for 'https://unknownhost': bob
Password for 'https://bob@unknownhost':
protocol=https
host=unknownhost
username=bob
password=s3cre7</code>

This is the command line that initiates the interaction.
Git-credential is then waiting for input on stdin.
We provide it with the things we know: the protocol and hostname.
A blank line indicates that the input is complete, and the credential system should answer with what it knows.
Git-credential then takes over, and writes to stdout with the bits of information it found.

If credentials are not found, Git asks the user for the username and password, and provides them back to the invoking stdout (here they’re attached to the same console).
The credential system is actually invoking a program that’s separate from Git itself; which one and how depends on the <code>credential.helper</code> configuration value.
There are several forms it can take:
<table>
<colgroup><col style="width: 50%;"><col style="width: 50%;">
</colgroup>
<thead><tr><th>Configuration Value</th><th>Behavior</th></tr></thead>
<tbody>
<tr><td><code>foo</code></td><td>Runs <code>git-credential-foo</code></td></tr>
<tr><td><code>foo -a --opt=bcd</code></td><td>Runs <code>git-credential-foo -a --opt=bcd</code></td></tr>
<tr><td><code>/absolute/path/foo -xyz</code></td><td>Runs <code>/absolute/path/foo -xyz</code></td></tr>
<tr><td><code>!f() { echo "password=s3cre7"; }; f</code></td><td>Code after <code>!</code> evaluated in shell</td></tr>
</tbody>
</table>

So the helpers described above are actually named <code>git-credential-cache</code>, <code>git-credential-store</code>, and so on, and we can configure them to take command-line arguments.
The general form for this is “git-credential-foo [args] &lt;action>.”
The stdin/stdout protocol is the same as git-credential, but they use a slightly different set of actions:
<code>get</code> is a request for a username/password pair.
<code>store</code> is a request to save a set of credentials in this helper’s memory.
<code>erase</code> purge the credentials for the given properties from this helper’s memory.
For the <code>store</code> and <code>erase</code> actions, no response is required (Git ignores it anyway).
For the <code>get</code> action, however, Git is very interested in what the helper has to say.

If the helper doesn’t know anything useful, it can simply exit with no output, but if it does know, it should augment the provided information with the information it has stored.
The output is treated like a series of assignment statements; anything provided will replace what Git already knows.
Here’s the same example from above, but skipping git-credential and going straight for git-credential-store:
<code>$ git credential-store --file ~/git.store store <b>(1)</b>

protocol=https
host=mygithost
username=bob
password=s3cre7
$ git credential-store --file ~/git.store get <b>(2)</b>
protocol=https
host=mygithost
username=bob <b>(3)</b>
password=s3cre7</code>

Here we tell <code>git-credential-store</code> to save some credentials: the username “bob” and the password “s3cre7” are to be used when <code><a href="https://mygithost">https://mygithost</a></code> is accessed.
Now we’ll retrieve those credentials.
We provide the parts of the connection we already know (<code><a href="https://mygithost">https://mygithost</a></code>), and an empty line.

<code>git-credential-store</code> replies with the username and password we stored above.
Here’s what the <code>~/git.store</code> file looks like:
<code>https://bob:s3cre7@mygithost</code>
It’s just a series of lines, each of which contains a credential-decorated URL.

The <code>osxkeychain</code> and <code>wincred</code> helpers use the native format of their backing stores, while <code>cache</code> uses its own in-memory format (which no other process can read).
<h3>A Custom Credential Cache</h3>
Given that <code>git-credential-store</code> and friends are separate programs from Git, it’s not much of a leap to realize that <em>any</em> program can be a Git credential helper.
The helpers provided by Git cover many common use cases, but not all.

For example, let’s say your team has some credentials that are shared with the entire team, perhaps for deployment.
These are stored in a shared directory, but you don’t want to copy them to your own credential store, because they change often.
None of the existing helpers cover this case; let’s see what it would take to write our own.
There are several key features this program needs to have:

The only action we need to pay attention to is <code>get</code>; <code>store</code> and <code>erase</code> are write operations, so we’ll just exit cleanly when they’re received.
The file format of the shared-credential file is the same as that used by <code>git-credential-store</code>.
The location of that file is fairly standard, but we should allow the user to pass a custom path just in case.
Once again, we’ll write this extension in Ruby, but any language will work so long as Git can execute the finished product.

Here’s the full source code of our new credential helper:
<code>#!/usr/bin/env ruby
require 'optparse'
path = File.expand_path '~/.git-credentials' # <b>(1)</b>

OptionParser.new do |opts|
    opts.banner = 'USAGE: git-credential-read-only [options] &lt;action>'
    opts.on('-f', '--file PATH', 'Specify path for backing store') do |argpath|
        path = File.expand_path argpath
    end
end.parse!
exit(0) unless ARGV[0].downcase == 'get' # <b>(2)</b>
exit(0) unless File.exists? path

known = {} # <b>(3)</b>
while line = STDIN.gets
    break if line.strip == ''
    k,v = line.strip.split '=', 2
    known[k] = v
end
File.readlines(path).each do |fileline| # <b>(4)</b>
    prot,user,pass,host = fileline.scan(/^(.*?):\/\/(.*?):(.*?)@(.*)$/).first

    if prot == known['protocol'] and host == known['host'] and user == known['username'] then
        puts "protocol=#{prot}"
        puts "host=#{host}"
        puts "username=#{user}"
        puts "password=#{pass}"
        exit(0)
    end
end</code>

Here we parse the command-line options, allowing the user to specify the input file.
The default is <code>~/.git-credentials</code>.
This program only responds if the action is <code>get</code> and the backing-store file exists.
This loop reads from stdin until the first blank line is reached.

The inputs are stored in the <code>known</code> hash for later reference.
This loop reads the contents of the storage file, looking for matches.
If the protocol, host, and username from <code>known</code> match this line, the program prints the results to stdout and exits.
We’ll save our helper as <code>git-credential-read-only</code>, put it somewhere in our <code>PATH</code> and mark it executable.

Here’s what an interactive session looks like:
<code>$ git credential-read-only --file=/mnt/shared/creds get
protocol=https
host=mygithost
username=bob
protocol=https
host=mygithost
username=bob
password=s3cre7</code>

Since its name starts with “git-”, we can use the simple syntax for the configuration value:
<code>$ git config --global credential.helper 'read-only --file /mnt/shared/creds'</code>
As you can see, extending this system is pretty straightforward, and can solve some common problems for you and your team.


<h2>use a github repo from a same account but different computers</h2>

supplying --force as an argument to the git push command

first fetch those changes from the remote, and then pull them into your local repository on computer 1. 

$ git fetch origin
$ git pull origin master
In these commands, origin is the name of your github remote and master is the name of the branch you are currently tracking. 

These names can be changed, but these are the defaults which appear to be the names in your case.

Note, you will likely need to revert the new changes you made to computer 1. 

Git will have a hard time trying to merge the changes from computer 2 with the changes you made to computer 1 when you were trying to commit the second time.

pull is fetch + merge.
If you've already run fetch, there's no need to run pull, merge should be enough.
Or just run pull without fetching first, as it fetches on its own.

<h2>Use Multiple GitHub Accounts With One Computer</h2>
<h3>How to set up and change SSH keys to use multiple GitHub accounts on one machine</h3>
I currently have two GitHub accounts: a personal and a work one. 
Obviously, my work computer is set up with my work account. 

I wanted to figure out how to push to GitHub with my personal account whenever I’m working on side projects via my work computer.
At first glance, for the seemingly simple task of switching between two accounts, the process seemed a little involved. 

But once you break things down into steps, it’s less daunting.
<h3>Quick Note on <strong><em>SSH</em></strong></h3>
<a href="https://www.ssh.com/ssh/protocol/#strong-authentication-with-ssh-keys">SSH</a><strong> </strong>(or secure shell) is a network protocol which, among <a href="https://www.ssh.com/ssh/protocol/#typical-uses-of-the-ssh-protocol">other things</a>, allows one computer to communicate with another over an unsecured network like the internet.
Without encryption, data travels over the web in plain text form. 
Consequently, it would be easy for someone to intercept valuable data, like user names or passwords, for wicked intent.SSH allows encryption of your data by way of a <a href="https://www.ssh.com/ssh/tunneling/"><em>tunnel</em></a>, which permits your computer to securely connect to another.
This is done via the use of <a href="https://www.ssh.com/ssh/key/">SSH keys</a> and <a href="https://en.wikipedia.org/wiki/Public-key_cryptography">public-key cryptography </a>(aka asymmetric cryptography) which are used for authentication purposes between said computers, in order to decrypt the information being shared.
<a href="https://www.youtube.com/watch?v=AQDCe585Lnc">Here’s a great video</a> explaining the concept of asymmetric cryptography further.SSH is commonly implemented using the client-server model.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://miro.medium.com/max/1400/1*On6fpv0NVHnmqZs7Dn6DqQ.png">
Client-server model with asymmetric cryptography
When running any remote commands from our computer(e.g., git push or git pull) to a remote repository (GitHub), it’s this protocol that enables us to do so without having to supply a password and username each time.
Let’s now look at the configuration for it.
<h3>Configuration</h3>The configuration can essentially be broken down into four steps:
Generate an SSH key for the new account.
Attach this new key to your GitHub account.
Register the new key with the SSH agent.
Create an SSH config file.

<h3><strong>Step 1. Generate an <em>SSH</em> key for the new account</strong></h3>Using the SSH protocol, we’ll have to generate a key for any new account we’d like to use.
Hop onto your terminal, run the following command, and attach your GitHub email address:$ ssh-keygen -t rsa -C "uremail@gmail.com" A new key pair will be generated. 
At this point, you want to be careful not to overwrite your existing key pair, which would look like the following:({your home Directory}/.ssh/id_rsa):Instead, you can copy the directory and modify the file name to include your account name, as in the screenshot below:
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://miro.medium.com/max/875/1*tKXjK-bNH8wwkKOFJT_6tg.png">
You will then be prompted to enter a passphrase. 
Your new SSH key will be found at a directory similar to this:{your home Directory}/.ssh/id_rsa_uraccount
<h3><strong>Step 2. Attach the new key to your GitHub account</strong></h3>We’ve just created a public key, and now we need to allow our GitHub account to trust it. 
This allows you to not have to authenticate every time you run a remote command (git push, git pull).
Copy the public key via the following command <code>pbcopy &lt; ~/.ssh/id_rsa.pub</code> and then log in to your personal GitHub account:
Go to <code>Settings</code>.
From the left side navigation, click <code>SSH and GPG keys</code>.
Click on <code>New SSH key</code>, name it (it's a good idea to name it after the computer you’re using it in), and paste the key you previously copied.
Click <code>Add key</code>.

<h3><strong>Step 3. Register the new key with the <em>SSH agent</em></strong></h3>We now need to register our key with the <a href="https://www.ssh.com/ssh/agent">SSH agent</a>. 

The SSH agent keeps track of user identity keys and passphrases and works as an additional layer of security.
In your terminal, write the command <code>ssh-add</code> and add the path to the files containing your keys. 
As shown below, we are adding keys for our main account and the second account we just created.ssh-add ~/.ssh/id_rsassh-add ~/.ssh/id_rsa_uraccount
<h3><strong>Step 4. Create an <em>SSH</em> config file</strong></h3>The SSH config file allows us to set configuration rules that will specify when we want to push to our work account versus our personal account. 

This is done by defining which identity file to use ( the ones we’ve added to our SSH agent ) on which domain.
If the file has already been created, it should be at <code>~/.ssh/config</code>. 
But by default, it will not exist, so we’ll need to create it by running the command <code>touch ~/.ssh/config</code>.
You can use any text editor or IDE to open and edit the file. 
I went with the terminal’s text editor <a href="https://www.vim.org/">vim</a><strong>. 

</strong>I don’t use it frequently, and it does have a bit of a learning curve, so I tend to use a <a href="https://devhints.io/vim">cheat sheet</a> to navigate through it<strong>.
</strong>To open the file, use <code>vim config</code>.# Account 1 (work or personal) - the default configHost github.com   HostName github.com   User git   IdentityFile ~/.ssh/id_rsa   # Account 2 (work or personal) - the config we are addingHost github-uraccount      HostName github.com   User git   IdentityFile ~/.ssh/id_rsa_uraccountThe top part is the default configuration. 
It comprises the following:<ul><li>the<strong> host</strong>(<code>github.com</code>)
Its <strong>host name </strong>(<code>github.com</code>)
a <strong>user ID </strong>(<code>git</code>)
its<strong> identity file</strong> (<code>~/.ssh/id_rsa</code>)</li></ul>We can basically duplicate the default configuration; we’ll only need to changes two things: the host (<code>github-uraccount</code>) and the identity file (to the key we created earlier, <code>~/.ssh/id_rsa_uraccount</code>).
And that should do it. 
Save and close the file using <code>:wq</code> (if you are using vim).
<h3>Create a new repository</h3>Now that we’re done with the configuration, let’s push to GitHub with our new account.
In your project’s working directory, start by initializing git using <code>git init </code>then go to GitHub and create a new repository.
When you get to the instructions under Existing Git Repo, you’d normally just copy and paste the commands to your terminal to add the repo as the remote to your local repo, but for this case, we need to replace “github.com” with the host we set up in our config file earlier. 

So instead of the default host <code>git@github.com</code>, we use <code>git@github-uraccount</code>.git remote add origin git@github-uraccount:uraccount/repo_name.gitNow you can push to GitHub using, for example, the following:git add .git commit -m "Initial commit"git push -u origin master
<h3>Associate your commits with a particular username</h3>For a single repository, if you’d like to change the name associated with your commits, you’ll also need to change your user name and email to reflect the GitHub account you want the repository to be associated with by using <code><a href="https://help.github.com/en/github/using-git/setting-your-username-in-git">git config</a></code> as shown below (to do it globally, add the flag <code>-g</code> before <code>user</code>).git config user.name "uraccount"git config user.email "uraccount@gmail.com"

<h2>Quickstart for Codespaces</h2>
In this guide, you'll create a codespace from a <a href="https://github.com/2percentsilk/haikus-for-codespaces">template repository</a> and explore some of the essential features available to you within the codespace.
From this quickstart, you will learn how to create a codespace, connect to a forwarded port to view your running application, use version control in a codespace, and personalize your setup with extensions.

For more information on exactly how Codespaces works, see the companion guide "<a href="https://docs.github.com/en/codespaces/getting-started/deep-dive">Deep dive into Codespaces</a>."
<h3>Creating your codespace</h3>
Navigate to the <a href="https://github.com/2percentsilk/haikus-for-codespaces">template repository</a> and select <strong>Use this template</strong>. 

Name your repository, select your preferred privacy setting, and click <strong>Create repository from this template</strong>.
Navigate to the main page of the newly created repository. 
Under the repository name, use the <strong> Code</strong> drop-down menu, and in the <strong>Codespaces</strong> tab, click  <strong>New codespace</strong>.

<h3>Running the application</h3>
Once your codespace is created, your repository will be automatically cloned into it. 
Now you can run the application and launch it in a browser.

Since this example uses a Node.js project, start the application by entering <code>npm run dev</code> in the terminal. 
This command executes the <code>dev</code> script in the package.json file and starts up the web application defined in the sample repository.
If you're following along with a different application type, enter the corresponding start command for that project.

When your application starts, the codespace recognizes the port the application is running on and displays a prompt to forward that port so you can connect to it. 
Click <strong>Open in Browser</strong> to view your running application in a new tab.
<h3>Edit the application and view changes</h3>

Switch back to your codespace and open the <code>haikus.json</code> file by double-clicking it in the File Explorer.
Edit the <code>text</code> field of the first haiku to personalize the application with your own haiku.
Go back to the running application tab in your browser and refresh to see your changes.

If you've closed the tab, open the Ports panel and click the <strong>Open in browser</strong> icon for the running port.
<h3>Committing and pushing your changes</h3>
Now that you've made a few changes, you can use the integrated terminal or the source view to commit and push the changes back to the remote.

In the Activity Bar, click the <strong>Source Control</strong> view.
To stage your changes, click  <strong>+</strong> next to the file you've changed, or next to <strong>Changes</strong> if you've changed multiple files and you want to stage them all.
Type a commit message describing the change you've made.

To commit your staged changes, click the check mark at the top the source control side bar.
You can push the changes you've made. 
This applies those changes to the upstream branch on the remote repository. 

You might want to do this if you're not yet ready to create a pull request, or if you prefer to create a pull request on GitHub.
At the top of the side bar, click the ellipsis (<strong>...</strong>).
In the drop-down menu, click <strong>Push</strong>.

<h3>Personalizing with an extension</h3>
Within a codespace, you have access to the Visual Studio Code Marketplace. 
For this example, you'll install an extension that alters the theme, but you can install any extension that is useful for your workflow.

In the left sidebar, click the Extensions icon.
In the search bar, enter <code>fairyfloss</code> and install the fairyfloss extension.
Select the <code>fairyfloss</code> theme by selecting it from the list.

Changes you make to your editor setup in the current codespace, such as theme and keyboard bindings, are synced automatically via <a href="https://code.visualstudio.com/docs/editor/settings-sync">Settings Sync</a> to any other codespaces you open and any instances of Visual Studio Code that are signed into your GitHub account.
<h3>Next Steps</h3>
You've successfully created, personalized, and run your first application within a codespace but there's so much more to explore! Here are some helpful resources for taking your next steps with Codespaces.

<a href="https://docs.github.com/en/codespaces/getting-started/deep-dive">Deep dive</a>: This quickstart presented some of the features of Codespaces. 
The deep dive looks at these areas from a technical standpoint.
<a href="https://docs.github.com/en/codespaces/getting-started-with-codespaces">Setting up your project for Codespaces</a>: These guides provide information on setting up your project to use Codespaces with specific languages

<a href="https://docs.github.com/en/codespaces/setting-up-your-codespace/configuring-codespaces-for-your-project">Configuring Codespaces for your project</a>: This guide provides details on creating a custom configuration for Codespaces for your project.
<h3>Further reading</h3>
<a href="https://docs.github.com/en/codespaces/managing-codespaces-for-your-organization/enabling-codespaces-for-your-organization">Enabling Codespaces for your organization</a>

<h2>Deep dive into Codespaces</h2>
Understand how Codespaces works.
Codespaces is an instant, cloud-based development environment that uses a container to provide you with common languages, tools, and utilities for development. 

Codespaces is also configurable, allowing you to create a customized development environment for your project. 
By configuring a custom development environment for your project, you can have a repeatable codespace configuration for all users of your project.
<h3>Creating your codespace</h3>
There are a number of entry points to create a codespace.
From your repository for new feature work.
From an open pull request to explore work-in-progress.

From a commit in the repository's history to investigate a bug at a specific point in time.
From Visual Studio Code.
Your codespace can be ephemeral if you need to test something or you can return to the same codespace to work on long-running feature work. 

For more information, see "<a href="https://docs.github.com/en/codespaces/developing-in-codespaces/creating-a-codespace">Creating a codespace</a>."
Once you've selected the option to create a new codespace, some steps happen in the background before the codespace is available to you.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://docs.github.com/assets/cb-155258/images/help/codespaces/new-codespace-button.png" >

<h3>Step 1: VM and storage are assigned to your codespace</h3>
When you create a codespace, a <a href="https://github.blog/2020-12-21-get-up-to-speed-with-partial-clone-and-shallow-clone/">shallow clone</a> of your repository is made on a Linux virtual machine that is both dedicated and private to you. 
Having a dedicated VM ensures that you have the entire set of compute resources from that machine available to you. 
If necessary, this also allows you to have full root access to your container.
<h3>Step 2: Container is created</h3>
Codespaces uses a container as the development environment. 

This container is created based on the configurations that you can define in a <code>devcontainer.json</code> file and/or Dockerfile in your repository. 
If you don't <a href="https://docs.github.com/en/codespaces/customizing-your-codespace/configuring-codespaces-for-your-project">configure a container</a>, Codespaces uses a <a href="https://docs.github.com/en/codespaces/customizing-your-codespace/configuring-codespaces-for-your-project#using-the-default-configuration">default image</a>, which has many languages and runtimes available. 
For information on what the default image contains, see the <a href="https://github.com/microsoft/vscode-dev-containers/tree/main/containers/codespaces-linux"><code>vscode-dev-containers</code></a> repository.

<strong>Note:</strong> If you want to use Git hooks in your codespace and apply anything in the <a href="https://git-scm.com/docs/git-init#_template_directory">git template directory</a> to your codespace, then you must set up hooks during step 4 after the container is created.
Since your repository is cloned onto the host VM before the container is created, anything in the <a href="https://git-scm.com/docs/git-init#_template_directory">git template directory</a> will not apply in your codespace unless you set up hooks in your <code>devcontainer.json</code> configuration file using the <code>postCreateCommand</code> in step 4. 
For more information, see "<a href="#step-4-post-creation-setup">Step 4: Post-creation setup</a>."

<h3>Step 3: Connecting to the codespace</h3>
When your container has been created and any other initialization has run, you'll be connected to your codespace. 
You can connect to it through the web or via <a href="https://docs.github.com/en/codespaces/developing-in-codespaces/using-codespaces-in-visual-studio-code">Visual Studio Code</a>, or both, if needed.

<h3>Step 4: Post-creation setup</h3>
Once you are connected to your codespace, your automated setup may continue to build based on the configuration you specified in your <code>devcontainer.json</code> file. 
You may see <code>postCreateCommand</code> and <code>postAttachCommand</code> run.

If you want to use Git hooks in your codespace,  set up hooks using the <a href="https://code.visualstudio.com/docs/remote/devcontainerjson-reference#_lifecycle-scripts"><code>devcontainer.json</code> lifecycle scripts</a>, such as <code>postCreateCommand</code>. 
For more information, see the <a href="https://code.visualstudio.com/docs/remote/devcontainerjson-reference#_devcontainerjson-properties"><code>devcontainer.json</code> reference</a> in the Visual Studio Code documentation.
If you have a public dotfiles repository for Codespaces, you can enable it for use with new codespaces. 

When enabled, your dotfiles will be cloned to the container and the install script will be invoked. 
For more information, see "<a href="https://docs.github.com/en/github/developing-online-with-codespaces/personalizing-codespaces-for-your-account#dotfiles">Personalizing Codespaces for your account</a>." 
Finally, the entire history of the repository is copied down with a full clone.

During post-creation setup you'll still be able to use the integrated terminal and make edits to your files, but take care to avoid any race conditions between your work and the commands that are running.
<h3>Codespaces lifecycle</h3>
<h3>Saving files in your codespace</h3>
As you develop in your codespace, it will save any changes to your files every few seconds. 
Your codespace will keep running for 30 minutes after the last activity. 
After that time it will stop running but you can restart it from either from the existing browser tab or the list of existing codespaces. 

File changes from the editor and terminal output are counted as activity and so your codespace will not stop if terminal output is continuing.
<strong>Note:</strong> Changes in a codespace in Visual Studio Code are not saved automatically, unless you have enabled <a href="https://code.visualstudio.com/docs/editor/codebasics#_save-auto-save">Auto Save</a>.
<h3>Closing or stopping your codespace</h3>
To stop your codespace you can <a href="https://docs.github.com/en/codespaces/codespaces-reference/using-the-vs-code-command-palette-in-codespaces#suspending-or-stopping-a-codespace">use the VS Code Command Palette</a> (<code>Shift + Command + P</code> (Mac) / <code>Ctrl + Shift + P</code> (Windows)). 
If you exit your codespace without running the stop command (for example, closing the browser tab), or if you leave the codespace running without interaction, the codespace and its running processes will continue until a window of inactivity occurs, after which the codespace will stop. 
By default, the window of inactivity is 30 minutes. 

When you close or stop your codespace, all uncommitted changes are preserved until you connect to the codespace again.
<h3>Running your application</h3>
Port forwarding gives you access to TCP ports running within your codespace. 

For example, if you're running a web application on port 4000 within your codespace, you can automatically forward that port to make the application accessible from your browser.
Port forwarding determines which ports are made accessible to you from the remote machine. 
Even if you do not forward a port, that port is still accessible to other processes running inside the codespace itself.

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://docs.github.com/assets/cb-55542/images/help/codespaces/port-forwarding.png" >
When an application running inside Codespaces outputs a port to the console, Codespaces detects the localhost URL pattern and automatically forwards the port. 
You can click on the URL in the terminal or in the toast message to open the port in a browser. 

By default, Codespaces forwards the port using HTTP. 
For more information on port forwarding, see "<a href="https://docs.github.com/en/codespaces/developing-in-codespaces/forwarding-ports-in-your-codespace">Forwarding ports in your codespace</a>."
While ports can be forwarded automatically, they are not publicly accessible to the internet. 

By default, all ports are private, but you can manually make a port available to your organization or public, and then share access through a URL. 
For more information, see "<a href="https://docs.github.com/en/codespaces/developing-in-codespaces/forwarding-ports-in-your-codespace#sharing-a-port">Sharing a port</a>."
Running your application when you first land in your codespace can make for a fast inner dev loop. 

As you edit, your changes are automatically saved and available on your forwarded port. 
To view changes, go back to the running application tab in your browser and refresh it.
<h3>Committing and pushing your changes</h3>
Git is available by default in your codespace and so you can rely on your existing Git workflow. 
You can work with Git in your codespace either via the Terminal or by using <a href="https://code.visualstudio.com/docs/editor/versioncontrol">Visual Studio Code</a>'s source control UI. 
For more information, see "<a href="https://docs.github.com/en/codespaces/developing-in-codespaces/using-source-control-in-your-codespace">Using source control in your codespace</a>"

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://docs.github.com/assets/cb-76209/images/help/codespaces/git-status.png" >
You can create a codespace from any branch, commit, or pull request in your project, or you can switch to a new or existing branch from within your active codespace. 
Because Codespaces is designed to be ephemeral, you can use it as an isolated environment to experiment, check a teammate's pull request, or fix merge conflicts. 

You can create more than one codespace per repository or even per branch. 
However, each user account has a limit of 10 codespaces. 
If you've reached the limit and want to create a new codespace, you must delete a codespace first.

<strong>Note:</strong> Commits from your codespace will be attributed to the name and public email configured at <a href="https://github.com/settings/profile">https://github.com/settings/profile</a>. 
A token scoped to the repository, included in the environment as <code>GITHUB_TOKEN</code>, and your GitHub credentials will be used to authenticate.
<h3>Personalizing your codespace with extensions</h3>
Using Visual Studio Code in your codespace gives you access to the Visual Studio Code Marketplace so that you can add any extensions you need. 
For information on how extensions run in Codespaces, see <a href="https://code.visualstudio.com/api/advanced-topics/remote-extensions">Supporting Remote Development and GitHub Codespaces</a> in the Visual Studio Code docs. 
If you already use Visual Studio Code, you can use <a href="https://code.visualstudio.com/docs/editor/settings-sync">Settings Sync</a> to automatically sync extensions, settings, themes, and keyboard shortcuts between your local instance and any Codespaces you create.

<h2>20 Git Commands</h2>
<div id="gitCommandtoc" class="toc"><a href="#gitCommandtopic-0" target="_self"><span class="orange">Git Commands</span></a> <a href="#gitCommandtopic-1" target="_self">git config</a> <a href="#gitCommandtopic-2" target="_self"> git init</a> <a href="#gitCommandtopic-3" target="_self">git clone</a> <a href="#gitCommandtopic-4" target="_self">git add</a> <a href="#gitCommandtopic-5" target="_self">git commit</a> <a href="#gitCommandtopic-6" target="_self">git diff</a> <a href="#gitCommandtopic-7" target="_self"><br><span class="orange">Git Commands With Examples</span></a> <a href="#gitCommandtopic-8" target="_self">git reset</a> <a href="#gitCommandtopic-9" target="_self">git status</a> <a href="#gitCommandtopic-10" target="_self">git rm</a> <a href="#gitCommandtopic-11" target="_self">git log</a> <a href="#gitCommandtopic-12" target="_self">git show</a> <a href="#gitCommandtopic-13" target="_self">git tag</a> <a href="#gitCommandtopic-14" target="_self">git branch</a> <a href="#gitCommandtopic-15" target="_self">git checkout</a> <a href="#gitCommandtopic-16" target="_self">git merge</a> <a href="#gitCommandtopic-17" target="_self">git remote</a> <a href="#gitCommandtopic-18" target="_self">git push</a> <a href="#gitCommandtopic-19" target="_self">git pull</a> <a href="#gitCommandtopic-20" target="_self">git stash</a> </div></center>
<h3 id="gitCommandtopic-0"><span class="orange">Git Commands</span></h3>
<h3 id="gitCommandtopic-1">git config</h3>
Usage: git config -global user.name "[name]"
Usage: git config -global user.email "[email address]"
This command sets the author name and email address respectively to be used with your commits.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/1-9.png">
<h3 id="gitCommandtopic-2"> git init</h3>
Usage: git init [repository name]
This command is used to start a new repository.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/2-6.png">
<h3 id="gitCommandtopic-3">git clone</h3>
Usage: git clone [url]
This command is used to obtain a repository from an existing URL.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/4-4.png">
<h3 id="gitCommandtopic-4">git add</h3>
Usage: git add [file]
This command adds a file to the staging area.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/5-4.png">
Usage: git add *
This command adds one or more to the staging area.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/6-3.png">
<h3 id="gitCommandtopic-5">git commit</h3>
Usage: git commit -m "[ Type in the commit message]"
This command records or snapshots the file permanently in the version history.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/7-3.png">
Usage: git commit -a
This command commits any files you’ve added with the git add command and also commits any files you’ve changed since then.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/8-2.png">
<h3 id="gitCommandtopic-6">git diff</h3>
Usage: git diff
This command shows the file differences which are not yet staged.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/9-2.png">
Usage: git diff -staged
This command shows the differences between the files in the staging area and the latest version present.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/10-2.png">
Usage: git diff [first branch] [second branch]
This command shows the differences between the two branches mentioned.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/43.png">
<h3 id="gitCommandtopic-7"><br><span class="orange">Git Commands With Examples</span></h3>
<h3 id="gitCommandtopic-8">git reset</h3>
Usage: git reset [file]
This command unstages the file, but it preserves the file contents.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/11-1.png">
Usage: git reset [commit]
This command undoes all the commits after the specified commit and preserves the changes locally.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/14-1.png">
Usage: git reset -hard [commit]
This command discards all history and goes back to the specified commit.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/13-1.png">
<h3 id="gitCommandtopic-9">git status</h3>
Usage: git status
This command lists all the files that have to be committed.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/15-1.png">
<h3 id="gitCommandtopic-10">git rm</h3>
Usage: git rm [file]
This command deletes the file from your working directory and stages the deletion.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/16-2.png">
<h3 id="gitCommandtopic-11">git log</h3>
Usage: git log
This command is used to list the version history for the current branch.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/18.png">
Usage: git log -follow[file]
This command lists version history for a file, including the renaming of files also.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/19.png">
<h3 id="gitCommandtopic-12">git show</h3>
Usage: git show [commit]
This command shows the metadata and content changes of the specified commit.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/20.png">
<h3 id="gitCommandtopic-13">git tag</h3>
Usage: git tag [commitID]
This command is used to give tags to the specified commit.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/22.png">
<h3 id="gitCommandtopic-14">git branch</h3>
Usage: git branch
This command lists all the local branches in the current repository.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/23.png">
Usage: git branch [branch name]
This command creates a new branch.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/24.png">
Usage: git branch -d [branch name]
This command deletes the feature branch.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/25.png">
<h3 id="gitCommandtopic-15">git checkout</h3>
Usage: git checkout [branch name]
This command is used to switch from one branch to another.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/27.png">
Usage: git checkout -b [branch name]
This command creates a new branch and also switches to it.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/28.png">
<h3 id="gitCommandtopic-16">git merge</h3>
Usage: git merge [branch name]
This command merges the specified branch’s history into the current branch.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/31-1.png">
<h3 id="gitCommandtopic-17">git remote</h3>
Usage: git remote add [variable name] [Remote Server Link]
This command is used to connect your local repository to the remote server.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/32.png">
<h3 id="gitCommandtopic-18">git push</h3>
Usage: git push [variable name] master
This command sends the committed changes of master branch to your remote repository.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/33.png">
Usage: git push [variable name] [branch]
This command sends the branch commits to your remote repository.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/34.png">
Usage: git push -all [variable name]
This command pushes all branches to your remote repository.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/36.png">
Usage: git push [variable name] :[branch name]
This command deletes a branch on your remote repository.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/37.png">
<h3 id="gitCommandtopic-19">git pull</h3>
Usage: git pull [Repository Link]
This command fetches and merges changes on the remote server to your working directory.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/38.png">
<h3 id="gitCommandtopic-20">git stash</h3>
Usage: git stash save
This command temporarily stores all the modified tracked files.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/39.png">
Usage: git stash pop
This command restores the most recently stashed files.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/40.png">
Usage: git stash list
This command lists all stashed changesets.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/44.png">
Usage: git stash drop
This command discards the most recently stashed changeset.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/07/42.png">

<h2>git - the simple guide</h2>
<div id="gitGuidetoc" class="toc"><a href="#gitGuidetopic-0" target="_self">create a new repository</a> <a href="#gitGuidetopic-1" target="_self">checkout a repository</a> <a href="#gitGuidetopic-2" target="_self">workflow</a> <a href="#gitGuidetopic-3" target="_self">add &amp; commit</a> <a href="#gitGuidetopic-4" target="_self">pushing changes</a> <a href="#gitGuidetopic-5" target="_self">branching</a> <a href="#gitGuidetopic-6" target="_self">update &amp; merge</a> <a href="#gitGuidetopic-7" target="_self">tagging</a> <a href="#gitGuidetopic-8" target="_self">log</a> <a href="#gitGuidetopic-9" target="_self">replace local changes</a> <a href="#gitGuidetopic-10" target="_self">useful hints</a> </div></center>
<h3 id="gitGuidetopic-0">create a new repository</h3>
create a new directory, open it and perform a 
<code>git init</code>
to create a new git repository.
<h3 id="gitGuidetopic-1">checkout a repository</h3>
create a working copy of a local repository by running the command
<code>git clone /path/to/repository</code>
when using a remote server, your command will be
<code>git clone username@host:/path/to/repository</code>
<h3 id="gitGuidetopic-2">workflow</h3>
your local repository consists of three "trees" maintained by git.
the first one is your <code>Working Directory</code> which holds the actual files.
the second one is the <code>Index</code> which acts as a staging area and
finally the <code>HEAD</code> which points to the last commit you've made.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://rogerdudler.github.io/git-guide/img/trees.png">
<h3 id="gitGuidetopic-3">add &amp; commit</h3>
You can propose changes (add it to the <b>Index</b>) using
<code>git add &lt;filename></code>
<code>git add *</code>
This is the first step in the basic git workflow. To actually commit these changes use
<code>git commit -m "Commit message"</code>
Now the file is committed to the <b>HEAD</b>, but not in your remote repository yet.
<h3 id="gitGuidetopic-4">pushing changes</h3>
Your changes are now in the <b>HEAD</b> of your local working copy. To send those changes to your remote repository, execute 
<code>git push origin master</code>
Change <i>master</i> to whatever branch you want to push your changes to.
If you have not cloned an existing repository and want to connect your repository to a remote server, you need to add it with
<code>git remote add origin &lt;server></code>
Now you are able to push your changes to the selected remote server
<h3 id="gitGuidetopic-5">branching</h3>
Branches are used to develop features isolated from each other. The <i>master</i> branch is the "default" branch when you create a repository. Use other branches for development and merge them back to the master branch upon completion.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://rogerdudler.github.io/git-guide/img/branches.png">
create a new branch named "feature_x" and switch to it using
<code>git checkout -b feature_x</code>
switch back to master
<code>git checkout master</code>
and delete the branch again
<code>git branch -d feature_x</code>
a branch is <i>not available to others</i> unless you push the branch to your remote repository
<code>git push origin &lt;branch></code>
<h3 id="gitGuidetopic-6">update &amp; merge</h3>
to update your local repository to the newest commit, execute 
<code>git pull</code>
in your working directory to <i>fetch</i> and <i>merge</i> remote changes.
to merge another branch into your active branch (e.g. master), use
<code>git merge &lt;branch></code>
in both cases git tries to auto-merge changes. Unfortunately, this is not always possible and results in <i>conflicts</i>.
You are responsible to merge those <i>conflicts</i>
manually by editing the files shown by git. After changing, you need to mark them as merged with
<code>git add &lt;filename></code>
before merging changes, you can also preview them by using
<code>git diff &lt;source_branch> &lt;target_branch></code>
<h3 id="gitGuidetopic-7">tagging</h3>
it's recommended to create tags for software releases. this is a known concept, which also exists in SVN. You can create a new tag named <i>1.0.0</i> by executing
<code>git tag 1.0.0 1b2e1d63ff</code>
the <i>1b2e1d63ff</i> stands for the first 10 characters of the commit id you want to reference with your tag. You can get the commit id by looking at the... 
<h3 id="gitGuidetopic-8">log</h3>
in its simplest form, you can study repository history using..
<code>git log</code>
You can add a lot of parameters to make the log look like what you want. To see only the commits of a certain author:
<code>git log --author=bob</code>
To see a very compressed log where each commit is one line:
<code>git log --pretty=oneline</code>
Or maybe you want to see an ASCII art tree of all the branches, decorated with the names of tags and branches: 
<code>git log --graph --oneline --decorate --all</code>
See only which files have changed: 
<code>git log --name-status</code>
These are just a few of the possible parameters you can use. For more, see
<code>git log --help</code>
<h3 id="gitGuidetopic-9">replace local changes</h3>
In case you did something wrong, which for sure never happens ;), you can replace local changes using the command
<code>git checkout -- &lt;filename></code>
this replaces the changes in your working tree with the last content in HEAD. Changes already added to the index, as well as new files, will be kept.
If you instead want to drop all your local changes and commits, fetch the latest history from the server and point your local master branch at it like this
<code>git fetch origin</code>
<code>git reset --hard origin/master</code>
<h3 id="gitGuidetopic-10">useful hints</h3>
built-in git GUI
<code>gitk</code>
use colorful git output
<code>git config color.ui true</code>
show log on just one line per commit
<code>git config format.pretty oneline</code>
use interactive adding
<code>git add -i</code>


<h2>Working on Git Bash</h2>
<div id="GitBashtoc" class="toc"><a href="#GitBashtopic-0" target="_self">Working on Git Bash</a><br><a href="#GitBashtopic-1" target="_self"> What is Git?</a><br><a href="#GitBashtopic-2" target="_self"> Installing Git Bash</a><br><a href="#GitBashtopic-3" target="_self"><span class="orange">Navigate in Git Bash</span></a><br><a href="#GitBashtopic-4" target="_self"> cd command</a><br><a href="#GitBashtopic-5" target="_self"> ls command</a><br><a href="#GitBashtopic-6" target="_self"> Set your global username/email configuration</a><br><a href="#GitBashtopic-7" target="_self"> Initializing a Local repository</a><br><a href="#GitBashtopic-8" target="_self"> Push files to your Git repository</a><br><a href="#GitBashtopic-9" target="_self"> Saving changes to local repository</a><br><a href="#GitBashtopic-10" target="_self"><span class="orange">Branching through Git Bash</span></a><br><a href="#GitBashtopic-11" target="_self"> Branching in Github</a><br><a href="#GitBashtopic-12" target="_self"> Navigating between Branches</a><br><a href="#GitBashtopic-13" target="_self"> Merge any two branches</a><br><a href="#GitBashtopic-14" target="_self"> Cloning Repository to system</a><br><a href="#GitBashtopic-15" target="_self"> Undoing commits</a><br><a href="#GitBashtopic-16" target="_self"> Conclusion</a><br><a href="#GitBashtopic-17" target="_self">What is Git Bash?</a><br><a href="#GitBashtopic-18" target="_self">Downloading and Installing Git (Bash)</a><br><a href="#GitBashtopic-19" target="_self">Running Git Commands in Different Terminals</a><br><a href="#GitBashtopic-20" target="_self">Running Linux Commands in Git Bash</a><br></div></center>
Git Bash is an application that provides Git command line experience on the Operating System. 
It is a command-line shell for enabling git with the command line in the system. 
A shell is a terminal application used to interface with an operating system through written commands. 
Git Bash is a package that installs Bash, some common bash utilities, and Git on a Windows operating system. 
In Git Bash the user interacts with the repository and git elements through the commands.
<h4 id="GitBashtopic-1"> What is Git?</h4>
<a href="https://www.geeksforgeeks.org/git-lets-get-into-it/" rel="noopener" target="_blank">Git</a> is version-control system for tracking changes in source code during software development.
It is designed for coordinating work among programmers, but it can be used to track changes in any set of files.
Its goal is to increase efficiency, speed and easily manage large projects through version controlling.
Every git working directory is a full-fledged repository with complete history and full version-tracking capabilities, independent of network access or a central server.
Git helps the team cope up with the confusion that tends to happen when multiple people are editing the same files.

<h4 id="GitBashtopic-2"> Installing Git Bash</h4>
Follow the steps given below to install Git Bash on Windows:
Step 1: The .exe file installer for Git Bash can be downloaded from <a href="https://gitforwindows.org/">https://gitforwindows.org/</a>
Once downloaded execute that installer, following window will occur:-

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200420211335/GitInstall.jpg" alt="" width="588" height="478" class="aligncenter size-full wp-image-1675377">

Step 2: Select the components that you need to install and click on the Next button.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200420212305/git-1.jpg" alt="" width="581" height="477" class="aligncenter size-full wp-image-1675417">



Step 3: Select how to use the Git from command-line and click on Next to begin the installation process.

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200420212300/git22.jpg" alt="" width="585" height="475" class="aligncenter size-full wp-image-1675413">

Step 4: Let the installation process finish to begin using Git Bash.

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200420212254/git3.jpg" alt="" width="581" height="479" class="aligncenter size-full wp-image-1675411">
To open Git Bash navigate to the folder where you have installed the git otherwise just simply search in your OS for git bash.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200421160427/Screenshot-2920.png" alt="" width="803" height="765" class="aligncenter size-full wp-image-1678357">
<h3 id="GitBashtopic-3"><span class="orange">Navigate in Git Bash</span></h3>
<h4 id="GitBashtopic-4"> cd command</h4>
cd command refers to change directory and is used to get into the desired directory.To navigate between the folders the cd command is used
Syntax:
cd folder_name

<h4 id="GitBashtopic-5"> ls command</h4>
ls command is used to list all the files and folders in the current directory.
Syntax:
ls

<h4 id="GitBashtopic-6"> Set your global username/email configuration</h4>
Open Git Bash and begin creating a username and email for working on Git Bash.Set your username:
git config --global user.name "FIRST_NAME LAST_NAME"
Set your email address:
git config --global user.email "MY_NAME@example.com"

<h4 id="GitBashtopic-7"> Initializing a Local repository</h4>
Follow the steps given below to initialize your Local Repository with Git:
Step 1: Make a repository on <a href="www.github.com">Github</a>

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200421144627/git-4.jpg" alt="" width="510" height="233" class="aligncenter size-full wp-image-1677989">

Step 2: Give a suitable name of your repository and create the repository
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200421145045/git5.jpg" alt="" width="932" height="838" class="aligncenter size-full wp-image-1678005">
Note: You can choose to initialize your git repository with a README file, and further, you can mention your project details in it. 
It helps people know what this repository is about. 
However, it’s absolutely not necessary. 
But if you do initialize your repo with a README file using interface provided by GitHub, then your local repository won’t have this README file. 
So to avoid running into a snag while trying to push your files (as in step 3 of next section), after step 5 (where you initialize your local folder as your git repository), do following to pull that file to your local folder:
git pull <repository_url>

Step 3: The following will appear after creating the repository
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200421145943/git6.jpg" alt="" width="1320" height="798" class="aligncenter size-full wp-image-1678043">

Step 4: Open Git Bash and change the current working directory to your local project by use of cd command.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200421151907/git-7.jpg" alt="" width="743" height="439" class="aligncenter size-full wp-image-1678146">

Step 5: Initialize the local directory as a Git repository.
 git init 

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200421152107/git-8.jpg" alt="" width="745" height="450" class="aligncenter size-full wp-image-1678156">

Step 6: Stage the files for the first commit by adding them to the local repository
git add .

Step 7: By “git status” you can see the staged files

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200421152939/git9.jpg" alt="" width="740" height="448" class="aligncenter size-full wp-image-1678200">

Step 8: Commit the files that you’ve staged in your local repository.
git commit -m "First commit"

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200421153825/git10.jpg" alt="" width="745" height="451" class="aligncenter size-full wp-image-1678232">
Now After “git status” command it can be seen that nothing to commit is left, Hence all files have been committed.
<h4 id="GitBashtopic-8"> Push files to your Git repository</h4>

Step 1: Go to Github repository and in code section copy the URL.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200421154837/git11.jpg" alt="" width="1253" height="594" class="aligncenter size-full wp-image-1678273">

Step 2: In the Command prompt, add the URL for your repository where your local repository will be pushed.
git remote add origin repository_URL

Step 3: Push the changes in your local repository to GitHub.
git push origin master
Here the files have been pushed to the master branch of your repository.

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200421155539/git12.png" alt="" width="742" height="449" class="aligncenter size-full wp-image-1678303">

Now in the GitHub repository, the pushed files can be seen.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200421155736/git13.png" alt="" width="1284" height="593" class="aligncenter size-full wp-image-1678317">

<h4 id="GitBashtopic-9"> Saving changes to local repository</h4>
Suppose the files are being changed and new files are added to local repository.
To save the changes in the git repository:

Step 1: Changes have to be staged for the commit.
git add .
or
git add file_name

Step 2: Now commit the staged files.
git commit -m "commit_name"

Step 3: Push the changes.
git push origin master

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200421165540/git-14.png" alt="" width="743" height="451" class="aligncenter size-full wp-image-1678619">
New changes can be seen

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200421170052/git-15.png" alt="" width="1323" height="598" class="aligncenter size-full wp-image-1678646">
<h3 id="GitBashtopic-10"><span class="orange">Branching through Git Bash</span></h3>
<h4 id="GitBashtopic-11"> Branching in Github</h4>
Suppose if a team is working on a project and a branch is created for every member working on the project.
Hence every member will work on their branches hence every time the best branch is merged to the master branch of the project.
The branches make it version controlling system and makes it very easy to maintain a project source code.Syntax:List all of the branches in your repository.
git branch

Create a new branch
git branch branch_name

Safe Delete the specified branch
git branch -d branch_name

Force delete the specified branch
git branch -D branch_name


<h4 id="GitBashtopic-12"> Navigating between Branches</h4>
To navigate between the branches git checkout is used.To create create a new branch and switch on it:
git checkout -b new_branch_name
To simply switch to a branch
git checkout branch_name
After checkout to branch you can see a * on the current branch

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200421182445/git-17.png" alt="" width="748" height="449" class="aligncenter size-full wp-image-1679040">
Now the same <code>commit add</code> and <code>commit actions</code> can be performed on this branch also.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200421183255/git-18.png" alt="" width="609" height="163" class="aligncenter size-full wp-image-1679074">

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200421183253/git19.png" alt="" width="648" height="266" class="aligncenter size-full wp-image-1679073">

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200421183249/git-20.png" alt="" width="1335" height="724" class="aligncenter size-full wp-image-1679071">

<h4 id="GitBashtopic-13"> Merge any two branches</h4>
To merge a branch in any branch:First reach to the target branch
git checkout branch_name

Merge the branch to target branch
git merge new_branch


<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200421233834/gi21.png" alt="" width="704" height="258" class="aligncenter size-full wp-image-1680678">

<h4 id="GitBashtopic-14"> Cloning Repository to system</h4>
Cloning is used to get a copy of the existing git repository.
When you run the git clone command it makes the zip folder saved in your default location
git clone url
This command saves the directory as the default directory name of the git repository
To save directory name as your custom name an additional argument is to be passed for your custom name of directory
git clone url custom_name

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200421234934/git22.png" alt="" width="715" height="202" class="aligncenter size-full wp-image-1680706">

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://media.geeksforgeeks.org/wp-content/uploads/20200421234938/git-23.png" alt="" width="1252" height="84" class="aligncenter size-full wp-image-1680707">

<h4 id="GitBashtopic-15"> Undoing commits</h4>
When there is a situation when you forget to add some files to commit and want to undo any commit, it can be commit again using <code>--ammend</code>Syntax:
git commit --amend

<h4 id="GitBashtopic-16"> Conclusion</h4>
To conclude it can be said that git bash is a command line platform which helps in enabling git and its elements in your system.
There are a bunch of commands which are used in git bash.
Git Bash is very easy to use and makes it easy to work on repositories and projects.

<h3 id="GitBashtopic-17">What is Git Bash?</h3>
Before you look at what Git Bash is, let's go over what <a href="https://en.wikipedia.org/wiki/Git" target="_blank" rel="noreferrer noopener nofollow">Git</a> is. 
Git is a version control system for controlling changes in software development. 
Like macOS and Linux, operating systems already have a command-line terminal where you can run Git and Linux commands directly. 
But for Windows, you have the Windows command prompt, which is a non-Unix terminal.
How can you run Git and Linux commands in Windows? Git Bash will do the trick. 
Git Bash is an <a href="https://en.wikipedia.org/wiki/Emulator" target="_blank" rel="noreferrer noopener nofollow">emulator</a> that provides an emulation layer for Git to run Linux commands on Windows PCs. 
An emulator enables one specific system to behave like another computer system.
<h3 id="GitBashtopic-18">Downloading and Installing Git (Bash)</h3>
Now that you know a little about Git Bash let's see how you can download and install it. 
There are three different ways of downloading the Git software for Windows OS, as shown below.
Through <a href="https://git-scm.com/download/win" target="_blank" rel="noreferrer noopener nofollow">Git's official website</a>
Through a separate project on GitHub called <a href="https://git-for-windows.github.io/" target="_blank" rel="noreferrer noopener nofollow">Git for Windows.</a>
Through a software package manager like <a href="https://chocolatey.org/" target="_blank" rel="noreferrer noopener nofollow">Chocolatey</a>

Download Git with any of the three ways you prefer, but this tutorial will use the official website.
After downloading Git, let's start installing it on your Windows PC.
1. Launch the installer you downloaded and click <strong>Next</strong> through the steps until you get to the <strong>Select Components</strong> screen.
2. Now, check the boxes of additional components you want to include in the installation. 
Leave the ones selected by default, as shown below, and click <strong>Next</strong>. 

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://adamtheautomator.com/wp-content/uploads/2021/08/Untitled-2021-08-31T160017.819.png">
 Selecting Additional Components To Install

3. Leave the default for creating a shortcut in the start menu folder, and click <strong>Next</strong>. 

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://adamtheautomator.com/wp-content/uploads/2021/08/Untitled-2021-08-31T160058.642.png">
 Selecting Start menu folder name

4. Select <strong>Use Notepad as Git's default editor</strong> from the drop-down list as a default editor to use with Git, and click <strong>Next</strong>. 
Now Git files like <em><a href="https://www.atlassian.com/git/tutorials/setting-up-a-repository/git-config" target="_blank" rel="noreferrer noopener nofollow">~./gitconfig</a></em> will open in Notepad by default. 

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://adamtheautomator.com/wp-content/uploads/2021/08/Untitled-2021-08-31T160129.657.png">
 Selecting Git's Default Editor

5. Select the <strong>Override the default branch name for new repositories</strong> option as the default branch name (<strong>main</strong>) for Git to use. 
When you initialize a Git repository, Git will use this branch name by default. 

The default branch name used to be “master” for Git repositories. 
But many people found “master” an offensive word. 
So GitHub followed the <a href="https://sfconservancy.org/news/2020/jun/23/gitbranchname/" target="_blank" rel="noreferrer noopener nofollow">Software Freedom Conservancy's</a> suggestion and provided an option to override the default branch name when initializing a Git repository. 

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://adamtheautomator.com/wp-content/uploads/2021/08/Untitled-2021-08-31T160213.065.png">
 Selecting Default Branch Name

6. Now, select <strong>Git from the command line and also from 3rd-party software</strong> option so that Git command can be executed from different tools. 
Some of those tools are Command Prompt, PowerShell or any other 3rd party software tools, along with the Git Bash console. 

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://adamtheautomator.com/wp-content/uploads/2021/08/Untitled-2021-08-31T160304.183.png">
 Selecting a Console Where Git Commands Can Run

7. Select the <strong>Use the <a href="https://en.wikipedia.org/wiki/OpenSSL" target="_blank" rel="noreferrer noopener nofollow">OpenSSL</a> library</strong> option to let Git validate certificates with OpenSSL, and click <strong>Next</strong>. 
OpenSSL is a cryptographic library that contains open-source implementation of SSL and TLS protocols. 

If you are using Git in an organization with enterprise-managed certificates, select the <strong>User the native Windows Secure Channel library</strong> option instead. 

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://adamtheautomator.com/wp-content/uploads/2021/08/Untitled-2021-08-31T160352.415.png">
 Selecting SSL/TLS library for HTTPS connections

8. Leave the default <strong>Checkout Windows-style, commit Unix-style line endings</strong> option selected, and click <strong>Next</strong>. 

If you configure “Windows-style” line ending conversions, when you hit return on your keyboard after executing a Git command, Git will insert an invisible character called <a href="https://docs.github.com/en/get-started/getting-started-with-git/configuring-git-to-handle-line-endings#about-line-endings" target="_blank" rel="noopener">line ending</a>. 
When different contributors make changes from different operating systems, Git might produce unexpected results. 

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://adamtheautomator.com/wp-content/uploads/2021/08/Untitled-2021-08-31T160446.764.png">
 Selecting line endings option

9. Select the <strong>Use Mintty (the default terminal of MSYS2)</strong> option as the default terminal emulator to run commands, and click <strong>Next</strong>. 
Mintty is the default terminal of <a href="https://www.msys2.org/wiki/MSYS2-introduction/" target="_blank" rel="noreferrer noopener nofollow">MSYS2</a>. 
MSYS2 is a collection of tools and libraries that provides a Unix-like environment for software distribution and a building platform for Windows. 

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://adamtheautomator.com/wp-content/uploads/2021/08/Untitled-2021-08-31T160521.451.png">
 Selecting a default terminal emulator

10. Select the <strong>Default (fast-forward or merge)</strong> option below as <code><a href="https://github.com/git-guides/git-pull" target="_blank" rel="noreferrer noopener nofollow">git pull</a></code> command's default behavior. 
The <code>git pull</code> command is the shorthand for <code><a href="https://git-scm.com/docs/git-fetch" target="_blank" rel="noreferrer noopener nofollow">git fetch</a></code> and <code><a href="https://git-scm.com/docs/git-merge" target="_blank" rel="noreferrer noopener nofollow">git merge</a></code>, which fetches and incorporates changes from a remote repository into the current branch. 

Perhaps you want to merge a new branch to the master. 
If so, Git would directly merge using fast-forward without going through <code>git fetch</code> and <code>git merge</code> commands. 
The merge is only possible if there are no commits on master from when you've created the new branch. 

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://adamtheautomator.com/wp-content/uploads/2021/08/Untitled-2021-08-31T160617.398.png">
 Selecting Default Behavior for <code>git pull</code> Command

11. Select the <strong>Git Credential Manager Core</strong> as the default <a href="https://git-scm.com/docs/gitcredentials" target="_blank" rel="noreferrer noopener nofollow">Git credential helper</a>, and click <strong>Next</strong>. 
Git credential helpers are external programs that Git can prompt for input data, like usernames and passwords. 
These input data can be stored in memory for a limited time or stored on the disk. 

Git Credential Manager Core is based on the .NET framework and will provide multi-factor HTTPS authentication with Git. 

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://adamtheautomator.com/wp-content/uploads/2021/08/Untitled-2021-08-31T160805.216.png">
 Selecting Default Credential Manager

12. Leave the extra features on default, as shown below, and click <strong>Next</strong>. 
The <strong>Enable file system caching</strong> option is checked to provide quick results when executing Git commands. 

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://adamtheautomator.com/wp-content/uploads/2021/08/Untitled-2021-08-31T161004.649.png">
 Enabling extra options

13. Ensure to leave both options below at default (<strong><a href="https://docs.microsoft.com/en-us/windows/console/pseudoconsoles" target="_blank" rel="noopener">pseudo console</a></strong> and <strong><a href="https://github.com/git-for-windows/git/discussions/3251" target="_blank" rel="noopener">built-in file system monitor</a></strong>) as they are still in an experimental stage, and click <strong>Install</strong>. 

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://adamtheautomator.com/wp-content/uploads/2021/08/Untitled-2021-08-31T161045.192.png">
 Experimental options support

14. Complete the installation and close the installation wizard by clicking on <strong>Finish</strong>. 

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://adamtheautomator.com/wp-content/uploads/2021/08/Untitled-2021-08-31T161121.891.png">
 Git setup wizard complete screen

15. Finally, right-click on your desktop and select <strong>Git Bash Here</strong> from the context menu, as shown below, to launch Git Bash terminal. 
Launching Git Bash from your desktop is one of the quickest ways to do so, but the same process goes when you right-click on a folder. 

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://adamtheautomator.com/wp-content/uploads/2021/08/version-1.png">
 Launching Git Bash from Desktop Context Menu

16. Run the <code>git</code> command below to verify Git Bash is installed and its current version (<code>--version</code>). 

<code>git --version</code></repository_url>
You can see below the current Git version in this tutorial is <strong>version 2.32.0.windows.2.</strong> 
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://adamtheautomator.com/wp-content/uploads/2021/08/version.png">
 Verifying Git Bash installation

<h3 id="GitBashtopic-19">Running Git Commands in Different Terminals</h3>
Now that you have Git Bash on your PC, it's time to learn some Git commands. 
Running Git commands isn't limited to Git Bash console only. 
Did you know you can run Git commands in the command prompt too? Yes!
Let's run Git commands both on Git Bash console and command prompt to declare variables accessible in both terminals.
1. Launch Git Bash console by clicking on the Start button, type <strong>git</strong>, and click on <strong>Git Bash</strong>. 

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://adamtheautomator.com/wp-content/uploads/2021/08/open-git.png">
Launching Git Bash from Start Button

2. Run the below <code><a href="https://git-scm.com/book/en/v2/Getting-Started-First-Time-Git-Setup" target="_blank" rel="noreferrer noopener nofollow">git config</a></code> command to add your name (<code>YourName</code>) as your <a href="https://docs.github.com/en/get-started/getting-started-with-git/setting-your-username-in-git" target="_blank" rel="noreferrer noopener nofollow">git username</a> (<code>user.name</code>). 
The <code>git config</code> command administers configuration variables that control how Git looks and operates. 

Pass the <code>--global</code> option to the <code>git config</code> command to define the configuration variable (<code>YourName</code>) in the <em>~/.gitconfig</em> file specifically. 

<code>git config --global user.name "YourName"</code>
3. Now open the command prompt and run the below <code>git config</code> command to add your email (<code>"<a href="/cdn-cgi/l/email-protection" data-cfemail="96c2f3e5e2d3fbf7fffad6fbf7fffab8f5f9fb">[email&nbsp;protected]</a>"</code>) as your <a href="https://docs.github.com/en/account-and-profile/setting-up-and-managing-your-github-user-account/managing-email-preferences/setting-your-commit-email-address" target="_blank" rel="noreferrer noopener nofollow">git user email</a> (<code>--global user.email</code>) in the <em>~/.gitconfig</em> file. 

<code>git config --global user.email "<a href="/cdn-cgi/l/email-protection" data-cfemail="a4f0c1d7d0e1c9c5cdc8e4c9c5cdc88ac7cbc9">[email&nbsp;protected]</a>"</code>
4. In the same command prompt window, run the below <code>git config</code> command to list (<code>--list</code>) all the configuration variables in Git. 

<code>git config --list</code>
You can see below that even though you've added variables in the <em>~/.gitconfig</em> file via different consoles, the variables are accessible and displayed in the command prompt. 

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://adamtheautomator.com/wp-content/uploads/2021/08/cmd-displayed.png">
Viewing Global Variables Added via Different Consoles

<h3 id="GitBashtopic-20">Running Linux Commands in Git Bash</h3>
As you can tell, all Git commands work in both Git Bash and the command prompt. 
And since Git is delivered as a Unix-style command-line environment, let's try running a Linux command on the Git Bash console!
Run the <code>ls</code> command both in Git Bash console and command prompt to list the files and folders in the working directory.
In the screenshots below, you can see that the Git Bash console returns an output, while the command prompt throws an error, saying the <strong>‘ls'</strong> command is not recognized.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://adamtheautomator.com/wp-content/uploads/2021/08/gitbash.png">
 Running Linux Command in Git Bash Returns a Result

<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://adamtheautomator.com/wp-content/uploads/2021/08/cmd.png">
 Running Linux Command in Command Prompt Returns an Error

You can run Linux commands on the command prompt so long as you change the directory to <em>C:\Program Files\Git\usr\bin</em> first.
In the command prompt, run the commands below to change the working directory to <code>C:\Program Files\Git\usr\bin</code> and run the <code>ls</code> command.

<code>cd C:\Program Files\Git\usr\bin # Change directory to where Linux utilities are stored
ls # Linux command that lists all files and folders in the working directory</code>
Below, you can see that you didn't get an error after running the <code>ls</code> command this time, but the command returned results instead.
<img class="lazy" data-src="https://youwuqiong.top/wp-admin/img.php?imgUrl=https://adamtheautomator.com/wp-content/uploads/2021/08/Untitled-2021-08-31T161830.266.png">
 Running Linux Commands in Command Prompt

<h2>Git Viewing the Commit History</h2>
$ git log
to exit git log or git diff
Type q to exit this screen.
Type h to get help.

Actually, there are three ways to do it, precisely.
:q
:z or
Ctrl + z

Reverting a commit that has been pushed to the remote
git checkout [commit ID] filename

<h2>git push --set-upstream origin branch</h2>
If you do not have upstream for the current branch, Git changes its behavior on <code>git push</code>, and on other commands as well.

The complete push story here is long and boring.  
To shorten it a whole lot, <code>git push</code> was implemented poorly.
<h3>What is an upstream?</h3>
An <em>upstream</em> is simply another branch name, usually a remote-tracking branch, associated with a (regular, local) branch.

Every branch has the option of having one (1) upstream set.  
That is, every branch either has an upstream, or does not have an upstream.  
No branch can have more than one upstream.

The upstream <em>should</em>, but does not have to be, a valid branch (whether remote-tracking like <code>origin/<em>B</em></code> or local like <code>master</code>).  
That is, if the current branch <em>B</em> has upstream <em>U</em>, <code>git rev-parse <em>U</em></code> <em>should</em> work.  
If it does not work—if it complains that <em>U</em> does not exist—then most of Git acts as though the upstream is not set at all.  
A few commands, like <code>git branch -vv</code>, will show the upstream setting but mark it as "gone".

<h3>What good is an upstream?</h3>
If your <code>push.default</code> is set to <code>simple</code> or <code>upstream</code>, the upstream setting will make <code>git push</code>, used with no additional arguments, just work.

That's it—that's all it does for <code>git push</code>.  
But that's fairly significant, since <code>git push</code> is one of the places where a simple typo causes major headaches.

If your <code>push.default</code> is set to <code>nothing</code>, <code>matching</code>, or <code>current</code>, setting an upstream does nothing at all for <code>git push</code>.

(All of this assumes your Git version is at least 2.0.)

<h3>The upstream affects <code>git fetch</code></h3>

If you run <code>git fetch</code> with no additional arguments, Git figures out <em>which</em> remote to fetch from by consulting the current branch's upstream.  
If the upstream is a remote-tracking branch, Git fetches from that remote.  
(If the upstream is not set or is a local branch, Git tries fetching <code>origin</code>.)

<h3>The upstream affects <code>git merge</code> and <code>git rebase</code> too</h3>

If you run <code>git merge</code> or <code>git rebase</code> with no additional arguments, Git uses the current branch's upstream.  
So it shortens the use of these two commands.

<h3>The upstream affects <code>git pull</code></h3>

You should never
2. use <code>git pull</code> anyway, but if you do, <code>git pull</code> uses the upstream setting to figure out which remote to fetch from, and then which branch to merge or rebase with.  
That is, <code>git pull</code> does the same thing as <code>git fetch</code>—because it actually <em>runs</em> <code>git fetch</code>—and then does the same thing as <code>git merge</code> or <code>git rebase</code>, because it actually <em>runs</em> <code>git merge</code> or <code>git rebase</code>.

(You should usually just do these two steps manually, at least until you know Git well enough that when either step fails, which they will eventually, you recognize what went wrong and know what to do about it.)

<h3>The upstream affects <code>git status</code></h3>

This may actually be the most important.  
Once you have an upstream set, <code>git status</code> can report the difference between your current branch and its upstream, in terms of commits.

If, as is the normal case, you are on branch <em><code>B</code></em> with its upstream set to <code>origin/<em>B</em></code>, and you run <code>git status</code>, you will immediately see whether you have commits you can push, and/or commits you can merge or rebase onto.

This is because <code>git status</code> runs:

<code>git rev-list --count @{u}..HEAD</code>: how many commits do you have on <em><code>B</code></em> that are not on <code>origin/<em>B</em></code>?

<code>git rev-list --count HEAD..@{u}</code>: how many commits do you have on <code>origin/<em>B</em></code> that are not on <em><code>B</code></em>?

Setting an upstream gives you all of these things.

<h3>How come <code>master</code> already has an upstream set?</h3>

When you first clone from some remote, using:

<code>$ git clone git://some.host/path/to/repo.git</code>

or similar, the last step Git does is, essentially, <code>git checkout master</code>.  
This checks out your local branch <code>master</code>—only you don't <em>have</em> a local branch <code>master</code>.

On the other hand, you <em>do</em> have a remote-tracking branch named <code>origin/master</code>, because you just cloned it.

Git guesses that you must have meant: "make me a new local <code>master</code> that points to the same commit as remote-tracking <code>origin/master</code>, and, while you're at it, set the upstream for <code>master</code> to <code>origin/master</code>."

This happens for <em>every</em> branch you <code>git checkout</code> that you do not already have.  
Git creates the branch <em>and</em> makes it "track" (have as an upstream) the corresponding remote-tracking branch.

<h3>But this doesn't work for <em>new</em> branches, i.e., branches with no remote-tracking branch <em>yet</em>.</h3>

If you create a <em>new</em> branch:

<code>$ git checkout -b solaris</code>

there is, as yet, no <code>origin/solaris</code>.  
Your local <code>solaris</code> <em>cannot</em> track remote-tracking branch <code>origin/solaris</code> because it does not exist.

When you first push the new branch:

<code>$ git push origin solaris</code>

that <em>creates</em> <code>solaris</code> on <code>origin</code>, and hence also creates <code>origin/solaris</code> in your own Git repository.  
But it's too late: you already have a local <code>solaris</code> that <em>has no upstream</em>.

3.
<h3>Shouldn't Git just set that, now, as the upstream automatically?</h3>

Probably.  
See "implemented poorly" and footnote 1.  
It's hard to change <em>now</em>: There are millions

4. of scripts that use Git and some may well depend on its current behavior.  
Changing the behavior requires a new major release, nag-ware to force you to set some configuration field, and so on.  
In short, Git is a victim of its own success: whatever mistakes it has in it, today, can only be fixed if the change is either mostly invisible, clearly-much-better, or done slowly over time.

The fact is, it doesn't today, <em>unless</em> you use <code>--set-upstream</code> or <code>-u</code> during the <code>git push</code>.  
That's what the message is telling you.

You don't have to do it like that.  
Well, as we noted above, you don't have to do it at all, but let's say you <em>want</em> an upstream.  
You have already created branch <code>solaris</code> on <code>origin</code>, through an earlier push, and as your <code>git branch</code> output shows, you already <em>have</em> <code>origin/solaris</code> in your local repository.

You just don't have it set as the upstream for <code>solaris</code>.

To set it now, rather than during the first push, use <code>git branch --set-upstream-to</code>.  
The <code>--set-upstream-to</code> sub-command takes the name of any existing branch, such as <code>origin/solaris</code>, and sets the current branch's upstream to that other branch.

That's it—that's all it does—but it has all those implications noted above.  
It means you can just run <code>git fetch</code>, then look around, then run <code>git merge</code> or <code>git rebase</code> as appropriate, then make new commits and run <code>git push</code>, without a bunch of additional fussing-around.

1.To be fair, it was not clear back then that the initial implementation was error-prone.  
That only became clear when every new user made the same mistakes every time.  
It's now "less poor", which is not to say "great".

2."Never" is a bit strong, but I find that Git newbies understand things a lot better when I separate out the steps, especially when I can show them what <code>git fetch</code> actually did, and they can then see what <code>git merge</code> or <code>git rebase</code> will do next.

3.If you run your <em>first</em> <code>git push</code> as <code>git push -u origin solaris</code>—i.e., if you add the <code>-u</code> flag—Git will set <code>origin/solaris</code> as the upstream for your current branch if (and only if) the push succeeds.  
So you should supply <code>-u</code> on the <em>first</em> push.  
In fact, you can supply it on any later push, and it will set <em>or change</em> the upstream at that point.  
But I think <code>git branch --set-upstream-to</code> is easier, if you forgot.

4.Measured by the Austin Powers / Dr Evil method of simply saying "one MILLLL-YUN", anyway.

<h2>Push to github without typing user name / password</h2>
<h3><strong>1. Using SSH</strong></h3>If you need to do a push without username and password prompt, but you are always prompted, then your origin remote is pointing at the https url rather than the ssh url.
A way to skip typing my username/password when using https://github, is by changing the HTTPs origin remote which pointing to an HTTP url into an SSH url.

For example,
<k>https url: https://github.com/&lt;Username>/&lt;Project>.git
ssh url: git@github.com:&lt;Username>/&lt;Project>.git</k>
You can do:
<k>git remote set-url origin git@github.com:&lt;Username>/&lt;Project>.git</k>
to change the url.

<strong>Switching remote URLs from HTTPS to SSH</strong>
Open Terminal (for Mac and Linux users) or the command prompt (for Windows).
Change the current working directory to your local project.
List your existing remotes in order to get the name of the remote you want to change.
git remote -v
$ origin https://github.com/USERNAME/REPOSITORY.git (fetch)
$ origin https://github.com/USERNAME/REPOSITORY.git (push)
Change your remote’s URL from HTTPS to SSH with the git remote set-url command.
git remote set-url origin git@github.com:USERNAME/OTHERREPOSITORY.git
Verify that the remote URL has changed.

git remote -v
$ Verify new remote URL
$ origin git@github.com:USERNAME/OTHERREPOSITORY.git (fetch)
$ origin git@github.com:USERNAME/OTHERREPOSITORY.git (push)

<h3><strong>2. Using Static configuration</strong></h3>Static configuration of usernames for a given authentication context.
It is generally configured by adding this to your config:

[credential “https://example.com&quot;] username = me

The password was not declared because of security reasons. It is not advisable to store your password on an unsecure storage.

<h3>3. <strong>Credential helpers to cache or store passwords, or to interact with a system password wallet or keychain</strong>.</h3>These are external programs from which Git can request both usernames and passwords
To use a helper, you must first select one to use. Git currently includes the following helpers:
cache: Cache credentials in memory for a short period of time.
store: Store credentials indefinitely on disk.

Steps:
a.Find a helper.
$ git help -a | grep credential-credential-foo

b.Read its description.
$ git help credential-foo

c.Tell Git to use it.
$ git config — global credential.helper foo


<h2>Multiple Branches in Git</h2>
<div id="MultipleBranchestoc" class="toc"><a href="#MultipleBranchestopic-0" target="_self"><span class="orange">Introduction</span></a><br><a href="#MultipleBranchestopic-1" target="_self"><span class="orange">Worktree</span></a><br><a href="#MultipleBranchestopic-2" target="_self"><span class="orange">Example</span></a><br><a href="#MultipleBranchestopic-3" target="_self">Create a new repo</a><br><a href="#MultipleBranchestopic-4" target="_self">Create a new branch</a><br><a href="#MultipleBranchestopic-5" target="_self">Create new worktree branch</a><br><a href="#MultipleBranchestopic-6" target="_self">Make changes in new worktree branch</a><br><a href="#MultipleBranchestopic-7" target="_self">Merge my hotfix back into master</a><br><a href="#MultipleBranchestopic-8" target="_self">Removing the worktree</a><br><a href="#MultipleBranchestopic-9" target="_self">Continuing working on my feature branch</a><br></div>
<h3 id="MultipleBranchestopic-0"><span class="orange">Introduction</span></h3>
There are times where you might be working from a particular git branch and need to quickly jump over to a different branch to do some urgent work.

Typically you would need to first <code>git stash</code> anything you were working on (as it's unlikely to be in a state where it can be committed), and then you'd have to leave your current branch to create a new branch from <code>master</code> and thus begin working on your new urgent task.

This is a fairly straightforward workflow, but there is a mild annoyance which is that I happen to <code>git stash</code> <em>a lot</em> and I find when jumping over to a new branch to do some urgent work that I might end up <code>git stash</code>‘ing a few more times along the way.

Ultimately, when I'm done with my urgent task and ready to go back to my other branch, I then have to sift through my stash to find the relevant one I want to pop. 
OK so not that tragic considering <code>git stash list</code> will indicate the branch on which the stash was taken (which helps), but I do then need to Google what the syntax is for popping a specific stash (e.g. 
it's <code>git stash apply stash@{n}</code> where <code>n</code> is the index you want to apply.)

Note: for the life of me I wish I could remember the syntax but it just eludes me every time.

Oh, and then you have to think about whether you actually want to use <code>apply</code>, which leaves the stashed changes in the stack, or if you meant to actually <code>pop</code> the stashed content (<code>git stash pop stash@{n}</code>) so it's properly removed from the stack.

This is where I was recently introduced to a concept in git referred to as a ‘worktree' (thanks Kiran).

<h3 id="MultipleBranchestopic-1"><span class="orange">Worktree</span></h3>
Git offers a feature referred to as a <a href="https://git-scm.com/docs/git-worktree">worktree</a>, and what it does is allow you to have multiple branches running at the same time.

It does this by creating a new directory for you with a copy of your git repository that is synced between the two directories where they are stored.

This is different to manually creating a new directory and git cloning your repo down, because with the worktree model the two sub directories are aware of each other.

Note: as you'll see, although this workflow is pretty cool, you <em>could</em> argue that <code>git stash</code> is just plain simpler and easier for a human mind to reason about. 
I'll leave that up to the reader to decide.

<h3 id="MultipleBranchestopic-2"><span class="orange">Example</span></h3>
In the following example I'm going to create a new git repo. 
I'll make a change in <code>master</code>, then create a new branch for doing some work. 
We'll then imagine that I have been given an urgent task that I must complete <em>now</em> and yet my current non-master branch is in such a state that I want to avoid just stashing everything.

Note: I use tmux to split my terminal into multiple windows, and this demonstration will require two windows (or two separate terminal instances if you're not using a screen multiplexer) for the sake of demonstration.

<h3 id="MultipleBranchestopic-3">Create a new repo</h3>
<code>mkdir foo_project
cd foo_project
touch foo
git add foo
git commit -m "created foo file"</code>

<h3 id="MultipleBranchestopic-4">Create a new branch</h3>
<code>git checkout -b foo_contents
echo 123 > foo
git add -u
git commit -m "added content to foo"</code>

Now I'll create a new file and stage it for committing, but I won't commit it (this is where we pretend my branch is in some hideously complex state).

<h3 id="MultipleBranchestopic-5">Create new worktree branch</h3>
<code>git worktree add ../foo_hotfix</code>

Note: you'll want to create the new worktree in a directory outside of your current repo's directory (just so there's a clear distinction).

At this point you'll find your current terminal is still in the same <code>foo_contents</code>, but there is now a new directory called <code>foo_hotfix</code> outside your current repo's directory.

<h3 id="MultipleBranchestopic-6">Make changes in new worktree branch</h3>
Open up a new terminal (or split window) and run through the following steps:

<code>cd ./foo_hotfix</code> (or <code>cd ../foo_hotfix</code> if your new terminal is currently set to your main git repo directory)
<code>git log</code>

OK, so if you do a <code>git log</code> you'll find that the worktree has a branch automatically created and named after the worktree (so the branch is called <code>foo_hotfix</code> in my case).

The important thing to realize is that <code>git worktree add</code> is a bit like <code>git branch</code> in that it creates the new worktree from the current branch you're in. 
Meaning that my <code>foo_hotfix</code> branch has the "added content to foo" commit from the <code>foo_contents</code> branch as that's where I ran the <code>git worktree add</code> command from.

This is what <code>git log</code> looks like for me in this new worktree:

<code>* d374dcb (Integralist) - (HEAD -> foo_hotfix, foo_contents) added content to foo (2 minutes ago)
* 9ae3a7f (Integralist) - (master) created foo file (3 minutes ago)
</code>
 don't want the commit <code>d374dcb</code> in there as it's coming from a branch (<code>foo_contents</code>) that's still in progress, and so I'll need to rebase out that commit:

<code>git rebase -i 9ae3a7f</code>

Note: the rebase editor opens and I change <code>pick</code> to <code>drop</code> to get rid of the commit.

Now at this point I have a new working directory that I can work in:

<code>echo hotfix > baz
git add baz
git commit -m "some hotfix"</code>

<h3 id="MultipleBranchestopic-7">Merge my hotfix back into master</h3>
I'm going to change into my <code>master</code> branch, but remember I'm still in the <code>foo_hotfix</code> directory, so my main repo directory <code>foo_project</code> (open in another terminal window) is still in the <code>foo_contents</code> branch).

<code>git checkout master
git merge foo_hotfix</code>

<h3 id="MultipleBranchestopic-8">Removing the worktree</h3>
OK, so at this point we've merged our hotfix into <code>master</code>. 
I want to go back to my original repo directory and make sure I have the latest <code>master</code> rebased in before continuing on with my <code>foo_contents</code> work.

To remove the worktree you can either remove it using the git interface (e.g. 
<code>git worktree remove foo_hotfix</code>) or manually remove it (e.g. 
<code>cd ../ &amp;&amp; rm ./foo_hotfix</code>), where git will, at some point in the future, internally run a prune and remove any references to this orphaned branch/working tree (you could also manually trigger that prune using <code>git worktree prune</code>).

Note: if I do <code>git worktree remove foo_hotfix</code> while currently residing inside the <code>foo_hotfix</code> directory, I'll find that the <code>.git</code> repository is removed from the directory.

<h3 id="MultipleBranchestopic-9">Continuing working on my feature branch</h3>
Presuming I'm still in the <code>foo_hotfix</code> directory and that's where I ran <code>git worktree remove foo_hotfix</code>:

<code>cd ../foo_project
git rebase master</code> &lt; whoops! I need to stash my changes first †
<code>git stash pop</code>

† why yes, this does seem a bit strange considering that's what I was trying to avoid in the first place, but in this case it's a single ‘stash' and so a simple <code>git stash pop</code> will suffice to get me back to where I need to be.

I can now continue working on my <code>foo_contents</code> branch.


<h2>Adding multiple remotes</h2>
<div id="multiRemotestoc" class="toc"><a href="#multiRemotestopic-1" target="_self">Configure primary remote</a><br><a href="#multiRemotestopic-2" target="_self">Change remote URL</a><br><a href="#multiRemotestopic-3" target="_self">List all remotes</a><br><a href="#multiRemotestopic-4" target="_self">Remove a remote</a><br><a href="#multiRemotestopic-5" target="_self">Push to multiple remotes</a><br><a href="#multiRemotestopic-6" target="_self">Pull from multiple remotes</a><br><a href="#multiRemotestopic-7" target="_self">Conclusion</a><br></div>
When you do <code>git init</code>, you initialize a local Git repository. 
In general, the purpose is to synchronize this repo with a remote Git repo. 

To be able to synchronize code with a remote repo, you need to specify where the remote repo exists.
The first step is to add remote repos to your project.
<code># Syntax to add a git remote
git remote add REMOTE-ID REMOTE-URL</code>
By convention, the original / primary remote repo is called <code>origin</code>. 
Here’s a real example:

<code># Add remote 1: GitHub.
git remote add origin git@github.com:jigarius/toggl2redmine.git
# Add remote 2: BitBucket.
git remote add upstream git@bitbucket.org:jigarius/toggl2redmine.git</code>
In the above example, we add the remote repository of a project called <a href="https://github.com/jigarius/toggl2redmine">Toggl 2 Redmine</a> found on GitHub. 
Use the above command to add one or more remote Git repos – make sure that each repo has its unique ID, i.e. 
<code>origin</code>, <code>upstream</code> in the above example.
<h3 id="multiRemotestopic-1">Configure primary remote</h3>
Though you can add multiple remotes, usually, each branch of your project can be configured to track a single remote branch. 
You can setup a branch to track a remote branch as follows:
<code># Change local branch.
git checkout BRANCH

# Configure local branch to track a remote branch.
git branch -u origin/BRANCH</code>
Here, <code>BRANCH</code> is the name of the remote branch, which is usually the same as your local branch.

<h3 id="multiRemotestopic-2">Change remote URL</h3>
If you want to change the URL associated to a remote that you’ve already added, you can do it with the following command:
<code># The syntax is: git remote set-url REMOTE-ID REMOTE-URL

git remote set-url upstream git@foobar.com:jigarius/toggl2redmine.git</code>
<h3 id="multiRemotestopic-3">List all remotes</h3>
To see a list of all remotes, simply use the following command:

<code>$git remote -v
origin	    git@github.com:jigarius/toggl2redmine.git (fetch)
origin	    git@github.com:jigarius/toggl2redmine.git (push)
upstream    git@bitbucket.org:jigarius/toggl2redmine.git (fetch)
upstream    git@bitbucket.org:jigarius/toggl2redmine.git (push)</code>
<h3 id="multiRemotestopic-4">Remove a remote</h3>
If you’ve added a remote which you no longer require, you can remove it as follows:
<code># The syntax is: git remote remove REMOTE-ID
git remote remove upstream</code>

<h3 id="multiRemotestopic-5">Push to multiple remotes</h3>
Now that you have a primary remote repo and other remotes as well, it’s time to configure the push. 
The objective is to <em>push to multiple Git remotes</em> with a single <code>git push</code> command.

To do this, choose a remote ID which will refer to all the remotes. 
I usually call it <code>all</code>, but there are developers who prefer <code>origin</code>. 
The idea is to add all the remote repo URLs as  “push URLs” to this remote. 

Here’s what you do:
<code># Create a new remote called "all" with the URL of the primary repo.
git remote add all git@github.com:jigarius/toggl2redmine.git

# Re-register the remote as a push URL.
git remote set-url --add --push all git@github.com:jigarius/toggl2redmine.git
# Add a push URL to a remote. 

This means that "git push" will also push to this git URL.
git remote set-url --add --push all git@bitbucket.org:jigarius/toggl2redmine.git</code>
If you don’t want to create an extra remote named <code>all</code>, you can skip the first command and use the remote <code>origin</code> instead of <code>all</code> in the subsequent command(s).

Now, you can push to all remote repositories with a single command!
<code># Replace BRANCH with the name of the branch you want to push.
git push all BRANCH</code>

<h3 id="multiRemotestopic-6">Pull from multiple remotes</h3>
It is not possible to <code>git pull</code> from multiple repos. 
However, you can <code>git fetch</code> from multiple repos with the following command:

<code>git fetch --all</code>
This will <em>fetch</em> information from all remote repos. 
You can switch to the latest version of a branch on a particular remote with the command:

<code># Checkout the branch you want to work with.
git checkout BRANCH
# Reset the branch to match the state as on a specific remote.

git reset --hard REMOTE-ID/BRANCH</code>
<h3 id="multiRemotestopic-7">Conclusion</h3>
It is easy to synchronize code between multiple git repositories, especially, pushing to multiple remotes. 

This is helpful when you’re maintaining mirrors / copies of the same repository. 
All you need to do is set up multiple push URLs on a remote and then perform <code>git push</code> to that remote as you usually do.


<h2>branch operations</h2>
rename a branch while pointed to any branch, do:
git branch -m oldname newname

rename the current branch, you can do:
git branch -m newname

push the local branch and reset the upstream branch:
git push origin -u newname

Delete the remote branch:
git push origin --delete oldname

A way to remember this is -m is for "move" (or mv), which is how you rename files. 
Adding an alias could also help. 

To do so, run the following:
git config --global alias.rename 'branch -m'

If you are on Windows or another case-insensitive filesystem, and there are only capitalization changes in the name, you need to use -M, otherwise, git will throw branch already exists error:
git branch -M newname

Switch to the branch which needs to be renamed
git branch -m new_name
git push origin :old_name
git push origin new_name:refs/heads/new_name

delete a local branch in Git
git branch -d local-branch

To delete a remote branch, you need to use the "git push" command:
git push origin --delete remote-branch-name

(https://github.com/williamkpchan/williamkpchan.github.io.git

?? git@github.com:williamkpchan/williamkpchan.github.io.git
?? git remote add origin git@github.com:williamkpchanHP/williamkpchan.github.io.git
)

git remote add origin git@github.com:williamkpchanHP/newDoc.git
git add *.bat
git push --set-upstream origin master

git branch -d newDoc
git commit -m "update"

git remote -vgit remote add origin <url>git remote set-url origin <url>

git remote -v

git@github.com:williamkpchanHP/newDoc.git
git branch -M main
git remote add origin git@github.com:williamkpchanHP/newDoc.git
git push -u origin main

<h2>ssh-keygen</h2>
git bash
ssh-keygen -t rsa -C williamkpchanHP@gmail.com
eval "$(ssh-agent -s)"
ssh-add ~/.ssh/id_rsa

to preview HTML files on GitHub is to go to https://htmlpreview.github.io/ or just prepend it to the original URL, i.e.: 
https://htmlpreview.github.io/?https://github.com/williamkpchanHP/newDoc/blob/main/inkscapeTutorial.html

<h2>Permanently authenticating with Git repositories</h2>
https://stackoverflow.com/questions/6565357/git-push-requires-username-and-password

Run the following command to enable credential caching:

git config credential.helper store
git push https://github.com/owner/repo.git

e.g.
git push https://github.com/williamkpchanHP/newDoc.git

if using ssh:
use SSH URL instead of HTTPS one:
ssh://git@github.com/username/repo.git

git push git@github.com:williamkpchanHP/newDoc.git

git config --global credential.helper 'cache --timeout 7200'
After enabling credential caching, it will be cached for 7200 seconds (2 hour).

<h2>git error "No such remote 'origin'</h2>

You haven't set up the remote repository
You then ran
git remote add origin https://github.com/williamkpchanHP/newDoc.git

After that, your local repository should be able to communicate with the remote repository that resides at the specified URL (https://github.com/williamkpchanHP/newDoc.git)... provided that remote repo actually exists!

Before attempting to push to that remote repository, you need to make sure that the latter actually exists. So go to GitHub and create the remote repo in question. Then and only then will you be able to successfully push with

git push -u origin master

<h2>delete branches in Git</h2>
Deleting <b>local branches</b>
First, we print out all the branches (local as well as remote), using the git branch command with -a (all) flag.

To delete the local branch, just run the git branch command again, this time with the -d (delete) flag, followed by the name of the branch you want to delete (test branch in this case).
Note: Comments are the output produced as a result of running these git commands

git branch -a
# *master
#  test
#  remote/origin/master
#  remote/origin/test

git branch -d test
# Deleted branch test (was ########).

Note: You can also use the -D flag which is synonymous with --delete --force instead of -d. This will delete the branch regardless of its merge status.

<b>Deleting remote branches</b>
To delete a remote branch, you can’t use the git branch command. Instead, use the git push command with --delete flag, followed by the name of the branch you want to delete. You also need to specify the remote name (origin in this case) after git push.

git branch -a
# *master
#  test
#  remote/origin/master
#  remote/origin/test

git push origin --delete test
# To <URL of your repository>.git
#  - [deleted]         test

Delete this branch: remote/devs/JunitTest
git push devs --delete JunitTest

<h2>show my global Git configuration</h2>
git config --list
or look at your ~/.gitconfig file.
The local configuration will be in your repository's .git/config file.

Use:
git config --list --show-origin
to see where that setting is defined (global, user, repo, etc...)

The shortest,
git config -l
shows all inherited values from: system, global and local

edit my global Git configuration
Short answer:
git config --edit --global

1. System level (applied to every user on the system and all their repositories)
to view, git config --list --system (may need sudo)
to set, git config --system color.ui true
to edit system config file, git config --edit --system

2. Global level (values specific personally to you, the user).
to view, git config --list --global
to set, git config --global user.name xyz
to edit global config file, git config --edit --global

3. Repository level (specific to that single repository)
to view, git config --list --local
to set, git config --local core.ignorecase true (--local optional)
to edit repository config file, git config --edit --local (--local optional)

view all settings
Run git config --list, showing system, global, and (if inside a repository) local configs
Run git config --list --show-origin, also shows the origin file of each config item

read one particular configuration
Run git config user.name to get user.name, for example.
You may also specify options --system, --global, --local to read that value at a particular level.


<h2>save username and password in Git</h2>
Attention: This method saves the credentials in plaintext on your PC's disk. Everyone on your computer can access it, e.g. malicious NPM modules.

You can use the git config to enable credentials storage in Git.
Run
git config --global credential.helper store

then
git pull

provide a username and password and those details will then be remembered later.
The credentials are stored in a file on the disk, with the disk permissions of "just user readable/writable" but still in plaintext.

When running this command,
git config --global credential.helper store

the first time you pull or push from the remote repository, you'll get asked about the username and password.

Afterwards, for consequent communications with the remote repository you don't have to provide the username and password.

The storage format is a .git-credentials file, stored in plaintext.

Also, you can use other helpers for the git config credential.helper, namely memory cache:
git config credential.helper 'cache --timeout=&lt;timeout>'

which takes an optional timeout parameter, determining for how long the credentials will be kept in memory.
Using the helper, the credentials will never touch the disk and will be erased after the specified timeout. The default value is 900 seconds (15 minutes).

If you want to change the password later
git pull
Will fail, because the password is incorrect, git then removes the offending user+password from the ~/.git-credentials file, so now re-run

git pull
to provide a new password so it works as earlier.

<h2>Git credential helper - update password</h2>
https://stackoverflow.com/questions/25845963/git-credential-helper-update-password

To update your credentials, go to Control Panel → Credential Manager → Generic Credentials.
Find the credentials related to your Git account and edit them to use the updated password.

Note that to use the Windows Credential Manager for Git you need to configure the credential helper like so:

git config --global credential.helper wincred

If you have multiple GitHub accounts that you use for different repositories, then you should configure credentials to use the full repository path (rather than just the domain, which is the default):
git config --global credential.useHttpPath true


<h2>git to revert to last version</h2>
git checkout master~1 pictList.js

<h2>Work With Multiple Github Accounts on a single Machine</h2>
https://gist.github.com/rahularity/86da20fe3858e6b311de068201d279e3
<a href="https://gist.github.com/starred" class="whitebut ">GitHub Gist</a>
<a href="https://gist.github.com/search?q=multiple+accounts" class="whitebut ">multiple accounts</a>

<div id="multiGittoc" class="toc"><a href="#multiGittopic-0" target="_self">Create SSH keys for all accounts</a><br><a href="#multiGittopic-1" target="_self"> Now generating SSH keys for my two accounts</a><br><a href="#multiGittopic-2" target="_self">Add SSH keys to SSH Agent</a><br><a href="#multiGittopic-3" target="_self">Add SSH public key to the Github</a><br><a href="#multiGittopic-4" target="_self">Create a Config File and Make Host Entries</a><br><a href="#multiGittopic-5" target="_self">Cloning GitHub repositories using different accounts</a><br><a href="#multiGittopic-6" target="_self">Finally</a><br></div></center><br><br>

Let suppose I have two github accounts, <b>https://github.com/rahul-office</b> and <b>https://github.com/rahul-personal</b>. 

Now i want to setup my mac to easily talk to both the github accounts.
NOTE: This logic can be extended to more than two accounts also. 
:)

The setup can be done in 5 easy steps:
Step 1: Create SSH keys for all accounts
Step 2: Add SSH keys to SSH Agent
Step 3: Add SSH public key to the Github
Step 4: Create a Config File and Make Host Entries
Step 5: Cloning GitHub repositories using different accounts

<h3 id="multiGittopic-0">Create SSH keys for all accounts</h3>
First make sure your current directory is your <b>.ssh</b> folder.

$ cd ~/.ssh
Syntax for generating unique ssh key for ann account is:
ssh-keygen -t rsa -C "your-email-address" -f "github-username"

here,
<b>-C</b> stands for comment to help identify your ssh key
<b>-f</b> stands for the file name where your ssh key get saved

<h4 id="multiGittopic-1"> Now generating SSH keys for my two accounts</h4>
ssh-keygen -t rsa -C "my_office_email@gmail.com" -f "github-rahul-office"
ssh-keygen -t rsa -C "my_personal_email@gmail.com" -f "github-rahul-personal"

Notice here <b>rahul-office</b> and <b>rahul-work</b> are the username of my github accounts corresponding to <b>my_office_email@gmail.com</b> and <b>my_personal_email@gmail.com</b> email ids respectively.
After entering the command the terminal will ask for passphrase, leave it empty and proceed.

<img class="lazy" data-src="https://github.com/rahularity/github-essentials/raw/master/screenshots/passphrase.png">

Now after adding keys , in your .ssh folder, a public key and a private will get generated.
The public key will have an extention <b>.pub</b> and private key will be there without any extention both having same name which you have passed after <b>-f</b> option in the above command. 
(in my case <b>github-rahul-office</b> and <b>github-rahu-personal</b>)

<img class="lazy" data-src="https://github.com/rahularity/github-essentials/raw/master/screenshots/ssh_keys_added.png">
<h3 id="multiGittopic-2">Add SSH keys to SSH Agent</h3>
Now we have the keys but it cannot be used until we add them to the SSH Agent.
ssh-add -K ~/.ssh/github-rahul-office
ssh-add -K ~/.ssh/github-rahul-personal

You can read more about adding keys to SSH Agent <a href="https://help.github.com/en/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent">here.</a>

<h3 id="multiGittopic-3">Add SSH public key to the Github</h3>
For the next step we need to add our public key (that we have generated in our previous step) and add it to corresponding github accounts.
For doing this we need to:
<b>1. Copy the public key</b>
<code> We can copy the public key either by opening the github-rahul-office.pub file in vim and then copying the content of it.
</code>

vim ~/.ssh/github-rahul-office.pub
vim ~/.ssh/github-rahul-personal.pub
OR

We can directly copy the content of the public key file in the clipboard.
pbcopy &lt; ~/.ssh/github-rahul-office.pub
pbcopy &lt; ~/.ssh/github-rahul-personal.pub

<b>2. Paste the public key on Github</b>
Sign in to Github Account
Goto <b>Settings</b> > <b>SSH and GPG keys</b> > <b>New SSH Key</b>
Paste your copied public key and give it a Title of your choice.

<em><b>OR</b></em>

Sign in to Github
Paste this link in your browser (<a href="https://github.com/settings/keys">https://github.com/settings/keys</a>) or click <a href="https://github.com/settings/keys">here</a>
Click on <b>New SSH Key</b> and paste your copied key.

<h3 id="multiGittopic-4">Create a Config File and Make Host Entries</h3>

The <b>~/.ssh/config</b> file allows us specify many config options for SSH.
If <b>config</b> file not already exists then create one (make sure you are in <b>~/.ssh</b> directory)
touch config

The commands below opens config in your default editor....Likely TextEdit, VS Code.
open config
Now we need to add these lines to the file, each block corresponding to each account we created earlier.

<code>     #rahul-office account
Host github.com-rahul-office
HostName github.com

User git
IdentityFile ~/.ssh/github-rahul-office
#rahul-personal account

Host github.com-rahul-personal
HostName github.com
User git

IdentityFile ~/.ssh/github-rahul-personal
</code>

<h3 id="multiGittopic-5">Cloning GitHub repositories using different accounts</h3>
So we are done with our setups and now its time to see it in action. 
We will clone a repository using one of the account we have added.

Make a new project folder where you want to clone your repository and go to that directory from your terminal.
For Example:
I am making a repository on my personal github account and naming it <b>TestRepo</b>

Now for cloning the repo use the below command:
<code>    git clone git@github.com-{your-username}:{owner-user-name}/{the-repo-name}.git
[e.g.] git clone git@github.com-rahul-personal:rahul-personal/TestRepo.git
</code>

<h3 id="multiGittopic-6">Finally</h3>
From now on, to ensure that our commits and pushes from each repository on the system uses the correct GitHub user — we will have to configure <b>user.email</b> and <b>user.name</b> in every repository freshly cloned or existing before.

To do this use the following commands.
<code>     git config user.email "my_office_email@gmail.com"
git config user.name "Rahul Pandey"

git config user.email "my-personal-email@gmail.com"
git config user.name "Rahul Pandey"
</code>

Pick the correct pair for your repository accordingly.
To push or pull to the correct account we need to add the remote origin to the project
<code>     git remote add origin git@github.com-rahul-personal:rahul-personal
git remote add origin git@github.com-rahul-office:rahul-office
</code>
Now you can use:

<code>     git push
git pull</code>

<h2>put multiple projects in a git repository</h2>
<h3>Solution 1</h3>
A single repository can contain multiple <em>independent</em> branches, called <i>orphan branches</i>. 
Orphan branches are completely separate from each other; they do not share histories.
<code>git checkout --orphan BRANCHNAME</code>
This creates a new branch, unrelated to your current branch. 
Each project should be in its own orphaned branch.
Now for whatever reason, git needs a bit of cleanup after an orphan checkout.
<code>rm .git/index
rm -r *</code>
<i>Make sure everything is committed before deleting</i>
Once the orphan branch is clean, you can use it normally.
<h3>Solution 2</h3>
Avoid all the hassle of orphan branches. 
Create two independent repositories, and push them to the same remote. 
Just use different branch names for each repo.
<code># repo 1
git push origin master:master-1
# repo 2
git push origin master:master-2</code>
<h3>Solution 3</h3>
This is for using a single directory for multiple projects. 
I use this technique for some closely related projects where I often need to pull changes from one project into another. 
It's similar to the orphaned branches idea but the branches don't need to be orphaned. 
Simply start all the projects from the same empty directory state.
<h4>Start all projects from one committed empty directory</h4>
Don't expect wonders from this solution. 
As I see it, you are always going to have annoyances with untracked files. 
Git doesn't really have a clue what to do with them and so if there are intermediate files generated by a compiler and ignored by your .gitignore file, it is likely that they will be left hanging some of the time if you try rapidly swapping between - for example - your software project and a PH.D thesis project.
However here is the plan. 
Start as you ought to start any git projects, by committing the empty repository, and then start all your projects from the same empty directory state. 
That way you are certain that the two lots of files are fairly independent. 
Also, give your branches a proper name and don't lazily just use "master". 
Your projects need to be separate so give them appropriate names.
Git commits (and hence tags and branches) basically store the state of a directory and its subdirectories and <i>Git has no idea whether these are parts of the same or different projects</i> so really there is no problem for git storing different projects in the same repository. 
The problem is then for you clearing up the untracked files from one project when using another, or separating the projects later.
<h3>Create an empty repository</h3>
<code>cd some_empty_directory
git init
touch .gitignore
git add .gitignore
git commit -m empty
git tag EMPTY</code>
Start your projects from empty.
<h4>Work on one project.</h4>
<code>git branch software EMPTY
git checkout software
echo "array board[8,8] of piece" > chess.prog
git add chess.prog 
git commit -m "chess program"</code>
<h4>Start another project</h4>
whenever you like.
<code>git branch thesis EMPTY
git checkout thesis
echo "the meaning of meaning" > philosophy_doctorate.txt
git add philosophy_doctorate.txt 
git commit -m "Ph.D"</code>
<h4>Switch back and forth</h4>
Go back and forwards between projects whenever you like.
This example goes back to the chess software project.
<code>git checkout software
echo "while not end_of_game do make_move()" >> chess.prog
git add chess.prog 
git commit -m "improved chess program"</code>
<h3>Untracked files are annoying</h3>
You will however be annoyed by untracked files when swapping between projects/branches.
<code>touch untracked_software_file.prog
git checkout thesis 
ls
    philosophy_doctorate.txt  untracked_software_file.prog</code>
<h4>It's not an insurmountable problem</h4>
Sort of by definition, git doesn't really know what to do with untracked files and it's up to you to deal with them. 
You can stop untracked files from being carried around from one branch to another as follows.
<code>git checkout EMPTY 
ls
    untracked_software_file.prog
rm -r *
    (directory is now really empty, apart from the repository stuff!)
git checkout thesis
ls
    philosophy_doctorate.txt</code>
By ensuring that the directory was empty before checking out our new project we made sure there were no hanging untracked files from another project.
<h4>A refinement</h4>
<code>$ GIT_AUTHOR_DATE='2001-01-01:T01:01:01' GIT_COMMITTER_DATE='2001-01-01T01:01:01' git commit -m empty</code>
If the same dates are specified whenever committing an empty repository, then independently created empty repository commits can have the same SHA1 code. 
<i>This allows two repositories to be created independently and then merged together into a single tree with a common root in one repository later.</i>
<h4>Example</h4>
<code># Create thesis repository. 
# Merge existing chess repository branch into it
mkdir single_repo_for_thesis_and_chess
cd single_repo_for_thesis_and_chess
git init
touch .gitignore
git add .gitignore
GIT_AUTHOR_DATE='2001-01-01:T01:01:01' GIT_COMMITTER_DATE='2001-01-01:T01:01:01' git commit -m empty
git tag EMPTY
echo "the meaning of meaning" > thesis.txt
git add thesis.txt
git commit -m "Wrote my PH.D"
git branch -m master thesis
# It's as simple as this ...
git remote add chess ../chessrepository/.git
git fetch chess chess:chess</code>
<h4>Result</h4>
<a href="https://i.stack.imgur.com/i94dQ.png" rel="noreferrer"><img class="lazy" data-src="https://i.stack.imgur.com/i94dQ.png" alt="Diagram of merged repositories"></a>
<h3>Use subdirectories per project?</h3>
It may also help if you keep your projects in subdirectories where possible, e.g. 
instead of having files
<code>chess.prog
philosophy_doctorate.txt </code>
have 
<code>chess/chess.prog
thesis/philosophy_doctorate.txt </code>
In this case your untracked software file will be <code>chess/untracked_software_file.prog</code>. 
When working in the <code>thesis</code> directory you should not be disturbed by untracked chess program files, and you may find occasions when you can work happily without deleting untracked files from other projects.
Also, if you want to remove untracked files from other projects, it will be quicker (and less prone to error) to dump an unwanted directory than to remove unwanted files by selecting each of them.
<h3>Branch names can include '/' characters</h3>
So you might want to name your branches something like
<code>project1/master
project1/featureABC
project2/master
project2/featureXYZ</code>

<h2>Creating a personal access token</h2>
<div id="pcttoc" class="toc"><a href="#pcttopic-0" target="_self">About personal access tokens</a><br><a href="#pcttopic-1" target="_self"> Types of personal access tokens</a><br><a href="#pcttopic-2" target="_self"> Keeping your personal access tokens secure</a><br><a href="#pcttopic-3" target="_self">Creating a fine-grained personal access token</a><br><a href="#pcttopic-4" target="_self">Creating a personal access token (classic)</a><br><a href="#pcttopic-5" target="_self">Using a personal access token on the command line</a><br></div></center><br><br>

Use a personal access token in place of a password when authenticating to GitHub in the command line or with the API.

<k>Warning</k>: Treat your access tokens like passwords.
For more information, see "<a href="#keeping-your-personal-access-tokens-secure">Keeping your personal access tokens secure</a>."

<h3 id="pcttopic-0">About personal access tokens</h3>
Personal access tokens are an alternative to using passwords for authentication to GitHub when using the <a href="https://docs.github.com/en/rest/overview/other-authentication-methods#via-oauth-and-personal-access-tokens">GitHub API</a> or the <a href="#using-a-token-on-the-command-line">command line</a>.

Personal access tokens are intended to access GitHub resources on behalf of yourself.
To access resources on behalf of an organization, or for long-lived integrations, you should use a GitHub App.
For more information, see "<a href="https://docs.github.com/en/apps/creating-github-apps/creating-github-apps/about-apps">About apps</a>."

<h3 id="pcttopic-1"> Types of personal access tokens</h3>
GitHub currently supports two types of personal access tokens: fine-grained personal access tokens and personal access tokens (classic).
GitHub recommends that you use fine-grained personal access tokens instead of personal access tokens (classic) whenever possible.

Organization owners can set a policy to restrict the access of personal access tokens (classic) to their organization.
For more information, see "<a href="https://docs.github.com/en/organizations/managing-programmatic-access-to-your-organization/setting-a-personal-access-token-policy-for-your-organization#restricting-access-by-personal-access-tokens-classic">Setting a personal access token policy for your organization</a>."

<h4>Fine-grained personal access tokens</h4>
Fine-grained personal access tokens have several security advantages over personal access tokens (classic):

Each token can only access resources owned by a single user or organization.
Each token can only access specific repositories.
Each token is granted specific permissions, which offer more control than the scopes granted to personal access tokens (classic).
Each token must have an expiration date.
Organization owners can require approval for any fine-grained personal access tokens that can access resources in the organization.

<h4>Personal access tokens (classic)</h4>
Personal access tokens (classic) are less secure.
However, some features currently will only work with personal access tokens (classic):

Only personal access tokens (classic) have write access for public repositories that are not owned by you or an organization that you are not a member of.
Outside collaborators can only use personal access tokens (classic) to access organization repositories that they are a collaborator on.
Only personal access tokens (classic) can access the GraphQL API.
Some REST API operations are not available to fine-grained personal access tokens.
For a list of REST API operations that are supported for fine-grained personal access tokens, see "<a href="https://docs.github.com/en/rest/overview/endpoints-available-for-fine-grained-personal-access-tokens">Endpoints available for fine-grained personal access tokens</a>".

If you choose to use a personal access token (classic), keep in mind that it will grant access to all repositories within the organizations that you have access to, as well as all personal repositories in your personal account.

As a security precaution, GitHub automatically removes personal access tokens that haven't been used in a year.
To provide additional security, we highly recommend adding an expiration to your personal access tokens.

<h3 id="pcttopic-2"> Keeping your personal access tokens secure</h3>
Personal access tokens are like passwords, and they share the same inherent security risks.
Before creating a new personal access token, consider if there is a more secure method of authentication available to you:

To access GitHub from the command line, you can use <a href="https://docs.github.com/en/github-cli/github-cli/about-github-cli">GitHub CLI</a> or <a href="https://github.com/GitCredentialManager/git-credential-manager/blob/main/README.md">Git Credential Manager</a> instead of creating a personal access token.
When using a personal access token in a GitHub Actions workflow, consider whether you can use the built-in <code>GITHUB_TOKEN</code> instead.
For more information, see "<a href="https://docs.github.com/en/actions/security-guides/automatic-token-authentication">Automatic token authentication</a>."

If these options are not possible, and you must create a personal access token, consider using another service such as the <a href="https://developer.1password.com/docs/cli/secret-references/">1Password CLI</a> to store your token securely, or 1Password's <a href="https://developer.1password.com/docs/cli/shell-plugins/github/">GitHub shell plugin</a> to securely authenticate to GitHub CLI.

When using a personal access token in a script, you can store your token as a secret and run your script through GitHub Actions.
For more information, see "<a href="https://docs.github.com/en/actions/security-guides/encrypted-secrets">Encrypted secrets</a>." You can also store your token as a Codespaces secret and run your script in Codespaces.
For more information, see "<a href="https://docs.github.com/en/codespaces/managing-your-codespaces/managing-encrypted-secrets-for-your-codespaces">Managing encrypted secrets for your codespaces</a>."

<h3 id="pcttopic-3">Creating a fine-grained personal access token</h3>

<k>Note</k>: Fine-grained personal access token are currently in beta and subject to change.
To leave feedback, see <a href="https://github.com/community/community/discussions/36441">the feedback discussion</a>.

<a href="https://docs.github.com/en/get-started/signing-up-for-github/verifying-your-email-address">Verify your email address</a>, if it hasn't been verified yet.

In the upper-right corner of any page, click your profile photo, then click <k>Settings</k>.

<img class="lazy" data-src="https://docs.github.com/assets/cb-34573/images/help/settings/userbar-account-settings.png">

In the left sidebar, click <k> Developer settings</k>.

In the left sidebar, under <k> Personal access tokens</k>, click <k>Fine-grained tokens</k>.

Click <k>Generate new token</k>.

Under <k>Token name</k>, enter a name for the token.

Under <k>Expiration</k>, select an expiration for the token.

Optionally, under <k>Description</k>, add a note to describe the purpose of the token.

Under <k>Resource owner</k>, select a resource owner.
The token will only be able to access resources owned by the selected resource owner.
Organizations that you are a member of will not appear unless the organization opted in to fine-grained personal access tokens.
For more information, see "<a href="https://docs.github.com/en/organizations/managing-programmatic-access-to-your-organization/setting-a-personal-access-token-policy-for-your-organization">Setting a personal access token policy for your organization</a>."

Optionally, if the resource owner is an organization that requires approval for fine-grained personal access tokens, below the resource owner, in the box, enter a justification for the request.

Under <k>Repository access</k>, select which repositories you want the token to access.
You should choose the minimal repository access that meets your needs.
Tokens always include read-only access to all public repositories on GitHub.

If you selected <k>Only select repositories</k> in the previous step, under the <k>Selected repositories</k> dropdown, select the repositories that you want the token to access.

Under <k>Permissions</k>, select which permissions to grant the token.
Depending on which resource owner and which repository access you specified, there are repository, organization, and account permissions.
You should choose the minimal permissions necessary for your needs.
For more information about what permissions are required for each REST API operation, see "<a href="https://docs.github.com/en/rest/overview/permissions-required-for-fine-grained-personal-access-tokens">Permissions required for fine-grained personal access tokens</a>."

Click <k>Generate token</k>.

If you selected an organization as the resource owner and the organization requires approval for fine-grained personal access tokens, then your token will be marked as <code>pending</code> until it is reviewed by an organization administrator.
Your token will only be able to read public resources until it is approved.
If you are an owner of the organization, your request is automatically approved.
For more information, see "<a href="https://docs.github.com/en/organizations/managing-programmatic-access-to-your-organization/reviewing-and-revoking-personal-access-tokens-in-your-organization">Reviewing and revoking personal access tokens in your organization</a>".

<h3 id="pcttopic-4">Creating a personal access token (classic)</h3>

<k>Note</k>: Organization owners can restrict the access of personal access token (classic) to their organization.
If you try to use a personal access token (classic) to access resources in an organization that has disabled personal access token (classic) access, your request will fail with a 403 response.
Instead, you must use a GitHub App, OAuth App, or fine-grained personal access token.

<k>Note</k>: Your personal access token (classic) can access every repository that you can access.
GitHub recommends that you use fine-grained personal access tokens instead, which you can restrict to specific repositories.
Fine-grained personal access tokens also enable you to specify fine-grained permissions instead of broad scopes.

<a href="https://docs.github.com/en/get-started/signing-up-for-github/verifying-your-email-address">Verify your email address</a>, if it hasn't been verified yet.

In the upper-right corner of any page, click your profile photo, then click <k>Settings</k>.

<img class="lazy" data-src="https://docs.github.com/assets/cb-34573/images/help/settings/userbar-account-settings.png">

In the left sidebar, click <k> Developer settings</k>.

In the left sidebar, under <k> Personal access tokens</k>, click <k>Tokens (classic)</k>.

Select <k>Generate new token</k>, then click <k>Generate new token (classic)</k>.

Give your token a descriptive name.
<img class="lazy" data-src="https://docs.github.com/assets/cb-3880/images/help/settings/token_description.png">

To give your token an expiration, select the <k>Expiration</k> drop-down menu, then click a default or use the calendar picker.
<img class="lazy" data-src="https://docs.github.com/assets/cb-39847/images/help/settings/token_expiration.png">

Select the scopes you'd like to grant this token.
To use your token to access repositories from the command line, select <k>repo</k>.
A token with no assigned scopes can only access public information.
For more information, see "<a href="https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/scopes-for-oauth-apps#available-scopes">Scopes for OAuth Apps</a>".

<img class="lazy" data-src="https://docs.github.com/assets/cb-43299/images/help/settings/token_scopes.gif">

Click <k>Generate token</k>.
<img class="lazy" data-src="https://docs.github.com/assets/cb-10912/images/help/settings/generate_token.png">

<img class="lazy" data-src="https://docs.github.com/assets/cb-33474/images/help/settings/personal_access_tokens.png">

To use your token to access resources owned by an organization that uses SAML single sign-on, authorize the token.
For more information, see "<a href="https://docs.github.com/en/enterprise-cloud@latest/authentication/authenticating-with-saml-single-sign-on/authorizing-a-personal-access-token-for-use-with-saml-single-sign-on">Authorizing a personal access token for use with SAML single sign-on</a>" in the GitHub Enterprise Cloud documentation.

<h3 id="pcttopic-5">Using a personal access token on the command line</h3>
Once you have a token, you can enter it instead of your password when performing Git operations over HTTPS.

For example, on the command line you would enter the following:

<code>$ git clone https://github.com/USERNAME/REPO.git
Username: YOUR_USERNAME
Password: <k>YOUR_TOKEN</k></code>

Personal access tokens can only be used for HTTPS Git operations.
If your repository uses an SSH remote URL, you will need to <a href="https://docs.github.com/en/get-started/getting-started-with-git/managing-remote-repositories#switching-remote-urls-from-ssh-to-https">switch the remote from SSH to HTTPS</a>.

If you are not prompted for your username and password, your credentials may be cached on your computer.
You can <a href="https://docs.github.com/en/get-started/getting-started-with-git/updating-credentials-from-the-macos-keychain">update your credentials in the Keychain</a> to replace your old password with the token.

Instead of manually entering your personal access token for every HTTPS Git operation, you can cache your personal access token with a Git client.
Git will temporarily store your credentials in memory until an expiry interval has passed.
You can also store the token in a plain text file that Git can read before every request.
For more information, see "<a href="https://docs.github.com/en/get-started/getting-started-with-git/caching-your-github-credentials-in-git">Caching your GitHub credentials in Git</a>."

<h2>Caching your GitHub credentials in Git</h2>
<div id="Cachingtoc" class="toc"><a href="#Cachingtopic-0" target="_self">GitHub CLI</a><br><a href="#Cachingtopic-1" target="_self">Git Credential Manager</a><br></div></center><br><br>

If you're <a href="https://docs.github.com/en/github/getting-started-with-github/about-remote-repositories">cloning GitHub repositories using HTTPS</a>, we recommend you use GitHub CLI or Git Credential Manager (GCM) to remember your credentials.

<k>Tip:</k> If you clone GitHub repositories using SSH, then you  can authenticate using an SSH key instead of using other credentials.
For information about setting up an SSH connection, see "<a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh">Connecting to GitHub with SSH</a>."

<h3 id="Cachingtopic-0">GitHub CLI</h3>
GitHub CLI will automatically store your Git credentials for you when you choose <code>HTTPS</code> as your preferred protocol for Git operations and answer "yes" to the prompt asking if you would like to authenticate to Git with your GitHub credentials.

<a href="https://github.com/cli/cli#installation">Install</a> GitHub CLI on macOS, Windows, or Linux.
In the command line, enter <code>gh auth login</code>, then follow the prompts.

When prompted for your preferred protocol for Git operations, select <code>HTTPS</code>.
When asked if you would like to authenticate to Git with your GitHub credentials, enter <code>Y</code>.

For more information about authenticating with GitHub CLI, see <a href="https://cli.github.com/manual/gh_auth_login"><code>gh auth login</code></a>.
<h3 id="Cachingtopic-1">Git Credential Manager</h3>
<a href="https://github.com/GitCredentialManager/git-credential-manager">Git Credential Manager</a> (GCM) is another way to store your credentials securely and connect to GitHub over HTTPS.
With GCM, you don't have to manually <a href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token">create and store a personal access token</a>, as GCM manages authentication on your behalf, including 2FA (two-factor authentication).

Install Git using <a href="https://brew.sh/">Homebrew</a>:
<code>$ brew install git</code>

Install GCM using Homebrew:
<code>$ brew tap microsoft/git
$ brew install --cask git-credential-manager-core</code>
For MacOS, you don't need to run <code>git config</code> because GCM automatically configures Git for you.

The next time you clone an HTTPS URL that requires authentication, Git will prompt you to log in using a browser window.
You may first be asked to authorize an OAuth app.
If your account or organization requires <a href="https://docs.github.com/en/authentication/securing-your-account-with-two-factor-authentication-2fa">two-factor auth</a>, you'll also need to complete the 2FA challenge.
Once you've authenticated successfully, your credentials are stored in the macOS keychain and will be used every time you clone an HTTPS URL.
Git will not require you to type your credentials in the command line again unless you change your credentials.

Install Git for Windows, which includes GCM.
For more information, see "<a href="https://github.com/git-for-windows/git/releases/latest">Git for Windows releases</a>" from its <a href="https://github.com/git-for-windows/git/releases/latest">releases page</a>.

We recommend always installing the latest version.
At a minimum, install version 2.29 or higher, which is the first version offering OAuth support for GitHub.
The next time you clone an HTTPS URL that requires authentication, Git will prompt you to log in using a browser window.
You may first be asked to authorize an OAuth app.
If your account or organization requires <a href="https://docs.github.com/en/authentication/securing-your-account-with-two-factor-authentication-2fa">two-factor auth</a>, you'll also need to complete the 2FA challenge.
Once you've authenticated successfully, your credentials are stored in the Windows credential manager and will be used every time you clone an HTTPS URL.
Git will not require you to type your credentials in the command line again unless you change your credentials.

<k>Warning:</k> Older versions of Git for Windows came with Git Credential Manager for Windows.
This older product is no longer supported and cannot connect to GitHub via OAuth.
We recommend you upgrade to <a href="https://github.com/git-for-windows/git/releases/latest">the latest version of Git for Windows</a>.

<k>Warning:</k> If you cached incorrect or outdated credentials in Credential Manager for Windows, Git will fail to access GitHub.
To reset your cached credentials so that Git prompts you to enter your credentials, access the Credential Manager in the Windows Control Panel under User Accounts > Credential Manager.
Look for the GitHub entry and delete it.

For Linux, install Git and GCM, then configure Git to use GCM.

Install Git from your distro's packaging system.
Instructions will vary depending on the flavor of Linux you run.

Install GCM.
See the <a href="https://github.com/GitCredentialManager/git-credential-manager#linux-install-instructions">instructions in the GCM repo</a>, as they'll vary depending on the flavor of Linux you run.

Configure Git to use GCM.
There are several backing stores that you may choose from, so see the GCM docs to complete your setup.
For more information, see "<a href="https://aka.ms/gcmcore-linuxcredstores">GCM Linux</a>."

The next time you clone an HTTPS URL that requires authentication, Git will prompt you to log in using a browser window.
You may first be asked to authorize an OAuth app.
If your account or organization requires <a href="https://docs.github.com/en/authentication/securing-your-account-with-two-factor-authentication-2fa">two-factor auth</a>, you'll also need to complete the 2FA challenge.
Once you've authenticated successfully, your credentials are stored on your system and will be used every time you clone an HTTPS URL.
Git will not require you to type your credentials in the command line again unless you change your credentials.
For more options for storing your credentials on Linux, see <a href="https://git-scm.com/bookhttps://docs.github.com/en/v2/Git-Tools-Credential-Storage">Credential Storage</a> in Pro Git.

<h2>Using Git with RStudio</h2>
<div id="gitrstudiotoc" class="toc"><a href="#gitrstudiotopic-1" target="_self"><span class="orange">Intro to practical version control for scientists</span></a><br><a href="#gitrstudiotopic-2" target="_self"><span class="orange">Installation and configuration of git</span></a><br><a href="#gitrstudiotopic-3" target="_self"> Install git</a><br><a href="#gitrstudiotopic-4" target="_self"> Install git using </a><a href="http://brew.sh">Homebrew</a><br><a href="#gitrstudiotopic-5" target="_self"> Configure git</a><br><a href="#gitrstudiotopic-6" target="_self"> Configure RStudio to use git</a><br><a href="#gitrstudiotopic-7" target="_self"><span class="orange">Learn to use git with RStudio</span></a><br><a href="#gitrstudiotopic-8" target="_self"> Create a new project</a><br><a href="#gitrstudiotopic-9" target="_self"> Open an existing project</a><br><a href="#gitrstudiotopic-10" target="_self"> Create and commit a file</a><br><a href="#gitrstudiotopic-11" target="_self"> Knit the HTML report</a><br><a href="#gitrstudiotopic-12" target="_self"> Change the plot</a><br><a href="#gitrstudiotopic-13" target="_self"> Make a change and revert it</a><br><a href="#gitrstudiotopic-14" target="_self"> Delete a file</a><br><a href="#gitrstudiotopic-15" target="_self"> Inspect your work</a><br><a href="#gitrstudiotopic-16" target="_self"> Use the git command line</a><br><a href="#gitrstudiotopic-17" target="_self"> Learn more about the git command line</a><br></div></center><br><br>

Git allows groups of people to work on the same documents (often code) at the same time, and without stepping on each other's toes.
It's a distributed version control system.
(cribbed from <a href="http://try.github.io">tryGit</a>)

<h3 id="gitrstudiotopic-1"><span class="orange">Intro to practical version control for scientists</span></h3>
These <a href="http://htmlpreview.github.io/?https://github.com/BernhardKonrad/2014-02-22-SFU/blob/gh-pages/BK-slides/git-intro.slides.html">slides</a> are courtesy of <a href="https://github.com/BernhardKonrad">Bernhard Konrad</a>.

<h3 id="gitrstudiotopic-2"><span class="orange">Installation and configuration of git</span></h3>
If you've already installed and configured <a href="http://git-scm.com">git</a>, skip ahead to
<a href="#learngit">Learn to use git with RStudio</a>.

<h3 id="gitrstudiotopic-3"> Install git</h3>
Mac OS 10.9 Mavericks comes with git installed.
To check that git is installed, open a Terminal and run…
<z>which git
git --version</z>

These commands should display something similar to this:
<z>➜  which git
/usr/bin/git
➜  git --version
git version 1.9.3</z>

For all other operating systems, go to the <a href="http://git-scm.com/downloads">Git downloads</a> web site, and click on the appropriate icon for your operating system.

If on a Mac the official Git package gives you any trouble, use the following instructions to install Git using Homebrew.

<h3 id="gitrstudiotopic-4"> Install git using <a href="http://brew.sh">Homebrew</a></h3>
<a href="http://brew.sh">Homebrew</a> is the missing package manager for Mac OS X.
To install Homebrew and use <z>brew</z> to install Git, run…
<z>ruby -e "$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)" brew install git</z>
Test that git is installed and working by running…
<z>which git
git --version</z>

<h3 id="gitrstudiotopic-5"> Configure git</h3>
Git associates your name and e-mail address with each commit, which helps when multiple people collaborate on a project.
To configure your name and e-mail address in git, open the Terminal and run…
<z>git config --global user.name 'Your Name'
git config --global user.email 'your@email.com'</z>

On a Mac, configure git to remember your password.
<z>git config --global credential.helper osxkeychain</z>

<h3 id="gitrstudiotopic-6"> Configure RStudio to use git</h3>
Open RStudio
Click <k>Tools -> Global Options -> Git/SVN</k>
If <k>Git executable</k> shows <k>(none)</k>, click <k>Browse</k> and select the git executable installed on your system

On a Mac, this will likely be one of
<z>/usr/bin/git</z>
<z>/usr/local/bin/git</z>
<z>/usr/local/git/bin/git</z>
On Windows, <z>git.exe</z> will likely be somewhere in <z>Program Files</z> Click <k>OK</k>

<h3 id="gitrstudiotopic-7"><span class="orange">Learn to use git with RStudio</span></h3>
<h3 id="gitrstudiotopic-8"> Create a new project</h3>
Or if you prefer, see below for instructions to open an existing project.

Open RStudio
Create a new project

Click <k>File -> New Project -> New Directory -> Empty Project</k>
Check <k>Create a git repository for this project</k>

<h3 id="gitrstudiotopic-9"> Open an existing project</h3>
Open an existing project

Click <k>File -> Open Project</k>

If you already have a tab labeled <k>Git</k> next to the tabs <k>Environment</k> and
<k>History</k>, skip these instructions.

Enable git for this project

Click <k>Tools -> Version Control -> Project Setup</k>
Click the dropdown box <k>Version control system</k> and select <k>Git</k>
If you don't have a <k>Git</k> option go back to <a href="#configurerstudio">Configure RStudio</a>.
Do not pass Go.
Do not collect $200

<h3 id="gitrstudiotopic-10"> Create and commit a file</h3>
Make your first commit

Click the <k>Git</k> tab
Check <k>Staged</k> next to <z>.gitignore</z> and <z>hello.Rproj</z>
Click <k>Commit</k>
Type a message in <k>Commit message</k>
Click <k>Commit</k>
Create a new Rmd file

Click <k>File -> New File -> R Markdown</k>
Edit the file and change the title
Save the file
Commit the new Rmd file

Check <k>Staged</k> and click <k>Commit</k>

<h3 id="gitrstudiotopic-11"> Knit the HTML report</h3>
Knit the Rmd file to generate an HTML report

Click <k>Knit HTML</k>
Commit the generated report

Check <k>Staged</k> for the <k>md</k> and <k>html</k> files and the <k>figures</k> directory
Click <k>Commit</k>

<h3 id="gitrstudiotopic-12"> Change the plot</h3>
Replace the <k>plot</k> with <k>ggplot</k> or <k>qplot</k> and save your changes
Commit the change
Knit the report
Commit all the modified files

<h3 id="gitrstudiotopic-13"> Make a change and revert it</h3>
Make an erroneous change to the file and save it
Click <k>Diff</k> and then <k>Revert</k>
The erroneous change has been undone and the previous version restored

<h3 id="gitrstudiotopic-14"> Delete a file</h3>
Create a new file named <z>doomed.md</z>
Enter some text and save it
Delete this doomed file

Under the <k>Files</k> tab check the box next to <z>doomed.md</z>
Click <k>Delete</k>
Under the <k>Git</k> tab, a red <z>D</z> appears next to the deleted file
Stage the change by clicking the checkbox and commit it

<h3 id="gitrstudiotopic-15"> Inspect your work</h3>
Make a few more changes and commits
Click <k>History</k> under the <k>Git</k> tab to review your day's work
Git has recorded a complete history of your work
In the event of impish gnomes introducing errors into your work, you can browse through your history, find the gnome to blame, and restore your previous good work.
Gnomes be damned.

<h3 id="gitrstudiotopic-16"> Use the git command line</h3>
There are many graphical interfaces for git—RStudio is one—but there is only one git command line interface, which is the common engine being used behind the scenes.
If your graphical interface ever lets you down, it's useful to peak under the hood.

Click <k>File -> New File -> Text File</k>
Describe your project in this new file
Save this file and name it <z>README.md</z>

Case matters! Name the file <z>README.md</z> and not <z>readme.md</z> or any other variation
Don't be imaginative.
Get used to being pedantic.
Foster your inner OCD
md is the extension of a <a href="markdown">Markdown</a> file
Note the yellow question marks indicating the new file that's not being tracked by git
Open a shell (also known as a Terminal)

Under the <k>Git</k> tab, click <k>More -> Shell</k>
Stage <z>README.md</z> using the git command line

Run <z>git add README.md</z>
The yellow question mark changes to a green <k>A</k>
Checking the <k>Staged</k> check box in fact runs <z>git add</z>
Unstage <z>README.md</z>

Run <z>git reset README.md</z>
The green <k>A</k> changes back to a yellow question mark
Unchecking the <k>Staged</k> check box in fact runs <z>git reset</z>
Stage and commit <z>README.md</z>

Run…
<z>git add README.md
git commit -m 'Add README.md'</z>

The <z>-m</z> option of <z>git commit</z> specifies the git log message
Browse the git history in RStudio, and inspect this commit

<h3 id="gitrstudiotopic-17"> Learn more about the git command line</h3>
Go to <a href="http://try.github.io">tryGit</a> and learn more about the git command line!

<h2>git remote add origin command to push remotely</h2>

<div id="gitremotetoc" class="toc"><a href="#gitremotetopic-0" target="_self">Create the remote origin on GitHub</a><br><a href="#gitremotetopic-1" target="_self">Copy and edit GitHub's remote add URL</a><br><a href="#gitremotetopic-2" target="_self">Run the git remote add origin command</a><br><a href="#gitremotetopic-3" target="_self">Perform a git push to the remote</a><br><a href="#gitremotetopic-4" target="_self">Verify the git remote add push on GitHub</a><br><a href="#gitremotetopic-5" target="_self">Overview of git remote add origin and push steps</a><br></div></center><br><br>
<iframe src="https://www.youtube.com/embed/uJ3T0VpibWg?autoplay=0&amp;modestbranding=1&amp;rel=0&amp;widget_referrer=https://www.theserverside.com/video/How-to-use-the-git-remote-add-origin-command-to-push-remotely&amp;enablejsapi=1&amp;origin=https://www.theserverside.com" type="text/html" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe> 

When developers want to take their local Git repository, use the git remote add origin command. 

The git reflog command shows how many commits are in the local repository before the git remote add origin call.

execute the git reflog command
<em>Reflog</em> is an abbreviation of reference logs. 

<h3 id="gitremotetopic-0">Create the remote origin on GitHub</h3><a href="#top" target="_self"><b>⇧</b></a><br> 
After the local repository is validated, the next step is to create a remote repository that the local repository will connect to. 

It's easy to create a remote repository. 
Log into GitHub and use the "<a href="https://www.theserverside.com/blog/Coffee-Talk-Java-News-Stories-and-Opinions/Create-a-GitHub-repository-with-this-step-by-step-tutorial">Create a new repository</a>" wizard. 
In this example, I named the GitHub repository <em>my-github-repo</em> to clearly differentiate it from the Git repository that is stored locally in a folder named <em>my-local-repo</em>. 
<img class="lazy loaded" data-src="https://cdn.ttgtmedia.com/rms/onlineImages/SideCOM_remote-repo-for-git-add-remote-command_002.jpg" src="https://cdn.ttgtmedia.com/rms/onlineImages/SideCOM_remote-repo-for-git-add-remote-command_002.jpg" data-was-processed="true">

Set up the remote origin repository on the GitHub server.

Since you will transfer information to the GitHub repository, do not initialize it with a README, configure a gitignore file or add a license. 
All of those things will exist in the local repository and will be subsequently pushed into the remote GitHub one. 

If those resources exist in both repositories before the git remote add origin command runs, it will create extra merge and conflict resolution steps that are easily avoided. 
<h3 id="gitremotetopic-1">Copy and edit GitHub's remote add URL</h3><a href="#top" target="_self"><b>⇧</b></a><br> 
When GitHub creates your repository, it presents an HTTP link, which is required as part of the git remote add origin command. 

The URL provided that uniquely identifies the GitHub repository I created is: 
http://github.com/cameronmcnz/my-github-repo.git 
Copy and paste this URL into a text editor and then add your username and password to the start of the URL: 

http://<strong>cameronmcnz:<a href="/cdn-cgi/l/email-protection" data-cfemail="92c6a7a7e6e7e6fde0fbf3fed2">[email&nbsp;protected]</a></strong>github.com/cameronmcnz/my-github-repo.git 
This URL setup lets you authenticate the file without using a credential manager or other password management tool. 
<h3 id="gitremotetopic-2">Run the git remote add origin command</h3><a href="#top" target="_self"><b>⇧</b></a><br> 

With the GitHub URL saved to the clipboard in the folder that contains your local Git repository, open a terminal window and run the following git remote add origin command: 
git remote add origin http://<strong>cameronmcnz:<a href="/cdn-cgi/l/email-protection" data-cfemail="3f6b0a0a4b4a4b504d565e537f">[email&nbsp;protected]</a></strong>github.com/cameronmcnz/my-github-repo.git 
This command will execute, but the system won't provide any feedback to the terminal window. 

To verify that the remote repo was added to your configuration, use the git remote –v command. 
This command will show that GitHub is the fetch and push targets of the local repository. 
<h3 id="gitremotetopic-3">Perform a git push to the remote</h3><a href="#top" target="_self"><b>⇧</b></a><br> 

Finally, with the GitHub service configured, push all your local code changes, commits and revision history to the remote server with a git push command. 
Make sure you specify the --set-upstream option, otherwise the remote server will reject the operation. 
Also include the name of the branch to push, which in this case is master. 

<img class="lazy" data-src="https://cdn.ttgtmedia.com/rms/onlineImages/SideCOM_git-remote-add-remote-push_003.jpg">

Push changes to the remote server with the git push command.

git push --set-upstream origin master 

As this action completes, the terminal window lists the number of objects <a href="https://www.theserverside.com/blog/Coffee-Talk-Java-News-Stories-and-Opinions/How-a-git-reset-and-push-to-remote-works-on-previous-local-commits">pushed to the server</a> and indicates that your local repository is set to track to a branch named <em>master </em>on the GitHub server. 
<h3 id="gitremotetopic-4">Verify the git remote add push on GitHub</h3><a href="#top" target="_self"><b>⇧</b></a><br> 
After the git remote add and push commands complete, go back to the <a href="https://github.com/cameronmcnz/my-github-repo">GitHub instance</a> and look at the contents of the recently created repository. 

<img class="lazy" data-src="https://cdn.ttgtmedia.com/rms/onlineImages/SideCOM_github-remote-add-origin-success_004.jpg">

The result of the local git remote add and push command is reflected in the remote GitHub repository.


The remote GitHub repository should contain all the files that make up your local repository and at the same time, maintain a copy of your commit history. 

If you look at my GitHub repository, you will see the HelloWorld.java, index.html and style.css files, along with an indication that the repository contains two commits. 
These files and commits are consistent with the output from the git reflog command from the start of this tutorial. 
<h3 id="gitremotetopic-5">Overview of git remote add origin and push steps</h3><a href="#top" target="_self"><b>⇧</b></a><br> 

In review, these are the five steps to successfully perform a git remote add origin and push to a remote repository: 

<li>Validate the existence of your local Git repository.</li> 
<li>Create a new, empty Git repository on your remote server.</li> 
<li>Obtain the git remote add URL for the remote repository and add credentials if needed.</li> 
<li>Run the git remote add origin command from your local repository with the --set-upstream and the name of the active branch to push.</li> 
<li>View the pushed files on the remote Git repository to verify that the git remote add and push commands ran successfully.</li> 

Now that the remote and local repositories can interact seamlessly, you can continue to <a href="https://www.theserverside.com/video/Follow-these-git-commit-message-guidelines">commit code</a> locally, push changes to the remote GitHub server, and begin to manage your source code in a distributed manner.






<br><br>
<br>
<br>
<br>
<script type='text/javascript' src='readbook.js'></script>
<script>
var lazyLoadInstance = new LazyLoad({
    elements_selector: ".lazy"
    // ... more custom settings?
});
</script>

</body>
</html>
