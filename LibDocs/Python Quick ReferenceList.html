<!DOCTYPE html>
<html>
<title>A Python Quick Reference</title>

<head>
<meta charset="utf-8">

<style>

a:hover,a:active{color:red}
table.w3-table-all{margin:20px 0}
.top {
 position:relative;
 background-color:black;
 height:68px;
 padding-top:20px;
 line-height:50px;
 overflow:hidden;
 z-index:2;
}
body {
 background-color: #000000;
 color: MediumSeaGreen;
 margin-left: 14%;
 margin-right: 14%;
 font-size: 24px;
}
a { text-decoration: none;
	color: #58D858;}
a:visited { color: #88C898;}
A:hover {	color: yellow;}
A:focus {	color: red;}
code { color: gray; background-color: #001010;  font-size: 18px;}
pre { color: gray; background-color: #001010; font-size: 16px;}
h1, h2, h3, h4, h5, .goldword {
	color: gold;
}
table{
	width: 100%;
	font-size: 20px;
	border-collapse: collapse;
	border: 1px solid gray;
}
th{
	border: 1px solid gray;
	font-weight:bold;
	color: lightgreen;
}
td{
	padding:10px;
	border: 1px dotted dimgray;
}
tr>th:first-child{
	width:40%;
}
tr>td:first-child{
	color: lime;

}
img{
	margin-top:1%;
	margin-bottom:2%;
}
.topic{
    color: lime;
}
.goldsha {
    color: white;
    border: 1px solid gold;
    padding: 2px;
    border-radius: 3px;
	box-shadow: -2px -2px 3px gold inset;
}
.redsha {
    color: gold;
    border: 1px solid red;
    padding: 2px;
    border-radius: 3px;
	box-shadow: -2px -2px 3px red inset;
}
.whitesha {
    color: red;
    border: 1px solid white;
    padding: 2px;
    border-radius: 3px;
	box-shadow: -3px -2px 3px white inset;
}
.orangesha {
    color: yellow;
    border: 1px solid orange;
    padding: 2px;
    border-radius: 3px;
	box-shadow: -2px -2px 3px orange inset;
}
.yellowsha {
    color: lime;
    border: 1px solid yellow;
    padding: 2px;
    border-radius: 3px;
	box-shadow: 3px 3px 3px silver;
	display: inline-block;
}
.greensha {
    color: lightblue;
    border: 1px solid green;
    padding: 2px;
    border-radius: 3px;
	box-shadow: -2px -2px 3px green inset;
}
.left {
    position: absolute;
    left: 100px;
    color: GoldenRod;
    border: 1px solid GoldenRod;
    padding: 2px;
    font-size: 60%;
}
.bord {
    color: redpink;
    border: 1px solid GoldenRod;
    padding: 1px;
    font-size: 90%;
}
.yellowbord {
    color: lime;
    border: 1px solid yellow;
    padding: 2px;
    border-radius: 3px;
	box-shadow: 3px 3px 3px silver;
}
.bluebord {
    color: white;
    border: 1px solid lightblue;
    padding: 2px;
    border-radius: 3px;
	box-shadow: -2px -2px 3px silver inset;
}
.highlight { 
    color: white;
    background-color: #002030
  }
hr {width: 50%;}
li{
	list-style-type: decimal;
}
#toc, #tang, #san, #pill {
	margin-left: 15%;
	margin-right: 15%;
	color: gold;
	padding: 1%;
	text-align: left;
	box-shadow: 5px 5px 15px silver;
	border-radius: 5px;
	border: 1px solid DarkSlateGray;
    font-size: 90%;
}
.mywords{
    color: Crimson;
}
.orangeword{
    color: orange;
}
.remarks {
	font-size: 22px;
	color: MediumSeaGreen;
}
</STYLE>

<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script>
$(document).ready(function(){
    $('h1, h2, h3, h4, h5, .goldword, .topic').click(function(){
    parent.history.back();
    return false;
    });
});
</script>


</head><body>

<center><b>Python Quick Reference</b></center>
<div id="toc"><ul></ul></div>
<br>
<br>
<br>

<H2>Contents</H2>
<MENU>
<LI><A HREF="#Invocation">Invocation Options</A>
<LI><A HREF="#Environment">Environment Variables</A>
<LI><A HREF="#Terms">Terms Used In This Document</A>
<LI><A HREF="#LexEnt">Lexical Entitites</A>
<LI><A HREF="#BasicTypes">Basic Types And Their Operations</A>
<LI><A HREF="#AdvTypes">Advanced Types</A>
<LI><A HREF="#Statements">Statements</A>
<LI><A HREF="#BuiltIn">Built In Functions</A>
<LI><A HREF="#BuiltInExc">Built In Exceptions</A>
<LI><A HREF="#SpecialMethods">Special Methods For User-Created Classes</A>
<LI><A HREF="#ImportantModules">Important Modules</A>
<LI><A HREF="#OtherModules">Other Modules In Base Distributions</A>
<LI><A HREF="#Workspace">Workspace Exploration And Idiom Hints</A>
<LI><A HREF="#Emacs">Python Mode for Emacs</A>
<LI><A HREF="#Debugger">The Python Debugger</A>
</MENU>
<HR>
<H2></H2>
<H2><A NAME=Invocation>Invocation Options</A></H2>
<PRE>
python [-diuv] [-c command | script | - ] [args]


     -d   Turn on parser  debugging  output  (for  wizards  only,
          depending on compilation options).

     -i   When a script is passed as first  argument  or  the  -c
          option  is used, enter interactive mode after executing
          the script or  the  command.   It  does  not  read  the
          $PYTHONSTARTUP  file.   This  can  be useful to inspect
          global variables or a stack trace when a script  raises
          an exception.

     -s   Suppress auto-printing of expressions in interactive mode.

     -u   Force stdout and stderr to be totally unbuffered.

     -v   Print a message each  time  a  module  is  initialized,
          showing  the  place  (filename or built-in module) from
          which it is loaded.

     -c command
          Specify the command  to  execute  (see  next  section).
          This  terminates the option list (following options are
          passed as arguments to the command).

     -  anything afterward is passed as options to python script or
        command, not interpreted as an option to interpreter itself.

     script is the name of a python file to execute

     args are passed to script or command (in "sys.argv")

</PRE>
If no script or command, Python enters interactive mode. Uses
"readline" package for input, if available.
<HR>
<H2></H2>
<H2><A NAME=Environment>ENVIRONMENT VARIABLES</A></H2>
<DL>
<DT>PYTHONPATH<DD>
	Augments the default search path for module files.  The
          format  is  the  same as the shell's $PATH: one or more
          directory pathnames separated by colons.   
    <DT>PYTHONSTARTUP<DD>
          If this is the name of a readable file, the Python com-
          mands in that file are executed before the first prompt
          is displayed in interactive mode. 
     <DT>PYTHONDEBUG<DD>
          If non-empty, same as -d option
     <DT>PYTHONINSPECT<DD>
          If non-empty, same as -i option
     <DT>PYTHONSUPPRESS<DD>
          If non-empty, same as -s option
     <DT>PYTHONUNBUFFERED<DD>
          If non-empty, same as -u option
     <DT>PYTHONVERBOSE<DD>
          If non-empty, same as -v option
</DL>
<HR>
<H2></H2>
<H2><A NAME=Terms>Terms Used In This Document</A></H2>
<DL COMPACT>
<DT>sequence<DD>a string, list or tuple
<DT>suite<DD>a series of statements, possibly separated
		   by newlines. Must all be at same indentation level,
		   except for suites inside compound statements
<DT>&lt;x&gt<DD>in a syntax diagram means a token referred to as "x"
<DT>[xxx]<DD>in a syntax diagram means "xxx" is optional
<DT>x ==&gt; y<DD>means the value of &lt;x&gt is &lt;y&gt
<DT>x &lt;=&gt; y<DD>means "x is equivalent to y"
</DL>
<HR>
<H2></H2>
<H2><A Name=LexEnt>Notable lexical entities</A></H2>
<H3>Keywords</H3>
<PRE>
         and           elif        from        lambda     return
         break         else        global      not     	  try  
         class         except      if          or      	  while     
         continue      exec        import      pass    	       
         def           finally     in          print   	       
	 del	       for         is          raise  
</PRE>
<P> 
Illegitimate Tokens (only valid in strings): @ $ ?
</P>
<P>
    A statement must all be on a single line. To break a statement over
    multiple lines use "\", as with the C preprocessor. 
    Exception: can always break when inside any (), [], or {} pair, or
    in triple-quoted strings.
</P>
<P>
    More than one statement can appear on a line if they are
    separated with semicolons (";").
</P>
<P>
    Comments start with "#" and continue to end of line.
</P>
<P>
    Identifiers: (letter|"_") (letter|digit|"_")*
    Python identifiers keywords, attributes, etc. are case-sensitive.
</P>
<P>
<H3>Strings</H3>
"a string"<BR>
      'another string'<BR>
      '''a string containing embedded newlines,<BR>
         and quote (') marks, can be <BR>
         delimited with triple quotes.'''<BR>
<H3>String Literal Escapes</H3>
<PRE>
     \newline  Ignored (escape newline)
     \\ Backslash (\)	     \e Escape (ESC)		\v Vertical Tab (VT)
     \' Single quote (')     \f Formfeed (FF)		\0OO  (zero) char with 
     \" Double quote (")     \n Linefeed (LF)		      octal value OO
     \a Bell (BEL)	     \r Carriage Return (CR)	\xXX  char with 
     \b Backspace (BS)	     \t Horizontal Tab (TAB)	      hex value XX
     \<any other char> is left as-is
</PRE>
<P>
    NULL byte (\000) is NOT an end-of-string marker; NULL's may
      be imbedded in strings
</P>
<P>
    Strings (and tuples) are immutable: they cannot be modified.
</P>
<P>

    long integer (unlimited precision):  1234567890L
</P>
<P>

    octal integer: 0177, 0177777777777777777L
    hex integer: 0xFF, 0xFFFFFFFFFFFFFFFFFFL
</P>
<P>

    float: 3.14e-10

</P>
<P>
    tuple of length 0, 1, 2, etc:<BR>
       () (1,) (1,2)        # parentheses are optional if len > 0<BR>
	  <BR>
    list of length 0, 1, 2, etc:<BR>
       [] [1] [1,2]<BR>
	  <BR>
    dictionary of length 0, 1, 2, etc:<BR>
       {}  {1 : 'first'}   {1 : 'first', 'next': 'second'}<BR>

</P>
<P>
    Indexing is 0-based. Negative indices (usually) mean count
    backwards from end of sequence.

</P>
<P>
    Sequence slicing  [starting-at-index : but-less-than-index]
    Start defaults to '0'; End defaults to 'sequence-length'.
</P>
<P>
      a = (0,1,2,3,4,5,6,7)<BR>
      a[3] ==> 3<BR>
      a[-1] ==> 7<BR>
      a[2:4] ==> (2, 3)<BR>
      a[1:] ==> (1, 2, 3, 4, 5, 6, 7)<BR>
      a[:3] ==> (0, 1, 2)<BR>
      a[:] ==> (0,1,2,3,4,5,6,7)   # makes a copy of the sequence.<BR>
<HR>
<H2></H2>   
<H2><A Name=BasicTypes>Basic Types and Their Operations</A></H2>
     <H3>Comparisions (defined between _any_ types)</H3>
<PRE>
        <	strictly less than	
        <=	less than or equal	
        >	strictly greater than	
        >=	greater than or equal	
        ==	equal	
        !=	not equal  ( "<>" is also allowed)
        is	object identity	(are _objects_ identical, not values)
        is not	negated object identity
</PRE>
      X < Y < Z < W has expected meaning, unlike C
</P>
<P>
<H3>Boolean values and operators</H3>
<PRE>
      False values:	None, numeric zeros, empty sequences and mappings
      True values:	all other values

      not X: if X is false then 1, else 0
      X or Y: if X is false then Y, else X
      X and Y: if X is false then X, else Y

      ('or', 'and' evaluate second arg only if necessary to determine outcome)
</PRE>
	<H3>None</H3>
      None is used as default return value on functions.
      Input that evaluates to None does not print when 
	running Python interactively

     <H3>Numeric types</H3>
      <H4>Floats, integers and long integers.</H4>
      
<P>      Floats are implemented with C doubles. </P>
<P>      Integers are implemented with C longs. </P>
<P>      Long integers have unlimited size (only limit is system
        resources)
</P>
      <H4>Operators on all numeric types</H4>
<PRE>
        abs(x)	absolute value of x	
        int(x)	x converted to integer	
        long(x)	x converted to long integer	
        float(x)	x converted to floating point	
        -x	x negated	
        +x	x unchanged	
        x + y	sum of x and y	
        x - y	difference of x and y	
        x * y	product of x and y	
        x / y	quotient of x and y	
        x % y	remainder of x / y
        divmod(x, y)	the tuple (x/y, x%y)
        pow(x, y)	x to the power y	
</PRE>
       <H4>Bit operators on integers and long integers</H4>
<PRE>
        ~x	the bits of x inverted	
        x ^ y	bitwise exclusive or of x and y	
        x & y	bitwise and of x and y	
        x | y	bitwise or of x and y	
        x << n	x shifted left by n bits	
        x >> n	x shifted right by n bits
</PRE>
       <H4>Numeric exceptions</H4>
<DL COMPACT>
       <DT>TypeError<DD>raised on application of arithemetic opertion '
	  to non-number
       <DT>OverflowError<DD> numeric bounds exceeded
       <DT>ZeroDivisionError<DD> raised when zero second argument of div or modulo op
</DL>
     <H3>Operators on all sequence types (lists, tuples, strings)</H3>
<PRE>
	len(s)		length of s	
	min(s)		smallest item of s	
	max(s)		largest item of s	
	x in s		1 if an item of s is equal to x, else 0
	x not in s	0 if an item of s is equal to x, else 1
	s + t		the concatenation of s and t	
	s * n, n * s	n copies of s concatenated	
	s[i]		i'th item of s, origin 0
	s[i:j]		slice of s from i to j	

	slice from index i up to but not including index j
	i defaults to 0, j to len(s)
	negative goes from right-end of sequence
</PRE>
     <H3>Operators on mutable sequences (lists)</H3>
<PRE>
	s[i] = x	item i of s is replaced by x	
	s[i:j] = t	slice of s from i to j is replaced by t	
	del s[i:j]	delete slice (same as s[i:j] = [])
	s.append(x)     add x to end of s
	s.count(x)	return number of i's for which s[i] == x
	s.index(x)	return smallest i such that s[i] == x1)
	s.insert(i, x) 	item i becomes x, old item i is now at i+1, etc.
	s.remove(x) 	same as del s[s.index(x)]	
	s.reverse() 	reverses the items of s (in place)
	s.sort()	sorts the list (in place)
			Optional parameter: function of two arguments 
			returning -1, 0 or 1 depending on whether arg1 
			is >, ==, < arg2.
</PRE>

IndexError is raised on out-of-range sequence subscript

<H3>	    Operations on mappings (dictionaries)</H3>
<PRE>
	len(a)		the number of items in a	
	a[k]		the item of a with key k
	a[k] = x	set a[k] to x	
	del a[k]	remove a[k] from a
	a.items()	a copy of a's list of (key, value) pairs	
	a.keys()	a copy of a's list of keys	
	a.values()	a copy of a's list of values	
	a.has_key(k)	1 if a has a key k, else 0
</PRE>
	     TypeError is raised if key not acceptable<BR>
	     KeyError is raised if try to read with non-existent key<BR>

<H3>	    Format operator for strings (%)</H3>
<H4>	       Uses sprintf codes. </H4>
<P>	Supports: %, c, s, i, d, u, o, x, X, e, E, f, g, G.</P>
<P>	Width and precision may be a * to specify that an integer argument
	specifies the actual width or precision.</P> 
<P>The flag characters -, +, blank, # and 0 are understood.</P>
<P>	%s will convert any type argument to string (uses str() function)
<PRE>
	a = '%s has %03d quote types.' % ('Python', 2)
	a ==> 'Python has 002 quote types.'
</PRE>
	       Right-hand-side can be a mapping:
<PRE>
	a = '%(lang)s has %(c)03d quote types.' % {'c':2, 'lang':'Python}
</PRE>
	 (vars() function very handy to use on right-hand-side.)
	 <H3> File Objects </H3>
	    Created with built-in function "open()"; may be created by other 
	    modules's functions as well.

	    <H4>Operators on file objects</H4>
<PRE>
	f.close(x)     			close file f.
	f.fileno(x)    			get fileno (fd) for f.
	f.flush(x)     			flush file's internal buffer.
	f.isatty()    			1 if file is connected to a tty-like dev, else 0
	f.read([size]) 			read at most most <size> bytes from file and
					return as a string object. If <size> omitted,
					read to EOF.

	f.readline()   			read one entire line from file
	f.readlines()  			read until EOF with readline() and return list
					of lines read.

	f.seek(offset, whence=0)     	set file's position, like 
					"stdio's fseek()". 
					whence == 0 then use absolute indexing
					whence == 1 then offset relative to current pos
					whence == 2 then offset relative to file end

	f.tell()     			return file's current position
	f.write(str)			Write string to file.
	f.writelines(list)		Write list of strings to file.
</PRE>
	<H4>File Exceptions</H4>
<DL><DT>EOFError<DD>		End-of-file hit when reading (may be raised
			many times, e.g. if <f> is a tty).

	     <DT>IOError<DD>		Other I/O-related I/O operation failure
</DL>
<HR>
<H2></H2>
<H2><A Name=AdvTypes>Advanced Types</A></H2>
<EM>See manuals for more details</EM>
<P>
<UL>
<LI>	  Module Objects
<LI>	  Class Objects
<LI>	  Type Objects
<LI>	  Callable types:
<LI>	    User-defined (written in Python):
<UL>
<LI>	      User-defined Function Objects
<LI>	      User-defined Method Objects
</UL>
<LI>	    Built-in (written in C):
<UL>
<LI>	      Built-in Function Objects
<LI>	      Built-in Method Objects
</UL>
<LI>	  Internal Types:
<UL>
<LI>	    Code Objects
<LI>	    Frame Objects
<LI>	    Traceback Objects
</UL>
</UL>
<HR>
<H2></H2>
<H2><A Name=Statements>Statements</A></H2>
<PRE>
pass		-- Null statement
=		-- Assignment operator. Can unpack tuples, lists,
		   first, second = a[0:2]; [f, s] = range(2)
del &lt;id&gt	-- Unbind name from object, or attributes from
		   objects, etc.
print [&lt;c1&gt [, &lt;c2&gt ]* [,]
		-- Writes to sys.stdout.
		   Puts spaces between arguments. Puts newline at end
		   unless statement ends with comma.
		   Print is not required when running interactively,
		   simply typing an expression will print its value,
		   unless the value is None.
exec &lt;x&gt [in &lt;globals&gt [,&lt;locals&gt;]]
		-- Executes &lt;x&gt in namespaces provided. Defaults
		   to current namespaces. &lt;x&gt can be a string, file
		   object or a function object.
f(&lt;value&gt;,... [&lt;id&gt;=&lt;value&gt;])
		-- Call function 'f' with parameters. Parameters can
		   be passed by name or be omitted if function 
		   defines default values. E.g. for 'f' is defined as
		   "def f(p1=1, p2=2)"
		   "f()"       &lt;=&gt;  "f(1, 2)"
		   "f(10)"     &lt;=&gt;  "f(10, 2)"
		   "f(p2=99)"  &lt;=&gt;  "f(1, 99)"

</PRE>
	<H3>Control Flow</H3>
<PRE>
if &lt;condition&gt;: &lt;suite&gt
[elif &lt;condition&gt;: &lt;suite&gt;]*
[else: suite]
		-- usual if/else_if/else statement

while &lt;condition&gt;: &lt;suite&gt
[else: &lt;suite&gt;]
		-- usual while statement. "else" suite is executed
		   after loop exits, unless the loop is exited with
		   "break"

for &lt;target&gt in &lt;condition-list&gt;: &lt;suite&gt;
[else: &lt;suite&gt;]
		-- iterates over sequence "&lt;condition-list&gt;",
	 	   assigning each element to "&lt;target&gt;".
		   "else" suite executed at end unless loop exited
		   with "break"

break		-- immediately exit "for" or "while" loop
continue	-- immediately do next iteration of "for" or "while" loop

return [&lt;result&gt;]
		-- return from function (or method) and return
		   "&lt;result&gt;". If no result given, then returns None.
</PRE>
<H3>Exception Statements</H3>
<PRE>
try: &lt;suite1&gt;
[except [&lt;exception&gt; [, &lt;value&gt;]: &lt;suite2&gt;]+
[else: &lt;suite3&gt;]
		-- statements in &lt;suite1&gt; are executed. If an
		   exception occurs, look in "except" clauses for
		   matching &lt;exception&gt;. If matches or bare "except"
		   execute suite of that clause. If no exception happens
		   suite in "else" clause is executed after &lt;suite1&gt;.
		   If &lt;exception&gt; has a value, it is put in &lt;value&gt;.
		   &lt;exception&gt; can also be tuple of exceptions, e.g.
		   "except (KeyError, NameError), val: print val"

try: &lt;suite1&gt;
finally: &lt;suite2&gt;
		-- statements in &lt;suite1&gt; are executed. If no
		   exception, execute &lt;suite2&gt; (even if &lt;suite1&gt; is
		   exited with a "return", "break" or "continue"
		   statement). If exception did occur, executes 
		  &lt;suite2&gt; and them immediately reraises exception.

raise &lt;exception&gt; [,&lt;value&gt; [,&lt;traceback&gt;]]
		-- raises &lt;exception&gt; with optional value
		   &lt;value&gt;. Parameter &lt;traceback&gt;
		   specifies a traceback object to use when printing
		   the exception's backtrace.

An exception is either a string (object) or a class instance.
Can create a new one simply by creating a new string:

		my_exception = 'You did something wrong'
		try: 
			if bad: 
				raise my_exception, bad
		except my_exception, value: 
			print 'Oops', value
Or, more complicated:
		class base_exception:
			pass
		class numeric_exception(base_exception):
			pass
		class text_exception(base_exception):
			pass
		try:
			if bad:
				raise text_exception()
				## This is a shorthand for the form
				## "raise &lt;class&gt;, &lt;instance&gt;"
				## 
		except base_exception:
			print 'Oops'
			## This will be printed because
			## text_exception is a subclass of base_exception

When an error message is printed for an unhandled exception which is a
class, the class name is printed, then a colon and a space, and
finally the instance converted to a string using the built-in function
str().

</PRE>
<H3>Name Space Statements</H3>
<PRE>
import &lt;module_id1&gt; [, &lt;module_id2&gt;]*
		-- imports modules. Members of module must be 
		   referred to by qualifying with module name:
		   "import sys; print sys.argv:

from &lt;module_id&gt; import &lt;id1&gt; [, &lt;id2&gt;]*
		-- imports names from module &lt;module_id&gt;. Names
		   are not qualified:
		   "from sys import argv; print argv"

from &lt;module_id&gt; import *
		-- imports all names in module &lt;module_id&gt;, except
		   those starting with "_":
		   "from sys import *; print argv"

global &lt;id1&gt; [,&lt;id2&gt;]*
		-- ids are from global scope (usually meaning from module)
		   rather than local (usually meaning only in
		   function).
		-- E,g, in fcn, no "global" statements, assume "a"
		   is name that hasn't been used in fcn or module
		   so far.

		   Try to read from "a" -&gt; NameError
		   Try to write to "a" -&gt; creates "a" local to fcn
		   If "a" not defined in fcn, but is in module, then
		   Try to read from "a", gets value from module
		   Try to write to "a", creates "a" local to fcn

		   But note "a[0]=3" starts with search for "a",
		   will use to global "a" if no local "a".
</PRE>		
	<H3>Function Definition</H3>
<PRE>
def &lt;func_id&gt; ([&lt;param_list&gt;]): &lt;suite&gt;
		-- creates a function object and assigns it name 
		   &lt;func_id&gt.

&lt;param_list&gt; ==&gt; [&lt;id&gt; [, &lt;id&gt;]*] [&lt;id&gt; =
							  &lt;v&gt; [,
							  &lt;id&gt; =
							  &lt;v&gt;]*]
							  [*&lt;id&gt;] 
							  [**&lt;id&gt;]
E.g.
	def test (p1, p2 = 1+1, *rest, **keywords):
		-- Parameters with "=" have default value (&lt;v&gt; is
		   evaluated when function defined).
		   If list has "*&lt;id&gt;" then &lt;id&gt; is assigned
		   a tuple of all remaining args passed to function.
		   (allows vararg functions).
		   If list has "**&lt;id&gt;" then &lt;id&gt; is assigned
		   a dictionary of all argumenst passed as keywords.
</PRE>
	<H3>	Class Definition</H3>
<PRE>
class &lt;class_id&gt; [(&lt;super_class1&gt; [,&lt;super_class2&gt;]*)]: &lt;suite&gt;
	-- Creates a class object and assigns it name &lt;class_id&gt;
	   &lt;suite&gt; may contain local "defs" of class methods and
	   assignments to class attributes.
E.g.
	     class my_class (class1, class_list[3]): ...
	          Creates a class object inheriting from both "class1" and whatever  
	          class object "class_list[3]" evaluates to. Assigns new
	          class object to name "my_class".

	First arg to class methods is always instance object.
	By convention this is called "self".
	Special method "__init__()" called when instance created.
	Create instance by "calling" class object, possibly with args.
	In current implementation, can't subclass off built-in
	classes. But can "wrap" them, see __getattr__() below.


E.g.
	class c (c_parent): 
	   def __init__(self, name): self.name = name
	          def print_name(self): print "I'm", self.name
	          def call_parent(self): c_parent.print_name(self)

	       instance = c('tom')
	       print instance.name 
	         'tom'
	       instance.print_name()
	         "I'm tom"

	Call parent's super class by accessing parent's method
	directly and passing "self" explicitly (see "call_parent"
	in example above).

	Many other special methods available for implementing
	arithmetic operators, sequence, mapping indexing, etc.

</PRE>
<H4>		Documentation Strings</H4>

Modules, classes and functions may be documented by placing
a string literal by itself as the first statement in the suite. The
documentation can be retrieved by getting the '__doc__' attribute from
the module, class or function.

<PRE>
Example:
	class c:
		"A description of 'c'"
		def __init__(self):
			"A description of the constructor"
			# etc.
Then c.__doc__ &lt;=&gt; "A description of 'c'".
Then c.__init__.__doc__ &lt;=&gt; "A description of the constructor".

</PRE>
<H3>		Others </H3>
<PRE>
lambda [&lt;param_list&gt;]: &lt;condition&gt;
		-- Create an anonymous function. &lt;condition&gt; must be
		   an expression not a statement (e.g., not "if xx:...", 
		   "print xxx", etc.) and thus can't contain newlines.
		   Used mostly for filter(), map(), reduce() functions.
</PRE>
<HR>
<H2></H2>
<H2><A Name=BuiltIn>Built-In Functions</A></H2>
<PRE>
abs(x)		Return the absolute value of a number

apply(f, args)
		Call func/method &lt;f&gt; with args &lt;args&gt;

callable(x)	Returns 1 if x callable, else 0.

chr(i)		Return one-character string whose ASCII code is
		integer i

cmp(x,y)	Return neg, zero, pos if x &lt;, ==, &gt; to y

coerce(x,y)	Return a tuple of the two numeric arguments converted to
	 	a common type.

compile(string, filename, kind) 
		Compile &lt;string&gt; into a code object.
		&lt;filename&gt; is used in error message, can be
		any string.  &lt;kind&gt; can be 'eval' if
		&lt;string&gt; is a single stmt, or 'single' which
		prints the output of expression statements that
		evaluate to something else than "None" or be 'exec'.

dir([object])	If no args, return the list of names in current local
		symbol table. With a module, class or class instance
		object as arg, return list of names in its attr dict.

divmod(a,b)	Returns tuple of (a/b, a%b)

eval(s, globals, locals)
		Eval string &lt;s&gt; in (optional) &lt;globals&gt;, &lt;locals&gt;. 
		&lt;s&gt; must have no NULL's or newlines. &lt;s&gt; can also be a
		code object.
		E.g.: x = 1; incr_x = eval('x + 1')

filter(function, list)
		Construct a list from those elements of &lt;list&gt; for which
	        &lt;function&gt; returns true. &lt;function&gt; takes one parameter.

float(x)	Convert a number to floating point.

getattr(object, name)
		Get attr called &lt;name&gt; from &lt;object&gt;.
		getattr(x, 'foobar') &lt;=&gt; x.foobar

globals()	Returns a dictionary containing current global variables.

hasattr(object, name)
		Returns true if &lt;object&gt; has attr called &lt;name&gt;.

hash(object)	Return the hash value of the object (if it has one)

hex(x)		Convert a number to a hexadecimal string.

id(object)	Return a unique 'identity' integer for an object.

input([prompt])	Prints prompt, if given. Reads input and evaluates it.

int(x)		Convert a number to a plain integer.

len(s)		Return the length (the number of items) of an object.

local()		Return a dictionary containing current local variables.

long(x)		Convert a number to a long integer.

map(function, list, ...)
		Apply &lt;function&gt; to every item of &lt;list&gt; and return a list
		of the results.  If additional arguments are passed, 
		&lt;function&gt; must take that many arguments and it is given
		to &lt;function&gt; on each call.

max(s)		Return the largest item of a non-empty sequence.

min(s)		Return the smallest item of a non-empty sequence.

oct(x)		Convert a number to an octal string.

open(filename [, mode='r', [bufsize=&lt;implementation dependent&gt;]])<br>
		Return a new file object. First two args are same as 
		those for C's "stdio open" function. &lt;bufsize&gt; is 0
		for unbuffered, 1 for line-buffered, negative for
		sys-default, all else, of (about) given size.

ord(c)		Return integer ASCII value of &lt;c&gt; (str of len 1).

pow(x, y [, z])	Return x to power y [modulo z]

range(start [,end [, step]])
		return list of ints from &gt;= start and &lt; end. 
		With 1 arg, list from 0..&lt;arg&gt;-1
		With 2 args, list from &lt;start&gt;..&lt;end&gt;-1
		With 3 args, list from &lt;start&gt; up to &lt;end&gt; by &lt;step&gt;

raw_input([prompt])
		Print prompt if given, then read string from std
		input.

reduce(f, list [, init])
		Apply the binary function &lt;f&gt; to the items of
		&lt;list&gt; so as to reduce the list to a single value.
		If &lt;init&gt; given, it is "prepended" to &lt;list&gt;.

reload(module)	Re-parse and re-initialize an already imported module.
		Useful in interactive mode, if you want to reload a
		module after fixing it. If module was synactically
		correct but had an error in initialization, must
		import it one more time before calling reload().

repr(object)	Return a string containing a printable representation
		of an object. Equivalent to `object` (using
		backquotes).

round(x,n=0)	Return the floating point value x rounded to n digits
	 		after the decimal point.

setattr(object, name, value)
		This is the counterpart of getattr().
		setattr(o, 'foobar', 3) &lt;=&gt; o.foobar = 3

str(object)	Return a string containing a nicely printable
		representation of an object.

tuple(list)	Creates a tuple with same elements as &lt;list&gt;

type(object)	Return type of an object. E.g.,
		if type(x) == type(''): print 'It is a string'

vars([object])	Without arguments, return a dictionary corresponding
		to the current local symbol table.  With a module,
		class or class instance object as argument   
		returns a dictionary corresponding to the object's
		symbol table. Useful with "%" formatting operator.

xrange(start [, end [, step]])
		Like range(), but doesn't actually store entire list
		all at once. Good to use in "for" loops when there is a
		big range and little memory.
</PRE>
<HR>
<H2></H2>
<H2><A Name=BuiltInExc>Built-In Exceptions</A></H2>
<DL>
<DT>AttributeError<DD>	On attribute reference or assignment failure
<DT>EOFError<DD>		Immediate end-of-file hit by input() or raw_input()
<DT>IOError<DD>		I/O-related I/O operation failure
<DT>ImportError<DD>	On failure of `import' to find module or name
<DT>IndexError<DD>	On out-of-range sequence subscript
<DT>KeyError<DD>		On reference to a non-existent mapping (dict) key
<DT>KeyboardInterrupt<DD>	On user entry of the interrupt key (often `Control-C')
<DT>MemoryError<DD>	On recoverable memory exhaustion
<DT>NameError<DD>		On failure to find a local or global (unqualified) name
<DT>OverflowError<DD>	On excessively large arithmetic operation
<DT>RuntimeError<DD>	Obsolete catch-all; define a suitable error instead
<DT>SyntaxError<DD>	On parser encountering a syntax error
<DT>SystemError<DD>	On non-fatal interpreter error - bug - report it
<DT>SystemExit<DD>	On `sys.exit()'
<DT>TypeError<DD>		On passing inappropriate type to built-in op or func
<DT>ValueError<DD>	On arg error not covered by TypeError or more precise
<DT>ZeroDivisionError<DD>	On division or modulo operation with 0 as 2nd arg
</DL>
<HR>
<H2></H2>
<H2><A Name=SpecialMethods>Special Methods For User-Created Classes</A></H2>
<PRE>
E.g.
class x: 
	 def __init__(self, v): self.value = v
	 def __add__(self, r): return self.value + r
a = x(3) # sort of like calling x.__init__(a, 3)
a + 4    # is equivalent to a.__add__(4)
</PRE>
	<H3>    Special methods for any class</H3> (s: self, o: other)
<PRE>
	__init__(s, args) object instantiation 
	__del__(s)        called on object demise (refcount becomes 0)
	__repr__(s)       repr() and `...` conversions
	__str__(s)        str() and 'print' statement
	__cmp__(s, o)     implements &lt;, ==, &gt;, &lt;=, &lt;&gt;, !=, &gt;=, is [not]
	__hash__(s)       hash() and dictionary operations
	__getattr__(s, name)  called when attr lookup doesn't find &lt;name&gt;
	__setattr__(s, name, val) called when setting an attr
                                  (inside, don't use "self.name = value"
                                   use "self.__dict__[name] = val")
	__delattr__(s, name)  called to delete attr &lt;name&gt;

        __call__(self, *args) called when an instance is called as function.
</PRE>
	   <H3> Numeric operations special methods </H3>
	    (s: self, o: other)
<PRE>
	s+o       =  __add__(s,o)         s-o        =  __sub__(s,o)
	s*o       =  __mul__(s,o)         s/o        =  __div__(s,o)
	s%o       =  __mod__(s,o)         divmod(s,o) = __divmod__(s,o)
	pow(s,o)  =  __pow__(s,o)
	s&o       =  __and__(s,o)         
	s^o       =  __xor__(s,o)         s|o        =  __or__(s,o)
	s&lt;&lt;o      =  __lshift__(s,o)      s&gt;&gt;o       =  __rshift__(s,o)
	nonzero(s) = __nonzero__(s) (used in boolean testing)
	-s        =  __neg__(s)           +s         =  __pos__(s)  
	abs(s)    =  __abs__(s)           ~s         =  __invert__(s)  (bitwise)
	int(s)    =  __int__(s)           long(s)    =  __long__(s)
	float(s)  =  __float__(s)
	oct(s)    =  __oct__(s)           hex(s)     =  __hex__(s)
	coerce(s,o) = __coerce__(s,o)

        Right-hand-side equivalents for all binary operators exist;
        are called when class instance is on r-h-s of operator:
        a + 3  calls __add__(a, 3)
        3 + a  calls __radd__(a, 3)
</PRE>	    
	   <H3> All seqs and maps, general operations plus:  </H3>
	(s: self, i: index or key)
<PRE>
	len(s)    = __len__(s)        length of object, &gt;= 0.  Length 0 == false
	s[i]      = __getitem__(s,i)  Element at index/key i, origin 0
</PRE>
	 <H3>   Sequences, general methods, plus:</H3>
<PRE>
	s[i]=v           = __setitem__(s,i,v)
	del s[i]         = __delitem__(s,i)
	s[i:j]           = __getslice__(s,i,j)
	s[i:j]=seq       = __setslice__(s,i,j,seq)
	del s[i:j]       = __delslice__(s,i,j)   == s[i:j] = []
</PRE>
	<H3>    Mappings, general methods, plus </H3>
<PRE>
	hash(s)          = __hash__(s) - hash value for dictionary references
	s[k]=v           = __setitem__(s,k,v)
	del s[k]         = __delitem__(s,k)
</PRE>
	<H3>    Special informative state attributes for some types: </H3>
<PRE>
	X.__dict__        dict used to store object's writeable attributes
	I.__methods__     list of I's methods; on many built-in types.
	I.__members__     lists of I's data attributes; on many built-in types
	I.__class__       class to which instance I belongs
	C.__bases__       r/o attr, tuple of class C's base classes
	M.__name__        r/o attr, module M's name as string
</PRE>
<HR>
<H2></H2>
<H2><A Name=ImportantModules>Important Modules</A></H2>
<P ALIGN=CENTER><EM>sys</EM></P>
<P><B>Variables:</B></P>
<PRE>
argv		-- The list of command line arguments passed to a 
		   Python script. sys.argv[0] is the script name.
builtin_module_names
		-- A list of strings giving the names of all modules
		   written in C that are linked into this interpreter.

check_interval	-- How often to check for thread switches or signals 
		   (measured in number of virtual machine instructions)
exc_type
exc_value
exc_traceback
		-- Set when in an exception handler. Are last
		   exception, last exception value, and traceback
		   object of call stack when exception occured.

exitfunc	-- User can set to a parameterless fcn. It will get
		   called before interpreter exits.
last_type
last_value
last_traceback
		-- Set only when an exception not handled and
		   interpreter prints an error. Used by debuggers.

modules		-- List of modules that have already been loaded.

path		-- Search path for external modules. Can be modified
		   by program.
platform	-- The current platform, e.g. "sunos5" or "linux1"
ps1
ps2
		-- prompts to use in interactive mode.
stdin
stdout
stderr
		-- File objects used for I/O. User can redirect by
		   assigning a new file object to them (or any object
		   with a method "write()" taking string argument).

tracebacklimit	-- Maximum levels of tb info printed on error.
</PRE>
<P><B>Functions:</B></P>
<PRE>
exit(n)		-- Exit with status &lt;n&gt;. Raises SystemExit exception.
		   (Hence can be caught and ignored by program)
settrace(func)	-- Sets a trace function: called before each line of 
		   code is exited.
setprofile(func)
		-- Sets a profile function for performance profiling.
</PRE>
<HR>
<P ALIGN=CENTER><EM>os</EM></P>
	"synonym" for whatever O/S-specific module is proper for current 
	environment. Uses "posix" whenever possible. 
<P>	
<B>	Variables </B>
</P>
<PRE>
name		-- name of O/S-specific module (e.g. "posix" or "mac")
path		-- O/S-specific module for path manipulations.
		   on Unix, os.path.split() &lt;=&gt; posixpath.split()
curdir		-- string used to represent current directory ('.')
pardir		-- string used to represent parent directory ('..')
sep		-- string used to separate directories ('/')
</PRE>
<HR>
<P ALIGN=CENTER><EM>posix</EM></P>
<P><B>	Variables: </B></P>
<PRE>
environ		-- dictionary of environment variables, e.g.
		   posix.environ['HOME']

error		-- exception raised on POSIX-related error. 
		   Corresponding value is tuple of errno code and
		   perror() string.
</PRE>
	<P><B>Some Functions (see doc for more):</B></P>
<PRE>
chdir(path)	-- Go to &lt;path&gt;.
close(fd)	-- Close file descriptor &lt;fd&gt;.
_exit(n)	-- Immediate exit, with no cleanups, no SystemExit,
		   etc. Should use this to exit a child process.
execv(p, args)	-- "Become" executable &lt;p&gt; with args &lt;args&gt;
fork()		-- Like C's fork(). Returns 0 to child, child pid to parent.
kill(pid, signal)
		-- Like C's kill
listdir(path)	-- List names of entries in directory &lt;path&gt;.
open(file, flags, mode)
		-- Like C's open(). Returns file descriptor.
pipe()		-- Creates pipe. Returns pair of file descriptors (r, w).
popen(command, mode='r', buffSize=0)
		-- Open a pipe to or from &lt;command&gt;. Result is a file
		   object to read to or write from, as indicated by
		   &lt;mode&gt; being 'r' or 'w'.
read(fd, n)	-- Read &lt;n&gt; bytes from &lt;fd&gt; and return as string.
stat(path)	-- Returns st_mode, st_ino, st_dev, st_nlink, st_uid,
		   st_gid, st_size, st_atime, st_mtime, st_ctime. 
system(command)	-- Execute string &lt;command&gt; in a subhell. Returns exit
		   status of subshell.
unlink(path)	-- Unlink ("delete") path/file.
wait()		-- Wait for child process completion. Returns tuple of
		   pid, exit_status
waitpid(pid, options)
		-- Wait for process pid to complete. Returns tuple of
		   pid, exit_status
write(fd, str)	-- Write &lt;str&gt; to &lt;fd&gt;. Returns num bytes written.
</PRE>
<HR>
<P ALIGN=CENTER><EM>posixpath</EM></P>
<P><B>Some Functions (see doc for more):</B></P>
<PRE>
exists(p)	-- True if string &lt;p&gt; is an existing path
expanduser(p)	-- Returns string that is &lt;p&gt; with "~" expansion done.
isabs(p)	-- True if string &lt;p&gt; is an absolute path.
isfile(p)	-- True if string &lt;p&gt; is a regular file.
isdir(p)	-- True if string &lt;p&gt; is a directory.
islink(p)	-- True if string &lt;p&gt; is a symbolic link.
isfile(p)	-- True if string &lt;p&gt; is a regular file.
ismount(p)	-- True if string &lt;p&gt; is a mount point.
split(p)	-- Splits into (head, tail) where &lt;tail&gt; is last
		   pathname component and &lt;head&gt; is everything leading
		   up to that.
splitext(p)	-- Splits into (root, ext) where last comp of &lt;root&gt;
		   contains no periods and &lt;ext&gt; is empty or starts
		   with a period.
walk(p, visit, arg)
		-- Calls the function &lt;visit&gt; with arguments
		   (&lt;arg&gt;, &lt;dirname&gt;, &lt;names&gt;) for each directory in the
	                  directory tree rooted at &lt;p&gt; The argument &lt;dirname&gt;
		   specifies the visited directory, the argument
		   &lt;names&gt; lists the files in the directory.  The
		   &lt;visit&gt; function may modify &lt;names&gt; to influence
	                  the set of directories visited below &lt;dirname&gt;,
	                  e.g., to avoid visiting certain parts of the tree.
</PRE>
<HR>
<P ALIGN=CENTER><EM>math</EM></P>
<P><B>Variables:</B></P>
<PRE>
pi
e

<PRE>
<P><B>Functions (see ordinary C man pages for info):</B></P>
<PRE>

acos(x)
asin(x)
atan(x)
atan2(x, y)
ceil(x)
cos(x)
cosh(x)
exp(x)
fabs(x)
floor(x)
fmod(x, y)
frexp(x)	-- Unlike C: (float, int) = frexp(float)
ldexp(x, y)
log(x)
log10(x)
modf(x)		-- Unlike C: (float, float) = modf(float)
pow(x, y)
sin(x)
sinh(x)
sqrt(x)
tan(x)
tanh(x)
</PRE>
<HR>
<P ALIGN=CENTER><EM>getopt</EM></P>
	<P><B>Functions:</B></P>
<PRE>
getopt(list, optstr)	-- Similar to C. &lt;optstr&gt; is option
			   letters to look for. Put ':' after letter
			   if option takes arg. E.g.
# invocation was "python test.py -c hi -a arg1 arg2"
   opts, args =  getopt.getopt(sys.argv[1:], 'ab:c:')   
# opts would be
   [('-c', 'hi'), ('-a', '')]
# args would be
   ['arg1', 'arg2']
</PRE>
<HR>
<P ALIGN=CENTER><EM>string</EM></P>
	<P><B>Some Variables:</B></P>
<PRE>
digits			-- The string '0123456789'
uppercase
lowercase
whitespace
			-- Strings containing the appropriate characters
index_error		-- Exception raised by index() if substr not found.
</PRE>
	<P><B>Some Functions:</B></P>
<PRE>
index(s, sub, i=0)	-- Return the lowest index in &lt;s&gt; not smaller
			   than &lt;i&gt; where the substring &lt;sub&gt; is found.
lower(s)		-- Return a string that is &lt;s&gt; in lowercase
splitfields(s, sep)	-- Returns a list containing the fields of the
			   string &lt;s&gt;, using the string &lt;sep&gt; as a separator.
joinfields(words, sep)	-- Concatenate a list or tuple of words with
			   intervening separators. 
strip(s)		-- Return a string that is &lt;s&gt; without leading
			   and trailing whitespace.
upper(s)		-- Return a string that is &lt;s&gt; in uppercase
</PRE>
<HR>
<P ALIGN=CENTER><EM>regex</EM></P>
Patterns are specified as strings. Default syntax is emacs-style.
<P><B>  Special Characters (using default syntax): </B></P>
<PRE>
.	matches any character
*	0 or more of preceeding regular expresssion
+	1 or more of preceeding regular expresssion
?	0 or 1 of preceeding regular expresssion
[ ]	defines character set: '[a-zA-Z]' to match all letters
[^ ]	defines complemented character set: matches if char is NOT in set
^	matches empty str at beginning of line
$	matches empty str at end of line
\	quoting char: \[ matches char '['
\\	matches '\'; due to Python string rules, write as '\\\\' in
	the pattern string.
\|	specifies alternative: 'foo\|bar' matches 'foo' or 'bar'
\( \)	grouping (for \|, or complicated expr, or substr for future
	reference by \D character or group() method)
\D	D is digit: matches substr matched by D'th \( \) in pattern
\`	empty str at beginning of file
\'	empty str at end of file
\b	empty str at beg or end of word: '\bis\b' matches 'is', but not 'his'
\B	empty str NOT at beginning or end of word
\&lt;	empty str at beginning of word
\&gt;	empty str at end of word
\w	any word constituent
\W	any non-word constituent
</PRE>
<P><B>	Variables: </B></P>
<PRE>
error			-- Exception when pattern string isn't valid regexp.
</PRE>
<P><B>	Functions:</B></P>
<PRE>
match(pattern, string)	-- Return how many characters at the beginning
			   of &lt;string&gt; match regexp &lt;pattern&gt;
			   or -1 if none.

search(pattern, string [, pos])	
			-- Return the first position in &lt;string&gt; that
			   matches regexp &lt;pattern&gt;.  Return -1 if none.
			   [starting at &lt;pos&gt;.]

compile(pattern [,translate])
			-- Create regexp object that has methods
			   match() and search() working as above. Also
			   group(i1, [,i2]*). Also regs,  tuple of 
			   positions matched; regs[0] is whole match, 
			   next are subexpressions. E.g.
			   p = compile('id\([a-z]\)\([a-z]\)')
			   p.match('idab') ==&gt; 4
			   p.group(1, 2) ==&gt; ('a', 'b')
			   p.regs ==&gt; ((0, 4), (2, 3), (3, 4), ...)

set_syntax(flag)	-- Set syntax flags for future calls to
			   match(), search() and compile(). Returns
			   current value. Flags in module regex_syntax.

symcomp(pattern [,translate])
			-- Like compile but with symbolic group
			   names. Names in angle brackets. Access 
			   through group method. E.g. 
			   p = symcomp('id\(&lt;l1&gt;[a-z]\)\(&lt;l2&gt;[a-z]\)')
			   p.match('idab') ==&gt; 4
			   p.group('l1') ==&gt; 'a'
</PRE>
<HR>
<P ALIGN=CENTER><EM>regex_syntax</EM></P>

Flags for regex.set_syntax(). BitOr the flags you want together and pass to
function.

<P><B>	Variables:</B></P>
<PRE>
RE_NO_BK_PARENS		-- if set, ( means grouping, \( is literal "("
			   if not, vice versa
RE_NO_BK_VBAR		-- if set, | means or, \| is literal "|"
			   if not, vice versa
RE_BK_PLUS_QM		-- if set, + or ? are operator, \+, \? are literal
			   if not, vice versa
RE_TIGHT_VBAR		-- if set, | binds tighter than ^ or $
			   if not, vice versa
RE_NEWLINE_OR		-- if set, \n is an OR operator
			   if not, it is a normal char
RE_CONTEXT_INDEP_OPS	-- if not set, special chars always have
				special meaning
			   if set, depends on context:
#       ^ - only special at the beginning, or after ( or |
#       $ - only special at the end, or before ) or |
#       *, +, ? - only special when not after the beginning, (, or |

RE_SYNTAX_AWK = (RE_NO_BK_PARENS | RE_NO_BK_VBAR | RE_CONTEXT_INDEP_OPS)
RE_SYNTAX_EGREP = (RE_SYNTAX_AWK | RE_NEWLINE_OR)
RE_SYNTAX_GREP = (RE_BK_PLUS_QM | RE_NEWLINE_OR)
RE_SYNTAX_EMACS = 0
</PRE>
<HR>
<P ALIGN=CENTER><EM>reg_sub</EM></P>
<P><B>	Functions:</B></P>
<PRE>
sub(pattern, rep, str)	-- Replace 1st occur of &lt;pattern&gt; in &lt;str&gt; by
			   &lt;rep&gt; and return this.
gsub(pattern, rep, str)	-- Replace _all_ occurances of &lt;pattern&gt; in &lt;str&gt; by
			   &lt;rep&gt; and return this.
split(str, pattern)	-- Split &lt;str&gt; into fields seperated by delimiters
			   matching &lt;pattern&gt; and return as list of
			   strings.
</PRE>
<HR>
<H2></H2>
<H2><A Name=OtherModules>Some Other Modules In Base Distribution</A></H2>
	 <H3>			 	 * Built-ins * </H3>
<PRE>
	    sys		Interpreter state vars and functions
	    __built-in__	Access to all built-in python identifiers
	    __main__		Scope of the interpreters main program, script or stdin
	    array		Obj efficiently representing arrays of basic values
	    math		Math functions of C standard
	    time 		Time-related functions
	    regex		Regular expression matching operations
	    marshal		Read and write some python values in binary format
	    struct		Convert between python values and C structs
</PRE>
<H3>* Standard *</H3>
<PRE>
	    getopt		Parse cmd line args in sys.argv.  A la UNIX 'getopt'.
	    os			A more portable interface to OS dependent functionality
	    rand		Pseudo-random generator, like C rand()
	    regsub		Functions useful for working with regular expressions
	    string		Useful string and characters functions and exceptions
	    whrandom		Wichmann-Hill pseudo-random number generator
</PRE>
<H3>* Unix *</H3>
<PRE>
	    dbm		Interface to Unix ndbm database library
	    grp		Interface to Unix group database
	    posix		OS functionality standardized by C and POSIX standards
	    posixpath		POSIX pathname functions
	    pwd		Access to the Unix password database
	    select		Access to Unix select multiplex file synchronization
	    socket		Access to BSD socket interface
	    thread		Low-level primitives for working with process threads
</PRE>
<H3>* Tk User-interface Toolkit *</H3>
<PRE>
	    tkinter		Main interface to Tk
</PRE>
</PRE>
<H3>* Multimedia *</H3>
<PRE>
	    audioop		Useful operations on sound fragments
	    imageop		Useful operations on images
	    jpeg		Access to jpeg image compressor and decompressor
	    rgbimg		Access SGI imglib image files
</PRE>
<H3>* Cryptographic Extensions *</H3>
<PRE>
	    md5		Interface to RSA's MD5 message digest algorithm
	    mpz		Interface to int part of GNU multiple precision library
	    rotor		Implementation of a rotor-based encryption algorithm
</PRE>
<H3>* Stdwin *	Standard Window System</H3>
<PRE>
	    stdwin		Standard Window System interface
	    stdwinevents	Stdwin event, command, and selection constants
	    rect		Rectangle manipulation operations
</PRE>
<H3>* SGI IRIX * (4 & 5)</H3>
<PRE>
	    al		SGI audio facilities
	    AL		al constants
	    fl		Interface to FORMS library
	    FL		fl constants
	    flp	Functions for form designer
	    fm		Access to font manager library
	    gl		Access to graphics library
	    GL		Constants for gl
	    DEVICE	More constants for gl
	    imgfile	Imglib image file interface
</PRE>
<H3>* Suns *</H3>
<PRE>
	    sunaudiodev	Access to sun audio interface
</PRE>
<H3>Partial Contents of Lib directory</H3>
<PRE>
BaseHTTPServer	--  Base class forhttp services.
CGIHTTPServer	--  CGI http services.
Complex		--  Complex numbers as instances of the class Complex.
Queue           --  A multi-producer, multi-consumer queue.
SimpleHTTPServer--  Simple extension to base http class
StringIO	--  File-like objects that read/write a string buffer.
SocketServer	--  Generic socket server classes.
UserDict        --  A wrapper to allow subclassing of built-in dict class.
UserList        --  A wrapper to allow subclassing of built-in list class.
addpack         --  Support for "packages", groups of related modules.
aifc            --  Stuff to parse AIFF-C and AIFF files.
anydbm		--  Generic interface to all dbm clones.
audiodev	--  Audio support for a few platforms.
base64		--  Conversions to/from base64 RFC-MIME transport encoding .
bdb             --  A generic Python debugger base class.
binhex		--  Macintosh binhex compression/decompression.
bisect          --  List bisection algorithms.
calendar        --  Calendar printing functions.
cgi		--  Wraps the WWW Forms Common Gateway Interface (CGI).
cmd             --  A generic class to build line-oriented command interpreters.
cmp             --  Efficiently compare files, boolean outcome only.
cmpcache        --  Same, but caches 'stat' results for speed.
codehack        --  Extract a function name from a code object.
colorsys        --  Conversion functions between RGB and other color systems.
commands        --  Tools for executing UNIX commands .
compileall	--  Force "compilation" of all .py files in a directory.
copy		--  Generic shallow and deep copying operations.
dircache        --  Sorted list of files in a dir, using a cache.
dircmp          --  Defines a class to build directory diff tools on.
dis             --  Bytecode disassembler.
dospath         --  Common operations on DOS pathnames.
dumbdbm		--  A dumb and slow but simple dbm clone.
dump            --  Print python code that reconstructs a variable.
emacs           --  Execute Emacs code from a Python interpreter.
find		--  Find files directory hierarcy matching a pattern.
fnmatch         --  Filename matching with shell patterns.
fpformat        --  General floating point formatting functions.
ftplib          --  An FTP client class.  Based on RFC 959.
getopt          --  Standard command line processing.
glob            --  filename globbing.
gopherlib       --  Gopher protocol client interface.
grep            --  'grep' utilities.
htmlentitydefs	--  Proposed entity definitions for HTML.
htmllib		--  HTML parsing utilities.
httplib         --  HTTP client class.
ihooks		--  Hooks into the "import" mechanism.
imghdr          --  Recognizing image files based on their first few bytes.
importall       --  Utility module to import all modules in the path.
linecache       --  Cache lines from files.
lockfile	--  Implements file locking.
maccache        --  Mac cache listdir(), isdir(), isfile() or exists().
macpath         --  Pathname (or related) operations for the Macintosh.
mailbox         --  A class to handle a unix-style or mmdf-style mailbox.
mhlib		--  MH (mailbox) interface.
mimetools       --  Various tools used by MIME-reading or MIME-writing programs.
multifile       --  Class to make multi-file messages easier to handle.
mutex           --  Mutual exclusion -- for use with module sched.
newdir          --  New dir() function.
ni		--  New import scheme with package support.
nntplib         --  An NNTP client class.  Based on RFC 977.
ntpath          --  Common operations on DOS pathnames.
os              --  Either mac, dos or posix depending system.
packmail        --  Create a self-unpacking shell archive.
pdb             --  A Python debugger.
persist         --  Implement limited persistence.
pickle		--  Pickling (save and restor) of Python objects.
pipes           --  Conversion pipeline templates.
poly            --  Polynomials.
posixfile	--  Extended (posix) file operations.
posixpath       --  Common operations on POSIX pathnames.
profile         --  Class for profiling python code.
pstats		--  Class for printing reports on profiled python code.
pty		--  Pseudo terminal utilities.
py_compile	--  Routine to "compile" a .py file to a .pyc file.
pyclbr		--  Parse a Python file and retrieve classes and methods.
quopri		--  Conversions to/from quoted-printable transport encoding.
rand            --  Don't use unless you want compatibility with C's rand().
random          --  Random variable generators.
regex_syntax    --  Flags for regex.set_syntax().
regexp          --  Backward compatibility for module "regexp" using "regex".
regsub          --  Regular expression subroutines.
repr            --  Redo repr() but with limits on most sizes.
rexec		--  Restricted execution facilities ("safe" exec, eval, etc).
rfc822          --  RFC-822 message manipulation class.
sched           --  A generally useful event scheduler class.
sgmllib		--  A parser for SGML.
shelve		--  Manage shelves of pickled objects.
shutil          --  Utility functions usable in a shell-like program.
sndhdr          --  Several routines that help recognizing sound.
stat            --  Constants and functions for interpreting stat/lstat struct.
statcache       --  Maintain a cache of file stats.
string          --  A collection of string operations.
sunau           --  Stuff to parse Sun and NeXT audio files.
sunaudio        --  Interpret sun audio headers.
symbol          --  Non-terminal symbols of Python grammar (from "graminit.h").
tb              --  Print tracebacks, with a dump of local variables.
tempfile        --  Temporary file name allocation.
toaiff          --  Convert "arbitrary" sound files to AIFF files .
token           --  Tokens (from "token.h").
tokenize        --  Compiles a regular expression that recognizes Python tokens.
traceback	--  Format and print Python stack traces.
tty		--  Terminal utilities.
types		--  Define names for all type symbols in the std interpreter.
tzparse         --  Parse a timezone specification.
urllib          --  Open an arbitrary URL.
urlparse	--  Parse URLs according to latest draft of standard.
uu		--  UUencode/UUdecode.
wave            --  Stuff to parse WAVE files.
whatsound       --  Several routines that help recognizing sound files.
whrandom        --  Wichmann-Hill random number generator.
zmod            --  Demonstration of abstruse mathematical concepts.
</PRE>
<HR>
<H2></H2>
<H2><A Name=Workspace>Workspace exploration and idiom hints</A></H2>
<PRE>
	dir(&lt;module&gt;)	list functions, variables in &lt;module&gt;
	dir()		get object keys, defaults to local name space
	X.__methods__	list of methods supported by X (if any)
	X.__members__	List of X's data attributes
	if __name__ == '__main__': main()	     invoke main if running as script
	map(None, lst1, lst2, ...)		     merge lists
	b = a[:]				     create copy of seq structure
	_			in interactive mode, is last value printed
<HR>
<H2></H2>
<H2><A Name=Emacs>Python Mode for Emacs</A></H2>
<PRE>
Type C-c ? when in python-mode for extensive help.

INDENTATION

Primarily for entering new code:
	TAB	 indent line appropriately
	LFD	 insert newline, then indent
	DEL	 reduce indentation, or delete single character

Primarily for reindenting existing code:
	C-c :	 guess py-indent-offset from file content; change locally
	C-u C-c :	 ditto, but change globally

	C-c TAB	 reindent region to match its context
	C-c &lt;	 shift region left by py-indent-offset
	C-c &gt;	 shift region right by py-indent-offset

MARKING & MANIPULATING REGIONS OF CODE

C-c C-b	 	mark block of lines
M-C-h	 	mark smallest enclosing def
C-u M-C-h	mark smallest enclosing class
C-c #	 	comment out region of code
C-u C-c #	uncomment region of code

MOVING POINT

C-c C-p	 	move to statement preceding point
C-c C-n	 	move to statement following point
C-c C-u	 	move up to start of current block
M-C-a	 	move to start of def
C-u M-C-a 	move to start of class
M-C-e	 	move to end of def
C-u M-C-e 	move to end of class

EXECUTING PYTHON CODE

C-c C-c	sends the entire buffer to the Python interpreter
C-c |	sends the current region
C-c !	starts a Python interpreter window; this will be used by
	subsequent C-c C-c or C-c | commands

VARIABLES

py-indent-offset	indentation increment
py-block-comment-prefix	comment string used by py-comment-region

py-python-command	shell command to invoke Python interpreter
py-scroll-process-buffer	t means always scroll Python process buffer
py-temp-directory	directory used for temp files (if needed)

py-beep-if-tab-change	ring the bell if tab-width is changed
</PRE>
<HR>
<H2></H2>
<H2><A Name=Debugger>The Python Debugger</A></H2>
<H3>Accessing</H3>
<PRE>
import pdb	(it's a module written in Python)

	-- defines functions
	   run(string)	-- interpret string in the debugger
	   runctx(string, globals, locals)
			-- interpret string using globals and locals
			   for namespace
	   runcall(fun, arg1, arg2, ...)
			-- run function object &lt;fun&gt; with args
	   pm()		-- run postmortem on last exception
			   (like debugging a core file)
	   post_mortem(t)
			-- run postmortem on traceback object &lt;t&gt;
	-- defines class "Pdb"
	   use Pdb to create reusable debugger objects. Object
	   preserves state (i.e. break points) between calls.

	   Pdb defines methods
	   run(string)	-- interpret string in the debugger
	   runctx(string, globals, locals)
			-- interpret string using globals and locals
			   for namespace
	   runcall(fun, arg1, arg2, ...)
			-- run function object with args

	      runs until a breakpoint hit, exception, or end of program
	If exception, variable '__exception__' holds (exception,value).
</PRE>
<H3>Commands</H3>
<PRE>
h, help
	brief reminder of commands
b, break [&lt;arg&gt;]
	if &lt;arg&gt; numeric, break at line &lt;arg&gt; in current file
	if &lt;arg&gt; is function object, break on entry to fcn &lt;arg&gt;
	if no arg, list breakpoints
cl, clear [&lt;arg&gt;]
	if &lt;arg&gt; numeric, clear breakpoint at &lt;arg&gt; in current file
	if no arg, clear all breakpoints after confirmation
w, where
	print current call stack
u, up
	move up one stack frame (to top-level caller)
d, down
	move down one stack frame 
s, step
	advance one line in the program, stepping into calls
n, next
	advance one line, stepping over calls
r, return
	continue execution until current function returns
	(return value is saved in variable "__return__", which
	can be printed or manipulated from debugger)
c, continue
	continue until next breakpoint
a, args
	print args to current function
rv, retval
	prints return value from last function that returned
p, print &lt;arg&gt;
	prints value of &lt;arg&gt; in current stack frame
l, list [&lt;first&gt; [, &lt;last&gt;]]
	       List source code for the current file.
	       Without arguments, list 11 lines around the current line
	       or continue the previous listing.
	       With one argument, list 11 lines starting at that line.
	       With two arguments, list the given range;
	       if the second argument is less than the first, it is a count.
whatis &lt;arg&gt;
	prints type of &lt;arg&gt;
! 
	executes rest of line as a Python statement in the current stack frame
q quit
	immediately stop execution and leave debugger
&lt;return&gt;
	executes last command again

Any input debugger doesn't recognize as a command is assumed to be a
Python statement to execute in the current stack frame, the same way
the exclamation mark ("!") command does.
</PRE>
<H3>Example</H3>
<PRE>
(1394) python
Python 1.0.3 (Sep 26 1994)
Copyright 1991-1994 Stichting Mathematisch Centrum, Amsterdam
&gt;&gt;&gt; import rm
&gt;&gt;&gt; rm.run()
Traceback (innermost last):
	 File "&lt;stdin&gt;", line 1
	 File "./rm.py", line 7
	   x = div(3)
	 File "./rm.py", line 2
	   return a / r
ZeroDivisionError: integer division or modulo
&gt;&gt;&gt; import pdb
&gt;&gt;&gt; pdb.pm()
&gt; ./rm.py(2)div: return a / r
(Pdb) list
	 1     def div(a):
	 2  -&gt;     return a / r
	 3  
	 4     def run():
	 5         global r
	 6         r = 0
	 7         x = div(3)
	 8         print x
[EOF]
(Pdb) print r
0
(Pdb) q
&gt;&gt;&gt; pdb.runcall(rm.run)
etc.
</PRE>
<H3>Quirks</H3>

<P>Breakpoints are stored as filename, line number tuples. If a module is
reloaded after editing, any remembered breakpoints are likely to be
wrong.</P>

<P>Always single-steps through top-most stack frame. That is, "c" acts
like "n".</P>

</body>
<br>
<br><br><br><br><br>
<script>
  $(function() {
    var toc = $('#toc>ul');

    function makeLi(text, href) {
      return $('<a href="' + href + '" target="_self">' + text + '</a><br>');
    }

    $('h2, h3, h4').each(function(i) {
      var chapter = $(this), chapterNumber = i + 1;
      toc.append(
        makeLi(chapter.text(), '#chapter-' + chapterNumber)
      );
      chapter.attr('id', 'chapter-' + chapterNumber);
    });

  });
</script>
</body>
</html>
