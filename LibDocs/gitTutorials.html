<base target="_blank"><html><head><title>GitTutorial</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src="https://williamkpchan.github.io/lazyload.min.js"></script>
<script type='text/javascript' src='https://williamkpchan.github.io/mainscript.js'></script>
<script src="https://williamkpchan.github.io/commonfunctions.js"></script>
<script src="https://d3js.org/d3.v4.min.js"></script>

<script>
var showTopicNumber = false;
var topicEnd = "";
var bookid = "GitTutorial"
var markerName = "h2"
</script>
<style>
body{width:80%;margin-left: 10%; font-size:22px;}
h1, h2 {color: gold;}
strong {color: orange;}
pre{width:100%;}
#toc{color:cyan; font-size:20px;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px; background-color:#044;}
</style></head><body onkeypress="chkKey()"><center>
<h1>GitTutorial</h1>
<a href="#mustWatch" class="red goldbs" target="_self">Must Watch!</a>
<br><br>
<div id="toc"></div></center>
<br><br>
<div id="mustWatch"><center><span class="red">MustWatch</span></center><br>
</div>
<pre>
<br>
<br>

<h2><span class="orange">What is an SSH KEY?</span></h2>
An SSH key is an access credential for the SSH (secure shell) network protocol. 
This authenticated and encrypted secure network protocol is used for remote communication between machines on an <a href="https://whatismyipaddress.com/unsecured-network" data-event="clicked" data-uuid="56ae9a7a-b8" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">unsecured open network</a>. 
SSH is used for remote file transfer, network management, and remote operating system access. 

The SSH acronym is also used to describe a set of tools used to interact with the SSH protocol.
SSH uses a pair of keys to initiate a secure handshake between remote parties. 
The key pair contains a public and private key. 
The private vs public nomenclature can be confusing as they are both called keys. 

It is more helpful to think of the public key as a "lock" and the private key as the "key". 
You give the public 'lock' to remote parties to encrypt or 'lock' data. 
This data is then opened with the 'private' key which you hold in a secure place.
<h2><span class="saddlebrown">&emsp;How to Create an SSH Key</span></h2>
SSH keys are generated through a <a href="https://en.wikipedia.org/wiki/Public-key_cryptography" data-event="clicked" data-uuid="a0e08bd3-5d" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">public key cryptographic algorithm</a>, the most common being <a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)" data-event="clicked" data-uuid="a0e08bd3-5d" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">RSA</a> or <a href="https://en.wikipedia.org/wiki/Digital_Signature_Algorithm" data-event="clicked" data-uuid="a0e08bd3-5d" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">DSA</a>. 
At a very high level SSH keys are generated through a mathematical formula that takes 2 prime numbers and a random seed variable to output the public and private key. 
This is a one-way formula that ensures the public key can be derived from the private key but the private key cannot be derived from the public key.
SSH keys are created using a key generation tool. 

The SSH command line tool suite includes a keygen tool. 
Most git hosting providers offer guides on <a href="https://confluence.atlassian.com/bitbucketserver/creating-ssh-keys-776639788.html" data-event="clicked" data-uuid="a0e08bd3-5d" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">how to create an SSH Key.</a>
<h2><span class="saddlebrown">&emsp;Generate an SSH Key on Mac and Linux</span></h2>
Both OsX and Linux operating systems have comprehensive modern terminal applications that ship with the SSH suite installed. 

The process for creating an SSH key is the same between them.
1. execute the following to begin the key creation
<code>ssh-keygen -t rsa -b 4096 -C "your_email@example.com"</code>
This command will create a new SSH key using the email as a label

2. You will then be prompted to "Enter a file in which to save the key."
You can specify a file location or press “Enter” to accept the default file location.
<code>> Enter a file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter]</code>
3. The next prompt will ask for a secure passphrase.

A passphrase will add an additional layer of security to the SSH and will be required anytime the SSH key is used. 
If someone gains access to the computer that private keys are stored on, they could also gain access to any system that uses that key. 
Adding a passphrase to keys will prevent this scenario.
<code>> Enter passphrase (empty for no passphrase): [Type a passphrase]

> Enter same passphrase again: [Type passphrase again]</code>`
At this point, a new SSH key will have been generated at the previously specified file path.
4. Add the new SSH key to the ssh-agent
The ssh-agent is another program that is part of the SSH toolsuite. 

The ssh-agent is responsible for holding private keys. 
Think of it like a keychain. 
In addition to holding private keys it also brokers requests to sign SSH requests with the private keys so that private keys are never passed around unsecurly.
Before adding the new SSH key to the ssh-agent first ensure the ssh-agent is running by executing:

<code>$ eval "$(ssh-agent -s)"
> Agent pid 59566</code>
Once the ssh-agent is running the following command will add the new SSH key to the local SSH agent.
<code>ssh-add -K /Users/you/.ssh/id_rsa</code>

The new SSH key is now registered and ready to use!
<h2><span class="saddlebrown">&emsp;Generate an SSH Key on Windows</span></h2>
Windows environments do not have a standard default unix shell. 
External shell programs will need to be installed for to have a complete keygen experience. 

The most straight forward option is to utilize <a href="/git/tutorials/git-bash" data-event="clicked" data-uuid="52fa3ad3-10" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Git Bash</a>. 
Once Git Bash is installed the same steps for Linux and Mac can be followed within the Git Bash shell.
<h2><span class="saddlebrown">&emsp;Windows Linux Subsystem</span></h2>
Modern windows environments offer a windows linux subsystem. 

The windows linux subsystem offers a full linux shell within a traditional windows environment. 
If a linux subsystem is available the same steps previously discussed for Linux and Mac can be followed with in the windows linux subsystem.
<h2><span class="saddlebrown">&emsp;Summary</span></h2>
SSH keys are used to authenticate secure connections. 

Following this guide, you will be able to create and start using an SSH key. 
Git is capable of using SSH keys instead of traditional  password authentication when pushing or pulling to remote repositories. 
Modern hosted git solutions like <a href="https://confluence.atlassian.com/bitbucket/set-up-an-ssh-key-728138079.html" data-event="clicked" data-uuid="c9bcb723-1c" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Bitbucket support SSH key authentication.</a>
<h2><br><span class="orange">Git Archive: How to export a git project</span></h2>
Sometimes it can be useful to create an archive file of a Git repository. 
An archive file combines multiple files into a single file. 
An archive file can then be extracted to reproduce the individual files. 

Git is incredibly powerful at preserving history and team collaboration; however, archive files remove the overhead of Git's metadata and can be simpler to distribute to other users or preserve in long term cold storage.
<h2><span class="saddlebrown">&emsp;What does git archive do?</span></h2>
The <code>git archive</code> command is a Git command line utility that will create an archive file from specified Git Refs like, commits, branches, or trees. 
<code>git archive</code> accepts additional arguments that will alter the archive output.
<h2><span class="saddlebrown">&emsp;Git export examples</span></h2>
A most basic <code>~git archive~</code> example follows
<code>git archive --format=tar HEAD</code>
This command when executed will create an archive from the current <code>HEAD</code> ref of the repository. 

By default, <code>git archive</code> will stream the archive output to the ephemeral stdout stream. 
You will need to capture this output stream to a permanent file. 
You can specify a permanent file by using <code>git archives</code> output option or using the operating systems stdout redirection.
<code>git archive --output=./example_repo_archive.tar --format=tar HEAD</code>

The proceeding example will create a new archive and store it in the <code>exmaple_repo_archive.tar</code> file. 
The previous examples have both created uncompressed archive output. 
This is denoted by the <code>--format=tar</code> option. 
The format option also accepts popular compressed file formats <code>zip</code> and <code>tar.gz</code>. 

Passing one of these format options will produce a compressed archive. 
If a format value is not passed it will be inferred from any <code>--output</code> option passed.
<code>git archive --output=./example_repo_archive.tar.gz --format=tar HEAD ./build</code>
A partial archives of the repository can be created by passing a path argument. 

This example adds a <code>./build</code> path argument to the archive command. 
This command will output an archive containing only files stored under the <code>./build</code> directory
<h2><span class="saddlebrown">&emsp;Options</span></h2>
The previous examples demonstrated some of the most frequently used <code>git-archive</code> use cases. 

The following are extended options that can be passed to <code>git-archive</code>.
<code>--prefix=&lt;prefix>/</code>
The prefix options prepends a path to each file in an archive. 
This can be helpful to ensure the archive contents get extracted in a unique namespace.

<code>--remote=&lt;repo></code>
The remote option expects a remote repository URL. 
When invoked with the remote option, <code>git-archive</code> will fetch the remote repository and create an archive from the specified ref if it’s available on the remote.
<h2><span class="saddlebrown">&emsp;Configuration</span></h2>
There are a few global Git configuration values that ~git archive~ will respect. 
These values can be set using the [git config][link to git config] utility.
<code>tar.umask</code>
The unmask configuration option is used to specify unix level permission bit restriction on the output archive file.

<code>tar.&lt;format>.command</code>
This configuration option allows specification of a custom shell command that the <code>git-archive</code> output will be run through. 
This is similar to omitting the <code>--output</code> option and piping the stdout stream from ~git archive~ to a custom tool. 
This enables fixed custom archive post-processing.

<code>tar.&lt;format>.remote</code>
If enabled this allows remote clients to fetch archives of type <code>format</code>.
<h3>&emsp;Git Archive Summary</h3>
Git archive is a helpful utility for creating distributable packages of git repositories. 

Git archive can target specific refs of a repository and only package the contents of that ref. 
Git archive has several output formats that can utilize added compression.
<h2><br><span class="orange">Is GitOps the next big thing in DevOps?</span></h2>
Many organizations now see DevOps as part of their digital transformation strategy, since it encourages a culture of shared responsibility, transparency, and faster feedback. 

Yet as the gap between development and operations teams shrinks, so do the processes. 
So it goes with Git, the most widely used version control system in the world today. 
As companies embrace DevOps methodologies, so to the tools, which has created an evolution to GitOps, a set of practices that allow developers to perform more IT operations-related tasks.
<h2><span class="saddlebrown">&emsp;What is GitOps?</span></h2>
At its core, GitOps is code-based infrastructure and operational procedures that rely on Git as a source control system. 
It’s an evolution of <a href="https://www.atlassian.com/continuous-delivery/principles/infrastructure-as-code" data-event="clicked" data-uuid="33f4fa37-f1" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Infrastructure as Code (IaC)</a> and a <a href="https://www.atlassian.com/devops/what-is-devops/devops-best-practices" data-event="clicked" data-uuid="33f4fa37-f1" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">DevOps best practice</a> that leverages Git as the single source of truth, and control mechanism for creating, updating, and deleting system architecture. 
More simply, it is the practice of using Git pull requests to verify and automatically deploy system infrastructure modifications.
In addition to Git as a key DevOps mechanism, GitOps is also used to describe tools that augment Gits default functionality. 

These tools were primarily used with operating models for Kubernetes-based infrastructure and applications. 
There is ongoing development and discussion within the DevOps community to bring GitOps tools to other non-Kubernetes platforms, such as Terraform.
GitOps ensures that a system’s cloud infrastructure is immediately reproducible based on the state of a Git repository. 
Pull requests modify the state of the Git repository. 

Once approved and merged, the pull requests will automatically reconfigure and sync the live infrastructure to the state of the repository. 
This live syncing pull request workflow is the core essence of GitOps.
<h2><span class="saddlebrown">&emsp;The history of GitOps</span></h2>
Git is a mission critical tool for software development that enables pull request and code review workflows. 

<a href="/git/tutorials/making-a-pull-request" data-event="clicked" data-uuid="a3fbf575-de" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Pull requests</a> promote visibility into incoming changes to a codebase and encourages communication, discussion, and review of changes. 
Pull requests are a pivotal feature in collaborative software development and changed the way teams and businesses build software. 
Pull requests bring transparency and measurability to a formerly opaque process. 
Git pull requests helped enable the evolution of DevOps processes into software development. 

System administrators, who typically were hesitant to change, are now embracing new software development practices such as agile and DevOps. 
Systems administration as a craft has a sloppy history. 
System administrators previously would manage hardware manually by either connecting to and provisioning machines in a physical server rack or over a cloud provisioning API. 
In addition to the manual provisioning process, large amounts of manual configuration work was a regular routine. 

Administrators would keep custom collections of imperative scripts and configurations, cobble them together, and place them in various places. 
These scripts could break at any time or get lost. 
Collaboration was challenging as the custom tool chains were not regularly documented or shared.
The DevOps movement arose from this primordial swamp of systems administration. 

<a href="/devops" data-event="clicked" data-uuid="a3fbf575-de" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">DevOps</a> borrowed the best ideas from software engineering and applied them to systems administration, where the cobbled-together tools became version-controlled code. 
IaC is one of the biggest revelations of DevOps. 
Previously system administrators favored custom imperative scripts to configure systems. 
Imperative software follows a sequence of steps to achieve a desired state, such as:

Imperative software is often error prone and easy to break by changing the sequence of events. 
Modern software development has trended away from imperative patterns and towards declarative software patterns.
Declarative software follows a declaration of an expected state instead of a sequence of commands. 
Here’s a comparison of imperative vs declarative devops statements. 

While the imperative statements might read: 
<strong>Install an operating system on this machine</strong>
<strong>Install these dependencies</strong>
<strong>Download code from this URL</strong>
<strong>Move the code to this directory</strong>
<strong>Do this 3 times for 3 other machines</strong>
The declarative version of this would simply read: <strong>4 machines have software from this URL, installed at this directory.</strong>
IaC encourages and promotes declarative system administration tools over custom imperative solutions. 

This led to the emergence of technologies like Docker <a href="/continuous-delivery/microservices/containers" data-event="clicked" data-uuid="28d556d8-0c" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Containers</a>, Ansible, Terraform, and <a href="/continuous-delivery/microservices/kubernetes" data-event="clicked" data-uuid="28d556d8-0c" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Kubernetes</a>, which utilize static declarative configuration files. 
Human readability and consistent reproducible state are the beneficial outcomes. 
These configuration files were naturally added to Git for tracking and review. 
This is close but not quite GitOps.

Many of the traditional system administration problems have been solved at this point in <a href="https://www.atlassian.com/devops/what-is-devops/history-of-devops" data-event="clicked" data-uuid="28d556d8-0c" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">DevOps history</a>. 
Configuration files and tools are now stored in a central location, documented and accessible by many team members. 
Commits and pull requests were used to track modifications to the configuration and foster collaboration discussion and review. 
The only remaining problem with this stage is that the configuration still feels disconnected from the live system. 

Once a configuration pull request is approved and merged to the repo, the live system is manually updated to match the state of the static repo. 
This is the exact problem GitOps solves.
The GitOps idea was first hatched and shared by WeaveWorks, an enterprise Kubernetes management firm and has since proliferated throughout the DevOps community. 
GitOps is an extension of IaC and declarative configuration discussed above. 

GitOps adds some magic to the pull request workflow that syncs the state of the live system to that of the static configuration repository.
<h2><span class="saddlebrown">&emsp;The benefits of GitOps</span></h2>
GitOps shares many of the same benefits as an agile <a href="/git/tutorials/comparing-workflows/feature-branch-workflow" data-event="clicked" data-uuid="b0bcbd2e-83" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">feature branch</a> software development workflow. 
The first major benefit is ease of adoption due to the usage of common tools. 

Git is the de facto standard of version control systems and is a common software development tool for most developers and software teams. 
This makes it easy for developers familiar with Git to become cross functional contributors and participate in GitOps. 
Using a version control system lets a team track all modifications to the configuration of a system. 
This gives a “source of truth” and valuable audit trail to review if something breaks or behaves unexpectedly. 

Teams can review the GitOps history and see when a regression was introduced. 
Additionally this audit trail can be used as a reference for compliance or security auditing. 
The GitOps history can be used as proof when things like encryption certificates are modified or updated.
GitOps brings transparency and clarity to an organization's infrastructure needs around a central repo. 

Containing all systems configurations in a central repository helps scale contribution input from team members. 
Pull requests made through hosted Git services like Bitbucket have rich tools for code review and discussion commentary. 
This builds passive communication loops that allows the full engineering team to observe and monitor infrastructure changes.
GitOps can greatly increase productivity for a DevOps team. 

It allows them to quickly experiment with new infrastructure configurations. 
If the new changes don’t behave as expected, a team can use Git history to revert changes to a known good state. 
This is incredibly powerful since it enables the familiar “undo” functionality in a complicated infrastructure. 
<h2><span class="saddlebrown">&emsp;How GitOps works</span></h2>
GitOps procedures are performed by an underlying orchestration system. 
GitOps itself is an agnostic best practice pattern. 
Many popular GitOps solutions today primarily use Kubernetes as the orchestration system. 
Some alternative GitOps tool sets are coming to market that support direct Terraform manipulation. 

To achieve a full GitOps install, a pipeline platform is required. 
Jenkins, <a href="https://bitbucket.org/product/features/pipelines" data-event="clicked" data-uuid="e769d0bf-dd" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Bitbucket Pipelines</a>, or CircleCi are some popular pipeline tools that are complementary to GitOps. 
Pipelines automate and bridge the gap between Git pull requests and the orchestration system. 
Once pipeline hooks are established and triggered from pull requests, commands are executed to the orchestration piece. 

A new pattern or component that is specifically introduced with GitOps is the GitOps “operator,” which is a mechanism that sits between the pipeline and the orchestration system. 
A pull request starts the pipeline that then triggers the operator. 
The operator examines the state of the repository and the start of the orchestration and syncs them. 
The operator is the magic component of GitOps.
<h2><span class="saddlebrown">&emsp;GitOps examples</span></h2>
Imagine a team identified a performance bottleneck or a spike in traffic and the team notices the load balancer is not working as expected. 
They look into the GitOps repo that holds the infrastructure configuration and find a specific file that configures and deploys the load balancer. 
They can review it on their online Git hosting site. 

After some review and discussion they identify that some of the configuration values for the load balancer are not optimal and need to be adjusted. 
A member of the team opens up a new pull request that optimizes the load balancer values. 
The pull request is reviewed and approved by a second team member and merged into the repository. 
The merge kicks off a GitOps pipeline, which triggers the GitOps operator. 

The operator sees the load balancer configuration was changed. 
It confirms with the systems orchestration tool that this does not match what is live on the teams cluster.
The operator signals the orchestration system to update the load balancer configuration. 
The orchestrator handles the rest and automatically deploys the newly configured load balancer. 

The team then monitors the newly updated live system to see it return to a healthy state. 
This is an ideal GitOps scenario. 
Let’s expand on it further to demonstrate GitOps utility.
Let’s imagine that instead of slightly tweaking the load balancer values to be more optimal, the team makes an aggressive decision to deploy an entirely new load balancer type. 

They feel the current load balancer is fundamentally flawed and want to try an alternative option. 
The workflow is the same as the value tweak. 
The team creates a pull request that introduces an entirely new load balancer configuration and deletes the old configuration. 
It is approved and deployed through the pipeline.

Unfortunately the team finds that this new type of load balancer is incompatible with some other services within their cluster. 
The new load balancer causes critical traffic failures and halts user operations. 
Luckily because the team has a complete GitOps pipeline they can quickly undo these load balancer changes. 
The team will make another pull request that reverts the repository back to the old known functional load balancer. 

This again will be noted by the GitOps pipeline and automatically deployed. 
It will rapidly improve the infrastructure and improves the reliability score of the team.
<h2><span class="saddlebrown">&emsp;Summary</span></h2>
GitOps is an incredibly powerful workflow pattern for managing modern cloud infrastructure. 

Though primarily focused on Kubernetes cluster management, the DevOps community is applying and publishing GitOps solutions to other non-Kubernetes systems. 
GitOps can bring many benefits to an engineering team including improved communication, visibility, stability, and system reliability. 
One of the core requirements for a GitOps experience is a modern hosted Git platform like Bitbucket.
<h2><br><span class="orange">Git cheat sheet</span></h2>
Use this handy git cheat sheet guide to enhance your workflow. 
This Git cheat sheet saves you time when you just can't remember what a command is or don't want to use git help in the command line. 
It is hard to memorize all the important Git commands by heart, so print this out or save it to your desktop to resort to when you get stuck. 
We’ve included the basic Git commands to help you learn Git, and more advanced concepts around Git branches, remote repositories, undoing changes, and more.

<a href="https://wac-cdn.atlassian.com/dam/jcr:e7e22f25-bba2-4ef1-a197-53f46b6df4a5/SWTM-2088_Atlassian-Git-Cheatsheet.pdf?cdnVersion=217" class="button green-hollow secondary">Download now</a>
<a href="https://wac-cdn.atlassian.com/dam/jcr:e7e22f25-bba2-4ef1-a197-53f46b6df4a5/SWTM-2088_Atlassian-Git-Cheatsheet.pdf?cdnVersion=217" class="cms-link cms-link--image margin-t50"><img src="https://wac-cdn.atlassian.com/dam/jcr:d60ca565-89db-4f07-98a0-dd35fae97293/git1.jpg?cdnVersion=217" loading="lazy" alt="git cheat sheet"></a>
<a href="https://wac-cdn.atlassian.com/dam/jcr:e7e22f25-bba2-4ef1-a197-53f46b6df4a5/SWTM-2088_Atlassian-Git-Cheatsheet.pdf?cdnVersion=217" class="button green-hollow secondary">Download now</a>
<h2><br><span class="orange">Setting up a repository</span></h2>
This tutorial provides an overview of how to set up a repository (repo) under Git version control. 
This resource will walk you through initializing a Git repository for a new or existing project. 
Included below are workflow examples of repositories both created locally and cloned from remote repositories. 
This guide assumes a basic familiarity with a command-line interface.

The high level points this guide will cover are:
Initializing a new Git repo
Cloning an existing Git repo
Committing a modified version of a file to the repo
Configuring a Git repo for remote collaboration
Common Git version control commands
By the end of this module, you should be able to create a Git repo, use common Git commands, commit a modified file, view your project’s history and configure a connection to a Git hosting service (Bitbucket).
<h2><span class="saddlebrown">&emsp;What is a Git repository?</span></h2>
A <a href="https://bitbucket.org/product/code-repository" data-event="clicked" data-uuid="92a86705-d9" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Git repository</a> is a virtual storage of your project. 
It allows you to save versions of your code, which you can access when needed. 
<h2><span class="saddlebrown">&emsp;Initializing a new repository: git init</span></h2>
To create a new repo, you'll use the <code>git init</code> command. 
<code>git init</code> is a one-time command you use during the initial setup of a new repo. 
Executing this command will create a new <code>.git</code> subdirectory in your current working directory. 

This will also create a new main branch. 
<h3>&emsp;Versioning an existing project with a new git repository</h3>
This example assumes you already have an existing project folder that you would like to create a repo within. 
You'll first <code>cd</code> to the root project folder and then execute the <code>git init</code> command.

<code>cd /path/to/your/existing/code 
git init</code>
Pointing <code>git init</code> to an existing project directory will execute the same initialization setup as mentioned above, but scoped to that project directory.
<code>git init &lt;project directory></code>

Visit the <a href="/git/tutorials/setting-up-a-repository/git-init" data-event="clicked" data-uuid="655db3bf-0e" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git init</a> page for a more detailed resource on <code>git init</code>.
<h2><span class="saddlebrown">&emsp;Cloning an existing repository: git clone</span></h2>
If a project has already been set up in a central repository, the clone command is the most common way for users to obtain a local development clone. 
Like <code>git init</code>, cloning is generally a one-time operation. 

Once a developer has obtained a working copy, all <a href="https://bitbucket.org/product/version-control-software" data-event="clicked" data-uuid="1a25b7c1-cd" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">version control</a> operations are managed through their local repository.
<code>git clone &lt;repo url></code>
<code>git clone</code> is used to create a copy or clone of remote repositories. 
You pass <code>git clone</code> a repository URL. 

Git supports a few different network protocols and corresponding URL formats. 
In this example, we'll be using the Git SSH protocol. 
Git SSH URLs follow a template of: <code>git@HOSTNAME:USERNAME/REPONAME.git</code>
An example Git SSH URL would be: <code>git@bitbucket.org:rhyolight/javascript-data-store.git</code> where the template values match:

<code><code>HOSTNAME: bitbucket.org</code></code>
<code><code>USERNAME: rhyolight</code></code>
<code><code>REPONAME: javascript-data-store</code></code>
When executed, the latest version of the remote repo files on the main branch will be pulled down and added to a new folder. 

The new folder will be named after the REPONAME in this case <code>javascript-data-store</code>. 
The folder will contain the full history of the remote repository and a newly created main branch.
For more documentation on <code>git clone</code> usage and supported Git URL formats, visit the <a href="/git/tutorials/setting-up-a-repository/git-clone" data-event="clicked" data-uuid="814bb7cd-ea" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git clone Page</a>.
<h2><span class="saddlebrown">&emsp;Saving changes to the repository: git add and git commit</span></h2>
Now that you have a repository cloned or initialized, you can commit file version changes to it. 
The following example assumes you have set up a project at <code>/path/to/project</code>. 
The steps being taken in this example are:
Change directories to <code>/path/to/project</code>

Create a new file <code>CommitTest.txt</code> with contents ~"test content for git tutorial"~
git add <code>CommitTest.txt</code> to the repository staging area
Create a new commit with a message describing what work was done in the commit
<code>cd /path/to/project 

echo "test content for git tutorial" >> CommitTest.txt 
git add CommitTest.txt 
git commit -m "added CommitTest.txt to the repo"</code>
After executing this example, your repo will now have <code>CommitTest.txt</code> added to the history and will track future updates to the file.

This example introduced two additional git commands: <code>add</code> and <code>commit</code>. 
This was a very limited example, but both commands are covered more in depth on the <a href="/git/tutorials/saving-changes" data-event="clicked" data-uuid="2f0de370-12" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git add</a> and <a href="/git/tutorials/saving-changes/git-commit" data-event="clicked" data-uuid="2f0de370-12" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git commit</a> pages. 
Another common use case for <code>git add</code> is the <code>--all</code> option. 
Executing <code>git add --all</code> will take any changed and untracked files in the repo and add them to the repo and update the repo's working tree.
<h2><span class="saddlebrown">&emsp;Repo-to-repo collaboration: git push</span></h2>
It’s important to understand that Git’s idea of a “working copy” is very different from the working copy you get by checking out source code from an SVN repository. 
Unlike SVN, Git makes no distinction between the working copies and the central repository—they're all full-fledged <a href="https://bitbucket.org/product/code-repository" data-event="clicked" data-uuid="55179607-83" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Git repositories</a>.
This makes collaborating with Git fundamentally different than with SVN. 

Whereas SVN depends on the relationship between the central repository and the working copy, Git’s collaboration model is based on repository-to-repository interaction. 
Instead of checking a working copy into SVN’s central repository, you push or pull commits from one repository to another.
Of course, there’s nothing stopping you from giving certain Git repos special meaning. 
For example, by simply designating one Git repo as the “central” repository, it’s possible to replicate a centralized workflow using Git. 

This is accomplished through conventions rather than being hardwired into the VCS itself.
<h3>&emsp;Bare vs. cloned repositories</h3>
If you used <code>git clone</code> in the previous "Initializing a new Repository" section to set up your local repository, your repository is already configured for remote collaboration. 
<code>git clone</code> will automatically configure your repo with a remote pointed to the Git URL you cloned it from. 

This means that once you make changes to a file and commit them, you can <code>git push</code> those changes to the remote repository.
If you used <code>git init</code> to make a fresh repo, you'll have no remote repo to push changes to. 
A common pattern when initializing a new repo is to go to a hosted Git service like Bitbucket and create a repo there. 
The service will provide a Git URL that you can then add to your local Git repository and <code>git push</code> to the hosted repo. 

Once you have created a remote repo with your service of choice you will need to update your local repo with a mapping. 
We discuss this process in the Configuration &amp; Set Up guide below.
If you prefer to host your own remote repo, you'll need to set up a "Bare Repository." Both <code>git init</code> and <code>git clone</code> accept a <code>--bare</code> argument. 
The most common use case for bare repo is to create a remote central Git repository
<h2><span class="saddlebrown">&emsp;Configuration &amp; set up: git config</span></h2>
Once you have a remote repo setup, you will need to add a remote repo url to your local <code>git config</code>, and set an upstream branch for your local branches. 
The <code>git remote</code> command offers such utility.
<code>git remote add &lt;remote_name> &lt;remote_repo_url></code>

This command will map remote repository at <code><remote_repo_url></remote_repo_url></code> to a ref in your local repo under <code><remote_name></remote_name></code>. 
Once you have mapped the remote repo you can push local branches to it.
<code>git push -u &lt;remote_name> &lt;local_branch_name></code>
This command will push the local repo branch under <code>&lt; local_branch_name ></code> to the remote repo at <code>&lt; remote_name ></code>.

For more in-depth look at <code>git remote</code>, see the <a href="https://www.atlassian.com/git/tutorials/syncing#git-remote" data-event="clicked" data-uuid="5969ceca-27" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket"><code>Git remote page</code></a>.
In addition to configuring a remote repo URL, you may also need to set global Git configuration options such as username, or email. 
The <code>git config</code> command lets you configure your Git installation (or an individual repository) from the command line. 
This command can define everything from user info, to preferences, to the behavior of a repository. 

Several common configuration options are listed below.
Git stores configuration options in three separate files, which lets you scope options to individual repositories (local), user (Global), or the entire system (system):
Local: <code><repo>/.git/config</repo></code> – Repository-specific settings.
Global: <code>/.gitconfig</code> – User-specific settings. 

This is where options set with the --global flag are stored.
System: <code>$(prefix)/etc/gitconfig</code> – System-wide settings.
Define the author name to be used for all commits in the current repository. 
Typically, you’ll want to use the <code>--global</code> flag to set configuration options for the current user.

<code>git config --global user.name &lt;name></code>
Define the author name to be used for all commits by the current user.
Adding the <code>--local</code> option or not passing a config level option at all, will set the <code>user.name</code> for the current local repository.
<code>git config --local user.email &lt;email></code>

Define the author email to be used for all commits by the current user.
<code>git config --global alias.&lt;alias-name> &lt;git-command></code>
Create a shortcut for a Git command. 
This is a powerful utility to create custom shortcuts for commonly used git commands. 

A simplistic example would be:
<code>git config --global alias.ci commit</code>
This creates a <code>ci</code> command that you can execute as a shortcut to <code>git commit</code>. 
To learn more about git aliases visit the <a href="/git/tutorials/setting-up-a-repository/git-config" data-event="clicked" data-uuid="509a8084-a3" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git config page</a>.

<code>git config --system core.editor &lt;editor></code>
Define the text editor used by commands like <code>git commit</code> for all users on the current machine. 
The <code>&lt; editor ></code> argument should be the command that launches the desired editor (e.g., vi). 
This example introduces the <code>--system</code> option. 

The <code>--system</code> option will set the configuration for the entire system, meaning all users and repos on a machine. 
For more detailed information on configuration levels visit the <a href="/git/tutorials/setting-up-a-repository/git-config" data-event="clicked" data-uuid="a0bb3866-bf" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git config page</a>.
<code>git config --global --edit</code>
Open the global configuration file in a text editor for manual editing. 

An in-depth guide on how to configure a text editor for git to use can be found on the <a href="/git/tutorials/setting-up-a-repository/git-config" data-event="clicked" data-uuid="51ad478c-f2" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Git config page</a>.
<h3>&emsp;Discussion</h3>
All configuration options are stored in plaintext files, so the <code>git config</code> command is really just a convenient command-line interface. 
Typically, you’ll only need to configure a Git installation the first time you start working on a new development machine, and for virtually all cases, you'll want to use the <code>--global</code> flag. 

One important exception is to override the author email address. 
You may wish to set your personal email address for personal and open source repositories, and your professional email address for work-related repositories.
Git stores configuration options in three separate files, which lets you scope options to individual repositories, users, or the entire system:
<code><repo>/.git/config</repo></code> – Repository-specific settings.

<code>~/.gitconfig</code> – User-specific settings. 
This is where options set with the --global flag are stored.
<code>$(prefix)/etc/gitconfig</code> – System-wide settings.
When options in these files conflict, local settings override user settings, which override system-wide. 

If you open any of these files, you’ll see something like the following:
<code>[user] name = John Smith email = john@example.com [alias] st = status co = checkout br = branch up = rebase ci = commit [core] editor = vim</code>
You can manually edit these values to the exact same effect as <code>git config</code>.
<h3>&emsp;Example</h3>

The first thing you’ll want to do after installing Git is tell it your name/email and customize some of the default settings. 
A typical initial configuration might look something like the following:
Tell Git who you are <code>git config</code>
<code>git --global user.name "John Smith" git config --global user.email john@example.com</code>

Select your favorite text editor
<code>git config --global core.editor vim</code>
Add some SVN-like aliases
<code>git config --global alias.st status 

git config --global alias.co checkout 
git config --global alias.br branch 
git config --global alias.up rebase 
git config --global alias.ci commit</code>

This will produce the <code>~ /.gitconfig</code> file from the previous section. 
Take a more in-depth look at git config on the <a href="/git/tutorials/setting-up-a-repository/git-config" data-event="clicked" data-uuid="4317e363-cc" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git config page</a>.
<h2><span class="saddlebrown">&emsp;Summary</span></h2>
Here we demonstarted how to create a git repository using two methods: <a href="/git/tutorials/setting-up-a-repository/git-init" data-event="clicked" data-uuid="9ad87fb6-e9" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git init</a> and <a href="/git/tutorials/setting-up-a-repository/git-clone" data-event="clicked" data-uuid="9ad87fb6-e9" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git clone</a>. 

This guide can be applied to manage software source code or other content that needs to be versioned. 
<a href="/git/tutorials/saving-changes" data-event="clicked" data-uuid="9ad87fb6-e9" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Git add</a>, <a href="/git/tutorials/saving-changes/git-commit" data-event="clicked" data-uuid="9ad87fb6-e9" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git commit</a>, <a href="/git/tutorials/syncing/git-push" data-event="clicked" data-uuid="9ad87fb6-e9" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git push</a>, and <a href="/git/tutorials/syncing" data-event="clicked" data-uuid="9ad87fb6-e9" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git remote</a> were also introduced and utilized at a high level. 
Read our <a href="https://bitbucket.org/product/code-repository" data-event="clicked" data-uuid="9ad87fb6-e9" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">guide about which code repository system is right for your team</a>! 
<h2><br><span class="orange">git init</span></h2>
This page will explore the <code>git init</code> command in depth. 
By the end of this page you will be informed on the core functionality and extended feature set of <code>git init</code>. 
This exploration includes:
<code>git init</code> options and usage

<code>.git</code> directory overview
 custom <code>git init</code> directory environment values
<code>git init</code> vs. <code>git clone</code>
<code>git init</code> bare repositories

<code>git init</code> templates
The <code>git init</code> command creates a new Git repository. 
It can be used to convert an existing, unversioned project to a Git repository or initialize a new, empty repository. 
Most other Git commands are not available outside of an initialized repository, so this is usually the first command you'll run in a new project.

Executing <code>git init</code> creates a <code>.git</code> subdirectory in the current working directory, which contains all of the necessary Git metadata for the new repository. 
This metadata includes subdirectories for objects, refs, and template files. 
A <code>HEAD</code> file is also created which points to the currently checked out commit.
Aside from the <code>.git</code> directory, in the root directory of the project, an existing project remains unaltered (unlike SVN, Git doesn't require a <code>.git</code> subdirectory in every subdirectory).

By default, <code>git init</code> will initialize the Git configuration to the <code>.git</code> subdirectory path. 
The subdirectory path can be modified and customized if you would like it to live elsewhere. 
You can set the <code>$GIT_DIR</code> environment variable to a custom path and <code>git init</code> will initialize the Git configuration files there. 
Additionally you can pass the <code>--separate-git-dir</code> argument for the same result. 

A common use case for a separate <code>.git</code> subdirectory is to keep your system configuration "dotfiles" (<code>.bashrc</code>, <code>.vimrc</code>, etc.) in the home directory while keeping the <code>.git</code> folder elsewhere.
<h2><span class="saddlebrown">&emsp;Usage</span></h2>
Compared to SVN, the <code>git init</code> command is an incredibly easy way to create new version-controlled projects. 
Git doesn’t require you to create a repository, import files, and check out a working copy. 

Additionally, Git does not require any pre-existing server or admin privileges. 
All you have to do is cd into your project subdirectory and run <code>git init</code>, and you'll have a fully functional Git repository.
<code>git init</code>
Transform the current directory into a Git repository. 

This adds a <code>.git</code> subdirectory to the current directory and makes it possible to start recording revisions of the project.
<code>git init &lt;directory></code>
Create an empty Git repository in the specified directory. 
Running this command will create a new subdirectory called <directory> containing nothing but the <code>.git</code> subdirectory.</directory>

If you've already run <code>git init</code> on a project directory and it contains a <code>.git</code> subdirectory, you can safely run <code>git init</code> again on the same project directory. 
It will not override an existing <code>.git</code> configuration.
<h3>&emsp;git init vs. git clone</h3>
A quick note: <code>git init</code> and <code>git clone</code> can be easily confused. 

At a high level, they can both be used to "initialize a new git repository." However, <code>git clone</code> is dependent on <code>git init</code>. 
<code>git clone</code> is used to create a copy of an existing repository. 
Internally, <code>git clone</code> first calls <code>git init</code> to create a new repository. 
It then copies the data from the existing repository, and checks out a new set of working files. 

Learn more on the <a href="/git/tutorials/setting-up-a-repository/git-clone" data-event="clicked" data-uuid="1cbfc86a-51" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git clone page</a>.
<h2><span class="saddlebrown">&emsp;Bare repositories --- git init --bare</span></h2>
<code>git init --bare &lt;directory></code>
Initialize an empty Git repository, but omit the working directory. 

Shared repositories should always be created with the <code>--bare</code> flag (see discussion below). 
Conventionally, repositories initialized with the <code>--bare</code> flag end in <code>.git</code>. 
For example, the bare version of a repository called <code>my-project</code> should be stored in a directory called <code>my-project.git</code>.
The <code>--bare</code> flag creates a repository that doesn’t have a working directory, making it impossible to edit files and commit changes in that repository. 

You would create a bare repository to git push and git pull from, but never directly commit to it. 
Central repositories should always be created as bare repositories because pushing branches to a non-bare repository has the potential to overwrite changes. 
Think of <code>--bare</code> as a way to mark a repository as a storage facility, as opposed to a development environment. 
This means that for virtually all Git workflows, the central repository is bare, and developers local repositories are non-bare.

<img src="https://wac-cdn.atlassian.com/dam/jcr:88f08a3d-f34e-4c8e-974c-a01f25b2eca1/01.svg?cdnVersion=217" loading="lazy" alt="Git Tutorial: Bare Repositories">The most common use case for  <code>git init --bare</code> is to create a remote central repository:
<code>ssh &lt;user>@&lt;host> cd path/above/repo git init --bare my-project.git</code>
First, you SSH into the server that will contain your central repository. 
Then, you navigate to wherever you’d like to store the project. 

Finally, you use the <code>--bare</code> flag to create a central storage repository. 
Developers would then clone <code>my-project.git</code> to create a local copy on their development machine.
<h2><span class="saddlebrown">&emsp;git init templates</span></h2>
<code>git init &lt;directory> --template=&lt;template_directory></code>

Initializes a new Git repository and copies files from the  <code><template_directory></template_directory></code> into the repository.
Templates allow you to initialize a new repository with a predefined <code>.git</code> subdirectory. 
You can configure a template to have default directories and files that will get copied to a new repository's <code>.git</code> subdirectory. 
The default Git templates usually reside in a <code>`/usr/share/git-core/templates`</code> directory but may be a different path on your machine.

The default templates are a good reference and example of how to utilize template features. 
A powerful feature of templates that's exhibited in the default templates is Git Hook configuration. 
You can create a template with predefined Git hooks and initialize your new git repositories with common hooks ready to go. 
Learn more about Git Hooks at the <a href="/git/tutorials/git-hooks" data-event="clicked" data-uuid="791cf24c-19" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Git Hook page</a>.
<h2><span class="saddlebrown">&emsp;Configuration</span></h2>
All configurations of <code>git init <directory></directory></code> take a <code><directory></directory></code> argument. 
If you provide the <code><directory></directory></code>, the command is run inside it. 
If this directory does not exist, it will be created. 

In addition to the options and configuration already discussed, <code>Git init</code> has a few other command line options. 
A full list of them follows:
<code>-Q</code>
<code>--QUIET</code>

Only prints "critical level" messages, Errors, and Warnings. 
All other output is silenced.
<code>--BARE </code>
Creates a bare repository. 

(See the "Bare Repositories" section above.)
<code>--TEMPLATE=<templatedirectory></templatedirectory></code>
Specifies the directory from which templates will be used. 
(See the "Git Init Templates" section above.)

<code>--SEPARATE-GIT-DIR=<git dir></git></code>
Creates a text file containing the path to <code><git dir></git></code>. 
This file acts as a link to the <code>.git</code> directory. 
This is useful if you would like to store your <code>.git</code> directory on a separate location or drive from your project's working files. 

Some common use cases for <code>--separate-git-dir</code> are:
To keep your system configuration "dotfiles" (<code>.bashrc, .vimrc</code>, etc.) in the home directory while keeping the <code>.git</code> folder elsewhere
Your Git history has grown very large in disk size and you need to move it elsewhere to a separate high-capacity drive
You want to have a Git project in a publicly accessible directory like <code>`www:root`</code>

You can call <code>git init --separate-git-dir</code> on an existing repository and the <code>.git dir</code> will be moved to the specified <code><git dir></git></code> path.
<code>--SHARED[=(FALSE|TRUE|UMASK|GROUP|ALL|WORLD|EVERYBODY|0XXX)]</code> 
Set access permissions for the new repository. 
This specifies which users and groups using Unix-level permissions are allowed to push/pull to the repository.
<h2><span class="saddlebrown">&emsp;Examples</span></h2>
<h3>&emsp;Create a new git repository for an existing code base</h3>
<code>cd /path/to/code \ 
git init \ 
git add . \ 
git commit</code>
<h3>&emsp;Create a new bare repository</h3>
<code>git init --bare /path/to/repo.git</code>

<h3>&emsp;Create a git init template and initialize a new git repository from the template</h3>
<code>mkdir -p /path/to/template \ 
echo "Hello World" >> /absolute/path/to/template/README \
git init /new/repo/path --template=/absolute/path/to/template \ 
cd /new/repo/path \ 
cat /new/repo/path/README</code>
<h2><br><span class="orange">git clone</span></h2>
Here we'll examine the <code>git clone</code> command in depth. 

<code>git clone</code> is a Git command line utility which is used to target an existing repository and create a clone, or copy of the target repository. 
In this page we'll discuss extended configuration options and common use cases of <code>git clone</code>. 
Some points we'll cover here are:
Cloning a local or remote repository

Cloning a bare repository
Using shallow options to partially clone repositories
Git URL syntax and supported protocols
On the <a href="/git/tutorials/setting-up-a-repository" data-event="clicked" data-uuid="d486c6be-ef" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">setting up a repository guide</a>, we covered a basic use case of <code>git clone</code>. 

This page will explore more complex cloning and configuration scenarios.
<h2><span class="saddlebrown">&emsp;Purpose: repo-to-repo collaboration development copy</span></h2>
If a project has already been set up in a central repository, the <code>git clone</code> command is the most common way for users to obtain a development copy. 
Like <code>git init</code>, cloning is generally a one-time operation. 

Once a developer has obtained a working copy, all version control operations and collaborations are managed through their local repository.
<h3>&emsp;Repo-to-repo collaboration</h3>
It’s important to understand that Git’s idea of a “working copy” is very different from the working copy you get by checking out code from an SVN repository. 
Unlike SVN, Git makes no distinction between the working copy and the central repository—they're all full-fledged <a href="https://bitbucket.org/product/code-repository" data-event="clicked" data-uuid="221e005e-18" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Git repositories</a>.

This makes collaborating with Git fundamentally different than with SVN. 
Whereas SVN depends on the relationship between the central repository and the working copy, Git’s collaboration model is based on repository-to-repository interaction. 
Instead of checking a working copy into SVN’s central repository, you <a href="/git/tutorials/syncing/git-push" data-event="clicked" data-uuid="0e615ec2-b6" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">push</a> or <a href="/git/tutorials/syncing/git-pull" data-event="clicked" data-uuid="0e615ec2-b6" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">pull</a> commits from one repository to another.
<img src="https://wac-cdn.atlassian.com/dam/jcr:e5228129-76b1-4b2c-8f10-af789f2ea6c0/03.svg?cdnVersion=217" loading="lazy" alt="Git Tutorial: Repo to Working Copy Collaboration"><img src="https://wac-cdn.atlassian.com/dam/jcr:5d68ce55-59a7-4840-a896-eb2014a9f17b/02.svg?cdnVersion=217" loading="lazy" alt="Git Tutorial: Repo to Repo Collaboration">Of course, there’s nothing stopping you from giving certain Git repos special meaning. 

For example, by simply designating one Git repo as the “central” repository, it’s possible to replicate a <a href="/git/tutorials/comparing-workflows" data-event="clicked" data-uuid="4f8e0f25-f3" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">centralized workflow</a> using Git. 
The point is, this is accomplished through conventions rather than being hardwired into the VCS itself.
<h2><span class="saddlebrown">&emsp;Usage</span></h2>
<code>git clone</code> is primarily used to point to an existing repo and make a clone or copy of that repo at in a new directory, at another location. 

The original repository can be located on the local filesystem or on remote machine accessible supported protocols. 
The <code>git clone</code> command copies an existing Git repository. 
This is sort of like SVN checkout, except the “working copy” is a full-fledged Git repository—it has its own history, manages its own files, and is a completely isolated environment from the original repository.
As a convenience, cloning automatically creates a remote connection called "origin" pointing back to the original repository. 

This makes it very easy to interact with a central repository. 
This automatic connection is established by creating Git refs to the remote branch heads under <code>refs/remotes/origin</code> and by initializing <code>remote.origin.url</code> and <code>remote.origin.fetch</code> configuration variables.
An example demonstrating using <code>git clone</code> can be found on the <a href="/git/tutorials/setting-up-a-repository" data-event="clicked" data-uuid="66d16ba5-73" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">setting up a repository guide</a>. 
The example below demonstrates how to obtain a local copy of a central repository stored on a server accessible at <code>example.com</code> using the SSH username john:

<code>git clone ssh://john@example.com/path/to/my-project.git 
cd my-project 
# Start working on the project</code>
The first command initializes a new Git repository in the <code>my-project</code> folder on your local machine and populates it with the contents of the central repository. 

Then, you can cd into the project and start editing files, committing snapshots, and interacting with other repositories. 
Also note that the <code>.git</code> extension is omitted from the cloned repository. 
This reflects the non-bare status of the local copy.
<h3>&emsp;Cloning to a specific folder</h3>

<code>git clone &lt;repo> &lt;directory></code>
Clone the repository located at <code>＜repo＞</code> into the folder called <code>~＜directory＞!</code> on the local machine.
<h3>&emsp;Cloning a specific tag</h3>
<code>git clone --branch &lt;tag> &lt;repo></code>

Clone the repository located at <code>＜repo＞</code> and only clone the ref for <code>＜tag＞</code>.
<h3>&emsp;Shallow clone</h3>
<code>git clone -depth=1 &lt;repo></code>
Clone the repository located at <code>＜repo＞</code> and only clone the 

history of commits specified by the option depth=1. 
In this example a clone of <code>＜repo＞</code> is made and only the most recent commit is included in the new cloned Repo. 
Shallow cloning is most useful when working with repos that have an extensive commit history. 
An extensive commit history may cause scaling problems such as disk space usage limits and long wait times when cloning. 

A Shallow clone can help alleviate these scaling issues.
<h2><span class="saddlebrown">&emsp;Configuration options</span></h2>
<h3>&emsp;git clone -branch</h3>
The <code>-branch</code> argument lets you specify a specific branch to clone instead of the branch the remote <code>HEAD</code> is pointing to, usually the main branch. 

In addition you can pass a tag instead of branch for the same effect.
<code>git clone -branch new_feature git://remoterepository.git</code>
This above example would clone only the <code>new_feature</code> branch from the remote Git repository. 
This is purely a convenience utility to save you time from downloading the <code>HEAD</code> ref of the repository and then having to additionally fetch the ref you need.

<h3>&emsp;git clone -mirror vs. git clone -bare</h3>
<h4>git clone --bare</h4>
Similar to <code>git init --bare,</code> when the <code>-bare</code> argument is passed to <code>git clone,</code> a copy of the remote repository will be made with an omitted working directory. 
This means that a repository will be set up with the history of the project that can be pushed and pulled from, but cannot be edited directly. 

In addition, no remote branches for the repo will be configured with the <code>-bare</code> repository. 
Like <code>git init --bare,</code> this is used to create a hosted repository that developers will not edit directly.
<h4>git clone --mirror</h4>
Passing the <code>--mirror</code> argument implicitly passes the <code>--bare</code> argument as well. 

This means the behavior of <code>--bare</code> is inherited by <code>--mirror</code>. 
Resulting in a bare repo with no editable working files. 
In addition, <code>--mirror</code> will clone all the extended refs of the remote repository, and maintain remote branch tracking configuration. 
You can then run <code>git remote</code> update on the mirror and it will overwrite all refs from the origin repo. 

Giving you exact 'mirrored' functionality.
<h3>&emsp;Other configuration options</h3>
For a comprehensive list of other git clone options visit the <a href="https://git-scm.com/docs/git-clone" data-event="clicked" data-uuid="22bf66b6-6d" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">official Git documentation</a>. 
In this document, we'll touch on some other common options.

<h4> git clone --template</h4>
<code>git clone --template=&lt;template_directory> &lt;repo location></code>
Clones the repo at <code>＜repo location＞</code> and applies the template from <code>＜template directory＞</code> to the newly created local branch. 

A thorough refrence on Git templates can be found on our <a href="/git/tutorials/setting-up-a-repository/git-init" data-event="clicked" data-uuid="fb996009-f0" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git init page</a>.
<h2><span class="saddlebrown">&emsp;Git URLs</span></h2>
Git has its own URL syntax which is used to pass remote repository locations to Git commands. 
Because <code>git clone</code> is most commonly used on remote repositories we will examine Git URL syntax here.

<h3>&emsp;Git URL protocols</h3>
<strong>-SSH</strong>
Secure Shell (SSH) is a ubiquitous authenticated network protocol that is commonly configured by default on most servers. 
Because SSH is an authenticated protocol, you'll need to establish credentials with the hosting server before connecting. 

<code>ssh://[user@]host.xz[:port]/path/to/repo.git/</code>
<strong>- GIT</strong>
A protocol unique to git. 
Git comes with a daemon that runs on port (9418). 

The protocol is similar to SSH however it has NO AUTHENTICATION. 
<code>git://host.xz[:port]/path/to/repo.git/</code>
<strong>- HTTP</strong>
Hyper text transfer protocol. 

The protocol of the web, most commonly used for transferring web page HTML data over the Internet. 
Git can be configured to communicate over HTTP <code>http[s]://host.xz[:port]/path/to/repo.git/</code>
<h2><span class="saddlebrown">&emsp;Summary</span></h2>
In this document we took a deep look at <code>git clone</code>. 

The most important takeaways are:
1. <code>git clone</code> is used to create a copy of a target repo
2. The target repo can be local or remote
3. Git supports a few network protocols to connect to remote repos
4. There are many different configuration options available that change the content of the clone
For further, deeper reference on <code>git clone</code> functionality, consult the <a href="https://git-scm.com/docs/git-clone" data-event="clicked" data-uuid="9341f816-4e" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">official Git documentation</a>. 
We also cover practical examples of git clone in our <a href="/git/tutorials/setting-up-a-repository" data-event="clicked" data-uuid="9341f816-4e" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">setting up a repository guide</a>.
<h2><br><span class="orange">git config</span></h2>
In this document, we'll take an in-depth look at the <code>git config</code> command. 
We briefly discussed <code>git config</code> usage on our <a href="/git/tutorials/setting-up-a-repository" data-event="clicked" data-uuid="76ac1290-87" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Setting up a Repository</a> page. 
The <code>git config</code> command is a convenience function that is used to set Git configuration values on a global or local project level. 
These configuration levels correspond to <code>.gitconfig</code> text files. 

Executing <code>git config</code> will modify a configuration text file. 
We'll be covering common configuration settings like email, username, and editor. 
We'll discuss Git aliases, which allow you to create shortcuts for frequently used Git operations. 
Becoming familiar with <code>git config</code> and the various Git configuration settings will help you create a powerful, customized Git workflow.
<h2><span class="saddlebrown">&emsp;Usage</span></h2>
The most basic use case for <code>git config</code> is to invoke it with a configuration name, which will display the set value at that name. 
Configuration names are dot delimited strings composed of a 'section' and a 'key' based on their hierarchy. 
For example: <code>user.email</code>

<code>git config user.email</code>
In this example, email is a child property of the user configuration block. 
This will return the configured email address, if any, that Git will associate with locally created commits.
<h3>&emsp;git config levels and files</h3>

Before we further discuss <code>git config</code> usage, let's take a moment to cover configuration levels. 
The <code>git config</code> command can accept arguments to specify which configuration level to operate on. 
The following configuration levels are available:
<code><strong>--local</strong></code>

By default, <code>git config</code> will write to a local level if no configuration option is passed. 
Local level configuration is applied to the context repository <code>git config</code> gets invoked in. 
Local configuration values are stored in a file that can be found in the repo's .git directory: <code>.git/config</code>
<code><strong>--global</strong></code>

Global level configuration is user-specific, meaning it is applied to an operating system user. 
Global configuration values are stored in a file that is located in a user's home directory. 
<code>~ /.gitconfig</code> on unix systems and <code>C:\Users\<username>\.gitconfig</username></code> on windows
<code><strong>--system</strong></code>

System-level configuration is applied across an entire machine. 
This covers all users on an operating system and all repos. 
The system level configuration file lives in a <code>gitconfig</code> file off the system root path. 
<code>$(prefix)/etc/gitconfig</code> on unix systems. 

On windows this file can be found at <code>C:\Documents and Settings\All Users\Application Data\Git\config</code> on Windows XP, and in <code>C:\ProgramData\Git\config</code> on Windows Vista and newer.
Thus the order of priority for configuration levels is: local, global, system. 
This means when looking for a configuration value, Git will start at the local level and bubble up to the system level.
<h3>&emsp;Writing a value</h3>

Expanding on what we already know about <code>git config</code>, let's look at an example in which we write a value:
<code>git config --global user.email "your_email@example.com"</code>
This example writes the value <code>your_email@example.com</code> to the configuration name <code>user.email</code>. 
It uses the <code>--global</code> flag so this value is set for the current operating system user.
<h2><span class="saddlebrown">&emsp;git config editor - core.editor</span></h2>
Many Git commands will launch a text editor to prompt for further input. 
One of the most common use cases for <code>git config</code> is configuring which editor Git should use. 
Listed below is a table of popular editors and matching <code>git config</code> commands:

<table border="1" cellpadding="1" cellspacing="1">
<thead><tr>
<th scope="col">Editor</th> <th scope="col">config command</th> </tr></thead>
<tbody>

<tr>
<td>Atom</td> <td><code>~ git config --global core.editor "atom --wait"~</code></td> </tr>
<tr>
<td>emacs</td> <td><code>~ git config --global core.editor "emacs"~</code></td> </tr>

<tr>
<td>nano</td> <td><code>~ git config --global core.editor "nano -w"~</code></td> </tr>
<tr>
<td>vim</td> <td><code>~ git config --global core.editor "vim"~</code></td> </tr>

<tr>
<td>Sublime Text (Mac)</td> <td><code>~ git config --global core.editor "subl -n -w"~</code></td> </tr>
<tr>
<td>Sublime Text (Win, 32-bit install)</td> <td><code>~ git config --global core.editor "'c:/program files (x86)/sublime text 3/sublimetext.exe' -w"~</code></td> </tr>

<tr>
<td>Sublime Text (Win, 64-bit install)</td> <td><code>~ git config --global core.editor "'c:/program files/sublime text 3/sublimetext.exe' -w"~</code></td> </tr>
<tr>
<td>Textmate</td> <td><code>~ git config --global core.editor "mate -w"~</code></td> </tr>

</tbody>
</table>
<h2><span class="saddlebrown">&emsp;Merge tools</span></h2>
In the event of a merge conflict, Git will launch a "merge tool." By default, Git uses an internal implementation of the common Unix diff program. 

The internal Git diff is a minimal merge conflict viewer. 
There are many external third party merge conflict resolutions that can be used instead. 
For an overview of various merge tools and configuration, see our guide on <a href="https://developer.atlassian.com/blog/2015/12/tips-tools-to-solve-git-conflicts/" data-event="clicked" data-uuid="0b3867b6-e6" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">tips and tools to resolve conflits with Git</a>. 
<code>git config --global merge.tool kdiff3</code>
<h2><span class="saddlebrown">&emsp;Colored outputs</span></h2>
Git supports colored terminal output which helps with rapidly reading Git output. 
You can customize your Git output to use a personalized color theme. 
The <code>git config</code> command is used to set these color values.

<h3>&emsp;<code>color.ui</code></h3>
This is the master variable for Git colors. 
Setting it to false will disable all Git's colored terminal output.
<code>$ git config --global color.ui false</code>

By default, <code>color.ui</code> is set to auto which will apply colors to the immediate terminal output stream. 
The auto setting will omit color code output if the output stream is redirected to a file or piped to another process.
You can set the <code>color.ui</code> value to always which will also apply color code output when redirecting the output stream to files or pipes. 
This can unintentionally cause problems since the receiving pipe may not be expecting color-coded input.

<h3>&emsp;Git color values</h3>
In addition to <code>color.ui</code>, there are many other granular color settings. 
Like <code>color.ui</code>, these color settings can all be set to false, auto, or always. 
These color settings can also have a specific color value set. 

Some examples of supported color values are:
normal
black
red

green
yellow
blue
magenta

cyan
white
Colors may also be specified as hexadecimal color codes like #ff0000, or ANSI 256 color values if your terminal supports it.
<h3>&emsp;Git color configuration settings</h3>

1. <code>color.branch</code> 
Configures the output color of the Git branch command 
2. <code>color.branch.</code>&lt;<code>slot</code>> 
This value is also applicable to Git branch output. 

&lt;<code>slot</code>> is one of the following:  
1. current: the current branch 
2. local: a local branch 
3. remote: a remote branch ref in refs/remotes 

4. upstream: an upstream tracking branch 
5. plain: any other ref
3. <code>color.diff</code> 
Applies colors to <code>git diff</code>, <code>git log</code>, and <code>git show</code> output 

4. <code>color.diff</code>.&lt;<code>slot</code>> 
Configuring a &lt;<code>slot</code>> value under <code>color.diff</code> tells git which part of the patch to use a specific color on. 
1. context: The context text of the diff. 
Git context is the lines of text content shown in a diff or patch that highlights changes. 

2. plain: a synonym for context 
3. meta: applies color to the meta information of the diff 
4. frag: applies color to the "hunk header" or "function in hunk header" 
5. old: applies a color to the removed lines in the diff 

6. new: colors the added lines of the diff 
7. commit: colors commit headers within the diff 
8. whitespace: sets a color for any whitespace errors in a diff
5. <code>color.decorate.</code>&lt;<code>slot</code>> 

Customize the color for <code>git log --decorate</code> output. 
The supported &lt;<code>slot</code>> values are: <code>branch</code>, <code>remoteBranch</code>, <code>tag</code>, <code>stash</code>, or <code>HEAD</code>. 
They are respectively applicable to local branches, remote-tracking branches, tags, stashed changes and <code>HEAD</code>. 
6. <code>color.grep</code>

Applies color to the output of git grep. 
7. <code>color.grep.</code> &lt;<code>slot</code>> 
Also applicable to git grep. 
The &lt;<code>slot</code>> variable specifies which part of the grep output to apply color. 

1. context: non-matching text in context lines 
2. filename: filename prefix 
3. function: function name lines 
4. linenumber: line number prefix 

5. match: matching text 
6. matchContext: matching text in context lines 
7. matchSelected: matching text in selected lines 
8. selected: non-matching text in selected lines 

9. separator: separators between fields on a line (:, -, and =) and between hunks (--) 
8. color.interactive 
This variable applies color for interactive prompts and displays. 
Examples are <code>git add --interactive</code> and <code>git clean --interactive </code>

9. color.interactive.&lt;<code>slot</code>> 
The &lt;<code>slot</code>> variable can be specified to target more specific "interactive output". 
The available &lt;<code>slot</code>> values are: prompt, header, help, error; and each act on the corresponding interactive output. 
10. <code>color.pager</code>

Enables or disables colored output when the pager is in use 
11. <code>color.showBranch </code>
Enables or disables color output for the git show branch command 
<code>12. 

color.status </code>
A boolean value that enables or disables color output for Git status 
<code>13. 
color.status.&lt;<code>slot</code>></code>

Used to specify custom color for specified git status elements. 
&lt;<code>slot</code>> supports the following values:
1. header 
Targets the header text of the status area

2. added or updated 
Both target files which are added but not committed
<code><code><code>3. 
changed </code></code> </code> 

Targets files that are modified but not added to the git index
4. untracked 
Targets files which are not tracked by Git
5. branch 

Applies color to the current branch
6. nobranch 
The color the "no branch" warning is shown in
7. unmerged 

Colors files which have unmerged changes
<h2><span class="saddlebrown">&emsp;Aliases</span></h2>
You may be familiar with the concept of aliases from your operating system command-line; if not, they're custom shortcuts that define which command will expand to longer or combined commands. 
Aliases save you the time and energy cost of typing frequently used commands. 

Git provides its own alias system. 
A common use case for Git aliases is shortening the commit command. 
Git aliases are stored in Git configuration files. 
This means you can use the <code>git config</code> command to configure aliases.

<code>git config --global alias.ci commit</code>
This example creates a ci alias for the <code>git commit</code> command. 
You can then invoke <code>git commit</code> by executing <code>git ci</code>. 
Aliases can also reference other aliases to create powerful combos.

<code>git config --global alias.amend ci --amend</code>
This example creates an alias amend which composes the ci alias into a new alias that uses <code>--amend flag</code>.
<h2><span class="saddlebrown">&emsp;Formatting &amp; whitespace</span></h2>
Git has several "whitespace" features that can be configured to highlight whitespace issues when using git diff. 

The whitespace issues will be highlighted using the configured color <code>color.diff.whitespace</code>
The following features are enabled by default:
<code>blank-at-eol</code> highlights orphan whitespaces at the line endings
<code>space-before-tab</code> highlights a space character that appears before a tab character when indenting a line

<code>blank-at-eof</code> highlights blank lines inserted at the end of a file
The following features are disabled by default
<code>indent-with-non-tab</code> highlights a line that is indented with spaces instead of tabs
<code>tab-in-indent</code> highlights an initial tab indent as an error

<code>trailing-space</code> is shorthand for both blank-at-eol and blank-at-eof
<code>cr-at-eol highlights</code> a carriage-return at the line endings
<code>tabwidth=<n></n></code> defines how many character positions a tab occupies. 
The default value is 8. 

Allowed values are 1-63
<h2><span class="saddlebrown">&emsp;Summary</span></h2>
In this article, we covered the use of the git <code>config command</code>. 
We discussed how the command is a convince method for editing raw <code>git config</code> files on the filesystem. 

We looked at basic read and write operations for configuration options. 
We took a look at common config patterns:
How to configure the Git editor
How to override configuration levels

How to reset configuration defaults
How to customize git colors
Overall, <code>git config</code> is a helper tool that provides a shortcut to editing raw <code>git config</code> files on disk. 
We covered in depth personal customization options. 

Basic knowledge of git configuration options is a prerequisite for <a href="/git/tutorials/setting-up-a-repository" data-event="clicked" data-uuid="cf101202-ff" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">setting up a repository</a>. 
See our guide there for a demonstration of the basics.
<h2><br><span class="orange">Git Alias</span></h2>
This section will focus on Git aliases. 

To better understand the value of Git aliases we must first discuss what an alias is. 
The term alias is synonymous with a shortcut. 
Alias creation is a common pattern found in other popular utilities like `bash` shell. 
Aliases are used to create shorter commands that map to longer commands. 

Aliases enable more efficient workflows by requiring fewer keystrokes to execute a command. 
For a brief example, consider the <code>git checkout</code> command. 
The checkout command is a frequently used git command, which adds up in cumulative keystrokes over time. 
An alias can be created that maps <code>git co</code> to <code>git checkout</code>, which saves precious human fingertip power by allowing the shorter keystroke form: <code>git co</code> to be typed instead.
<h2><span class="saddlebrown">&emsp;Git Alias Overview</span></h2>
It is important to note that there is no direct <code>git alias</code> command. 
Aliases are created through the use of the <code><a href="/git/tutorials/setting-up-a-repository/git-config" data-event="clicked" data-uuid="7d188d3f-5d" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git config</a></code> command and the Git configuration files. 
As with other configuration values, aliases can be created in a local or global scope.

To better understand Git aliases let us create some examples.
<code>$ git config --global alias.co checkout
$ git config --global alias.br branch
$ git config --global alias.ci commit

$ git config --global alias.st status</code>
The previous code example creates globally stored shortcuts for common git commands. 
Creating the aliases will not modify the source commands. 
So <code>git checkout</code> will still be available even though we now have the <code>git co</code> alias. 

These aliases were created with the <code>--global</code> flag which means they will be stored in Git's global operating system level configuration file. 
On linux systems, the global config file is located in the User home directory at <code>/.gitconfig</code>.
<code>    [alias]
    co = checkout

        br = branch
        ci = commit
        st = status</code>
This demonstrates that the aliases are now equivalent to the source commands.
<h2><span class="saddlebrown">&emsp;Usage</span></h2>
Git aliasing is enabled through the use of <code>git config</code>, For command-line option and usage examples please review the <code><a href="/git/tutorials/setting-up-a-repository/git-config" data-event="clicked" data-uuid="64d77f56-12" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git config</a> </code>documentation.
<h2><span class="saddlebrown">&emsp;Examples</span></h2>
<h3>&emsp;Using aliases to create new Git commands</h3>

A common Git pattern is to remove recently added files from the staging area. 
This is achieved by leveraging options to the <code>git reset</code> command. 
A new alias can be created to encapsulate this behavior and create a new alias-command-keyword which is easy to remember:
<code>git config --global alias.unstage 'reset HEAD --'</code>

The preceding code example creates a new alias <code>unstage</code>. 
This now enables the invocation of <code>git unstage. 
git unstage</code> which will perform a reset on the staging area. 
This makes the following two commands equivalent.

<code>git unstage fileA
$ git reset HEAD -- fileA</code>
<h2><span class="saddlebrown">&emsp;Discussion</span></h2>
<h3>&emsp;How do I create Git Aliases?</h3>

Aliases can be created through two primary methods:
<h4> Directly editing Git config files</h4>
The global or local config files can be manually edited and saved to create aliases. 

The global config file lives at <code>$HOME/.gitconfig</code> file path. 
The local path lives within an active git repository at <code>/.git/config</code>
The config files will respect an <code>[alias]</code> section that looks like:
<code>[alias]

co = checkout</code>
This means that <code>co</code> is a shortcut for <code>checkout</code>
<h4> Using the git config to create aliases</h4>

As previously demonstrated the <code>git config</code> command is a convenient utility to quickly create aliases. 
The <code>git config</code> command is actually a helper utility for writing to the global and local Git config files.
<code>git config --global alias.co checkout</code>
Invoking this command will update the underlying global config file just as it had been edited in our previous example.
<h2><span class="saddlebrown">&emsp;Git Alias Summary</span></h2>
Git aliases are a powerful workflow tool that create shortcuts to frequently used Git commands. 
Using Git aliases will make you a faster and more efficient developer. 
Aliases can be used to wrap a sequence of Git commands into new faux Git command. 

Git aliases are created through the use of the <coide>git config command which essentially modifies local or global Git config files. 
Learn more on the <code><a href="/git/tutorials/setting-up-a-repository/git-config" data-event="clicked" data-uuid="5ae035dd-d9" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git config</a></code> page.</coide>
<h2><br><span class="orange">Saving changes</span></h2>
When working in Git, or other version control systems, the concept of "saving" is a more nuanced process than saving in a word processor or other traditional file editing applications. 

The traditional software expression of "saving" is synonymous with the Git term "committing". 
A commit is the Git equivalent of a "save". 
Traditional saving should be thought of as a file system operation that is used to overwrite an existing file or write a new file. 
Alternatively, Git committing is an operation that acts upon a collection of files and directories.

Saving changes in Git vs SVN is also a different process. 
SVN Commits or 'check-ins' are operations that make a remote push to a centralized server. 
This means an SVN commit needs Internet access in order to fully 'save' project changes. 
Git commits can be captured and built up locally, then pushed to a remote server as needed using the <code>git push -u origin main</code> command. 

The difference between the two methods is a fundamental difference between architecture designs. 
Git is a distributed application model whereas SVN is a centralized model. 
Distributed applications are generally more robust as they do not have a single point of failure like a centralized server.
Git has an additional saving mechanism called 'the stash'. 

The stash is an ephemeral storage area for changes that are not ready to be committed. 
The stash operates on the working directory, the first of <a href="/git/tutorials/undoing-changes/git-reset" data-event="clicked" data-uuid="17d1a54c-1e" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">the three trees</a> and has extensive usage options. 
To learn more visit the <code><a href="/git/tutorials/saving-changes/git-stash" data-event="clicked" data-uuid="17d1a54c-1e" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git stash</a></code> page.
A Git repository can be configured to ignore specific files or directories. 

This will prevent Git from saving changes to any ignored content. 
Git has multiple methods of configuration that manage the ignore list. 
Git ignore configure is discussed in further detail on the <code><a href="/git/tutorials/saving-changes/gitignore" data-event="clicked" data-uuid="4c2fda31-93" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git ignore</a></code> page.
<h2><span class="saddlebrown">&emsp;git add</span></h2>
The <code>git add</code> command adds a change in the working directory to the staging area. 
It tells Git that you want to include updates to a particular file in the next commit. 
However, <code>git add</code> doesn't really affect the repository in any significant way—changes are not actually recorded until you run <code><a href="/git/tutorials/saving-changes/git-commit" data-event="clicked" data-uuid="a6ea75ae-23" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git commit</a></code>.
In conjunction with these commands, you'll also need <code><a href="/git/tutorials/inspecting-a-repository" data-event="clicked" data-uuid="de2fbc46-55" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git status</a></code> to view the state of the working directory and the staging area.
<h2><span class="saddlebrown">&emsp;How it works</span></h2>
The <code>git add</code> and <code><a href="/git/tutorials/saving-changes/git-commit" data-event="clicked" data-uuid="9fe65418-88" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git commit</a></code> commands compose the fundamental Git workflow. 
These are the two commands that every Git user needs to understand, regardless of their team’s collaboration model. 
They are the means to record versions of a project into the repository’s history.

Developing a project revolves around the basic edit/stage/commit pattern. 
First, you edit your files in the working directory. 
When you’re ready to save a copy of the current state of the project, you stage changes with <code>git add</code>. 
After you’re happy with the staged snapshot, you commit it to the project history with <code>git commit</code>. 

The <code><a href="/git/tutorials/undoing-changes/git-reset" data-event="clicked" data-uuid="90760fc2-97" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git reset</a></code> command is used to undo a commit or staged snapshot.
In addition to <code>git add</code> and <code>git commit</code>, a third command <code><a href="/git/tutorials/syncing/git-push" data-event="clicked" data-uuid="555e5407-ff" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git push</a></code> is essential for a complete collaborative Git workflow. 
<code>git push</code> is utilized to send the committed changes to remote repositories for collaboration. 
This enables other team members to access a set of saved changes.

<img src="https://wac-cdn.atlassian.com/dam/jcr:0f27e004-f2f5-4890-921d-65fa77ba2774/01.svg?cdnVersion=217" loading="lazy" alt="Git Tutorial: git add Snapshot">The <code>git add</code> command should not be confused with <code>svn add</code>, which adds a file to the repository. 
Instead, <code>git add</code> works on the more abstract level of changes. 
This means that <code>git add</code> needs to be called every time you alter a file, whereas <code>svn add</code> only needs to be called once for each file. 
It may sound redundant, but this workflow makes it much easier to keep a project organized.
<h2><span class="saddlebrown">&emsp;The staging area</span></h2>
The primary function of the <code>git add</code> command, is to promote pending changes in the working directory, to the <code>git staging</code> area. 
The staging area is one of Git's more unique features, and it can take some time to wrap your head around it if you’re coming from an SVN (or even a Mercurial) background. 
It helps to think of it as a buffer between the working directory and the project history. 

The staging area is considered one of the <a href="/git/tutorials/undoing-changes/git-reset" data-event="clicked" data-uuid="de2bfdc7-2e" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">"three trees" of Git</a>, along with, the working directory, and the commit history.
Instead of committing all of the changes you've made since the last commit, the stage lets you group related changes into highly focused snapshots before actually committing it to the project history. 
This means you can make all sorts of edits to unrelated files, then go back and split them up into logical commits by adding related changes to the stage and commit them piece-by-piece. 
As in any revision control system, it’s important to create atomic commits so that it’s easy to track down bugs and revert changes with minimal impact on the rest of the project.
<h2><span class="saddlebrown">&emsp;Common options</span></h2>
<code>git add &lt;file></code>
Stage all changes in <code><span>&lt;</span>file></code> for the next commit.
<code>git add &lt;directory></code>

Stage all changes in <code><span>&lt;</span>directory></code> for the next commit.
<code>git add -p</code>
Begin an interactive staging session that lets you choose portions of a file to add to the next commit. 
This will present you with a chunk of changes and prompt you for a command. 

Use <code>y</code> to stage the chunk, <code>n</code> to ignore the chunk, <code>s</code> to split it into smaller chunks, <code>e</code> to manually edit the chunk, and <code>q</code> to exit.
<h2><span class="saddlebrown">&emsp;Examples</span></h2>
When you’re starting a new project, <code>git add</code> serves the same function as <code>svn import</code>. 
To create an initial commit of the current directory, use the following two commands:

<code>git add .
git commit</code>
Once you’ve got your project up-and-running, new files can be added by passing the path to <code>git add</code>:
<code>git add hello.py

git commit</code>
The above commands can also be used to record changes to existing files. 
Again, Git doesn’t differentiate between staging changes in new files vs. changes in files that have already been added to the repository.
<h2><span class="saddlebrown">&emsp;Summary</span></h2>
In review, <code>git add</code> is the first command in a chain of operations that directs Git to "save" a snapshot of the current project state, into the commit history. 
When used on its own, <code>git add</code> will promote pending changes from the working directory to the staging area. 
The <code><a href="/git/tutorials/inspecting-a-repository" data-event="clicked" data-uuid="cc09a392-9e" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git status</a></code> command is used to examine the current state of the repository and can be used to confirm a <code>git add</code> promotion. 
The <code><a href="/git/tutorials/undoing-changes/git-reset" data-event="clicked" data-uuid="cc09a392-9e" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git reset</a></code> command is used to undo a <code>git add</code>. 

The <code><a href="/git/tutorials/saving-changes/git-commit" data-event="clicked" data-uuid="cc09a392-9e" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git commit</a></code> command is then used to Commit a snapshot of the staging directory to the repositories commit history.
<h2><br><span class="orange">Git commit</span></h2>
The <code>git commit</code> command captures a snapshot of the project's currently staged changes. 
Committed snapshots can be thought of as “safe” versions of a project—Git will never change them unless you explicitly ask it to. 

Prior to the execution of <code>git commit</code>, The <code><a href="/git/tutorials/saving-changes" data-event="clicked" data-uuid="50aae23b-d3" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git add</a></code> command is used to promote or 'stage' changes to the project that will be stored in a commit. 
These two commands <code>git commit</code> and <code>git add</code> are two of the most frequently used.
<h2><span class="saddlebrown">&emsp;Git commit vs SVN commit</span></h2>
While they share the same name, <code>git commit</code> is nothing like <code>svn commit</code>. 

This shared term can be a point of confusion for Git newcomers who have a svn background, and it is important to emphasize the difference. 
To compare <code>git commit</code> vs <code>svn commit</code> is to compare a centralized application model (svn) vs a distributed application model (Git). 
In SVN, a commit pushes changes from the local SVN client, to a remote centralized shared SVN repository. 
In Git, repositories are distributed, Snapshots are committed to the local repository, and this requires absolutely no interaction with other Git repositories. 

Git commits can later be pushed to arbitrary remote repositories.
<h2><span class="saddlebrown">&emsp;How it works</span></h2>
At a high-level, Git can be thought of as a timeline management utility. 
Commits are the core building block units of a Git project timeline. 

Commits can be thought of as snapshots or milestones along the timeline of a Git project. 
Commits are created with the <code>git commit</code> command to capture the state of a project at that point in time. 
Git Snapshots are always committed to the local repository. 
This is fundamentally different from SVN, wherein the working copy is committed to the central repository. 

In contrast, Git doesn’t force you to interact with the central repository until you’re ready. 
Just as the staging area is a buffer between the working directory and the project history, each developer’s local repository is a buffer between their contributions and the central repository.
This changes the basic development model for Git users. 
Instead of making a change and committing it directly to the central repo, Git developers have the opportunity to accumulate commits in their local repo. 

This has many advantages over SVN-style collaboration: it makes it easier to split up a feature into atomic commits, keep related commits grouped together, and clean up local history before publishing it to the central repository. 
It also lets developers work in an isolated environment, deferring integration until they’re at a convenient point to merge with other users. 
While isolation and deferred integration are individually beneficial, it is in a team's best interest to integrate frequently and in small units. 
For more information regarding best practices for Git team collaboration read how teams structure their <a href="/git/tutorials/comparing-workflows" data-event="clicked" data-uuid="c1eab9eb-04" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Git workflow</a>.
<h2><span class="saddlebrown">&emsp;Snapshots, not differences</span></h2>
Aside from the practical distinctions between SVN and Git, their underlying implementation also follows entirely divergent design philosophies. 
Whereas SVN tracks differences of a file, Git’s version control model is based on snapshots. 
For example, a SVN commit consists of a diff compared to the original file added to the repository. 

Git, on the other hand, records the entire contents of each file in every commit.
<img src="https://wac-cdn.atlassian.com/dam/jcr:7406fe56-d36d-44cf-92e3-b28e4bae36f8/02.svg?cdnVersion=217" loading="lazy" alt="Git Tutorial: Snapshots, Not Differences">This makes many Git operations much faster than SVN, since a particular version of a file doesn’t have to be “assembled” from its diffs—the complete revision of each file is immediately available from Git's internal database.
Git's snapshot model has a far-reaching impact on virtually every aspect of its version control model, affecting everything from its branching and merging tools to its collaboration work-flows.
<h2><span class="saddlebrown">&emsp;Common options</span></h2>
<code>git commit</code>
Commit the staged snapshot. 
This will launch a text editor prompting you for a commit message. 
After you’ve entered a message, save the file and close the editor to create the actual commit.

<code>git commit -a</code>
Commit a snapshot of all changes in the working directory. 
This only includes modifications to tracked files (those that have been added with <code>git add</code> at some point in their history).
<code>git commit -m "commit message"</code>

A shortcut command that immediately creates a commit with a passed commit message. 
By default, <code>git commit</code> will open up the locally configured text editor, and prompt for a commit message to be entered. 
Passing the <code>-m</code> option will forgo the text editor prompt in-favor of an inline message.
<code>git commit -am "commit message"</code>

A power user shortcut command that combines the <code>-a</code> and <code>-m</code> options. 
This combination immediately creates a commit of all the staged changes and takes an inline commit message.
<code>git commit --amend</code>
This option adds another level of functionality to the commit command. 

Passing this option will modify the last commit. 
Instead of creating a new commit, staged changes will be added to the previous commit. 
This command will open up the system's configured text editor and prompt to change the previously specified commit message.
<h2><span class="saddlebrown">&emsp;Examples</span></h2>
<h3>&emsp;Saving changes with a commit</h3>
The following example assumes you’ve edited some content in a file called <code>hello.py</code> on the current branch, and are ready to commit it to the project history. 
First, you need to stage the file with <code>git add</code>, then you can commit the staged snapshot.
<code>git add hello.py</code>

This command will add <code>hello.py</code> to the Git staging area. 
We can examine the result of this action by using the <code>git status</code> command.
<code>git status
On branch main

Changes to be committed:
(use "git reset HEAD &lt;file>..." to unstage)
 new file: hello.py</code>
The green output new file: <code>hello.py</code> indicates that <code>hello.py</code> will be saved with the next commit. 

From the commit is created by executing:
<code>git commit</code>
This will open a text editor (customizable via <code>git config</code>) asking for a commit log message, along with a list of what’s being committed:
<code># Please enter the commit message for your changes. 

Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch main
# Changes to be committed:

# (use "git reset HEAD ..." to unstage)
#
#modified: hello.py</code>
Git doesn't require commit messages to follow any specific formatting constraints, but the canonical format is to summarize the entire commit on the first line in less than 50 characters, leave a blank line, then a detailed explanation of what’s been changed. 

For example:
<code>Change the message displayed by hello.py
- Update the sayHello() function to output the user's name
- Change the sayGoodbye() function to a friendlier message</code>

It is a common practice to use the first line of the commit message as a subject line, similar to an email. 
The rest of the log message is considered the body and used to communicate details of the commit change set. 
Note that many developers also like to use the present tense in their commit messages. 
This makes them read more like actions on the repository, which makes many of the history-rewriting operations more intuitive.
<h2><span class="saddlebrown">&emsp;How to update (amend) a commit</span></h2>
To continue with the <code>hello.py</code> example above. 
Let's make further updates to <code>hello.py</code> and execute the following:
<code>git add hello.py

git commit --amend</code>
This will once again, open up the configured text editor. 
This time, however, it will be pre-filled with the commit message we previously entered. 
This indicates that we are not creating a new commit, but editing the last.
<h2><span class="saddlebrown">&emsp;Summary</span></h2>
The <code>git commit</code> command is one of the core primary functions of Git. 
Prior use of the <code>git add</code> command is required to select the changes that will be staged for the next commit. 
Then <code>git commit</code> is used to create a snapshot of the staged changes along a timeline of a Git projects history. 

Learn more about <code><a href="/git/tutorials/saving-changes" data-event="clicked" data-uuid="6e151a06-dc" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git add</a> </code>usage on the accompanying page. 
The <code><a href="/git/tutorials/inspecting-a-repository" data-event="clicked" data-uuid="6e151a06-dc" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git status</a></code> command can be used to explore the state of the staging area and pending commit.
The commit model of SVN and Git are significantly different but often confused, because of the shared terminology. 
If you are coming to Git from a personal history of SVN usage, it is good to learn that in Git, commits are cheap and should be used frequently. 

Whereas SVN commits are an expensive operation that makes a remote request, Git commits are done locally and with a more efficient algorithm.
<h2><br><span class="orange">Git diff</span></h2>
<h2><span class="saddlebrown">&emsp;Comparing changes with git diff</span></h2>
Diffing is a function that takes two input data sets and outputs the changes between them. 

<code>git diff</code> is a multi-use Git command that when executed runs a diff function on Git data sources. 
These data sources can be commits, branches, files and more. 
This document will discuss common invocations of <code>git diff</code> and diffing work flow patterns. 
The <code>git diff</code> command is often used along with <code>git status</code> and <code>git log</code> to analyze the current state of a Git repo.
<h2><span class="saddlebrown">&emsp;Reading diffs: outputs</span></h2>
<h3>&emsp;Raw output format</h3>
The following examples will be executed in a simple repo. 
The repo is created with the commands below:

<code>$:> mkdir diff_test_repo
$:> cd diff_test_repo
$:> touch diff_test.txt
$:> echo "this is a git diff test example" > diff_test.txt

$:> git init .
Initialized empty Git repository in /Users/kev/code/test/.git/
$:> git add diff_test.txt
$:> git commit -am"add diff test file"

[main (root-commit) 6f77fc3] add diff test file
1 file changed, 1 insertion(+)
create mode 100644 diff_test.txt</code>
If we execute <code>git diff</code> at this point, there will be no output. 

This is expected behavior as there are no changes in the repo to diff. 
Once the repo is created and we've added the <code>diff_test.txt</code> file, we can change the contents of the file to start experimenting with diff output.
<code>$:> echo "this is a diff example" > diff_test.txt</code>
Executing this command will change the content of the <code>diff_test.txt</code> file. 

Once modified, we can view a diff and analyze the output. 
Now executing <code>git diff</code> will produce the following output:
<code>diff --git a/diff_test.txt b/diff_test.txt
index 6b0c6cf..b37e70a 100644

--- a/diff_test.txt
+++ b/diff_test.txt
@@ -1 +1 @@
-this is a git diff test example

+this is a diff example</code>
Let us now examine a more detailed breakdown of the diff output.
<h3>&emsp;1. 
Comparison input</h3>

<code>diff --git a/diff_test.txt b/diff_test.txt</code>
This line displays the input sources of the diff. 
We can see that <code>a/diff_test.txt</code> and <code>b/diff_test.txt</code> have been passed to the diff.
<h3>&emsp;2. 

Meta data</h3>
<code>index 6b0c6cf..b37e70a 100644</code>
This line displays some internal Git metadata. 
You will most likely not need this information. 

The numbers in this output correspond to Git object version hash identifiers.
<h3>&emsp;3. 
Markers for changes</h3>
<code>--- a/diff_test.txt

+++ b/diff_test.txt</code>
These lines are a legend that assigns symbols to each diff input source. 
In this case, changes from <code>a/diff_test.txt</code> are marked with a <code>---</code> and the changes from <code>b/diff_test.txt</code> are marked with the <code>+++</code> symbol.
<h3>&emsp;4. 

Diff chunks</h3>
The remaining diff output is a list of diff 'chunks'. 
A diff only displays the sections of the file that have changes. 
In our current example, we only have one chunk as we are working with a simple scenario. 

Chunks have their own granular output semantics.
<code>@@ -1 +1 @@
-this is a git diff test example
+this is a diff example</code>

The first line is the chunk header. 
Each chunk is prepended by a header inclosed within <code>@@</code> symbols. 
The content of the header is a summary of changes made to the file. 
In our simplified example, we have -1 +1 meaning line one had changes. 

In a more realistic diff, you would see a header like:
<code>@@ -34,6 +34,8 @@</code>
In this header example, 6 lines have been extracted starting from line number 34. 
Additionally, 8 lines have been added starting at line number 34.

The remaining content of the diff chunk displays the recent changes. 
Each changed line is prepended with a <code>+</code> or <code>-</code> symbol indicating which version of the diff input the changes come from. 
As we previously discussed, <code>-</code> indicates changes from the <code>a/diff_test.txt</code> and + indicates changes from <code>b/diff_test.txt</code>.
<h2><span class="saddlebrown">&emsp;Highlighting changes</span></h2>
<h3>&emsp;1. 
<code>git diff --color-words</code></h3>
<code>git diff</code> also has a special mode for highlighting changes with much better granularity: <code>‐‐color-words</code>. 
This mode tokenizes added and removed lines by whitespace and then diffs those.

<code>$:> git diff --color-words
diff --git a/diff_test.txt b/diff_test.txt
index 6b0c6cf..b37e70a 100644
--- a/diff_test.txt

+++ b/diff_test.txt
@@ -1 +1 @@
this is agit difftest example</code>
Now the output displays only the color-coded words that have changed.

<h3>&emsp;2. 
<code>git diff-highlight</code></h3>
If you clone the git source, you’ll find a sub-directory called contrib. 
It contains a bunch of git-related tools and other interesting bits and pieces that haven’t yet been promoted to git core. 

One of these is a Perl script called diff-highlight. 
Diff-highlight pairs up matching lines of diff output and highlights sub-word fragments that have changed.
<code>$:> git diff | /your/local/path/to/git-core/contrib/diff-highlight/diff-highlight
diff --git a/diff_test.txt b/diff_test.txt

index 6b0c6cf..b37e70a 100644
--- a/diff_test.txt
+++ b/diff_test.txt
@@ -1 +1 @@

-this is a git diff test example
+this is a diff example</code>
Now we’ve pared down our diff to the smallest possible change.
<h2><span class="saddlebrown">&emsp;Diffing binary files</span></h2>
In addition to the text file utilities we have thus far demonstrated, <code>git diff</code> can be run on binary files. 
Unfortunately, the default output is not very helpful.
<code>$:> git diff
Binary files a/script.pdf and b/script.pdf differ</code>

Git does have a feature that allows you to specify a shell command to transform the content of your binary files into text prior to performing the diff. 
It does require a little set up though. 
First, you need to specify a textconv filter describing how to convert a certain type of binary to text. 
We're using a simple utility called pdftohtml (available via homebrew) to convert my PDFs into human readable HTML. 

You can set this up for a single repository by editing your <code>.git/config</code> file, or globally by editing <code>~ /.gitconfig</code>
<code>[diff "pdfconv"]
textconv=pdftohtml -stdout</code>
Then all you need to do is associate one or more file patterns with our pdfconv filter. 

You can do this by creating a <code>.gitattributes</code> file in the root of your repository.
<code>*.pdf diff=pdfconv</code>
Once configured, <code>git diff</code> will first run the binary file through the configured converter script and diff the converter output. 
The same technique can be applied to get useful diffs from all sorts of binary files, for example: zips, jars and other archives: using <code>unzip -l</code> (or similar) in place of pdf2html will show you paths that have been added or removed between commits images: exiv2 can be used to show metadata changes such as image dimensions documents: conversion tools exist for transforming .odf, .doc and other document formats to plain text. 

In a pinch, strings will often work for binary files where no formal converter exists.
<h2><span class="saddlebrown">&emsp;Comparing files: git diff file</span></h2>
The <code>git diff</code> command can be passed an explicit file path option. 
When a file path is passed to <code>git diff</code> the diff operation will be scoped to the specified file. 

The below examples demonstrate this usage.
<code>git diff HEAD ./path/to/file</code>
This example is scoped to <code>./path/to/file</code> when invoked, it will compare the specific changes in the working directory, against the index, showing the changes that are not staged yet. 
By default <code>git diff</code> will execute the comparison against <code>HEAD</code>. 

Omitting <code>HEAD</code> in the example above <code>git diff ./path/to/file</code> has the same effect.
<code>git diff --cached ./path/to/file</code>
When <code>git diff</code> is invoked with the <code>--cached</code> option the diff will compare the staged changes with the local repository. 
The <code>--cached</code> option is synonymous with <code>--staged</code>.
<h2><span class="saddlebrown">&emsp;Comparing all changes</span></h2>
Invoking <code>git diff</code> without a file path will compare changes across the entire repository. 
The above, file specific examples, can be invoked without the <code>./path/to/file</code> argument and have the same output results across all files in the local repo.
<h2><span class="saddlebrown">&emsp;Changes since last commit</span></h2>
By default <code>git diff</code> will show you any uncommitted changes since the last commit.
<code>git diff</code>
<h2><span class="saddlebrown">&emsp;Comparing files between two different commits</span></h2>
<code>git diff</code> can be passed Git refs to commits to diff. 

Some example refs are, <code>HEAD</code>, tags, and branch names. 
Every commit in Git has a commit ID which you can get when you execute <code>GIT LOG</code>. 
You can also pass this commit ID to <code>git diff</code>.
<code>git log --prety=oneline

957fbc92b123030c389bf8b4b874522bdf2db72c add feature
ce489262a1ee34340440e55a0b99ea6918e19e7a rename some classes
6b539f280d8b0ec4874671bae9c6bed80b788006 refactor some code for feature
646e7863348a427e1ed9163a9a96fa759112f102 add some copy to body

$:> git diff 957fbc92b123030c389bf8b4b874522bdf2db72c ce489262a1ee34340440e55a0b99ea6918e19e7a</code>
<h2><span class="saddlebrown">&emsp;Comparing branches</span></h2>
<h3>&emsp;Comparing two branches</h3>
Branches are compared like all other ref inputs to <code>git diff</code>

<code>git diff branch1..other-feature-branch</code>
This example introduces the dot operator. 
The two dots in this example indicate the diff input is the tips of both branches. 
The same effect happens if the dots are omitted and a space is used between the branches. 

Additionally, there is a three dot operator:
<code>git diff branch1...other-feature-branch</code>
The three dot operator initiates the diff by changing the first input parameter <code>branch1</code>. 
It changes <code>branch1</code> into a ref of the shared common ancestor commit between the two diff inputs, the shared ancestor of <code>branch1</code> and other-feature-branch. 

The last parameter input parameter remains unchanged as the tip of other-feature-branch.
<h2><span class="saddlebrown">&emsp;Comparing files from two branches</span></h2>
To compare a specific file across branches, pass in the path of the file as the third argument to <code>git diff</code>
<code>git diff main new_branch ./diff_test.txt</code>
<h2><span class="saddlebrown">&emsp;Summary</span></h2>
This page disscused the Git diffing process and the <code>git diff</code> command. 
We discussed how to read <code>git diff</code> output and the various data included in the output. 
Examples were provided on how to alter the <code>git diff</code> output with highlighting and colors. 

We discussed different diffing strategies such as how to diff files in branches and specific commits. 
In addition to the <code>git diff</code> command, we also used <code>git log</code> and <code>git checkout</code>.
<h2><br><span class="orange">Git stash</span></h2>
<code>git stash</code> temporarily shelves (or <em>stashes</em>) changes you've made to your working copy so you can work on something else, and then come back and re-apply them later on. 

Stashing is handy if you need to quickly switch context and work on something else, but you're mid-way through a code change and aren't quite ready to commit.
Git Stash 
<a href="#stashing-your-work" data-event="clicked" data-uuid="230bc552-c7" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Stashing your work</a>
<a href="#re-applying-your-stashed-changes" data-event="clicked" data-uuid="230bc552-c7" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Re-applying your stashed changes</a>

<a href="#stashing-untracked-or-ignored" data-event="clicked" data-uuid="230bc552-c7" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Stashing untracked or ignored files</a>
<a href="#managing-multiple-stashes" data-event="clicked" data-uuid="230bc552-c7" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Managing multiple stashes</a>
<a href="#viewing-stash-diffs" data-event="clicked" data-uuid="230bc552-c7" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Viewing stash diffs</a>
<a href="#partial-stashes" data-event="clicked" data-uuid="230bc552-c7" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Partial stashes</a>

<a href="#creating-a-branch-from-your-stash" data-event="clicked" data-uuid="230bc552-c7" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Creating a branch from your stash</a>
<a href="#cleaning-up-your-stash" data-event="clicked" data-uuid="230bc552-c7" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Cleaning up your stash</a>
<a href="#how-git-stash-works" data-event="clicked" data-uuid="230bc552-c7" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">How git stash works</a>
<h2><span class="saddlebrown">&emsp;Stashing your work</span></h2>
The <code>git stash</code> command takes your uncommitted changes (both staged and unstaged), saves them away for later use, and then reverts them from your working copy. 
For example:
<code>$ git status
On branch main

Changes to be committed:
new file:   style.css
Changes not staged for commit:
modified:   index.html

$ git stash
Saved working directory and index state WIP on main: 5002d47 our new homepage
HEAD is now at 5002d47 our new homepage
$ git status

On branch main
nothing to commit, working tree clean</code>
At this point you're free to make changes, create new commits, switch branches, and perform any other Git operations; then come back and re-apply your stash when you're ready.
Note that the stash is local to your Git repository; stashes are not transferred to the server when you push.
<h2><span class="saddlebrown">&emsp;Re-applying your stashed changes</span></h2>
You can reapply previously stashed changes with <code>git stash pop</code>:
<code>$ git status
On branch main

nothing to commit, working tree clean
$ git stash pop
On branch main
Changes to be committed:

new file:   style.css
Changes not staged for commit:
modified:   index.html
Dropped refs/stash@{0} (32b3aa1d185dfe6d57b3c3cc3b32cbf3e380cc6a)</code>

<em>Popping</em> your stash removes the changes from your stash and reapplies them to your working copy.
Alternatively, you can reapply the changes to your working copy <em>and</em> keep them in your stash with <code>git stash apply</code>:
<code>$ git stash apply
On branch main

Changes to be committed:
new file:   style.css
Changes not staged for commit:
modified:   index.html</code>

This is useful if you want to apply the same stashed changes to multiple branches. 
Now that you know the basics of stashing, there is one caveat with <code>git stash</code> you need to be aware of: by default Git <em>won't</em> stash changes made to untracked or ignored files.
<h2><span class="saddlebrown">&emsp;Stashing untracked or ignored files</span></h2>
By default, running <code>git stash</code> will stash:

changes that have been added to your index (staged changes)
changes made to files that are currently tracked by Git (unstaged changes)
But it will <strong>not</strong> stash:
new files in your working copy that have not yet been staged

files that have been <a href="/git/tutorials/saving-changes/gitignore" data-event="clicked" data-uuid="17b204f2-9e" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">ignored</a>
So if we add a third file to our example above, but don't stage it (i.e. 
we don't run <code>git add</code>), <code>git stash</code> won't stash it.
<code>$ script.js

$ git status
On branch main
Changes to be committed:
new file:   style.css

Changes not staged for commit:
modified:   index.html
Untracked files:
script.js

$ git stash
Saved working directory and index state WIP on main: 5002d47 our new homepage
HEAD is now at 5002d47 our new homepage
$ git status

On branch main
Untracked files:
script.js</code>
Adding the <code>-u</code> option (or <code>--include-untracked</code>) tells <code>git stash</code> to also stash your untracked files:

<code>$ git status
On branch main
Changes to be committed:
new file:   style.css

Changes not staged for commit:
modified:   index.html
Untracked files:
script.js

$ git stash -u
Saved working directory and index state WIP on main: 5002d47 our new homepage
HEAD is now at 5002d47 our new homepage
$ git status

On branch main
nothing to commit, working tree clean</code>
You can include changes to <a href="https://www.atlassian.com/git/tutorials/gitignore" data-event="clicked" data-uuid="ab2af912-f8" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">ignored</a> files as well by passing the <code>-a</code> option (or <code>--all</code>) when running <code>git stash</code>.
<img src="https://wac-cdn.atlassian.com/dam/jcr:d6fec41a-dc66-4af6-8b0f-c23d271eaf8e/01.svg?cdnVersion=217" loading="lazy" alt="Git Stash options">
<h2>&emsp;Managing multiple stashes</h2>
You aren't limited to a single stash. 
You can run <code>git stash</code> several times to create multiple stashes, and then use <code>git stash list</code> to view them. 
By default, stashes are identified simply as a "WIP" – work in progress – on top of the branch and commit that you created the stash from. 
After a while it can be difficult to remember what each stash contains:

<code>$ git stash list
stash@{0}: WIP on main: 5002d47 our new homepage
stash@{1}: WIP on main: 5002d47 our new homepage
stash@{2}: WIP on main: 5002d47 our new homepage</code>

To provide a bit more context, it's good practice to annotate your stashes with a description, using <code>git stash save "message"</code>:
<code>$ git stash save "add style to our site"
Saved working directory and index state On main: add style to our site
HEAD is now at 5002d47 our new homepage

$ git stash list
stash@{0}: On main: add style to our site
stash@{1}: WIP on main: 5002d47 our new homepage
stash@{2}: WIP on main: 5002d47 our new homepage</code>

By default, <code>git stash pop</code> will re-apply the most recently created stash: <code>stash@{0}</code>
You can choose which stash to re-apply by passing its identifier as the last argument, for example:
<code>$ git stash pop stash@{2}</code>
<h2><span class="saddlebrown">&emsp;Viewing stash diffs</span></h2>
You can view a summary of a stash with <code>git stash show</code>:
<code>$ git stash show
index.html | 1 +
style.css | 3 +++

2 files changed, 4 insertions(+)</code>
Or pass the <code>-p</code> option (or <code>--patch</code>) to view the full diff of a stash:
<code>$ git stash show -p
diff --git a/style.css b/style.css

new file mode 100644
index 0000000..d92368b
--- /dev/null
+++ b/style.css

@@ -0,0 +1,3 @@
+* {
+  text-decoration: blink;
+}

diff --git a/index.html b/index.html
index 9daeafb..ebdcbd2 100644
--- a/index.html
+++ b/index.html

@@ -1 +1,2 @@
+&lt;link rel="stylesheet" href="style.css"/></code>
<h2><span class="saddlebrown">&emsp;Partial stashes</span></h2>
You can also choose to stash just a single file, a collection of files, or individual changes from within files. 

If you pass the <code>-p</code> option (or <code>--patch</code>) to <code>git stash</code>, it will iterate through each changed "hunk" in your working copy and ask whether you wish to stash it:
<code>$ git stash -p
diff --git a/style.css b/style.css
new file mode 100644

index 0000000..d92368b
--- /dev/null
+++ b/style.css
@@ -0,0 +1,3 @@

+* {
+  text-decoration: blink;
+}
Stash this hunk [y,n,q,a,d,/,e,?]? y

diff --git a/index.html b/index.html
index 9daeafb..ebdcbd2 100644
--- a/index.html
+++ b/index.html

@@ -1 +1,2 @@
+&lt;link rel="stylesheet" href="style.css"/>
Stash this hunk [y,n,q,a,d,/,e,?]? n</code>
<img src="https://wac-cdn.atlassian.com/dam/jcr:4f32476c-e84f-41b3-a7d9-1b5a70acb22b/02.svg?cdnVersion=217" loading="lazy" alt="Git Stash -p">You can hit <strong>?</strong> for a full list of hunk commands. 

Commonly useful ones are:
<table>
<thead><tr>
<th><strong>Command</strong></th> <th><strong>Description</strong></th> </tr></thead>

<thead>
<tr>
<td><em>/</em></td> <td>search for a hunk by regex</td> </tr>
<tr>

<td><em>?</em></td> <td>help</td> </tr>
<tr>
<td><em>n</em></td> <td>don't stash this hunk</td> </tr>
<tr>

<td><em>q</em></td> <td>quit (any hunks that have already been selected will be stashed)</td> </tr>
<tr>
<td><em>s</em></td> <td>split this hunk into smaller hunks</td> </tr>
<tr>

<td><em>y</em></td> <td>stash this hunk</td> </tr>
</thead>
</table>
There is no explicit "abort" command, but hitting <code>CTRL-C</code>(SIGINT) will abort the stash process.
<h2><span class="saddlebrown">&emsp;Creating a branch from your stash</span></h2>
If the changes on your branch diverge from the changes in your stash, you may run into conflicts when popping or applying your stash. 
Instead, you can use <code>git stash branch</code> to create a new branch to apply your stashed changes to:
<code>$ git stash branch add-stylesheet stash@{1}

Switched to a new branch 'add-stylesheet'
On branch add-stylesheet
Changes to be committed:
new file:   style.css

Changes not staged for commit:
modified:   index.html
Dropped refs/stash@{1} (32b3aa1d185dfe6d57b3c3cc3b32cbf3e380cc6a)</code>
This checks out a new branch based on the commit that you created your stash from, and then pops your stashed changes onto it.
<h2><span class="saddlebrown">&emsp;Cleaning up your stash</span></h2>
If you decide you no longer need a particular stash, you can delete it with <code>git stash drop</code>:
<code>$ git stash drop stash@{1}
Dropped stash@{1} (17e2697fd8251df6163117cb3d58c1f62a5e7cdb)</code>

Or you can delete all of your stashes with:
<code>$ git stash clear</code>
<h2><span class="saddlebrown">&emsp;How git stash works</span></h2>
If you just wanted to know how to use <code>git stash</code>, you can stop reading here. 

But if you're curious about how Git (and <code>git stash</code>) works under the hood, read on!
Stashes are actually encoded in your repository as commit objects. 
The special ref at <code>.git/refs/stash</code> points to your most recently created stash, and previously created stashes are referenced by the <code>stash</code> ref's reflog. 
This is why you refer to stashes by <code>stash@{n}:</code> you're actually referring to the nth reflog entry for the <code>stash</code> ref. 

Since a stash is just a commit, you can inspect it with <code>git log</code>:
<code>$ git log --oneline --graph stash@{0}
*-. 
953ddde WIP on main: 5002d47 our new homepage

|\ \ 
| | * 24b35a1 untracked files on main: 5002d47 our new homepage
| * 7023dd4 index on main: 5002d47 our new homepage
|/ 

* 5002d47 our new homepage</code>
Depending on what you stashed, a single <code>git stash</code> operation creates either two or three new commits. 
The commits in the diagram above are:
<code>stash@{0}</code>, a new commit to store the tracked files that were in your working copy when you ran <code>git stash</code>

<code>stash@{0}</code>'s first parent, the pre-existing commit that was at HEAD when you ran <code>git stash</code>
<code>stash@{0}</code>'s second parent, a new commit representing the index when you ran <code>git stash</code>
<code>stash@{0}</code>'s third parent, a new commit representing untracked files that were in your working copy when you ran <code>git stash</code>. 
This third parent only created if: 

your working copy actually contained untracked files; and
you specified the <code>--include-untracked</code> or <code>--all</code> option when invoked <code>git stash</code>.
How <code>git stash</code> encodes your worktree and index as commits:
Before stashing, your worktree may contain changes to tracked files, untracked files, and ignored files. 

Some of these changes may also be staged in the index.
<img alt="Before stashing" src="https://wac-cdn.atlassian.com/dam/jcr:3a2ede93-1f2d-45ae-9e0b-167cc0362f37/03.svg?cdnVersion=217"> 
 Invoking <code>git stash</code> encodes any changes to tracked files as two new commits in your DAG: one for unstaged changes, and one for changes staged in the index. 
The special <code>refs/stash</code> ref is updated to point to them.

<img alt="Git stash" src="https://wac-cdn.atlassian.com/dam/jcr:35edaf68-e8b1-484e-b5f0-292c532f048a/04.svg?cdnVersion=217"> 
 Using the <code>--include-untracked</code> option also encodes any changes to untracked files as an additional commit.
<img alt="Git stash --include-untracked" src="https://wac-cdn.atlassian.com/dam/jcr:f7dd5493-a98d-449e-ae37-146d6270ccf7/05.svg?cdnVersion=217"> 
 Using the <code>--all</code> option includes changes to any ignored files alongside changes to untracked files in the same commit.

<img alt="Git Stash --all" src="https://wac-cdn.atlassian.com/dam/jcr:446fad60-0ff5-4383-8177-a5fc2813364d/06.svg?cdnVersion=217" title="Git Stash --all">  
When you run <code>git stash pop</code>, the changes from the commits above are used to update your working copy and index, and the stash reflog is shuffled to remove the popped commit. 
Note that the popped commits aren't immediately deleted, but do become candidates for future garbage collection.
<h2><br><span class="orange">.gitignore</span></h2>
Git sees every file in your working copy as one of three things:
tracked - a file which has been previously staged or committed;
untracked - a file which <em>has not</em> been staged or committed; or
ignored - a file which Git has been explicitly told to ignore.

Ignored files are usually build artifacts and machine generated files that can be derived from your repository source or should otherwise not be committed. 
Some common examples are:
dependency caches, such as the contents of <code>/node_modules</code> or <code>/packages</code>
compiled code, such as <code>.o</code>, <code>.pyc</code>, and <code>.class</code> files

build output directories, such as <code>/bin</code>, <code>/out</code>, or <code>/target</code>
files generated at runtime, such as <code>.log</code>, <code>.lock</code>, or <code>.tmp</code>
hidden system files, such as <code>.DS_Store</code> or <code>Thumbs.db</code>
personal IDE config files, such as <code>.idea/workspace.xml</code>

Ignored files are tracked in a special file named <code>.gitignore</code> that is checked in at the root of your repository. 
There is no explicit git ignore command: instead the <code>.gitignore</code> file must be edited and committed by hand when you have new files that you wish to ignore. 
<code>.gitignore</code> files contain patterns that are matched against file names in your repository to determine whether or not they should be ignored.
Ignoring files in Git 

<a href="#git-ignore-patterns" data-event="clicked" data-uuid="4a21e395-72" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Git ignore patterns</a>
<a href="#shared" data-event="clicked" data-uuid="4a21e395-72" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Shared .gitignore files in your repository</a>
<a href="#personal-git-ignore-rules" data-event="clicked" data-uuid="4a21e395-72" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Personal Git ignore rules</a>
<a href="#global-git-ignore-rules" data-event="clicked" data-uuid="4a21e395-72" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Global Git ignore rules</a>

<a href="#ignoring-a-previously-committed" data-event="clicked" data-uuid="4a21e395-72" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Ignoring a previously committed file</a>
<a href="#committing-an-ignored-file" data-event="clicked" data-uuid="4a21e395-72" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Committing an ignored file</a>
<a href="#stashing-an-ignored-file" data-event="clicked" data-uuid="4a21e395-72" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Stashing an ignored file</a>
<a href="#debugging" data-event="clicked" data-uuid="4a21e395-72" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Debugging .gitignore files</a>
<h2><span class="saddlebrown">&emsp;Git ignore patterns</span></h2>
<code>.gitignore</code> uses <a href="http://linux.die.net/man/7/glob" data-event="clicked" data-uuid="28b4a0d0-ea" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">globbing patterns</a> to match against file names. 
You can construct your patterns using various symbols:
<table>

<thead><tr>
<th>Pattern</th> <th>Example matches</th> <th>Explanation*</th> </tr></thead>
<tbody>
<tr>

<td> <code>**/logs </code> </td> <td> <code>logs/debug.log</code>
<code>logs/monday/foo.bar</code>
<code>build/logs/debug.log</code> </td> <td> You can prepend a pattern with a double asterisk to match directories anywhere in the repository. 
</td> </tr>

<tr>
<td> <code>**/logs/debug.log </code> </td> <td> <code>logs/debug.log</code>
<code>build/logs/debug.log</code>
<em>but not</em>

<code>logs/build/debug.log</code> </td> <td> You can also use a double asterisk to match files based on their name and the name of their parent directory. 
</td> </tr>
<tr>
<td> <code>*.log</code> </td> <td> <code>debug.log</code>

<code>foo.log</code>
<code>.log</code>
<code>logs/debug.log</code> </td> <td> An asterisk is a wildcard that matches zero or more characters. 
</td> </tr>

<tr>
<td> <code>*.log </code>
<code>!important.log</code> </td> <td> <code>debug.log</code>
<code>trace.log</code>

<em>but not</em>
<code>important.log</code>
<code>logs/important.log</code> </td> <td> Prepending an exclamation mark to a pattern negates it. 
If a file matches a pattern, but <em>also</em> matches a negating pattern defined later in the file, it will not be ignored. 

</td> </tr>
<tr>
<td> <code>*.log </code>
<code>!important/*.log</code>

<code>trace.*</code> </td> <td> <code>debug.log</code>
<code>important/trace.log</code>
<em>but not</em>
<code>important/debug.log</code> </td> <td> Patterns defined after a negating pattern will re-ignore any previously negated files. 

</td> </tr>
<tr>
<td> <code>/debug.log</code> </td> <td> <code>debug.log</code>
<em>but not</em>

<code>logs/debug.log</code> </td> <td> Prepending a slash matches files only in the repository root. 
</td> </tr>
<tr>
<td> <code>debug.log</code> </td> <td> <code>debug.log</code>

<code>logs/debug.log</code> </td> <td> By default, patterns match files in any directory </td> </tr>
<tr>
<td> <code>debug?.log </code> </td> <td> <code>debug0.log</code>
<code>debugg.log</code>

<em>but not</em>
<code>debug10.log</code> </td> <td> A question mark matches exactly one character. 
</td> </tr>
<tr>

<td> <code>debug[0-9].log </code> </td> <td> <code>debug0.log</code>
<code>debug1.log</code>
<em>but not</em>
<code>debug10.log</code> </td> <td> Square brackets can also be used to match a single character from a specified range. 

</td> </tr>
<tr>
<td> <code>debug[01].log </code> </td> <td> <code>debug0.log</code>
<code>debug1.log</code>

<em>but not </em>
<code>debug2.log</code>
<code>debug01.log</code> </td> <td> Square brackets match a single character form the specified set. 
</td> </tr>

<tr>
<td> <code>debug[!01].log </code> </td> <td> <code>debug2.log</code>
<em>but not</em>
<code>debug0.log</code>

<code>debug1.log</code>
<code>debug01.log</code> </td> <td> An exclamation mark can be used to match any character except one from the specified set. 
</td> </tr>
<tr>

<td> <code>debug[a-z].log </code> </td> <td> <code>debuga.log</code>
<code>debugb.log</code>
<em>but not</em>
<code>debug1.log</code> </td> <td> Ranges can be numeric or alphabetic. 

</td> </tr>
<tr>
<td> <code>logs</code> </td> <td> <code>logs</code>
<code>logs/debug.log</code>

<code>logs/latest/foo.bar</code>
<code>build/logs</code>
<code>build/logs/debug.log</code> </td> <td> If you don't append a slash, the pattern will match both files and the contents of directories with that name. 
In the example matches on the left, both directories and files named <em>logs</em> are ignored </td> </tr>

<tr>
<td> logs/ </td> <td> <code>logs/debug.log</code>
<code>logs/latest/foo.bar</code>
<code>build/logs/foo.bar</code>

<code>build/logs/latest/debug.log</code> </td> <td> Appending a slash indicates the pattern is a directory. 
The entire contents of any directory in the repository matching that name – including all of its files and subdirectories – will be ignored </td> </tr>
<tr>
<td> <code>logs/ </code>

<code>!logs/important.log</code> </td> <td> <code>logs/debug.log</code>
<code>logs/important.log</code> </td> <td> Wait a minute! Shouldn't <code>logs/important.log</code> be negated in the example on the left
Nope! Due to a performance-related quirk in Git, you <em>can not</em> negate a file that is ignored due to a pattern matching a directory </td> </tr>
<tr>

<td> <code>logs/**/debug.log </code> </td> <td> <code>logs/debug.log</code>
<code>logs/monday/debug.log</code>
<code>logs/monday/pm/debug.log</code> </td> <td> A double asterisk matches zero or more directories. 
</td> </tr>

<tr>
<td> <code>logs/*day/debug.log </code> </td> <td> <code>logs/monday/debug.log</code>
<code>logs/tuesday/debug.log</code>
<em>but not</em>

<code>logs/latest/debug.log</code> </td> <td> Wildcards can be used in directory names as well. 
</td> </tr>
<tr>
<td> <code>logs/debug.log</code> </td> <td> <code>logs/debug.log</code>

<em>but not</em>
<code>debug.log</code>
<code>build/logs/debug.log</code> </td> <td> Patterns specifying a file in a particular directory are relative to the repository root. 
(You can prepend a slash if you like, but it doesn't do anything special.) </td> </tr>

</tbody>
</table>
** these explanations assume your .gitignore file is in the top level directory of your repository, as is the convention. 
If your repository has multiple .gitignore files, simply mentally replace "repository root" with "directory containing the .gitignore file" (and consider unifying them, for the sanity of your team).*

In addition to these characters, you can use # to include comments in your <code>.gitignore</code> file:
<code># ignore all logs
*.log</code>
You can use \ to escape <code>.gitignore</code> pattern characters if you have files or directories containing them:

<code># ignore the file literally named foo[01].txt
foo\[01\].txt</code>
<h2><span class="saddlebrown">&emsp;Shared .gitignore files in your repository</span></h2>
Git ignore rules are usually defined in a <code>.gitignore</code> file at the root of your repository. 

However, you can choose to define multiple <code>.gitignore</code> files in different directories in your repository. 
Each pattern in a particular <code>.gitignore</code> file is tested relative to the directory containing that file. 
However the convention, and simplest approach, is to define a single <code>.gitignore</code> file in the root. 
As your <code>.gitignore</code> file is checked in, it is versioned like any other file in your repository and shared with your teammates when you push. 

Typically you should only include patterns in <code>.gitignore</code> that will benefit other users of the repository.
<h2><span class="saddlebrown">&emsp;Personal Git ignore rules</span></h2>
You can also define personal ignore patterns for a particular repository in a special file at <code>.git/info/exclude</code>. 
These are not versioned, and not distributed with your repository, so it's an appropriate place to include patterns that will likely only benefit you. 

For example if you have a custom logging setup, or special development tools that produce files in your repository's working directory, you could consider adding them to <code>.git/info/exclude</code> to prevent them from being accidentally committed to your repository.
<h2><span class="saddlebrown">&emsp;Global Git ignore rules</span></h2>
In addition, you can define global Git ignore patterns for all repositories on your local system by setting the Git <code>core.excludesFile</code> property. 
You'll have to create this file yourself. 

If you're unsure where to put your global <code>.gitignore</code> file, your home directory isn't a bad choice (and makes it easy to find later). 
Once you've created the file, you'll need to configure its location with <code>git config</code>:
<code>$ touch ~/.gitignore
$ git config --global core.excludesFile ~/.gitignore</code>

You should be careful what patterns you choose to globally ignore, as different file types are relevant for different projects. 
Special operating system files (e.g. 
<code>.DS_Store</code> and <code>thumbs.db</code>) or temporary files created by some developer tools are typical candidates for ignoring globally.
<h2><span class="saddlebrown">&emsp;Ignoring a previously committed file</span></h2>
If you want to ignore a file that you've committed in the past, you'll need to delete the file from your repository and then add a <code>.gitignore</code> rule for it. 
Using the <code>--cached</code> option with <code>git rm</code> means that the file will be deleted from your repository, but will remain in your working directory as an ignored file.
<code>$ echo debug.log >> .gitignore
$ git rm --cached debug.log

rm 'debug.log'
$ git commit -m "Start ignoring debug.log"</code>
You can omit the <code>--cached</code> option if you want to delete the file from both the repository and your local file system.
<h2><span class="saddlebrown">&emsp;Committing an ignored file</span></h2>
It is possible to force an ignored file to be committed to the repository using the <code>-f</code> (or <code>--force</code>) option with <code>git add</code>:
<code>$ cat .gitignore
*.log
$ git add -f debug.log

$ git commit -m "Force adding debug.log"</code>
You might consider doing this if you have a general pattern (like <code>*.log</code>) defined, but you want to commit a specific file. 
However a better solution is to define an exception to the general rule:
<code>$ echo !debug.log >> .gitignore

$ cat .gitignore
*.log
!debug.log
$ git add debug.log

$ git commit -m "Adding debug.log"</code>
This approach is more obvious, and less confusing, for your teammates.
<h2><span class="saddlebrown">&emsp;Stashing an ignored file</span></h2>
<code><a href="/git/tutorials/saving-changes/git-stash" data-event="clicked" data-uuid="a2b120cc-65" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git stash</a></code> is a powerful Git feature for temporarily shelving and reverting local changes, allowing you to re-apply them later on. 

As you'd expect, by default <code>git stash</code> ignores ignored files and only stashes changes to files that are tracked by Git. 
However, you can invoke <a href="/git/tutorials/saving-changes/git-stash#stashing-untracked-or-ignored" data-event="clicked" data-uuid="a2b120cc-65" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git stash with the --all option</a> to stash changes to ignored and untracked files as well.
<h2><span class="saddlebrown">&emsp;Debugging .gitignore files</span></h2>
If you have complicated <code>.gitignore</code> patterns, or patterns spread over multiple <code>.gitignore</code> files, it can be difficult to track down why a particular file is being ignored. 

You can use the <code>git check-ignore</code> command with the <code>-v</code> (or <code>--verbose</code>) option to determine which pattern is causing a particular file to be ignored:
<code>$ git check-ignore -v debug.log
.gitignore:3:*.log  debug.log</code>
The output shows:

<code>&lt;file containing the pattern> : &lt;line number of the pattern> : &lt;pattern>    &lt;file name></code>
You can pass multiple file names to <code>git check-ignore</code> if you like, and the names themselves don't even have to correspond to files that exist in your repository.
<h2><br><span class="orange">Git Status: Inspecting a repository</span></h2>
<h2><span class="saddlebrown">&emsp;git status</span></h2>
The <code>git status</code> command displays the state of the working directory and the staging area. 
It lets you see which changes have been staged, which haven’t, and which files aren’t being tracked by Git. 
Status output does <em>not</em> show you any information regarding the committed project history. 
For this, you need to use <a href="https://www.atlassian.com/git/tutorials/inspecting-a-repository/git-log" data-event="clicked" data-uuid="53827bc0-8c" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket"><code>git log</code></a>.

<h3>&emsp;Related git commands</h3>
<a href="/git/tutorials/inspecting-a-repository/git-tag" data-event="clicked" data-uuid="d7284824-be" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git tag  </a> 
Tags are ref's that point to specific points in Git history. 
<code>git tag</code> is generally used to capture a point in history that is used for a marked version release (i.e. 

v1.0.1). 
<strong><code><a href="/git/tutorials/inspecting-a-repository/git-blame" data-event="clicked" data-uuid="d7284824-be" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git blame</a></code></strong> 
The high-level function of <code>git blame</code> is the display of author metadata attached to specific committed lines in a file. 
This is used to explore the history of specific code and answer questions about what, how, and why the code was added to a repository.

<a href="/git/tutorials/git-log" data-event="clicked" data-uuid="d7284824-be" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git log  </a> 
The <code>git log</code> command displays committed snapshots. 
It lets you list the project history, filter it, and search for specific changes. 
<h3>&emsp;Usage</h3>

<code>git status</code>
List which files are staged, unstaged, and untracked.
<h3>&emsp;Discussion</h3>
The <code>git status</code> command is a relatively straightforward command. 

It simply shows you what's been going on with <code>git add</code> and <code>git commit</code>. 
Status messages also include relevant instructions for staging/unstaging files. 
Sample output showing the three main categories of a <code>git status</code> call is included below:
<code># On branch main

# Changes to be committed:
# (use "git reset HEAD &lt;file>..." to unstage)
#
#modified: hello.py

#
# Changes not staged for commit:
# (use "git add &lt;file>..." to update what will be committed)
# (use "git checkout -- &lt;file>..." to discard changes in working directory)

#
#modified: main.py
#
# Untracked files:

# (use "git add &lt;file>..." to include in what will be committed)
#
#hello.pyc</code>
<h4> Ignoring Files
</h4>
Untracked files typically fall into two categories. 
They're either files that have just been added to the project and haven't been committed yet, or they're compiled binaries like <code>.pyc</code>, <code>.obj</code>, <code>.exe</code>, etc. 
While it's definitely beneficial to include the former in the <code>git status</code> output, the latter can make it hard to see what’s actually going on in your repository.

For this reason, Git lets you completely ignore files by placing paths in a special file called <a href="https://www.atlassian.com/git/tutorials/gitignore" data-event="clicked" data-uuid="611de77f-81" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket"><code>.gitignore</code></a>. 
Any files that you'd like to ignore should be included on a separate line, and the * symbol can be used as a wildcard. 
For example, adding the following to a <code>.gitignore</code> file in your project root will prevent compiled Python modules from appearing in <code>git status</code>:
<code>*.pyc</code>

<h3>&emsp;Example</h3>
It's good practice to check the state of your repository before committing changes so that you don't accidentally commit something you don't mean to. 
This example displays the repository status before and after staging and committing a snapshot:
<code># Edit hello.py

git status
# hello.py is listed under "Changes not staged for commit"
git add hello.py
git status

# hello.py is listed under "Changes to be committed"
git commit
git status
# nothing to commit (working directory clean)</code>

The first status output will show the file as unstaged. 
The <code>git add</code> action will be reflected in the second <code>git status</code>, and the final status output will tell you that there is nothing to commit—the working directory matches the most recent commit. 
Some Git commands (e.g., <code><a href="/git/tutorials/using-branches/git-merge" data-event="clicked" data-uuid="0a572913-9d" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git merge</a></code>) require the working directory to be clean so that you don't accidentally overwrite changes.
<h2><span class="saddlebrown">&emsp;git log</span></h2>
The <code>git log</code> command displays committed snapshots. 
It lets you list the project history, filter it, and search for specific changes. 
While <code>git status</code> lets you inspect the working directory and the staging area, <code>git log</code> only operates on the committed history.
<img src="https://wac-cdn.atlassian.com/dam/jcr:52d530ce-7f51-48e3-920b-a18f776048d3/01.svg?cdnVersion=217" loading="lazy" alt="Git Tutorial: git status vs. git log">Log output can be customized in several ways, from simply filtering commits to displaying them in a completely user-defined format. 

Some of the most common configurations of <code>git log</code> are presented below.
<h3>&emsp;Usage</h3>
<code>git log</code>
Display the entire commit history using the default formatting. 

If the output takes up more than one screen, you can use <code>Space</code> to scroll and <code>q</code> to exit.
<code>git log -n &lt;limit></code>
Limit the number of commits by <code><limit></limit></code>. 
For example, <code>git log -n 3</code> will display only 3 commits.

Condense each commit to a single line. 
This is useful for getting a high-level overview of the project history.
<code>git log --oneline</code>
<code>git log --stat</code>

Along with the ordinary <code>git log</code> information, include which files were altered and the relative number of lines that were added or deleted from each of them.
<code>git log -p</code>
Display the patch representing each commit. 
This shows the full diff of each commit, which is the most detailed view you can have of your project history.

<code>git log --author="&lt;pattern>"</code>
Search for commits by a particular author. 
The  argument can be a plain string or a regular expression.
<code>git log --grep="&lt;pattern>"</code>

Search for commits with a commit message that matches , which can be a plain string or a regular expression.
<code>git log &lt;since>..&lt;until></code>
Show only commits that occur between <code>&lt; since ></code> and <code>&lt; until ></code>. 
Both arguments can be either a commit ID, a branch name, <code>HEAD</code>, or any other kind of <a href="http://www.kernel.org/pub/software/scm/git/docs/gitrevisions.html" data-event="clicked" data-uuid="5ded62bd-07" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">revision reference</a>.

<code>git log &lt;file></code>
Only display commits that include the specified file. 
This is an easy way to see the history of a particular file. 
<code>git log --graph --decorate --oneline</code>

A few useful options to consider. 
The --graph flag that will draw a text based graph of the commits on the left hand side of the commit messages. 
--decorate adds the names of branches or tags of the commits that are shown. 
--oneline shows the commit information on a single line making it easier to browse through commits at-a-glance.

<h3>&emsp;Discussion</h3>
The <code>git log</code> command is Git's basic tool for exploring a repository’s history. 
It’s what you use when you need to find a specific version of a project or figure out what changes will be introduced by merging in a feature branch.
<code>commit 3157ee3718e180a9476bf2e5cab8e3f1e78a73b7

Author: John Smith</code>
Most of this is pretty straightforward; however, the first line warrants some explanation. 
The 40-character string after <code>commit</code> is an SHA-1 checksum of the commit’s contents. 
This serves two purposes. 

First, it ensures the integrity of the commit—if it was ever corrupted, the commit would generate a different checksum. 
Second, it serves as a unique ID for the commit.
This ID can be used in commands like <code>git log <since>..<until></until></since></code> to refer to specific commits. 
For instance, <code>git log 3157e..5ab91</code> will display everything between the commits with ID's <code>3157e</code> and <code>5ab91</code>. 

Aside from checksums, branch names (discussed in the <a href="/git/tutorials/using-branches" data-event="clicked" data-uuid="aa8e9e3f-88" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Branch Module</a>) and the HEAD keyword are other common methods for referring to individual commits. 
<code>HEAD</code> always refers to the current commit, be it a branch or a specific commit.
The ~ character is useful for making relative references to the parent of a commit. 
For example, <code>3157e~1</code> refers to the commit before <code>3157e</code>, and <code>HEAD~3</code> is the great-grandparent of the current commit.

The idea behind all of these identification methods is to let you perform actions based on specific commits. 
The <code>git log</code> command is typically the starting point for these interactions, as it lets you find the commits you want to work with.
<h3>&emsp;Example</h3>
The <em>Usage</em> section provides many examples of <code>git log</code>, but keep in mind that several options can be combined into a single command:

<code>git log --author="John Smith" -p hello.py</code>
This will display a full diff of all the changes John Smith has made to the file <code>hello.py</code>.
The .. 
syntax is a very useful tool for comparing branches. 

The next example displays a brief overview of all the commits that are in <code>some-feature</code> that are not in <code>main</code>.
<code>git log --oneline main..some-feature</code>
<h2><br><span class="orange">Git tag</span></h2>
<h2><span class="saddlebrown">&emsp;Tagging</span></h2>
This document will discuss the Git concept of tagging and the <code>git tag</code> command. 
Tags are ref's that point to specific points in Git history. 
Tagging is generally used to capture a point in history that is used for a marked version release (i.e. 
v1.0.1). 

A tag is like a branch that doesn’t change. 
Unlike branches, tags, after being created, have no further history of commits. 
For more info on branches visit the <code>git branch</code> page. 
This document will cover the different kind of tags, how to create tags, listing all tags, deleting tags, sharing tags, and more.
<h2><span class="saddlebrown">&emsp;Creating a tag</span></h2>
To create a new tag execute the following command:
<code>git tag &lt;tagname></code>
Replace <code>&lt; tagname ></code> with a semantic identifier to the state of the repo at the time the tag is being created. 

A common pattern is to use version numbers like <code>git tag v1.4</code>. 
Git supports two different types of tags, annotated and lightweight tags. 
The previous example created a lightweight tag. 
Lightweight tags and Annotated tags differ in the amount of accompanying meta data they store. 

A best practice is to consider Annotated tags as public, and Lightweight tags as private. 
Annotated tags store extra meta data such as: the tagger name, email, and date. 
This is important data for a public release. 
Lightweight tags are essentially 'bookmarks' to a commit, they are just a name and a pointer to a commit, useful for creating quick links to relevant commits.
<h2><span class="saddlebrown">&emsp;Annotated Tags</span></h2>
Annotated tags are stored as full objects in the Git database. 
To reiterate, They store extra meta data such as: the tagger name, email, and date. 
Similar to commits and commit messages Annotated tags have a tagging message. 

Additionally, for security, annotated tags can be signed and verified with GNU Privacy Guard (GPG). 
Suggested best practices for git tagging is to prefer annotated tags over lightweight so you can have all the associated meta-data.
<code>git tag -a v1.4</code>
Executing this command will create a new annotated tag identified with <code>v1.4</code>. 

The command will then open up the configured default text editor to prompt for further meta data input.
<code>git tag -a v1.4 -m "my version 1.4"</code>
Executing this command is similar to the previous invocation, however, this version of the command is passed the <code>-m</code> option and a message. 
This is a convenience method similar to <code>git commit -m</code> that will immediately create a new tag and forgo opening the local text editor in favor of saving the message passed in with the <code>-m</code> option.
<h2><span class="saddlebrown">&emsp;Lightweight Tags</span></h2>
<code>git tag v1.4-lw</code>
Executing this command creates a lightweight tag identified as <code>v1.4-lw.</code> Lightweight tags are created with the absence of the <code>-a</code>, <code>-s</code>, or <code>-m</code> options. 
Lightweight tags create a new tag checksum and store it in the <code>.git/</code> directory of the project's repo.
<h2><span class="saddlebrown">&emsp;Listing Tags</span></h2>
To list stored tags in a repo execute the following:
<code>git tag</code>
This will output a list of tags:

<code>v0.10.0
v0.10.0-rc1
v0.11.0
v0.11.0-rc1

v0.11.1
v0.11.2
v0.12.0
v0.12.0-rc1

v0.12.1
v0.12.2
v0.13.0
v0.13.0-rc1

v0.13.0-rc2</code>
To refine the list of tags the <code>-l</code> option can be passed with a wild card expression:
<code>$ git tag -l *-rc*
v0.10.0-rc1

v0.11.0-rc1
v0.12.0-rc1
v0.13.0-rc1
v0.13.0-rc2

v0.14.0-rc1
v0.9.0-rc1
v15.0.0-rc.1
v15.0.0-rc.2

v15.4.0-rc.3</code>
This previous example uses the <code>-l</code> option and a wildcard expression of <code>-rc</code> which returns a list of all tags marked with a <code>-rc</code> prefix, traditionally used to identify <em>release candidates</em>.
<h2><span class="saddlebrown">&emsp;Tagging Old Commits</span></h2>
The previous tagging examples have demonstrated operations on implicit commits. 

By default, <code>git tag</code> will create a tag on the commit that <code>HEAD</code> is referencing. 
Alternatively <code>git tag</code> can be passed as a ref to a specific commit. 
This will tag the passed commit instead of defaulting to <code>HEAD.</code> To gather a list of older commits execute the <code>git log</code> command.
<code>$ git log --pretty=oneline

15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch 'feature'
a6b4c97498bd301d84096da251c98a07c7723e65 add update method for thing
0d52aaab4479697da7686c15f77a3d64d9165190 one more thing
6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch 'experiment'</code>

Executing <code>git log</code> will output a list of commits. 
In this example we will pick the top most commit <code>Merge branch 'feature'</code> for the new tag. 
We will need to reference to the commit SHA hash to pass to Git:
<code>git tag -a v1.2 15027957951b64cf874c3557a0f3547bd83b3ff6</code>

Executing the above <code>git tag</code> invocation will create a new annotated commit identified as <code>v1.2</code> for the commit we selected in the previous <code>git log</code> example.
<h2><span class="saddlebrown">&emsp;ReTagging/Replacing Old Tags</span></h2>
If you try to create a tag with the same identifier as an existing tag, Git will throw an error like:
<code>fatal: tag 'v0.4' already exists</code>

Additionally if you try to tag an older commit with an existing tag identifier Git will throw the same error.
In the event that you must update an existing tag, the <code>-f FORCE</code> option must be used.
<code>git tag -a -f v1.4 15027957951b64cf874c3557a0f3547bd83b3ff6</code>
Executing the above command will map the <code>15027957951b64cf874c3557a0f3547bd83b3ff6</code> commit to the <code>v1.4</code> tag identifier. 

It will override any existing content for the <code>v1.4</code> tag.
<h2><span class="saddlebrown">&emsp;Sharing: Pushing Tags to Remote</span></h2>
Sharing tags is similar to pushing branches. 
By default, <code>git push</code> will not push tags. 

Tags have to be explicitly passed to <code>git push</code>.
<code>$ git push origin v1.4
Counting objects: 14, done.
Delta compression using up to 8 threads.

Compressing objects: 100% (12/12), done.
Writing objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done.
Total 14 (delta 3), reused 0 (delta 0)
To git@bitbucket.com:atlasbro/gittagdocs.git

 * [new tag]         v1.4 -> v1.4</code>
To push multiple tags simultaneously pass the <code>--tags</code> option to <code>git push</code> command. 
When another user clones or pulls a repo they will receive the new tags.
<h2><span class="saddlebrown">&emsp;Checking Out Tags</span></h2>
You can view the state of a repo at a tag by using the <code><a href="/git/tutorials/using-branches/git-checkout" data-event="clicked" data-uuid="1f382484-ad" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git checkout</a></code> command.
<code>git checkout v1.4</code>
The above command will checkout the <code>v1.4</code> tag. 
This puts the repo in a detached <code>HEAD</code> state. 

This means any changes made will not update the tag. 
They will create a new detached commit. 
This new detached commit will not be part of any branch and will only be reachable directly by the commits SHA hash. 
Therefore it is a best practice to create a new branch anytime you're making changes in a detached <code>HEAD</code> state.
<h2><span class="saddlebrown">&emsp;Deleting Tags</span></h2>
Deleting tags is a straightforward operation. 
Passing the <code>-d</code> option and a tag identifier to <code>git tag</code> will delete the identified tag.
<code>$ git tag

v1
v2
v3
$ git tag -d v1

$ git tag
v2
v3</code>
In this example <code>git tag</code> is executed to display a list of tags showing v1, v2, v3, Then <code>git tag -d v1</code> is executed which deletes the v1 tag.
<h2><span class="saddlebrown">&emsp;Summary</span></h2>
To recap, Tagging is an additional mechanism used to create a snap shot of a Git repo. 
Tagging is traditionally used to create semantic version number identifier tags that correspond to software release cycles. 
The <code>git tag</code> command is the primary driver of tag: creation, modification and deletion. 

There are two types of tags; annotated and lightweight. 
Annotated tags are generally the better practices as they store additional valuable meta data about the tag. 
Additional Git commands covered in this document were <code><a href="/git/tutorials/syncing/git-push" data-event="clicked" data-uuid="997104e6-8d" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git push</a></code>, and <code><a href="/git/tutorials/using-branches/git-checkout" data-event="clicked" data-uuid="997104e6-8d" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git checkout</a>.</code> Visit their corresponding pages for discussion on their extended use.
<h2><br><span class="orange">Git blame</span></h2>
The <code>git blame</code> command is a versatile troubleshooting utility that has extensive usage options. 
The high-level function of <code>git blame</code> is the display of author metadata attached to specific committed lines in a file. 
This is used to examine specific points of a file's history and get context as to who the last author was that modified the line. 
This is used to explore the history of specific code and answer questions about what, how, and why the code was added to a repository.

<code>Git blame</code> is often used with a GUI display. 
Online Git hosting sites like <a href="https://bitbucket.org/product" data-event="clicked" data-uuid="9ef74e0c-0d" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Bitbucket</a> offer <em>blame views</em> which are UI wrappers to <code>git blame</code>. 
These views are referenced in collaborative discussions around pull requests and commits. 
Additionally, most IDE's that have Git integration also have dynamic blame views.
<h2><span class="saddlebrown">&emsp;How It Works</span></h2>
In order to demonstrate <code>git blame</code> we need a repository with some history. 
We will use the open source project <a href="https://bitbucket.org/kevzettler/git-blame-example" data-event="clicked" data-uuid="4f353630-55" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git-blame-example</a>. 
This open source project is a simple repository that contains a README.md file which has a few commits from different authors. 

The first step of our <code>git blame</code> usage example is to <code>git clone</code> the example repository.
<code>git clone https://kevzettler@bitbucket.org/kevzettler/git-blame-example.git &amp;&amp; cd git-blame-example</code>
Now that we have a copy of the example code we can start exploring it with <code>git blame</code>. 
The state of the example repo can be examined using <code><a href="/git/tutorials/git-log" data-event="clicked" data-uuid="8d25b115-c5" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git log</a></code>. 

The commit history should look like the following:
<code>$ git log
commit 548dabed82e4e5f3734c219d5a742b1c259926b2
Author: Juni Mukherjee &lt;jmukherjee@atlassian.com>

Date:   Thu Mar 1 19:55:15 2018 +0000
    Another commit to help git blame track the who, the what, and the when
commit eb06faedb1fdd159d62e4438fc8dbe9c9fe0728b
Author: Juni Mukherjee &lt;jmukherjee@atlassian.com>

Date:   Thu Mar 1 19:53:23 2018 +0000
    Creating the third commit, along with Kev and Albert, so that Kev can get git blame docs.
commit 990c2b6a84464fee153253dbf02e845a4db372bb
Merge: 82496ea 89feb84

Author: Albert So &lt;aso@atlassian.com>
Date:   Thu Mar 1 05:33:01 2018 +0000
    Merged in albert-so/git-blame-example/albert-so/readmemd-edited-online-with-bitbucket-1519865641474 (pull request #2)
    README.md edited online with Bitbucket

commit 89feb84d885fe33d1182f2112885c2a64a4206ec
Author: Albert So &lt;aso@atlassian.com>
Date:   Thu Mar 1 00:54:03 2018 +0000
    README.md edited online with Bitbucket</code>

<code>git blame</code> only operates on individual files. 
A file-path is required for any useful output. 
The default execution of <code>git blame</code> will simply output the commands help menu. 
For this example, we will operate on the README.MD file. 

It is a common open source software practice to include a README file in the root of a git repository as documentation source for the project.
<code>git blame README.MD</code>
Executing the above command will give us our first sample of blame output. 
The following output is a subset of the full blame output of the README. 

Additionally, this output is static is reflective of the state of the repo at the time of this writing.
<code>$ git blame README.md
82496ea3 (kevzettler     2018-02-28 13:37:02 -0800  1) # Git Blame example
82496ea3 (kevzettler     2018-02-28 13:37:02 -0800  2)

89feb84d (Albert So      2018-03-01 00:54:03 +0000  3) This repository is an example of a project with multiple contributors making commits.
82496ea3 (kevzettler     2018-02-28 13:37:02 -0800  4)
82496ea3 (kevzettler     2018-02-28 13:37:02 -0800  5) The repo use used elsewhere to demonstrate `git blame`
82496ea3 (kevzettler     2018-02-28 13:37:02 -0800  6)

89feb84d (Albert So      2018-03-01 00:54:03 +0000  7) Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod TEMPOR incididunt ut labore et dolore magna aliqua. 
Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. 
Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. 
Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum

89feb84d (Albert So      2018-03-01 00:54:03 +0000  8)
eb06faed (Juni Mukherjee 2018-03-01 19:53:23 +0000  9) Annotates each line in the given file with information from the revision which last modified the line. 
Optionally, start annotating from the given revision.
eb06faed (Juni Mukherjee 2018-03-01 19:53:23 +0000 10)

548dabed (Juni Mukherjee 2018-03-01 19:55:15 +0000 11) Creating a line to support documentation needs for git blame.
548dabed (Juni Mukherjee 2018-03-01 19:55:15 +0000 12)
548dabed (Juni Mukherjee 2018-03-01 19:55:15 +0000 13) Also, it is important to have a few of these commits to clearly reflect the who, the what and the when. 
This will help Kev get good screenshots when he runs the git blame on this README.</code>

This is a sample of the first 13 lines of the README.md file. 
To better understand this output lets break down a line. 
The following table displays the content of line 3 and the columns of the table indicate the column content.
<table border="1" cellpadding="1" cellspacing="1"><tbody>

<tr>
<td>Id</td> <td>Author</td> <td>Timestamp</td> <td>Line Number</td> <td>Line Content</td> </tr>
<tr>
<td>89feb84d</td> <td>Albert So</td> <td>2018-03-01 00:54:03 +0000</td> <td>3</td> <td>This repository is an example of a project with multiple contributors making commits.</td> </tr>

</tbody></table>
If we review the blame output list, we can make some observations. 
There are three authors listed. 
In addition to the project's maintainer Kev Zettler, Albert So, and Juni Mukherjee are also listed. 

Authors are generally the most valuable part of <code>git blame</code> output. 
The timestamp column is also primarily helpful. 
What the change was is indicated by line content column.
<h2><span class="saddlebrown">&emsp;Common Options</span></h2>
<code>git blame -L 1,5 README.md</code>
The <code>-L</code> option will restrict the output to the requested line range. 
Here we have restricted the output to lines 1 through 5.
<code>git blame -e README.md</code>

The <code>-e</code> option shows the authors email address instead of username.
<code>git blame -w README.md</code>
The <code>-w</code> option ignores whitespace changes. 
If a previous author has modified the spacing of a file by switching from tabs to spaces or adding new lines this, unfortunately, obscures the output of <code>git blame</code> by showing these changes.

<code>git blame -M README.md</code>
The <code>-M</code> option detects moved or copied lines within in the same file. 
This will report the original author of the lines instead of the last author that moved or copied the lines.
<code>git blame -C README.md</code>

The <code>-C</code> option detects lines that were moved or copied from other files. 
This will report the original author of the lines instead of the last author that moved or copied the lines.
<h2><span class="saddlebrown">&emsp;Git Blame vs Git Log</span></h2>
While <code>git blame</code> displays the last author that modified a line, often times you will want to know when a line was originally added. 

This can be cumbersome to achieve using <code>git blame</code>. 
It requires a combination of the <code>-w</code>, <code>-C</code>, and <code>-M</code> options. 
It can be far more convenient to use the <code><a href="/git/tutorials/git-log" data-event="clicked" data-uuid="5f27d5ec-41" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git log</a> </code>command.
To list all original commits in-which a specific code piece was added or modified execute <code>git log</code> with the <code>-S</code> option. 

Append the <code>-S</code> option with the code you are looking for. 
Let's take one of the lines from the README output above to use as an example. 
Let us take the text "CSS3D and WebGL renderers" from Line 12 of the README output.
<code>$ git log -S"CSS3D and WebGL renderers." --pretty=format:'%h %an %ad %s'

e339d3c85 Mario Schuettel Tue Oct 13 16:51:06 2015 +0200 reverted README.md to original content
509c2cc35 Daniel Tue Sep 8 13:56:14 2015 +0200 Updated README
cb20237cc Mr.doob Mon Dec 31 00:22:36 2012 +0100 Removed DOMRenderer. 
Now with the CSS3DRenderer it has become irrelevant.</code>

This output shows us that content from the README was added or modified 3 times by 3 different authors. 
It was originally added in commit cb20237cc by Mr.doob. 
In this example, <code>git log</code> has also been prepended with the <code>--pretty-format</code> option. 
This option converts the default output format of <code>git log</code> into one that matches the format of <code>git log</code>. 

For more information on usage and configuration options visit the <code><a href="/git/tutorials/git-log" data-event="clicked" data-uuid="0eefe36b-97" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git log</a></code> page.
<h2><span class="saddlebrown">&emsp;Summary</span></h2>
The <code>git blame</code> command is used to examine the contents of a file line by line and see when each line was last modified and who the author of the modifications was. 
The output format of <code>git blame</code> can be altered with various command line options. 

Online Git hosting solutions like Bitbucket offer <em>blame views</em>, which offer a superior user experience to command line <code>git blame</code> usage. 
<code>git blame</code> and git log can be used in combination to help discover the history of a file's contents. 
The <code>git log</code> command has some similar blame functionality, to learn more visit the <code><a href="/git/tutorials/git-log" data-event="clicked" data-uuid="7fa39ccc-9f" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git log</a></code> overview page.
<h2><br><span class="orange">Undoing Commits &amp; Changes</span></h2>
In this section, we will discuss the available 'undo' Git strategies and commands. 
It is first important to note that Git does not have a traditional 'undo' system like those found in a word processing application. 
It will be beneficial to refrain from mapping Git operations to any traditional 'undo' mental model. 
Additionally, Git has its own nomenclature for 'undo' operations that it is best to leverage in a discussion. 

This nomenclature includes terms like reset, revert, checkout, clean, and more.
A fun metaphor is to think of Git as a timeline management utility. 
Commits are snapshots of a point in time or points of interest along the timeline of a project's history. 
Additionally, multiple timelines can be managed through the use of branches. 

When 'undoing' in Git, you are usually moving back in time, or to another timeline where mistakes didn't happen.
This tutorial provides all of the necessary skills to work with previous revisions of a software project. 
First, it shows you how to explore old commits, then it explains the difference between reverting public commits in the project history vs. resetting unpublished changes on your local machine.
<h2><span class="saddlebrown">&emsp;Finding what is lost: Reviewing old commits</span></h2>
The whole idea behind any version control system is to store “safe” copies of a project so that you never have to worry about irreparably breaking your code base. 
Once you’ve built up a project history of commits, you can review and revisit any commit in the history. 
One of the best utilities for reviewing the history of a Git repository is the <code>git log</code> command. 
In the example below, we use <code><a href="/git/tutorials/git-log" data-event="clicked" data-uuid="4c01e4f1-66" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git log</a></code> to get a list of the latest commits to a popular open-source graphics library.

<code>git log --oneline
e2f9a78fe Replaced FlyControls with OrbitControls
d35ce0178 Editor: Shortcuts panel Safari support.
9dbe8d0cf Editor: Sidebar.Controls to Sidebar.Settings.Shortcuts. 

Clean up.
05c5288fc Merge pull request #12612 from TyLindberg/editor-controls-panel
0d8b6e74b Merge pull request #12805 from harto/patch-1
23b20c22e Merge pull request #12801 from gam0022/improve-raymarching-example-v2

fe78029f1 Fix typo in documentation
7ce43c448 Merge pull request #12794 from WestLangley/dev-x
17452bb93 Merge pull request #12778 from OndrejSpanel/unitTestFixes
b5c1b5c70 Merge pull request #12799 from dhritzkiv/patch-21

1b48ff4d2 Updated builds.
88adbcdf6 WebVRManager: Clean up.
2720fbb08 Merge pull request #12803 from dmarcos/parentPoseObject
9ed629301 Check parent of poseObject instead of camera

219f3eb13 Update GLTFLoader.js
15f13bb3c Update GLTFLoader.js
6d9c22a3b Update uniforms only when onWindowResize
881b25b58 Update ProjectionMatrix on change aspect</code>

Each commit has a unique SHA-1 identifying hash. 
These IDs are used to travel through the committed timeline and revisit commits. 
By default, <code>git log</code> will only show commits for the currently selected branch. 
It is entirely possible that the commit you're looking for is on another branch. 

You can view all commits across all branches by executing <code>git log --branches=*</code>. 
The command <code><a href="/git/tutorials/using-branches" data-event="clicked" data-uuid="09799081-61" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git branch</a></code> is used to view and visit other branches. 
Invoking the command, <code>git branch -a</code> will return a list of all known branch names. 
One of these branch names can then be logged using <code>git log <branch_name></branch_name></code>.

When you have found a commit reference to the point in history you want to visit, you can utilize the <code>git checkout</code> command to visit that commit. 
<code>Git checkout</code> is an easy way to “load” any of these saved snapshots onto your development machine. 
During the normal course of development, the <code>HEAD</code> usually points to <code>main</code> or some other local branch, but when you check out a previous commit, <code>HEAD</code> no longer points to a branch—it points directly to a commit. 
This is called a “detached <code>HEAD</code>” state, and it can be visualized as the following:

<img src="https://wac-cdn.atlassian.com/dam/jcr:9b234e0d-ee33-4463-ac14-298c9559015d/01%20Checking%20out%20a%20previous%20commit.svg?cdnVersion=217" loading="lazy" alt="Git Tutorial: Checking out a previous commit">Checking out an old file does not move the <code>HEAD</code> pointer. 
It remains on the same branch and same commit, avoiding a 'detached head' state. 
You can then commit the old version of the file in a new snapshot as you would any other changes. 
So, in effect, this usage of <code>git checkout</code> on a file, serves as a way to revert back to an old version of an individual file. 

For more information on these two modes visit the <code><a href="/git/tutorials/using-branches/git-checkout" data-event="clicked" data-uuid="de6055b4-9b" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git checkout</a></code> page
<h2><span class="saddlebrown">&emsp;Viewing an old revision</span></h2>
This example assumes that you’ve started developing a crazy experiment, but you’re not sure if you want to keep it or not. 
To help you decide, you want to take a look at the state of the project before you started your experiment. 

First, you’ll need to find the ID of the revision you want to see.
<code>git log --oneline</code>
Let’s say your project history looks something like the following:
<code>b7119f2 Continue doing crazy things

872fa7e Try something crazy
a1e8fb5 Make some important changes to hello.txt
435b61d Create hello.txt
9773e52 Initial import</code>

You can use <code>git checkout</code> to view the “Make some import changes to hello.txt” commit as follows:
<code>git checkout a1e8fb5</code>
This makes your working directory match the exact state of the <code>a1e8fb5</code> commit. 
You can look at files, compile the project, run tests, and even edit files without worrying about losing the current state of the project. 

Nothing you do in here will be saved in your repository. 
To continue developing, you need to get back to the “current” state of your project:
<code>git checkout main</code>
This assumes that you're developing on the default <code>main</code> branch. 

Once you’re back in the <code>main</code> branch, you can use either <code><a href="/git/tutorials/undoing-changes/git-revert" data-event="clicked" data-uuid="dfac3eaa-01" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git revert </a></code>or <code><a href="/git/tutorials/undoing-changes/git-reset" data-event="clicked" data-uuid="dfac3eaa-01" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git reset</a></code> to undo any undesired changes.
<h2><span class="saddlebrown">&emsp;Undoing a committed snapshot</span></h2>
There are technically several different strategies to 'undo' a commit. 
The following examples will assume we have a commit history that looks like:

<code>git log --oneline
872fa7e Try something crazy
a1e8fb5 Make some important changes to hello.txt
435b61d Create hello.txt

9773e52 Initial import</code>
We will focus on undoing the <code>872fa7e Try something crazy</code> commit. 
Maybe things got a little too crazy.
<h2><span class="saddlebrown">&emsp;How to undo a commit with git checkout</span></h2>
Using the <code>git checkout</code> command we can checkout the previous commit, <code>a1e8fb5,</code> putting the repository in a state before the crazy commit happened. 
Checking out a specific commit will put the repo in a "detached <font face="monospace">HEAD</font>" state. 
This means you are no longer working on any branch. 
In a detached state, any new commits you make will be orphaned when you change branches back to an established branch. 

Orphaned commits are up for deletion by Git's garbage collector. 
The garbage collector runs on a configured interval and permanently destroys orphaned commits. 
To prevent orphaned commits from being garbage collected, we need to ensure we are on a branch.
From the detached <font face="monospace">HEAD</font> state, we can execute <code>git checkout -b new_branch_without_crazy_commit</code>. 

This will create a new branch named <code>new_branch_without_crazy_commit</code> and switch to that state. 
The repo is now on a new history timeline in which the <code>872fa7e</code> commit no longer exists. 
At this point, we can continue work on this new branch in which the <code>872fa7e</code> commit no longer exists and consider it 'undone'. 
Unfortunately, if you need the previous branch, maybe it was your <code>main</code> branch, this undo strategy is not appropriate. 

Let's look at some other 'undo' strategies. 
For more information and examples review our in-depth <code><a href="/git/tutorials/using-branches/git-checkout" data-event="clicked" data-uuid="591df866-46" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git checkout</a></code> discussion.
<h2><span class="saddlebrown">&emsp;How to undo a public commit with git revert</span></h2>
Let's assume we are back to our original commit history example. 

The history that includes the <code>872fa7e</code> commit. 
This time let's try a revert 'undo'. 
If we execute <code>git revert HEAD</code>, Git will create a new commit with the inverse of the last commit. 
This adds a new commit to the current branch history and now makes it look like:

<code>git log --oneline
e2f9a78 Revert "Try something crazy"
872fa7e Try something crazy
a1e8fb5 Make some important changes to hello.txt

435b61d Create hello.txt
9773e52 Initial import</code>
At this point, we have again technically 'undone' the <code>872fa7e</code> commit. 
Although <code>872fa7e</code> still exists in the history, the new <code>e2f9a78</code> commit is an inverse of the changes in <code>872fa7e</code>. 

Unlike our previous checkout strategy, we can continue using the same branch. 
This solution is a satisfactory undo. 
This is the ideal 'undo' method for working with public shared repositories. 
If you have requirements of keeping a curated and minimal Git history this strategy may not be satisfactory.
<h2><span class="saddlebrown">&emsp;How to undo a commit with git reset</span></h2>
For this undo strategy we will continue with our working example. 
<code><a href="/git/tutorials/undoing-changes/git-reset" data-event="clicked" data-uuid="edfd0725-f4" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git reset</a></code> is an extensive command with multiple uses and functions. 
If we invoke <code>git reset --hard a1e8fb5</code> the commit history is reset to that specified commit. 

Examining the commit history with <code>git log</code> will now look like:
<code>git log --oneline
a1e8fb5 Make some important changes to hello.txt
435b61d Create hello.txt

9773e52 Initial import</code>
The log output shows the <code>e2f9a78</code> and <code>872fa7e</code> commits no longer exist in the commit history. 
At this point, we can continue working and creating new commits as if the 'crazy' commits never happened. 
This method of undoing changes has the cleanest effect on history. 

Doing a reset is great for local changes however it adds complications when working with a shared remote repository. 
If we have a shared remote repository that has the <code>872fa7e</code> commit pushed to it, and we try to <code>git push</code> a branch where we have reset the history, Git will catch this and throw an error. 
Git will assume that the branch being pushed is not up to date because of it's missing commits. 
In these scenarios, <code>git revert</code> should be the preferred undo method.
<h2><span class="saddlebrown">&emsp;Undoing the last commit</span></h2>
In the previous section, we discussed different strategies for undoing commits. 
These strategies are all applicable to the most recent commit as well. 
In some cases though, you might not need to remove or reset the last commit. 

Maybe it was just made prematurely. 
In this case you can amend the most recent commit. 
Once you have made more changes in the working directory and staged them for commit by using <code><a href="/git/tutorials/saving-changes" data-event="clicked" data-uuid="53539d30-e0" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git add</a></code>, you can execute <code>git commit --amend</code>. 
This will have Git open the configured system editor and let you modify the last commit message. 

The new changes will be added to the amended commit.
<h2><span class="saddlebrown">&emsp;Undoing uncommitted changes</span></h2>
Before changes are committed to the repository history, they live in the staging index and the working directory. 
You may need to undo changes within these two areas. 

The staging index and working directory are internal Git state management mechanisms. 
For more detailed information on how these two mechanisms operate, visit the <code><a href="/git/tutorials/resetting-checking-out-and-reverting" data-event="clicked" data-uuid="7e9c72f9-33" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git reset</a></code> page which explores them in depth.
<h2><span class="saddlebrown">&emsp;The working directory</span></h2>
The working directory is generally in sync with the local file system. 

To undo changes in the working directory you can edit files like you normally would using your favorite editor. 
Git has a couple utilities that help manage the working directory. 
There is the <code><a href="/git/tutorials/undoing-changes/git-clean" data-event="clicked" data-uuid="b07325c3-e6" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git clean</a></code> command which is a convenience utility for undoing changes to the working directory. 
Additionally, <code>git reset</code> can be invoked with the <code>--mixed</code> or <code>--hard</code> options and will apply a reset to the working directory.
<h2><span class="saddlebrown">&emsp;The staging index</span></h2>
The <code><a href="/git/tutorials/saving-changes" data-event="clicked" data-uuid="1ae8651e-97" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git add</a></code> command is used to add changes to the staging index. 
<code>Git reset</code> is primarily used to undo the staging index changes. 
A <code>--mixed</code> reset will move any pending changes from the staging index back into the working directory.
<h2><span class="saddlebrown">&emsp;Undoing public changes</span></h2>
When working on a team with remote repositories, extra consideration needs to be made when undoing changes. 
<code>Git reset</code> should generally be considered a 'local' undo method. 
A reset should be used when undoing changes to a private branch. 

This safely isolates the removal of commits from other branches that may be in use by other developers. 
Problems arise when a reset is executed on a shared branch and that branch is then pushed remotely with <code>git push</code>. 
Git will block the push in this scenario complaining that the branch being pushed is out of date from the remote branch as it is missing commits.
The preferred method of undoing shared history is <code>git revert</code>. 

A revert is safer than a reset because it will not remove any commits from a shared history. 
A revert will retain the commits you want to undo and create a new commit that inverts the undesired commit. 
This method is safer for shared remote collaboration because a remote developer can then pull the branch and receive the new revert commit which undoes the undesired commit.
<h2><span class="saddlebrown">&emsp;Summary</span></h2>
We covered many high-level strategies for undoing things in Git. 
It's important to remember that there is more than one way to 'undo' in a Git project. 
Most of the discussion on this page touched on deeper topics that are more thoroughly explained on pages specific to the relevant Git commands. 
The most commonly used 'undo' tools are <code><a href="/git/tutorials/using-branches/git-checkout" data-event="clicked" data-uuid="242d5e5f-bb" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git checkout,</a> <a href="/git/tutorials/undoing-changes/git-revert" data-event="clicked" data-uuid="242d5e5f-bb" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git revert</a></code>, and <code><a href="/git/tutorials/undoing-changes/git-reset" data-event="clicked" data-uuid="242d5e5f-bb" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git reset</a></code>. 

Some key points to remember are:
Once changes have been committed they are generally permanent
Use <code>git checkout</code> to move around and review the commit history
<code>git revert</code> is the best tool for undoing shared public changes

<code>git reset</code> is best used for undoing local private changes
In addition to the primary undo commands, we took a look at other Git utilities: <code><a href="/git/tutorials/git-log" data-event="clicked" data-uuid="242d5e5f-bb" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git log</a></code> for finding lost commits <code><a href="/git/tutorials/undoing-changes/git-clean" data-event="clicked" data-uuid="242d5e5f-bb" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git clean</a></code> for undoing uncommitted changes <code><a href="/git/tutorials/saving-changes" data-event="clicked" data-uuid="242d5e5f-bb" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git add</a></code> for modifying the staging index.
Each of these commands has its own in-depth documentation. 
To learn more about a specific command mentioned here, visit the corresponding links.

<h2><br><span class="orange">Git Clean</span></h2>
In this section, we will focus on a detailed discussion of the <code>git clean</code> command. 
<code>Git clean</code> is to some extent an 'undo' command. 
<code>Git clean</code> can be considered complementary to other commands like <code><a href="/git/tutorials/undoing-changes/git-reset" data-event="clicked" data-uuid="22a7a299-78" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git reset</a></code> and <code><a href="/git/tutorials/using-branches/git-checkout" data-event="clicked" data-uuid="22a7a299-78" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git checkout</a></code>. 

Whereas these other commands operate on files previously added to the Git tracking index, the <code>git clean</code> command operates on untracked files. 
Untracked files are files that have been created within your repo's working directory but have not yet been added to the repository's tracking index using the <code><a href="/git/tutorials/saving-changes" data-event="clicked" data-uuid="22a7a299-78" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git add</a></code> command. 
To better demonstrate the difference between tracked and untracked files consider the following command line example
<code>$ mkdir git_clean_test

$ cd git_clean_test/
$ git init .
Initialized empty Git repository in /Users/kev/code/git_clean_test/.git/
$ echo "tracked" > ./tracked_file

$ git add ./tracked_file
$ echo "untracked" > ./untracked_file
$ mkdir ./untracked_dir &amp;&amp; touch ./untracked_dir/file
$ git status

On branch master
Initial commit
Changes to be committed: (use "git rm --cached &lt;file>..." to unstage)
new file: tracked_file

Untracked files: (use "git add &lt;file>..." to include in what will be committed) untracked_dir/ untracked_file</code>
The example creates a new Git repository in the <code>git_clean_test</code> directory. 
It then proceeds to create a <code>tracked_file</code> which is added to the Git index, additionally, an <code>untracked_file</code> is created, and an <code>untracked_dir</code>. 
The example then invokes <code>git status</code> which displays output indicating Git's internal state of tracked and untracked changes. 

With the repository in this state, we can execute the <code>git clean</code> command to demonstrate its intended purpose.
<code>$ git clean fatal: clean.requireForce defaults to true and neither -i, -n, nor -f given; refusing to clean</code>
At this point, executing the default <code>git clean</code> command may produce a fatal error. 
The example above demonstrates what this may look like. 

By default, Git is globally configured to require that <code>git clean</code> be passed a "force" option to initiate. 
This is an important safety mechanism. 
When finally executed <code>git clean</code> is not undo-able. 
When fully executed, <code>git clean</code> will make a hard filesystem deletion, similar to executing the command line rm utility. 

Make sure you really want to delete the untracked files before you run it.
<h2><span class="saddlebrown">&emsp;Common options and usage</span></h2>
Given the previous explanation of the default git clean behaviors and caveats, the following content demonstrates various git clean use cases and the accompanying command line options required for their operation.
<code>-n</code>

The -n option will perform a “dry run” of git clean. 
This will show you which files are going to be removed without actually removing them. 
It is a best practice to always first perform a dry run of git clean. 
We can demonstrate this option in the demo repo we created earlier.

<code>$ git clean -n
Would remove untracked_file</code>
The output tells us that <code>untracked_file</code> will be removed when the <code>git clean</code> command is executed. 
Notice that the <code>untracked_dir</code> is not reported in the output here. 

By default <code>git clean</code> will not operate recursively on directories. 
This is another safety mechanism to prevent accidental permanent deletion.
<code>-f or --force</code>
The force option initiates the actual deletion of untracked files from the current directory. 

Force is required unless the <code>clean.requireForce</code> configuration option is set to false. 
This will not remove untracked folders or files specified by <code>.gitignore</code>. 
Let us now execute a live <code>git clean</code> in our example repo.
<code>$ git clean -f 

Removing untracked_file</code>
The command will output the files that are removed. 
You can see here that <code>untracked_file</code> has been removed. 
Executing git status at this point or doing a ls will show that untracked_file has been deleted and is nowhere to be found. 

By default git clean -f will operate on all the current directory untracked files. 
Additionally, a &lt; path > value can be passed with the -f option that will remove a specific file.
<code>git clean -f &lt;path>
-d include directories</code>

The -d option tells git clean that you also want to remove any untracked directories, by default it will ignore directories. 
We can add the -d option to our previous examples:
<code>$ git clean -dn
Would remove untracked_dir/

$ git clean -df
Removing untracked_dir/</code>
Here we have executed a 'dry run' using the -dn combination which outputs untracked_dir is up for removal. 
Then we execute a forced clean, and receive output that untracked_dir is removed.

<code>-x force removal of ignored files</code>
A common software release pattern is to have a build or distribution directory that is not committed to the repositories tracking index. 
The build directory will contain ephemeral build artifacts that are generated from the committed source code. 
This build directory is usually added to the repositories .gitignore file. 

It can be convenient to also clean this directory with other untracked files. 
The -x option tells git clean to also include any ignored files. 
As with previous git clean invocations, it is a best practice to execute a 'dry run' first, before the final deletion. 
The -x option will act on all ignored files, not just project build specific ones. 

This could be unintended things like ./.idea IDE configuration files.
<code>git clean -xf</code>
Like the -d option -x can be passed and composed with other options. 
This example demonstrates a combination with -f that will remove untracked files from the current directory as well as any files that Git usually ignores.
<h2><span class="saddlebrown">&emsp;Interactive mode or git clean interactive</span></h2>
In addition to the ad-hoc command line execution we have demonstrated so far, <code>git clean</code> has an "interactive" mode that you can initiate by passing the <code>-i</code> option. 
Let us revisit the example repo from the introduction of this document. 
In that initial state, we will start an interactive clean session.

<code>$ git clean -di
Would remove the following items:
untracked_dir/  untracked_file
*** Commands ***

1: clean
2: filter by pattern    3: select by numbers    4: ask each             5: quit
 6: help
What now></code>
We have initiated the interactive session with the <code>-d</code> option so it will also act upon our <code>untracked_dir</code>. 
The interactive mode will display a <code>What now></code> prompt that requests a command to apply to the untracked files. 

The commands themselves are fairly self explanatory. 
We'll take a brief look at each in a random order starting with command <code>6: help</code>. 
Selecting command 6 will further explain the other commands:
<code>What now> 6

clean               - start cleaning
filter by pattern   - exclude items from deletion
select by numbers   - select items to be deleted by numbers
ask each            - confirm each deletion (like "rm -i")

quit
- stop cleaning
help
- this screen
?
 - help for prompt selection</code>
<code>5: quit</code>

Is straight forward and will exit the interactive session.
<code>1: clean</code>
Will delete the indicated items. 
If we were to execute <code>1: clean</code> at this point <code>untracked_dir/ untracked_file</code> would be removed

<code>4: ask each</code>
will iterate over each untracked file and display a <code>Y/N</code> prompt for a deletion. 
It looks like the following:
<code>*** Commands ***

1: clean
2: filter by pattern    3: select by numbers    4: ask each             5: quit
 6: help
What now> 4
Remove untracked_dir/ [y/N]? N
Remove untracked_file [y/N]? N</code>

<code>2: filter by pattern</code>
Will display an additional prompt that takes input used to filter the list of untracked files.
<code>Would remove the following items:
untracked_dir/  untracked_file

*** Commands ***
1: clean
2: filter by pattern    3: select by numbers    4: ask each             5: quit
 6: help
What now> 2
untracked_dir/  untracked_file

Input ignore patterns>> *_file
untracked_dir/</code>
Here we input the <code>*_file</code> wildcard pattern which then restricts the untracked file list to just <code>untracked_dir</code>.
<code>3: select by numbers</code>

Similar to command 2, command 3 works to refine the list of untracked file names. 
The interactive session will prompt for numbers that correspond to an untracked file name.
<code>Would remove the following items:
untracked_dir/  untracked_file

*** Commands ***
1: clean
2: filter by pattern    3: select by numbers    4: ask each             5: quit
 6: help
What now> 3
1: untracked_dir/    2: untracked_file

Select items to delete>> 2
1: untracked_dir/  * 2: untracked_file
Select items to delete>>
Would remove the following item:

untracked_file
*** Commands ***
1: clean
2: filter by pattern    3: select by numbers    4: ask each             5: quit
 6: help</code>
<h2><span class="saddlebrown">&emsp;Summary</span></h2>
To recap, <code>git clean</code> is a convenience method for deleting untracked files in a repo's working directory. 

Untracked files are those that are in the repo's directory but have not yet been added to the repo's index with <code><a href="/git/tutorials/saving-changes" data-event="clicked" data-uuid="a41d6d74-1d" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git add</a></code>. 
Overall the effect of <code>git clean</code> can be accomplished using <code><a href="/git/tutorials/inspecting-a-repository" data-event="clicked" data-uuid="a41d6d74-1d" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git status</a></code> and the operating systems native deletion tools. 
<code>Git clean</code> can be used alongside <code><a href="/git/tutorials/undoing-changes/git-reset" data-event="clicked" data-uuid="a41d6d74-1d" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git reset</a></code> to fully undo any additions and commits in a repository.
<h2><br><span class="orange">Git Revert</span></h2>
The <code>git revert</code> command can be considered an 'undo' type command, however, it is not a traditional undo operation. 
Instead of removing the commit from the project history, it figures out how to invert the changes introduced by the commit and appends a new commit with the resulting inverse content. 
This prevents Git from losing history, which is important for the integrity of your revision history and for reliable collaboration.
Reverting should be used when you want to apply the inverse of a commit from your project history. 

This can be useful, for example, if you’re tracking down a bug and find that it was introduced by a single commit. 
Instead of manually going in, fixing it, and committing a new snapshot, you can use <code>git revert</code> to automatically do all of this for you.
<img src="https://wac-cdn.atlassian.com/dam/jcr:b6fcf82b-5b15-4569-8f4f-a76454f9ca5b/03%20(7).svg?cdnVersion=217" loading="lazy" alt="Git revert - Atlassian git tutorials">
<h2><span class="saddlebrown">&emsp;How it works</span></h2>
The <code>git revert</code> command is used for undoing changes to a repository's commit history. 

Other 'undo' commands like, <code><a href="/git/tutorials/using-branches/git-checkout" data-event="clicked" data-uuid="5d4c42a1-e9" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git checkout</a></code> and <code><a href="/git/tutorials/undoing-changes/git-reset" data-event="clicked" data-uuid="5d4c42a1-e9" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git reset</a></code>, move the <code>HEAD</code> and branch ref pointers to a specified commit. 
<code>Git revert</code> also takes a specified commit, however, <code>git revert</code> does not move ref pointers to this commit. 
A revert operation will take the specified commit, inverse the changes from that commit, and create a new "revert commit". 
The ref pointers are then updated to point at the new revert commit making it the tip of the branch.

To demonstrate let’s create an example repo using the command line examples below:
<code>$ mkdir git_revert_test
$ cd git_revert_test/
$ git init .

Initialized empty Git repository in /git_revert_test/.git/
$ touch demo_file
$ git add demo_file
$ git commit -am"initial commit"

[main (root-commit) 299b15f] initial commit
1 file changed, 0 insertions(+), 0 deletions(-)
create mode 100644 demo_file
$ echo "initial content" >> demo_file

$ git commit -am"add new content to demo file"
[main 3602d88] add new content to demo file
n 1 file changed, 1 insertion(+)
$ echo "prepended line content" >> demo_file

$ git commit -am"prepend content to demo file"
[main 86bb32e] prepend content to demo file
1 file changed, 1 insertion(+)
$ git log --oneline

86bb32e prepend content to demo file
3602d88 add new content to demo file
299b15f initial commit</code>
Here we have initialized a repo in a newly created directory named <code>git_revert_test</code>. 

We have made 3 commits to the repo in which we have added a file <code>demo_file</code> and modified its content twice. 
At the end of the repo setup procedure, we invoke <code>git log</code> to display the commit history, showing a total of 3 commits. 
With the repo in this state, we are ready to initiate a <code>git revert.</code>
<code>$ git revert HEAD [main b9cd081] Revert "prepend content to demo file" 1 file changed, 1 deletion(-)</code>

<code>Git revert</code> expects a commit ref was passed in and will not execute without one. 
Here we have passed in the <code>HEAD</code> ref. 
This will revert the latest commit. 
This is the same behavior as if we reverted to commit <code>3602d8815dbfa78cd37cd4d189552764b5e96c58</code>. 

Similar to a merge, a revert will create a new commit which will open up the configured system editor prompting for a new commit message. 
Once a commit message has been entered and saved Git will resume operation. 
We can now examine the state of the repo using <code>git log</code> and see that there is a new commit added to the previous log:
<code>$ git log --oneline 1061e79 Revert "prepend content to demo file" 86bb32e prepend content to demo file 3602d88 add new content to demo file 299b15f initial commit</code>

Note that the 3rd commit is still in the project history after the revert. 
Instead of deleting it, <code>git revert</code> added a new commit to undo its changes. 
As a result, the 2nd and 4th commits represent the exact same code base and the 3rd commit is still in our history just in case we want to go back to it down the road.
<h2><span class="saddlebrown">&emsp;Common options</span></h2>
<code>-e
--edit</code>
This is a default option and doesn't need to be specified. 
This option will open the configured system editor and prompts you to edit the commit message prior to committing the revert

<code>--no-edit</code>
This is the inverse of the <code>-e</code> option. 
The revert will not open the editor.
<code>-n

--no-commit</code>
Passing this option will prevent <code>git revert</code> from creating a new commit that inverses the target commit. 
Instead of creating the new commit this option will add the inverse changes to the Staging Index and Working Directory. 
These are the other trees Git uses to manage the state of the repository. 

For more info visit the <code><a href="/git/tutorials/undoing-changes/git-reset" data-event="clicked" data-uuid="1e50c0e7-9c" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git reset</a></code> page.
<h2><span class="saddlebrown">&emsp;Resetting vs. reverting</span></h2>
It's important to understand that <code>git revert</code> undoes a single commit—it does not "revert" back to the previous state of a project by removing all subsequent commits. 
In Git, this is actually called a reset, not a revert.

<img src="https://wac-cdn.atlassian.com/dam/jcr:a6a50d78-48e3-4765-8492-9e48dec8fd2f/04%20(2).svg?cdnVersion=217" loading="lazy" alt="Git revert vs Git reset - Atlassian git tutorials">Reverting has two important advantages over resetting. 
First, it doesn’t change the project history, which makes it a “safe” operation for commits that have already been published to a shared repository. 
For details about why altering shared history is dangerous, please see the <a href="/git/tutorials/undoing-changes/git-reset" data-event="clicked" data-uuid="c15a517f-54" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git reset</a> page.
Second, <code>git revert</code> is able to target an individual commit at an arbitrary point in the history, whereas <code>git reset</code> can only work backward from the current commit. 

For example, if you wanted to undo an old commit with <code>git reset</code>, you would have to remove all of the commits that occurred after the target commit, remove it, then re-commit all of the subsequent commits. 
Needless to say, this is not an elegant undo solution. 
For a more detailed discussion on the differences between <code>git revert</code> and other 'undo' commands see <a href="/git/tutorials/resetting-checking-out-and-reverting" data-event="clicked" data-uuid="c15a517f-54" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Resetting, Checking Out and Reverting.</a>  
<h2><span class="saddlebrown">&emsp;Summary</span></h2>
The <code>git revert</code> command is a forward-moving undo operation that offers a safe method of undoing changes. 

Instead of deleting or orphaning commits in the commit history, a revert will create a new commit that inverses the changes specified. 
<code>Git revert</code> is a safer alternative to <code>git reset</code> in regards to losing work. 
To demonstrate the effects of <code>git revert</code> we leveraged other commands that have more in-depth documentation on their individual pages: <code><a href="/git/tutorials/git-log" data-event="clicked" data-uuid="c15a517f-54" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git log</a></code>, <code><a href="/git/tutorials/saving-changes/git-commit" data-event="clicked" data-uuid="c15a517f-54" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git commit</a>, and</code> <code><a href="/git/tutorials/undoing-changes/git-reset" data-event="clicked" data-uuid="c15a517f-54" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git reset</a>.</code>
<h2><br><span class="orange">Git Reset</span></h2>
The <code>git reset</code> command is a complex and versatile tool for undoing changes. 
It has three primary forms of invocation. 
These forms correspond to command line arguments <code>--soft, --mixed, --hard</code>. 
The three arguments each correspond to Git's three internal state management mechanism's, The Commit Tree (<code>HEAD</code>), The Staging Index, and The Working Directory.
<h2><span class="saddlebrown">&emsp;Git Reset &amp; Three Trees of Git</span></h2>
To properly understand <code>git reset</code> usage, we must first understand Git's internal state management systems. 
Sometimes these mechanisms are called Git's "three trees". 
Trees may be a misnomer, as they are not strictly traditional tree data-structures. 
They are, however, node and pointer-based data structures that Git uses to track a timeline of edits. 

The best way to demonstrate these mechanisms is to create a changeset in a repository and follow it through the three trees. 
To get started we will create a new repository with the commands below:
<code>$ mkdir git_reset_test
$ cd git_reset_test/

$ git init .
Initialized empty Git repository in /git_reset_test/.git/
$ touch reset_lifecycle_file
$ git add reset_lifecycle_file

$ git commit -m"initial commit"
[main (root-commit) d386d86] initial commit
1 file changed, 0 insertions(+), 0 deletions(-)
create mode 100644 reset_lifecycle_file</code>

The above example code creates a new git repository with a single empty file, <code>reset_lifecycle_file</code>. 
At this point, the example repository has a single commit (<code>d386d86</code>) from adding <code>reset_lifecycle_file</code>.
<h2><span class="saddlebrown">&emsp;The working directory</span></h2>
The first tree we will examine is "The Working Directory". 

This tree is in sync with the local filesystem and is representative of the immediate changes made to content in files and directories.
<code class="nohighlight custom">
$ echo 'hello git reset' > reset_lifecycle_file
$ git status 

On branch main
Changes not staged for commit: 
(use "git add ..." to update what will be committed) 
(use "git checkout -- ..." to discard changes in working directory) 

<span>modified: reset_lifecycle_file</span>
</code>
In our demo repository, we modify and add some content to the <code>reset_lifecycle_file</code>. 
Invoking <code>git status</code> shows that Git is aware of the changes to the file. 

These changes are currently a part of the first tree, "The Working Directory". 
<code>Git status</code> can be used to show changes to the Working Directory. 
They will be displayed in the red with a 'modified' prefix.
<h2><span class="saddlebrown">&emsp;Staging index</span></h2>
Next up is the 'Staging Index' tree. 
This tree is tracking Working Directory changes, that have been promoted with <code>git add</code>, to be stored in the next commit. 
This tree is a complex internal caching mechanism. 
Git generally tries to hide the implementation details of the Staging Index from the user.

To accurately view the state of the Staging Index we must utilize a lesser known Git command <code>git ls-files</code>. 
The <code>git ls-files</code> command is essentially a debug utility for inspecting the state of the Staging Index tree.
<code>git ls-files -s
100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0   reset_lifecycle_file</code>

Here we have executed <code>git ls-files</code> with the <code>-s</code> or <code>--stage</code> option. 
Without the <code>-s</code> option the <code>git ls-files</code> output is simply a list of file names and paths that are currently part of the index. 
The <code>-s</code> option displays additional metadata for the files in the Staging Index. 
This metadata is the staged contents' mode bits, object name, and stage number. 

Here we are interested in the object name, the second value (<code>d7d77c1b04b5edd5acfc85de0b592449e5303770</code>). 
This is a standard Git object SHA-1 hash. 
It is a hash of the content of the files. 
The Commit History stores its own object SHA's for identifying pointers to commits and refs and the Staging Index has its own object SHA's for tracking versions of files in the index.

Next, we will promote the modified <code>reset_lifecycle_file</code> into the Staging Index.
<code class="nohighlight custom">
$ git add reset_lifecycle_file 
$ git status 

On branch main Changes to be committed: 
(use "git reset HEAD ..." to unstage) 
<span>modified: reset_lifecycle_file</span>
</code>

Here we have invoked <code>git add reset_lifecycle_file</code> which adds the file to the Staging Index. 
Invoking <code>git status</code> now shows <code>reset_lifecycle_file</code> in green under "Changes to be committed". 
It is important to note that <code>git status</code> is not a true representation of the Staging Index. 
The <code>git status</code> command output displays changes between the Commit History and the Staging Index. 

Let us examine the Staging Index content at this point.
<code>$ git ls-files -s 100644 d7d77c1b04b5edd5acfc85de0b592449e5303770 0 reset_lifecycle_file</code>
We can see that the object SHA for <code>reset_lifecycle_file</code> has been updated from <code>e69de29bb2d1d6434b8b29ae775ad8c2e48c5391</code> to <code>d7d77c1b04b5edd5acfc85de0b592449e5303770</code>.
<h2><span class="saddlebrown">&emsp;Commit history</span></h2>
The final tree is the Commit History. 
The <code>git commit</code> command adds changes to a permanent snapshot that lives in the Commit History. 
This snapshot also includes the state of the Staging Index at the time of commit.
<code>$ git commit -am"update content of reset_lifecycle_file"

[main dc67808] update content of reset_lifecycle_file
1 file changed, 1 insertion(+)
$ git status
On branch main

nothing to commit, working tree clean</code>
Here we have created a new commit with a message of <code>"update content of resetlifecyclefile"</code>. 
The changeset has been added to the Commit History. 
Invoking <code>git status</code> at this point shows that there are no pending changes to any of the trees. 

Executing <code>git log</code> will display the Commit History. 
Now that we have followed this changeset through the three trees we can begin to utilize <code>git reset</code>.
<h2><span class="saddlebrown">&emsp;How it works</span></h2>
At a surface level, <code>git reset</code> is similar in behavior to <code>git checkout</code>. 

Where <code>git checkout</code> solely operates on the <code>HEAD</code> ref pointer, <code>git reset</code> will move the <code>HEAD</code> ref pointer and the current branch ref pointer. 
To better demonstrate this behavior consider the following example:
<img src="https://wac-cdn.atlassian.com/dam/jcr:8d616ece-8cee-4fde-bdee-4b280a0a8334/01%20git-sequence-transparent%20kopiera.png?cdnVersion=217" loading="lazy" alt='4 nodes with "main node" being the last one'>This example demonstrates a sequence of commits on the <code>main</code> branch. 
The <code>HEAD</code> ref and <code>main</code> branch ref currently point to commit d. 

Now let us execute and compare, both <code>git checkout b</code> and <code>git reset b.</code>
<h3>&emsp;git checkout b</h3>
<img src="https://wac-cdn.atlassian.com/dam/jcr:f45c4a34-8968-4c81-83cf-d55ebf01a447/02%20git-checkout-transparent%20kopiera.png?cdnVersion=217" loading="lazy" alt="4 nodes with main pointing at last node and head pointing at 2nd node">With <code>git checkout</code>, the <code>main</code> ref is still pointing to <code>d</code>. 
The <code>HEAD</code> ref has been moved, and now points at commit <code>b</code>. 

The repo is now in a 'detached <code>HEAD</code>' state.
<h3>&emsp;git reset b</h3>
<img src="https://wac-cdn.atlassian.com/dam/jcr:bdf5fda3-4aac-4170-ba35-58f7a66ea3c4/03%20git-reset-transparent%20kopiera.png?cdnVersion=217" loading="lazy" alt="2 sets of 2 nodes, with head,main pointing at the 2nd of the 1st set">Comparatively, <code>git reset</code>, moves both the <code>HEAD</code> and branch refs to the specified commit.
In addition to updating the commit ref pointers, <code>git reset</code> will modify the state of the three trees. 

The ref pointer modification always happens and is an update to the third tree, the Commit tree. 
The command line arguments <code>--soft, --mixed</code>, and <code>--hard</code> direct how to modify the Staging Index, and Working Directory trees.
<h2><span class="saddlebrown">&emsp;Main Options</span></h2>
The default invocation of <code>git reset</code> has implicit arguments of <code>--mixed</code> and <code>HEAD</code>. 

This means executing <code>git reset</code> is equivalent to executing <code>git reset --mixed HEAD</code>. 
In this form <code>HEAD</code> is the specified commit. 
Instead of <code>HEAD</code> any Git SHA-1 commit hash can be used.
<img src="https://wac-cdn.atlassian.com/dam/jcr:7fb4b5f7-a2cd-4cb7-9a32-456202499922/03%20(8).svg?cdnVersion=217" loading="lazy" alt="diagram of scope of git resets">
<h2><span class="saddlebrown">&emsp;--hard</span></h2>
This is the most direct, DANGEROUS, and frequently used option. 
When passed <code>--hard</code> The Commit History ref pointers are updated to the specified commit. 
Then, the Staging Index and Working Directory are reset to match that of the specified commit. 
Any previously pending changes to the Staging Index and the Working Directory gets reset to match the state of the Commit Tree. 

This means any pending work that was hanging out in the Staging Index and Working Directory will be lost.
To demonstrate this, let's continue with the three tree example repo we established earlier. 
First let's make some modifications to the repo. 
Execute the following commands in the example repo:

<code>$ echo 'new file content' > new_file
$ git add new_file
$ echo 'changed content' >> reset_lifecycle_file</code>
These commands have created a new file named <code>new_file</code> and added it to the repo. 

Additionally, the content of <code>reset_lifecycle_file</code> will be modified. 
With these changes in place let us now examine the state of the repo using <code>git status</code>.
<code>$ git status
On branch main

Changes to be committed:
 (use "git reset HEAD ..." to unstage)
new file: new_file
Changes not staged for commit:

 (use "git add ..." to update what will be committed)
 (use "git checkout -- ..." to discard changes in working directory)
modified: reset_lifecycle_file</code>
We can see that there are now pending changes to the repo. 

The Staging Index tree has a pending change for the addition of <code>new_file</code> and the Working Directory has a pending change for the modifications to <code>reset_lifecycle_file</code>.
Before moving forward let us also examine the state of the Staging Index:
<code>$ git ls-files -s
100644 8e66654a5477b1bf4765946147c49509a431f963 0 new_file

100644 d7d77c1b04b5edd5acfc85de0b592449e5303770 0 reset_lifecycle_file</code>
We can see that <code>new_file</code> has been added to the index. 
We have made updates to <code>reset_lifecycle_file</code> but the Staging Index SHA (<code>d7d77c1b04b5edd5acfc85de0b592449e5303770</code>) remains the same. 
This is expected behavior because have not used <code>git add</code> to promote these changes to the Staging Index. 

These changes exist in the Working Directory.
Let us now execute a <code>git reset --hard</code> and examine the new state of the repository.
<code>$ git reset --hard
HEAD is now at dc67808 update content of reset_lifecycle_file

$ git status
On branch main
nothing to commit, working tree clean
$ git ls-files -s

100644 d7d77c1b04b5edd5acfc85de0b592449e5303770 0 reset_lifecycle_file</code>
Here we have executed a "hard reset" using the <code>--hard</code> option. 
Git displays output indicating that <code>HEAD</code> is pointing to the latest commit <code>dc67808</code>. 
Next, we check the state of the repo with <code>git status</code>. 

Git indicates there are no pending changes. 
We also examine the state of the Staging Index and see that it has been reset to a point before <code>new_file</code> was added. 
Our modifications to <code>reset_lifecycle_file</code> and the addition of <code>new_file</code> have been destroyed. 
This data loss cannot be undone, this is critical to take note of.
<h2><span class="saddlebrown">&emsp;--mixed</span></h2>
This is the default operating mode. 
The ref pointers are updated. 
The Staging Index is reset to the state of the specified commit. 

Any changes that have been undone from the Staging Index are moved to the Working Directory. 
Let us continue.
<code>$ echo 'new file content' > new_file
$ git add new_file

$ echo 'append content' >> reset_lifecycle_file
$ git add reset_lifecycle_file
$ git status
On branch main

Changes to be committed:
(use "git reset HEAD ..." to unstage)
new file: new_file
modified: reset_lifecycle_file

$ git ls-files -s
100644 8e66654a5477b1bf4765946147c49509a431f963 0 new_file
100644 7ab362db063f9e9426901092c00a3394b4bec53d 0 reset_lifecycle_file</code>
In the example above we have made some modifications to the repository. 

Again, we have added a <code>new_file</code> and modified the contents of <code>reset_lifecycle_file</code>. 
These changes are then applied to the Staging Index with <code>git add</code>. 
With the repo in this state, we will now execute the reset.
<code>$ git reset --mixed

$ git status
On branch main
Changes not staged for commit:
(use "git add ..." to update what will be committed)

(use "git checkout -- ..." to discard changes in working directory)
modified: reset_lifecycle_file
Untracked files:
(use "git add ..." to include in what will be committed)

new_file
no changes added to commit (use "git add" and/or "git commit -a")
$ git ls-files -s
100644 d7d77c1b04b5edd5acfc85de0b592449e5303770 0 reset_lifecycle_file</code>

Here we have executed a "mixed reset". 
To reiterate, <code>--mixed</code> is the default mode and the same effect as executing <code>git reset</code>. 
Examining the output from <code>git status</code> and <code>git ls-files</code>, shows that the Staging Index has been reset to a state where <code>reset_lifecycle_file</code> is the only file in the index. 
The object SHA for <code>reset_lifecycle_file</code> has been reset to the previous version.

The important things to take note of here is that <code>git status</code> shows us that there are modifications to <code>reset_lifecycle_file</code> and there is an untracked file: <code>new_file</code>. 
This is the explicit <code>--mixed</code> behavior. 
The Staging Index has been reset and the pending changes have been moved into the Working Directory. 
Compare this to the <code>--hard</code> reset case where the Staging Index was reset and the Working Directory was reset as well, losing these updates.
<h2><span class="saddlebrown">&emsp;--soft</span></h2>
When the <code>--soft</code> argument is passed, the ref pointers are updated and the reset stops there. 
The Staging Index and the Working Directory are left untouched. 
This behavior can be hard to clearly demonstrate. 

Let's continue with our demo repo and prepare it for a soft reset.
<code class="nohighlight custom">
$ git add reset_lifecycle_file 
$ git ls-files -s 

100644 67cc52710639e5da6b515416fd779d0741e3762e 0 reset_lifecycle_file 
$ git status 
On branch main
Changes to be committed: 

(use "git reset HEAD ..." to unstage) 
<span>modified: reset_lifecycle_file </span>
Untracked files: 
(use "git add ..." to include in what will be committed) 

new_file
</code>
Here we have again used <code>git add</code> to promote the modified <code>reset_lifecycle_file</code> into the Staging Index. 
We confirm that the index has been updated with the <code>git ls-files</code> output. 

The output from <code>git status</code> now displays the "Changes to be committed" in green. 
The <code>new_file</code> from our previous examples is floating around in the Working Directory as an untracked file. 
Lets quickly execute <code>rm new_file</code> to delete the file as we will not need it for the upcoming examples.
With the repository in this state we now execute a soft reset.

<code>$ git reset --soft
$ git status
On branch main
Changes to be committed:

(use "git reset HEAD ..." to unstage)
modified: reset_lifecycle_file
$ git ls-files -s
100644 67cc52710639e5da6b515416fd779d0741e3762e 0 reset_lifecycle_file</code>

We have executed a 'soft reset'. 
Examining the repo state with <code>git status</code> and <code>git ls-files</code> shows that nothing has changed. 
This is expected behavior. 
A soft reset will only reset the Commit History. 

By default, <code>git reset</code> is invoked with <code>HEAD</code> as the target commit. 
Since our Commit History was already sitting on <code>HEAD</code> and we implicitly reset to <code>HEAD</code> nothing really happened.
To better understand and utilize <code>--soft</code> we need a target commit that is not <code>HEAD</code>. 
We have <code>reset_lifecycle_file</code> waiting in the Staging Index. 

Let's create a new commit.
<code>$ git commit -m"prepend content to reset_lifecycle_file"</code>
At this point, our repo should have three commits. 
We will be going back in time to the first commit. 

To do this we will need the first commit's ID. 
This can be found by viewing output from <code>git log</code>.
<code>$ git log
commit 62e793f6941c7e0d4ad9a1345a175fe8f45cb9df

Author: bitbucket 
Date: Fri Dec 1 15:03:07 2017 -0800
prepend content to reset_lifecycle_file
commit dc67808a6da9f0dec51ed16d3d8823f28e1a72a

Author: bitbucket 
Date: Fri Dec 1 10:21:57 2017 -0800
update content of reset_lifecycle_file
commit 780411da3b47117270c0e3a8d5dcfd11d28d04a4

Author: bitbucket 
Date: Thu Nov 30 16:50:39 2017 -0800
initial commit</code>
Keep in mind that Commit History ID's will be unique to each system. 

This means the commit ID's in this example will be different from what you see on your personal machine. 
The commit ID we are interested in for this example is <code>780411da3b47117270c0e3a8d5dcfd11d28d04a4</code>. 
This is the ID that corresponds to the "initial commit". 
Once we have located this ID we will use it as the target for our soft reset.

Before we travel back in time lets first check the current state of the repo.
<code>$ git status &amp;&amp; git ls-files -s
On branch main
nothing to commit, working tree clean

100644 67cc52710639e5da6b515416fd779d0741e3762e 0 reset_lifecycle_file</code>
Here we execute a combo command of <code>git status and </code><code>git ls-files -s</code> this shows us there are pending changes to the repo and <code>reset_lifecycle_file</code> in the Staging Index is at a version of <code>67cc52710639e5da6b515416fd779d0741e3762e</code>. 
With this in mind lets execute a soft reset back to our first commit.
<code>$git reset --soft 780411da3b47117270c0e3a8d5dcfd11d28d04a4

$ git status &amp;&amp; git ls-files -s
On branch main
Changes to be committed:
(use "git reset HEAD ..." to unstage)

modified: reset_lifecycle_file
100644 67cc52710639e5da6b515416fd779d0741e3762e 0 reset_lifecycle_file</code>
The code above executes a "soft reset" and also invokes the <code>git status</code> and <code>git ls-files</code> combo command, which outputs the state of the repository. 
We can examine the repo state output and note some interesting observations. 

First, <code>git status</code> indicates there are modifications to <code>reset_lifecycle_file</code> and highlights them indicating they are changes staged for the next commit. 
Second, the <code>git ls-files</code> input indicates that the Staging Index has not changed and retains the SHA 67cc52710639e5da6b515416fd779d0741e3762e we had earlier.
To further clarify what has happened in this reset let us examine the <code>git log:</code> 
<code>$ git log commit 780411da3b47117270c0e3a8d5dcfd11d28d04a4 Author: bitbucket <bitbucket> Date: Thu Nov 30 16:50:39 2017 -0800 initial commit</bitbucket></code>

The log output now shows that there is a single commit in the Commit History. 
This helps to clearly illustrate what <code>--soft</code> has done. 
As with all <code>git reset</code> invocations, the first action reset takes is to reset the commit tree. 
Our previous examples with <code>--hard</code> and <code>--mixed</code> have both been against the <code>HEAD</code> and have not moved the Commit Tree back in time. 

During a soft reset, this is all that happens.
This may then be confusing as to why <code>git status</code> indicates there are modified files. 
<code>--soft</code> does not touch the Staging Index, so the updates to our Staging Index followed us back in time through the commit history. 
This can be confirmed by the output of <code>git ls-files -s</code> showing that the SHA for <code>reset_lifecycle_file</code> is unchanged. 

As a reminder, <code>git status</code> does not show the state of 'the three trees', it essentially shows a diff between them. 
In this case, it is displaying that the Staging Index is ahead of the changes in the Commit History as if we have already staged them.
<h2><span class="saddlebrown">&emsp;Resetting vs Reverting</span></h2>
If <code><a href="/git/tutorials/undoing-changes/git-revert" data-event="clicked" data-uuid="9a314d2c-2f" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git revert</a></code> is a “safe” way to undo changes, you can think of <code>git reset</code> as the dangerous method. 

There is a real risk of losing work with <code>git reset</code>. 
<code>Git reset</code> will never delete a commit, however, commits can become 'orphaned' which means there is no direct path from a ref to access them. 
These orphaned commits can usually be found and restored using <code><a href="/git/tutorials/rewriting-history/git-reflog" data-event="clicked" data-uuid="9a314d2c-2f" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git reflog</a></code>. 
Git will permanently delete any orphaned commits after it runs the internal garbage collector. 

By default, Git is configured to run the garbage collector every 30 days. 
Commit History is one of the 'three git trees' the other two, Staging Index and Working Directory are not as permanent as Commits. 
Care must be taken when using this tool, as it’s one of the only Git commands that have the potential to lose your work.
Whereas reverting is designed to safely undo a public commit, <code>git reset</code> is designed to undo local changes to the Staging Index and Working Directory. 

Because of their distinct goals, the two commands are implemented differently: resetting completely removes a changeset, whereas reverting maintains the original changeset and uses a new commit to apply the undo.
<h2><span class="saddlebrown">&emsp;Don't Reset Public History</span></h2>
You should never use <code>git reset <commit></commit></code> when any snapshots after <commit> have been pushed to a public repository. 
After publishing a commit, you have to assume that other developers are reliant upon it.</commit>

Removing a commit that other team members have continued developing poses serious problems for collaboration. 
When they try to sync up with your repository, it will look like a chunk of the project history abruptly disappeared. 
The sequence below demonstrates what happens when you try to reset a public commit. 
The <code>origin/main</code> branch is the central repository’s version of your local <code>main</code> branch.

<img src="https://wac-cdn.atlassian.com/dam/jcr:c42c55b9-72fd-45c0-8e66-ad1025a7fd1f/04-06%20Don&amp;%23039;t%20Reset%20Public%20History.svg?cdnVersion=217" loading="lazy" alt="4 sets of nodes with origin/main pointing at the last one " class="block center max-height-fix">As soon as you add new commits after the reset, Git will think that your local history has diverged from <code>origin/main</code>, and the merge commit required to synchronize your repositories is likely to confuse and frustrate your team.
The point is, make sure that you’re using <code>git reset <commit></commit></code> on a local experiment that went wrong—not on published changes. 
If you need to fix a public commit, the <code>git revert</code> command was designed specifically for this purpose.
<h2><span class="saddlebrown">&emsp;Examples</span></h2>
<code>git reset ＜file＞</code>
Remove the specified file from the staging area, but leave the working directory unchanged. 
This unstages a file without overwriting any changes.
<code>git reset</code>

Reset the staging area to match the most recent commit, but leave the working directory unchanged. 
This unstages all files without overwriting any changes, giving you the opportunity to re-build the staged snapshot from scratch.
<code>git reset --hard</code>
Reset the staging area and the working directory to match the most recent commit. 

In addition to unstaging changes, the <code>--hard</code> flag tells Git to overwrite all changes in the working directory, too. 
Put another way: this obliterates all uncommitted changes, so make sure you really want to throw away your local developments before using it.
<code>git reset <commit><commit></commit></commit></code>
Move the current branch tip backward to <code>commit</code>, reset the staging area to match, but leave the working directory alone. 

All changes made since <code><commit> </commit></code>will reside in the working directory, which lets you re-commit the project history using cleaner, more atomic snapshots.
<code>git reset --hard <commit><commit></commit></commit></code>
Move the current branch tip backward to <code><commit> </commit></code> and reset both the staging area and the working directory to match. 
This obliterates not only the uncommitted changes, but all commits after, as well.
<h2><span class="saddlebrown">&emsp;Unstaging a file</span></h2>
The <code>git reset</code> command is frequently encountered while preparing the staged snapshot. 
The next example assumes you have two files called <code>hello.py</code> and <code>main.py</code> that you’ve already added to the repository.
<code># Edit both hello.py and main.py

# Stage everything in the current directory
git add .
# Realize that the changes in hello.py and main.py
# should be committed in different snapshots

# Unstage main.py
git reset main.py
# Commit only hello.py
git commit -m "Make some changes to hello.py"

# Commit main.py in a separate snapshot
git add main.py
git commit -m "Edit main.py"</code>
As you can see, <code>git reset</code> helps you keep your commits highly-focused by letting you unstage changes that aren’t related to the next commit.
<h2><span class="saddlebrown">&emsp;Removing Local Commits</span></h2>
The next example shows a more advanced use case. 
It demonstrates what happens when you’ve been working on a new experiment for a while, but decide to completely throw it away after committing a few snapshots.
<code># Create a new file called `foo.py` and add some code to it

# Commit it to the project history
git add foo.py
git commit -m "Start developing a crazy feature"
# Edit `foo.py` again and change some other tracked files, too

# Commit another snapshot
git commit -a -m "Continue my crazy feature"
# Decide to scrap the feature and remove the associated commits
git reset --hard HEAD~2</code>

The <code>git reset HEAD~2</code> command moves the current branch backward by two commits, effectively removing the two snapshots we just created from the project history. 
Remember that this kind of reset should only be used on unpublished commits. 
Never perform the above operation if you’ve already pushed your commits to a shared repository.
<h2><span class="saddlebrown">&emsp;Summary</span></h2>
To review, <code>git reset</code> is a powerful command that is used to undo local changes to the state of a Git repo. 
<code>Git reset</code> operates on "The Three Trees of Git". 
These trees are the Commit History (<code>HEAD</code>), the Staging Index, and the Working Directory. 
There are three command line options that correspond to the three trees. 

The options <code>--soft, --mixed</code>, and <code>--hard</code> can be passed to <code>git reset</code>.
In this article we leveraged several other Git commands to help demonstrate the reset processes. 
Learn more about those commands on their individual pages at: <code><a href="/git/tutorials/inspecting-a-repository" data-event="clicked" data-uuid="b8bb2004-b2" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git status</a>, <a href="/git/tutorials/git-log" data-event="clicked" data-uuid="b8bb2004-b2" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git log</a>, <a href="/git/tutorials/saving-changes" data-event="clicked" data-uuid="b8bb2004-b2" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git add</a>, <a href="/git/tutorials/using-branches/git-checkout" data-event="clicked" data-uuid="b8bb2004-b2" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git checkout</a>, <a href="/git/tutorials/rewriting-history/git-reflog" data-event="clicked" data-uuid="b8bb2004-b2" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git reflog</a>,</code> and <code> <a href="/git/tutorials/undoing-changes/git-revert" data-event="clicked" data-uuid="b8bb2004-b2" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git revert</a></code>.
<h2><br><span class="orange">Git RM</span></h2>
A common question when getting started with Git is "How do I tell Git not to track a file (or files) any more?" The <code>git rm</code> command is used to remove files from a Git repository. 
It can be thought of as the inverse of the <code><a href="/git/tutorials/saving-changes" data-event="clicked" data-uuid="9aba4cd0-7c" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git add</a></code> command.
<h2><span class="saddlebrown">&emsp;Git rm Overview</span></h2>
The <code>git rm</code> command can be used to remove individual files or a collection of files. 

The primary function of <code>git rm</code> is to remove tracked files from the Git index. 
Additionally, <code>git rm</code> can be used to remove files from both the staging index and the working directory. 
There is no option to remove a file from only the working directory. 
The files being operated on must be identical to the files in the current <code>HEAD</code>. 

If there is a discrepancy between the <code>HEAD</code> version of a file and the staging index or working tree version, Git will block the removal. 
This block is a safety mechanism to prevent removal of in-progress changes.
Note that <code>git rm</code> does not remove branches. 
Learn more about <a href="/git/tutorials/using-branches" data-event="clicked" data-uuid="3c4dd8e2-16" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">using git branches</a>
<h2><span class="saddlebrown">&emsp;Usage</span></h2>
<code>&lt;file>…</code>
Specifies the target files to remove. 
The option value can be an individual file, a space delimited list of files <code>file1 file2 file3</code>, or a wildcard file glob <code>(~./directory/*)</code>.

<code>-f
--force</code>
The <code>-f </code>option is used to override the safety check that Git makes to ensure that the files in <code>HEAD </code> match the current content in the staging index and working directory.
<code>-n

--dry-run</code>
The "dry run" option is a safeguard that will execute the <code>git rm</code> command but not actually delete the files. 
Instead it will output which files it would have removed.
<code>-r</code>

The <code>-r</code> option is shorthand for 'recursive'. 
When operating in recursive mode <code>git rm</code> will remove a target directory and all the contents of that directory.
<code>--</code>
The separator option is used to explicitly distinguish between a list of file names and the arguments being passed to <code>git rm</code>. 

This is useful if some of the file names have syntax that might be mistaken for other options.
<code>--cached</code>
The cached option specifies that the removal should happen only on the staging index. 
Working directory files will be left alone.

<code>--ignore-unmatch</code>
This causes the command to exit with a 0 sigterm status even if no files matched. 
This is a Unix level status code. 
The code 0 indicates a successful invocation of the command. 

The <code>--ignore-unmatch</code> option can be helpful when using <code>git rm</code> as part of a greater shell script that needs to fail gracefully.
<code>-q
--quiet</code>
The quiet option hides the output of the <code>git rm</code> command. 

The command normally outputs one line for each file removed.
<h2><span class="saddlebrown">&emsp;How to undo git rm</span></h2>
Executing <code>git rm</code> is not a permanent update. 
The command will update the staging index and the working directory. 

These changes will not be persisted until a new commit is created and the changes are added to the commit history. 
This means that the changes here can be "undone" using common Git commands.
<code>git reset HEAD</code>
A reset will revert the current staging index and working directory back to the <code>HEAD</code> commit. 

This will undo a <code>git rm</code>.
<code>git checkout .</code>
A checkout will have the same effect and restore the latest version of a file from <code>HEAD</code>.
In the event that <code>git rm</code> was executed and a new commit was created which persist the removal, <code>git reflog</code> can be used to find a ref that is before the <code>git rm</code> execution. 

Learn more about <a href="/git/tutorials/rewriting-history/git-reflog" data-event="clicked" data-uuid="88d6388e-6c" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">using git reflog</a>.
<h2><span class="saddlebrown">&emsp;Discussion</span></h2>
The &lt;<code>file></code> argument given to the command can be exact paths, wildcard file glob patterns, or exact directory names. 
The command removes only paths currently commited to the Git repository.

Wildcard file globbing matches across directories. 
It is important to be cautious when using wildcard globs. 
Consider the examples: <code>directory/*</code> and <code>directory*</code>. 
The first example will remove all sub files of <code>directory/</code> whereas the second example will remove all sibling directories like <code>directory1</code><code> directory2 </code><code>directory_whatever</code> which may be an unexpected result.
<h2><span class="saddlebrown">&emsp;The scope of git rm</span></h2>
The <code>git rm</code> command operates on the current branch only. 
The removal event is only applied to the working directory and staging index trees. 
The file removal is not persisted to the repository history until a new commit is created.
<h2><span class="saddlebrown">&emsp;Why use git rm instead of rm</span></h2>
A Git repository will recognize when a regular shell <code>rm</code> command has been executed on a file it is tracking. 
It will update the working directory to reflect the removal. 
It will not update the staging index with the removal. 

An additional <code>git add</code> command will have to be executed on the removed file paths to add the changes to the staging index. 
The <code>git rm</code> command acts a shortcut in that it will update the working directory and the staging index with the removal.
<h2><span class="saddlebrown">&emsp;Examples</span></h2>
<code>git rm Documentation/\*.txt</code>

This example uses a wildcard file glob to remove all <code>*.txt files</code> that are children of the <code>Documentation</code> directory and any of its subdirectories.
Note that the asterisk * is escaped with slashes in this example; this is a guard that prevents the shell from expanding the wildcard. 
The wildcard then expands the pathnames of files and subdirectories under the <code>Documentation/</code> directory.
<code>git rm -f git-*.sh</code>

This example uses the force option and targets all wildcard <code>git-*.sh</code> files. 
The force option explicitly removes the target files from both the working directory and staging index.
<h2><span class="saddlebrown">&emsp;How to remove files no longer in the filesystem</span></h2>
As stated above in "Why use <code>git rm</code> instead of <code>rm</code>" , <code>git rm</code> is actually a convenience command that combines the standard shell <code>rm</code> and <code>git add</code> to remove a file from the working directory and promote that removal to the staging index. 

A repository can get into a cumbersome state in the event that several files have been removed using only the standard shell <code>rm</code> command.
If intentions are to record all the explicitly removed files as part of the next commit, <code>git commit -a</code> will add all the removal events to the staging index in preparation of the next commit.
If however, intentions are to persistently remove the files that were removed with the shell <code>rm</code>, use the following command:
<code>git diff --name-only --diff-filter=D -z | xargs -0 git rm --cached</code>

This command will generate a list of the removed files from the working directory and pipe that list to <code>git rm --cached</code> which will update the staging index.
<h2><span class="saddlebrown">&emsp;Git rm summary</span></h2>
<code>git rm</code> is a command that operates on two of the primary Git <a href="/git/tutorials/undoing-changes/git-reset" data-event="clicked" data-uuid="3b9ee0c7-9b" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">internal state management trees</a>: the working directory, and staging index. 
<code>git rm</code> is used to remove a file from a Git repository. 
It is a convenience method that combines the effect of the default shell <code>rm</code> command with <code>git add</code>. 

This means that it will first remove a target from the filesystem and then add that removal event to the staging index. 
The command is one of many that can be used for <a href="/git/tutorials/undoing-changes" data-event="clicked" data-uuid="3b9ee0c7-9b" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">undoing changes in Git.</a>
<h2><br><span class="orange">Rewriting history</span></h2>
<h2><span class="saddlebrown">&emsp;Intro</span></h2>
This tutorial will cover various methods of rewriting and altering Git history. 
Git uses a few different methods to record changes. 
We will discuss the strengths and weaknesses of the different methods and give examples of how to work with them. 
This tutorial discusses some of the most common reasons for overwriting committed snapshots and shows you how to avoid the pitfalls of doing so.

Git's main job is to make sure you never lose a committed change. 
But it's also designed to give you total control over your development workflow. 
This includes letting you define exactly what your project history looks like; however, it also creates the potential of losing commits. 
Git provides its history-rewriting commands under the disclaimer that using them may result in lost content.

Git has several mechanisms for storing history and saving changes. 
These mechanisms include: Commit <code>--amend</code>, <code>git rebase</code> and <code>git reflog</code>. 
These options give you powerful work flow customization options. 
By the end of this tutorial, you'll be familiar with commands that will let you restructure your Git commits, and be able to avoid pitfalls that are commonly encountered when rewriting history.
<h2><span class="saddlebrown">&emsp;Changing the Last Commit: <code>git commit --amend</code></span></h2>
The <code>git commit --amend</code> command is a convenient way to modify the most recent commit. 
It lets you combine staged changes with the previous commit instead of creating an entirely new commit. 
It can also be used to simply edit the previous commit message without changing its snapshot. 

But, amending does not just alter the most recent commit, it replaces it entirely, meaning the amended commit will be a new entity with its own ref. 
To Git, it will look like a brand new commit, which is visualized with an asterisk (*) in the diagram below. 
There are a few common scenarios for using <code>git commit --amend</code>. 
We'll cover usage examples in the following sections.

<img src="https://wac-cdn.atlassian.com/dam/jcr:34fd0826-9e89-4ef1-bce8-b1325cf48306/01-02%20Changing%20the%20Last%20Commit.svg?cdnVersion=217" loading="lazy" alt="Git commit amend"><h3>&emsp;Change most recent Git commit message</h3>
<code>git commit --amend</code>
Let's say you just committed and you made a mistake in your commit log message. 
Running this command when there is nothing staged lets you edit the previous commit’s message without altering its snapshot.

Premature commits happen all the time in the course of your everyday development. 
It’s easy to forget to stage a file or to format your commit message the wrong way. 
The <code>--amend</code> flag is a convenient way to fix these minor mistakes.
<code>git commit --amend -m "an updated commit message"</code>

Adding the <code>-m</code> option allows you to pass in a new message from the command line without being prompted to open an editor.
<h3>&emsp;Changing committed files</h3>
The following example demonstrates a common scenario in Git-based development. 
Let's say we've edited a few files that we would like to commit in a single snapshot, but then we forget to add one of the files the first time around. 

Fixing the error is simply a matter of staging the other file and committing with the <code>--amend</code> flag:
<code># Edit hello.py and main.py
git add hello.py
git commit 

# Realize you forgot to add the changes from main.py 
git add main.py 
git commit --amend --no-edit</code>
The <code>--no-edit</code> flag will allow you to make the amendment to your commit without changing its commit message. 

The resulting commit will replace the incomplete one, and it will look like we committed the changes to <code>hello.py</code> and <code>main.py</code> in a single snapshot.
<h3>&emsp;Don’t amend public commits</h3>
Amended commits are actually entirely new commits and the previous commit will no longer be on your current branch. 
This has the same consequences as resetting a public snapshot. 

Avoid amending a commit that other developers have based their work on. 
This is a confusing situation for developers to be in and it’s complicated to recover from.
<h3>&emsp;Recap</h3>
To review, <code>git commit --amend</code> lets you take the most recent commit and add new staged changes to it. 

You can add or remove changes from the Git staging area to apply with a <code>--amend</code> commit. 
If there are no changes staged, a <code>--amend</code> will still prompt you to modify the last commit message log. 
Be cautious when using <code>--amend</code> on commits shared with other team members. 
Amending a commit that is shared with another user will potentially require confusing and lengthy merge conflict resolutions.
<h2><span class="saddlebrown">&emsp;Changing older or multiple commits</span></h2>
To modify older or multiple commits, you can use <code>git rebase</code> to combine a sequence of commits into a new base commit. 
In standard mode, <code>git rebase</code> allows you to literally rewrite history — automatically applying commits in your current working branch to the passed branch head. 
Since your new commits will be replacing the old, it's important to not use <code>git rebase</code> on commits that have been pushed public, or it will appear that your project history disappeared.

In these or similar instances where it's important to preserve a clean project history, adding the <code>-i</code> option to <code>git rebase</code> allows you to run <code>rebase interactive</code>. 
This gives you the opportunity to alter individual commits in the process, rather than moving all commits. 
You can learn more about interactive rebasing and additional rebase commands on the <a href="/git/tutorials/rewriting-history/git-rebase" data-event="clicked" data-uuid="14586184-ff" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git rebase page</a>.
<h4> Changing committed files
</h4>
During a rebase, the edit or <code>e</code> command will pause the rebase playback on that commit and allow you to make additional changes with <code>git commit --amend</code> Git will interrupt the playback and present a message:
<code>Stopped at 5d025d1... 
formatting

You can amend the commit now, with
git commit --amend
Once you are satisfied with your changes, run
git rebase --continue

</code>
<h4> Multiple messages</h4>
Each regular Git commit will have a log message explaining what happened in the commit. 

These messages provide valuable insight into the project history. 
During a rebase, you can run a few commands on commits to modify commit messages.
Reword or 'r' will stop rebase playback and let you rewrite the individual commit message during.
Squash or 's' during rebase playback, any commits marked <code>s</code> will be paused on and you will be prompted to edit the separate commit messages into a combined message. 

More on this in the squash commits section below.
Fixup or 'f' has the same combining effect as squash. 
Unlike squash, fixup commits will not interrupt rebase playback to open an editor to combine commit messages. 
The commits marked 'f' will have their messages discarded in-favor of the previous commit's message.

<h4> Squash commits for a clean history</h4>
The <code>s</code> "squash" command is where we see the true utility of rebase. 
Squash allows you to specify which commits you want to merge into the previous commits. 

This is what enables a "clean history." During rebase playback, Git will execute the specified rebase command for each commit. 
In the case of squash commits, Git will open your configured text editor and prompt to combine the specified commit messages. 
This entire process can be visualized as follows:
<img src="https://wac-cdn.atlassian.com/dam/jcr:d01223a6-df25-48b3-87fd-2b9140d9ae2b/03%20Squash%20commits%20for%20a%20clean%20history.svg?cdnVersion=217" loading="lazy" alt="Git Tutorial: git rebase -i example">Note that the commits modified with a rebase command have a different ID than either of the original commits. 

Commits marked with pick will have a new ID if the previous commits have been rewritten.
Modern Git hosting solutions like Bitbucket now offer "auto squashing" features upon merge. 
These features will automatically rebase and squash a branch's commits for you when utilizing the hosted solutions UI. 
For more info see "<a href="https://bitbucket.org/blog/git-squash-commits-merging-bitbucket" data-event="clicked" data-uuid="558502f1-ae" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Squash commits when merging a Git branch with Bitbucket</a>."

<h3>&emsp;Recap</h3>
Git rebase gives you the power to modify your history, and interactive rebasing allows you to do so without leaving a “messy” trail. 
This creates the freedom to make and correct errors and refine your work, while still maintaining a clean, linear project history.
<h2><span class="saddlebrown">&emsp;The safety net: git reflog</span></h2>
Reference logs, or "reflogs" are a mechanism Git uses to record updates applied to tips of branches and other commit references. 
Reflog allows you to go back to commits even though they are not referenced by any branch or tag. 
After rewriting history, the reflog contains information about the old state of branches and allows you to go back to that state if necessary. 
Every time your branch tip is updated for any reason (by switching branches, pulling in new changes, rewriting history or simply by adding new commits), a new entry will be added to the reflog. 

In this section we will take a high level look at the <code>git reflog</code> command and explore some common uses.
<h3>&emsp;Usage</h3>
<code>git reflog</code>
This displays the reflog for the local repository.

<code>git reflog --relative-date</code>
This shows the reflog with relative date information (e.g. 
2 weeks ago).
<h3>&emsp;Example</h3>

To understand <code>git reflog</code>, let's run through an example.
<code>0a2e358 HEAD@{0}: reset: moving to HEAD~2
0254ea7 HEAD@{1}: checkout: moving from 2.2 to main
c10f740 HEAD@{2}: checkout: moving from main to 2.2</code>

The reflog above shows a checkout from main to the 2.2 branch and back. 
From there, there's a hard reset to an older commit. 
The latest activity is represented at the top labeled <code>HEAD@{0}</code>.
If it turns out that you accidentally moved back, the reflog will contain the commit main pointed to <code>(0254ea7)</code> before you accidentally dropped 2 commits.

<code>git reset --hard 0254ea7</code>
Using Git reset, it is now possible to change main back to the commit it was before. 
This provides a safety net in case the history was accidentally changed.
It's important to note that the reflog only provides a safety net if changes have been committed to your local repository and that it only tracks movements of the repositories branch tip. 

Additionally reflog entries have an expiration date. 
The default expiration time for reflog entries is 90 days.
For additional information, see our <code><a href="/git/tutorials/rewriting-history/git-reflog" data-event="clicked" data-uuid="6088a949-85" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git reflog</a></code> page. 
<h2><span class="saddlebrown">&emsp;Summary</span></h2>
In this article we discussed several methods of changing git history, and undoing git changes. 
We took a high level look at the git rebase process. 
Some Key takeaways are:
There are many ways to rewrite history with git.

Use <code>git commit --amend</code> to change your latest log message.
Use <code>git commit --amend</code> to make modifications to the most recent commit.
Use <code>git rebase</code> to combine commits and modify history of a branch.
<code>git rebase -i</code> gives much more fine grained control over history modifications than a standard git rebase.

Learn more about the commands we covered at their individual pages:
<a href="/git/tutorials/rewriting-history/git-rebase" data-event="clicked" data-uuid="f79af9a1-52" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git rebase</a>
<a href="/git/tutorials/rewriting-history/git-reflog" data-event="clicked" data-uuid="f79af9a1-52" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git reflog</a>
<h2><br><span class="orange">git rebase</span></h2>
This document will serve as an in-depth discussion of the <code>git rebase</code> command. 
The Rebase command has also been looked at on the <a href="/git/tutorials/setting-up-a-repository" data-event="clicked" data-uuid="b0e63bbf-18" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">setting up a repository</a> and <a href="/git/tutorials/rewriting-history" data-event="clicked" data-uuid="b0e63bbf-18" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">rewriting history</a> pages. 
This page will take a more detailed look at <code>git rebase</code> configuration and execution. 
Common Rebase use cases and pitfalls will be covered here.

Rebase is one of two Git utilities that specializes in integrating changes from one branch onto another. 
The other change integration utility is <code>git merge</code>. 
Merge is always a forward moving change record. 
Alternatively, rebase has powerful history rewriting features. 

For a detailed look at Merge vs. Rebase, visit our <a href="/git/tutorials/merging-vs-rebasing" data-event="clicked" data-uuid="0f3e7f66-0d" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Merging vs Rebasing guide</a>. 
Rebase itself has 2 main modes: "manual" and "interactive" mode. 
We will cover the different Rebase modes in more detail below.
<h2><span class="saddlebrown">&emsp;What is git rebase?</span></h2>
<h2><br><span class="orange">git reflog</span></h2>
This page provides a detailed discussion of the <code>git reflog</code> command. 
Git keeps track of updates to the tip of branches using a mechanism called reference logs, or "reflogs." Many Git commands accept a parameter for specifying a reference or "ref", which is a pointer to a commit. 
Common examples include:

<code>git checkout </code>
<code>git reset </code>
<code>git merge <ref></ref></code>
Reflogs track when Git refs were updated in the local repository. 

In addition to branch tip reflogs, a special reflog is maintained for the Git stash. 
Reflogs are stored in directories under the local repository's <code>.git</code> directory. 
<code>git reflog</code> directories can be found at <code>.git/logs/refs/heads/.</code>, <code>.git/logs/HEAD</code>, and also <code>.git/logs/refs/stash</code> if the <code>git stash</code> has been used on the repo.
We discussed <code>git reflog</code> at a high level on the <a href="/git/tutorials/rewriting-history" data-event="clicked" data-uuid="3c4a2d0f-fb" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Rewriting History Page</a>. 

This document will cover: extended configuration options of <code>git reflog</code>, common use-cases and pitfalls of <code>git reflog</code>, how to undo changes with <code>git reflog</code>, and more.
<h2><span class="saddlebrown">&emsp;Basic usage</span></h2>
The most basic Reflog use case is invoking:
<code>git reflog</code>

This is essentially a short cut that's equivalent to:
<code>git reflog show HEAD</code>
This will output the <code>HEAD</code> reflog. 
You should see output similar to:

<code>eff544f HEAD@{0}: commit: migrate existing content
bf871fd HEAD@{1}: commit: Add Git Reflog outline
9a4491f HEAD@{2}: checkout: moving from main to git_reflog
9a4491f HEAD@{3}: checkout: moving from Git_Config to main

39b159a HEAD@{4}: commit: expand on git context 
9b3aa71 HEAD@{5}: commit: more color clarification
f34388b HEAD@{6}: commit: expand on color support 
9962aed HEAD@{7}: commit: a git editor -> the Git editor</code>

Visit the <a href="/git/tutorials/rewriting-history" data-event="clicked" data-uuid="c2763bb8-ec" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Rewriting History page</a> for another example of common reflog access.
<h3>&emsp;Reflog references</h3>
By default, <code>git reflog</code> will output the reflog of the <code>HEAD</code> ref. 
<code>HEAD</code> is a symbolic reference to the currently active branch. 

Reflogs are available for other refs as well. 
The syntax to access a git ref is <code>name@{qualifier}</code>. 
In addition to <code>HEAD</code> refs, other branches, tags, remotes, and the Git stash can be referenced as well.
You can get a complete reflog of all refs by executing:

<code> git reflog show --all </code>
To see the reflog for a specific branch pass that branch name to <code>git reflog show</code>
<code>git reflog show otherbranch 9a4491f otherbranch@{0}: commit: seperate articles into branch PRs 35aee4a otherbranch{1}: commit (initial): initial commit add git-init and setting-up-a-repo docs </code>
Executing this example will show a reflog for the <code>otherbranch</code> branch. 

The following example assumes you have previously stashed some changes using the <code>git stash</code> command.
<code>git reflog stash 0d44de3 stash@{0}: WIP on git_reflog: c492574 flesh out intro </code>
This will output a reflog for the Git stash. 
The returned ref pointers can be passed to other Git commands:

<code>git diff stash@{0} otherbranch@{0} </code>
When executed, this example code will display Git diff output comparing the <code>stash@{0}</code> changes against the <code>otherbranch@{0}</code> ref.
<h3>&emsp;Timed reflogs</h3>
Every reflog entry has a timestamp attached to it. 

These timestamps can be leveraged as the <code>qualifier</code> token of Git ref pointer syntax. 
This enables filtering Git reflogs by time. 
The following are some examples of available time qualifiers:
<code>1.minute.ago</code>

<code>1.hour.ago</code>
<code>1.day.ago</code>
<code>yesterday</code>
<code>1.week.ago</code>

<code>1.month.ago</code>
<code>1.year.ago</code>
<code>2011-05-17.09:00:00</code>
Time qualifiers can be combined (e.g. 

<code>1.day.2.hours.ago</code>), Additionally plural forms are accepted (e.g. 
<code>5.minutes.ago</code>).
Time qualifier refs can be passed to other git commands.
<code> git diff main@{0} main@{1.day.ago} </code>

This example will diff the current main branch against main 1 day ago. 
This example is very useful if you want to know changes that have occurred within a time frame.
<h2><span class="saddlebrown">&emsp;Subcommands &amp; configuration options</span></h2>
<code>git reflog</code> accepts few addition arguments which are considered subcommands.

<h3>&emsp;Show - <code>git reflog show</code></h3>
<code>show</code> is implicitly passed by default. 
For example, the command:
<code>git reflog main@{0} </code>

is equivalent to the command:
<code>git reflog show main@{0} </code>
In addition, <code>git reflog show</code> is an alias for <code>git log -g --abbrev-commit --pretty=oneline</code>. 
Executing <code>git reflog show <refid></refid></code> will display the log for the passed <refid>.<code><refid></refid></code></refid>

<h3>&emsp;Expire - <code>git reflog expire</code></h3>
The expire subcommand cleans up old or unreachable reflog entries. 
The <code>expire</code> subcommand has potential for data loss. 
This subcommand is not typically used by end users, but used by git internally. 

Passing a <code>-n</code> or <code>--dry-run</code> option to <code>git reflog expire</code> Will perform a "dry run" which will output which reflog entries are marked to be pruned, but will not actually prune them.
By default, the reflog expiration date is set to 90 days. 
An expire time can be specified by passing a command line argument <code>--expire=time</code> to <code>git reflog expire</code> or by setting a git configuration name of <code>gc.reflogExpire</code>.
<h3>&emsp;Delete - <code>git reflog delete</code></h3>

The <code>delete</code> subcommand is self explanatory and will delete a passed in reflog entry. 
As with <code>expire</code>, <code>delete</code> has potential to lose data and is not commonly invoked by end users.
<h2><span class="saddlebrown">&emsp;Recovering lost commits</span></h2>
Git never really loses anything, even when performing history rewriting operations like rebasing or commit amending. 

For the next example let's assume that we have made some new changes to our repo. 
Our <code>git log --pretty=oneline</code> looks like the following:
<code>338fbcb41de10f7f2e54095f5649426cb4bf2458 extended content 1e63ceab309da94256db8fb1f35b1678fb74abd4 bunch of content c49257493a95185997c87e0bc3a9481715270086 flesh out intro eff544f986d270d7f97c77618314a06f024c7916 migrate existing content bf871fd762d8ef2e146d7f0226e81a92f91975ad Add Git Reflog outline 35aee4a4404c42128bee8468a9517418ed0eb3dc initial commit add git-init and setting-up-a-repo docs </code>
We then commit those changes and execute the following:

<code>#make changes to HEAD git commit -am "some WIP changes" </code>
With the addition of the new commit. 
The log now looks like:
<code>37656e19d4e4f1a9b419f57850c8f1974f871b07 some WIP changes 338fbcb41de10f7f2e54095f5649426cb4bf2458 extended content 1e63ceab309da94256db8fb1f35b1678fb74abd4 bunch of content c49257493a95185997c87e0bc3a9481715270086 flesh out intro eff544f986d270d7f97c77618314a06f024c7916 migrate existing content bf871fd762d8ef2e146d7f0226e81a92f91975ad Add Git Reflog outline 35aee4a4404c42128bee8468a9517418ed0eb3dc initial commit add git-init and setting-up-a-repo docs </code>

At this point we perform an interactive rebase against the main branch by executing...
<code>git rebase -i origin/main </code>
During the rebase we mark commits for squash with the <code>s</code> rebase subcommand. 
During the rebase, we squash a few commits into the most recent "some WIP changes" commit.

Because we squashed commits the <code>git log</code> output now looks like:
<code>40dhsoi37656e19d4e4f1a9b419f57850ch87dah987698hs some WIP changes 35aee4a4404c42128bee8468a9517418ed0eb3dc initial commit add git-init and setting-up-a-repo docs </code>
If we examine <code>git log</code> at this point it appears that we no longer have the commits that were marked for squashing. 
What if we want to operate on one of the squashed commits? Maybe to remove its changes from history? This is an opportunity to leverage the reflog.

<code>git reflog 37656e1 HEAD@{0}: rebase -i (finish): returning to refs/heads/git_reflog 37656e1 HEAD@{1}: rebase -i (start): checkout origin/main 37656e1 HEAD@{2}: commit: some WIP changes </code>
We can see there are reflog entries for the start and finish of the <code>rebase</code> and prior to those is our "some WIP changes" commit. 
We can pass the reflog ref to <code>git reset</code> and reset to a commit that was before the rebase.
<code>git reset HEAD@{2} </code>

Executing this reset command will move <code>HEAD</code> to the commit where "some WIP changes" was added, essentially restoring the other squashed commits.
<h2><span class="saddlebrown">&emsp;Summary</span></h2>
In this tutorial we discussed the <code>git reflog</code> command. 
Some key points covered were:

How to view reflog for specific branches
How to undo a git rebase using the reflog
How specify and view time based reflog entries
We briefly mentioned that <code>git reflog</code> can be used with other git commands like <a href="/git/tutorials/using-branches/git-checkout" data-event="clicked" data-uuid="2afcb8c0-56" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git checkout</a>, <a href="/git/tutorials/resetting-checking-out-and-reverting" data-event="clicked" data-uuid="2afcb8c0-56" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git reset</a>, and <a href="/git/tutorials/using-branches/git-merge" data-event="clicked" data-uuid="2afcb8c0-56" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git merge</a>. 

Learn more at their respective pages. 
For additional discussion on refs and the reflog, <a href="/git/tutorials/refs-and-the-reflog" data-event="clicked" data-uuid="2afcb8c0-56" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">learn more here</a>.
<h2><br><span class="orange">git syncing</span></h2>
SVN uses a single centralized repository to serve as the communication hub for developers, and collaboration takes place by passing changesets between the developers’ working copies and the central repository. 

This is different from Git's distributed collaboration model, which gives every developer their own copy of the repository, complete with its own local history and branch structure. 
Users typically need to share a series of commits rather than a single changeset. 
Instead of committing a changeset from a working copy to the central repository, Git lets you share entire branches between repositories.
The <code>git remote</code> command is one piece of the broader system which is responsible for syncing changes. 

Records registered through the <code>git remote</code> command are used in conjunction with the <code><a href="/git/tutorials/syncing/git-fetch" data-event="clicked" data-uuid="54cb84e0-0a" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git fetch</a></code>, <code><a href="/git/tutorials/syncing/git-push" data-event="clicked" data-uuid="54cb84e0-0a" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git push</a></code>, and <code><a href="/git/tutorials/syncing/git-pull" data-event="clicked" data-uuid="54cb84e0-0a" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git pull</a></code> commands. 
These commands all have their own syncing responsibilities which can be explored on the corresponding links.
<h2><span class="saddlebrown">&emsp;Git remote</span></h2>
The <code>git remote</code> command lets you create, view, and delete connections to other repositories. 

Remote connections are more like bookmarks rather than direct links into other repositories. 
Instead of providing real-time access to another repository, they serve as convenient names that can be used to reference a not-so-convenient URL.
For example, the following diagram shows two remote connections from your repo into the central repo and another developer’s repo. 
Instead of referencing them by their full URLs, you can pass the origin and john shortcuts to other Git commands.

<img src="https://wac-cdn.atlassian.com/dam/jcr:df13d351-6189-4f0b-94f0-21d3fcd66038/01.svg?cdnVersion=217" loading="lazy" alt="Using git remote to connect other repositories">
<h2><span class="saddlebrown">&emsp;Git remote usage overview</span></h2>
The <code>git remote</code> command is essentially an interface for managing a list of remote entries that are stored in the repository's <code>./.git/config</code> file. 
The following commands are used to view the current state of the remote list.
<h2><span class="saddlebrown">&emsp;Viewing git remote configurations</span></h2>
<code>git remote</code>
List the remote connections you have to other repositories.
<code>git remote -v</code>
Same as the above command, but include the URL of each connection.
<h2><span class="saddlebrown">&emsp;Creating and modifying git remote configurations</span></h2>
The <code>git remote</code> command is also a convenience or 'helper' method for modifying a repo's <code>./.git/config</code> file. 
The commands presented below let you manage connections with other repositories. 
The following commands will modify the repo's <code>/.git/config</code> file. 

The result of the following commands can also be achieved by directly editing the <code>./.git/config</code> file with a text editor.
<code>git remote add &lt;name> &lt;url></code>
Create a new connection to a remote repository. 
After adding a remote, you’ll be able to use <code>＜name＞</code> as a convenient shortcut for <code>＜url＞</code> in other Git commands.

<code>git remote rm &lt;name></code>
Remove the connection to the remote repository called <code>＜name＞</code>.
<code>git remote rename &lt;old-name> &lt;new-name></code>
Rename a remote connection from <code>＜old-name＞</code> to <code>＜new-name＞</code>.
<h2><span class="saddlebrown">&emsp;Git remote discussion</span></h2>
Git is designed to give each developer an entirely isolated development environment. 
This means that information is not automatically passed back and forth between repositories. 
Instead, developers need to manually pull upstream commits into their local repository or manually push their local commits back up to the central repository. 

The <code>git remote</code> command is really just an easier way to pass URLs to these "sharing" commands.
<h2><span class="saddlebrown">&emsp;The origin Remote</span></h2>
When you clone a repository with <code>git clone</code>, it automatically creates a remote connection called origin pointing back to the cloned repository. 
This is useful for developers creating a local copy of a central repository, since it provides an easy way to pull upstream changes or publish local commits. 

This behavior is also why most Git-based projects call their central repository origin.
<h2><span class="saddlebrown">&emsp;Repository URLs</span></h2>
Git supports many ways to reference a remote repository. 
Two of the easiest ways to access a remote repo are via the HTTP and the SSH protocols. 

HTTP is an easy way to allow anonymous, read-only access to a repository. 
For example:
<code>http://host/path/to/repo.git</code>
But, it’s generally not possible to push commits to an HTTP address (you wouldn’t want to allow anonymous pushes anyways). 

For read-write access, you should use SSH instead:
<code>ssh://user@host/path/to/repo.git</code>
You’ll need a valid SSH account on the host machine, but other than that, Git supports authenticated access via SSH out of the box. 
Modern secure 3rd party hosting solutions like Bitbucket.com will provide these URLs for you.
<h2><span class="saddlebrown">&emsp;Git remote commands</span></h2>
The <code>git remote</code> command is one of many Git commands that takes additional appended 'subcommands'. 
Below is an examination of the commonly used <code>git remote</code> subcommands.
<code>ADD &lt;NAME> &lt;URL></code>

Adds a record to <code>./.git/config</code> for remote named <code>＜name＞</code> at the repository url <code>＜url＞.</code>
Accepts a <code>-f</code> option, that will <code>git fetch <name></name></code> immediately after the remote record is created.
Accepts a <code>--tags</code> option, that will <code>git fetch <name></name></code> immediately and import every tag from the remote repository.
<code>RENAME &lt;OLD> &lt;NEW></code>

Updates <code>./.git/config</code> to rename the record <code>＜OLD＞</code> to <code>＜NEW＞</code>. 
All remote-tracking branches and configuration settings for the remote are updated.
<code>REMOVE or RM &lt;NAME></code>
Modifies <code>./.git/config</code> and removes the remote named <code>＜NAME＞</code>. 

All remote-tracking branches and configuration settings for the remote are removed.
<code>GET-URL &lt;NAME></code>
Outputs the URLs for a remote record.
Accepts <code>--push</code>, push URLs are queried rather than fetch URLs.

With <code>--all</code>, all URLs for the remote will be listed.
<code>SHOW &lt;NAME></code>
Outputs high-level information about the remote <code>＜NAME＞</code>.
<code>PRUNE &lt;NAME></code>

Deletes any local branches for <code>＜NAME＞</code> that are not present on the remote repository.
Accepts a <code>--dry-run</code> option which will list what branches are set to be pruned, but will not actually prune them.
<h2><span class="saddlebrown">&emsp;Git remote examples</span></h2>
In addition to origin, it’s often convenient to have a connection to your teammates’ repositories. 

For example, if your co-worker, John, maintained a publicly accessible repository on <code>dev.example.com/john.git</code>, you could add a connection as follows:
<code>git remote add john http://dev.example.com/john.git</code>
Having this kind of access to individual developers’ repositories makes it possible to collaborate outside of the central repository. 
This can be very useful for small teams working on a large project.
<h2><span class="saddlebrown">&emsp;Showing your remotes</span></h2>
By default, the <code>git remote</code> command will list previously stored remote connections to other repositories. 
This will produce single line output that lists the names of "bookmark" name of remote repos.
<code>$ git remote

origin
upstream
other_users_repo</code>
Invoking <code>git remote</code> with the <code>-v</code> option will print the list of bookmarked repository names and additionally, the corresponding repository URL. 

The <code>-v</code> option stands for "verbose". 
Below is example output of verbose <code>git remote</code> output.
<code>git remote -v
origin  git@bitbucket.com:origin_user/reponame.git (fetch)

origin  git@bitbucket.com:origin_user/reponame.git (push)
upstream    https://bitbucket.com/upstream_user/reponame.git (fetch)
upstream    https://bitbucket.com/upstream_user/reponame.git (push)
other_users_repo    https://bitbucket.com/other_users_repo/reponame (fetch)

other_users_repo    https://bitbucket.com/other_users_repo/reponame (push)</code>
<h2><span class="saddlebrown">&emsp;Adding Remote Repositories</span></h2>
The <code>git remote add</code> command will create a new connection record to a remote repository. 
After adding a remote, you’ll be able to use <name> as a convenient shortcut for <url> in other Git commands. 

For more information on the accepted URL syntax, view the "Repository URLs" section below. 
This command will create a new record within the repository's <code>./.git/config</code>. 
An example of this config file update follows:</url></name>
<code>$ git remote add fake_test https://bitbucket.com/upstream_user/reponame.git; [remote "remote_test"] 

 url = https://bitbucket.com/upstream_user/reponame.git 
 fetch = +refs/heads/*:refs/remotes/remote_test/*</code>
<h2><span class="saddlebrown">&emsp;Inspecting a Remote</span></h2>
The show subcommand can be appended to <code>git remote</code> to give detailed output on the configuration of a remote. 

This output will contain a list of branches associated with the remote and also the endpoints attached for fetching and pushing.
<code>git remote show upstream
* remote upstream
 Fetch URL: https://bitbucket.com/upstream_user/reponame.git

 Push URL: https://bitbucket.com/upstream_user/reponame.git
 HEAD branch: main
 Remote branches:
  main tracked

  simd-deprecated tracked
  tutorial tracked
 Local ref configured for 'git push':
  main pushes to main (fast-forwardable)</code>
<h2><span class="saddlebrown">&emsp;Fetching and pulling from Git remotes</span></h2>
Once a remote record has been configured through the use of the <code>git remote</code> command, the remote name can be passed as an argument to other Git commands to communicate with the remote repo. 
Both <code><a href="/git/tutorials/syncing/git-fetch" data-event="clicked" data-uuid="9a680130-bf" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git fetch</a></code>, and <code><a href="/git/tutorials/syncing/git-pull" data-event="clicked" data-uuid="9a680130-bf" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git pull</a></code> can be used to read from a remote repository. 
Both commands have different operations that are explained in further depth on their respective links.
<h2><span class="saddlebrown">&emsp;Pushing to Git remotes</span></h2>
The <code>git push</code> command is used to write to a remote repository.
<code>git push &lt;remote-name> &lt;branch-name></code>
This example will upload the local state of <code>＜branch-name＞</code> to the remote repository specified by <code>＜remote-name＞</code>.
<h2><span class="saddlebrown">&emsp;Renaming and Removing Remotes</span></h2>
<code>git remote rename &lt;old-name> &lt;new-name></code>
The command <code>git remote</code> rename is self-explanatory. 
When executed, this command will rename a remote connection from <code>＜old-name＞</code> to <code>＜new-name＞</code>. 

Additionally, this will modify the contents of <code>./.git/config</code> to rename the record for the remote there as well.
<code>git remote rm &lt;name></code>
The command <code>git remote rm</code> will remove the connection to the remote repository specified by the <code>＜name＞</code> parameter. 
To demonstrate let us 'undo' the remote addition from our last example. 

If we execute <code>git remote rm remote_test</code>, and then examine the contents of <code>./.git/config</code> we can see that the <code>[remote "remote_test"]</code> record is no longer there.
<h2><br><span class="orange">git fetch</span></h2>
The <code>git fetch</code> command downloads commits, files, and refs from a remote repository into your local repo. 
Fetching is what you do when you want to see what everybody else has been working on. 

It’s similar to <code>svn update</code> in that it lets you see how the central history has progressed, but it doesn’t force you to actually merge the changes into your repository. 
Git isolates fetched content from existing local content; it has absolutely no effect on your local development work. 
Fetched content has to be explicitly checked out using the <code><a href="/git/tutorials/using-branches/git-checkout" data-event="clicked" data-uuid="c9e29710-85" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git checkout</a></code> command. 
This makes fetching a safe way to review commits before integrating them with your local repository.

When downloading content from a remote repo, <code>git pull</code> and <code>git fetch</code> commands are available to accomplish the task. 
You can consider <code>git fetch</code> the 'safe' version of the two commands. 
It will download the remote content but not update your local repo's working state, leaving your current work intact. 
<code>git pull</code> is the more aggressive alternative; it will download the remote content for the active local branch and immediately execute <code>git merge</code> to create a merge commit for the new remote content. 

If you have pending changes in progress this will cause conflicts and kick-off the merge conflict resolution flow.
<h2><span class="saddlebrown">&emsp;How git fetch works with remote branches</span></h2>
To better understand how <code>git fetch</code> works let us discuss how Git organizes and stores commits. 
Behind the scenes, in the repository's <code>./.git/objects</code> directory, Git stores all commits, local and remote. 

Git keeps remote and local branch commits distinctly separate through the use of branch refs. 
The refs for local branches are stored in the <code>./.git/refs/heads/</code>. 
Executing the <code><a href="/git/tutorials/using-branches" data-event="clicked" data-uuid="11f10924-a4" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git branch</a></code> command will output a list of the local branch refs. 
The following is an example of <code>git branch</code> output with some demo branch names.

<code>git branch
main
feature1
debug2</code>

Examining the contents of the <code>/.git/refs/heads/</code> directory would reveal similar output.
<code>ls ./.git/refs/heads/
main
feature1

debug2</code>
Remote branches are just like local branches, except they map to commits from somebody else’s repository. 
Remote branches are prefixed by the remote they belong to so that you don’t mix them up with local branches. 
Like local branches, Git also has refs for remote branches. 

Remote branch refs live in the <code>./.git/refs/remotes/</code> directory. 
The next example code snippet shows the branches you might see after fetching a remote repo conveniently named remote-repo:
<code>git branch -r
# origin/main

# origin/feature1
# origin/debug2
# remote-repo/main
# remote-repo/other-feature</code>

This output displays the local branches we had previously examined but now displays them prefixed with <code>origin/</code>. 
Additionally, we now see the remote branches prefixed with <code>remote-repo</code>. 
You can check out a remote branch just like a local one, but this puts you in a detached <code>HEAD</code> state (just like checking out an old commit). 
You can think of them as read-only branches. 

To view your remote branches, simply pass the <code>-r</code> flag to the <code>git branch</code> command.
You can inspect remote branches with the usual <code>git checkout</code> and <code>git log</code> commands. 
If you approve the changes a remote branch contains, you can merge it into a local branch with a normal <code>git merge</code>. 
So, unlike SVN, synchronizing your local repository with a remote repository is actually a two-step process: fetch, then merge. 

The <code>git pull</code> command is a convenient shortcut for this process.
<h2><span class="saddlebrown">&emsp;Git fetch commands and options</span></h2>
<code>git fetch &lt;remote></code>
Fetch all of the branches from the repository. 

This also downloads all of the required commits and files from the other repository.
<code>git fetch &lt;remote> &lt;branch></code>
Same as the above command, but only fetch the specified branch.
<code>git fetch --all</code>

A power move which fetches all registered remotes and their branches:
<code>git fetch --dry-run</code>
The <code>--dry-run</code> option will perform a demo run of the command. 
It will output examples of actions it will take during the fetch but not apply them.
<h2><span class="saddlebrown">&emsp;Git fetch examples</span></h2>
<h2><span class="saddlebrown">&emsp;git fetch a remote branch</span></h2>
The following example will demonstrate how to fetch a remote branch and update your local working state to the remote contents. 
In this example, let us assume there is a central repo origin from which the local repository has been cloned from using the <code>git clone</code> command. 

Let us also assume an additional remote repository named coworkers_repo that contains a feature_branch which we will configure and fetch. 
With these assumptions set let us continue the example.
Firstly we will need to configure the remote repo using the <code><a href="/git/tutorials/syncing" data-event="clicked" data-uuid="63679c2a-64" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git remote</a></code> command.
<code>git remote add coworkers_repo git@bitbucket.org:coworker/coworkers_repo.git</code>

Here we have created a reference to the coworker's repo using the repo URL. 
We will now pass that remote name to <code>git fetch</code> to download the contents.
<code>git fetch coworkers_repo coworkers/feature_branch
fetching coworkers/feature_branch</code>

We now locally have the contents of coworkers/feature_branch we will need the integrate this into our local working copy. 
We begin this process by using the <code><a href="/git/tutorials/using-branches/git-checkout" data-event="clicked" data-uuid="f7cce13f-df" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git checkout</a></code> command to checkout the newly downloaded remote branch.
<code>git checkout coworkers/feature_branch
Note: checking out coworkers/feature_branch'.

You are in 'detached HEAD' state. 
You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. 
Example:
git checkout -b &lt;new-branch-name></code>

The output from this checkout operation indicates that we are in a detached <code>HEAD</code> state. 
This is expected and means that our <code>HEAD</code> ref is pointing to a ref that is not in sequence with our local history. 
Being that <code>HEAD</code> is pointed at the coworkers/feature_branch ref, we can create a new local branch from that ref. 
The 'detached <code>HEAD</code>' output shows us how to do this using the <code>git checkout</code> command:

<code>git checkout -b local_feature_branch</code>
Here we have created a new local branch named local_feature_branch. 
This puts updates <code>HEAD</code> to point at the latest remote content and we can continue development on it from this point.
<h2><span class="saddlebrown">&emsp;Synchronize origin with git fetch</span></h2>
The following example walks through the typical workflow for synchronizing your local repository with the central repository's main branch.
<code>git fetch origin</code>
This will display the branches that were downloaded:
<code>a1e8fb5..45e66a4 main -> origin/main

a1e8fb5..9e8ab1c develop -> origin/develop
* [new branch] some-feature -> origin/some-feature</code>
The commits from these new remote branches are shown as squares instead of circles in the diagram below. 
As you can see, <code>git fetch</code> gives you access to the entire branch structure of another repository.

<img src="https://wac-cdn.atlassian.com/dam/jcr:f8458bba-d80a-457e-98f5-3544679eb16b/01%20Synchronize%20origin%20with%20git%20fetch.svg?cdnVersion=217" loading="lazy" alt="Origin and main branches">To see what commits have been added to the upstream main, you can run a <code>git log</code> using origin/main as a filter:  
<code>git log --oneline main..origin/main</code>
To approve the changes and merge them into your local main branch use the following commands:
<code>git checkout main

git log origin/main</code>
Then we can use <code>git merge origin/main</code>:
<code>git merge origin/main</code>
The origin/main and main branches now point to the same commit, and you are synchronized with the upstream developments.
<h2><span class="saddlebrown">&emsp;Git fetch summary</span></h2>
In review, <code>git fetch</code> is a primary command used to download contents from a remote repository. 
<code>git fetch</code> is used in conjunction with <code>git remote</code>, <code>git branch</code>, <code>git checkout</code>, and <code><a href="/git/tutorials/undoing-changes/git-reset" data-event="clicked" data-uuid="31daa4b9-83" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git reset</a></code> to update a local repository to the state of a remote. 
The <code>git fetch</code> command is a critical piece of collaborative git work flows. 

<code>git fetch</code> has similar behavior to <code>git pull</code>, however, <code>git fetch</code> can be considered a safer, nondestructive version.
<h2><br><span class="orange">git push</span></h2>
The <code>git push</code> command is used to upload local repository content to a remote repository. 
Pushing is how you transfer commits from your local repository to a remote repo. 

It's the counterpart to <code><a href="/git/tutorials/syncing/git-fetch" data-event="clicked" data-uuid="09d8c62e-0b" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git fetch</a></code>, but whereas fetching imports commits to local branches, pushing exports commits to remote branches. 
Remote branches are configured using the <code><a href="/git/tutorials/syncing" data-event="clicked" data-uuid="09d8c62e-0b" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git remote</a></code> command. 
Pushing has the potential to overwrite changes, caution should be taken when pushing. 
These issues are discussed below.
<h2><span class="saddlebrown">&emsp;Git push usage</span></h2>
<code>git push &lt;remote> &lt;branch></code>
Push the specified branch to <remote>, along with all of the necessary commits and internal objects. 
This creates a local branch in the destination repository. 

To prevent you from overwriting commits, Git won’t let you push when it results in a non-fast-forward merge in the destination repository.</remote>
<code>git push &lt;remote> --force</code>
Same as the above command, but force the push even if it results in a non-fast-forward merge. 
Do not use the <code>--force</code> flag unless you’re absolutely sure you know what you’re doing.

<code>git push &lt;remote> --all</code>
Push all of your local branches to the specified remote.
<code>git push &lt;remote> --tags</code>
Tags are not automatically pushed when you push a branch or use the <code>--all</code> option. 

The <code>--tags</code> flag sends all of your local tags to the remote repository.
<h2><span class="saddlebrown">&emsp;Git push discussion</span></h2>
<code>git push</code> is most commonly used to publish an upload local changes to a central repository. 
After a local repository has been modified a push is executed to share the modifications with remote team members.

<img src="https://wac-cdn.atlassian.com/dam/jcr:0d181327-3fb0-44ec-9ab4-d6dea0fd406f/01%20Git%20push%20discussion.svg?cdnVersion=217" loading="lazy" alt="Using git push to publish changes">The above diagram shows what happens when your local <code>main</code> has progressed past the central repository’s <code>main</code> and you publish changes by running <code>git push origin main</code>. 
Notice how <code>git push</code> is essentially the same as running <code>git merge main</code> from inside the remote repository.
<h2><span class="saddlebrown">&emsp;Git push and syncing</span></h2>
<code>git push</code> is one component of many used in the overall Git "syncing" process. 

The syncing commands operate on remote branches which are configured using the <code><a href="/git/tutorials/syncing" data-event="clicked" data-uuid="e64275c5-39" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git remote</a></code> command. 
<code>git push</code> can be considered and 'upload' command whereas, <code><a href="/git/tutorials/syncing/git-fetch" data-event="clicked" data-uuid="e64275c5-39" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git fetch</a></code> and <code><a href="/git/tutorials/syncing/git-pull" data-event="clicked" data-uuid="e64275c5-39" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git pull</a></code> can be thought of as 'download' commands. 
Once changesets have been moved via a download or upload a <code><a href="/git/tutorials/using-branches/git-merge" data-event="clicked" data-uuid="e64275c5-39" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git merge</a></code> may be performed at the destination to integrate the changes.
<h2><span class="saddlebrown">&emsp;Pushing to bare repositories</span></h2>
A frequently used, modern Git practice is to have a remotely hosted <code>--bare</code> repository act as a central origin repository. 
This origin repository is often hosted off-site with a trusted 3rd party like Bitbucket. 
Since pushing messes with the remote branch structure, It is safest and most common to push to repositories that have been created with the <code>--bare</code> flag. 
Bare repos don’t have a working directory so a push will not alter any in progress working directory content. 

For more information on bare repository creation, read about <code><a href="/git/tutorials/setting-up-a-repository/git-init" data-event="clicked" data-uuid="1c263958-e9" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git init</a></code>.
<h2><span class="saddlebrown">&emsp;Force Pushing</span></h2>
Git prevents you from overwriting the central repository’s history by refusing push requests when they result in a non-fast-forward merge. 
So, if the remote history has diverged from your history, you need to pull the remote branch and merge it into your local one, then try pushing again. 

This is similar to how SVN makes you synchronize with the central repository via <code>svn update</code> before committing a changeset.
The <code>--force</code> flag overrides this behavior and makes the remote repository’s branch match your local one, deleting any upstream changes that may have occurred since you last pulled. 
The only time you should ever need to force push is when you realize that the commits you just shared were not quite right and you fixed them with a <code>git commit --amend</code> or an interactive rebase. 
However, you must be absolutely certain that none of your teammates have pulled those commits before using the <code>--force</code> option.
<h2><span class="saddlebrown">&emsp;Examples</span></h2>
<h2><span class="saddlebrown">&emsp;Default git push</span></h2>
The following example describes one of the standard methods for publishing local contributions to the central repository. 
First, it makes sure your local main is up-to-date by fetching the central repository’s copy and rebasing your changes on top of them. 

The interactive rebase is also a good opportunity to clean up your commits before sharing them. 
Then, the <code>git push</code> command sends all of the commits on your local main to the central repository.
<code>git checkout main
git fetch origin main

git rebase -i origin/main
# Squash commits, fix up commit messages etc.
git push origin main</code>
Since we already made sure the local main was up-to-date, this should result in a fast-forward merge, and <code>git push</code> should not complain about any of the non-fast-forward issues discussed above.
<h2><span class="saddlebrown">&emsp;Amended force push</span></h2>
The <code><a href="/git/tutorials/saving-changes/git-commit" data-event="clicked" data-uuid="25f3d3a2-c2" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git commit</a></code> command accepts a <code>--amend</code> option which will update the previous commit. 
A commit is often amended to update the commit message or add new changes. 
Once a commit is amended a <code>git push</code> will fail because Git will see the amended commit and the remote commit as diverged content. 

The <code>--force</code> option must be used to push an amended commit.
<code># make changes to a repo and git add
git commit --amend
# update the existing commit message

git push --force origin main</code>
The above example assumes it is being executed on an existing repository with a commit history. 
<code>git commit --amend</code> is used to update the previous commit. 
The amended commit is then force pushed using the <code>--force</code> option.
<h2><span class="saddlebrown">&emsp;Deleting a remote branch or tag</span></h2>
Sometimes branches need to be cleaned up for book keeping or organizational purposes. 
The fully delete a branch, it must be deleted locally and also remotely.
<code>git branch -D branch_name

git push origin :branch_name</code>
The above will delete the remote branch named branch_name passing a branch name prefixed with a colon to <code>git push</code> will delete the remote branch.
<h2><br><span class="orange">git pull</span></h2>
The <code>git pull</code> command is used to fetch and download content from a remote repository and immediately update the local repository to match that content. 

Merging remote upstream changes into your local repository is a common task in Git-based collaboration work flows. 
The <code>git pull</code> command is actually a combination of two other commands, <code><a href="/git/tutorials/syncing/git-fetch" data-event="clicked" data-uuid="5ad2a533-c2" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git fetch</a></code> followed by <code><a href="/git/tutorials/using-branches/git-merge" data-event="clicked" data-uuid="5ad2a533-c2" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git merge</a></code>. 
In the first stage of operation <code>git pull</code> will execute a <code>git fetch</code> scoped to the local branch that <code>HEAD</code> is pointed at. 
Once the content is downloaded, <code>git pull</code> will enter a merge workflow. 

A new merge commit will be-created and <code>HEAD</code> updated to point at the new commit.
<h2><span class="saddlebrown">&emsp;Git pull usage</span></h2>
<h2><span class="saddlebrown">&emsp;How it works</span></h2>
The <code>git pull</code> command first runs <code>git fetch</code> which downloads content from the specified remote repository. 

Then a <code>git merge</code> is executed to merge the remote content refs and heads into a new local merge commit. 
To better demonstrate the pull and merging process let us consider the following example. 
Assume we have a repository with a main branch and a remote origin.
<img src="https://wac-cdn.atlassian.com/dam/jcr:63e58c34-b273-4e48-a6b1-6e3ba4d4a0ea/01%20bubble%20diagram-01.svg?cdnVersion=217" loading="lazy" alt="Main on remote origin vs main on repo">In this scenario, <code>git pull</code> will download all the changes from the point where the local and main diverged. 

In this example, that point is E. 
<code>git pull</code> will fetch the diverged remote commits which are A-B-C. 
The pull process will then create a new local merge commit containing the content of the new diverged remote commits.
<img src="https://wac-cdn.atlassian.com/dam/jcr:0269bb2d-eb7f-43d8-80a2-8afa88d11eea/02%20bubble%20diagram-02.svg?cdnVersion=217" loading="lazy" alt="Remote origin/main merged to local main">In the above diagram, we can see the new commit H. 

This commit is a new merge commit that contains the contents of remote A-B-C commits and has a combined log message. 
This example is one of a few <code>git pull</code> merging strategies. 
A <code>--rebase</code> option can be passed to <code>git pull</code> to use a rebase merging strategy instead of a merge commit. 
The next example will demonstrate how a rebase pull works. 

Assume that we are at a starting point of our first diagram, and we have executed <code>git pull --rebase</code>.
<img src="https://wac-cdn.atlassian.com/dam/jcr:d5633068-d448-4140-953e-2ab31553ce10/03%20bubble%20diagram-03-updated@2x%20kopiera.png?cdnVersion=217" loading="lazy" alt="rebase">In this diagram, we can now see that a rebase pull does not create the new H commit. 
Instead, the rebase has copied the remote commits A--B--C and rewritten the local commits E--F--G to appear after them them in the local origin/main commit history.
<h2><span class="saddlebrown">&emsp;Common Options</span></h2>
<code>git pull &lt;remote></code>
Fetch the specified remote’s copy of the current branch and immediately merge it into the local copy. 
This is the same as <code>git fetch ＜remote＞</code> followed by <code>git merge origin/＜current-branch＞</code>.
<code>git pull --no-commit &lt;remote></code>

Similar to the default invocation, fetches the remote content but does not create a new merge commit.
<code>git pull --rebase &lt;remote></code>
Same as the previous pull Instead of using <code>git merge</code> to integrate the remote branch with the local one, use <code><a href="/git/tutorials/rewriting-history/git-rebase" data-event="clicked" data-uuid="ff1f46ae-78" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git rebase</a></code>.
<code>git pull --verbose</code>

Gives verbose output during a pull which displays the content being downloaded and the merge details.
<h2><span class="saddlebrown">&emsp;Git pull discussion</span></h2>
You can think of <code>git pull</code> as Git's version of <code>svn update</code>. 
It’s an easy way to synchronize your local repository with upstream changes. 

The following diagram explains each step of the pulling process.
<img src="https://wac-cdn.atlassian.com/dam/jcr:9c543e76-04df-429e-af48-43a5276d7f4f/04-06%20Git%20pull%20discussion.svg?cdnVersion=217" loading="lazy" alt="git pull">You start out thinking your repository is synchronized, but then <code>git fetch</code> reveals that origin's version of main has progressed since you last checked it. 
Then <code>git merge</code> immediately integrates the remote main into the local one.
<h2><span class="saddlebrown">&emsp;Git pull and syncing</span></h2>
<code>git pull</code> is one of many commands that claim the responsibility of 'syncing' remote content. 
The <code><a href="/git/tutorials/syncing" data-event="clicked" data-uuid="8c2ecb0d-eb" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git remote</a></code> command is used to specify what remote endpoints the syncing commands will operate on. 
The <code><a href="/git/tutorials/syncing/git-push" data-event="clicked" data-uuid="8c2ecb0d-eb" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git push</a> </code>command is used to upload content to a remote repository.
The <code>git fetch</code> command can be confused with <code>git pull</code>. 

They are both used to download remote content. 
An important safety distinction can be made between <code>git pull</code> and <code>get fetch</code>. 
<code>git fetch</code> can be considered the "safe" option whereas, <code>git pull</code> can be considered unsafe. 
<code>git fetch</code> will download the remote content and not alter the state of the local repository. 

Alternatively, <code>git pull</code> will download remote content and immediately attempt to change the local state to match that content. 
This may unintentionally cause the local repository to get in a conflicted state.
<h2><span class="saddlebrown">&emsp;Pulling via Rebase</span></h2>
The <code>--rebase</code> option can be used to ensure a linear history by preventing unnecessary merge commits. 

Many developers prefer rebasing over merging, since it’s like saying, "I want to put my changes on top of what everybody else has done." In this sense, using <code>git pull</code> with the <code>--rebase</code> flag is even more like <code>svn update</code> than a plain <code>git pull</code>.
In fact, pulling with <code>--rebase</code> is such a common workflow that there is a dedicated configuration option for it:
<code>git config --global branch.autosetuprebase always</code>
After running that command, all <code>git pull</code> commands will integrate via <code>git rebase</code> instead of <code>git merge</code>.
<h2><span class="saddlebrown">&emsp;Git Pull Examples</span></h2>
The following examples demonstrate how to use <code>git pull</code> in common scenarios:
<h2><span class="saddlebrown">&emsp;Default Behavior</span></h2>
<code>git pull</code>

Executing the default invocation of <code>git pull</code> will is equivalent to <code>git fetch origin HEAD</code> and <code>git merge HEAD</code> where <code>HEAD</code> is ref pointing to the current branch.
<h2><span class="saddlebrown">&emsp;Git pull on remotes</span></h2>
<code>git checkout new_feature
git pull &lt;remote repo></code>

This example first performs a checkout and switches to the <newfeature> branch. 
Following that, the <code>git pull</code> is executed with <remote repo> being passed. 
This will implicitly pull down the newfeature branch from <remote repo>. 
Once the download is complete it will initiate a <code>git merge</code>.</remote></remote></newfeature>
<h2><span class="saddlebrown">&emsp;Git pull rebase instead of merge</span></h2>
The following example demonstrates how to synchronize with the central repository's main branch using a rebase:
<code>git checkout main
git pull --rebase origin</code>

This simply moves your local changes onto the top of what everybody else has already contributed.
<h2><br><span class="orange">Making a Pull Request</span></h2>
Pull requests are a feature that makes it easier for developers to collaborate using <a href="http://www.bitbucket.org" data-event="clicked" data-uuid="96196903-11" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Bitbucket</a>. 
They provide a user-friendly web interface for discussing proposed changes before integrating them into the official project.

<img src="https://wac-cdn.atlassian.com/dam/jcr:ff6b00cc-0ca3-4d5b-8235-8d4cbcedd19e/01.svg?cdnVersion=217" loading="lazy" alt="Git Workflows: Pull Request in Bitbucket">In their simplest form, pull requests are a mechanism for a developer to notify team members that they have completed a feature. 
Once their feature branch is ready, the developer files a pull request via their Bitbucket account. 
This lets everybody involved know that they need to review the code and merge it into the <code>main</code> branch.
But, the pull request is more than just a notification—it’s a dedicated forum for discussing the proposed feature. 

If there are any problems with the changes, teammates can post feedback in the pull request and even tweak the feature by pushing follow-up commits. 
All of this activity is tracked directly inside of the pull request.
<img src="https://wac-cdn.atlassian.com/dam/jcr:dc1a0821-efd6-4852-b7e6-c3a787656c61/02.svg?cdnVersion=217" loading="lazy" alt="Git Workflows: Activity inside a pull request">Compared to other collaboration models, this formal solution for sharing commits makes for a much more streamlined workflow. 
SVN and Git can both automatically send notification emails with a simple script; however, when it comes to discussing changes, developers typically have to rely on email threads. 

This can become haphazard, especially when follow-up commits are involved. 
Pull requests put all of this functionality into a friendly web interface right next to your Bitbucket repositories.
<h3>&emsp;Anatomy of a Pull Request</h3>
When you file a pull request, all you’re doing is <em>requesting</em> that another developer (e.g., the project maintainer) <em>pulls</em> a branch from your repository into their repository. 

This means that you need to provide 4 pieces of information to file a pull request: the source repository, the source branch, the destination repository, and the destination branch.
<img src="https://wac-cdn.atlassian.com/dam/jcr:d079cf8a-2bea-4d77-910e-2eac20c8050e/01%20Anatomy%20of%20a%20Pull%20Request.svg?cdnVersion=217" loading="lazy" alt="Git Workflows: Pull Requests">Many of these values will be set to a sensible default by Bitbucket. 
However, depending on your collaboration workflow, your team may need to specify different values. 
The above diagram shows a pull request that asks to merge a feature branch into the official main branch, but there are many other ways to use pull requests.
<h2><span class="saddlebrown">&emsp;How it works</span></h2>
Pull requests can be used in conjunction with the <a href="/git/tutorials/comparing-workflows/feature-branch-workflow" data-event="clicked" data-uuid="3212ee66-f0" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Feature Branch Workflow</a>, the <a href="/git/tutorials/comparing-workflows/gitflow-workflow" data-event="clicked" data-uuid="3212ee66-f0" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Gitflow Workflow</a>, or the <a href="/git/tutorials/comparing-workflows/forking-workflow" data-event="clicked" data-uuid="3212ee66-f0" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Forking Workflow</a>. 
But a pull request requires either two distinct branches or two distinct repositories, so they will not work with the <a href="/git/tutorials/comparing-workflows/forking-workflow" data-event="clicked" data-uuid="3212ee66-f0" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Centralized Workflow</a>. 
Using pull requests with each of these workflows is slightly different, but the general process is as follows:

A developer creates the feature in a dedicated branch in their local repo.
The developer pushes the branch to a public Bitbucket repository.
The developer files a pull request via Bitbucket.
The rest of the team reviews the code, discusses it, and alters it.

The project maintainer merges the feature into the official repository and closes the pull request. 
The rest of this section describes how pull requests can be leveraged against different collaboration workflows.
<h3>&emsp;Feature Branch Workflow With Pull Requests</h3>
The Feature Branch Workflow uses a shared Bitbucket repository for managing collaboration, and developers create features in isolated branches. 

But, instead of immediately merging them into <code>main</code>, developers should open a pull request to initiate a discussion around the feature before it gets integrated into the main codebase.
<img src="https://wac-cdn.atlassian.com/dam/jcr:8359fb05-ef37-428d-9e45-d0591614a126/02%20Anatomy%20of%20a%20Pull%20Request.svg?cdnVersion=217" loading="lazy" alt="Pull Request: Feature Branch workflow">There is only one public repository in the Feature Branch Workflow, so the pull request’s destination repository and the source repository will always be the same. 
Typically, the developer will specify their feature branch as the source branch and the <code>main</code> branch as the destination branch.
After receiving the pull request, the project maintainer has to decide what to do. 

If the feature is ready to go, they can simply merge it into <code>main</code> and close the pull request. 
But, if there are problems with the proposed changes, they can post feedback in the pull request. 
Follow-up commits will show up right next to the relevant comments.
It’s also possible to file a pull request for a feature that is incomplete. 

For example, if a developer is having trouble implementing a particular requirement, they can file a pull request containing their work-in-progress. 
Other developers can then provide suggestions inside of the pull request, or even fix the problem themselves with additional commits.
<h3>&emsp;Gitflow Workflow With Pull Requests</h3>
The Gitflow Workflow is similar to the Feature Branch Workflow, but defines a strict branching model designed around the project release. 

Adding pull requests to the Gitflow Workflow gives developers a convenient place to talk about a release branch or a maintenance branch while they’re working on it.
<img src="https://wac-cdn.atlassian.com/dam/jcr:50c76de3-6c5b-4adf-9a96-a611cc3dbebc/05.svg?cdnVersion=217" loading="lazy" alt="Pull Requests: Gitflow Workflow"><img src="https://wac-cdn.atlassian.com/dam/jcr:a7e725a9-c98e-4a7f-af46-5106b2358d50/03%20Gitflow%20Workflow%20With%20Pull%20Requests.svg?cdnVersion=217" loading="lazy" alt="Pull Requests: Gitflow Workflow 2">The mechanics of pull requests in the Gitflow Workflow are the exact same as the previous section: a developer simply files a pull request when a feature, release, or hotfix branch needs to be reviewed, and the rest of the team will be notified via Bitbucket.
Features are generally merged into the <code>develop</code> branch, while release and hotfix branches are merged into both <code>develop</code> and <code>main</code>. 
Pull requests can be used to formally manage all of these merges.

<h3>&emsp;Forking Workflow With Pull Requests</h3>
In the Forking Workflow, a developer pushes a completed feature to <em>their own</em> public repository instead of a shared one. 
After that, they file a pull request to let the project maintainer know that it’s ready for review.
The notification aspect of pull requests is particularly useful in this workflow because the project maintainer has no way of knowing when another developer has added commits to their Bitbucket repository.

<img src="https://wac-cdn.atlassian.com/dam/jcr:bab8474f-faf7-4538-aa5c-66fb52846583/04%20Forking%20Workflow%20With%20Pull%20Requests.svg?cdnVersion=217" loading="lazy" alt="Pull Requests: Forking workflow">Since each developer has their own public repository, the pull request’s source repository will differ from its destination repository. 
The source repository is the developer’s public repository and the source branch is the one that contains the proposed changes. 
If the developer is trying to merge the feature into the main codebase, then the destination repository is the official project and the destination branch is <code>main</code>.
Pull requests can also be used to collaborate with other developers outside of the official project. 

For example, if a developer was working on a feature with a teammate, they could file a pull request using the <em>teammate’s</em> Bitbucket repository for the destination instead of the official project. 
They would then use the same feature branch for the source and destination branches.
<img src="https://wac-cdn.atlassian.com/dam/jcr:0907a594-5786-47fb-87b4-05fc08e0c8dc/08.svg?cdnVersion=217" loading="lazy" alt="Pull Requests: Forking workflow">The two developers could discuss and develop the feature inside of the pull request. 
When they’re done, one of them would file another pull request asking to merge the feature into the official main branch. 

This kind of flexibility makes pull requests very powerful collaboration tool in the Forking workflow.
<h2><span class="saddlebrown">&emsp;Example</span></h2>
The example below demonstrates how pull requests can be used in the Forking Workflow. 
It is equally applicable to developers working in small teams and to a third-party developer contributing to an open source project.

In the example, Mary is a developer, and John is the project maintainer. 
Both of them have their own public Bitbucket repositories, and John’s contains the official project.
<h3>&emsp;Mary forks the official project</h3>
<img src="https://wac-cdn.atlassian.com/dam/jcr:8b3d2111-5a88-4802-967c-71f51c248b03/09.svg?cdnVersion=217" loading="lazy" alt="Pull Requests: Fork the project">To start working in the project, Mary first needs to fork John’s Bitbucket repository. 

She can do this by signing in to Bitbucket, navigating to John’s repository, and clicking the <em>Fork</em> button.
<img src="https://wac-cdn.atlassian.com/dam/jcr:93d2ede4-241e-4296-b403-584d5ee24d8e/10.svg?cdnVersion=217" loading="lazy" alt="Pull Request: Fork in Bitbucket">After filling out the name and description for the forked repository, she will have a server-side copy of the project.
<h3>&emsp;Mary clones her Bitbucket repository</h3>
<img src="https://wac-cdn.atlassian.com/dam/jcr:4f051d96-8ce7-4aab-af74-b2de38c41443/11.svg?cdnVersion=217" loading="lazy" alt="Pull Request: Clone the Bitbucket repo">Next, Mary needs to clone the Bitbucket repository that she just forked. 

This will give her a working copy of the project on her local machine. 
She can do this by running the following command:
<code>git clone https://user@bitbucket.org/user/repo.git</code>
Keep in mind that <code>git clone</code> automatically creates an <code>origin</code> remote that points back to Mary’s forked repository.

<h3>&emsp;Mary develops a new feature</h3>
<img src="https://wac-cdn.atlassian.com/dam/jcr:f0979362-cf67-413d-bac1-8275e20aea58/12.svg?cdnVersion=217" loading="lazy" alt="Pull Requests: develop a new feature">Before she starts writing any code, Mary needs to create a new branch for the feature. 
This branch is what she will use as the source branch of the pull request.
<code>git checkout -b some-feature

# Edit some code
git commit -a -m "Add first draft of some feature"</code>
Mary can use as many commits as she needs to create the feature. 
And, if the feature’s history is messier than she would like, she can use an <a href="/git/tutorials/rewriting-history/git-rebase" data-event="clicked" data-uuid="f98ce24d-78" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">interactive rebase</a> to remove or squash unnecessary commits. 

For larger projects, cleaning up a feature’s history makes it much easier for the project maintainer to see what’s going on in the pull request.
<h3>&emsp;Mary pushes the feature to her Bitbucket repository</h3>
<img src="https://wac-cdn.atlassian.com/dam/jcr:d3a07e01-ad5c-4e11-929a-87c049a27a6b/13.svg?cdnVersion=217" loading="lazy" alt="Pull Requests: Push feature to Bitbucket repository">After her feature is complete, Mary pushes the feature branch to her own Bitbucket repository (not the official repository) with a simple <code>git push</code>:
<code>git push origin some-branch</code>

This makes her changes available to the project maintainer (or any collaborators who might need access to them).
<h3>&emsp;Mary creates the pull request</h3>
<img src="https://wac-cdn.atlassian.com/dam/jcr:de06b2f6-5846-4ef2-af0b-4d1fc17fbc16/05%20Mary%20creates%20the%20pull%20request.svg?cdnVersion=217" loading="lazy" alt="Pull Request: Create Pull Request">After Bitbucket has her feature branch, Mary can create the pull request through her Bitbucket account by navigating to her forked repository and clicking the <em>Pull request</em> button in the top-right corner. 
The resulting form automatically sets Mary’s repository as the source repository, and it asks her to specify the source branch, the destination repository, and the destination branch.

Mary wants to merge her feature into the main codebase, so the source branch is her feature branch, the destination repository is John’s public repository, and the destination branch is <code>main</code>. 
She’ll also need to provide a title and description for the pull request. 
If there are other people who need to approve the code besides John, she can enter them in the <em>Reviewers</em> field.
<img src="https://wac-cdn.atlassian.com/dam/jcr:494da6fb-45be-4771-b5a1-2cf940959114/06%20Mary%20creates%20the%20pull%20request.png?cdnVersion=217" loading="lazy" alt="Pull Request: Bitbucket">After she creates the pull request, a notification will be sent to John via his Bitbucket feed and (optionally) via email.

<h3>&emsp;John reviews the pull request</h3>
<img src="https://wac-cdn.atlassian.com/dam/jcr:1b30ef44-9679-49d1-bc86-8b1a0cf5e241/pull-request-8.png?cdnVersion=217" loading="lazy" alt="Pull Request: Bitbucket pull requests">John can access all of the pull requests people have filed by clicking on the <em>Pull request</em> tab in his own Bitbucket repository. 
Clicking on Mary’s pull request will show him a description of the pull request, the feature’s commit history, and a diff of all the changes it contains.
If he thinks the feature is ready to merge into the project, all he has to do is hit the <em>Merge</em> button to approve the pull request and merge Mary’s feature into his <code>main</code> branch.

But, for this example, let’s say John found a small bug in Mary’s code, and needs her to fix it before merging it in. 
He can either post a comment to the pull request as a whole, or he can select a specific commit in the feature’s history to comment on.
<img src="https://wac-cdn.atlassian.com/dam/jcr:6d9007c1-7b42-42e4-a1ca-f7129185c16d/pull-request-9.png?cdnVersion=217" loading="lazy" alt="Pull Request: Comment"><h3>&emsp;Mary adds a follow-up commit</h3>
If Mary has any questions about the feedback, she can respond inside of the pull request, treating it as a discussion forum for her feature.

To correct the error, Mary adds another commit to her feature branch and pushes it to her Bitbucket repository, just like she did the first time around. 
This commit is automatically added to the original pull request, and John can review the changes again, right next to his original comment.
<h3>&emsp;John accepts the pull request</h3>
Finally, John accepts the changes, merges the feature branch into main, and closes the pull request. 

The feature is now integrated into the project, and any other developers working on it can pull it into their own local repositories using the standard <code>git pull</code> command.
<h2><span class="saddlebrown">&emsp;Where to go from here</span></h2>
You should now have all of the tools you need to start integrating pull requests into your existing workflow. 
Remember, pull requests are not a replacement for any of the <a href="/git/tutorials/comparing-workflows" data-event="clicked" data-uuid="d042b508-56" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Git-based collaboration workflows</a>, but rather a convenient addition to them that makes collaboration more accessible to all of your team members.

<h2><br><span class="orange">Git Branch</span></h2>
<a class="play-trigger" data-event="clicked" data-uuid="97230c3f-82" data-event-component="linkButton" data-event-container="videoEmbedInline" data-schema-version="1" data-product-key="bitbucket" href="https://www.youtube.com/watch?v=S2TUommS3O0">
</a>
<script type="text/x-component">

{
"type":"imkt.components.VideoEmbedInline",
"params": {
"videoId":"S2TUommS3O0",

"source":"youtube",
"behavior":"replaceImage",
"uniqueId":"97230c3f"
}

}
</script>
This document is an in-depth review of the <code>git branch</code> command and a discussion of the overall Git branching model. 
Branching is a feature available in most modern version control systems. 

Branching in other VCS's can be an expensive operation in both time and disk space. 
In Git, branches are a part of your everyday development process. 
Git branches are effectively a pointer to a snapshot of your changes. 
When you want to add a new feature or fix a bug—no matter how big or how small—you spawn a new branch to encapsulate your changes. 

This makes it harder for unstable code to get merged into the main code base, and it gives you the chance to clean up your future's history before merging it into the main branch.
<img src="https://wac-cdn.atlassian.com/dam/jcr:a905ddfd-973a-452a-a4ae-f1dd65430027/01%20Git%20branch.svg?cdnVersion=217" loading="lazy" alt="Git Tutorial: git branch">The diagram above visualizes a repository with two isolated lines of development, one for a little feature, and one for a longer-running feature. 
By developing them in branches, it’s not only possible to work on both of them in parallel, but it also keeps the <code>main</code> branch free from questionable code.
The implementation behind Git branches is much more lightweight than other version control system models. 

Instead of copying files from directory to directory, Git stores a branch as a reference to a commit. 
In this sense, a branch represents the tip of a series of commits—it's not a container for commits. 
The history for a branch is extrapolated through the commit relationships.
As you read, remember that Git branches aren't like SVN branches. 

Whereas SVN branches are only used to capture the occasional large-scale development effort, Git branches are an integral part of your everyday workflow. 
The following content will expand on the internal Git branching architecture.
<h2><span class="saddlebrown">&emsp;How it works</span></h2>
A branch represents an independent line of development. 

Branches serve as an abstraction for the edit/stage/commit process. 
You can think of them as a way to request a brand new working directory, staging area, and project history. 
New commits are recorded in the history for the current branch, which results in a fork in the history of the project.
The <code>git branch</code> command lets you create, list, rename, and delete branches. 

It doesn’t let you switch between branches or put a forked history back together again. 
For this reason, <code>git branch</code> is tightly integrated with the <code><a href="/git/tutorials/using-branches/git-checkout" data-event="clicked" data-uuid="552ca8af-a0" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git checkout</a></code> and <code><a href="/git/tutorials/using-branches/git-merge" data-event="clicked" data-uuid="552ca8af-a0" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git merge</a></code> commands.
<h2><span class="saddlebrown">&emsp;Common Options</span></h2>
<code>git branch</code>

List all of the branches in your repository. 
This is synonymous with <code>git branch --list.</code>
<code>git branch &lt;branch></code>
Create a new branch called <code>＜branch＞</code>. 

This does <em>not</em> check out the new branch.
<code>git branch -d &lt;branch></code>
Delete the specified branch. 
This is a “safe” operation in that Git prevents you from deleting the branch if it has unmerged changes.

<code>git branch -D &lt;branch></code>
Force delete the specified branch, even if it has unmerged changes. 
This is the command to use if you want to permanently throw away all of the commits associated with a particular line of development.
<code>git branch -m &lt;branch></code>

Rename the current branch to <code>＜branch＞</code>.
<code>git branch -a</code>
List all remote branches. 
<h2><span class="saddlebrown">&emsp;Creating Branches</span></h2>
It's important to understand that branches are just pointers to commits. 
When you create a branch, all Git needs to do is create a new pointer, it doesn’t change the repository in any other way. 
If you start with a repository that looks like this:
<img src="https://wac-cdn.atlassian.com/dam/jcr:547aa16b-4bdd-45bc-9fbc-18e795dd9df1/02%20Creating%20branches.svg?cdnVersion=217" loading="lazy" alt="Git Tutorial: repository without any branches">Then, you create a branch using the following command:

<code>git branch crazy-experiment</code>
The repository history remains unchanged. 
All you get is a new pointer to the current commit:
<img src="https://wac-cdn.atlassian.com/dam/jcr:387f080e-19b8-43ab-a7a3-0921ffd7298a/03%20Creating%20branches.svg?cdnVersion=217" loading="lazy" alt="Git Tutorial: Create new branch">Note that this only <em>creates</em> the new branch. 

To start adding commits to it, you need to select it with <code>git checkout</code>, and then use the standard <code>git add</code> and <code>git commit</code> commands. 
<h2><span class="saddlebrown">&emsp;Creating remote branches</span></h2>
So far these examples have all demonstrated local branch operations. 
The <code>git branch</code> command also works on remote branches. 

In order to operate on remote branches, a remote repo must first be configured and added to the local repo config.
<code>$ git remote add new-remote-repo https://bitbucket.com/user/repo.git
# Add remote repo to local repo config
$ git push &lt;new-remote-repo> crazy-experiment~

# pushes the crazy-experiment branch to new-remote-repo</code>
This command will push a copy of the local branch <code>crazy-experiment</code> to the remote repo <code>＜remote＞.</code>
<h2><span class="saddlebrown">&emsp;Deleting Branches</span></h2>
Once you’ve finished working on a branch and have merged it into the main code base, you’re free to delete the branch without losing any history:

<code>git branch -d crazy-experiment</code>
However, if the branch hasn’t been merged, the above command will output an error message:
<code>error: The branch 'crazy-experiment' is not fully merged. 
If you are sure you want to delete it, run 'git branch -D crazy-experiment'.</code>

This protects you from losing access to that entire line of development. 
If you really want to delete the branch (e.g., it’s a failed experiment), you can use the capital <code>-D</code> flag:
<code>git branch -D crazy-experiment</code>
This deletes the branch regardless of its status and without warnings, so use it judiciously.

The previous commands will delete a local copy of a branch. 
The branch may still exist in remote repos. 
To delete a remote branch execute the following.
<code>git push origin --delete crazy-experiment</code>

Or
<code>git push origin :crazy-experiment</code>
This will push a delete signal to the remote origin repository that triggers a delete of the remote <code>crazy-experiment</code> branch.
<h2><span class="saddlebrown">&emsp;Summary</span></h2>
In this document we discussed Git's branching behavior and the <code>git branch</code> command. 
The <code>git branch</code> commands primary functions are to create, list, rename and delete branches. 
To operate further on the resulting branches the command is commonly used with other commands like <code>git checkout</code>. 
Learn more about <code>git checkout</code> branch operations; such as switching branches and merging branches, on the <code><a href="/git/tutorials/using-branches/git-checkout" data-event="clicked" data-uuid="e2ed5746-2d" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git checkout</a></code> page.

Compared to other VCSs, Git's branch operations are inexpensive and frequently used. 
This flexibility enables powerful <a href="/git/tutorials/comparing-workflows" data-event="clicked" data-uuid="91880f20-34" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Git workflow</a> customization. 
For more info on Git workflows visit our extended workflow discussion pages: <a href="/git/tutorials/comparing-workflows/feature-branch-workflow" data-event="clicked" data-uuid="91880f20-34" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">The Feature Branch Workflow</a>, <a href="/git/tutorials/comparing-workflows/gitflow-workflow" data-event="clicked" data-uuid="91880f20-34" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">GitFlow Workflow</a>, and <a href="/git/tutorials/comparing-workflows/forking-workflow" data-event="clicked" data-uuid="91880f20-34" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Forking Workflow</a>. 
<h2><br><span class="orange">Git Checkout</span></h2>
This page is an examination of the <code>git checkout</code> command. 
It will cover usage examples and edge cases. 
In Git terms, a "checkout" is the act of switching between different versions of a target entity. 
The <code>git checkout</code> command operates upon three distinct entities: files, commits, and branches. 

In addition to the definition of "checkout" the phrase "checking out" is commonly used to imply the act of executing the <code>git checkout</code> command. 
In the <a href="/git/tutorials/undoing-changes" data-event="clicked" data-uuid="e058c6a6-d3" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Undoing Changes</a> topic, we saw how <code>git checkout</code> can be used to view old commits. 
The focus for the majority of this document will be checkout operations on branches.
Checking out branches is similar to checking out old commits and files in that the working directory is updated to match the selected branch/revision; however, new changes are saved in the project history—that is, it’s not a read-only operation.
<h2><span class="saddlebrown">&emsp;Checking out branches</span></h2>
The <code>git checkout</code> command lets you navigate between the branches created by <code>git branch</code>. 
Checking out a branch updates the files in the working directory to match the version stored in that branch, and it tells Git to record all new commits on that branch. 
Think of it as a way to select which line of development you’re working on.

Having a dedicated branch for each new feature is a dramatic shift from a traditional SVN workflow. 
It makes it ridiculously easy to try new experiments without the fear of destroying existing functionality, and it makes it possible to work on many unrelated features at the same time. 
In addition, branches also facilitate several collaborative workflows.
The <code>git checkout</code> command may occasionally be confused with <code>git clone</code>. 

The difference between the two commands is that clone works to fetch code from a remote repository, alternatively checkout works to switch between versions of code already on the local system.
<h2><span class="saddlebrown">&emsp;Usage: Existing branches</span></h2>
Assuming the repo you're working in contains pre-existing branches, you can switch between these branches using <code>git checkout</code>. 
To find out what branches are available and what the current branch name is, execute <code>git branch</code>.

<code>$＞ git branch 
main 
another_branch 
feature_inprogress_branch 

$＞ git checkout feature_inprogress_branch</code>
The above example demonstrates how to view a list of available branches by executing the <code>git branch</code> command, and switch to a specified branch, in this case, the <code>feature_inprogress_branch</code>.
<h2><span class="saddlebrown">&emsp;New Branches</span></h2>
<code>Git checkout</code> works hand-in-hand with <code><a href="/git/tutorials/using-branches" data-event="clicked" data-uuid="4e97d1ee-e7" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git branch</a></code>. 

The <code>git branch</code> command can be used to create a new branch. 
When you want to start a new feature, you create a new branch off <code>main</code> using <code>git branch new_branch</code>. 
Once created you can then use <code>git checkout new_branch</code> to switch to that branch. 
Additionally, The <code>git checkout</code> command accepts a <code>-b</code> argument that acts as a convenience method which will create the new branch and immediately switch to it. 

You can work on multiple features in a single repository by switching between them with <code>git checkout</code>.
<code>git checkout -b ＜new-branch＞</code>
The above example simultaneously creates and checks out <code>＜new-branch＞</code>. 
The <code>-b</code> option is a convenience flag that tells Git to run <code>git branch <new-branch></new-branch></code> before running <code>git checkout ＜new-branch＞</code>.

<code>git checkout -b ＜new-branch＞ ＜existing-branch＞</code>
By default <code>git checkout -b</code> will base the <code>new-branch</code> off the current <code>HEAD</code>. 
An optional additional branch parameter can be passed to <code>git checkout</code>. 
In the above example, <code>＜</code><code>existing-branch＞</code> is passed which then bases <code>new-branch</code> off of <code>existing-branch</code> instead of the current <code>HEAD</code>.
<h2><span class="saddlebrown">&emsp;Switching Branches</span></h2>
Switching branches is a straightforward operation. 
Executing the following will point <code>HEAD</code> to the tip of <code>＜branchname＞.</code>
<code>git checkout ＜branchname＞</code>

Git tracks a history of checkout operations in the reflog. 
You can execute <code>git reflog</code> to view the history.
<h2><span class="saddlebrown">&emsp;Git Checkout a Remote Branch</span></h2>
When collaborating with a team it is common to utilize remote repositories. 

These repositories may be hosted and shared or they may be another colleague's local copy. 
Each remote repository will contain its own set of branches. 
In order to checkout a remote branch you have to first fetch the contents of the branch.
<code>git fetch --all</code>

In modern versions of Git, you can then checkout the remote branch like a local branch.
<code>git checkout ＜remotebranch＞</code>
Older versions of Git require the creation of a new branch based on the <code>remote</code>.
<code>git checkout -b ＜remotebranch＞ origin/＜remotebranch＞</code>

Additionally you can checkout a new local branch and reset it to the remote branches last commit.
<code>git checkout -b ＜branchname＞
git reset --hard origin/＜branchname＞</code>
<h2><span class="saddlebrown">&emsp;Detached HEADS</span></h2>
Now that we’ve seen the three main uses of <code>git checkout</code> on branches, it's important to discuss the <code>“detached HEAD”</code> state. 
Remember that the <code>HEAD</code> is Git’s way of referring to the current snapshot. 
Internally, the <code>git checkout</code> command simply updates the <code>HEAD</code> to point to either the specified branch or commit. 
When it points to a branch, Git doesn't complain, but when you check out a commit, it switches into a <code>“detached HEAD”</code> state.

This is a warning telling you that everything you’re doing is “detached” from the rest of your project’s development. 
If you were to start developing a feature while in a detached <code>HEAD</code> state, there would be no branch allowing you to get back to it. 
When you inevitably check out another branch (e.g., to merge your feature in), there would be no way to reference your feature:
<img src="https://wac-cdn.atlassian.com/dam/jcr:d93bca4e-11ed-4cd6-a690-e97444755429/01-02%20Detached%20HEADS.svg?cdnVersion=217" loading="lazy" alt="Attached head vs detached head">The point is, your development should always take place on a branch—never on a detached <code>HEAD</code>. 

This makes sure you always have a reference to your new commits. 
However, if you’re just looking at an old commit, it doesn’t really matter if you’re in a detached <code>HEAD</code> state or not.
<h2><span class="saddlebrown">&emsp;Summary</span></h2>
This page focused on usage of the <code>git checkout</code> command when changing branches. 

In summation, <code>git checkout</code>, when used on branches, alters the target of the <code>HEAD</code> ref. 
It can be used to create branches, switch branches, and checkout remote branches. 
The <code>git checkout</code> command is an essential tool for standard Git operation. 
It is a counterpart to <code><a href="/git/tutorials/using-branches/git-merge" data-event="clicked" data-uuid="c959781f-eb" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git merge</a></code>. 

The <code>git checkout</code> and <code>git merge</code> commands are critical tools to enabling <code><a href="/git/tutorials/comparing-workflows" data-event="clicked" data-uuid="c959781f-eb" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git workflows</a></code><a href="https://www.atlassian.com/git/tutorials/comparing-workflows" data-event="clicked" data-uuid="c959781f-eb" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">.</a>
<h2><br><span class="orange">Git Merge</span></h2>
Merging is Git's way of putting a forked history back together again. 
The <code>git merge</code> command lets you take the independent lines of development created by <code>git branch</code> and integrate them into a single branch.

Note that all of the commands presented below merge into the current branch. 
The current branch will be updated to reflect the merge, but the target branch will be completely unaffected. 
Again, this means that <code>git merge</code> is often used in conjunction with <code>git checkout</code> for selecting the current branch and <code>git branch -d</code> for deleting the obsolete target branch.
<h2><span class="saddlebrown">&emsp;How it works</span></h2>
<code>Git merge</code> will combine multiple sequences of commits into one unified history. 
In the most frequent use cases, <code>git merge</code> is used to combine two branches. 
The following examples in this document will focus on this branch merging pattern. 
In these scenarios, <code>git merge</code> takes two commit pointers, usually the branch tips, and will find a common base commit between them. 

Once Git finds a common base commit it will create a new "merge commit" that combines the changes of each queued merge commit sequence.
Say we have a new branch feature that is based off the <code>main</code> branch. 
We now want to merge this feature branch into <code>main</code>.
<img src="https://wac-cdn.atlassian.com/dam/jcr:7afd8460-b7bf-4c42-b997-4f5cf24f21e8/01%20Branch-2%20kopiera.png?cdnVersion=217" loading="lazy" alt="">Invoking this command will merge the specified branch feature into the current branch, we'll assume <code>main</code>. 

Git will determine the merge algorithm automatically (discussed below).
<img src="https://wac-cdn.atlassian.com/dam/jcr:c6db91c1-1343-4d45-8c93-bdba910b9506/02%20Branch-1%20kopiera.png?cdnVersion=217" loading="lazy" alt="New merge commit node">Merge commits are unique against other commits in the fact that they have two parent commits. 
When creating a merge commit Git will attempt to auto magically merge the separate histories for you. 
If Git encounters a piece of data that is changed in both histories it will be unable to automatically combine them. 

This scenario is a version control conflict and Git will need user intervention to continue. 
<h2><span class="saddlebrown">&emsp;Preparing to merge</span></h2>
Before performing a merge there are a couple of preparation steps to take to ensure the merge goes smoothly.
<h2><span class="saddlebrown">&emsp;Confirm the receiving branch</span></h2>
Execute <code>git status </code>to ensure that <code>HEAD</code> is pointing to the correct merge-receiving branch. 
If needed, execute <code>git checkout <receiving></receiving></code> to switch to the receiving branch. 
In our case we will execute <code>git checkout main.</code>
<h2><span class="saddlebrown">&emsp;Fetch latest remote commits</span></h2>
Make sure the receiving branch and the merging branch are up-to-date with the latest remote changes. 
Execute <code>git fetch</code> to pull the latest remote commits. 
Once the fetch is completed ensure the <code>main</code> branch has the latest updates by executing <code>git pull.</code>
<h2><span class="saddlebrown">&emsp;Merging</span></h2>
Once the previously discussed "preparing to merge" steps have been taken a merge can be initiated by executing <code>git merge <branch name></branch></code> where <code><branch name></branch></code> is the name of the branch that will be merged into the receiving branch.
<h2><span class="saddlebrown">&emsp;Fast Forward Merge</span></h2>
A fast-forward merge can occur when there is a linear path from the current branch tip to the target branch. 
Instead of “actually” merging the branches, all Git has to do to integrate the histories is move (i.e., “fast forward”) the current branch tip up to the target branch tip. 

This effectively combines the histories, since all of the commits reachable from the target branch are now available through the current one. 
For example, a fast forward merge of some-feature into <code>main</code> would look something like the following:
<img src="https://wac-cdn.atlassian.com/dam/jcr:d90f2536-7951-4e5e-ab79-f45a502fb4c8/03-04%20Fast%20forward%20merge.svg?cdnVersion=217" loading="lazy" alt="Feature node nodes ahead of the main node, after fast forward, both are on the same node">
However, a fast-forward merge is not possible if the branches have diverged. 

When there is not a linear path to the target branch, Git has no choice but to combine them via a 3-way merge. 
3-way merges use a dedicated commit to tie together the two histories. 
The nomenclature comes from the fact that Git uses three commits to generate the merge commit: the two branch tips and their common ancestor.
<img src="https://wac-cdn.atlassian.com/dam/jcr:91aece4a-8fa0-4fc3-bae9-69d51932f104/05-06%20Fast%20forward%20merge.svg?cdnVersion=217" loading="lazy" alt="">

While you can use either of these merge strategies, many developers like to use fast-forward merges (facilitated through <a href="/git/tutorials/rewriting-history/git-rebase" data-event="clicked" data-uuid="cca19fc4-83" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">rebasing</a>) for small features or bug fixes, while reserving 3-way merges for the integration of longer-running features. 
In the latter case, the resulting merge commit serves as a symbolic joining of the two branches.
Our first example demonstrates a fast-forward merge. 
The code below creates a new branch, adds two commits to it, then integrates it into the main line with a fast-forward merge.

<code># Start a new feature
git checkout -b new-feature main
# Edit some files
git add &lt;file>

git commit -m "Start a feature"
# Edit some files
git add &lt;file>
git commit -m "Finish a feature"

# Merge in the new-feature branch
git checkout main
git merge new-feature
git branch -d new-feature</code>

This is a common workflow for short-lived topic branches that are used more as an isolated development than an organizational tool for longer-running features.
Also note that Git should not complain about the <code>git branch -d</code>, since new-feature is now accessible from the main branch.
In the event that you require a merge commit during a fast forward merge for record keeping purposes you can execute <code>git merge</code> with the <code>--no-ff </code>option.
<code>git merge --no-ff &lt;branch></code>

This command merges the specified branch into the current branch, but always generates a merge commit (even if it was a fast-forward merge). 
This is useful for documenting all merges that occur in your repository.
<h2><span class="saddlebrown">&emsp;3-way merge</span></h2>
The next example is very similar, but requires a 3-way merge because <code>main</code> progresses while the feature is in-progress. 

This is a common scenario for large features or when several developers are working on a project simultaneously.
<code>Start a new feature
git checkout -b new-feature main
# Edit some files

git add &lt;file>
git commit -m "Start a feature"
# Edit some files
git add &lt;file>

git commit -m "Finish a feature"
# Develop the main branch
git checkout main
# Edit some files

git add &lt;file>
git commit -m "Make some super-stable changes to main"
# Merge in the new-feature branch
git merge new-feature

git branch -d new-feature</code>
Note that it’s impossible for Git to perform a fast-forward merge, as there is no way to move <code>main</code> up to <code>new-feature</code> without backtracking.
For most workflows, <code>new-feature</code> would be a much larger feature that took a long time to develop, which would be why new commits would appear on <code>main</code> in the meantime. 
If your feature branch was actually as small as the one in the above example, you would probably be better off rebasing it onto <code>main</code> and doing a fast-forward merge. 

This prevents superfluous merge commits from cluttering up the project history.
<h2><span class="saddlebrown">&emsp;Resolving conflict</span></h2>
If the two branches you're trying to merge both changed the same part of the same file, Git won't be able to figure out which version to use. 
When such a situation occurs, it stops right before the merge commit so that you can resolve the conflicts manually.

The great part of Git's merging process is that it uses the familiar edit/stage/commit workflow to resolve merge conflicts. 
When you encounter a merge conflict, running the <code>git status</code> command shows you which files need to be resolved. 
For example, if both branches modified the same section of <code>hello.py</code>, you would see something like the following:
<code>On branch main

Unmerged paths:
(use "git add/rm ..." as appropriate to mark resolution)
both modified: hello.py</code>
<h2><span class="saddlebrown">&emsp;How conflicts are presented</span></h2>
When Git encounters a conflict during a merge, It will edit the content of the affected files with visual indicators that mark both sides of the conflicted content. 
These visual markers are: &lt;&lt;&lt;&lt;&lt;&lt;>>>>>>. 
Its helpful to search a project for these indicators during a merge to find where conflicts need to be resolved.
<code>here is some content not affected by the conflict

&lt;&lt;&lt;&lt;&lt;&lt;&lt; main
this is conflicted text from main
=======
this is conflicted text from feature branch

>>>>>>> feature branch;</code>
Generally the content before the <code>=======</code> marker is the receiving branch and the part after is the merging branch.
Once you've identified conflicting sections, you can go in and fix up the merge to your liking. 
When you're ready to finish the merge, all you have to do is run <code>git add</code> on the conflicted file(s) to tell Git they're resolved. 

Then, you run a normal <code>git commit</code> to generate the merge commit. 
It’s the exact same process as committing an ordinary snapshot, which means it’s easy for normal developers to manage their own merges.
Note that merge conflicts will only occur in the event of a 3-way merge. 
It’s not possible to have conflicting changes in a fast-forward merge. 
<h2><span class="saddlebrown">&emsp;Summary</span></h2>
This document is an overview of the <code>git merge</code> command. 
Merging is an essential process when working with Git. 
We discussed the internal mechanics behind a merge and the differences between a fast forward merge and a three way, true merge. 

Some key take-aways are:
Git merging combines sequences of commits into one unified history of commits.
There are two main ways Git will merge: Fast Forward and Three way
Git can automatically merge commits unless there are changes that conflict in both commit sequences.

This document integrated and referenced other Git commands like: <code><a href="/git/tutorials/using-branches" data-event="clicked" data-uuid="42e06596-d5" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git branch</a></code>, <code><a href="/git/tutorials/syncing/git-pull" data-event="clicked" data-uuid="42e06596-d5" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git pull</a></code>, and <code><a href="/git/tutorials/syncing/git-fetch" data-event="clicked" data-uuid="42e06596-d5" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git fetch</a></code>. 
Visit their corresponding stand-alone pages for more information. 
<h2><br><span class="orange">Git merge conflicts</span></h2>
Version control systems are all about managing contributions between multiple distributed authors ( usually developers ). 

Sometimes multiple developers may try to edit the same content. 
If Developer A tries to edit code that Developer B is editing a conflict may occur. 
To alleviate the occurrence of conflicts developers will work in separate <a href="/git/tutorials/using-branches" data-event="clicked" data-uuid="a5fba3a8-06" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">isolated branches</a>. 
The <code>git merge</code> command's primary responsibility is to combine separate branches and resolve any conflicting edits.
<h2><span class="saddlebrown">&emsp;Understanding merge conflicts</span></h2>
Merging and conflicts are a common part of the Git experience. 
Conflicts in other version control tools like SVN can be costly and time-consuming. 
Git makes merging super easy. 

Most of the time, Git will figure out how to automatically integrate new changes.
Conflicts generally arise when two people have changed the same lines in a file, or if one developer deleted a file while another developer was modifying it. 
In these cases, Git cannot automatically determine what is correct. 
Conflicts only affect the developer conducting the merge, the rest of the team is unaware of the conflict. 

Git will mark the file as being conflicted and halt the merging process. 
It is then the developers' responsibility to resolve the conflict.
<h2><span class="saddlebrown">&emsp;Types of merge conflicts</span></h2>
A merge can enter a conflicted state at two separate points. 

When starting and during a merge process. 
The following is a discussion of how to address each of these conflict scenarios.
<h3>&emsp;Git fails to start the merge</h3>
A merge will fail to start when Git sees there are changes in either the working directory or staging area of the current project. 

Git fails to start the merge because these pending changes could be written over by the commits that are being merged in. 
When this happens, it is not because of conflicts with other developer's, but conflicts with pending local changes. 
The local state will need to be stabilized using <code>git stash</code>, <code>git checkout</code>, <code>git commit</code> or <code>git reset</code>. 
A merge failure on start will output the following error message:

<code>error: Entry '&lt;fileName>' not uptodate. 
Cannot merge. 
(Changes in working directory)</code>
<h3>&emsp;Git fails during the merge</h3>

A failure DURING a merge indicates a conflict between the current local branch and the branch being merged. 
This indicates a conflict with another developers code. 
Git will do its best to merge the files but will leave things for you to resolve manually in the conflicted files. 
A mid-merge failure will output the following error message:

<code>error: Entry '&lt;fileName>' would be overwritten by merge. 
Cannot merge. 
(Changes in staging area)</code>
<h2><span class="saddlebrown">&emsp;Creating a merge conflict</span></h2>
In order to get real familiar with merge conflicts, the next section will simulate a conflict to later examine and resolve. 
The example will be using a Unix-like command-line Git interface to execute the example simulation.
<code>$ mkdir git-merge-test
$ cd git-merge-test

$ git init .
$ echo "this is some content to mess with" > merge.txt
$ git add merge.txt
$ git commit -am"we are commiting the inital content"

[main (root-commit) d48e74c] we are commiting the inital content
1 file changed, 1 insertion(+)
create mode 100644 merge.txt</code>
This code example executes a sequence of commands that accomplish the following.

Create a new directory named <code>git-merge-test,</code> change to that directory, and initialize it as a new Git repo.
Create a new text file <code>merge.txt</code> with some content in it. 
Add <code>merge.txt</code> to the repo and commit it.
Now we have a new repo with one branch <code>main</code> and a file <code>merge.txt</code> with content in it. 

Next, we will create a new branch to use as the conflicting merge.
<code>$ git checkout -b new_branch_to_merge_later
$ echo "totally different content to merge later" > merge.txt
$ git commit -am"edited the content of merge.txt to cause a conflict"

[new_branch_to_merge_later 6282319] edited the content of merge.txt to cause a conflict
1 file changed, 1 insertion(+), 1 deletion(-)</code>
The proceeding command sequence achieves the following:
create and check out a new branch named <code>new_branch_to_merge_later</code>

overwrite the content in <code>merge.txt</code>  
commit the new content
With this new branch: <code>new_branch_to_merge_later</code> we have created a commit that overrides the content of <code>merge.txt</code>
<code>git checkout main

Switched to branch 'main'
echo "content to append" >> merge.txt
git commit -am"appended content to merge.txt"
[main 24fbe3c] appended content to merge.tx

1 file changed, 1 insertion(+)</code>
This chain of commands checks out the <code>main</code> branch, appends content to <code>merge.txt</code>, and commits it. 
This now puts our example repo in a state where we have 2 new commits. 
One in the <code>main</code> branch and one in the <code>new_branch_to_merge_later</code> branch. 

At this time lets <code>git merge new_branch_to_merge_later</code> and see what happen!
<code>$ git merge new_branch_to_merge_later
Auto-merging merge.txt
CONFLICT (content): Merge conflict in merge.txt

Automatic merge failed; fix conflicts and then commit the result.</code>
BOOM . 
A conflict appears. 
Thanks, Git for letting us know about this!
<h2><span class="saddlebrown">&emsp;How to identify merge conflicts</span></h2>
As we have experienced from the proceeding example, Git will produce some descriptive output letting us know that a CONFLICT has occcured. 
We can gain further insight by running the <code><a href="/git/tutorials/inspecting-a-repository" data-event="clicked" data-uuid="af012c20-58" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git status</a></code> command
<code>$ git status

On branch main
You have unmerged paths.
(fix conflicts and run "git commit")
(use "git merge --abort" to abort the merge)

Unmerged paths:
(use "git add &lt;file>..." to mark resolution)
both modified:   merge.txt</code>
The output from <code>git status</code> indicates that there are unmerged paths due to a conflict. 

The <code>merge.text</code> file now appears in a modified state. 
Let's examine the file and see whats modified.
<code>$ cat merge.txt
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD

this is some content to mess with
content to append
=======
totally different content to merge later

>>>>>>> new_branch_to_merge_later</code>
Here we have used the <code>cat</code> command to put out the contents of the <code>merge.txt </code>file. 
We can see some strange new additions
<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code>

<code>=======</code>
<code>>>>>>>> new_branch_to_merge_later</code>
Think of these new lines as "conflict dividers". 
The <code>=======</code> line is the "center" of the conflict. 

All the content between the center and the <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code> line is content that exists in the current branch main which the <code>HEAD</code> ref is pointing to. 
Alternatively all content between the center and <code>>>>>>>> new_branch_to_merge_later</code> is content that is present in our merging branch.
<h2><span class="saddlebrown">&emsp;How to resolve merge conflicts using the command line</span></h2>
The most direct way to resolve a merge conflict is to edit the conflicted file. 

Open the <code>merge.txt</code> file in your favorite editor. 
For our example lets simply remove all the conflict dividers. 
The modified <code>merge.txt</code> content should then look like:
<code>this is some content to mess with

content to append
totally different content to merge later</code>
Once the file has been edited use <code>git add merge.txt</code> to stage the new merged content. 
To finalize the merge create a new commit by executing:

<code>git commit -m "merged and resolved the conflict in merge.txt"</code>
Git will see that the conflict has been resolved and creates a new merge commit to finalize the merge.
<h2><span class="saddlebrown">&emsp;Git commands that can help resolve merge conflicts</span></h2>
<h3>&emsp;General tools</h3>

<code>git status</code>
The status command is in frequent use when a working with Git and during a merge it will help identify conflicted files.
<code>git log --merge</code>
Passing the <code>--merge</code> argument to the <code>git log</code> command will produce a log with a list of commits that conflict between the merging branches.

<code>git diff</code>
<code>diff</code> helps find differences between states of a repository/files. 
This is useful in predicting and preventing merge conflicts.
<h3>&emsp;Tools for when git fails to start a merge</h3>

<code>git checkout</code>
<code>checkout</code> can be used for <em>undoing</em> changes to files, or for changing branches
<code>git reset --mixed</code>
<code>reset</code> can be used to undo changes to the working directory and staging area.

<h3>&emsp;Tools for when git conflicts arise during a merge</h3>
<code>git merge --abort</code>
Executing <code>git merge</code> with the <code>--abort</code> option will exit from the merge process and return the branch to the state before the merge began.
<code>git reset</code>

<code>Git reset</code> can be used during a merge conflict to reset conflicted files to a know good state
<h2><span class="saddlebrown">&emsp;Summary</span></h2>
Merge conflicts can be an intimidating experience. 
Luckily, Git offers powerful tools to help navigate and resolve conflicts. 

Git can handle most merges on its own with automatic merging features. 
A conflict arises when two separate branches have made edits to the same line in a file, or when a file has been deleted in one branch but edited in the other. 
Conflicts will most likely happen when working in a team environment.
There are many tools to help resolve merge conflicts. 

Git has plenty of command line tools we discussed here. 
For more detailed information on these tools visit stand-alone pages for <code><a href="/git/tutorials/git-log" data-event="clicked" data-uuid="2c548fdd-40" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git log</a></code>, <code><a href="/git/tutorials/undoing-changes/git-reset" data-event="clicked" data-uuid="2c548fdd-40" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git reset</a></code>, <code><a href="/git/tutorials/inspecting-a-repository" data-event="clicked" data-uuid="2c548fdd-40" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git status</a></code>, <code><a href="/git/tutorials/using-branches/git-checkout" data-event="clicked" data-uuid="2c548fdd-40" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git checkout</a></code>, and <code><a href="/git/tutorials/undoing-changes/git-reset" data-event="clicked" data-uuid="2c548fdd-40" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git reset</a></code>. 
In addition to the Git, many third-party tools offer streamlined merge conflict support features.
<h2><br><span class="orange">Git Merge Strategy Options and Examples</span></h2>
When a piece of work is complete, tested and ready to be merged back into the main line of development, your team has some policy choices to make. 
What are your merge strategy options? In this article we'll examine the possibilities and then provide some notes on how Atlassian operates. 
Hopefully at the end you'll have the tools to decide what works best for your team.
<h2><span class="saddlebrown">&emsp;Git Merge Strategies</span></h2>
A merge happens when combining two branches. 
Git will take two (or more) commit pointers and attempt to find a common base commit between them. 
Git has several different methods to find a base commit, these methods are called "merge strategies". 
Once Git finds a common base commit it will create a new "merge commit" that combines the changes of the specified merge commits. 

Technically, a merge commit is a regular commit which just happens to have two parent commits.
<img src="https://wac-cdn.atlassian.com/dam/jcr:03a86203-4306-48c0-ad11-faa46f47aa27/what-is-a-merge.gif?cdnVersion=217" loading="lazy" alt=""><code>git merge</code> will automatically select a merge strategy unless explicitly specified. 
The <code>git merge</code> and <code>git pull</code> commands can be passed an <code>-s</code> (strategy) option. 
The <code>-s</code> option can be appended with the name of the desired merge strategy. 

If not explicitly specified, Git will select the most appropriate merge strategy based on the provided branches. 
The following is a list of the available merge strategies.
<h3>&emsp;Recursive</h3>
<code>git merge -s recursive branch1 branch2</code>

This operates on two heads. 
Recursive is the default merge strategy when pulling or merging one branch. 
Additionally this can detect and handle merges involving renames, but currently cannot make use of detected copies. 
This is the default merge strategy when pulling or merging one branch.

<h3>&emsp;Resolve</h3>
<code>git merge -s resolve branch1 branch2</code>
This can only resolve two heads using a 3-way merge algorithm. 
It tries to carefully detect cris-cross merge ambiguities and is considered generally safe and fast.

<h3>&emsp;Octopus</h3>
<code>git merge -s octopus branch1 branch2 branch3 branchN</code>
The default merge strategy for more than two heads. 
When more than one branch is passed octopus is automatically engaged. 

If a merge has conflicts that need manual resolution octopus will refuse the merge attempt. 
It is primarily used for bundling similar feature branch heads together.
<h3>&emsp;Ours</h3>
<code>git merge -s ours branch1 branch2 branchN</code>

The Ours strategy operates on multiple N number of branches. 
The output merge result is always that of the current branch <code>HEAD</code>. 
The "ours" term implies the preference effectively ignoring all changes from all other branches. 
It is intended to be used to combine history of similar feature branches.

<h3>&emsp;Subtree</h3>
<code>git merge -s subtree branchA branchB</code>
This is an extension of the recursive strategy. 
When merging A and B, if B is a child subtree of A, B is first updated to reflect the tree structure of A, This update is also done to the common ancestor tree that is shared between A and B.
<h2><span class="saddlebrown">&emsp;Types of Git Merge Strategies</span></h2>
<h3>&emsp;Explicit Merges</h3>
Explicit merges are the default merge type. 
The 'explicit' part is that they create a new merge commit. 

This alters the commit history and explicitly shows where a merge was executed. 
The merge commit content is also explicit in the fact that it shows which commits were the parents of the merge commit. 
Some teams avoid explicit merges because arguably the merge commits add "noise" to the history of the project.
<h3>&emsp;implicit merge via rebase or fast-forward merge</h3>

<h3>&emsp;Squash on merge, generally without explicit merge</h3>
<h2><span class="saddlebrown">&emsp;Recursive Git Merge Strategy Options</span></h2>
The 'recursive' strategy introduced above, has its own subset of additional operation options.
<code>ours</code>

Not to be confused with the Ours merge strategy. 
This option conflicts to be auto-resolved cleanly by favoring the 'our' version. 
Changes from the 'theirs' side are automatically incorporated if they do not conflict.
<code>theirs</code>

The opposite of the 'ours' strategy. 
the "theirs" option favors the foreign merging tree in conflict resolution.
<code>patience</code>
This option spends extra time to avoid mis-merges on unimportant matching lines. 

This options is best used when branches to be merged have extremely diverged.
<code>diff-algorithim</code>
<code>ignore-*
ignore-space-change

ignore-all-space
ignore-space-at-eol
ignore-cr-at-eol</code>
A set of options that target whitespace characters. 

Any line that matches the subset of the passed option will be ignored.
<code>renormalize</code>
This option runs a check-out and check-in on all of the tree git trees while resolving a three-way merge. 
This option is intended to be used with merging branches with differing <code>checkin</code>/<code>checkout</code> states.

<code>no-normalize</code>
Disables the renormalize option. 
This overrides the <code>merge.renormalize</code> configuration variable.
<code>no-renames</code>

This option will ignore renamed files during the merge.
<code>find-renames=n</code>
This is the default behavior. 
The recursive merge will honor file renames. 

The <code>n</code> parameter can be used to pass a threshold for rename similarity. 
The default <code>n</code> value is <code>100%.</code>
<code>subtree</code>
This option borrows from the `subtree` strategy. 

Where the strategy operates on two trees and modifies how to make them match on a shared ancestor, this option instead operates on the path metadata of the tree to make them match.
<h2><span class="saddlebrown">&emsp;Our Git Merge Policy</span></h2>
Atlassian strongly prefers using explicit merges. 
The reason is very simple: explicit merges provide great traceability and context on the features being merged. 

A local history clean-up rebase before sharing a feature branch for review is absolutely encouraged, but this does not change the policy at all. 
It augments it.
<h2><br><span class="orange">Comparing Workflows</span></h2>
Git is the most commonly used version control system today. 

A Git workflow is a recipe or recommendation for how to use Git to accomplish work in a consistent and productive manner. 
Git workflows encourage developers and <a href="/devops/what-is-devops" data-event="clicked" data-uuid="50078859-65" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">DevOps</a> teams to leverage Git effectively and consistently. 
Git offers a lot of flexibility in how users manage changes. 
Given Git's focus on flexibility, there is no standardized process on how to interact with Git. 

When working with a team on a Git-managed project, it’s important to make sure the team is all in agreement on how the flow of changes will be applied. 
To ensure the team is on the same page, an agreed-upon Git workflow should be developed or selected. 
There are several publicized Git workflows that may be a good fit for your team. 
Here, we will discuss some of these Git workflow options.

The array of possible workflows can make it hard to know where to begin when implementing Git in the workplace. 
This page provides a starting point by surveying the most common Git workflows for software teams.
As you read through, remember that these workflows are designed to be guidelines rather than concrete rules. 
We want to show you what’s possible, so you can mix and match aspects from different workflows to suit your individual needs.
<h2><span class="saddlebrown">&emsp;What is a successful Git workflow?</span></h2>
When evaluating a workflow for your team, it's most important that you consider your team’s culture. 
You want the workflow to enhance the effectiveness of your team and not be a burden that limits productivity. 
Some things to consider when evaluating a Git workflow are:

Does this workflow scale with team size?
Is it easy to undo mistakes and errors with this workflow?
Does this workflow impose any new unnecessary cognitive overhead to the team?
<h2><span class="saddlebrown">&emsp;Centralized Workflow</span></h2>
<img src="https://wac-cdn.atlassian.com/dam/jcr:0869c664-5bc1-4bf2-bef0-12f3814b3187/01.svg?cdnVersion=217" loading="lazy" alt="git workflow | Central and local repositories">The Centralized Workflow is a great Git workflow for teams transitioning from SVN. 
Like Subversion, the Centralized Workflow uses a central repository to serve as the single point-of-entry for all changes to the project. 
Instead of <code>trunk</code>, the default development branch is called <code>main</code> and all changes are committed into this branch. 
This workflow doesn’t require any other branches besides <code>main</code>.

Transitioning to a distributed version control system may seem like a daunting task, but you don’t have to change your existing workflow to take advantage of Git. 
Your team can develop projects in the exact same way as they do with Subversion.
However, using Git to power your development workflow presents a few advantages over SVN. 
First, it gives every developer their own local copy of the entire project. 

This isolated environment lets each developer work independently of all other changes to a project - they can add commits to their local repository and completely forget about upstream developments until it's convenient for them.
Second, it gives you access to Git’s robust branching and merging model. 
Unlike SVN, Git branches are designed to be a fail-safe mechanism for integrating code and sharing changes between repositories. 
The Centralized Workflow is similar to other workflows in its utilization of a remote server-side hosted repository that developers push and pull form. 

Compared to other workflows, the Centralized Workflow has no defined pull request or forking patterns. 
A Centralized Workflow is generally better suited for teams migrating from SVN to Git and smaller size teams.
<h2><span class="saddlebrown">&emsp;How it works</span></h2>
Developers start by cloning the central repository. 

In their own local copies of the project, they edit files and commit changes as they would with SVN; however, these new commits are stored locally - they’re completely isolated from the central repository. 
This lets developers defer synchronizing upstream until they’re at a convenient break point.
To publish changes to the official project, developers "push" their local <code>main</code> branch to the central repository. 
This is the equivalent of <code>svn commit</code>, except that it adds all of the local commits that aren’t already in the central <code>main</code> branch.

<h3>&emsp;Initialize the central repository</h3>
<img src="https://wac-cdn.atlassian.com/dam/jcr:8fe7b38d-e671-4d2f-bde7-52c5f60e1164/01%20Central%20Repository.svg?cdnVersion=217" loading="lazy" alt="Git Workflow: Initialize Central Bare Repository">First, someone needs to create the central repository on a server. 
If it’s a new project, you can initialize an empty repository. 
Otherwise, you’ll need to import an existing Git or SVN repository.

Central repositories should always be bare repositories (they shouldn’t have a working directory), which can be created as follows:
<code>ssh user@host git init --bare /path/to/repo.git</code>
Be sure to use a valid SSH username for <code>user</code>, the domain or IP address of your server for <code>host</code>, and the location where you'd like to store your repo for <code>/path/to/repo.git</code>. 
Note that the <code>.git</code> extension is conventionally appended to the repository name to indicate that it’s a bare repository.

<h3>&emsp;Hosted central repositories</h3>
Central repositories are often created through 3rd party Git hosting services like <a href="https://bitbucket.org/product" data-event="clicked" data-uuid="1ac8ea43-80" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Bitbucket Cloud</a> or <a href="https://bitbucket.org/product/enterprise" data-event="clicked" data-uuid="1ac8ea43-80" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Bitbucket Server</a>. 
The process of initializing a bare repository discussed above is handled for you by the hosting service. 
The hosting service will then provide an address for the central repository to access from your local repository.

<h3>&emsp;Clone the central repository</h3>
Next, each developer creates a local copy of the entire project. 
This is accomplished via the <code><a href="/git/tutorials/setting-up-a-repository/git-clone" data-event="clicked" data-uuid="2eb42001-26" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git clone</a></code> command:
<code>git clone ssh://user@host/path/to/repo.git</code>

When you clone a repository, Git automatically adds a shortcut called <code>origin</code> that points back to the “parent” repository, under the assumption that you'll want to interact with it further on down the road. 
<h3>&emsp;Make changes and commit</h3>
Once the repository is cloned locally, a developer can make changes using the standard Git commit process: edit, stage, and commit. 
If you’re not familiar with the staging area, it’s a way to prepare a commit without having to include every change in the working directory. 

This lets you create highly focused commits, even if you’ve made a lot of local changes.
<code>git status # View the state of the repo
git add &lt;some-file> # Stage a file
git commit # Commit a file&lt;/some-file></code>

Remember that since these commands create local commits, John can repeat this process as many times as he wants without worrying about what’s going on in the central repository. 
This can be very useful for large features that need to be broken down into simpler, more atomic chunks.
<h3>&emsp;Push new commits to central repository</h3>
Once the local repository has new changes committed. 

These change will need to be pushed to share with other developers on the project.
<code>git push origin main</code>
This command will push the new committed changes to the central repository. 
When pushing changes to the central repository, it is possible that updates from another developer have been previously pushed that contain code which conflict with the intended push updates. 

Git will output a message indicating this conflict. 
In this situation, <code>git pull</code> will first need to be executed. 
This conflict scenario will be expanded on in the following section.
<h3>&emsp;Managing conflicts</h3>

The central repository represents the official project, so its commit history should be treated as sacred and immutable. 
If a developer’s local commits diverge from the central repository, Git will refuse to push their changes because this would overwrite official commits.
<img src="https://wac-cdn.atlassian.com/dam/jcr:2943ffa0-df0a-493b-8677-30b31a1a43e3/02%20Local%20Repository.svg?cdnVersion=217" loading="lazy" alt="Git Workflows: Managing conflicts">Before the developer can publish their feature, they need to fetch the updated central commits and rebase their changes on top of them. 
This is like saying, “I want to add my changes to what everyone else has already done.” The result is a perfectly linear history, just like in traditional SVN workflows.

If local changes directly conflict with upstream commits, Git will pause the rebasing process and give you a chance to manually resolve the conflicts. 
The nice thing about Git is that it uses the same <code>git status</code> and <code>git add</code> commands for both generating commits and resolving merge conflicts. 
This makes it easy for new developers to manage their own merges. 
Plus, if they get themselves into trouble, Git makes it very easy to abort the entire rebase and try again (or go find help).
<h2><span class="saddlebrown">&emsp;Example</span></h2>
Let’s take a general example at how a typical small team would collaborate using this workflow. 
We’ll see how two developers, John and Mary, can work on separate features and share their contributions via a centralized repository.
<h3>&emsp;John works on his feature</h3>

<img src="https://wac-cdn.atlassian.com/dam/jcr:76bfc199-100a-4ef7-b9cf-86179ea5507c/06%20(2).svg?cdnVersion=217" loading="lazy" alt="Git Workflows: Edit Stage Commit Feature Process">In his local repository, John can develop features using the standard Git commit process: edit, stage, and commit.
Remember that since these commands create local commits, John can repeat this process as many times as he wants without worrying about what’s going on in the central repository.
<h3>&emsp;Mary works on her feature</h3>
<img src="https://wac-cdn.atlassian.com/dam/jcr:a0aa8d1b-11a4-4aa4-a3a9-4f83f9be9a67/07.svg?cdnVersion=217" loading="lazy" alt="Git Workflows: Edit Stage Commit Feature">Meanwhile, Mary is working on her own feature in her own local repository using the same edit/stage/commit process. 

Like John, she doesn’t care what’s going on in the central repository, and she <em>really</em> doesn’t care what John is doing in his local repository, since all local repositories are <em>private</em>.
<h3>&emsp;John publishes his feature</h3>
<img src="https://wac-cdn.atlassian.com/dam/jcr:6e5dc66d-b041-4013-b321-b1908fecfdbd/08.svg?cdnVersion=217" loading="lazy" alt="Git Workflows: Publish Feature">Once John finishes his feature, he should publish his local commits to the central repository so other team members can access it. 
He can do this with the <code><a href="/git/tutorials/syncing/git-push" data-event="clicked" data-uuid="592fc470-52" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git push</a></code> command, like so:

<code>git push origin main</code>
Remember that <code>origin</code> is the remote connection to the central repository that Git created when John cloned it. 
The <code>main</code> argument tells Git to try to make the <code>origin</code>’s <code>main</code> branch look like his local <code>main</code> branch. 
Since the central repository hasn’t been updated since John cloned it, this won’t result in any conflicts and the push will work as expected.

<h3>&emsp;Mary tries to publish her feature</h3>
<img src="https://wac-cdn.atlassian.com/dam/jcr:52e2347e-b8e0-49ab-9530-5d1e9129198e/09.svg?cdnVersion=217" loading="lazy" alt="Git Workflows: Push Command Error">Let’s see what happens if Mary tries to push her feature after John has successfully published his changes to the central repository. 
She can use the exact same push command:
<code>git push origin main</code>

But, since her local history has diverged from the central repository, Git will refuse the request with a rather verbose error message:
<code>error: failed to push some refs to '/path/to/repo.git'
hint: Updates were rejected because the tip of your current branch is behind
hint: its remote counterpart. 

Merge the remote changes (e.g. 
'git pull')
hint: before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.</code>

This prevents Mary from overwriting official commits. 
She needs to pull John’s updates into her repository, integrate them with her local changes, and then try again.
<h3>&emsp;Mary rebases on top of John’s commit(s)</h3>
<img src="https://wac-cdn.atlassian.com/dam/jcr:25edd772-a30a-475a-a6ca-d1055ae61737/10.svg?cdnVersion=217" loading="lazy" alt="Git Workflows: Git Pull Rebase">Mary can use <code><a href="/git/tutorials/syncing/git-pull" data-event="clicked" data-uuid="5eba1fb9-97" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git pull</a></code> to incorporate upstream changes into her repository. 

This command is sort of like <code>svn update</code>—it pulls the entire upstream commit history into Mary’s local repository and tries to integrate it with her local commits:
<code>git pull --rebase origin main</code>
The <code>--rebase</code> option tells Git to move all of Mary’s commits to the tip of the <code>main</code> branch after synchronising it with the changes from the central repository, as shown below:
<img src="https://wac-cdn.atlassian.com/dam/jcr:0e7adcca-372a-4f08-9260-265d7b961a9f/03%20Mary&amp;%23039;s%20Repository.svg?cdnVersion=217" loading="lazy" alt="Git workflows: Rebasing to Master">The pull would still work if you forgot this option, but you would wind up with a superfluous “merge commit” every time someone needed to synchronize with the central repository. 

For this workflow, it’s always better to rebase instead of generating a merge commit.
<h3>&emsp;Mary resolves a merge conflict</h3>
<img src="https://wac-cdn.atlassian.com/dam/jcr:eaad29a3-6d94-4916-8a2c-3dea71aea4c2/12.svg?cdnVersion=217" loading="lazy" alt="Git Workflows: Rebasing on Commits">Rebasing works by transferring each local commit to the updated <code>main</code> branch one at a time. 
This means that you catch merge conflicts on a commit-by-commit basis rather than resolving all of them in one massive merge commit. 

This keeps your commits as focused as possible and makes for a clean project history. 
In turn, this makes it much easier to figure out where bugs were introduced and, if necessary, to roll back changes with minimal impact on the project.
If Mary and John are working on unrelated features, it’s unlikely that the rebasing process will generate conflicts. 
But if it does, Git will pause the rebase at the current commit and output the following message, along with some relevant instructions:

<code>CONFLICT (content): Merge conflict in &lt;some-file></code>
<img src="https://wac-cdn.atlassian.com/dam/jcr:ebec4580-b3fc-47a4-b64d-a485bf892c87/04%20Mary&amp;%23039;s%20Repository.svg?cdnVersion=217" loading="lazy" alt="Git workflows: Conflict Resolution">The great thing about Git is that <em>anyone</em> can resolve their own merge conflicts. 
In our example, Mary would simply run a <code><a href="/git/tutorials/inspecting-a-repository" data-event="clicked" data-uuid="95672487-81" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git status</a></code> to see where the problem is. 
Conflicted files will appear in the Unmerged paths section:

<code># Unmerged paths:
# (use "git reset HEAD &lt;some-file>..." to unstage)
# (use "git add/rm &lt;some-file>..." as appropriate to mark resolution)
#

# both modified: &lt;some-file></code>
Then, she’ll edit the file(s) to her liking. 
Once she’s happy with the result, she can stage the file(s) in the usual fashion and let <code><a href="/git/tutorials/rewriting-history/git-rebase" data-event="clicked" data-uuid="188d9aa3-ea" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git rebase</a></code> do the rest:
<code>git add &lt;some-file>

git rebase --continue</code>
And that’s all there is to it. 
Git will move on to the next commit and repeat the process for any other commits that generate conflicts.
If you get to this point and realize and you have no idea what’s going on, don’t panic. 

Just execute the following command and you’ll be right back to where you started:
<code>git rebase --abort</code>
<h3>&emsp;Mary successfully publishes her feature</h3>
<img src="https://wac-cdn.atlassian.com/dam/jcr:de2dabdd-542f-4f64-9be4-870abff06f60/14.svg?cdnVersion=217" loading="lazy" alt="Git Workflows: Synchronize Central Repo">After she’s done synchronizing with the central repository, Mary will be able to publish her changes successfully:

<code>git push origin main</code>
<h3>&emsp;Where to go from here</h3>
As you can see, it’s possible to replicate a traditional Subversion development environment using only a handful of Git commands. 
This is great for transitioning teams off of SVN, but it doesn’t leverage the distributed nature of Git.

The Centralized Workflow is great for small teams. 
The conflict resolution process detailed above can form a bottleneck as your team scales in size. 
If your team is comfortable with the Centralized Workflow but wants to streamline its collaboration efforts, it's definitely worth exploring the benefits of the <a href="/git/tutorials/comparing-workflows/feature-branch-workflow" data-event="clicked" data-uuid="b6c63303-e9" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Feature Branch Workflow</a>. 
By dedicating an isolated branch to each feature, it’s possible to initiate in-depth discussions around new additions before integrating them into the official project.
<h2><span class="saddlebrown">&emsp;Other common workflows</span></h2>
The Centralized Workflow is essentially a building block for other Git workflows. 
Most popular Git workflows will have some sort of centralized repo that individual developers will push and pull from. 
Below we will briefly discuss some other popular Git workflows. 

These extended workflows offer more specialized patterns in regard to managing branches for feature development, hot fixes, and eventual release.
<h2><span class="saddlebrown">&emsp;Feature branching</span></h2>
Feature Branching is a logical extension of Centralized Workflow. 
The core idea behind the <a href="/git/tutorials/comparing-workflows/feature-branch-workflow" data-event="clicked" data-uuid="83638610-a0" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Feature Branch Workflow</a> is that all feature development should take place in a dedicated branch instead of the <code>main</code> branch. 

This encapsulation makes it easy for multiple developers to work on a particular feature without disturbing the main codebase. 
It also means the <code>main</code> branch should never contain broken code, which is a huge advantage for continuous integration environments. 
<h2><span class="saddlebrown">&emsp;Gitflow Workflow</span></h2>
The <a href="/git/tutorials/comparing-workflows/gitflow-workflow" data-event="clicked" data-uuid="29203141-9e" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Gitflow Workflow</a> was first published in a highly regarded 2010 blog post from <a href="http://nvie.com/posts/a-successful-git-branching-model/" data-event="clicked" data-uuid="29203141-9e" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Vincent Driessen at nvie</a>. 

The Gitflow Workflow defines a strict branching model designed around the project release. 
This workflow doesn’t add any new concepts or commands beyond what’s required for the Feature Branch Workflow. 
Instead, it assigns very specific roles to different branches and defines how and when they should interact. 
<h2><span class="saddlebrown">&emsp;Forking Workflow</span></h2>
The <a href="/git/tutorials/comparing-workflows/forking-workflow" data-event="clicked" data-uuid="f83cb73b-bf" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Forking Workflow</a> is fundamentally different than the other workflows discussed in this tutorial. 
Instead of using a single server-side repository to act as the “central” codebase, it gives every developer a server-side repository. 
This means that each contributor has not one, but two Git repositories: a private local one and a public server-side one. 
<h2><span class="saddlebrown">&emsp;Guidelines</span></h2>
There is no one size fits all Git workflow. 
As previously stated, it’s important to develop a Git workflow that is a productivity enhancement for your team. 
In addition to team culture, a workflow should also complement business culture. 
Git features like branches and tags should complement your business’s release schedule. 

If your team is using <a href="/software/jira" data-event="clicked" data-uuid="0e583888-c9" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">task tracking project management software</a> you may want to use branches that correspond with tasks in progress. 
In addition, some guidelines to consider when deciding on a workflow are:
<h3>&emsp;Short-lived branches</h3>
The longer a branch lives separate from the production branch, the higher the risk for merge conflicts and deployment challenges. 

Short-lived branches promote cleaner merges and deploys.
<h3>&emsp;Minimize and simplify reverts</h3>
It’s important to have a workflow that helps proactively prevent merges that will have to be reverted. 
A workflow that tests a branch before allowing it to be merged into the <code>main</code> branch is an example. 

However, accidents do happen. 
That being said, it’s beneficial to have a workflow that allows for easy reverts that will not disrupt the flow for other team members.
<h3>&emsp;Match a release schedule</h3>
A workflow should complement your business’s software development release cycle. 

If you plan to release multiple times a day, you will want to keep your <code>main</code> branch stable. 
If your release schedule is less frequent, you may want to consider using Git tags to tag a branch to a version.
<h2><span class="saddlebrown">&emsp;Summary</span></h2>
In this document we discussed Git workflows. 

We took an in-depth look at a Centralized Workflow with practical examples. 
Expanding on the Centralized Workflow we discussed additional specialized workflows. 
Some key takeaways from this document are:
There is no one-size-fits-all Git workflow

A workflow should be simple and enhance the productivity of your team
Your business requirements should help shape your Git workflow
To read about the next Git workflow check out our comprehensive breakdown of the <a href="/git/tutorials/comparing-workflows/feature-branch-workflow" data-event="clicked" data-uuid="fb03d0cd-4f" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Feature Branch Workflow</a>.
<h2><br><span class="orange">Git Feature Branch Workflow</span></h2>
The core idea behind the Feature Branch Workflow is that all feature development should take place in a dedicated branch instead of the <code>main</code> branch. 
This encapsulation makes it easy for multiple developers to work on a particular feature without disturbing the main codebase. 
It also means the <code>main</code> branch will never contain broken code, which is a huge advantage for continuous integration environments.
Encapsulating feature development also makes it possible to leverage pull requests, which are a way to initiate discussions around a branch. 

They give other developers the opportunity to sign off on a feature before it gets integrated into the official project. 
Or, if you get stuck in the middle of a feature, you can open a pull request asking for suggestions from your colleagues. 
The point is, pull requests make it incredibly easy for your team to comment on each other’s work.
The Git Feature Branch Workflow is a composable workflow that can be leveraged by other high-level Git workflows. 

We discussed other Git workflows on <a href="/git/tutorials/comparing-workflows" data-event="clicked" data-uuid="59710065-d9" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">the Git workflow overview page</a>. 
Git Feature Branch Workflow is branching model focused, meaning that it is a guiding framework for managing and creating branches. 
Other workflows are more repo focused. 
The Git Feature Branch Workflow can be incorporated into other workflows. 

The <a href="/git/tutorials/comparing-workflows/gitflow-workflow" data-event="clicked" data-uuid="59710065-d9" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Gitflow</a>, and <a href="/git/tutorials/comparing-workflows/forking-workflow" data-event="clicked" data-uuid="59710065-d9" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Git Forking Workflows</a> traditionally use a Git Feature Branch Workflow in regards to their branching models.
<h2><span class="saddlebrown">&emsp;How it works</span></h2>
The Feature Branch Workflow assumes a central repository, and <code>main</code> represents the official project history. 
Instead of committing directly on their local <code>main</code> branch, developers create a new branch every time they start work on a new feature. 

Feature branches should have descriptive names, like animated-menu-items or issue-#1061. 
The idea is to give a clear, highly-focused purpose to each branch. 
Git makes no technical distinction between the <code>main</code> branch and feature branches, so developers can edit, stage, and commit changes to a feature branch.
In addition, feature branches can (and should) be pushed to the central repository. 

This makes it possible to share a feature with other developers without touching any official code. 
Since <code>main</code> is the only “special” branch, storing several feature branches on the central repository doesn’t pose any problems. 
Of course, this is also a convenient way to back up everybody’s local commits. 
The following is a walk-through of the life-cycle of a feature branch.

<h3>&emsp;Start with the main branch</h3>
All feature branches are created off the latest code state of a project. 
This guide assumes this is maintained and updated in the <code>main</code> branch.
<code>git checkout main

git fetch origin 
git reset --hard origin/main</code>
This switches the repo to the <code>main</code> branch, pulls the latest commits and resets the repo's local copy of <code>main</code> to match the latest version.
<h3>&emsp;Create a new-branch</h3>

Use a separate branch for each feature or issue you work on. 
After creating a branch, check it out locally so that any changes you make will be on that branch.
<code>git checkout -b new-feature</code>
This checks out a branch called new-feature based on <code>main</code>, and the -b flag tells Git to create the branch if it doesn’t already exist.

<h3>&emsp;Update, add, commit, and push changes</h3>
On this branch, edit, stage, and commit changes in the usual fashion, building up the feature with as many commits as necessary. 
Work on the feature and make commits like you would any time you use Git. 
When ready, push your commits, updating the feature branch on Bitbucket.

<code>git status
git add &lt;some-file>
git commit</code>
<h3>&emsp;Push feature branch to remote</h3>

It’s a good idea to push the feature branch up to the central repository. 
This serves as a convenient backup, when collaborating with other developers, this would give them access to view commits to the new branch.
<code>git push -u origin new-feature</code>
This command pushes new-feature to the central repository (origin), and the -u flag adds it as a remote tracking branch. 

After setting up the tracking branch, <code>git push</code> can be invoked without any parameters to automatically push the new-feature branch to the central repository. 
To get feedback on the new feature branch, create a pull request in a repository management solution like <a href="https://bitbucket.org/product" data-event="clicked" data-uuid="225259bb-6e" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Bitbucket Cloud</a> or <a href="/software/bitbucket/enterprise/data-center" data-event="clicked" data-uuid="225259bb-6e" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Bitbucket Data Center</a>. 
From there, you can add reviewers and make sure everything is good to go before merging.
<h3>&emsp;Resolve feedback</h3>

Now teammates comment and approve the pushed commits. 
Resolve their comments locally, commit, and push the suggested changes to Bitbucket. 
Your updates appear in the pull request.
<h3>&emsp;Merge your pull request</h3>

Before you merge, you may have to resolve merge conflicts if others have made changes to the repo. 
When your pull request is approved and conflict-free, you can add your code to the <code>main</code> branch. 
Merge from the pull request in Bitbucket.
<h2><span class="saddlebrown">&emsp;Pull requests</span></h2>
Aside from isolating feature development, branches make it possible to discuss changes via pull requests. 
Once someone completes a feature, they don’t immediately merge it into <code>main</code>. 
Instead, they push the feature branch to the central server and file a pull request asking to merge their additions into <code>main</code>. 
This gives other developers an opportunity to review the changes before they become a part of the main codebase.

Code review is a major benefit of pull requests, but they’re actually designed to be a generic way to talk about code. 
You can think of pull requests as a discussion dedicated to a particular branch. 
This means that they can also be used much earlier in the development process. 
For example, if a developer needs help with a particular feature, all they have to do is file a pull request. 

Interested parties will be notified automatically, and they’ll be able to see the question right next to the relevant commits.
Once a pull request is accepted, the actual act of publishing a feature is much the same as in the <a href="/git/tutorials/comparing-workflows" data-event="clicked" data-uuid="823f4a59-7c" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Centralized Workflow</a>. 
First, you need to make sure your local <code>main</code> is synchronized with the upstream <code>main</code>. 
Then, you merge the feature branch into <code>main</code> and push the updated <code>main</code> back to the central repository.

Pull requests can be facilitated by product repository management solutions like Bitbucket Cloud or Bitbucket Server. 
View the Bitbucket Server pull requests documentation for an example.
<h2><span class="saddlebrown">&emsp;Example</span></h2>
The following is an example of the type of scenario in which a feature branching workflow is used. 

The scenario is that of a team doing code review around on a new feature pull request. 
This is one example of the many purposes this model can be used for.
<h3>&emsp;Mary begins a new feature</h3>
<img src="https://wac-cdn.atlassian.com/dam/jcr:223f5106-2191-4450-8916-e5c80d7d907a/02.svg?cdnVersion=217" loading="lazy" alt="Feature Branch Workflow: comit changes">Before she starts developing a feature, Mary needs an isolated branch to work on. 

She can request a new branch with the following command:
<code>git checkout -b marys-feature main</code>
This checks out a branch called <code>marys-feature</code> based on <code>main,</code> and the -b flag tells Git to create the branch if it doesn’t already exist. 
On this branch, Mary edits, stages, and commits changes in the usual fashion, building up her feature with as many commits as necessary:

<code>git status
git add &lt;some-file>
git commit</code>
<h3>&emsp;Mary goes to lunch</h3>

<img src="https://wac-cdn.atlassian.com/dam/jcr:e2c88c1b-fb28-46a3-93be-c1c45f86bd1c/03%20(1).svg?cdnVersion=217" loading="lazy" alt="Feature Branch Workflow: git push">Mary adds a few commits to her feature over the course of the morning. 
Before she leaves for lunch, it’s a good idea to push her feature branch up to the central repository. 
This serves as a convenient backup, but if Mary was collaborating with other developers, this would also give them access to her initial commits.
<code>git push -u origin marys-feature</code>

This command pushes <code>marys-feature</code> to the central repository (origin), and the -u flag adds it as a remote tracking branch. 
After setting up the tracking branch, Mary can call <code>git push</code> without any parameters to push her feature.
<h3>&emsp;Mary finishes her feature</h3>
<img src="https://wac-cdn.atlassian.com/dam/jcr:d0c471b4-61c8-4005-86bc-904d894e391b/04.svg?cdnVersion=217" loading="lazy" alt="Feature Branch Workflow: Git push ">When Mary gets back from lunch, she completes her feature. 

Before merging it into <code>main</code>, she needs to file a pull request letting the rest of the team know she's done. 
But first, she should make sure the central repository has her most recent commits:
<code>git push</code>
Then, she files the pull request in her Git GUI asking to merge <code>marys-feature</code> into <code>main</code>, and team members will be notified automatically. 

The great thing about pull requests is that they show comments right next to their related commits, so it's easy to ask questions about specific changesets.
<h3>&emsp;Bill receives the pull request</h3>
<img src="https://wac-cdn.atlassian.com/dam/jcr:2119c2a3-7dff-43ad-bf98-77672d93242f/05%20(1).svg?cdnVersion=217" loading="lazy" alt="Feature Branch Workflow: Review a pull request">Bill gets the pull request and takes a look at <code>marys-feature.</code> He decides he wants to make a few changes before integrating it into the official project, and he and Mary have some back-and-forth via the pull request.
<h3>&emsp;Mary makes the changes</h3>

<img src="https://wac-cdn.atlassian.com/dam/jcr:1c466900-dffa-4912-8764-79943755dbf9/06%20(1).svg?cdnVersion=217" loading="lazy" alt="Feature Branch Workflow: Pull request Revisions">To make the changes, Mary uses the exact same process as she did to create the first iteration of her feature. 
She edits, stages, commits, and pushes updates to the central repository. 
All her activity shows up in the pull request, and Bill can still make comments along the way.
If he wanted, Bill could pull <code>marys-feature</code> into his local repository and work on it on his own. 

Any commits he added would also show up in the pull request.
<h3>&emsp;Mary publishes her feature</h3>
<img src="https://wac-cdn.atlassian.com/dam/jcr:09308632-38a3-4637-bba2-af2110629d56/07.svg?cdnVersion=217" loading="lazy" alt="Feature Branch Workflow: Merging a feature branch">Once Bill is ready to accept the pull request, someone needs to merge the feature into the stable project (this can be done by either Bill or Mary):
<code>git checkout main

git pull
git pull origin marys-feature
git push</code>
This process often results in a merge commit. 

Some developers like this because it’s like a symbolic joining of the feature with the rest of the code base. 
But, if you’re partial to a linear history, it’s possible to rebase the feature onto the tip of <code>main</code> before executing the merge, resulting in a fast-forward merge.
Some GUI’s will automate the pull request acceptance process by running all of these commands just by clicking an “Accept” button. 
If yours doesn’t, it should at least be able to automatically close the pull request when the feature branch gets merged into <code>main.</code>

Meanwhile, John is doing the exact same thing
While Mary and Bill are working on marys-feature and discussing it in her pull request, John is doing the exact same thing with his own feature branch. 
By isolating features into separate branches, everybody can work independently, yet it’s still trivial to share changes with other developers when necessary.
<h2><span class="saddlebrown">&emsp;Summary</span></h2>
In this document, we discussed the Git Feature Branch Workflow. 
This workflow helps organize and track branches that are focused on business domain feature sets. 
Other Git workflows like the Git Forking Workflow and the Gitflow Workflow are repo focused and can leverage the Git Feature Branch Workflow to manage their branching models. 
This document demonstrated a high-level code example and fictional example for implementing the Git Feature Branch Workflow. 

Some key associations to make with the Feature Branch Workflow are:
focused on branching patterns
can be leveraged by other repo oriented workflows
promotes collaboration with team members through pull requests and merge reviews

Utilizing <a href="/git/tutorials/rewriting-history/git-rebase" data-event="clicked" data-uuid="3127d2ac-9a" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git rebase</a> during the review and merge stages of a feature branch will create enforce a cohesive Git history of feature merges. 
A feature branching model is a great tool to promote collaboration within a team environment.
Go one click deeper into Git workflows by reading our comprehensive tutorial of the <a href="/git/tutorials/comparing-workflows/gitflow-workflow" data-event="clicked" data-uuid="23a79267-e4" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Gitflow Workflow.</a>
<h2><br><span class="orange">Gitflow Workflow</span></h2>
Gitflow is a legacy Git workflow that was originally a disruptive and novel strategy for managing Git branches. 
Gitflow has fallen in popularity in favor of <a href="/continuous-delivery/continuous-integration/trunk-based-development" data-event="clicked" data-uuid="67fb4adb-7b" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">trunk-based workflows</a>, which are now considered best practices for modern continuous software development and <a href="/devops/what-is-devops" data-event="clicked" data-uuid="67fb4adb-7b" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">DevOps</a> practices. 
Gitflow also can be challenging to use with <a href="/continuous-delivery" data-event="clicked" data-uuid="67fb4adb-7b" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">CI/CD</a>. 
This post details Gitflow for historical purposes.
<h2><span class="saddlebrown">&emsp;What is Gitflow?</span></h2>
Giflow is an alternative Git branching model that involves the use of feature branches and multiple primary branches. 
It was first published and made popular by <a href="http://nvie.com/posts/a-successful-git-branching-model/" data-event="clicked" data-uuid="e10b8224-ac" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Vincent Driessen at nvie</a>. 
Compared to trunk-based development, Giflow has numerous, longer-lived branches and larger commits. 

Under this model, developers create a feature branch and delay merging it to the main trunk branch until the feature is complete. 
These long-lived feature branches require more collaboration to merge and have a higher risk of deviating from the trunk branch. 
They can also introduce conflicting updates.
Gitflow can be used for projects that have a scheduled release cycle and for the <a href="/devops/what-is-devops/devops-best-practices" data-event="clicked" data-uuid="e10b8224-ac" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">DevOps best practice</a> of <a href="/continuous-delivery" data-event="clicked" data-uuid="e10b8224-ac" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">continuous delivery</a>. 

This workflow doesn’t add any new concepts or commands beyond what’s required for the <a href="/git/tutorials/comparing-workflows/feature-branch-workflow" data-event="clicked" data-uuid="e10b8224-ac" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Feature Branch Workflow</a>. 
Instead, it assigns very specific roles to different branches and defines how and when they should interact. 
In addition to <code>feature</code> branches, it uses individual branches for preparing, maintaining, and recording releases. 
Of course, you also get to leverage all the benefits of the Feature Branch Workflow: pull requests, isolated experiments, and more efficient collaboration.
<h2><span class="saddlebrown">&emsp;Getting Started</span></h2>
Gitflow is really just an abstract idea of a Git workflow. 
This means it dictates what kind of branches to set up and how to merge them together. 
We will touch on the purposes of the branches below. 

The git-flow toolset is an actual command line tool that has an installation process. 
The installation process for git-flow is straightforward. 
Packages for git-flow are available on multiple operating systems. 
On OSX systems, you can execute <code>brew install git-flow</code>. 

On windows you will need to <a href="https://git-scm.com/download/win" data-event="clicked" data-uuid="c8c2cf44-6c" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">download and install git-flow</a>. 
After installing git-flow you can use it in your project by executing <code>git flow init</code>. 
Git-flow is a wrapper around Git. 
The <code>git flow init</code> command is an extension of the default <code><a href="/git/tutorials/setting-up-a-repository/git-init" data-event="clicked" data-uuid="c8c2cf44-6c" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git init</a></code> command and doesn't change anything in your repository other than creating branches for you.
<h2><span class="saddlebrown">&emsp;How it works</span></h2>
<img src="https://wac-cdn.atlassian.com/dam/jcr:a13c18d6-94f3-4fc4-84fb-2b8f1b2fd339/01%20How%20it%20works.svg?cdnVersion=217" loading="lazy" alt="Git flow workflow - Historical Branches"><h3>&emsp;Develop and main branches</h3>
Instead of a single <code>main</code> branch, this workflow uses two branches to record the history of the project. 
The <code>main</code> branch stores the official release history, and the <code>develop</code> branch serves as an integration branch for features. 

It's also convenient to tag all commits in the <code>main</code> branch with a version number.
The first step is to complement the default <code>main</code> with a <code>develop</code> branch. 
A simple way to do this is for one developer to create an empty <code>develop</code> branch locally and push it to the server:
<code>git branch develop

git push -u origin develop</code>
This branch will contain the complete history of the project, whereas <code>main</code> will contain an abridged version. 
Other developers should now clone the central repository and create a tracking branch for <code>develop.</code>
When using the git-flow extension library, executing <code>git flow init</code> on an existing repo will create the <code>develop</code> branch:

<code>$ git flow init
Initialized empty Git repository in ~/project/.git/
No branches exist yet. 
Base branches must be created now.

Branch name for production releases: [main]
Branch name for "next release" development: [develop]
How to name your supporting branch prefixes?
Feature branches? [feature/]

Release branches? [release/]
Hotfix branches? [hotfix/]
Support branches? [support/]
Version tag prefix? []

$ git branch
* develop
main</code>
<h2><span class="saddlebrown">&emsp;Feature branches</span></h2>
Each new feature should reside in its own branch, which can be <a href="/git/tutorials/syncing/git-push" data-event="clicked" data-uuid="e941cce9-03" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">pushed to the central repository</a> for backup/collaboration. 
But, instead of branching off of <code>main</code>, <code>feature</code> branches use <code>develop</code> as their parent branch. 
When a feature is complete, it gets <a href="/git/tutorials/using-branches/git-merge" data-event="clicked" data-uuid="e941cce9-03" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">merged back into develop</a>. 
Features should never interact directly with <code>main</code>.

<img src="https://wac-cdn.atlassian.com/dam/jcr:34c86360-8dea-4be4-92f7-6597d4d5bfae/02%20Feature%20branches.svg?cdnVersion=217" loading="lazy" alt="Git flow workflow - Feature Branches">Note that <code>feature</code> branches combined with the <code>develop</code> branch is, for all intents and purposes, the Feature Branch Workflow. 
But, the Gitflow workflow doesn’t stop there.
<code>Feature</code> branches are generally created off to the latest <code>develop</code> branch.
<h3>&emsp;Creating a feature branch</h3>

Without the git-flow extensions:
<code>git checkout develop
git checkout -b feature_branch</code>
When using the git-flow extension:

<code>git flow feature start feature_branch</code>
Continue your work and use Git like you normally would.
<h3>&emsp;Finishing a feature branch</h3>
When you’re done with the development work on the feature, the next step is to merge the <code>feature_branch</code> into <code>develop</code>.

Without the git-flow extensions:
<code>git checkout develop
git merge feature_branch</code>
Using the git-flow extensions:

<code>git flow feature finish feature_branch</code>
<h2><span class="saddlebrown">&emsp;Release branches</span></h2>
<img src="https://wac-cdn.atlassian.com/dam/jcr:8f00f1a4-ef2d-498a-a2c6-8020bb97902f/03%20Release%20branches.svg?cdnVersion=217" loading="lazy" alt="Git Flow Workflow - Release Branches">Once <code>develop</code> has acquired enough features for a release (or a predetermined release date is approaching), you fork a <code>release</code> branch off of <code>develop</code>. 
Creating this branch starts the next release cycle, so no new features can be added after this point—only bug fixes, documentation generation, and other release-oriented tasks should go in this branch. 

Once it's ready to ship, the <code>release</code> branch gets merged into <code>main</code> and tagged with a version number. 
In addition, it should be merged back into <code>develop</code>, which may have progressed since the release was initiated.
Using a dedicated branch to prepare releases makes it possible for one team to polish the current release while another team continues working on features for the next release. 
It also creates well-defined phases of development (e.g., it's easy to say, “This week we're preparing for version 4.0,” and to actually see it in the structure of the repository).

Making <code>release</code> branches is another straightforward branching operation. 
Like <code>feature</code> branches, <code>release</code> branches are based on the <code>develop</code> branch. 
A new <code>release</code> branch can be created using the following methods.
Without the git-flow extensions:

<code>git checkout develop
git checkout -b release/0.1.0</code>
When using the git-flow extensions:
<code>$ git flow release start 0.1.0

Switched to a new branch 'release/0.1.0'</code>
Once the release is ready to ship, it will get merged it into <code>main</code> and <code>develop</code>, then the <code>release</code> branch will be deleted. 
It’s important to merge back into <code>develop</code> because critical updates may have been added to the <code>release</code> branch and they need to be accessible to new features. 
If your organization stresses code review, this would be an ideal place for a pull request.

To finish a <code>release</code> branch, use the following methods:
Without the git-flow extensions:
<code>git checkout main
git merge release/0.1.0</code>

Or with the git-flow extension:
<code>git flow release finish '0.1.0'</code>
<h2><span class="saddlebrown">&emsp;Hotfix branches</span></h2>
<img src="https://wac-cdn.atlassian.com/dam/jcr:cc0b526e-adb7-4d45-874e-9bcea9898b4a/04%20Hotfix%20branches.svg?cdnVersion=217" loading="lazy" alt="Git flow workflow - Hotfix Branches">Maintenance or <code>“hotfix”</code> branches are used to quickly patch production releases. 

<code>Hotfix</code> branches are a lot like <code>release</code> branches and <code>feature</code> branches except they're based on <code>main</code> instead of <code>develop</code>. 
This is the only branch that should fork directly off of <code>main</code>. 
As soon as the fix is complete, it should be merged into both <code>main</code> and <code>develop</code> (or the current <code>release</code> branch), and <code>main</code> should be tagged with an updated version number.
Having a dedicated line of development for bug fixes lets your team address issues without interrupting the rest of the workflow or waiting for the next release cycle. 

You can think of maintenance branches as ad hoc <code>release</code> branches that work directly with <code>main</code>. 
A <code>hotfix</code> branch can be created using the following methods:
Without the git-flow extensions:
<code>git checkout main

git checkout -b hotfix_branch</code>
When using the git-flow extensions: 
<code>$ git flow hotfix start hotfix_branch</code>
Similar to finishing a <code>release</code> branch, a <code>hotfix</code> branch gets merged into both <code>main</code> and <code>develop.</code>

<code>git checkout main
git merge hotfix_branch
git checkout develop
git merge hotfix_branch

git branch -D hotfix_branch</code>
<code>$ git flow hotfix finish hotfix_branch</code>
<h2><span class="saddlebrown">&emsp;Example</span></h2>
A complete example demonstrating a Feature Branch Flow is as follows. 

Assuming we have a repo setup with a <code>main</code> branch.
<code class="git">git checkout main
git checkout -b develop
git checkout -b feature_branch

# work happens on feature branch
git checkout develop
git merge feature_branch
git checkout main

git merge develop
git branch -d feature_branch</code>
In addition to the <code>feature</code> and <code>release</code> flow, a <code>hotfix</code> example is as follows:
<code>git checkout main

git checkout -b hotfix_branch
# work is done commits are added to the hotfix_branch
git checkout develop
git merge hotfix_branch

git checkout main
git merge hotfix_branch</code>
<h2><span class="saddlebrown">&emsp;Summary</span></h2>
Here we discussed the Gitflow Workflow. 

Gitflow is one of many styles of <a href="/git/tutorials/comparing-workflows" data-event="clicked" data-uuid="eb876823-60" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Git workflows</a> you and your team can utilize.
Some key takeaways to know about Gitflow are:
The workflow is great for a release-based software workflow.
Gitflow offers a dedicated channel for hotfixes to production.

The overall flow of Gitflow is:
A <code>develop</code> branch is created from <code>main</code>
A <code>release</code> branch is created from <code>develop</code>
<code>Feature</code> branches are created from <code>develop</code>

When a <code>feature</code> is complete it is merged into the <code>develop</code> branch
When the <code>release</code> branch is done it is merged into <code>develop</code> and <code>main</code>
If an issue in <code>main</code> is detected a <code>hotfix</code> branch is created from <code>main</code>
Once the <code>hotfix</code> is complete it is merged to both <code>develop</code> and <code>main</code>

Next, learn about the <a href="/git/tutorials/comparing-workflows/forking-workflow" data-event="clicked" data-uuid="475cc6d9-e6" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Forking Workflow</a> or visit our <a href="/git/tutorials/comparing-workflows" data-event="clicked" data-uuid="475cc6d9-e6" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">workflow comparison page</a>.
<h2><br><span class="orange">Forking Workflow</span></h2>
The Forking Workflow is fundamentally different than other popular Git workflows. 
Instead of using a single server-side repository to act as the “central” codebase, it gives every developer their own server-side repository. 

This means that each contributor has not one, but two Git repositories: a private local one and a public server-side one. 
The Forking Workflow is most often seen in public open source projects.
The main advantage of the Forking Workflow is that contributions can be integrated without the need for everybody to push to a single central repository. 
Developers push to their own server-side repositories, and only the project maintainer can push to the official repository. 

This allows the maintainer to accept commits from any developer without giving them write access to the official codebase.
The Forking Workflow typically follows a branching model based on the <a href="/git/tutorials/comparing-workflows/gitflow-workflow" data-event="clicked" data-uuid="cafe4607-26" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Gitflow Workflow</a>. 
This means that complete feature branches will be purposed for merge into the original project maintainer's repository. 
The result is a distributed workflow that provides a flexible way for large, organic teams (including untrusted third-parties) to collaborate securely. 

This also makes it an ideal workflow for open source projects.
<h2><span class="saddlebrown">&emsp;How it works</span></h2>
As in the other <a href="/git/tutorials/comparing-workflows" data-event="clicked" data-uuid="08ba4228-fa" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Git workflows</a>, the Forking Workflow begins with an official public repository stored on a server. 
But when a new developer wants to start working on the project, they do not directly clone the official repository.

Instead, they fork the official repository to create a copy of it on the server. 
This new copy serves as their personal public repository—no other developers are allowed to push to it, but they can pull changes from it (we’ll see why this is important in a moment). 
After they have created their server-side copy, the developer performs a <code><a href="/git/tutorials/setting-up-a-repository/git-clone" data-event="clicked" data-uuid="8cf4f401-14" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git clone</a></code> to get a copy of it onto their local machine. 
This serves as their private development environment, just like in the other workflows.

When they're ready to publish a local commit, they push the commit to their own public repository—not the official one. 
Then, they file a pull request with the main repository, which lets the project maintainer know that an update is ready to be integrated. 
The pull request also serves as a convenient discussion thread if there are issues with the contributed code. 
The following is a step-by-step example of this workflow.

A developer 'forks' an 'official' server-side repository. 
This creates their own server-side copy.
The new server-side copy is cloned to their local system.
A Git remote path for the 'official' repository is added to the local clone.

A new local feature branch is created.
The developer makes changes on the new branch.
New commits are created for the changes.
The branch gets pushed to the developer's own server-side copy.

The developer opens a pull request from the new branch to the 'official' repository.
The pull request gets approved for merge and is merged into the original server-side repository
To integrate the feature into the official codebase, the maintainer pulls the contributor’s changes into their local repository, checks to make sure it doesn’t break the project, merges it into their local <code>main</code> branch, then pushes the <code>main</code> branch to the official repository on the server. 
The contribution is now part of the project, and other developers should pull from the official repository to synchronize their local repositories.

It’s important to understand that the notion of an “official” repository in the Forking Workflow is merely a convention. 
In fact, the only thing that makes the official repository so official is that it’s the public repository of the project maintainer.
<h2><span class="saddlebrown">&emsp;Forking vs cloning</span></h2>
It's important to note that "forked" repositories and "forking" are not special operations. 

Forked repositories are created using the standard <code><a href="/git/tutorials/setting-up-a-repository/git-clone" data-event="clicked" data-uuid="485683ae-e3" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git clone</a></code> command. 
Forked repositories are generally "server-side clones" and usually managed and hosted by a 3rd party Git service like <a href="https://bitbucket.org/product" data-event="clicked" data-uuid="485683ae-e3" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Bitbucket</a>. 
There is no unique Git command to create forked repositories. 
A clone operation is essentially a copy of a repository and its history. 
<h2><span class="saddlebrown">&emsp;Branching in the Forking Workflow</span></h2>
All of these personal public repositories are really just a convenient way to share branches with other developers. 
Everybody should still be using branches to isolate individual features, just like in the <a href="/git/tutorials/comparing-workflows/feature-branch-workflow" data-event="clicked" data-uuid="89234bff-10" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Feature Branch Workflow</a> and the <a href="/git/tutorials/comparing-workflows/gitflow-workflow" data-event="clicked" data-uuid="89234bff-10" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Gitflow Workflow.</a> The only difference is how those branches get shared. 
In the Forking Workflow, they are pulled into another developer’s local repository, while in the Feature Branch and Gitflow Workflows they are pushed to the official repository.
<h2><span class="saddlebrown">&emsp;Fork a repository</span></h2>
<img src="https://wac-cdn.atlassian.com/dam/jcr:642c56e3-ddc6-43ff-ab86-c5cd845afd05/03.svg?cdnVersion=217" loading="lazy" alt="git fork workflow - fork a repositiory">All new developers to a Forking Workflow project need to fork the official repository. 
As previously stated, forking is just a standard <code>git clone</code> operation. 
It’s possible to do this by SSH’ing into the server and running <code>git clone</code> to copy it to another location on the server. 

Popular Git hosting services like Bitbucket, offer repo forking features that automate this step.
<h2><span class="saddlebrown">&emsp;Clone your fork</span></h2>
Next each developer needs to clone their own public forked repository. 
They can do this with the familiar <code>git clone</code> command.

Assuming the use of Bitbucket to host these repositories, developers on a project should have their own Bitbucket account and they should clone their forked copy of the repository with:
<code>git clone https://user@bitbucket.org/user/repo.git</code>
<h2><span class="saddlebrown">&emsp;Adding a remote</span></h2>
Whereas other Git workflows use a single origin remote that points to the central repository, the Forking Workflow requires two remotes—one for the official repository, and one for the developer’s personal server-side repository. 

While you can call these remotes anything you want, a common convention is to use origin as the remote for your forked repository (this will be created automatically when you run <code>git clone</code>) and upstream for the official repository.
<code>git remote add upstream https://bitbucket.org/maintainer/repo</code>
You’ll need to create the upstream remote yourself using the above command. 
This will let you easily keep your local repository up-to-date as the official project progresses. 

Note that if your upstream repository has authentication enabled (i.e., it's not open source), you'll need to supply a username, like so:
<code>git remote add upstream https://user@bitbucket.org/maintainer/repo.git</code>
This requires users to supply a valid password before cloning or pulling from the official codebase.
<h2><span class="saddlebrown">&emsp;Working in a branch: making &amp; pushing changes</span></h2>
In the developer's local copy of the forked repository they can edit code, commit changes, and create branches just like in other Git workflows:
<code>git checkout -b some-feature # Edit some code git commit -a -m "Add first draft of some feature"</code>
All of their changes will be entirely private until they push it to their public repository. 
And, if the official project has moved forward, they can access new commits with <code>git pull</code>:

<code>git pull upstream main</code>
Since developers should be working in a dedicated feature branch, this should generally result in a fast-forward merge.
<h2><span class="saddlebrown">&emsp;Making a Pull Request</span></h2>
<img src="https://wac-cdn.atlassian.com/dam/jcr:0de71551-5c08-4fc4-ab6d-dc8a51bfcc5a/05.svg?cdnVersion=217" loading="lazy" alt="Git Fork Workflow - Making a pull request">Once a developer is ready to share their new feature, they need to do two things. 

First, they have to make their contribution accessible to other developers by pushing it to their public repository. 
Their origin remote should already be set up, so all they should have to do is the following:
<code>git push origin feature-branch</code>
This diverges from the other workflows in that the origin remote points to the developer’s personal server-side repository, not the main codebase.

Second, they need to notify the project maintainer that they want to merge their feature into the official codebase. 
Bitbucket provides a “pull request” button that leads to a form asking you to specify which branch you want to merge into the official repository. 
Typically, you’ll want to integrate your <code>feature</code> branch into the upstream remote’s <code>main</code> branch.
<h2><span class="saddlebrown">&emsp;Summary</span></h2>
To recap, the Forking Workflow is commonly used in public open-source projects. 
Forking is a <code>git clone</code> operation executed on a server copy of a projects repo. 
A Forking Workflow is often used in conjunction with a Git hosting service like Bitbucket. 
A high-level example of a Forking Workflow is:

You want to contribute to an open source library hosted at bitbucket.org/userA/open-project
Using Bitbucket you create a fork of the repo to bitbucket.org/YourName/open-project
On your local system you execute <code>git clone</code> on https://bitbucket.org/YourName/open-project to get a local copy of the repo
You create a new <code>feature</code> branch in your local repo

Work is done to complete the new feature and <code>git commit</code> is executed to save the changes
You then push the new <code>feature</code> branch to your remote forked repo
Using Bitbucket you open up a pull request for the new branch against the original repo at bitbucket.org/userA/open-project
The Forking Workflow helps a maintainer of a project open up the repository to contributions from any developer without having to manually manage authorization settings for each individual contributor. 

This gives the maintainer more of a "pull" style workflow. 
Most commonly used in open-source projects, the Forking Workflow can also be applied to private business workflows to give more authoritative control over what is merged into a release. 
This can be useful in teams that have Deploy Managers or strict release cycles.
Unsure what workflow is right for you? Check out our comprehensive <a href="/git/tutorials/comparing-workflows" data-event="clicked" data-uuid="d7f002a9-9b" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Git workflow comparison page.</a>

<h2><br><span class="orange">SVN to Git - prepping for the migration</span></h2>
In <a href="/git/tutorials/why-git" data-event="clicked" data-uuid="17b8dea5-b1" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Why Git?</a>, we discussed the many ways that Git can help your team become more agile. 
Once you’ve decided to make the switch, your next step is to figure out how to migrate your existing development workflow to Git.
This article explains some of the biggest changes you’ll encounter while transitioning your team from SVN to Git. 

The most important thing to remember during the migration process is that Git is not SVN. 
To realize the full potential of Git, try your best to open up to new ways of thinking about version control.
<h2><span class="saddlebrown">&emsp;For administrators</span></h2>
Adopting Git can take anywhere from a few days to several months depending on the size of your team. 

This section addresses some of the main concerns for engineering managers when it comes to training employees on Git and migrating repositories from SVN to Git.
<h2><span class="saddlebrown">&emsp;Basic Git commands</span></h2>
Git once had a reputation for a steep learning curve. 
However the Git maintainers have been steadily releasing new improvements like sensible defaults and contextual help messages that have made the on-boarding process a lot more pleasant.

Atlassian offers a comprehensive series of self-paced <a href="/git/tutorials" data-event="clicked" data-uuid="d79b14f9-01" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Git tutorials</a>, as well as webinars and live training sessions. 
Together, these should provide all the training options your team needs to get started with Git. 
To get you started, here are a list of some basic Git commands to get you going with Git:
<table>

<thead><tr>
<th>Git task</th> <th>Notes</th> <th>Git commands</th> </tr></thead>
<thead>
<tr>

<td><a href="/git/tutorials/setting-up-a-repository/git-config" data-event="clicked" data-uuid="29a4c69c-4a" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Tell Git who you are</a></td> <td>Configure the author name and email address to be used with your commits.Note that Git strips some characters (for example trailing periods) from user.name.</td> <td>git config --global user.name "Sam Smith"
git config --global user.email sam@example.com</td> </tr>
<tr>
<td><a href="/git/tutorials/setting-up-a-repository/git-init" data-event="clicked" data-uuid="29a4c69c-4a" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Create a new local repository</a></td> <td> </td> <td>git init</td> </tr>

<tr>
<td><a href="/git/tutorials/setting-up-a-repository" data-event="clicked" data-uuid="29a4c69c-4a" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Check out a repository</a></td> <td>Create a working copy of a local repository:</td> <td>git clone /path/to/repository</td> </tr>
<tr>
<td> </td> <td>For a remote server, use:</td> <td>git clone username@host:/path/to/repository</td> </tr>

<tr>
<td><a href="/git/tutorials/saving-changes" data-event="clicked" data-uuid="29a4c69c-4a" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Add files</a></td> <td>Add one or more files to staging (index):</td> <td>git add <filename>git add *</filename>
</td> </tr>
<tr>

<td><a href="/git/tutorials/saving-changes/git-commit" data-event="clicked" data-uuid="29a4c69c-4a" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Commit</a></td> <td>Commit changes to head (but not yet to the remote repository):</td> <td>git commit -m "Commit message"</td> </tr>
<tr>
<td> </td> <td>Commit any files you've added with git add, and also commit any files you've changed since then:</td> <td>git commit -a</td> </tr>
<tr>

<td><a href="/git/tutorials/syncing/git-push" data-event="clicked" data-uuid="29a4c69c-4a" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Push</a></td> <td>Send changes to the main branch of your remote repository:</td> <td>git push origin main</td> </tr>
<tr>
<td><a href="/git/tutorials/inspecting-a-repository" data-event="clicked" data-uuid="29a4c69c-4a" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Status</a></td> <td>List the files you've changed and those you still need to add or commit:</td> <td>git status</td> </tr>
<tr>

<td><a href="/git/tutorials/syncing" data-event="clicked" data-uuid="29a4c69c-4a" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Connect to a remote repository</a></td> <td>If you haven't connected your local repository to a remote server, add the server to be able to push to it:</td> <td>git remote add origin <server></server>
</td> </tr>
<tr>
<td> </td> <td>List all currently configured remote repositories:</td> <td>git remote -v</td> </tr>

<tr>
<td><a href="/git/tutorials/using-branches" data-event="clicked" data-uuid="29a4c69c-4a" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Branches</a></td> <td>Create a new branch and switch to it:</td> <td>git checkout -b <branchname></branchname>
</td> </tr>
<tr>

<td> </td> <td>Switch from one branch to another:</td> <td>git checkout <branchname></branchname>
</td> </tr>
<tr>
<td> </td> <td>List all the branches in your repo, and also tell you what branch you're currently in:</td> <td>git branch</td> </tr>

<tr>
<td> </td> <td>Delete the feature branch:</td> <td>git branch -d <branchname></branchname>
</td> </tr>
<tr>

<td> </td> <td>Push the branch to your remote repository, so others can use it:</td> <td>git push origin <branchname></branchname>
</td> </tr>
<tr>
<td> </td> <td>Push all branches to your remote repository:</td> <td>git push --all origin</td> </tr>

<tr>
<td> </td> <td>Delete a branch on your remote repository:</td> <td>git push origin :<branchname></branchname>
</td> </tr>
<tr>

<td><a href="/git/tutorials/syncing/git-pull" data-event="clicked" data-uuid="29a4c69c-4a" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Update from the remote repository</a></td> <td>Fetch and merge changes on the remote server to your working directory:</td> <td>git pull</td> </tr>
<tr>
<td> </td> <td>To merge a different branch into your active branch:</td> <td>git merge <branchname></branchname>
</td> </tr>

<tr>
<td> </td> <td>View all the merge conflicts:View the conflicts against the base file:Preview changes, before merging:</td> <td>git diff
git diff --base <filename>
git diff <sourcebranch><targetbranch></targetbranch></sourcebranch></filename>

</td> </tr>
<tr>
<td> </td> <td>After you have manually resolved any conflicts, you mark the changed file:</td> <td>git add <filename></filename>
</td> </tr>

<tr>
<td>Tags</td> <td>You can use tagging to mark a significant changeset, such as a release:</td> <td>git tag 1.0.0 <commitid></commitid>
</td> </tr>
<tr>

<td> </td> <td>CommitId is the leading characters of the changeset ID, up to 10, but must be unique. 
Get the ID using:</td> <td>git log</td> </tr>
<tr>
<td> </td> <td>Push all tags to remote repository:</td> <td>git push --tags origin</td> </tr>

<tr>
<td><a href="/git/tutorials/undoing-changes" data-event="clicked" data-uuid="29a4c69c-4a" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Undo local changes</a></td> <td>If you mess up, you can replace the changes in your working tree with the last content in head:Changes already added to the index, as well as new files, will be kept.</td> <td>git checkout -- <filename></filename>
</td> </tr>
<tr>

<td> </td> <td>Instead, to drop all your local changes and commits, fetch the latest history from the server and point your local main branch at it, do this:</td> <td>git fetch origin
git reset --hard origin/main</td> </tr>
<tr>
<td>Search</td> <td>Search the working directory for foo():</td> <td>git grep "foo()"</td> </tr>

</thead>
</table>
<h2><span class="saddlebrown">&emsp;Git Migration Tools</span></h2>
There’s a number of tools available to help you migrate your existing projects from SVN to Git, but before you decide what tools to use, you need to figure out how you want to migrate your code. 

Your options are:
Migrate your entire codebase to Git and stop using SVN altogether.
Don’t migrate any existing projects to Git, but use Git for all new projects.
Migrate some of your projects to Git while continuing to use SVN for other projects.

Use SVN and Git simultaneously on the same projects.
A complete transition to Git limits the complexity in your development workflow, so this is the preferred option. 
However, this isn’t always possible in larger companies with dozens of development teams and potentially hundreds of projects. 
In these situations, a hybrid approach is a safer option.

Your choice of migration tool(s) depends largely on which of the above strategies you choose. 
Some of the most common SVN-to-Git migration tools are introduced below.
<h3>&emsp;Atlassian’s migration scripts</h3>
If you’re interested in making an abrupt transition to Git, Atlassian’s migration scripts are a good choice for you. 

These scripts provide all the tools you need to reliably convert your existing SVN repositories to Git repositories. 
The resulting native-Git history ensures you won’t need to deal with any SVN-to-Git interoperability issues after the conversion process.
We’ve provided a complete <a href="/git/tutorials/migrating-overview" data-event="clicked" data-uuid="7eab4959-6b" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">technical walkthrough</a> for using these scripts to convert your entire codebase to a collection of Git repositories. 
This walkthrough explains everything from extracting SVN author information to re-organizing non-standard SVN repository structures.

<h3>&emsp;SVN Mirror for Stash (now Bitbucket) plugin</h3>
<a href="https://marketplace.atlassian.com/plugins/org.tmatesoft.subgit.stash-svn-importer" data-event="clicked" data-uuid="89dceab3-61" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket" title="SVN Mirror for Stash">SVN Mirror for Stash</a> is a <a href="https://bitbucket.org/product/enterprise" data-event="clicked" data-uuid="89dceab3-61" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Bitbucket</a> plugin that lets you easily maintain a hybrid codebase that works with both SVN and Git. 
Unlike Atlassian’s migration scripts, SVN Mirror for Stash lets you use Git and SVN simultaneously on the same project for as long as you like.
This compromise solution is a great option for larger companies. 

It enables incremental Git adoption by letting different teams migrate workflows at their convenience.
<h3>&emsp;What is Git-SVN?</h3>
The git-svn tool is an interface between a local Git repository and a remote SVN repository. 
Git-svn lets developers write code and create commits locally with Git, then push them up to a central SVN repository with svn commit-style behavior. 

This should be temporary, but is helpful when debating making the switch from SVN to Git. 
git svn is a good option if you’re not sure about making the switch to Git and want to let some of your developers explore Git commands without committing to a full-on migration. 
It’s also perfect for the training phase—instead of an abrupt transition, your team can ease into it with local Git commands before worrying about collaboration workflows.
Note that git svn should only be a temporary phase of your migration process. 

Since it still depends on SVN for the “backend,” it can’t leverage the more powerful Git features like branching or advanced collaboration workflows.
<h3>&emsp;Rollout Strategies</h3>
Migrating your codebase is only one aspect of adopting Git. 
You also need to consider how to introduce Git to the people behind that codebase. 

External consultants, internal Git champions, and pilots teams are the three main strategies for moving your development team over to Git.
<h3>&emsp;External Git Consultants</h3>
Git consultants can essentially handle the migration process for you for a nominal fee. 
This has the advantage of creating a Git workflow that’s perfectly suited to your team without investing the time to figure it out on your own. 

It also makes expert training resources available to you while your team is learning Git. 
<a href="https://www.atlassian.com/experts/?tab=find-an-expert&amp;expertskills=SVNtoGitmigration&amp;products=*&amp;expertlocation=" data-event="clicked" data-uuid="b471fb9b-20" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket" title="Atlassian Experts">Atlassian Experts</a> are pros when it comes to SVN to Git migration and are a good resource for sourcing a Git consultant.
On the other hand, designing and implementing a Git workflow on your own is a great way for your team to understand the inner workings of their new development process. 
This avoids the risk of your team being left in the dark when your consultant leaves.

<h3>&emsp;Internal Git Champions</h3>
A Git champion is a developer inside of your company who’s excited to start using Git. 
Leveraging a Git champion is a good option for companies with a strong developer culture and eager programmers comfortable being early adopters. 
The idea is to enable one of your engineers to become a Git expert so they can design a Git workflow tailored to your company and serve as an internal consultant when it’s time to transition the rest of the team to Git.

Compared to an external consultant, this has the advantage of keeping your Git expertise in-house. 
However, it requires a larger time investment to train that Git champion, and it runs the risk of choosing the wrong Git workflow or implementing it incorrectly.
<h3>&emsp;Pilot Teams</h3>
The third option for transitioning to Git is to test it out on a pilot team. 

This works best if you have a small team working on a relatively isolated project. 
This could work even better by combining external consultants with internal Git champions in the pilot team for a winning combo. 
This has the advantage of requiring buy-in from your entire team, and also limits the risk of choosing the wrong workflow, since it gets input from the entire team while designing the new development process. 
In other words, it ensures any missing pieces are caught sooner than when a consultant or champion designs the new workflow on their own.

On the other hand, using a pilot team means more initial training and setup time: instead of one developer figuring out a new workflow, there’s a whole team that could potentially be temporarily less productive while they’re getting comfortable with their new workflow. 
However, this short term pain is absolutely worth the long term gain.
<h3>&emsp;Security and Permissions</h3>
Access control is an aspect of Git where you need to fundamentally re-think how you manage your codebase.

In SVN, you typically store your entire codebase in a single central repository, then limit access to different teams or individuals by folder. 
In Git, this is not possible: developers must retrieve the entire repository to work with it. 
You typically can not retrieve a subset of the repository, as you can with SVN. 
permissions can only be granted to entire Git repositories.

This means you have to split up your large, monolithic SVN repository into several small Git repositories. 
We actually experienced this first hand here at Atlassian when our <a href="/software/jira" data-event="clicked" data-uuid="47eda68f-e4" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Jira</a> development team migrated to Git. 
All of our Jira plugins used to be stored in a single SVN repository, but after the migration, each plugin ended up in its own repository.
Keep in mind that Git was designed to securely integrate code contributions from thousands of independent Linux developers, so it definitely provides some way to set up whatever kind of access control your team needs. 

This may, however, require a fresh look at your build cycle.
If you’re concerned about maintaining dependencies between your new collection of Git repositories, you may find a dependency management layer on top of Git helpful. 
A dependency management layer will help with build times because as a project grows, you need “caching” in order to speed up your build time. 
A list of recommended dependency management layer tools for every technology stack can be found in this helpful article: <a href="http://blogs.atlassian.com/2014/04/git-project-dependencies/" data-event="clicked" data-uuid="cdfc1eb7-92" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket" title="Git and project dependencies">"Git and project dependencies"</a>.
<h2><span class="saddlebrown">&emsp;For developers</span></h2>
<h3>&emsp;A Repository for Every Developer</h3>
As a developer, the biggest change you’ll need to adjust to is the distributed nature of Git. 
Instead of a single central repository, every developer has their own copy of the entire repository. 

This dramatically changes the way you collaborate with your fellow programmers.
Instead of checking out an SVN repository with svn checkout and getting a working copy, you clone the entire Git repository to your local machine with git clone.
Collaboration occurs by moving branches between repositories with either git push, git fetch, or git pull. 
Sharing is commonly done on the branch level in Git but can be done on the commit level, similar to SVN. 

But in Git, a commit represents the entire state of the whole project instead rather than file modifications. 
Since you can use branches in both Git and SVN, the important distinction here is that you can commit locally with Git, without sharing your work. 
This enables you to experiment more freely, work more effectively offline and speeds up almost all version control related commands. 
However, it’s important to understand that a remote repository is not a direct link into somebody else’s repository. 

It’s simply a bookmark that prevents you from having to re-type the full URL each time you interact with a remote repository. 
Until you explicitly pull or push a branch to a remote repository, you’re working in an isolated environment.
The other big adjustment for SVN users is the notion of “local” and “remote” repositories. 
Local repositories are on your local machine, and all other repositories are referred to as remote repositories. 

The main purpose of a remote repository is to make your code accessible to the rest of the team, and thus no active development takes place in them. 
Local repositories reside on your local machine, and it’s where you do all of your software development.
<h3>&emsp;Don’t Be Scared of Branching or Merging</h3>
In SVN, you commit code by editing files in your working copy, then running svn commit to send the code to the central repository. 

Everybody else can then pull those changes into their own working copies with svn update. 
SVN branches are usually reserved for large, long-running aspects of a project because merging is a dangerous procedure that has the potential to break the project.
Git’s basic development workflow is much different. 
Instead of being bound to a single line of development (e.g., trunk/), life revolves around branching and merging.

When you want to start working on anything in Git, you create and check out a new branch with git checkout -b <branch-name>. 
This gives you a dedicated line of development where you can write code without worrying about affecting anyone else on your team. 
If you break something beyond repair, you simply throw the branch away with git branch -d <branch-name>. 
If you build something useful, you file a pull request asking to merge it into the main branch.</branch-name></branch-name>

<h3>&emsp;Potential Git Workflows</h3>
When choosing a Git workflow it is important to consider your team's needs. 
A simple workflow can maximise development speed and flexibility, while a more complex workflow can ensure greater consistency and control of work in progress. 
You can adapt and combine the general approaches listed below to suit your needs and the different roles on your team. 

A core developer might use feature branches while a contractor works from a fork, for example.
A <a href="/git/tutorials/comparing-workflows" data-event="clicked" data-uuid="7b1b0f85-92" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">centralized workflow</a> provides the closest match to common SVN processes, so it's a good option to get started.
Building on that idea, using a <a href="/git/tutorials/comparing-workflows/feature-branch-workflow" data-event="clicked" data-uuid="7b1b0f85-92" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">feature branch workflow</a> lets developers keep their work in progress isolated and important shared branches protected. 
Feature branches also form the basis for managing changes via pull requests.

A <a href="/git/tutorials/comparing-workflows/gitflow-workflow" data-event="clicked" data-uuid="7b1b0f85-92" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Gitflow workflow</a> is a more formal, structured extension to feature branching, making it a great option for larger teams with well-defined release cycles.
Finally, consider a <a href="/git/tutorials/comparing-workflows/forking-workflow" data-event="clicked" data-uuid="7b1b0f85-92" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">forking workflow</a> if you need maximum isolation and control over changes, or have many developers contributing to one repository.
But, if you really want to get the most out of Git as a professional team, you should consider the feature branch workflow. 
This is a truly distributed workflow that is highly secure, incredibly scalable, and quintessentially agile.

<h3>&emsp;Conclusion</h3>
Transitioning your team to Git can be a daunting task, but it doesn’t have to be. 
This article introduced some of the common options for migrating your existing codebase, rolling out Git to your development teams, and dealing with security and permissions. 
We also introduced the biggest challenges that your developers should be prepared for during the migration process.

Hopefully, you now have a solid foundation for introducing distributed development to your company, regardless of its size or current development practices.
<h2><br><span class="orange">Migrate to Git from SVN</span></h2>
We’ve broken down the SVN-to-Git migration process into 5 simple steps:
Prepare your environment for the migration.

Convert the SVN repository to a local Git repository.
Synchronize the local Git repository when the SVN repository changes.
Share the Git repository with your developers via Bitbucket.
Migrate your development efforts from SVN to Git. 

The prepare, convert, and synchronize steps take a SVN commit history and turn it into a Git repository. 
The best way to manage these first 3 steps is to designate one of your team members as the migration lead (if you’re reading this guide, that person is probably you). 
All 3 of these steps should be performed on the migration lead’s local computer.
<img src="https://wac-cdn.atlassian.com/dam/jcr:620e114f-077f-416b-aeb4-ecdb4b6c64c6/01.svg?cdnVersion=217" loading="lazy" alt="Git Migration: Prepare, clone, sync">After the synchronize phase, the migration lead should have no trouble keeping a local Git repository up-to-date with an SVN counterpart. 

To share the Git repository, the migration lead can share their local Git repository with other developers by pushing it to <a href="http://bitbucket.org" data-event="clicked" data-uuid="56e51640-83" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Bitbucket</a>, a Git hosting service.
<img src="https://wac-cdn.atlassian.com/dam/jcr:adce07b0-ef2a-4ab4-b08b-72a02d0a61fb/02.svg?cdnVersion=217" loading="lazy" alt="Git Migration: Share the git repo via bitbucket">Once it’s on Bitbucket, other developers can clone the converted Git repository to their local machines, explore its history with Git commands, and begin integrating it into their build processes. 
However, we advocate a one-way synchronization from SVN to Git until your team is ready to switch to a pure Git workflow. 
This means that everybody should treat their Git repository as read-only and continue committing to the original SVN repository. 

The only changes to the Git repository should happen when the migration lead synchronizes it and pushes the updates to Bitbucket.
This provides a clear-cut transition period where your team can get comfortable with Git without interrupting your existing SVN-based workflow. 
Once you’re confident that your developers are ready to make the switch, the final step in the migration process is to freeze your SVN repository and begin committing with Git instead.
<img src="https://wac-cdn.atlassian.com/dam/jcr:a202d2e1-bb9a-4c25-92ed-91a16a63ccde/03.svg?cdnVersion=217" loading="lazy" alt="Git migration: Migrate Active Development to Git">This switch should be a very natural process, as the entire Git workflow is already in place and your developers have had all the time they need to get comfortable with it. 

By this point, you have successfully migrated your project from SVN to Git.
<h2><br><span class="orange">Prepare</span></h2>
The first step to migrating a project from SVN to Git-based version control is to prepare the migration lead’s local machine. 
In this phase, you’ll download a convenient utility script, mount a case-sensitive filesystem (if necessary), and map author information from SVN to Git.

All of the the following steps should be performed on the migration lead’s local machine.
<h3>&emsp;Download the migration script</h3>
Git comes with most of the necessary tools for importing an SVN repository; however, there are a few missing bits of functionality that Atlassian has rolled into a handy JAR file. 
This file will be integral to the migration, so be sure to download <a href="https://bitbucket.org/atlassian/svn-migration-scripts/downloads" data-event="clicked" data-uuid="ade13b8b-a9" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket"><code>svn-migration-scripts.jar</code></a> from Atlassian’s Bitbucket account. 

This guide assumes that you’ve saved it in your home directory. 
Disclaimer: for the svn migration you need a case-sensitive filesystem and this does not work on NTFS. 
We suggest using this on a Linux machine. 
Once you’ve downloaded it, it’s a good idea to verify the scripts to make sure you have the <a href="http://www.java.com/en/download/help/download_options.xml" data-event="clicked" data-uuid="a9c1d937-3e" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Java Runtime Environment</a>, <a href="http://git-scm.com/downloads" data-event="clicked" data-uuid="a9c1d937-3e" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Git</a>, <a href="http://subversion.apache.org/packages.html" data-event="clicked" data-uuid="a9c1d937-3e" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Subversion</a>, and the <a href="https://www.kernel.org/pub/software/scm/git/docs/git-svn.html" data-event="clicked" data-uuid="a9c1d937-3e" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git-svn</a> utility installed. 

Open a command prompt and run the following:
<code>java -jar ~/svn-migration-scripts.jar verify</code>
This will display an error message in the console if you don’t have the necessary programs for the migration process. 
Make sure that any missing software is installed before moving on.

If you get a warning about being unable to determine a version, run <code>export LANG=C</code> (*nix) or <code>SET LANG=C</code> (Windows) and try again.
If you’re performing the migration on a computer running OS X, you’ll also see the following warning:
<code>You appear to be running on a case-insensitive file-system. 
This is unsupported, and can result in data loss.</code>

We’ll address this in the next section.
<h3>&emsp;Mount a case-sensitive disk image</h3>
Migrating to Git should be done on a case-sensitive file system to avoid corrupting the repository. 
This is a problem if you’re performing the migration on an OS X computer, as the OS X filesystem isn’t case-sensitive.

If you’re not running OS X, all you need to do is create a directory on your local machine called <code>~/GitMigration</code>. 
This is where you will perform the conversion. 
After that, you can skip to the next section.
<img src="https://wac-cdn.atlassian.com/dam/jcr:81ada5cb-b6bd-45c1-bf8e-a50c89f3a821/01.svg?cdnVersion=217" loading="lazy" alt="Git migration: mount disk image">If you are running OS X, you need to mount a case-sensitive disk image with the <code>create-disk-image</code> script included in <code>svn-migration-scripts.jar</code>. 

It takes two parameters:
The size of the disk image to create in gigabytes. 
You can use any size you like, as long as it’s bigger than the SVN repository that you’re trying to migrate.
The name of the disk image. 

This guide uses <code>GitMigration</code> for this value. 
For example, the following command creates a 5GB disk image called <code>GitMigration</code>:
<code>java -jar ~/svn-migration-scripts.jar create-disk-image 5 GitMigration</code>
The disk image is mounted in your home directory, so you should now see a directory called <code>~/GitMigration</code> on your local machine. 

This serves as a virtual case-sensitive filesystem, and it’s where you’ll store the converted Git repository.
<h3>&emsp;Extract the author information</h3>
SVN only records the username of the author for each revision. 
Git, however, stores the full name and email address of the author. 

This means that you need to create a text file that maps SVN usernames to their Git counterparts.
<img src="https://wac-cdn.atlassian.com/dam/jcr:814496ce-fa1e-437c-815e-839ebb0def23/02.svg?cdnVersion=217" loading="lazy" alt="Git migration: Map SVN usernames to Git usernames">Run the following commands to automatically generate this text file:
<code>cd ~/GitMigration java -jar ~/svn-migration-scripts.jar authors <svn-repo> > authors.txt</svn-repo></code>
Be sure to replace <code><svn-repo></svn-repo></code> with the URI of the SVN repository that you want to migrate. 

For example, if your repository resided at <code>https://svn.example.com</code>, you would run the following:
<code>java -jar ~/svn-migration-scripts.jar authors https://svn.example.com > authors.txt</code>
This creates a text file called <code>authors.txt</code> that contains the username of every author in the SVN repository along with a generated name and email address. 
It should look something like this:

<code>j.doe = j.doe <j.doe> m.smith = m.smith <m.smith></m.smith></j.doe></code>
Change the portion to the right of the equal sign to the full name and email address of the corresponding user. 
For example, you might change the above authors to:
<code>j.doe = John Doe <john.doe> m.smith = Mary Smith <mary.smith></mary.smith></john.doe></code>

<h3>&emsp;Summary</h3>
Now that you have your migration scripts, disk image (OS X only), and author information, you’re ready to import your SVN history into a new Git repository. 
The next phase explains how this conversion works.
<h2><br><span class="orange">Convert</span></h2>
The next step in the migration from SVN to Git is to import the contents of the SVN repository into a new Git repository. 
We’ll do this with the <code>git svn</code> utility that is included with most Git distributions, then we’ll clean up the results with <code>svn-migration-scripts.jar</code>.
Beware that the conversion process can take a significant amount of time for larger repositories, even when cloning from a local SVN repository. 
As a benchmark, converting a 400MB repository with 33,000 commits on main took around 12 hours to complete.

For reasonably sized repositories, the following steps should be run on the migration lead’s local computer. 
However, if you have a very large SVN repository and want to cut down on the conversion time, you can run <code>git svn clone</code> on the SVN server instead of on the migration lead’s local machine. 
This will avoid the overhead of cloning via a network connection.
<h3>&emsp;Clone the SVN repository</h3>

The <code>git svn clone</code> command transforms the trunk, branches, and tags in your SVN repository into a new Git repository. 
Depending on the structure of your SVN repo, the command needs to be configured differently.
<img src="https://wac-cdn.atlassian.com/dam/jcr:a88bfe6a-5abc-4791-bff2-3757dd113e5d/01.svg?cdnVersion=217" loading="lazy" alt="Git migration: git svn clone command"><strong>Standard SVN layouts</strong>
If your SVN project uses the standard <code>/trunk</code>, <code>/branches</code>, and <code>/tags</code> directory layout, you can use the <code>--stdlayout</code> option instead of manually specifying the repository’s structure. 

Run the following command in the <code>~/GitMigration</code> directory:
<code>git svn clone --stdlayout --authors-file=authors.txt
&lt;svn-repo>/&lt;project> &lt;git-repo-name></code>
Where <code><svn-repo></svn-repo></code> is the URI of the SVN repository that you want to migrate and,  is the name of the project that you want to import, and <code><git-repo-name></git-repo-name></code> is the directory name of the new Git repository.

For example, if you were migrating a project called <code>Confluence</code>, hosted on <code>https://svn.atlassian.com</code>, you might run the following:
<code>git svn clone --stdlayout --authors-file=authors.txt https://svn.atlassian.com/Confluence ConfluenceAsGit</code>
<strong>Non-standard SVN layouts</strong>
If your SVN repository doesn’t have a standard layout, you need to provide the locations of your trunk, branches, and tags using the <code>--trunk</code>, <code>--branches</code>, and <code>--tags</code> command line options. 

For example, if you have branches stored in both the <code>/branches</code> directory and the <code>/bugfixes</code> directories, you would use the following command:
<code>git svn clone --trunk=/trunk --branches=/branches 
--branches=/bugfixes --tags=/tags --authors-file=authors.txt 
&lt;svn-repo>/&lt;project> &lt;git-repo-name></code>

<h3>&emsp;Inspect the new Git repository</h3>
After <code>git svn clone</code> has finished (this might take a while), you’ll find a new directory called <code>＜git-repo-name＞</code> in <code>~/GitMigration</code>. 
This is the converted Git repository. 
You should be able to switch into <code>＜git-repo-name＞</code> and run any of the standard Git commands to explore your project.

Branches and tags are not imported into the new Git repository as you might expect. 
You won’t find any of your SVN branches in the <code>git branch</code> output, nor will you find any of your SVN tags in the <code>git tag</code> output. 
But, if you run <code>git branch -r</code>, you’ll find all of the branches and tags from your SVN repository. 
The <code>git svn clone</code> command imports your SVN branches as remote branches and imports your SVN tags as remote branches prefixed with <code>tags/</code>.

<img src="https://wac-cdn.atlassian.com/dam/jcr:a5d2c618-2d55-46aa-b2d3-237905744fdf/01-02%20Inspect%20the%20new%20Git%20repository.svg?cdnVersion=217" loading="lazy" alt="Git migration: structure of cloned Git repo">This behavior makes certain two-way synchronization procedures easier, but it can be very confusing when trying to make a one-way migration Git. 
That’s why our next step will be to convert these remote branches to local branches and actual Git tags.
<h3>&emsp;Clean the new Git repository</h3>
The <code>clean-git</code> script included in <code>svn-migration-scripts.jar</code> turns the SVN branches into local Git branches and the SVN tags into full-fledged Git tags. 

Note that this is a <strong>destructive</strong> operation, and you will not be able to move commits from the Git repository back into the SVN repository.
If you’re following this migration guide, this isn’t a problem, as it advocates a one-way sync from SVN to Git (the Git repository is considered read-only until after the <a href="/git/tutorials/migrating-migrate" data-event="clicked" data-uuid="d339237c-a1" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Migrate</a> step). 
However, if you’re planning on committing to the Git repository <em>and</em> the SVN repository during the migration process, you should not perform the following commands. 
This is an advanced task, as is not recommended for the typical project.

To see what can be cleaned up, run the following command in <code>~/GitMigration/<git-repo-name></git-repo-name></code>:
<code>java -Dfile.encoding=utf-8 -jar ~/svn-migration-scripts.jar clean-git</code>
This will output all of the changes the script wants to make, but it won’t actually make any of them. 
To execute these changes, you need to use the <code>--force</code> option, like so:

<code>java -Dfile.encoding=utf-8 -jar ~/svn-migration-scripts.jar clean-git --force</code>
You should now see all of your SVN branches in the <code>git branch</code> output, along with your SVN tags in the <code>git tag</code> output. 
This means that you’ve successfully converted your SVN project to a Git repository.
<h3>&emsp;Summary</h3>

In this step, you turned an SVN repository into a new Git repository with the <code>git svn clone</code> command, then cleaned up the structure of the resulting repository with <code>svn-migration-scripts.jar</code>. 
In the next step, you’ll learn how to keep this new Git repo in sync with any new commits to the SVN repository. 
This will be a similar process to the conversion, but there are some important workflow considerations during this transition period.
<h2><br><span class="orange">Synchronize</span></h2>
It’s very easy to synchronize your Git repository with new commits in the original SVN repository. 
This makes for a comfortable transition period in the migration process where you can continue to use your existing SVN workflow, but begin to experiment with Git.
It’s possible to synchronize in both directions. 
However, we recommend a one-way sync from SVN to Git. 

During your transition period, you should only commit to your SVN repository, not your Git repo. 
Once you’re confident that your team is ready to make the switch, you can complete the migration process and begin to commit changes with Git instead of SVN.
<img src="https://wac-cdn.atlassian.com/dam/jcr:e69120b8-449f-42d8-9192-04f7bd14401a/01.svg?cdnVersion=217" loading="lazy" alt="Git migration: we recommend a one-way sync from SVN to Git.">In the meantime, you should continue to commit to your SVN repository and synchronize your Git repository whenever necessary. 
This process is similar to the <a href="/git/tutorials/migrating-convert" data-event="clicked" data-uuid="4168cddc-e8" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Convert</a> phase, but since you’re only dealing with incremental changes, it should be much more efficient.

<h3>&emsp;Update the authors file</h3>
The <code>authors.txt</code> file that we used to map SVN usernames to full names and email addresses is essential to the synchronization process. 
If it has been moved from the <code>~/GitMigration/authors.txt</code> location that we’ve been using thus far, you need to update its location with:
<code>git config svn.authorsfile </code>

If new developers have committed to the SVN repository since the last sync (or the initial clone), the authors file needs to be updated accordingly. 
You can do this by manually appending new users to <code>authors.txt</code>, or you can use the <code>--authors-prog</code> option, as discussed in the next section.
For one-off synchronizations it’s often easier to directly edit the authors file; however, the-<code>--authors-prog</code> option is preferred if you’re performing unsupervised syncs (i.e. 
in a scheduled task).

<h3>&emsp;Automatically generating Git authors</h3>
If your authors file doesn’t need to be updated, you can skip to the next section.
The <code>git svn</code> command includes an option called <code>--authors-prog</code>, which points to a script that automatically transforms SVN usernames into Git authors. 
You’ll need to configure this script to accept the SVN username as its only argument and return a single line in the form of <code>Name <email></email></code> (just like the right hand side of the existing authors file). 

This option can be very useful if you need to periodically add new developers to your project.
If you want to use the <code>--authors-prog</code> option, create a file called <code>authors.sh</code> option in <code>~/GitMigration</code>. 
Add the following line to <code>authors.sh</code> to return a dummy Git name and email for any authors that aren’t found in <code>authors.txt</code>:
<code>echo "$1 "</code>

Again, this will only generate a dummy name and email based on the SVN username, so feel free to alter it if you can provide a more meaningful mapping.
<h3>&emsp;Fetch the new SVN commits</h3>
Unlike SVN, Git makes a distinction between <em>downloading</em> upstream commits and <em>integrating</em> them into the project. 
The former is called "fetching", while the latter can be done via merging or rebasing. 

In the <code>~/GitMigration</code> directory, run the following command to fetch any new commits from the original SVN repository.
<code>git svn fetch</code>
This is similar to the <code>git svn clone</code> command from the previous phase in that it only updates the Git repository’s remote branches--the local branches will not reflect any of the updates yet. 
Your remote branches, on the other hand, should exactly match your SVN repo’s history.

If you’re using the <code>--authors-prog</code> option, you need include it in the above command, like so:
<code>git svn fetch --authors-prog=authors.sh</code>
<h3>&emsp;Synchronize with the fetched commits</h3>
To apply the downloaded commits to the repository, run the following command:

<code>java -Dfile.encoding=utf-8 -jar ~/svn-migration-scripts.jar sync-rebase</code>
This will rebase the fetched commits onto your local branches so that they match their remote counterparts. 
You should now be able to see the new commits in your <code>git log</code> output.
<h3>&emsp;Clean up the Git repo (again)</h3>

It’s also a good idea to run the <code>git-clean</code> script again to remove any obsolete tags or branches that were deleted from the original SVN repository since the last sync:
<code>java -Dfile.encoding=utf-8 -jar ~/svn-migration-scripts.jar clean-git --force</code>
Your local Git repository should now be synchronized with your SVN repository.
<h3>&emsp;Summary</h3>

During this transition period, it’s very important that your developers only commit to the original SVN repository. 
The only time the Git repository should be updated is via the synchronization process discussed above. 
This is much easier than managing a two-way synchronization workflow, but it still allows you to start integrating Git into your build process.
<h2><br><span class="orange">Share</span></h2>
In SVN, developers share contributions by committing changes from a working copy on their local computer to a central repository. 
Then, other developers pull these updates from the central repo into their own local working copies.
Git’s collaboration workflow is much different. 
Instead of differentiating between working copies and the central repository, Git gives each developer their own local copy of the <em>entire</em> repository. 

Changes are committed to this local repository instead of a central one. 
To share updates with other developers, you need to push these local changes to a public Git repository on a server. 
Then, the other developers can pull your new commits from the public repo into their own local repositories.
<img src="https://wac-cdn.atlassian.com/dam/jcr:7a5136ac-1171-4d2f-839c-9924f287550d/01.svg?cdnVersion=217" loading="lazy" alt="Git migration: Centralized SVN development vs. Distributed Git development">Giving each developer their own complete repository is the heart of distributed version control, and it opens up a wide array of potential workflows. 

You can read more about these workflows from our <a href="/git/tutorials/comparing-workflows" data-event="clicked" data-uuid="6c98b265-c9" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Git Workflows</a> section.
So far, you’ve only been working with a local Git repository. 
This page explains how to push this local repo to a public repository hosted on <a href="http://bitbucket.org" data-event="clicked" data-uuid="0cd3d4e3-51" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Bitbucket</a>. 
Sharing the Git repository during the migration allows your team to experiment with Git commands without affecting their active SVN development. 

Until you’re ready to make the switch, it’s very important to <strong>treat the shared Git repositories as read-only</strong>. 
All development should continue to be committed to the original SVN repository.
<h3>&emsp;Create a Bitbucket account</h3>
If you don’t already have a <a href="http://bitbucket.org" data-event="clicked" data-uuid="708d6072-5c" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Bitbucket</a> account, you’ll need to create one. 

Hosting is free for up to 5 users, so you can start experimenting with new Git workflows right away.
<h3>&emsp;Create a Bitbucket repository</h3>
Next, you’ll need to create a Bitbucket repository. 
Bitbucket makes it very easy to administer your hosted repositories via a web interface. 

All you have to do is click the Create repository button after you’ve logged in.
<img src="https://wac-cdn.atlassian.com/dam/jcr:f3988ab0-bcde-4e68-859d-f1057e1c5e7a/git-migration-bitbucket-create-repository.png?cdnVersion=217" loading="lazy" alt="Git migration: Create repository">In the resulting form, add a name and description for your repository. 
If your project is private, keep the <em>Access level</em> option checked so that only designated developers are allowed to clone it. 
For the <em>Forking</em> field, use <em>Allow only private forks</em>. 

Use <em>Git</em> for the <em>Repository type</em>, select any project management tools you want to use, and select the primary programming language of your project in the <em>Language</em> field.
<img src="https://wac-cdn.atlassian.com/dam/jcr:76a8c7ba-87bc-4d55-8a26-9a4987ad96ce/git-migration-bitbucket-create-repo.png?cdnVersion=217" loading="lazy" alt="Git migration: Create Bitbucket repository">To create the hosted repository, submit the form by clicking the <em>Create repository</em> button. 
After your repository is set up, you’ll see a <em>Next steps</em> page that describes some useful commands for importing an existing project. 
The rest of this page will walk you through those instructions step-by-step.

<h3>&emsp;Add an origin remote</h3>
To make it easier to push commits from your local Git repository to the Bitbucket repository you just created, you should record the Bitbucket repo’s URL in a remote. 
A remote is just a convenient shortcut for a URL. 
Technically, you can use anything you like for the shortcut, but if the remote repository serves as the official codebase for the project, it’s conventionally referred to as <code>origin</code>. 

Run the following in your local Git repository to add your new Bitbucket repository as the <code>origin</code> remote.
<code>git remote add origin https://<user>@bitbucket.org/<user>/<repo>.git</repo></user></user></code>
Be sure to change <code><user></user></code> to your Bitbucket username and <code><repo></repo></code> to the name of the Bitbucket repository. 
You should also be able to copy and paste the complete URL from the Bitbucket web interface.

<img src="https://wac-cdn.atlassian.com/dam/jcr:7f3b235f-0d18-4bcc-bb30-981b051d8288/02.svg?cdnVersion=217" loading="lazy" alt="GIt migration: Add an origin remote">After running the above command, you can use <code>origin</code> in other Git commands to refer to your Bitbucket repository.
<h3>&emsp;Push the local repository to Bitbucket</h3>
Next, you need to populate your Bitbucket repository with the contents of your local Git repository. 
This is called “pushing,” and can be accomplished with the following command:

<code>git push -u origin --all</code>
The <code>-u</code> option tells Git to track the upstream branches. 
This enables Git to tell you if the remote repo’s commit history is ahead or behind your local ones. 
The <code>--all</code> option pushes all of the local branches to the remote repository.

You also need to push your local tags to the Bitbucket repository with the <code>--tags</code> option:
<code>git push --tags</code>
<img src="https://wac-cdn.atlassian.com/dam/jcr:787bb789-8116-46a8-935d-a2eb6be7d0db/03.svg?cdnVersion=217" loading="lazy" alt="Git migration: Push to Bitbucket repo">Your Bitbucket repository is now essentially a clone of your local repository. 
In the Bitbucket web interface, you should be able to explore the entire commit history of all of your branches.

<h3>&emsp;Share the repository with your team</h3>
All you have to do now is share the URL of your Bitbucket repository with any other developers that need access to the repository. 
The URL for any Git repository can be copy-and-pasted from the repository home page on Bitbucket:
<img src="https://wac-cdn.atlassian.com/dam/jcr:18695793-ba20-483b-b5b3-563b5799b5a8/git-migration-share-repository.png?cdnVersion=217" loading="lazy" alt="Git Migration: Share the repository">If your repository is private, you’ll also need to grant access to your team members in the <em>Administration</em> tab of the Bitbucket web interface. 

Users and groups can be managed by clicking the <em>Access management</em> link the left sidebar.
<img src="https://wac-cdn.atlassian.com/dam/jcr:cec369cf-cd07-4d0d-9e3d-3a5c61b63a69/git-migration-private-repository.png?cdnVersion=217" loading="lazy" alt="Git migration: Access management of Git repositories">As an alternative, you can use Bitbucket’s built-in invitation feature to invite other developers to fork the repository. 
The invited users will automatically be given access to the repository, so you don’t need to worry about granting permissions.
Once they have the URL of your repository, another developer can copy the repository to their local machine with <code>git clone</code> and begin working with the project. 

For example, after running the following command on their local machine, another developer would find a new Git repository containing the project in the <code></code> directory.
<code>git clone https://<user>@bitbucket.org/<user>/<project>.git </project></user></user></code>
<h3>&emsp;Continue committing with SVN, not Git</h3>
You should now be able to push your local project to a remote repository, and your team should be able to use that remote repository to clone the project onto their local machines. 

These are all the tools you need to start collaborating with Git. 
However, you and your team should continue to commit changes using SVN until everybody is ready to make the switch.
The only changes to the Git repository should come from the original SVN repository using the synchronization process discussed on the previous page. 
For all intents and purposes, this means that all of your Git repositories (both local and remote) are read-only. 

Your developers can experiment with them, and you can begin to integrate them into your build process, but you should avoid committing any permanent changes using Git.
<img src="https://wac-cdn.atlassian.com/dam/jcr:b6f66202-67cc-4343-b68a-e5c7cf0b7a50/04.svg?cdnVersion=217" loading="lazy" alt="Git migration: Only changes to the Git repo should come from the original SVN repo"><h3>&emsp;Summary</h3>
In this step, you set up a Bitbucket repository to share your converted Git repository with other developers. 
You should now have all the tools you need to implement any of the git workflows described in <a href="/git/tutorials/comparing-workflows" data-event="clicked" data-uuid="fbe9c6b4-21" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Git Workflows</a>. 

You can continue synchronizing with the SVN repository and sharing the resulting Git commits via Bitbucket for as long as it takes to get your development team comfortable with Git. 
Then, you can complete the migration process by retiring your SVN repository.
<h2><br><span class="orange">Migrate</span></h2>
This migration guide advocates a one-way synchronization from SVN to Git during the transition period. 

This means that while your team is getting comfortable with Git, they should still only be committing to the original SVN repository. 
When you’re ready to make the switch, the SVN repository should freeze at whatever state it’s in. 
Then, developers should begin committing to their local Git repositories and sharing them via Bitbucket.
<img src="https://wac-cdn.atlassian.com/dam/jcr:dd5784af-b852-4e79-b431-f009dabde162/01.svg?cdnVersion=217" loading="lazy" alt="Git migration: One-way synchronization from SVN to Git">The discrete switch from SVN to Git makes for a very intuitive migration. 

All of your developers should already understand the new Git workflows that they’ll be using, and they should have had plenty of time to practice using Git commands on the local repositories they cloned from Bitbucket.
This page guides you through the final step of the migration.
<h3>&emsp;Synchronize the Git repository</h3>
Before finalizing your migration to Git, you should make sure that your Git repository contains any new changes that have been committed to your SVN repository. 

You can do this with the same process described in the <a href="/git/tutorials/migrating-synchronize" data-event="clicked" data-uuid="8188c344-8e" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Synchronize</a> phase.
<code>git svn fetch java -Dfile.encoding=utf-8 -jar ~/svn-migration-scripts.jar sync-rebase java -Dfile.encoding=utf-8 -jar ~/svn-migration-scripts.jar clean-git --force</code>
<h3>&emsp;Backup the SVN repository</h3>
While you can still see your pre-Git project history in the migrated repository, it’s a good idea to backup the SVN repository just in case you ever need to explore the raw SVN data. 

An easy way to backup an SVN repo is to run the following on the machine that hosts the central SVN repository. 
If your SVN repo is hosted on a Linux machine, you can use the following:
<code>svnadmin dump <svn-repo> | gzip -9 > <backup-file></backup-file></svn-repo></code>
Replace <code><svn-repo></svn-repo></code> with the file path of the SVN repository that you’re backing up, and replace <code><backup-file></backup-file></code> with the file path of the compressed file containing the backup.

<h3>&emsp;Make the SVN repository read-only</h3>
All of your developers should now be committing with Git. 
To enforce this convention, you can make your SVN repository read-only. 
This process can vary depending on your server setup, but if you’re using the <code>svnserve</code> daemon, you can accomplish this by editing your SVN repo’s <code>conf/svnserve.conf</code> file. 

It’s <code>[general]</code> section should contain the following lines:
<code>anon-access = read auth-access = read</code>
This tells <code>svnserve</code> that both anonymous and authenticated users only have read permissions.
<h3>&emsp;Summary</h3>

And that’s all there is to migrating a project to Git. 
Your team should now be developing with a pure Git workflow and enjoying all of the benefits of distributed development. 
Good job!
<h2><br><span class="orange">Perforce to Git - why to make the move</span></h2>
Git is the leading SCM solution for software developers. 
Interest in Git has grown steadily since its initial release in 2005. 
Today it is popular among professional teams of all scales, from indie developers to large enterprises, as well as critical open source projects such as Android and the Linux kernel.
Yet Perforce, a commercial centralized SCM system, still resonates with game developers and other subsets of software developers. 

Why is that? In order to understand this lingering appeal, we’ll have to review some of the reasons why Git surpassed Perforce and other centralized SCM systems for general development, and see why the <a href="https://bitbucket.org/product/game-development-software" data-event="clicked" data-uuid="7f2436b5-33" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">game development industry</a> has been slower to switch.
<h3>&emsp;How Git ate the world</h3>
Take a step back to 1995. 
Your two options for SCM are CVS and ClearCase. 

CVS is free and, feature-wise, worth every penny. 
ClearCase is incredibly expensive but powerful: it can handle real merges (up to a 64-way merge!), global development teams, and software projects with multiple modules.
Now Perforce enters the picture. 
It isn’t free, but it’s much cheaper than ClearCase. 

It’s not as powerful as ClearCase, but it’s relatively fast and gets the job done. 
And that’s the recipe for a successful commercial SCM product. 
Indeed, as ClearCase slowly fades away and Subversion stagnates, a few years ago Perforce seemed ripe for wider adoption.
Fast-forward to the present. 

Git is now the <a href="/git/articles/10-years-of-git" data-event="clicked" data-uuid="2ebd38ed-c5" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">top SCM tool</a> for software developers. 
What happened?
<h3>&emsp;Distributed Speed</h3>
Git is distributed: every developer has the full history of their code repository locally. 

This makes the initial clone of the repository slower (unless you are using Smart Mirroring), but subsequent operations such as commit, blame, diff, merge, and log dramatically faster.
Perforce, for the most part, requires a connection to the server in order to even see the history of changes. 
And that single central server becomes a bottleneck as teams and projects get bigger. 
Commands like viewing history (<em>p4 changes</em>), creating a tag (<em>p4 label or p4 tag</em>), making a branch (<em>p4 integ</em>), or even making a file writable in your workspace (<em>p4 edit</em>) require write access to the server – which is an obvious bottleneck when thousands of users are accessing that server.

<h3>&emsp;Cost</h3>
Perforce, although it no longer publishes pricing, is known to be in the range of several hundred dollars per user for purchase and a percentage of that for annual renewals. 
For larger teams, it can also require fairly expensive hardware for that big central server.
Git by itself is open source and completely free. 

Bitbucket Server, which offers technical support and on premise installation, is a fraction of the cost of Perforce.
Take a team of 50 developers. 
Bitbucket would cost $600 per year compared to tens of thousands of dollars for Perforce. 
That adds up to a lot of free lunches for hard-working hackers.

<h3>&emsp;Workflow</h3>
Putting aside all the bells and whistles, fundamentally an SCM tool is about collaboration: letting a team of developers work on a shared set of software files. 
Git offers simple and computationally inexpensive branching, which opens up the door to a variety of cool <a href="/git/tutorials/comparing-workflows" data-event="clicked" data-uuid="93d9d6af-2d" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">workflows</a>. 
Task branching, Git Flow, forked repositories – there’s a fast and easy workflow for any type of team from open source to professional development, aided by powerful code review and collaboration tools.

Git also makes it easy to collaborate across company boundaries, a common requirement in cross-functional development. 
Even if physical network access to a Git shared repository is not possible, Git patch and bundle tools make sharing data simple.
Perforce, on the other hand, maintains a branching record on a per-file basis, compared to a per-commit basis with Git. 
What does this mean? Well, for starters it creates an awful lot of metadata in the Perforce database every time you make a branch. 

That contributes to performance problems at larger deployments, to the extent that many Perforce administrators restrict branch creation. 
Consider that for a moment: every time you want to make a task branch to try out a new feature, you’ve got to go and ask permission. 
If you can’t make task branches, you might check in unstable code on the main branch, or just wait until you’re “done” before committing at all. 
You sacrifice the benefit of having CI/CD on your task branches and being able to track granular work-in-progress. 

The end result is reduced productivity as developers either live with less productive workflows or just start using Git on the side and figure out how to manually merge their work back to Perforce.
Besides being expensive, Perforce branches aren’t conducive to the type of workflow most developers prefer. 
Perforce branches are shared, so there is no such thing as a private task branch with periodic rebasing. 
And Perforce’s merge algorithms are overly complicated, with entire <a href="http://answers.perforce.com/articles/KB/3580/?q=merge+rename&amp;l=en_US&amp;fs=Search&amp;pn=1" data-event="clicked" data-uuid="4432abca-e9" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">articles</a> written about how to merge files that were renamed or had their attributes modified.

And sharing code between Perforce servers? You’re back to sharing tar files with no common history. 
Perforce’s data model thinks of software history as being unique to a single server, compared to Git’s easy ability to clone and share history everywhere.
<h3>&emsp;Mind share and community</h3>
Putting aside commercial competitors, why did Git beat out Mercurial and other worthy competitors? There is some value in momentum of course, and Git has it. 

Git was created by Linus Torvalds to solve the distributed development challenges of the Linux kernel project, and now is the standard SCM tool for Linux, Android, OpenStack, and most other significant open source projects. 
It’s what all the cool kids are using – so if you’re a hiring manager, you can probably assume that a new engineer can (and will want to) work with Git without requiring extensive training.
And, of course, you have the full power of a vibrant open source community standing behind Git. 
Git is evolving rapidly to solve real-world problems, with major new features like Git LFS arriving on the scene. 

You can contribute your own code to the Git project if there’s a bug you want to see fixed, and you’ll never be locked into a commercial product with a roadmap and pace set by a single company. 
Just look at the range of Git client programs available: several powerful desktop GUIs, Windows Explorer integration, plugins for every IDE and developer tool. 
<h3>&emsp;GUIs and developer tools</h3>
In the original days of Git, the GUI and tool support was somewhat lacking. 

This was a stumbling block for users who prefer a visual interface for interacting with their Git repositories. 
Non-technical collaborators such as game artists were particularly disenfranchised. 
Perforce’s Windows Explorer plugin was a hit with this audience.
But thankfully those days are past. 

GUIs like <a href="http://www.sourcetreeapp.com/" data-event="clicked" data-uuid="3ff801c9-58" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Sourcetree</a> offer a point-and-click experience and there are a multitude of shell integrations for Git. 
Bitbucket provides code review, merge and pull requests, forking, online code browsing, and a plethora of other collaboration tools. 
Indeed, everyone from data scientists to <a href="https://bitbucket.org/blog/updatable-websites-with-bitbucket-and-cloudcannon" data-event="clicked" data-uuid="3ff801c9-58" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">creative agencies</a> are organizing communities that make use of the open collaboration that Git and Bitbucket make possible.
<h3>&emsp;Game developers are special</h3>

So that being said, what’s stopped some communities like game developers and researchers working with huge data sets from jumping on the bandwagon? It all boils down to the type of data and the complexity of the project organization. 
<h3>&emsp;Binary files</h3>
Game developers, particularly artists, need to work with large binary objects like textures and audio assets. 
Data scientists may have massive data sets comprising <a href="http://cnets.indiana.edu/groups/nan/webtraffic/click-dataset/" data-event="clicked" data-uuid="84159000-94" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">billions of event samples</a>.

That poses two problems for Git.
These files can’t be merged. 
A centralized locking mechanism is handy, and Perforce offers one. 
(Note however that even a centralized server only offers a locking mechanism on a single branch, so relying on this feature implies that you had a very restricted workflow.)

These files cause Git to slow down as the size of the repository grows.
The repository size problem is largely addressed by <a href="/git/tutorials/git-lfs" data-event="clicked" data-uuid="e758c391-ba" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Git LFS</a>, an extension that lets Git handle large files while delegating the actual file storage elsewhere.
The problem of file locking bears examination on two fronts. 
From a software configuration management perspective, Git LFS has a superior breed of file locking on the roadmap. 

Git LFS will help coordinate locking binary files across multiple branches with an algorithm that makes sure you’re working on the latest version, no matter which branch you’re on. 
That opens up branching workflows to users working with large binary files, compared to Perforce’s single-branch locking model.
It is also useful to think about file locking as a coordination problem. 
If you’re going to start working on a shared asset that can’t be merged, how do you broadcast that knowledge to all interested parties? Again, here’s where the advent of modern workflows using pull requests and real-time team collaboration really shines. 

You can quickly communicate your intentions using HipChat and check to see if there’s any outstanding work in progress on a particular file.
It’s also interesting to consider how the problem of handling large files will evolve in the era of Big Data. 
In order to test a Big Data analytics job, you may need a data set that’s several terabytes in size. 
Forget about any SCM system – this project is tested and run on a Big Data-compatible file system. 

What’s needed here is a CI/CD system that can orchestrate a more complex pipeline with artifacts living on HDFS or S3. 
That leads to our next topic.
<h3>&emsp;Large projects</h3>
Game development is a classic example of a software project with multiple modules or components – the game engine, the UI, static art, video renderings, and so on. 

Perforce as a monolithic centralized repository can host all of these modules in a single server, and let users choose which parts to pick into their own workspace. 
However, this advantage is largely moot now. 
Modern Git systems like Bitbucket provide easier management of Git multi-module tools like submodules and subtrees. 
And more importantly, large projects like Android have shown how to manage a complex project using higher level composition tools. 

Many of these lessons have been pulled into modern CI/CD tools like Bamboo and Bitbucket Pipelines, which can orchestrate complex continuous integration workflows, model the dependencies between projects, and <a href="https://confluence.atlassian.com/bamboo/bamboo-best-practice-sharing-artifacts-402033116.html" data-event="clicked" data-uuid="78c1fbae-eb" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">manage artifacts</a> between projects.
This trend largely follows the Git (and *nix) philosophy of building a tool that does a single job very well. 
Continuous integration and continuous delivery (CI/CD) is a practice of its own, with tools that are dedicated to understanding build and release workflow. 
It also aligns with modern software development <a href="https://leanpub.com/the-devops-2-toolkit" data-event="clicked" data-uuid="191f9cc2-83" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">best practices</a>, which aim to use small self-contained microservices rather than monolithic projects.

<h3>&emsp;Next steps</h3>
There’s clearly some momentum in the “Perforce to Git” camp, and Git and modern CI/CD tools are now poised to handle the largest and most complex development efforts. 
Indeed, Perforce even made a tool called Git Fusion that lets you extract part of a central Perforce repository as a Git repo. 
Unfortunately, while Git Fusion was a noble effort, trying to layer Git onto a centralized SCM system isn’t very easy; if you attempt to mix your usage models, you can quite easily corrupt one system’s view of the data. 

If you don’t mix your usage models, it’s hard to see the value of putting a commercial centralized backend behind Git. 
The trend as we’ve seen is actually in the other direction: how do you put the last few remaining pieces of centralized SCM that were useful into Git?
If you’re using Perforce for any software or game development, you’re probably wondering (nervously) about how to migrate to Git. 
How do you even do that? And is it worth the switching cost? That’s exactly what we’ll cover in the next article.

<h2><br><span class="orange">Migrating from Perforce to Git</span></h2>
As we discussed in the <a href="/git/tutorials/perforce-git" data-event="clicked" data-uuid="aea06e5c-89" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">previous article</a>, Git is now the de facto choice for SCM for just about any type of digital development. 
But if you have years of valuable history stored in Perforce, you are probably weighing the cost of switching. 
In this article we’ll tackle those concerns head-on, and tell you how to migrate data to Git. 

We’ve broken the Perforce to Git migration process down to 8 steps:
<a href="#moving-perforce-data" data-event="clicked" data-uuid="ca5f0a80-ff" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Moving Perforce data</a>
<a href="#users-and-permissions" data-event="clicked" data-uuid="ca5f0a80-ff" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Mapping users and permissions to a new Git repo</a>
<a href="#binary-files" data-event="clicked" data-uuid="ca5f0a80-ff" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Large binary files</a>

<a href="#complex-dependencies" data-event="clicked" data-uuid="ca5f0a80-ff" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Complex dependencies</a>
<a href="#how-to-structure-your-team" data-event="clicked" data-uuid="ca5f0a80-ff" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Structuring your team during the migration</a>
<a href="#mirrors-and-clusters" data-event="clicked" data-uuid="ca5f0a80-ff" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Mirroring data</a>
<a href="#alm-tools" data-event="clicked" data-uuid="ca5f0a80-ff" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">ALM Tools</a>

<a href="#define-success" data-event="clicked" data-uuid="ca5f0a80-ff" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">How to define success after a Perforce to Git migration</a>
<h3>&emsp;Step 1: Moving Perforce data</h3>
There are two general approaches for moving the data over from Perforce to Git. 
Before we dive into that area, we need to consider a fundamental difference between how Perforce and Git handle software projects.

A Perforce server can hold tens or hundreds of distinct software projects, each with its own branching model. 
A developer defines a “view” that tells the Perforce server which files to put into a working copy. 
A Git repository on the other hand normally holds a single software project and its branches and tags (although large monolithic Git repos do exist). 
You typically clone the repo and, perhaps, check out submodules or subtrees. 

The question of moving the data, then, has two parts: how to extract data from Perforce, and how to translate that into an equivalent set of Git repositories.
<h3>&emsp;Moving Perforce Data Option 1: Using Git Fusion</h3>
If you want to preserve the entire history of your data in Perforce, you can use Perforce’s own Git Fusion tool to extract a section of a Perforce server (a single project) into a Git repo. 
Essentially, you:

<a href="https://www.perforce.com/perforce/doc.current/manuals/git-fusion/" data-event="clicked" data-uuid="2a6ecd0d-2b" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Install Git Fusion</a>
Set up the correct <a href="https://www.perforce.com/perforce/doc.current/manuals/git-fusion/chapter_dyn_ngj_3l.html#section_rg2_p32_2k" data-event="clicked" data-uuid="2a6ecd0d-2b" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">views</a> of your data, including the branching structure
Use any Git client to clone from Git Fusion
Push your repo into Bitbucket

<code>Hands-on example *In order to work through this example you’ll need a Perforce server with Git Fusion already operational.* Let’s say that you have a Perforce project living in the repository path //depot/acme/… (in Perforce depot view syntax). 
It has three branches: - //depot/acme/main/… - //depot/acme/r1.0/… - //depot/acme/r1.1/… Keep in mind that with Perforce you see branches as additional directories in the tree. 
Your first step is to configure Git Fusion so that it understands the branching relationship in Perforce. 
To do this, you create a repo configuration file: [@repo] description = Acme project charset = utf8 [main] git-branch-name = main view = //depot/acme/main/… … [r1.0] git-branch-name = r1.0 view = //depot/acme/r1.0/… … [r1.1] git-branch-name = r1.1 view = //depot/acme/r1.1/… … Submit this file to Perforce under the path //.git-fusion/repos/acme/p4gf_config Now create an empty project called acme in Bitbucket using the normal Bitbucket administration tools. 

You can configure the access control and team members per your usual standards. 
Next, clone from Git Fusion: git clone https://<git fusion server url>/acme cd acme git remote add bitbucket <bitbucket project url> git push –u --all bitbucket git push --tags Bitbucket That’s it! You should now see the imported history in Bitbucket.</bitbucket></git></code>
Now, this may not always give you a 100% faithful copy of your Perforce data. 
There are some Perforce operations, like partial merges, that just have no equivalent in Git. 

But all in all, this method will get most of your history without too much effort.
Keep in mind that preserving the last 10 years of branching history from a legacy SCM doesn’t mean that you have to keep using the same workflow. 
Notably, you should consider adopting feature branch workflows like Git Flow as a practical first step.
<em>Pros and cons</em>

Requires the most setup work and runtime
Preserves the most history (letting you shut down legacy Perforce server)
Maintains legacy branching model in history 
<h3>&emsp;Moving Perforce Data Option 2: Start over</h3>

The other option is to start over. 
Forget all that crufty history: just extract the head (tip) of each branch in Perforce that corresponds to your project, and check that stuff into a new empty Git repo. 
(This implies that you have Perforce workspaces defined with a correct ‘view’ of the data you want.)
This is the simplest and fastest technique. 

No matter how complicated your Perforce history was, your new Git repo is lean and mean. 
You get the chance to start a new Git-based workflow without any accumulated baggage.
The main drawback is that you probably want to keep the old Perforce server around in a read-only mode in case anyone needs to dig into historical code for any reason. 
This won’t cost you anything in license fees but it does imply that you’re keeping that old server alive for a while.

<code>**Hands-on example** Go into your Perforce workspace (the directory where the main branch of your project data is checked out) and run: p4 sync This fetches the latest revision of your files. 
Now create an empty project called acme in Bitbucket using the normal Bitbucket administration tools. 
You can configure the access control and team members per your usual standards. 
Next, create a new Git repo in your workspace and push to Bitbucket: git init . 

git remote add origin <bitbucket project url> git push –u --all origin git push --tags origin You should now see the latest snapshot of your code as the first commit in your new Bitbucket project.</bitbucket></code>
<em>Pros and cons</em>
Fast and simple
Redesign branching model and workflow

Legacy Perforce server used for read-only access
<h3>&emsp;Step 2: Users and permissions</h3>
After the data is moved over, the next task is usually to start mapping your users and permissions into new Bitbucket projects. 
If you use LDAP for a user directory you’ll save some time here. 

Otherwise, you can easily extract a set of user accounts from Perforce using the p4 users –o command and then enter them into Bitbucket a project at a time. 
Translating Perforce permissions into the equivalent Bitbucket permissions can be difficult because Perforce permissions are granular and complex, with the possibility of excluding access to individual files. 
This complicated permission scheme is one reason why a Perforce server can bog down – every attempt at access may cause the server to perform an expensive computation on a complicated data structure.
In most cases it’s faster just to ask project leads to define a simpler set of permissions in Bitbucket using the normal project, repo, and branch level permissions. 

Indeed, you’ll want to revisit your permission setup anyway, as Git offers up so many new workflow options. 
For example, in Perforce you may have restricted branch creation, while in Bitbucket you may only need to restrict push access to the main branch.
<h3>&emsp;Step 3: Binary files</h3>
If you stored large binary blobs in Perforce, think carefully about how you want to manage those in Git. 

You could try out Git LFS, or you could simply use a regular artifact management system instead. 
In any case you don’t want to blindly push large blobs into a Git repo.
<h3>&emsp;Step 4: Complex dependencies</h3>
A Perforce working copy may actually map in read-only copies of data from several modules. 

In Git, this is done either using submodules, subtrees, or by leveraging CI/CD or artifact management systems. 
There’s no easy answer here, but some data import tools can model a submodule relationship between Git repos. 
For a more in depth look on how to use submodules or subtrees, you can read about each here: <a href="https://blogs.atlassian.com/2013/05/alternatives-to-git-submodule-git-subtree/" data-event="clicked" data-uuid="a5919a36-6a" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">https://blogs.atlassian.com/2013/05/alternatives-to-git-submodule-git-subtree/</a>.
<h3>&emsp;Step 5: How to structure your team during the migration</h3>

So, your Perforce server has 100 projects from 10 teams. 
You’ve got a migration strategy and tool set laid out. 
Schedule the maintenance window and go!
Er… no.

Remember that switching SCM tools is as much about developers as it is data. 
You’ve got people, process, and schedule to consider – don’t try to boil the ocean in a single day. 
It’s too risky.
You need to consider a project plan during the actual migration phase. 

(It might be a good time to try out a new Jira workflow…) Here are some options you can look at.
Migrate team-by-team and project-by-project. 
Aim to start a project and team at the beginning of a sprint or program increment, when you have some time to adapt.
Migrate incrementally. 

Import all of your data in a weekend, but then let teams slowly complete the switch to Git over time. 
Periodically pickup the deltas by re-running your import tools. 
Although more complex, this strategy isn’t bad if you have dependencies between teams and the early adopters need at least a recent snapshot in Git to feed their CI/CD pipeline.
Use both systems at the same time for a period of time. 

While not for the faint of heart, it’s technically feasible to use Git Fusion to do a two-way data exchange as long as you are not doing complex operations that will confuse the data translator.
Lastly, invest in communicating the changes to the team – the motivation, the why, and a series of steps for how to do it. 
Pick an “early adopter” team with engineers experienced in the entire software development lifecycle, and have that team be a model for the others. 
Find Git champions to assist people when they have a difficulty. 

Making small, understandable, iterative changes will help this process be successful.
<h3>&emsp;Step 6: Mirrors and Clusters</h3>
Perforce has a simple but effective system for mirroring data to remote sites to reduce the effect of latency. 
It has a more complex system for running a set of local mirrors for read-only clustering. 

Although latency is simply not as much of a concern for Git, if you are running a worldwide operation you should look at Bitbucket Data Center for both clustering and mirroring, which will greatly speed up your clone times for a global team.
<h3>&emsp;Step 7: ALM Tools</h3>
And now for some good news – you’ve got a lot of choices for your ALM tool stack when you move from Perforce to Git. 
Pretty much every developer and ALM tool out there works with Git, and of course Bitbucket gives you great integration with Jira and Bamboo. 

As you transition to Git, you can explore Bamboo features such as <a href="https://confluence.atlassian.com/bamboo/using-plan-branches-289276872.html" data-event="clicked" data-uuid="fe1274a0-c5" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Plan Branches</a> that take advantage of a feature branch workflow.
<h3>&emsp;Step 8: Defining success</h3>
So how exactly do you measure success during a migration from Perforce to Git? In many migration projects we tend to focus too much on the fidelity of data transfer. 
But that is not a useful metric for many reasons. 

It’s likely that you can never get a bit-for-bit history in Git that is exactly the equivalent of what happened in a centralized SCM system like Perforce.
A more practical approach is to use CI/CD for verification. 
Once you switch your CI/CD pipeline from Perforce to Git, do all your tests still pass? And can you still deploy your software? If all of your important older builds can still pass through your CI/CD pipeline, then it’s time to declare victory!
<h3>&emsp;That’s a wrap</h3>

So now you’ve seen why there’s movement from Perforce to Git, and how to actually get there. 
The next step is to choose a Git solution. 
If you are switching from Perforce for game development, <a href="https://bitbucket.org/product/game-development-software" data-event="clicked" data-uuid="f75c43da-0a" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">see why game developers love Bitbucket</a>.
<h2><br><span class="orange">How to move a full Git repository</span></h2>
If you're wrangling multiple Git repositorites, you'll eventually want to move files from one to another. 
This tutorial will show you how you can move a full Git repository from one remote server to another. 
The steps below even allow you to choose which branches and tags to include.
Let’s call the original repository ORI and the new one NEW, here are the steps required to copy everything from ORI to NEW:

1. Create a local repository in the <strong>temp-dir</strong> directory using:
<code>git clone &lt;url to ORI repo> temp-dir</code>
<img src="https://wac-cdn.atlassian.com/dam/jcr:9fb5cea3-dcd6-4743-b847-a852a9683d47/clone-ori-repo.png?cdnVersion=217" loading="lazy" alt="clone ori repository">2. 
Go into the temp-dir directory.

3. To see a list of the different branches in ORI do:
<code>git branch -a</code>
<img src="https://wac-cdn.atlassian.com/dam/jcr:38e6c2f1-cfc8-47a7-9391-66944c0eacdf/git-branch-a.png?cdnVersion=217" loading="lazy" alt="git branch-a">4. 
Checkout all the branches that you want to copy from ORI to NEW using:

<code>git checkout branch-name</code>
<img src="https://wac-cdn.atlassian.com/dam/jcr:f290a19a-3d8b-46ee-ad34-18269d659905/checkout-branches.png?cdnVersion=217" loading="lazy" alt="checkout-branches">5. 
Now fetch all the tags from ORI using:
<code>git fetch --tags</code>

<img src="https://wac-cdn.atlassian.com/dam/jcr:f933e76e-f773-4943-8bd2-935a696cea0d/git-fetch-tags.png?cdnVersion=217" loading="lazy" alt="git-fetch-tags">6. 
Before doing the next step make sure to check your local tags and branches using the following commands:
<code>git tag
git branch -a</code>

<img src="https://wac-cdn.atlassian.com/dam/jcr:789cf04f-ed2c-4ef8-8299-138b460b9751/git-tag-and-git-branch-a.png?cdnVersion=217" loading="lazy" alt="git-tag-and-git-branch-a">7. 
Now clear the link to the ORI repository with the following command:
<code>git remote rm origin</code>
8. Now link your local repository to your newly created NEW repository using the following command:

<code>git remote add origin &lt;url to NEW repo></code>
9. Now push all your branches and tags with these commands:
<code>git push origin --all
git push --tags</code>

<img src="https://wac-cdn.atlassian.com/dam/jcr:2d1db8cb-7a28-46d0-8717-9afb0f1da244/end-result.png?cdnVersion=217" loading="lazy" alt="end-result">10. 
You now have a full copy from your ORI repo.
<h3>&emsp;Extra</h3>
If you want to simply copy the entire repository you can use

<code>git clone --mirror &lt;url to ORI repo> temp-dir</code>
to replace step 1 to 5.
<h2><br><span class="orange">Advanced Git Tutorials</span></h2>
<a href="/git/tutorials" data-event="clicked" data-uuid="04567e0e-5c" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Atlassian’s Git tutorials</a> introduce the most common Git commands, and our <a href="/git/tutorials/comparing-workflows" data-event="clicked" data-uuid="04567e0e-5c" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Git Workflows</a> modules discuss how these commands are typically used to facilitate collaboration. 

Alone, these are enough to get a development team up and running with Git. 
But, if you really want to leverage the full power of Git, you’re ready to dive into our Advanced Git articles.
Each of these articles provide an in-depth discussion of an advanced feature of Git. 
Instead of presenting new commands and concepts, they refine your existing Git skills by explaining what’s going on under the hood. 

Armed with this knowledge, you’ll be able to use familiar Git commands more effectively. 
More importantly, you’ll never be scared of breaking your Git repository because you’ll understand why it broke and how to fix it.
<h2><span class="saddlebrown">&emsp;Merging vs. Rebasing</span></h2>
<img src="https://wac-cdn.atlassian.com/dam/jcr:15447956-9d33-4817-9dc6-fd6c86f24240/hero.svg?cdnVersion=217" loading="lazy" alt="Merging vs. Rebasing">Git is all about working with divergent history. 

Its <code>git merge</code> and <code>git rebase</code> commands offer alternative ways to integrate commits from different branches, and both options come with their own advantages. 
In this article, we’ll discuss how and when a basic <code>git merge</code> operation can be replaced with a rebase.
<a href="/git/tutorials/merging-vs-rebasing" data-event="clicked" data-uuid="3f3da231-e3" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Learn more </a>
<h2><span class="saddlebrown">&emsp;Resetting, Checking Out, and Reverting</span></h2>
<img src="https://wac-cdn.atlassian.com/dam/jcr:7a828d45-b8d9-49a0-9f43-8f6687110fcb/hero.svg?cdnVersion=217" loading="lazy" alt="Resetting, Checking Out, and Reverting">The <code>git reset</code>, <code>git checkout</code>, and <code>git revert</code> commands are all similar in that they undo some type of change in your repository. 
But, they all affect different combinations of the working directory, staged snapshot, and commit history. 
This article clearly defines how these commands differ and when each of them should be used in the standard Git workflows.
<a href="/git/tutorials/resetting-checking-out-and-reverting" data-event="clicked" data-uuid="11438188-2f" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Learn more </a>
<h2><span class="saddlebrown">&emsp;Advanced Git Log</span></h2>
<img src="https://wac-cdn.atlassian.com/dam/jcr:613277ed-3b4b-4c45-8657-869f9bc3d23e/hero.svg?cdnVersion=217" loading="lazy" alt="Advanced Git Log">The <code>git log</code> command is what makes your project history useful. 
Without it, you wouldn’t be able to access any of your commits. 
But, if you’re like most aspiring Git users, you’ve probably only scratched the surface of what’s possible with <code>git log</code>. 

This article walks you through its advanced formatting and filtering options, giving you the power to extract all sorts of interesting information from your Git repository.
<a href="/git/tutorials/git-log" data-event="clicked" data-uuid="465fd086-6c" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Learn more </a>
<h2><span class="saddlebrown">&emsp;Git Hooks</span></h2>
<img src="https://wac-cdn.atlassian.com/dam/jcr:c5d250fd-b2ab-446a-9a5a-f7dec86abed8/hero.svg?cdnVersion=217" loading="lazy" alt="Git Hooks">If you want to perform custom actions when a certain event takes place in a Git repository, hooks are your tool of choice. 

They let you normalize commit messages, automate testing suites, notify continuous integration systems, and much more. 
After this article, you’ll understand the many ways in which Git hooks can streamline your workflow.
<a href="/git/tutorials/git-hooks" data-event="clicked" data-uuid="8356bc4a-16" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Learn more </a>
<h2><span class="saddlebrown">&emsp;Refs and the Reflog</span></h2>
<img src="https://wac-cdn.atlassian.com/dam/jcr:8d62148d-ba03-4762-bd3a-06ddc465b07f/hero.svg?cdnVersion=217" loading="lazy" alt="Refs and the Reflog">A <strong>ref</strong> is Git’s internal way of referring to a commit. 
You’re already familiar with many categories of refs, including commit hashes and branch names. 
But, there are many other types of refs, and virtually every Git command utilizes them in some form or another. 
You’ll walk away from this article with an intimate knowledge of Git’s inner workings.

<a href="/git/tutorials/refs-and-the-reflog" data-event="clicked" data-uuid="a5f7aae6-7e" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Learn more </a>
<h2><br><span class="orange">Merging vs. Rebasing</span></h2>
The <code>git rebase</code> command has a reputation for being magical Git voodoo that beginners should stay away from, but it can actually make life much easier for a development team when used with care. 
In this article, we’ll compare <code>git rebase</code> with the related <code>git merge</code> command and identify all of the potential opportunities to incorporate rebasing into the typical Git workflow.
<h2><span class="saddlebrown">&emsp;Conceptual Overview</span></h2>
The first thing to understand about <code>git rebase</code> is that it solves the same problem as <code>git merge</code>. 
Both of these commands are designed to integrate changes from one branch into another branch—they just do it in very different ways.
Consider what happens when you start working on a new feature in a dedicated branch, then another team member updates the <code>main</code> branch with new commits. 

This results in a forked history, which should be familiar to anyone who has used Git as a collaboration tool.
<img src="https://wac-cdn.atlassian.com/dam/jcr:1523084b-d05a-4f5a-bd1a-01866ec09ca3/01%20A%20forked%20commit%20history.svg?cdnVersion=217" loading="lazy" alt="A forked commit history">Now, let’s say that the new commits in <code>main</code> are relevant to the feature that you’re working on. 
To incorporate the new commits into your <code>feature</code> branch, you have two options: merging or rebasing.
<h3>&emsp;The Merge Option</h3>

The easiest option is to merge the <code>main</code> branch into the feature branch using something like the following:
<code>git checkout feature
git merge main</code>
Or, you can condense this to a one-liner:

<code>git merge feature main</code>
This creates a new “merge commit” in the <code>feature</code> branch that ties together the histories of both branches, giving you a branch structure that looks like this:
<img src="https://wac-cdn.atlassian.com/dam/jcr:4639eeb8-e417-434a-a3f8-a972277fc66a/02%20Merging%20main%20into%20the%20feature%20branh.svg?cdnVersion=217" loading="lazy" alt="Merging master into the feature branch">Merging is nice because it’s a <em>non-destructive</em> operation. 
The existing branches are not changed in any way. 

This avoids all of the potential pitfalls of rebasing (discussed below).
On the other hand, this also means that the <code>feature</code> branch will have an extraneous merge commit every time you need to incorporate upstream changes. 
If <code>main</code> is very active, this can pollute your feature branch’s history quite a bit. 
While it’s possible to mitigate this issue with advanced <code>git log</code> options, it can make it hard for other developers to understand the history of the project.

<h3>&emsp;The Rebase Option</h3>
As an alternative to merging, you can rebase the <code>feature</code> branch onto <code>main</code> branch using the following commands:
<code>git checkout feature
git rebase main</code>

This moves the entire <code>feature</code> branch to begin on the tip of the <code>main</code> branch, effectively incorporating all of the new commits in <code>main</code>. 
But, instead of using a merge commit, rebasing <em>re-writes</em> the project history by creating brand new commits for each commit in the original branch.
<img src="https://wac-cdn.atlassian.com/dam/jcr:3bafddf5-fd55-4320-9310-3d28f4fca3af/03%20Rebasing%20the%20feature%20branch%20into%20main.svg?cdnVersion=217" loading="lazy" alt="Rebasing the feature branch onto master">The major benefit of rebasing is that you get a much cleaner project history. 
First, it eliminates the unnecessary merge commits required by <code>git merge</code>. 

Second, as you can see in the above diagram, rebasing also results in a perfectly linear project history—you can follow the tip of <code>feature</code> all the way to the beginning of the project without any forks. 
This makes it easier to navigate your project with commands like <code>git log</code>, <code>git bisect</code>, and <code>gitk</code>.
But, there are two trade-offs for this pristine commit history: safety and traceability. 
If you don’t follow the <a href="#the-golden-rule-of-rebasing" data-event="clicked" data-uuid="6d457fd5-0f" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Golden Rule of Rebasing</a>, re-writing project history can be potentially catastrophic for your collaboration workflow. 

And, less importantly, rebasing loses the context provided by a merge commit—you can’t see when upstream changes were incorporated into the feature.
<h3>&emsp;Interactive Rebasing</h3>
Interactive rebasing gives you the opportunity to alter commits as they are moved to the new branch. 
This is even more powerful than an automated rebase, since it offers complete control over the branch’s commit history. 

Typically, this is used to clean up a messy history before merging a feature branch into <code>main</code>.
To begin an interactive rebasing session, pass the <code>i</code> option to the <code>git rebase</code> command:
<code>git checkout feature
git rebase -i main</code>

This will open a text editor listing all of the commits that are about to be moved:
<code>pick 33d5b7a Message for commit #1
pick 9480b3d Message for commit #2
pick 5c67e61 Message for commit #3</code>

This listing defines exactly what the branch will look like after the rebase is performed. 
By changing the <code>pick</code> command and/or re-ordering the entries, you can make the branch’s history look like whatever you want. 
For example, if the 2nd commit fixes a small problem in the 1st commit, you can condense them into a single commit with the <code>fixup</code> command:
<code>pick 33d5b7a Message for commit #1

fixup 9480b3d Message for commit #2
pick 5c67e61 Message for commit #3</code>
When you save and close the file, Git will perform the rebase according to your instructions, resulting in project history that looks like the following:
<img src="https://wac-cdn.atlassian.com/dam/jcr:a712e238-6cb9-4c8c-8ef7-1975dca49be3/04%20Squashing%20a%20commit%20with%20an%20interactive%20rebase.svg?cdnVersion=217" loading="lazy" alt="Squashing a commit with an interactive rebase">Eliminating insignificant commits like this makes your feature’s history much easier to understand. 

This is something that <code>git merge</code> simply cannot do.
<h2><span class="saddlebrown">&emsp;The Golden Rule of Rebasing</span></h2>
Once you understand what rebasing is, the most important thing to learn is when <em>not</em> to do it. 
The golden rule of <code>git rebase</code> is to never use it on <em>public</em> branches.

For example, think about what would happen if you rebased <code>main</code> onto your <code>feature</code> branch:
<img src="https://wac-cdn.atlassian.com/dam/jcr:2908e0e6-f74b-4425-b5d2-f5eca8cfcd99/05%20Rebasing%20the%20main%20branch.svg?cdnVersion=217" loading="lazy" alt="Rebasing the master branch">The rebase moves all of the commits in <code>main</code> onto the tip of <code>feature</code>. 
The problem is that this only happened in <em>your</em> repository. 
All of the other developers are still working with the original <code>main</code>. 

Since rebasing results in brand new commits, Git will think that your <code>main</code> branch’s history has diverged from everybody else’s.
The only way to synchronize the two <code>main</code> branches is to merge them back together, resulting in an extra merge commit <em>and</em> two sets of commits that contain the same changes (the original ones, and the ones from your rebased branch). 
Needless to say, this is a very confusing situation.
So, before you run <code>git rebase</code>, always ask yourself, “Is anyone else looking at this branch?” If the answer is yes, take your hands off the keyboard and start thinking about a non-destructive way to make your changes (e.g., the <code>git revert</code> command). 

Otherwise, you’re safe to re-write history as much as you like.
<h3>&emsp;Force-Pushing</h3>
If you try to push the rebased <code>main</code> branch back to a remote repository, Git will prevent you from doing so because it conflicts with the remote <code>main</code> branch. 
But, you can force the push to go through by passing the <code>--force</code> flag, like so:

<code># Be very careful with this command! git push --force</code>
This overwrites the remote <code>main</code> branch to match the rebased one from your repository and makes things very confusing for the rest of your team. 
So, be very careful to use this command only when you know exactly what you’re doing.
One of the only times you should be force-pushing is when you’ve performed a local cleanup <em>after</em> you’ve pushed a private feature branch to a remote repository (e.g., for backup purposes). 

This is like saying, “Oops, I didn’t really want to push that original version of the feature branch. 
Take the current one instead.” Again, it’s important that nobody is working off of the commits from the original version of the feature branch.
<h2><span class="saddlebrown">&emsp;Workflow Walkthrough</span></h2>
Rebasing can be incorporated into your existing Git workflow as much or as little as your team is comfortable with. 

In this section, we’ll take a look at the benefits that rebasing can offer at the various stages of a feature’s development.
The first step in any workflow that leverages <code>git rebase</code> is to create a dedicated branch for each feature. 
This gives you the necessary branch structure to safely utilize rebasing:
<img src="https://wac-cdn.atlassian.com/dam/jcr:88bfb19f-81ca-4202-b5d1-f2d8fa8778f2/06%20Developing%20a%20feature%20in%20a%20dedicated%20branch.svg?cdnVersion=217" loading="lazy" alt="Developing a feature in a dedicated branch"><h3>&emsp;Local Cleanup</h3>

One of the best ways to incorporate rebasing into your workflow is to clean up local, in-progress features. 
By periodically performing an interactive rebase, you can make sure each commit in your feature is focused and meaningful. 
This lets you write your code without worrying about breaking it up into isolated commits—you can fix it up after the fact.
When calling <code>git rebase</code>, you have two options for the new base: The feature’s parent branch (e.g., <code>main</code>), or an earlier commit in your feature. 

We saw an example of the first option in the <em>Interactive Rebasing</em> section. 
The latter option is nice when you only need to fix up the last few commits. 
For example, the following command begins an interactive rebase of only the last 3 commits.
<code>git checkout feature git rebase -i HEAD~3</code>

By specifying <code>HEAD~3</code> as the new base, you’re not actually moving the branch—you’re just interactively re-writing the 3 commits that follow it. 
Note that this will <em>not</em> incorporate upstream changes into the <code>feature</code> branch.
<img src="https://wac-cdn.atlassian.com/dam/jcr:51d9f126-1fc1-4c6c-ba52-c4085cd59002/07%20Rebasing%20into%20Head-3.svg?cdnVersion=217" loading="lazy" alt="Rebasing onto Head~3">If you want to re-write the entire feature using this method, the <code>git merge-base</code> command can be useful to find the original base of the <code>feature</code> branch. 
The following returns the commit ID of the original base, which you can then pass to <code>git rebase</code>:

<code>git merge-base feature main</code>
This use of interactive rebasing is a great way to introduce <code>git rebase</code> into your workflow, as it only affects local branches. 
The only thing other developers will see is your finished product, which should be a clean, easy-to-follow feature branch history.
But again, this only works for <em>private</em> feature branches. 

If you’re collaborating with other developers via the same feature branch, that branch is <em>public</em>, and you’re not allowed to re-write its history.
There is no <code>git merge</code> alternative for cleaning up local commits with an interactive rebase.
<h3>&emsp;Incorporating Upstream Changes Into a Feature</h3>
In the <em>Conceptual Overview</em> section, we saw how a feature branch can incorporate upstream changes from <code>main</code> using either <code>git merge</code> or <code>git rebase</code>. 

Merging is a safe option that preserves the entire history of your repository, while rebasing creates a linear history by moving your feature branch onto the tip of <code>main</code>.
This use of <code>git rebase</code> is similar to a local cleanup (and can be performed simultaneously), but in the process it incorporates those upstream commits from <code>main</code>.
Keep in mind that it’s perfectly legal to rebase onto a remote branch instead of <code>main</code>. 
This can happen when collaborating on the same feature with another developer and you need to incorporate their changes into your repository.

For example, if you and another developer named John added commits to the <code>feature</code> branch, your repository might look like the following after fetching the remote <code>feature</code> branch from John’s repository:
<img src="https://wac-cdn.atlassian.com/dam/jcr:0bb661aa-361d-47ba-8c7b-00b3be0546cb/08.svg?cdnVersion=217" loading="lazy" alt="Collaborating on the same feature branch">You can resolve this fork the exact same way as you integrate upstream changes from <code>main</code>: either merge your local <code>feature</code> with <code>john/feature</code>, or rebase your local <code>feature</code> onto the tip of <code>john/feature</code>.
<img src="https://wac-cdn.atlassian.com/dam/jcr:1896adb1-5d49-419a-9b50-3a36adac186c/09.svg?cdnVersion=217" loading="lazy" alt="Merging vs. rebasing onto a remote branch">Note that this rebase doesn’t violate the <em>Golden Rule of Rebasing</em> because only your local <code>feature</code> commits are being moved—everything before that is untouched. 
This is like saying, “add my changes to what John has already done.” In most circumstances, this is more intuitive than synchronizing with the remote branch via a merge commit.

By default, the <code>git pull</code> command performs a merge, but you can force it to integrate the remote branch with a rebase by passing it the <code>--rebase</code> option.
<h3>&emsp;Reviewing a Feature With a Pull Request</h3>
If you use pull requests as part of your code review process, you need to avoid using <code>git rebase</code> after creating the pull request. 
As soon as you make the pull request, other developers will be looking at your commits, which means that it’s a <em>public</em> branch. 

Re-writing its history will make it impossible for Git and your teammates to track any follow-up commits added to the feature.
Any changes from other developers need to be incorporated with <code>git merge</code> instead of <code>git rebase</code>.
For this reason, it’s usually a good idea to clean up your code with an interactive rebase <em>before</em> submitting your pull request.
<h3>&emsp;Integrating an Approved Feature</h3>

After a feature has been approved by your team, you have the option of rebasing the feature onto the tip of the <code>main</code> branch before using <code>git merge</code> to integrate the feature into the main code base.
This is a similar situation to incorporating upstream changes into a feature branch, but since you’re not allowed to re-write commits in the <code>main</code> branch, you have to eventually use <code>git merge</code> to integrate the feature. 
However, by performing a rebase before the merge, you’re assured that the merge will be fast-forwarded, resulting in a perfectly linear history. 
This also gives you the chance to squash any follow-up commits added during a pull request.

<img src="https://wac-cdn.atlassian.com/dam/jcr:412813ee-381f-42f6-8b43-79760d2da0dc/08-10%20Integrating%20a%20feature%20into%20master%20with%20and%20without%20a%20rebase.svg?cdnVersion=217" loading="lazy" alt="Integrating a feature into master with and without a rebase">If you’re not entirely comfortable with <code>git rebase</code>, you can always perform the rebase in a temporary branch. 
That way, if you accidentally mess up your feature’s history, you can check out the original branch and try again. 
For example:
<code>git checkout feature

git checkout -b temporary-branch
git rebase -i main
# [Clean up the history]
git checkout main

git merge temporary-branch</code>
<h2><span class="saddlebrown">&emsp;Summary</span></h2>
And that’s all you really need to know to start rebasing your branches. 
If you would prefer a clean, linear history free of unnecessary merge commits, you should reach for <code>git rebase</code> instead of <code>git merge</code> when integrating changes from another branch.

On the other hand, if you want to preserve the complete history of your project and avoid the risk of re-writing public commits, you can stick with <code>git merge</code>. 
Either option is perfectly valid, but at least now you have the option of leveraging the benefits of <code>git rebase</code>.
<h2><br><span class="orange">Resetting, Checking Out &amp; Reverting</span></h2>
The <code><a href="/git/tutorials/undoing-changes/git-reset" data-event="clicked" data-uuid="babf1db2-2e" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git reset</a></code>, <code><a href="/git/tutorials/using-branches/git-checkout" data-event="clicked" data-uuid="babf1db2-2e" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git checkout</a></code>, and <code><a href="/git/tutorials/undoing-changes/git-revert" data-event="clicked" data-uuid="babf1db2-2e" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git revert</a></code> commands are some of the most useful tools in your Git toolbox. 

They all let you undo some kind of change in your repository, and the first two commands can be used to manipulate either commits or individual files.
Because they’re so similar, it’s very easy to mix up which command should be used in any given development scenario. 
In this article, we’ll compare the most common configurations of <code>git reset</code>, <code>git checkout</code>, and <code>git revert</code>. 
Hopefully, you’ll walk away with the confidence to navigate your repository using any of these commands.

<img src="https://wac-cdn.atlassian.com/dam/jcr:0c5257d5-ff01-4014-af12-faf2aec53cc3/01.svg?cdnVersion=217" loading="lazy" alt="The three trees of Git">It helps to think about each command in terms of their effect on the three state management mechanisms of a Git repository: the working directory, the staged snapshot, and the commit history. 
These components are sometimes known as "The three trees" of Git. 
We explore the three trees in depth on the <code><a href="/git/tutorials/undoing-changes/git-reset" data-event="clicked" data-uuid="d00a992f-c1" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git reset</a></code> page. 
Keep these mechanisms in mind as you read through this article.

A checkout is an operation that moves the <code>HEAD</code> ref pointer to a specified commit. 
To demonstrate this consider the following example.
<img src="https://wac-cdn.atlassian.com/dam/jcr:8d616ece-8cee-4fde-bdee-4b280a0a8334/01%20git-sequence-transparent%20kopiera.png?cdnVersion=217" loading="lazy" alt="Move the HEAD ref pointer to a specified commit">This example demonstrates a sequence of commits on the <code>main</code> branch. 
The <code>HEAD</code> ref and <code>main</code> branch ref currently point to commit d. 

Now let us execute <code>git checkout b</code>
<img src="https://wac-cdn.atlassian.com/dam/jcr:f45c4a34-8968-4c81-83cf-d55ebf01a447/02%20git-checkout-transparent%20kopiera.png?cdnVersion=217" loading="lazy" alt="Sequence of commits on the master branch">This is an update to the "Commit History" tree. 
The <code>git checkout</code> command can be used in a commit, or file level scope. 
A file level checkout will change the file's contents to those of the specific commit.

A revert is an operation that takes a specified commit and creates a new commit which inverses the specified commit. 
<code>git revert</code> can only be run at a commit level scope and has no file level functionality.
A reset is an operation that takes a specified commit and resets the "three trees" to match the state of the repository at that specified commit. 
A reset can be invoked in three different modes which correspond to the three trees.

Checkout and reset are generally used for making local or private 'undos'. 
They modify the history of a repository that can cause conflicts when pushing to remote shared repositories. 
Revert is considered a safe operation for 'public undos' as it creates new history which can be shared remotely and doesn't overwrite history remote team members may be dependent on.
<h2><span class="saddlebrown">&emsp;Git Reset vs Revert vs Checkout reference</span></h2>
The table below sums up the most common use cases for all of these commands. 
Be sure to keep this reference handy, as you’ll undoubtedly need to use at least some of them during your Git career.
<table>
<thead><tr>

<th>Command</th> <th>Scope</th> <th>Common use cases</th> </tr></thead>
<thead>
<tr>
<td><code>git reset</code></td> <td>Commit-level</td> <td>Discard commits in a private branch or throw away uncommited changes</td> </tr>

<tr>
<td><code>git reset</code></td> <td>File-level</td> <td>Unstage a file</td> </tr>
<tr>
<td><code>git checkout</code></td> <td>Commit-level</td> <td>Switch between branches or inspect old snapshots</td> </tr>

<tr>
<td><code>git checkout</code></td> <td>File-level</td> <td>Discard changes in the working directory</td> </tr>
<tr>
<td><code>git revert</code></td> <td>Commit-level</td> <td>Undo commits in a public branch</td> </tr>

<tr>
<td><code>git revert</code></td> <td>File-level</td> <td>(N/A)</td> </tr>
</thead>
</table>
<h2><span class="saddlebrown">&emsp;Commit Level Operations</span></h2>
The parameters that you pass to <code>git reset</code> and <code>git checkout</code> determine their scope. 
When you don’t include a file path as a parameter, they operate on whole commits. 
That’s what we’ll be exploring in this section. 

Note that <code>git revert</code> has no file-level counterpart.
<h3>&emsp;Reset A Specific Commit</h3>
On the commit-level, resetting is a way to move the tip of a branch to a different commit. 
This can be used to remove commits from the current branch. 

For example, the following command moves the <code>hotfix</code> branch backwards by two commits.
<code>git checkout hotfix git reset HEAD~2</code>
The two commits that were on the end of <code>hotfix</code> are now dangling, or orphaned commits. 
This means they will be deleted the next time Git performs a garbage collection. 

In other words, you’re saying that you want to throw away these commits. 
This can be visualized as the following:
<img src="https://wac-cdn.atlassian.com/dam/jcr:e8a43261-2460-4783-9731-1197dc8959ab/03-04%20Reset%20a%20specific%20commit.png?cdnVersion=217" loading="lazy" alt="Resetting the hotfix branch to HEAD-2">This usage of <code>git reset</code> is a simple way to undo changes that haven’t been shared with anyone else. 
It’s your go-to command when you’ve started working on a feature and find yourself thinking, “Oh crap, what am I doing? I should just start over.”

In addition to moving the current branch, you can also get <code>git reset</code> to alter the staged snapshot and/or the working directory by passing it one of the following flags:
<code>--soft</code> – The staged snapshot and working directory are not altered in any way.
<code>--mixed</code> – The staged snapshot is updated to match the specified commit, but the working directory is not affected. 
This is the default option.

<code>--hard</code> – The staged snapshot and the working directory are both updated to match the specified commit.
It’s easier to think of these modes as defining the scope of a <code>git reset</code> operation. 
For further detailed information visit the <code><a href="/git/tutorials/undoing-changes/git-reset" data-event="clicked" data-uuid="22b21bf5-d6" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git reset</a></code> page.
<h3>&emsp;Checkout old commits</h3>

The <code>git checkout</code> command is used to update the state of the repository to a specific point in the projects history. 
When passed with a branch name, it lets you switch between branches.
<code>git checkout hotfix</code>
Internally, all the above command does is move <code>HEAD</code> to a different branch and update the working directory to match. 

Since this has the potential to overwrite local changes, Git forces you to commit or <a href="/git/tutorials/saving-changes/git-stash" data-event="clicked" data-uuid="20a3cd14-b4" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">stash</a> any changes in the working directory that will be lost during the checkout operation. 
Unlike <code>git reset</code>, <code>git checkout</code> doesn’t move any branches around.
<img src="https://wac-cdn.atlassian.com/dam/jcr:7dffc21e-29c6-4bfd-acd1-2965fcdd923e/05-06%20Checkout%20old%20commits.png?cdnVersion=217" loading="lazy" alt="Moving HEAD from master to hotfix">You can also check out arbitrary commits by passing the commit reference instead of a branch. 
This does the exact same thing as checking out a branch: it moves the <code>HEAD</code> reference to the specified commit. 

For example, the following command will check out the grandparent of the current commit:
<code>git checkout HEAD~2</code>
<img src="https://wac-cdn.atlassian.com/dam/jcr:9b4d9562-7ed1-441c-bbd1-1897bea5676e/07.svg?cdnVersion=217" loading="lazy" alt="Moving `HEAD` to an arbitrary commit">This is useful for quickly inspecting an old version of your project. 
However, since there is no branch reference to the current <code>HEAD</code>, this puts you in a detached <code>HEAD</code> state. 

This can be dangerous if you start adding new commits because there will be no way to get back to them after you switch to another branch. 
For this reason, you should always create a new branch before adding commits to a detached <code>HEAD</code>.
<h3>&emsp;Undo Public Commits with Revert</h3>
Reverting undoes a commit by creating a new commit. 

This is a safe way to undo changes, as it has no chance of re-writing the commit history. 
For example, the following command will figure out the changes contained in the 2nd to last commit, create a new commit undoing those changes, and tack the new commit onto the existing project.
<code>git checkout hotfix git revert HEAD~2</code>
This can be visualized as the following:

<img src="https://wac-cdn.atlassian.com/dam/jcr:f02c67ca-d7b8-47f8-98f8-e0017dc9f7c5/08-09%20Undo%20public%20commits.svg?cdnVersion=217" loading="lazy" alt="Reverting the 2nd to last commit">Contrast this with <code>git reset</code>, which <em>does</em> alter the existing commit history. 
For this reason, <code>git revert</code> should be used to undo changes on a public branch, and <code>git reset</code> should be reserved for undoing changes on a private branch.
You can also think of <code>git revert</code> as a tool for undoing <em>committed</em> changes, while <code>git reset HEAD</code> is for undoing <em>uncommitted</em> changes.
Like <code>git checkout</code>, <code>git revert</code> has the potential to overwrite files in the working directory, so it will ask you to commit or <a href="/git/tutorials/saving-changes/git-stash" data-event="clicked" data-uuid="824881fe-38" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">stash changes</a> that would be lost during the revert operation.
<h2><span class="saddlebrown">&emsp;File-level Operations</span></h2>
The <code>git reset</code> and <code>git checkout</code> commands also accept an optional file path as a parameter. 
This dramatically alters their behavior. 
Instead of operating on entire snapshots, this forces them to limit their operations to a single file.

<h3>&emsp;Git Reset A Specific File</h3>
When invoked with a file path, <code>git reset</code> updates the <em>staged snapshot</em> to match the version from the specified commit. 
For example, this command will fetch the version of <code>foo.py</code> in the 2nd-to-last commit and stage it for the next commit:
<code>git reset HEAD~2 foo.py</code>

As with the commit-level version of <code>git reset</code>, this is more commonly used with <code>HEAD</code> rather than an arbitrary commit. 
Running <code>git reset HEAD foo.py</code> will unstage <code>foo.py</code>. 
The changes it contains will still be present in the working directory.
<img src="https://wac-cdn.atlassian.com/dam/jcr:1a010f5a-c90d-49ee-a0e6-31054433e2d4/07.svg?cdnVersion=217" loading="lazy" alt="Moving a file from the commit history into the staged snapshot">The <code>--soft</code>, <code>--mixed</code>, and <code>--hard</code> flags do not have any effect on the file-level version of <code>git reset</code>, as the staged snapshot is <em>always</em> updated, and the working directory is <em>never</em> updated.

<h3>&emsp;Git Checkout File</h3>
Checking out a file is similar to using <code>git reset</code> with a file path, except it updates the <em>working directory</em> instead of the stage. 
Unlike the commit-level version of this command, this does not move the <code>HEAD</code> reference, which means that you won’t switch branches.
<img src="https://wac-cdn.atlassian.com/dam/jcr:cc252fc0-fc76-4740-8458-9c0d7af94bca/08.svg?cdnVersion=217" loading="lazy" alt="Moving a file from the commit history into the working directory">For example, the following command makes <code>foo.py</code> in the working directory match the one from the 2nd-to-last commit:

<code>git checkout HEAD~2 foo.py</code>
Just like the commit-level invocation of <code>git checkout</code>, this can be used to inspect old versions of a project—but the scope is limited to the specified file.
If you stage and commit the checked-out file, this has the effect of “reverting” to the old version of that file. 
Note that this removes <em>all</em> of the subsequent changes to the file, whereas the <code>git revert</code> command undoes only the changes introduced by the specified commit.

Like <code>git reset</code>, this is commonly used with <code>HEAD</code> as the commit reference. 
For instance, <code>git checkout HEAD foo.py</code> has the effect of discarding unstaged changes to <code>foo.py</code>. 
This is similar behavior to <code>git reset HEAD --hard</code>, but it operates only on the specified file.
<h2><span class="saddlebrown">&emsp;Summary</span></h2>
You should now have all the tools you could ever need to undo changes in a Git repository. 
The <code><a href="/git/tutorials/undoing-changes/git-reset" data-event="clicked" data-uuid="9637776c-fe" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git reset</a></code>, <code><a href="/git/tutorials/using-branches/git-checkout" data-event="clicked" data-uuid="9637776c-fe" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git checkout</a></code>, and <code><a href="/git/tutorials/undoing-changes/git-revert" data-event="clicked" data-uuid="9637776c-fe" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git revert</a></code> commands can be confusing, but when you think about their effects on the working directory, staged snapshot, and commit history, it should be easier to discern which command fits the development task at hand.
<h2><br><span class="orange">Advanced Git log</span></h2>
The purpose of any version control system is to record changes to your code. 

This gives you the power to go back into your project history to see who contributed what, figure out where bugs were introduced, and revert problematic changes. 
But, having all of this history available is useless if you don’t know how to navigate it. 
That’s where the git log command comes in.
By now, you should already know the basic git log command for displaying commits. 

But, you can alter this output by passing many different parameters to git log.
The advanced features of git log can be split into two categories: formatting how each commit is displayed, and filtering which commits are included in the output. 
Together, these two skills give you the power to go back into your project and find any information that you could possibly need.
<h2><span class="saddlebrown">&emsp;Formatting Log Output</span></h2>
First, this article will take a look at the many ways in which <code>git log</code>’s output can be formatted. 
Most of these come in the form of flags that let you request more or less information from <code>git log</code>.
If you don’t like the default <code>git log</code> format, you can use <code>git config</code>’s aliasing functionality to create a shortcut for any of the formatting options discussed below. 
Please see in <a href="https://www.atlassian.com/git/tutorials/setting-up-a-repository#git-config" data-event="clicked" data-uuid="7c57ed0a-48" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">The git config Command</a> for how to set up an alias.

<h3>&emsp;Oneline</h3>
The <code>--oneline</code> flag condenses each commit to a single line. 
By default, it displays only the commit ID and the first line of the commit message. 
Your typical <code>git log --oneline</code> output will look something like this:

<code>0e25143 Merge branch 'feature'
ad8621a Fix a bug in the feature
16b36c6 Add a new feature
23ad9ad Add the initial code base</code>

This is very useful for getting a high-level overview of your project.
<h3>&emsp;Decorating</h3>
Many times it’s useful to know which branch or tag each commit is associated with. 
The <code>--decorate</code> flag makes <code>git log</code> display all of the references (e.g., branches, tags, etc) that point to each commit.

This can be combined with other configuration options. 
For example, running <code>git log --oneline --decorate</code> will format the commit history like so:
<code>0e25143 (HEAD, main) Merge branch 'feature'
ad8621a (feature) Fix a bug in the feature

16b36c6 Add a new feature
23ad9ad (tag: v0.9) Add the initial code base</code>
This lets you know that the top commit is also checked out (denoted by <code>HEAD</code>) and that it is also the tip of the <code>main</code> branch. 
The second commit has another branch pointing to it called <code>feature</code>, and finally the 4th commit is tagged as <code>v0.9</code>.

Branches, tags, <code>HEAD</code>, and the commit history are almost all of the information contained in your Git repository, so this gives you a more complete view of the logical structure of your repository.
<h3>&emsp;Diffs</h3>
The <code>git log</code> command includes many options for displaying diffs with each commit. 
Two of the most common options are <code>--stat</code> and <code>-p</code>.

The <code>--stat</code> option displays the number of insertions and deletions to each file altered by each commit (note that modifying a line is represented as 1 insertion and 1 deletion). 
This is useful when you want a brief summary of the changes introduced by each commit. 
For example, the following commit added 67 lines to the <code>hello.py</code> file and removed 38 lines:
<code>commit f2a238924e89ca1d4947662928218a06d39068c3

Author: John &lt;john@example.com>
Date:   Fri Jun 25 17:30:28 2014 -0500
Add a new feature
hello.py | 105 ++++++++++++++++++++++++-----------------

1 file changed, 67 insertion(+), 38 deletions(-)</code>
The amount of <code>+</code> and <code>-</code> signs next to the file name show the relative number of changes to each file altered by the commit. 
This gives you an idea of where the changes for each commit can be found.
If you want to see the actual changes introduced by each commit, you can pass the <code>-p</code> option to <code>git log</code>. 

This outputs the entire patch representing that commit:
<code>commit 16b36c697eb2d24302f89aa22d9170dfe609855b
Author: Mary &lt;mary@example.com>
Date:   Fri Jun 25 17:31:57 2014 -0500

Fix a bug in the feature
diff --git a/hello.py b/hello.py
index 18ca709..c673b40 100644
--- a/hello.py

+++ b/hello.py
@@ -13,14 +13,14 @@ B
-print("Hello, World!")
+print("Hello, Git!")</code>

For commits with a lot of changes, the resulting output can become quite long and unwieldy. 
More often than not, if you’re displaying a full patch, you’re probably searching for a specific change. 
For this, you want to use the pickaxe option.
<h3>&emsp;The Shortlog</h3>

The <code>git shortlog</code> command is a special version of <code>git log</code> intended for creating release announcements. 
It groups each commit by author and displays the first line of each commit message. 
This is an easy way to see who’s been working on what.
For example, if two developers have contributed 5 commits to a project, the <code>git shortlog</code> output might look like the following:

<code>Mary (2):
  Fix a bug in the feature
  Fix a serious security hole in our framework
John (3):

  Add the initial code base
  Add a new feature
  Merge branch 'feature'</code>
By default, <code>git shortlog</code> sorts the output by author name, but you can also pass the <code>-n</code> option to sort by the number of commits per author.

<h3>&emsp;Graphs</h3>
The <code>--graph</code> option draws an ASCII graph representing the branch structure of the commit history. 
This is commonly used in conjunction with the <code>--oneline</code> and <code>--decorate</code> commands to make it easier to see which commit belongs to which branch:
<code>git log --graph --oneline --decorate</code>

For a simple repository with just 2 branches, this will produce the following:
<code>*   0e25143 (HEAD, main) Merge branch 'feature'
|\  
| * 16b36c6 Fix a bug in the new feature

| * 23ad9ad Start a new feature
* | ad8621a Fix a critical security issue
|/  
* 400e4b7 Fix typos in the documentation

* 160e224 Add the initial code base</code>
The asterisk shows which branch the commit was on, so the above graph tells us that the <code>23ad9ad</code> and <code>16b36c6</code> commits are on a topic branch and the rest are on the <code>main</code> branch.
While this is a nice option for simple repositories, you’re probably better off with a more full-featured visualization tool like <code>gitk</code> or <a href="/software/sourcetree" data-event="clicked" data-uuid="b50d3c1e-a4" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Sourcetree</a> for projects that are heavily branched.
<h3>&emsp;Custom Formatting</h3>

For all of your other <code>git log</code> formatting needs, you can use the <code>--pretty=format:"<string>"</string></code> option. 
This lets you display each commit however you want using <code>printf</code>-style placeholders.
For example, the <code>%cn</code>, <code>%h</code> and <code>%cd</code> characters in the following command are replaced with the committer name, abbreviated commit hash, and the committer date, respectively.
<code>git log --pretty=format:"%cn committed %h on %cd"</code>

This results in the following format for each commit:
<code>John committed 400e4b7 on Fri Jun 24 12:30:04 2014 -0500 John committed 89ab2cf on Thu Jun 23 17:09:42 2014 -0500 Mary committed 180e223 on Wed Jun 22 17:21:19 2014 -0500 John committed f12ca28 on Wed Jun 22 13:50:31 2014 -0500</code>
The complete list of placeholders can be found in the <a href="https://www.kernel.org/pub/software/scm/git/docs/git-log.html#_pretty_formats" data-event="clicked" data-uuid="2a7932fb-18" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Pretty Formats</a> section of the <code>git log</code> manual page.
Aside from letting you view only the information that you’re interested in, the <code>--pretty=format:"<string>"</string></code> option is particularly useful when you’re trying to pipe <code>git log</code> output into another command.
<h2><span class="saddlebrown">&emsp;Filtering the Commit History</span></h2>
Formatting how each commit gets displayed is only half the battle of learning <code>git log</code>. 
The other half is understanding how to navigate the commit history. 
The rest of this article introduces some of the advanced ways to pick out specific commits in your project history using <code>git log</code>. 

All of these can be combined with any of the formatting options discussed above.
<h3>&emsp;By Amount</h3>
The most basic filtering option for <code>git log</code> is to limit the number of commits that are displayed. 
When you’re only interested in the last few commits, this saves you the trouble of viewing all the commits in a page.

You can limit <code>git log</code>’s output by including the <code>-<n></n></code> option. 
For example, the following command will display only the 3 most recent commits.
<code>git log -3</code>
<h3>&emsp;By Date</h3>

If you’re looking for a commit from a specific time frame, you can use the <code>--after</code> or <code>--before</code> flags for filtering commits by date. 
These both accept a variety of date formats as a parameter. 
For example, the following command only shows commits that were created <em>after</em> July 1st, 2014 (inclusive):
<code>git log --after="2014-7-1"</code>

You can also pass in relative references like <code>"1 week ago"</code> and <code>"yesterday"</code>:
<code>git log --after="yesterday"</code>
To search for a commits that were created between two dates, you can provide both a <code>--before</code> and <code>--after</code> date. 
For instance, to display all the commits added between July 1st, 2014 and July 4th, 2014, you would use the following:

<code>git log --after="2014-7-1" --before="2014-7-4"</code>
Note that the <code>--since</code> and <code>--until</code> flags are synonymous with <code>--after</code> and <code>--before</code>, respectively.
<h3>&emsp;By Author</h3>
When you’re only looking for commits created by a particular user, use the <code>--author</code> flag. 

This accepts a regular expression, and returns all commits whose author matches that pattern. 
If you know exactly who you’re looking for, you can use a plain old string instead of a regular expression:
<code>git log --author="John"</code>
This displays all commits whose author includes the name <em>John</em>. 

The author name doesn’t need to be an <em>exact</em> match—it just needs to <em>contain</em> the specified phrase.
You can also use regular expressions to create more complex searches. 
For example, the following command searches for commits by either <em>Mary</em> or <em>John</em>.
<code>git log --author="John\|Mary"</code>

Note that the author’s email is also included with the author’s name, so you can use this option to search by email, too.
If your workflow separates committers from authors, the <code>--committer</code> flag operates in the same fashion.
<h3>&emsp;By Message</h3>
To filter commits by their commit message, use the <code>--grep</code> flag. 

This works just like the <code>--author</code> flag discussed above, but it matches against the commit message instead of the author.
For example, if your team includes relevant issue numbers in each commit message, you can use something like the following to pull out all of the commits related to that issue:
<code>git log --grep="JRA-224:"</code>
You can also pass in the <code>-i</code> parameter to <code>git log</code> to make it ignore case differences while pattern matching.

<h3>&emsp;By File</h3>
Many times, you’re only interested in changes that happened to a particular file. 
To show the history related to a file, all you have to do is pass in the file path. 
For example, the following returns all commits that affected either the <code>foo.py</code> or the <code>bar.py</code> file:

<code>git log -- foo.py bar.py</code>
The <code>--</code> parameter is used to tell <code>git log</code> that subsequent arguments are file paths and not branch names. 
If there’s no chance of mixing it up with a branch, you can omit the <code>--</code>.
<h3>&emsp;By Content</h3>

It’s also possible to search for commits that introduce or remove a particular line of source code. 
This is called a <em>pickaxe</em>, and it takes the form of <code>-S"<string>"</string></code>. 
For example, if you want to know when the string <em>Hello, World!</em> was added to any file in the project, you would use the following command:
<code>git log -S"Hello, World!"</code>

If you want to search using a regular expression instead of a string, you can use the <code>-G"<regex>"</regex></code> flag instead.
This is a very powerful debugging tool, as it lets you locate all of the commits that affect a particular line of code. 
It can even show you when a line was copied or moved to another file.
<h3>&emsp;By Range</h3>

You can pass a range of commits to <code>git log</code> to show only the commits contained in that range. 
The range is specified in the following format, where <code><since></since></code> and <code><until></until></code> are commit references:
<code>git log <since>..<until></until></since></code>
This command is particularly useful when you use branch references as the parameters. 

It’s a simple way to show the differences between 2 branches. 
Consider the following command:
<code>git log main..feature</code>
The <code>main..feature</code> range contains all of the commits that are in the <code>feature</code> branch, but aren’t in the <code>main</code> branch. 

In other words, this is how far <code>feature</code> has progressed since it forked off of <code>main</code>. 
You can visualize this as follows:
<img src="https://wac-cdn.atlassian.com/dam/jcr:9c5a06e5-bd01-40b8-8c46-34190edfb2cb/01%20By%20Range.svg?cdnVersion=217" loading="lazy" alt="Detecting a fork in the history using ranges">Note that if you switch the order of the range (<code>feature..main</code>), you will get all of the commits in <code>main</code>, but not in <code>feature</code>. 
If <code>git log</code> outputs commits for both versions, this tells you that your history has diverged.

<h3>&emsp;Filtering Merge Commits</h3>
By default, <code>git log</code> includes merge commits in its output. 
But, if your team has an always-merge policy (that is, you merge upstream changes into topic branches instead of rebasing the topic branch onto the upstream branch), you’ll have a lot of extraneous merge commits in your project history.
You can prevent <code>git log</code> from displaying these merge commits by passing the <code>--no-merges</code> flag:

<code>git log --no-merges</code>
On the other hand, if you’re <em>only</em> interested in the merge commits, you can use the <code>--merges</code> flag:
<code>git log --merges</code>
This returns all commits that have at least two parents.
<h2><span class="saddlebrown">&emsp;Summary</span></h2>
You should now be fairly comfortable using <code>git log</code>’s advanced parameters to format its output and select which commits you want to display. 
This gives you the power to pull out exactly what you need from your project history.
These new skills are an important part of your Git toolkit, but remember that <code>git log</code> is often used in conjunction other Git commands. 

Once you’ve found the commit you’re looking for, you typically pass it off to <code>git checkout</code>, <code>git revert</code>, or some other tool for manipulating your commit history. 
So, be sure to keep on learning about Git’s advanced features.
<h2><br><span class="orange">Git Hooks</span></h2>
Git hooks are scripts that run automatically every time a particular event occurs in a Git repository. 

They let you customize Git’s internal behavior and trigger customizable actions at key points in the development life cycle.
<img src="https://wac-cdn.atlassian.com/dam/jcr:ac22adee-d740-4216-a92a-33c14b5623e5/01.svg?cdnVersion=217" loading="lazy" alt="Hooks executing during the commit creation process">Common use cases for Git hooks include encouraging a commit policy, altering the project environment depending on the state of the repository, and implementing continuous integration workflows. 
But, since scripts are infinitely customizable, you can use Git hooks to automate or optimize virtually any aspect of your development workflow.
In this article, we’ll start with a conceptual overview of how Git hooks work. 

Then, we’ll survey some of the most popular hooks for use in both local and server-side repositories.
<h2><span class="saddlebrown">&emsp;Conceptual Overview</span></h2>
All Git hooks are ordinary scripts that Git executes when certain events occur in the repository. 
This makes them very easy to install and configure.

Hooks can reside in either local or server-side repositories, and they are only executed in response to actions in that repository. 
We’ll take a concrete look at categories of hooks later in this article. 
The configuration discussed in the rest of this section applies to both local and server-side hooks.
<h3>&emsp;Installing Hooks</h3>

Hooks reside in the <code>.git/hooks</code> directory of every Git repository. 
Git automatically populates this directory with example scripts when you initialize a repository. 
If you take a look inside <code>.git/hooks</code>, you’ll find the following files:
<code>applypatch-msg.sample       pre-push.sample

commit-msg.sample           pre-rebase.sample
post-update.sample          prepare-commit-msg.sample
pre-applypatch.sample       update.sample
pre-commit.sample</code>

These represent most of the available hooks, but the <code>.sample</code> extension prevents them from executing by default. 
To “install” a hook, all you have to do is remove the <code>.sample</code> extension. 
Or, if you’re writing a new script from scratch, you can simply add a new file matching one of the above filenames, minus the <code>.sample</code> extension.
As an example, try installing a simple <code>prepare-commit-msg</code> hook. 

Remove the <code>.sample</code> extension from this script, and add the following to the file:
<code>#!/bin/sh
echo "# Please include a useful commit message!" > $1</code>
Hooks need to be executable, so you may need to change the file permissions of the script if you’re creating it from scratch. 

For example, to make sure that <code>prepare-commit-msg</code> is executable, you would run the following command:
<code>chmod +x prepare-commit-msg</code>
You should now see this message in place of the default commit message every time you run <code>git commit</code>. 
We’ll take a closer look at how this actually works in the Prepare Commit Message section. 

For now, let’s just revel in the fact that we can customize some of Git’s internal functionality.
The built-in sample scripts are very useful references, as they document the parameters that are passed in to each hook (they vary from hook to hook).
<h3>&emsp;Scripting Languages</h3>
The built-in scripts are mostly shell and PERL scripts, but you can use any scripting language you like as long as it can be run as an executable. 

The shebang line (<code>#!/bin/sh</code>) in each script defines how your file should be interpreted. 
So, to use a different language, all you have to do is change it to the path of your interpreter.
For instance, we can write an executable Python script in the <code>prepare-commit-msg</code> file instead of using shell commands. 
The following hook will do the same thing as the shell script in the previous section.

<code>#!/usr/bin/env python
import sys, os
commit_msg_filepath = sys.argv[1]
with open(commit_msg_filepath, 'w') as f:

f.write("# Please include a useful commit message!")</code>
Notice how the first line changed to point to the Python interpreter. 
And, instead of using <code>$1</code> to access the first argument passed to the script, we used <code>sys.argv[1]</code> (again, more on this in a moment).
This is a very powerful feature for Git hooks because it lets you work in whatever language you’re most comfortable with.

<h3>&emsp;Scope of Hooks</h3>
Hooks are local to any given Git repository, and they are <em>not</em> copied over to the new repository when you run <code>git clone</code>. 
And, since hooks are local, they can be altered by anybody with access to the repository.
This has an important impact when configuring hooks for a team of developers. 

First, you need to find a way to make sure hooks stay up-to-date amongst your team members. 
Second, you can’t force developers to create commits that look a certain way—you can only encourage them to do so.
Maintaining hooks for a team of developers can be a little tricky because the <code>.git/hooks</code> directory isn’t cloned with the rest of your project, nor is it under version control. 
A simple solution to both of these problems is to store your hooks in the actual project directory (above the <code>.git</code> directory). 

This lets you edit them like any other version-controlled file. 
To install the hook, you can either create a symlink to it in <code>.git/hooks</code>, or you can simply copy and paste it into the <code>.git/hooks</code> directory whenever the hook is updated.
<img src="https://wac-cdn.atlassian.com/dam/jcr:e068ea71-a552-4d07-9917-49104f4d382e/02.svg?cdnVersion=217" loading="lazy" alt="Hooks executing during the commit creation process">As an alternative, Git also provides a <a href="http://git-scm.com/docs/git-init#_template_directory" data-event="clicked" data-uuid="9653aa05-69" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Template Directory</a> mechanism that makes it easier to install hooks automatically. 
All of the files and directories contained in this template directory are copied into the <code>.git</code> directory every time you use <code>git init</code> or <code>git clone</code>.

All of the <a href="/git/tutorials/git-hooks" data-event="clicked" data-uuid="42b74930-77" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">local hooks</a> described below can be altered—or completely un-installed—by the owner of a repository. 
It’s entirely up to each team member whether or not they actually use a hook. 
With this in mind, it’s best to think of Git hooks as a convenient developer tool rather than a strictly enforced development policy.
That said, it is possible to reject commits that do not conform to some standard using server-side hooks. 

We’ll talk more about this later in the article.
<h2><span class="saddlebrown">&emsp;Local Hooks</span></h2>
Local hooks affect only the repository in which they reside. 
As you read through this section, remember that each developer can alter their own local hooks, so you can’t use them as a way to enforce a commit policy. 

They can, however, make it much easier for developers to adhere to certain guidelines.
In this section, we’ll be exploring 6 of the most useful local hooks:
<code>pre-commit</code>
<code>prepare-commit-msg</code>

<code>commit-msg</code>
<code>post-commit</code>
<code>post-checkout</code>
<code>pre-rebase</code>

The first 4 hooks let you plug into the entire commit life cycle, and the final 2 let you perform some extra actions or safety checks for the <code>git checkout</code> and <code>git rebase</code> commands, respectively.
All of the <code>pre-</code> hooks let you alter the action that’s about to take place, while the <code>post-</code> hooks are used only for notifications.
We’ll also see some useful techniques for parsing hook arguments and requesting information about the repository using lower-level Git commands.
<h3>&emsp;Pre-Commit</h3>

The <code>pre-commit</code> script is executed every time you run <code>git commit</code> before Git asks the developer for a commit message or generates a commit object. 
You can use this hook to inspect the snapshot that is about to be committed. 
For example, you may want to run some automated tests that make sure the commit doesn’t break any existing functionality.
No arguments are passed to the <code>pre-commit</code> script, and exiting with a non-zero status aborts the entire commit. 

Let’s take a look at a simplified (and more verbose) version of the built-in <code>pre-commit</code> hook. 
This script aborts the commit if it finds any whitespace errors, as defined by the <code>git diff-index</code> command (trailing whitespace, lines with only whitespace, and a space followed by a tab inside the initial indent of a line are considered errors by default).
<code>#!/bin/sh
# Check if this is the initial commit

if git rev-parse --verify HEAD >/dev/null 2>&amp;1
then
echo "pre-commit: About to create a new commit..."
against=HEAD

else
echo "pre-commit: About to create the first commit..."
against=4b825dc642cb6eb9a060e54bf8d69288fbee4904
fi

# Use git diff-index to check for whitespace errors
echo "pre-commit: Testing for whitespace errors..."
if ! git diff-index --check --cached $against
then

echo "pre-commit: Aborting commit due to whitespace errors"
exit 1
else
echo "pre-commit: No whitespace errors :)"

exit 0
fi</code>
In order to use <code>git diff-index</code>, we need to figure out which commit reference we’re comparing the index to. 
Normally, this is <code>HEAD</code>; however, <code>HEAD</code> doesn’t exist when creating the initial commit, so our first task is to account for this edge case. 

We do this with <a href="https://www.kernel.org/pub/software/scm/git/docs/git-rev-parse.html" data-event="clicked" data-uuid="9cadf1a7-b6" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket"><code>git rev-parse --verify</code></a>, which simply checks whether or not the argument (<code>HEAD</code>) is a valid reference. 
The <code>>/dev/null 2>&amp;1</code> portion silences any output from <code>git rev-parse</code>. 
Either <code>HEAD</code> or an empty commit object is stored in the <code>against</code> variable for use with <code>git diff-index</code>. 
The <code>4b825d...</code> hash is a magic commit ID that represents an empty commit.

The <a href="http://www.kernel.org/pub/software/scm/git/docs/git-diff-index.html" data-event="clicked" data-uuid="87f652af-39" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket"><code>git diff-index --cached</code></a> command compares a commit against the index. 
By passing the <code>--check</code> option, we’re asking it to warn us if the changes introduces whitespace errors. 
If it does, we abort the commit by returning an exit status of <code>1</code>, otherwise we exit with <code>0</code> and the commit workflow continues as normal.
This is just one example of the <code>pre-commit</code> hook. 

It happens to use existing Git commands to run tests on the changes introduced by the proposed commit, but you can do anything you want in <code>pre-commit</code> including executing other scripts, running a 3rd-party test suite, or checking code style with Lint.
<h3>&emsp;Prepare Commit Message</h3>
The <code>prepare-commit-msg</code> hook is called after the <code>pre-commit</code> hook to populate the text editor with a commit message. 
This is a good place to alter the automatically generated commit messages for squashed or merged commits.

One to three arguments are passed to the <code>prepare-commit-msg</code> script:
The name of a temporary file that contains the message. 
You change the commit message by altering this file in-place.
The type of commit. 

This can be <code>message</code> (<code>-m</code> or <code>-F</code> option), <code>template</code> (<code>-t</code> option), <code>merge</code> (if the commit is a merge commit), or <code>squash</code> (if the commit is squashing other commits).
The SHA1 hash of the relevant commit. 
Only given if <code>-c</code>, <code>-C</code>, or <code>--amend</code> option was given.
As with <code>pre-commit</code>, exiting with a non-zero status aborts the commit.

We already saw a simple example that edited the commit message, but let’s take a look at a more useful script. 
When using an issue tracker, a common convention is to address each issue in a separate branch. 
If you include the issue number in the branch name, you can write a <code>prepare-commit-msg</code> hook to automatically include it in each commit message on that branch.
<code>#!/usr/bin/env python

import sys, os, re
from subprocess import check_output
# Collect the parameters
commit_msg_filepath = sys.argv[1]

if len(sys.argv) > 2:
commit_type = sys.argv[2]
else:
commit_type = ''

if len(sys.argv) > 3:
commit_hash = sys.argv[3]
else:
commit_hash = ''

print "prepare-commit-msg: File: %s\nType: %s\nHash: %s" % (commit_msg_filepath, commit_type, commit_hash)
# Figure out which branch we're on
branch = check_output(['git', 'symbolic-ref', '--short', 'HEAD']).strip()
print "prepare-commit-msg: On branch '%s'" % branch

# Populate the commit message with the issue #, if there is one
if branch.startswith('issue-'):
print "prepare-commit-msg: Oh hey, it's an issue branch."
result = re.match('issue-(.*)', branch)

issue_number = result.group(1)
with open(commit_msg_filepath, 'r+') as f:
    content = f.read()
    f.seek(0, 0)

    f.write("ISSUE-%s %s" % (issue_number, content))</code>
First, the above <code>prepare-commit-msg</code> hook shows you how to collect all of the parameters that are passed to the script. 
Then, it calls <code>git symbolic-ref --short HEAD</code> to get the branch name that corresponds to <code>HEAD</code>. 
If this branch name starts with <code>issue-</code>, it re-writes the commit message file contents to include the issue number in the first line. 

So, if your branch name is <code>issue-224</code>, this will generate the following commit message.
<code>ISSUE-224 
# Please enter the commit message for your changes. 
Lines starting 

# with '#' will be ignored, and an empty message aborts the commit. 
# On branch issue-224 
# Changes to be committed: 
#   modified:   test.txt</code>

One thing to keep in mind when using <code>prepare-commit-msg</code> is that it runs even when the user passes in a message with the <code>-m</code> option of <code>git commit</code>. 
This means that the above script will automatically insert the <code>ISSUE-[#]</code> string without letting the user edit it. 
You can handle this case by seeing if the 2nd parameter (<code>commit_type</code>) is equal to <code>message</code>.
However, without the <code>-m</code> option, the <code>prepare-commit-msg</code> hook does allow the user to edit the message after its generated, so this is really more of a convenience script than a way to enforce a commit message policy. 

For that, you need the <code>commit-msg</code> hook discussed in the next section.
<h3>&emsp;Commit Message</h3>
The <code>commit-msg</code> hook is much like the <code>prepare-commit-msg</code> hook, but it’s called <em>after</em> the user enters a commit message. 
This is an appropriate place to warn developers that their message doesn’t adhere to your team’s standards.

The only argument passed to this hook is the name of the file that contains the message. 
If it doesn’t like the message that the user entered, it can alter this file in-place (just like with <code>prepare-commit-msg</code>) or it can abort the commit entirely by exiting with a non-zero status.
For example, the following script checks to make sure that the user didn’t delete the <code>ISSUE-[#]</code> string that was automatically generated by the <code>prepare-commit-msg</code> hook in the previous section.
<code>#!/usr/bin/env python

import sys, os, re
from subprocess import check_output
# Collect the parameters
commit_msg_filepath = sys.argv[1]

# Figure out which branch we're on
branch = check_output(['git', 'symbolic-ref', '--short', 'HEAD']).strip()
print "commit-msg: On branch '%s'" % branch
# Check the commit message if we're on an issue branch

if branch.startswith('issue-'):
print "commit-msg: Oh hey, it's an issue branch."
result = re.match('issue-(.*)', branch)
issue_number = result.group(1)

required_message = "ISSUE-%s" % issue_number
with open(commit_msg_filepath, 'r') as f:
    content = f.read()
    if not content.startswith(required_message):

        print "commit-msg: ERROR! The commit message must start with '%s'" % required_message
        sys.exit(1)</code>
While this script is called every time the user creates a commit, you should avoid doing much outside of checking the commit message. 
If you need to notify other services that a snapshot was committed, you should use the <code>post-commit</code> hook instead.

<h3>&emsp;Post-Commit</h3>
The <code>post-commit</code> hook is called immediately after the <code>commit-msg</code> hook. 
It can’t change the outcome of the <code>git commit</code> operation, so it’s used primarily for notification purposes.
The script takes no parameters and its exit status does not affect the commit in any way. 

For most <code>post-commit</code> scripts, you’ll want access to the commit that was just created. 
You can use <code>git rev-parse HEAD</code> to get the new commit’s SHA1 hash, or you can use <code>git log -1 HEAD</code> to get all of its information.
For example, if you want to email your boss every time you commit a snapshot (probably not the best idea for most workflows), you could add the following <code>post-commit</code> hook.
<code>#!/usr/bin/env python

import smtplib
from email.mime.text import MIMEText
from subprocess import check_output
# Get the git log --stat entry of the new commit

log = check_output(['git', 'log', '-1', '--stat', 'HEAD'])
# Create a plaintext email message
msg = MIMEText("Look, I'm actually doing some work:\n\n%s" % log)
msg['Subject'] = 'Git post-commit hook notification'

msg['From'] = 'mary@example.com'
msg['To'] = 'boss@example.com'
# Send the message
SMTP_SERVER = 'smtp.example.com'

SMTP_PORT = 587
session = smtplib.SMTP(SMTP_SERVER, SMTP_PORT)
session.ehlo()
session.starttls()

session.ehlo()
session.login(msg['From'], 'secretPassword')
session.sendmail(msg['From'], msg['To'], msg.as_string())
session.quit()</code>

It’s possible to use <code>post-commit</code> to trigger a local continuous integration system, but most of the time you’ll want to be doing this in the <code>post-receive</code> hook. 
This runs on the server instead of the user’s local machine, and it also runs every time <em>any</em> developer pushes their code. 
This makes it a much more appropriate place to perform your continuous integration.
<h3>&emsp;Post-Checkout</h3>

The <code>post-checkout</code> hook works a lot like the <code>post-commit</code> hook, but it’s called whenever you successfully check out a reference with <code>git checkout</code>. 
This is nice for clearing out your working directory of generated files that would otherwise cause confusion.
This hook accepts three parameters, and its exit status has no affect on the <code>git checkout</code> command.
The ref of the previous HEAD

The ref of the new HEAD
A flag telling you if it was a branch checkout or a file checkout. 
The flag will be <code>1</code> and <code>0</code>, respectively.
A common problem with Python developers occurs when generated <code>.pyc</code> files stick around after switching branches. 

The interpreter sometimes uses these <code>.pyc</code> instead of the <code>.py</code> source file. 
To avoid any confusion, you can delete all <code>.pyc</code> files every time you check out a new branch using the following <code>post-checkout</code> script:
<code>#!/usr/bin/env python
import sys, os, re

from subprocess import check_output
# Collect the parameters
previous_head = sys.argv[1]
new_head = sys.argv[2]

is_branch_checkout = sys.argv[3]
if is_branch_checkout == "0":
print "post-checkout: This is a file checkout. 
Nothing to do."

sys.exit(0)
print "post-checkout: Deleting all '.pyc' files in working directory"
for root, dirs, files in os.walk('.'):
for filename in files:

    ext = os.path.splitext(filename)[1]
    if ext == '.pyc':
        os.unlink(os.path.join(root, filename))</code>
The current working directory for hook scripts is always set to the root of the repository, so the <code>os.walk('.')</code> call iterates through every file in the repository. 

Then, we check its extension and delete it if it’s a <code>.pyc</code> file.
You can also use the <code>post-checkout</code> hook to alter your working directory based on which branch you have checked out. 
For example, you might use a <code>plugins</code> branch to store all of your plugins outside of the core codebase. 
If these plugins require a lot of binaries that other branches do not, you can selectively build them only when you’re on the <code>plugins</code> branch.

<h3>&emsp;Pre-Rebase</h3>
The <code>pre-rebase</code> hook is called before <code>git rebase</code> changes anything, making it a good place to make sure something terrible isn’t about to happen.
This hook takes 2 parameters: the upstream branch that the series was forked from, and the branch being rebased. 
The second parameter is empty when rebasing the current branch. 

To abort the rebase, exit with a non-zero status.
For example, if you want to completely disallow rebasing in your repository, you could use the following <code>pre-rebase</code> script:
<code>#!/bin/sh
# Disallow all rebasing

echo "pre-rebase: Rebasing is dangerous. 
Don't do it."
exit 1</code>
Now, every time you run <code>git rebase</code>, you’ll see this message:

<code>pre-rebase: Rebasing is dangerous. 
Don't do it.
The pre-rebase hook refused to rebase.</code>
For a more in-depth example, take a look at the included <code>pre-rebase.sample</code> script. 

This script is a little more intelligent about when to disallow rebasing. 
It checks to see if the topic branch that you’re trying to rebase has already been merged into the <code>next</code> branch (which is assumed to be the mainline branch). 
If it has, you’re probably going to get into trouble by rebasing it, so the script aborts the rebase.
<h2><span class="saddlebrown">&emsp;Server-side Hooks</span></h2>
Server-side hooks work just like local ones, except they reside in server-side repositories (e.g., a central repository, or a developer’s public repository). 
When attached to the official repository, some of these can serve as a way to enforce policy by rejecting certain commits.
There are 3 server-side hooks that we’ll be discussing in the rest of this article:
<code>pre-receive</code>

<code>update</code>
<code>post-receive</code>
All of these hooks let you react to different stages of the <code>git push</code> process.
The output from server-side hooks are piped to the client’s console, so it’s very easy to send messages back to the developer. 

But, you should also keep in mind that these scripts don’t return control of the terminal until they finish executing, so you should be careful about performing long-running operations.
<h3>&emsp;Pre-Receive</h3>
The <code>pre-receive</code> hook is executed every time somebody uses <code>git push</code> to push commits to the repository. 
It should always reside in the <em>remote</em> repository that is the destination of the push, not in the originating repository.

The hook runs before any references are updated, so it’s a good place to enforce any kind of development policy that you want. 
If you don’t like who is doing the pushing, how the commit message is formatted, or the changes contained in the commit, you can simply reject it. 
While you can’t stop developers from making malformed commits, you can prevent these commits from entering the official codebase by rejecting them with <code>pre-receive</code>.
The script takes no parameters, but each ref that is being pushed is passed to the script on a separate line on standard input in the following format:

<code>&lt;old-value> &lt;new-value> &lt;ref-name></code>
You can see how this hook works using a very basic <code>pre-receive</code> script that simply reads in the pushed refs and prints them out.
<code>#!/usr/bin/env python
import sys

import fileinput
# Read in each ref that the user is trying to update
for line in fileinput.input():
print "pre-receive: Trying to push ref: %s" % line

# Abort the push
# sys.exit(1)</code>
Again, this is a little different than the other hooks because information is passed to the script via standard input instead of as command-line arguments. 
After placing the above script in the <code>.git/hooks</code> directory of a remote repository and pushing the <code>main</code> branch, you’ll see something like the following in your console:

<code>b6b36c697eb2d24302f89aa22d9170dfe609855b 85baa88c22b52ddd24d71f05db31f4e46d579095 refs/heads/main</code>
You can use these SHA1 hashes, along with some lower-level Git commands, to inspect the changes that are going to be introduced. 
Some common use cases include:
Rejecting changes that involve an upstream rebase

Preventing non-fast-forward merges
Checking that the user has the correct permissions to make the intended changes (mostly used for centralized Git workflows)
If multiple refs are pushed, returning a non-zero status from <code>pre-receive</code> aborts <em>all</em> of them. 
If you want to accept or reject branches on a case-by-case basis, you need to use the <code>update</code> hook instead.

<h3>&emsp;Update</h3>
The <code>update</code> hook is called after <code>pre-receive</code>, and it works much the same way. 
It’s still called before anything is actually updated, but it’s called separately for each ref that was pushed. 
That means if the user tries to push 4 branches, <code>update</code> is executed 4 times. 

Unlike <code>pre-receive</code>, this hook doesn’t need to read from standard input. 
Instead, it accepts the following 3 arguments:
The name of the ref being updated
The old object name stored in the ref

The new object name stored in the ref
This is the same information passed to <code>pre-receive</code>, but since <code>update</code> is invoked separately for each ref, you can reject some refs while allowing others.
<code>#!/usr/bin/env python
import sys

branch = sys.argv[1]
old_commit = sys.argv[2]
new_commit = sys.argv[3]
print "Moving '%s' from %s to %s" % (branch, old_commit, new_commit)

# Abort pushing only this branch
# sys.exit(1)</code>
The above <code>update</code> hook simply outputs the branch and the old/new commit hashes. 
When pushing more than one branch to the remote repository, you’ll see the <code>print</code> statement execute for each branch.

<h3>&emsp;Post-Receive</h3>
The <code>post-receive</code> hook gets called after a successful push operation, making it a good place to perform notifications. 
For many workflows, this is a better place to trigger notifications than <code>post-commit</code> because the changes are available on a public server instead of residing only on the user’s local machine. 
Emailing other developers and triggering a continuous integration system are common use cases for <code>post-receive</code>.

The script takes no parameters, but is sent the same information as <code>pre-receive</code> via standard input.
<h2><span class="saddlebrown">&emsp;Summary</span></h2>
In this article, we learned how Git hooks can be used to alter internal behavior and receive notifications when certain events occur in a repository. 
Hooks are ordinary scripts that reside in the <code>.git/hooks</code> repository, which makes them very easy to install and customize.

We also looked at some of the most common local and server-side hooks. 
These let us plug in to the entire development life cycle. 
We now know how to perform customizable actions at every stage in the commit creation process, as well as the <code>git push</code> process. 
With a little bit of scripting knowledge, this lets you do virtually anything you can imagine with a Git repository.

<h2><br><span class="orange">Refs and the Reflog</span></h2>
Git is all about commits: you stage commits, create commits, view old commits, and transfer commits between repositories using many different Git commands. 
The majority of these commands operate on a commit in some form or another, and many of them accept a commit reference as a parameter. 
For example, you can use <code>git checkout</code> to view an old commit by passing in a commit hash, or you can use it to switch branches by passing in a branch name.

<img src="https://wac-cdn.atlassian.com/dam/jcr:bb02240a-7d85-4f5a-ae7f-c2727b37fc79/01%20Many%20ways%20of%20referring%20to%20a%20commit.svg?cdnVersion=217" loading="lazy" alt="Many ways of referring to a commit">By understanding the many ways to refer to a commit, you make all of these commands that much more powerful. 
In this chapter, we’ll shed some light on the internal workings of common commands like <code>git checkout</code>, <code>git branch</code>, and <code>git push</code> by exploring the many methods of referring to a commit.
We’ll also learn how to revive seemingly “lost” commits by accessing them through Git’s reflog mechanism.
<h2><span class="saddlebrown">&emsp;Hashes</span></h2>
The most direct way to reference a commit is via its SHA-1 hash. 
This acts as the unique ID for each commit. 
You can find the hash of all your commits in the <code>git log</code> output.
<code>commit 0c708fdec272bc4446c6cabea4f0022c2b616eba Author: Mary Johnson <mary> Date: Wed Jul 9 16:37:42 2014 -0500 Some commit message</mary></code>

When passing the commit to other Git commands, you only need to specify enough characters to uniquely identify the commit. 
For example, you can inspect the above commit with <code>git show</code> by running the following command:
<code>git show 0c708f</code>
It’s sometimes necessary to resolve a branch, tag, or another indirect reference into the corresponding commit hash. 

For this, you can use the <code>git rev-parse</code> command. 
The following returns the hash of the commit pointed to by the <code>main</code> branch:
<code>git rev-parse main</code>
This is particularly useful when writing custom scripts that accept a commit reference. 

Instead of parsing the commit reference manually, you can let <code>git rev-parse</code> normalize the input for you.
<h2><span class="saddlebrown">&emsp;Refs</span></h2>
A <strong>ref</strong> is an indirect way of referring to a commit. 
You can think of it as a user-friendly alias for a commit hash. 

This is Git’s internal mechanism of representing branches and tags.
Refs are stored as normal text files in the <code>.git/refs</code> directory, where <code>.git</code> is usually called <code>.git</code>. 
To explore the refs in one of your repositories, navigate to <code>.git/refs</code>. 
You should see the following structure, but it will contain different files depending on what branches, tags, and remotes you have in your repo:

<code>.git/refs/ heads/ main some-feature remotes/ origin/ main tags/ v0.9</code>
The <code>heads</code> directory defines all of the local branches in your repository. 
Each filename matches the name of the corresponding branch, and inside the file you’ll find a commit hash. 
This commit hash is the location of the tip of the branch. 

To verify this, try running the following two commands from the root of the Git repository:
<code># Output the contents of `refs/heads/main` file: cat .git/refs/heads/main # Inspect the commit at the tip of the `main` branch: git log -1 main</code>
The commit hash returned by the <code>cat</code> command should match the commit ID displayed by <code>git log</code>.
To change the location of the <code>main</code> branch, all Git has to do is change the contents of the <code>refs/heads/main</code> file. 

Similarly, creating a new branch is simply a matter of writing a commit hash to a new file. 
This is part of the reason why Git branches are so lightweight compared to SVN.
The <code>tags</code> directory works the exact same way, but it contains tags instead of branches. 
The <code>remotes</code> directory lists all remote repositories that you created with <code>git remote</code> as separate subdirectories. 

Inside each one, you’ll find all the remote branches that have been fetched into your repository.
<h3>&emsp;Specifying Refs</h3>
When passing a ref to a Git command, you can either define the full name of the ref, or use a short name and let Git search for a matching ref. 
You should already be familiar with short names for refs, as this is what you’re using each time you refer to a branch by name.

<code>git show some-feature</code>
The <code>some-feature</code> argument in the above command is actually a short name for the branch. 
Git resolves this to <code>refs/heads/some-feature</code> before using it. 
You can also specify the full ref on the command line, like so:

<code>git show refs/heads/some-feature</code>
This avoids any ambiguity regarding the location of the ref. 
This is necessary, for instance, if you had both a tag and a branch called <code>some-feature</code>. 
However, if you’re using proper naming conventions, ambiguity between tags and branches shouldn’t generally be a problem.

We’ll see more full ref names in the Refspecs section.
<h2><span class="saddlebrown">&emsp;Packed Refs</span></h2>
For large repositories, Git will periodically perform a garbage collection to remove unnecessary objects and compress refs into a single file for more efficient performance. 
You can force this compression with the garbage collection command:

<code>git gc</code>
This moves all of the individual branch and tag files in the <code>refs</code> folder into a single file called <code>packed-refs</code> located in the top of the <code>.git</code> directory. 
If you open up this file, you’ll find a mapping of commit hashes to refs:
<code>00f54250cf4e549fdfcafe2cf9a2c90bc3800285 refs/heads/feature 0e25143693cfe9d5c2e83944bbaf6d3c4505eb17 refs/heads/main bb883e4c91c870b5fed88fd36696e752fb6cf8e6 refs/tags/v0.9</code>

On the outside, normal Git functionality won’t be affected in any way. 
But, if you’re wondering why your <code>.git/refs</code> folder is empty, this is where the refs went.
<h2><span class="saddlebrown">&emsp;Special Refs</span></h2>
In addition to the <code>refs</code> directory, there are a few special refs that reside in the top-level <code>.git</code> directory. 

They are listed below:
<code>HEAD</code> – The currently checked-out commit/branch.
<code>FETCH_HEAD</code> – The most recently fetched branch from a remote repo.
<code>ORIG_HEAD</code> – A backup reference to <code>HEAD</code> before drastic changes to it.

<code>MERGE_HEAD</code> – The commit(s) that you’re merging into the current branch with <code>git merge</code>.
<code>CHERRY_PICK_HEAD</code> – The commit that you’re cherry-picking.
These refs are all created and updated by Git when necessary. 
For example, The <code>git pull</code> command first runs <code>git fetch</code>, which updates the <code>FETCH_HEAD</code> reference. 

Then, it runs <code>git merge FETCH_HEAD</code> to finish pulling the fetched branches into the repository. 
Of course, you can use all of these like any other ref, as I’m sure you’ve done with <code>HEAD</code>.
These files contain different content depending on their type and the state of your repository. 
The <code>HEAD</code> ref can contain either a <strong>symbolic ref</strong>, which is simply a reference to another ref instead of a commit hash, or a commit hash. 

For example, take a look at the contents of <code>HEAD</code> when you’re on the <code>main</code> branch:
<code>git checkout main cat .git/HEAD</code>
This will output <code>ref: refs/heads/main</code>, which means that <code>HEAD</code> points to the <code>refs/heads/main</code> ref. 
This is how Git knows that the <code>main</code> branch is currently checked out. 

If you were to switch to another branch, the contents of <code>HEAD</code> would be updated to reflect the new branch. 
But, if you were to check out a commit instead of a branch, <code>HEAD</code> would contain a commit hash instead of a symbolic ref. 
This is how Git knows that it’s in a detached HEAD state.
For the most part, <code>HEAD</code> is the only reference that you’ll be using directly. 

The others are generally only useful when writing lower-level scripts that need to hook into Git’s internal workings.
<h2><span class="saddlebrown">&emsp;Refspecs</span></h2>
A refspec maps a branch in the local repository to a branch in a remote repository. 
This makes it possible to manage remote branches using local Git commands and to configure some advanced <code>git push</code> and <code>git fetch</code> behavior.

A refspec is specified as <code>[+]</code><code>＜src＞</code><code>:</code><code>＜dst＞</code>. 
The <code>＜src＞</code> parameter is the source branch in the local repository, and the <code>＜dst＞</code> parameter is the destination branch in the remote repository. 
The optional <code>+</code> sign is for forcing the remote repository to perform a non-fast-forward update.
Refspecs can be used with the <code>git push</code> command to give a different name to the remote branch. 

For example, the following command pushes the <code>main</code> branch to the <code>origin</code> remote repo like an ordinary <code>git push</code>, but it uses <code>qa-main</code> as the name for the branch in the <code>origin</code> repo. 
This is useful for QA teams that need to push their own branches to a remote repo.
<code>git push origin main:refs/heads/qa-main</code>
You can also use refspecs for deleting remote branches. 

This is a common situation for feature-branch workflows that push the feature branches to a remote repo (e.g., for backup purposes). 
The remote feature branches still reside in the remote repo after they are deleted from the local repo, so you get a build-up of dead feature branches as your project progresses. 
You can delete them by pushing a refspec that has an empty <code><src></src></code> parameter, like so:
<code>git push origin :some-feature</code>

This is very convenient, since you don’t need to log in to your remote repository and manually delete the remote branch. 
Note that as of Git v1.7.0 you can use the <code>--delete</code> flag instead of the above method. 
The following will have the same effect as the above command:
<code>git push origin --delete some-feature</code>

By adding a few lines to the Git configuration file, you can use refspecs to alter the behavior of <code>git fetch</code>. 
By default, <code>git fetch</code> fetches <em>all</em> of the branches in the remote repository. 
The reason for this is the following section of the <code>.git/config</code> file:
<code>[remote "origin"] url = https://git@github.com:mary/example-repo.git fetch = +refs/heads/*:refs/remotes/origin/*</code>

The <code>fetch</code> line tells <code>git fetch</code> to download all of the branches from the <code>origin</code> repo. 
But, some workflows don’t need all of them. 
For example, many continuous integration workflows only care about the <code>main</code> branch. 
To fetch only the <code>main</code> branch, change the <code>fetch</code> line to match the following:

<code>[remote "origin"] url = https://git@github.com:mary/example-repo.git fetch = +refs/heads/main:refs/remotes/origin/main</code>
You can also configure <code>git push</code> in a similar manner. 
For instance, if you want to always push the <code>main</code> branch to <code>qa-main</code> in the <code>origin</code> remote (as we did above), you would change the config file to:
<code>[remote "origin"] url = https://git@github.com:mary/example-repo.git fetch = +refs/heads/main:refs/remotes/origin/main push = refs/heads/main:refs/heads/qa-main</code>

Refspecs give you complete control over how various Git commands transfer branches between repositories. 
They let you rename and delete branches from your local repository, fetch/push to branches with different names, and configure <code>git push</code> and <code>git fetch</code> to work with only the branches that you want.
<h2><span class="saddlebrown">&emsp;Relative Refs</span></h2>
You can also refer to commits relative to another commit. 

The <code>~</code> character lets you reach parent commits. 
For example, the following displays the grandparent of <code>HEAD</code>:
<code>git show HEAD~2</code>
But, when working with merge commits, things get a little more complicated. 

Since merge commits have more than one parent, there is more than one path that you can follow. 
For 3-way merges, the first parent is from the branch that you were on when you performed the merge, and the second parent is from the branch that you passed to the <code>git merge</code> command.
The <code>~</code> character will always follow the <em>first</em> parent of a merge commit. 
If you want to follow a different parent, you need to specify which one with the <code>^</code> character. 

For example, if <code>HEAD</code> is a merge commit, the following returns the second parent of <code>HEAD</code>.
<code>git show HEAD^2</code>
You can use more than one <code>^</code> character to move more than one generation. 
For instance, this displays the grandparent of <code>HEAD</code> (assuming it’s a merge commit) that rests on the <em>second</em> parent.

<code>git show HEAD^2^1</code>
To clarify how <code>~</code> and <code>^</code> work, the following figure shows you how to reach any commit from <code>A</code> using relative references. 
In some cases, there are multiple ways to reach a commit.
<img src="https://wac-cdn.atlassian.com/dam/jcr:cb2ce970-3ef4-4eda-96a9-fe990745f5a7/02.svg?cdnVersion=217" loading="lazy" alt="Accessing commits using relative refs">Relative refs can be used with the same commands that a normal ref can be used. 

For example, all of the following commands use a relative reference:
<code># Only list commits that are parent of the second parent of a merge commit git log HEAD^2 # Remove the last 3 commits from the current branch git reset HEAD~3 # Interactively rebase the last 3 commits on the current branch git rebase -i HEAD~3</code>
<h2><span class="saddlebrown">&emsp;The Reflog</span></h2>
The reflog is Git’s safety net. 

It records almost every change you make in your repository, regardless of whether you committed a snapshot or not. 
You can think of it as a chronological history of everything you’ve done in your local repo. 
To view the reflog, run the <code>git reflog</code> command. 
It should output something that looks like the following:

<code>400e4b7 HEAD@{0}: checkout: moving from main to HEAD~2 0e25143 HEAD@{1}: commit (amend): Integrate some awesome feature into `main` 00f5425 HEAD@{2}: commit (merge): Merge branch ';feature'; ad8621a HEAD@{3}: commit: Finish the feature</code>
This can be translated as follows:
You just checked out <code>HEAD~2</code>
Before that you amended a commit message

Before that you merged the <code>feature</code> branch into <code>main</code>
Before that you committed a snapshot
The <code>HEAD{<n>}</n></code> syntax lets you reference commits stored in the reflog. 
It works a lot like the <code>HEAD~<n></n></code> references from the previous section, but the <code><n></n></code> refers to an entry in the reflog instead of the commit history.

You can use this to revert to a state that would otherwise be lost. 
For example, lets say you just scrapped a new feature with <code>git reset</code>. 
Your reflog might look something like this:
<code>ad8621a HEAD@{0}: reset: moving to HEAD~3 298eb9f HEAD@{1}: commit: Some other commit message bbe9012 HEAD@{2}: commit: Continue the feature 9cb79fa HEAD@{3}: commit: Start a new feature</code>

The three commits before the <code>git reset</code> are now dangling, which means that there is no way to reference them—except through the reflog. 
Now, let’s say you realize that you shouldn’t have thrown away all of your work. 
All you have to do is check out the <code>HEAD@{1}</code> commit to get back to the state of your repository before you ran <code>git reset</code>.
<code>git checkout HEAD@{1}</code>

This puts you in a detached <code>HEAD</code> state. 
From here, you can create a new branch and continue working on your feature.
<h2><span class="saddlebrown">&emsp;Summary</span></h2>
You should now be quite comfortable referring to commits in a Git repository. 

We learned how branches and tags were stored as refs in the <code>.git</code> subdirectory, how to read a <code>packed-refs</code> file, how <code>HEAD</code> is represented, how to use refspecs for advanced pushing and fetching, and how to use the relative <code>~</code> and <code>^</code> operators to traverse a branch hierarchy.
We also took a look at the reflog, which is a way to reference commits that are not available through any other means. 
This is a great way to recover from those little “Oops, I shouldn’t have done that” situations.
The point of all this was to be able to pick out exactly the commit that you need in any given development scenario. 

It’s very easy to leverage the skills you learned in this article against your existing Git knowledge, as some of the most common commands accept refs as arguments, including <code>git log</code>, <code>git show</code>, <code>git checkout</code>, <code>git reset</code>, <code>git revert</code>, <code>git rebase</code>, and many others.
<h2><br><span class="orange">Git submodules</span></h2>
Git submodules allow you to keep a git repository as a subdirectory of another git repository. 
Git submodules are simply a reference to another repository at a particular snapshot in time. 

Git submodules enable a Git repository  to incorporate and track version history of external code.
<h2><span class="saddlebrown">&emsp;What is a git submodule?</span></h2>
Often a code repository will depend upon external code. 
This external code can be incorporated in a few different ways. 

The external code can be directly copied and pasted into the main repository. 
This method has the downside of losing any upstream changes to the external repository. 
Another method of incorporating external code is through the use of a language's package management system like Ruby Gems or NPM. 
This method has the downside of requiring installation and version management at all places the origin code is deployed. 

Both of these suggested incorporation methods do not enable tracking edits and changes to the external repository.
A git submodule is a record within a host git repository that points to a specific commit in another external repository. 
Submodules are very static and only track specific commits. 
Submodules do not track git refs or branches and are not automatically updated when the host repository is updated. 

When adding a submodule to a repository a new .gitmodules file will be created. 
The .gitmodules file contains meta data about the mapping between the submodule project's URL and local directory. 
If the host repository has multiple submodules, the .gitmodules file will have an entry  for each submodule.
<h2><span class="saddlebrown">&emsp;When should you use a git submodule?</span></h2>
If you need to maintain a strict version management over your external dependencies,  it can make sense to use git submodules. 
The following are a few best use cases for git submodules.
When an external component or subproject is changing too fast or upcoming changes will break the API, you can lock the code to a specific commit for your own safety.
 When you have a component that isn’t updated very often and you want to track it as a vendor dependency.

 When you are delegating a piece of the project to a third party and you want to integrate their work at a specific time or release. 
Again this works when updates are not too frequent.
<h2><span class="saddlebrown">&emsp;Common commands for git submodules</span></h2>
<h3>&emsp;Add git submodule</h3>

The <code>git submodule add</code> is used to add a new submodule to an existing repository. 
The following is an example that creates an empty repo and explores git submodules.
<code>$ mkdir git-submodule-demo
$ cd git-submodule-demo/

$ git init
Initialized empty Git repository in /Users/atlassian/git-submodule-demo/.git/</code>
This sequence of commands will create a new directory <code>git-submodule-demo</code>, enter that directory, and initialize it as a new repository. 
Next we will add a submodule to this fresh new repo.

<code>$ git submodule add https://bitbucket.org/jaredw/awesomelibrary
Cloning into '/Users/atlassian/git-submodule-demo/awesomelibrary'...
remote: Counting objects: 8, done.
remote: Compressing objects: 100% (6/6), done.

remote: Total 8 (delta 1), reused 0 (delta 0)
Unpacking objects: 100% (8/8), done.</code>
The <code>git submodule add</code> command takes a URL parameter that points to a git repository. 
Here we have added the <code>awesomelibrary</code> as a submodule. 

Git will immediately clone the submodule. 
We can now review the current state of the repository using <code>git status</code>...
<code>$ git status
On branch main

No commits yet
Changes to be committed:
(use "git rm --cached &lt;file>..." to unstage)
new file:   .gitmodules

new file:   awesomelibrary</code>
There are now two new files in the repository <code>.gitmodules</code> and the <code>awesomelibrary</code> directory. 
Looking at the contents of <code>.gitmodules</code> shows the new submodule mapping
<code>[submodule "awesomelibrary"]

path = awesomelibrary
url = https://bitbucket.org/jaredw/awesomelibrary</code>
<code>$ git add .gitmodules awesomelibrary/
$ git commit -m "added submodule"

[main (root-commit) d5002d0] added submodule
2 files changed, 4 insertions(+)
create mode 100644 .gitmodules
create mode 160000 awesomelibrary</code>

<h3>&emsp;Cloning git submodules</h3>
<code>git clone /url/to/repo/with/submodules
git submodule init
git submodule update</code>

<h3>&emsp;Git submodule Init</h3>
The default behavior of <code>git submodule init</code> is to copy the mapping from the <code>.gitmodules</code> file into the local <code>./.git/config</code> file. 
This may seem redundant and lead to questioning <code>git submodule init</code> usefulness. 
<code>git submodule init</code> has extend behavior in which it accepts a list of explicit module names. 

This enables a workflow of activating only specific submodules that are needed for work on the repository. 
This can be helpful if there are many submodules in a repo but they don't all need to be fetched for work you are doing.
<h3>&emsp;Submodule workflows</h3>
Once submodules are properly initialized and updated within a parent repository they can be utilized exactly like stand-alone repositories. 

This means that submodules have their own branches and history. 
When making changes to a submodule it is important to publish submodule changes and then update the parent repositories reference to the submodule. 
Let’s continue with the <code>awesomelibrary</code> example and make some changes:
<code>$ cd awesomelibrary/

$ git checkout -b new_awesome
Switched to a new branch 'new_awesome'
$ echo "new awesome file" > new_awesome.txt
$ git status

On branch new_awesome
Untracked files:
(use "git add &lt;file>..." to include in what will be committed)
new_awesome.txt

nothing added to commit but untracked files present (use "git add" to track)
$ git add new_awesome.txt
$ git commit -m "added new awesome textfile"
[new_awesome 0567ce8] added new awesome textfile

1 file changed, 1 insertion(+)
create mode 100644 new_awesome.txt
$ git branch
main

* new_awesome</code>
Here we have changed directory to the awesomelibrary submodule. 
We have created a new text file <code>new_awesome.txt</code> with some content and we have added and committed this new file to the submodule. 
Now let us change directories back to the parent repository and review the current state of the parent repo.

<code>$ cd ..
$ git status
On branch main
Changes not staged for commit:

(use "git add &lt;file>..." to update what will be committed)
(use "git checkout -- &lt;file>..." to discard changes in working directory)
modified:   awesomelibrary (new commits)
no changes added to commit (use "git add" and/or "git commit -a")</code>

Executing <code>git status</code> shows us that the parent repository is aware of the new commits to the <code>awesomelibrary</code> submodule. 
It doesn't go into detail about the specific updates because that is the submodule repositories responsibility. 
The parent repository is only concerned with pinning the submodule to a commit. 
Now we can update the parent repository again by doing a <code>git add</code> and <code>git commit</code> on the submodule. 

This will put everything into a good state with the local content. 
If you are working in a team environment it is critical that you then <code>git push</code> the submodule updates, and the parent repository updates.
When working with submodules, a common pattern of confusion and error is forgetting to push updates for remote users. 
If we revisit the <code>awesomelibrary</code> work we just did, we pushed only the updates to the parent repository. 

Another developer would go to pull the latest parent repository and it would be pointing at a commit of <code>awesomelibrary</code> that they were unable to pull because we had forgotten to push the submodule. 
This would break the remote developers local repo. 
To avoid this failure scenario make sure to always commit and push the submodule and parent repository.
<h2><span class="saddlebrown">&emsp;Conclusion</span></h2>
Git submodules are a powerful way to leverage git as an external dependency management tool. 
Weigh the pros and cons of git submodules before using them, as they are an advanced feature and may take a learning curve for team members to adopt.
<h2><br><span class="orange">Git subtree: the alternative to Git submodule</span></h2>
The Internet is full of articles on why you shouldn’t use Git submodules. 

While submodules are useful for a few use cases, they do have several drawbacks.
Are there alternatives? The answer is: yes! There are (at least) two tools that can help track the history of software dependencies in your project while allowing you to keep using Git:
<code>git subtree</code>
Google repo

In this post we will look at <code>git subtree </code>and show why it is an improvement – albeit not perfect – over git submodule.
<h2><span class="saddlebrown">&emsp;What is <code>git subtree</code>, and why should I use it?</span></h2>
<code>git subtree</code> lets you nest one repository inside another as a sub-directory. 
It is one of several ways Git projects can manage project dependencies.

<img src="https://wac-cdn.atlassian.com/dam/jcr:f5fcef58-5b93-4ff4-b9a1-3f721d29ead8/BeforeAfterGitSubtreeDiagram.png?cdnVersion=217" loading="lazy" alt="A diagram showing the interaction between two repositories before and after using Git Subtree.">Why you may want to consider <code>git subtree</code>
Management of a simple workflow is easy.
Older version of Git are supported (even older than v1.5.2).
The sub-project’s code is available right after the clone of the super project is done.

<code>git subtree</code> does not require users of your repository to learn anything new. 
They can ignore the fact that you are using <code>git subtree</code> to manage dependencies.
<code>git subtree</code> does not add new metadata files like git submodule does (i.e., .gitmodule).
Contents of the module can be modified without having a separate repository copy of the dependency somewhere else.

Drawbacks (but in our opinion they're largely acceptable):
You must learn about a new merge strategy (i.e.<code>git subtree</code>).
Contributing code back upstream for the sub-projects is slightly more complicated.
The responsibility of not mixing super and sub-project code in commits lies with you.
<h2><span class="saddlebrown">&emsp;How to use <code>git subtree</code></span></h2>
<code>git subtree</code> is available in stock version of Git since May 2012 – v1.7.11 and above. 
The version installed by homebrew on OSX already has subtree properly wired, but on some platforms you might need to follow the installation instructions.
Here is a canonical example of tracking a vim plug-in using <code>git subtree.</code>

<h3>&emsp;The quick and dirty way without remote tracking</h3>
If you just want a couple of one-liners to cut and paste, read this paragraph. 
First add <code>git subtree</code> at a specified prefix folder:
<code>git subtree add --prefix .vim/bundle/tpope-vim-surround https://bitbucket.org/vim-plugins-mirror/vim-surround.git main --squash</code>

(The common practice is to not store the entire history of the subproject in your main repository, but If you want to preserve it just omit the <em>–squash</em> flag.)
The above command produces this output:
<code>git fetch https://bitbucket.org/vim-plugins-mirror/vim-surround.git main
warning: no common commits

remote: Counting objects: 338, done.
remote: Compressing objects: 100% (145/145), done.
remote: Total 338 (delta 101), reused 323 (delta 89)
Receiving objects: 100% (338/338), 71.46 KiB, done.

Resolving deltas: 100% (101/101), done.
From https://bitbucket.org/vim-plugins-mirror/vim-surround.git
* branch main -} FETCH_HEAD
Added dir '.vim/bundle/tpope-vim-surround'</code>

As you can see this records a merge commit by squashing the whole history of the vim-surround repository into a single one:
<code>1bda0bd [3 minutes ago] (HEAD, stree) Merge commit 'ca1f4da9f0b93346bba9a430c889a95f75dc0a83' as '.vim/bundle/tpope-vim-surround' [Nicola Paolucci]
ca1f4da [3 minutes ago] Squashed '.vim/bundle/tpope-vim-surround/' content from commit 02199ea [Nicola Paolucci]</code>
If after a while you want to update the code of the plugin from the upstream repository you can just do a <code>git subtree</code> pull:

<code>git subtree pull --prefix .vim/bundle/tpope-vim-surround https://bitbucket.org/vim-plugins-mirror/vim-surround.git main --squash</code>
This is very quick and painless, but the commands are slightly lengthy and hard to remember. 
We can make the commands shorter by adding the sub-project as a remote.
<h3>&emsp;Adding the sub-project as a remote</h3>

Adding the subtree as a remote allows us to refer to it in shorter form:
<code>git remote add -f tpope-vim-surround https://bitbucket.org/vim-plugins-mirror/vim-surround.git</code>
Now we can add the subtree (as before), but now we can refer to the remote in short form:
<code>git subtree add --prefix .vim/bundle/tpope-vim-surround tpope-vim-surround main --squash</code>

The command to update the sub-project at a later date becomes:
<code>git fetch tpope-vim-surround main
git subtree pull --prefix .vim/bundle/tpope-vim-surround tpope-vim-surround main --squash</code>
<h3>&emsp;Contributing back upstream</h3>

We can freely commit our fixes to the sub-project in our local working directory now. 
When it’s time to contribute back to the upstream project, we need to fork the project and add it as another remote:
<code>git remote add durdn-vim-surround ssh://git@bitbucket.org/durdn/vim-surround.git</code>
Now we can use the <em>subtree push</em> command like the following:

<code>git subtree push --prefix=.vim/bundle/tpope-vim-surround/ durdn-vim-surround main
git push using: durdn-vim-surround main
Counting objects: 5, done.
Delta compression using up to 4 threads.

Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 308 bytes, done.
Total 3 (delta 2), reused 0 (delta 0)
To ssh://git@bitbucket.org/durdn/vim-surround.git

02199ea..dcacd4b dcacd4b21fe51c9b5824370b3b224c440b3470cb -} main</code>
After this we’re ready and we can open a pull-request to the maintainer of the package.
<h3>&emsp;Can I do this without using the <code>git subtree</code> command?</h3>
Yes! Yes you can. 

<code>git subtree</code> is different from the subtree merge strategy. 
You can still use the merge strategy even if for some reason <code>git subtree</code> is not available. 
Here is how you would go about it.
Add the dependency as a simple <code>git remote</code>:

<code>git remote add -f tpope-vim-surround https://bitbucket.org/vim-plugins-mirror/vim-surround.git</code>
Before reading the contents of the dependency into the repository, it’s important to record a merge so that we can track the entire tree history of the plug-in up to this point:
<code>git merge -s ours --no-commit tpope-vim-surround/main</code>
Which outputs:

<code>Automatic merge went well; stopped before committing as requested</code>
We then read the content of the latest tree-object into the plugin repository into our working directory ready to be committed:
<code>git read-tree --prefix=.vim/bundle/tpope-vim-surround/ -u tpope-vim-surround/main</code>
Now we can commit (and it will be a merge commit that will preserve the history of the tree we read):

<code>git ci -m"[subtree] adding tpope-vim-surround"
[stree 779b094] [subtree] adding tpope-vim-surround</code>
When we want to update the project we can now pull using the <code>git subtree</code> merge strategy:
<code>git pull -s subtree tpope-vim-surround main</code>
<h2><span class="saddlebrown">&emsp;<code>Git subtree</code> is a great alternative</span></h2>
After having used git submodules for a while, you'll see <code>git subtree</code> solves lots of the problems with git submodule. 
As usual, with all things Git, there is a learning curve to make the most of the feature.
Follow me on Twitter <a href="https://www.twitter.com/durdn" data-event="clicked" data-uuid="e1639e22-b4" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">@durdn</a> for more things and stuff about Git. 

And check out <a href="https://www.bitbucket.org/?_ga=2.71978451.1385799339.1568044055-1068396449.1567112770" data-event="clicked" data-uuid="e1639e22-b4" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Atlassian Bitbucket</a> if you’re looking for a good tool to manage your Git repos.
Update: After publishing this piece, I also wrote an <a href="https://developer.atlassian.com/blog/2015/05/the-power-of-git-subtree?_ga=2.71978451.1385799339.1568044055-1068396449.1567112770" data-event="clicked" data-uuid="e1639e22-b4" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">article on the power of <code>Git subtree</code></a><em>.</em>
<h6>Share this</h6> <a href="https://twitter.com/share?url=https%3A%2F%2Fatlassian.com%2F&amp;text=Git%20Forks%20And%20Upstreams:%20How-to%20and%20a%20cool%20tip" data-event="clicked" data-uuid="2d218c88-07" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Twitter</a> 
<h2><br><span class="orange">How to handle big repositories with Git</span></h2>
Git is a fantastic choice for tracking the evolution of your code base and collaborating efficiently with your peers. 
But what happens when the repository you want to track is really <strong>really</strong> big?
In this post I’ll give you some techniques for dealing with it.
<h2><span class="saddlebrown">&emsp;Two categories of big repositories</span></h2>
If you think about it there are broadly two major reasons for repositories growing massive:
They accumulate a very very long history (the project grows over a very long period of time and the baggage accumulates)
They include huge binary assets that need to be tracked and paired  together with code.

…or it could be both.
Sometimes the second type of problem is compounded by the fact that old, deprecated binary artifacts are still stored in the repository. 
But there’s a moderately easy – if annoying – fix for that (see below).
The techniques and workarounds for each scenario are different, though sometimes complementary. 

So I’ll cover them separately.
<h2><span class="saddlebrown">&emsp;Cloning repositories with a very long history</span></h2>
Even though threshold for a qualifying a repository as “massive” is pretty high, they’re still a pain to clone. 
And you can’t always avoid long histories. 

Some repos have to be kept in tact for legal or regulatory reasons.
<h3>&emsp;Simple solution: git shallow clone</h3>
The first solution to a fast clone and saving developer’s and system’s time and disk space is to copy only recent revisions. 
Git’s shallow clone option allows you to pull down only the latest n commits of the repo’s history.

How do you do it? Just use the –depth option. 
For example:
<code>git clone --depth [depth] [remote-url] </code>
Imagine you accumulated ten or more years of project history in your repository. 

For example, we migrated <a href="/software/jira" data-event="clicked" data-uuid="0bf2c9a7-e1" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Jira </a>(an 11 year-old code base) to Git. 
The time savings for repos like this can add up and be very noticeable.
The full clone of Jira is 677MB, with the working directory being another 320MB, made up of more than 47,000+ commits. 
A shallow clone of the repo takes 29.5 seconds, compared to 4 minutes 24 seconds for a full clone with all the history. 

The benefit grows proportionately to how many binary assets your project has swallowed over time.
<em>Tip:</em> <a href="/continuous-delivery/continuous-integration/ci-friendly-git-repos" data-event="clicked" data-uuid="b368a704-e4" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Build systems connected to your Git repo</a> benefit from shallow clones, too!
Shallow clones used to be somewhat impaired citizens of the Git world as some operations were barely supported. 
But recent versions (<a href="https://www.atlassian.com/blog/archives/whats-new-git-1-9?_ga=2.85910233.1564368919.1571097409-1339596144.1562091064" data-event="clicked" data-uuid="e387c03a-a7" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">1.9</a> and above) have improved the situation greatly, and you can properly pull and push to repositories even from a shallow clone now.

<h3>&emsp;Surgical solution: git filter branch</h3>
For the huge repositories that have lots of binary cruft committed by mistake, or old assets not needed anymore, a great solution is to use <em>git filter-branch</em>. 
The command lets you walk through the entire history of the project filtering out, modifying, and skipping files according to predefined patterns.
It is a very powerful tool once you’ve identified where your repo is heavy. 

There are helper scripts available to identify big objects, so that part should be easy enough.
The syntax goes like this:
<code>git filter-branch --tree-filter <span>'rm -rf [/path/to/spurious/asset/folder]'</span></code>
<em>git filter-branch</em> has a minor drawback, though: once you use _filter-branch_, you effectively rewrite the entire history of your project. 

That is, all commit ids change. 
This requires every developer to re-clone the updated repository.
So if you’re planning to carry out a cleanup action using <em>git filter-branch</em>, you should alert your team, plan a short freeze while the operation is carried out, and then notify everyone that they should clone the repository again.
<em>Tip:</em> More on git filter-branch in <a href="https://www.atlassian.com/blog/git/tear-apart-repository-git-way?_ga=2.116821446.1564368919.1571097409-1339596144.1562091064" data-event="clicked" data-uuid="9f587485-57" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">this post about tearing apart your Git repo.</a>

<h3>&emsp;Alternative to git shallow-clone: clone only one branch</h3>
Since git 1.7.10, you can also limit the amount of history you clone by cloning a single branch, like so:
<code>git clone [remote url] --branch [branch_name] --single-branch [folder]</code>
This specific hack is useful when you’re working with long running and divergent branches, or if you have lots branches and only ever need to work with a few of them. 

If you only have a handful of branches with very few differences you probably won’t see a huge difference using this.
<h2><span class="saddlebrown">&emsp;Managing repositories with huge binary assets</span></h2>
The second type of big repository is those with huge binary assets. 
This is something <a href="https://www.atlassian.com/blog/git/git-lfs-for-designers-game-developers-architects?_ga=2.42796773.1564368919.1571097409-1339596144.1562091064" data-event="clicked" data-uuid="c1fc5bb0-79" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">many different kinds of software (and non-software!) teams encounter.</a> Gaming teams have to juggle around huge 3D models, web development teams might need to track raw image assets, CAD teams might need to manipulate and track the status of binary deliverables.

Git is not especially bad at handling binary assets, but it’s not especially good either. 
By default, Git will compress and store all subsequent full versions of the binary assets, which is obviously not optimal if you have many.
There are some basic tweaks that improve the situation, like running the garbage collection <em>(‘git gc’)</em>, or tweaking the usage of delta commits for some binary types in .gitattributes.
But it’s important to reflect on the nature of your project’s binary assets, as that will help you determine the winning approach. 

For example, here are some points to consider:
For binary files that change significantly – and not just some meta data headers – the delta compression is probably going to be useless. 
So use <em>‘delta off’ </em>for those files to avoid the unnecessary delta compression work as part of the repack.
In the scenario above, it’s likely that those files don’t zlib compress very well either so you could turn compression off with <em>‘core.compression 0’ </em>or ‘<em>core.loosecompression 0’</em>. 

That’s a global setting that would negatively affect all the non-binary files that actually compress well so this makes sense if you split the binary assets into a separate repository.
t’s important to remember that <em>‘git gc’ </em>turns the “duplicated” loose objects into a single pack file. 
But again, unless the files compress in some way, that probably won’t make any significant difference in the resulting pack file.
Explore the tuning of <em>‘core.bigFileThreshold’</em>. 

Anything larger than 512MB won’t be delta compressed anyway (without having to set .gitattributes) so maybe that’s something worth tweaking.
<h3>&emsp;Solution for big folder trees: git sparse-checkout</h3>
A mild help to the binary assets problem is Git’s sparse checkout option (available since Git 1.7.0). 
This technique allows to keep the working directory clean by explicitly detailing which folders you want to populate. 

Unfortunately, it does not affect the size of the overall local repository, but can be helpful if you have a huge tree of folders.
What are the involved commands? Here’s an example:
Clone the full repository once: <em>‘git clone’</em>
Activate the feature: <em>‘git config core.sparsecheckout true’</em>

Add folders that are needed explicitly, ignoring assets folders: 
echo src/  .git/info/sparse-checkout
Read the tree as specified: 
<em>git read-tree -m -u HEAD</em>

After the above, you can go back to use your normal git commands, but your work directory will only contain the folders you specified above.
<h3>&emsp;Solution for controlling when you update large files: submodules</h3>
<h2><span class="saddlebrown">&emsp;[UPDATE] …or you can skip all that and use Git LFS</span></h2>
If you work with large files on a regular basis, the best solution might be to take advantage of the large file support (LFS) Atlassian co-developed with GitHub in 2015. 

(Yes, you read that right. 
We teamed up with GitHub on an open-source contribution to the Git project.)
Git LFS is an extension that stores pointers (naturally!) to large files in your repository, instead of storing the files themselves in there. 
The actual files are stored on a remote server. 

As you can imagine, this dramatically reduces the time it takes to clone your repo.
<img src="https://wac-cdn.atlassian.com/dam/jcr:72213c27-9025-432e-94db-b1df0fd150c3/GitLFSDiagram-1.png?cdnVersion=217" loading="lazy" alt=""><a href="https://www.atlassian.com/blog/git/git-lfs-for-designers-game-developers-architects?_ga=2.39759587.1564368919.1571097409-1339596144.1562091064" data-event="clicked" data-uuid="2b25e2f2-f1" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Bitbucket supports Git LFS</a>, as does GitHub. 
So chances are, you already have access to this technology. 
It’s especially helpful for teams that include designers, videographers, musicians, or CAD users.

<h3>&emsp;Conclusions</h3>
Don’t give up the fantastic capabilities of Git just because you have a big repository history or huge files. 
There are workable solutions to both problems.
Check out the other articles I linked to above for more info on submodules, project dependencies, and Git LFS. 

And for refreshers on commands and workflow, our <a href="/git" data-event="clicked" data-uuid="4e3c7360-8e" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Git microsite</a> has loads of tutorials. 
Happy coding!
<h6>Share this</h6> <a href="https://twitter.com/share?url=https%3A%2F%2Fatlassian.com%2F&amp;text=Git%20Forks%20And%20Upstreams:%20How-to%20and%20a%20cool%20tip" data-event="clicked" data-uuid="39eec479-23" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Twitter</a> 
<h2><br><span class="orange">Git LFS</span></h2>
<h3>&emsp;What is Git LFS?</h3>
Git is a <em>distributed</em> version control system, meaning the entire history of the repository is transferred to the client during the cloning process. 
For projects containing large files, particularly large files that are modified regularly, this initial clone can take a huge amount of time, as every version of every file has to be downloaded by the client. 
Git LFS (Large File Storage) is a Git extension developed by Atlassian, GitHub, and a few other open source contributors, that reduces the impact of large files in your repository by downloading the relevant versions of them <em>lazily</em>. 

Specifically, large files are downloaded during the checkout process rather than during cloning or fetching.
Git LFS does this by replacing large files in your repository with tiny <em>pointer</em> files. 
During normal usage, you'll never see these pointer files as they are handled automatically by Git LFS:
When you add a file to your repository, Git LFS replaces its contents with a pointer, and stores the file contents in a local Git LFS cache. 

<img alt="git lfs - git add" src="https://wac-cdn.atlassian.com/dam/jcr:9abf0939-a978-4867-a751-28bd1ca318de/01.svg?cdnVersion=217">
 When you push new commits to the server, any Git LFS files referenced by the newly pushed commits are transferred from your local Git LFS cache to the remote Git LFS store tied to your Git repository. 
<img alt="git lfs - git push" src="https://wac-cdn.atlassian.com/dam/jcr:cb729dbe-3c28-4775-821d-0e2518668d8b/02.svg?cdnVersion=217">
 When you checkout a commit that contains Git LFS pointers, they are replaced with files from your local Git LFS cache, or downloaded from the remote Git LFS store. 

<img alt="git lfs - git checkout" src="https://wac-cdn.atlassian.com/dam/jcr:7e70a242-db91-4093-b178-c1281fe3ddbb/03.svg?cdnVersion=217" title="git lfs - git checkout">
Git LFS is seamless: in your working copy you'll only see your actual file content. 
This means you can use Git LFS without changing your existing Git workflow; you simply <code>git checkout</code>, edit, <code>git add</code>, and <code>git commit</code> as normal. 
<code>git clone</code> and <code>git pull</code> operations will be significantly faster as you only download the versions of large files referenced by commits that you <em>actually</em> check out, rather than every version of the file that ever existed.

<iframe allowfullscreen="" frameborder="0" height="300" src="https://www.youtube.com/embed/9gaTargV5BY" width="100%"></iframe>
To use Git LFS, you will need a Git LFS aware host such as <a href="https://bitbucket.org/" data-event="clicked" data-uuid="e0727e2b-3d" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Bitbucket Cloud</a> or <a href="https://bitbucket.org/product/enterprise/data-center" data-event="clicked" data-uuid="e0727e2b-3d" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Bitbucket Data Center</a>. 
Repository users will need to have the <a href="#installing-git-lfs" data-event="clicked" data-uuid="e0727e2b-3d" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Git LFS command-line client installed</a>, or a Git LFS aware GUI client such as <a href="https://www.sourcetreeapp.com/" data-event="clicked" data-uuid="e0727e2b-3d" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Sourcetree</a>. 
Fun fact: Steve Streeting, the Atlassian developer who invented Sourcetree, is also a major contributor to the Git LFS project, so Sourcetree and Git LFS work together rather well.

What is Git LFS?
<a href="#installing-git-lfs" data-event="clicked" data-uuid="52007d55-56" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Installing Git LFS</a>
<a href="#creating-new-repository" data-event="clicked" data-uuid="52007d55-56" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Creating a new Git LFS repository</a>
<a href="#clone-respository" data-event="clicked" data-uuid="52007d55-56" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Cloning an existing Git LFS repository</a>

<a href="#speeding-up-clones" data-event="clicked" data-uuid="52007d55-56" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Speeding up clones</a>
<a href="#pulling-and-checking-out" data-event="clicked" data-uuid="52007d55-56" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Pulling and checking out</a>
<a href="#speeding-up-pulls" data-event="clicked" data-uuid="52007d55-56" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Speeding up pulls</a>
<a href="#tracking-files" data-event="clicked" data-uuid="52007d55-56" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Tracking files with Git LFS</a>

<a href="#committing-and-pushing" data-event="clicked" data-uuid="52007d55-56" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Committing and pushing</a>
<a href="#moving-between-hosts" data-event="clicked" data-uuid="52007d55-56" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Moving a Git LFS repository between hosts</a>
<a href="#fetching-history" data-event="clicked" data-uuid="52007d55-56" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Fetching extra Git LFS history</a>
<a href="#deleting-local-files" data-event="clicked" data-uuid="52007d55-56" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Deleting local Git LFS files</a>

<a href="#deleting-remote-files" data-event="clicked" data-uuid="52007d55-56" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Deleting remote Git LFS files from the server</a>
<a href="#finding-references" data-event="clicked" data-uuid="52007d55-56" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Finding paths or commits that reference a Git LFS object</a>
<a href="#including-excluding-files" data-event="clicked" data-uuid="52007d55-56" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Including/excluding Git LFS files</a>
<a href="#locking-files" data-event="clicked" data-uuid="52007d55-56" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Locking Git LFS files</a>

<a href="#how-git-lfs-works" data-event="clicked" data-uuid="52007d55-56" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">How Git LFS works</a>
<h3>&emsp;Installing Git LFS</h3>
There are three easy ways to install Git LFS:
a. 

Install it using your favorite package manager. 
<code>git-lfs</code> packages are available for Homebrew, MacPorts, dnf, and <a href="https://github.com/github/git-lfs/blob/master/INSTALLING.md" data-event="clicked" data-uuid="a1710d36-9e" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">packagecloud</a>; or
b. 
Download and install <a href="https://git-lfs.github.com/" data-event="clicked" data-uuid="a1710d36-9e" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Git LFS</a> from the project website; or

c. 
Install <a href="https://www.sourcetreeapp.com/" data-event="clicked" data-uuid="a1710d36-9e" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Sourcetree</a>, a free Git GUI client that comes bundled with Git LFS.
 Once git-lfs is on your path, run git lfs install to initialize Git LFS (you can skip this step if you installed Sourcetree):
<code>$ git lfs install Git LFS initialized. </code>

You'll only need to run <code>git lfs install</code> once. 
Once initialized for your system, Git LFS will bootstrap itself automatically when you clone a repository containing Git LFS content.
<h3>&emsp;Creating a new Git LFS repository</h3>
To create a new Git LFS aware repository, you'll need to run git lfs install after you create the repository:

<code># initialize Git
$ mkdir Atlasteroids
$ cd Atlasteroids
$ git init

Initialized empty Git repository in /Users/tpettersen/Atlasteroids/.git/
# initialize Git LFS
$ git lfs install
Updated pre-push hook.

Git LFS initialized.</code>
This installs a special <code>pre-push</code> <a href="https://www.atlassian.com/git/tutorials/git-hooks" data-event="clicked" data-uuid="90c61dbd-70" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Git hook</a> in your repository that will transfer Git LFS files to the server when you <code>git push</code>.
Git LFS is automatically enabled for all <a href="https://bitbucket.org/" data-event="clicked" data-uuid="421a2b4a-80" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Bitbucket Cloud</a> repositories. 
For <a href="https://bitbucket.org/product/enterprise/data-center" data-event="clicked" data-uuid="421a2b4a-80" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Bitbucket Data Center</a>, you'll need to enable Git LFS in your repository settings:

<img src="https://wac-cdn.atlassian.com/dam/jcr:2d4bd71b-5205-4297-aec9-f0c91bfb6ad2/05.png?cdnVersion=217" loading="lazy" alt="Bitbucket Server Git LFS">Once Git LFS is initialized for your repository, you can specify which files to track using <a href="#tracking-files" data-event="clicked" data-uuid="21991f65-42" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket"><code>git lfs track</code></a>.
<h3>&emsp;Cloning an existing Git LFS repository</h3>
Once Git LFS is installed, you can clone a Git LFS repository as normal using <code>git clone</code>. 
At the end of the cloning process Git will check out the default branch (usually <code>main</code>), and any Git LFS files needed to complete the checkout process will be automatically downloaded for you. 

For example:
<code>$ git clone git@bitbucket.org:tpettersen/Atlasteroids.git
Cloning into 'Atlasteroids'...
remote: Counting objects: 156, done.

remote: Compressing objects: 100% (154/154), done.
remote: Total 156 (delta 87), reused 0 (delta 0)
Receiving objects: 100% (156/156), 54.04 KiB | 31.00 KiB/s, done.
Resolving deltas: 100% (87/87), done.

Checking connectivity... 
done.
Downloading Assets/Sprites/projectiles-spritesheet.png (21.14 KB)
Downloading Assets/Sprites/productlogos_cmyk-spritesheet.png (301.96 KB)

Downloading Assets/Sprites/shuttle2.png (1.62 KB)
Downloading Assets/Sprites/space1.png (1.11 MB)
Checking out files: 100% (81/81), done.</code>
There are four <code>PNGs</code> in this repository being tracked by Git LFS. 

When running git clone, Git LFS files are downloaded one at a time as pointer files are checked out of your repository.
<h3>&emsp;Speeding up clones</h3>
If you're cloning a repository with a large number of LFS files, the explicit <code>git lfs clone</code> command offers far better performance:
<code>$ git lfs clone git@bitbucket.org:tpettersen/Atlasteroids.git

Cloning into 'Atlasteroids'...
remote: Counting objects: 156, done.
remote: Compressing objects: 100% (154/154), done.
remote: Total 156 (delta 87), reused 0 (delta 0)

Receiving objects: 100% (156/156), 54.04 KiB | 0 bytes/s, done.
Resolving deltas: 100% (87/87), done.
Checking connectivity... 
done.

Git LFS: (4 of 4 files) 1.14 MB / 1.15 MB</code>
Rather than downloading Git LFS files one at a time, the <code>git lfs clone</code> command waits until the checkout is complete, and then downloads any required Git LFS files as a batch. 
This takes advantage of parallelized downloads, and dramatically reduces the number of HTTP requests and processes spawned (which is especially important for improving performance on Windows).
<h3>&emsp;Pulling and checking out</h3>

Just like cloning, you can pull from a Git LFS repository using a normal <code>git pull</code>. 
Any needed Git LFS files will be downloaded as part of the automatic checkout process once the pull completes:
<code>$ git pull
Updating 4784e9d..7039f0a

Downloading Assets/Sprites/powerup.png (21.14 KB)
Fast-forward
Assets/Sprites/powerup.png      |    3 +
Assets/Sprites/powerup.png.meta | 4133 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

2 files changed, 4136 insertions(+)
create mode 100644 Assets/Sprites/projectiles-spritesheet.png
create mode 100644 Assets/Sprites/projectiles-spritesheet.png.meta</code>
No explicit commands are needed to retrieve Git LFS content. 

However, if the checkout fails for an unexpected reason, you can download any missing Git LFS content for the current commit with <code>git lfs pull</code>:
<code>$ git lfs pull
Git LFS: (4 of 4 files) 1.14 MB / 1.15 MB</code>
<h3>&emsp;Speeding up pulls</h3>

Like <code>git lfs clone</code>, <code>git lfs pull</code> downloads your Git LFS files as a batch. 
If you know a large number of files have changed since the last time you pulled, you may wish to disable the automatic Git LFS download during checkout, and then batch download your Git LFS content with an explicit <code>git lfs pull</code>. 
This can be done by overriding your Git config with the <code>-c</code> option when you invoke <code>git pull</code>:
<code>$ git -c filter.lfs.smudge= -c filter.lfs.required=false pull &amp;&amp; git lfs pull</code>

Since that's rather a lot of typing, you may wish to create a simple <a href="https://www.atlassian.com/blog/git/advanced-git-aliases" data-event="clicked" data-uuid="35885c2f-d6" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Git alias</a> to perform a batched Git and Git LFS pull for you:
<code>$ git config --global alias.plfs "\!git -c filter.lfs.smudge= -c filter.lfs.required=false pull &amp;&amp; git lfs pull"
$ git plfs</code>
This will greatly improve performance when a large number of Git LFS files need to be downloaded (again, especially on Windows).

<h3>&emsp;Tracking files with Git LFS</h3>
When you add a new type of large file to your repository, you'll need to tell Git LFS to track it by specifying a pattern using the <code>git lfs track</code> command:
<code>$ git lfs track "*.ogg"
Tracking *.ogg</code>

Note that the quotes around <code>"*.ogg"</code> are important. 
Omitting them will cause the wildcard to be expanded by your shell, and individual entries will be created for each <code>.ogg</code> file in your current directory:
<code># probably not what you want
$ git lfs track *.ogg

Tracking explode.ogg
Tracking music.ogg
Tracking phaser.ogg</code>
The patterns supported by Git LFS are the same as those supported by <a href="https://www.atlassian.com/git/tutorials/gitignore" data-event="clicked" data-uuid="d31a66b2-b6" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket"><code>.gitignore</code></a>, for example:

<code># track all .ogg files in any directory
$ git lfs track "*.ogg"
# track files named music.ogg in any directory
$ git lfs track "music.ogg"

# track all files in the Assets directory and all subdirectories
$ git lfs track "Assets/"
# track all files in the Assets directory but *not* subdirectories
$ git lfs track "Assets/*"

# track all ogg files in Assets/Audio
$ git lfs track "Assets/Audio/*.ogg"
# track all ogg files in any directory named Music
$ git lfs track "**/Music/*.ogg"

# track png files containing "xxhdpi" in their name, in any directory
$ git lfs track "*xxhdpi*.png</code>
These patterns are relative to the directory in which you ran the <code>git lfs track</code> command. 
To keep things simple, it is best to run <code>git lfs track</code> from the root of your repository. 

Note that Git LFS does not support <em>negative patterns</em> like <code>.gitignore</code> does.
After running <code>git lfs track</code>, you'll notice a new file named <code>.gitattributes</code> in the directory you ran the command from. 
<code>.gitattributes</code> is a Git mechanism for binding special behaviors to certain file patterns. 
Git LFS automatically creates or updates <code>.gitattributes</code> files to bind tracked file patterns to the Git LFS filter. 

However, you will need to commit any changes to the <code>.gitattributes</code> file to your repository yourself:
<code>$ git lfs track "*.ogg"
Tracking *.ogg
$ git add .gitattributes

$ git diff --cached
diff --git a/.gitattributes b/.gitattributes
new file mode 100644
index 0000000..b6dd0bb

--- /dev/null
+++ b/.gitattributes
@@ -0,0 +1 @@
+*.ogg filter=lfs diff=lfs merge=lfs -text

$ git commit -m "Track ogg files with Git LFS"</code>
For ease of maintenance, it is simplest to keep all Git LFS patterns in a single <code>.gitattributes</code> file by always running <code>git lfs track</code> from the root of your repository. 
However, you can display a list of all patterns that are currently tracked by Git LFS (and the <code>.gitattributes</code> files they are defined in) by invoking <code>git lfs track</code> with no arguments:
<code>$ git lfs track

Listing tracked paths
*.stl (.gitattributes)
*.png (Assets/Sprites/.gitattributes)
*.ogg (Assets/Audio/.gitattributes)</code>

You can stop tracking a particular pattern with Git LFS by simply removing the appropriate line from your <code>.gitattributes</code> file, or by running the <code>git lfs untrack</code> command:
<code>$ git lfs untrack "*.ogg"
Untracking *.ogg
$ git diff

diff --git a/.gitattributes b/.gitattributes
index b6dd0bb..e69de29 100644
--- a/.gitattributes
+++ b/.gitattributes

@@ -1 +0,0 @@
-*.ogg filter=lfs diff=lfs merge=lfs -text</code>
After running <code>git lfs untrack</code> you will again have to commit the changes to <code>.gitattributes</code> yourself.
<h3>&emsp;Committing and pushing</h3>

You can commit and push as normal to a repository that contains Git LFS content. 
If you have committed changes to files tracked by Git LFS, you will see some additional output from <code>git push</code> as the Git LFS content is transferred to the server:
<code>$ git push
Git LFS: (3 of 3 files) 4.68 MB / 4.68 MB




             

Counting objects: 8, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (8/8), done.
Writing objects: 100% (8/8), 1.16 KiB | 0 bytes/s, done.

Total 8 (delta 1), reused 0 (delta 0)
To git@bitbucket.org:tpettersen/atlasteroids.git
 7039f0a..b3684d3  main -> main</code>
If transferring the LFS files fails for some reason, the push will be aborted and you can safely try again. 

Like Git, Git LFS storage is <em>content addressable</em>: content is stored against a key which is a SHA-256 hash of the content itself. 
This means it is always safe to re-attempt transferring Git LFS files to the server; you can't accidentally overwrite a Git LFS file's contents with the wrong version.
<h3>&emsp;Moving a Git LFS repository between hosts</h3>
To migrate a Git LFS repository from one hosting provider to another, you can use a combination of <code>git lfs fetch</code> and <code>git lfs push</code> with the <code>--all option</code> specified.

For example, to move all Git and Git LFS repository from a remote named <code>github</code> to a remote named <code>bitbucket</code>  :
<code># create a bare clone of the GitHub repository
$ git clone --bare git@github.com:kannonboy/atlasteroids.git
$ cd atlasteroids

# set up named remotes for Bitbucket and GitHub
$ git remote add bitbucket git@bitbucket.org:tpettersen/atlasteroids.git
$ git remote add github git@github.com:kannonboy/atlasteroids.git
# fetch all Git LFS content from GitHub

$ git lfs fetch --all github
# push all Git and Git LFS content to Bitbucket
$ git push --mirror bitbucket
$ git lfs push --all bitbucket</code>

<h3>&emsp;Fetching extra Git LFS history</h3>
Git LFS typically only downloads the files needed for commits that you actually checkout locally. 
However, you can force Git LFS to download extra content for other recently modified branches using <code>git lfs fetch --recent</code>:
<code>$ git lfs fetch --recent

Fetching main
Git LFS: (0 of 0 files, 14 skipped) 0 B / 0 B, 2.83 MB skipped



         Fetching recent branches within 7 days
Fetching origin/power-ups
Git LFS: (8 of 8 files, 4 skipped) 408.42 KB / 408.42 KB, 2.81 MB skipped

Fetching origin/more-music
Git LFS: (1 of 1 files, 14 skipped) 1.68 MB / 1.68 MB, 2.83 MB skipped</code>
This is useful for batch downloading new Git LFS content while you're out at lunch, or if you're planning on reviewing work from your teammates and will not be able to download content later on due to limited internet connectivity. 
For example, you may wish to run <code>git lfs fetch --recent</code> before jumping on a plane!

Git LFS considers any branch or tag containing a commit newer than seven days as recent. 
You can configure the number of days considered as recent by setting the <code>lfs.fetchrecentrefsdays</code> property:
<code># download Git LFS content for branches or tags updated in the last 10 days
$ git config lfs.fetchrecentrefsdays 10</code>

By default, <code>git lfs fetch --recent</code> will only download Git LFS content for the commit at the tip of a recent branch or tag.
<img src="https://wac-cdn.atlassian.com/dam/jcr:d0336935-7db5-4624-8021-0d96c8aeede1/01.svg?cdnVersion=217" loading="lazy" alt="git lfs - git lfs fetch --recent">However you can configure Git LFS to download content for earlier commits on recent branches and tags by configuring the <code>lfs.fetchrecentcommitsdays</code> property:
<code># download the latest 3 days of Git LFS content for each recent branch or tag
$ git config lfs.fetchrecentcommitsdays 3</code>

Use this setting with care: if you have fast moving branches, this can result in a <em>huge</em> amount of data being downloaded. 
However it can be useful if you need to review interstitial changes on a branch, cherry picking commits across branches, or rewrite history.
<img src="https://wac-cdn.atlassian.com/dam/jcr:bc73a895-bfcc-4e93-a0dc-ff29d1b1ff85/02.svg?cdnVersion=217" loading="lazy" alt="git lfs - git lfs fetch --recent commits">As discussed in <a href="#moving-between-hosts" data-event="clicked" data-uuid="f7026058-ea" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Moving a Git LFS repository between hosts</a>, you can also elect to fetch <em>all</em> Git LFS content for your repository with <code>git lfs fetch --all</code>:
<code>$ git lfs fetch --all

Scanning for all objects ever referenced...
 23 objects found






    
Fetching objects...
Git LFS: (9 of 9 files, 14 skipped) 2.06 MB / 2.08 MB, 2.83 MB skipped</code>

<h3>&emsp;Deleting local Git LFS files</h3>
You can delete files from your local Git LFS cache with the <code>git lfs prune</code> command:
<code>$ git lfs prune
 4 local objects, 33 retained





       

Pruning 4 files, (2.1 MB)
 Deleted 4 files</code>
This will delete any local Git LFS files that are considered <em>old</em>. 
An old file is any file <strong>not</strong> referenced by:

the currently checked out commit
a commit that has not yet been pushed (to origin, or whatever <code>lfs.pruneremotetocheck</code> is set to)
a recent commit
By default, a recent commit is any commit created in the last <em>ten</em> days. 

This is calculated by adding:
the value of the <code>lfs.fetchrecentrefsdays</code> property discussed in <a href="#fetching-history" data-event="clicked" data-uuid="df122a87-ab" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Fetching extra Git LFS history</a> (which defaults to <em>seven</em>); to
the value of the <code>lfs.pruneoffsetdays</code> property (which defaults to <em>three</em>)
<img src="https://wac-cdn.atlassian.com/dam/jcr:3af646d9-762d-4a57-a769-bb10bb02b0aa/03.svg?cdnVersion=217" loading="lazy" alt="git lfs prune">You can configure the prune offset to retain Git LFS content for a longer period:

<code># don't prune commits younger than four weeks (7 + 21)
$ git config lfs.pruneoffsetdays 21</code>
Unlike Git's built-in garbage collection, Git LFS content is <em>not</em> pruned automatically, so running <code>git lfs prune</code> on a regular basis is a good idea to keep your local repository size down.
You can test out what effect a prune operation will have with <code>git lfs prune --dry-run</code>:

<code>$ git lfs prune --dry-run
 4 local objects, 33 retained





       
4 files would be pruned (2.1 MB)</code>
And exactly which Git LFS objects will be pruned with <code>git lfs prune --verbose --dry-run</code>:

<code>$ git lfs prune --dry-run --verbose
 4 local objects, 33 retained





       
4 files would be pruned (2.1 MB)
* 4a3a36141cdcbe2a17f7bcf1a161d3394cf435ac386d1bff70bd4dad6cd96c48 (2.0 MB)

* 67ad640e562b99219111ed8941cb56a275ef8d43e67a3dac0027b4acd5de4a3e (6.3 KB)
* 6f506528dbf04a97e84d90cc45840f4a8100389f570b67ac206ba802c5cb798f (1.7 MB)
* a1d7f7cdd6dba7307b2bac2bcfa0973244688361a48d2cebe3f3bc30babcf1ab (615.7 KB)</code>
The long hexadecimal strings output by <code>--verbose</code> mode are SHA-256 hashes (also known as Object IDs, or OIDs) of the Git LFS objects to be pruned. 

You can use the techniques described in <a href="#finding-references" data-event="clicked" data-uuid="8269543c-35" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Finding paths or commits that reference a Git LFS object</a> to find our more about the objects that will be pruned.
As an additional safety check, you can use the <code>--verify-remote</code> option to check whether the remote Git LFS store has a copy of your Git LFS objects before they are pruned:
<code>$ git lfs prune --verify-remote
 16 local objects, 2 retained, 12 verified with remote




           

Pruning 14 files, (1.7 MB)
 Deleted 14 files</code>
This makes the pruning process significantly slower, but gives you peace of mind knowing that any pruned objects are recoverable from the server. 
You can enable the <code>--verify-remote</code> option permanently for your system by configuring the <code>lfs.pruneverifyremotealways</code> property globally:

<code>$ git config --global lfs.pruneverifyremotealways true </code>
Or you can enable remote verification for just the context repository by omitting the <code>--global</code> option from the command above.
<h3>&emsp;Deleting remote Git LFS files from the server</h3>
The Git LFS command-line client doesn't support pruning files from the server, so how you delete them depends on your hosting provider.

In Bitbucket Cloud, you can view and delete Git LFS files via <strong>Repository Settings > Git LFS</strong>:
<img src="https://wac-cdn.atlassian.com/dam/jcr:46218516-f4aa-490a-9afc-c36ca863c98f/09.png?cdnVersion=217" loading="lazy" alt="Bitbucket Cloud - delete lfs from server">Note that each Git LFS file is indexed by its SHA-256 OID; the paths that reference each file are not visible via the UI. 
This is because there could be many different paths at many different commits that may refer to a given object, so looking them up would be a very slow process.
To determine what a given Git LFS file actually contains, you have three options:

look at the file preview image and file type in the left hand column of the Bitbucket Git LFS UI
download the file using the link in the right hand column of the Bitbucket Git LFS UI -search for commits referencing the Git LFS object's SHA-256 OID, as discussed in the next section
<h3>&emsp;Finding paths or commits that reference a Git LFS object</h3>
If you have a Git LFS SHA-256 OID, you can determine which commits reference it with <code>git log --all -p -S <oid></oid></code>:

<code>$ git log --all -p -S 3b6124b8b01d601fa20b47f5be14e1be3ea7759838c1aac8f36df4859164e4cc
commit 22a98faa153d08804a63a74a729d8846e6525cb0
Author: Tim Pettersen &lt;tpettersen@atlassian.com>
Date:   Wed Jul 27 11:03:27 2016 +1000

Projectiles and exploding asteroids
diff --git a/Assets/Sprites/projectiles-spritesheet.png
new file mode 100755
index 0000000..49d7baf

--- /dev/null
+++ b/Assets/Sprites/projectiles-spritesheet.png
@@ -0,0 +1,3 @@
+version https://git-lfs.github.com/spec/v1

+oid sha256:3b6124b8b01d601fa20b47f5be14e1be3ea7759838c1aac8f36df4859164e4cc
+size 21647</code>
This <code>git log</code> incantation generates a patch (<code>-p</code>) from commits on any branch (<code>--all</code>) that add or remove a line (<code>-S</code>) containing the specified string (a Git LFS SHA-256 OID).
The patch shows you the commit and the path to the LFS object, as well as who added it, and when it was committed. 

You can simply checkout the commit, and Git LFS will download the file if needed and place it in your working copy.
If you suspect that a particular Git LFS object is in your current HEAD, or on a particular branch, you can use <code>git grep</code> to find the file path that references it:
<code># find a particular object by OID in HEAD
$ git grep 3b6124b8b01d601fa20b47f5be14e1be3ea7759838c1aac8f36df4859164e4cc HEAD

HEAD:Assets/Sprites/projectiles-spritesheet.png:oid sha256:3b6124b8b01d601fa20b47f5be14e1be3ea7759838c1aac8f36df4859164e4cc
# find a particular object by OID on the "power-ups" branch
$ git grep e88868213a5dc8533fc9031f558f2c0dc34d6936f380ff4ed12c2685040098d4 power-ups
power-ups:Assets/Sprites/shield2.png:oid sha256:e88868213a5dc8533fc9031f558f2c0dc34d6936f380ff4ed12c2685040098d4</code>

You can replace <code>HEAD</code> or <code>power-ups</code> with any ref, commit, or tree that contains the Git LFS object.
<h3>&emsp;Including/excluding Git LFS files</h3>
In some situations you may want to only download a subset of the available Git LFS content for a particular commit. 
For example, when configuring a CI build to run unit tests, you may only need your source code, so may want to exclude heavyweight files that aren't necessary to build your code.

You can exclude a pattern or subdirectory using <code>git lfs fetch -X</code> (or <code>--exclude</code>):
<code>$ git lfs fetch -X "Assets/**" </code>
Alternatively, you may want to only include a particular pattern or subdirectory. 
For example, an audio engineer could fetch just <code>ogg</code> and <code>wav</code> files with <code>git lfs fetch -I</code> (or <code>--include</code>):

<code>$ git lfs fetch -I "*.ogg,*.wav" </code>
If you combine includes and excludes, only files that match an include pattern <em>and</em> do not match an exclude pattern will be fetched. 
For example, you can fetch everything in your <em>Assets</em> directory <em>except</em> <code>gifs</code> with:
<code>$ git lfs fetch -I "Assets/**" -X "*.gif" </code>

Excludes and includes support the same patterns as <a href="#tracking-files" data-event="clicked" data-uuid="eb24aa8d-ff" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket"><code>git lfs track</code></a> and <code>.gitignore</code>. 
You can make these patterns permanent for a particular repository by setting the <code>lfs.fetchinclude</code> and <code>lfs.fetchexclude</code> config properties:
<code>$ git config lfs.fetchinclude "Assets/**"
$ git config lfs.fetchexclude "*.gif"</code>

These settings can also be applied to every repository on your system by appending the <code>--global</code> option.
<h3>&emsp;Locking Git LFS files</h3>
Unfortunately, there is no easy way of resolving binary merge conflicts. 
With Git LFS file locking, you can lock files by extension or by file name and prevent binary files from being overwritten during a merge.

In order to take advantage of LFS' file locking feature, you first need to tell Git which type of files are lockable. 
In the example below, the `--lockable` flag is appended to the `git lfs track` command which both stores PSD files in LFS and marks them as lockable.
<code>$ git lfs track "*.psd" --lockable</code>
Then add the following to your .gitattributes file:

<code>*.psd filter=lfs diff=lfs merge=lfs -text lockable</code>
When preparing to make changes to an LFS file, you'll use the lock command in order to register the file as locked on your Git server.
<code>$ git lfs lock images/foo.psd
Locked images/foo.psd</code>

Once you no longer need the file lock, you can remove it using Git LFS' unlock command.
<code>$ git lfs unlock images/foo.psd</code>
Git LFS file locks can be overridden, similar to <code>git push</code>, using a <code>--force</code> flag. 
Do not use the <code>--force</code> flag unless you’re absolutely sure you know what you’re doing.

<code>$ git lfs unlock images/foo.psd --force</code>
<h3>&emsp;How Git LFS works</h3>
If you're interested in learning more about clean and smudge filters, pre-push hooks, and the other interesting computer science behind Git LFS, check out this presentation from Atlassian on Git LFS at LinuxCon 2016:
<iframe allowfullscreen="" frameborder="0" height="300" src="https://www.youtube.com/embed/w-037RcHjAA" width="100%"></iframe>

<h2><br><span class="orange">Git gc</span></h2>
The <code>git gc</code> command is a repository maintenance command. 
The "gc" stands for garbage collection. 
Executing <code>git gc</code> is literally telling Git to clean up the mess it's made in the current repository. 

Garbage collection is a concept that originates from interpreted programming languages which do dynamic memory allocation. 
Garbage collection in interpreted languages is used to recover memory that has become inaccessible to the executing program.
Git repositories accumulate various types of garbage. 
One type of Git garbage is orphaned or inaccessible commits. 

Git commits can become inaccessible when performing history altering commands like <code><a href="/git/tutorials/undoing-changes/git-reset" data-event="clicked" data-uuid="2e855c31-cd" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git resets</a></code> or <code><a href="/git/tutorials/rewriting-history/git-rebase" data-event="clicked" data-uuid="2e855c31-cd" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git rebase</a></code>. 
In an effort to preserve history and avoid data loss Git will not delete detached commits. 
A detached commit can still be checked out, cherry picked, and examined through the <code>git log</code>.
In addition to detached commit clean up, <code>git gc</code> will also perform compression on stored Git Objects, freeing up precious disk space. 

When Git identifies a group of similar objects it will compress them into a 'pack'. 
Packs are like zip files of Git bjects and live in the <code>./git/objects/pack</code> directory within a repository.
<h2><span class="saddlebrown">&emsp;What does git gc actually do?</span></h2>
Before execution, <code>git gc</code> first checks several <code><a href="/git/tutorials/setting-up-a-repository/git-config" data-event="clicked" data-uuid="d15b6250-31" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git config</a> </code>values. 

These values will help clarify the rest of <code>git gc</code> responsibility.
<h3>&emsp;git gc configuration</h3>
<code>gc.reflogExpire</code>
An optional variable that defaults to 90 days. 

It is used to set how long records in a branches reflog should be preserved.
<code>gc.reflogExpireUnreachable</code>
An optional variable that defaults to 30 days. 
It is used to set how long inaccessible reflog records should be preserved.

<code>gc.aggressiveWindow</code>
An optional variable that defaults to 250. 
It controls how much time is spent in the delta compression phase of object packing when <code>git gc</code> is executed with the <code>--aggressive</code> option.
<code>gc.aggressiveDepth</code>

Optional variable that defaults to 50. 
It controls the depth of compression <code>git-repack</code> uses during a <code>git gc --aggresive</code> execution
<code>gc.pruneExpire</code>
Optional variable that defaults to "2 weeks ago". 

It sets how long a inaccessible object will be preserved before pruning
<code>gc.worktreePruneExpire</code>
Optional variable that defaults to "3 months ago". 
It sets how long a stale working tree will be preserved before being deleted.

<h3>&emsp;git gc execution</h3>
Behind the scenes <code>git gc</code> actually executes a bundle of other internal subcommands like <code><a href="/git/tutorials/git-prune" data-event="clicked" data-uuid="c929138c-c7" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git prune</a></code>, <code>git repack</code>, <code>git pack</code> and <code>git rerere</code>. 
The high-level responsibility of these commands is to identify any Git objects that are outside the threshold levels set from the <code>git gc</code> configuration. 
Once identified, these objects are then compressed, or pruned accordingly.
<h2><span class="saddlebrown">&emsp;git gc best practices and FAQS</span></h2>
Garbage collection is run automatically on several frequently used commands:
<code><a href="/git/tutorials/making-a-pull-request" data-event="clicked" data-uuid="fb29806e-53" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git pull</a></code>
<code><a href="/git/tutorials/git-merge" data-event="clicked" data-uuid="fb29806e-53" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git merge</a></code>

<code><a href="/git/tutorials/rewriting-history/git-rebase" data-event="clicked" data-uuid="fb29806e-53" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git rebase</a></code>
<code><a href="/git/tutorials/saving-changes" data-event="clicked" data-uuid="fb29806e-53" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git commit</a></code>
The frequency in which <code>git gc</code> should be manually executed corresponds to the activity level of a repository. 
A repository with a single contributing developer will need to execute <code>git gc</code> far less often than a frequently-updated multi-user repository.
<h2><span class="saddlebrown">&emsp;git gc vs git prune</span></h2>
<code>git gc</code> is a parent command and <code>git prune</code> is a child. 
<code>git gc</code> will internally trigger <code>git prune</code>. 
<code>git prune</code> is used to remove Git objects that have been deemed inaccessible by the <code>git gc</code> configuration. 

Learn more about <code><a href="/git/tutorials/git-prune" data-event="clicked" data-uuid="ea84e22a-e7" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git prune</a></code>.
<h2><span class="saddlebrown">&emsp;What is git gc aggressive?</span></h2>
<code>git gc</code> can be invoked with the <code>--aggressive</code> command line option. 
The <code>--aggressive</code> option causes <code>git gc</code> to spend more time on its optimization effort. 

This causes <code>git gc</code> to run slower but will save more disk space after its completion. 
The effects of <code>--aggressive</code> are persistent and only need to be run after a large volume of changes to a repository.
<h2><span class="saddlebrown">&emsp;What is git gc auto?</span></h2>
The <code>git gc --auto</code> command variant first checks if any housekeeping is required on the repo before executing. 

If it finds housekeeping is not needed it exits without doing any work. 
Some Git commands implicitly run <code>git gc --auto</code> after execution to clean up any loose objects they have created.
Before execution <code>git gc --auto</code> will check the <code>git</code> configuration for threshold values on loose objects and packing compression size. 
These values can be set with <code><a href="/git/tutorials/setting-up-a-repository/git-config" data-event="clicked" data-uuid="79b78b02-fc" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git config</a></code>. 

If the repository surpasses any of the housekeeping thresholds <code>git gc --auto</code> will be executed.
<h2><span class="saddlebrown">&emsp;Getting started with git gc</span></h2>
You're probably already using <code>git gc</code> without noticing. 
As discussed in the best practices section, it is automatically invoked through frequently used commands. 

If you want to manually invoke it simply execute <code>git gc</code> and you should see an output indicating the work it has performed.
<h2><br><span class="orange">Git Prune</span></h2>
The <code>git prune</code> command is an internal housekeeping utility that cleans up unreachable or "orphaned" Git objects. 
Unreachable objects are those that are inaccessible by any refs. 

Any commit that cannot be accessed through a branch or tag is considered unreachable. 
<code>git prune</code> is generally not executed directly. 
Prune is considered a garbage collection command and is a child command of the <code><a href="/git/tutorials/git-gc" data-event="clicked" data-uuid="a7353687-32" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git gc</a></code> command.
<h2><span class="saddlebrown">&emsp;Git Prune Overview</span></h2>
In order to understand the effects of <code>git prune</code> we need to simulate a scenario where a commit becomes unreachable. 
The following is a sequence of command line executions that will simulate this experience.
<code>~ $ cd git-prune-demo/
~/git-prune-demo $ git init .

Initialized empty Git repository in /Users/kev/Dropbox/git-prune-demo/.git/
~/git-prune-demo $ echo "hello git prune" > hello.txt
~/git-prune-demo $ git add hello.txt
~/git-prune-demo $ git commit -am "added hello.txt"</code>

The preceding sequence of commands will create a new repository in a directory named <code>git-prune-demo</code>. 
One commit consisting of a new file <code>hello.text</code> is added to the repo with the basic content of "hello git prune". 
Next, we will create modify <code>hello.txt</code> and create a new commit from those modifications.
<code>~/git-prune-demo $ echo "this is second line txt" >> hello.txt

~/git-prune-demo $ cat hello.txt
hello git prune
this is second line txt
~/git-prune-demo $ git commit -am "added another line to hello.txt"

[main 5178bec] added another line to hello.txt
1 file changed, 1 insertion(+)</code>
We now have a 2 commit history in this demo repo. 
We can verify by using <code>git log</code>:

<code>~/git-prune-demo $ git log
commit 5178becc2ca965e1728554ce1cb8de2f2c2370b1
Author: kevzettler &lt;kevzettler@gmail.com>
Date:   Sun Sep 30 14:49:59 2018 -0700

    added another line to hello.txt
commit 994b122045cf4bf0b97139231b4dd52ea2643c7e
Author: kevzettler &lt;kevzettler@gmail.com>
Date:   Sun Sep 30 09:43:41 2018 -0700

    added hello.txt</code>
The <code><a href="/git/tutorials/git-log" data-event="clicked" data-uuid="b2910bc4-74" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git log</a></code> output displays the 2 commits and corresponding commit messages about the edits made to <code>hello.txt</code>. 
The next step is for us to make one of the commits unreachable. 
We will do this by utilizing the <code><a href="/git/tutorials/undoing-changes/git-reset" data-event="clicked" data-uuid="b2910bc4-74" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git reset</a></code> command. 

We reset the state of the repo to the first commit. 
the "added hello.txt" commit.
<code>~/git-prune-demo $ git reset --hard 994b122045cf4bf0b97139231b4dd52ea2643c7e
HEAD is now at 994b122 added hello.txt</code>

If we now use <code>git log</code> to examine the state of the repository we can see that we only have one commit
<code>~/git-prune-demo $ git log
commit 994b122045cf4bf0b97139231b4dd52ea2643c7e
Author: kevzettler &lt;kevzettler@gmail.com>

Date:   Sun Sep 30 09:43:41 2018 -0700
    added hello.txt</code>
The demo repository is now in a state that contains a detached commit. 
The second commit we made with the message "added another line to hello.txt" is no longer displayed in the <code>git log</code> output and is now detached. 

It may appear as though we have lost or deleted the commit, but Git is very strict about not deleting history. 
We can confirm it is still available, but detached, by using <code><a href="/git/tutorials/using-branches/git-checkout" data-event="clicked" data-uuid="88bb7ba6-63" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git checkout</a></code> to visit it directly:
<code>~/git-prune-demo $ git checkout 5178becc2ca965e1728554ce1cb8de2f2c2370b1
Note: checking out '5178becc2ca965e1728554ce1cb8de2f2c2370b1'.

You are in 'detached HEAD' state. 
You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. 
Example:
  git checkout -b &lt;new-branch-name>

HEAD is now at 5178bec... 
added another line to hello.txt
~/git-prune-demo $ git log
commit 5178becc2ca965e1728554ce1cb8de2f2c2370b1

Author: kevzettler &lt;kevzettler@gmail.com>
Date:   Sun Sep 30 14:49:59 2018 -0700
  added another line to hello.txt
commit 994b122045cf4bf0b97139231b4dd52ea2643c7e

Author: kevzettler &lt;kevzettler@gmail.com>
Date:   Sun Sep 30 09:43:41 2018 -0700
  added hello.txt</code>
When we check out the detached commit, Git is thoughtful enough to give us a detailed message explaining that we are in a detached state. 

If we examine the log here we can see that the "added another line to hello.txt" commit is now back in the log output! Now that we know the repository is in a good simulation state with a detached commit we can practice using <code>git prune</code>. 
First though, let us return to the <code>main</code> branch using <code>git checkout</code>
<code>~/git-prune-demo $ git checkout main
Warning: you are leaving 1 commit behind, not connected to

any of your branches:
  5178bec added another line to hello.txt
If you want to keep it by creating a new branch, this may be a good time
to do so with:

 git branch &lt;new-branch-name> 5178bec
Switched to branch 'main'</code>
When returning to main via <code>git checkout</code>, Git is again thoughtful enough to let us know that we are leaving a detached commit behind. 
It's now time to prune the detached commit! Next, we will execute <code>git prune</code> but we must be sure to pass some options to it. 

<code>--dry-run</code> and <code>--verbose</code> will display output indicating what is set to be pruned but not actually prune it.
<code>~/git-prune-demo $ git prune --dry-run --verbose</code>
This command will most likely return empty output. 
Empty output implies that the prune will not actually delete anything. 

Why would this happen? Well, the commit is most likely not fully detached. 
Somewhere Git is still maintaining a reference to it. 
This is a prime example of why <code>git prune</code> is not to be used stand-alone outside of <code>git gc</code>. 
This is also a good example of how it is hard to fully lose data with Git.

Most likely Git is storing a reference to our detached commit in the reflog. 
We can investigate by running <code><a href="/git/tutorials/rewriting-history/git-reflog" data-event="clicked" data-uuid="a296a7fc-3d" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git reflog</a></code>. 
You should see some output describing the sequence of actions we took to get here. 
For more info on <code>git reflog</code> visit the <code><a href="/git/tutorials/rewriting-history/git-reflog" data-event="clicked" data-uuid="a296a7fc-3d" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git reflog</a></code> page. 

In addition to preserving history in the reflog, Git has internal expiration dates on when it will prune detached commits. 
Again, these are all implementation details that <code>git gc</code> handles and <code>git prune</code> should not be used standalone.
To conclude our <code>git prune</code> simulation demo we must clear the reflog
<code>~/git-prune-demo $ git reflog expire --expire=now --expire-unreachable=now --all</code>

The above command will force expire all entries to the reflog that are older than now. 
This is a brutal and dangerous command that you should never have to use as casual Git user. 
We are executing this command to demonstrate a successful <code>git prune</code>. 
With the reflog totally wiped we can now execute <code>git prune</code>.

<code>~/git-prune-demo $ git prune --dry-run --verbose --expire=now
1782293bdfac16b5408420c5cb0c9a22ddbdd985 blob
5178becc2ca965e1728554ce1cb8de2f2c2370b1 commit
a1b3b83440d2aa956ad6482535cbd121510a3280 commit

f91c3433eae245767b9cd5bdb46cd127ed38df26 tree</code>
This command should output a list of Git SHA object references that looks like the above.
<h2><span class="saddlebrown">&emsp;Usage</span></h2>
<code>git prune</code> has a short list of options that we covered in the overview section.

<code>-n --dry-run</code>
Don't execute the prune. 
Just show an output of what it will do
<code>-v --verbose</code>

Display output of all objects and actions taken by the prune
<code>--progress</code>
Displays output that indicates the progress of the prune
<code>--expire &lt;time></code>

Force expiration of objects that are past <code><time></time></code>
<code>&lt;head>…</code>
Specifying a  will preserve any options from that head ref
<h2><span class="saddlebrown">&emsp;Discussion</span></h2>
<h3>&emsp;What’s the Difference Between Git Prune, Git Fetch --prune, and Git Remote Prune?</h3>
<code>git remote prune</code> and <code>git fetch --prune</code> do the same thing: delete the refs to branches that don't exist on the remote. 
This is highly desirable when working in a team workflow in which remote branches are deleted after merge to <code>main</code>. 
The second command, <code>git fetch --prune</code> will connect to the remote and fetch the latest remote state before pruning. 

It is essentially a combination of commands:
<code>git fetch --all &amp;&amp; git remote prune</code>
The generic <code>git prune</code> command is entirely different. 
As discussed in the overview section, git prune will delete locally detached commits.

<h3>&emsp;How Do I Clean Outdated Branches?</h3>
<code>git fetch --prune</code> is the best utility for cleaning outdated branches. 
It will connect to a shared remote repository remote and fetch all remote branch refs. 
It will then delete remote refs that are no longer in use on the remote repository.

<h3>&emsp;Does Git Remote Prune Origin Delete the Local Branch?</h3>
No <code>git remote prune origin</code> will only delete the refs to remote branches that no longer exist. 
Git stores both local and remote refs. 
A repository will have <code>local/origin</code> and <code>remote/origin</code> ref collections. 

<code>git remote prune origin</code> will only prune the refs in <code>remote/origin</code>. 
This safely leaves local work in <code>local/origin</code>.
<h2><span class="saddlebrown">&emsp;Git Prune Summary</span></h2>
The <code>git prune</code> command is intended to be invoked as a child command to <code>git gc</code>. 

It is highly unlikely you will ever need to invoke <code>git prune</code> in a day to day software engineering capacity. 
Other commands are needed to understand the effects of <code>git prune</code>. 
Some commands used in this article were <code>git log</code>, <code>git reflog</code>, and <code>git checkout</code>.
<h2><br><span class="orange">Git Bash</span></h2>
At its core, Git is a set of command line utility programs that are designed to execute on a Unix style command-line environment. 
Modern operating systems like Linux and macOS both include built-in Unix command line terminals. 
This makes Linux and macOS complementary operating systems when working with Git. 
Microsoft Windows instead uses Windows command prompt, a non-Unix terminal environment.

In Windows environments, Git is often packaged as part of higher level GUI applications. 
GUIs for Git may attempt to abstract and hide the underlying version control system primitives. 
This can be a great aid for Git beginners to rapidly contribute to a project. 
Once a project's collaboration requirements grow with other team members, it is critical to be aware of how the actual raw Git methods work. 

This is when it can be beneficial to drop a GUI version for the command line tools. 
Git Bash is offered to provide a terminal Git experience.
<h2><span class="saddlebrown">&emsp;What is Git Bash?</span></h2>
Git Bash is an application for Microsoft Windows environments which provides an emulation layer for a Git command line experience. 

Bash is an acronym for Bourne Again Shell. 
A shell is a terminal application used to interface with an operating system through written commands. 
Bash is a popular default shell on Linux and macOS. 
Git Bash is a package that installs Bash, some common bash utilities, and Git on a Windows operating system.
<h2><span class="saddlebrown">&emsp;How to install Git Bash</span></h2>
Git Bash comes included as part of the <a href="https://gitforwindows.org/" data-event="clicked" data-uuid="3313252a-82" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Git For Windows</a> package. 
Download and install Git For Windows like other Windows applications. 
Once downloaded find the included <code>.exe</code> file and open to execute Git Bash.
<h2><span class="saddlebrown">&emsp;How to use Git Bash</span></h2>
Git Bash has the same operations as a standard Bash experience. 
It will be helpful to review basic Bash usage. 
Advanced usage of Bash is outside the scope of this Git focused document.
<h2><span class="saddlebrown">&emsp;How to navigate folders</span></h2>
The Bash command <code>pwd</code> is used to print the 'present working directory'. 
<code>pwd</code> is equivalent to executing <font face="monospace">cd</font> on a DOS(Windows console host) terminal. 
This is the folder or path that the current Bash session resides in.

The Bash command <code>ls</code> is used to 'list' contents of the current working directory. 
<code>ls</code> is equivalent to <code>DIR</code> on a Windows console host terminal.
Both Bash and Windows console host have a <font face="monospace">cd</font> command. 
<font face="monospace">cd</font> is an acronym for 'Change Directory'. 

<font face="monospace">cd</font> is invoked with an appended directory name. 
Executing <font face="monospace">cd</font> will change the terminal sessions current working directory to the passed directory argument.
<h2><span class="saddlebrown">&emsp;Git Bash Commands</span></h2>
Git Bash is packaged with additional commands that can be found in the <code>/usr/bin</code> directory of the Git Bash emulation. 

Git Bash can actually provide a fairly robust shell experience on Windows. 
Git Bash comes packaged with the following shell commands which are outside the scope of this document: <code><a href="https://man.openbsd.org/ssh.1" data-event="clicked" data-uuid="11dd0be1-ac" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Ssh</a></code>, <code><a href="https://linux.die.net/man/1/scp" data-event="clicked" data-uuid="11dd0be1-ac" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">scp</a></code>, <code><a href="http://man7.org/linux/man-pages/man1/cat.1.html" data-event="clicked" data-uuid="11dd0be1-ac" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">cat</a></code>, <code><a href="https://linux.die.net/man/1/find" data-event="clicked" data-uuid="11dd0be1-ac" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">find</a></code>.
In addition the previously discussed set of Bash commands, Git Bash includes the full set of Git core commands discussed through out this site. 
Learn more at the corresponding documentation pages for <code><a href="/git/tutorials/setting-up-a-repository/git-clone" data-event="clicked" data-uuid="11dd0be1-ac" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git clone</a><code>, <code><a href="/git/tutorials/saving-changes/git-commit" data-event="clicked" data-uuid="11dd0be1-ac" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git commit</a></code>, <code><a href="/git/tutorials/using-branches/git-checkout" data-event="clicked" data-uuid="11dd0be1-ac" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git checkout</a></code>, <code><a href="/git/tutorials/syncing/git-push" data-event="clicked" data-uuid="11dd0be1-ac" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git push</a></code>,</code></code> and more.

<h2><br><span class="orange">The best way to store your dotfiles: A bare Git repository</span></h2>
<em>Disclaimer: the title is slightly hyperbolic, there are other proven solutions to the problem. 
I do think the technique below is very elegant though.</em>
Recently I read about this amazing technique in an <a href="https://news.ycombinator.com/item?id=11070797" data-event="clicked" data-uuid="b9ad08bb-3a" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Hacker News thread</a> on people's solutions to store their <a href="https://en.wikipedia.org/wiki/Dot-file" data-event="clicked" data-uuid="b9ad08bb-3a" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">dotfiles</a>. 

User <code>StreakyCobra</code> <a href="https://news.ycombinator.com/item?id=11071754" data-event="clicked" data-uuid="b9ad08bb-3a" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">showed his elegant setup</a> and ... 
It made so much sense! I am in the process of switching my own system to the same technique. 
The only pre-requisite is to install <a href="/git" data-event="clicked" data-uuid="b9ad08bb-3a" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Git</a>.
In his words the technique below requires:

No extra tooling, no symlinks, files are tracked on a version control system, you can use different branches for different computers, you can replicate you configuration easily on new installation.
The technique consists in storing a <a href="http://www.saintsjd.com/2011/01/what-is-a-bare-git-repository/" data-event="clicked" data-uuid="60414dad-7f" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Git bare repository</a> in a "<em>side</em>" folder (like <code>$HOME/.cfg</code> or <code>$HOME/.myconfig</code>) using a specially crafted alias so that commands are run against that repository and not the usual <code>.git</code> local folder, which would interfere with any other Git repositories around.
<h2><span class="saddlebrown">&emsp;Starting from scratch</span></h2>
If you haven't been tracking your configurations in a Git repository before, you can start using this technique easily with these lines:

<code>git init --bare $HOME/.cfg
alias config='/usr/bin/git --git-dir=$HOME/.cfg/ --work-tree=$HOME'
config config --local status.showUntrackedFiles no
echo "alias config='/usr/bin/git --git-dir=$HOME/.cfg/ --work-tree=$HOME'" >> $HOME/.bashrc</code>

The first line creates a folder <code>~/.cfg</code> which is a <a href="http://www.saintsjd.com/2011/01/what-is-a-bare-git-repository/" data-event="clicked" data-uuid="ccebf12a-1b" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Git bare repository</a> that will track our files.
Then we create an alias <code>config</code> which we will use instead of the regular <code>git</code> when we want to interact with our configuration repository.
We set a flag - local to the repository - to hide files we are not explicitly tracking yet. 
This is so that when you type <code>config status</code> and other commands later, files you are not interested in tracking will not show up as <code>untracked</code>.

Also you can add the alias definition by hand to your <code>.bashrc</code> or use the the fourth line provided for convenience.
I packaged the above lines into a <a href="https://bitbucket.org/snippets/nicolapaolucci/ergX9" data-event="clicked" data-uuid="ccebf12a-1b" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">snippet</a> up on Bitbucket and linked it from a short-url. 
So that you can set things up with:
<code>curl -Lks http://bit.do/cfg-init | /bin/bash</code>

After you've executed the setup any file within the <code>$HOME</code> folder can be versioned with normal commands, replacing <code>git</code> with your newly created <code>config</code> alias, like:
<code>config status
config add .vimrc
config commit -m "Add vimrc"

config add .bashrc
config commit -m "Add bashrc"
config push</code>
<h2><span class="saddlebrown">&emsp;Install your dotfiles onto a new system (or migrate to this setup)</span></h2>
If you already store your configuration/dotfiles in a <a href="/git" data-event="clicked" data-uuid="05fca68b-75" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Git repository</a>, on a new system you can migrate to this setup with the following steps:
Prior to the installation make sure you have committed the alias to your <code>.bashrc</code> or <code>.zsh</code>:
<code>alias config='/usr/bin/git --git-dir=$HOME/.cfg/ --work-tree=$HOME'</code>
And that your source repository ignores the folder where you'll clone it, so that you don't create weird recursion problems:

<code>echo ".cfg" >> .gitignore</code>
Now clone your dotfiles into a <a href="http://www.saintsjd.com/2011/01/what-is-a-bare-git-repository/" data-event="clicked" data-uuid="0b08395c-43" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">bare</a> repository in a "<em>dot</em>" folder of your <code>$HOME</code>:
<code>git clone --bare &lt;git-repo-url> $HOME/.cfg</code>
Define the alias in the current shell scope:

<code>alias config='/usr/bin/git --git-dir=$HOME/.cfg/ --work-tree=$HOME'</code>
Checkout the actual content from the bare repository to your <code>$HOME</code>:
<code>config checkout</code>
The step above might fail with a message like:

<code>error: The following untracked working tree files would be overwritten by checkout:
.bashrc
.gitignore
Please move or remove them before you can switch branches.

Aborting</code>
This is because your <code>$HOME</code> folder might already have some stock configuration files which would be overwritten by Git. 
The solution is simple: back up the files if you care about them, remove them if you don't care. 
I provide you with a possible rough shortcut to move all the offending files automatically to a backup folder:

<code>mkdir -p .config-backup &amp;&amp; \
config checkout 2>&amp;1 | egrep "\s+\." | awk {'print $1'} | \
xargs -I{} mv {} .config-backup/{}</code>
Re-run the check out if you had problems:

<code>config checkout</code>
Set the flag <code>showUntrackedFiles</code> to <code>no</code> on this specific (local) repository:
<code>config config --local status.showUntrackedFiles no</code>
You're done, from now on you can now type <code>config</code> commands to add and update your dotfiles:

<code>config status
config add .vimrc
config commit -m "Add vimrc"
config add .bashrc

config commit -m "Add bashrc"
config push</code>
Again as a shortcut not to have to remember all these steps on any new machine you want to setup, you can create a simple script, <a href="https://bitbucket.org/snippets/nicolapaolucci/7rE9K" data-event="clicked" data-uuid="a253817e-a4" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">store it as Bitbucket snippet</a> like I did, <a href="http://bit.do/" data-event="clicked" data-uuid="a253817e-a4" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">create a short url</a> for it and call it like this:
<code>curl -Lks http://bit.do/cfg-install | /bin/bash</code>

For completeness this is what I ended up with (tested on many freshly minted <a href="http://www.alpinelinux.org/" data-event="clicked" data-uuid="e61989a4-a0" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Alpine Linux</a> containers to test it out):
<code>git clone --bare https://bitbucket.org/durdn/cfg.git $HOME/.cfg
function config {
 /usr/bin/git --git-dir=$HOME/.cfg/ --work-tree=$HOME $@

}
mkdir -p .config-backup
config checkout
if [ $? = 0 ]; then

echo "Checked out config.";
else
echo "Backing up pre-existing dot files.";
config checkout 2>&amp;1 | egrep "\s+\." | awk {'print $1'} | xargs -I{} mv {} .config-backup/{}

fi;
config checkout
config config status.showUntrackedFiles no</code>
<h2><span class="saddlebrown">&emsp;Wrapping up</span></h2>
I hope you find this technique useful to track your configuration. 
If you're curious, <a href="https://bitbucket.org/durdn/cfg.git" data-event="clicked" data-uuid="f0ce43f5-48" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">my dotfiles live here</a>. 
Also please do stay connected by following <a href="https://www.twitter.com/durdn" data-event="clicked" data-uuid="f0ce43f5-48" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">@durdn</a> or my awesome team at <a href="https://www.twitter.com/atlassiandev" data-event="clicked" data-uuid="f0ce43f5-48" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">@atlassiandev</a>.
<h2><br><span class="orange">Git Cherry Pick</span></h2>
<code>git cherry-pick</code> is a powerful command that enables arbitrary Git commits to be picked by reference and appended to the current working HEAD. 
Cherry picking is the act of picking a commit from a branch and applying it to another. 
<code>git cherry-pick</code> can be useful for undoing changes. 
For example, say a commit is accidently made to the wrong branch. 

You can switch to the correct branch and cherry-pick the commit to where it should belong.
<h2><span class="saddlebrown">&emsp;When to use git cherry pick</span></h2>
<code>git cherry-pick</code> is a useful tool but not always a best practice. 
Cherry picking can cause duplicate commits and many scenarios where cherry picking would work, traditional merges are preferred instead. 

With that said <code>git cherry-pick</code> is a handy tool for a few scenarios...
<h2><span class="saddlebrown">&emsp;Team collaboration.</span></h2>
Often times a team will find individual members working in or around the same code. 
Maybe a new product feature has a backend and frontend component. 

There may be some shared code between to two product sectors. 
Maybe the backend developer creates a data structure that the frontend will also need to utilize. 
The frontend developer could use <code>git cherry-pick</code> to pick the commit in which this hypothetical data structure was created. 
This pick would enable the frontend developer to continue progress on their side of the project.
<h2><span class="saddlebrown">&emsp;Bug hotfixes</span></h2>
When a bug is discovered it is important to deliver a fix to end users as quickly as possible. 
For an example scenario,say a developer has started work on a new feature. 
During that new feature development they identify a pre-existing bug. 

The developer creates an explicit commit patching this bug. 
This new patch commit can be cherry-picked directly to the <code>main</code> branch to fix the bug before it effects more users.
<h2><span class="saddlebrown">&emsp;Undoing changes and restoring lost commits</span></h2>
Sometimes a <code>feature</code> branch may go stale and not get merged into <code>main</code>. 

Sometimes a pull request might get closed without merging. 
Git never loses those commits and through commands like <code><a href="/git/tutorials/git-log" data-event="clicked" data-uuid="c6f9669c-b5" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git log</a></code> and <code><a href="/git/tutorials/rewriting-history/git-reflog" data-event="clicked" data-uuid="c6f9669c-b5" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git reflog</a></code> they can be found and cherry picked back to life.
<h2><span class="saddlebrown">&emsp;How to use git cherry pick</span></h2>
To demonstrate how to use <code>git cherry-pick</code> let us assume we have a repository with the following branch state:

<code>    a - b - c - d   Main
     \
       e - f - g Feature</code>
<code>git cherry-pick</code> usage is straight forward and can be executed like:

<code>git cherry-pick commitSha</code>
In this example <code>commit</code>Sha is a commit reference. 
You can find a commit reference by using <code>git log</code>. 
In this example we have constructed lets say we wanted to use commit `f` in <code>main</code>. 

First we ensure that we are working on the <code>main</code> branch.
<code>git checkout main</code>
Then we execute the cherry-pick with the following command:
<code>git cherry-pick f</code>

Once executed our Git history will look like:
<code>    a - b - c - d - f   Main
     \
       e - f - g Feature</code>

The f commit has been successfully picked into the main branch
<h2><span class="saddlebrown">&emsp;Examples of git cherry pick</span></h2>
<code>git cherry pick</code> can also be passed some execution options.
<code>-edit</code>

Passing the <code>-edit</code> option will cause git to prompt for a commit message before applying the cherry-pick operation
<code>--no-commit</code>
The <code>--no-commit</code> option will execute the cherry pick but instead of making a new commit it will move the contents of the target commit into the working directory of the current branch.
<code>--signoff</code>

The <code>--signoff</code> option will add a 'signoff' signature line to the end of the cherry-pick commit message
In addition to these helpful options <code>git cherry-pick</code> also accepts a variety of merge strategy options. 
Learn more about these options at the <a href="/git/tutorials/using-branches/merge-strategy" data-event="clicked" data-uuid="a3eea4d5-33" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git merge strategies</a> documentation.
Additionally, git cherry-pick also accepts option input for merge conflict resolution, this includes options: <code>--abort --continue</code> and <code>--quit</code> this options are covered more in depth with regards to <a href="/git/tutorials/using-branches/git-merge" data-event="clicked" data-uuid="a3eea4d5-33" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git merge</a> and <a href="/git/tutorials/rewriting-history/git-rebase" data-event="clicked" data-uuid="a3eea4d5-33" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git rebase</a>.
<h2><span class="saddlebrown">&emsp;Summary</span></h2>
Cherry picking is a powerful and convenient command that is incredibly useful in a few scenarios. 
Cherry picking should not be misused in place of <a href="/git/tutorials/using-branches/git-merge" data-event="clicked" data-uuid="75d82edd-7e" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git merge</a> or <a href="/git/tutorials/rewriting-history/git-rebase" data-event="clicked" data-uuid="75d82edd-7e" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git rebase</a>. 
The <a href="/git/tutorials/git-log" data-event="clicked" data-uuid="75d82edd-7e" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git log</a> command is required to help find commits to cherry pick.

<h2><br><span class="orange">Gitk</span></h2>
Gitk is a graphical repository browser. 
It was the first of its kind. 
It can be thought of as a GUI wrapper for <code><a href="/git/tutorials/git-log" data-event="clicked" data-uuid="a83fe36b-e3" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git log</a></code>. 

It is useful for exploring and visualizing the history of a repository. 
It’s written in tcl/tk which makes it portable across operating systems. 
<code>gitk</code> is maintained by Paul Mackerras as an independent project, separate from Git core. 
Stable versions are distributed as part of the Git suite for the convenience of end users. 

Gitk can be a helpful learning aid for newcomers to Git.
<h2><span class="saddlebrown">&emsp;Gitk Overview</span></h2>
Gitk can be a helpful learning utility for those new to version control, or those transitioning from another version control system like subversion. 
Gitk is a convenience utility that is packaged with Git core. 

It provides a graphical user interface that helps with visualization of Git's internal mechanics. 
Other popular Git GUIs are git-gui and Atlassian's own <a href="http://www.sourcetreeapp.com/" data-event="clicked" data-uuid="f47d9f1f-26" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Sourcetree</a>.
<h2><span class="saddlebrown">&emsp;Usage</span></h2>
Gitk is invoked similarly to <code>git log</code>. 

Executing the <code>gitk</code> command will launch the Gitk UI which will look similar to the following:
<img src="https://wac-cdn.atlassian.com/dam/jcr:ffef9006-9b6b-47c2-a997-6463a2780c06/01%20initial%20kopiera.png?cdnVersion=217" loading="lazy" alt="">The upper left pane displays the commits to the repository, with the latest on top. 
The lower right displays the list of files impacted by the selected commit. 
The lower left pane displays the commit details and full diff. 

Clicking a file in the lower right pane focuses the diff in the lower left pane to the relevant section.
Gitk will reflect the current state of the repository. 
If the repository state is modified through separate command line usage like changing branches Gitk will need to be reloaded. 
Gitk can be reloaded by on the File menu -> Reload.

By default Gitk will render the current history of commits. 
Gitk has a variety of command line options that can be passed on initialization. 
These options primarily restrict the list of commits rendered to Gitk's top-level view. 
The general form of execution with these revision options is as follows:
<h2><span class="saddlebrown">&emsp;Options</span></h2>
<code>    gitk [&lt;options>] [&lt;revision range>] [--] [&lt;path>…]
&lt;revision range></code>
A revision range in the form <code>"<from>..<to>"</to></from></code> can be passed to show all revisions between <code><from></from></code> and back to <code><to></to></code>. 

Alternatively, a single revision can be passed.
<code>    &lt;path>…</code>
Limit commits to a specific file path. 
To isolate paths from revision names use "--" to separate the paths from any preceding options.

<code>--all
</code>
Shows all branches, tags, refs.
<code>--branches[=&lt;pattern>] --tags[=&lt;pattern>] --remotes[=&lt;pattern>]</code>

Displays the selected item (branches, tags, remotes) as if they were mainline commits. 
When  is passed, further limits refs to ones matching the specified pattern
<code>    --since=&lt;date></code>
Render commits more recent than the specified date.

<code>    --until=&lt;date></code>
Render commits older than the specified date.
<code>    --date-order</code>
Sort commits by date.

<code>    --merge</code>
Show commits that modify conflicted files that were identified during a merge
<code>    --left-right</code>
Renders informative labels that indicate which side of a diff commits are from. 

Commits from the left side are prefixed with a &lt; symbol and those from the right with a > symbol.
<code>    --ancestry-path</code>
When given a range of commits to display (e.g. 
<code>commit1..commit2 or commit2 commit1</code>), only display commits that exist directly on the ancestry chain between the <code>commit1</code> and <code>commit2</code>, i.e. 

commits that are both descendants of <code>commit1</code>, and ancestors of <code>commit2</code>. 
(See "History simplification" in <code>git-log(1)</code> for a more detailed explanation.)
<code>L&lt;start>,&lt;end>:&lt;file></code>
Powerful options that let you trace the history of a given code line number range.
<h2><span class="saddlebrown">&emsp;Discussion &amp; Examples</span></h2>
In order to provide any valuable output, Gitk needs an underlying repository with committed history. 
The following code is a sequence of bash commands that will create a new repo with two branches that have commits and have been <a href="/git/tutorials/using-branches/git-merge" data-event="clicked" data-uuid="b95b79ab-6d" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">merged</a> into one.
<code>    mkdir gitkdemo &amp;&amp;

cd gitkdemo &amp;&amp;
git init . 
&amp;&amp;
echo "hello world" > index.txt &amp;&amp;

git add index.txt &amp;&amp;
git commit -m "added index.txt with hello world content"</code>
This demo repository will be a good example to explore with Gitk. 
This command sequence creates a new repo with 1 commit and an <code>index.txt</code> file. 

Let us now invoke <code>gitk</code> to examine the repo.
<img src="https://wac-cdn.atlassian.com/dam/jcr:d562475f-a051-415d-a184-3d70172a24bd/02%20first-commit%20kopiera.png?cdnVersion=217" loading="lazy" alt="">
<h2><span class="saddlebrown">&emsp;Can Gitk Compare Two Commits?</span></h2>
Continuing with our demo repository let us now create an additional commit:
<code>    echo "prpended content to index" >> index.txt &amp;&amp;

git commit -am "prepended content to index"</code>
Once the proceeding commands are executed, <code>gitk</code> will need to be reloaded. 
Either reload <code>gitk</code> from the command line or use the GUI and navigate to <code>File -> Reload</code>. 
Once reloaded we should see our new <code>commit</code>.

<img src="https://wac-cdn.atlassian.com/dam/jcr:5f28aed4-73e0-4423-87b0-139da44bb318/03%20next-commit%20kopiera.png?cdnVersion=217" loading="lazy" alt="">We can see that the <code>main</code> branch ref is now pointed at the new commit. 
To compare these two commits we use the upper left history panel. 
Within the history panel click on a commit that will be the base of the diff. 
Once selected, right click on a second commit to open up a context menu.

<img src="https://wac-cdn.atlassian.com/dam/jcr:684fc06c-c4a7-4c1d-b2ea-576d146fc99f/04%20commit-diff%20kopiera.png?cdnVersion=217" loading="lazy" alt="">This context menu will provide the options of
<code>    Diff this -> selected
Diff selected -> this</code>
Selecting either of these options will cause a diff between the two commits to appear in the lower left pane which in our example will look like:

<img src="https://wac-cdn.atlassian.com/dam/jcr:2f861a4d-e966-4a15-9727-4baa1f906c42/diff-output.png?cdnVersion=217" loading="lazy" alt="">The diff output shows us that <code>index.txt</code> had a new line of "prepended content to index" added between the two commits.
<h2><span class="saddlebrown">&emsp;How to Use Gitk to Compare Two Branches</span></h2>
Continuing with our example repo, let's create a new branch.
<code>    git checkout -b new_branch &amp;&amp;

echo "new branch content" > new_branch_file.txt &amp;&amp;
git add new_branch_file.txt &amp;&amp;
git commit -m "new branch commit with new file and prepended content" &amp;&amp;
echo "new branch index update" >> index.txt &amp;&amp;

git commit -am "new branch commit to index.txt with new content"</code>
The proceeding command sequence will create a new branch named <code>new_branch</code> and add file <code>new_branch_file.txt</code> to it. 
Additionally, new content is added to <code>index.txt</code> and an additional commit is made for that update. 
We now have a new branch that is 2 commits ahead of main. 

We must reload Gitk to reflect these changes.
<img src="https://wac-cdn.atlassian.com/dam/jcr:174879a8-bdfe-4879-84ed-f2081c74b451/05%20new-branch%20kopiera.png?cdnVersion=217" loading="lazy" alt="">This is a great learning opportunity to discuss Git's branching mechanism. 
Gitk displays the commits as a straight line sequence of commits. 
The term branch implies that we should expect a 'branch' or fork in the timeline. 

Git branches are different from other version control systems. 
In Git, a branch is a pointer to a commit. 
The pointer moves to commits as they are created. 
When you create a <code>git branch</code>, you are not changing anything in the structure of the repository or the source tree. 

You are just creating a new pointer.
In order to compare the commits that differ between the 2 branches Gitk needs to be launched with a specified revision range. 
Executing <code>gitk main..new_branch</code> will open Gitk with only the commits between the two branch refs
<img src="https://wac-cdn.atlassian.com/dam/jcr:75c629ca-695f-4a23-b40b-b6add6fdd6e1/06%20branch-compare%20kopiera.png?cdnVersion=217" loading="lazy" alt="">This is a powerful utility for comparing branches.
<h2><span class="saddlebrown">&emsp;Gitk vs Git Gui</span></h2>
Git Gui is another Tcl/Tk based graphical user interface to Git. 
Whereas Gitk focuses on navigating and visualizing the history of a repository, Git Gui focuses on refining individual <code>commits</code>, single file annotation and does not show project history. 
Git Gui also supplies menu actions to launch Gitk for history exploration. 

Git Gui is also invoked from the command line by executing <code>git gui</code>.
<h2><span class="saddlebrown">&emsp;Gitk Summary</span></h2>
In conclusion, Gitk is a graphical interface wrapper for <code>git log</code>. 
Gitk is incredibly powerful for visualizing and exploring the history of a repository. 

Gitk is also a helpful tool for learning the internals of Git.
<h2><br><span class="orange">Git Show</span></h2>
<h3>&emsp;What is git-show?</h3>
<code>git-show</code> is a command line utility that is used to view expanded details on Git objects such as blobs, trees, tags, and commits. 

<code>git-show</code> has specific behavior per object type.
Tags show the tag message and other objects included in the tag. 
Trees show the names and content of objects in a tree. 
Blobs show the direct content of the blob. 

Commits show a commit log message and a diff output of the changes in the commit.
Git objects are all accessed by references. 
By default, <code>git-show</code> acts against the HEAD reference. 
The HEAD reference always points to the last commit of the current branch. 

Therefore, you can use <code>git-show</code> to display the log message and diff output of the latest commit.
<h3>&emsp;Git-show options</h3>
<strong><code>＜object＞…</code></strong>
A reference to an object or a list of objects may be passed to examine those specific objects. 

If no explicit objects are passed, <code>git-show</code> defaults to the HEAD reference.
<strong><code>--pretty[=＜format＞]</code></strong>
The pretty option takes a secondary format value that can be one of: <code>oneline, short, medium, full, fuller, email, raw,</code> and <code>format:＜string＞</code>. 
If omitted, the format defaults to <code>medium</code>. 

Each format option is a different template for how Git formats the show output. 
The ＜code＞oneline＜/code＞ option can be very helpful for showing a list of commits
<strong><code>--abbrev-commit</code></strong>
This option shortens the length of output commit IDs. 

Commit IDs are 40 characters long and can be hard to view on narrow terminal screens. 
This option combined with <code>--pretty=oneline</code> can produce a highly succinct <code>git log</code> output.
<strong><code>--no-abbrev-commit</code></strong>
Always Show the full 40 character commit ID. 

This will ignore --<code>abbrev-commit</code> and any other options that abbreviate commit IDs like the <code>--oneline format</code>
<strong><code>--oneline</code></strong>
This is a shortcut for using the expanded command <code>--pretty=oneline --abbrev-commit</code>
<strong><code>--encoding[=＜encoding＞]</code></strong>

Character encoding on Git log messages defaults to UTF-8. 
The encoding option can change to a different character encoding output. 
This is useful if you are working with Git in an environment with different character encoding, like an Asian language terminal.
<strong><code>＞--expand-tabs=＜n＞

--expand-tabs
--no-expand-tabs</code></strong>
These options replace tab characters with spaces in the log message output. 
The <code>n</code> value can be set to configure how many space characters the tabs expand to. 

Without an explicit n value tabs will expand to 8 spaces. 
<code>--no-expand-tabs</code> is equivalent to <code>n=0</code>
<strong><code>--notes=＜ref＞
--no-notes</code></strong>

Git has a note system that enables arbitrary ‘note’ metadata to be attached to objects. 
This data can be hidden or filtered when using <code>git-show</code>. 
<strong><code>--show-signature</code></strong>
This option will validate the commit is signed with an encrypted signature by passing it to a gpg subcommand.

<h3>&emsp;Pretty formats for git-show</h3>
The <code>--pretty</code> option discussed above accepts several secondary options to massage the format of <code>git-show</code> output. 
These secondary options are listed below with example template
<strong>oneline</strong>

<code>＜sha1> ＜title line></code>
Oneline attempts to compact as much info into a single line as possible
<strong>short</strong>
<code>commit ＜sha1＞

Author: ＜author＞
＜title line＞</code>
<strong>medium</strong>
<code>commit ＜sha1＞

Author: ＜author＞
Date: ＜author date＞
＜title line＞
＜full commit message＞</code>

<strong>full</strong>
<code>commit ＜sha1＞
Author: ＜author＞
Commit: ＜committer＞

＜title line＞
＜full commit message＞</code>
<strong>fuller</strong>
<code>commit ＜sha1＞

Author: ＜author＞
AuthorDate: ＜author date＞
Commit: ＜committer＞
CommitDate: ＜committer date＞

＜title line＞
＜full commit message＞</code>
<b>email</b>
<code>From ＜sha1＞ ＜date＞

From: ＜author＞
Date: ＜author date＞
Subject: [PATCH] ＜title line＞
＜full commit message＞</code>

<strong>raw</strong>
<strong>raw</strong> format ignores other direct formatting options passed to <code>git-show</code> and outputs the commit exactly as stored in the object. 
Raw will disregard <code>--abrev</code> and <code>--no-abbrev</code> and always show the parent commits.
<strong>format:</strong>

format enables the specification of a custom output format. 
It works similar to the C language’s <code>printf</code> command. 
The <code>--pretty=format</code> option takes a secondary value of a template string. 
The template has access to placeholder variables that will be filled with data from the commit object. 

These placeholders are listed below:
 <em>%H</em>: commit hash
 <em>%h</em>: abbreviated commit hash
 <em>%T</em>: tree hash

 <em>%t</em>: abbreviated tree hash
 <em>%P</em>: parent hashes
<em> %p</em>: abbreviated parent hashes
<em> %an</em>: author name

 <em>%aN</em>: author name 
 <em>%ae</em>: author email
 <em>%aE</em>: author email 
<em> %ad</em>: author date (format respects --date= option)

<em> %aD</em>: author date, RFC2822 style
 <em>%ar</em>: author date, relative
<em> %at</em>: author date, UNIX timestamp
<em> %ai</em>: author date, ISO 8601 format

<em> %cn</em>: committer name
 <em>%cN</em>: committer name 
 <em>%ce</em>: committer email
 <em>%cE</em>: committer email 

<em> %cd</em>: committer date
 <em>%cD</em>: committer date, RFC2822 style
<em> %cr</em>: committer date, relative
 <em>%ct</em>: committer date, UNIX timestamp

<em> %ci</em>: committer date, ISO 8601 format
<em> %d</em>: ref names, like the --decorate option of git-log(1)
<em> %e</em>: encoding
<em> %s</em>: subject

<em> %f</em>: sanitized subject line, suitable for a filename
<em> %b</em>: body
<em> %N</em>: commit notes
<em> %gD</em>: reflog selector, e.g., refs/stash@{1}

<em> %gd</em>: shortened reflog selector, e.g., stash@{1}
 <em>%gs</em>: reflog subject
 <em>%Cred</em>: switch color to red
<em> %Cgreen</em>: switch color to green

 <em>%Cblue</em>: switch color to blue
 <em>%Creset</em>: reset color
 <em>%C(...)</em>: color specification, as described in color.branch.* config option
<em> %m</em>: left, right or boundary mark

 <em>%n</em>: newline
 <em>%%</em>: a raw %
 <em>%x00</em>: print a byte from a hex code
 <em>%w([<w>[,<i1>[,<i2>]]])</i2></i1></w></em>: switch line wrapping, like the -w option of git-shortlog

<h3>&emsp;Examples of git-show</h3>
<code>git show --pretty="" --name-only bd61ad98</code>
This will list all the files that were touched in a commit
<code>git show REVISION:path/to/file</code>

This will show a specific version of a file. 
Replace the <code>REVISON</code> with a Git sha.
<code>git show v2.0.0 6ef002d74cbbc099e1063728cab14ef1fc49c783</code>
This will show the v2.0.0 tag and also commit at <code>6ef002d74cbbc099e1063728cab14ef1fc49c783</code>

<code>git show commitA...commitD</code>
This will output all commits in the range from <code>commitA</code> to <code>commit D</code>
<h3>&emsp;Summary</h3>
<code>git-show</code> is a very versatile command for examining objects in a Git repo. 

It can be used to target specific files at specific revisions. 
Examining a commit range with <code>git-show</code> will output all the individual commits between the range. 
<code>git-show</code> can be a helpful tool for creating patch notes and tracking changes in a repository.
<h2><br><span class="orange">Learn Git with Bitbucket Cloud</span></h2>
<h3>&emsp;Objective</h3>
Learn the basics of Git with this space themed tutorial. 
<h3>&emsp;Mission Brief</h3>
Your mission is to learn the ropes of Git by completing the tutorial and tracking down all your team's space stations. 

Commands covered in this tutorial:
git clone, git config, git add, git status, git commit, git push, git pull, git branch, git checkout, and git merge
<table>
<thead><tr>

<th>Time</th> <th>Audience</th> <th>Prerequisites</th> </tr></thead>
<thead>
<tr>
<td>30 minutes</td> <td>You are new to Git and Bitbucket Cloud</td> <td><a class="button green solid" href="/git/tutorials/install-git" data-event="clicked" data-uuid="3546b51c-e3" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">You have installed Git</a></td> </tr>

<tr>
<td> </td> <td> </td> <td><a class="button green solid" href="https://bitbucket.org/account/signup/" data-event="clicked" data-uuid="3546b51c-e3" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">You have a Bitbucket account</a></td> </tr>
</thead>
</table>
<h2><span class="saddlebrown">&emsp;Create a Git repository</span></h2>
As our new Bitbucket space station administrator, you need to be organized. 
When you make files for your space station, you’ll want to keep them in one place and shareable with teammates, no matter where they are in the universe. 
With Bitbucket, that means adding everything to a repository. 

Let’s create one!
<em>Some fun facts about repositories</em>
You have access to all files in your local repository, whether you are working on one file or multiple files.
You can view public repositories without a Bitbucket account if you have the URL for that repository.

Each repository belongs to a user account or a team. 
In the case of a user account, that user owns the repository. 
+ In the case of a team, that team owns it.
The repository owner is the only person who can delete the repository. 

If the repository belongs to a team, an admin can delete the repository.
A code project can consist of multiple repositories across multiple accounts but can also be a single repository from a single account.
Each repository has a 2 GB size limit, but we recommend keeping your repository no larger than 1 GB.
<h3>&emsp;Step 1. Create the repository</h3>
Initially, the repository you create in Bitbucket is going to be empty without any code in it. 
That's okay because you will start adding some files to it soon. 
This Bitbucket repository will be the central repository for your files, which means that others can access that repository if you give them permission. 

After creating a repository, you'll copy a version to your local system—that way you can update it from one repo, then transfer those changes to the other.
<img src="https://wac-cdn.atlassian.com/dam/jcr:a226d62e-3f0f-4c7e-8d99-c3c73188f9f6/01.svg?cdnVersion=217" loading="lazy" alt="Central Repo to Local Repo">Do the following to create your repository:
From Bitbucket, click the <b>+</b> icon in the global sidebar and select <strong>Repository</strong>.
<img alt="Create Repo Menu" src="https://wac-cdn.atlassian.com/dam/jcr:bd8f6b7c-f3ad-43c2-b178-7e72e5b3c768/bbc_globalsidebar_create_repo.png?cdnVersion=217">

Bitbucket displays the <strong>Create a new repository</strong> page. 
Take some time to review the dialog's contents. 
With the exception of the <strong>Repository type</strong>, everything you enter on this page you can later change.
<img alt="Create the repository" src="https://wac-cdn.atlassian.com/dam/jcr:a7ae8cb6-c567-45d0-a560-2c64c985be87/03.png?cdnVersion=217">

 Enter <code>BitbucketStationLocations</code> for the <strong>Name</strong> field. 
Bitbucket uses this <strong>Name</strong> in the URL of the repository. 
For example, if the user <code>the_best</code> has a repository called <code>awesome_repo</code>, the URL for that repository would be <code>https://bitbucket.org/the_best/awesome_repo</code>.
 For <strong>Access level</strong>, leave the <strong>This is a private repository box </strong>checked. 

A private repository is only visible to you and those you give access to. 
If this box is unchecked, everyone can see your repository.
 Pick <strong>Git</strong> for the <strong>Repository type</strong>. 
Keep in mind that you can't change the repository type after you click <strong>Create repository</strong>.

 Click <strong>Create repository</strong>. 
Bitbucket creates your repository and displays its <strong>Overview</strong> page.
<h3>&emsp;Step 2. Explore your new repository</h3>

Take some time to explore the repository you have just created. 
You should be on the repository's <strong>Overview</strong> page:
<img src="https://wac-cdn.atlassian.com/dam/jcr:8c475d77-935d-4f3a-bf86-3f0e3dee9d00/explore_repository_gif.gif?cdnVersion=217" loading="lazy" alt="Repository Overview">Click <strong>+</strong> from the global sidebar for common actions for a repository. 
Click items in the navigation sidebar to see what's behind each one, including Settings to update repository details and other settings. 

To view the shortcuts available to navigate these items, press the <strong>?</strong> key on your keyboard.
When you click the <strong>Commits</strong> option in the sidebar, you find that you have no commits because you have not created any content for your repository. 
Your repository is private and you have not invited anyone to the repository, so the only person who can create or edit the repository's content right now is you, the repository owner.
<h2><span class="saddlebrown">&emsp;Copy your Git repository and add files</span></h2>
Now that you have a place to add and share your space station files, you need a way to get to it from your local system. 
To set that up, you want to copy the Bitbucket repository to your system. 
Git refers to copying a repository as "cloning" it. 
When you clone a repository, you create a connection between the Bitbucket server (which Git knows as origin) and your local system.

<img src="https://wac-cdn.atlassian.com/dam/jcr:a4d2c201-3486-4f2b-81a9-8ab6b663c9b9/01.svg?cdnVersion=217" loading="lazy" alt="Origin to Local"><h3>&emsp;Step 1. Clone your repository to your local system</h3>
Open a browser and a terminal window from your desktop. 
After opening the terminal window, do the following:

Navigate to your home (~) directory
<code> $ cd ~</code>

As you use Bitbucket more, you will probably work in multiple repositories. 

For that reason, it's a good idea to create a directory to contain all those repositories.

Create a directory to contain your repositories.
<code> $ mkdir repos</code>


From the terminal, update the directory you want to work in to your new repos directory.
<code> $ cd ~/repos</code>


From Bitbucket, go to your <strong>BitbucketStationLocations</strong> repository.
 Click the + icon in the global sidebar and select <strong>Clone this repository</strong>.
Bitbucket displays a pop-up clone dialog. 
By default, the clone dialog sets the protocol to <strong>HTTPS</strong> or <strong>SSH</strong>, depending on your settings. 

For the purposes of this tutorial, don't change your default protocol.
<img alt="Clone dialog" src="https://wac-cdn.atlassian.com/dam/jcr:05fe1970-336f-4b70-9a1d-b5bfb86356a2/git_clone_repo.gif?cdnVersion=217" title="Clone dialog">  
 Copy the highlighted clone command.
 From your terminal window, paste the command you copied from Bitbucket and press <strong>Return</strong>.

 Enter your Bitbucket password when the terminal asks for it. 
If you created an account by linking to Google, use your password for that account.
If you experience a <strong>Windows password error</strong>:
In some versions of Microsoft Windows operating system and Git you might see an error similar to the one in the following example.

<h4>Windows clone password error example</h4> 
<code>$ git clone
https://emmap1@bitbucket.org/emmap1/bitbucketstationlocations.git 
Cloning into 'bitbucketspacestation'...

fatal: could not read
Password for 'https://emmap1@bitbucket.org': No such file or directory</code>
If you get this error, enter the following at the command line:
<code>  $ git config --global core.askpass</code>
Then go back to step 4 and repeat the clone process. 
The bash agent should now prompt you for your password. 
You should only have to do this once.
At this point, your terminal window should look similar to this:

<code>$ cd ~/repos
$ git clone https://emmap1@bitbucket.org/emmap1/bitbucketstationlocations.git
Cloning into 'bitbucketstationlocations'...
Password

warning: You appear to have cloned an empty repository.</code>

You already knew that your repository was empty right? Remember that you have added no source files to it yet.


List the contents of your repos directory and you should see your <code>bitbucketstationlocations</code> directory in it.
<code>$ ls</code>
Congratulations! You've cloned your repository to your local system.
<h3>&emsp;Step 2. Add a file to your local repository and put it on Bitbucket</h3>
With the repository on your local system, it's time to get to work. 
You want to start keeping track of all your space station locations. 
To do so, let's create a file about all your locations.

Go to your terminal window and navigate to the top level of your local repository.
<code> $ cd ~/repos/bitbucketstationlocations/</code>

Enter the following line into your terminal window to create a new file with content.

<code>$ echo "Earth's Moon" >> locations.txt</code>

If the command line doesn't return anything, it means you created the file correctly!


Get the status of your local repository. 
The <code><a href="/git/tutorials/inspecting-a-repository" data-event="clicked" data-uuid="c1282a38-6a" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git status</a></code> command tells you about how your project is progressing in comparison to your Bitbucket repository.
At this point, Git is aware that you created a new file, and you'll see something like this:
<code>$ git status 

On branch main
Initial commit
Untracked files:
 (use "git add &lt;file>..." to include in what will be committed)

 locations.txt
nothing added to commit but untracked files present (use "git add" to track)</code>

The file is untracked, meaning that Git sees a file not part of a previous commit. 

The status output also shows you the next step: adding the file.

Tell Git to track your new <code>locations.txt</code> file using the <code><a href="/git/tutorials/saving-changes" data-event="clicked" data-uuid="aab5a2f6-ac" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git add</a></code> command. 
Just like when you created a file, the <code>git add</code> command doesn't return anything when you enter it correctly.

<code>$ git add locations.txt</code>

The <code>git add</code> command moves changes from the working directory to the Git staging area. 
The staging area is where you prepare a snapshot of a set of changes before committing them to the official history.

<img alt="Git add staging" src="https://wac-cdn.atlassian.com/dam/jcr:dbf0c59f-848d-4814-bfd5-6b190a092963/03.svg?cdnVersion=217">  

Check the status of the file.
<code> $ git status 

On branch main
Initial commit
Changes to be committed:
 (use "git rm --cached &lt;file>..." to unstage)

 new file: locations.txt</code>

Now you can see the new file has been added (staged) and you can commit it when you are ready. 
The <code>git status</code> command displays the state of the working directory and the staged snapshot.


Issue the <code><a href="/git/tutorials/saving-changes/git-commit" data-event="clicked" data-uuid="e3d1336c-21" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git commit</a></code> command with a commit message, as shown on the next line. 
The -m indicates that a commit message follows.
<code>$ git commit -m 'Initial commit' 

[main (root-commit) fedc3d3] Initial commit
1 file changed, 1 insertion(+)
create mode 100644 locations.txt</code>


The <code>git commit</code> takes the staged snapshot and commits it to the project history. 
Combined with <code>git add</code>, this process defines the basic workflow for all Git users.
<img alt="Git commit" src="https://wac-cdn.atlassian.com/dam/jcr:d5f60ca0-b606-4e7c-b3a2-430165bc0672/04.svg?cdnVersion=217">  Up until this point, everything you have done is on your local system and invisible to your Bitbucket repository until you push those changes.
<em>Learn a bit more about Git and remote repositories</em>

Git's ability to communicate with remote repositories (in your case, Bitbucket is the remote repository) is the foundation of every Git-based collaboration workflow.
 Git's collaboration model gives every developer their own copy of the repository, complete with its own local history and branch structure. 
Users typically need to share a series of commits rather than a single changeset. 
Instead of committing a changeset from a working copy to the central repository, Git lets you share entire branches between repositories.

<img alt="Git branching" src="https://wac-cdn.atlassian.com/dam/jcr:c24540ba-3f2b-4697-9fd3-91242f5ac5f2/05.svg?cdnVersion=217">  
 You manage connections with other repositories and publish local history by "pushing" branches to other repositories. 
You see what others have contributed by "pulling" branches into your local repository.


Go back to your local terminal window and send your committed changes to Bitbucket using <code><a href="/git/tutorials/syncing/git-push" data-event="clicked" data-uuid="b8640c66-1c" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git push origin main</a></code>. 
This command specifies that you are pushing to the main branch (the branch on Bitbucket) on origin (the Bitbucket server).
You should see something similar to the following response:
<code> $ git push origin main 

Counting objects: 3, done.
Writing objects: 100% (3/3), 253 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0) To https://emmap1@bitbucket.org/emmap1/bitbucketstationlocations.git
* [new branch] main -> main

Branch main set up to track remote branch main from origin.</code>

Your commits are now on the remote repository (origin).
<img alt="Git push" src="https://wac-cdn.atlassian.com/dam/jcr:ccfab346-46aa-4677-8469-2e109683bf19/06.svg?cdnVersion=217"> 


Go to your <strong>BitbucketStationLocations</strong> repository on Bitbucket.
 If you click <strong>Commits</strong> in the sidebar, you'll see a single commit on your repository. 
Bitbucket combines all the things you just did into that commit and shows it to you. 

You can see that the Author column shows the value you used when you configured the Git global file <code>( ~/.gitconfig)</code>.
If you click <strong>Source</strong> in the sidebar, you'll see that you have a single source file in your repository, the <code>locations.txt</code> file you just added.
<img alt="Bitbucket commits" src="https://wac-cdn.atlassian.com/dam/jcr:2e8d96aa-6d0e-4670-9d58-50c0251c4bea/git_commits_source.gif?cdnVersion=217">
Remember how the repository looked when you first created it? It probably looks a bit different now.
<h2><span class="saddlebrown">&emsp;Pull changes from your Git repository on Bitbucket Cloud</span></h2>
Next on your list of space station administrator activities, you need a file with more details about your locations. 
Since you don't have many locations at the moment, you are going to add them right from Bitbucket.
<h3>&emsp;Step 1. Create a file in Bitbucket</h3>
To add your new locations file, do the following:
From your <strong>BitbucketStationLocations</strong> repository, click <strong>Source</strong> to open the source directory. 
Notice you only have one file, <code>locations.txt</code> , in your directory.

<img alt="Bitbucket source window" src="https://wac-cdn.atlassian.com/dam/jcr:5dbc892c-1a9e-4440-96ea-536541ea88d5/01%20git%20source%20page%20image%20kopiera.png?cdnVersion=217">
<strong>A. 
Source page: </strong>Click the link to open this page.
<strong>B. 

Branch selection: </strong>Pick the branch you want to view.
<strong>C. 
More options button: </strong>Click to open a menu with more options, such as 'Add file'.
<strong>D. 

Source file area:</strong> View the directory of files in Bitbucket. 
 From the <strong>Source </strong>page, click the <strong>More options </strong>button in the top right corner and select <strong>Add file </strong>from the menu. 
The <strong>More options </strong>button only appears after you have added at least one file to the repository.
A page for creating the new file opens, as shown in the following image.

<img alt="Bitbucket new file" src="https://wac-cdn.atlassian.com/dam/jcr:546c1f3b-03ac-446c-ab5b-50b836fdfb66/mer_new_file_st_git.png?cdnVersion=217" title="Bitbucket new file"><strong>A. 
Branch with new file:</strong> Change if you want to add file to a different branch.
<strong>B. 
New file area:</strong> Add content for your new file here. 

 Enter <code>stationlocations</code> in the <strong>filename</strong> field.
 Select <strong>HTML</strong> from the <strong>Syntax mode</strong> list.
 Add the following HTML code into the text box:
<code class=""> &lt;p>Bitbucket has the following space stations:&lt;/p>

&lt;p>
 &lt;b>Earth's Moon&lt;/b>&lt;br>
 Headquarters
&lt;/p></code>


Click <strong>Commit</strong>. 
The <strong>Commit message</strong> field appears with the message: <code>stationlocations created online with Bitbucket.</code>
 Click <strong>Commit</strong> under the message field.

You now have a new file in Bitbucket! You are taken to a page with details of the commit, where you can see the change you just made:
<img src="https://wac-cdn.atlassian.com/dam/jcr:582fb362-907c-42c4-9ac3-496eb1a0c1ae/02%20new_file_committed_git%20kopiera.png?cdnVersion=217" loading="lazy" alt="Master branch">If you want to see a list of the commits you've made so far, click <strong>Commits</strong> in the sidebar.
<h3>&emsp;Step 2. Pull changes from a remote repository</h3>

Now we need to get that new file into your local repository. 
The process is pretty straight forward, basically just the reverse of the push you used to get the <code>locations.txt</code> file into Bitbucket.
To pull the file into your local repository, do the following:
Open your terminal window and navigate to the top level of your local repository.

<code> $ cd ~/repos/bitbucketstationlocations/</code>

Enter the <code>git pull --all</code> command to pull all the changes from Bitbucket. 
(In more complex branching workflows, pulling and merging all changes might not be appropriate .) Enter your Bitbucket password when asked for it. 

Your terminal should look similar to the following
<code>$ git pull --all
Fetching origin
remote: Counting objects: 3, done.

remote: Compressing objects: 100% (3/3), done.
remote: Total 3 (delta 0), reused 0 (delta 0)
Unpacking objects: 100% (3/3), done.
From https://bitbucket.org/emmap1/bitbucketstationlocations

fe5a280..fcbeeb0 main -> origin/main
Updating fe5a280..fcbeeb0
Fast-forward
stationlocations | 5 ++++++++++++++

1 file changed, 5 insertions(+)
create mode 100644 stationlocations</code>

The <a href="https://www.atlassian.com/git/tutorials/syncing/git-pull" data-event="clicked" data-uuid="8a42b46a-5a" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket"><code>git pull</code></a> command merges the file from your remote repository (Bitbucket) into your local repository with a single command.

<img alt="Origin to Local" src="https://wac-cdn.atlassian.com/dam/jcr:a4d2c201-3486-4f2b-81a9-8ab6b663c9b9/01.svg?cdnVersion=217" title="Origin to Local"> 

Navigate to your repository folder on your local system and you'll see the file you just added.
Fantastic! With the addition of the two files about your space station location, you have performed the basic Git workflow (clone, add, commit, push, and pull) between Bitbucket and your local system.
<h2><span class="saddlebrown">&emsp;Use a Git branch to merge a file</span></h2>
Being a space station administrator comes with certain responsibilities. 
Sometimes you’ll need to keep information locked down, especially when mapping out new locations in the solar system. 
Learning branches will allow you to update your files and only share the information when you're ready. 

Branches are most powerful when you're working on a team. 
You can work on your own part of a project from your own branch, pull updates from Bitbucket, and then merge all your work into the main branch when it's ready. 
<a href="https://confluence.atlassian.com/bitbucket/branch-or-fork-your-repository-221450630.html" data-event="clicked" data-uuid="63893999-2d" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Our documentation</a> includes more explanation of why you would want to use branches.
A branch represents an independent line of development for your repository. 

Think of it as a brand-new working directory, staging area, and project history. 
Before you create any new branches, you automatically start out with the main branch. 
For a visual example, this diagram shows the main branch and the other branch with a bug fix update.
<img src="https://wac-cdn.atlassian.com/dam/jcr:5e550e98-3f0a-4a5e-bebc-9438cc1384e8/03%20Use%20a%20Git%20branch%20to%20merge%20a%20file.svg?cdnVersion=217" loading="lazy" alt="Git branching"><h3>&emsp;Step 1. Create a branch and make a change</h3>
Create a branch where you can add future plans for the space station that you aren't ready to commit. 
When you are ready to make those plans known to all, you can merge the changes into your Bitbucket repository and then delete the no-longer-needed branch.
It's important to understand that branches are just pointers to commits. 

When you create a branch, all Git needs to do is create a new pointer—it doesn’t create a whole new set of files or folders. 
Before you begin, your repository looks like this: 
<img src="https://wac-cdn.atlassian.com/dam/jcr:3b5d663b-0b1c-4321-a32c-0708769e8aeb/04%20Create%20a%20branch%20and%20make%20a%20change.svg?cdnVersion=217" loading="lazy" alt="Master branch">To create a branch, do the following:
Go to your terminal window and navigate to the top level of your local repository using the following command:

<code>cd ~/repos/bitbucketstationlocations/</code>

Create a branch from your terminal window.
<code>$ git branch future-plans</code>


This command creates a branch but does not switch you to that branch, so your repository looks something like this:
<img alt="Create branch" src="https://wac-cdn.atlassian.com/dam/jcr:36506d0e-5e8e-4ef8-82a5-368597c66efd/05%20Create%20a%20branch%20and%20make%20a%20change.svg?cdnVersion=217">
The repository history remains unchanged. 

All you get is a new pointer to the current branch. 
To begin working on the new branch, you have to check out the branch you want to use.

Checkout the new branch you just created to start using it.

<code>$ git checkout future-plans 
Switched to branch 'future-plans'</code>

The <code>git checkout</code> command works hand-in-hand with <code>git</code> branch . 

Because you are creating a branch to work on something new, every time you create a new branch (with <code>git branch</code>), you want to make sure to check it out (with <code>git checkout</code>) if you're going to use it. 
Now that you’ve checked out the new branch, your Git workflow looks something like this:
<img alt="Feature branch" src="https://wac-cdn.atlassian.com/dam/jcr:5331fdcb-bfcf-435a-be7e-5b21d75a5531/06%20Create%20a%20branch%20and%20make%20a%20change.svg?cdnVersion=217">


Search for the <code>bitbucketstationlocations</code> folder on your local system and open it. 
You will notice there are no extra files or folders in the directory as a result of the new branch.
 Open the <code>stationlocations</code> file using a text editor.
 Make a change to the file by adding another station location:

<code>&lt;p>Bitbucket has the following space stations:&lt;/p>
&lt;p>
 &lt;b>Earth's Moon&lt;/b>&lt;br>
 Headquarters

&lt;/p>
&lt;p>
 &lt;b>Mars&lt;/b>&lt;br>
 Recreation Department

&lt;/p></code>

Save and close the file.
 Enter <code>git status</code> in the terminal window. 

You will see something like this:
<code>$ git status 
On branch future-plans
Changes not staged for commit:

(use "git add &lt;file>..." to update what will be committed)
(use "git checkout -- &lt;file>..." to discard changes in working directory)
 modified: stationlocations
no changes added to commit (use "git add" and/or "git commit -a")</code>


Notice the <code>On branch future-plans</code> line? If you entered <code>git status</code> previously, the line was on <code>branch main</code> because you only had the one <code>main branch</code>. 
Before you stage or commit a change, always check this line to make sure the branch where you want to add the change is checked out.


Stage your file.
<code>$ git add stationlocations</code>

Enter the <code>git commit</code> command in the terminal window, as shown with the following:

<code>$ git commit stationlocations -m 'making a change in a branch' 
[future-plans e3b7732] making a change in a branch
1 file changed, 4 insertions(+)</code>


With this recent commit, your repository looks something like this:
<img alt="Feature branch commit" src="https://wac-cdn.atlassian.com/dam/jcr:72ab245a-391a-4aba-b6a5-741a10c2518b/07%20Create%20a%20branch%20and%20make%20a%20change.svg?cdnVersion=217" title="Feature branch commit">  Now it's time to merge the change that you just made back into the <code>main</code> branch.
<h3>&emsp;Step 2. Merge your branch: fast-forward merging</h3>

Your space station is growing, and it's time for the opening ceremony of your Mars location. 
Now that your future plans are becoming a reality, you can merge your <code>future-plans</code> branch into the main branch on your local system.
Because you created only one branch and made one change, use the fast-forward branch method to merge. 
You can do a fast-forward merge because you have a linear path from the current branch tip to the target branch. 

Instead of “actually” merging the branches, all Git has to do to integrate the histories is move (i.e., “fast-forward”) the current branch tip up to the target branch tip. 
This effectively combines the histories, since all of the commits reachable from the target branch are now available through the current one.
<img src="https://wac-cdn.atlassian.com/dam/jcr:6b88dd16-49d9-4477-884e-a047589669db/08%20Merge%20your%20branch.svg?cdnVersion=217" loading="lazy" alt="Fast forward merge">This branch workflow is common for short-lived topic branches with smaller changes and are not as common for longer-running features.
To complete a fast-forward merge do the following:

Go to your terminal window and navigate to the top level of your local repository.
<code> $ cd ~/repos/bitbucketstationlocations/</code>

Enter the <code>git status</code> command to be sure you have all your changes committed and find out what branch you have checked out.

<code>$ git status 
On branch future-plans
nothing to commit, working directory clean</code>


Switch to the <code>main</code> branch.
<code>$ git checkout main 
Switched to branch 'main'
Your branch is up-to-date with 'origin/main'.</code>


Merge changes from the <code>future-plans</code> branch into the <code>main</code> branch. 
It will look something like this:
<code>$ git merge future-plans 

Updating fcbeeb0..e3b7732
Fast-forward
stationlocations | 4 ++++
1 file changed, 4 insertions(+)</code>


You've essentially moved the pointer for the <code>main</code> branch forward to the current head and your repository looks something like the fast forward merge above.

Because you don't plan on using <code>future-plans</code> anymore, you can delete the branch.

<code>$ git branch -d future-plans 
Deleted branch future-plans (was e3b7732).</code>

When you delete <code>future-plans</code>, you can still access the branch from <code>main</code> using a commit id. 

For example, if you want to undo the changes added from <code>future-plans</code>, use the commit id you just received to go back to that branch.

Enter <code>git status</code> to see the results of your merge, which show that your local repository is one ahead of your remote repository. 
It will look something like this:

<code>$ git status 
On branch main
Your branch is ahead of 'origin/main' by 1 commit.
(use "git push" to publish your local commits)

nothing to commit, working directory clean</code>
Here's what you've done so far:
Created a branch and checked it out
Made a change in the new branch

Committed the change to the new branch
Integrated that change back into the main branch
Deleted the branch you are no longer using.
Next, we need to push all this work back up to Bitbucket, your remote repository. 

<h3>&emsp;Step 3. Push your change to Bitbucket</h3>
You want to make it possible for everyone else to see the location of the new space station. 
To do so, you can push the current state of your local repository to Bitbucket.

This diagram shows what happens when your local repository has changes that the central repository does not have and you push those changes to Bitbucket.
<img src="https://wac-cdn.atlassian.com/dam/jcr:eb405dec-41b9-47b6-86f7-2d22c9ca7c10/09-10%20Merge%20your%20branch.svg?cdnVersion=217" loading="lazy" alt="Before and after pushing branch">Here's how to push your change to the remote repository:
From the repository directory in your terminal window, enter <code>git push origin main</code> to push the changes. 
It will result in something like this:

<code> $ git push origin main
Counting objects: 3, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.

Writing objects: 100% (3/3), 401 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To https://emmap1@bitbucket.org/emmap1/bitbucketstationlocations.git
fcbeeb0..e3b7732 main -> main</code>


Click the <strong>Overview</strong> page of your Bitbucket repository, and notice you can see your push in the <strong>Recent Activity</strong> stream.
 Click <strong>Commits</strong> and you can see the commit you made on your local system. 
Notice that the change keeps the same commit id as it had on your local system.

<img alt="Commit activity" src="https://wac-cdn.atlassian.com/dam/jcr:284b516b-cede-44bf-9807-85b5be9009cd/08.png?cdnVersion=217">
You can also see that the line to the left of the commits list has a straight-forward path and shows no branches. 
That’s because the <code>future-plans</code> branch never interacted with the remote repository, only the change we created and committed.
 Click <strong>Branches</strong> and notice that the page has no record of the branch either.

 Click <strong>Source</strong>, and then click the <code>stationlocations</code> file. 
You can see the last change to the file has the commit id you just pushed.
 Click the file history list to see the changes committed for this file, which will look similar to the following figure.
<img alt="File history" src="https://wac-cdn.atlassian.com/dam/jcr:a09d2ccd-3c2b-4941-9beb-38b7565e11ad/history_after_push_git.png?cdnVersion=217" title="File history">

<h3>&emsp;You are done!</h3>
Not sure you will be able to remember all the Git commands you just learned? No problem. 
Bookmark our <a href="/git/tutorials/svn-to-git-prepping-your-team-migration" data-event="clicked" data-uuid="936e210e-e3" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">basic Git commands</a> page so that you can refer to it when needed.
<h2><br><span class="orange">Learn about code review in Bitbucket Cloud</span></h2>
<h3>&emsp;Objective</h3>
Create a repository and add someone as a reviewer to your pull request to start collaborating on your code.
<strong>Disclaimer</strong>: The following section of this tutorial outlines the steps of adding a reviewer (or team member) to your pull request, so you can collaborate on your code in Bitbucket Cloud. 
If you are not working with a teammate or do not need to add reviewers at this time, feel free to move onto the next tutorial: <a href="/git/tutorials/learn-branching-with-bitbucket-cloud" data-event="clicked" data-uuid="18efd4be-65" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Learn branching in Bitbucket Cloud</a>.

<h3>&emsp;Mission Brief</h3>
So far, you’ve been the only person working in your repositories and on your code. 
What if you wanted to have someone review your code and provide feedback? By adding a reviewer to your pull request, you can do just that, whether you’re in the same room or across the universe.
<table>

<thead><tr>
<th>Time</th> <th>Audience</th> <th>Prerequisites</th> </tr></thead>
<thead><tr>
<td>15 minutes</td> <td>You have some experience using Bitbucket Cloud. 

If not, try out one of our <a href="/git/tutorials/learn-git-with-bitbucket-cloud" data-event="clicked" data-uuid="91694c42-e0" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">beginner tutorials</a>.</td> <td><a class="button green solid" href="https://bitbucket.org/account/signup" data-event="clicked" data-uuid="91694c42-e0" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Sign up for Bitbucket Cloud</a></td> </tr></thead>
<thead><tr>
<td>None</td> <td>For those who prefer using a Git GUI with Bitbucket Cloud</td> <td><a class="button green solid" href="http://www.sourcetreeapp.com/" data-event="clicked" data-uuid="91694c42-e0" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Sign up for Sourcetree</a></td> </tr></thead>
</table>

<strong>About branches and pull requests</strong>
When you work on a team with multiple Bitbucket users, you'll want to work on your own set of code separately from the main codebase. 
Branches allow you to do just that. 
A branch represents an independent line of development for your repository. 

Think of it as a brand-new working directory, staging area, and project history. 
After you create a branch, you work on and commit code to that branch, pull updates from Bitbucket to keep your branch up-to-date, and then push all your work to Bitbucket.
Once you've got code changes on a branch in Bitbucket, you can create a pull request, which is where code review takes place. 
Your teammates will comment on your code with feedback and questions and eventually (hopefully) approve the pull request. 

When you have enough approvals, merge the pull request to merge your branch into the main code.
<h2><span class="saddlebrown">&emsp;Create a repository</span></h2>
You just arrived at the Bitbucket space station and it's time to go through the orientation process, part of which involves making updates to your welcome package and getting them approved.
Click <strong>+</strong> in the global sidebar and select <strong>Repository</strong> under <strong>Create</strong>.

 Make sure the team you created is the repository <strong>Owner</strong>.
 Enter anything you want for the <strong>Project name</strong> and <strong>Repository name</strong>. 
If you can't think of anything, how about <em>Welcome package</em> and <em>First impressions</em>, respectively.
 From <strong>Include a README?</strong>, select either of the <strong>Yes</strong> options.

 From <strong>Version control system</strong>, pick an option for the type of repository you want to create. 
If you're not sure, keep as is.
 Click <strong>Create repository</strong> and you'll land on the <strong>Source</strong> view of your brand, new repository.
 From <strong>Source</strong>, select <img alt="" src="https://wac-cdn.atlassian.com/dam/jcr:bae57be3-ff14-439c-9320-9be1c5c867af/ellipsis.png?cdnVersion=217">  > <strong>Add file</strong>.

 Name the file <code>survey.html</code>, then copy this code and paste it into the main text area.
<code>\&lt;\!DOCTYPE html>
&lt;html>
&lt;head>

&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8">
&lt;style media="screen" type="text/css">
body {
margin: auto;

width: 700px;
color: #FFFFFF;
font-family: Arial, sans-serif;
background-color: #172B4D;

}
body>h1 {
margin: 50px;
font-size: 50px;

text-align: center;
color: #0052CC;
}
&lt;/style>

&lt;/head>
&lt;body>
&lt;h2>Team up in space&lt;/h2>
&lt;p>

Welcome to the team! You've made it this far so we know that you've got the potential to do great things. 
Because you're going to be collaborating with other awesome people, anything you add needs to be code reviewed and approved. 
That's just how a team works! You should have already created a branch and checked it out locally. 
If you haven't, go back to the tutorial and do that now. 

We'll be here.
&lt;/p>
&lt;p>
Because you're on your own branch, you can go crazy. 

Spice up this file any way you like. 
Add more files to this repository if you see fit. 
If want to take it slow and are just here to learn about pull requests, you can use this opportunity to fill out our short questionaire.
&lt;/p>

&lt;br>
&lt;p>
&lt;b>Question 1&lt;/b>: Have you used pull requests before?
&lt;/p>

&lt;p>
&lt;b>Answer 1&lt;/b>: **** Your answer here **** &lt;/p>
&lt;p>
&lt;b>Question 2&lt;/b>: Why do you want to learn about code review?

&lt;/p>
&lt;p>
&lt;b>Answer 2&lt;/b>: **** Your answer here **** &lt;/p>
&lt;p>

&lt;b>Question 3&lt;/b>: Who do you plan to work with on Bitbucket? &lt;/p>
&lt;p>
&lt;b>Answer 3&lt;/b>: **** Your answer here **** &lt;/p>
&lt;/body>

&lt;/html></code>

Click <strong>Commit</strong> and then <strong>Commit</strong> again from the dialog.
Your repository is looking pretty good now. 

Take a look around if you feel like it.
<h2><span class="saddlebrown">&emsp;Clone and make a change on a new branch</span></h2>
When you know that you will be adding reviewers to review and approve your code prior to merging, you’d most likely already have the repository cloned before creating a branch. 
So that’s what we’re going to do first before you set up your own branch.

<h3>&emsp;If you're using command line</h3>
<h4> Step 1. Clone your repository to your local system</h4>

Let's get it onto your local system so that you can really start working on it.
From the repository, click the <strong>Clone</strong> button in the top right.
Bitbucket displays the <strong>Clone this repository</strong> dialog. 
By default, the clone dialog sets the protocol to <strong>HTTPS</strong> or <strong>SSH</strong>, depending on your settings. 

As a result, you don't need to  change your default protocol.<img alt="Clone this repository" src="https://wac-cdn.atlassian.com/dam/jcr:e45288f2-1655-4b3f-8330-daed3558c2d7/clone_cr_tut.png?cdnVersion=217">
 Copy the clone command.
 From a terminal window, change into the local directory where you want to clone your repository.
<code>$ cd ~/&lt;path_to_directory></code>


Paste the command you copied from Bitbucket, for example:
<code>$ git clone https://breezy@bitbucket.org/powerstars/first-impressions.git
Cloning into 'first-impressions'...

Password for 'https://breezycloud@bitbucket.org': 
remote: Counting objects: 6, done.
remote: Compressing objects: 100% (5/5), done.
remote: Total 6 (delta 1), reused 0 (delta 0)

Unpacking objects: 100% (6/6), done.</code>
For more details, check out our cloning video to see how it's done:
<iframe width="560" height="315" src="https://www.youtube.com/embed/0M3LilUsX9Y" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
<h4> Step 2. Create a branch and pull in locally</h4>
Now that your repository is all set up, next comes the fun part. 
You can create branches locally or through Bitbucket. 

Let's create one from Bitbucket for the purposes of this tutorial.
Click <strong>Branches</strong> from the left navigation. 
You'll see that you already have one branch — your primary branch, <code>main</code>.
 Click <strong>Create a branch</strong> in the top right corner.

 After you create a branch, you need to check it out on your local system. 
Bitbucket provides you with a fetch and checkout command that you can copy and paste into your command line, similar to the following:
<code>$ git fetch &amp;&amp; git checkout my-updates
Password for 'https://breezycloud@bitbucket.org': 

From https://bitbucket.org/planetbreezycloud/first-impressions
* [new branch]      my-updates -> origin/my-updates
Branch 'my-updates' set up to track remote branch 'my-updates' from 'origin'.
Switched to a new branch 'my-updates'</code>

As you can see, you've switched to your new branch locally, allowing you to work on and push that separate line of code.
<h4> Step 3. Make a change to the branch</h4>

Now, it's your turn to makes some changes to your repository. 
Like the file mentions, you can go as crazy or as simple as you like. 
Change up the CSS. 
Add more files. 

Compose a space opera. 
Or simply answer the questions.
Open the <code>survey.html</code> file (or whatever you named it) with a text editor.
 Make your changes, big or small, and then save and close the file.

 From your terminal window, you should still be in the repository directory unless you've changed something. 
Display the status of the repository with <code>git status</code>. 
You should see the <code>survey.html</code> file you modified. 
If you added or modified other files, you'll see those as well.

<code>$ git status
On branch my-updates
Your branch is up-to-date with 'origin/my-updates'.
Changes not staged for commit:

(use "git add &lt;file>..." to update what will be committed)
(use "git checkout -- &lt;file>..." to discard changes in working directory)
    modified:   survey.html
no changes added to commit (use "git add" and/or "git commit -a")</code>


Add your changes locally with <code>git add <filename></filename></code>:
<code>$ git add survey.html</code>


Commit your changes locally with  <code>git commit -m "your commit message"</code>:
<code>$ git commit -m "Answered questions"
[my-updates 7506040] Answered questions
1 file changed, 3 insertions(+), 3 deletions(-)</code>


Enter <code>git push origin <branch_name> </branch_name></code>to push the changes to your branch on Bitbucket, and enter your password to finish pushing changes.
<code>$ git push origin my-updates
Password for 'https://breezycloud@bitbucket.org': 

Counting objects: 3, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 350 bytes | 350.00 KiB/s, done.

Total 3 (delta 1), reused 0 (delta 0)
To https://bitbucket.org/planetbreezycloud/first-impressions.git
 454ccaf..7506040  my-updates -> my-updates
Branch main set up to track remote branch main from origin.</code>


From Bitbucket, click the <strong>Source</strong> page of your repository. 
You should see both branches in the dropdown. 
Any other commits you make to my-updates will also appear on that branch.

<h3>&emsp;If you're using Sourcetree</h3>
<h4> Step 1. Clone your repository to your local system</h4>

Let's get it onto your local system so that you can really start working on it.
From the repository, click <strong>+</strong> in the global sidebar and select <strong>Clone this repository</strong> under <strong>Get to work</strong>.<img alt="Clone this repository" src="https://wac-cdn.atlassian.com/dam/jcr:1b7dd506-da73-4e5a-82d5-bf756699c0ba/clone_cr_tut-1.png?cdnVersion=217">
Click the <strong>Clone in Sourcetree</strong> button.
From the <strong>Clone New</strong> window, update the <strong>Destination Path</strong> to<code> <path_to_repo_directory>/first-impressions/</path_to_repo_directory></code>.<img alt="Clone new" src="https://wac-cdn.atlassian.com/dam/jcr:679043cd-55d0-4ca3-b0f9-f964b686d83b/01%20st_clone_branch%20kopiera.png?cdnVersion=217">

 Click the <strong>Clone</strong> button.
To see how it's done, check out the Clone a repository part of our video here:
<iframe allow="autoplay; encrypted-media" allowfullscreen="" frameborder="0" height="315" src="https://www.youtube.com/embed/0ocf7u76WSo" width="560"></iframe>
<h4> Step 2. Create a branch and pull in locally</h4>
Now that your repository is all set up, next comes the fun part. 
Because branches aren't only a Bitbucket concept, you can create one locally. 

However, we're going to create one from Bitbucket for the purposes of this tutorial.
Click <strong>Branches</strong> from the left navigation. 
You'll see that you already have one branch — your main branch.
 Click <strong>Create a branch</strong> in the top right corner.

 Enter a <strong>Branch name</strong> and click Create. 
If you aren't sure what to name your branch, go with something like my-updates.
 After you create a branch, you need to check it out from your local system. 
To do so, click the <strong>Check out in Sourcetree</strong> button.

 From the <strong>Checkout Existing</strong> dialog in Sourcetree, click <strong>Checkout</strong>.
Now you've got a branch in Bitbucket and it's checked out to your local system, allowing you to work on and push that separate line of code.
<h4> Step 3. Make a change to the branch
</h4>
Now, it's your turn to makes some changes to your repository. 
Like the file mentions, you can go as crazy or as simple as you like. 
Change up the CSS. 

Add more files. 
Compose a space opera. 
Or simply answer the questions.
From the repository in Sourcetree, click the <strong>Show in Finder</strong> button.<img alt="Show in Finder" src="https://wac-cdn.atlassian.com/dam/jcr:40f0b690-81b5-4e1b-abee-3a2faf2520f8/sourcetree_finder_git.png?cdnVersion=217">

 Open the <code>survey.html</code> file (or whatever you named it) with a text editor.
 Make your changes, big or small, and then save and close the file.
 Open Sourcetree and notice that your repository has <strong>Uncommitted changes</strong>.<img alt="Uncommitted changes" src="https://wac-cdn.atlassian.com/dam/jcr:fb8bbc2b-6c70-4041-b66a-c8974d9756a7/02%20st_uncommitted_branch%20kopiera.png?cdnVersion=217">
 (Git only) Add the file to the staging area:

Select the <strong>Uncommitted changes</strong> line.
 From the <strong>Unstaged files</strong> list, place a checkmark next to the survey.html file (and any other files with uncommitted changes).<img alt="Add changes to index" src="https://wac-cdn.atlassian.com/dam/jcr:7b6493bb-05f1-49a4-ad4b-0902f1dadcec/st_confirm_stage.png?cdnVersion=217">
 From the <strong>Confirm Stage?</strong> dialog, click <strong>OK</strong>.
 Click the <strong>Commit</strong> button at the top to commit the file.

 Enter a commit message in the space provided, something like <em>Answered</em> questions.
 Click the <strong>Commit</strong> button under the message box. 
When you switch back to the view, you see that the file has been committed but not pushed to the Bitbucket repository.
 From Sourcetree, click the <strong>Push</strong> button to push your committed changes.

 From the dialog that appears, click <strong>OK</strong> to push your branch with the commit to Bitbucket.
 From Bitbucket, click the <strong>Source</strong> page of your repository. 
You should see both branches in the dropdown. 
Any other commits you make to my-updates will also appear on that branch.
<h2><span class="saddlebrown">&emsp;Create a pull request to merge your change</span></h2>
To add reviewers to check and approve your code prior to merging, your next step is to create a pull request. 
In addition to a place for code review, a pull request shows a comparison of your changes against the original repository (also known as a diff) and provides an easy way to merge code when ready.
<h3>&emsp;Step 1. Create the pull request</h3>
You need a branch to create a pull request. 
Good thing you already have one.
From your repository, click <strong>+</strong> in the global sidebar. 

Then, click <strong>Create a pull request</strong> under <strong>Get to work</strong>.
Bitbucket displays the request form.
Complete the form: 
You've already got an automatic <strong>Title</strong>, your last commit message.

 Add a <strong>Description</strong> if you'd like.
<strong>(Optional - adding a reviewer) </strong>If you need someone to review and/or approve your code prior to merging, add them in the <strong>Reviewers</strong> field. 
You can see that Breezy Cloud was added as the reviewer to the example pull request below.
In order to add a reviewer to a pull request, you must first grant the user access to your repository by adding them to a group. 

For more information and detailed steps, refer to the following: <a href="https://support.atlassian.com/bitbucket-cloud/docs/grant-repository-access-to-users-and-groups/" data-event="clicked" data-uuid="1e540a86-6b" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Grant repository access to users and groups</a>. 
<strong>Note</strong>: You can always create the pull request and then add reviewers later.
When you're done, the form will look something like this:<img alt="branch form" src="https://wac-cdn.atlassian.com/dam/jcr:c6d1c3eb-27ed-4c6b-bc06-c9079b9bdd22/create_pr_tut.png?cdnVersion=217">
 Click <strong>Create pull request</strong>.

Bitbucket opens the pull request, and if you added a reviewer, they will receive an email notification with details about the pull request for them to review.
<h3>&emsp;Step 2. Merge your pull request</h3>
Not so fast! You may have noticed the <strong>Merge</strong> button at the top. 

Before you click it, you need to wait for an approval of your changes. 
In addition to the email notification your teammates receive, they'll also see the pull request appear under <strong>Pull requests to review</strong> on the <strong>Your work</strong> dashboard.
<img src="https://wac-cdn.atlassian.com/dam/jcr:27f3dabd-0be8-454f-bd6c-553d75e98526/pull_request_review.png?cdnVersion=217" loading="lazy" alt="York work dashboard">From the pull request, the reviewer can view the diff and add comments to start a discussion before clicking the <strong>Approve</strong> button.
When someone approves your pull request, you'll get an email notification. 

Once you've got the approvals you need (in this case just one!), you can merge. 
From the pull request, click <strong>Merge</strong>. 
And that's it! If you want to see what it looks like when your branch merges with the main branch, click <strong>Commits</strong> to see the commit tree.
<img src="https://wac-cdn.atlassian.com/dam/jcr:0305c413-fdcf-44c6-9470-f60e81c6ae4e/pr_tutorial_commits.png?cdnVersion=217" loading="lazy" alt="Commits">

<h2><br><span class="orange">Learn Branching with Bitbucket Cloud</span></h2>
<h3>&emsp;Objective</h3>
This tutorial will teach you the basics of creating, working in, reviewing, and merging branches using Git and Bitbucket Cloud. 
<table>

<thead><tr>
<th>Time</th> <th>Audience</th> <th>Prerequisites</th> </tr></thead>
<thead>
<tr>

<td>35 minutes</td> <td>You already understand the basic Git workflow</td> <td><a class="button green solid" href="/git/tutorials/install-git" data-event="clicked" data-uuid="1a318f8e-9b" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">You have installed Git</a></td> </tr>
<tr>
<td> </td> <td> </td> <td><a class="button green solid" href="/software/bitbucket/bundle" data-event="clicked" data-uuid="1a318f8e-9b" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">You have a Bitbucket account</a></td> </tr>
</thead>

</table>
This tutorial is for you if you already understand the basic Git workflow including how to:
<strong>Clone</strong>: copying the remote repository in Bitbucket Cloud to your local system
<strong>Add or stage</strong>: taking changes you have made and get them ready to add to your git history

<strong>Commit</strong>: add new or changed files to the git history for the repository
<strong>Pull</strong>: get new changes others have added to the repository into your local repository
<strong>Push</strong>: get changes from your local system onto the remote repository 
If you don't know the Git basics, don't worry just check out our <a href="/git/tutorials/learn-git-with-bitbucket-cloud" data-event="clicked" data-uuid="78a53144-43" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Learn Git with Bitbucket Cloud</a> tutorial and you'll be up to speed in no time.

<strong>Why branching matters</strong>
Branching is one of the best ways to get the most out of Git for version control. 
Branching in Git allows you to:
Have several teams working from a single repository concurrently.

Have team members anywhere in the world using Bitbucket Cloud to collaborate.
Have multiple lines of development running at the same time independent of each other without needing code freezes.
<h2><span class="saddlebrown">&emsp;Get set up</span></h2>
Since we want you to feel like you're working on a team, in a common Bitbucket repository, we will have you fork a public repository we have supplied.

<strong>What is a fork?</strong>
<em>Fork</em> is another way of saving a clone or copy. 
The term fork (in programming) derives from a Unix system call that creates a copy of an existing process. 
So, unlike a branch, a fork is independent from the original repository. 

If the original repository is deleted, the fork remains. 
If you fork a repository, you get that repository and all of its branches. 
Go to <a href="https://bitbucket.org/tutorials/tutorials.git.bitbucket.org" data-event="clicked" data-uuid="d452d9d3-97" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">tutorials/tutorials.git.bitbucket.org</a>
Click <strong>+ > Fork this repository</strong> on the left side of the screen.

Modify the <strong>Name</strong> so it is unique to your team, then click <strong>Fork repository</strong>. 
Create a directory for the repository which will be easy to navigate to. 
You might choose something like this:  <code>$ mkdir test-repositories $ cd test-repositories/ $ test-repositories</code>
The preceding example creates the test-repositories directory using the mkdir (make directory) command and switches to that directory using the cd (change directory) command.

Clone the forked repository into the directory you just created. 
It might look something like this:  <code>$ git clone https://dstevenstest@bitbucket.org/dstevenstest/mygittutorial.bitbucket.io.git     Cloning into 'mygittutorial.bitbucket.io'... 
remote: Counting objects: 12392, done. 
remote: Compressing objects: 100% (12030/12030), done. 

remote: Total 12392 (delta 8044), reused 564 (delta 360)     Receiving objects: 100% (12392/12392), 2.72 MiB | 701.00 KiB/s, done. 
Resolving deltas: 100% (8044/8044), done. 
$ cd mygittutorial.bitbucket.io/</code>
Which clones the repository using the git clone command and creates the directory the clone created <a href="https://superteam-tutorials.git.bitbucket.io/" data-event="clicked" data-uuid="d452d9d3-97" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">mygittutorial.git.bitbucket.io</a>. 

<h3>&emsp;Create a branch and change something using the branching workflow</h3>
You're going to add a quote on your website in this branch. 
Create a branch using the git branch command. 
<code>$ git branch test-1</code>

Check out the branch you just created using the git checkout command. 
<code>$ git checkout test-1 Switched to branch 'test-1'</code>
List the branches you have locally using the git branch command. 
<code>$ git branch   main   * test-1</code>

Make an update to the editme.html file by adding a quote. 
You can use something like the following:   <code>   <blockquote>This is a quote, and I like it.</blockquote>   <cite>A quote: The Art of Quoting</cite> </code>
Add that change. 
<code>git add editme.html</code>

Note: your change isn't committed to the Git history yet it's in a "waiting" state. 
We learned about this in <a href="/git/tutorials/saving-changes" data-event="clicked" data-uuid="5dc2cc67-09" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Saving changes</a>.
Commit the change with a descriptive commit message. 
<code>git commit editme.html -m'added a new quote' [test-1 063b772] added a new quote 1 file changed, 3 insertions(+), 3 deletions(-)</code>

Note: now the changes is part of the Git history as a single "commit" We learned about this in <a href="/git/tutorials/saving-changes" data-event="clicked" data-uuid="5dc2cc67-09" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Saving changes</a>.
Push that change to Bitbucket using the git push command. 
<code>git push fatal: The current branch test-1 has no upstream branch. 
To push the current branch and set the remote as upstream, use   git push --set-upstream origin test-1</code>

You will see an error because the first time you push a new branch you created locally you have to designate that branch.
Push the branch and change using the git push branch command. 
<code>$ git push origin test-1 Counting objects: 3, done. 
Delta compression using up to 8 threads. 

Compressing objects: 100% (3/3), done. 
Writing objects: 100% (3/3), 363 bytes | 0 bytes/s, done. 
Total 3 (delta 2), reused 0 (delta 0) remote: remote: Create pull request for test-1: remote: https://bitbucket.org/dstevenstest/dans.git.bitbucket.org/pull-requests/new?source=test-1&amp;t=1 remote: To https://bitbucket.org/dstevenstest/dans.git.bitbucket.org.git * [new branch] test-1 -> test-1</code>
This tells the system that the origin repository is the destination of this new branch.

Open your tutorial repository and click Branches. 
You should now see both the main and the test-1 branches. 
It should look something like this:
<img src="https://wac-cdn.atlassian.com/dam/jcr:cb973bad-62d0-4fb1-b59b-9a14b7b58fd4/01%20learn-branches-01.png?cdnVersion=217" loading="lazy" alt="Learn Bitbucket Branches"><h3>&emsp;Create, fetch, and checkout a remote branch</h3>

When you're working in a team you'll likely have to pull or fetch branches which other team members create and push to Bitbucket. 
This example will give you some of the basics of creating and working with branches others create.
Go to your tutorial repository in Bitbucket and click <strong>Branches</strong>. 
You should see something like this: <img alt="Branches" src="https://wac-cdn.atlassian.com/dam/jcr:fb7c325d-f1d5-471a-a05c-aba3f1de5a22/02%20bbc-tutorial-branches-page%20kopiera.png?cdnVersion=217">

Click <strong>Create branch</strong>, name the branch test-2, and click <strong>Create</strong>. 
Copy the git fetch command in the check out your branch dialog. 
It will probably look something like this:  <code>$ git fetch &amp;&amp; git checkout test-2 From https://bitbucket.org/dstevenstest/dans.git.bitbucket.org * [new branch] test-2 -> origin/test-2 Branch test-2 set up to track remote branch test-2 from origin. 
Switched to a new branch 'test-2'</code>

Use the git branch command in your terminal. 
You should see a list of branches something like this:  <code>$ git branch   main   test-1 * test-2</code>
The branch with the asterisk * is the active branch. 
This is critical to remember when you are working in any branching workflow. 

Use the git status command and you'll see something like this:  <code>$ git status On branch test-2 Your branch is up-to-date with 'origin/test-2'. 
nothing to commit, working tree clean</code>
You can see what branch you're on and that the branch is currently up to date with your remote (origin) branch. 
Use the git checkout command to change the focus back to your other branch. 

The command will look something like this:  <code>$ git checkout test-1 Switched to branch 'test-1' Your branch is ahead of 'origin/test-1' by 3 commits. 
(use "git push" to publish your local commits)</code>
One of the most important things to remember when working in branches is that you want to be sure the branch you're making changes to is the correct branch. 
<h3>&emsp;Push change and create a pull request</h3>

Now it's time to get your first change reviewed and merge the branch.
Click <strong>+> Create a pull request</strong>. 
You can see your test-1 branch as the source branch and main in the destination branch. 
Because we created this repository by forking an existing repository the destination is set to the main branch of the repository we forked.

To correct this you will need to change the repository destination branch (the branch into which you will merge your changes) from tutorials/tutorials.git.bitbucket.org to your repository.
<img alt="Pull Request" src="https://wac-cdn.atlassian.com/dam/jcr:8983bfe5-6fa7-439f-8e60-4e3c250defda/03%20bitbucket-pull-requests%20kopiera.png?cdnVersion=217">
You would also add reviewers on your team to the pull request. 
<a href="https://www.atlassian.com/git/tutorials/making-a-pull-request" data-event="clicked" data-uuid="2e1e9aee-71" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Learn more about pull requests</a>

Click <strong>Create pull request</strong>.
Make a comment in the pull request by selecting a line in the diff (the area displaying the change you made to the editme.html file).
Click <strong>Approve</strong> in the top left of the page. 
Of course in a real pull request you'd have reviewers making comments

Click <strong>Merge</strong>. 
(Optional) Update the <strong>Commit message</strong> with more details.
Select the <strong>Merge commit</strong> Merge strategy from the two options: 
<strong>Merge commit</strong>—Keeps all commits from your source branch and makes them part of the destination branch. 

This option is the same as entering git merge --no-ff in the command line.
<strong>Squash</strong>—Combines your commits when you merge the source branch into the destination branch. 
This option is the same as entering git merge --squash in the command line.
<a href="https://confluence.atlassian.com/x/cRNODQ#Workwithpullrequests-Mergestrategies" data-event="clicked" data-uuid="2e1e9aee-71" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Learn more</a> for details on these two types of merge strategies.

Click <strong>Commits</strong> and you will see how the branch you just merged fits into the larger scheme of changes.
<h3>&emsp;Delete a branch and pull main into local working branch</h3>
Now you've gone through the basic branching workflow and your change is in main. 
The last thing we'll learn is how to delete the branch you just merged, pull the updated main branch, and merge the updated main branch into your test-2 branch.

<strong>Why delete the branch?</strong>
Remember, branching in Git differs from SVN or similar version control systems by using a branches as both long running branches, like a main and development branch, and short term development branches like the examples we use in this tutorial. 
Because this is the case it's not a bad idea to delete local branches to keep your local environment cleaner.
<strong>Why pull main and merge it into test-2?</strong>

We're using this as an example of you working on a repository into which another team member is working. 
It's a good idea to pull changes into your working branch from time to time to prevent merge conflicts in pull requests.
Open your terminal and run the git status command the result should look something like this:  <code>$ git status On branch test-1 nothing to commit, working tree clean</code>
You can see you're on the branch you just used to make your change and that you don't have any changes. 

We're ready to get rid of that branch now that we've finished that work.
Switch to the main branch by running the git checkout main command. 
The result should look something like this:  <code>git checkout main Switched to branch 'main' Your branch is up-to-date with 'origin/main'.</code>
Notice that the message says you are up-to-date? This is only your local branch. 

We know this because we just merged a change into main and haven't pulled that change from the remote repository to our local system. 
That's what we'll do next.
Run the git pull command. 
The result should look something like this:  <code>$ git pull remote: Counting objects: 1, done. 

remote: Total 1 (delta 0), reused 0 (delta 0) Unpacking objects: 100% (1/1), done. 
From https://bitbucket.org/dstevenstest/dans.git.bitbucket.org 2d4c0ab..dd424cb main -> origin/main Updating 2d4c0ab..dd424cb Fast-forward editme.html | 6 +++--- 1 file changed, 3 insertions(+), 3 deletions(-)</code>
What happened is that when you pull the changes from the remote repository git runs a fast-forward merge to integrate the changes you made. 
It also lists how many files and lines in that file changed.

Run the git branch -d {branch_name} command to remove the test-1 branch. 
The result will look something like this:  <code>$ git branch -d test-1 Deleted branch test-1 (was 063b772)</code>
You can see that it deleted the branch and what the last commit hash was for that branch. 
This is the safe way to delete a branch because git won't allow you to delete the branch if it has uncommitted changes. 

You should be aware however that this won't prevent deleting changes which are committed to the git history but not merged into another branch.
Switch to the test-2 branch using the git checkout command. 
<code>$ git checkout test-2 Switched to branch 'test-2' Your branch is up-to-date with 'origin/test-2'.</code>
Merge the main branch into your working branch using the git merge main test-2 command. 

The result will look something like this:  <code>$ git merge main test-2 Updating 2d4c0ab..dd424cb Fast-forward editme.html | 6 +++--- 1 file changed, 3 insertions(+), 3 deletions(-)</code>
It's important to remember the following: 
The active branch matters. 
If you want to merge main into test-2 you want to have test-2 checked out (active). 

The same is true if you want to merge test-2 into main you need to have main checked out.
To see what branch is active at any time use git branch and the active branch will have an asterisk or use git status and it will tell you want branch you are on and if there are pending local changes.
We hope you've learned a bit about branching and the commands involved. 
Let's review what we just covered:
<h2><span class="saddlebrown">&emsp;Review the branching workflow</span></h2>
The Git Feature Branch workflow is an efficient way to get working with your team in Bitbucket. 
In this workflow, all feature development takes place on branches separate from the main branch. 
As a result, multiple developers can work on their own features without touching the main code.

<table border="0" cellpadding="1" cellspacing="1" class="image-text"><tbody>
<tr>
<td rowspan="6"><img src="https://wac-cdn.atlassian.com/dam/jcr:bfd5f251-ffa7-40d2-b564-a8247784179a/branch-diagram.png?cdnVersion=217" width="180px"></td> <td> <h3>&emsp;Start with the main branch</h3> This workflow helps you collaborate on your code with at least one other person. 
As long as your Bitbucket and local repos are up-to-date, you're ready to get started.

</td> </tr>
<tr>
<td> <h3>Create a new-branch</h3> Use a separate branch for each feature or issue you work on. 
After creating a branch, check it out locally so that any changes you make will be on that branch.

</td> </tr>
<tr>
<td> <h3>&emsp;Update, add, commit, and push changes</h3> Work on the feature and make commits like you would any time you use Git. 
When ready, push your commits, updating the feature branch on Bitbucket.

</td> </tr>
<tr>
<td> <h3>&emsp;Get your code reviewed</h3> To get feedback on your code, create a pull request in Bitbucket. 
From there, you can add reviewers and make sure everything is good to go before merging. 

</td> </tr>
<tr>
<td> <h3>&emsp;Resolve feedback</h3> Now your teammates comment and approve. 
Resolve their comments locally, commit, and push changes to Bitbucket. 

Your updates appear in the pull request.
</td> </tr>
<tr>
<td> <h3>&emsp;Merge your branch</h3> Before you merge, you may have to resolve merge conflicts if others have made changes to the repo. 

When your pull request is approved and conflict-free, you can add your code to the main branch. 
Merge from the pull request in Bitbucket. 
</td> </tr>
</tbody></table>

This tutorial is limited in it's ability to show how branches make teams more effective. 
There are several approaches to branching and we discuss some of these approaches in: <a href="/git/tutorials/comparing-workflows" data-event="clicked" data-uuid="fe36e380-b8" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Comparing workflows</a>.
<h2><br><span class="orange">Learn how to undo changes in Git using Bitbucket Cloud</span></h2>
<h3>&emsp;Objective</h3>

Learn how to undo changes on your local machine and a Bitbucket Cloud repository while collaborating with others.
<h3>&emsp;Mission Brief</h3>
Commands covered in this tutorial: <code>git revert</code>, <code>git reset</code>, <code>git log</code>, and <code>git status</code>
<table>

<thead><tr>
<th>Time</th> <th>Audience</th> <th>Prerequisites</th> </tr></thead>
<thead>
<tr>

<td> 40 minutes
</td> <td> This tutorial assumes familiarity with the following <code>git</code> commands:
<code>git clone</code>, <code>git commit</code>, <code>git pull</code>, and <code>git push</code>
</td> <td><a class="button green solid" href="https://www.atlassian.com/git/tutorials/install-git" data-event="clicked" data-uuid="765ac2dd-7c" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">You have installed Git</a></td> </tr>

<tr>
<td> </td> <td> </td> <td><a class="button green solid" href="/software/bitbucket/bundle" data-event="clicked" data-uuid="765ac2dd-7c" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">You have a Bitbucket account</a></td> </tr>
</thead>
</table>

Everyone makes mistakes. 
Not every push is perfect so this tutorial will help you use the most common git functions to undo a change or changes safely.
This tutorial assumes familiarity with the following git commands:
<code><a href="/git/tutorials/setting-up-a-repository/git-clone" data-event="clicked" data-uuid="ebe36db6-bf" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git clone</a></code>

<code><a href="/git/tutorials/saving-changes/git-commit" data-event="clicked" data-uuid="ebe36db6-bf" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git commit</a></code>
<code><a href="/git/tutorials/syncing/git-pull" data-event="clicked" data-uuid="ebe36db6-bf" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git pull</a></code>
<code><a href="/git/tutorials/syncing/git-push" data-event="clicked" data-uuid="ebe36db6-bf" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git push</a></code>
If you don't know those commands we can help you <a href="/git/tutorials/learn-git-with-bitbucket-cloud" data-event="clicked" data-uuid="b5ca1758-12" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Learn git with Bitbucket Cloud</a>. 

Then come back here and learn how to undo changes. 
These <code>git</code> commands are applicable to a windows or unix environment. 
This tutorial will utilize unix command line utilities when instructing file system navigation.
<h2><span class="saddlebrown">&emsp;Undoing changes on your local machine</span></h2>
When the change you want to undo is on your local system and hasn't been pushed to a remote repository there are two primary ways to undo your change:
<table border="1" cellpadding="1" cellspacing="1"><tbody>
<tr>
<td><strong>Command</strong></td> <td><strong>Definition</strong></td> </tr>

<tr>
<td> <code>git revert</code>
</td> <td> An 'undo' command, though not a traditional undo operation. 
Instead of removing the commit, it figures out how to invert the changes in the commit, then appends a new commit with the inverse content. 

This prevents Git from losing history, which is important for the integrity of your revision history and for reliable collaboration.
</td> </tr>
<tr>
<td> <code>git reset</code>

</td> <td> A versatile <code>git</code> command undoing changes. 
The <code>git reset</code> command has a powerful set of options but we'll just be using the following reset modes for this tutorial:
<code>--soft</code>: Only resets the <code>HEAD</code> to the commit you select. 
Works basically the same as <code>git checkout <commit></commit></code> but does not create a detached head state.

<code>--mixed</code>: Resets the <code>HEAD</code> to the commit you select in both the history and undoes the changes in the index.
<code>--hard</code>: Resets the <code>HEAD</code> to the commit you select in both the history, undoes the changes in the index, and undoes the changes in your working directory. 
We won't be testing a hard reset for this tutorial.
For a complete description of how <code>git reset</code> works see git-scm.com's <a href="https://git-scm.com/book/en/v2/Git-Tools-Reset-Demystified" data-event="clicked" data-uuid="07224b37-84" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Git Tools - Reset Demystified</a>.

</td> </tr>
</tbody></table>
As you progress through the tutorial you'll learn several other <code>git</code> commands as part of learning how to undo changes, so let's get started.
<h2><span class="saddlebrown">&emsp;Fork a repository</span></h2>
Let's begin by creating a unique repository with all the code from the original. 
This process is called “<a href="/git/tutorials/comparing-workflows/forking-workflow" data-event="clicked" data-uuid="7fd2fb2b-51" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">forking</a> a repository”. 
Forking is an extended <code>git</code> process that is enabled when a shared repository is hosted with a 3rd party hosting service like Bitbucket.
Click or enter the following URL: <a href="https://bitbucket.org/atlassian/tutorial-documentation-tests/commits/all" data-event="clicked" data-uuid="5888743f-ac" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">https://bitbucket.org/atlassian/tutorial-documentation-tests/commits/all</a>

Click the <strong>+</strong> symbol on the left sidebar, then select <strong>Fork this repository</strong>, review the dialog and click <strong>Fork repository</strong>.
You should be taken to the overview of the new repository.
Click the + symbol and select <strong>Clone this repository</strong>.
On your computer clone the repository.

Navigate to the directory containing the cloned repository.
Now that you've got a repository full of code and an existing history on your local system you're ready to begin undoing some changes.
<h2><span class="saddlebrown">&emsp;Find changes on your local system</span></h2>
You'll have to be able to find and reference the change you want to undo. 

This can be accomplished by browsing the commit UI on Bitbucket and there are a few command line utilities that can locate a specific change.
<h2><span class="saddlebrown">&emsp;git status</span></h2>
<code>Git status</code> returns the state of your working directory (the location of the repository on your local system) and the staging area (where you prepare a set of changes to add to the project history) and will show any files which have changes and if those changes have been added to the staging area. 
Let us now execute <code>git status</code> and examine the current state of the repository.

<code>$ git status
On branch main
Your branch is up-to-date with 'origin/main'.
nothing to commit, working tree clean</code>

The output of <code>git status</code> here shows us that everything is up-to-date with the remote main branch and there are no pending changes are waiting to be committed. 
In the next example we will make some edits to the repository and examine it in a pending changes state. 
This means you have changes to files in the repository on your local system that you haven't prepared (or staged) to be added to the project history.
To demonstrate this next example,  first open the <code>myquote2.html</code> file. 

Make some modifications to the contents of <code>myquote2.html</code>, save and exit the file. 
Let us once again execute <code>git status</code> to examine the repository in this state.
<code>$ git status
On branch main

Your branch is up-to-date with 'origin/main'.
Changes not staged for commit:
(use "git add &lt;file>..." to update what will be committed)
(use "git checkout -- &lt;file>..." to discard changes in working directory)

Modified: myquote2.html
no changes added to commit (use "git add" and/or "git commit -a")
--</code>
The output here shows that the repository has pending modifications to <code>myquote2.html</code>. 

Good news! If the change you want to undo has, like the example above, not been added to the staging area yet you can just edit the file and keep going. 
Git only starts tracking a change when you add it to the staging area and then commit it to the project history.
Let us now “undo” the changes we have made to <code>myquote2.html</code>. 
Because this is a simplified example with minimal changes, we have two available methods for undoing the changes. 

If we execute <code>git checkout myquote2.html</code> The repository will restore <code>myquote2.html</code> to the previously committed version. 
Alternatively, we can execute <code>git reset --hard</code> which will revert the whole repository to the last commit.
<h2><span class="saddlebrown">&emsp;git log</span></h2>
The <code>git log</code> command lets you list the project history, filter it, and search for specific changes. 

While <code>git status</code> lets you inspect the working directory and the staging area, <code>git log</code> only shows the committed history.
The same log of commited history can be found within the Bitbucket UI by accessing the “commits” view of a repository. 
The commits view for our demo repository can be found at: <a href="https://bitbucket.org/dans9190/tutorial-documentation-tests/commits/all" data-event="clicked" data-uuid="688d5afe-01" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">https://bitbucket.org/dans9190/tutorial-documentation-tests/commits/all</a>. 
This view will have similar output to the <code>git log</code> command line utility. 

It can be used to find and identify a commit to undo.
In the following example you can see several things in the history but each change is, at it's root, a commit so that's what we'll need to find and undo.
<code>$ git status
On branch main

Your branch is up-to-date with 'origin/main'.
nothing to commit, working tree clean
$ git log
commit 1f08a70e28d84d5034a8076db9103f22ec2e982c

Author: Daniel Stevens &lt;dstevens@atlassian.com>
Date:   Wed Feb 7 17:06:50 2018 +0000
Initial Bitbucket Pipelines configuration
commit 52f823ca251a132225dd1cc18ad768de8d336e84

Author: Daniel Stevens &lt;dstevens@atlassian.com>
Date:   Fri Sep 30 15:50:58 2016 -0700
repeated quote to show how a change moves through the process
commit 4801b87c2147dce83f1bf31acfcffa6cb1d7e0a5

Merge: 1a6a403 3b29606
Author: Dan Stevens [Atlassian] &lt;dstevens@atlassian.com>
Date:   Fri Jul 29 18:45:34 2016 +0000
Merged in changes (pull request #6)

Changes
</code>
Let's look a little closer at one of the commits in the list:
<code>commit 52f823ca251a132225dd1cc18ad768de8d336e84

Author: Daniel Stevens &lt;dstevens@atlassian.com>
Date:   Fri Sep 30 15:50:58 2016 -0700
repeated quote to show how a change moves through the process</code>
What you can see is each commit message has four elements:

<table border="1" cellpadding="1" cellspacing="1"><tbody>
<tr>
<td><strong>Element</strong></td> <td><strong>Description</strong></td> </tr>
<tr>

<td> Commit hash
</td> <td> An alphanumeric string (<a href="https://www.atlassian.com/git/tutorials/what-is-git#security" data-event="clicked" data-uuid="c81003a1-7c" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">SHA-1 encoded</a>) that identifies this specific change
</td> </tr>
<tr>

<td> Author
</td> <td> The person who committed the change
</td> </tr>
<tr>

<td> Date
</td> <td> The date the change was committed to the project
</td> </tr>
<tr>

<td> Commit message
</td> <td> A text string that describes the change(s).
<em>Best practice tip: write short descriptive commit messages and you'll help create a more harmonious working repository for everyone.</em>
</td> </tr>

</tbody></table>
<h2><span class="saddlebrown">&emsp;Locate a specific commit</span></h2>
Most likely the change you want to undo will be somewhere further back in the project history which can be quite extensive. 
So let's learn a couple basic operations using <code>git log</code> to find a specific change.

Go to your terminal window and navigate to the top level of your local repository using the <code>cd</code> (change directory) command.
<code>$ cd ~/repos/tutorial-documentation-tests/</code>
Enter the <code>git log --oneline</code> command. 
Adding <code>--oneline</code> will display each commit on a single line that allows you to see more history in your terminal.

Press the <strong>q</strong> key to exit the commit log and return to your command prompt at any time.
You should see something like the following example:
<code>$ git log --oneline
1f08a70 (HEAD -> main, origin/main, origin/HEAD) Initial Bitbucket Pipelines configuration

52f823c repeated quote to show how a change moves through the process
4801b87 Merged in changes (pull request #6)
1a6a403 myquote edited online with Bitbucket
3b29606 (origin/changes) myquote2.html edited online with Bitbucket

8b236d9 myquote edited online with Bitbucket
235b9a7 testing prs
c5826da more changes
...</code>


Press the <strong>q</strong> key to return to your command prompt.
Locate the commit with the hash <code>c5826da</code> and <em>more changes</em> in the list the <code>git log</code> command produced. 
Someone didn't write a descriptive commit message so we'll have to figure out if that's got the changes we need.

Highlight and copy the commit hash <code>c5826da</code> from the <code>git log</code> result in your terminal window.
Type <code>git show</code> then paste or transcribe the commit hash you copied and press enter. 
You should see something like this:
<code>$git show c5826daeb6ee3fd89e63ce35fc9f3594fe243605

commit c5826daeb6ee3fd89e63ce35fc9f3594fe243605
Author: Daniel Stevens &lt;dstevens@atlassian.com>
Date:   Tue Sep 8 13:50:23 2015 -0700
more changes

diff --git a/README.md b/README.md
index bdaee88..6bb2629 100644
--- a/README.md
+++ b/README.md

@@ -11,12 +11,7 @@ This README would normally document whatever steps are necessary to get your app
### How do I get set up? ###
* Summary of set up
-* Configuration

-* Dependencies
-* Database configuration
-* How to run tests
-* Deployment instructions

-* more stuff and things
:</code>
The prompt at the bottom will continue to fill in until it shows the entire change. 
Press <strong>q</strong> to exit to your command prompt.
<h2><span class="saddlebrown">&emsp;Filter the git log to find a specific commit</span></h2>
You can filter and adjust the output of the <code>git log</code> with the following additions:
<table border="1" cellpadding="1" cellspacing="1"><tbody>
<tr>

<td><strong>This filter</strong></td> <td><strong>Does this</strong></td> <td><strong>This example command</strong></td> <td><strong>Would result in</strong></td> </tr>
<tr>
<td><code>-<n></n></code></td> <td> Limits the number of commits shown
</td> <td><code>git log -10</code></td> <td> The 10 most recent commits in the history

</td> </tr>
<tr>
<td> <code>--after</code>
<code>--before</code>

</td> <td> Limits the commits shown to the correlating time frame
You can also use <code>--after "yyyy-mm-dd" --before "yyyy-mm-dd"</code>
</td> <td><code>git log --after 2017-07-04</code></td> <td> All commits after July 4, 2017
</td> </tr>

<tr>
<td><code>--author="name"</code></td> <td> Lists all commits whose author matches the name
</td> <td><code>git log --author="Alana"</code></td> <td> All commits made by any author with Alana in the name field
</td> </tr>

<tr>
<td><code>--grep="message string"</code></td> <td> Returns any commit with a commit message which matches the string you entered
</td> <td><code>git log --grep="HOT-"</code></td> <td> All commits with HOT- as a text string in their messages
</td> </tr>

</tbody></table>
This was a very brief look at the <code>git log</code> command if you like working in the command like you'll probably want to check out the <a href="/git/tutorials/git-log" data-event="clicked" data-uuid="294e7dda-c8" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">advanced git log tutorial</a>.
<h2><span class="saddlebrown">&emsp;Undo a change with git reset</span></h2>
To get started let's just undo the latest commit in the history. 

In this case let's say you just enabled Bitbucket's CI/CD solution pipelines but realized the script isn't quite right.
Enter <code>git log --oneline</code> in your terminal window.
Copy the commit hash for the second commit in the <code>log: 52f823c</code> then press <strong>q</strong> to exit the log.
Enter <code>git reset --soft 52f823c</code> in your terminal window. 

The command should run in the background if successful. 
That's it, you've undone your first change. 
Now let's see the result of this action.
Enter <code>git status</code> in your terminal window and you will see the commit was undone and is now an uncommitted change. 

It should look something like this:
<code>$ git status
On branch main
Your branch is behind 'origin/main' by 1 commit, and can be fast-forwarded.

(use "git pull" to update your local branch)
Changes to be committed:
(use "git reset HEAD &lt;file>..." to unstage)
new file:   bitbucket-pipelines.yml</code>


Enter <code>git log --oneline</code> in your terminal window. 
You should see something like this:
<code>$ git log --oneline

52f823c repeated quote to show how a change moves through the process
4801b87 Merged in changes (pull request #6)
1a6a403 myquote edited online with Bitbucket
3b29606 (origin/changes) myquote2.html edited online with Bitbucket

8b236d9 myquote edited online with Bitbucket
235b9a7 testing prs
c5826da more changes
43a87f4 remivng

d5c4c62 a few small changes
23a7476 Merged in new-feature2 (pull request #3)
5cc4e1e add a commit message
cbbb5d6 trying a thing

438f956 adding section for permissions and cleaning up some formatting
23251c1 updated snipptes.xml organization into resources. 
other files misc changes
3f630f8 Adding file to track changes

...</code>

You can see the new <code>HEAD</code> of the branch is commit <code>52f823c</code> which is exactly what you wanted.
Press <strong>q</strong> to exit the log. 

Leave your terminal open because now that you've learned how to do a simple reset, let's try something a little more complex.
<h2><span class="saddlebrown">&emsp;Undo several changes with git reset</span></h2>
Let's say you've realized that  pull request #6 (<code>4801b87</code>), needed to be reworked and you want to keep a clean history so you'll reset the <code>HEAD</code> to commit <code>1a6a403</code> this time you'll use the <code>git reset</code> command.
Enter <code>git log --online</code>

Copy the commit hash <code>1a6a403 </code>(myquote edited online with Bitbucket)  which is the commit just below pull request #6 which has the changes we want to undo.
Enter <code>git reset 1a6a403</code> in your terminal window. 
The output should look something like this:
<code>$ git reset 1a6a403

Unstaged changes after reset:
M README.md
M myquote2.html</code>
You can see that the changes are now in an uncommitted state. 

This means that now we've removed several changes from both the history of the project and the staging area.

Enter <code>git status</code> in your terminal window. 
The output should look something like this:

<code>$ git status
On branch main
Your branch is behind 'origin/main' by 6 commits, and can be fast-forwarded.
(use "git pull" to update your local branch)

Changes not staged for commit:
(use "git add &lt;file>..." to update what will be committed)
(use "git checkout -- &lt;file>..." to discard changes in working directory)
modified:   README.md

modified:   myquote2.html
Untracked files:
(use "git add &lt;file>..." to include in what will be committed)
bitbucket-pipelines.yml

no changes added to commit (use "git add" and/or "git commit -a")</code>
Now you can see that the first change we undid (the <code>bitbucket-pipelines.yml</code> file) is now completely untracked by <code>git</code>. 
This is because invoking <code>git reset</code> removes the change from both the head of the branch and the tracking or index area of <code>git</code>. 
The underlying process is a bit more complex than we can cover here, you can read more in <code><a href="/git/tutorials/undoing-changes/git-reset" data-event="clicked" data-uuid="bc50ff36-df" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git reset</a></code>.


Enter <code>git log --oneline</code> in your terminal window.
<code>1a6a403 myquote edited online with Bitbucket
8b236d9 myquote edited online with Bitbucket

43a87f4 remivng
d5c4c62 a few small changes
23a7476 Merged in new-feature2 (pull request #3)
5cc4e1e add a commit message

cbbb5d6 trying a thing
438f956 adding section for permissions and cleaning up some formatting
23251c1 updated snipptes.xml organization into resources. 
other files misc changes

3f630f8 Adding file to track changes
e52470d README.md edited online with Bitbucket
e2fad94 README.md edited online with Bitbucket
592f84f Merge branch 'main' into new-feature2 Merge branch  especially if it merges an updated upstream into a topic branch.

7d0bab8 added a line
879f965 adding to the quote file
8994332 Merged in HOT-235 (pull request #2)
b4a0b43 removed sarcastic remarks because they violate policy.

b5f5199 myquote2.html created online with Bitbucket
b851618 adding my first file
5b43509 writing and using tests</code>
The log output now shows the commit history has also been modified and begins at commit <code>1a6a403</code>. 

For the sake of demonstration and further example, Let’s say we want to now undo the reset we just did. 
After further consideration, maybe we wanted to keep the contents of pull request #6. 
<h2><span class="saddlebrown">&emsp;Pushing resets to Bitbucket</span></h2>
<code>Git resets</code> are one of a few “undo” methods <code>git</code> offers. 

Resets are generally considered an ‘unsafe’ option for undoing changes. 
Resets are fine when working locally on isolated code but become risky when shared with team members.
In order to share a branch that has been reset with a remote team a ‘forced push’ has to be executed. 
A ‘forced push’ is initiated by executing <code>git push -f</code>. 

A forced push will destroy any history on the branch that was built after the point of the push.
An example of this ‘unsafe’ scenario is followed:
Dev A has been working on a branch developing a new feature.
Dev B has been working on the same branch developing a separate feature.

Dev B decides to reset the branch to an earlier state before both Dev A and Dev B started work.
Dev B then force pushes the reset branch to the remote repository.
Dev A pulls the branch to receive any updates. 
During this pull Dev A receives the forced update. 

This resets Dev A’s local branch back in time before any of their feature work was done and loses their commits.
<h2><span class="saddlebrown">&emsp;Undo a git reset</span></h2>
So far we have been passing <code>git commit</code> Sha hashes to <code>git reset</code>. 
The <code>git log</code> output is now missing commits that we have reset. 

How will we get those commits back? Git never fully deletes commit unless it has become detached any pointers to it. 
Furthermore <code>git</code> stores a separate log of all ref movement called “the reflog”. 
We can examine the reflog by executing <code>git reflog</code>.
<code>1a6a403 HEAD@{0}: reset: moving to 1a6a403

1f08a70 HEAD@{1}: reset: moving to origin/main
1f08a70 HEAD@{2}: clone: from git@bitbucket.org:dans9190/tutorial-documentation-tests.git</code>
Your output from <code>git reflog</code> should be similar to the above. 
You can see a history of actions on the repo. 

The top line is a reference to the reset we did to reset pull request #6. 
Let us now reset the reset to restore pull request #6. 
The second column of this reflog output indicates a ref pointer to a modification action take on the repo. 
Here <code>HEAD@{0}</code> is a reference to the reset command we previously executed. 

We do not want to replay that reset command so we will restore the repo to <code>HEAD@{1}.</code>
<code>$ git reset --hard HEAD@{1}
HEAD is now at 1f08a70 Initial Bitbucket Pipelines configuration</code>
Let us now examine the repos commit history with <code>git log --oneline</code>:

<code>$git log --online
1f08a70 Initial Bitbucket Pipelines configuration
52f823c repeated quote to show how a change moves through the process
4801b87 Merged in changes (pull request #6)

1a6a403 myquote edited online with Bitbucket
3b29606 myquote2.html edited online with Bitbucket
8b236d9 myquote edited online with Bitbucket
235b9a7 testing prs

c5826da more changes
43a87f4 remivng
d5c4c62 a few small changes
23a7476 Merged in new-feature2 (pull request #3)

5cc4e1e add a commit message
cbbb5d6 trying a thing
438f956 adding section for permissions and cleaning up some formatting
23251c1 updated snipptes.xml organization into resources. 

other files misc changes
3f630f8 Adding file to track changes
e52470d README.md edited online with Bitbucket
e2fad94 README.md edited online with Bitbucket

592f84f Merge branch 'main' into new-feature2 Merge branch  especially if it merges an updated upstream into a topic branch.
7d0bab8 added a line
:</code>
Here we can see that the repo’s commit history has been restored to the previous version we were experimenting with. 

We can see that commit <code>4801b87</code> restored even though it appeared lost from the first reset operation. 
The <code>git reflog</code> is a powerful tool for undoing changes in the repository. 
Learn more in depth usage on the <code>git reflog</code> page.
<h2><span class="saddlebrown">&emsp;git revert</span></h2>
The previous set of examples did some serious time traveling undo operations using <code>git reset</code> and <code>git reflog</code>. 
Git contains another ‘undo’ utility which is often considered ‘safer’ than reseting. 
Reverting creates new commits which contain an inverse of the specified commits changes. 
These revert commits can then be safely pushed to remote repositories to share with other developers.

The following section will demonstrate <code>git revert</code> usage. 
Let us continue with our example from the previous section. 
To start let us examine the log and find a commit to revert.
<code>$ git log --online

1f08a70 Initial Bitbucket Pipelines configuration
52f823c repeated quote to show how a change moves through the process
4801b87 Merged in changes (pull request #6)
1a6a403 myquote edited online with Bitbucket

1f08a70 Initial Bitbucket Pipelines configuration
52f823c repeated quote to show how a change moves through the process
4801b87 Merged in changes (pull request #6)
1a6a403 myquote edited online with Bitbucket

3b29606 myquote2.html edited online with Bitbucket
8b236d9 myquote edited online with Bitbucket
235b9a7 testing prs
c5826da more changes

43a87f4 remivng
d5c4c62 a few small changes
23a7476 Merged in new-feature2 (pull request #3)
5cc4e1e add a commit message

cbbb5d6 trying a thing
438f956 adding section for permissions and cleaning up some formatting
23251c1 updated snipptes.xml organization into resources. 
other files misc changes

3f630f8 Adding file to track changes
e52470d README.md edited online with Bitbucket
e2fad94 README.md edited online with Bitbucket
592f84f Merge branch 'main' into new-feature2 Merge branch  especially if it merges an updated upstream into a topic branch.

7d0bab8 added a line
:</code>
For this example let’s pick the most recent commit <code>1f08a70</code> as our commit to operate on. 
For this scenario let's say that we want to undo the edits made in that commit. 

Execute:
<code>$ git revert 1f08a70</code>
This will kick off a <code>git merge</code> workflow. 
Git will create a new commit thats content is a reverse of the commit that was specified for the revert. 

Git will then open up a configured text editor to prompt for a new commit message. 
Reverts are considered the safer undo option because of this commit workflow. 
The creation of revert commits leave a clear trail in the commit history of when an undo operation was executed.
<h2><span class="saddlebrown">&emsp;You just learned how to undo changes!</span></h2>
Congratulations, you’re done! Come back to this tutorial any time or head to the Undoing Changes section to go more in depth. 
Keep up the good work in Bitbucket!
<h2><br><span class="orange">What is version control?</span></h2>
Version control, also known as source control, is the practice of tracking and managing changes to software code. 

Version control systems are software tools that help software teams manage changes to source code over time. 
As development environments have accelerated, version control systems help software teams work faster and smarter. 
They are especially useful for <a href="/devops/what-is-devops" data-event="clicked" data-uuid="9add58dd-17" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">DevOps</a> teams since they help them to reduce development time and increase successful deployments.
Version control software keeps track of every modification to the code in a special kind of database. 

If a mistake is made, developers can turn back the clock and compare earlier versions of the code to help fix the mistake while minimizing disruption to all team members.
<a class="play-trigger" data-event="clicked" data-uuid="b98fb7df-fa" data-event-component="linkButton" data-event-container="videoEmbedInline" data-schema-version="1" data-product-key="bitbucket" href="https://www.youtube.com/watch?v=xQujH0ElTUg">
</a>
<script type="text/x-component">

{
"type":"imkt.components.VideoEmbedInline",
"params": {
"videoId":"xQujH0ElTUg",

"source":"youtube",
"behavior":"replaceImage",
"uniqueId":"b98fb7df"
}

}
</script>
For almost all software projects, the source code is like the crown jewels - a precious asset whose value must be protected. 
For most software teams, the source code is a repository of the invaluable knowledge and understanding about the problem domain that the developers have collected and refined through careful effort. 

Version control protects source code from both catastrophe and the casual degradation of human error and unintended consequences.
Software developers working in teams are continually writing new source code and changing existing source code. 
The code for a project, app or software component is typically organized in a folder structure or "file tree". 
One developer on the team may be working on a new feature while another developer fixes an unrelated bug by changing code, each developer may make their changes in several parts of the file tree.

Version control helps teams solve these kinds of problems, tracking every individual change by each contributor and helping prevent concurrent work from conflicting. 
Changes made in one part of the software can be incompatible with those made by another developer working at the same time. 
This problem should be discovered and solved in an orderly manner without blocking the work of the rest of the team. 
Further, in all software development, any change can introduce new bugs on its own and new software can't be trusted until it's tested. 

So testing and development proceed together until a new version is ready. 
Good version control software supports a developer's preferred workflow without imposing one particular way of working. 
Ideally it also works on any platform, rather than dictate what operating system or tool chain developers must use. 
Great version control systems facilitate a smooth and continuous flow of changes to the code rather than the frustrating and clumsy mechanism of file locking - giving the green light to one developer at the expense of blocking the progress of others.

Software teams that do not use any form of version control often run into problems like not knowing which changes that have been made are available to users or the creation of incompatible changes between two unrelated pieces of work that must then be painstakingly untangled and reworked. 
If you're a developer who has never used version control you may have added versions to your files, perhaps with suffixes like "final" or "latest" and then had to later deal with a new final version. 
Perhaps you've commented out code blocks because you want to disable certain functionality without deleting the code, fearing that there may be a use for it later. 
Version control is a way out of these problems.

Version control software is an essential part of the every-day of the modern software team's professional practices. 
Individual software developers who are accustomed to working with a capable version control system in their teams typically recognize the incredible value version control also gives them even on small solo projects. 
Once accustomed to the powerful benefits of version control systems, many developers wouldn't consider working without it even for non-software projects.
<h2><span class="saddlebrown">&emsp;Benefits of version control systems</span></h2>
Using version control software is a best practice for high performing software and <a href="/devops/what-is-devops" data-event="clicked" data-uuid="1e733403-1f" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">DevOps</a> teams. 
Version control also helps developers move faster and allows software teams to preserve efficiency and agility as the team scales to include more developers.
Version Control Systems (VCS) have seen great improvements over the past few decades and some are better than others. 
VCS are sometimes known as SCM (Source Code Management) tools or RCS (Revision Control System). 

One of the most popular VCS tools in use today is called Git. 
Git is a <em>Distributed</em> VCS, a category known as DVCS, more on that later. 
Like many of the most popular VCS systems available today, Git is free and open source. 
Regardless of what they are called, or which system is used, the primary benefits you should expect from version control are as follows.

A complete long-term change history of every file. 
This means every change made by many individuals over the years. 
Changes include the creation and deletion of files as well as edits to their contents. 
Different VCS tools differ on how well they handle renaming and moving of files. 

This history should also include the author, date and written notes on the purpose of each change. 
Having the complete history enables going back to previous versions to help in root cause analysis for bugs and it is crucial when needing to fix problems in older versions of software. 
If the software is being actively worked on, almost everything can be considered an "older version" of the software.
 Branching and merging. 

Having team members work concurrently is a no-brainer, but even individuals working on their own can benefit from the ability to work on independent streams of changes. 
Creating a "branch" in VCS tools keeps multiple streams of work independent from each other while also providing the facility to merge that work back together, enabling developers to verify that the changes on each branch do not conflict. 
Many software teams adopt a practice of branching for each feature or perhaps branching for each release, or both. 
There are many different workflows that teams can choose from when they decide how to make use of branching and merging facilities in VCS.

 Traceability. 
Being able to trace each change made to the software and connect it to project management and bug tracking software such as <a href="/software/jira" data-event="clicked" data-uuid="c3202cd6-09" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Jira</a>, and being able to annotate each change with a message describing the purpose and intent of the change can help not only with root cause analysis and other forensics. 
Having the annotated history of the code at your fingertips when you are reading the code, trying to understand what it is doing and why it is so designed can enable developers to make correct and harmonious changes that are in accord with the intended long-term design of the system. 
This can be especially important for working effectively with legacy code and is crucial in enabling developers to estimate future work with any accuracy.

While it is possible to develop software without using any version control, doing so subjects the project to a huge risk that no professional team would be advised to accept. 
So the question is not whether to use version control but which version control system to use.
There are many choices, but here we are going to focus on just one, Git. 
Learn more about other types of <a href="https://bitbucket.org/product/version-control-software" data-event="clicked" data-uuid="3e6fd41a-18" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">version control software</a>. 

<h2><br><span class="orange">Source code management</span></h2>
Source code management (SCM) is used to track modifications to a source code repository. 
SCM tracks a running history of changes to a code base and helps resolve conflicts when merging updates from multiple contributors. 
SCM is also synonymous with Version control. 

As software projects grow in lines of code and contributor head count, the costs of communication overhead and management complexity also grow. 
SCM is a critical tool to alleviate the organizational strain of growing development costs.
<h2><br><span class="orange">What is Git</span></h2>
By far, the most widely used modern version control system in the world today is Git. 

Git is a mature, actively maintained open source project originally developed in 2005 by Linus Torvalds, the famous creator of the Linux operating system kernel. 
A staggering number of software projects rely on Git for version control, including commercial projects as well as open source. 
Developers who have worked with Git are well represented in the pool of available software development talent and it works well on a wide range of operating systems and IDEs (Integrated Development Environments).
Having a distributed architecture, Git is an example of a DVCS (hence Distributed Version Control System). 

Rather than have only one single place for the full version history of the software as is common in once-popular version control systems like CVS or Subversion (also known as SVN), in Git, every developer's working copy of the code is also a repository that can contain the full history of all changes.
In addition to being distributed, Git has been designed with performance, security and flexibility in mind.
<h2><span class="saddlebrown">&emsp;Performance</span></h2>
The raw performance characteristics of Git are very strong when compared to many alternatives. 

Committing new changes, branching, merging and comparing past versions are all optimized for performance. 
The algorithms implemented inside Git take advantage of deep knowledge about common attributes of real source code file trees, how they are usually modified over time and what the access patterns are.
Unlike some version control software, Git is not fooled by the names of the files when determining what the storage and version history of the file tree should be, instead, Git focuses on the file content itself. 
After all, source code files are frequently renamed, split, and rearranged. 

The object format of Git's repository files uses a combination of delta encoding (storing content differences), compression and explicitly stores directory contents and version metadata objects.
Being distributed enables significant performance benefits as well.
For example, say a developer, Alice, makes changes to source code, adding a feature for the upcoming 2.0 release, then commits those changes with descriptive messages. 
She then works on a second feature and commits those changes too. 

Naturally these are stored as separate pieces of work in the version history. 
Alice then switches to the version 1.3 branch of the same software to fix a bug that affects only that older version. 
The purpose of this is to enable Alice's team to ship a bug fix release, version 1.3.1, before version 2.0 is ready. 
Alice can then return to the 2.0 branch to continue working on new features for 2.0 and all of this can occur without any network access and is therefore fast and reliable. 

She could even do it on an airplane. 
When she is ready to send all of the individually committed changes to the remote repository, Alice can "push" them in one command.
<h2><span class="saddlebrown">&emsp;Security</span></h2>
Git has been designed with the integrity of managed source code as a top priority. 

The content of the files as well as the true relationships between files and directories, versions, tags and commits, all of these objects in the Git repository are secured with a cryptographically secure hashing algorithm called SHA1. 
This protects the code and the change history against both accidental and malicious change and ensures that the history is fully traceable.
With Git, you can be sure you have an authentic content history of your source code.
Some other version control systems have no protections against secret alteration at a later date. 

This can be a serious information security vulnerability for any organization that relies on software development.
<h2><span class="saddlebrown">&emsp;Flexibility</span></h2>
One of Git's key design objectives is flexibility. 
Git is flexible in several respects: in support for various kinds of nonlinear development workflows, in its efficiency in both small and large projects and in its compatibility with many existing systems and protocols.

Git has been designed to support branching and tagging as first-class citizens (unlike SVN) and operations that affect branches and tags (such as merging or reverting) are also stored as part of the change history. 
Not all version control systems feature this level of tracking.
<h2><span class="saddlebrown">&emsp;Version control with Git</span></h2>
Git is the best choice for most software teams today. 

While every team is different and should do their own analysis, here are the main reasons why version control with Git is preferred over alternatives:
<h3>&emsp;Git is good</h3>
Git has the functionality, performance, security and flexibility that most teams and individual developers need. 
These attributes of Git are detailed above. 

In side-by-side comparisons with most other alternatives, many teams find that Git is very favorable.
<h3>&emsp;Git is a de facto standard</h3>
Git is the most broadly adopted tool of its kind. 
This makes Git attractive for the following reasons. 

At Atlassian, nearly all of our project source code is managed in Git.
Vast numbers of developers already have Git experience and a significant proportion of college graduates may have experience with only Git. 
While some organizations may need to climb the learning curve when migrating to Git from another version control system, many of their existing and future developers do not need to be trained on Git.
In addition to the benefits of a large talent pool, the predominance of Git also means that many third party software tools and services are already integrated with Git including IDEs, and our own tools like DVCS desktop client <a href="http://www.sourcetreeapp.com/" data-event="clicked" data-uuid="05c291c4-65" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Sourcetree</a>, issue and project tracking software, <a href="/software/jira" data-event="clicked" data-uuid="05c291c4-65" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Jira</a>, and code hosting service, <a href="https://bitbucket.org/product" data-event="clicked" data-uuid="05c291c4-65" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Bitbucket</a>.

If you are an inexperienced developer wanting to build up valuable skills in software development tools, when it comes to version control, Git should be on your list.
<h3>&emsp;Git is a quality open source project</h3>
Git is a very well supported open source project with over a decade of solid stewardship. 
The project maintainers have shown balanced judgment and a mature approach to meeting the long term needs of its users with regular releases that improve usability and functionality. 

The quality of the open source software is easily scrutinized and countless businesses rely heavily on that quality.
Git enjoys great community support and a vast user base. 
Documentation is excellent and plentiful, including books, tutorials and dedicated web sites. 
There are also podcasts and video tutorials.

Being open source lowers the cost for hobbyist developers as they can use Git without paying a fee. 
For use in open-source projects, Git is undoubtedly the successor to the previous generations of successful open source version control systems, SVN and CVS.
<h3>&emsp;Criticism of Git</h3>
One common criticism of Git is that it can be difficult to learn. 

Some of the terminology in Git will be novel to newcomers and for users of other systems, the Git terminology may be different, for example, <code>revert</code> in Git has a different meaning than in SVN or CVS. 
Nevertheless, Git is very capable and provides a lot of power to its users. 
Learning to use that power can take some time, however once it has been learned, that power can be used by the team to increase their development speed.
For those teams coming from a non-distributed VCS, having a central repository may seem like a good thing that they don't want to lose. 

However, while Git has been designed as a distributed version control system (DVCS), with Git, you can still have an official, canonical repository where all changes to the software must be stored. 
With Git, because each developer's repository is complete, their work doesn't need to be constrained by the availability and performance of the "central" server. 
During outages or while offline, developers can still consult the full project history. 
Because Git is flexible as well as being distributed, you can work the way you are accustomed to but gain the additional benefits of Git, some of which you may not even realise you're missing.

Now that you understand what version control is, what Git is and why software teams should use it, read on to discover the benefits Git can provide across the whole organization.
<h2><br><span class="orange">Why Git for your organization</span></h2>
Switching from a centralized version control system to Git changes the way your development team creates software. 
And, if you’re a company that relies on its software for mission-critical applications, altering your development workflow impacts your entire business.

<img src="https://wac-cdn.atlassian.com/dam/jcr:fe39ef08-ff6a-4603-adc6-fcfc78035a50/01.svg?cdnVersion=217" loading="lazy" alt="Organizational Development">In this article, we’ll discuss how Git benefits each aspect of your organization, from your development team to your marketing team, and everything in between. 
By the end of this article, it should be clear that Git isn’t just for <a href="/agile/software-development/developer" data-event="clicked" data-uuid="047ad650-7e" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">agile software development</a>—it’s for agile business.
<h2><span class="saddlebrown">&emsp;Git for developers</span></h2>
<h3>&emsp;Feature Branch Workflow</h3>

One of the biggest advantages of Git is its branching capabilities. 
Unlike centralized version control systems, Git branches are cheap and easy to merge. 
This facilitates the feature branch workflow popular with many Git users.
<img src="https://wac-cdn.atlassian.com/dam/jcr:39ab5e67-39a7-4cd2-9cf4-98bc89dffd9a/01%20Feature%20Branch%20Workflow.svg?cdnVersion=217" loading="lazy" alt="Feature branch workflow">Feature branches provide an isolated environment for every change to your codebase. 

When a developer wants to start working on something—no matter how big or small—they create a new branch. 
This ensures that the main branch always contains production-quality code.
Using feature branches is not only more reliable than directly editing production code, but it also provides organizational benefits. 
They let you represent development work at the same granularity as the your <a href="/agile/scrum/backlogs" data-event="clicked" data-uuid="db086deb-bb" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">agile backlog</a>. 

For example, you might implement a policy where each <a href="/software/jira" data-event="clicked" data-uuid="db086deb-bb" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Jira</a> ticket is addressed in its own feature branch.
<h3>&emsp;Distributed Development</h3>
In SVN, each developer gets a working copy that points back to a single central repository. 
Git, however, is a distributed version control system. 

Instead of a working copy, each developer gets their own local repository, complete with a full history of commits.
<img src="https://wac-cdn.atlassian.com/dam/jcr:9d51f0ee-5946-4be2-886c-ff040ef8c1a1/03.svg?cdnVersion=217" loading="lazy" alt="Distributed development">Having a full local history makes Git fast, since it means you don’t need a network connection to create commits, inspect previous versions of a file, or perform diffs between commits.
Distributed development also makes it easier to scale your engineering team. 
If someone breaks the production branch in SVN, other developers can’t check in their changes until it’s fixed. 

With Git, this kind of blocking doesn’t exist. 
Everybody can continue going about their business in their own local repositories.
And, similar to feature branches, distributed development creates a more reliable environment. 
Even if a developer obliterates their own repository, they can simply clone someone else’s and start anew.

<h3>&emsp;Pull Requests</h3>
Many source code management tools such as <a href="https://Bitbucket.org" data-event="clicked" data-uuid="44d87a0a-a6" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Bitbucket</a> enhance core Git functionality with pull requests. 
A pull request is a way to ask another developer to merge one of your branches into their repository. 
This not only makes it easier for project leads to keep track of changes, but also lets developers initiate discussions around their work before integrating it with the rest of the codebase.

<img src="https://wac-cdn.atlassian.com/dam/jcr:ada8f4c4-22b1-486c-872b-df83484e288b/02%20Pull%20Requests.svg?cdnVersion=217" loading="lazy" alt="Pull requests">Since they’re essentially a comment thread attached to a feature branch, pull requests are extremely versatile. 
When a developer gets stuck with a hard problem, they can open a pull request to ask for help from the rest of the team. 
Alternatively, junior developers can be confident that they aren’t destroying the entire project by treating pull requests as a formal code review.
<h3>&emsp;Community</h3>

In many circles, Git has come to be the expected version control system for new projects. 
If your team is using Git, odds are you won’t have to train new hires on your workflow, because they’ll already be familiar with distributed development.
<img src="https://wac-cdn.atlassian.com/dam/jcr:60fb4158-0c3e-4f1b-a932-fb4e8a660ee4/05.svg?cdnVersion=217" loading="lazy" alt="Git Community">In addition, Git is very popular among open source projects. 
This means it’s easy to leverage 3rd-party libraries and encourage others to fork your own open source code.

<h3>&emsp;Faster Release Cycle</h3>
The ultimate result of feature branches, distributed development, pull requests, and a stable community is a faster release cycle. 
These capabilities facilitate an <a href="/agile/project-management/workflow" data-event="clicked" data-uuid="5214986f-27" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">agile workflow</a> where developers are encouraged to share smaller changes more frequently. 
In turn, changes can get pushed down the deployment pipeline faster than the monolithic releases common with centralized version control systems.

<img src="https://wac-cdn.atlassian.com/dam/jcr:4263b82f-e177-47d4-a587-dab97a20334d/06.svg?cdnVersion=217" loading="lazy" alt="Faster release cycle">As you might expect, Git works very well with continuous integration and continuous delivery environments. 
Git hooks allow you to run scripts when certain events occur inside of a repository, which lets you automate deployment to your heart’s content. 
You can even build or deploy code from specific branches to different servers.
For example, you might want to configure Git to deploy the most recent commit from the develop branch to a test server whenever anyone merges a pull request into it. 

Combining this kind of build automation with peer review means you have the highest possible confidence in your code as it moves from development to staging to production.
<h2><span class="saddlebrown">&emsp;Git for marketing</span></h2>
To understand how switching to Git affects your company’s marketing activities, imagine your development team has three distinct changes scheduled for completion in the next few weeks:
The entire team is finishing up a game-changing feature that they’ve been working on for the last 6 months.

Mary is implementing a smaller, unrelated feature that only impacts existing customers.
Rick is making some much-needed updates to the user interface.
If you’re using a traditional development workflow that relies on a centralized VCS, all of these changes would probably be rolled up into a single release. 
Marketing can only make one announcement that focuses primarily on the game-changing feature, and the marketing potential of the other two updates is effectively ignored.

The shorter development cycle facilitated by Git makes it much easier to divide these into individual releases. 
This gives marketers more to talk about, more often. 
In the above scenario, marketing can build out three campaigns that revolve around each feature, and thus target very specific market segments. 
<img src="https://wac-cdn.atlassian.com/dam/jcr:452591fb-9c9d-4a94-a262-671e146fe869/07.svg?cdnVersion=217" loading="lazy" alt="Git for Marketing">For instance, they might prepare a big PR push for the game changing feature, a corporate blog post and newsletter blurb for Mary’s feature, and some guest posts about Rick’s underlying UX theory for sending to external design blogs. 

All of these activities can be synchronized with a separate release.
<h2><span class="saddlebrown">&emsp;Git for product management</span></h2>
The benefits of Git for product management is much the same as for marketing. 
More frequent releases means more frequent customer feedback and faster updates in reaction to that feedback. 

Instead of waiting for the next release 8 weeks from now, you can push a solution out to customers as quickly as your developers can write the code.
<img src="https://wac-cdn.atlassian.com/dam/jcr:1c1cc48f-324a-4aaa-9a54-58ab93a7d219/08.svg?cdnVersion=217" loading="lazy" alt="Priority Management git workflow">The feature branch workflow also provides flexibility when priorities change. 
For instance, if you’re halfway through a release cycle and you want to postpone one feature in lieu of another time-critical one, it’s no problem. 
That initial feature can sit around in its own branch until engineering has time to come back to it.

This same functionality makes it easy to manage innovation projects, beta tests, and rapid prototypes as independent codebases.
<h2><span class="saddlebrown">&emsp;Git for designers</span></h2>
Feature branches lend themselves to rapid prototyping. 
Whether your UX/UI designers want to implement an entirely new user flow or simply replace some icons, checking out a new branch gives them a sandboxed environment to play with. 

This lets designers see how their changes will look in a real working copy of the product without the threat of breaking existing functionality.
<img src="https://wac-cdn.atlassian.com/dam/jcr:6521263d-9cd5-4705-89d7-769f0d286fa4/09.svg?cdnVersion=217" loading="lazy" alt="Git non-destructive versioning">Encapsulating user interface changes like this makes it easy to present updates to other stakeholders. 
For example, if the director of engineering wants to see what the design team has been working on, all they have to do is tell the director to check out the corresponding branch.
Pull requests take this one step further and provide a formal place for interested parties to discuss the new interface. 

Designers can make any necessary changes, and the resulting commits will show up in the pull request. 
This invites everybody to participate in the iteration process.
Perhaps the best part of prototyping with branches is that it’s just as easy to merge the changes into production as it is to throw them away. 
There’s no pressure to do either one. 

This encourages designers and UI developers to experiment while ensuring that only the best ideas make it through to the customer. 
<h2><span class="saddlebrown">&emsp;Git for customer support</span></h2>
Customer support and customer success often have a different take on updates than product managers. 
When a customer calls them up, they’re usually experiencing some kind of problem. 

If that problem is caused by your company’s software, a bug fix needs to be pushed out as soon as possible.
Git’s streamlined development cycle avoids postponing bug fixes until the next monolithic release. 
A developer can patch the problem and push it directly to production. 
Faster fixes means happier customers and fewer repeat support tickets. 

Instead of being stuck with, “Sorry, we’ll get right on that” your customer support team can start responding with “We’ve already fixed it! 
<h2><span class="saddlebrown">&emsp;Git for human resources</span></h2>
To a certain extent, your software development workflow determines who you hire. 
It always helps to hire engineers that are familiar with your technologies and workflows, but using Git also provides other advantages.

Employees are drawn to companies that provide career growth opportunities, and understanding how to leverage Git in both large and small organizations is a boon to any programmer. 
By choosing Git as your version control system, you’re making the decision to attract forward-looking developers.
<h2><span class="saddlebrown">&emsp;Git for anyone managing a budget</span></h2>
Git is all about efficiency. 

For developers, it eliminates everything from the time wasted passing commits over a network connection to the man hours required to integrate changes in a centralized version control system. 
It even makes better use of junior developers by giving them a safe environment to work in. 
All of this affects the bottom line of your engineering department.
<img src="https://wac-cdn.atlassian.com/dam/jcr:c5db1ef6-ae40-46cc-8408-c0f9e0b53a84/10.svg?cdnVersion=217" loading="lazy" alt="Git distributed team">But, don’t forget that these efficiencies also extend outside your development team. 

They prevent marketing from pouring energy into collateral for features that aren’t popular. 
They let designers test new interfaces on the actual product with little overhead. 
They let you react to customer complaints immediately.
Being agile is all about finding out what works as quickly as possible, magnifying efforts that are successful, and eliminating ones that aren’t. 

Git serves as a multiplier for all your business activities by making sure every department is doing their job more efficiently.
<h2><br><span class="orange">Install Git</span></h2>
<h2><span class="saddlebrown">&emsp;Install Git on Mac OS X</span></h2>
There are several ways to install Git on a Mac. 

In fact, if you've installed XCode (or it's Command Line Tools), Git may already be installed. 
To find out, open a terminal and enter <code>git --version</code>.
<code>$ git --version git version 2.7.0 (Apple Git-66)</code>
Apple actually maintain and ship <a href="http://opensource.apple.com/source/Git/" data-event="clicked" data-uuid="c4488ddc-c7" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">their own fork of Git</a>, but it tends to lag behind mainstream Git by several major versions. 

You may want to install a newer version of Git using one of the methods below:
<h3>&emsp;Git for Mac Installer</h3>
The easiest way to install Git on a Mac is via the stand-alone installer:
Download the latest <a href="https://sourceforge.net/projects/git-osx-installer/files/" data-event="clicked" data-uuid="137f06c3-65" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Git for Mac installer</a>.

 Follow the prompts to install Git.
 Open a terminal and verify the installation was successful by typing <code>git --version</code>:
<code>$ git --version</code>
<code> git version 2.9.2</code>

 Configure your Git username and email using the following commands, replacing Emma's name with your own. 
These details will be associated with any commits that you create:
<code>$ git config --global user.name "Emma Paris"</code>
<code> $ git config --global user.email "eparis@atlassian.com"</code>

 (Optional) To make Git remember your username and password when working with HTTPS repositories, <a href="#install-the-git-credential-osx" data-event="clicked" data-uuid="137f06c3-65" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">configure the git-credential-osxkeychain helper</a>.
<h3>&emsp;Install Git with Homebrew</h3>
If you have <a href="http://brew.sh/" data-event="clicked" data-uuid="d818f630-bb" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">installed Homebrew</a> to manage packages on OS X, you can follow these instructions to install Git:
Open your terminal and install Git using Homebrew:

<code>$ brew install git</code>
 Verify the installation was successful by typing which <code>git --version</code>:
<code>$ git --version git version 2.9.2</code>
 Configure your Git username and email using the following commands, replacing Emma's name with your own. 

These details will be associated with any commits that you create:
<code>$ git config --global user.name "Emma Paris"</code>
<code>$ git config --global user.email "eparis@atlassian.com"</code>
 (Optional) To make Git remember your username and password when working with HTTPS repositories, install the <a href="#install-the-git-credential-osx" data-event="clicked" data-uuid="4c7e868c-dc" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">git-credential-osxkeychain helper</a>.

<h3>&emsp;Install Git with MacPorts</h3>
If you have <a href="https://www.macports.org/install.php" data-event="clicked" data-uuid="b964b614-6f" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">installed MacPorts</a> to manage packages on OS X, you can follow these instructions to install Git:
Open your terminal and update MacPorts:
<code>$ sudo port selfupdate</code>

 Search for the latest available Git ports and variants:
<code>$ port search git</code>
<code>$ port variants git</code>
 Install Git with bash completion, the OS X keychain helper, and the docs:

<code>$ sudo port install git +bash_completion+credential_osxkeychain+doc</code>
 Configure your Git username and email using the following commands, replacing Emma's name with your own. 
These details will be associated with any commits that you create:
<code>$ git config --global user.name "Emma Paris"</code>

<code>$ git config --global user.email "eparis@atlassian.com"</code>
 (Optional) To make Git remember your username and password when working with HTTPS repositories, configure the git-credential-osxkeychain helper.
<h3>&emsp;Install the git-credential-osxkeychain helper</h3>
Bitbucket supports pushing and pulling your Git repositories over both SSH and HTTPS. 

To work with a private repository over HTTPS, you must supply a username and password each time you push or pull. 
The <strong>git-credential-osxkeychain</strong> helper allows you to cache your username and password in the OSX keychain, so you don't have to retype it each time.
If you followed the MacPorts or Homebrew instructions above, the helper should already be installed. 
Otherwise you'll need to download and install it. 

Open a terminal window and check:
<code>$ git credential-osxkeychain usage: git credential-osxkeychain <get></get></code>
If you receive a usage statement, skip to step 4. If the helper is not installed, go to step 2.

Use curl to download git-credential-osxkeychain (or <a href="http://github-media-downloads.s3.amazonaws.com/osx/git-credential-osxkeychain" data-event="clicked" data-uuid="808a5fc6-28" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">download it via your browser</a>) and move it to <code>/usr/local/bin</code>:
<code>$ curl -O http://github-media-downloads.s3.amazonaws.com/osx/git-credential-osxkeychain $ sudo mv git-credential-osxkeychain /usr/local/bin/</code>
Make the file an executable:
<code>$ chmod u+x /usr/local/bin/git-credential-osxkeychain</code>

Configure git to use the osxkeychain credential helper.
<code>$ git config --global credential.helper osxkeychain</code>
The next time Git prompts you for a username and password, it will cache them in your keychain for future use.
<h3>&emsp;Install Git with Atlassian Sourcetree</h3>

Sourcetree, a free visual Git client for Mac, comes with its own bundled version of Git. 
You can <a href="http://www.sourcetreeapp.com/" data-event="clicked" data-uuid="dcb3f9da-6e" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">download Sourcetree here</a>.
To learn how to use Git with Sourcetree (and how to host your Git repositories on Bitbucket) you can follow our comprehensive <a href="https://support.atlassian.com/bitbucket-cloud/docs/tutorial-learn-bitbucket-with-sourcetree/?_ga=2.64335407.1424849300.1543857612-1803500522.1531756517" data-event="clicked" data-uuid="75d314ae-6c" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Git tutorial with Bitbucket and Sourcetree</a>.
<h3>&emsp;Build Git from source on OS X</h3>

Building Git can be a little tricky on Mac due to certain libraries moving around between OS X releases. 
On El Capitan (OS X 10.11), follow these instructions to build Git:
From your terminal install XCode's Command Line Tools (if you haven't already):
<code>$ xcode-select --install</code>

Install <a href="http://brew.sh/" data-event="clicked" data-uuid="780607e6-e1" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Homebrew</a>.
Using Homebrew, install openssl:
<code>$ brew install openssl</code>
Clone the Git source (or if you don't yet have a version of Git installed, <a href="https://github.com/git/git/archive/master.zip" data-event="clicked" data-uuid="780607e6-e1" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">download and extract it</a>):

<code>$ git clone https://github.com/git/git.git</code>
To build Git run make with the following flags:
<code>$ NO_GETTEXT=1 make CFLAGS="-I/usr/local/opt/openssl/include" LDFLAGS="-L/usr/local/opt/openssl/lib"</code>
<a class="button" href="https://www.atlassian.com/git/tutorials/learn-git-with-bitbucket-cloud" data-event="clicked" data-uuid="9ebe3cc8-b0" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket" title="Learn Git with Bitbucket Cloud">Next Step: Learn Git with Bitbucket Cloud</a>
<h2><span class="saddlebrown">&emsp;Install Git on Windows</span></h2>
<h3>&emsp;Git for Windows stand-alone installer</h3>
Download the latest <a href="https://git-for-windows.github.io/" data-event="clicked" data-uuid="db01c3b6-2c" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Git for Windows installer</a>.
When you've successfully started the installer, you should see the <strong>Git Setup</strong> wizard screen. 

Follow the <strong>Next</strong> and <strong>Finish</strong> prompts to complete the installation. 
The default options are pretty sensible for most users.
Open a Command Prompt (or Git Bash if during installation you elected not to use Git from the Windows Command Prompt).
Run the following commands to configure your Git username and email using the following commands, replacing Emma's name with your own. 

These details will be associated with any commits that you create:
<code>$ git config --global user.name "Emma Paris" $ git config --global user.email "eparis@atlassian.com"</code>
<em>Optional: Install the Git credential helper on Windows</em>
Bitbucket supports pushing and pulling over HTTP to your remote Git repositories on Bitbucket. 

Every time you interact with the remote repository, you must supply a username/password combination. 
You can store these credentials, instead of supplying the combination every time, with the <a href="https://github.com/Microsoft/Git-Credential-Manager-for-Windows" data-event="clicked" data-uuid="db01c3b6-2c" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Git Credential Manager for Windows</a>.
<h3>&emsp;Install Git with Atlassian Sourcetree</h3>
Sourcetree, a free visual Git client for Windows, comes with its own bundled version of Git. 

You can <a href="http://www.sourcetreeapp.com/" data-event="clicked" data-uuid="bf01ae0f-71" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">download Sourcetree here</a>.
To learn how to use Git with Sourcetree (and how to host your Git repositories on Bitbucket) you can follow our comprehensive <a href="https://support.atlassian.com/bitbucket-cloud/docs/tutorial-learn-bitbucket-with-sourcetree/?_ga=2.64335407.1424849300.1543857612-1803500522.1531756517" data-event="clicked" data-uuid="2b550fa4-ae" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Git tutorial with Bitbucket and Sourcetree</a>. 
<a class="button" href="https://www.atlassian.com/git/tutorials/learn-git-with-bitbucket-cloud" data-event="clicked" data-uuid="59933b07-d8" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket" title="Learn Git with Bitbucket Cloud">Next Step: Learn Git with Bitbucket Cloud</a>
<h2><span class="saddlebrown">&emsp;Install Git on Linux</span></h2>
<h3>&emsp;Debian / Ubuntu (apt-get)</h3>
Git packages are available via <a href="https://wiki.debian.org/Apt" data-event="clicked" data-uuid="2c05a50d-59" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">apt</a>:
From your shell, install Git using apt-get:
<code>$ sudo apt-get update</code>

<code>$ sudo apt-get install git</code>
 Verify the installation was successful by typing <code>git --version</code>:
<code>$ git --version</code>
<code>git version 2.9.2</code>

 Configure your Git username and email using the following commands, replacing Emma's name with your own. 
These details will be associated with any commits that you create:
<code>$ git config --global user.name "Emma Paris"</code>
<code>$ git config --global user.email "eparis@atlassian.com"</code>

<h3>&emsp;Fedora (dnf/yum)</h3>
Git packages are available via both <a href="https://fedoraproject.org/wiki/Yum" data-event="clicked" data-uuid="9ad92d42-93" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">yum</a> and <a href="https://fedoraproject.org/wiki/Dnf" data-event="clicked" data-uuid="9ad92d42-93" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">dnf</a>:
From your shell, install Git using dnf (or yum, on older versions of Fedora):
<code>$ sudo dnf install git</code>

or
<code>$ sudo yum install git</code>
 Verify the installation was successful by typing <code>git --version</code>:
<code>$ git --version</code>

<code>git version 2.9.2</code>
 Configure your Git username and email using the following commands, replacing Emma's name with your own. 
These details will be associated with any commits that you create
<code>$ git config --global user.name "Emma Paris"</code>

<code> $ git config --global user.email "eparis@atlassian.com"</code>
<h3>&emsp;Build Git from source on Linux</h3>
<em>Debian / Ubuntu</em>
Git requires the several dependencies to build on Linux. 

These are available via <a href="https://wiki.debian.org/Apt" data-event="clicked" data-uuid="a9d6325b-c4" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">apt</a>:
From your shell, install the necessary dependencies using apt-get:
<code>$ sudo apt-get update</code>
<code>$ sudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext libz-dev libssl-dev asciidoc xmlto docbook2x</code>

 Clone the Git source (or if you don't yet have a version of Git installed, <a href="https://www.kernel.org/pub/software/scm/git/" data-event="clicked" data-uuid="d00a590d-de" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">download and extract it</a>):
<code>$ git clone https://git.kernel.org/pub/scm/git/git.git</code>
 To build Git and install it under <code>/usr</code>, run <code>make</code>:
<code>$ make all doc info prefix=/usr</code>

<code>$ sudo make install install-doc install-html install-info install-man prefix=/usr</code>
<em>Fedora</em>
Git requires the several dependencies to build on Linux. 
These are available via both <a href="https://fedoraproject.org/wiki/Yum" data-event="clicked" data-uuid="b4d0004c-1b" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">yum</a> and <a href="https://fedoraproject.org/wiki/Dnf" data-event="clicked" data-uuid="b4d0004c-1b" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">dnf</a>:

From your shell, install the necessary build dependencies using dnf (or yum, on older versions of Fedora):
<code>$ sudo dnf install curl-devel expat-devel gettext-devel openssl-devel perl-devel zlib-devel asciidoc xmlto docbook2X</code>
or using yum. 
For yum, you may need to install the Extra Packages for Enterprise Linux (EPEL) repository first:

<code>$ sudo yum install epel-release</code>
<code>$ sudo yum install curl-devel expat-devel gettext-devel openssl-devel perl-devel zlib-devel asciidoc xmlto docbook2X</code>
 Symlink docbook2X to the filename that the Git build expects:
<code>$ sudo ln -s /usr/bin/db2x_docbook2texi /usr/bin/docbook2x-texi</code>

 Clone the Git source (or if you don't yet have a version of Git installed, <a href="https://www.kernel.org/pub/software/scm/git/" data-event="clicked" data-uuid="7ba3722c-65" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">download and extract it</a>):
<code>$ git clone https://git.kernel.org/pub/scm/git/git.git</code>
 To build Git and install it under <code>/usr</code>, run <code>make</code>:
<code>$ make all doc prefix=/usr</code>

<code>$ sudo make install install-doc install-html install-man prefix=/usr</code>
<a class="button" href="/git/tutorials/learn-git-with-bitbucket-cloud" data-event="clicked" data-uuid="1bf601c1-a7" data-event-component="linkButton" data-event-container="richText" data-schema-version="1" data-product-key="bitbucket">Next Step: Learn Git with Bitbucket Cloud</a>

<script src='https://williamkpchan.github.io/LibDocs/readbook.js'></script>
<script>
var lazyLoadInstance = new LazyLoad({
  elements_selector: ".lazy"
  // ... more custom settings?
});
</script>
</pre></body></html>