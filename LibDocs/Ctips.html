<!DOCTYPE html>
<head>
<meta charset="utf-8">
<title>C Tips</title>
<link href="https://fonts.googleapis.com/css?family=Patrick Hand:400" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src='../mainscript.js'></script>
</head>


<style>
body { background-color: black; font-family: 'Patrick Hand', sans-serif; font-size: 18px; color: gray; width: 80%; margin-left: 10%;}

.tip { width: 100%;}
h2 {color: #10C030; }
.code { background-color: #001000; border-radius: 8px; border: 1px solid DarkSlateGray; padding: 5px; }
.code-block { font-family: monaco, Consolas, "Lucida Console", monospace; background-color: #001000; padding: 5px 5px; font-size: 1.15rem; border-radius: 0.15rem; display: block; margin: 1rem 0;}
.tip-number { margin-bottom: 2.5rem; color: #20A020; text-transform: uppercase; letter-spacing: 0.1rem; font-weight: bolder; font-size: 26px;}
.js-tip, .cssTip, .cssExplain { padding: 2px 2px; font-size: 20px; line-height: 1.6;}
.tip-button { background-color: #003020; outline: none; padding: 5px 5px; display: inline-block; margin: auto; font-size: 1rem; margin-top: 5px; cursor: pointer; font-weight: bolder; border: none; border-radius: 8px; color: #10C030;}
.disabled { background-color: #D8D8D8 !important; color: #888; cursor: not-allowed !important;}
a { text-decoration: none; color: #58D858;}
a:visited { color: #88C898;}
A:hover {	color: yellow;}
A:focus {	color: red;}
code { color: gray; background-color: #001010; font-size: 18px;}
pre { color: gray; background-color: #000500; font-size: 16px; width:80%;
	white-space: pre-wrap;}

</style>
<body onkeypress="chkKey()">
<h2>C Tips</h2>
<pre class="js-tip"> </pre><br>
<button class="tip-button" onclick="forward()">Tips Left: <span class="tip-limit-count"></span></button>

<script>
// List of JavaScript tips
var tipsList = [
'<i>sample code to write "Hello, World!" on the screen</i>\n\n#include&lt;stdio.h>\nint main()\n{ printf("Hello, World!\\n");\n  return 0;\n }',
'<i>sample code to write "Hello, World!" on the screen start with void</i>\n\n#include&lt;stdio.h>\n#include&lt;conio.h>\nvoid main()\n{  printf("Hello, World!\\n");\n  return;}',
'<i>Comments format</i>\n\n/* Comments */',
'<i>load standard for input/output</i>\n\n#include&lt;stdio.h>',
'<i>return value int/void</i>\n\nint/void main()',
'<i>program execution begins the main function</i>\n\nmain()',
'<i>to group all statements</i>\n\n{...}',
'<i>prints text on the screen</i>\n\nprintf()',
'<i>At the end of the main function returns value 0</i>\n\nreturn 0',
'<i>Basic Structure of C Program</i>\n\nThe Documentation section contains comment lines\nthe link-section instructs the compiler\nThe Definition section describes all the symbolic-constants. \nThe global declaration section define globally used variables and user-defined functions. \nThen comes the main() which contains two parts: \nDeclaration part to declare all variables\nExecution part\nall the statements terminate with a semi-colon. \nThe sub-program section deals with all user-defined functions',
'<i>to read and print data</i>\n#include&lt;stdio.h>\nvoid main()\n{ int a,b,c;\n printf("Please enter any two numbers: \\n");\n scanf("%d %d", &a, &b);\n c =  a + b;\n printf("The addition of two number is: %d", c);\n }',
'<i>reading a single character from standard input</i>\n\n#include&lt;stdio.h>\nvoid main()\n{ char title;\n  title = getchar();\n }',
'<i>to accept a character from standard input for files</i>\n\nint getc(FILE *stream);',
'<i>to write characters one at a time</i>\n\n#include&lt;stdio.h>\nvoid main()\n{ char result = \'P\';\n putchar(result);\n putchar(\' \');\n }',
'<i>sending a single character to the standard output file</i>\n\nint putc(int c, FILE *stream);',
'<i>Formatted Input Syntax:</i>\n\nscanf("control string", arg1, arg2, ..., argn);\n%w sd, % denotes the conversion specification;\n w defines the field width\nd defines the integer format. \n#include&lt;stdio.h>\nvoid main()\n{ int var1= 60;\n int var2= 1234;\n scanf("%2d %5d", &var1, &var2);\n }',
'<i>to read input and print output</i>\n#include &lt;stdio.h>\nint main () {\n char str1[20], str2[30];\n printf("Enter name: ");\n scanf("%s", str1);\n printf("Enter your website name: ");\n scanf("%s", str2);\n printf("Entered Name: %s\", str1);\n printf("Entered Website:%s", str2);\n return(0);\n}',
'<i>reads a line from stdin</i>\n\nchar *gets(char *str);\nstr is a pointer to an array of characters where C strings are stored. ',
'<i>write a string to stdout, but it does not include null characters. A new line character needs to be appended to</i>\nthe output\n\nint puts(const char *str)',
'<i>Format Specifier</i>\n%d: Integer, %f: Float, %c: Character, %s: String,\n%u: Unsigned Integer, %ld: Long Int, %d: integer values\nprintf("%d",&lt;variable name>);',
'<i>Identifiers are names given to entities such as constants, variables, structures, functions etc.</i>\n\nint amount;\ndouble totalbalance;\namount and totalbalance are identifiers and int, and double are keywords.',
'<i>Naming Identifiers Rules</i>\n\nAn identifier can only have alphanumeric characters, letters & digits and underscore( _ ) symbol.\nfirst character must be an alphabet or underscore.\nOnly first thirty-one (31) characters are significant.\nMust not contain white spaces.\nIdentifiers are case-sensitive.',
'<i>defines constants</i>\n\n#include&lt;stdio.h>\nmain()\n{ const int SIDE = 10;\n int area;\n area = SIDE*SIDE;\n  printf("The area of the square with side: %d is: %d sq. units" , SIDE, area);\n }',
'<i>Single Character Constants Escape Sequence</i>\n\n\\a: beep sound \\b: backspace\n\\f: form feed \n: new line \\r: carriage return\n\\t: horizontal tab \\v: vertical tab \\\': single quote\n\\":\ndouble quote \\\: backslash \\0: null',
'<i>Arithmetic Operators</i>\n\n +: Addition;\n -: Subtraction;\n *: Multiplication;\n /: Division;\n %: Modulus',
'<i>to Add Two Numbers</i>\n\n#include &lt;stdio.h>\nvoid main()\n{ int i=3,j=7,k;\n /* Variables Defining and Assign values */ k=i+j;\n  printf("sum of two numbers is %d\\n", k);\n }',
'<i>To use any preprocessor directives</i>\n\nprefix them with pound symbol #',
'<i>Substitutes a preprocessor macro</i>\n\nMacro substitution has a name and replacement text, defined with #define directive.\nThe pound sign means to expand this parameter to the macro text\nThe C preprocessor simply replaces the name of macro with replacement text from the place where the macro is defined\nin the source code.',
'<i>Inserts a particular header from another file.</i>\n\n#include',
'<i>Undefines a preprocessor macro.</i>\n\n#undef',
'<i>Returns true if this macro is defined.</i>\n\n#ifdef',
'<i>Returns true if this macro is not defined.</i>\n\n#ifndef',
'<i>Tests if a compile time condition is true.</i>\n\n#if',
'<i>The alternative for #if.</i>\n\n#else',
'<i>#else and #if in one statement.</i>\n\n#elif',
'<i>Ends preprocessor conditional.</i>\n\n#endif',
'<i>Prints error message on stderr.</i>\n\n#error',
'<i>Issues special commands to the compiler, using a standardized method.</i>\n\n#pragma',
'<i>predefined macros: The current date as a character literal in "MMM DD YYYY" format.</i>\n\n__DATE__',
'<i>predefined macros: The current time as a character literal in "HH:MM:SS" format.</i>\n\n__TIME__',
'<i>predefined macros: This contains the current filename as a string literal.</i>\n\n__FILE__',
'<i>predefined macros: This contains the current line number as a decimal constant.</i>\n\n__LINE__',
'<i>predefined macros: Defined as 1 when the compiler complies with the ANSI standard.</i>\n\n__STDC__',
'<i>Standard Predefined Macros example, __STDC__ Macro:</i>\n\n__STDC__ Macro is used to confirm the compiler standard.\n#include &lt;stdio.h>\nint main()\n{ printf("Compiler Standard Number: %d\\n", __STDC__);\n  return 0;\n }',
'<i>Macro to Get Array Size of Any Data Type</i>\nThe following macro will help you in getting the size of an array of any data type.\nIt works by dividing the length of the array to the size of its field.\n\n<strong>#define NUM_OF(x) (sizeof (x) / sizeof (*x))</strong>\n\n#define num(x) (sizeof (x) / sizeof (*x))\n\nint _tmain(){\n	int number[10] = {1,1,1,1,1,1};\n	char *teststr[20] = {"","","","","","","","",""};\n\n	printf("Size of number[10] is %d\\n", num(number));\n	printf("Size of teststr[20] is %d\\n", num(teststr));\n}\n\nSize of number[10] is 10\nSize of teststr[20] is 20\n\n',
'<i>Calculate Elapsed Time</i>\nFriends, have you ever needed to calculate the time passed between two events?\nOr keep a check on some function which is spuriously taking extra execution time than expected?\n\nHere is the code snippet implemented using a set of macros to help you figure out how long something will take to run.\n\n#include "stdafx.h"\n#include &lt;time.h>\n#include &lt;windows.h>\n#include &lt;stdlib.h>\nclock_t startm, stopm;\n#define BEGIN if ( (startm = clock()) == -1) \\n{ \\nprintf("clock returned error.");exit(1);\n \\n} \\n#define CLOSE if ( (stopm = clock()) == -1) \\n{printf("clock returned error.");\n \\nexit(1);\n \\n} \\n#define SHOWTIME printf( "%6.3f seconds elapsed.", ((double)stopm-startm)/CLOCKS_PER_SEC);\n\nmain() {\n     BEGIN;\n     // Specify set of instructions for you want to measure execution time\n     Sleep(10);\n     CLOSE;\n     SHOWTIME;\n}\n\n',
'<i>Smart Random Number Generator</i>\nWe have this rand() function defined in the <em>stdlib.h</em> for the random number generation.\nDid you use it and realized that every time you run your program, but it returns the same result.\n\nIt\'s because, by default, the standard (pseudo) random number generator gets seeded with the number 1.\nTo have it start anywhere else in the series, call the function srand (unsigned int seed).\n\nFor the seed, you can use the current time in seconds.\n\n#include &lt;time.h>\n\n// At the beginning of main, or at least before you use rand()\nsrand(time(NULL));\n\n<strong>Annexure:</strong>\n\nFor your note, the above code seeds the generator from the current second of time.\nThis fact implies that if you expect your program to re-run more than once a second, the given code may not fulfill your requirement.\nA possible workaround is to store the seed in a file (that you will read later from your program), and you then increment it every time the program is run.\n\n',
'<i>"goes to <code>--></code>" Operator</i>\nthe symbol (<strong>-></strong>) doesn\'t represent an operator.\nIt is a combination of two separate operators, i.e., <code>-- </code>and <code>></code> known as the "<strong>goes to</strong>."\nExample, there is conditional\'s code which decrements variable x, while returning x\'s original (not decremented) value, and then compares it with 0 using the > operator.\n\nint _tmain(){\n	int x = 10;\n 	while( x --> 0 ) // x goes to 0\n	{ printf("%d ", x); }\n	printf("\\n");\n}\n9 8 7 6 5 4 3 2 1 0',
'<i>Some Cool SCANF Tricks</i>\nFind out some of the unheard scanf tricks that you must know.\n\nscanf(“%[^,]”, a);\n // This doesn’t scrap the comma\nscanf(“%[^,],”,a);\n // This one scraps the comma\n\nscanf(“%[^\n]\n”, a);\n // It will read until you meet ‘\n’, then trashes the ‘\n’\n\nscanf(“%*s %s”, last_name);\n // last_name is a variable\n\n',
'<i>Call Functions at Program Termination</i>\nDid you know about the <em>atexit()</em> API?\nThis C API is used to register functions which can get automatically called when the program finishes its execution.\n\n<strong>For example –</strong>\n\n#include &lt;stdio.h>\n#include &lt;stdlib.h>\n\nvoid foo(void)\n{\n    printf("Goodbye Foo!\\n");\n}\n\nvoid bar(void)\n{\n    printf("Goodbye Bar!\\n");\n}\n\nint main(int argc, wchar_t* argv[])\n{\n    atexit(bar);\n    atexit(foo);\n    return 0;\n}\n\nNotice that foo and bar functions haven’t been called but are registered to get called when the program exits.\n\nThese should not return anything nor accept any arguments.\nYou can register up to 32 such functions.\nThey’ll get called in the LIFO order.\n\n',
'<i>Initialize a 2-D Array with a Long List of Values</i>\nIt can be easily achieved by keeping the list values into a file and then store the file content into the 2-D array with the following line of code.\n\ndouble array[SIZE][SIZE] = {\n    #include "float_values.txt"\n}\n\n',
'<i>Add Any Numbers without "+" Operator</i>\nBitwise operators can be used to perform the addition (+) operation as mentioned in below example:\nint Add(int x, int y)\n{\n	if (y == 0)\n		return x;\n	else\n		return Add( x ^ y, (x & y) &lt;&lt; 1);\n}',
'<i>Swapping Two Variables without Any Temp Variable</i>\nThere are three ways to do this.\nTo swap two variables without using additional space or arithmetic operators, simply use the xor operator.\na = a ^ b;\nb = a ^ b;\na = a ^ b;\n// OR\na = a + b –(b=a);\n// OR\na ^= b ^= a ^= b;',
'<i>Put the Constant As the First Term While Making Comparisons</i>\nSometimes, we tend to confuse "=" operator with "==" operator.\nTo avoid this, use the defensive programming approach.\n0==x instead of x==0 so that 0=x can be caught by\n\nIt means you should write "1==x" instead of "x==1" so that the compiler will always flag an error for the miswritten "1=x".\n\nSo whenever you mistakenly write the following.\n\nif ( 1 = x )\n\nThe compiler will complain and refuse to compile the program.\n\nWhile it\'s not possible if you are comparing two variables.\nFor example, the expression\n\nif (x == y)\n\ncan be miss written as\n\nif(x = y)\n\n',
'<i>Quick Commenting</i>\nTo comment blocks of code which have comments within them.\nC does not allow nested comments, the */ comment end is prematurely terminating your comment block.\n\nYou can utilize the C Preprocessor\'s #if directive to circumvent this:\n#if 0\n    /* This code here is the stuff we want commented */\n    if (a != 0) {\n      b = 0;\n    }\n#endif',
'<i>Use of Conditional Operator</i>\nThe Conditional operator is also known as the Ternary operator.\nx = (y &lt; 0) ? 10 : 20;\nBut in C++, you can also use it in the following manner:\n(c &lt; 0 ? a : b) = 1;\n// If c &lt; 0 then a = 1\n// If c > 0 then b = 1',
'<i>Arrays and Pointers not Entirely the Same</i>\nMany of us tend to misunderstand a concept that pointers and arrays are the same.\nThey are not.\n\nPointers are merely variables holding the address of some location whereas an array is a contiguous sequence of memory locations.\n\nPointers can help to create heterogeneous data structures such as a link list or hash table.\nWhereas the arrays are homogenous which can hold only values of similar type such as numbers and strings.\n\nPointers get allocated dynamically on the heap whereas the arrays are static allocations on the stack.\n\nAt compile time, an array is an array.\nOnly during run-time, an array devolves to a pointer.\n\nTo prove this fact, let me show you an example.\n\nint a[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\nint *b = a;\n\nprintf("%d\\n%d\\n", sizeof(a), sizeof(b));\n\nAnd the output is (assuming size of int is 4 bytes and address size is 8 bytes) –\n40\n8\n\n',
'<i>Pointer to array and Array of Pointers.</i>\nLet\'s check out an interesting comparison between the following three declarations.\n\nint *ptr1[5];\nint (*ptr2)[5];\nint* (ptr3[5])\n\nint *ptr1[5];\n\nHere in int *ptr1[5], ptr1 is an array of 5 integer pointers (An array of int pointers).\n\nint (*ptr2)[5];\n\nAnd in int (*ptr2)[5], ptr2 is a pointer to an array of 5 integers (A pointer to an array of integers).\n\nint* (ptr3[5]);\n\nIt\'s same as ptr1 (An array of int pointers).\n\n',
'<i>Log off computer Using C.</i>\n#include &lt;windows.h>\n\nint main(){\n   system("shutdown -l -f -t 00");\n}\n\n',
'<i>Maintain good posture when you’re programming</i>\nSomeone in your early life probably drilled into you the importance of having proper posture.\nIgnore them at your own peril, especially when you’re young and haven’t yet gotten out of bed to say, “Ouch.”\nFor many programmers, coding becomes an obsession.\nFor most C programmers, it’s quite easy to sit and write code for many hours straight.\nSuch a stationary position is hard on the body.\nSo, every few minutes, take a break.\nIf you can’t manage that, schedule a break.\nSeriously: The next time you compile, stand up! Look outside! Walk around a bit!\nWhile you’re working, try as hard as you can to keep your shoulders back and your wrists elevated.\nDon’t crook your neck when you look at the monitor.\nDon’t hunch over the keyboard.\nLook out a window to change your focus.\n\nRemember that it’s pleasant to acknowledge others.\nTrue, it’s easy to grunt or snarl at someone when you’re in the midst of a project.\nKeep in mind that other humans may not appreciate the depth of thought and elation you feel when you code.\nIf you can’t be pleasant now, apologize later.\n\n',
'<i>Use creative names in C programs</i>\nThe best code reads like a human language.\nFor small snippets having appropriate variable and function names is a boon to writing clear code.\nThe following expression is a favorite:\nwhile(!done)\nYou can read this statement as “while not done.” It makes sense.\nUntil the value of the <code>done</code>variable is TRUE, the loop spins.\nBut somewhere inside the loop, when the exit condition is met, the value of <code>done</code> is set equal to TRUE and the loop stops.\nA name such as <em>setringervolume()</em> is great, but the name <em>set_ringer_volume()</em> is better.\nFor example: ch=read_next_character();\nThe function <em>read_next_character()</em> needs no explanation.',
'<i>Write a function in C</i>\nAnytime you use code more than once, consider throwing it off into a function, even if the code is only one line long or appears in several spots and doesn’t really seem function-worthy.\nSuppose that you use the <em>fgets()</em> function to read a string, but then you follow <em>fgets()</em> with another function that removes the final newline character from the input buffer.\nWhy not make both items their own function, something like <em>get_input()?</em>\n\n',
'<i>Work on your C code a little bit at a time</i>\nA majority of the time you spend coding is to fix problems, to correct flaws in logic, or to fine-tune.\nWhen making such adjustments, avoid the temptation to make three or four changes at one time.\nAddress issues one at a time.\nThe reason for the admonition is that it’s tempting to hop around your code and work on several things at a time.\nFor example: You need to fix the spacing in a <em>printf()</em> statement’s output, adjust a loop, and set a new maximum value.\nDo those things one at a time!\nWhen you attempt to do several things at a time, you can screw up.\nBut which thing did you goof up? You have to go back and check everything, including the related statements and functions, to ensure they work.\nDuring situations like these, you will seriously wish for a time machine.\nInstead, just work on your code a little bit at a time.\n\n',
'<i>Break apart larger C projects into several modules</i>\nNo one likes to scroll through 500 lines of code.\nUnless you’re totally immersed in your project and can keep everything stored in your noggin, break out functions into modules.\nMany C programmers prefer to group related functions into similar files.\nC programmers typically have an output file, an input file, an initialization file, and so on.\nEach file, or <em>module,</em> is compiled and linked separately to form the code.\nThe benefits are that the files are smaller and if they compile and work, you no longer need to mess with them.\n\n',
'<i>Know what a pointer is in C</i>\nA <em>pointer</em> is a variable that stores a memory location.\nIt’s not magic, and it shouldn’t be confusing, as long as you keep the basic mantra in your head:\n<em>A pointer is a variable that stores a memory location.</em>\nA memory location stored in a pointer references another variable or a buffer (like an array).\nTherefore, the pointer must be initialized before it’s used:\n<em>A pointer must be initialized before it’s used.</em>\nWhen the pointer variable in C is prefixed by the <code>*</code>(asterisk) operator, it references the contents of the variable at the memory location.\nThis duality is weird, of course, but it’s highly useful.\n\nDeclare a pointer variable by using the *\nUse the & operator to grab the address of any variable in C.\nArrays are automatically referenced by their memory locations, so you can use an array name without the & prefix to grab its address.\n“Address” and “memory location” are the same thing.\n\nA great way to explore pointers is to use the Code::Blocks debugger;\n specifically, the Watches window.\n\n',
'<i>Add white space before condensing your C code</i>\nC programmers love to bunch up statements, cramming as many of them as they can into a single line, such as\nwhile(putchar(*(sample++)))\nIt can also be a source of woe.\nif( c != \'\0\' ) is easier to read than the line: if(c!=\'\0\')\nIn C language source code, white space is for the benefit of human eyes.',
'<i>Know when if-else becomes switch-case</i>\nMany C programmers are big fans of the <em>if-else decision tree</em>, but they generally avoid stacking up multiple <em>if</em> statements.\nIt usually means that the programming logic is flawed.\nFor example:\n\nif(something)\n    ;\nelse if(something_else)\n    ;\nelse(finally)\n    ;\n\nThis structure is okay, and it’s often necessary to deal with a 3-part decision.\nBut the following structure, which has been built by many budding C programmers, probably isn’t the best way to code a decision tree:\n\nif(something)\n    ;\nelse if(something_else_1)\n    ;\nelse if(something_else_2)\n    ;\nelse if(something_else_3)\n    ;\nelse if(something_else_4)\n    ;\nelse(finally)\n    ;\n\nGenerally speaking, anytime you have that many <em>else-if</em> statements, you probably need to employ the <em>switch-case</em> structure instead.\nIn fact this example is probably what inspired the <em>switch-case</em> structure in the first place.\n\n',
'<i>assignment operators in the C language</i>\none handy tool in the C language is an assignment operator.\nIn C, you can abbreviate a = a + n;\nby using an assignment operator:\na += n;\n\nThe += operator goes before the equal sign.\nIf it went afterward, it might change into a unary operator, which looks weird: a =+ n;\nSo the value of variable <code>a</code> equals positive <code>n</code><em>?</em>\n\nincrement and decrement operators, <code>++</code> and <code>--</code> are quite popular in loops.',
'<i>When you get stuck, read your code out loud</i>\nTo help you track down that bug, start reading your code aloud.\nPretend that a programmer friend is sitting right next to you.\nExplain what your code is doing and how it works.\nAs you talk through your code, you’ll find the problem.\nIf you don’t, have your imaginary friend ask you questions during your explanation.\nDon’t worry about going mental.\nYou’re a C programmer.\nYou’re already mental.\nAs a bonus, talking through your code also helps you identify which portions need to have comments and what the comments should be.\nFor example:\n\na++;\n      /* increment a */\n\nIn the preceding line, you see a terrible example of a comment.\nDuh.\nOf course, <code>a</code> is incremented.\nHere’s a better version of that comment:\n\na++;\n      /* skip the next item to align output */\n\nDon’t just comment on what the code is doing — comment on <em>why.</em> Again, pretend that you’re explaining your code to another programmer — or to future-you.\nFuture-you will thank present-you for the effort.\n',
'<i>Function pointers</i>\nSometimes it is useful to store a function in a variable.\nThis isn’t a technique that is normally used in day-to-day programming, but it can be used to increase the modularity of a program by, for example, storing the function to be used in handling an event in the event’s data (or control) structure.\n\nThe key here is to define a type, “pointer-to function-returning-something” and then use that as a variable declaration-it makes the code a lot easier to read.\nLet’s consider a simple example.\nFirst I define a type PFC, which is a Pointer to a Function returning a Character:\n\ntypedef char (*PFC)();\n\nThis is then used to create a variable z:\n\nPFC z;\n\nI define a function a():\n\nchar a() {\n      return \'a\';\n}\n\nThe address of this function is then stored in z:\n\nz = a;\n\nNote that you don’t need the & (“address-of”) operator here;\n the compiler knows that a must be the address of a function.\nThis is because there are only two things you can do with a function: 1) call it, or 2) take its address.\nSince the function isn’t called (there are no parentheses after a in the assignment above), the only option is to use the address of the function, which is then stored in the variable z.\n\nTo call the function whose address is in z, just add the parentheses:\n\nprintf("I am %c\\n", z());\n\n',
'<i>Variable-length argument lists</i>\nNormally you declare a function to take a fixed number of arguments.\nBut it is also possible to define functions capable of taking variable numbers of arguments.\nThe standard C function printf() is a function of this sort.\nYou can put almost any number of integers, floats, doubles, and strings in the format specifier part (after the string argument), and the printf() function will figure out what to do with them.\nJust like printf(), you can declare your own functions that contain a variable number of arguments.\n\nHere is an example:\n\nint vararg(int arg_count, ...) {}\n\nThe first argument here, arg_count, is an integer that gives the actual number of arguments that follow it in the “variable” argument list, which is shown by the three dots.\n\nThere are a few built-in functions or macros that deal with variable arguments: va_list, va_start,va_arg, and va_end (these are defined in the stdarg.h header file).\n\nFirst, you need to declare a pointer to the variable arguments:\n\nva_list argp;\n\nNext, set this argp variable to the first argument in the variable part.\nThis is the argument after the last fixed argument;\n here arg_count:\n\nva_start(argp, arg_count);\n\nThen we can extract each variable argument one at a time from the variable part using va_arg:\n\nfor (i = 0;\n i &lt;\n arg_count;\n i++) {\n      j = va_arg(argp, int);\n      t += j;\n}\n\nNote that you need to know in advance the type of the argument being retrieved (here it’s a simpleint) and the number of arguments (here, given by the fixed argument arg_count).\n\nFinally, you need to tidy up by calling va_end:\n\nva_end(argp);\n\n',
'<i>Testing and setting individual bits</i>\n“Bit-twiddling”, or manipulating the individual bits of items such as integers, is sometimes considered to be a dark art used by advanced programmers.\nIt’s true that setting individual bit values can seem a rather obscure procedure.\nBut it can be useful, and it is a technique that is well worth knowing.\n\nLet’s first discuss why you would want to do this.\nPrograms often use “flag” variables to hold Boolean values (that is, true or false).\nSo you might have a number of variables like these:\n\nint moving;\nint decelerating;\nint accelerating;\n\nIf these are related in some way, as the ones above are (they all define the state of some action related to movement), then it’s often more convenient to store all the information in a single “state variable” and use a single bit in that variable for each possible state, like this:\n\n#define MOVING (1 &lt;&lt;\n 1)\n#define DECELERATING (1 &lt;&lt;\n 2)\n#define ACCELERATING (1 &lt;&lt;\n 3)\nint state;\n\nThen you can use bit-setting operations to set or clear an individual bit:\n\nstate |= MOVING;\nstate &= ~MOVING;\n\nThe advantage is that all the state information is stored in one place and it’s clear that you are operating on a single logical entity.\n\nThe code archive contains an example that shows how to set, clear, and test a single bit in a integer.\nIf you don’t understand exactly what is going on here, don’t worry.\nThe best way to think of these are as standard “incantations.”\n\nTo set a given bit in an int called value (in the range 0 to 31), use this expression:\n\nvalue |= 1 &lt;&lt;\n bit\n\nTo clear a given bit, use this:\n\nvalue &= ~(1 &lt;&lt;\n bit);\n\nAnd to test if a bit is zero or one, use this:\n\nr = value & (1 &lt;&lt;\n bit);\n\n',
'<i>Short circuit operators</i>\nC’s logical operators, && (“and”) and || (“or”), let you chain together conditions when you want to take some action only when all of a set of conditions are true (&&) or when any one set of conditions is true (||).\nBut C also provides the & and | operators.\nAnd it is vital that you understand the difference in how these work.\nIn brief, the double-character operators (&& and ||) are called “short-circuit” operators.\nWhen used between two expressions, the second expression is only evaluated when the first expression is found to be true;\n otherwise it is skipped.\nLet’s look at an example to clarify this:\n\nFILE *f = 0;\n\nint short_circuit_ok() {\n      int t;\n\n      t = (int)f && feof(f);\n      return t;\n}\n\nThe test (int)f && feof(f) is intended to return a true value when the end of the file f is reached.\nThis test evaluates f first;\n and this will be zero (a false value) if the file has not been opened.\nThis is an error, so trying to read to the end of the file is not possible.\nHowever, since the first part of the test fails, the second part will not be evaluated, so no attempt is made on feof() .\nThis shows the correct use of a short circuit operator to test if a file had been opened before an operation on the file is tried.\nBut, see this code:\n\nint short_circuit_bad() {\n      int t;\n      t = (int)f & feof(f);\n      return t;\n}\n\nHere, the test uses the & operator instead of &&.\nThe & operator is an instruction to evaluate both expressions in all circumstances.\nSo, even if the first part of the test fails (as the file hasn’t been opened), the second part will be evaluated (to test for the end of the file).\nThis could be disastrous and might cause a segmentation fault (or similar) because there is no control over the order of evaluation.\n\nIn fact, the way in which these expressions are evaluated is, to some extent, dependent on the compiler and optimizer.\nSo, it is possible that some compilers might be smart enough to realize that this code can never succeed and therefore might not evaluate both parts of the test.\nMany compilers are not this smart, however;\n so a test of this sort in a C program, where the evaluation of one part is dependent on the other to be true, is a very bad idea!\n\n',
'<i>Ternary operators</i>\nA ternary operation is one that takes three arguments.\nIn C the ternary operator (?<br />\ncan be used as a shorthand way of performing if..else tests.\nThe syntax can be expressed like this:\n\n&lt;\n Test expression > ? &lt;\n If true, execute this code> : &lt;\n else execute this code >\n\nFor example, given two int variables, t and items I could use if..else to test the value of items and assign its value to t like this:\n\nif (items > 0) {\n      t = items;\n} else {\n      t = -items;\n}\n\nUsing the ternary operator, I could rewrite that entire code in a single line, like this:\n\nt = items > 0 ? items : -items;\n\n<img src="https://hownot2code.files.wordpress.com/2016/11/2-3.png">\n\n<i>If you aren’t used to them, ternary operators may look a bit odd, but they can shorten and simplify your code.</i>\n\nHere’s another example.\nThis code displays the first string when there is a single item and the second string when there are multiple items:\n\nif (items == 1) {\n      printf("there is %d item\\n", t);\n} else {\n      printf("there are %d items\\n", t);\n}\n\nThis can be rewritten as follows:\n\nprintf("there %s %d item%s", t == 1 ? "is" : "are", t, t == 1 ? "\\n" : "s\\n");\n\n',
'<i>Stacks &#8211;\n pushing and popping</i>\nA “stack” is a last-in, first-out storage system.\nYou can use address arithmetic to add elements to a stack (pushing) or remove elements from the stack (popping).\nWhen programmers refer to “the stack”, they typically mean the structure that is used by the C compiler to store local variables declared inside a function.\nBut, in fact, a stack is a generic type of data structure that you can create and use in your own code, which is what I discuss here.\n\nThe code below defines a very small stack: an array _stack of 2 integers.\nRemember, when testing, it is always better to use small numbers of items rather than large numbers.\nIf your code contains errors, these will be easier to spot in an array of two items rather than in array of 100 items.\nI also declare a stack pointer _sp and set it to the base (the address) of the _stack array:\n\n#define STACK_SIZE 2\nstatic int _stack[STACK_SIZE];\nstatic int* _sp = _stack;\n\nI now define the push() function, which pushes an integer onto the stack, just as you might add a plate onto a stack of plates.\nIt returns the new number of items on the stack, or -1 if the stack is full:\n\nint push(int value) {\n      int count;count = _sp - _stack;\n      if (count >= STACK_SIZE) {\n            count = -1;\n      } else {\n            *_sp++ = value;\n            count += 1;\n      }\n      return count;\n}\n\nIn order to get an item from the stack, I need a pop() function.\nRemember a stack is a last-in, first-out structure.\nIf I have stacked up ten plates to be washed, I pull the first plate off the top of the stack (which was the last plate I put on the stack), wash it, and then take off the next plate (the last-but-one plate that I put on the stack) and so on.\nMy pop() function does this with the elements stored in my_stack data structure.\nIt returns the new number of items on the stack, or -1 if it is empty:\n\nint pop(int* value) {\n      int count;\n count = _sp - _stack;\n      if (count == 0) {\n            count = -1;\n      } else {\n            *value = *--_sp;\n      count -= 1;\n      }\n      return count;\n}\n\nAnd here is some code showing how to push and pop items onto and off the stack:\n\nvoid test_stack() {\n      int i, r, v;\n      for (i = 0;\n i &lt;\n 4;\n i++) {\n            v = i + 10;\n            r = push(v);\n            printf("push returned %d;\n v was %d\\n", r, v);\n      }\n      for (i = 0;\n i &lt;\n 4;\n i++) {\n            v = 0;\n            r = pop(&v);\n            printf("pop returned %d;\n v was %d\\n", r, v);\n      }\n}\n\nStacks are handy, temporary storage structures.\nIt’s worth getting to know them!\n\n',
'<i>Copying data</i>\nHere are three ways of copying data.\nThe first uses the standard C function, memcpy(), which copies n bytes from the src to the dst buffer:\n\nvoid copy1(void *src, void *dst, int n) {\n      memcpy(dst, src, n);\n}\n\nNow let’s look at a do-it-yourself alternative to memcpy().\nThis could be useful if you wanted to do some more processing or checking of the copied data:\n\nvoid copy2(void *src, void *dst, int n) {\n	int i;\n	char *p, *q;for (i = 0, p = src, q = dst;\n i &lt;\n n;\n i++) {\n		*p++ = *q++;\n	}\n}\n\nAnd finally, here is a function that uses 32-bit integers to achieve faster copying.\nBear in mind that this may not be faster than the compiler can achieve if it makes optimizations that are particular to the machine architecture.\nHowever, it can be useful in a microcontroller where speed is often very important.\nIn this particular example, the code assumes that the data count n is a multiple of 4 since it is dealing with 4-byte integers:\n\nvoid copy3(void *src, void *dst, int n) {\n	int i;\n	int *p, *q;\n        for (i = 0, p = (int*)src, q = (int*)dst;\n i &lt;\n n / 4;\n i++) {\n	        *p++ = *q++;\n	}\n}\n\nYou can find some examples of copying strings using these three functions in the code archive.\n\n',
'<i>Testing for header inclusion</i>\nC uses “header” (“.h”) files that may contain declarations of functions and constants.\nA header file may be included in a C code file by importing it using its name between angle brackets when it is one of the headers supplied with your compiler (#include &lt;\n string.h >) or between double-quotes when it is a header that you have written: (#include “mystring.h”).\nBut in a complex program containing many source code files, there is the danger that you may include the same header file more than once.\n\n<img src="https://hownot2code.files.wordpress.com/2016/11/3-3.png">\n\nSuppose we have a simple header file, <strong>header1.h</strong>, that contains the following definitions:\n\ntypedef int T;\ntypedef float F;\nconst int T_SIZE = sizeof(T);\n\nThen we make another header <strong>(header2.h)</strong> that contains this:\n\n#include "header1.h"\ntypedef struct {\n	T t;\n	F f;\n} U;\nconst int U_SIZE = sizeof(U);\n\nNow, if in our main program, main.c, we have this:\n\n#include "header1.h"\n#include "header2.h"\n\nWhen we compile the program, we will get a compilation error, because T_SIZE will be declared twice (because its definition in <strong>header1</strong> is included in two different files).\nWe have to include <strong>header1</strong> in <strong>header2</strong> in order to get <strong>header2</strong> to compile in circumstances where we don’t use <strong>header1</strong>.\nSo, how can we fix this problem? The way around this is to define a “guard” macro that encloses all of the definitions in a header file, so that <strong>header1</strong> becomes:\n\n#ifndef HEADER1_H\n#define HEADER1_H\ntypedef int T;\ntypedef float F;\nconst int T_SIZE = sizeof(T);\n#endif\n\nThis sort of problem is so common that many IDEs such as NetBeans will do this for you when you create a new header.\nIf you create the header file yourself, however, you need to do this explicitly.\nTo avoid this sort of error, you must make sure that all your header definitions are within the “guard” #ifdef.\n\n',
'<i>Parentheses - to use or not to use?</i>\nA competent and experienced C programmer will neither overuse nor underuse parentheses-the round bracket delimiters “(” and “)”.\nBut what exactly is the correct way to use parentheses?\n\nThere are a number of simple rules:\n1) To change the normal operator precedence.\nFor example, 3 * (4 + 3) is not the same as 3 * 4 + 3 .\n\n2) To make things clearer.\nIt isn’t absolutely necessary to use parentheses here:\n\nt = items > 0 ? items : -items;\n\nThat’s because the operator precedence of || is lower than &lt;\n and >.\nHowever, you might find it clearer to write this:\n\n(x > 0) || (x &lt;\n 100 & y > 10) || (y &lt;\n 0)\n\nUsing parentheses for clarity is useful because not many people can correctly list all the C operator priorities.\n\n3) In a macro expression.\nIt is a good idea to add parentheses when defining a constant like this:\n\n#define MYCONST (4 + 3)\n\nThat’s because you don’t know where this constant might be used.\nIn the example above, if there were no parentheses, you may not get what you expect.\nConsider this:\n\n3 * MYCONST\n\nThe resulting value would be different (due to the effects of operator precedence) if you omitted the parentheses in the constant declaration.\n\nBut there’s one place where you don’t need to use parentheses: in a return statement.\nFor example, this…\n\nreturn (x + y);\n\n…has exactly the same effect as\n\nreturn x + y;\n\nMany programmers make a habit of using unnecessary parentheses in return statements.\nThis may be because they are used to placing expressions between parentheses in other control statements such as if, while, for, and do.\nAll of those statements require parentheses.\nBut a return statement does not.\n\n',
'<i>Arrays as addresses</i>\nProgrammers who come to C from another language frequently get confused when C treats an array as an address and vice versa.\nAfter all, isn’t an array supposed to be some sort of container with a fixed number of slots, each of which holds a single item? An address is just a number indicating a memory location;\n so an array and an address are very different things, right?\n\nWell, no, not right, as it turns out.\n\nC is correct: <i>an array is just the base address of a block of memory</i>, and the array notation you may have come across when learning a language, such as Java or JavaScript, is merely syntactic sugar.<br />\nLook carefully at the following code:\n\nstatic int _x[4];\n\ntest_array_as_address() {\n	int i;\n\n	for (i = 0;\n i &lt;\n 4;\n i++) {\n		_x[i] = (int) (_x + i);\n	}\n\n	for (i = 0;\n i &lt;\n 4;\n i++) {\n		printf("%x:%x:%x\\n", _x + i, _x[i], *(_x + i));\n	}\n\n}\n\nHere, the first for loop copies the address of each individual array element into the array itself:\n\n_x[i] = (int) (_x + i);\n\nAt each turn through the loop, the address is incremented by the value of i.\nSo the address of the array variable _x will be the first element (since i is 0 at the first turn through the loop), and each subsequent address will be the address of _x plus 1.\nWhen we add 1 to the array’s address, the C compiler calculates the appropriate offset to the next array element according to the data-type of the array (here, that’s 4 bytes for an array of integers).\n\nThe second for loop prints the values stored in the array, first printing the address of the element _x + i, then the value of the element using normal array indexing _x[i], and finally the contents of the array using pointer/address notation (where the * operator returns the contents of the address placed in parentheses): *(_x + i).\nIn all cases, the three values are the same.\nThis shows that the array and its address are the same thing, and each element in the array has an address given by the address of the array, plus the number of bytes needed to store an element.\n\nIncidentally, note that you don’t need to use the & operator to get the address of the array, because, to the compiler, the array is an address.\n\n',

];

bookid = "C Tips"
</script>

<script src='https://williamkpchan.github.io/showTips.js'></script>
<!--script src='../showTips.js'></script-->


</body>
</html>