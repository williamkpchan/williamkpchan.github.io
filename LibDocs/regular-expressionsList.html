<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style>
#toc {
  margin-left: 12%;
  margin-right: 12%;
  color: gold;
  padding: 1%;
  text-align: left;
  box-shadow: 5px 5px 15px silver;
  border-radius: 5px;
  border: 1px solid DarkSlateGray;
  font-size: 18px;
}
body {
 margin: 5%;
 font-size: 24px;
 background-color: #000000;
 color: #40C060;
}
div#top {
	background-color: #A03300;
	background-image: url(img/header100.png);
	background-position: top center;
	background-repeat: repeat-x;
	background-size: 2160px 108px;
	margin: 0;
	height: 108px;
	width: 100%;
}

#btntop {
	background-color: #E0E0E0;
	width: 100%;
	height: 20px;
	border-top: 1px solid #001030;
	border-bottom: 1px solid #001030;
}
#btntop div {
	width: 143px;
	height: 20px;
	text-align: center;
	background-color: #A03300;
	border-left: 1px solid #001030;
}
#btntop table {
	border-right: 1px solid #001030;
}
#btntop a {
	text-decoration: none;
	background: none;
	font-size: 24px;
	font-weight: normal;
}
#btntop a:link, #btntop a:visited, #btntop a:hover, #btntop a:active {
	color: green; 
}
div.topad {
	margin: 20px 10px 30px 10px;
}
div#bodytext {
	position: absolute;
	left: 260px;
}
div#copyright {
	margin: 30px 5px 10px 10px;
	padding-top: 2px;
	border-top: groove #C0C0C0 2px;
}
p {
	font-size: 24px;
	font-weight: normal;
	text-align: left;
	margin: 10px;
}
ul {
	font-size: 24px;
	font-weight: normal;
	margin-left: 24px;
	margin-right: 10px;
	padding-left: 0;
}
ul.noindent {
	margin-left: 10px;
}
ul li {
	list-style-position: inside;
}
ol {
	font-size: 24px;
	font-weight: normal;
	margin-left: 50px;
	margin-right: 10px;
	padding-left: 0;
}
input {
	font-size: 24px;
	font-weight: normal;
}
select {
	font-size: 24px;
	font-weight: normal;
}
textarea {
	font-family: 'Andale Mono', 'Lucida Console', monospace;
	font-size: 24px;
	font-weight: normal;
}
table.body {
	margin: 10px;
}
th, td {
	font-size: 24px;
}
td.small {
	font-size: 24px;
}
td.yes {
	background-color: #E0FFE0;
	white-space: nowrap;
}
td.fail {
	background-color: #FFF4E8;
	white-space: nowrap;
}
table.reference {
	margin: 10px;
	border-collapse: collapse;
  	border: solid black 2px;
}
table.reference th {
	border-right: solid black 1px;
	border-bottom: solid black 1px;
	padding: 4px;
}
table.reference td {
	border-right: solid black 1px;
	border-bottom: solid black 1px;
	padding: 4px;
}
table.sidead td {
	font-size: 24px;
	text-align: justify;
	padding-left: 8px;
	padding-right: 10px;
}
h1 {
	font-size: 20px;
	font-weight: bold;
	font-variant: normal;
	color: gold;
	margin: 20px 10px 10px 10px;
	border-bottom: solid gold 1px;
	padding-bottom: 3px;
}
h2 {
	font-size: 20px;
	font-weight: bold;
	font-variant: normal;
	color: gold;
	margin: 40px 10px 10px 10px;
	border-bottom: solid gold 1px;
	padding-bottom: 3px;
}
#bodytext div.adsense {
	margin-left: 10px;
	margin-top: 30px;
}
#bodytext script+div.adsense {
	margin-top: 20px;
}
div.adsense+h1 {
	margin-top: 30px;
}
div.adsense+h2 {
	margin-top: 30px;
}
div#side {
	position: absolute;
}
table.side {
	border-style: solid;
	border-width: 2px;
	border-color: #803300;
	margin: 20px 5px 20px 10px;
}
table.sidead {
	background-color: #FFF4E8;
	border-style: solid;
	border-width: 2px;
	border-color: #803300;
	margin: 20px 5px 20px 10px;
}
td.sideheader {
	background-color: #FF6600;
	color: green;
	text-align: center;
	height: 28px;
}

div.amzn-native-container {
	margin: 20px 10px -10px 10px;
}
a:link { 
  font-size: 18px;
	color: green;
	text-decoration: none;
} 
a:visited { 
	color: #000080;
} 
a:hover {
	color: green;
	background: #0000FF;
} 
a:active {
	color: green;
	background: #FF0000;
}
a:hover.img, a:active.img {
	background: none;
}
tt {
	font-family: 'Andale Mono', 'Lucida Console', monospace;
}
tt.match, tt.string {
	white-space: nowrap;
	padding-top: 1px;
	padding-bottom: 1px;
}
tt.match {
	background-color: #C0E0FF;
}
tt.string {
	background-color: #001818;
}
tt.code {
	white-space: nowrap;
}
tt span {
	padding-top: 1px;
	padding-bottom: 1px;
}
pre {
	font-family: 'Andale Mono', 'Lucida Console', monospace;
	font-size: 24px;
	font-weight: normal;
	margin: 10px;
}
p.indent {
	margin-left: 30px;
}
p.copyright {
	font-size: 24px;
	font-weight: normal;
	margin: 0;
}
img.left {
	margin: 5px 10px 5px 0;
}
img.right {
	margin: 5px 0 5px 10px;
}
img.iconleft {
	margin: 0 10px 0 0;
}
img.side {
	margin: 20px 5px 0 10px;
}
form {
	margin: 0;
	padding: 0;
}
.characterstring { color: #0000FF; }
.comment { color: #FF0000; font-style: italic; }
.numericconstant { color: #000080; }
.reservedword { font-weight: bold; }
.longcode {
	font-size: 24px;
}
tt.regexbuddy {
	margin-left: 10px;
}
div.regexbuddyregex { 
        margin-top: 10pt; 
        margin-bottom: 10pt; 
}
div.regexbuddytree { 
        margin-top: 10pt; 
        margin-bottom: 10pt; 
        overflow-y: scroll; 
        height: 200%; 
}
div.regexbuddyfooter { 
        margin-top: 10pt; 
        margin-bottom: 10pt; 
}
ul.buddy {
	padding-left: 0;
}
li.char { background-image: url(http://www.regexbuddy.com/manual/btn/char.png); list-style-type: none; padding-left: 24px; background-size: 16px; background-repeat: no-repeat; }
li.string { background-image: url(http://www.regexbuddy.com/manual/btn/string.png); list-style-type: none; padding-left: 24px; background-size: 16px; background-repeat: no-repeat; }
li.escaped { background-image: url(http://www.regexbuddy.com/manual/btn/escaped.png); list-style-type: none; padding-left: 24px; background-size: 16px; background-repeat: no-repeat; }
li.special { background-image: url(http://www.regexbuddy.com/manual/btn/special.png); list-style-type: none; padding-left: 24px; background-size: 16px; background-repeat: no-repeat; }
li.meta { background-image: url(http://www.regexbuddy.com/manual/btn/meta.png); list-style-type: none; padding-left: 24px; background-size: 16px; background-repeat: no-repeat; }
li.option { background-image: url(http://www.regexbuddy.com/manual/btn/option.png); list-style-type: none; padding-left: 24px; background-size: 16px; background-repeat: no-repeat; }
li.optiongroup { background-image: url(http://www.regexbuddy.com/manual/btn/optiongroup.png); list-style-type: none; padding-left: 24px; background-size: 16px; background-repeat: no-repeat; }
li.anchor { background-image: url(http://www.regexbuddy.com/manual/btn/anchor.png); list-style-type: none; padding-left: 24px; background-size: 16px; background-repeat: no-repeat; }
li.repeat { background-image: url(http://www.regexbuddy.com/manual/btn/repeat.png); list-style-type: none; padding-left: 24px; background-size: 16px; background-repeat: no-repeat; }
li.backreference { background-image: url(http://www.regexbuddy.com/manual/btn/backreference.png); list-style-type: none; padding-left: 24px; background-size: 16px; background-repeat: no-repeat; }
li.call { background-image: url(http://www.regexbuddy.com/manual/btn/call.png); list-style-type: none; padding-left: 24px; background-size: 16px; background-repeat: no-repeat; }
li.void { background-image: url(http://www.regexbuddy.com/manual/btn/void.png); list-style-type: none; padding-left: 24px; background-size: 16px; background-repeat: no-repeat; }
li.fail { background-image: url(http://www.regexbuddy.com/manual/btn/fail.png); list-style-type: none; padding-left: 24px; background-size: 16px; background-repeat: no-repeat; }
li.group { background-image: url(http://www.regexbuddy.com/manual/btn/group.png); list-style-type: none; padding-left: 24px; background-size: 16px; background-repeat: no-repeat; }
li.capture { background-image: url(http://www.regexbuddy.com/manual/btn/capture.png); list-style-type: none; padding-left: 24px; background-size: 16px; background-repeat: no-repeat; }
li.atomic { background-image: url(http://www.regexbuddy.com/manual/btn/atomic.png); list-style-type: none; padding-left: 24px; background-size: 16px; background-repeat: no-repeat; }
li.lookaround { background-image: url(http://www.regexbuddy.com/manual/btn/lookaround.png); list-style-type: none; padding-left: 24px; background-size: 16px; background-repeat: no-repeat; }
li.conditional { background-image: url(http://www.regexbuddy.com/manual/btn/conditional.png); list-style-type: none; padding-left: 24px; background-size: 16px; background-repeat: no-repeat; }
li.alternate { background-image: url(http://www.regexbuddy.com/manual/btn/alternate.png); list-style-type: none; padding-left: 24px; background-size: 16px; background-repeat: no-repeat; }
li.error { background-image: url(http://www.regexbuddy.com/manual/btn/error.png); list-style-type: none; padding-left: 24px; background-size: 16px; background-repeat: no-repeat; }
li.comment { background-image: url(http://www.regexbuddy.com/manual/btn/comment.png); list-style-type: none; padding-left: 24px; background-size: 16px; background-repeat: no-repeat; }
li.tip { background-image: url(http://www.regexbuddy.com/manual/btn/tip.png); list-style-type: none; padding-left: 24px; background-size: 16px; background-repeat: no-repeat; }
li.comparesame { background-image: url(http://www.regexbuddy.com/manual/btn/comparesame.png); list-style-type: none; padding-left: 24px; background-size: 16px; background-repeat: no-repeat; }
li.comparediff { background-image: url(http://www.regexbuddy.com/manual/btn/comparediff.png); list-style-type: none; padding-left: 24px; background-size: 16px; background-repeat: no-repeat; }
li.cc { background-image: url(http://www.regexbuddy.com/manual/btn/cc.png); list-style-type: none; padding-left: 24px; background-size: 16px; background-repeat: no-repeat; }
li.ccchar { background-image: url(http://www.regexbuddy.com/manual/btn/ccchar.png); list-style-type: none; padding-left: 24px; background-size: 16px; background-repeat: no-repeat; }
li.ccstring { background-image: url(http://www.regexbuddy.com/manual/btn/ccstring.png); list-style-type: none; padding-left: 24px; background-size: 16px; background-repeat: no-repeat; }
li.ccspecial { background-image: url(http://www.regexbuddy.com/manual/btn/ccspecial.png); list-style-type: none; padding-left: 24px; background-size: 16px; background-repeat: no-repeat; }
li.ccrange { background-image: url(http://www.regexbuddy.com/manual/btn/ccrange.png); list-style-type: none; padding-left: 24px; background-size: 16px; background-repeat: no-repeat; }
li.ccintersect { background-image: url(http://www.regexbuddy.com/manual/btn/ccintersect.png); list-style-type: none; padding-left: 24px; background-size: 16px; background-repeat: no-repeat; }
li.ccvoid { background-image: url(http://www.regexbuddy.com/manual/btn/ccvoid.png); list-style-type: none; padding-left: 24px; background-size: 16px; background-repeat: no-repeat; }
li.ccfail { background-image: url(http://www.regexbuddy.com/manual/btn/ccfail.png); list-style-type: none; padding-left: 24px; background-size: 16px; background-repeat: no-repeat; }
li.lb { background-image: url(http://www.regexbuddy.com/manual/btn/lb.png); list-style-type: none; padding-left: 24px; background-size: 16px; background-repeat: no-repeat; }
li.cclb { background-image: url(http://www.regexbuddy.com/manual/btn/cclb.png); list-style-type: none; padding-left: 24px; background-size: 16px; background-repeat: no-repeat; }
@media screen and (min-resolution: 1.5dppx) {
	li.char { background-image: url(http://www.regexbuddy.com/manual/btn150/char.png); }
	li.string { background-image: url(http://www.regexbuddy.com/manual/btn150/string.png); }
	li.escaped { background-image: url(http://www.regexbuddy.com/manual/btn150/escaped.png); }
	li.special { background-image: url(http://www.regexbuddy.com/manual/btn150/special.png); }
	li.meta { background-image: url(http://www.regexbuddy.com/manual/btn150/meta.png); }
	li.option { background-image: url(http://www.regexbuddy.com/manual/btn150/option.png); }
	li.optiongroup { background-image: url(http://www.regexbuddy.com/manual/btn150/optiongroup.png); }
	li.anchor { background-image: url(http://www.regexbuddy.com/manual/btn150/anchor.png); }
	li.repeat { background-image: url(http://www.regexbuddy.com/manual/btn150/repeat.png); }
	li.backreference { background-image: url(http://www.regexbuddy.com/manual/btn150/backreference.png); }
	li.call { background-image: url(http://www.regexbuddy.com/manual/btn150/call.png); }
	li.void { background-image: url(http://www.regexbuddy.com/manual/btn150/void.png); }
	li.fail { background-image: url(http://www.regexbuddy.com/manual/btn150/fail.png); }
	li.group { background-image: url(http://www.regexbuddy.com/manual/btn150/group.png); }
	li.capture { background-image: url(http://www.regexbuddy.com/manual/btn150/capture.png); }
	li.atomic { background-image: url(http://www.regexbuddy.com/manual/btn150/atomic.png); }
	li.lookaround { background-image: url(http://www.regexbuddy.com/manual/btn150/lookaround.png); }
	li.conditional { background-image: url(http://www.regexbuddy.com/manual/btn150/conditional.png); }
	li.alternate { background-image: url(http://www.regexbuddy.com/manual/btn150/alternate.png); }
	li.error { background-image: url(http://www.regexbuddy.com/manual/btn150/error.png); }
	li.comment { background-image: url(http://www.regexbuddy.com/manual/btn150/comment.png); }
	li.tip { background-image: url(http://www.regexbuddy.com/manual/btn150/tip.png); }
	li.comparesame { background-image: url(http://www.regexbuddy.com/manual/btn150/comparesame.png); }
	li.comparediff { background-image: url(http://www.regexbuddy.com/manual/btn150/comparediff.png); }
	li.cc { background-image: url(http://www.regexbuddy.com/manual/btn150/cc.png); }
	li.ccchar { background-image: url(http://www.regexbuddy.com/manual/btn150/ccchar.png); }
	li.ccstring { background-image: url(http://www.regexbuddy.com/manual/btn150/ccstring.png); }
	li.ccspecial { background-image: url(http://www.regexbuddy.com/manual/btn150/ccspecial.png); }
	li.ccrange { background-image: url(http://www.regexbuddy.com/manual/btn150/ccrange.png); }
	li.ccintersect { background-image: url(http://www.regexbuddy.com/manual/btn150/ccintersect.png); }
	li.ccvoid { background-image: url(http://www.regexbuddy.com/manual/btn150/ccvoid.png); }
	li.ccfail { background-image: url(http://www.regexbuddy.com/manual/btn150/ccfail.png); }
	li.lb { background-image: url(http://www.regexbuddy.com/manual/btn150/lb.png); }
	li.cclb { background-image: url(http://www.regexbuddy.com/manual/btn150/cclb.png); }
}
.regexnest1 { color: #000000; background-color: #60F040; }
.regexplain { background-color: #001818; }
.regexspecial { color: #000080; background-color: #80C0FF; }
.regexnest2 { color: #000000; background-color: #00C000; }
.regexnest3 { color: green; background-color: #006000; }
.regexccopen { color: #181000; background-color: #FFC040; font-weight: bold; }
.regexccspecial { color: #181000; background-color: #F09000; }
.regexccliteral { color: #302000; background-color: #FFC040; }
.regexescaped { color: #202020; background-color: #C0C0C0; }
.regexccrange { color: #302000; background-color: #F8A820; }
.regexcomment { color: #0000FF; background-color: #FFE0C0; font-weight: bold; font-style: italic; }
.regexerr { color: green; background-color: #FF0000; }
.regexmeta { color: #300040; background-color: #C080FF; }
.replaceplain { background-color: #FFF860; }</style>

</head>
<body>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script>
$(document).ready(function(){
    $('h1, h2, h3, h4, h5, .goldword, .topic, .orangeword').click(function(){
    parent.history.back();
    return false;
    });
});
</script>


</head><body>

<center><h4>Regular Expressions</h4></center>
<div id="toc"><ul></ul></div>
<br>
<br>
<br>

<H1>
Regular Expressions Tutorial
</h1>
 
<H2>What Regular Expressions Are Exactly - Terminology</H2>
 
<P>Basically, a regular expression is a pattern describing a certain amount of text. Their name comes from the mathematical theory on which they are based. But we will not dig into that. You will usually find the name abbreviated to &quot;regex&quot; or &quot;regexp&quot;. This tutorial uses &quot;regex&quot;, because it is easy to pronounce the plural &quot;regexes&quot;. On this website, regular expressions are highlighted in red as 
<TT CLASS=code>
<SPAN CLASS="regexplain">
regex
</SPAN>
</TT>
.</P>
 
<P>This first example is actually a perfectly valid regex. It is the most basic pattern, simply matching the literal text 
<TT CLASS=match>
regex
</TT>
. A "match" is the piece of text, or sequence of bytes or characters that pattern was found to correspond to by the regex processing software. Matches are highlighted in blue on this site.</P>
 
<P><TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccliteral">
._%+
</SPAN>
<SPAN CLASS="regexccliteral">
-
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexplain">
@
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccliteral">
.
</SPAN>
<SPAN CLASS="regexccliteral">
-
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexescaped">
\.
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
{2,}
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 is a more complex pattern. It describes a series of letters, digits, dots, underscores, percentage signs and hyphens, followed by an at sign, followed by another series of letters, digits and hyphens, finally followed by a single dot and two or more letters. In other words: this pattern describes an 
<A HREF="email.html" TARGET="_top">
email address
</A>
. This also shows the syntax highlighting applied to regular expressions on this site. Word boundaries and quantifiers are blue, character classes are orange, and escaped literals are gray. You'll see additional colors like green for grouping and purple for meta tokens later in the tutorial.</P>
 
<P>With the above regular expression pattern, you can search through a text file to find email addresses, or verify if a given string looks like an email address. This tutorial uses the term "string" to indicate the text that the regular expression is applied to. This website highlights them in 
<TT CLASS=string>
green
</TT>
. The term "string" or "character string" is used by programmers to indicate a sequence of characters. In practice, you can use regular expressions with whatever data you can access using the application or programming language you are working with.</P>
 
<A NAME="engine">
</A>

<H2>Different Regular Expression Engines</H2>
 
<P>A regular expression "engine" is a piece of software that can process regular expressions, trying to match the pattern to the given string. Usually, the engine is part of a larger application and you do not access the engine directly. Rather, the application invokes it for you when needed, making sure the right regular expression is applied to the right file or data.</P>
 
<P>As usual in the software world, different regular expression engines are not fully compatible with each other. The syntax and behavior of a particular engine is called a regular expression flavor. This tutorial covers all the popular regular expression flavors, including 
<A HREF="perl.html" TARGET="_top">
Perl
</A>
, 
<A HREF="pcre.html" TARGET="_top">
PCRE
</A>
, 
<A HREF="php.html" TARGET="_top">
PHP
</A>
, 
<A HREF="dotnet.html" TARGET="_top">
.NET
</A>
, 
<A HREF="java.html" TARGET="_top">
Java
</A>
, 
<A HREF="javascript.html" TARGET="_top">
JavaScript
</A>
, 
<A HREF="xregexp.html" TARGET="_top">
XRegExp
</A>
, 
<A HREF="vbscript.html" TARGET="_top">
VBScript
</A>
, 
<A HREF="python.html" TARGET="_top">
Python
</A>
, 
<A HREF="ruby.html" TARGET="_top">
Ruby
</A>
, 
<A HREF="delphi.html" TARGET="_top">
Delphi
</A>
, 
<A HREF="rlanguage.html" TARGET="_top">
R
</A>
, 
<A HREF="tcl.html" TARGET="_top">
Tcl
</A>
, 
<A HREF="posix.html" TARGET="_top">
POSIX
</A>
, and 
<A HREF="tools.html" TARGET="_top">
many others
</A>
. The tutorial alerts you when these flavors require different syntax or show different behavior. Even if your application is not explicitly covered by the tutorial, it likely uses a regex flavor that is covered, as most applications are developed using one of the programming environments or regex libraries just mentioned.</P>
<H2>Give Regexes a First Try</H2>
 
<P>You can easily try the following yourself in a text editor that supports regular expressions, such as 
<A HREF="editpadpro.html" TARGET="_top">
EditPad Pro
</A>
. If you do not have such an editor, you can 
<A HREF="//www.editpadpro.com/download.html" TARGET="_top">
download the free evaluation version of EditPad Pro
</A>
 to try this out. EditPad Pro's regex engine is fully functional in the demo version.</P>
 
<P><IMG SRC="https://www.regular-expressions.info/screens/eppeditpadpro.png" ALT="Highlighting regular expression matches in EditPad Pro" BORDER=0></P>
 
<P>As a quick test, copy and paste the text of this page into EditPad Pro. Then select Search|Multiline Search Panel in the menu. In the search panel that appears near the bottom, type in 
<TT CLASS=code>
<SPAN CLASS="regexplain">
regex
</SPAN>
</TT>
 in the box labeled "Search Text". Mark the "Regular expression" checkbox, and click the Find First button. This is the leftmost button on the search panel. See how EditPad Pro's regex engine finds the first match. Click the Find Next button, which sits next to the Find First button, to find further matches. When there are no further matches, the Find Next button's icon flashes briefly.</P>
 
<P>Now try to search using the regex 
<TT CLASS=code>
<SPAN CLASS="regexplain">
reg
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
ular expression
</SPAN>
<SPAN CLASS="regexplain">
s
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
ex
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexplain">
p
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
es
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
. This regex finds all names, singular and plural, I have used on this page to say "regex". If we only had plain text search, we would have needed 5 searches. With regexes, we need just one search. Regexes save you time when using a tool like EditPad Pro. Select Count Matches in the Search menu to see how many times this regular expression can match the file you have open in EditPad Pro.</P>
 
<P>If you are a programmer, your software will run faster since even a simple regex engine applying the above regex once will outperform a state of the art plain text search algorithm searching through the data five times. Regular expressions also reduce development time. With a regex engine, it takes only one line (e.g. in Perl, PHP, Python, Ruby, Java, or .NET) or a couple of lines (e.g. in C using PCRE) of code to, say, check if the user's input looks like a 
<A HREF="email.html" TARGET="_top">
valid email address
</A>
.</P>
 
<P><A HREF="tutorialcnt.html" TARGET="_top">
Regex Tutorial Table of Contents
</A></P>
  
 
</DIV>
 
<div class=topad>
<A HREF="//www.regexbuddy.com/create.html" TARGET="_top">
</A>
</div>
 
<H1>Table of Contents
</h1>
 
<P>This regular expressions tutorial teaches you every aspect of regular expressions. Each topic assumes you have read and understood all previous topics. If you are new to regular expressions, you should read the topics in the order presented.</P>
 
<P><A HREF="tutorial.html" TARGET="_top">
Introduction
</A></P>
 
<P CLASS=indent>
The introduction indicates the scope of the tutorial and which regex flavors are discussed. It also introduces basic terminology.</P>
 
<P><A HREF="characters.html" TARGET="_top">
Literal Characters and Special Characters
</A></P>
 
<P CLASS=indent>
The simplest regex consists of only literal characters. Certain characters have special meanings in a regex and have to be escaped. Escaping rules may get a bit complicated when using regexes in software source code.</P>
 
<P><A HREF="nonprint.html" TARGET="_top">
Non-Printable Characters
</A></P>
 
<P CLASS=indent>
Non-printable characters such as control characters and special spacing or line break characters are easier to enter using control character escapes or hexadecimal escapes.</P>
 
<P><A HREF="engine.html" TARGET="_top">
How a Regex Engine Works Internally
</A></P>
 
<P CLASS=indent>
First look at the internals of the regular expression engine's internals. Later topics build on this information. Knowing the engine's internals greatly helps you to craft regexes that match what you intended, and not match what you do not want.</P>
 
<P><A HREF="charclass.html" TARGET="_top">
Character Classes or Character Sets
</A></P>
 
<P CLASS=indent>
A character class or character set matches a single character out of several possible characters, consisting of individual characters and/or ranges of characters. A negated character class matches a single character not in the character class.</P>
 
<P><A HREF="shorthand.html" TARGET="_top">
Shorthand Character Classes
</A></P>
 
<P CLASS=indent>
Shorthand character classes allow you to use common sets of characters quickly. You can use shorthands on their own or as part of character classes.</P>
 
<p><A HREF="charclasssubtract.html" TARGET="_top">
Character Class Subtraction
</A></p>
 
<p class=indent>
Character class subtraction allows you to match one character that is present in one set of characters but not present in another set of characters.</p>
 
<p><A HREF="charclassintersect.html" TARGET="_top">
Character Class Intersection
</A></p>
 
<p class=indent>
Character class intersection allows you to match one character that is present in one set of characters and also present in another set of characters.</p>
 
<P><A HREF="dot.html" TARGET="_top">
The Dot
</A></P>
 
<P CLASS=indent>
The dot matches any character, though usually not line break characters unless you change an option.</P>
 
<P><A HREF="anchors.html" TARGET="_top">
Anchors
</A></P>
 
<P CLASS=indent>
Anchors are zero-length. They do not match any characters, but rather a position. There are anchors to match at the start and end of the subject string, and anchors to match at the start and end of each line.</P>
 
<P><A HREF="wordboundaries.html" TARGET="_top">
Word Boundaries
</A></P>
 
<P CLASS=indent>
Word boundaries are like anchors, but match at the start of a word and/or the end of a word.</P>
 
<P><A HREF="alternation.html" TARGET="_top">
Alternation
</A></P>
 
<P CLASS=indent>
By separating different sub-regexes with vertical bars, you can tell the regex engine to attempt them from left to right, and return success as soon as one of them can be matched.</P>
 
<P><A HREF="optional.html" TARGET="_top">
Optional Items
</A></P>
 
<P CLASS=indent>
Putting a question mark after an item tells the regex engine to match the item if possible, but continue anyway (rather than admit defeat) if it cannot be matched.</P>
 
<P><A HREF="repeat.html" TARGET="_top">
Repetition Using Various Quantifiers
</A></P>
 
<P CLASS=indent>
Three styles of operators, the star, the plus, and curly braces, allow you to repeat an item zero or more times, once or more, or an arbitrary number of times. It is important to understand that these quantifiers are "greedy" by default, unless you explicitly make them "lazy".</P>
 
<P><A HREF="brackets.html" TARGET="_top">
Grouping
</A></P>
 
<P CLASS=indent>
By placing parentheses around part of the regex, you tell the engine to treat that part as a single item when applying quantifiers or to group alternatives together. Parentheses also create capturing groups allow you to reuse the text matched by part of the regex.</P>
 
<P><A HREF="backref.html" TARGET="_top">
Backreferences
</A></P>
 
<p class=indent>
Backreferences to capturing groups match the same text that was previously matched by that capturing group, allowing you to match patterns of repeated text.</p>
 
<P><A HREF="named.html" TARGET="_top">
Named Groups and Backreferences
</A></P>
 
<P CLASS=indent>
Regular expressions that have multiple groups are much easier to read and maintain if you use named capturing groups and named backreferences.</P>
 
<P><A HREF="branchreset.html" TARGET="_top">
Branch Reset Groups
</A></P>
 
<P CLASS=indent>
When using alternation to match different variants of the same thing, you can put the alternatives in a branch reset group. Then all the alternatives share the same capturing groups. This allows you to use backreferences or retrieve part of the matched text without having to check which of the alternatives captured it.</P>
 
<P><A HREF="freespacing.html" TARGET="_top">
Free-Spacing and Comments
</A></P>
 
<P CLASS=indent>
Splitting a regular expression into multiple lines, adding comments and whitespace, makes it easier to read and understand.</P>
 
<P><A HREF="unicode.html" TARGET="_top">
Unicode Characters and Properties
</A></P>
 
<P CLASS=indent>
If your regular expression flavor supports Unicode, then you can use special Unicode regex tokens to match specific Unicode characters, or to match any character that has a certain Unicode property or is part of a particular Unicode script or block.</P>
 
<P><A HREF="modifiers.html" TARGET="_top">
Mode Modifiers
</A></P>
 
<P CLASS=indent>
Change matching modes such as "case insensitive" for specific parts of the regular expression.</P>
 
<P><A HREF="atomic.html" TARGET="_top">
Atomic Grouping and Possessive Quantifiers
</A></P>
 
<P CLASS=indent>
Nested quantifiers can cause an exponentially increasing amount of backtracking that brings the regex engine to a grinding halt. Atomic grouping and possessive quantifiers provide a solution.</P>
 
<P><A HREF="lookaround.html" TARGET="_top">
Lookaround with Zero-Length Assertions
</A>
, 
<A HREF="lookaround.html" TARGET="_top">
part 1
</A>
 and 
<A HREF="lookaround2.html" TARGET="_top">
part 2
</A></P>
 
<P CLASS=indent>
With lookahead and lookbehind, collectively called lookaround, you can find matches that are followed or not followed by certain text, and preceded or not preceded by certain text, without having the preceding or following text included in the overall regex match. You can also use lookaround to test the same part of the match for multiple requirements.</P>
 
<P><A HREF="keep.html" TARGET="_top">
Keep The Text Matched So Far out of The Overall Regex Match
</A></P>
 
<P CLASS=indent>
Keeping the text matched so far out of the overall regex match allows you to find matches that are preceded by certain text, without having that preceding text included in the overall regex match. This method is primarily of interest with regex flavors that have no or limited support for lookbehind.</P>
 
<P><A HREF="conditional.html" TARGET="_top">
Conditionals
</A></P>
 
<P CLASS=indent>
A conditional is a special construct that first evaluates a lookaround or backreference, and then execute one sub-regex if the lookaround succeeds, and another sub-regex if the lookaround fails.</P>
 
<p><A HREF="recurse.html" TARGET="_top">
Recursion
</A></p>
 
<p class=indent>
Recursion matches the whole regex again at a particular point inside the regex, which makes it possible to match balanced constructs.</p>
 
<p><A HREF="subroutine.html" TARGET="_top">
Subroutine Calls
</A></p>
 
<p class=indent>
Subroutine calls allow you to write regular expressions that match the same constructs in multiple places without having to duplicate parts of your regular expression.</p>
 
<p><A HREF="recursecapture.html" TARGET="_top">
Recursion, Subroutines, &amp; Capturing
</A></p>
 
<p class=indent>
Capturing groups inside recursion and subroutine calls are handled differently by the regex flavors that support them.</p>
 
<p><A HREF="recursebackref.html" TARGET="_top">
Backreferences with Recursion Level
</A></p>
 
<p class=indent>
Special backreferences match the text stored by a capturing group at a particular recursion level, instead of the text most recently matched by that capturing group.</p>
 
<p><A HREF="recursebacktrack.html" TARGET="_top">
Recursion, Subroutines, &amp; Backtracking
</A></p>
 
<p class=indent>
The regex flavors that support recursion and subroutine calls backtrack differently after a recursion or subroutine call fails.</p>
 
<p><A HREF="posixbrackets.html" TARGET="_top">
POSIX Bracket Expressions
</A></p>
 
<p class=indent>
If you are using a 
<A HREF="posix.html" TARGET="_top">
POSIX-compliant
</A>
 regular expression engine, you can use POSIX bracket expressions to match locale-dependent characters.</p>
 
<P><A HREF="zerolength.html" TARGET="_top">
Issues with Zero-Length Matches
</A></P>
 
<P CLASS=indent>
When a regex can find zero-length matches, regex engines use different strategies to avoid getting stuck on a zero-length match when you want to iterate over all matches in a string. This may lead to different match results.</P>
 
<P><A HREF="continue.html" TARGET="_top">
Continuing from The Previous Match Attempt
</A></P>
 
<P CLASS=indent>
Forcing a regex match to start at the end of a previous match provides an efficient way to parse text data.</P>
 

</DIV>
 
<div class=topad>
<A HREF="//www.regexbuddy.com/create.html" TARGET="_top">
</A>
</div>
 
<H1>
Literal Characters
</h1>
 
<P>The most basic regular expression consists of a single literal character, such as 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
. It matches the first occurrence of that character in the string. If the string is 
<TT CLASS=string>
Jack is a boy
</TT>
, it matches the 
<TT CLASS=match>
a
</TT>
 after the 
<TT CLASS=string>
J
</TT>
. The fact that this 
<TT CLASS=string>
a
</TT>
 is in the middle of the word does not matter to the regex engine. If it matters to you, you will need to tell that to the regex engine by using 
<A HREF="wordboundaries.html" TARGET="_top">
word boundaries
</A>
. We will get to that later.</P>
 
<P>This regex can match the second 
<TT CLASS=match>
a
</TT>
 too. It only does so when you tell the regex engine to start searching through the string after the first match. In a text editor, you can do so by using its "Find Next" or "Search Forward" function. In a programming language, there is usually a separate function that you can call to continue searching through the string after the previous match.</P>
 
<P>Similarly, the regex 
<TT CLASS=code>
<SPAN CLASS="regexplain">
cat
</SPAN>
</TT>
 matches 
<TT CLASS=match>
cat
</TT>
 in 
<TT CLASS=string>
About cats and dogs
</TT>
. This regular expression consists of a series of three literal characters. This is like saying to the regex engine: find a 
<TT CLASS=code>
<SPAN CLASS="regexplain">
c
</SPAN>
</TT>
, immediately followed by an 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
, immediately followed by a 
<TT CLASS=code>
<SPAN CLASS="regexplain">
t
</SPAN>
</TT>
.</P>
 
<P>Note that regex engines are case sensitive by default. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
cat
</SPAN>
</TT>
 does not match 
<TT CLASS=string>
Cat
</TT>
, unless you tell the regex engine to ignore differences in case.</P>
 
<A NAME="special">
</A>

<H2>Special Characters</H2>
 
<P>Because we want to do more than simply search for literal pieces of text, we need to reserve certain characters for special use. In the 
<A HREF="tutorial.html#engine">
regex flavors discussed in this tutorial
</A>
, there are 12 characters with special meanings: the backslash 
<TT CLASS=code>
<SPAN CLASS="regexerr">
\
</SPAN>
</TT>
, the caret 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
</TT>
, the dollar sign 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
, the period or dot 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
.
</SPAN>
</TT>
, the vertical bar or pipe symbol 
<TT CLASS=code>
<SPAN CLASS="regexerr">
|
</SPAN>
</TT>
, the question mark 
<TT CLASS=code>
<SPAN CLASS="regexerr">
?
</SPAN>
</TT>
, the asterisk or star 
<TT CLASS=code>
<SPAN CLASS="regexerr">
*
</SPAN>
</TT>
, the plus sign 
<TT CLASS=code>
<SPAN CLASS="regexerr">
+
</SPAN>
</TT>
, the opening parenthesis 
<TT CLASS=code>
<SPAN CLASS="regexerr">
(
</SPAN>
</TT>
, the closing parenthesis 
<TT CLASS=code>
<SPAN CLASS="regexerr">
)
</SPAN>
</TT>
, the opening square bracket 
<TT CLASS=code>
<SPAN CLASS="regexerr">
[
</SPAN>
</TT>
, and the opening curly brace 
<TT CLASS=code>
<SPAN CLASS="regexplain">
{
</SPAN>
</TT>
, These special characters are often called "metacharacters". Most of them are errors when used alone.</P>
 
<P>If you want to use any of these characters as a literal in a regex, you need to escape them with a backslash. If you want to match 
<TT CLASS=match>
1+1=2
</TT>
, the correct regex is 
<TT CLASS=code>
<SPAN CLASS="regexplain">
1
</SPAN>
<SPAN CLASS="regexescaped">
\+
</SPAN>
<SPAN CLASS="regexplain">
1=2
</SPAN>
</TT>
. Otherwise, the plus sign has a special meaning.</P>
 
<P>Note that 
<TT CLASS=code>
<SPAN CLASS="regexplain">
1
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexplain">
1=2
</SPAN>
</TT>
, with the backslash omitted, is a valid regex. So you won't get an error message. But it doesn't match 
<TT CLASS=string>
1+1=2
</TT>
. It would match 
<TT CLASS=match>
111=2
</TT>
 in 
<TT CLASS=string>
123+111=234
</TT>
, due to the special meaning of 
<A HREF="repeat.html" TARGET="_top">
the plus character
</A>
.</P>
 
<P>If you forget to escape a special character where its use is not allowed, such as in 
<TT CLASS=code>
<SPAN CLASS="regexerr">
+
</SPAN>
<SPAN CLASS="regexplain">
1
</SPAN>
</TT>
, then you will get an error message.</P>
 
<P>Most regular expression flavors treat the brace 
<TT CLASS=code>
<SPAN CLASS="regexplain">
{
</SPAN>
</TT>
 as a literal character, unless it is part of a repetition operator like 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexspecial">
{1,3}
</SPAN>
</TT>
. So you generally do not need to escape it with a backslash, though you can do so if you want. But there are a few exceptions. 
<A HREF="java.html" TARGET="_top">
Java
</A>
 requires literal opening braces to be escaped. 
<A HREF="boost.html" TARGET="_top">
Boost
</A>
 and 
<A HREF="stdregex.html" TARGET="_top">
std::regex
</A>
 require all literal braces to be escaped.</p>
 
<P><TT CLASS=code>
<SPAN CLASS="regexplain">
]
</SPAN>
</TT>
 is a literal outside 
<A HREF="charclass.html" TARGET="_top">
character classes
</A>
. Different rules apply inside character classes. Those are discussed in the topic about character classes. Again, there are exceptions. 
<A HREF="stdregex.html" TARGET="_top">
std::regex
</A>
 and 
<A HREF="ruby.html" TARGET="_top">
Ruby
</A>
 require closing square brackets to be escaped even outside character classes.</P>
 
<P>All other characters should not be escaped with a backslash. That is because the backslash is also a special character. The backslash in combination with a literal character can create a regex token with a special meaning. E.g. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\d
</SPAN>
</TT>
 is a 
<A HREF="shorthand.html" TARGET="_top">
shorthand
</A>
 that matches a single digit from 
<tt class=match>
0
</tt>
 to 
<tt class=match>
9
</tt>
.</P>
 
<a name="qe">
</a>
<P>Escaping a single metacharacter with a backslash works in all regular expression flavors. Some flavors also support the 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
\Q
</SPAN>
<SPAN CLASS="regexplain">
…
</SPAN>
<SPAN CLASS="regexmeta">
\E
</SPAN>
</TT>
 escape sequence. All the characters between the 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
\Q
</SPAN>
</TT>
 and the 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
\E
</SPAN>
</TT>
 are interpreted as literal characters. E.g. 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
\Q
</SPAN>
<SPAN CLASS="regexplain">
*\d+*
</SPAN>
<SPAN CLASS="regexmeta">
\E
</SPAN>
</TT>
 matches the literal text 
<tt class=match>
*\d+*
</tt>
. The 
<tt>
\E
</tt>
 may be omitted at the end of the regex, so 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
\Q
</SPAN>
<SPAN CLASS="regexplain">
*\d+*
</SPAN>
</TT>
 is the same as 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
\Q
</SPAN>
<SPAN CLASS="regexplain">
*\d+*
</SPAN>
<SPAN CLASS="regexmeta">
\E
</SPAN>
</TT>
. This syntax is supported by the 
<A HREF="jgsoft.html" TARGET="_top">
JGsoft engine
</A>
, 
<A HREF="perl.html" TARGET="_top">
Perl
</A>
, 
<A HREF="pcre.html" TARGET="_top">
PCRE
</A>
, 
<A HREF="php.html" TARGET="_top">
PHP
</A>
, 
<A HREF="delphi.html" TARGET="_top">
Delphi
</A>
, 
<A HREF="java.html" TARGET="_top">
Java
</A>
, both inside and outside 
<A HREF="charclass.html" TARGET="_top">
character classes
</A>
. Java 4 and 5 have bugs that cause 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
\Q
</SPAN>
<SPAN CLASS="regexplain">
…
</SPAN>
<SPAN CLASS="regexmeta">
\E
</SPAN>
</TT>
 to misbehave, however, so you shouldn't use this syntax with Java. 
<A HREF="boost.html" TARGET="_top">
Boost
</A>
 supports it outside character classes, but not inside.</p>
<H2>Special Characters and Programming Languages</H2>
 
<P>If you are a programmer, you may be surprised that characters like the single quote and double quote are not special characters. That is correct. When using a 
<A HREF="powergrep.html" TARGET="_top">
regular expression or grep tool
</A>
 like PowerGREP or the search function of a 
<A HREF="editpadpro.html" TARGET="_top">
text editor
</A>
 like EditPad Pro, you should not escape or repeat the quote characters like you do in a programming language.</P>
 
<P>In your source code, you have to keep in mind which characters get special treatment inside strings by your programming language. That is because those characters are processed by the compiler, before the regex library sees the string. So the regex 
<TT CLASS=code>
<SPAN CLASS="regexplain">
1
</SPAN>
<SPAN CLASS="regexescaped">
\+
</SPAN>
<SPAN CLASS="regexplain">
1=2
</SPAN>
</TT>
 must be written as 
<TT>
"1\\+1=2"
</TT>
 in C++ code. The C++ compiler turns the escaped backslash in the source code into a single backslash in the string that is passed on to the regex library. To match 
<TT CLASS=match>
c:\temp
</TT>
, you need to use the regex 
<TT CLASS=code>
<SPAN CLASS="regexplain">
c:
</SPAN>
<SPAN CLASS="regexescaped">
\\
</SPAN>
<SPAN CLASS="regexplain">
temp
</SPAN>
</TT>
. As a string in C++ source code, this regex becomes 
<TT>
"c:\\\\temp"
</TT>
. Four backslashes to match a single one indeed.</P>
 
<P>See the 
<A HREF="tools.html" TARGET="_top">
tools and languages
</A>
 section of this website for more information on how to use regular expressions in various programming languages.</P>

</div>

</DIV>
 
<div class=topad>
<A HREF="//www.regexbuddy.com/create.html" TARGET="_top">
</A>
</div>
 
<H1>
Non-Printable Characters
</H1>
 
<P> You can use special character sequences to put non-printable characters in your regular expression. Use 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\t
</SPAN>
</TT>
 to match a tab character (ASCII 0x09), 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\r
</SPAN>
</TT>
 for carriage return (0x0D) and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\n
</SPAN>
</TT>
 for line feed (0x0A). More exotic non-printables are 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\a
</SPAN>
</TT>
 (bell, 0x07), 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\e
</SPAN>
</TT>
 (escape, 0x1B), and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\f
</SPAN>
</TT>
 (form feed, 0x0C). Remember that Windows text files use 
<TT CLASS=string>
\r\n
</TT>
 to terminate lines, while UNIX text files use 
<TT CLASS=string>
\n
</TT>
.</P>
 
<p>In some flavors, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\v
</SPAN>
</TT>
 matches the vertical tab (ASCII 0x0B). In other flavors, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\v
</SPAN>
</TT>
 is a shorthand that matches any vertical whitespace character. That includes the vertical tab, form feed, and all line break characters. Perl 5.10, PCRE 7.2, PHP 5.2.4, R, Delphi XE, and later versions treat it as a shorthand. Earlier versions treated it as a needlessly escaped literal v. The 
<A HREF="jgsoft.html" TARGET="_top">
JGsoft flavor
</A>
 originally matched only the vertical tab with 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\v
</SPAN>
</TT>
. JGsoft V2 matches any vertical whitespace with 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\v
</SPAN>
</TT>
.</p>
 
<a name="control">
</a>
<p>Many regex flavors also support the tokens 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\cA
</SPAN>
</TT>
 through 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\cZ
</SPAN>
</TT>
 to insert ASCII control characters. The letter after the backslash is always a lowercase c. The second letter is an uppercase letter A through Z, to indicate Control+A through Control+Z. These are equivalent to 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\x01
</SPAN>
</TT>
 through 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\x1A
</SPAN>
</TT>
 (26 decimal). E.g. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\cM
</SPAN>
</TT>
 matches a carriage return, just like 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\r
</SPAN>
</TT>
, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\x0D
</SPAN>
</TT>
, and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\u000D
</SPAN>
</TT>
. Most flavors allow the second letter to be lowercase, with no difference in meaning. Only 
<A HREF="java.html" TARGET="_top">
Java
</A>
 requires the A to Z to be uppercase.</p>
 
<p>Using characters other than letters after
<tt>
\c
</tt>
is not recommended because the behavior is inconsistent between applications. Some allow any character after
<tt>
\c
</tt>
while other allow ASCII characters. The application may take the last 5 bits that character index in the code page or its Unicode code point to form an ASCII control character. Or the application may just flip bit 0x40. Either way 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\c@
</SPAN>
</TT>
 through 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\c_
</SPAN>
</TT>
 would match control characters 0x00 through 0x1F. But 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\c*
</SPAN>
</TT>
 might match a line feed or the letter 
<tt class=match>
j
</tt>
. The asterisk is character 0x2A in the ASCII table, so the lower 5 bits are 0x0A while flipping bit 0x40 gives 0x6A. Metacharacters indeed lose their meaning immediately after
<tt>
\c
</tt>
in applications that support 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\cA
</SPAN>
</TT>
 through 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\cZ
</SPAN>
</TT>
 for matching control characters. The original JGsoft flavor, 
<A HREF="dotnet.html" TARGET="_top">
.NET
</A>
, and 
<A HREF="xregexp.html" TARGET="_top">
XRegExp
</A>
 are more sensible. They treat anything other than a letter after
<tt>
\c
</tt>
as an error.</p>
 
<p>In 
<A HREF="xml.html" TARGET="_top">
XML Schema regular expressions
</A>
 and 
<A HREF="xpath.html" TARGET="_top">
XPath
</A>
, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\c
</SPAN>
</TT>
 is a 
<A HREF="shorthand.html" TARGET="_top">
shorthand character class
</A>
 that matches any character allowed in an XML name.</p>
 
<p>The 
<A HREF="jgsoft.html" TARGET="_top">
JGsoft flavor
</A>
 originally treated 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\cA
</SPAN>
</TT>
 through 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\cZ
</SPAN>
</TT>
 as control characters. But JGsoft V2 treats 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\c
</SPAN>
</TT>
 as an XML shorthand.</p>
 
<P>If your regular expression engine supports 
<A HREF="unicode.html" TARGET="_top">
Unicode
</A>
, you can use 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\uFFFF
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\x{FFFF}
</SPAN>
</TT>
 to insert a Unicode character. The euro currency sign occupies Unicode code point U+20AC. If you cannot type it on your keyboard, you can insert it into a regular expression with 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\u20AC
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\x{20AC}
</SPAN>
</TT>
. See the tutorial section on Unicode for more details on 
<a href="unicode.html#codepoint">
matching Unicode code points
</a>
.</P>
 
<a name="hex">
</a>
<P>If your regex engine works with 8-bit code pages instead of Unicode, then you can include any character in your regular expression if you know its position in the character set that you are working with. In the Latin-1 character set, the copyright symbol is character 0xA9. So to search for the copyright symbol, you can use 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\xA9
</SPAN>
</TT>
. Another way to search for a tab is to use 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\x09
</SPAN>
</TT>
. Note that the leading zero is required. In 
<A HREF="tcl.html" TARGET="_top">
Tcl
</A>
 8.5 and prior you have to be careful with this syntax, because Tcl used to eat up all hexadecimal characters after 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\x
</SPAN>
</TT>
 and treat the last 4 as a Unicode code point. So 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\xA9ABC20AC
</SPAN>
</TT>
 would match the euro symbol. Tcl 8.6 only takes the first two hexadecimal digits as part of the 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\x
</SPAN>
</TT>
, as all other regex flavors do, so 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\xA9
</SPAN>
<SPAN CLASS="regexplain">
ABC20AC
</SPAN>
</TT>
 matches 
<tt class=match>
&copy;ABC20AC
</tt>
.</P>
 
<a name="octal">
</a>
<p>Many applications also support octal escapes in the form of 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\0377
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\377
</SPAN>
</TT>
, where 377 is the octal representation of the character's position in the character set (255 decimal in this case). There is a lot of variation between regex flavors as to the number of octal digits allowed or required after the backslash, whether the leading zero is required or not allowed, and whether 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\0
</SPAN>
</TT>
 without additional digits matches a NULL byte. In some flavors this causes complications as 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\1
</SPAN>
</TT>
 to 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\77
</SPAN>
</TT>
 can be octal escapes 1 to 63 (decimal) or 
<A HREF="backref.html" TARGET="_top">
backreferences
</A>
 1 to 77 (decimal), depending on how many 
<A HREF="brackets.html" TARGET="_top">
capturing groups
</A>
 there are in the regex. Therefore, using these octal escapes in regexes is strongly discouraged. Use hexadecimal escapes instead.</p>
 
<p>Perl 5.14, PCRE 8.34, PHP 5.5.10, and R 3.0.3 support a new syntax 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\o{377}
</SPAN>
</TT>
 for octal escapes. You can have any number of octal digits between the curly braces, with or without leading zero. There is no confusion with backreferences and literal digits that follow are cleanly separated by the closing curly brace. Do be careful to only put octal digits between the curly braces. In Perl, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\o{whatever}
</SPAN>
</TT>
 is not an error but matches a NULL byte.</p>
 
<p>The 
<A HREF="jgsoft.html" TARGET="_top">
JGsoft flavor
</A>
 originally supported octal escapes in the form of 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\0377
</SPAN>
</TT>
. JGsoft V2 supports 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\o{377}
</SPAN>
</TT>
 and treats 
<TT CLASS=code>
<SPAN CLASS="regexerr">
\0377
</SPAN>
</TT>
 as an error.</p>
 
<a name="stringsyntax">
</a>

<H2>Regex Syntax versus String Syntax</h2>
 
<p>Many programming languages support similar escapes for non-printable characters in their syntax for literal strings in source code. Then such escapes are translated by the compiler into their actual characters before the string is passed to the regex engine. If the regex engine does not support the same escapes, this can cause an apparent difference in behavior when a regex is specified as a literal string in source code compared with a regex that is read from a file or received from user input. For example, 
<A HREF="posix.html" TARGET="_top">
POSIX regular expressions
</A>
 do not support any of these escapes. But the C programming language does support escapes like 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\n
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\x0A
</SPAN>
</TT>
 in string literals. So when developing an application in C using the POSIX library, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\n
</SPAN>
</TT>
 is only interpreted as a newline when you add the regex as a string literal to your source code. Then the compiler interprets 
<tt>
\n
</tt>
 and the regex engine sees an actual newline character. If your code reads the same regex from a file, then the regex engine sees 
<TT CLASS=code>
<SPAN CLASS="regexescaped">
\n
</SPAN>
</TT>
. Depending on the implementation, the POSIX library interprets this as a literal 
<TT CLASS=code>
<SPAN CLASS="regexplain">
n
</SPAN>
</TT>
 or as an error. The actual POSIX standard states that the behavior of an "ordinary" character preceded by a backslash is "undefined".</p>
 
<p>A similar issue exists in Python 3.2 and prior with the Unicode escape 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\uFFFF
</SPAN>
</TT>
. Python has supported this syntax as part of (Unicode) string literals ever since Unicode support was added to Python. But 
<A HREF="python.html" TARGET="_top">
Python's re module
</A>
 only supports 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\uFFFF
</SPAN>
</TT>
 starting with Python 3.3. In Python 3.2 and earlier, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\uFFFF
</SPAN>
</TT>
 works when you add your regex as a literal (Unicode) string to your Python code. But when your Python 3.2 script reads the regex from a file or user input, 
<TT CLASS=code>
<SPAN CLASS="regexescaped">
\u
</SPAN>
<SPAN CLASS="regexplain">
FFFF
</SPAN>
</TT>
 matches 
<tt class=match>
uFFFF
</tt>
 literally as the regex engine sees 
<TT CLASS=code>
<SPAN CLASS="regexescaped">
\u
</SPAN>
</TT>
 as an escaped literal 
<TT CLASS=code>
<SPAN CLASS="regexplain">
u
</SPAN>
</TT>
.</p>

</div>

</DIV>
 
<div class=topad>
<A HREF="//www.regexbuddy.com/create.html" TARGET="_top">
</A>
</div>
 
<H1>
First Look at How a Regex Engine Works Internally
</h1>
 
<P>Knowing how the regex engine works enables you to craft better regexes more easily. It helps you understand quickly why a particular regex does not do what you initially expected. This saves you lots of guesswork and head scratching when you need to write more complex regexes.</P>
 
<P>After introducing a new regex token, this tutorial explains step by step how the regex engine actually processes that token. This inside look may seem a bit long-winded at certain times. But understanding how the regex engine works enables you to use its full power and help you avoid common mistakes.</P>
 
<P>While there are many implementations of regular expressions that differ sometimes slightly and sometimes significantly in syntax and behavior, there are basically only two kinds of regular expression engines: text-directed engines, and regex-directed engines. Nearly all modern regex flavors are based on regex-directed engines. This is because certain very useful features, such as 
<A HREF="repeat.html#lazy">
lazy quantifiers
</A>
 and 
<A HREF="backref.html" TARGET="_top">
backreferences
</A>
, can only be implemented in regex-directed engines.</P>
 
<p>A regex-directed engine walks through the regex, attempting to match the next token in the regex to the next character. If a match is found, the engine advances through the regex and the subject string. If a token fails to match, the engine 
<i>
backtracks
</i>
 to a previous position in the regex and the subject string where it can try a different path through the regex. This tutorial will talk a lot more about backtracking later on. Modern regex flavors using regex-directed engines have lots of features such as 
<A HREF="atomic.html" TARGET="_top">
atomic grouping
</A>
 and 
<A HREF="possessive.html" TARGET="_top">
possessive quantifiers
</A>
 that allow you to control this backtracking.</p>
 
<p>A text-directed engine walks through the subject string, attempting all permutations of the regex before advancing to the next character in the string. A text-directed engine never backtracks. Thus, there isn't much to discuss about the matching process of a text-directed engine. In most cases, a text-directed engine finds the same matches as a regex-directed engine.</p>
 
<p>When this tutorial talks about regex engine internals, the discussion assumes a regex-directed engine. It only mentions text-directed engines in situations where they find different matches. And that only really happens when your regex uses 
<A HREF="alternation.html" TARGET="_top">
alternation
</A>
 with two alternatives that can match at the same position.</p>
<H2>The Regex Engine Always Returns the Leftmost Match</H2>
 
<P>This is a very important point to understand: a regex engine always returns the leftmost match, even if a "better" match could be found later. When applying a regex to a string, the engine starts at the first character of the string. It tries all possible permutations of the regular expression at the first character. Only if all possibilities have been tried and found to fail, does the engine continue with the second character in the text. Again, it tries all possible permutations of the regex, in exactly the same order. The result is that the regex engine returns the 
<I>
leftmost
</I>
 match.</P>
 
<P>When applying 
<TT CLASS=code>
<SPAN CLASS="regexplain">
cat
</SPAN>
</TT>
 to 
<TT CLASS=string>
He captured a catfish for his cat.
</TT>
, the engine tries to match the first token in the regex 
<TT CLASS=code>
<SPAN CLASS="regexplain">
c
</SPAN>
</TT>
 to the first character in the match 
<TT CLASS=string>
H
</TT>
. This fails. There are no other possible permutations of this regex, because it merely consists of a sequence of literal characters. So the regex engine tries to match the 
<TT CLASS=code>
<SPAN CLASS="regexplain">
c
</SPAN>
</TT>
 with the 
<TT CLASS=string>
e
</TT>
. This fails too, as does matching the 
<TT CLASS=code>
<SPAN CLASS="regexplain">
c
</SPAN>
</TT>
 with the space. Arriving at the 4th character in the string, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
c
</SPAN>
</TT>
 matches 
<TT CLASS=match>
c
</TT>
. The engine then tries to match the second token 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
 to the 5th character, 
<TT CLASS=match>
a
</TT>
. This succeeds too. But then, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
t
</SPAN>
</TT>
 fails to match 
<TT CLASS=string>
p
</TT>
. At that point, the engine knows the regex cannot be matched starting at the 4th character in the string. So it continues with the 5th: 
<TT CLASS=string>
a
</TT>
. Again, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
c
</SPAN>
</TT>
 fails to match here and the engine carries on. At the 15th character in the string, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
c
</SPAN>
</TT>
 again matches 
<TT CLASS=match>
c
</TT>
. The engine then proceeds to attempt to match the remainder of the regex at character 15 and finds that 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
 matches 
<TT CLASS=match>
a
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexplain">
t
</SPAN>
</TT>
 matches 
<TT CLASS=match>
t
</TT>
.</P>
 
<P>The entire regular expression could be matched starting at character 15. The engine is "eager" to report a match. It therefore reports the first three letters of catfish as a valid match. The engine never proceeds beyond this point to see if there are any "better" matches. The first match is considered good enough.</P>
 
<P>In this first example of the engine's internals, our regex engine simply appears to work like a regular text search routine. However, it is important that you can follow the steps the engine takes in your mind. In following examples, the way the engine works has a profound impact on the matches it finds. Some of the results may be surprising. But they are always logical and predetermined, once you know how the engine works.</P>
 
</DIV>
 
<div class=topad>
<A HREF="//www.regexbuddy.com/create.html" TARGET="_top">
</A>
</div>
 
<H1>
Character Classes or Character Sets
</h1>
 
<P>With a "character class", also called "character set", you can tell the regex engine to match only one out of several characters. Simply place the characters you want to match between square brackets. If you want to match an a or an e, use 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
ae
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
. You could use this in 
<TT CLASS=code>
<SPAN CLASS="regexplain">
gr
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
ae
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexplain">
y
</SPAN>
</TT>
 to match either 
<TT CLASS=match>
gray
</TT>
 or 
<TT CLASS=match>
grey
</TT>
. Very useful if you do not know whether the document you are searching through is written in American or British English.</P>
 
<P>A character class matches only a single character. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
gr
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
ae
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexplain">
y
</SPAN>
</TT>
 does not match 
<TT CLASS=string>
graay
</TT>
, 
<TT CLASS=string>
graey
</TT>
 or any such thing. The order of the characters inside a character class does not matter. The results are identical.</P>
 
<P>You can use a hyphen inside a character class to specify a range of characters. 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 matches a 
<I>
single
</I>
 digit between 0 and 9. You can use more than one range. 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
f
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
F
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 matches a single hexadecimal digit, case insensitively. You can combine ranges and single characters. 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
f
</SPAN>
<SPAN CLASS="regexccliteral">
x
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
F
</SPAN>
<SPAN CLASS="regexccliteral">
X
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 matches a hexadecimal digit or the letter X. Again, the order of the characters and the ranges does not matter.</P>
 
<P>Character classes are one of the most commonly used features of regular expressions. You can find a word, even if it is misspelled, such as 
<TT CLASS=code>
<SPAN CLASS="regexplain">
sep
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
ae
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexplain">
r
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
ae
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexplain">
te
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexplain">
li
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
cs
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexplain">
en
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
cs
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexplain">
e
</SPAN>
</TT>
. You can find an identifier in a programming language with 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccliteral">
_
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccliteral">
_
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
. You can find a C-style hexadecimal number with 
<TT CLASS=code>
<SPAN CLASS="regexplain">
0
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
xX
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
F
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
f
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
.</P>
 
<A NAME="negated">
</A>

<H2>Negated Character Classes</H2>
 
<P>Typing a caret after the opening square bracket negates the character class. The result is that the character class matches any character that is 
<I>
not
</I>
 in the character class. Unlike the 
<A HREF="dot.html" TARGET="_top">
dot
</A>
, negated character classes also match (invisible) line break characters. If you don't want a negated character class to match line breaks, you need to include the line break characters in the class. 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccspecial">
\r
</SPAN>
<SPAN CLASS="regexccspecial">
\n
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 matches any character that is not a digit or a line break.</P>
 
<P>It is important to remember that a negated character class still must match a character. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
q
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
u
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 does 
<EM>
not
</EM>
 mean: "a q not followed by a u". It means: "a q followed by a character that is not a u". It does not match the q in the string 
<TT CLASS=string>
Iraq
</TT>
. It does match the q and the space after the q in 
<TT CLASS=string>
Iraq is a country
</TT>
. Indeed: the space becomes part of the overall match, because it is the "character that is not a u" that is matched by the negated character class in the above regexp. If you want the regex to match the q, and only the q, in both strings, you need to use 
<A HREF="lookaround.html" TARGET="_top">
negative lookahead
</A>
: 
<TT CLASS=code>
<SPAN CLASS="regexplain">
q
</SPAN>
<SPAN CLASS="regexnest1">
(?!
</SPAN>
<SPAN CLASS="regexplain">
u
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
. But we will get to that later.</P>
 
<a name="special">
</a>

<H2>Metacharacters Inside Character Classes</H2>
 
<P>In most regex flavors, the only special characters or metacharacters inside a character class are the closing bracket 
<tt>
]
</tt>
, the backslash 
<tt>
\
</tt>
, the caret 
<tt>
^
</tt>
, and the hyphen 
<tt>
-
</tt>
. The 
<A HREF="characters.html#special">
usual metacharacters
</A>
 are normal characters inside a character class, and do not need to be escaped by a backslash. To search for a star or plus, use 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
+*
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
. Your regex will work fine if you escape the regular metacharacters inside a character class, but doing so significantly reduces readability.</P>
 
<P>To include a backslash as a character without any special meaning inside a character class, you have to escape it with another backslash. 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
\\
</SPAN>
<SPAN CLASS="regexccliteral">
x
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 matches a backslash or an x. The closing bracket 
<tt>
]
</tt>
, the caret 
<tt>
^
</tt>
 and the hyphen 
<tt>
-
</tt>
 can be included by escaping them with a backslash, or by placing them in a position where they do not take on their special meaning. The 
<A HREF="posix.html" TARGET="_top">
POSIX
</A>
 and 
<A HREF="gnu.html" TARGET="_top">
GNU
</A>
 flavors are an exception. They treat backslashes in character classes as literal characters. So with these flavors, you can't escape anything in character classes.</p>
 
<p>To include an unescaped caret as a literal, place it anywhere except right after the opening bracket. 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
x^
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 matches an x or a caret. This works with all flavors discussed in this tutorial.</p>
 
<p>You can include an unescaped closing bracket by placing it right after the opening bracket, or right after the negating caret. 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
]x
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 matches a closing bracket or an x. 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
]x
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 matches any character that is not a closing bracket or an x. This does not work in 
<A HREF="javascript.html" TARGET="_top">
JavaScript
</A>
, which treats 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[]
</SPAN>
</TT>
 as an empty character class that always fails to match, and 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 as a negated empty character class that matches any single character. 
<A HREF="ruby.html" TARGET="_top">
Ruby
</A>
 treats empty character classes as an error. So both JavaScript and Ruby require closing brackets to be escaped with a backslash to include them as literals in a character class.</p>
 
<p>The hyphen can be included right after the opening bracket, or right before the closing bracket, or right after the negating caret. Both 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
-x
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
x
</SPAN>
<SPAN CLASS="regexccliteral">
-
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 match an x or a hyphen. 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
-x
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
x
</SPAN>
<SPAN CLASS="regexccliteral">
-
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 match any character thas is not an x or a hyphen. This works in all flavors discussed in this tutorial. Hyphens at other positions in character classes where they can't form a range may be interpreted as literals or as errors. Regex flavors are quite inconsistent about this.</P>
 
<p>Many regex tokens that work outside character classes can also be used inside character classes. This includes character escapes, octal escapes, and hexadecimal escapes for 
<A HREF="nonprint.html" TARGET="_top">
non-printable characters
</A>
. For flavors that support 
<A HREF="unicode.html" TARGET="_top">
Unicode
</A>
, it also includes Unicode character escapes and Unicode properties. 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
$
</SPAN>
<SPAN CLASS="regexccspecial">
\u20AC
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 matches a dollar or euro sign, assuming your regex flavor supports Unicode escapes.</P>
<H2>Repeating Character Classes</H2>
 
<P>If you repeat a character class by using the 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
?
</SPAN>
</TT>
, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 operators, you're repeating the entire character class. You're not repeating just the character that it matched. The regex 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 can match 
<TT CLASS=match>
837
</TT>
 as well as 
<TT CLASS=match>
222
</TT>
.</P>
 
<P>If you want to repeat the matched character, rather than the class, you need to use backreferences. 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\1
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 matches 
<TT CLASS=match>
222
</TT>
 but not 
<TT CLASS=string>
837
</TT>
. When applied to the string 
<TT CLASS=string>
833337
</TT>
, it matches 
<TT CLASS=match>
3333
</TT>
 in the middle of this string. If you do not want that, you need to use 
<A HREF="lookaround.html" TARGET="_top">
lookaround
</A>
.</P>
 
<h2>Looking Inside The Regex Engine</h2>
 
<P>As was mentioned earlier: the order of the characters inside a character class does not matter. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
gr
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
ae
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexplain">
y
</SPAN>
</TT>
 matches 
<TT CLASS=match>
grey
</TT>
 in 
<TT CLASS=string>
Is his hair grey or gray?
</TT>
, because that is the 
<I>
leftmost match
</I>
. We already saw 
<A HREF="engine.html" TARGET="_top">
how the engine applies a regex consisting only of literal characters
</A>
. Now we'll see how it applies a regex that has more than one permutation. That is: 
<TT CLASS=code>
<SPAN CLASS="regexplain">
gr
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
ae
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexplain">
y
</SPAN>
</TT>
 can match both 
<TT CLASS=match>
gray
</TT>
 and 
<TT CLASS=match>
grey
</TT>
.</P>
 
<P>Nothing noteworthy happens for the first twelve characters in the string. The engine fails to match 
<TT CLASS=code>
<SPAN CLASS="regexplain">
g
</SPAN>
</TT>
 at every step, and continues with the next character in the string. When the engine arrives at the 13th character, 
<TT CLASS=match>
g
</TT>
 is matched. The engine then tries to match the remainder of the regex with the text. The next token in the regex is the literal 
<TT CLASS=code>
<SPAN CLASS="regexplain">
r
</SPAN>
</TT>
, which matches the next character in the text. So the third token, 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
ae
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 is attempted at the next character in the text (
<TT CLASS=string>
e
</TT>
). The character class gives the engine two options: match 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
 or match 
<TT CLASS=code>
<SPAN CLASS="regexplain">
e
</SPAN>
</TT>
. It first attempts to match 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
, and fails.</P>
 
<P>But because we are using a regex-directed engine, it must continue trying to match all the other permutations of the regex pattern before deciding that the regex cannot be matched with the text starting at character 13. So it continues with the other option, and finds that 
<TT CLASS=code>
<SPAN CLASS="regexplain">
e
</SPAN>
</TT>
 matches 
<TT CLASS=match>
e
</TT>
. The last regex token is 
<TT CLASS=code>
<SPAN CLASS="regexplain">
y
</SPAN>
</TT>
, which can be matched with the following character as well. The engine has found a complete match with the text starting at character 13. It returns 
<TT CLASS=match>
grey
</TT>
 as the match result, and looks no further. Again, the 
<I>
leftmost match
</I>
 is returned, even though we put the 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
 first in the character class, and 
<TT CLASS=match>
gray
</TT>
 could have been matched in the string. But the engine simply did not get that far, because another equally valid match was found to the left of it. 
<TT CLASS=match>
gray
</TT>
 is only matched if you tell the regex engine to continue looking for a second match in the remainder of the subject string after the first match.</P>

</DIV>
 
<div class=topad>
<A HREF="//www.regexbuddy.com/create.html" TARGET="_top">
</A>
</div>
 
<a name="subtract">
</a>
<H1>
Character Class Subtraction
</H1>
 
<P>Character class subtraction is supported by the 
<A HREF="xml.html" TARGET="_top">
XML Schema
</A>
, 
<A HREF="xpath.html" TARGET="_top">
XPath
</A>
, 
<A HREF="dotnet.html" TARGET="_top">
.NET
</A>
 (version 2.0 and later), and 
<A HREF="jgsoft.html" TARGET="_top">
JGsoft
</A>
 regex flavors. It makes it easy to match any single character present in one list (the character class), but not present in another list (the subtracted class). The syntax for this is 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
class
</SPAN>
<SPAN CLASS="regexccopen">
-[
</SPAN>
<SPAN CLASS="regexccliteral">
subtract
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
. If the character after a hyphen is an opening bracket, these flavors interpret the hyphen as the subtraction operator rather than the range operator. You can use the full character class syntax within the subtracted character class.</p>
 
<p>The character class 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
-[
</SPAN>
<SPAN CLASS="regexccliteral">
aeiuo
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 matches a single letter that is not a vowel. In other words: it matches a single consonant. Without character class subtraction or 
<A HREF="charclassintersect.html" TARGET="_top">
intersection
</A>
, the only way to do this would be to list all consonants: 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
b
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
d
</SPAN>
<SPAN CLASS="regexccrange">
f
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
h
</SPAN>
<SPAN CLASS="regexccrange">
j
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
n
</SPAN>
<SPAN CLASS="regexccrange">
p
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
t
</SPAN>
<SPAN CLASS="regexccrange">
v
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
.</p>
 
<p>The character class 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
\p{Nd}
</SPAN>
<SPAN CLASS="regexccopen">
-[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccspecial">
\p{IsThai}
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 matches any single Thai digit. The base class matches any Unicode digit. All non-Thai characters are subtracted from that class. 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
\p{Nd}
</SPAN>
<SPAN CLASS="regexccopen">
-[
</SPAN>
<SPAN CLASS="regexccspecial">
\P{IsThai}
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 does the same. 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
\p{IsThai}
</SPAN>
<SPAN CLASS="regexccopen">
-[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccspecial">
\p{Nd}
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
\p{IsThai}
</SPAN>
<SPAN CLASS="regexccopen">
-[
</SPAN>
<SPAN CLASS="regexccspecial">
\P{Nd}
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 also match a single Thai digit by subtracting all non-digits from the Thai characters.</p>
<H2>Nested Character Class Subtraction</H2>
 
<P>Since you can use the full character class syntax within the subtracted character class, you can subtract a class from the class being subtracted. 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
-[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
6
</SPAN>
<SPAN CLASS="regexccopen">
-[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
3
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 first subtracts 
<tt>
0-3
</tt>
 from 
<tt>
0-6
</tt>
, yielding 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
-[
</SPAN>
<SPAN CLASS="regexccrange">
4
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
6
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
, or 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
3
</SPAN>
<SPAN CLASS="regexccrange">
7
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
, which matches any character in the string 
<tt class=string>
0123789
</tt>
.</p>
 
<p>The class subtraction must always be the last element in the character class. 
<tt>
[0-9-[4-6]a-f]
</tt>
 is not a valid regular expression. It should be rewritten as 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
f
</SPAN>
<SPAN CLASS="regexccopen">
-[
</SPAN>
<SPAN CLASS="regexccrange">
4
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
6
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
. The subtraction works on the whole class. E.g. 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
\p{Ll}
</SPAN>
<SPAN CLASS="regexccspecial">
\p{Lu}
</SPAN>
<SPAN CLASS="regexccopen">
-[
</SPAN>
<SPAN CLASS="regexccspecial">
\p{IsBasicLatin}
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 matches all uppercase and lowercase Unicode letters, except any ASCII letters. The 
<tt>
\p{IsBasicLatin}
</tt>
 is subtracted from the combination of 
<tt>
\p{Ll}\p{Lu}
</tt>
 rather than from 
<tt>
\p{Lu}
</tt>
 alone. This regex will not match 
<tt class=string>
abc
</tt>
.</p>
 
<p>While you can use nested character class subtraction, you cannot subtract two classes sequentially. To subtract ASCII characters and Greek characters from a class with all Unicode letters, combine the ASCII and Greek characters into one class, and subtract that, as in 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
\p{L}
</SPAN>
<SPAN CLASS="regexccopen">
-[
</SPAN>
<SPAN CLASS="regexccspecial">
\p{IsBasicLatin}
</SPAN>
<SPAN CLASS="regexccspecial">
\p{IsGreek}
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
.</p>
<H2>Negation Takes Precedence over Subtraction</h2>
 
<p>The character class 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
1234
</SPAN>
<SPAN CLASS="regexccopen">
-[
</SPAN>
<SPAN CLASS="regexccliteral">
3456
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 is both negated and subtracted from. In all flavors that support character class subtraction, the base class is negated before it is subtracted from. This class should be read as "(not 1234) minus 3456". Thus this character class matches any character other than the digits 1, 2, 3, 4, 5, and 6.</p>
<H2>Notational Compatibility with Other Regex Flavors</H2>
 
<p>Note that a regex like 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccliteral">
-[aeiuo
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexplain">
]
</SPAN>
</TT>
 does not cause any errors in most regex flavors that do not support character class subtraction. But it won't match what you intended either. In most flavors, this regex consists of a character class followed by a literal 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
. The character class matches a character that is either in the range a-z, or a hyphen, or an opening bracket, or a vowel. Since the a-z range and the vowels are redundant, you could write this character class as 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccliteral">
-[
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
-[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 in Perl. A hyphen after a range is treated as a literal character, just like a hyphen immediately after the opening bracket. This is true in the XML, .NET and JGsoft flavors too. 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccliteral">
-_
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 matches a lowercase letter, a hyphen or an underscore in these flavors.</p>
 
<p>Strictly speaking, this means that the character class subtraction syntax is incompatible with Perl and the majority of other regex flavors. But in practice there's no difference. Using non-alphanumeric characters in character class ranges is very bad practice because it relies on the order of characters in the ASCII character table. That makes the regular expression hard to understand for the programmer who inherits your work. While 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
[
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 would match any upper case letter or an opening square bracket in Perl, this regex is much clearer when written as 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccliteral">
[
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
. The former regex would cause an error with the XML, .NET and JGsoft flavors, because they interpret 
<tt>
-[]
</tt>
 as an empty subtracted class, leaving an unbalanced 
<tt>
[
</tt>
.</p>
 

<div class=topad>
<A HREF="//www.regexbuddy.com/create.html" TARGET="_top">
</A>
</div>
 
<a name="intersect">
</a>
<H1>
Character Class Intersection
</H1>
 
<P>Character class intersection is supported by 
<A HREF="java.html" TARGET="_top">
Java
</A>
, 
<a href="jgsoft.html#v2">
JGsoft V2
</a>
, and by 
<A HREF="ruby.html" TARGET="_top">
Ruby
</A>
 1.9 and later. It makes it easy to match any single character that must be present in two sets of characters. The syntax for this is 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
class
</SPAN>
<SPAN CLASS="regexccopen">
&amp;&amp;[
</SPAN>
<SPAN CLASS="regexccliteral">
intersect
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
. You can use the full character class syntax within the intersected character class.</p>
 
<p>If the intersected class does not need a negating caret, then Java and Ruby allow you to omit the nested square brackets: 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
class
</SPAN>
<SPAN CLASS="regexccspecial">
&amp;&amp;
</SPAN>
<SPAN CLASS="regexccliteral">
intersect
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
.</p>
 
<p>You cannot omit the nested square brackets in PowerGREP. If you do, PowerGREP interprets the ampersands as literals. So in PowerGREP 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
class&amp;&amp;intersect
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 is a character class containing only literals, just like 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
clas&amp;inter
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
.</p>
 
<p>The character class 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
&amp;&amp;[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
aeiuo
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 matches a single letter that is not a vowel. In other words: it matches a single consonant. Without character class 
<A HREF="charclasssubtract.html" TARGET="_top">
subtraction
</A>
 or intersection, the only way to do this would be to list all consonants: 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
b
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
d
</SPAN>
<SPAN CLASS="regexccrange">
f
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
h
</SPAN>
<SPAN CLASS="regexccrange">
j
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
n
</SPAN>
<SPAN CLASS="regexccrange">
p
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
t
</SPAN>
<SPAN CLASS="regexccrange">
v
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
.</p>
 
<p>The character class 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
\p{Nd}
</SPAN>
<SPAN CLASS="regexccopen">
&amp;&amp;[
</SPAN>
<SPAN CLASS="regexccspecial">
\p{IsThai}
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 matches any single Thai digit. 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
\p{IsThai}
</SPAN>
<SPAN CLASS="regexccopen">
&amp;&amp;[
</SPAN>
<SPAN CLASS="regexccspecial">
\p{Nd}
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 does exactly the same.</p>
<H2>Intersection of Multiple Classes</H2>
 
<P>You can intersect the same class more than once. 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
&amp;&amp;[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
6
</SPAN>
<SPAN CLASS="regexccopen">
&amp;&amp;[
</SPAN>
<SPAN CLASS="regexccrange">
4
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 is the same as 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
4
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
6
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 as those are the only digits present in all three parts of the intersection. In Java and Ruby you can write the same regex as 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
&amp;&amp;[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
6
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
&amp;&amp;[
</SPAN>
<SPAN CLASS="regexccrange">
4
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
, 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
&amp;&amp;[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
6
</SPAN>
<SPAN CLASS="regexccspecial">
&amp;&amp;
</SPAN>
<SPAN CLASS="regexccrange">
4
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
, 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccspecial">
&amp;&amp;
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
6
</SPAN>
<SPAN CLASS="regexccopen">
&amp;&amp;[
</SPAN>
<SPAN CLASS="regexccrange">
4
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
, or just 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccspecial">
&amp;&amp;
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
6
</SPAN>
<SPAN CLASS="regexccspecial">
&amp;&amp;
</SPAN>
<SPAN CLASS="regexccrange">
4
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
. The nested square brackets are only needed if one of the parts of the intersection is negated.</p>
 
<p>If you do not use square brackets around the right hand part of the intersection, then there is no confusion that the entire remainder of the character class is the right hand part of the intersection. If you do use the square brackets, you could write something like 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9&amp;&amp;[
</SPAN>
<SPAN CLASS="regexccliteral">
12]
</SPAN>
<SPAN CLASS="regexccliteral">
56
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
. In Ruby, this is the same as 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccspecial">
&amp;&amp;
</SPAN>
<SPAN CLASS="regexccliteral">
1256
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
. But Java has bugs that cause it to treat this as 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccspecial">
&amp;&amp;
</SPAN>
<SPAN CLASS="regexccliteral">
56
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
, completely ignoring the nested brackets.</p>
 
<p>PowerGREP does not allow anything after the nested 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
. The characters 
<TT CLASS=code>
<SPAN CLASS="regexerr">
56
</SPAN>
</TT>
 in 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
&amp;&amp;[
</SPAN>
<SPAN CLASS="regexccliteral">
12
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexerr">
56
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 are an error. This way there is no ambiguity about their meaning.</p>
 
<p>You also shouldn't put && at the very start or very end of the regex. Ruby treats 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccspecial">
&amp;&amp;
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
&amp;&amp;
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 as intersections with an empty class, which matches no characters at all. Java ignores leading and trailing && operators. PowerGREP treats them as literal ampersands.</p>
<H2>Intersection in Negated Classes</h2>
 
<p>The character class 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
1234
</SPAN>
<SPAN CLASS="regexccopen">
&amp;&amp;[
</SPAN>
<SPAN CLASS="regexccliteral">
3456
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 is both negated and intersected. In Java and PowerGREP, negation takes precedence over intersection. Java and PowerGREP read this regex as "(not 1234) and 3456". Thus in Java and PowerGREP this class is the same as 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
56
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 and matches the digits 5 and 6. In Ruby, intersection takes precedence over negation. Ruby reads 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
1234
</SPAN>
<SPAN CLASS="regexccspecial">
&amp;&amp;
</SPAN>
<SPAN CLASS="regexccliteral">
3456
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 as "not (1234 and 3456)". Thus in Ruby this class is the same as 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
34
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 which matches anything except the digits 3 and 4.</p>
 
<p>If you want to negate the right hand side of the intersection, then you must use square brackets. Those automatically control precedence. So Java, PowerGREP, and Ruby all read 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
1234
</SPAN>
<SPAN CLASS="regexccopen">
&amp;&amp;[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
3456
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 as "1234 and (not 3456)". Thus this regex is the same as 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
12
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
.</p>
<H2>Notational Compatibility with Other Regex Flavors</H2>
 
<p>The ampersand has no special meaning in character classes in any other regular expression flavors discussed in this tutorial. The ampersand is simply a literal, and repeating it just adds needless duplicates. All these flavors treat 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
1234&amp;&amp;3456
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 as identical to 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
&amp;123456
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
.</p>
 
<p>Strictly speaking, this means that the character class intersection syntax is incompatible with the majority of other regex flavors. But in practice there's no difference, because there is no point in using two ampersands in a character class when you just want to add a literal ampersand. A single ampersand is still treated as a literal by Java, Ruby, and PowerGREP.</p>
 

</DIV>
 
<div class=topad>
<A HREF="//www.regexbuddy.com/create.html" TARGET="_top">
</A>
</div>
 
<H1>
Shorthand Character Classes
</H1>
 
<P>Since certain character classes are used often, a series of shorthand character classes are available. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\d
</SPAN>
</TT>
 is short for 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
. In most flavors that support Unicode, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\d
</SPAN>
</TT>
 includes all digits from all scripts. Notable exceptions are 
<A HREF="java.html" TARGET="_top">
Java
</A>
, 
<A HREF="javascript.html" TARGET="_top">
JavaScript
</A>
, and 
<A HREF="pcre.html" TARGET="_top">
PCRE
</A>
. These Unicode flavors match only ASCII digits with 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\d
</SPAN>
</TT>
.</P>
 
<P><TT CLASS=code>
<SPAN CLASS="regexspecial">
\w
</SPAN>
</TT>
 stands for "word character". It always matches the ASCII characters 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccliteral">
_
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
. Notice the inclusion of the underscore and digits. In most flavors that support Unicode, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\w
</SPAN>
</TT>
 includes many characters from other scripts. There is a lot of inconsistency about which characters are actually included. Letters and digits from alphabetic scripts and ideographs are generally included. Connector punctuation other than the underscore and numeric symbols that aren't digits may or may not be included. 
<A HREF="xml.html" TARGET="_top">
XML Schema
</A>
 and 
<A HREF="xpath.html" TARGET="_top">
XPath
</A>
 even include all symbols in 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\w
</SPAN>
</TT>
. Again, 
<A HREF="java.html" TARGET="_top">
Java
</A>
, 
<A HREF="javascript.html" TARGET="_top">
JavaScript
</A>
, and 
<A HREF="pcre.html" TARGET="_top">
PCRE
</A>
 match only ASCII characters with 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\w
</SPAN>
</TT>
.</p>
 
<P><TT CLASS=code>
<SPAN CLASS="regexspecial">
\s
</SPAN>
</TT>
 stands for "whitespace character". Again, which characters this actually includes, depends on the regex flavor. In all flavors discussed in this tutorial, it includes 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
 
</SPAN>
<SPAN CLASS="regexccspecial">
\t
</SPAN>
<SPAN CLASS="regexccspecial">
\r
</SPAN>
<SPAN CLASS="regexccspecial">
\n
</SPAN>
<SPAN CLASS="regexccspecial">
\f
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
. That is: 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\s
</SPAN>
</TT>
 matches a space, a tab, a line break, or a form feed. Most flavors also include the vertical tab, with 
<A HREF="perl.html" TARGET="_top">
Perl
</A>
 (prior to version 5.18) and 
<A HREF="pcre.html" TARGET="_top">
PCRE
</A>
 (prior to version 8.34) being notable exceptions. In flavors that support Unicode, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\s
</SPAN>
</TT>
 normally includes all characters from the Unicode "separator" category. 
<A HREF="java.html" TARGET="_top">
Java
</A>
 and 
<A HREF="pcre.html" TARGET="_top">
PCRE
</A>
 are exceptions once again. But 
<A HREF="javascript.html" TARGET="_top">
JavaScript
</A>
 does match all Unicode whitespace with 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\s
</SPAN>
</TT>
.</P>
 
<P>Shorthand character classes can be used both inside and outside the square brackets. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\s
</SPAN>
<SPAN CLASS="regexspecial">
\d
</SPAN>
</TT>
 matches a whitespace character followed by a digit. 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
\s
</SPAN>
<SPAN CLASS="regexccspecial">
\d
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 matches a single character that is either whitespace or a digit. When applied to 
<TT CLASS=string>
1&nbsp;+&nbsp;2&nbsp;=&nbsp;3
</TT>
, the former regex matches 
<TT CLASS=match>
&nbsp;2
</TT>
 (space two), while the latter matches 
<TT CLASS=match>
1
</TT>
 (one). 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
\d
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
f
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
F
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 matches a hexadecimal digit, and is equivalent to 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
f
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
F
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 if your flavor only matches ASCII characters with 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\d
</SPAN>
</TT>
.</P>
 
<a name="negated">
</a>

<H2>Negated Shorthand Character Classes</H2>
 
<P>The above three shorthands also have negated versions. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\D
</SPAN>
</TT>
 is the same as 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccspecial">
\d
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\W
</SPAN>
</TT>
 is short for 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccspecial">
\w
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\S
</SPAN>
</TT>
 is the equivalent of 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccspecial">
\s
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
.</P>
 
<P>Be careful when using the negated shorthands inside square brackets. 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
\D
</SPAN>
<SPAN CLASS="regexccspecial">
\S
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 is 
<EM>
not
</EM>
 the same as 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccspecial">
\d
</SPAN>
<SPAN CLASS="regexccspecial">
\s
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
. The latter matches any character that is neither a digit nor whitespace. It matches 
<TT CLASS=match>
x
</TT>
, but not 
<TT CLASS=string>
8
</TT>
. The former, however, matches any character that is either not a digit, or is not whitespace. Because all digits are not whitespace, and all whitespace characters are not digits, 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
\D
</SPAN>
<SPAN CLASS="regexccspecial">
\S
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 matches any character; digit, whitespace, or otherwise.</P>
 
<a name="more">
</a>

<H2>More Shorthand Character Classes</h2>
 
<p>While support for 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\d
</SPAN>
</TT>
, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\s
</SPAN>
</TT>
, and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\w
</SPAN>
</TT>
 is quite universal, there are some regex flavors that support additional shorthand character classes. 
<A HREF="perl.html" TARGET="_top">
Perl
</A>
 5.10 introduced 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\h
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\v
</SPAN>
</TT>
. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\h
</SPAN>
</TT>
 matches horizontal whitespace, which includes the tab and all characters in the "space separator" Unicode category. It is the same as 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
\t
</SPAN>
<SPAN CLASS="regexccspecial">
\p{Zs}
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\v
</SPAN>
</TT>
 matches "vertical whitespace", which includes all characters treated as line breaks in the Unicode standard. It is the same as 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
\n
</SPAN>
<SPAN CLASS="regexccspecial">
\cK
</SPAN>
<SPAN CLASS="regexccspecial">
\f
</SPAN>
<SPAN CLASS="regexccspecial">
\r
</SPAN>
<SPAN CLASS="regexccspecial">
\x85
</SPAN>
<SPAN CLASS="regexccspecial">
\x{2028}
</SPAN>
<SPAN CLASS="regexccspecial">
\x{2029}
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
.</p>
 
<p><A HREF="pcre.html" TARGET="_top">
PCRE
</A>
 also supports 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\h
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\v
</SPAN>
</TT>
 starting with version 7.2. 
<A HREF="php.html" TARGET="_top">
PHP
</A>
 does as of version 5.2.2, 
<A HREF="java.html" TARGET="_top">
Java
</A>
 as of version 8, and the 
<A HREF="jgsoft.html" TARGET="_top">
JGsoft engine
</A>
 as of version 2. 
<A HREF="boost.html" TARGET="_top">
Boost
</A>
 supports 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\h
</SPAN>
</TT>
 starting with version 1.42. No version of Boost supports 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\v
</SPAN>
</TT>
 as a shorthand.</p>
 
<p>In many other regex flavors, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\v
</SPAN>
</TT>
 matches only the 
<A HREF="nonprint.html" TARGET="_top">
vertical tab
</A>
 character. Perl, PCRE, and PHP never supported this, so they were free to give 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\v
</SPAN>
</TT>
 a different meaning. Java 4 to 7 and JGsoft V1 did use 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\v
</SPAN>
</TT>
 to match only the vertical tab. Java 8 and JGsoft V2 changed the meaning of this token anyway. The vertical tab is also a vertical whitespace character. To avoid confusion, the above paragraph uses 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\cK
</SPAN>
</TT>
 to represent the vertical tab.</p>
 
<p><A HREF="ruby.html" TARGET="_top">
Ruby
</A>
 1.9 and later have their own version of 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\h
</SPAN>
</TT>
. It matches a single hexadecimal digit just like 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
f
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
F
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\v
</SPAN>
</TT>
 is a vertical tab in Ruby.</p>
 
<a name="xml">
</a>

<H2>XML Character Classes</h2>
 
<P><A HREF="xml.html" TARGET="_top">
XML Schema
</A>
, 
<A HREF="xpath.html" TARGET="_top">
XPath
</A>
, and 
<a href="jgsoft.html#v2">
JGsoft V2
</a>
 regular expressions support four more shorthands that aren't supported by any other regular expression flavors. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\i
</SPAN>
</TT>
 matches any character that may be the first character of an XML name. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\c
</SPAN>
</TT>
 matches any character that may occur after the first character in an XML name. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\I
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\C
</SPAN>
</TT>
 are the respective negated shorthands. Note that the 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\c
</SPAN>
</TT>
 shorthand syntax conflicts with the 
<a href="characters.html#control">
control character
</a>
 syntax used in many other regex flavors.</p>
 
<P>You can use these four shorthands both inside and outside character classes using the bracket notation. They're very useful for validating XML references and values in your XML schemas. The regular expression 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\i
</SPAN>
<SPAN CLASS="regexspecial">
\c
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
 matches an XML name like 
<tt class=match>
xml:schema
</tt>
.</p>
 
<P>The regex 
<TT CLASS=code>
<SPAN CLASS="regexplain">
&lt;
</SPAN>
<SPAN CLASS="regexspecial">
\i
</SPAN>
<SPAN CLASS="regexspecial">
\c
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexspecial">
\s
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexplain">
&gt;
</SPAN>
</TT>
 matches an opening XML tag without any attributes. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
&lt;/
</SPAN>
<SPAN CLASS="regexspecial">
\i
</SPAN>
<SPAN CLASS="regexspecial">
\c
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexspecial">
\s
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexplain">
&gt;
</SPAN>
</TT>
 matches any closing tag. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
&lt;
</SPAN>
<SPAN CLASS="regexspecial">
\i
</SPAN>
<SPAN CLASS="regexspecial">
\c
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexspecial">
\s
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexspecial">
\i
</SPAN>
<SPAN CLASS="regexspecial">
\c
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexspecial">
\s
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexplain">
=
</SPAN>
<SPAN CLASS="regexspecial">
\s
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexplain">
"
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
"
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexplain">
"
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
'
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
'
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexplain">
'
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexspecial">
\s
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexplain">
&gt;
</SPAN>
</TT>
 matches an opening tag with any number of attributes. Putting it all together, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
&lt;
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexspecial">
\i
</SPAN>
<SPAN CLASS="regexspecial">
\c
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexspecial">
\s
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexspecial">
\i
</SPAN>
<SPAN CLASS="regexspecial">
\c
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexspecial">
\s
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexplain">
=
</SPAN>
<SPAN CLASS="regexspecial">
\s
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexnest3">
(
</SPAN>
<SPAN CLASS="regexplain">
"
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
"
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexplain">
"
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexplain">
'
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
'
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexplain">
'
</SPAN>
<SPAN CLASS="regexnest3">
)
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
/
</SPAN>
<SPAN CLASS="regexspecial">
\i
</SPAN>
<SPAN CLASS="regexspecial">
\c
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\s
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexplain">
&gt;
</SPAN>
</TT>
 matches either an opening tag with attributes or a closing tag.</p>
 
<p>No other regex flavors discussed in this tutorial support XML character classes. If your XML files are plain ASCII , you can use 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
_:
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 for 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\i
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
-._:
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 for 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\c
</SPAN>
</TT>
. If you want to allow all Unicode characters that the XML standard allows, then you will end up with some pretty long regexes. You would have to use 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
:
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccliteral">
_
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccrange">
\u00C0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
\u00D6
</SPAN>
<SPAN CLASS="regexccrange">
\u00D8
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
\u00F6
</SPAN>
<SPAN CLASS="regexccrange">
\u00F8
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
\u02FF
</SPAN>
<SPAN CLASS="regexccrange">
\u0370
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
\u037D
</SPAN>
<SPAN CLASS="regexccrange">
\u037F
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
\u1FFF
</SPAN>
<SPAN CLASS="regexccrange">
\u200C
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
\u200D
</SPAN>
<SPAN CLASS="regexccliteral">
<BR>
 
</SPAN>
<SPAN CLASS="regexccrange">
\u2070
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
\u218F
</SPAN>
<SPAN CLASS="regexccrange">
\u2C00
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
\u2FEF
</SPAN>
<SPAN CLASS="regexccrange">
\u3001
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
\uD7FF
</SPAN>
<SPAN CLASS="regexccrange">
\uF900
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
\uFDCF
</SPAN>
<SPAN CLASS="regexccrange">
\uFDF0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
\uFFFD
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 instead of 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\i
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
-.
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccliteral">
:
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccliteral">
_
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccspecial">
\u00B7
</SPAN>
<SPAN CLASS="regexccrange">
\u00C0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
\u00D6
</SPAN>
<SPAN CLASS="regexccrange">
\u00D8
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
\u00F6
</SPAN>
<SPAN CLASS="regexccrange">
\u00F8
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
\u037D
</SPAN>
<SPAN CLASS="regexccrange">
\u037F
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
\u1FFF
</SPAN>
<SPAN CLASS="regexccrange">
\u200C
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
\u200D
</SPAN>
<SPAN CLASS="regexccliteral">
<BR>
 
</SPAN>
<SPAN CLASS="regexccspecial">
\u203F
</SPAN>
<SPAN CLASS="regexccspecial">
\u2040
</SPAN>
<SPAN CLASS="regexccrange">
\u2070
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
\u218F
</SPAN>
<SPAN CLASS="regexccrange">
\u2C00
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
\u2FEF
</SPAN>
<SPAN CLASS="regexccrange">
\u3001
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
\uD7FF
</SPAN>
<SPAN CLASS="regexccrange">
\uF900
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
\uFDCF
</SPAN>
<SPAN CLASS="regexccrange">
\uFDF0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
\uFFFD
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 instead of 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\c
</SPAN>
</TT>
.</p>
 

</DIV>
 
<div class=topad>
<A HREF="//www.regexbuddy.com/create.html" TARGET="_top">
</A>
</div>
 
<H1>
The Dot Matches (Almost) Any Character
</h1>
 
<P>In regular expressions, the dot or period is one of the most commonly used 
<A HREF="characters.html#special">
metacharacters
</A>
. Unfortunately, it is also the most commonly misused metacharacter.</P>
 
<P>The dot matches a single character, without caring what that character is. The only exception are line break characters. In all regex flavors discussed in this tutorial, the dot does 
<I>
not
</I>
 match line breaks by default.</P>
 
<P>This exception exists mostly because of historic reasons. The first tools that used regular expressions were line-based. They would read a file line by line, and apply the regular expression separately to each line. The effect is that with these tools, the string could never contain line breaks, so the dot could never match them.</P>
 
<P>Modern tools and languages can apply regular expressions to very large strings or even entire files. Except for 
<A HREF="javascript.html" TARGET="_top">
JavaScript
</A>
 and 
<A HREF="vbscript.html" TARGET="_top">
VBScript
</A>
, all regex flavors discussed here have an option to make the dot match all characters, including line breaks.</P>
 
<p>In PowerGREP, tick the checkbox labeled "dot matches line breaks" to make the dot match all characters. In EditPad Pro, turn on the "Dot" or "Dot matches newline" search option.</p>
 
<P>In Perl, the mode where the dot also matches line breaks is called "single-line mode". This is a bit unfortunate, because it is easy to mix up this term with "multi-line mode". Multi-line mode only affects 
<A HREF="anchors.html" TARGET="_top">
anchors
</A>
, and single-line mode only affects the dot. You can activate single-line mode by adding an s after the regex code, like this: 
<TT CLASS=code>
m/^regex$/s;
</TT>
.</P>
 
<P>Other languages and regex libraries have adopted Perl's terminology. When using the 
<A HREF="dotnet.html" TARGET="_top">
regex classes of the .NET framework
</A>
, you activate this mode by specifying 
<TT CLASS=code>
RegexOptions.Singleline
</TT>
, such as in 
<TT CLASS=code>
Regex.Match("string", "regex", RegexOptions.Singleline)
</TT>
.</P>
 
<P><a name="nodotall">
</a>
<A HREF="javascript.html" TARGET="_top">
JavaScript
</A>
 and 
<A HREF="vbscript.html" TARGET="_top">
VBScript
</A>
 do not have an option to make the dot match line break characters. In those languages, you can use a 
<A HREF="charclass.html" TARGET="_top">
character class
</A>
 such as 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
\s
</SPAN>
<SPAN CLASS="regexccspecial">
\S
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 to match any character. This character matches a character that is either a whitespace character (including line break characters), or a character that is not a whitespace character. Since all characters are either whitespace or non-whitespace, this character class matches any character.</P>
 
<p>In all of 
<A HREF="boost.html" TARGET="_top">
Boost
</A>
's regex grammars the dot matches line breaks by default. Boost's ECMAScript grammar allows you to turn this off with 
<tt>
regex_constants::no_mod_m
</tt>
.</P>
 
<a name="linebreak">
</a>

<H2>Line Break Characters</h2>
 
<p>While support for the dot is universal among regex flavors, there are significant differences in which characters they treat as line break characters. All flavors treat the newline 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\n
</SPAN>
</TT>
 as a line break. UNIX text files terminate lines with a single newline. All the scripting languages discussed in this tutorial do not treat any other characters as line breaks. This isn't a problem even on Windows where text files normally break lines with a 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\r
</SPAN>
<SPAN CLASS="regexspecial">
\n
</SPAN>
</TT>
 pair. That's because these scripting languages read and write files in 
<i>
text mode
</i>
 by default. When running on Windows, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\r
</SPAN>
<SPAN CLASS="regexspecial">
\n
</SPAN>
</TT>
 pairs are automatically converted into 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\n
</SPAN>
</TT>
 when a file is read, and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\n
</SPAN>
</TT>
 is automatically written to file as 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\r
</SPAN>
<SPAN CLASS="regexspecial">
\n
</SPAN>
</TT>
.</p>
 
<p><A HREF="stdregex.html" TARGET="_top">
std::regex
</A>
, 
<A HREF="xml.html" TARGET="_top">
XML Schema
</A>
 and 
<A HREF="xpath.html" TARGET="_top">
XPath
</A>
 also treat the carriage return 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\r
</SPAN>
</TT>
 as a line break character. 
<A HREF="javascript.html" TARGET="_top">
JavaScript
</A>
 adds the Unicode line separator 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\u2028
</SPAN>
</TT>
 and page separator 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\u2029
</SPAN>
</TT>
 on top of that. 
<A HREF="java.html" TARGET="_top">
Java
</A>
 includes these plus the Latin-1 next line control character 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\u0085
</SPAN>
</TT>
. 
<A HREF="boost.html" TARGET="_top">
Boost
</A>
 adds the form feed 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\f
</SPAN>
</TT>
 to the list. Only 
<A HREF="delphi.html" TARGET="_top">
Delphi
</A>
 and the 
<A HREF="jgsoft.html" TARGET="_top">
JGsoft flavor
</A>
 supports all Unicode line breaks, completing the mix with the vertical tab.</p>
 
<p><A HREF="dotnet.html" TARGET="_top">
.NET
</A>
 is notably absent from the list of flavors that treat characters other than 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\n
</SPAN>
</TT>
 as line breaks. Unlike scripting languages that have their roots in the UNIX world, .NET is a Windows development framework that does not automatically strip carriage return characters from text files that it reads. If you read a Windows text file as a whole into a string, it will contain carriage returns. If you use the regex 
<TT CLASS=code>
<SPAN CLASS="regexplain">
abc
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
 on that string, without setting RegexOptions.SingleLine, then it will match 
<tt class=match>
abc
</tt>
 plus all characters that follow on the same line, plus the carriage return at the end of the line, but without the newline after that.</p>
 
<p>Some flavors allow you to control which characters should be treated as line breaks. Java has the UNIX_LINES option which makes it treat only 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\n
</SPAN>
</TT>
 as a line break. 
<A HREF="pcre.html" TARGET="_top">
PCRE
</A>
 has options that allow you to choose between 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\n
</SPAN>
</TT>
 only, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\r
</SPAN>
</TT>
 only, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\r
</SPAN>
<SPAN CLASS="regexspecial">
\n
</SPAN>
</TT>
, or all Unicode line breaks.</p>
 
<p>On 
<A HREF="posix.html" TARGET="_top">
POSIX
</A>
 systems, the POSIX locale determines which characters are line breaks. The C locale treats only the newline 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\n
</SPAN>
</TT>
 as a line break. Unicode locales support all Unicode line breaks.</p>
 
<a name="n">
</a>

<H2>\N Never Matches Line Breaks</h2>
 
<p>Perl 5.12 and PCRE 8.10 introduced 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\N
</SPAN>
</TT>
 which matches any single character that is not a line break, just like the dot does. Unlike the dot, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\N
</SPAN>
</TT>
 is not affected by "single-line mode". 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
s
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
<SPAN CLASS="regexspecial">
\N
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
</TT>
 turns on single-line mode and then matches any character that is not a line break followed by any character regardless of whether it is a line break.</p>
 
<p>PCRE's options that control which characters are treated as line breaks affect 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\N
</SPAN>
</TT>
 in exactly the same way as they affect the dot.</p>
 
<p>PHP 5.3.4 and R 2.14.0 also support 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\N
</SPAN>
</TT>
 as their regex support is based on PCRE 8.10 or later. JGsoft V2 also supports 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\N
</SPAN>
</TT>
.</p>
<H2>Use The Dot Sparingly</H2>
 
<P>The dot is a very powerful regex metacharacter. It allows you to be lazy. Put in a dot, and everything matches just fine when you test the regex on valid data. The problem is that the regex also matches in cases where it should not match. If you are new to regular expressions, some of these cases may not be so obvious at first.</P>
 
<P>Let's illustrate this with a simple example. Say we want to match a date in mm/dd/yy format, but we want to leave the user the choice of date separators. The quick solution is 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\d
</SPAN>
<SPAN CLASS="regexspecial">
\d
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
\d
</SPAN>
<SPAN CLASS="regexspecial">
\d
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
\d
</SPAN>
<SPAN CLASS="regexspecial">
\d
</SPAN>
</TT>
. Seems fine at first. It matches a date like 
<TT CLASS=match>
02/12/03
</TT>
 just fine. Trouble is: 
<TT CLASS=match>
02512703
</TT>
 is also considered a valid date by this regular expression. In this match, the first dot matched 
<TT CLASS=match>
5
</TT>
, and the second matched 
<TT CLASS=match>
7
</TT>
. Obviously not what we intended.</P>
 
<P><TT CLASS=code>
<SPAN CLASS="regexspecial">
\d
</SPAN>
<SPAN CLASS="regexspecial">
\d
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
- /.
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
\d
</SPAN>
<SPAN CLASS="regexspecial">
\d
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
- /.
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
\d
</SPAN>
<SPAN CLASS="regexspecial">
\d
</SPAN>
</TT>
 is a better solution. This regex allows a dash, space, dot and forward slash as date separators. Remember that the dot is not a metacharacter inside a 
<A HREF="charclass.html" TARGET="_top">
character class
</A>
, so we do not need to escape it with a backslash.</P>
 
<P>This regex is still far from perfect. It matches 
<TT CLASS=match>
99/99/99
</TT>
 as a valid date. 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
01
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
\d
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
- /.
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
3
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
\d
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
- /.
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
\d
</SPAN>
<SPAN CLASS="regexspecial">
\d
</SPAN>
</TT>
 is a step ahead, though it still matches 
<TT CLASS=match>
19/39/99
</TT>
. How perfect you want your regex to be depends on what you want to do with it. If you are validating user input, it has to be perfect. If you are parsing data files from a known source that generates its files in the same way every time, our last attempt is probably more than sufficient to parse the data without errors. You can find a 
<A HREF="dates.html" TARGET="_top">
better regex to match dates
</A>
 in the example section.</P>
 
<H2>Use Negated Character Classes Instead of the Dot</H2>
 
<P>A 
<a href="charclass.html#negated">
negated character class
</a>
 is often more appropriate than the dot. The tutorial section that explains the repeat operators 
<A HREF="repeat.html" TARGET="_top">
star and plus
</A>
 covers this in more detail. But the warning is important enough to mention it here as well. Again let's illustrate with an example.</P>
 
<P>Suppose you want to match a double-quoted string. Sounds easy. We can have any number of any character between the double quotes, so 
<TT CLASS=code>
<SPAN CLASS="regexplain">
"
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexplain">
"
</SPAN>
</TT>
 seems to do the trick just fine. The dot matches any character, and the star allows the dot to be repeated any number of times, including zero. If you test this regex on 
<TT CLASS=string>
Put a "string" between double quotes
</TT>
, it matches 
<TT CLASS=match>
"string"
</TT>
 just fine. Now go ahead and test it on 
<TT CLASS=string>
Houston, we have a problem with "string one" and "string two". Please respond.
</TT></P>
 
<P>Ouch. The regex matches 
<TT CLASS=match>
"string one" and "string two"
</TT>
. Definitely not what we intended. The reason for this is that the 
<A HREF="repeat.html" TARGET="_top">
star
</A>
 is 
<I>
greedy
</I>
.</P>
 
<P>In the date-matching example, we improved our regex by replacing the dot with a character class. Here, we do the same with a negated character class. Our original definition of a double-quoted string was faulty. We do not want any number of 
<EM>
any character
</EM>
 between the quotes. We want any number of characters that are not double quotes or newlines between the quotes. So the proper regex is 
<TT CLASS=code>
<SPAN CLASS="regexplain">
"
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
"
</SPAN>
<SPAN CLASS="regexccspecial">
\r
</SPAN>
<SPAN CLASS="regexccspecial">
\n
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexplain">
"
</SPAN>
</TT>
.</P>

</DIV>
 
<div class=topad>
<A HREF="//www.regexbuddy.com/create.html" TARGET="_top">
</A>
</div>
 
<H1>
Start of String and End of String Anchors
</h1>
 
<P>Thus far, we have learned about 
<A HREF="characters.html" TARGET="_top">
literal characters
</A>
, 
<A HREF="charclass.html" TARGET="_top">
character classes
</A>
, and the 
<A HREF="dot.html" TARGET="_top">
dot
</A>
. Putting one of these in a regex tells the regex engine to try to match a single character.</P>
 
<P>Anchors are a different breed. They do not match any character at all. Instead, they match a position before, after, or between characters. They can be used to "anchor" the regex match at a certain position. The caret 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
</TT>
 matches the position before the first character in the string. Applying 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
 to 
<TT CLASS=string>
abc
</TT>
 matches 
<TT CLASS=match>
a
</TT>
. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
 does not match 
<TT CLASS=string>
abc
</TT>
 at all, because the 
<TT CLASS=code>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
 cannot be matched right after the start of the string, matched by 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
</TT>
. See below for the inside view of the regex engine.</P>
 
<P>Similarly, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
 matches right after the last character in the string. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
c
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
 matches 
<TT CLASS=match>
c
</TT>
 in 
<TT CLASS=string>
abc
</TT>
, while 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
 does not match at all.</P>
 
<p>A regex that consists solely of an anchor can only find 
<A HREF="zerolength.html" TARGET="_top">
zero-length matches
</A>
. This can be useful, but can also create 
<A HREF="zerolength.html" TARGET="_top">
complications
</A>
 that are explained near the end of this tutorial.</p>
<H2>Useful Applications</H2>
 
<P>When using regular expressions in a programming language to validate user input, using anchors is very important. If you use the code 
<TT CLASS=code>
if ($input =~ m/\d+/)
</TT>
 in a 
<A HREF="perl.html" TARGET="_top">
Perl
</A>
 script to see if the user entered an integer number, it will accept the input even if the user entered 
<TT CLASS=string>
qsdf4ghjk
</TT>
, because 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\d
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 matches the 
<tt class=match>
4
</tt>
. The correct regex to use is 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
<SPAN CLASS="regexspecial">
\d
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
. Because "start of string" must be matched before the match of 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\d
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
, and "end of string" must be matched right after it, the entire string must consist of 
<A HREF="shorthand.html" TARGET="_top">
digits
</A>
 for 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
<SPAN CLASS="regexspecial">
\d
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
 to be able to match.</P>
 
<P>It is easy for the user to accidentally type in a space. When Perl reads from a line from a text file, the line break is also be stored in the variable. So before validating input, it is good practice to trim leading and trailing 
<A HREF="shorthand.html" TARGET="_top">
whitespace
</A>
. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
<SPAN CLASS="regexspecial">
\s
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 matches leading whitespace and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\s
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
 matches trailing whitespace. In Perl, you could use 
<TT CLASS=code>
$input =~ s/^\s+|\s+$//g
</TT>
. Handy use of alternation and /g allows us to do this in a single line of code.</P>
 
<A NAME="multi">
</A>

<H2>Using ^ and $ as Start of Line and End of Line Anchors</H2>
 
<P>If you have a string consisting of multiple lines, like 
<TT CLASS=string>
first line\nsecond line
</TT>
 (where \n indicates a line break), it is often desirable to work with lines, rather than the entire string. Therefore, most regex engines discussed in this tutorial have the option to expand the meaning of both anchors. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
</TT>
 can then match at the start of the string (before the 
<TT CLASS=string>
f
</TT>
 in the above string), as well as after each line break (between 
<TT CLASS=string>
\n
</TT>
 and 
<TT CLASS=string>
s
</TT>
). Likewise, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
 still matches at the end of the string (after the last 
<TT CLASS=string>
e
</TT>
), and also before every line break (between 
<TT CLASS=string>
e
</TT>
 and 
<TT CLASS=string>
\n
</TT>
).</P>
 
<P>In text editors like 
<A HREF="editpadpro.html" TARGET="_top">
EditPad Pro
</A>
 or GNU Emacs, and regex tools like 
<A HREF="powergrep.html" TARGET="_top">
PowerGREP
</A>
, the caret and dollar always match at the start and end of each line. This makes sense because those applications are designed to work with entire files, rather than short strings. In 
<A HREF="ruby.html" TARGET="_top">
Ruby
</A>
 and 
<A HREF="stdregex.html" TARGET="_top">
std::regex
</A>
 the caret and dollar also always match at the start and end of each line. In 
<A HREF="boost.html" TARGET="_top">
Boost
</A>
 they match at the start and end of each line by default. Boost allows you to turn this off with 
<tt>
regex_constants::no_mod_m
</tt>
 when using the ECMAScript grammar.</P>
 
<P>In all other programming languages and libraries discussed on this website , you have to explicitly activate this extended functionality. It is traditionally called "multi-line mode". In Perl, you do this by adding an m after the regex code, like this: 
<TT CLASS=code>
m/^regex$/m;
</TT>
. In 
<A HREF="dotnet.html" TARGET="_top">
.NET
</A>
, the anchors match before and after newlines when you specify 
<TT CLASS=code>
RegexOptions.Multiline
</TT>
, such as in 
<TT CLASS=code>
Regex.Match("string", "regex", RegexOptions.Multiline)
</TT>
.</P>
 
<a name="linebreak">
</a>
<h2>Line Break Characters</h2>
 
<p>The tutorial page about the dot already discussed which characters are seen as 
<a href="dot.html#linebreak">
line break characters
</a>
 by the various regex flavors. This affects the anchors just as much when in multi-line mode, and when the dollar matches before the end of the final break. The anchors handle line breaks that consist of a single character the same way as the dot in each regex flavor.</p>
 
<p>For anchors there's an additional consideration when CR and LF occur as a pair and the regex flavor treats both these characters as line breaks. 
<A HREF="delphi.html" TARGET="_top">
Delphi
</A>
, 
<A HREF="java.html" TARGET="_top">
Java
</A>
, and the 
<A HREF="jgsoft.html" TARGET="_top">
JGsoft flavor
</A>
 treat CRLF as an indivisible pair. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
</TT>
 matches after CRLF and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
 matches before CRLF, but neither match in the middle of a CRLF pair. 
<A HREF="javascript.html" TARGET="_top">
JavaScript
</A>
 and 
<A HREF="xpath.html" TARGET="_top">
XPath
</A>
 treat CRLF pairs as two line breaks. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
</TT>
 matches in the middle of and after CRLF, while 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
 matches before and in the middle of CRLF.</p>
 
<A NAME="az">
</A>
<H2>Permanent Start of String and End of String Anchors</H2>
 
<P><TT CLASS=code>
<SPAN CLASS="regexspecial">
\A
</SPAN>
</TT>
 only ever matches at the start of the string. Likewise, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\Z
</SPAN>
</TT>
 only ever matches at the end of the string. These two tokens never match at line breaks. This is true in all regex flavors discussed in this tutorial, even when you turn on "multiline mode". In EditPad Pro and PowerGREP, where the caret and dollar always match at the start and end of lines, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\A
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\Z
</SPAN>
</TT>
 only match at the start and the end of the entire file.</P>
 
<p><A HREF="javascript.html" TARGET="_top">
JavaScript
</A>
, 
<A HREF="posix.html" TARGET="_top">
POSIX
</A>
, 
<A HREF="xml.html" TARGET="_top">
XML
</A>
, and 
<A HREF="xpath.html" TARGET="_top">
XPath
</A>
 do not support 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\A
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\Z
</SPAN>
</TT>
. You're stuck with using the caret and dollar for this purpose.</p>
 
<p>The 
<A HREF="gnu.html" TARGET="_top">
GNU extensions
</A>
 to POSIX regular expressions use 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\`
</SPAN>
</TT>
 (backtick) to match the start of the string, and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\'
</SPAN>
</TT>
 (single quote) to match the end of the string.</p>
 
<A NAME="realend">
</A>
<H2>Strings Ending with a Line Break</H2>
 
<p>Because Perl returns a string with a newline at the end when reading a line from a file, Perl's regex engine matches 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
 at the position before the line break at the end of the string even when multi-line mode is turned off. Perl also matches 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
 at the very end of the string, regardless of whether that character is a line break. So 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
<SPAN CLASS="regexspecial">
\d
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
 matches 
<tt class=match>
123
</tt>
 whether the subject string is 
<tt class=string>
123
</tt>
 or 
<tt class=string>
123\n
</tt>
.</p>
 
<p>Most modern regex flavors have copied this behavior. That includes 
<A HREF="dotnet.html" TARGET="_top">
.NET
</A>
, 
<A HREF="java.html" TARGET="_top">
Java
</A>
, 
<A HREF="pcre.html" TARGET="_top">
PCRE
</A>
, 
<A HREF="delphi.html" TARGET="_top">
Delphi
</A>
, 
<A HREF="php.html" TARGET="_top">
PHP
</A>
, and 
<A HREF="python.html" TARGET="_top">
Python
</A>
. This behavior is independent of any settings such as "multi-line mode".</p>
 
<p>In all these flavors except 
<A HREF="python.html" TARGET="_top">
Python
</A>
, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\Z
</SPAN>
</TT>
 also matches before the final line break. If you only want a match at the absolute very end of the string, use 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\z
</SPAN>
</TT>
 (lower case z instead of upper case Z). 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\A
</SPAN>
<SPAN CLASS="regexspecial">
\d
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexspecial">
\z
</SPAN>
</TT>
 does not match 
<TT CLASS=string>
123\n
</TT>
. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\z
</SPAN>
</TT>
 matches after the line break, which is not matched by the 
<A HREF="shorthand.html" TARGET="_top">
shorthand character class
</A>
.</P>
 
<p>In Python, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\Z
</SPAN>
</TT>
 matches only at the very end of the string. Python does not support 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\z
</SPAN>
</TT>
.</p>
 
<A NAME="trailing">
</A>
<H2>Strings Ending with Multiple Line Breaks</H2>
 
<p>If a string ends with multiple line breaks and multi-line mode is off then 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
 only matches before the last of those line breaks in all flavors where it can match before the final break. The same is true for 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\Z
</SPAN>
</TT>
 regardless of multi-line mode.</P>
 
<p>Boost is the only exception. In Boost, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\Z
</SPAN>
</TT>
 can match before any number of trailing line breaks as well as at the very end of the string. So if the subject string ends with three line breaks, Boost's 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\Z
</SPAN>
</TT>
 has four positions that it can match at. Like in all other flavors, Boost's 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\Z
</SPAN>
</TT>
 is independent of multi-line mode. Boost's 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
 only matches at the very end of the string when you turn off multi-line mode (which is on by default in Boost).</p>
 
<h2>Looking Inside The Regex Engine</h2>
 
<P>Let's see what happens when we try to match 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
<SPAN CLASS="regexplain">
4
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
 to 
<TT CLASS=string>
749\n486\n4
</TT>
 (where \n represents a newline character) in multi-line mode. As usual, the regex engine starts at the first character: 
<TT CLASS=string>
7
</TT>
. The first token in the regular expression is 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
</TT>
. Since this token is a zero-length token, the engine does not try to match it with the character, but rather with the position before the character that the regex engine has reached so far. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
</TT>
 indeed matches the position before 
<TT CLASS=string>
7
</TT>
. The engine then advances to the next regex token: 
<TT CLASS=code>
<SPAN CLASS="regexplain">
4
</SPAN>
</TT>
. Since the previous token was zero-length, the regex engine does 
<EM>
not
</EM>
 advance to the next character in the string. It remains at 
<TT CLASS=string>
7
</TT>
. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
4
</SPAN>
</TT>
 is a literal character, which does not match 
<TT CLASS=string>
7
</TT>
. There are no other permutations of the regex, so the engine starts again with the first regex token, at the next character: 
<TT CLASS=string>
4
</TT>
. This time, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
</TT>
 cannot match at the position before the 4. This position is preceded by a character, and that character is not a newline. The engine continues at 
<TT CLASS=string>
9
</TT>
, and fails again. The next attempt, at 
<TT CLASS=string>
\n
</TT>
, also fails. Again, the position before 
<TT CLASS=string>
\n
</TT>
 is preceded by a character, 
<TT CLASS=string>
9
</TT>
, and that character is not a newline.</P>
 
<P>Then, the regex engine arrives at the second 
<TT CLASS=string>
4
</TT>
 in the string. The 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
</TT>
 can match at the position before the 
<TT CLASS=string>
4
</TT>
, because it is preceded by a newline character. Again, the regex engine advances to the next regex token, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
4
</SPAN>
</TT>
, but does not advance the character position in the string. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
4
</SPAN>
</TT>
 matches 
<TT CLASS=match>
4
</TT>
, and the engine advances both the regex token and the string character. Now the engine attempts to match 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
 at the position before (indeed: before) the 
<TT CLASS=string>
8
</TT>
. The dollar cannot match here, because this position is followed by a character, and that character is not a newline.</P>
 
<P>Yet again, the engine must try to match the first token again. Previously, it was successfully matched at the second 
<TT CLASS=string>
4
</TT>
, so the engine continues at the next character, 
<TT CLASS=string>
8
</TT>
, where the caret does not match. Same at the six and the newline.</P>
 
<P>Finally, the regex engine tries to match the first token at the third 
<TT CLASS=string>
4
</TT>
 in the string. With success. After that, the engine successfully matches 
<TT CLASS=code>
<SPAN CLASS="regexplain">
4
</SPAN>
</TT>
 with 
<TT CLASS=match>
4
</TT>
. The current regex token is advanced to 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
, and the current character is advanced to the very last position in the string: the void after the string. No regex token that needs a character to match can match here. Not even a 
<A HREF="charclass.html#negated">
negated character class
</A>
. However, we are trying to match a dollar sign, and the mighty dollar is a strange beast. It is zero-length, so it tries to match the position before the current character. It does not matter that this "character" is the void after the string. In fact, the dollar checks the current character. It must be either a newline, or the void after the string, for 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
 to match the position before the current character. Since that is the case after the example, the dollar matches successfully.</P>
 
<P>Since 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
 was the last token in the regex, the engine has found a successful match: the last 
<TT CLASS=match>
4
</TT>
 in the string.</P>

</DIV>
 
<div class=topad>
<A HREF="//www.regexbuddy.com/create.html" TARGET="_top">
</A>
</div>
 
<H1>
Word Boundaries
</h1>
 
<P>The metacharacter 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 is an 
<A HREF="anchors.html" TARGET="_top">
anchor
</A>
 like the caret and the dollar sign. It matches at a position that is called a "word boundary". This match is zero-length.</P>
 
<P>There are three different positions that qualify as word boundaries:</P>
 
<UL>
 
<LI>
Before the first character in the string, if the first character is a word character.
</LI>
 
<LI>
After the last character in the string, if the last character is a word character.
</LI>
 
<LI>
Between two characters in the string, where one is a word character and the other is not a word character.
</LI>
 
</UL>
 
<P>Simply put: 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 allows you to perform a "whole words only" search using a regular expression in the form of 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexplain">
word
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
. A "word character" is a character that can be used to form words. All characters that are not "word characters" are "non-word characters".</p>
 
<p>Exactly which characters are word characters depends on the regex flavor you're working with. In most flavors, characters that are matched by the 
<A HREF="shorthand.html" TARGET="_top">
short-hand character class
</A>
 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\w
</SPAN>
</TT>
 are the characters that are treated as word characters by word boundaries. 
<A HREF="java.html" TARGET="_top">
Java
</A>
 is an exception. Java supports Unicode for 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 but not for 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\w
</SPAN>
</TT>
.</P>
 
<P>Most flavors, except the ones discussed below, have only one metacharacter that matches both before a word and after a word. This is because any position between characters can never be both at the start and at the end of a word. Using only one operator makes things easier for you.</P>
 
<P>Since digits are considered to be word characters, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexplain">
4
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 can be used to match a 4 that is not part of a larger number. This regex does not match 
<TT CLASS=string>
44 sheets of a4
</TT>
. So saying "
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 matches before and after an alphanumeric sequence" is more exact than saying "before and after a word".</P>
 
<P><TT CLASS=code>
<SPAN CLASS="regexspecial">
\B
</SPAN>
</TT>
 is the negated version of 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\B
</SPAN>
</TT>
 matches at every position where 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 does not. Effectively, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\B
</SPAN>
</TT>
 matches at any position between two word characters as well as at any position between two non-word characters.</P>
<H2>Looking Inside The Regex Engine</h2>
 
<P>Let's see what happens when we apply the regex 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexplain">
is
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 to the string 
<TT CLASS=string>
This island is beautiful
</TT>
. The engine starts with the first token 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 at the first character 
<TT CLASS=string>
T
</TT>
. Since this token is zero-length, the position before the character is inspected. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 matches here, because the T is a word character and the character before it is the void before the start of the string. The engine continues with the next token: the literal 
<TT CLASS=code>
<SPAN CLASS="regexplain">
i
</SPAN>
</TT>
. The engine does not advance to the next character in the string, because the previous regex token was zero-length. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
i
</SPAN>
</TT>
 does not match 
<TT CLASS=string>
T
</TT>
, so the engine retries the first token at the next character position.</P>
 
<P><TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 cannot match at the position between the 
<TT CLASS=string>
T
</TT>
 and the 
<TT CLASS=string>
h
</TT>
. It cannot match between the 
<TT CLASS=string>
h
</TT>
 and the 
<TT CLASS=string>
i
</TT>
 either, and neither between the 
<TT CLASS=string>
i
</TT>
 and the 
<TT CLASS=string>
s
</TT>
.</P>
 
<P>The next character in the string is a space. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 matches here because the space is not a word character, and the preceding character is. Again, the engine continues with the 
<TT CLASS=code>
<SPAN CLASS="regexplain">
i
</SPAN>
</TT>
 which does not match with the space.</P>
 
<P>Advancing a character and restarting with the first regex token, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 matches between the space and the second 
<TT CLASS=string>
i
</TT>
 in the string. Continuing, the regex engine finds that 
<TT CLASS=code>
<SPAN CLASS="regexplain">
i
</SPAN>
</TT>
 matches 
<TT CLASS=match>
i
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexplain">
s
</SPAN>
</TT>
 matches 
<TT CLASS=match>
s
</TT>
. Now, the engine tries to match the second 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 at the position before the 
<TT CLASS=string>
l
</TT>
. This fails because this position is between two word characters. The engine reverts to the start of the regex and advances one character to the 
<TT CLASS=string>
s
</TT>
 in 
<TT CLASS=string>
island
</TT>
. Again, the 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 fails to match and continues to do so until the second space is reached. It matches there, but matching the 
<TT CLASS=code>
<SPAN CLASS="regexplain">
i
</SPAN>
</TT>
 fails.</P>
 
<P>But 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 matches at the position before the third 
<TT CLASS=string>
i
</TT>
 in the string. The engine continues, and finds that 
<TT CLASS=code>
<SPAN CLASS="regexplain">
i
</SPAN>
</TT>
 matches 
<TT CLASS=match>
i
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexplain">
s
</SPAN>
</TT>
 matches 
<TT CLASS=match>
s
</TT>
. The last token in the regex, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
, also matches at the position before the third space in the string because the space is not a word character, and the character before it is.</P>
 
<P>The engine has successfully matched the word 
<TT CLASS=match>
is
</TT>
 in our string, skipping the two earlier occurrences of the characters i and s. If we had used the regular expression 
<TT CLASS=code>
<SPAN CLASS="regexplain">
is
</SPAN>
</TT>
, it would have matched the 
<TT CLASS=match>
is
</TT>
 in 
<TT CLASS=string>
This
</TT>
.</P>
 
<a name="tcl">
</a>

<H2>Tcl Word Boundaries</h2>
 
<p>Word boundaries, as described above, are supported by most regular expression flavors. Notable exceptions are the 
<A HREF="posix.html" TARGET="_top">
POSIX
</A>
 and 
<A HREF="xml.html" TARGET="_top">
XML Schema
</A>
 flavors, which don't support word boundaries at all. 
<A HREF="tcl.html" TARGET="_top">
Tcl
</A>
 uses a different syntax.</p>
 
<p>In Tcl, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 matches a backspace character, just like 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\x08
</SPAN>
</TT>
 in most regex flavors (including Tcl's). 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\B
</SPAN>
</TT>
 matches a single backslash character in Tcl, just like 
<TT CLASS=code>
<SPAN CLASS="regexescaped">
\\
</SPAN>
</TT>
 in all other regex flavors (and Tcl too).</p>
 
<p>Tcl uses the letter "y" instead of the letter "b" to match word boundaries. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\y
</SPAN>
</TT>
 matches at any word boundary position, while 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\Y
</SPAN>
</TT>
 matches at any position that is not a word boundary. These Tcl regex tokens match exactly the same as 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\B
</SPAN>
</TT>
 in Perl-style regex flavors. They don't discriminate between the start and the end of a word.</p>
 
<p>Tcl has two more word boundary tokens that do discriminate between the start and end of a word. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\m
</SPAN>
</TT>
 matches only at the start of a word. That is, it matches at any position that has a non-word character to the left of it, and a word character to the right of it. It also matches at the start of the string if the first character in the string is a word character. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\M
</SPAN>
</TT>
 matches only at the end of a word. It matches at any position that has a word character to the left of it, and a non-word character to the right of it. It also matches at the end of the string if the last character in the string is a word character.</p>
 
<p>The only regex engine that supports Tcl-style word boundaries (besides Tcl itself) is the 
<A HREF="jgsoft.html" TARGET="_top">
JGsoft engine
</A>
. In 
<A HREF="powergrep.html" TARGET="_top">
PowerGREP
</A>
 and 
<A HREF="editpadpro.html" TARGET="_top">
EditPad Pro
</A>
, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\B
</SPAN>
</TT>
 are Perl-style word boundaries, while 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\y
</SPAN>
</TT>
, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\Y
</SPAN>
</TT>
, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\m
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\M
</SPAN>
</TT>
 are Tcl-style word boundaries.</p>
 
<p>In most situations, the lack of 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\m
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\M
</SPAN>
</TT>
 tokens is not a problem. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\y
</SPAN>
<SPAN CLASS="regexplain">
word
</SPAN>
<SPAN CLASS="regexspecial">
\y
</SPAN>
</TT>
 finds "whole words only" occurrences of "word" just like 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\m
</SPAN>
<SPAN CLASS="regexplain">
word
</SPAN>
<SPAN CLASS="regexspecial">
\M
</SPAN>
</TT>
 would. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\M
</SPAN>
<SPAN CLASS="regexplain">
word
</SPAN>
<SPAN CLASS="regexspecial">
\m
</SPAN>
</TT>
 could never match anywhere, since 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\M
</SPAN>
</TT>
 never matches at a position followed by a word character, and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\m
</SPAN>
</TT>
 never at a position preceded by one. If your regular expression needs to match characters before or after 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\y
</SPAN>
</TT>
, you can easily specify in the regex whether these characters should be word characters or non-word characters. If you want to match any word, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\y
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexspecial">
\y
</SPAN>
</TT>
 gives the same result as 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\m
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexspecial">
\M
</SPAN>
</TT>
. Using 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\w
</SPAN>
</TT>
 instead of the dot automatically restricts the first 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\y
</SPAN>
</TT>
 to the start of a word, and the second 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\y
</SPAN>
</TT>
 to the end of a word. Note that 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\y
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexspecial">
\y
</SPAN>
</TT>
 would not work. This regex matches each word, and also each sequence of non-word characters between the words in your subject string. That said, if your flavor supports 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\m
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\M
</SPAN>
</TT>
, the regex engine could apply 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\m
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexspecial">
\M
</SPAN>
</TT>
 slightly faster than 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\y
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexspecial">
\y
</SPAN>
</TT>
, depending on its internal optimizations.</p>
 
<p>If your regex flavor supports 
<A HREF="lookaround.html" TARGET="_top">
lookahead and lookbehind
</A>
, you can use 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?&lt;!
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexnest1">
(?=
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 to emulate Tcl's 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\m
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?&lt;=
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexnest1">
(?!
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 to emulate 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\M
</SPAN>
</TT>
. Though quite a bit more verbose, these lookaround constructs match exactly the same as Tcl's word boundaries.</p>
 
<p>If your flavor has lookahead but not lookbehind, and also has Perl-style word boundaries, you can use 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexnest1">
(?=
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 to emulate Tcl's 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\m
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexnest1">
(?!
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 to emulate 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\M
</SPAN>
</TT>
. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 matches at the start or end of a word, and the lookahead checks if the next character is part of a word or not. If it is we're at the start of a word. Otherwise, we're at the end of a word.</p>
 
<a name="gnu">
</a>

<H2>GNU Word Boundaries</h2>
 
<P>The 
<A HREF="gnu.html" TARGET="_top">
GNU extensions
</A>
 to POSIX regular expressions add support for the 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\B
</SPAN>
</TT>
 word boundaries, as described above. GNU also uses its own syntax for start-of-word and end-of-word boundaries. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\&lt;
</SPAN>
</TT>
 matches at the start of a word, like Tcl's 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\m
</SPAN>
</TT>
. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\&gt;
</SPAN>
</TT>
 matches at the end of a word, like Tcl's 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\M
</SPAN>
</TT>
.</p>
 
<p><A HREF="boost.html" TARGET="_top">
Boost
</A>
 also treats 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\&lt;
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\&gt;
</SPAN>
</TT>
 as word boundaries when using the ECMAScript, extended, egrep, or awk grammar.</p>
 
<a name="posix">
</a>
<h2>POSIX Word Boundaries</h2>
 
<p>The 
<A HREF="posix.html" TARGET="_top">
POSIX
</A>
 standard defines 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
[[:&lt;:]]
</SPAN>
</TT>
 as a start-of-word boundary, and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
[[:&gt;:]]
</SPAN>
</TT>
 as an end-of-word boundary. Though the syntax is borrowed from 
<A HREF="posixbrackets.html" TARGET="_top">
POSIX bracket expressions
</A>
, these tokens are word boundaries that have nothing to do with and cannot be used inside character classes. Tcl and GNU also support POSIX word boundaries. 
<A HREF="pcre.html" TARGET="_top">
PCRE
</A>
 supports POSIX word boundaries starting with version 8.34. Boost supports them in all its grammars.</p>

</DIV>
 
<div class=topad>
<A HREF="//www.regexbuddy.com/create.html" TARGET="_top">
</A>
</div>
 
<H1>
Alternation with The Vertical Bar or Pipe Symbol
</h1>
 
<P>I already explained how you can use 
<A HREF="charclass.html" TARGET="_top">
character classes
</A>
 to match a single character out of several possible characters. Alternation is similar. You can use alternation to match a single regular expression out of several possible regular expressions.</P>
 
<P>If you want to search for the literal text 
<TT CLASS=code>
<SPAN CLASS="regexplain">
cat
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexplain">
dog
</SPAN>
</TT>
, separate both options with a vertical bar or pipe symbol: 
<TT CLASS=code>
<SPAN CLASS="regexplain">
cat
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexplain">
dog
</SPAN>
</TT>
. If you want more options, simply expand the list: 
<TT CLASS=code>
<SPAN CLASS="regexplain">
cat
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexplain">
dog
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexplain">
mouse
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexplain">
fish
</SPAN>
</TT>
.</P>
 
<P>The alternation operator has the lowest precedence of all regex operators. That is, it tells the regex engine to match either everything to the left of the vertical bar, or everything to the right of the vertical bar. If you want to limit the reach of the alternation, you need to use parentheses for grouping. If we want to improve the first example to match whole words only, we would need to use 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
cat
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
dog
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
. This tells the regex engine to find a 
<A HREF="wordboundaries.html" TARGET="_top">
word boundary
</A>
, then either 
<TT CLASS=code>
<SPAN CLASS="regexplain">
cat
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexplain">
dog
</SPAN>
</TT>
, and then another word boundary. If we had omitted the parentheses then the regex engine would have searched for a word boundary followed by 
<TT CLASS=code>
<SPAN CLASS="regexplain">
cat
</SPAN>
</TT>
, or, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
dog
</SPAN>
</TT>
 followed by a word boundary.</P>
 
<a name="eager">
</a>

<H2>Remember That The Regex Engine Is Eager</H2>
 
<P>I already explained that 
<A HREF="engine.html" TARGET="_top">
the regex engine is eager
</A>
. It stops searching as soon as it finds a valid match. The consequence is that in certain situations, the order of the alternatives matters. Suppose you want to use a regex to match a list of function names in a programming language: Get, GetValue, Set or SetValue. The obvious solution is 
<TT CLASS=code>
<SPAN CLASS="regexplain">
Get
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexplain">
GetValue
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexplain">
Set
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexplain">
SetValue
</SPAN>
</TT>
. Let's see how this works out when the string is 
<TT CLASS=string>
SetValue
</TT>
.</P>
 
<P>The regex engine starts at the first token in the regex, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
G
</SPAN>
</TT>
, and at the first character in the string, 
<TT CLASS=string>
S
</TT>
. The match fails. However, the regex engine studied the entire regular expression before starting. So it knows that this regular expression uses alternation, and that the entire regex has not failed yet. So it continues with the second option, being the second 
<TT CLASS=code>
<SPAN CLASS="regexplain">
G
</SPAN>
</TT>
 in the regex. The match fails again. The next token is the first 
<TT CLASS=code>
<SPAN CLASS="regexplain">
S
</SPAN>
</TT>
 in the regex. The match succeeds, and the engine continues with the next character in the string, as well as the next token in the regex. The next token in the regex is the 
<TT CLASS=code>
<SPAN CLASS="regexplain">
e
</SPAN>
</TT>
 after the 
<TT CLASS=code>
<SPAN CLASS="regexplain">
S
</SPAN>
</TT>
 that just successfully matched. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
e
</SPAN>
</TT>
 matches 
<TT CLASS=match>
e
</TT>
. The next token, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
t
</SPAN>
</TT>
 matches 
<TT CLASS=match>
t
</TT>
.</P>
 
<P>At this point, the third option in the alternation has been successfully matched. Because the regex engine is eager, it considers the entire alternation to have been successfully matched as soon as one of the options has. In this example, there are no other tokens in the regex outside the alternation, so the entire regex has successfully matched 
<TT CLASS=match>
Set
</TT>
 in 
<TT CLASS=string>
SetValue
</TT>
.</P>
 
<P>Contrary to what we intended, the regex did not match the entire string. There are several solutions. One option is to take into account that the regex engine is eager, and change the order of the options. If we use 
<TT CLASS=code>
<SPAN CLASS="regexplain">
GetValue
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexplain">
Get
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexplain">
SetValue
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexplain">
Set
</SPAN>
</TT>
, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
SetValue
</SPAN>
</TT>
 is attempted before 
<TT CLASS=code>
<SPAN CLASS="regexplain">
Set
</SPAN>
</TT>
, and the engine matches the entire string. We could also combine the four options into two and use the 
<A HREF="optional.html" TARGET="_top">
question mark
</A>
 to make part of them optional: 
<TT CLASS=code>
<SPAN CLASS="regexplain">
Get
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
Value
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexplain">
Set
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
Value
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
</TT>
. Because the question mark is greedy, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
SetValue
</SPAN>
</TT>
 is be attempted before 
<TT CLASS=code>
<SPAN CLASS="regexplain">
Set
</SPAN>
</TT>
.</P>
 
<P>The best option is probably to express the fact that we only want to match complete words. We do not want to match Set or SetValue if the string is 
<TT CLASS=string>
SetValueFunction
</TT>
. So the solution is 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
Get
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
GetValue
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
Set
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
SetValue
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
Get
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexplain">
Value
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
Set
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexplain">
Value
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
. Since all options have the same end, we can optimize this further to 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
Get
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
Set
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
Value
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
.</P>
<H2>Text-Directed Engine Returns the Longest Match</H2>
 
<P>Alternation is where 
<A HREF="engine.html" TARGET="_top">
regex-directed and text-directed engines differ
</A>
. When a text-directed engine attempts 
<TT CLASS=code>
<SPAN CLASS="regexplain">
Get
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexplain">
GetValue
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexplain">
Set
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexplain">
SetValue
</SPAN>
</TT>
 on 
<TT CLASS=string>
SetValue
</TT>
, it tries all permutations of the regex at the start of the string. It does so efficiently, without any backtracking. It sees that the regex can find a match at the start of the string, and that the matched text can be either 
<TT CLASS=string>
Set
</TT>
 or 
<TT CLASS=string>
SetValue
</TT>
. Because the text-directed engine evaluates the regex as a whole, it has no concept of one alternative being listed before another. But it has to make a choice as to which match to return. It always returns the longest match, in this case 
<tt class=match>
SetValue
</tt>
.</P>
<H2>POSIX Requires The Longest Match</h2>
 
<p>The 
<A HREF="posix.html" TARGET="_top">
POSIX standard
</A>
 leaves it up to the implementation to choose a text-directed or regex-directed engine. A BRE that includes backreferences needs to be evaluated using a regex-directed engine. But a BRE without backreferences or an ERE can be evaluated using a text-directed engine. But the POSIX standard does mandate that the longest match be returned, even when a regex-directed engine is used. Such an engine cannot be eager. It has to continue trying all alternatives even after a match is found, in order to find the longest one. This can result in very poor performance when a regex contains multiple quantifiers or a combination of quantifiers and alternation, as all combinations have to be tried to find the longest match.</p>
 
<p>The 
<A HREF="tcl.html" TARGET="_top">
Tcl
</A>
 and 
<A HREF="gnu.html" TARGET="_top">
GNU
</A>
 flavors also work this way.</p>
 

</DIV>
 
<div class=topad>
<A HREF="//www.regexbuddy.com/create.html" TARGET="_top">
</A>
</div>
 
<H1>
Optional Items
</h1>
 
<P>The question mark makes the preceding token in the regular expression optional. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
colo
</SPAN>
<SPAN CLASS="regexplain">
u
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexplain">
r
</SPAN>
</TT>
 matches both 
<TT CLASS=match>
colour
</TT>
 and 
<TT CLASS=match>
color
</TT>
. The question mark is called a quantifier.</P>
 
<P>You can make several tokens optional by grouping them together using parentheses, and placing the question mark after the closing parenthesis. E.g.:&nbsp;
<TT CLASS=code>
<SPAN CLASS="regexplain">
Nov
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
ember
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
</TT>
 matches 
<TT CLASS=match>
Nov
</TT>
 and 
<TT CLASS=match>
November
</TT>
.</P>
 
<P>You can write a regular expression that matches many alternatives by including more than one question mark. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
Feb
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
ruary
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexplain">
 23
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
rd
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
</TT>
 matches 
<TT CLASS=match>
February 23rd
</TT>
, 
<TT CLASS=match>
February 23
</TT>
, 
<TT CLASS=match>
Feb 23rd
</TT>
 and 
<TT CLASS=match>
Feb 23
</TT>
.</P>
 
<p>You can also use curly braces to make something optional. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
colo
</SPAN>
<SPAN CLASS="regexplain">
u
</SPAN>
<SPAN CLASS="regexspecial">
{0,1}
</SPAN>
<SPAN CLASS="regexplain">
r
</SPAN>
</TT>
 is the same as 
<TT CLASS=code>
<SPAN CLASS="regexplain">
colo
</SPAN>
<SPAN CLASS="regexplain">
u
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexplain">
r
</SPAN>
</TT>
. 
<A HREF="posix.html" TARGET="_top">
POSIX BRE
</A>
 and 
<A HREF="posix.html" TARGET="_top">
GNU BRE
</A>
 do not support either syntax. These flavors require backslashes to 
<em>
give
</em>
 curly braces their special meaning: 
<TT CLASS=code>
<SPAN CLASS="regexplain">
colo
</SPAN>
<SPAN CLASS="regexplain">
u
</SPAN>
<SPAN CLASS="regexspecial">
\{0,1\}
</SPAN>
<SPAN CLASS="regexplain">
r
</SPAN>
</TT>
.</p>
 
<a name="greedy">
</a>

<H2>Important Regex Concept: Greediness</H2>
 
<P>The question mark is the first metacharacter introduced by this tutorial that is 
<I>
greedy
</I>
. The question mark gives the regex engine two choices: try to match the part the question mark applies to, or do not try to match it. The engine always tries to match that part. Only if this causes the entire regular expression to fail, will the engine try ignoring the part the question mark applies to.</P>
 
<P>The effect is that if you apply the regex 
<TT CLASS=code>
<SPAN CLASS="regexplain">
Feb 23
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
rd
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
</TT>
 to the string 
<TT CLASS=string>
Today is Feb 23rd, 2003
</TT>
, the match is always 
<TT CLASS=match>
Feb 23rd
</TT>
 and not 
<TT CLASS=match>
Feb 23
</TT>
. You can make the question mark 
<I>
lazy
</I>
 (i.e. turn off the greediness) by putting a second question mark after the first.</P>
 
<P>The discussion about the other 
<A HREF="repeat.html" TARGET="_top">
repetition
</A>
 operators has more details on greedy and lazy quantifiers.</P>
<H2>Looking Inside The Regex Engine</h2>
 
<P>Let's apply the regular expression 
<TT CLASS=code>
<SPAN CLASS="regexplain">
colo
</SPAN>
<SPAN CLASS="regexplain">
u
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexplain">
r
</SPAN>
</TT>
 to the string 
<TT CLASS=string>
The colonel likes the color green
</TT>
.</P>
 
<P>The first token in the regex is the 
<A HREF="characters.html" TARGET="_top">
literal
</A>
 
<TT CLASS=code>
<SPAN CLASS="regexplain">
c
</SPAN>
</TT>
. The first position where it matches successfully is the 
<TT CLASS=match>
c
</TT>
 in 
<TT CLASS=string>
colonel
</TT>
. The engine continues, and finds that 
<TT CLASS=code>
<SPAN CLASS="regexplain">
o
</SPAN>
</TT>
 matches 
<TT CLASS=match>
o
</TT>
, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
l
</SPAN>
</TT>
 matches 
<TT CLASS=match>
l
</TT>
 and another 
<TT CLASS=code>
<SPAN CLASS="regexplain">
o
</SPAN>
</TT>
 matches 
<TT CLASS=match>
o
</TT>
. Then the engine checks whether 
<TT CLASS=code>
<SPAN CLASS="regexplain">
u
</SPAN>
</TT>
 matches 
<TT CLASS=string>
n
</TT>
. This fails. However, the question mark tells the regex engine that failing to match 
<TT CLASS=code>
<SPAN CLASS="regexplain">
u
</SPAN>
</TT>
 is acceptable. Therefore, the engine skips ahead to the next regex token: 
<TT CLASS=code>
<SPAN CLASS="regexplain">
r
</SPAN>
</TT>
. But this fails to match 
<TT CLASS=string>
n
</TT>
 as well. Now, the engine can only conclude that the entire regular expression cannot be matched starting at the 
<TT CLASS=match>
c
</TT>
 in 
<TT CLASS=string>
colonel
</TT>
. Therefore, the engine starts again trying to match 
<TT CLASS=code>
<SPAN CLASS="regexplain">
c
</SPAN>
</TT>
 to the first o in 
<TT CLASS=string>
colonel
</TT>
.</P>
 
<P>After a series of failures, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
c
</SPAN>
</TT>
 matches the 
<TT CLASS=match>
c
</TT>
 in 
<TT CLASS=string>
color
</TT>
, and 
<TT CLASS=code>
<SPAN CLASS="regexplain">
o
</SPAN>
</TT>
, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
l
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexplain">
o
</SPAN>
</TT>
 match the following characters. Now the engine checks whether 
<TT CLASS=code>
<SPAN CLASS="regexplain">
u
</SPAN>
</TT>
 matches 
<TT CLASS=string>
r
</TT>
. This fails. Again: no problem. The question mark allows the engine to continue with 
<TT CLASS=code>
<SPAN CLASS="regexplain">
r
</SPAN>
</TT>
. This matches 
<TT CLASS=match>
r
</TT>
 and the engine reports that the regex successfully matched 
<TT CLASS=match>
color
</TT>
 in our string.</P>

</DIV>
 
</DIV>
 
<div class=topad>
<A HREF="//www.regexbuddy.com/create.html" TARGET="_top">
</A>
</div>
 
<H1>
Repetition with Star and Plus
</h1>
 
<P>One repetition operator or quantifier was already introduced: the 
<A HREF="optional.html" TARGET="_top">
question mark
</A>
. It tells the engine to attempt to match the preceding token zero times or once, in effect making it optional.</P>
 
<P>The asterisk or star tells the engine to attempt to match the preceding token zero or more times. The plus tells the engine to attempt to match the preceding token once or more. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
&lt;
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexplain">
&gt;
</SPAN>
</TT>
 matches an HTML tag without any attributes. The angle brackets are 
<A HREF="characters.html" TARGET="_top">
literals
</A>
. The first 
<A HREF="charclass.html" TARGET="_top">
character class
</A>
 matches a letter. The second character class matches a letter or digit. The star repeats the second character class. Because we used the star, it's OK if the second character class matches nothing. So our regex will match a tag like 
<TT CLASS=match>
&lt;B&gt;
</TT>
. When matching 
<TT CLASS=match>
&lt;HTML&gt;
</TT>
, the first character class will match 
<TT CLASS=match>
H
</TT>
. The star will cause the second character class to be repeated three times, matching 
<TT CLASS=match>
T
</TT>
, 
<TT CLASS=match>
M
</TT>
 and 
<TT CLASS=match>
L
</TT>
 with each step.</P>
 
<P>I could also have used 
<TT CLASS=code>
<SPAN CLASS="regexplain">
&lt;
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexplain">
&gt;
</SPAN>
</TT>
. I did not, because this regex would match 
<TT CLASS=match>
&lt;1&gt;
</TT>
, which is not a valid HTML tag. But this regex may be sufficient if you know the string you are searching through does not contain any such invalid tags.</P>
 
<A NAME="limit">
</A>

<H2>Limiting Repetition</H2>
 
<P>There's an additional quantifier that allows you to specify how many times a token can be repeated. The syntax is 
<TT>
{
<I>
min
</I>
,
<I>
max
</I>
}
</TT>
, where 
<I>
min
</I>
 is zero or a positive integer number indicating the minimum number of matches, and 
<I>
max
</I>
 is an integer equal to or greater than 
<I>
min
</I>
 indicating the maximum number of matches. If the comma is present but 
<I>
max
</I>
 is omitted, the maximum number of matches is infinite. So 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
{0,1}
</SPAN>
</TT>
 is the same as 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
?
</SPAN>
</TT>
, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
{0,}
</SPAN>
</TT>
 is the same as 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
, and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
{1,}
</SPAN>
</TT>
 is the same as 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
. Omitting both the comma and 
<I>
max
</I>
 tells the engine to repeat the token exactly 
<I>
min
</I>
 times.</P>
 
<P>You could use 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
1
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
{3}
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 to match a number between 1000 and 9999. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
1
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
{2,4}
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 matches a number between 100 and 99999. Notice the use of the 
<A HREF="wordboundaries.html" TARGET="_top">
word boundaries
</A>
.</P>
 
<A NAME="greedy">
</A>

<H2>Watch Out for The Greediness!</H2>
 
<P>Suppose you want to use a regex to match an HTML tag. You know that the input will be a valid HTML file, so the regular expression does not need to exclude any invalid use of sharp brackets. If it sits between sharp brackets, it is an HTML tag.</P>
 
<P>Most people new to regular expressions will attempt to use 
<TT CLASS=code>
<SPAN CLASS="regexplain">
&lt;
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexplain">
&gt;
</SPAN>
</TT>
. They will be surprised when they test it on a string like 
<TT CLASS=string>
This is a &lt;EM&gt;first&lt;/EM&gt; test
</TT>
. You might expect the regex to match 
<TT CLASS=match>
&lt;EM&gt;
</TT>
 and when continuing after that match, 
<TT CLASS=match>
&lt;/EM&gt;
</TT>
.</P>
 
<P>But it does not. The regex will match 
<TT CLASS=match>
&lt;EM&gt;first&lt;/EM&gt;
</TT>
. Obviously not what we wanted. The reason is that the plus is 
<I>
greedy
</I>
. That is, the plus causes the regex engine to repeat the preceding token as often as possible. Only if that causes the entire regex to fail, will the regex engine 
<I>
backtrack
</I>
. That is, it will go back to the plus, make it give up the last iteration, and proceed with the remainder of the regex. Let's take a look inside the regex engine to see in detail how this works and why this causes our regex to fail. After that, I will present you with two possible solutions.</P>
 
<P>Like the plus, the star and the repetition using curly braces are greedy.</P>
<H2>Looking Inside The Regex Engine</h2>
 
<P>The first token in the regex is 
<TT CLASS=code>
<SPAN CLASS="regexplain">
&lt;
</SPAN>
</TT>
. This is a 
<A HREF="characters.html" TARGET="_top">
literal
</A>
. As we already know, the first place where it will match is the first 
<TT CLASS=match>
&lt;
</TT>
 in the string. The next token is the dot, which matches any character except newlines. The dot is repeated by the plus. The plus is 
<I>
greedy
</I>
. Therefore, the engine will repeat the dot as many times as it can. The dot matches 
<TT CLASS=match>
E
</TT>
, so the regex continues to try to match the dot with the next character. 
<TT CLASS=match>
M
</TT>
 is matched, and the dot is repeated once more. The next character is the 
<TT CLASS=string>
&gt;
</TT>
. You should see the problem by now. The dot matches the 
<TT CLASS=match>
&gt;
</TT>
, and the engine continues repeating the dot. The dot will match all remaining characters in the string. The dot fails when the engine has reached the void after the end of the string. Only at this point does the regex engine continue with the next token: 
<TT CLASS=code>
<SPAN CLASS="regexplain">
&gt;
</SPAN>
</TT>
.</P>
 
<P>So far, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
&lt;
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 has matched 
<TT CLASS=match>
&lt;EM&gt;first&lt;/EM&gt; test
</TT>
 and the engine has arrived at the end of the string. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
&gt;
</SPAN>
</TT>
 cannot match here. The engine remembers that the plus has repeated the dot more often than is required. (Remember that the plus 
<I>
requires
</I>
 the dot to match only once.) Rather than admitting failure, the engine will 
<I>
backtrack
</I>
. It will reduce the repetition of the plus by one, and then continue trying the remainder of the regex.</P>
 
<P>So the match of 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 is reduced to 
<TT CLASS=match>
EM&gt;first&lt;/EM&gt; tes
</TT>
. The next token in the regex is still 
<TT CLASS=code>
<SPAN CLASS="regexplain">
&gt;
</SPAN>
</TT>
. But now the next character in the string is the last 
<TT CLASS=string>
t
</TT>
. Again, these cannot match, causing the engine to backtrack further. The total match so far is reduced to 
<TT CLASS=match>
&lt;EM&gt;first&lt;/EM&gt; te
</TT>
. But 
<TT CLASS=code>
<SPAN CLASS="regexplain">
&gt;
</SPAN>
</TT>
 still cannot match. So the engine continues backtracking until the match of 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 is reduced to 
<TT CLASS=match>
EM&gt;first&lt;/EM
</TT>
. Now, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
&gt;
</SPAN>
</TT>
 can match the next character in the string. The last token in the regex has been matched. The engine reports that 
<TT CLASS=match>
&lt;EM&gt;first&lt;/EM&gt;
</TT>
 has been successfully matched.</P>
 
<P>Remember that the regex engine is 
<I>
eager
</I>
 to return a match. It will not continue backtracking further to see if there is another possible match. It will report the first valid match it finds. Because of greediness, this is the leftmost longest match.</P>
 
<A NAME="lazy">
</A>
<H2>Laziness Instead of Greediness</H2>
 
<P>The quick fix to this problem is to make the plus 
<i>
lazy
</i>
 instead of greedy. Lazy quantifiers are sometimes also called "ungreedy" or "reluctant". You can do that by putting a question mark after the plus in the regex. You can do the same with the star, the curly braces and the question mark itself. So our example becomes 
<TT CLASS=code>
<SPAN CLASS="regexplain">
&lt;
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexplain">
&gt;
</SPAN>
</TT>
. Let's have another look inside the regex engine.</P>
 
<P>Again, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
&lt;
</SPAN>
</TT>
 matches the first 
<TT CLASS=match>
&lt;
</TT>
 in the string. The next token is the dot, this time repeated by a lazy plus. This tells the regex engine to repeat the dot as few times as possible. The minimum is one. So the engine matches the dot with 
<TT CLASS=match>
E
</TT>
. The requirement has been met, and the engine continues with 
<TT CLASS=code>
<SPAN CLASS="regexplain">
&gt;
</SPAN>
</TT>
 and 
<TT CLASS=string>
M
</TT>
. This fails. Again, the engine will 
<I>
backtrack
</I>
. But this time, the backtracking will force the lazy plus to expand rather than reduce its reach. So the match of 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 is expanded to 
<TT CLASS=match>
EM
</TT>
, and the engine tries again to continue with 
<TT CLASS=code>
<SPAN CLASS="regexplain">
&gt;
</SPAN>
</TT>
. Now, 
<TT CLASS=match>
&gt;
</TT>
 is matched successfully. The last token in the regex has been matched. The engine reports that 
<TT CLASS=match>
&lt;EM&gt;
</TT>
 has been successfully matched. That's more like it.</P>
 
<H2>An Alternative to Laziness</H2>
 
<P>In this case, there is a better option than making the plus lazy. We can use a greedy plus and a 
<A HREF="charclass.html" TARGET="_top">
negated character class
</A>
: 
<TT CLASS=code>
<SPAN CLASS="regexplain">
&lt;
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
&gt;
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexplain">
&gt;
</SPAN>
</TT>
. The reason why this is better is because of the backtracking. When using the lazy plus, the engine has to backtrack for each character in the HTML tag that it is trying to match. When using the negated character class, no backtracking occurs at all when the string contains valid HTML code. Backtracking slows down the regex engine. You will not notice the difference when doing a single search in a text editor. But you will save plenty of CPU cycles when using such a regex repeatedly in a tight loop in a script that you are writing, or perhaps in a custom syntax coloring scheme for 
<A HREF="editpadpro.html" TARGET="_top">
EditPad Pro
</A>
.</P>
 
<P>Only 
<A HREF="engine.html" TARGET="_top">
regex-directed engines
</A>
 backtrack. Text-directed engines don't and thus do not get the speed penalty. But they also do not support lazy quantifiers.</P>
 
<a name="qe">
</a>
<H2>Repeating \Q…\E Escape Sequences</h2>
 
<p>The 
<a href="characters.html#qe">
\Q…\E sequence
</a>
 escapes a string of characters, matching them as literal characters. The escaped characters are treated as individual characters. If you place a quantifier after the 
<tt>
\E
</tt>
, it will only be applied to the last character. E.g. if you apply 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
\Q
</SPAN>
<SPAN CLASS="regexplain">
*\d+*
</SPAN>
<SPAN CLASS="regexmeta">
\E
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 to 
<tt class=string>
*\d+**\d+*
</tt>
, the match will be 
<tt class=match>
*\d+**
</tt>
. Only the asterisk is repeated. Java 4 and 5 have a bug that causes the whole \Q…E sequence to be repeated, yielding the whole subject string as the match. This was fixed in Java 6.</p>

</DIV>
 
<div class=topad>
<A HREF="//www.regexbuddy.com/create.html" TARGET="_top">
</A>
</div>
 
<H1>
Use Parentheses for Grouping and Capturing
</h1>
 
<P>By placing part of a regular expression inside round brackets or parentheses, you can group that part of the regular expression together. This allows you to apply a 
<A HREF="repeat.html" TARGET="_top">
quantifier
</A>
 to the entire group or to restrict 
<A HREF="alternation.html" TARGET="_top">
alternation
</A>
 to part of the regex. 
<P>Only parentheses can be used for grouping. Square brackets define a 
<A HREF="charclass.html" TARGET="_top">
character class
</A>
, and curly braces are used by a 
<A HREF="repeat.html#limit">
quantifier with specific limits
</A>
.</P>
<H2>Parentheses Create Numbered Capturing Groups</H2>
 
<P>Besides grouping part of a regular expression together, parentheses also create a numbered capturing group. It stores the part of the string matched by the part of the regular expression inside the parentheses.</P>
 
<P>The regex 
<TT CLASS=code>
<SPAN CLASS="regexplain">
Set
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
Value
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
</TT>
 matches 
<TT CLASS=match>
Set
</TT>
 or 
<TT CLASS=match>
SetValue
</TT>
. In the first case, the first (and only) capturing group remains empty. In the second case, the first capturing group matches 
<TT CLASS=match>
Value
</TT>
.</P>
 
<a name="noncap">
</a>

<H2>Non-Capturing Groups</H2>
 
<P>If you do not need the group to capture its match, you can optimize this regular expression into 
<TT CLASS=code>
<SPAN CLASS="regexplain">
Set
</SPAN>
<SPAN CLASS="regexnest1">
(?:
</SPAN>
<SPAN CLASS="regexplain">
Value
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
</TT>
. The question mark and the colon after the opening parenthesis are the syntax that creates a non-capturing group. The question mark after the opening bracket is unrelated to the question mark at the end of the regex. The final question mark is the quantifier that makes the previous token 
<A HREF="optional.html" TARGET="_top">
optional
</A>
. This quantifier cannot appear after an opening parenthesis, because there is nothing to be made optional at the start of a group. Therefore, there is no ambiguity between the question mark as an operator to make a token optional and the question mark as part of the syntax for non-capturing groups, even though this may be confusing at first. There are other kinds of groups that use the 
<tt>
(?
</tt>
 syntax in combination with other characters than the colon that are explained later in this tutorial.</P>
 
<P><TT CLASS=code>
<SPAN CLASS="regexplain">
color=
</SPAN>
<SPAN CLASS="regexnest1">
(?:
</SPAN>
<SPAN CLASS="regexplain">
red
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
green
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
blue
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 is another regex with a non-capturing group. This regex has no quantifiers.</P>
 
<P>Regex flavors that support 
<A HREF="named.html" TARGET="_top">
named capture
</A>
 often have an option to 
<a href="named.html#number">
turn all unnamed groups into non-capturing groups
</a>
.</P>
<H2>Using Text Matched By Capturing Groups</H2>
 
<P>Capturing groups make it easy to extract part of the regex match. You can reuse the text inside the regular expression via a 
<A HREF="backref.html" TARGET="_top">
backreference
</A>
. Backreferences can also be used in replacement strings. Please check the 
<A HREF="replacebackref.html" TARGET="_top">
replacement text tutorial
</A>
 for details.</p>

</DIV>
 
<div class=topad>
<A HREF="//www.regexbuddy.com/create.html" TARGET="_top">
</A>
</div>
 
<H1>
Using Backreferences To Match The Same Text Again
</H1>
 
<P>Backreferences match the same text as previously matched by a capturing group. Suppose you want to match a pair of opening and closing HTML tags, and the text in between. By putting the opening tag into a backreference, we can reuse the name of the tag for the closing tag. Here's how: 
<TT CLASS=code>
<SPAN CLASS="regexplain">
&lt;
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
&gt;
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexplain">
&gt;
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexplain">
&lt;/
</SPAN>
<SPAN CLASS="regexspecial">
\1
</SPAN>
<SPAN CLASS="regexplain">
&gt;
</SPAN>
</TT>
. This regex contains only one pair of parentheses, which capture the string matched by 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
. This is the opening HTML tag. (Since HTML tags are case insensitive, this regex requires case insensitive matching.) The backreference 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\1
</SPAN>
</TT>
 (backslash one) references the first capturing group. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\1
</SPAN>
</TT>
 matches the exact same text that was matched by the first capturing group. The 
<TT CLASS=code>
<SPAN CLASS="regexplain">
/
</SPAN>
</TT>
 before it is a literal character. It is simply the forward slash in the closing HTML tag that we are trying to match.</P>
 
<P>To figure out the number of a particular backreference, scan the regular expression from left to right. Count the opening parentheses of all the numbered capturing groups. The first parenthesis starts backreference number one, the second number two, etc. Skip parentheses that are part of other syntax such as non-capturing groups. This means that non-capturing parentheses have another benefit: you can insert them into a regular expression without changing the numbers assigned to the backreferences. This can be very useful when modifying a complex regular expression.</P>
 
<P>You can reuse the same backreference more than once. 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
c
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
x
</SPAN>
<SPAN CLASS="regexspecial">
\1
</SPAN>
<SPAN CLASS="regexplain">
x
</SPAN>
<SPAN CLASS="regexspecial">
\1
</SPAN>
</TT>
 matches 
<TT CLASS=match>
axaxa
</TT>
, 
<TT CLASS=match>
bxbxb
</TT>
 and 
<TT CLASS=match>
cxcxc
</TT>
.</P>
 
<p>Most regex flavors support up to 99 capturing groups and double-digit backreferences. So 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\99
</SPAN>
</TT>
 is a valid backreference if your regex has 99 capturing groups.</p>
<H2>Looking Inside The Regex Engine</h2>
 
<P>Let's see how the regex engine applies the regex 
<TT CLASS=code>
<SPAN CLASS="regexplain">
&lt;
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
&gt;
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexplain">
&gt;
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexplain">
&lt;/
</SPAN>
<SPAN CLASS="regexspecial">
\1
</SPAN>
<SPAN CLASS="regexplain">
&gt;
</SPAN>
</TT>
 to the string 
<TT CLASS=string>
Testing &lt;B&gt;&lt;I&gt;bold italic&lt;/I&gt;&lt;/B&gt; text
</TT>
. The first token in the regex is the literal 
<TT CLASS=code>
<SPAN CLASS="regexplain">
&lt;
</SPAN>
</TT>
. The regex engine traverses the string until it can match at the first 
<TT CLASS=match>
&lt;
</TT>
 in the string. The next token is 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
. The regex engine also takes note that it is now inside the first pair of capturing parentheses. 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 matches 
<TT CLASS=match>
B
</TT>
. The engine advances to 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 and 
<TT CLASS=string>
&gt;
</TT>
. This match fails. However, because of the 
<A HREF="repeat.html" TARGET="_top">
star
</A>
, that's perfectly fine. The position in the string remains at 
<TT CLASS=string>
&gt;
</TT>
. The 
<A HREF="wordboundaries.html" TARGET="_top">
word boundary
</A>
 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 matches at the 
<TT CLASS=string>
&gt;
</TT>
 because it is preceded by 
<TT CLASS=string>
B
</TT>
. The word boundary does not make the engine advance through the string. The position in the regex is advanced to 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
&gt;
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
.</P>
 
<P>This step crosses the closing bracket of the first pair of capturing parentheses. This prompts the regex engine to store what was matched inside them into the first backreference. In this case, 
<TT CLASS=match>
B
</TT>
 is stored.</P>
 
<P>After storing the backreference, the engine proceeds with the match attempt. 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
&gt;
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 does not match 
<TT CLASS=match>
&gt;
</TT>
. Again, because of another star, this is not a problem. The position in the string remains at 
<TT CLASS=string>
&gt;
</TT>
, and position in the regex is advanced to 
<TT CLASS=code>
<SPAN CLASS="regexccliteral">
&gt;
</SPAN>
</TT>
. These obviously match. The next token is a dot, repeated by a lazy star. Because of the laziness, the regex engine initially skips this token, taking note that it should backtrack in case the remainder of the regex fails.</P>
 
<P>The engine has now arrived at the second 
<TT CLASS=code>
<SPAN CLASS="regexplain">
&lt;
</SPAN>
</TT>
 in the regex, and the second 
<TT CLASS=string>
&lt;
</TT>
 in the string. These match. The next token is 
<TT CLASS=code>
<SPAN CLASS="regexplain">
/
</SPAN>
</TT>
. This does not match 
<TT CLASS=string>
I
</TT>
, and the engine is forced to backtrack to the dot. The dot matches the second 
<TT CLASS=match>
&lt;
</TT>
 in the string. The star is still lazy, so the engine again takes note of the available backtracking position and advances to 
<TT CLASS=code>
<SPAN CLASS="regexplain">
&lt;
</SPAN>
</TT>
 and 
<TT CLASS=string>
I
</TT>
. These do not match, so the engine again backtracks.</P>
 
<P>The backtracking continues until the dot has consumed 
<TT CLASS=match>
&lt;I&gt;bold italic
</TT>
. At this point, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
&lt;
</SPAN>
</TT>
 matches the third 
<TT CLASS=match>
&lt;
</TT>
 in the string, and the next token is 
<TT CLASS=code>
<SPAN CLASS="regexplain">
/
</SPAN>
</TT>
 which matches 
<TT CLASS=match>
/
</TT>
. The next token is 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\1
</SPAN>
</TT>
. Note that the token is the backreference, and not 
<TT CLASS=code>
<SPAN CLASS="regexplain">
B
</SPAN>
</TT>
. The engine does not substitute the backreference in the regular expression. Every time the engine arrives at the backreference, it reads the value that was stored. This means that if the engine had backtracked beyond the first pair of capturing parentheses before arriving the second time at 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\1
</SPAN>
</TT>
, the new value stored in the first backreference would be used. But this did not happen here, so 
<TT CLASS=match>
B
</TT>
 it is. This fails to match at 
<TT CLASS=string>
I
</TT>
, so the engine backtracks again, and the dot consumes the third 
<TT CLASS=string>
&lt;
</TT>
 in the string.</P>
 
<P>Backtracking continues again until the dot has consumed 
<TT CLASS=match>
&lt;I&gt;bold italic&lt;/I&gt;
</TT>
. At this point, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
&lt;
</SPAN>
</TT>
 matches 
<TT CLASS=match>
&lt;
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexplain">
/
</SPAN>
</TT>
 matches 
<TT CLASS=match>
/
</TT>
. The engine arrives again at 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\1
</SPAN>
</TT>
. The backreference still holds 
<TT CLASS=match>
B
</TT>
. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\1
</SPAN>
</TT>
 matches 
<TT CLASS=match>
B
</TT>
. The last token in the regex, 
<TT CLASS=code>
<SPAN CLASS="regexccliteral">
&gt;
</SPAN>
</TT>
 matches 
<TT CLASS=match>
&gt;
</TT>
. A complete match has been found: 
<TT CLASS=match>
&lt;B&gt;&lt;I&gt;bold italic&lt;/I&gt;&lt;/B&gt;
</TT>
.</P>
<H2>Backtracking Into Capturing Groups</h2>
 
<p>You may have wondered about the word boundary 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 in the 
<TT CLASS=code>
<SPAN CLASS="regexplain">
&lt;
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
&gt;
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexplain">
&gt;
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexplain">
&lt;/
</SPAN>
<SPAN CLASS="regexspecial">
\1
</SPAN>
<SPAN CLASS="regexplain">
&gt;
</SPAN>
</TT>
 mentioned above. This is to make sure the regex won't match incorrectly paired tags such as 
<tt class=string>
&lt;boo>
bold&lt;/b>
</tt>
. You may think that cannot happen because the capturing group matches 
<tt class=match>
boo
</tt>
 which causes 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\1
</SPAN>
</TT>
 to try to match the same, and fail. That is indeed what happens. But then the regex engine backtracks.</p>
 
<p>Let's take the regex 
<TT CLASS=code>
<SPAN CLASS="regexplain">
&lt;
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
&gt;
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexplain">
&gt;
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexplain">
&lt;/
</SPAN>
<SPAN CLASS="regexspecial">
\1
</SPAN>
<SPAN CLASS="regexplain">
&gt;
</SPAN>
</TT>
 without the word boundary and look inside the regex engine at the point where 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\1
</SPAN>
</TT>
 fails the first time. First, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
</TT>
 continues to expand until it has reached the end of the string, and 
<TT CLASS=code>
<SPAN CLASS="regexplain">
&lt;/
</SPAN>
<SPAN CLASS="regexspecial">
\1
</SPAN>
<SPAN CLASS="regexplain">
&gt;
</SPAN>
</TT>
 has failed to match each time 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
</TT>
 matched one more character.</p>
 
<p>Then the regex engine backtracks into the capturing group. 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
 has matched 
<tt class=match>
oo
</tt>
, but would just as happily match 
<tt class=match>
o
</tt>
 or nothing at all. When backtracking, 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
 is forced to give up one character. The regex engine continues, exiting the capturing group a second time. Since [A-Z][A-Z0-9]* has now matched 
<tt class=match>
bo
</tt>
, that is what is stored into the capturing group, overwriting 
<tt class=match>
boo
</tt>
 that was stored before. 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
&gt;
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
 matches the second 
<tt class=match>
o
</tt>
 in the opening tag. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
&gt;
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexplain">
&lt;/
</SPAN>
</TT>
 matches 
<tt class=match>
&gt;bold&lt;
</tt>
. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\1
</SPAN>
</TT>
 fails again.</p>
 
<p>The regex engine does all the same backtracking once more, until 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
 is forced to give up another character, causing it to match nothing, which the 
<A HREF="repeat.html" TARGET="_top">
star
</A>
 allows. The capturing group now stores just 
<tt class=match>
b
</tt>
. 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
&gt;
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
 now matches 
<tt class=match>
oo
</tt>
. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
&gt;
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexplain">
&lt;/
</SPAN>
</TT>
 once again matches 
<tt class=match>
&gt;bold&lt;
</tt>
. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\1
</SPAN>
</TT>
 now succeeds, as does 
<TT CLASS=code>
<SPAN CLASS="regexccliteral">
&gt;
</SPAN>
</TT>
 and an overall match is found. But not the one we wanted.</p>
 
<p>There are several solutions to this. One is to use the word boundary. When 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
 backtracks the first time, reducing the capturing group to 
<tt class=match>
bo
</tt>
, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 fails to match between 
<tt class=string>
o
</tt>
 and 
<tt class=string>
o
</tt>
. This forces 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
 to backtrack again immediately. The capturing group is reduced to 
<tt class=match>
b
</tt>
 and the word boundary fails between 
<tt class=string>
b
</tt>
 and 
<tt class=string>
o
</tt>
. There are no further backtracking positions, so the whole match attempt fails.</p>
 
<p>The reason we need the word boundary is that we're using 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
&gt;
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
 to skip over any attributes in the tag. If your paired tags never have any attributes, you can leave that out, and use 
<TT CLASS=code>
<SPAN CLASS="regexplain">
&lt;
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
&gt;
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexplain">
&lt;/
</SPAN>
<SPAN CLASS="regexspecial">
\1
</SPAN>
<SPAN CLASS="regexplain">
&gt;
</SPAN>
</TT>
. Each time 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
 backtracks, the 
<TT CLASS=code>
<SPAN CLASS="regexplain">
&gt;
</SPAN>
</TT>
 that follows it fails to match, quickly ending the match attempt.</p>
 
<p>If you don't want the regex engine to backtrack into capturing groups, you can use an atomic group. The tutorial section on 
<A HREF="atomic.html" TARGET="_top">
atomic grouping
</A>
 has all the details.</p>
 
<A NAME="repeat">
</A>

<H2>Repetition and Backreferences</H2>
 
<P>As I mentioned in the above inside look, the regex engine does not permanently substitute backreferences in the regular expression. It will use the last match saved into the backreference each time it needs to be used. If a new match is found by capturing parentheses, the previously saved match is overwritten. There is a 
<A HREF="captureall.html" TARGET="_top">
clear difference
</A>
 between 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
abc
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
abc
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
. Though both successfully match 
<TT CLASS=match>
cab
</TT>
, the first regex will put 
<TT CLASS=match>
cab
</TT>
 into the first backreference, while the second regex will only store 
<TT CLASS=match>
b
</TT>
. That is because in the second regex, the plus caused the pair of parentheses to repeat three times. The first time, 
<TT CLASS=match>
c
</TT>
 was stored. The second time, 
<TT CLASS=match>
a
</TT>
, and the third time 
<TT CLASS=match>
b
</TT>
. Each time, the previous value was overwritten, so 
<TT CLASS=match>
b
</TT>
 remains.</P>
 
<P>This also means that 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
abc
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
=
</SPAN>
<SPAN CLASS="regexspecial">
\1
</SPAN>
</TT>
 will match 
<TT CLASS=match>
cab=cab
</TT>
, and that 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
abc
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexplain">
=
</SPAN>
<SPAN CLASS="regexspecial">
\1
</SPAN>
</TT>
 will not. The reason is that when the engine arrives at 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\1
</SPAN>
</TT>
, it holds 
<TT CLASS=code>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
 which fails to match 
<TT CLASS=string>
c
</TT>
. Obvious when you look at a simple example like this one, but a common cause of difficulty with regular expressions nonetheless. When using backreferences, always double check that you are really capturing what you want.</P>
 
<H2>Useful Example: Checking for Doubled Words</H2>
 
<P>When editing text, doubled words such as "the the" easily creep in. Using the regex 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\s
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexspecial">
\1
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 in your 
<A HREF="editpadpro.html" TARGET="_top">
text editor
</A>
, you can easily find them. To delete the second word, simply type in 
<TT CLASS=string>
\1
</TT>
 as the replacement text and click the Replace button.</P>
 
<H2>Parentheses and Backreferences Cannot Be Used Inside Character Classes</H2>
 
<P>Parentheses cannot be used inside 
<A HREF="charclass.html" TARGET="_top">
character classes
</A>
, at least not as metacharacters. When you put a parenthesis in a character class, it is treated as a literal character. So the regex 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
(a)b
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 matches 
<TT CLASS=match>
a
</TT>
, 
<TT CLASS=match>
b
</TT>
, 
<TT CLASS=match>
(
</TT>
, and 
<TT CLASS=match>
)
</TT>
.</P>
 
<P>Backreferences, too, cannot be used inside a character class. The \1 in a regex like 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
\1
</SPAN>
<SPAN CLASS="regexccliteral">
b
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 is either an error or a needlessly escaped literal 1. In 
<A HREF="javascript.html" TARGET="_top">
JavaScript
</A>
 it's an 
<a href="nonprint.html#octal">
octal escape
</a>
.</P>

</DIV>
 
<div class=topad>
<A HREF="//www.regexbuddy.com/create.html" TARGET="_top">
</A>
</div>
 
<H1>
Backreferences to Failed Groups
</H1>
 
<p>The previous topic on 
<A HREF="backref.html" TARGET="_top">
backreferences
</A>
 applies to all regex flavors, except those few that don't support backreferences at all. Flavors behave differently when you start doing things that don't fit the "match the text matched by a previous capturing group" job description.</p>
 
<p>There is a difference between a backreference to a capturing group that matched nothing, and one to a capturing group that did not participate in the match at all. The regex 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
q
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
<SPAN CLASS="regexspecial">
\1
</SPAN>
</TT>
 matches 
<tt class=match>
b
</tt>
. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
q
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
</TT>
 is optional and matches nothing, causing 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
q
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 to successfully match and capture nothing. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
 matches 
<tt class=match>
b
</tt>
 and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\1
</SPAN>
</TT>
 successfully matches the nothing captured by the group.</p>
 
<p>In most flavors, the regex 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
q
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
<SPAN CLASS="regexspecial">
\1
</SPAN>
</TT>
 fails to match 
<tt class=string>
b
</tt>
. 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
q
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 fails to match at all, so the group never gets to capture anything at all. Because the whole group is optional, the engine does proceed to match 
<TT CLASS=code>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
. The engine now arrives at 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\1
</SPAN>
</TT>
 which references a group that did not participate in the match attempt at all. This causes the backreference to fail to match at all, mimicking the result of the group. Since there's no 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
?
</SPAN>
</TT>
 making 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\1
</SPAN>
</TT>
 optional, the overall match attempt fails.</p>
 
<p>One of the few exceptions is 
<A HREF="javascript.html" TARGET="_top">
JavaScript
</A>
. According to the official ECMA standard, a backreference to a non-participating capturing group must successfully match nothing just like a backreference to a participating group that captured nothing does. In other words, in JavaScript, 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
q
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
<SPAN CLASS="regexspecial">
\1
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
q
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
<SPAN CLASS="regexspecial">
\1
</SPAN>
</TT>
 both match 
<tt class=match>
b
</tt>
. 
<A HREF="xpath.html" TARGET="_top">
XPath
</A>
 also works this way.</p>
 
<p>Dinkumware's implementation of 
<A HREF="stdregex.html" TARGET="_top">
std::regex
</A>
 handles backreferences like JavaScript for all its grammars that support backreferences. 
<A HREF="boost.html" TARGET="_top">
Boost
</A>
 did so too until version 1.46. As of version 1.47, Boost fails backreferences to non-participating groups when using the ECMAScript grammar, but still lets them successfully match nothing when using the basic and grep grammars.</p>
 
<a name="invalid">
</a>

<H2>Backreferences to Non-Existent Capturing Groups</H2>
 
<p>Backreferences to groups that do not exist, such as 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
one
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexerr">
\7
</SPAN>
</TT>
, are an error in most regex flavors. There are exceptions though. 
<A HREF="javascript.html" TARGET="_top">
JavaScript
</A>
 treats 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\1
</SPAN>
</TT>
 through 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\7
</SPAN>
</TT>
 as 
<a href="characters.html#octal">
octal escapes
</a>
 when there are fewer capturing groups in the regex than the digit after the backslash. 
<TT CLASS=code>
<SPAN CLASS="regexescaped">
\8
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexescaped">
\9
</SPAN>
</TT>
 are an error because 8 and 9 are not valid octal digits.</p>
 
<p><A HREF="java.html" TARGET="_top">
Java
</A>
 treats backreferences to groups that don't exist as backreferences to groups that exist but never participate in the match. They are not an error, but simply never match anything.</p>
 
<p><A HREF="dotnet.html" TARGET="_top">
.NET
</A>
 is a little more complicated. .NET supports single-digit and double-digit backreferences as well as double-digit octal escapes without a leading zero. Backreferences trump octal escapes. So 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\12
</SPAN>
</TT>
 is a line feed (octal 12 = decimal 10) in a regex with fewer than 12 capturing groups. It would be a backreference to the 12th group in a regex with 12 or more capturing groups. .NET does not support single-digit octal escapes. So 
<TT CLASS=code>
<SPAN CLASS="regexerr">
\7
</SPAN>
</TT>
 is an error in a regex with fewer than 7 capturing groups.</p>
 
<a name="forward">
</a>

<H2>Forward References</H2>
 
<p>Many modern regex flavors, including 
<A HREF="jgsoft.html" TARGET="_top">
JGsoft
</A>
, 
<A HREF="dotnet.html" TARGET="_top">
.NET
</A>
, 
<A HREF="java.html" TARGET="_top">
Java
</A>
, 
<A HREF="perl.html" TARGET="_top">
Perl
</A>
, 
<A HREF="pcre.html" TARGET="_top">
PCRE
</A>
, 
<A HREF="php.html" TARGET="_top">
PHP
</A>
, 
<A HREF="delphi.html" TARGET="_top">
Delphi
</A>
, and 
<A HREF="ruby.html" TARGET="_top">
Ruby
</A>
 allow forward references. They allow you to use a backreference to a group that appears later in the regex. Forward references are obviously only useful if they're inside a repeated group. Then there can be situations in which the regex engine evaluates the backreference after the group has already matched. Before the group is attempted, the backreference fails like a backreference to a failed group does.</p>
 
<p>If forward references are supported, the regex 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexspecial">
\2
</SPAN>
<SPAN CLASS="regexplain">
two
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexplain">
one
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 matches 
<tt class=match>
oneonetwo
</tt>
. At the start of the string, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\2
</SPAN>
</TT>
 fails. Trying the other 
<A HREF="alternation.html" TARGET="_top">
alternative
</A>
, 
<tt class=match>
one
</tt>
 is matched by the second capturing group, and subsequently by the first group. The first group is then repeated. This time, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\2
</SPAN>
</TT>
 matches 
<tt class=match>
one
</tt>
 as captured by the second group. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
two
</SPAN>
</TT>
 then matches 
<tt class=match>
two
</tt>
. With two repetitions of the first group, the regex has matched the whole subject string.</p>
 
<p><A HREF="javascript.html" TARGET="_top">
JavaScript
</A>
 does not support forward references, but does not treat them as an error. In JavaScript, forward references always find a zero-length match, just as backreferences to non-participating groups do in JavaScript. Because this is not particularly useful, 
<A HREF="xregexp.html" TARGET="_top">
XRegExp
</A>
 makes them an error. In 
<A HREF="stdregex.html" TARGET="_top">
std::regex
</A>
, 
<A HREF="boost.html" TARGET="_top">
Boost
</A>
, 
<A HREF="python.html" TARGET="_top">
Python
</A>
, 
<A HREF="tcl.html" TARGET="_top">
Tcl
</A>
, and 
<A HREF="vbscript.html" TARGET="_top">
VBScript
</A>
 forward references are an error.</p>
 
<a name="nested">
</a>

<H2>Nested References</H2>
 
<p>A nested reference is a backreference inside the capturing group that it references. Like forward references, nested references are only useful if they're inside a repeated group, as in 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexspecial">
\1
</SPAN>
<SPAN CLASS="regexplain">
two
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexplain">
one
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
. When nested references are supported, this regex also matches 
<tt class=match>
oneonetwo
</tt>
. At the start of the string, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\1
</SPAN>
</TT>
 fails. Trying the other 
<A HREF="alternation.html" TARGET="_top">
alternative
</A>
, 
<tt class=match>
one
</tt>
 is matched by the second capturing group, and subsequently by the first group. The first group is then repeated. This time, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\1
</SPAN>
</TT>
 matches 
<tt class=match>
one
</tt>
 as captured by the last iteration of the first group. It doesn't matter that the regex engine has re-entered the first group. The text matched by the group was stored into the backreference when the group was previously exited. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
two
</SPAN>
</TT>
 then matches 
<tt class=match>
two
</tt>
. With two repetitions of the first group, the regex has matched the whole subject string. If you retrieve the text from the capturing groups after the match, the first group stores 
<tt class=match>
onetwo
</tt>
 while the second group captured the first occurrence of 
<tt class=match>
one
</tt>
 in the string.</p>
 
<P>The 
<A HREF="jgsoft.html" TARGET="_top">
JGsoft
</A>
, 
<A HREF="dotnet.html" TARGET="_top">
.NET
</A>
, 
<A HREF="java.html" TARGET="_top">
Java
</A>
, 
<A HREF="perl.html" TARGET="_top">
Perl
</A>
, and 
<A HREF="vbscript.html" TARGET="_top">
VBScript
</A>
 flavors all support nested references. 
<A HREF="pcre.html" TARGET="_top">
PCRE
</A>
 does too, but had bugs with backtracking into capturing groups with nested backreferences. Instead of fixing the bugs, PCRE 8.01 worked around them by forcing capturing groups with nested references to be 
<A HREF="atomic.html" TARGET="_top">
atomic
</A>
. So in PCRE, 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexspecial">
\1
</SPAN>
<SPAN CLASS="regexplain">
two
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexplain">
one
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 is the same as 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?&gt;
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexspecial">
\1
</SPAN>
<SPAN CLASS="regexplain">
two
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexnest3">
(
</SPAN>
<SPAN CLASS="regexplain">
one
</SPAN>
<SPAN CLASS="regexnest3">
)
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
. This affects languages with regex engines based on PCRE, such as 
<A HREF="php.html" TARGET="_top">
PHP
</A>
, 
<A HREF="delphi.html" TARGET="_top">
Delphi
</A>
, and 
<A HREF="rlanguage.html" TARGET="_top">
R
</A>
.</P>
 
<p><A HREF="javascript.html" TARGET="_top">
JavaScript
</A>
 and 
<A HREF="ruby.html" TARGET="_top">
Ruby
</A>
 do not support nested references, but treat them as backreferences to non-participating groups instead of as errors. In JavaScript that means they always match a zero-length string, while in Ruby they always fail to match. In 
<A HREF="stdregex.html" TARGET="_top">
std::regex
</A>
, 
<A HREF="boost.html" TARGET="_top">
Boost
</A>
, 
<A HREF="python.html" TARGET="_top">
Python
</A>
, and 
<A HREF="tcl.html" TARGET="_top">
Tcl
</A>
, nested references are an error.</p>
 

</DIV>
 
<div class=topad>
<A HREF="//www.regexbuddy.com/create.html" TARGET="_top">
</A>
</div>
 
<H1>
Named Capturing Groups and Backreferences
</h1>
 
<P>Nearly all modern regular expression engines support 
<A HREF="brackets.html" TARGET="_top">
numbered capturing groups
</A>
 and 
<A HREF="backref.html" TARGET="_top">
numbered backreferences
</A>
. Long regular expressions with lots of groups and backreferences may be hard to read. They can be particularly difficult to maintain as adding or removing a capturing group in the middle of the regex upsets the numbers of all the groups that follow the added or removed group.</P>
 
<p><A HREF="python.html" TARGET="_top">
Python's re module
</A>
 was the first to offer a solution: named capturing groups and named backreferences. 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?P&lt;name&gt;
</SPAN>
<SPAN CLASS="regexplain">
group
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 captures the match of 
<TT CLASS=code>
<SPAN CLASS="regexplain">
group
</SPAN>
</TT>
 into the backreference "name". 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
name
</SPAN>
</TT>
 must be an alphanumeric sequence starting with a letter. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
group
</SPAN>
</TT>
 can be any regular expression. You can reference the contents of the group with the named backreference 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
(?P=name)
</SPAN>
</TT>
. The question mark, P, angle brackets, and equals signs are all part of the syntax. Though the syntax for the named backreference uses parentheses, it's just a backreference that doesn't do any capturing or grouping. The 
<A HREF="backref.html" TARGET="_top">
HTML tags example
</A>
 can be written as 
<TT CLASS=code>
<SPAN CLASS="regexplain">
&lt;
</SPAN>
<SPAN CLASS="regexnest1">
(?P&lt;tag&gt;
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
&gt;
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexplain">
&gt;
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexplain">
&lt;/
</SPAN>
<SPAN CLASS="regexspecial">
(?P=tag)
</SPAN>
<SPAN CLASS="regexplain">
&gt;
</SPAN>
</TT>
.</P>
 
<P>The 
<A HREF="dotnet.html" TARGET="_top">
.NET framework
</A>
 also supports named capture. Microsoft's developers invented their own syntax, rather than follow the one pioneered by Python and copied by PCRE (the only two regex engines that supported named capture at that time). 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?&lt;name&gt;
</SPAN>
<SPAN CLASS="regexplain">
group
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?'name'
</SPAN>
<SPAN CLASS="regexplain">
group
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 captures the match of 
<TT CLASS=code>
<SPAN CLASS="regexplain">
group
</SPAN>
</TT>
 into the backreference "name". The named backreference is 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\k&lt;name&gt;
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\k'name'
</SPAN>
</TT>
. Compared with Python, there is no P in the syntax for named groups. The syntax for named backreferences is more similar to that of numbered backreferences than to what Python uses. You can use single quotes or angle brackets around the name. This makes absolutely no difference in the regex. You can use both styles interchangeably. The syntax using angle brackets is preferable in programming languages that use single quotes to delimit strings, while the syntax using single quotes is preferable when adding your regex to an XML file, as this minimizes the amount of escaping you have to do to format your regex as a literal string or as XML content.</P>
 
<p>Because Python and .NET introduced their own syntax, we refer to these two variants as the "Python syntax" and the ".NET syntax" for named capture and named backreferences. Today, many other regex flavors have copied this syntax.</p>
 
<p><A HREF="perl.html" TARGET="_top">
Perl 5.10
</A>
 added support for both the Python and .NET syntax for named capture and backreferences. It also adds two more syntactic variants for named backreferences: 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\k{one}
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\g{two}
</SPAN>
</TT>
. There's no difference between the five syntaxes for named backreferences in Perl. All can be used interchangeably. In the replacement text, you can interpolate the variable 
<tt class=code>
$+{name}
</tt>
 to insert the text matched by a named capturing group.</p>
 
<p><A HREF="pcre.html" TARGET="_top">
PCRE 7.2
</A>
 and later support all the syntax for named capture and backreferences that Perl 5.10 supports. Old versions of PCRE supported the Python syntax, even though that was not "Perl-compatible" at the time. Languages like 
<A HREF="php.html" TARGET="_top">
PHP
</A>
, 
<A HREF="delphi.html" TARGET="_top">
Delphi
</A>
, and 
<A HREF="rlanguage.html" TARGET="_top">
R
</A>
 that implement their regex support using PCRE also support all this syntax. Unfortunately, neither PHP or R support named references in the replacement text. You'll have to use numbered references to the named groups. PCRE does not support search-and-replace at all.</p>
 
<p><A HREF="java.html" TARGET="_top">
Java 7
</A>
 and 
<A HREF="xregexp.html" TARGET="_top">
XRegExp
</A>
 copied the .NET syntax, but only the variant with angle brackets. 
<A HREF="ruby.html" TARGET="_top">
Ruby 1.9
</A>
 and supports both variants of the .NET syntax. The 
<A HREF="jgsoft.html" TARGET="_top">
JGsoft flavor
</A>
 supports the Python syntax and both variants of the .NET syntax.</p>
 
<a name="boost">
</a>
<p><A HREF="boost.html" TARGET="_top">
Boost 1.42
</A>
 and later support named capturing groups using the .NET syntax with angle brackets or quotes and named backreferences using the 
<tt>
\g
</tt>
 syntax with curly braces from Perl 5.10. Boost 1.47 additionally supports backreferences using the 
<tt>
\k
</tt>
 syntax with angle brackets and quotes from .NET. Boost 1.47 allowed these variants to multiply. Boost 1.47 allows named and numbered backreferences to be specified with 
<tt>
\g
</tt>
 or 
<tt>
\k
</tt>
 and with curly braces, angle brackets, or quotes. So Boost 1.47 and later have six variations of the backreference syntax on top of the basic 
<tt>
\1
</tt>
 syntax. This puts Boost in conflict with Ruby, PCRE, PHP, R, and JGsoft which treat 
<tt>
\g
</tt>
 with angle brackets or quotes as a 
<A HREF="subroutine.html" TARGET="_top">
subroutine call
</A>
.</p>
 
<a name="number">
</a>

<H2>Numbers for Named Capturing Groups</H2>
 
<p>Mixing named and numbered capturing groups is not recommended because flavors are inconsistent in how the groups are numbered. If a group doesn't need to have a name, make it non-capturing using the 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?:
</SPAN>
<SPAN CLASS="regexplain">
group
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 syntax. In .NET you can make all unnamed groups non-capturing by setting 
<tt class=code>
RegexOptions.ExplicitCapture
</tt>
. In 
<A HREF="delphi.html" TARGET="_top">
Delphi
</A>
, set 
<tt>
roExplicitCapture
</tt>
. With 
<A HREF="xregexp.html" TARGET="_top">
XRegExp
</A>
, use the 
<tt>
/n
</tt>
 flag. 
<A HREF="perl.html" TARGET="_top">
Perl
</A>
 supports 
<tt>
/n
</tt>
 starting with Perl 5.22. With 
<A HREF="pcre.html" TARGET="_top">
PCRE
</A>
, set 
<tt>
PCRE_NO_AUTO_CAPTURE
</tt>
. The 
<A HREF="jgsoft.html" TARGET="_top">
JGsoft flavor
</A>
 and .NET support the 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
n
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
</TT>
 
<A HREF="modifiers.html" TARGET="_top">
mode modifier
</A>
. If you make all unnamed groups non-capturing, you can skip this section and save yourself a headache.</p>
 
<p>Most flavors number both named and unnamed capturing groups by counting their opening parentheses from left to right. Adding a named capturing group to an existing regex still upsets the numbers of the unnamed groups. In .NET, however, unnamed capturing groups are assigned numbers first, counting their opening parentheses from left to right, skipping all named groups. After that, named groups are assigned the numbers that follow by counting the opening parentheses of the named groups from left to right.</p>
 
<p>The 
<A HREF="jgsoft.html" TARGET="_top">
JGsoft regex engine
</A>
 copied the Python and the .NET syntax at a time when only Python and PCRE used the Python syntax, and only .NET used the .NET syntax. Therefore it also copied the numbering behavior of both Python and .NET, so that regexes intended for Python and .NET would keep their behavior. It numbers Python-style named groups along unnamed ones, like Python does. It numbers .NET-style named groups afterward, like .NET does. These rules apply even when you mix both styles in the same regex.</p>
 
<P>As an example, the regex 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexnest1">
(?P&lt;x&gt;
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
c
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexnest1">
(?P&lt;y&gt;
</SPAN>
<SPAN CLASS="regexplain">
d
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 matches 
<TT CLASS=match>
abcd
</TT>
 as expected. If you do a search-and-replace with this regex and the replacement 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\1
</SPAN>
<SPAN CLASS="regexspecial">
\2
</SPAN>
<SPAN CLASS="regexspecial">
\3
</SPAN>
<SPAN CLASS="regexspecial">
\4
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
$1
</SPAN>
<SPAN CLASS="regexspecial">
$2
</SPAN>
<SPAN CLASS="regexspecial">
$3
</SPAN>
<SPAN CLASS="regexspecial">
$4
</SPAN>
</TT>
 (depending on the flavor), you will get 
<TT CLASS=string>
abcd
</TT>
. All four groups were numbered from left to right, from one till four.</P>
 
<P>Things are a bit more complicated with the .NET framework. The regex 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexnest1">
(?&lt;x&gt;
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
c
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexnest1">
(?&lt;y&gt;
</SPAN>
<SPAN CLASS="regexplain">
d
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 again matches 
<TT CLASS=match>
abcd
</TT>
. However, if you do a search-and-replace with 
<TT CLASS=string>
$1$2$3$4
</TT>
 as the replacement, you will get 
<TT CLASS=string>
acbd
</TT>
. First, the unnamed groups 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
c
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 got the numbers 1 and 2. Then the named groups "x" and "y" got the numbers 3 and 4.</P>
 
<P>In all other flavors that copied the .NET syntax the regex 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexnest1">
(?&lt;x&gt;
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
c
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexnest1">
(?&lt;y&gt;
</SPAN>
<SPAN CLASS="regexplain">
d
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 still matches 
<TT CLASS=match>
abcd
</TT>
. But in all those flavors, except the JGsoft flavor, the replacement 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\1
</SPAN>
<SPAN CLASS="regexspecial">
\2
</SPAN>
<SPAN CLASS="regexspecial">
\3
</SPAN>
<SPAN CLASS="regexspecial">
\4
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
$1
</SPAN>
<SPAN CLASS="regexspecial">
$2
</SPAN>
<SPAN CLASS="regexspecial">
$3
</SPAN>
<SPAN CLASS="regexspecial">
$4
</SPAN>
</TT>
 (depending on the flavor) gets you 
<TT CLASS=string>
abcd
</TT>
. All four groups were numbered from left to right.</P>
 
<p>In 
<A HREF="powergrep.html" TARGET="_top">
PowerGREP
</A>
, which uses the JGsoft flavor, named capturing groups play a special role. Groups with the same name are shared between all regular expressions and replacement texts in the same PowerGREP action. This allows captured by a named capturing group in one part of the action to be referenced in a later part of the action. Because of this, PowerGREP does not allow numbered references to named capturing groups at all. When mixing named and numbered groups in a regex, the numbered groups are still numbered following the Python and .NET rules, like the JGsoft flavor always does.</p>
 
<a name="duplicate">
</a>

<H2>Multiple Groups with The Same Name</H2>
 
<p>The 
<A HREF="dotnet.html" TARGET="_top">
.NET framework
</A>
 and the 
<A HREF="jgsoft.html" TARGET="_top">
JGsoft flavor
</A>
 allow multiple groups in the regular expression to have the same name. All groups with the same name share the same storage for the text they match. Thus, a backreference to that name matches the text that was matched by the group with that name that most recently captured something. A reference to the name in the replacement text inserts the text matched by the group with that name that was the last one to capture something.</p>
 
<p><A HREF="perl.html" TARGET="_top">
Perl
</A>
 and 
<A HREF="ruby.html" TARGET="_top">
Ruby
</A>
 also allow groups with the same name. But these flavors only use smoke and mirrors to make it look like the all the groups with the same name act as one. In reality, the groups are separate. In Perl, a backreference matches the text captured by the leftmost group in the regex with that name that matched something. In Ruby, a backreference matches the text captured by any of the groups with that name. Backtracking makes Ruby try all the groups.</p>
 
<p>So in Perl and Ruby, you can only meaningfully use groups with the same name if they are in separate alternatives in the regex, so that only one of the groups with that name could ever capture any text. Then backreferences to that group sensibly match the text captured by the group.</p>
 
<p>For example, if you want to match "a" followed by a digit 0..5, or "b" followed by a digit 4..7, and you only care about the digit, you could use the regex 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest1">
(?&lt;digit&gt;
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
5
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
<SPAN CLASS="regexnest1">
(?&lt;digit&gt;
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
4
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
7
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
. In these four flavors, the group named "digit" will then give you the digit 0..7 that was matched, regardless of the letter. If you want this match to be followed by c and the exact same digit, you could use 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?:
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest2">
(?&lt;digit&gt;
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
5
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
<SPAN CLASS="regexnest2">
(?&lt;digit&gt;
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
4
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
7
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
c
</SPAN>
<SPAN CLASS="regexspecial">
\k&lt;digit&gt;
</SPAN>
</TT></p>
 
<p>PCRE does not allow duplicate named groups by default. PCRE 6.7 and later allow them if you turn on that option or use the 
<A HREF="modifiers.html" TARGET="_top">
mode modifier
</A>
 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
J
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
</TT>
. But prior to PCRE 8.36 that wasn't very useful as backreferences always pointed to the first capturing group with that name in the regex regardless of whether it participated in the match. Starting with PCRE 8.36 (and thus PHP 5.6.9 and R 3.1.3) and also in PCRE2, backreferences point to the first group with that name that actually participated in the match. Though PCRE and Perl handle duplicate groups in opposite directions the end result is the same if you follow the advice to only use groups with the same name in separate alternatives.</p>
 
<p>Boost allows duplicate named groups. Prior to Boost 1.47 that wasn't useful as backreferences always pointed to the last group with that name that appears before the backreference in the regex. In Boost 1.47 and later backreferences point to the first group with that name that actually participated in the match just like in PCRE 8.36 and later.</p>
 
<p>Python, Java, and XRegExp 3 do not allow multiple groups to use the same name. Doing so will give a regex compilation error. XRegExp 2 allowed them, but did not handle them correctly.</p>
 
<p>In Perl 5.10, PCRE 8.00, PHP 5.2.14, and Boost 1.42 (or later versions of these) it is best to use a 
<A HREF="branchreset.html" TARGET="_top">
branch reset group
</A>
 when you want groups in different alternatives to have the same name, as in 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?|
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest2">
(?&lt;digit&gt;
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
5
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
<SPAN CLASS="regexnest2">
(?&lt;digit&gt;
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
4
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
7
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
c
</SPAN>
<SPAN CLASS="regexspecial">
\k&lt;digit&gt;
</SPAN>
</TT>
. With this special syntax&mdash;group opened with 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?|
</SPAN>
</TT>
 instead of 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?:
</SPAN>
</TT>
&mdash;the two groups named "digit" really are one and the same group. Then backreferences to that group are always handled correctly and consistently between these flavors. (Older versions of PCRE and PHP may support branch reset groups, but don't correctly handle duplicate names in branch reset groups.)</p>

</div>

</DIV>
 
<div class=topad>
<A HREF="//www.regexbuddy.com/create.html" TARGET="_top">
</A>
</div>
 
<h1>
Relative Backreferences
</h1>
 
<p>Some applications support relative backreferences. These use a negative number to reference a group preceding the backreference. To find the group that the relative backreference refers to, take the absolute number of the backreference and count that many opening parentheses of (named or unnamed) capturing groups starting at the backreference and going from right to left through the regex. So 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
c
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\k&lt;-1&gt;
</SPAN>
</TT>
 matches 
<tt class=match>
abcc
</tt>
 and 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
c
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\k&lt;-3&gt;
</SPAN>
</TT>
 matches 
<tt class=match>
abca
</tt>
. If the backreference is inside a capturing group, then you also need to count that capturing group's opening parenthesis. So 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
c
</SPAN>
<SPAN CLASS="regexspecial">
\k&lt;-2&gt;
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 matches 
<tt class=match>
abcb
</tt>
. 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
c
</SPAN>
<SPAN CLASS="regexspecial">
\k&lt;-1&gt;
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 either fails to match or is an error depending on whether your application allows 
<A HREF="backref2.html" TARGET="_top">
nested backreferences
</A>
.</p>
 
<p>The syntax for nested backreferences varies widely. It is generally an extension of the syntax for 
<A HREF="named.html" TARGET="_top">
named backreferences
</A>
. 
<a href="jgsoft.html#v2">
JGsoft V2
</a>
 and 
<A HREF="ruby.html" TARGET="_top">
Ruby
</A>
 1.9 and later support 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\k&lt;-1&gt;
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\k'-1'
</SPAN>
</TT>
. Though this looks like the .NET syntax for named capture, .NET itself does not support relative backreferences.</p>
 
<p><A HREF="perl.html" TARGET="_top">
Perl
</A>
 5.10, 
<A HREF="pcre.html" TARGET="_top">
PCRE
</A>
 7.0, 
<A HREF="php.html" TARGET="_top">
PHP
</A>
 5.2.2, and 
<A HREF="rlanguage.html" TARGET="_top">
R
</A>
 support 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\g{-1}
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\g-1
</SPAN>
</TT>
.</p>
 
<p><A HREF="boost.html" TARGET="_top">
Boost
</A>
 supports the Perl syntax starting with Boost 1.42. Boost adds the Ruby syntax starting with Boost 1.47. To complicate matters, Boost 1.47 allowed these variants to multiply. Boost 1.47 and later allow relative backreferences to be specified with 
<tt>
\g
</tt>
 or 
<tt>
\k
</tt>
 and with curly braces, angle brackets, or quotes. That makes six variations plus 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\g-1
</SPAN>
</TT>
 for a total of seven variations. This puts Boost in conflict with Ruby, PCRE, PHP, R, and JGsoft which treat 
<tt>
\g
</tt>
 with angle brackets or quotes and a negative number as a 
<A HREF="subroutine.html" TARGET="_top">
relative subroutine call
</A>
.</p>

</DIV>
 
<div class=topad>
<A HREF="//www.regexbuddy.com/create.html" TARGET="_top">
</A>
</div>
 
<H1>
Branch Reset Groups
</h1>
 
<p><A HREF="perl.html" TARGET="_top">
Perl
</A>
 5.10 introduced a new regular expression feature called a branch reset group. 
<a href="jgsoft.html#v2">
JGsoft V2
</a>
 and 
<A HREF="pcre.html" TARGET="_top">
PCRE
</A>
 7.2 and later also support this, as do languages like 
<A HREF="php.html" TARGET="_top">
PHP
</A>
, 
<A HREF="delphi.html" TARGET="_top">
Delphi
</A>
, and 
<A HREF="rlanguage.html" TARGET="_top">
R
</A>
 that have regex functions based on PCRE. 
<A HREF="boost.html" TARGET="_top">
Boost
</A>
 added them to its ECMAScript grammar in version 1.42.</p>
 
<p><A HREF="alternation.html" TARGET="_top">
Alternatives
</A>
 inside a branch reset group share the same capturing groups. The syntax is 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?|
</SPAN>
<SPAN CLASS="regexplain">
regex
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 where 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?|
</SPAN>
</TT>
 opens the group and 
<TT CLASS=code>
<SPAN CLASS="regexplain">
regex
</SPAN>
</TT>
 is any regular expression. If you don't use any alternation or capturing groups inside the branch reset group, then its special function doesn't come into play. It then acts as a 
<a href="brackets.html#noncapture">
non-capturing group
</a>
.</p>
 
<p>The regex 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?|
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexplain">
c
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 consists of a single branch reset group with three alternatives. This regex matches either 
<tt class=match>
a
</tt>
, 
<tt class=match>
b
</tt>
, or 
<tt class=match>
c
</tt>
. The regex has only a single capturing group with number 1 that is shared by all three alternatives. After the match, 
<tt>
$1
</tt>
 holds 
<tt class=match>
a
</tt>
, 
<tt class=match>
b
</tt>
, or 
<tt class=match>
c
</tt>
.</p>
 
<p>Compare this with the regex 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
c
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 that lacks the branch reset group. This regex also matches 
<tt class=match>
a
</tt>
, 
<tt class=match>
b
</tt>
, or 
<tt class=match>
c
</tt>
. But it has three capturing groups. After the match, 
<tt>
$1
</tt>
 holds 
<tt class=match>
a
</tt>
 or nothing at all, 
<tt>
$2
</tt>
 holds 
<tt class=match>
b
</tt>
 or nothing at all, while 
<tt>
$3
</tt>
 holds 
<tt class=match>
c
</tt>
 or nothing at all.</p>
 
<p><A HREF="backref.html" TARGET="_top">
Backreferences
</A>
 to capturing groups inside branch reset groups work like you'd expect. 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?|
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexplain">
c
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\1
</SPAN>
</TT>
 matches 
<tt class=match>
aa
</tt>
, 
<tt class=match>
bb
</tt>
, or 
<tt class=match>
cc
</tt>
. Since only one of the alternatives inside the branch reset group can match, the alternative that participates in the match determines the text stored by the capturing group and thus the text matched by the backreference.</p>
 
<p>The alternatives in the branch reset group don't need to have the same number of capturing groups. 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?|
</SPAN>
<SPAN CLASS="regexplain">
abc
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexplain">
d
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexplain">
e
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexplain">
f
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
g
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexplain">
h
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexplain">
i
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 has three capturing groups. When this regex matches 
<tt class=match>
abc
</tt>
, all three groups are empty. When 
<tt class=match>
def
</tt>
 is matched, 
<tt>
$1
</tt>
 holds 
<tt class=match>
d
</tt>
, 
<tt>
$2
</tt>
 holds 
<tt class=match>
e
</tt>
 and 
<tt>
$3
</tt>
 holds 
<tt class=match>
f
</tt>
. When 
<tt class=match>
ghi
</tt>
 is matched, 
<tt>
$1
</tt>
 holds 
<tt class=match>
h
</tt>
 while the other two are empty.</p>
 
<p>You can have capturing groups before and after the branch reset group. Groups before the branch reset group are numbered as usual. Groups in the branch reset group are numbered continued from the groups before the branch reset group, which each alternative resetting the number. Groups after the branch reset group are numbered continued from the alternative with the most groups, even if that is not the last alternative. So 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
x
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexnest1">
(?|
</SPAN>
<SPAN CLASS="regexplain">
abc
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexplain">
d
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexplain">
e
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexplain">
f
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
g
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexplain">
h
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexplain">
i
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
y
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 defines five capturing groups. 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
x
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 is group 1, 
<TT CLASS=code>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexplain">
d
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexplain">
h
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
</TT>
 are group 2, 
<TT CLASS=code>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexplain">
e
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
</TT>
 is group 3, 
<TT CLASS=code>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexplain">
f
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
</TT>
 is group 4, and 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
y
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 is group 5.</p>
<H2>Named Capturing Groups in Branch Reset Groups</h2>
 
<p>You can use 
<A HREF="named.html" TARGET="_top">
named capturing groups
</A>
 inside branch reset groups. If you do, you should use the same names for the groups that will get the same numbers. Otherwise you'll get undesirable behavior in Perl or Boost. PowerGREP treats mismatched group names as an error. PCRE only reliably supports named groups inside branch reset groups starting with version 8.00. This means Delphi only does so starting with XE7 and PHP starting with version 5.2.14.</p>
 
<p><TT CLASS=code>
<SPAN CLASS="regexnest1">
(?'before'
</SPAN>
<SPAN CLASS="regexplain">
x
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexnest1">
(?|
</SPAN>
<SPAN CLASS="regexplain">
abc
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexnest2">
(?'left'
</SPAN>
<SPAN CLASS="regexplain">
d
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest2">
(?'middle'
</SPAN>
<SPAN CLASS="regexplain">
e
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest2">
(?'right'
</SPAN>
<SPAN CLASS="regexplain">
f
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
g
</SPAN>
<SPAN CLASS="regexnest2">
(?'left'
</SPAN>
<SPAN CLASS="regexplain">
h
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexplain">
i
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexnest1">
(?'after'
</SPAN>
<SPAN CLASS="regexplain">
y
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 is the same as the previous regex. It names the five groups "before", "left", "middle", "right", and "after". Notice that because the 3rd alternative has only one capturing group, that must be the name of the first group in the other alternatives.</p>
 
<p>If you omit the names in some alternatives, the groups will still share the names with the other alternatives. In the regex 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?'before'
</SPAN>
<SPAN CLASS="regexplain">
x
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexnest1">
(?|
</SPAN>
<SPAN CLASS="regexplain">
abc
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexnest2">
(?'left'
</SPAN>
<SPAN CLASS="regexplain">
d
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest2">
(?'middle'
</SPAN>
<SPAN CLASS="regexplain">
e
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest2">
(?'right'
</SPAN>
<SPAN CLASS="regexplain">
f
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
g
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexplain">
h
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexplain">
i
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexnest1">
(?'after'
</SPAN>
<SPAN CLASS="regexplain">
y
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 the group 
<TT CLASS=code>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexplain">
h
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
</TT>
 is still named "left" because the branch reset group makes it share the name and number of 
<TT CLASS=code>
<SPAN CLASS="regexnest2">
(?'left'
</SPAN>
<SPAN CLASS="regexplain">
d
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
</TT>
.</p>
 
<p>In Perl, PCRE, and Boost, it is best to use a 
<A HREF="branchreset.html" TARGET="_top">
branch reset group
</A>
 when you want groups in different alternatives to 
<a href="named.html#duplicate">
have the same name
</a>
. That's the only way in Perl, PCRE, and Boost to make sure that groups with the same name really are one and the same group.</p>
 
<p>In PowerGREP, groups with the same name are always treated as one and the same group. So you don't really need to use a branch reset group in PowerGREP when using named capturing groups.</p>
<H2>Day and Month with Accurate Number of Days</h2>
 
<p>It's time for a more practical example. These two regular expressions match a date in m/d or mm/dd format. They exclude invalid dates such as 2/31.</p>
 
<p><TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
<SPAN CLASS="regexnest1">
(?:
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexplain">
0
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
13578
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
1
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
02
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexplain">
/
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
012
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
3
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
01
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexplain">
 
</SPAN>
<SPAN CLASS="regexcomment">
# 31 days
</SPAN>
<SPAN CLASS="regexplain">
<BR>
  
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
  
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexplain">
0
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
469
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
11
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexplain">
/
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
012
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
30
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexplain">
         
</SPAN>
<SPAN CLASS="regexcomment">
# 30 days
</SPAN>
<SPAN CLASS="regexplain">
<BR>
  
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
  
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexplain">
0
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexplain">
2
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexplain">
/
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
012
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexplain">
                   
</SPAN>
<SPAN CLASS="regexcomment">
# 29 days
</SPAN>
<SPAN CLASS="regexplain">
<BR>
  
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT></p>
 
<p>The first version uses a 
<a href="brackets.html#noncap">
non-capturing group
</a>
 
<tt>
(?:…)
</tt>
 to group the alternatives. It has six separate capturing groups. 
<tt>
$1
</tt>
 and 
<tt>
$2
</tt>
 would hold the month and the day for months with 31 days, 
<tt>
$3
</tt>
 and 
<tt>
$4
</tt>
 for months with 30 days, and 
<tt>
$5
</tt>
 and 
<tt>
$6
</tt>
 would only be used for February.</p>
 
<p><TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
<SPAN CLASS="regexnest1">
(?|
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexplain">
0
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
13578
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
1
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
02
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexplain">
/
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
012
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
3
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
01
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexplain">
 
</SPAN>
<SPAN CLASS="regexcomment">
# 31 days
</SPAN>
<SPAN CLASS="regexplain">
<BR>
  
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
  
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexplain">
0
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
469
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
11
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexplain">
/
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
012
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
30
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexplain">
         
</SPAN>
<SPAN CLASS="regexcomment">
# 30 days
</SPAN>
<SPAN CLASS="regexplain">
<BR>
  
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
  
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexplain">
0
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexplain">
2
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexplain">
/
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
012
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexplain">
                   
</SPAN>
<SPAN CLASS="regexcomment">
# 29 days
</SPAN>
<SPAN CLASS="regexplain">
<BR>
  
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT></p>
 
<p>The second version uses a branch reset group 
<tt>
(?|…)
</tt>
 to group the alternatives and merge their capturing groups. Now there are only two capturing groups that are shared between the tree alternatives. When a match is found, 
<tt>
$1
</tt>
 always holds the month, and 
<tt>
2
</tt>
 always holds the day, regardless of the number of days in the month.</p>

</DIV>
 
<div class=topad>
<A HREF="//www.regexbuddy.com/create.html" TARGET="_top">
</A>
</div>
 
<H1>
Free-Spacing Regular Expressions
</h1>
 
<p>Most modern regex flavors support a variant of the regular expression syntax called free-spacing mode. This mode allows for regular expressions that are much easier for people to read. Of the flavors discussed in this tutorial, only 
<A HREF="xml.html" TARGET="_top">
XML Schema
</A>
 and the 
<A HREF="posix.html" TARGET="_top">
POSIX
</A>
 and 
<A HREF="gnu.html" TARGET="_top">
GNU
</A>
 flavors don't support it. Plain 
<A HREF="javascript.html" TARGET="_top">
JavaScript
</A>
 doesn't either, but 
<A HREF="xregexp.html" TARGET="_top">
XRegExp
</A>
 does. The mode is usually enabled by setting an option or flag outside the regex. With flavors that support 
<A HREF="modifiers.html" TARGET="_top">
mode modifiers
</A>
, you can put 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
x
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
</TT>
 the very start of the regex to make the remainder of the regex free-spacing.</p>
 
<P>In free-spacing mode, whitespace between regular expression tokens is ignored. Whitespace includes spaces, tabs, and line breaks. Note that only whitespace 
<i>
between
</i>
 tokens is ignored. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexplain">
 
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
<SPAN CLASS="regexplain">
 
</SPAN>
<SPAN CLASS="regexplain">
c
</SPAN>
</TT>
 is the same as 
<TT CLASS=code>
<SPAN CLASS="regexplain">
abc
</SPAN>
</TT>
 in free-spacing mode. But 
<TT CLASS=code>
<SPAN CLASS="regexescaped">
\ 
</SPAN>
<SPAN CLASS="regexplain">
d
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\d
</SPAN>
</TT>
 are not the same. The former matches 
<tt class=match>
&nbsp;d
</tt>
, while the latter matches a digit. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\d
</SPAN>
</TT>
 is a single regex token composed of a backslash and a "d". Breaking up the token with a space gives you an escaped space (which matches a space), and a literal "d".</p>
 
<p>Likewise, grouping modifiers cannot be broken up. 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?&gt;
</SPAN>
<SPAN CLASS="regexplain">
atomic
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 is the same as 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?&gt;
</SPAN>
<SPAN CLASS="regexplain">
 
</SPAN>
<SPAN CLASS="regexplain">
ato
</SPAN>
<SPAN CLASS="regexplain">
 
</SPAN>
<SPAN CLASS="regexplain">
mic
</SPAN>
<SPAN CLASS="regexplain">
 
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 and as 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
( ?&gt;
</SPAN>
<SPAN CLASS="regexplain">
ato
</SPAN>
<SPAN CLASS="regexplain">
 
</SPAN>
<SPAN CLASS="regexplain">
mic
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
. They all match the same 
<A HREF="atomic.html" TARGET="_top">
atomic group
</A>
. They're not the same as 
<TT CLASS=code>
<SPAN CLASS="regexerr">
(?
</SPAN>
<SPAN CLASS="regexplain">
 
</SPAN>
<SPAN CLASS="regexplain">
&gt;atomic
</SPAN>
<SPAN CLASS="regexerr">
)
</SPAN>
</TT>
. The latter is a syntax error. The 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
?&gt;
</SPAN>
</TT>
 grouping modifier is a single element in the regex syntax, and must stay together. This is true for all such constructs, including 
<A HREF="lookaround.html" TARGET="_top">
lookaround
</A>
, 
<A HREF="named.html" TARGET="_top">
named groups
</A>
, etc.</P>
 
<p>Exactly which spaces and line breaks are ignored depends on the regex flavor. All flavors discussed in this 
<A HREF="tutorial.html" TARGET="_top">
tutorial
</A>
 ignore the ASCII space, tab, line feed, carriage return, and form feed characters. 
<a href="jgsoft.html#v2">
JGsoft V2
</a>
 and 
<A HREF="boost.html" TARGET="_top">
Boost
</A>
 are the only flavors that ignore all Unicode spaces and line breaks. JGsoft V1 almost does but misses the next line control character (U+0085). Perl always treats non-ASCII spaces as literals. Perl 5.22 and later ignore non-ASCII line breaks. Perl 5.16 and prior treat them as literals. Perl 5.18 and 5.20 treated unescaped non-ASCII line breaks as errors in free-spacing mode to give developers a transition period.</p>
<H2>Free-Spacing in Character Classes</h2>
 
<P>A character class is also treated as a single token. 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
abc
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 is not the same as 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
 a b c 
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
. The former matches one of three letters, while the latter matches those three letters or a space. In other words: free-spacing mode has no effect inside character classes. Spaces and line breaks inside character classes will be included in the character class. This means that in free-spacing mode, you can use 
<TT CLASS=code>
<SPAN CLASS="regexescaped">
\ 
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
 
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 to match a single space. Use whichever you find more readable. The 
<a href="nonprint.html#hex">
hexadecimal escape
</a>
 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\x20
</SPAN>
</TT>
 also works, of course.</p>
 
<p><A HREF="java.html" TARGET="_top">
Java
</A>
, however, does not treat a character class as a single token in free-spacing mode. Java does ignore spaces, line breaks, and comments inside character classes. So in Java's free-spacing mode, 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
abc
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 is identical to 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexplain">
 
</SPAN>
<SPAN CLASS="regexccliteral">
a
</SPAN>
<SPAN CLASS="regexplain">
 
</SPAN>
<SPAN CLASS="regexccliteral">
b
</SPAN>
<SPAN CLASS="regexplain">
 
</SPAN>
<SPAN CLASS="regexccliteral">
c
</SPAN>
<SPAN CLASS="regexplain">
 
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
. To add a space to a character class, you'll have to escape it with a backslash. But even in free-spacing mode, the negating caret must appear immediately after the opening bracket. 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexplain">
 
</SPAN>
<SPAN CLASS="regexccliteral">
^
</SPAN>
<SPAN CLASS="regexplain">
 
</SPAN>
<SPAN CLASS="regexccliteral">
a
</SPAN>
<SPAN CLASS="regexplain">
 
</SPAN>
<SPAN CLASS="regexccliteral">
b
</SPAN>
<SPAN CLASS="regexplain">
 
</SPAN>
<SPAN CLASS="regexccliteral">
c
</SPAN>
<SPAN CLASS="regexplain">
 
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 matches any of the four characters 
<tt class=match>
^
</tt>
, 
<tt class=match>
a
</tt>
, 
<tt class=match>
b
</tt>
 or 
<tt class=match>
c
</tt>
 just like 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
abc^
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 would. With the negating caret in the proper place, 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexplain">
 
</SPAN>
<SPAN CLASS="regexccliteral">
a
</SPAN>
<SPAN CLASS="regexplain">
 
</SPAN>
<SPAN CLASS="regexccliteral">
b
</SPAN>
<SPAN CLASS="regexplain">
 
</SPAN>
<SPAN CLASS="regexccliteral">
c
</SPAN>
<SPAN CLASS="regexplain">
 
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 matches any character that is not 
<tt class=string>
a
</tt>
, 
<tt class=string>
b
</tt>
 or 
<tt class=string>
c
</tt>
.</p>
 
<p>Perl 5.26 offers limited free-spacing within character classes as an option. The 
<tt>
/x
</tt>
 flag enables free-spacing outside character classes only, as in previous versions of Perl. The double 
<tt>
/xx
</tt>
 flag additionally makes Perl 5.26 treat unescaped spaces and tabs inside character classes as free whitespace. Line breaks are still literals inside character classes.</p>
 
<p>Java treats the 
<TT CLASS=code>
<SPAN CLASS="regexccliteral">
^
</SPAN>
</TT>
 in 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexplain">
 
</SPAN>
<SPAN CLASS="regexccliteral">
^
</SPAN>
<SPAN CLASS="regexplain">
 
</SPAN>
<SPAN CLASS="regexccliteral">
a
</SPAN>
<SPAN CLASS="regexplain">
 
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 as a literal. Even when spaces are ignored they still break the special meaning of the caret in Java. Perl 5.26 treats 
<TT CLASS=code>
<SPAN CLASS="regexccspecial">
^
</SPAN>
</TT>
 in 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexplain">
 
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexplain">
 
</SPAN>
<SPAN CLASS="regexccliteral">
a
</SPAN>
<SPAN CLASS="regexplain">
 
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 as a negation caret in 
<tt>
/xx
</tt>
 mode. Perl 5.26 totally ignores free whitespace. It still considers the caret to be at the start of the character class.</p>
 
<a name="freecomment">
</a>

<H2>Comments in Free-Spacing Mode</h2>
 
<p>Another feature of free-spacing mode is that the 
<tt>
#
</tt>
 character starts a comment. The comment runs until the end of the line. Everything from the 
<tt>
#
</tt>
 until the next newline character is ignored. Most flavors do not recognize any other line break characters as the end of a comment, even if they recognize other line breaks as free whitespace or allow 
<a href="anchors.html#linebreak">
anchors to match at other line breaks
</a>
. JGsoft V2 is the only flavor that recognizes all Unicode line breaks. Boost misses the vertical tab.</p>
 
<p><A HREF="xpath.html" TARGET="_top">
XPath
</A>
 and 
<A HREF="oracle.html" TARGET="_top">
Oracle
</A>
 do not support comments within the regular expression, even though they have a free-spacing mode. They always treat # as a literal character.</p>
 
<p>Java is the only flavor that treats # as the start of a comment inside character classes in free-spacing mode. The comment runs until the end of the line, so you can use a ] to close a comment. All other flavors treat # as a literal inside character classes. That includes Perl 5.26 in 
<tt>
/xx
</tt>
 mode.</p>
 
<p>Putting it all together, the 
<A HREF="dates.html" TARGET="_top">
regex to match a valid date
</A>
 can be clarified by writing it across multiple lines:</p>
 
<p><TT CLASS=code>
<SPAN CLASS="regexcomment">
# Match a 20th or 21st century date in yyyy-mm-dd format
</SPAN>
<SPAN CLASS="regexplain">
<BR>
 
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
19
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
20
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\d
</SPAN>
<SPAN CLASS="regexspecial">
\d
</SPAN>
<SPAN CLASS="regexplain">
                
</SPAN>
<SPAN CLASS="regexcomment">
# year (group 1)
</SPAN>
<SPAN CLASS="regexplain">
<BR>
 
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
- /.
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexplain">
                     
</SPAN>
<SPAN CLASS="regexcomment">
# separator
</SPAN>
<SPAN CLASS="regexplain">
<BR>
 
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
0
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
1
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
1
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
012
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
            
</SPAN>
<SPAN CLASS="regexcomment">
# month (group 2)
</SPAN>
<SPAN CLASS="regexplain">
<BR>
 
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
- /.
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexplain">
                     
</SPAN>
<SPAN CLASS="regexcomment">
# separator
</SPAN>
<SPAN CLASS="regexplain">
<BR>
 
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
0
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
1
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
12
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
3
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
01
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
   
</SPAN>
<SPAN CLASS="regexcomment">
# day (group 3)
</SPAN>
</TT></p>
 
<P><IMG SRC="https://www.regular-expressions.info/screens/rxbcomments.png" SRCSET="screens/rxbcomments.png 1x, screens150/rxbcomments.png 1.5x" ALT="RegexBuddy makes regular expressions more readable with syntax coloring "></P>
 
<a name="parenscomment">
</a>

<H2>Comments Without Free-Spacing</h2>
 
<P>Many flavors also allow you to add comments to your regex without using free-spacing mode. The syntax is 
<TT CLASS=code>
<SPAN CLASS="regexcomment">
(?#comment)
</SPAN>
</TT>
 where "comment" can be whatever you want, as long as it does not contain a closing parenthesis. The regex engine ignores everything after the 
<TT CLASS=code>
<SPAN CLASS="regexcomment">
(?#
</SPAN>
</TT>
 until the first closing parenthesis.</P>
 
<p>Of the flavors discussed in this tutorial, all flavors that support comment in free-spacing mode, except 
<A HREF="java.html" TARGET="_top">
Java
</A>
 and 
<A HREF="tcl.html" TARGET="_top">
Tcl
</A>
, also support 
<TT CLASS=code>
<SPAN CLASS="regexcomment">
(?#comment)
</SPAN>
</TT>
. The flavors that don't support comments in free-spacing mode or don't support free-spacing mode at all don't support 
<TT CLASS=code>
<SPAN CLASS="regexcomment">
(?#comment)
</SPAN>
</TT>
 either.</p>

</DIV>
 
<div class=topad>
<A HREF="//www.regexbuddy.com/create.html" TARGET="_top">
</A>
</div>
 
<H1>
Unicode Regular Expressions
</h1>
 
<P>Unicode is a character set that aims to define all characters and glyphs from all human languages, living and dead. With more and more software being required to support multiple languages, or even just 
<I>
any
</I>
 language, Unicode has been strongly gaining popularity in recent years. Using different character sets for different languages is simply too cumbersome for programmers and users.</P>
 
<P>Unfortunately, Unicode brings its own requirements and pitfalls when it comes to regular expressions. Of the regex flavors discussed in this tutorial, 
<A HREF="java.html" TARGET="_top">
Java
</A>
, 
<A HREF="xml.html" TARGET="_top">
XML
</A>
 and 
<A HREF="dotnet.html" TARGET="_top">
the .NET framework
</A>
 use Unicode-based regex engines. 
<A HREF="perl.html" TARGET="_top">
Perl
</A>
 supports Unicode starting with version 5.6. 
<A HREF="pcre.html" TARGET="_top">
PCRE
</A>
 can optionally be 
<a href="pcre.html#supportucp">
compiled with Unicode support
</a>
. Note that PCRE is far less flexible in what it allows for the 
<tt>
\p
</tt>
 tokens, despite its name "Perl-compatible". The 
<a href="php.html#preg">
PHP preg functions
</a>
, which are based on PCRE, support Unicode when the /u option is appended to the regular expression. 
<A HREF="ruby.html" TARGET="_top">
Ruby
</A>
 supports Unicode escapes and properties in regular expressions starting with version 1.9. 
<A HREF="xregexp.html" TARGET="_top">
XRegExp
</A>
 brings support for Unicode properties to JavaScript.</P>
 
<P><A HREF="regexbuddy.html" TARGET="_top">
RegexBuddy's regex engine
</A>
 is fully Unicode-based starting with version 2.0.0. RegexBuddy 1.x.x did not support Unicode at all. 
<A HREF="powergrep.html" TARGET="_top">
PowerGREP
</A>
 uses the same Unicode regex engine starting with version 3.0.0. Earlier versions would convert Unicode files to ANSI prior to grepping with an 8-bit (i.e. non-Unicode) regex engine. 
<A HREF="editpadpro.html" TARGET="_top">
EditPad Pro
</A>
 supports Unicode starting with version 6.0.0.</P>
 
<H2>Characters, Code Points, and Graphemes or How Unicode Makes a Mess of Things</H2>
 
<P>Most people would consider 
<TT class=string>
à
</TT>
 a single character. Unfortunately, it need not be depending on the meaning of the word "character".</P>
 
<P>All Unicode regex engines discussed in this tutorial treat any single Unicode 
<I>
code point
</I>
 as a single character. When this tutorial tells you that 
<A HREF="dot.html" TARGET="_top">
the dot matches any single character
</A>
, this translates into Unicode parlance as "the dot matches any single Unicode code point". In Unicode, 
<TT class=string>
à
</TT>
 can be encoded as two code points: U+0061 (a) followed by U+0300 (grave accent). In this situation, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
.
</SPAN>
</TT>
 applied to 
<TT class=string>
à
</TT>
 will match 
<TT CLASS=match>
a
</TT>
 without the accent. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
 will fail to match, since the string consists of two code points. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
 matches 
<TT class=match>
à
</TT>
.</P>
 
<P>The Unicode code point U+0300 (grave accent) is a 
<I>
combining mark
</I>
. Any code point that is not a combining mark can be followed by any number of combining marks. This sequence, like U+0061 U+0300 above, is displayed as a single 
<I>
grapheme
</I>
 on the screen.</P>
 
<P>Unfortunately, 
<TT class=string>
à
</TT>
 can also be encoded with the single Unicode code point U+00E0 (a with grave accent). The reason for this duality is that many historical character sets encode "a with grave accent" as a single character. Unicode's designers thought it would be useful to have a one-on-one mapping with popular legacy character sets, in addition to the Unicode way of separating marks and base letters (which makes arbitrary combinations not supported by legacy character sets possible).</P>
 
<A NAME="grapheme">
</A>
<H2>How to Match a Single Unicode Grapheme</H2>
 
<P>Matching a single grapheme, whether it's encoded as a single code point, or as multiple code points using combining marks, is easy in Perl, PCRE, PHP, Boost, Ruby 2.0, and the Just Great Software applications: simply use 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\X
</SPAN>
</TT>
. You can consider 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\X
</SPAN>
</TT>
 the Unicode version of 
<A HREF="dot.html" TARGET="_top">
the dot
</A>
. There is one difference, though: 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\X
</SPAN>
</TT>
 always matches line break characters, whereas the dot does not match line break characters unless you enable the 
<A HREF="modifiers.html" TARGET="_top">
dot matches newline matching mode
</A>
.</P>
 
<P>In Java, .NET, and Ruby 1.9 you can use 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\P{M}
</SPAN>
<SPAN CLASS="regexspecial">
\p{M}
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?&gt;
</SPAN>
<SPAN CLASS="regexspecial">
\P{M}
</SPAN>
<SPAN CLASS="regexspecial">
\p{M}
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 as a reasonably close substitute. To match any number of graphemes, use 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?&gt;
</SPAN>
<SPAN CLASS="regexspecial">
\P{M}
</SPAN>
<SPAN CLASS="regexspecial">
\p{M}
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 as a substitute for 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\X
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
.</P>
 
<A NAME="codepoint">
</A>
<H2>Matching a Specific Code Point</H2>
 
<P>To match a specific Unicode code point, use 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\uFFFF
</SPAN>
</TT>
 where FFFF is the hexadecimal number of the code point you want to match. You must always specify 4 hexadecimal digits E.g. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\u00E0
</SPAN>
</TT>
 matches 
<TT class=match>
à
</TT>
, but only when encoded as a single code point U+00E0.</P>
 
<p><A HREF="perl.html" TARGET="_top">
Perl
</A>
, 
<A HREF="pcre.html" TARGET="_top">
PCRE
</A>
, 
<A HREF="boost.html" TARGET="_top">
Boost
</A>
, and 
<A HREF="stdregex.html" TARGET="_top">
std::regex
</A>
 do not support the 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\uFFFF
</SPAN>
</TT>
 syntax. They use 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\x{FFFF}
</SPAN>
</TT>
 instead. You can omit leading zeros in the hexadecimal number between the curly braces. Since 
<tt>
\x
</tt>
 by itself is not a valid regex token, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\x{1234}
</SPAN>
</TT>
 can never be confused to match 
<tt>
\x
</tt>
 1234 times. It always matches the Unicode code point U+1234. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\x{1234}
</SPAN>
<SPAN CLASS="regexspecial">
{5678}
</SPAN>
</TT>
 will try to match code point U+1234 exactly 5678 times.</p>
 
<P>In Java, the regex token 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\uFFFF
</SPAN>
</TT>
 only matches the specified code point, even when you turned on canonical equivalence. However, the same syntax 
<TT>
\uFFFF
</TT>
 is also used to insert Unicode characters into literal strings in the Java source code. 
<TT>
Pattern.compile("\u00E0")
</TT>
 will match both the single-code-point and double-code-point encodings of 
<TT class=match>
à
</TT>
, while 
<TT>
Pattern.compile("\\u00E0")
</TT>
 matches only the single-code-point version. Remember that when writing a regex as a Java string literal, backslashes must be escaped. The former Java code compiles the regex 
<TT CLASS=code>
<SPAN CLASS="regexplain">
à
</SPAN>
</TT>
, while the latter compiles 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\u00E0
</SPAN>
</TT>
. Depending on what you're doing, the difference may be significant.</P>
 
<P><A HREF="javascript.html" TARGET="_top">
JavaScript
</A>
, which does not offer any Unicode support through its RegExp class, does support 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\uFFFF
</SPAN>
</TT>
 for matching a single Unicode code point as part of its string syntax.</p>
 
<p><A HREF="xml.html" TARGET="_top">
XML Schema
</A>
 and 
<A HREF="xpath.html" TARGET="_top">
XPath
</A>
 do not have a regex token for matching Unicode code points. However, you can easily use XML entities like 
<tt>
&amp;#xFFFF;
</tt>
 to insert literal code points into your regular expression.</p>
 
<A NAME="category">
</A>
<H2>Unicode Categories</H2>
 
<P>In addition to complications, Unicode also brings new possibilities. One is that each Unicode character belongs to a certain category. You can match a single character belonging to the "letter" category with 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{L}
</SPAN>
</TT>
. You can match a single character 
<I>
not
</I>
 belonging to that category with 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\P{L}
</SPAN>
</TT>
.</P>
 
<P>Again, "character" really means "Unicode code point". 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{L}
</SPAN>
</TT>
 matches a single code point in the category "letter". If your input string is 
<TT class=string>
à
</TT>
 encoded as U+0061 U+0300, it matches 
<TT class=match>
a
</TT>
 without the accent. If the input is 
<TT class=string>
à
</TT>
 encoded as U+00E0, it matches 
<TT class=match>
à
</TT>
 with the accent. The reason is that both the code points U+0061 (a) and U+00E0 (à) are in the category "letter", while U+0300 is in the category "mark".</P>
 
<P>You should now understand why 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\P{M}
</SPAN>
<SPAN CLASS="regexspecial">
\p{M}
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 is the equivalent of 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\X
</SPAN>
</TT>
. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\P{M}
</SPAN>
</TT>
 matches a code point that is not a combining mark, while 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{M}
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 matches 
<A HREF="repeat.html" TARGET="_top">
zero or more
</A>
 code points that are combining marks. To match a letter including any diacritics, use 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{L}
</SPAN>
<SPAN CLASS="regexspecial">
\p{M}
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
. This last regex will always match 
<TT class=match>
à
</TT>
, regardless of how it is encoded. The 
<A HREF="possessive.html" TARGET="_top">
possessive quantifier
</A>
 makes sure that backtracking doesn't cause 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\P{M}
</SPAN>
<SPAN CLASS="regexspecial">
\p{M}
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 to match a non-mark without the combining marks that follow it, which 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\X
</SPAN>
</TT>
 would never do.</P>
 
<p>PCRE, PHP, and .NET are case sensitive when it checks the part between curly braces of a 
<tt>
\p
</tt>
 token. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Zs}
</SPAN>
</TT>
 will match any kind of space character, while 
<TT CLASS=code>
<SPAN CLASS="regexerr">
\p{zs}
</SPAN>
</TT>
 will throw an error. All other regex engines described in this tutorial will match the space in both cases, ignoring the case of the category between the curly braces. Still, I recommend you make a habit of using the same uppercase and lowercase combination as I did in the list of properties below. This will make your regular expressions work with all Unicode regex engines.</p>
 
<P>In addition to the standard notation, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{L}
</SPAN>
</TT>
, Java, Perl, PCRE, the 
<A HREF="jgsoft.html" TARGET="_top">
JGsoft engine
</A>
, and XRegExp 3 allow you to use the shorthand 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\pL
</SPAN>
</TT>
. The shorthand only works with single-letter Unicode properties. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\pL
</SPAN>
<SPAN CLASS="regexplain">
l
</SPAN>
</TT>
 is 
<i>
not
</i>
 the equivalent of 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Ll}
</SPAN>
</TT>
. It is the equivalent of 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{L}
</SPAN>
<SPAN CLASS="regexplain">
l
</SPAN>
</TT>
 which matches 
<tt class=match>
Al
</tt>
 or 
<tt class=match>
àl
</tt>
 or any Unicode letter followed by a literal 
<tt class=match>
l
</tt>
.</p>
 
<p>Perl, XRegExp, and the JGsoft engine also support the longhand 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Letter}
</SPAN>
</TT>
. You can find a complete list of all Unicode properties below. You may omit the underscores or use hyphens or spaces instead.</P>
 
<UL>
 
<LI>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{L}
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Letter}
</SPAN>
</TT>
: any kind of letter from any language. 
<UL>
 
<LI>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Ll}
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Lowercase_Letter}
</SPAN>
</TT>
: a lowercase letter that has an uppercase variant. 
<LI>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Lu}
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Uppercase_Letter}
</SPAN>
</TT>
: an uppercase letter that has a lowercase variant. 
<LI>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Lt}
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Titlecase_Letter}
</SPAN>
</TT>
: a letter that appears at the start of a word when only the first letter of the word is capitalized. 
<LI>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{L&amp;}
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Cased_Letter}
</SPAN>
</TT>
: a letter that exists in lowercase and uppercase variants (combination of Ll, Lu and Lt). 
<LI>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Lm}
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Modifier_Letter}
</SPAN>
</TT>
: a special character that is used like a letter. 
<LI>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Lo}
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Other_Letter}
</SPAN>
</TT>
: a letter or ideograph that does not have lowercase and uppercase variants. 
</UL>
 
<LI>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{M}
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Mark}
</SPAN>
</TT>
: a character intended to be combined with another character (e.g. accents, umlauts, enclosing boxes, etc.). 
<UL>
 
<LI>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Mn}
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Non_Spacing_Mark}
</SPAN>
</TT>
: a character intended to be combined with another character without taking up extra space (e.g. accents, umlauts, etc.). 
<LI>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Mc}
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Spacing_Combining_Mark}
</SPAN>
</TT>
: a character intended to be combined with another character that takes up extra space (vowel signs in many Eastern languages). 
<LI>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Me}
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Enclosing_Mark}
</SPAN>
</TT>
: a character that encloses the character is is combined with (circle, square, keycap, etc.). 
</UL>
 
<LI>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Z}
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Separator}
</SPAN>
</TT>
: any kind of whitespace or invisible separator. 
<UL>
 
<LI>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Zs}
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Space_Separator}
</SPAN>
</TT>
: a whitespace character that is invisible, but does take up space. 
<LI>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Zl}
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Line_Separator}
</SPAN>
</TT>
: line separator character U+2028. 
<LI>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Zp}
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Paragraph_Separator}
</SPAN>
</TT>
: paragraph separator character U+2029. 
</UL>
 
<LI>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{S}
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Symbol}
</SPAN>
</TT>
: math symbols, currency signs, dingbats, box-drawing characters, etc. 
<UL>
 
<LI>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Sm}
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Math_Symbol}
</SPAN>
</TT>
: any mathematical symbol. 
<LI>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Sc}
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Currency_Symbol}
</SPAN>
</TT>
: any currency sign. 
<LI>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Sk}
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Modifier_Symbol}
</SPAN>
</TT>
: a combining character (mark) as a full character on its own. 
<LI>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{So}
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Other_Symbol}
</SPAN>
</TT>
: various symbols that are not math symbols, currency signs, or combining characters. 
</UL>
 
<LI>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{N}
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Number}
</SPAN>
</TT>
: any kind of numeric character in any script. 
<UL>
 
<LI>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Nd}
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Decimal_Digit_Number}
</SPAN>
</TT>
: a digit zero through nine in any script except ideographic scripts. 
<LI>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Nl}
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Letter_Number}
</SPAN>
</TT>
: a number that looks like a letter, such as a Roman numeral. 
<LI>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{No}
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Other_Number}
</SPAN>
</TT>
: a superscript or subscript digit, or a number that is not a digit 0–9 (excluding numbers from ideographic scripts). 
</UL>
 
<LI>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{P}
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Punctuation}
</SPAN>
</TT>
: any kind of punctuation character. 
<UL>
 
<LI>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Pd}
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Dash_Punctuation}
</SPAN>
</TT>
: any kind of hyphen or dash. 
<LI>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Ps}
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Open_Punctuation}
</SPAN>
</TT>
: any kind of opening bracket. 
<LI>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Pe}
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Close_Punctuation}
</SPAN>
</TT>
: any kind of closing bracket. 
<LI>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Pi}
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Initial_Punctuation}
</SPAN>
</TT>
: any kind of opening quote. 
<LI>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Pf}
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Final_Punctuation}
</SPAN>
</TT>
: any kind of closing quote. 
<LI>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Pc}
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Connector_Punctuation}
</SPAN>
</TT>
: a punctuation character such as an underscore that connects words. 
<LI>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Po}
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Other_Punctuation}
</SPAN>
</TT>
: any kind of punctuation character that is not a dash, bracket, quote or connector. 
</UL>
 
<LI>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{C}
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Other}
</SPAN>
</TT>
: invisible control characters and unused code points. 
<UL>
 
<LI>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Cc}
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Control}
</SPAN>
</TT>
: an ASCII or Latin-1 control character: 0x00–0x1F and 0x7F–0x9F. 
<LI>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Cf}
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Format}
</SPAN>
</TT>
: invisible formatting indicator. 
<LI>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Co}
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Private_Use}
</SPAN>
</TT>
: any code point reserved for private use. 
<LI>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Cs}
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Surrogate}
</SPAN>
</TT>
: one half of a surrogate pair in UTF-16 encoding. 
<LI>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Cn}
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Unassigned}
</SPAN>
</TT>
: any code point to which no character has been assigned. 
</UL>
 
</UL>
 
<a name="script">
</a>
<H2>Unicode Scripts</H2>
 
<p>The Unicode standard places each assigned code point (character) into one script. A script is a group of code points used by a particular human writing system. Some scripts like 
<tt>
Thai
</tt>
 correspond with a single human language. Other scripts like 
<tt>
Latin
</tt>
 span multiple languages.</p>
 
<p>Some languages are composed of multiple scripts. There is no Japanese Unicode script. Instead, Unicode offers the 
<tt>
Hiragana
</tt>
, 
<tt>
Katakana
</tt>
, 
<tt>
Han
</tt>
, and 
<tt>
Latin
</tt>
 scripts that Japanese documents are usually composed of.</p>
 
<p>A special script is the 
<tt>
Common
</tt>
 script. This script contains all sorts of characters that are common to a wide range of scripts. It includes all sorts of punctuation, whitespace and miscellaneous symbols.</p>
 
<p>All assigned Unicode code points (those matched by 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\P{Cn}
</SPAN>
</TT>
) are part of exactly one Unicode script. All unassigned Unicode code points (those matched by 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Cn}
</SPAN>
</TT>
) are not part of any Unicode script at all.</p>
 
<p>The 
<A HREF="jgsoft.html" TARGET="_top">
JGsoft engine
</A>
, 
<A HREF="perl.html" TARGET="_top">
Perl
</A>
, 
<A HREF="pcre.html" TARGET="_top">
PCRE
</A>
, 
<A HREF="php.html" TARGET="_top">
PHP
</A>
, 
<A HREF="ruby.html" TARGET="_top">
Ruby 1.9
</A>
, 
<A HREF="delphi.html" TARGET="_top">
Delphi
</A>
, and 
<A HREF="xregexp.html" TARGET="_top">
XRegExp
</A>
 can match Unicode scripts. Here's a list:</p>
 
<ol>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Common}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Arabic}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Armenian}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Bengali}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Bopomofo}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Braille}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Buhid}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Canadian_Aboriginal}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Cherokee}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Cyrillic}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Devanagari}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Ethiopic}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Georgian}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Greek}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Gujarati}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Gurmukhi}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Han}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Hangul}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Hanunoo}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Hebrew}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Hiragana}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Inherited}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Kannada}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Katakana}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Khmer}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Lao}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Latin}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Limbu}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Malayalam}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Mongolian}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Myanmar}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Ogham}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Oriya}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Runic}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Sinhala}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Syriac}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Tagalog}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Tagbanwa}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{TaiLe}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Tamil}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Telugu}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Thaana}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Thai}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Tibetan}
</SPAN>
</TT>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Yi}
</SPAN>
</TT>
 
</ol>
 
<p>Perl and the JGsoft flavor allow you to use 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{IsLatin}
</SPAN>
</TT>
 instead of 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Latin}
</SPAN>
</TT>
. The "Is" syntax is useful for distinguishing between scripts and blocks, as explained in the next section. PCRE, PHP, and XRegExp do not support the "Is" prefix.</p>
 
<p>Java 7 adds support for Unicode scripts. Unlike the other flavors, Java 7 requires the "Is" prefix.</p>
 
<a name="block">
</a>
<H2>Unicode Blocks</H2>
 
<p>The Unicode standard divides the Unicode character map into different blocks or ranges of code points. Each block is used to define characters of a particular script like "Tibetan" or belonging to a particular group like "Braille Patterns". Most blocks include unassigned code points, reserved for future expansion of the Unicode standard.</p>
 
<p>Note that Unicode blocks do not correspond 100% with scripts. An essential difference between blocks and scripts is that a block is a single contiguous range of code points, as listed below. Scripts consist of characters taken from all over the Unicode character map. Blocks may include unassigned code points (i.e. code points matched by 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Cn}
</SPAN>
</TT>
). Scripts never include unassigned code points. Generally, if you're not sure whether to use a Unicode script or Unicode block, use the script.</p>
 
<p>For example, the Currency block does not include the dollar and yen symbols. Those are found in the Basic_Latin and Latin-1_Supplement blocks instead, even though both are currency symbols, and the yen symbol is not a Latin character. This is for historical reasons, because the ASCII standard includes the dollar sign, and the ISO-8859 standard includes the yen sign. You should not blindly use any of the blocks listed below based on their names. Instead, look at the ranges of characters they actually match. A tool like 
<A HREF="regexbuddy.html" TARGET="_top">
RegexBuddy
</A>
 can be very helpful with this. The Unicode property 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Sc}
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Currency_Symbol}
</SPAN>
</TT>
 would be a better choice than the Unicode block 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InCurrency_Symbols}
</SPAN>
</TT>
 when trying to find all currency symbols.</p>
 
<ol>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InBasic_Latin}
</SPAN>
</TT>
: U+0000–U+007F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InLatin-1_Supplement}
</SPAN>
</TT>
: U+0080–U+00FF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InLatin_Extended-A}
</SPAN>
</TT>
: U+0100–U+017F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InLatin_Extended-B}
</SPAN>
</TT>
: U+0180–U+024F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InIPA_Extensions}
</SPAN>
</TT>
: U+0250–U+02AF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InSpacing_Modifier_Letters}
</SPAN>
</TT>
: U+02B0–U+02FF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InCombining_Diacritical_Marks}
</SPAN>
</TT>
: U+0300–U+036F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InGreek_and_Coptic}
</SPAN>
</TT>
: U+0370–U+03FF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InCyrillic}
</SPAN>
</TT>
: U+0400–U+04FF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InCyrillic_Supplementary}
</SPAN>
</TT>
: U+0500–U+052F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InArmenian}
</SPAN>
</TT>
: U+0530–U+058F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InHebrew}
</SPAN>
</TT>
: U+0590–U+05FF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InArabic}
</SPAN>
</TT>
: U+0600–U+06FF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InSyriac}
</SPAN>
</TT>
: U+0700–U+074F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InThaana}
</SPAN>
</TT>
: U+0780–U+07BF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InDevanagari}
</SPAN>
</TT>
: U+0900–U+097F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InBengali}
</SPAN>
</TT>
: U+0980–U+09FF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InGurmukhi}
</SPAN>
</TT>
: U+0A00–U+0A7F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InGujarati}
</SPAN>
</TT>
: U+0A80–U+0AFF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InOriya}
</SPAN>
</TT>
: U+0B00–U+0B7F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InTamil}
</SPAN>
</TT>
: U+0B80–U+0BFF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InTelugu}
</SPAN>
</TT>
: U+0C00–U+0C7F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InKannada}
</SPAN>
</TT>
: U+0C80–U+0CFF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InMalayalam}
</SPAN>
</TT>
: U+0D00–U+0D7F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InSinhala}
</SPAN>
</TT>
: U+0D80–U+0DFF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InThai}
</SPAN>
</TT>
: U+0E00–U+0E7F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InLao}
</SPAN>
</TT>
: U+0E80–U+0EFF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InTibetan}
</SPAN>
</TT>
: U+0F00–U+0FFF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InMyanmar}
</SPAN>
</TT>
: U+1000–U+109F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InGeorgian}
</SPAN>
</TT>
: U+10A0–U+10FF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InHangul_Jamo}
</SPAN>
</TT>
: U+1100–U+11FF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InEthiopic}
</SPAN>
</TT>
: U+1200–U+137F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InCherokee}
</SPAN>
</TT>
: U+13A0–U+13FF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InUnified_Canadian_Aboriginal_Syllabics}
</SPAN>
</TT>
: U+1400–U+167F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InOgham}
</SPAN>
</TT>
: U+1680–U+169F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InRunic}
</SPAN>
</TT>
: U+16A0–U+16FF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InTagalog}
</SPAN>
</TT>
: U+1700–U+171F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InHanunoo}
</SPAN>
</TT>
: U+1720–U+173F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InBuhid}
</SPAN>
</TT>
: U+1740–U+175F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InTagbanwa}
</SPAN>
</TT>
: U+1760–U+177F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InKhmer}
</SPAN>
</TT>
: U+1780–U+17FF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InMongolian}
</SPAN>
</TT>
: U+1800–U+18AF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InLimbu}
</SPAN>
</TT>
: U+1900–U+194F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InTai_Le}
</SPAN>
</TT>
: U+1950–U+197F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InKhmer_Symbols}
</SPAN>
</TT>
: U+19E0–U+19FF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InPhonetic_Extensions}
</SPAN>
</TT>
: U+1D00–U+1D7F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InLatin_Extended_Additional}
</SPAN>
</TT>
: U+1E00–U+1EFF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InGreek_Extended}
</SPAN>
</TT>
: U+1F00–U+1FFF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InGeneral_Punctuation}
</SPAN>
</TT>
: U+2000–U+206F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InSuperscripts_and_Subscripts}
</SPAN>
</TT>
: U+2070–U+209F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InCurrency_Symbols}
</SPAN>
</TT>
: U+20A0–U+20CF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InCombining_Diacritical_Marks_for_Symbols}
</SPAN>
</TT>
: U+20D0–U+20FF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InLetterlike_Symbols}
</SPAN>
</TT>
: U+2100–U+214F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InNumber_Forms}
</SPAN>
</TT>
: U+2150–U+218F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InArrows}
</SPAN>
</TT>
: U+2190–U+21FF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InMathematical_Operators}
</SPAN>
</TT>
: U+2200–U+22FF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InMiscellaneous_Technical}
</SPAN>
</TT>
: U+2300–U+23FF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InControl_Pictures}
</SPAN>
</TT>
: U+2400–U+243F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InOptical_Character_Recognition}
</SPAN>
</TT>
: U+2440–U+245F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InEnclosed_Alphanumerics}
</SPAN>
</TT>
: U+2460–U+24FF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InBox_Drawing}
</SPAN>
</TT>
: U+2500–U+257F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InBlock_Elements}
</SPAN>
</TT>
: U+2580–U+259F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InGeometric_Shapes}
</SPAN>
</TT>
: U+25A0–U+25FF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InMiscellaneous_Symbols}
</SPAN>
</TT>
: U+2600–U+26FF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InDingbats}
</SPAN>
</TT>
: U+2700–U+27BF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InMiscellaneous_Mathematical_Symbols-A}
</SPAN>
</TT>
: U+27C0–U+27EF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InSupplemental_Arrows-A}
</SPAN>
</TT>
: U+27F0–U+27FF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InBraille_Patterns}
</SPAN>
</TT>
: U+2800–U+28FF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InSupplemental_Arrows-B}
</SPAN>
</TT>
: U+2900–U+297F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InMiscellaneous_Mathematical_Symbols-B}
</SPAN>
</TT>
: U+2980–U+29FF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InSupplemental_Mathematical_Operators}
</SPAN>
</TT>
: U+2A00–U+2AFF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InMiscellaneous_Symbols_and_Arrows}
</SPAN>
</TT>
: U+2B00–U+2BFF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InCJK_Radicals_Supplement}
</SPAN>
</TT>
: U+2E80–U+2EFF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InKangxi_Radicals}
</SPAN>
</TT>
: U+2F00–U+2FDF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InIdeographic_Description_Characters}
</SPAN>
</TT>
: U+2FF0–U+2FFF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InCJK_Symbols_and_Punctuation}
</SPAN>
</TT>
: U+3000–U+303F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InHiragana}
</SPAN>
</TT>
: U+3040–U+309F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InKatakana}
</SPAN>
</TT>
: U+30A0–U+30FF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InBopomofo}
</SPAN>
</TT>
: U+3100–U+312F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InHangul_Compatibility_Jamo}
</SPAN>
</TT>
: U+3130–U+318F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InKanbun}
</SPAN>
</TT>
: U+3190–U+319F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InBopomofo_Extended}
</SPAN>
</TT>
: U+31A0–U+31BF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InKatakana_Phonetic_Extensions}
</SPAN>
</TT>
: U+31F0–U+31FF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InEnclosed_CJK_Letters_and_Months}
</SPAN>
</TT>
: U+3200–U+32FF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InCJK_Compatibility}
</SPAN>
</TT>
: U+3300–U+33FF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InCJK_Unified_Ideographs_Extension_A}
</SPAN>
</TT>
: U+3400–U+4DBF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InYijing_Hexagram_Symbols}
</SPAN>
</TT>
: U+4DC0–U+4DFF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InCJK_Unified_Ideographs}
</SPAN>
</TT>
: U+4E00–U+9FFF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InYi_Syllables}
</SPAN>
</TT>
: U+A000–U+A48F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InYi_Radicals}
</SPAN>
</TT>
: U+A490–U+A4CF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InHangul_Syllables}
</SPAN>
</TT>
: U+AC00–U+D7AF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InHigh_Surrogates}
</SPAN>
</TT>
: U+D800–U+DB7F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InHigh_Private_Use_Surrogates}
</SPAN>
</TT>
: U+DB80–U+DBFF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InLow_Surrogates}
</SPAN>
</TT>
: U+DC00–U+DFFF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InPrivate_Use_Area}
</SPAN>
</TT>
: U+E000–U+F8FF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InCJK_Compatibility_Ideographs}
</SPAN>
</TT>
: U+F900–U+FAFF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InAlphabetic_Presentation_Forms}
</SPAN>
</TT>
: U+FB00–U+FB4F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InArabic_Presentation_Forms-A}
</SPAN>
</TT>
: U+FB50–U+FDFF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InVariation_Selectors}
</SPAN>
</TT>
: U+FE00–U+FE0F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InCombining_Half_Marks}
</SPAN>
</TT>
: U+FE20–U+FE2F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InCJK_Compatibility_Forms}
</SPAN>
</TT>
: U+FE30–U+FE4F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InSmall_Form_Variants}
</SPAN>
</TT>
: U+FE50–U+FE6F 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InArabic_Presentation_Forms-B}
</SPAN>
</TT>
: U+FE70–U+FEFF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InHalfwidth_and_Fullwidth_Forms}
</SPAN>
</TT>
: U+FF00–U+FFEF 
<li>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InSpecials}
</SPAN>
</TT>
: U+FFF0–U+FFFF 
</ol>
 
<p>Not all Unicode regex engines use the same syntax to match Unicode blocks. 
<A HREF="java.html" TARGET="_top">
Java
</A>
, 
<A HREF="ruby.html" TARGET="_top">
Ruby 2.0
</A>
, and 
<A HREF="xregexp.html" TARGET="_top">
XRegExp
</A>
 use the 
<tt>
\p{InBlock}
</tt>
 syntax as listed above. 
<A HREF="dotnet.html" TARGET="_top">
.NET
</A>
 and 
<A HREF="xml.html" TARGET="_top">
XML
</A>
 use 
<tt>
\p{IsBlock}
</tt>
 instead. 
<A HREF="perl.html" TARGET="_top">
Perl
</A>
 and the 
<A HREF="jgsoft.html" TARGET="_top">
JGsoft flavor
</A>
 support both notations. I recommend you use the "In" notation if your regex engine supports it. "In" can only be used for Unicode blocks, while "Is" can also be used for Unicode properties and scripts, depending on the regular expression flavor you're using. By using "In", it's obvious you're matching a block and not a similarly named property or script.</p>
 
<p>In .NET and XML, you must omit the underscores but keep the hyphens in the block names. E.g. Use 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{IsLatinExtended-A}
</SPAN>
</TT>
 instead of 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InLatin_Extended-A}
</SPAN>
</TT>
. In Java, you must omit the hyphens. .NET and XML also compare the names case sensitively, while Perl, Ruby, and the JGsoft flavor compare them case insensitively. Java 4 is case sensitive. Java 5 and later are case sensitive for the "Is" prefix but not for the block names themselves.</p>
 
<p>The actual names of the blocks are the same in all regular expression engines. The block names are defined in the Unicode standard. PCRE and PHP do not support Unicode blocks, even though they support Unicode scripts.</p>
 
<H2>Do You Need To Worry About Different Encodings?</H2>
 
<P>While you should always keep in mind the pitfalls created by the different ways in which accented characters can be encoded, you don't always have to worry about them. If you know that your input string and your regex use the same style, then you don't have to worry about it at all. This process is called Unicode 
<I>
normalization
</I>
. All programming languages with native Unicode support, such as Java, C# and VB.NET, have library routines for normalizing strings. If you normalize both the subject and regex before attempting the match, there won't be any inconsistencies.</P>
 
<P>If you are using Java, you can pass the CANON_EQ flag as the second parameter to Pattern.compile(). This tells the Java regex engine to consider 
<I>
canonically equivalent
</I>
 characters as identical. The regex 
<TT CLASS=code>
<SPAN CLASS="regexplain">
à
</SPAN>
</TT>
 encoded as U+00E0 matches 
<TT class=match>
à
</TT>
 encoded as U+0061 U+0300, and vice versa. None of the other regex engines currently support canonical equivalence while matching.</P>
 
<P>If you type the à key on the keyboard, all word processors that I know of will insert the code point U+00E0 into the file. So if you're working with text that you typed in yourself, any regex that you type in yourself will match in the same way.</P>
 
<P>Finally, if you're using 
<A HREF="powergrep.html" TARGET="_top">
PowerGREP
</A>
 to search through text files encoded using a traditional Windows (often called "ANSI") or ISO-8859 code page, PowerGREP always uses the one-on-one substitution. Since all the Windows or ISO-8859 code pages encode accented characters as a single code point, nearly all software uses a single Unicode code point for each character when converting the file to Unicode.</P>

</DIV>
 
<div class=topad>
<A HREF="//www.regexbuddy.com/create.html" TARGET="_top">
</A>
</div>
 
<H1>
Specifying Modes Inside The Regular Expression
</H1>
 
<p>Normally, matching modes are specified outside the regular expression. In a programming language, you pass them as a flag to the regex constructor or append them to the regex literal. In an application, you'd toggle the appropriate buttons or checkboxes. You can find the specifics in the 
<A HREF="tools.html" TARGET="_top">
tools and languages
</A>
 section of this website.</p>
 
<P>Sometimes, the tool or language does not provide the ability to specify matching options. The handy 
<TT CLASS=code>
String.matches()
</TT>
 method in 
<A HREF="java.html" TARGET="_top">
Java
</A>
 does not take a parameter for matching options like 
<TT CLASS=code>
Pattern.compile()
</TT>
 does. Or, the regex flavor may support matching modes that aren't exposed as external flags. The regex functions in 
<A HREF="rlanguage.html" TARGET="_top">
R
</A>
 have 
<tt>
ignore.case
</tt>
 as their only option, even though the underlying PCRE library has more matching modes than any other discussed in this tutorial.</P>
 
<P>In those situation, you can add the following mode modifiers to the start of the regex. To specify multiple modes, simply put them together as in 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
i
</SPAN>
<SPAN CLASS="regexmeta">
s
</SPAN>
<SPAN CLASS="regexmeta">
m
</SPAN>
<SPAN CLASS="regexmeta">
x
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
</TT>
.</P>
 
<ul>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
i
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
</TT>
 makes the regex case insensitive.
</li>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
c
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
</TT>
 makes the regex case sensitive. Only supported by 
<A HREF="tcl.html" TARGET="_top">
Tcl
</A>
.
</li>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
x
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
</TT>
 turn on 
<A HREF="freespacing.html" TARGET="_top">
free-spacing mode
</A>
.
</li>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
t
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
</TT>
 turn off free-spacing mode. Only supported by Tcl.
</li>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
s
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
</TT>
 for "single line mode" makes the 
<A HREF="dot.html" TARGET="_top">
dot
</A>
 match all characters, including line breaks. Not supported by 
<A HREF="ruby.html" TARGET="_top">
Ruby
</A>
 or 
<A HREF="javascript.html" TARGET="_top">
JavaScript
</A>
. In Tcl, 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
s
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
</TT>
 also makes the caret and dollar match at the start and end of the string only.
</li>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
m
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
</TT>
 for "multi-line mode" makes the 
<A HREF="anchors.html" TARGET="_top">
caret and dollar
</A>
 match at the start and end of each line in the subject string. In Ruby, 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
m
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
</TT>
 makes the dot match all characters, without affecting the caret and dollar which always match at the start and end of each line in Ruby. In Tcl, 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
m
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
</TT>
 also prevents the dot from matching line breaks.
</li>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
p
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
</TT>
 in Tcl makes the caret and dollar match at the start and the end of each line, and makes the dot match line breaks.
</li>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
w
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
</TT>
 in Tcl makes the caret and dollar match only at the start and the end of the subject string, and prevents the dot from matching line breaks.
</li>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
n
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
</TT>
 turns all 
<a href="named.html#number">
unnamed groups
</a>
 into non-capturing groups. Only supported by 
<A HREF="dotnet.html" TARGET="_top">
.NET
</A>
, 
<A HREF="xregexp.html" TARGET="_top">
XRegExp
</A>
, and the 
<A HREF="jgsoft.html" TARGET="_top">
JGsoft flavor
</A>
. In Tcl, 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
n
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
</TT>
 is the same as 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
m
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
</TT>
.
</li>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
J
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
</TT>
 allows 
<a href="named.html#duplicate">
duplicate group names
</a>
. Only supported by 
<A HREF="pcre.html" TARGET="_top">
PCRE
</A>
 and languages that use it such as 
<A HREF="delphi.html" TARGET="_top">
Delphi
</A>
, 
<A HREF="php.html" TARGET="_top">
PHP
</A>
 and 
<A HREF="rlanguage.html" TARGET="_top">
R
</A>
.
</li>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
U
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
</TT>
 turns on "ungreedy mode", which switches the syntax for greedy and lazy quantifiers. So 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
U
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
 is lazy and 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
U
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
</TT>
 is greedy. Only supported by PCRE and languages that use it. It's use is strongly discouraged because it confuses the meaning of the standard quantifier syntax.
</li>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
d
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
</TT>
 corresponds with UNIX_LINES in 
<A HREF="java.html" TARGET="_top">
Java
</A>
, which makes the dot, caret, and dollar treat only the newline character 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\n
</SPAN>
</TT>
 as a line break, instead of recognizing all line break characters from the Unicode standard. Whether they match or don't match (at) line breaks depends on 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
s
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
m
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
</TT>
.
</li>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
b
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
</TT>
 makes Tcl interpret the regex as a POSIX BRE.
</li>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
e
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
</TT>
 makes Tcl interpret the regex as a POSIX ERE.
</li>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
q
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
</TT>
 makes Tcl interpret the regex as a literal string (minus the 
<tt>
(?q)
</tt>
 characters).
</li>
 
<li>
<TT CLASS=code>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
X
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
</TT>
 makes escaping letters with a backslash an error if that combination is not a valid regex token. Only supported by PCRE and languages that use it.
</li>
 
</ul>
<H2>Turning Modes On and Off for Only Part of The Regular Expression</H2>
 
<P>Modern regex flavors allow you to apply modifiers to only part of the regular expression. If you insert the modifier 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
i
</SPAN>
<SPAN CLASS="regexmeta">
s
</SPAN>
<SPAN CLASS="regexmeta">
m
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
</TT>
 in the middle of the regex then the modifier only applies to the part of the regex to the right of the modifier. With these flavors, you can turn off modes by preceding them with a minus sign. All modes after the minus sign will be turned off. E.g. 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
i
</SPAN>
<SPAN CLASS="regexmeta">
-
</SPAN>
<SPAN CLASS="regexmeta">
s
</SPAN>
<SPAN CLASS="regexmeta">
m
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
</TT>
 turns on case insensitivity, and turns off both single-line mode and multi-line mode.</P>
 
<p>Flavors that can't apply modifiers to only part of the regex treat a modifiers in the middle of the regex as an error. 
<A HREF="python.html" TARGET="_top">
Python
</A>
 is an exception to this. In Python, putting a modifier in the middle of the regex affects the whole regex. So in Python, 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
i
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
<SPAN CLASS="regexplain">
caseless
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexplain">
caseless
</SPAN>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
i
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
</TT>
 are both case insensitive. In all other flavors, the trailing mode modifier either has no effect or is an error.</p>
 
<P>You can quickly test how the regex flavor you're using handles mode modifiers. The regex 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
i
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
<SPAN CLASS="regexplain">
te
</SPAN>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
-
</SPAN>
<SPAN CLASS="regexmeta">
i
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
<SPAN CLASS="regexplain">
st
</SPAN>
</TT>
 should match 
<TT CLASS=match>
test
</TT>
 and 
<TT CLASS=match>
TEst
</TT>
, but not 
<TT CLASS=string>
teST
</TT>
 or 
<TT CLASS=string>
TEST
</TT>
.</P>
<H2>Modifier Spans</H2>
 
<P>Instead of using two modifiers, one to turn an option on, and one to turn it off, you use a modifier span. 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
i
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
<SPAN CLASS="regexplain">
caseless
</SPAN>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
-
</SPAN>
<SPAN CLASS="regexmeta">
i
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
<SPAN CLASS="regexplain">
cased
</SPAN>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
i
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
<SPAN CLASS="regexplain">
caseless
</SPAN>
</TT>
 is equivalent to 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
i
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
<SPAN CLASS="regexplain">
caseless
</SPAN>
<SPAN CLASS="regexnest1">
(?
</SPAN>
<SPAN CLASS="regexnest1">
-
</SPAN>
<SPAN CLASS="regexnest1">
i:
</SPAN>
<SPAN CLASS="regexplain">
cased
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
caseless
</SPAN>
</TT>
. This syntax resembles that of the 
<A HREF="brackets.html" TARGET="_top">
non-capturing group
</A>
 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?:
</SPAN>
<SPAN CLASS="regexplain">
group
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
. You could think of a non-capturing group as a modifier span that does not change any modifiers. But there are flavors, like 
<A HREF="javascript.html" TARGET="_top">
JavaScript
</A>
, 
<A HREF="python.html" TARGET="_top">
Python
</A>
, and 
<A HREF="tcl.html" TARGET="_top">
Tcl
</A>
 that support non-capturing groups even though they do not support modifier spans. Like a non-capturing group, the modifier span does not create a 
<A HREF="backref.html" TARGET="_top">
backreference
</A>
.</P>
 
<P>Modifier spans are supported by all regex flavors that allow you to use mode modifiers in the middle of the regular expression, and by those flavors only. These include the 
<A HREF="jgsoft.html" TARGET="_top">
JGsoft engine
</A>
, 
<A HREF="dotnet.html" TARGET="_top">
.NET
</A>
, 
<A HREF="java.html" TARGET="_top">
Java
</A>
, 
<A HREF="perl.html" TARGET="_top">
Perl
</A>
 and 
<A HREF="pcre.html" TARGET="_top">
PCRE
</A>
, 
<A HREF="php.html" TARGET="_top">
PHP
</A>
, 
<A HREF="delphi.html" TARGET="_top">
Delphi
</A>
, and 
<A HREF="rlanguage.html" TARGET="_top">
R
</A>
.</p>

</DIV>
 
<div class=topad>
<A HREF="//www.regexbuddy.com/create.html" TARGET="_top">
</A>
</div>
 
<H1>
Atomic Grouping
</h1>
 
<p>An atomic group is a group that, when the regex engine exits from it, automatically throws away all backtracking positions remembered by any tokens inside the group. Atomic groups are non-capturing. The syntax is 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?&gt;
</SPAN>
<SPAN CLASS="regexplain">
group
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
. 
<A HREF="lookaround.html" TARGET="_top">
Lookaround groups
</A>
 are also atomic. Atomic grouping is supported by most modern regular expression flavors, including the 
<A HREF="jgsoft.html" TARGET="_top">
JGsoft
</A>
 flavor, 
<A HREF="java.html" TARGET="_top">
Java
</A>
, 
<A HREF="pcre.html" TARGET="_top">
PCRE
</A>
, 
<A HREF="dotnet.html" TARGET="_top">
.NET
</A>
, 
<A HREF="perl.html" TARGET="_top">
Perl
</A>
, 
<A HREF="boost.html" TARGET="_top">
Boost
</A>
, and 
<A HREF="ruby.html" TARGET="_top">
Ruby
</A>
. Most of these also support 
<A HREF="possessive.html" TARGET="_top">
possessive quantifiers
</A>
, which are essentially a notational convenience for atomic grouping.</p>
 
<p>An example will make the behavior of atomic groups clear. The regular expression 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
bc
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
c
</SPAN>
</TT>
 (capturing group) matches 
<tt class=match>
abcc
</tt>
 and 
<tt class=match>
abc
</tt>
. The regex 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest1">
(?&gt;
</SPAN>
<SPAN CLASS="regexplain">
bc
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
c
</SPAN>
</TT>
 (atomic group) matches 
<tt class=match>
abcc
</tt>
 but not 
<tt class=string>
abc
</tt>
.</p>
 
<p>When applied to 
<tt class=string>
abc
</tt>
, both regexes will match 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
 to 
<tt class=match>
a
</tt>
, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
bc
</SPAN>
</TT>
 to 
<tt class=match>
bc
</tt>
, and then 
<TT CLASS=code>
<SPAN CLASS="regexplain">
c
</SPAN>
</TT>
 will fail to match at the end of the string. Here their paths diverge. The regex with the capturing group has remembered a backtracking position for the alternation. The group will give up its match, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
 then matches 
<tt class=match>
b
</tt>
 and 
<TT CLASS=code>
<SPAN CLASS="regexplain">
c
</SPAN>
</TT>
 matches 
<tt class=match>
c
</tt>
. Match found!</p>
 
<p>The regex with the atomic group, however, exited from an atomic group after 
<TT CLASS=code>
<SPAN CLASS="regexplain">
bc
</SPAN>
</TT>
 was matched. At that point, all backtracking positions for tokens inside the group are discarded. In this example, the alternation's option to try 
<TT CLASS=code>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
 at the second position in the string is discarded. As a result, when 
<TT CLASS=code>
<SPAN CLASS="regexplain">
c
</SPAN>
</TT>
 fails, the regex engine has no alternatives left to try.</p>
 
<p>Of course, the above example isn't very useful. But it does illustrate very clearly how atomic grouping eliminates certain matches. Or more importantly, it eliminates certain match attempts.</p>
<H2>Regex Optimization Using Atomic Grouping</h2>
 
<p>Consider the regex 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
integer
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
insert
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
in
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 and the subject 
<tt class=string>
integers
</tt>
. Obviously, because of the 
<A HREF="wordboundaries.html" TARGET="_top">
word boundaries
</A>
, these don't match. What's not so obvious is that the regex engine will spend quite some effort figuring this out.</p>
 
<p><TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 matches at the start of the string, and 
<TT CLASS=code>
<SPAN CLASS="regexplain">
integer
</SPAN>
</TT>
 matches 
<tt class=match>
integer
</tt>
. The regex engine makes note that there are two more alternatives in the group, and continues with 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
. This fails to match between the 
<tt class=string>
r
</tt>
 and 
<tt class=string>
s
</tt>
. So the engine backtracks to try the second alternative inside the group. The second alternative matches 
<tt class=match>
in
</tt>
, but then fails to match 
<TT CLASS=code>
<SPAN CLASS="regexplain">
s
</SPAN>
</TT>
. So the engine backtracks once more to the third alternative. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
in
</SPAN>
</TT>
 matches 
<tt class=match>
in
</tt>
. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 fails between the 
<tt class=string>
n
</tt>
 and 
<tt class=string>
t
</tt>
 this time. The regex engine has no more remembered backtracking positions, so it declares failure.</p>
 
<p>This is quite a lot of work to figure out 
<tt class=string>
integers
</tt>
 isn't in our list of words. We can optimize this by telling the regular expression engine that if it can't match 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 after it matched 
<tt class=match>
integer
</tt>
, then it shouldn't bother trying any of the other words. The word we've encountered in the subject string is a longer word, and it isn't in our list.</p>
 
<p>We can do this by turning the capturing group into an atomic group: 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexnest1">
(?&gt;
</SPAN>
<SPAN CLASS="regexplain">
integer
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
insert
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
in
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
. Now, when 
<TT CLASS=code>
<SPAN CLASS="regexplain">
integer
</SPAN>
</TT>
 matches, the engine exits from an atomic group, and throws away the backtracking positions it stored for the alternation. When 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 fails, the engine gives up immediately. This savings can be significant when scanning a large file for a long list of keywords. This savings will be vital when your alternatives contain 
<A HREF="repeat.html" TARGET="_top">
repeated tokens
</A>
 (not to mention repeated groups) that lead to 
<A HREF="catastrophic.html" TARGET="_top">
catastrophic backtracking
</A>
.</p>
 
<p>Don't be too quick to make all your groups atomic. As we saw in the first example above, atomic grouping can exclude valid matches too. Compare how 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexnest1">
(?&gt;
</SPAN>
<SPAN CLASS="regexplain">
integer
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
insert
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
in
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexnest1">
(?&gt;
</SPAN>
<SPAN CLASS="regexplain">
in
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
integer
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
insert
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 behave when applied to 
<tt class=string>
insert
</tt>
. The former regex matches, while the latter fails. If the groups weren't atomic, both regexes would match. Remember that 
<A HREF="alternation.html" TARGET="_top">
alternation
</A>
 tries its alternatives from left to right. If the second regex matches 
<tt class=match>
in
</tt>
, it won't try the two other alternatives due to the atomic group.</p>

</DIV>
 
<div class=topad>
<A HREF="//www.regexbuddy.com/create.html" TARGET="_top">
</A>
</div>
 
<H1>
Possessive Quantifiers
</h1>
 
<P>The topic on 
<A HREF="repeat.html" TARGET="_top">
repetition operators or quantifiers
</A>
 explains the difference between greedy and lazy repetition. Greediness and laziness determine the order in which the regex engine tries the possible permutations of the regex pattern. A greedy quantifier first tries to repeat the token as many times as possible, and gradually gives up matches as the engine backtracks to find an overall match. A lazy quantifier first repeats the token as few times as required, and gradually expands the match as the engine backtracks through the regex to find an overall match.</P>
 
<P>Because greediness and laziness change the order in which permutations are tried, they can change the overall regex match. However, they do not change the fact that the regex engine will backtrack to try all possible permutations of the regular expression in case no match can be found.</p>
 
<p>Possessive quantifiers are a way to prevent the regex engine from trying all permutations. This is primarily useful for performance reasons. You can also use possessive quantifiers to eliminate certain matches.</P>
 
<P>Of the regex flavors discussed in this tutorial, possessive quantifiers are supported by 
<A HREF="jgsoft.html" TARGET="_top">
JGsoft
</A>
, 
<A HREF="java.html" TARGET="_top">
Java
</A>
, and 
<A HREF="pcre.html" TARGET="_top">
PCRE
</A>
. That includes languages with regex support based on PCRE such as 
<A HREF="php.html" TARGET="_top">
PHP
</A>
, 
<A HREF="delphi.html" TARGET="_top">
Delphi
</A>
, and 
<A HREF="rlanguage.html" TARGET="_top">
R
</A>
. 
<A HREF="ruby.html" TARGET="_top">
Ruby
</A>
 supports possessive quantifiers starting with Ruby 1.9, 
<A HREF="perl.html" TARGET="_top">
Perl
</A>
 supports them starting with Perl 5.10, and 
<A HREF="boost.html" TARGET="_top">
Boost
</A>
 starting with Boost 1.42.</p>
<H2>How Possessive Quantifiers Work</h2>
 
<p>Like a greedy quantifier, a possessive quantifier repeats the token as many times as possible. Unlike a greedy quantifier, it does 
<i>
not
</i>
 give up matches as the engine backtracks. With a possessive quantifier, the deal is all or nothing. You can make a quantifier possessive by placing an extra 
<tt>
+
</tt>
 after it. 
<tt>
*
</tt>
 is greedy, 
<tt>
*?
</tt>
 is lazy, and 
<tt>
*+
</tt>
 is possessive. 
<tt>
++
</tt>
, 
<tt>
?+
</tt>
 and 
<tt>
{n,m}+
</tt>
 are all possessive as well.</p>
 
<p>Let's see what happens if we try to match 
<TT CLASS=code>
<SPAN CLASS="regexplain">
"
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
"
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexplain">
"
</SPAN>
</TT>
 against 
<tt class=string>
"abc"
</tt>
. The 
<TT CLASS=code>
<SPAN CLASS="regexplain">
"
</SPAN>
</TT>
 matches the 
<TT CLASS=match>
"
</TT>
. 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
"
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 matches 
<tt class=match>
a
</tt>
, 
<tt class=match>
b
</tt>
 and 
<tt class=match>
c
</tt>
 as it is repeated by the 
<A HREF="repeat.html" TARGET="_top">
star
</A>
. The final 
<TT CLASS=code>
<SPAN CLASS="regexplain">
"
</SPAN>
</TT>
 then matches the final 
<tt class=match>
"
</tt>
 and we found an overall match. In this case, the end result is the same, whether we use a greedy or possessive quantifier. There is a slight performance increase though, because the possessive quantifier doesn't have to remember any backtracking positions.</p>
 
<p>The performance increase can be significant in situations where the regex fails. If the subject is 
<tt class=string>
"abc
</tt>
 (no closing quote), the above matching process happens in the same way, except that the second 
<TT CLASS=code>
<SPAN CLASS="regexplain">
"
</SPAN>
</TT>
 fails. When using a possessive quantifier, there are no steps to backtrack to. The regular expression does not have any alternation or non-possessive quantifiers that can give up part of their match to try a different permutation of the regular expression. So the match attempt fails immediately when the second 
<TT CLASS=code>
<SPAN CLASS="regexplain">
"
</SPAN>
</TT>
 fails.</p>
 
<p>Had we used 
<TT CLASS=code>
<SPAN CLASS="regexplain">
"
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
"
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexplain">
"
</SPAN>
</TT>
 with a greedy quantifier instead, the engine would have backtracked. After the 
<TT CLASS=code>
<SPAN CLASS="regexplain">
"
</SPAN>
</TT>
 failed at the end of the string, the 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
"
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
 would give up one match, leaving it with 
<tt class=match>
ab
</tt>
. The 
<TT CLASS=code>
<SPAN CLASS="regexplain">
"
</SPAN>
</TT>
 would then fail to match 
<tt class=string>
c
</tt>
. 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
"
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
 backtracks to just 
<tt class=match>
a
</tt>
, and 
<TT CLASS=code>
<SPAN CLASS="regexplain">
"
</SPAN>
</TT>
 fails to match 
<tt class=string>
b
</tt>
. Finally, 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
"
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
 backtracks to match zero characters, and 
<TT CLASS=code>
<SPAN CLASS="regexplain">
"
</SPAN>
</TT>
 fails 
<tt class=string>
a
</tt>
. Only at this point have all backtracking positions been exhausted, and does the engine give up the match attempt. Essentially, this regex performs as many needless steps as there are characters following the unmatched opening quote.</p>
<H2>When Possessive Quantifiers Matter</h2>
 
<p>The main practical benefit of possessive quantifiers is to speed up your regular expression. In particular, possessive quantifiers allow your regex to fail faster. In the above example, when the closing quote fails to match, we 
<i>
know
</i>
 the regular expression couldn't possibly have skipped over a quote. So there's no need to backtrack and check for the quote. We make the regex engine aware of this by making the quantifier possessive. In fact, some engines, including the 
<A HREF="jgsoft.html" TARGET="_top">
JGsoft
</A>
 engine, detect that 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
"
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexplain">
"
</SPAN>
</TT>
 are mutually exclusive when compiling your regular expression, and automatically make the star possessive.</p>
 
<p>Now, linear backtracking like a regex with a single quantifier does is pretty fast. It's unlikely you'll notice the speed difference. However, when you're nesting quantifiers, a possessive quantifier may save your day. Nesting quantifiers means that you have one or more repeated tokens inside a group, and the group is also repeated. That's when 
<A HREF="catastrophic.html" TARGET="_top">
catastrophic backtracking
</A>
 often rears its ugly head. In such cases, you'll depend on possessive quantifiers and/or 
<A HREF="atomic.html" TARGET="_top">
atomic grouping
</A>
 to save the day.</p>
<H2>Possessive Quantifiers Can Change The Match Result</h2>
 
<p>Using possessive quantifiers can change the result of a match attempt. Since no backtracking is done, and matches that would require a greedy quantifier to backtrack will not be found with a possessive quantifier. For example, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
"
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexplain">
"
</SPAN>
</TT>
 matches 
<tt class=match>
"abc"
</tt>
 in 
<tt class=string>
"abc"x
</tt>
, but 
<TT CLASS=code>
<SPAN CLASS="regexplain">
"
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexplain">
"
</SPAN>
</TT>
 does not match this string at all.</p>
 
<p>In both regular expressions, the first 
<TT CLASS=code>
<SPAN CLASS="regexplain">
"
</SPAN>
</TT>
 matches the first 
<tt class=match>
"
</tt>
 in the string. The repeated dot then matches the remainder of the string 
<tt class=match>
abc"x
</tt>
. The second 
<TT CLASS=code>
<SPAN CLASS="regexplain">
"
</SPAN>
</TT>
 then fails to match at the end of the string.</p>
 
<p>Now, the paths of the two regular expressions diverge. The possessive dot-star wants it all. No backtracking is done. Since the 
<TT CLASS=code>
<SPAN CLASS="regexplain">
"
</SPAN>
</TT>
 failed, there are no permutations left to try, and the overall match attempt fails. The greedy dot-star, while initially grabbing everything, is willing to give back. It will backtrack one character at a time. Backtracking to 
<tt class=match>
abc"
</tt>
, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
"
</SPAN>
</TT>
 fails to match 
<tt class=string>
x
</tt>
. Backtracking to 
<tt class=match>
abc
</tt>
, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
"
</SPAN>
</TT>
 matches 
<tt class=match>
"
</tt>
. An overall match 
<tt class=match>
"abc"
</tt>
 is found.</p>
 
<p>Essentially, the lesson here is that when using possessive quantifiers, you need to make sure that whatever you're applying the possessive quantifier to should not be able to match what should follow it. The problem in the above example is that the dot also matches the closing quote. This prevents us from using a possessive quantifier. The negated character class in the previous section cannot match the closing quote, so we can make it possessive.</p>
 
<h2>Using Atomic Grouping Instead of Possessive Quantifiers</h2>
 
<p>Technically, possessive quantifiers are a notational convenience to place an 
<A HREF="atomic.html" TARGET="_top">
atomic group
</A>
 around a single quantifier. All regex flavors that support possessive quantifiers also support atomic grouping. But not all regex flavors that support atomic grouping support possessive quantifiers. With those flavors, you can achieve the exact same results using an atomic group.</p>
 
<p>Basically, instead of 
<TT CLASS=code>
<SPAN CLASS="regexplain">
X
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
, write 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?&gt;
</SPAN>
<SPAN CLASS="regexplain">
X
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
. It is important to notice that both the quantified token X and the quantifier are inside the atomic group. Even if X is a group, you still need to put an extra atomic group around it to achieve the same effect. 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?:
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 is equivalent to 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?&gt;
</SPAN>
<SPAN CLASS="regexnest2">
(?:
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 but not to 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?&gt;
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
. The latter is a valid regular expression, but it won't have the same effect when used as part of a larger regular expression.</p>
 
<p>To illustrate, 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?:
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?&gt;
</SPAN>
<SPAN CLASS="regexnest2">
(?:
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
 both fail to match 
<tt class=string>
b
</tt>
. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
 matches the 
<tt class=match>
b
</tt>
. The star is satisfied, and the fact that it's possessive or the atomic group will cause the star to forget all its backtracking positions. The second 
<TT CLASS=code>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
 in the regex has nothing left to match, and the overall match attempt fails.</p>
 
<p>In the regex 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?&gt;
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
, the atomic group forces the alternation to give up its backtracking positions. This means that if an 
<tt class=match>
a
</tt>
 is matched, it won't come back to try 
<TT CLASS=code>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
 if the rest of the regex fails. Since the star is outside of the group, it is a normal, greedy star. When the second 
<TT CLASS=code>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
 fails, the greedy star backtracks to zero iterations. Then, the second 
<TT CLASS=code>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
 matches the 
<tt class=match>
b
</tt>
 in the subject string.</p>
 
<p>This distinction is particularly important when converting a regular expression written by somebody else using possessive quantifiers to a regex flavor that doesn't have possessive quantifiers. You could, of course, let a tool like 
<A HREF="regexbuddy.html" TARGET="_top">
RegexBuddy
</A>
 do the conversion for you.</p>

</DIV>
 
<div class=topad>
<A HREF="//www.regexbuddy.com/create.html" TARGET="_top">
</A>
</div>
 
<H1>
Lookahead and Lookbehind Zero-Length Assertions
</h1>
 
<P>Lookahead and lookbehind, collectively called "lookaround", are zero-length assertions just like the 
<A HREF="anchors.html" TARGET="_top">
start and end of line
</A>
, and 
<A HREF="wordboundaries.html" TARGET="_top">
start and end of word
</A>
 anchors explained earlier in this tutorial. The difference is that lookaround actually matches characters, but then gives up the match, returning only the result: match or no match. That is why they are called "assertions". They do not consume characters in the string, but only assert whether a match is possible or not. Lookaround allows you to create regular expressions that are impossible to create without them, or that would get very longwinded without them.</P>
 
<A NAME="lookahead">
</A>

<H2>Positive and Negative Lookahead</H2>
 
<P>Negative lookahead is indispensable if you want to match something not followed by something else. When explaining 
<A HREF="charclass.html" TARGET="_top">
character classes
</A>
, this tutorial explained why you cannot use a negated character class to match a 
<tt class=match>
q
</tt>
 not followed by a 
<tt class=string>
u
</tt>
. Negative lookahead provides the solution: 
<TT CLASS=code>
<SPAN CLASS="regexplain">
q
</SPAN>
<SPAN CLASS="regexnest1">
(?!
</SPAN>
<SPAN CLASS="regexplain">
u
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
. The negative lookahead construct is the pair of parentheses, with the opening parenthesis followed by a question mark and an exclamation point. Inside the lookahead, we have the trivial regex 
<TT CLASS=code>
<SPAN CLASS="regexplain">
u
</SPAN>
</TT>
.</P>
 
<P>Positive lookahead works just the same. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
q
</SPAN>
<SPAN CLASS="regexnest1">
(?=
</SPAN>
<SPAN CLASS="regexplain">
u
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 matches a q that is followed by a u, without making the u part of the match. The positive lookahead construct is a pair of parentheses, with the opening parenthesis followed by a question mark and an equals sign.</P>
 
<P>You can use any regular expression inside the lookahead (but not lookbehind, as explained below). Any valid regular expression can be used inside the lookahead. If it contains 
<A HREF="brackets.html" TARGET="_top">
capturing groups
</A>
 then those groups will capture as normal and backreferences to them will work normally, even outside the lookahead. (The only exception is 
<A HREF="tcl.html" TARGET="_top">
Tcl
</A>
, which treats all groups inside lookahead as non-capturing.) The lookahead itself is not a capturing group. It is not included in the count towards numbering the backreferences. If you want to store the match of the regex inside a lookahead, you have to put capturing parentheses around the regex inside the lookahead, like this: 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?=
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexplain">
regex
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
. The other way around will not work, because the lookahead will already have discarded the regex match by the time the capturing group is to store its match.</P>
<H2>Regex Engine Internals</H2>
 
<P>First, let's see how the engine applies 
<TT CLASS=code>
<SPAN CLASS="regexplain">
q
</SPAN>
<SPAN CLASS="regexnest1">
(?!
</SPAN>
<SPAN CLASS="regexplain">
u
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 to the string 
<TT CLASS=string>
Iraq
</TT>
. The first token in the regex is the 
<A HREF="characters.html" TARGET="_top">
literal
</A>
 
<TT CLASS=code>
<SPAN CLASS="regexplain">
q
</SPAN>
</TT>
. As we already know, this causes the engine to traverse the string until the 
<TT CLASS=match>
q
</TT>
 in the string is matched. The position in the string is now the void after the string. The next token is the lookahead. The engine takes note that it is inside a lookahead construct now, and begins matching the regex inside the lookahead. So the next token is 
<TT CLASS=code>
<SPAN CLASS="regexplain">
u
</SPAN>
</TT>
. This does not match the void after the string. The engine notes that the regex inside the lookahead failed. Because the lookahead is negative, this means that the lookahead has successfully matched at the current position. At this point, the entire regex has matched, and 
<TT CLASS=match>
q
</TT>
 is returned as the match.</P>
 
<P>Let's try applying the same regex to 
<TT CLASS=string>
quit
</TT>
. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
q
</SPAN>
</TT>
 matches 
<TT CLASS=match>
q
</TT>
. The next token is the 
<TT CLASS=code>
<SPAN CLASS="regexplain">
u
</SPAN>
</TT>
 inside the lookahead. The next character is the 
<TT CLASS=string>
u
</TT>
. These match. The engine advances to the next character: 
<TT CLASS=string>
i
</TT>
. However, it is done with the regex inside the lookahead. The engine notes success, and discards the regex match. This causes the engine to step back in the string to 
<TT CLASS=string>
u
</TT>
.</P>
 
<P>Because the lookahead is negative, the successful match inside it causes the lookahead to fail. Since there are no other permutations of this regex, the engine has to start again at the beginning. Since 
<TT CLASS=code>
<SPAN CLASS="regexplain">
q
</SPAN>
</TT>
 cannot match anywhere else, the engine reports failure.</P>
 
<P>Let's take one more look inside, to make sure you understand the implications of the lookahead. Let's apply 
<TT CLASS=code>
<SPAN CLASS="regexplain">
q
</SPAN>
<SPAN CLASS="regexnest1">
(?=
</SPAN>
<SPAN CLASS="regexplain">
u
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
i
</SPAN>
</TT>
 to 
<TT CLASS=string>
quit
</TT>
. The lookahead is now positive and is followed by another token. Again, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
q
</SPAN>
</TT>
 matches 
<TT CLASS=match>
q
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexplain">
u
</SPAN>
</TT>
 matches 
<TT CLASS=match>
u
</TT>
. Again, the match from the lookahead must be discarded, so the engine steps back from 
<TT CLASS=string>
i
</TT>
 in the string to 
<TT CLASS=string>
u
</TT>
. The lookahead was successful, so the engine continues with 
<TT CLASS=code>
<SPAN CLASS="regexplain">
i
</SPAN>
</TT>
. But 
<TT CLASS=code>
<SPAN CLASS="regexplain">
i
</SPAN>
</TT>
 cannot match 
<TT CLASS=string>
u
</TT>
. So this match attempt fails. All remaining attempts fail as well, because there are no more q's in the string.</P>
 
<A NAME="lookbehind">
</A>
<H2>Positive and Negative Lookbehind</H2>
 
<P>Lookbehind has the same effect, but works backwards. It tells the regex engine to temporarily step backwards in the string, to check if the text inside the lookbehind can be matched there. 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?&lt;!
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
 matches a "b" that is not preceded by an "a", using negative lookbehind. It doesn't match 
<TT CLASS=string>
cab
</TT>
, but matches the 
<TT CLASS=match>
b
</TT>
 (and only the 
<TT CLASS=match>
b
</TT>
) in 
<TT CLASS=string>
bed
</TT>
 or 
<TT CLASS=string>
debt
</TT>
. 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?&lt;=
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
 (positive lookbehind) matches the 
<TT CLASS=match>
b
</TT>
 (and only the 
<TT CLASS=match>
b
</TT>
) in 
<TT CLASS=match>
cab
</TT>
, but does not match 
<TT CLASS=string>
bed
</TT>
 or 
<TT CLASS=string>
debt
</TT>
.</P>
 
<P>The construct for positive lookbehind is 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?&lt;=
</SPAN>
<SPAN CLASS="regexplain">
text
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
: a pair of parentheses, with the opening parenthesis followed by a question mark, "less than" symbol, and an equals sign. Negative lookbehind is written as 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?&lt;!
</SPAN>
<SPAN CLASS="regexplain">
text
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
, using an exclamation point instead of an equals sign.</P>
 
<H2>More Regex Engine Internals</H2>
 
<P>Let's apply 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?&lt;=
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
 to 
<TT CLASS=string>
thingamabob
</TT>
. The engine starts with the lookbehind and the first character in the string. In this case, the lookbehind tells the engine to step back one character, and see if 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
 can be matched there. The engine cannot step back one character because there are no characters before the 
<TT CLASS=string>
t
</TT>
. So the lookbehind fails, and the engine starts again at the next character, the 
<TT CLASS=string>
h
</TT>
. (Note that a negative lookbehind would have succeeded here.) Again, the engine temporarily steps back one character to check if an "a" can be found there. It finds a 
<TT CLASS=string>
t
</TT>
, so the positive lookbehind fails again.</P>
 
<P>The lookbehind continues to fail until the regex reaches the 
<TT CLASS=string>
m
</TT>
 in the string. The engine again steps back one character, and notices that the 
<TT CLASS=match>
a
</TT>
 can be matched there. The positive lookbehind matches. Because it is zero-length, the current position in the string remains at the 
<TT CLASS=string>
m
</TT>
. The next token is 
<TT CLASS=code>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
, which cannot match here. The next character is the second 
<TT CLASS=string>
a
</TT>
 in the string. The engine steps back, and finds out that the 
<TT CLASS=string>
m
</TT>
 does not match 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
.</P>
 
<P>The next character is the first 
<TT CLASS=string>
b
</TT>
 in the string. The engine steps back and finds out that 
<TT CLASS=match>
a
</TT>
 satisfies the lookbehind. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
 matches 
<TT CLASS=match>
b
</TT>
, and the entire regex has been matched successfully. It matches one character: the first 
<TT CLASS=match>
b
</TT>
 in the string.</P>
 
<A NAME="limitbehind">
</A>
<H2>Important Notes About Lookbehind</H2>
 
<P>The good news is that you can use lookbehind anywhere in the regex, not only at the start. If you want to find a word not ending with an "s", you could use 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexnest1">
(?&lt;!
</SPAN>
<SPAN CLASS="regexplain">
s
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
. This is definitely not the same as 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
s
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
. When applied to 
<TT CLASS=string>
John's
</TT>
, the former matches 
<TT CLASS=match>
John
</TT>
 and the latter matches 
<TT CLASS=match>
John'
</TT>
 (including the apostrophe). I will leave it up to you to figure out why. (Hint: 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 matches between the apostrophe and the 
<TT CLASS=string>
s
</TT>
). The latter also doesn't match single-letter words like "a" or "I". The correct regex without using lookbehind is 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
s
</SPAN>
<SPAN CLASS="regexccspecial">
\W
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 (star instead of plus, and \W in the character class). Personally, I find the lookbehind easier to understand. The last regex, which works correctly, has a double negation (the \W in the negated character class). Double negations tend to be confusing to humans. Not to regex engines, though. (Except perhaps for Tcl, which treats negated shorthands in negated character classes as an error.)</P>
 
<P>The bad news is that most regex flavors do not allow you to use just any regex inside a lookbehind, because they cannot apply a regular expression backwards. The regular expression engine needs to be able to figure out how many characters to step back before checking the lookbehind. When evaluating the lookbehind, the regex engine determines the length of the regex inside the lookbehind, steps back that many characters in the subject string, and then applies the regex inside the lookbehind from left to right just as it would with a normal regex.</P>
 
<P>Many regex flavors, including those used by 
<A HREF="perl.html" TARGET="_top">
Perl
</A>
, 
<A HREF="python.html" TARGET="_top">
Python
</A>
, and 
<A HREF="boost.html" TARGET="_top">
Boost
</A>
 only allow fixed-length strings. You can use 
<A HREF="characters.html" TARGET="_top">
literal text
</A>
, 
<a href="nonprint.html#hex">
character escapes
</a>
, 
<a href="nonprint.html#hex">
Unicode escapes
</a>
 other than 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\X
</SPAN>
</TT>
, and 
<A HREF="charclass.html" TARGET="_top">
character classes
</A>
. You cannot use 
<A HREF="repeat.html" TARGET="_top">
quantifiers
</A>
 or 
<A HREF="backref.html" TARGET="_top">
backreferences
</A>
. You can use 
<A HREF="alternation.html" TARGET="_top">
alternation
</A>
, but only if all alternatives have the same length. These flavors evaluate lookbehind by first stepping back through the subject string for as many characters as the lookbehind needs, and then attempting the regex inside the lookbehind from left to right.</P>
 
<p><A HREF="pcre.html" TARGET="_top">
PCRE
</A>
 is not fully Perl-compatible when it comes to lookbehind. While Perl requires alternatives inside lookbehind to have the same length, PCRE allows alternatives of variable length. 
<A HREF="php.html" TARGET="_top">
PHP
</A>
, 
<A HREF="delphi.html" TARGET="_top">
Delphi
</A>
, 
<A HREF="rlanguage.html" TARGET="_top">
R
</A>
, and 
<A HREF="ruby.html" TARGET="_top">
Ruby
</A>
 also allow this. Each alternative still has to be fixed-length. Each alternative is treated as a separate fixed-length lookbehind.</p>
 
<P><A HREF="java.html" TARGET="_top">
Java
</A>
 takes things a step further by allowing finite repetition. You still cannot use the 
<A HREF="repeat.html" TARGET="_top">
star
</A>
 or 
<A HREF="repeat.html" TARGET="_top">
plus
</A>
, but you can use the 
<A HREF="optional.html" TARGET="_top">
question mark
</A>
 and the 
<A HREF="repeat.html" TARGET="_top">
curly braces
</A>
 with the 
<i>
max
</i>
 parameter specified. Java determines the minimum and maximum possible lengths of the lookbehind. The lookbehind in the regex 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?&lt;!
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
<SPAN CLASS="regexspecial">
{2,4}
</SPAN>
<SPAN CLASS="regexplain">
c
</SPAN>
<SPAN CLASS="regexspecial">
{3,5}
</SPAN>
<SPAN CLASS="regexplain">
d
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
test
</SPAN>
</TT>
 has 5 possible lengths. It can be from 7 through 11 characters long. When Java (version 6 or later) tries to match the lookbehind, it first steps back the minimum number of characters (7 in this example) in the string and then evaluates the regex inside the lookbehind as usual, from left to right. If it fails, Java steps back one more character and tries again. If the lookbehind continues to fail, Java continues to step back until the lookbehind either matches or it has stepped back the maximum number of characters (11 in this example). This repeated stepping back through the subject string kills performance when the number of possible lengths of the lookbehind grows. Keep this in mind. Don't choose an arbitrarily large maximum number of repetitions to work around the lack of infinite quantifiers inside lookbehind. Java 4 and 5 have bugs that cause lookbehind with alternation or variable quantifiers to fail when it should succeed in some situations. These bugs were fixed in Java 6.</P>
 
<P>The only regex engines that allow you to use a full regular expression inside lookbehind, including infinite repetition and backreferences, are the 
<A HREF="jgsoft.html" TARGET="_top">
JGsoft engine
</A>
 and the 
<A HREF="dotnet.html" TARGET="_top">
.NET framework RegEx classes
</A>
. These regex engines really apply the regex inside the lookbehind backwards, going through the regex inside the lookbehind and through the subject string from right to left. They only need to evaluate the lookbehind once, regardless of how many different possible lengths it has.</P>
 
<P>Finally, flavors like 
<A HREF="javascript.html" TARGET="_top">
JavaScript
</A>
, 
<A HREF="stdregex.html" TARGET="_top">
std::regex
</A>
, and 
<A HREF="tcl.html" TARGET="_top">
Tcl
</A>
 do not support lookbehind at all, even though they do support lookahead.</P>
 
<H2>Lookaround Is Atomic</H2>
 
<P>The fact that lookaround is zero-length automatically makes it 
<a href="atomic.html#use">
atomic
</a>
. As soon as the lookaround condition is satisfied, the regex engine forgets about everything inside the lookaround. It will not backtrack inside the lookaround to try different permutations.</P>
 
<P>The only situation in which this makes any difference is when you use 
<A HREF="brackets.html" TARGET="_top">
capturing groups
</A>
 inside the lookaround. Since the regex engine does not backtrack into the lookaround, it will not try different permutations of the capturing groups.</P>
 
<P>For this reason, the regex 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?=
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexspecial">
\d
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexspecial">
\1
</SPAN>
</TT>
 never matches 
<tt class=string>
123x12
</tt>
. First the lookaround captures 
<tt class=match>
123
</tt>
 into 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\1
</SPAN>
</TT>
. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 then matches the whole string and backtracks until it matches only 
<tt class=match>
1
</tt>
. Finally, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 fails since 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\1
</SPAN>
</TT>
 cannot be matched at any position. Now, the regex engine has nothing to backtrack to, and the overall regex fails. The backtracking steps created by 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\d
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 have been discarded. It never gets to the point where the lookahead captures only 
<tt class=string>
12
</tt>
.</P>
 
<P>Obviously, the regex engine does try further positions in the string. If we change the subject string, the regex 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?=
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexspecial">
\d
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexspecial">
\1
</SPAN>
</TT>
 does match 
<tt class=match>
56x56
</tt>
 in 
<tt class=string>
456x56
</tt>
.</P>
 
<P>If you don't use capturing groups inside lookaround, then all this doesn't matter. Either the lookaround condition can be satisfied or it cannot be. In how many ways it can be satisfied is irrelevant.</P>

</DIV>
 
<div class=topad>
<A HREF="//www.regexbuddy.com/create.html" TARGET="_top">
</A>
</div>
 
<H1>
Testing The Same Part of a String for More Than One Requirement
</h1>
 
<P><A HREF="lookaround.html" TARGET="_top">
Lookaround
</A>
, which was introduced in detail in the 
<A HREF="lookaround.html" TARGET="_top">
previous topic
</A>
, is a very powerful concept. Unfortunately, it is often underused by people new to regular expressions, because lookaround is a bit confusing. The confusing part is that the lookaround is zero-length. So if you have a regex in which a lookahead is followed by another piece of regex, or a lookbehind is preceded by another piece of regex, then the regex traverses part of the string twice.</P>
 
<P>A more practical example makes this clear. Let's say we want to find a word that is six letters long and contains the three consecutive letters 
<TT CLASS=string>
cat
</TT>
. Actually, we can match this without lookaround. We just specify all the options and lump them together using 
<A HREF="alternation.html" TARGET="_top">
alternation
</A>
: 
<TT CLASS=code>
<SPAN CLASS="regexplain">
cat
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
{3}
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexplain">
cat
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
{2}
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
{2}
</SPAN>
<SPAN CLASS="regexplain">
cat
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
{3}
</SPAN>
<SPAN CLASS="regexplain">
cat
</SPAN>
</TT>
. Easy enough. But this method gets unwieldy if you want to find any word between 6 and 12 letters long containing either "cat", "dog" or "mouse".</P>
<H2>Lookaround to The Rescue</H2>
 
<P>In this example, we basically have two requirements for a successful match. First, we want a word that is 6 letters long. Second, the word we found must contain the word "cat".</P>
 
<P>Matching a 6-letter word is easy with 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
{6}
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
. Matching a word containing "cat" is equally easy: 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexplain">
cat
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
.</P>
 
<P>Combining the two, we get: 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?=
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
{6}
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexplain">
cat
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
. Easy! Here's how this works. At each character position in the string where the regex is attempted, the engine first attempts the regex inside the positive lookahead. This sub-regex, and therefore the lookahead, matches only when the current character position in the string is at the start of a 6-letter word in the string. If not, the lookahead fails and the engine continues trying the regex from the start at the next character position in the string.</P>
 
<P>The lookahead is zero-length. So when the regex inside the lookahead has found the 6-letter word, the current position in the string is still at the beginning of the 6-letter word. The regex engine attempts the remainder of the regex at this position. Because we already know that a 6-letter word can be matched at the current position, we know that 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 matches and that the first 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
 matches 6 times. The engine then 
<A HREF="repeat.html" TARGET="_top">
backtracks
</A>
, reducing the number of characters matched by 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
, until 
<TT CLASS=code>
<SPAN CLASS="regexplain">
cat
</SPAN>
</TT>
 can be matched. If 
<TT CLASS=code>
<SPAN CLASS="regexplain">
cat
</SPAN>
</TT>
 cannot be matched, the engine has no other choice but to restart at the beginning of the regex, at the next character position in the string. This is at the second letter in the 6-letter word we just found, where the lookahead will fail, causing the engine to advance character by character until the next 6-letter word.</P>
 
<P>If 
<TT CLASS=code>
<SPAN CLASS="regexplain">
cat
</SPAN>
</TT>
 can be successfully matched, the second 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
 consumes the remaining letters, if any, in the 6-letter word. After that, the last 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 in the regex is guaranteed to match where the second 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 inside the lookahead matched. Our double-requirement-regex has matched successfully.</P>
<H2>Optimizing Our Solution</H2>
 
<P>While the above regex works just fine, it is not the most optimal solution. This is not a problem if you are just doing a search in a text editor. But optimizing things is a good idea if this regex will be used repeatedly and/or on large chunks of data in an application you are developing.</P>
 
<P>You can discover these optimizations by yourself if you carefully examine the regex and follow how the regex engine applies it, as we did above. The third and last 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 are guaranteed to match. Since 
<A HREF="wordboundaries.html" TARGET="_top">
word boundaries
</A>
 are zero-length, and therefore do not change the result returned by the regex engine, we can remove them, leaving: 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?=
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
{6}
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexplain">
cat
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
. Though the last 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
 is also guaranteed to match, we cannot remove it because it adds characters to the regex match. Remember that the lookahead discards its match, so it does not contribute to the match returned by the regex engine. If we omitted the 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
, the resulting match would be the start of a 6-letter word containing "cat", up to and including "cat", instead of the entire word.</P>
 
<P>But we can optimize the first 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
. As it stands, it will match 6 letters and then backtrack. But we know that in a successful match, there can never be more than 3 letters before "cat". So we can optimize this to 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
{0,3}
</SPAN>
</TT>
. Note that making the asterisk lazy would not have optimized this sufficiently. The lazy asterisk would find a successful match sooner, but if a 6-letter word does not contain "cat", it would still cause the regex engine to try matching "cat" at the last two letters, at the last single letter, and even at one character beyond the 6-letter word.</P>
 
<P>So we have 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?=
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
{6}
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
{0,3}
</SPAN>
<SPAN CLASS="regexplain">
cat
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
. One last, minor, optimization involves the first 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
. Since it is zero-length itself, there's no need to put it inside the lookahead. So the final regex is: 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexnest1">
(?=
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
{6}
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
{0,3}
</SPAN>
<SPAN CLASS="regexplain">
cat
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
.</P>
 
<p>You could replace the final 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
 with 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
{0,3}
</SPAN>
</TT>
 too. But it wouldn't make any difference. The lookahead has already checked that we're at a 6-letter word, and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
{0,3}
</SPAN>
<SPAN CLASS="regexplain">
cat
</SPAN>
</TT>
 has already matched 3 to 6 letters of that word. Whether we end the regex with 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
{0,3}
</SPAN>
</TT>
 doesn't matter, because either way, we'll be matching all the remaining word characters. Because the resulting match and the speed at which it is found are the same, we may just as well use the version that is easier to type.</p>
<H2>A More Complex Problem</H2>
 
<P>So, what would you use to find any word between 6 and 12 letters long containing either "cat", "dog" or "mouse"? Again we have two requirements, which we can easily combine using a lookahead: 
<TT CLASS=code>
<SPAN CLASS="regexplain">
 
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexnest1">
(?=
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
{6,12}
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
{0,9}
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
cat
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
dog
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
mouse
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
. Very easy, once you get the hang of it. This regex will also put "cat", "dog" or "mouse" into the first backreference.</P>

</DIV>
 
<div class=topad>
<A HREF="//www.regexbuddy.com/create.html" TARGET="_top">
</A>
</div>
 
<h1>
Keep The Text Matched So Far out of The Overall Regex Match
</h1>
 
<p><A HREF="lookaround.html" TARGET="_top">
Lookbehind
</A>
 is often used to match certain text that is preceded by other text, without including the other text in the overall regex match. 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?&lt;=
</SPAN>
<SPAN CLASS="regexplain">
h
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
d
</SPAN>
</TT>
 matches only the second 
<tt class=match>
d
</tt>
 in 
<tt class=string>
adhd
</tt>
. While a lot of regex flavors support lookbehind, most regex flavors only allow a subset of the regex syntax to be used inside lookbehind. 
<A HREF="perl.html" TARGET="_top">
Perl
</A>
 and 
<A HREF="boost.html" TARGET="_top">
Boost
</A>
 require the lookbehind to be of fixed length. 
<A HREF="pcre.html" TARGET="_top">
PCRE
</A>
 and 
<A HREF="ruby.html" TARGET="_top">
Ruby
</A>
 allow 
<A HREF="alternation.html" TARGET="_top">
alternatives
</A>
 of different length, but still don't allow 
<A HREF="repeat.html" TARGET="_top">
quantifiers
</A>
 other than the fixed-length 
<tt>
{n}
</tt>
.</p>
 
<p>To overcome the limitations of lookbehind, Perl 5.10, PCRE 7.2, Ruby 2.0, and Boost 1.42 introduce a new feature that can be used instead of lookbehind for its most common purpose. 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
\K
</SPAN>
</TT>
 keeps the text matched so far out of the overall regex match. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
h
</SPAN>
<SPAN CLASS="regexmeta">
\K
</SPAN>
<SPAN CLASS="regexplain">
d
</SPAN>
</TT>
 matches only the second 
<tt class=match>
d
</tt>
 in 
<tt class=string>
adhd
</tt>
.</p>
 
<p>The 
<A HREF="jgsoft.html" TARGET="_top">
JGsoft flavor
</A>
 has always supported unrestricted 
<A HREF="lookaround.html" TARGET="_top">
lookbehind
</A>
, which is much more flexible than 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
\K
</SPAN>
</TT>
. Still, JGsoft V2 adds support for 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
\K
</SPAN>
</TT>
 if you prefer this way of working.</p>
<H2>Looking Inside The Regex Engine</h2>
 
<p>Let's see how 
<TT CLASS=code>
<SPAN CLASS="regexplain">
h
</SPAN>
<SPAN CLASS="regexmeta">
\K
</SPAN>
<SPAN CLASS="regexplain">
d
</SPAN>
</TT>
 works. The engine begins the match attempt at the start of the string. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
h
</SPAN>
</TT>
 fails to match 
<tt class=string>
a
</tt>
. There are no further alternatives to try. The match attempt at the start of the string has failed.</p>
 
<p>The engine advances one character through the string and attempts the match again. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
h
</SPAN>
</TT>
 fails to match 
<tt class=string>
d
</tt>
.</p>
 
<p>Advancing again, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
h
</SPAN>
</TT>
 matches 
<tt class=match>
h
</tt>
. The engine advances through the regex. The regex has now reached 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
\K
</SPAN>
</TT>
 in the regex and the position between 
<tt class=string>
h
</tt>
 and the second 
<tt class=string>
d
</tt>
 in the string. 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
\K
</SPAN>
</TT>
 does nothing other than to tell that if this match attempt ends up succeeding, the regex engine should pretend that the match attempt started at the present position between 
<tt class=string>
h
</tt>
 and 
<tt class=string>
d
</tt>
, rather than between the first 
<tt class=string>
d
</tt>
 and 
<tt class=string>
h
</tt>
 where it really started.</p>
 
<p>The engine advances through the regex. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
d
</SPAN>
</TT>
 matches the second 
<tt class=match>
d
</tt>
 in the string. An overall match is found. Because of the position saved by 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
\K
</SPAN>
</TT>
, the second 
<tt class=match>
d
</tt>
 in the string is returned as the overall match.</p>
 
<p><TT CLASS=code>
<SPAN CLASS="regexmeta">
\K
</SPAN>
</TT>
 only affects the position returned after a successful match. It does not move the start of the match attempt during the matching process. The regex 
<TT CLASS=code>
<SPAN CLASS="regexplain">
hhh
</SPAN>
<SPAN CLASS="regexmeta">
\K
</SPAN>
<SPAN CLASS="regexplain">
d
</SPAN>
</TT>
 matches the 
<tt class=match>
d
</tt>
 in 
<tt class=string>
hhhhd
</tt>
. This regex first matches 
<tt class=match>
hhh
</tt>
 at the start of the string. Then 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
\K
</SPAN>
</TT>
 notes the position between 
<tt class=string>
hhh
</tt>
 and 
<tt class=string>
hd
</tt>
 in the string. Then 
<TT CLASS=code>
<SPAN CLASS="regexplain">
d
</SPAN>
</TT>
 fails to match the fourth 
<tt class=string>
h
</tt>
 in the string. The match attempt at the start of the string has failed.</p>
 
<p>Now the engine must advance one character in the string before starting the next match attempt. It advances from the actual start of the match attempt, which was at the start of the string. The position stored by 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
\K
</SPAN>
</TT>
 does not change this. So the second match attempt begins at the position after the first 
<tt class=string>
h
</tt>
 in the string. Starting there, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
hhh
</SPAN>
</TT>
 matches 
<tt class=match>
hhh
</tt>
, 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
\K
</SPAN>
</TT>
 notes the position, and 
<TT CLASS=code>
<SPAN CLASS="regexplain">
d
</SPAN>
</TT>
 matches 
<tt class=match>
d
</tt>
. Now, the position remembered by 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
\K
</SPAN>
</TT>
 is taken into account, and 
<tt class=match>
d
</tt>
 is returned as the overall match.</p>
<H2>\K Can Be Used Anywhere</h2>
 
<p>You can use 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
\K
</SPAN>
</TT>
 pretty much anywhere in any regular expression. You should only avoid using it inside lookbehind. You can use it inside groups, even when they have quantifiers. You can have as many instances of 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
\K
</SPAN>
</TT>
 in your regex as you like. 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
ab
</SPAN>
<SPAN CLASS="regexmeta">
\K
</SPAN>
<SPAN CLASS="regexplain">
c
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
d
</SPAN>
<SPAN CLASS="regexmeta">
\K
</SPAN>
<SPAN CLASS="regexplain">
e
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
f
</SPAN>
</TT>
 matches 
<tt class=match>
cf
</tt>
 when preceded by 
<tt class=string>
ab
</tt>
. It also matches 
<tt class=match>
ef
</tt>
 when preceded by 
<tt class=string>
d
</tt>
.</p>
 
<p><TT CLASS=code>
<SPAN CLASS="regexmeta">
\K
</SPAN>
</TT>
 does not affect capturing groups. When 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
ab
</SPAN>
<SPAN CLASS="regexmeta">
\K
</SPAN>
<SPAN CLASS="regexplain">
c
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
d
</SPAN>
<SPAN CLASS="regexmeta">
\K
</SPAN>
<SPAN CLASS="regexplain">
e
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
f
</SPAN>
</TT>
 matches 
<tt class=match>
cf
</tt>
, the capturing group captures 
<tt class=match>
abc
</tt>
 as if the 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
\K
</SPAN>
</TT>
 weren't there. When the regex matches 
<tt class=match>
ef
</tt>
, the capturing group stores 
<tt class=match>
de
</tt>
.</p>
<H2>Limitations of \K</h2>
 
<p>Because 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
\K
</SPAN>
</TT>
 does not affect the way the regex engine goes through the matching process, it offers a lot more flexibility than lookbehind in Perl, PCRE, and Ruby. You can put anything to the left of 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
\K
</SPAN>
</TT>
, but you're limited to what you can put inside lookbehind.</p>
 
<p>But this flexibility does come at a cost. Lookbehind really goes backwards through the string. This allows lookbehind check for a match before the start of the match attempt. When the match attempt was started at the end of the previous match, lookbehind can match text that was part of the previous match. 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
\K
</SPAN>
</TT>
 cannot do this, precisely because it does not affect the way the regex engine goes through the matching process.</p>
 
<p>If you iterate over all matches of 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?&lt;=
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
 in the string 
<tt class=string>
aaaa
</tt>
, you will get three matches: the second, third, and fourth 
<tt class=match>
a
</tt>
 in the string. The first match attempt begins at the start of the string and fails because the lookbehind fails. The second match attempt begins between the first and second 
<tt class=string>
a
</tt>
, where the lookbehind succeeds and the second 
<tt class=match>
a
</tt>
 is matched. The third match attempt begins after the second 
<tt class=match>
a
</tt>
 that was just matched. Here the lookbehind succeeds too. It doesn't matter that the preceding 
<tt class=match>
a
</tt>
 was part of the previous match. Thus the third match attempt matches the third 
<tt class=match>
a
</tt>
. Similarly, the fourth match attempt matches the fourth 
<tt class=match>
a
</tt>
. The fifth match attempt starts at the end of the string. The lookbehind still succeeds, but there are no characters left for 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
 to match. The match attempt fails. The engine has reached the end of the string and the iteration stops. Five match attempts have found three matches.</p>
 
<p>Things are different when you iterate over 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexmeta">
\K
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
 in the string 
<tt class=string>
aaaa
</tt>
. You will get only two matches: the second and the fourth 
<tt class=match>
a
</tt>
. The first match attempt begins at the start of the string. The first 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
 in the regex matches the first 
<tt class=match>
a
</tt>
 in the string. 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
\K
</SPAN>
</TT>
 notes the position. The second 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
 matches the second 
<tt class=match>
a
</tt>
 in the string, which is returned as the first match. The second match attempt begins after the second 
<tt class=match>
a
</tt>
 that was just matched. The first 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
 in the regex matches the third 
<tt class=match>
a
</tt>
 in the string. 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
\K
</SPAN>
</TT>
 notes the position. The second 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
 matches the fourth 
<tt class=match>
a
</tt>
 in the string, which is returned as the first match. The third match attempt begins at the end of the string. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
 fails. The engine has reached the end of the string and the iteration stops. Three match attempts have found two matches.</p>
 
<p>Basically, you'll run into this issue when the part of the regex before the 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
\K
</SPAN>
</TT>
 can match the same text as the part of the regex after the 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
\K
</SPAN>
</TT>
. If those parts can't match the same text, then a regex using 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
\K
</SPAN>
</TT>
 will find the same matches than the same regex rewritten using lookbehind. In that case, you should use 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
\K
</SPAN>
</TT>
 instead of lookbehind as that will give you better performance in Perl, PCRE, and Ruby.</p>
 
<p>Another limitation is that while lookbehind comes in positive and negative variants, 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
\K
</SPAN>
</TT>
 does not provide a way to negate anything. 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?&lt;!
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
 matches the string 
<tt class=string>
b
</tt>
 entirely, because it is a "b" not preceded by an "a". 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
a
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexmeta">
\K
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
 does not match the string 
<tt class=string>
b
</tt>
 at all. When attempting the match, 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
a
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 matches 
<tt class=match>
b
</tt>
. The regex has now reached the end of the string. 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
\K
</SPAN>
</TT>
 notes this position. But now there is nothing left for 
<TT CLASS=code>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
 to match. The match attempt fails. 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
a
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexmeta">
\K
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
 is the same as 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?&lt;=
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
a
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
, which are both different from 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?&lt;!
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
.</p>

</DIV>
 
<div class=topad>
<A HREF="//www.regexbuddy.com/create.html" TARGET="_top">
</A>
</div>
 
<H1>
If-Then-Else Conditionals in Regular Expressions
</h1>
 
<P>A special construct 
<TT>
(?ifthen|else)
</TT>
 allows you to create conditional regular expressions. If the 
<EM>
if
</EM>
 part evaluates to true, then the regex engine will attempt to match the 
<EM>
then
</EM>
 part. Otherwise, the 
<EM>
else
</EM>
 part is attempted instead. The syntax consists of a pair of parentheses. The opening bracket must be followed by a question mark, immediately followed by the 
<EM>
if
</EM>
 part, immediately followed by the 
<EM>
then
</EM>
 part. This part can be followed by a vertical bar and the 
<EM>
else
</EM>
 part. You may omit the 
<EM>
else
</EM>
 part, and the vertical bar with it.</P>
 
<P>For the 
<EM>
if
</EM>
 part, you can use the 
<A HREF="lookaround.html" TARGET="_top">
lookahead and lookbehind
</A>
 constructs. Using positive lookahead, the syntax becomes 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?
</SPAN>
<SPAN CLASS="regexnest2">
(?=
</SPAN>
<SPAN CLASS="regexplain">
regex
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexplain">
then
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
else
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
. Because the lookahead has its own parentheses, the 
<EM>
if
</EM>
 and 
<EM>
then
</EM>
 parts are clearly separated.</P>
 
<P>Remember that the lookaround constructs do not consume any characters. If you use a lookahead as the 
<EM>
if
</EM>
 part, then the regex engine will attempt to match the 
<EM>
then
</EM>
 or 
<EM>
else part
</EM>
 (depending on the outcome of the lookahead) at the same position where the 
<EM>
if
</EM>
 was attempted.</P>
 
<P>Alternatively, you can check in the 
<EM>
if
</EM>
 part whether a 
<A HREF="brackets.html" TARGET="_top">
capturing group
</A>
 has taken part in the match thus far. Place the number of the capturing group inside parentheses, and use that as the if part. Note that although the syntax for a conditional check on a backreference is the same as a number inside a capturing group, no capturing group is created. The number and the parentheses are part of the if-then-else syntax started with 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?
</SPAN>
</TT>
.</P>
 
<P>For the 
<EM>
then
</EM>
 and 
<EM>
else
</EM>
, you can use any regular expression. If you want to use 
<A HREF="alternation.html" TARGET="_top">
alternation
</A>
, you will have to group the 
<EM>
then
</EM>
 or 
<EM>
else
</EM>
 together using 
<A HREF="brackets.html" TARGET="_top">
parentheses
</A>
, like in 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?
</SPAN>
<SPAN CLASS="regexnest2">
(?=
</SPAN>
<SPAN CLASS="regexplain">
condition
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexplain">
then1
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
then2
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
then3
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexplain">
else1
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
else2
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
else3
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
. Otherwise, there is no need to use parentheses around the 
<EM>
then
</EM>
 and 
<EM>
else
</EM>
 parts.</P>
<H2>Looking Inside The Regex Engine</h2>
 
<P>The regex 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
<SPAN CLASS="regexnest1">
(?(1)
</SPAN>
<SPAN CLASS="regexplain">
c
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
d
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 consists of the optional capturing group 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
</TT>
, the literal 
<TT CLASS=code>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
, and the conditional 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?(1)
</SPAN>
<SPAN CLASS="regexplain">
c
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
d
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 that tests the capturing group. This regex matches 
<TT CLASS=match>
bd
</TT>
 and 
<TT class=match>
abc
</TT>
. It does not match 
<tt class=string>
bc
</tt>
, but does match 
<TT CLASS=match>
bd
</TT>
 in 
<TT CLASS=string>
abd
</TT>
. Let's see how this regular expression works on each of these four subject strings.</p>
 
<p>When applied to 
<TT CLASS=string>
bd
</TT>
, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
 fails to match. Since the capturing group containing 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
 is optional, the engine continues with 
<TT CLASS=code>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
 at the start of the subject string. Since the whole group was optional, the group did not take part in the match. Any subsequent 
<A HREF="backref.html" TARGET="_top">
backreference
</A>
 to it like 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\1
</SPAN>
</TT>
 will fail. Note that 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
</TT>
 is very different from 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
. In the former regex, the capturing group does not take part in the match if 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
 fails, and backreferences to the group will fail. In the latter group, the capturing group always takes part in the match, capturing either 
<TT CLASS=match>
a
</TT>
 or nothing. Backreferences to a capturing group that took part in the match and captured nothing always succeed. Conditionals evaluating such groups execute the "then" part. In short: if you want to use a reference to a group in a conditional, use 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
</TT>
 instead of 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
.</p>
 
<p>Continuing with our regex, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
 matches 
<tt class=match>
b
</tt>
. The regex engine now evaluates the conditional. The first capturing group did not take part in the match at all, so the "else" part or 
<TT CLASS=code>
<SPAN CLASS="regexplain">
d
</SPAN>
</TT>
 is attempted. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
d
</SPAN>
</TT>
 matches 
<tt class=match>
d
</tt>
 and an overall match is found.</p>
 
<p>Moving on to our second subject string 
<TT class=string>
abc
</TT>
, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
 matches 
<tt class=match>
a
</tt>
, which is captured by the capturing group. Subsequently, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
 matches 
<tt class=match>
b
</tt>
. The regex engine again evaluates the conditional. The capturing group took part in the match, so the "then" part or 
<TT CLASS=code>
<SPAN CLASS="regexplain">
c
</SPAN>
</TT>
 is attempted. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
c
</SPAN>
</TT>
 matches 
<tt class=match>
c
</tt>
 and an overall match is found.</p>
 
<p>Our third subject 
<tt class=string>
bc
</tt>
 does not start with 
<tt class=string>
a
</tt>
, so the capturing group does not take part in the match attempt, like we saw with the first subject string. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
 still matches 
<tt class=match>
b
</tt>
, and the engine moves on to the conditional. The first capturing group did not take part in the match at all, so the "else" part or 
<TT CLASS=code>
<SPAN CLASS="regexplain">
d
</SPAN>
</TT>
 is attempted. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
d
</SPAN>
</TT>
 does not match 
<tt class=string>
c
</tt>
 and the match attempt at the start of the string fails. The engine does try again starting at the second character in the string, but fails since 
<TT CLASS=code>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
 does not match 
<tt class=string>
c
</tt>
.</p>
 
<p>The fourth subject 
<TT CLASS=string>
abd
</TT>
 is the most interesting one. Like in the second string, the capturing group grabs the 
<TT CLASS=match>
a
</TT>
 and the 
<TT CLASS=code>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
 matches. The capturing group took part in the match, so the "then" part or 
<TT CLASS=code>
<SPAN CLASS="regexplain">
c
</SPAN>
</TT>
 is attempted. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
c
</SPAN>
</TT>
 fails to match 
<tt class=string>
d
</tt>
, and the match attempt fails. Note that the "else" part is not attempted at this point. The capturing group took part in the match, so only the "then" part is used. However, the regex engine isn't done yet. It restarts the regular expression from the beginning, moving ahead one character in the subject string.</p>
 
<p>Starting at the second character in the string, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
 fails to match 
<TT CLASS=string>
b
</TT>
. The capturing group does not take part in the second match attempt which started at the second character in the string. The regex engine moves beyond the optional group, and attempts 
<TT CLASS=code>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
, which matches. The regex engine now arrives at the conditional in the regex, and at the third character in the subject string. The first capturing group did not take part in the current match attempt, so the "else" part or 
<TT CLASS=code>
<SPAN CLASS="regexplain">
d
</SPAN>
</TT>
 is attempted. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
d
</SPAN>
</TT>
 matches 
<tt class=match>
d
</tt>
 and an overall match 
<tt class=match>
bd
</tt>
 is found.</p>
 
<p>If you want to avoid this last match result, you need to use 
<A HREF="anchors.html" TARGET="_top">
anchors
</A>
. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
<SPAN CLASS="regexnest1">
(?(1)
</SPAN>
<SPAN CLASS="regexplain">
c
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
d
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
 does not find any matches in the last subject string. The caret fails to match before the second and third characters in the string.</p>
<H2>Named and Relative Conditionals</H2>
 
<P>Conditionals are supported by 
<A HREF="jgsoft.html" TARGET="_top">
the JGsoft engine
</A>
, 
<A HREF="perl.html" TARGET="_top">
Perl
</A>
, 
<A HREF="pcre.html" TARGET="_top">
PCRE
</A>
, 
<A HREF="python.html" TARGET="_top">
Python
</A>
, and the 
<A HREF="dotnet.html" TARGET="_top">
.NET framework
</A>
. 
<A HREF="ruby.html" TARGET="_top">
Ruby
</A>
 supports them starting with version 2.0. Languages such as 
<A HREF="delphi.html" TARGET="_top">
Delphi
</A>
, 
<A HREF="php.html" TARGET="_top">
PHP
</A>
, and 
<A HREF="rlanguage.html" TARGET="_top">
R
</A>
 that have regex features based on PCRE also support conditionals.</p>
 
<p>All these flavors also support 
<A HREF="named.html" TARGET="_top">
named capturing groups
</A>
. You can use the name of a capturing group instead of its number as the 
<EM>
if
</EM>
 test. The syntax is slightly inconsistent between regex flavors. In Python, .NET, and the JGsoft applications, you simply specify the name of the group between parentheses. 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?&lt;test&gt;
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
<SPAN CLASS="regexnest1">
(?(test)
</SPAN>
<SPAN CLASS="regexplain">
c
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
d
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 is the regex from the previous section using named capture. In Perl or Ruby, you have to put angle brackets or quotes around the name of the group, and put that between the conditional's parentheses: 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?&lt;test&gt;
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
<SPAN CLASS="regexnest1">
(?(&lt;test&gt;)
</SPAN>
<SPAN CLASS="regexplain">
c
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
d
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?'test'
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
<SPAN CLASS="regexnest1">
(?('test')
</SPAN>
<SPAN CLASS="regexplain">
c
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
d
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
. PCRE supports all three variants.</P>
 
<p>PCRE 7.2 and later and JGsoft V2 also support relative conditionals. The syntax is the same as that of a conditional that references a numbered capturing group with an added plus or minus sign before the group number. The conditional then counts the opening parentheses to the left (minus) or to the right (plus) starting at the 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?(
</SPAN>
</TT>
 that opens the conditional. 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
<SPAN CLASS="regexnest1">
(?(-1)
</SPAN>
<SPAN CLASS="regexplain">
c
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
d
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 is another way of writing the above regex. The benefit is that this regex won't break if you add capturing groups at the start or the end of the regex.</p>
 
<p><A HREF="python.html" TARGET="_top">
Python
</A>
 supports conditionals using a numbered or named capturing group. Python does not support conditionals using lookaround, even though Python does support lookaround outside conditionals. Instead of a conditional like 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?
</SPAN>
<SPAN CLASS="regexnest2">
(?=
</SPAN>
<SPAN CLASS="regexplain">
regex
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexplain">
then
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
else
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
, you can alternate two opposite lookarounds: 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?=
</SPAN>
<SPAN CLASS="regexplain">
regex
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
then
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexnest1">
(?!
</SPAN>
<SPAN CLASS="regexplain">
regex
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
else
</SPAN>
</TT>
.</p>
<H2>Conditionals Referencing Non-Existent Capturing Groups</H2>
 
<p><A HREF="boost.html" TARGET="_top">
Boost
</A>
 and 
<A HREF="ruby.html" TARGET="_top">
Ruby
</A>
 treat a conditional that references a non-existent capturing group as an error. The latest versions of all other flavors discussed in this tutorial don't. They simply let such conditionals always attempt the "else" part. A few flavors changed their minds, though. Python 3.4 and prior and PCRE 7.6 and prior (and thus PHP 5.2.5 and prior) used to treat them as errors.</p>
 
<H2>Example: Extract Email Headers</H2>
 
<P>The regex 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexplain">
From
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
To
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
Subject
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
: 
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexnest2">
(?(2)
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexplain">
@
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexescaped">
\.
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 extracts the From, To, and Subject headers from an email message. The name of the header is captured into the first backreference. If the header is the From or To header, it is captured into the second backreference as well.</P>
 
<P>The second part of the pattern is the if-then-else conditional 
<TT CLASS=code>
<SPAN CLASS="regexnest2">
(?(2)
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexplain">
@
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexescaped">
\.
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
. The 
<em>
if
</em>
 part checks whether the second capturing group took part in the match thus far. It will have taken part if the header is the From or To header. In that case, the 
<EM>
then
</EM>
 part of the conditional 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexplain">
@
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexescaped">
\.
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 tries to 
<A HREF="email.html" TARGET="_top">
match an email address
</A>
. To keep the example simple, we use an overly simple regex to match the email address, and we don't try to match the display name that is usually also part of the From or To header.</P>
 
<P>If the second capturing group did not participate in the match this far, the 
<EM>
else
</EM>
 part 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 is attempted instead. This simply matches the remainder of the line, allowing for any test subject.</P>
 
<P>Finally, we place an extra pair of parentheses around the conditional. This captures the contents of the email header matched by the conditional into the third backreference. The conditional itself does not capture anything. When implementing this regular expression, the first capturing group will store the name of the header ("From", "To", or "Subject"), and the third capturing group will store the value of the header.</P>
 
<p>You could try to match even more headers by putting another conditional into the "else" part. E.g. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexplain">
From
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
To
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexplain">
Date
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
Subject
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
: 
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexnest2">
(?(2)
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexplain">
@
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexescaped">
\.
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexnest3">
(?(3)
</SPAN>
<SPAN CLASS="regexplain">
mm/dd/yyyy
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexnest3">
)
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 would match a "From", "To", "Date" or "Subject", and use the regex 
<TT CLASS=code>
<SPAN CLASS="regexplain">
mm/dd/yyyy
</SPAN>
</TT>
 to check whether the 
<A HREF="dates.html" TARGET="_top">
date is valid
</A>
. Obviously, the date validation regex is just a dummy to keep the example simple. The header is captured in the first group, and its validated contents in the fourth group.</p>
 
<p>As you can see, regular expressions using conditionals quickly become unwieldy. I recommend that you only use them if one regular expression is all your tool allows you to use. When programming, you're far better of using the regex 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
From
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
To
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
Date
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
Subject
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
: 
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 to capture one header with its unvalidated contents. In your source code, check the name of the header returned in the first capturing group, and then use a second regular expression to validate the contents of the header returned in the second capturing group of the first regex. Though you'll have to write a few lines of extra code, this code will be much easier to understand and maintain. If you precompile all the regular expressions, using multiple regular expressions will be just as fast, if not faster, than the one big regex stuffed with conditionals.</p>

</DIV>
 
<div class=topad>
<A HREF="//www.regexbuddy.com/create.html" TARGET="_top">
</A>
</div>
 
<H1>
Matching Nested Constructs with Balancing Groups
</h1>
 
<p>The 
<A HREF="dotnet.html" TARGET="_top">
.NET
</A>
 regex flavor has a special feature called balancing groups. The main purpose of balancing groups is to match balanced constructs or nested constructs, which is where they get their name from. A technically more accurate name for the feature would be capturing group subtraction. That's what the feature really does. It's .NET's solution to a problem that other regex flavors like 
<A HREF="perl.html" TARGET="_top">
Perl
</A>
, 
<A HREF="pcre.html" TARGET="_top">
PCRE
</A>
, and 
<A HREF="ruby.html" TARGET="_top">
Ruby
</A>
 handle with 
<A HREF="recurse.html" TARGET="_top">
regular expression recursion
</A>
. 
<a href="jgsoft.html#v2">
JGsoft V2
</a>
 supports both balancing groups and recursion.</p>
 
<p><tt>
(?&lt;capture-subtract&gt;regex)
</tt>
 or 
<tt>
(?'capture-subtract'regex)
</tt>
 is the basic syntax of a balancing group. It's the same syntax used for 
<A HREF="named.html" TARGET="_top">
named capturing groups
</A>
 in .NET but with two group names delimited by a minus sign. The name of this group is "capture". You can omit the name of the group. 
<tt>
(?&lt;-subtract&gt;regex)
</tt>
 or 
<tt>
(?'-subtract'regex)
</tt>
 is the syntax for a non-capturing balancing group.</p>
 
<p>The name "subtract" must be the name of another group in the regex. When the regex engine enters the balancing group, it subtracts one match from the group "subtract". If the group "subtract" did not match yet, or if all its matches were already subtracted, then the balancing group fails to match. You could think of a balancing group as a 
<A HREF="conditional.html" TARGET="_top">
conditional
</A>
 that tests the group "subtract", with "regex" as the "if" part and an "else" part that always fails to match. The difference is that the balancing group has the added feature of subtracting one match from the group "subtract", while a conditional leaves the group untouched.</p>
 
<p>If the balancing group succeeds and it has a name ("capture" in this example), then the group captures the text between the end of the match that was subtracted from the group "subtract" and the start of the match of the balancing group itself ("regex" in this example).</p>
 
<p>The reason this works in .NET is that capturing groups in .NET keep a stack of everything they captured during the matching process that wasn't backtracked or subtracted. Most other regex engines only store the most recent match of each capturing groups. When 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 matches 
<tt class=match>
abc
</tt>
 then 
<tt>
Match.Groups[1].Value
</tt>
 returns 
<tt class=match>
c
</tt>
 as with other regex engines, but 
<tt>
Match.Groups[1].Captures
</tt>
 stores all three iterations of the group: 
<tt class=match>
a
</tt>
, 
<tt class=match>
b
</tt>
, and 
<tt class=match>
c
</tt>
.</p>
<H2>Looking Inside The Regex Engine</h2>
 
<p>Let's apply the regex 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?'open'
</SPAN>
<SPAN CLASS="regexplain">
o
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexnest1">
(?'between-open'
</SPAN>
<SPAN CLASS="regexplain">
c
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 to the string 
<tt class=string>
ooccc
</tt>
. 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?'open'
</SPAN>
<SPAN CLASS="regexplain">
o
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 matches the first 
<tt class=match>
o
</tt>
 and stores that as the first capture of the group "open". The 
<A HREF="repeat.html" TARGET="_top">
quantifier
</A>
 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 repeats the group. 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?'open'
</SPAN>
<SPAN CLASS="regexplain">
o
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 matches the second 
<tt class=match>
o
</tt>
 and stores that as the second capture. Repeating again, 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?'open'
</SPAN>
<SPAN CLASS="regexplain">
o
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 fails to match the first 
<tt class=string>
c
</tt>
. But the 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 is satisfied with two repetitions.</p>
 
<p>The regex engine advances to 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?'between-open'
</SPAN>
<SPAN CLASS="regexplain">
c
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
. Before the engine can enter this balancing group, it must check whether the subtracted group "open" has captured something. It has captured the second 
<tt class=match>
o
</tt>
. The engine enters the group, subtracting the most recent capture from "open". This leaves the group "open" with the first 
<tt class=match>
o
</tt>
 as its only capture. Now inside the balancing group, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
c
</SPAN>
</TT>
 matches 
<tt class=match>
c
</tt>
. The engine exits the balancing group. The group "between" captures the text between the match subtracted from "open" (the second 
<tt class=match>
o
</tt>
) and the 
<tt class=match>
c
</tt>
 just matched by the balancing group. This is an empty string but it is captured anyway.</p>
 
<p>The balancing group too has 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 as its quantifier. The engine again finds that the subtracted group "open" captured something, namely the first 
<tt class=match>
o
</tt>
. The regex enters the balancing group, leaving the group "open" without any matches. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
c
</SPAN>
</TT>
 matches the second 
<tt class=match>
c
</tt>
 in the string. The group "between" captures 
<tt class=match>
oc
</tt>
 which is the text between the match subtracted from "open" (the first 
<tt class=match>
o
</tt>
) and the second 
<tt class=match>
c
</tt>
 just matched by the balancing group.</p>
 
<p>The balancing group is repeated again. But this time, the regex engine finds that the group "open" has no matches left. The balancing group fails to match. The group "between" is unaffected, retaining its most recent capture.</p>
 
<p>The 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 is satisfied with two iterations. The engine has reached the end of the regex. It returns 
<tt class=match>
oocc
</tt>
 as the overall match. 
<tt>
Match.Groups['open'].Success
</tt>
 will return 
<tt>
false
</tt>
, because all the captures of that group were subtracted. 
<tt>
Match.Groups['between'].Value
</tt>
 returns 
<tt>
"oc"
</tt>
.</p>
 
<h2>Matching Balanced Pairs</h2>
 
<p>We need to modify this regex if we want it to match a balanced number of o's and c's. To make sure that the regex won't match 
<tt class=string>
ooccc
</tt>
, which has more c's than o's, we can add 
<A HREF="anchors.html" TARGET="_top">
anchors
</A>
: 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
<SPAN CLASS="regexnest1">
(?'open'
</SPAN>
<SPAN CLASS="regexplain">
o
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexnest1">
(?'-open'
</SPAN>
<SPAN CLASS="regexplain">
c
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
. This regex goes through the same matching process as the previous one. But after 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?'-open'
</SPAN>
<SPAN CLASS="regexplain">
c
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 fails to match its third iteration, the engine reaches 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
 instead of the end of the regex. This fails to match. The regex engine will backtrack trying different permutations of the quantifiers, but they will all fail to match. No match can be found.</p>
 
<p>But the regex 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
<SPAN CLASS="regexnest1">
(?'open'
</SPAN>
<SPAN CLASS="regexplain">
o
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexnest1">
(?'-open'
</SPAN>
<SPAN CLASS="regexplain">
c
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
 still matches 
<tt class=match>
ooc
</tt>
. The matching process is again the same until the balancing group has matched the first 
<tt class=match>
c
</tt>
 and left the group 'open' with the first 
<tt class=match>
o
</tt>
 as its only capture. The quantifier makes the engine attempt the balancing group again. The engine again finds that the subtracted group "open" captured something. The regex enters the balancing group, leaving the group "open" without any matches. But now, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
c
</SPAN>
</TT>
 fails to match because the regex engine has reached the end of the string.</p>
 
<p>The regex engine must now backtrack out of the balancing group. When backtracking a balancing group, .NET also backtracks the subtraction. Since the capture of the the first 
<tt class=match>
o
</tt>
 was subtracted from "open" when entering the balancing group, this capture is now restored while backtracking out of the balancing group. The repeated group 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?'-open'
</SPAN>
<SPAN CLASS="regexplain">
c
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 is now reduced to a single iteration. But the quantifier is fine with that, as 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 means "once or more" as it always does. Still at the end of the string, the regex engine reaches 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
 in the regex, which matches. The whole string 
<tt class=match>
ooc
</tt>
 is returned as the overall match. 
<tt>
Match.Groups['open'].Captures
</tt>
 will hold the first 
<tt class=match>
o
</tt>
 in the string as the only item in the CaptureCollection. That's because, after backtracking, the second 
<tt class=match>
o
</tt>
 was subtracted from the group, but the first 
<tt class=match>
o
</tt>
 was not.</p>
 
<p>To make sure the regex matches 
<tt class=match>
oc
</tt>
 and 
<tt class=match>
oocc
</tt>
 but not 
<tt class=string>
ooc
</tt>
, we need to check that the group "open" has no captures left when the matching process reaches the end of the regex. We can do this with a 
<A HREF="conditional.html" TARGET="_top">
conditional
</A>
. 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?(open)
</SPAN>
<SPAN CLASS="regexnest2">
(?!)
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 is a conditional that checks whether the group "open" matched something. In .NET, having matched something means still having captures on the stack that weren't backtracked or subtracted. If the group has captured something, the "if" part of the conditional is evaluated. In this case that is the empty negative lookahead 
<TT CLASS=code>
<SPAN CLASS="regexnest2">
(?!)
</SPAN>
</TT>
. The empty string inside this lookahead always matches. Because the lookahead is negative, this causes the lookahead to always fail. Thus the conditional always fails if the group has captured something. If the group has not captured anything, the "else" part of the conditional is evaluated. In this case there is no "else" part. This means that the conditional always succeeds if the group has not captured something. This makes 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?(open)
</SPAN>
<SPAN CLASS="regexnest2">
(?!)
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 a proper test to verify that the group "open" has no captures left.</p>
 
<p>The regex 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
<SPAN CLASS="regexnest1">
(?'open'
</SPAN>
<SPAN CLASS="regexplain">
o
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexnest1">
(?'-open'
</SPAN>
<SPAN CLASS="regexplain">
c
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexnest1">
(?(open)
</SPAN>
<SPAN CLASS="regexnest2">
(?!)
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
 fails to match 
<tt class=string>
ooc
</tt>
. When 
<TT CLASS=code>
<SPAN CLASS="regexplain">
c
</SPAN>
</TT>
 fails to match because the regex engine has reached the end of the string, the engine backtracks out of the balancing group, leaving "open" with a single capture. The regex engine now reaches the conditional, which fails to match. The regex engine will backtrack trying different permutations of the quantifiers, but they will all fail to match. No match can be found.</p>
 
<p>The regex 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
<SPAN CLASS="regexnest1">
(?'open'
</SPAN>
<SPAN CLASS="regexplain">
o
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexnest1">
(?'-open'
</SPAN>
<SPAN CLASS="regexplain">
c
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexnest1">
(?(open)
</SPAN>
<SPAN CLASS="regexnest2">
(?!)
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
 does match 
<tt class=match>
oocc
</tt>
. After 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?'-open'
</SPAN>
<SPAN CLASS="regexplain">
c
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 has matched 
<tt class=match>
cc
</tt>
, the regex engine cannot enter the balancing group a third time, because "open" has no captures left. The engine advances to the conditional. The conditional succeeds because "open" has no captures left and the conditional does not have an "else" part. Now 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
 matches at the end of the string.</p>
 
<h2>Matching Balanced Constructs</h2>
 
<p><TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
<SPAN CLASS="regexnest1">
(?:
</SPAN>
<SPAN CLASS="regexnest2">
(?'open'
</SPAN>
<SPAN CLASS="regexplain">
o
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexnest2">
(?'-open'
</SPAN>
<SPAN CLASS="regexplain">
c
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexnest1">
(?(open)
</SPAN>
<SPAN CLASS="regexnest2">
(?!)
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
 wraps the capturing group and the balancing group in a 
<A HREF="brackets.html" TARGET="_top">
non-capturing group
</A>
 that is also repeated. This regex matches any string like 
<tt class=match>
ooocooccocccoc
</tt>
 that contains any number of perfectly balanced o's and c's, with any number of pairs in sequence, nested to any depth. The balancing group makes sure that the regex never matches a string that has more c's at any point in the string than it has o's to the left of that point. The conditional at the end, which must remain outside the repeated group, makes sure that the regex never matches a string that has more o's than c's.</p>
 
<p><TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
<SPAN CLASS="regexnest1">
(?&gt;
</SPAN>
<SPAN CLASS="regexnest2">
(?'open'
</SPAN>
<SPAN CLASS="regexplain">
o
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexnest2">
(?'-open'
</SPAN>
<SPAN CLASS="regexplain">
c
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexnest1">
(?(open)
</SPAN>
<SPAN CLASS="regexnest2">
(?!)
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
 optimizes the previous regex by using an 
<A HREF="atomic.html" TARGET="_top">
atomic group
</A>
 instead of the non-capturing group. The atomic group, which is also non-capturing, eliminates nearly all backtracking when the regular expression cannot find a match, which can greatly increase performance when used on long strings with lots of o's and c's but that aren't properly balanced at the end. The atomic group does not change how the regex matches strings that do have balanced o's and c's.</p>
 
<p><TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
<SPAN CLASS="regexplain">
m
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexnest1">
(?&gt;
</SPAN>
<SPAN CLASS="regexnest2">
(?&gt;
</SPAN>
<SPAN CLASS="regexnest3">
(?'open'
</SPAN>
<SPAN CLASS="regexplain">
o
</SPAN>
<SPAN CLASS="regexnest3">
)
</SPAN>
<SPAN CLASS="regexplain">
m
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexnest2">
(?&gt;
</SPAN>
<SPAN CLASS="regexnest3">
(?'-open'
</SPAN>
<SPAN CLASS="regexplain">
c
</SPAN>
<SPAN CLASS="regexnest3">
)
</SPAN>
<SPAN CLASS="regexplain">
m
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexnest1">
(?(open)
</SPAN>
<SPAN CLASS="regexnest2">
(?!)
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
 allows any number of letters 
<tt class=string>
m
</tt>
 anywhere in the string, while still requiring all o's and c's to be balanced. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
m
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
 at the start of the regex allows any number of m's before the first o. 
<TT CLASS=code>
<SPAN CLASS="regexnest2">
(?'open'
</SPAN>
<SPAN CLASS="regexplain">
o
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 was changed into 
<TT CLASS=code>
<SPAN CLASS="regexnest2">
(?&gt;
</SPAN>
<SPAN CLASS="regexnest3">
(?'open'
</SPAN>
<SPAN CLASS="regexplain">
o
</SPAN>
<SPAN CLASS="regexnest3">
)
</SPAN>
<SPAN CLASS="regexplain">
m
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 to allow any number of m's after each o. Similarly, 
<TT CLASS=code>
<SPAN CLASS="regexnest2">
(?'-open'
</SPAN>
<SPAN CLASS="regexplain">
c
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 was changed into 
<TT CLASS=code>
<SPAN CLASS="regexnest2">
(?&gt;
</SPAN>
<SPAN CLASS="regexnest3">
(?'-open'
</SPAN>
<SPAN CLASS="regexplain">
c
</SPAN>
<SPAN CLASS="regexnest3">
)
</SPAN>
<SPAN CLASS="regexplain">
m
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 to allow any number of m's after each c.</p>
 
<p>This is the generic solution for matching balanced constructs using .NET's balancing groups or capturing group subtraction feature. You can replace 
<TT CLASS=code>
<SPAN CLASS="regexnest3">
o
</SPAN>
</TT>
, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
m
</SPAN>
</TT>
, and 
<TT CLASS=code>
<SPAN CLASS="regexplain">
c
</SPAN>
</TT>
 with any regular expression, as long as no two of these three can match the same text.</p>
 
<p><TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
()
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexnest1">
(?&gt;
</SPAN>
<SPAN CLASS="regexnest2">
(?&gt;
</SPAN>
<SPAN CLASS="regexnest3">
(?'open'
</SPAN>
<SPAN CLASS="regexescaped">
\(
</SPAN>
<SPAN CLASS="regexnest3">
)
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
()
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexnest2">
(?&gt;
</SPAN>
<SPAN CLASS="regexnest3">
(?'-open'
</SPAN>
<SPAN CLASS="regexescaped">
\)
</SPAN>
<SPAN CLASS="regexnest3">
)
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
()
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexnest1">
(?(open)
</SPAN>
<SPAN CLASS="regexnest2">
(?!)
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
 applies this technique to match a string in which all parentheses are perfectly balanced.</p>
 
<h2>Backreferences To Subtracted Groups</h2>
 
<p>You can use 
<A HREF="backref.html" TARGET="_top">
backreferences
</A>
 to groups that have their matches subtracted by a balancing group. The backreference matches the group's most recent match that wasn't backtracked or subtracted. The regex 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?'x'
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
ab
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
{2}
</SPAN>
<SPAN CLASS="regexnest1">
(?'-x')
</SPAN>
<SPAN CLASS="regexspecial">
\k'x'
</SPAN>
</TT>
 matches 
<tt class=match>
aaa
</tt>
, 
<tt class=match>
aba
</tt>
, 
<tt class=match>
bab
</tt>
, or 
<tt class=match>
bbb
</tt>
. It does not match 
<tt class=string>
aab
</tt>
, 
<tt class=string>
abb
</tt>
, 
<tt class=string>
baa
</tt>
, or 
<tt class=string>
bba
</tt>
. The first and third letters of the string have to be the same.</p>
 
<p>Let's see how 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?'x'
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
ab
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
{2}
</SPAN>
<SPAN CLASS="regexnest1">
(?'-x')
</SPAN>
<SPAN CLASS="regexspecial">
\k'x'
</SPAN>
</TT>
 matches 
<tt class=match>
aba
</tt>
. The first iteration of 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?'x'
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
ab
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 captures 
<tt class=match>
a
</tt>
. The second iteration captures 
<tt class=match>
b
</tt>
. Now the regex engine reaches the balancing group 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?'-x')
</SPAN>
</TT>
. It checks whether the group "x" has matched, which it has. The engine enters the balancing group, subtracting the match 
<tt class=match>
b
</tt>
 from the stack of group "x". There are no regex tokens inside the balancing group. It matches without advancing through the string. Now the regex engine reaches the backreference 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\k'x'
</SPAN>
</TT>
. The match at the top of the stack of group "x" is 
<tt class=match>
a
</tt>
. The next character in the string is also an 
<tt class=match>
a
</tt>
 which the backreference matches. 
<tt class=match>
aba
</tt>
 is found as an overall match.</p>
 
<p>When you apply this regex to 
<tt class=string>
abb
</tt>
, the matching process is the same, except that the backreference fails to match the second 
<tt class=string>
b
</tt>
 in the string. Since the regex has no other permutations that the regex engine can try, the match attempt fails.</p>
 
<h2>Matching Palindromes</h2>
 
<p><TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
<SPAN CLASS="regexnest1">
(?'letter'
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexnest1">
(?:
</SPAN>
<SPAN CLASS="regexspecial">
\k'letter'
</SPAN>
<SPAN CLASS="regexnest2">
(?'-letter')
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexnest1">
(?(letter)
</SPAN>
<SPAN CLASS="regexnest2">
(?!)
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
 matches palindrome words of any length. This regular expression takes advantage of the fact that backreferences and capturing group subtraction work well together. It also uses an empty balancing group as the regex in the previous section.</p>
 
<p>Let's see how this regex matches the palindrome 
<tt class=match>
radar
</tt>
. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
</TT>
 matches at the start of the string. Then 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?'letter'
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 iterates five times. The group "letter" ends up with five matches on its stack: 
<tt class=match>
r
</tt>
, 
<tt class=match>
a
</tt>
, 
<tt class=match>
d
</tt>
, 
<tt class=match>
a
</tt>
, and 
<tt class=match>
r
</tt>
. The regex engine is now at the end of the string and at 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
</TT>
 in the regex. It doesn't match, but that's fine, because the quantifier makes it optional. The engine now reaches the backreference 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\k'letter'
</SPAN>
</TT>
. The group "letter" has 
<tt class=match>
r
</tt>
 at the top of its stack. This fails to match the void after the end of the string.</p>
 
<p>The regex engine backtracks. 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?'letter'
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 is reduced to four iterations, leaving 
<tt class=match>
r
</tt>
, 
<tt class=match>
a
</tt>
, 
<tt class=match>
d
</tt>
, and 
<tt class=match>
a
</tt>
 on the stack of the group "letter". 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
</TT>
 matches 
<tt class=match>
r
</tt>
. The backreference again fails to match the void after the end of the string. The engine backtracks, forcing 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
</TT>
 to give up its match. Now "letter" has 
<tt class=match>
a
</tt>
 at the top of its stack. This causes the backreference to fail to match 
<tt class=string>
r
</tt>
.</p>
 
<p>More backtracking follows. 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?'letter'
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 is reduced to three iterations, leaving 
<tt class=match>
d
</tt>
 at the top of the stack of the group "letter". The engine again proceeds with 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
</TT>
. It fails again because there is no 
<tt class=string>
d
</tt>
 for the backreference to match.</p>
 
<p>Backtracking once more, the capturing stack of group "letter" is reduced to 
<tt class=match>
r
</tt>
 and 
<tt class=match>
a
</tt>
. Now the tide turns. 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
</TT>
 matches 
<tt class=match>
d
</tt>
. The backreference matches 
<tt class=match>
a
</tt>
 which is the most recent match of the group "letter" that wasn't backtracked. The engine now reaches the empty balancing group 
<TT CLASS=code>
<SPAN CLASS="regexnest2">
(?'-letter')
</SPAN>
</TT>
. This matches, because the group "letter" has a match 
<tt class=match>
a
</tt>
 to subtract.</p>
 
<p>The backreference and balancing group are inside a repeated non-capturing group, so the engine tries them again. The backreference matches 
<tt class=match>
r
</tt>
 and the balancing group subtracts it from "letter"'s stack, leaving the capturing group without any matches. Iterating once more, the backreference fails, because the group "letter" has no matches left on its stack. This makes the group act as a non-participating group. Backreferences to non-participating groups always fail in .NET, as they do in most regex flavors.</p>
 
<p><TT CLASS=code>
<SPAN CLASS="regexnest1">
(?:
</SPAN>
<SPAN CLASS="regexspecial">
\k'letter'
</SPAN>
<SPAN CLASS="regexnest2">
(?'-letter')
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 has successfully matched two iterations. Now, the conditional 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?(letter)
</SPAN>
<SPAN CLASS="regexnest2">
(?!)
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 succeeds because the group "letter" has no matches left. The anchor 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
 also matches. The palindrome 
<tt class=match>
radar
</tt>
 has been matched.</p>

</DIV>
 
<div class=topad>
<A HREF="//www.regexbuddy.com/create.html" TARGET="_top">
</A>
</div>
 
<h1>
Regular Expression Recursion
</h1>
 
<p><A HREF="perl.html" TARGET="_top">
Perl 5.10
</A>
, 
<A HREF="pcre.html" TARGET="_top">
PCRE 4.0
</A>
, 
<A HREF="ruby.html" TARGET="_top">
Ruby 2.0
</A>
, and all later versions of these three, support regular expression recursion. Perl uses the syntax 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
(?R)
</SPAN>
</TT>
 with 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
(?0)
</SPAN>
</TT>
 as a synonym. Ruby 2.0 uses 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\g&lt;0&gt;
</SPAN>
</TT>
. PCRE supports all three as of version 7.7. Earlier versions supported only the Perl syntax (which Perl actually copied from PCRE). Recent versions of 
<A HREF="delphi.html" TARGET="_top">
Delphi
</A>
, 
<A HREF="php.html" TARGET="_top">
PHP
</A>
, and 
<A HREF="rlanguage.html" TARGET="_top">
R
</A>
 also support all three, as their regex functions are based on PCRE. 
<a href="jgsoft.html#v2">
JGsoft V2
</a>
 also supports all variations of regex recursion.</p>
 
<p>While Ruby 1.9 does not have any syntax for regex recursion, it does support 
<A HREF="subroutine.html" TARGET="_top">
capturing group recursion
</A>
. So you could recurse the whole regex in Ruby 1.9 if you wrap the whole regex in a capturing group. 
<A HREF="dotnet.html" TARGET="_top">
.NET
</A>
 does not support recursion, but it supports 
<A HREF="balancing.html" TARGET="_top">
balancing groups
</A>
 that can be used instead of recursion to match balanced constructs.</p>
 
<p>As we'll see later, there are differences in how Perl, PCRE, and Ruby deal with 
<A HREF="recursebackref.html" TARGET="_top">
backreferences
</A>
 and 
<A HREF="recursebacktrack.html" TARGET="_top">
backtracking
</A>
 during recursion. While they copied each other's syntax, they did not copy each other's behavior. JGsoft V2, however, copied their syntax and their behavior. So JGsoft V2 has three different ways of doing regex recursion, which you choose by using a different syntax. But these differences do not come into play in the basic example on this page.</p>
 
<p><A HREF="boost.html" TARGET="_top">
Boost
</A>
 1.42 copied the syntax from Perl. But its implementation is marred by bugs. Boost 1.60 attempted to fix the behavior of 
<A HREF="recurserepeat.html" TARGET="_top">
quantifiers on recursion
</A>
, but it's still quite different from other flavors and incompatible with previous versions of Boost. Boost 1.64 finally stopped crashing upon 
<A HREF="recurseinfinite.html" TARGET="_top">
infinite recursion
</A>
. But recursion of the whole regex still attempts only the first alternative.</p>
<H2>Simple Recursion</h2>
 
<p>The regexes 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexspecial">
(?R)
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexplain">
z
</SPAN>
</TT>
, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexspecial">
(?0)
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexplain">
z
</SPAN>
</TT>
, and 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexspecial">
\g&lt;0&gt;
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexplain">
z
</SPAN>
</TT>
 all match one or more letters 
<tt class=match>
a
</tt>
 followed by exactly the same number of letters 
<tt class=match>
z
</tt>
. Since these regexes are functionally identical, we'll use the syntax with R for recursion to see how this regex matches the string 
<tt class=match>
aaazzz
</tt>
.</p>
 
<p>First, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
 matches the first 
<tt class=match>
a
</tt>
 in the string. Then the regex engine reaches 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
(?R)
</SPAN>
</TT>
. This tells the engine to attempt the whole regex again at the present position in the string. Now, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
 matches the second 
<tt class=match>
a
</tt>
 in the string. The engine reaches 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
(?R)
</SPAN>
</TT>
 again. On the second recursion, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
 matches the third 
<tt class=match>
a
</tt>
. On the third recursion, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
 fails to match the first 
<tt class=string>
z
</tt>
 in the string. This causes 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
(?R)
</SPAN>
</TT>
 to fail. But the regex uses a quantifier to make 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
(?R)
</SPAN>
</TT>
 
<A HREF="optional.html" TARGET="_top">
optional
</A>
. So the engine continues with 
<TT CLASS=code>
<SPAN CLASS="regexplain">
z
</SPAN>
</TT>
 which matches the first 
<tt class=match>
z
</tt>
 in the string.</p>
 
<p>Now, the regex engine has reached the end of the regex. But since it's two levels deep in recursion, it hasn't found an overall match yet. It only has found a match for 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
(?R)
</SPAN>
</TT>
. Exiting the recursion after a successful match, the engine also reaches 
<TT CLASS=code>
<SPAN CLASS="regexplain">
z
</SPAN>
</TT>
. It now matches the second 
<tt class=match>
z
</tt>
 in the string. The engine is still one level deep in recursion, from which it exists with a successful match. Finally, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
z
</SPAN>
</TT>
 matches the third 
<tt class=match>
z
</tt>
 in the string. The engine is again at the end of the regex. This time, it's not inside any recursion. Thus, it returns 
<tt class=match>
aaazzz
</tt>
 as the overall regex match.</p>
 
<a name="balanced">
</a>

<H2>Matching Balanced Constructs</h2>
 
<p>The main purpose of recursion is to match balanced constructs or nested constructs. The generic regex is 
<TT CLASS=code>
<SPAN CLASS="regexplain">
b
</SPAN>
<SPAN CLASS="regexnest1">
(?:
</SPAN>
<SPAN CLASS="regexplain">
m
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexspecial">
(?R)
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexplain">
e
</SPAN>
</TT>
 where 
<TT CLASS=code>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
 is what begins the construct, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
m
</SPAN>
</TT>
 is what can occur in the middle of the construct, and 
<TT CLASS=code>
<SPAN CLASS="regexplain">
e
</SPAN>
</TT>
 is what can occur at the end of the construct. For correct results, no two of 
<TT CLASS=code>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
m
</SPAN>
</TT>
, and 
<TT CLASS=code>
<SPAN CLASS="regexplain">
e
</SPAN>
</TT>
 should be able to match the same text. You can use an 
<A HREF="atomic.html" TARGET="_top">
atomic group
</A>
 instead of the 
<A HREF="brackets.html" TARGET="_top">
non-capturing group
</A>
 for improved performance: 
<TT CLASS=code>
<SPAN CLASS="regexplain">
b
</SPAN>
<SPAN CLASS="regexnest1">
(?&gt;
</SPAN>
<SPAN CLASS="regexplain">
m
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexspecial">
(?R)
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexplain">
e
</SPAN>
</TT>
.</p>
 
<p>A common real-world use is to match a balanced set of parentheses. 
<TT CLASS=code>
<SPAN CLASS="regexescaped">
\(
</SPAN>
<SPAN CLASS="regexnest1">
(?&gt;
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
()
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexspecial">
(?R)
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexescaped">
\)
</SPAN>
</TT>
 matches a single pair of parentheses with any text in between, including an unlimited number of parentheses, as long as they are all properly paired. If the subject string contains unbalanced parentheses, then the first regex match is the leftmost pair of balanced parentheses, which may occur after unbalanced opening parentheses. If you want a regex that does not find any matches in a string that contains unbalanced parentheses, then you need to use a 
<A HREF="subroutine.html" TARGET="_top">
subroutine call
</A>
 instead of recursion. If you want to find a sequence of multiple pairs of balanced parentheses as a single match, then you also need a subroutine call.</p>
<H2>Recursion with Alternation</h2>
 
<p>If what may appear in the middle of the balanced construct may also appear on its own without the beginning and ending parts then the generic regex is 
<TT CLASS=code>
<SPAN CLASS="regexplain">
b
</SPAN>
<SPAN CLASS="regexspecial">
(?R)
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexplain">
e
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexplain">
m
</SPAN>
</TT>
. Again, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
m
</SPAN>
</TT>
, and 
<TT CLASS=code>
<SPAN CLASS="regexplain">
e
</SPAN>
</TT>
 all need to be mutually exclusive. 
<TT CLASS=code>
<SPAN CLASS="regexescaped">
\(
</SPAN>
<SPAN CLASS="regexspecial">
(?R)
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexescaped">
\)
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
()
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 matches a pair of balanced parentheses like the regex in the previous section. But it also matches any text that does not contain any parentheses at all.</p>
 
<p>This regular expression does not work correctly in Boost. If a regex has 
<A HREF="alternation.html" TARGET="_top">
alternation
</A>
 that is not inside a group then recursion of the whole regex in Boost only attempts the first alternative. So 
<TT CLASS=code>
<SPAN CLASS="regexescaped">
\(
</SPAN>
<SPAN CLASS="regexspecial">
(?R)
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexescaped">
\)
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
()
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 in Boost matches any number of balanced parentheses nested arbitrarily deep with no text in between, or any text that does not contain any parentheses at all. If you flip the alternatives then 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
()
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexescaped">
\(
</SPAN>
<SPAN CLASS="regexspecial">
(?R)
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexescaped">
\)
</SPAN>
</TT>
 in Boost matches any text without any parentheses or a single pair of parentheses with any text without parentheses in between. In all other flavors these two regexes find the same matches.</p>
 
<p>The solution for Boost is to put the alternation inside a group. 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?:
</SPAN>
<SPAN CLASS="regexescaped">
\(
</SPAN>
<SPAN CLASS="regexspecial">
(?R)
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexescaped">
\)
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
()
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?:
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
()
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexescaped">
\(
</SPAN>
<SPAN CLASS="regexspecial">
(?R)
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexescaped">
\)
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 find the same matches in all flavors discussed in this tutorial that support recursion.</p>

</DIV>
 
<h1>
Regular Expression Subroutines
</h1>
<p><A HREF="perl.html" TARGET="_top">
Perl 5.10
</A>
, 
<A HREF="pcre.html" TARGET="_top">
PCRE 4.0
</A>
, and 
<A HREF="ruby.html" TARGET="_top">
Ruby 1.9
</A>
 support regular expression subroutine calls.  These are very similar to 
<A HREF="recurse.html" TARGET="_top">
regular expression recursion
</A>
.  Instead of matching the entire regular expression again, a subroutine call only matches the regular expression inside a capturing group.  You can make a subroutine call to any capturing group from anywhere in the regex.  If you place a call inside the group that it calls, you'll have a recursive capturing group.</p>
<p>As with regex recursion, there is a wide variety of syntax that you can use for exactly the same thing.  Perl uses 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
(?1)
</SPAN>
</TT>
 to call a numbered group, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
(?+1)
</SPAN>
</TT>
 to call the next group, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
(?-1)
</SPAN>
</TT>
 to call the preceding group, and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
(?&amp;name)
</SPAN>
</TT>
 to call a named group.  You can use all of these to reference the same group.  
<TT CLASS=code>
<SPAN CLASS="regexspecial">
(?+1)
</SPAN>
<SPAN CLASS="regexnest1">
(?'name'
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
abc
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
(?1)
</SPAN>
<SPAN CLASS="regexspecial">
(?-1)
</SPAN>
<SPAN CLASS="regexspecial">
(?&amp;name)
</SPAN>
</TT>
 matches a string that is five letters long and consists only of the first three letters of the alphabet.  This regex is exactly the same as 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
abc
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
(?'name'
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
abc
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
abc
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
abc
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
abc
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
.</p>

<p>PCRE was the first regex engine to support subroutine calls.  
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?P&lt;name&gt;
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
abc
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
(?1)
</SPAN>
<SPAN CLASS="regexspecial">
(?P&gt;name)
</SPAN>
</TT>
 matches three letters like 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?P&lt;name&gt;
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
abc
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
abc
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
abc
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 does.  
<TT CLASS=code>
<SPAN CLASS="regexspecial">
(?1)
</SPAN>
</TT>
 is a call to a numbered group and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
(?P&gt;name)
</SPAN>
</TT>
 is a call to a named group.  The latter is called the "Python syntax" in the PCRE man page.  While this syntax mimics the syntax Python uses for 
<A HREF="python.html" TARGET="_top">
named capturing groups
</A>
, it is a PCRE invention.  Python does not support subroutine calls or recursion.  PCRE 7.2 added 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
(?+1)
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
(?-1)
</SPAN>
</TT>
 for relative calls.  PCRE 7.7 adds all the syntax used by Perl 5.10 and Ruby 2.0.  Recent versions of 
<A HREF="php.html" TARGET="_top">
PHP
</A>
, 
<A HREF="delphi.html" TARGET="_top">
Delphi
</A>
, and 
<A HREF="rlanguage.html" TARGET="_top">
R
</A>
 also support all this syntax, as their regex functions are based on PCRE.</p>
<p>The syntax used by Ruby 1.9 and later looks more like that of backreferences.  
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\g&lt;1&gt;
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\g'1'
</SPAN>
</TT>
 call a numbered group, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\g&lt;name&gt;
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\g'name'
</SPAN>
</TT>
 call a named group, while 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\g&lt;-1&gt;
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\g'-1'
</SPAN>
</TT>
 call the preceding group.  Ruby 2.0 adds 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\g&lt;+1&gt;
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\g'+1'
</SPAN>
</TT>
 to call the next group.  
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\g&lt;+1&gt;
</SPAN>
<SPAN CLASS="regexnest1">
(?&lt;name&gt;
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
abc
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\g&lt;1&gt;
</SPAN>
<SPAN CLASS="regexspecial">
\g&lt;-1&gt;
</SPAN>
<SPAN CLASS="regexspecial">
\g&lt;name&gt;
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\g'+1'
</SPAN>
<SPAN CLASS="regexnest1">
(?'name'
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
abc
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\g'1'
</SPAN>
<SPAN CLASS="regexspecial">
\g'-1'
</SPAN>
<SPAN CLASS="regexspecial">
\g'name'
</SPAN>
</TT>
 match the same 5-letter string in Ruby 2.0 as the Perl example does in Perl.  The syntax with angle brackets and with quotes can be used interchangeably.</p>

<p><a href="jgsoft.html#v2">
JGsoft V2
</a>
 supports all three sets of syntax.  As we'll see later, there are differences in how Perl, PCRE, and Ruby deal with 
<A HREF="recursecapture.html" TARGET="_top">
capturing
</A>
, 
<A HREF="recursebackref.html" TARGET="_top">
backreferences
</A>
, and 
<A HREF="recursebacktrack.html" TARGET="_top">
backtracking
</A>
 during subroutine calls.  While they copied each other's syntax, they did not copy each other's behavior.  JGsoft V2, however, copied their syntax and their behavior.  So JGsoft V2 has three different ways of doing regex recursion, which you choose by using a different syntax.  But these differences do not come into play in the basic examples on this page.</p>
<p><A HREF="boost.html" TARGET="_top">
Boost
</A>
 1.42 copied the syntax from Perl but its implementation is marred by bugs, which are still not all fixed in version 1.62.  Most significantly, quantifiers other than 
<tt>
*
</tt>
 or 
<tt>
{0,}
</tt>
 cause subroutine calls to misbehave.  This is partially fixed in Boost 1.60 which correctly handles 
<tt>
?
</tt>
 and 
<tt>
{0,1}
</tt>
 too.</p>
<p>Boost does not support the Ruby syntax for subroutine calls.  In Boost 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\g&lt;1&gt;
</SPAN>
</TT>
 is a backreference&mdash;not a subroutine call&mdash;to capturing group 1.  So 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
ab
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\g&lt;1&gt;
</SPAN>
</TT>
 can match 
<tt class=match>
aa
</tt>
 and 
<tt class=match>
bb
</tt>
 but not 
<tt class=string>
ab
</tt>
 or 
<tt class=string>
ba
</tt>
.  In Ruby the same regex would match all four strings.  No other flavor discussed in this tutorial uses this syntax for backreferences.</p>
<a name="balanced">
</a>

<H2>Matching Balanced Constructs</h2>
<p>Recursion into a capturing group is a more flexible way of 
<a href="recurse.html#balanced">
matching balanced constructs
</a>
 than recursion of the whole regex.  We can wrap the regex in a capturing group, recurse into the capturing group instead of the whole regex, and add anchors outside the capturing group.  
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\A
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
<SPAN CLASS="regexnest2">
(?:
</SPAN>
<SPAN CLASS="regexplain">
m
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexspecial">
(?1)
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexplain">
e
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\z
</SPAN>
</TT>
 is the generic regex for checking that a string consists entirely of a correctly balanced construct.  Again, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
 is what begins the construct, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
m
</SPAN>
</TT>
 is what can occur in the middle of the construct, and 
<TT CLASS=code>
<SPAN CLASS="regexplain">
e
</SPAN>
</TT>
 is what can occur at the end of the construct.  For correct results, no two of 
<TT CLASS=code>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
m
</SPAN>
</TT>
, and 
<TT CLASS=code>
<SPAN CLASS="regexplain">
e
</SPAN>
</TT>
 should be able to match the same text.  You can use an 
<A HREF="atomic.html" TARGET="_top">
atomic group
</A>
 instead of the 
<A HREF="brackets.html" TARGET="_top">
non-capturing group
</A>
 for improved performance: 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\A
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
<SPAN CLASS="regexnest2">
(?&gt;
</SPAN>
<SPAN CLASS="regexplain">
m
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexspecial">
(?1)
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexplain">
e
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\z
</SPAN>
</TT>
.</p>
<p>Similarly, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\A
</SPAN>
<SPAN CLASS="regexplain">
o
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
<SPAN CLASS="regexnest2">
(?:
</SPAN>
<SPAN CLASS="regexplain">
m
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexspecial">
(?1)
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexplain">
e
</SPAN>
<SPAN CLASS="regexplain">
o
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexspecial">
\z
</SPAN>
</TT>
 and the optimized 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\A
</SPAN>
<SPAN CLASS="regexplain">
o
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
<SPAN CLASS="regexnest2">
(?&gt;
</SPAN>
<SPAN CLASS="regexplain">
m
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexspecial">
(?1)
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexplain">
e
</SPAN>
<SPAN CLASS="regexplain">
o
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexspecial">
\z
</SPAN>
</TT>
 match a string that consists of nothing but a sequence of one or more correctly balanced constructs, with possibly other text in between.  Here, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
o
</SPAN>
</TT>
 is what can occur outside the balanced constructs.  It will often be the same as 
<TT CLASS=code>
<SPAN CLASS="regexplain">
m
</SPAN>
</TT>
.  
<TT CLASS=code>
<SPAN CLASS="regexplain">
o
</SPAN>
</TT>
 should not be able to match the same text as 
<TT CLASS=code>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexplain">
e
</SPAN>
</TT>
.</p>
<p><TT CLASS=code>
<SPAN CLASS="regexspecial">
\A
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexescaped">
\(
</SPAN>
<SPAN CLASS="regexnest2">
(?&gt;
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
()
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexspecial">
(?1)
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexescaped">
\)
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\z
</SPAN>
</TT>
 matches a string that consists of nothing but a correctly balanced pair of parentheses, possibly with text between them.  
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\A
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
()
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexescaped">
\(
</SPAN>
<SPAN CLASS="regexnest2">
(?&gt;
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
()
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexspecial">
(?1)
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexescaped">
\)
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
()
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexspecial">
\z
</SPAN>
</TT>
.</p>

<H2>Matching The Same Construct More Than Once</h2>
<p>A regex that needs to match the same kind of construct (but not the exact same text) more than once in different parts of the regex can be shorter and more concise when using subroutine calls.  Suppose you need a regex to match patient records like these:</p>
<pre>
Name: John Doe
Born: 17-Jan-1964
Admitted: 30-Jul-2013
Released: 3-Aug-2013
</pre>
<p>Further suppose that you need to match the date format rather accurately so the regex can filter out valid records, leaving invalid records for human inspection.  In most regex flavors you could easily do this with this regex, using 
<A HREF="freespacing.html" TARGET="_top">
free-spacing syntax
</A>
:</p>
<p><TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
<SPAN CLASS="regexplain">
Name:
</SPAN>
<SPAN CLASS="regexescaped">
\ 
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\r
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexspecial">
\n
</SPAN>
<SPAN CLASS="regexplain">
<BR>
</SPAN>
<SPAN CLASS="regexplain">
Born:
</SPAN>
<SPAN CLASS="regexescaped">
\ 
</SPAN>
<SPAN CLASS="regexnest1">
(?:
</SPAN>
<SPAN CLASS="regexplain">
3
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
01
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
12
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
1
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
<BR>
       
</SPAN>
<SPAN CLASS="regexplain">
-
</SPAN>
<SPAN CLASS="regexnest1">
(?:
</SPAN>
<SPAN CLASS="regexplain">
Jan
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
Feb
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
Mar
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
Apr
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
May
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
Jun
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
Jul
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
Aug
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
Sep
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
Oct
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
Nov
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
Dec
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
<BR>
       
</SPAN>
<SPAN CLASS="regexplain">
-
</SPAN>
<SPAN CLASS="regexnest1">
(?:
</SPAN>
<SPAN CLASS="regexplain">
19
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
20
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
\r
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexspecial">
\n
</SPAN>
<SPAN CLASS="regexplain">
<BR>
</SPAN>
<SPAN CLASS="regexplain">
Admitted:
</SPAN>
<SPAN CLASS="regexescaped">
\ 
</SPAN>
<SPAN CLASS="regexnest1">
(?:
</SPAN>
<SPAN CLASS="regexplain">
3
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
01
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
12
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
1
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
<BR>
           
</SPAN>
<SPAN CLASS="regexplain">
-
</SPAN>
<SPAN CLASS="regexnest1">
(?:
</SPAN>
<SPAN CLASS="regexplain">
Jan
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
Feb
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
Mar
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
Apr
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
May
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
Jun
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
Jul
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
Aug
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
Sep
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
Oct
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
Nov
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
Dec
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
<BR>
           
</SPAN>
<SPAN CLASS="regexplain">
-
</SPAN>
<SPAN CLASS="regexnest1">
(?:
</SPAN>
<SPAN CLASS="regexplain">
19
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
20
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
\r
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexspecial">
\n
</SPAN>
<SPAN CLASS="regexplain">
<BR>
</SPAN>
<SPAN CLASS="regexplain">
Released:
</SPAN>
<SPAN CLASS="regexescaped">
\ 
</SPAN>
<SPAN CLASS="regexnest1">
(?:
</SPAN>
<SPAN CLASS="regexplain">
3
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
01
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
12
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
1
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
<BR>
           
</SPAN>
<SPAN CLASS="regexplain">
-
</SPAN>
<SPAN CLASS="regexnest1">
(?:
</SPAN>
<SPAN CLASS="regexplain">
Jan
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
Feb
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
Mar
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
Apr
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
May
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
Jun
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
Jul
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
Aug
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
Sep
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
Oct
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
Nov
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
Dec
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
<BR>
           
</SPAN>
<SPAN CLASS="regexplain">
-
</SPAN>
<SPAN CLASS="regexnest1">
(?:
</SPAN>
<SPAN CLASS="regexplain">
19
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
20
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT></p>
<p>With subroutine calls you can make this regex much shorter, easier to read, and easier to maintain:</p>
<p><TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
<SPAN CLASS="regexplain">
Name:
</SPAN>
<SPAN CLASS="regexescaped">
\ 
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\r
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexspecial">
\n
</SPAN>
<SPAN CLASS="regexplain">
<BR>
</SPAN>
<SPAN CLASS="regexplain">
Born:
</SPAN>
<SPAN CLASS="regexescaped">
\ 
</SPAN>
<SPAN CLASS="regexnest1">
(?'date'
</SPAN>
<SPAN CLASS="regexnest2">
(?:
</SPAN>
<SPAN CLASS="regexplain">
3
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
01
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
12
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
1
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexplain">
<BR>
               
</SPAN>
<SPAN CLASS="regexplain">
-
</SPAN>
<SPAN CLASS="regexnest2">
(?:
</SPAN>
<SPAN CLASS="regexplain">
Jan
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
Feb
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
Mar
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
Apr
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
May
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
Jun
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
Jul
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
Aug
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
Sep
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
Oct
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
Nov
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
Dec
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexplain">
<BR>
               
</SPAN>
<SPAN CLASS="regexplain">
-
</SPAN>
<SPAN CLASS="regexnest2">
(?:
</SPAN>
<SPAN CLASS="regexplain">
19
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
20
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\r
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexspecial">
\n
</SPAN>
<SPAN CLASS="regexplain">
<BR>
</SPAN>
<SPAN CLASS="regexplain">
Admitted:
</SPAN>
<SPAN CLASS="regexescaped">
\ 
</SPAN>
<SPAN CLASS="regexspecial">
\g'date'
</SPAN>
<SPAN CLASS="regexspecial">
\r
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexspecial">
\n
</SPAN>
<SPAN CLASS="regexplain">
<BR>
</SPAN>
<SPAN CLASS="regexplain">
Released:
</SPAN>
<SPAN CLASS="regexescaped">
\ 
</SPAN>
<SPAN CLASS="regexspecial">
\g'date'
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT></p>
<a name="define">
</a>
<h2>Separate Subroutine Definitions</h2>
<p>In Perl, PCRE, and JGsoft V2, you can take this one step further using the special DEFINE group: 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?(DEFINE)
</SPAN>
<SPAN CLASS="regexnest2">
(?'subroutine'
</SPAN>
<SPAN CLASS="regexplain">
regex
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
.  While this looks like a 
<A HREF="conditional.html" TARGET="_top">
conditional
</A>
 that references the non-existent group DEFINE containing a single named group "subroutine", the DEFINE group is a special syntax.  The fixed text 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?(DEFINE)
</SPAN>
</TT>
 opens the group.  A parenthesis closes the group.  This special group tells the regex engine to ignore its contents, other than to parse it for named and numbered capturing groups.  You can put as many capturing groups inside the DEFINE group as you like.  The DEFINE group itself never matches anything, and never fails to match.  It is completely ignored.  The regex 
<TT CLASS=code>
<SPAN CLASS="regexplain">
foo
</SPAN>
<SPAN CLASS="regexnest1">
(?(DEFINE)
</SPAN>
<SPAN CLASS="regexnest2">
(?'subroutine'
</SPAN>
<SPAN CLASS="regexplain">
skipped
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
bar
</SPAN>
</TT>
 matches 
<tt class=match>
foobar
</tt>
.  The DEFINE group is completely superfluous in this regex, as there are no calls to any of the groups inside of it.</p>
<p>With a DEFINE group, our regex becomes:</p>
<p><TT CLASS=code>
<SPAN CLASS="regexnest1">
(?(DEFINE)
</SPAN>
<SPAN CLASS="regexnest2">
(?'date'
</SPAN>
<SPAN CLASS="regexnest3">
(?:
</SPAN>
<SPAN CLASS="regexplain">
3
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
01
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
12
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
1
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest3">
)
</SPAN>
<SPAN CLASS="regexplain">
<BR>
                  
</SPAN>
<SPAN CLASS="regexplain">
-
</SPAN>
<SPAN CLASS="regexnest3">
(?:
</SPAN>
<SPAN CLASS="regexplain">
Jan
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexplain">
Feb
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexplain">
Mar
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexplain">
Apr
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexplain">
May
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexplain">
Jun
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexplain">
Jul
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexplain">
Aug
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexplain">
Sep
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexplain">
Oct
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexplain">
Nov
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexplain">
Dec
</SPAN>
<SPAN CLASS="regexnest3">
)
</SPAN>
<SPAN CLASS="regexplain">
<BR>
                  
</SPAN>
<SPAN CLASS="regexplain">
-
</SPAN>
<SPAN CLASS="regexnest3">
(?:
</SPAN>
<SPAN CLASS="regexplain">
19
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexplain">
20
</SPAN>
<SPAN CLASS="regexnest3">
)
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
<BR>
</SPAN>
<SPAN CLASS="regexspecial">
^
</SPAN>
<SPAN CLASS="regexplain">
Name:
</SPAN>
<SPAN CLASS="regexescaped">
\ 
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\r
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexspecial">
\n
</SPAN>
<SPAN CLASS="regexplain">
<BR>
</SPAN>
<SPAN CLASS="regexplain">
Born:
</SPAN>
<SPAN CLASS="regexescaped">
\ 
</SPAN>
<SPAN CLASS="regexspecial">
(?P&gt;date)
</SPAN>
<SPAN CLASS="regexspecial">
\r
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexspecial">
\n
</SPAN>
<SPAN CLASS="regexplain">
<BR>
</SPAN>
<SPAN CLASS="regexplain">
Admitted:
</SPAN>
<SPAN CLASS="regexescaped">
\ 
</SPAN>
<SPAN CLASS="regexspecial">
(?P&gt;date)
</SPAN>
<SPAN CLASS="regexspecial">
\r
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexspecial">
\n
</SPAN>
<SPAN CLASS="regexplain">
<BR>
</SPAN>
<SPAN CLASS="regexplain">
Released:
</SPAN>
<SPAN CLASS="regexescaped">
\ 
</SPAN>
<SPAN CLASS="regexspecial">
(?P&gt;date)
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT></p>
<h2>Quantifiers On Subroutine Calls</h2>
<p>Quantifiers on subroutine calls work just like a 
<A HREF="recurserepeat.html" TARGET="_top">
quantifier on recursion
</A>
.  The call is repeated as many times in sequence as needed to satisfy the quantifier.  
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
abc
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
(?1)
</SPAN>
<SPAN CLASS="regexspecial">
{3}
</SPAN>
</TT>
 matches 
<tt class=match>
abcb
</tt>
 and any other combination of four-letter combination of the first three letters of the alphabet.  First the group matches once, and then the call matches three times.  This regex is equivalent to 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
abc
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
abc
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
{3}
</SPAN>
</TT>
.</p>
<p>Quantifiers on the group are ignored by the subroutine call.  
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
abc
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
{3}
</SPAN>
<SPAN CLASS="regexspecial">
(?1)
</SPAN>
</TT>
 also matches 
<tt class=match>
abcb
</tt>
.  First, the group matches three times, because it has a quantifier.  Then the subroutine call matches once, because it has no quantifier.  
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
abc
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
{3}
</SPAN>
<SPAN CLASS="regexspecial">
(?1)
</SPAN>
<SPAN CLASS="regexspecial">
{3}
</SPAN>
</TT>
 matches six letters, such as 
<tt class=match>
abbcab
</tt>
, because now both the group and the call are repeated 3 times.  These two regexes are equivalent to 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
abc
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
{3}
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
abc
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
abc
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
{3}
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
abc
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
{3}
</SPAN>
</TT>
.</p>

<p>While Ruby does not support subroutine definition groups, it does support subroutine calls to groups that are repeated zero times.  
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
{0}
</SPAN>
<SPAN CLASS="regexspecial">
\g&lt;1&gt;
</SPAN>
<SPAN CLASS="regexspecial">
{3}
</SPAN>
</TT>
 matches 
<tt class=match>
aaa
</tt>
.  The group itself is skipped because it is repeated zero times.  Then the subroutine call matches three times, according to its quantifier.  This also works in PCRE 7.7 and later.  It doesn't work (reliably) in older versions of PCRE or in any version of Perl because of bugs.</p>
<p>The Ruby version of the patient record example can be further cleaned up as:</p>
<p><TT CLASS=code>
<SPAN CLASS="regexnest1">
(?'date'
</SPAN>
<SPAN CLASS="regexnest2">
(?:
</SPAN>
<SPAN CLASS="regexplain">
3
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
01
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
12
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
1
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexplain">
<BR>
        
</SPAN>
<SPAN CLASS="regexplain">
-
</SPAN>
<SPAN CLASS="regexnest2">
(?:
</SPAN>
<SPAN CLASS="regexplain">
Jan
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
Feb
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
Mar
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
Apr
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
May
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
Jun
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
Jul
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
Aug
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
Sep
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
Oct
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
Nov
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
Dec
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexplain">
<BR>
        
</SPAN>
<SPAN CLASS="regexplain">
-
</SPAN>
<SPAN CLASS="regexnest2">
(?:
</SPAN>
<SPAN CLASS="regexplain">
19
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
20
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
{0}
</SPAN>
<SPAN CLASS="regexplain">
<BR>
</SPAN>
<SPAN CLASS="regexspecial">
^
</SPAN>
<SPAN CLASS="regexplain">
Name:
</SPAN>
<SPAN CLASS="regexescaped">
\ 
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\r
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexspecial">
\n
</SPAN>
<SPAN CLASS="regexplain">
<BR>
</SPAN>
<SPAN CLASS="regexplain">
Born:
</SPAN>
<SPAN CLASS="regexescaped">
\ 
</SPAN>
<SPAN CLASS="regexspecial">
\g'date'
</SPAN>
<SPAN CLASS="regexspecial">
\r
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexspecial">
\n
</SPAN>
<SPAN CLASS="regexplain">
<BR>
</SPAN>
<SPAN CLASS="regexplain">
Admitted:
</SPAN>
<SPAN CLASS="regexescaped">
\ 
</SPAN>
<SPAN CLASS="regexspecial">
\g'date'
</SPAN>
<SPAN CLASS="regexspecial">
\r
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexspecial">
\n
</SPAN>
<SPAN CLASS="regexplain">
<BR>
</SPAN>
<SPAN CLASS="regexplain">
Released:
</SPAN>
<SPAN CLASS="regexescaped">
\ 
</SPAN>
<SPAN CLASS="regexspecial">
\g'date'
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT></p>

</DIV>
 
<div class=topad>
<A HREF="//www.regexbuddy.com/create.html" TARGET="_top">
</A>
</div>
 
<h1>
Infinite Recursion
</h1>
 
<p>Regular expressions such as 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
(?R)
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexplain">
z
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexspecial">
(?R)
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexplain">
z
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexspecial">
(?R)
</SPAN>
<SPAN CLASS="regexplain">
z
</SPAN>
</TT>
 that use recursion without having anything that must be matched in front of the recursion can result in infinite recursion. If the regex engine reaches the recursion without having advanced through the text then the next recursion will again reach the recursion without having advanced through the text. With the first regex this happens immediately at the start of the match attempt. With the other two this happens as soon as there are no further letters 
<tt class=string>
a
</tt>
 to be matched.</p>
 
<p>JGsoft V2 and Boost 1.64 treat the first two regexes as a syntax error because they always lead to infinite recursion. They allow the third regex because that one can match 
<tt class=match>
a
</tt>
. Ruby 1.9 and later, all versions of PCRE, and PCRE2 10.20 and prior treat all three forms of potential infinite recursion as a syntax error. Perl, PCRE2 10.21 and later, and Boost 1.63 and prior allow all three forms.</p>
<H2>Circular Infinite Subroutine Calls</h2>
 
<p>Subroutine calls can also lead to infinite recursion. All flavors handle the potentially infinite recursion in 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexspecial">
(?1)
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexplain">
z
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexspecial">
(?1)
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexplain">
z
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexspecial">
(?1)
</SPAN>
<SPAN CLASS="regexplain">
z
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 in the same way as they handle potentially infinite recursion of the entire regex.</p>
 
<p>But subroutine calls that are not recursive by themselves may end up being recursive if the group they call has another subroutine call that calls a parent group of the first subroutine call. When subroutine calls are forced to go around in a circle that too leads to infinite recursion. Detecting such circular calls when compiling a regex is more complicated than checking for straight infinite recursion. Only JGsoft V2 and Ruby 1.9 and later are able to detect this and treat it as a syntax error. All other flavors allow these regexes.</p>
<H2>Errors and Crashes</h2>
 
<p>When infinite recursion does occur, whether it's straight recursion or subroutine calls going in circles, JGsoft V2, Perl, and PCRE2 treat it as a matching error that aborts the entire match attempt. Boost 1.64 handles this by not attempting the recursion and acting as if the recursion failed. If the recursion is optional then Boost 1.64 may find matches where other flavors throw errors.</p>
 
<p>Boost 1.63 and prior and PCRE 8.12 and prior crash when infinite recursion occurs. This also affects Delphi up to version XE6 and PHP up to version 5.4.8 as they are based on older PCRE versions.</p>
 
<a name="endless">
</a>

<H2>Endless Recursion</h2>
 
<p>A regex such as 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexspecial">
(?R)
</SPAN>
<SPAN CLASS="regexplain">
z
</SPAN>
</TT>
 that has a recursion token that is not optional and is not have 
<A HREF="alternation.html" TARGET="_top">
an alternative
</A>
 without the same recursion leads to endless recursion. Such a regular expression can never find a match. When 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
 matches the regex engine attempts the recursion. If it can match another 
<tt class=match>
a
</tt>
 then it has to attempt the recursion again. Eventually 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
 will run out of letters to match. The recursion then fails. Because it's not optional the regex fails to match.</p>
 
<p>JGsoft V2 and Ruby detect this situation when compiling your regular expression. They flag endless recursion as a syntax error. Perl, PCRE, PCRE2, and Boost do not detect endless recursion. They simply go through the matching process which finds no matches.

</DIV>
 
<div class=topad>
<A HREF="//www.regexbuddy.com/create.html" TARGET="_top">
</A>
</div>
 
<h1>
Quantifiers On Recursion
</h1>
 
<p>The 
<A HREF="recurse.html" TARGET="_top">
introduction to recursion
</A>
 shows how 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexspecial">
(?R)
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexplain">
z
</SPAN>
</TT>
 matches 
<tt class=match>
aaazzz
</tt>
. The 
<A HREF="repeat.html" TARGET="_top">
quantifier
</A>
 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
?
</SPAN>
</TT>
 makes the preceding token optional. In other words, it repeats the token between zero or one times. In 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexspecial">
(?R)
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexplain">
z
</SPAN>
</TT>
 the 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
(?R)
</SPAN>
</TT>
 is made optional by the 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
?
</SPAN>
</TT>
 that follows it. You may wonder why the regex attempted the recursion three times, instead of once or not at all.</p>
 
<p>The reason is that upon recursion, the regex engine takes a fresh start in attempting the whole regex. All quantifiers and alternatives behave as if the matching process prior to the recursion had never happened at all, other than that the engine advanced through the string. The regex engine restores the states of all quantifiers and alternatives when it exits from a recursion, whether the recursion matched or failed. Basically, the matching process continues normally as if the recursion never happened, other than that the engine advanced through the string.</p>
 
<p>If you're familiar with procedural programming languages, regex recursion is basically a recursive function call and the quantifiers are local variables in the function. Each recursion of the function gets its own set of local variables that don't affect and aren't affected by the same local variables in recursions higher up the stack. Quantifiers on recursion work this way in all flavors, except 
<A HREF="boost.html" TARGET="_top">
Boost
</A>
.</p>
 
<p>Let's see how 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexspecial">
(?R)
</SPAN>
<SPAN CLASS="regexspecial">
{3}
</SPAN>
<SPAN CLASS="regexplain">
z
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexplain">
q
</SPAN>
</TT>
 behaves (Boost excepted). The simplest possible match is 
<tt class=match>
q
</tt>
, found by the second alternative in the regex.</p>
 
<p>The simplest match in which the first alternative matches is 
<tt class=match>
aqqqz
</tt>
. After 
<tt class=match>
a
</tt>
 is matches, the regex engine begins a recursion. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
 fails to match 
<tt class=string>
q
</tt>
. Still inside the recursion, the engine attempts the second alternative. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
q
</SPAN>
</TT>
 matches 
<tt class=match>
q
</tt>
. The engine exits from the recursion with a successful match. The engine now notes that the quantifier 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
{3}
</SPAN>
</TT>
 has successfully repeated once. It needs two more repetitions, so the engine begins another recursion. It again matches 
<tt class=match>
q
</tt>
. On the third iteration of the quantifier, the third recursion matches 
<tt class=match>
q
</tt>
. Finally, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
z
</SPAN>
</TT>
 matches 
<tt class=match>
z
</tt>
 and an overall match is found.</p>
 
<p>This regex does not match 
<tt class=string>
aqqz
</tt>
 or 
<tt class=string>
aqqqqz
</tt>
. 
<tt class=string>
aqqz
</tt>
 fails because during the third iteration of the quantifier, the recursion fails to match 
<tt class=string>
z
</tt>
. 
<tt class=string>
aqqqqz
</tt>
 fails because after 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexspecial">
(?R)
</SPAN>
<SPAN CLASS="regexspecial">
{3}
</SPAN>
</TT>
 has matched 
<tt class=match>
aqqq
</tt>
, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
z
</SPAN>
</TT>
 fails to match the fourth 
<tt class=string>
q
</tt>
.</p>
 
<p>The regex can match longer strings such as 
<tt class=match>
aqaqqqzqz
</tt>
. With this string, during the second iteration of the quantifier, the recursion matches 
<tt class=match>
aqqqz
</tt>
. Since each recursion tracks the quantifier separately, the recursion needs three consecutive recursions of its own to satisfy its own instance of the quantifier. This can lead to arbitrarily long matches such as 
<tt class=match>
aaaqqaqqqzzaqqqzqzqaqqaaqqqzqqzzz
</tt>
.</p>
<H2>How Boost Handles Quantifiers on Recursion</h2>
 
<p>Boost has its own ideas about how quantifiers should work on recursion. Recursion only works the same in Boost as in other flavors if the recursion operator either has no quantifier at all or if it has 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
 as its quantifier. Any other quantifier may lead to very different matches (or lack thereof) in Boost 1.59 or prior versus Boost 1.60 and later versus other regex flavors. Boost 1.60 attempted to fix some of the differences between Boost and other flavors but it only resulted in a different incompatible behavior.</p>
 
<p>In Boost 1.59 and prior, quantifiers on recursion count both iteration and recursion throughout the entire recursion stack. So possible matches for 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexspecial">
(?R)
</SPAN>
<SPAN CLASS="regexspecial">
{3}
</SPAN>
<SPAN CLASS="regexplain">
z
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexplain">
q
</SPAN>
</TT>
 in Boost 1.59 include 
<tt class=match>
aaaazzzz
</tt>
, 
<tt class=match>
aaaqzzz
</tt>
, 
<tt class=match>
aaqqzz
</tt>
, 
<tt class=match>
aaqzqz
</tt>
, and 
<tt class=match>
aqaqzzz
</tt>
. In all these matches the number of recursions and iterations add up to 3. No other flavor would find these matches because they require 3 iterations during each recursion. So other flavors can match things like 
<tt class=match>
aaqqqzaqqqzaqqqzz
</tt>
 or 
<tt class=match>
aqqaqqqzz
</tt>
. Boost 1.59 would match only 
<tt class=match>
aqqqz
</tt>
 within these strings.</p>
 
<p>Boost 1.60 attempts to iterate quantifiers at each recursion level like other flavors, but does so incorrectly. Any quantifier that makes the recursion optional allows for infinite repetition. So Boost 1.60 and later treat 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexspecial">
(?R)
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexplain">
z
</SPAN>
</TT>
 the same as 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexspecial">
(?R)
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexplain">
z
</SPAN>
</TT>
. While this fixes the problem that 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexspecial">
(?R)
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexplain">
z
</SPAN>
</TT>
 could not match 
<tt class=match>
aaazzz
</tt>
 entirely in Boost 1.59, it also allows matches such as 
<tt class=match>
aazazz
</tt>
 that other flavors won't find with this regex. If the quantifier is not optional, then Boost 1.60 only allows it to match during the first recursion. So 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexspecial">
(?R)
</SPAN>
<SPAN CLASS="regexspecial">
{3}
</SPAN>
<SPAN CLASS="regexplain">
z
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexplain">
q
</SPAN>
</TT>
 could only ever match 
<tt class=match>
q
</tt>
 or 
<tt class=match>
aqqqz
</tt>
.</p>
 
<p>Boost's issues with quantifiers on recursion also affect quantifiers on parent groups of the recursion token. They also affect quantifiers on subroutine calls and quantifiers groups that contain a subroutine call to a parent group of the group with the quantifier.</p>
<H2>Quantifiers on Other Tokens in The Recursion</h2>
 
<p>Quantifiers on other tokens in the regex behave normally during recursion. They track their iterations separately at each recursion. So 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexspecial">
{2}
</SPAN>
<SPAN CLASS="regexspecial">
(?R)
</SPAN>
<SPAN CLASS="regexplain">
z
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexplain">
q
</SPAN>
</TT>
 matches 
<tt class=match>
aaqz
</tt>
, 
<tt class=match>
aaaaqzz
</tt>
, 
<tt class=match>
aaaaaaqzzz
</tt>
, and so on. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
 has to match twice during each recursion.</p>
 
<p>Quantifiers like these that are inside the recursion but do not repeat the recursion itself do work correctly in Boost.</p>

</DIV>
 
<h1>
Subroutine Calls May or May Not Capture
</h1>
<p>This tutorial 
<A HREF="subroutine.html" TARGET="_top">
introduced regular expression subroutines
</A>
 with this example that we want to match accurately:</p>
<pre>
Name: John Doe
Born: 17-Jan-1964
Admitted: 30-Jul-2013
Released: 3-Aug-2013
</pre>
<p>In 
<A HREF="ruby.html" TARGET="_top">
Ruby
</A>
 or 
<A HREF="pcre.html" TARGET="_top">
PCRE
</A>
, we can use this regular expression:</p>

<p><TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
<SPAN CLASS="regexplain">
Name:
</SPAN>
<SPAN CLASS="regexescaped">
\ 
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\n
</SPAN>
<SPAN CLASS="regexplain">
<BR>
</SPAN>
<SPAN CLASS="regexplain">
Born:
</SPAN>
<SPAN CLASS="regexescaped">
\ 
</SPAN>
<SPAN CLASS="regexnest1">
(?'date'
</SPAN>
<SPAN CLASS="regexnest2">
(?:
</SPAN>
<SPAN CLASS="regexplain">
3
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
01
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
12
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
1
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexplain">
<BR>
               
</SPAN>
<SPAN CLASS="regexplain">
-
</SPAN>
<SPAN CLASS="regexnest2">
(?:
</SPAN>
<SPAN CLASS="regexplain">
Jan
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
Feb
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
Mar
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
Apr
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
May
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
Jun
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
Jul
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
Aug
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
Sep
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
Oct
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
Nov
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
Dec
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexplain">
<BR>
               
</SPAN>
<SPAN CLASS="regexplain">
-
</SPAN>
<SPAN CLASS="regexnest2">
(?:
</SPAN>
<SPAN CLASS="regexplain">
19
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
20
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\n
</SPAN>
<SPAN CLASS="regexplain">
<BR>
</SPAN>
<SPAN CLASS="regexplain">
Admitted:
</SPAN>
<SPAN CLASS="regexescaped">
\ 
</SPAN>
<SPAN CLASS="regexspecial">
\g'date'
</SPAN>
<SPAN CLASS="regexspecial">
\n
</SPAN>
<SPAN CLASS="regexplain">
<BR>
</SPAN>
<SPAN CLASS="regexplain">
Released:
</SPAN>
<SPAN CLASS="regexescaped">
\ 
</SPAN>
<SPAN CLASS="regexspecial">
\g'date'
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT></p>
<p><A HREF="perl.html" TARGET="_top">
Perl
</A>
 needs slightly different syntax, which also works in PCRE:</p>

<p><TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
<SPAN CLASS="regexplain">
Name:
</SPAN>
<SPAN CLASS="regexescaped">
\ 
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\n
</SPAN>
<SPAN CLASS="regexplain">
<BR>
</SPAN>
<SPAN CLASS="regexplain">
Born:
</SPAN>
<SPAN CLASS="regexescaped">
\ 
</SPAN>
<SPAN CLASS="regexnest1">
(?'date'
</SPAN>
<SPAN CLASS="regexnest2">
(?:
</SPAN>
<SPAN CLASS="regexplain">
3
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
01
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
12
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
1
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexplain">
<BR>
               
</SPAN>
<SPAN CLASS="regexplain">
-
</SPAN>
<SPAN CLASS="regexnest2">
(?:
</SPAN>
<SPAN CLASS="regexplain">
Jan
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
Feb
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
Mar
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
Apr
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
May
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
Jun
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
Jul
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
Aug
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
Sep
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
Oct
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
Nov
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
Dec
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexplain">
<BR>
               
</SPAN>
<SPAN CLASS="regexplain">
-
</SPAN>
<SPAN CLASS="regexnest2">
(?:
</SPAN>
<SPAN CLASS="regexplain">
19
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
20
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\n
</SPAN>
<SPAN CLASS="regexplain">
<BR>
</SPAN>
<SPAN CLASS="regexplain">
Admitted:
</SPAN>
<SPAN CLASS="regexescaped">
\ 
</SPAN>
<SPAN CLASS="regexspecial">
(?&amp;date)
</SPAN>
<SPAN CLASS="regexspecial">
\n
</SPAN>
<SPAN CLASS="regexplain">
<BR>
</SPAN>
<SPAN CLASS="regexplain">
Released:
</SPAN>
<SPAN CLASS="regexescaped">
\ 
</SPAN>
<SPAN CLASS="regexspecial">
(?&amp;date)
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT></p>

<p>Unfortunately, there are differences in how these three regex flavors treat subroutine calls beyond their syntax.  First of all, in Ruby a subroutine call makes the capturing group store the text matched during the subroutine call.  In Perl, PCRE, and Boost a subroutine call does not affect the group that is called.</p>
<p>When the Ruby solution matches the sample above, retrieving the contents of the capturing group "date" will get you 
<tt class=match>
3-Aug-2013
</tt>
 which was matched by the last subroutine call to that group.  When the Perl solution matches the same, retrieving 
<tt class=code>
$+{date}
</tt>
 will get you 
<tt class=match>
17-Jan-1964
</tt>
.  In Perl, the subroutine calls did not capture anything at all.  But the "Born" date was matched with a normal 
<A HREF="named.html" TARGET="_top">
named capturing group
</A>
 which stored the text that it matched normally.  Any subroutine calls to the group don't change that.  PCRE behaves as Perl in this case, even when you use the Ruby syntax with PCRE.</p>
<p><a href="jgsoft.html#v2">
JGsoft V2
</a>
 behaves like Ruby when you use the first regular expression.  You can remember this by the fact that the 
<tt>
\g
</tt>
 syntax is a Ruby invention, later copied by PCRE.  JGsoft V2 behaves like Perl when you use the second regular expression.  You can remember this by the fact that Perl uses ampersands for subroutine calls in procedural code too.</p>

<p>If you want to extract the dates from the match, the best solution is to add another capturing group for each date.  Then you can ignore the text stored by the "date" group and this particular difference between these flavors.  In Ruby or PCRE:</p>
<p><TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
<SPAN CLASS="regexplain">
Name:
</SPAN>
<SPAN CLASS="regexescaped">
\ 
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\n
</SPAN>
<SPAN CLASS="regexplain">
<BR>
</SPAN>
<SPAN CLASS="regexplain">
Born:
</SPAN>
<SPAN CLASS="regexescaped">
\ 
</SPAN>
<SPAN CLASS="regexnest1">
(?'born'
</SPAN>
<SPAN CLASS="regexnest2">
(?'date'
</SPAN>
<SPAN CLASS="regexnest3">
(?:
</SPAN>
<SPAN CLASS="regexplain">
3
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
01
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
12
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
1
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest3">
)
</SPAN>
<SPAN CLASS="regexplain">
<BR>
                       
</SPAN>
<SPAN CLASS="regexplain">
-
</SPAN>
<SPAN CLASS="regexnest3">
(?:
</SPAN>
<SPAN CLASS="regexplain">
Jan
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexplain">
Feb
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexplain">
Mar
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexplain">
Apr
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexplain">
May
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexplain">
Jun
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexplain">
Jul
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexplain">
Aug
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexplain">
Sep
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexplain">
Oct
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexplain">
Nov
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexplain">
Dec
</SPAN>
<SPAN CLASS="regexnest3">
)
</SPAN>
<SPAN CLASS="regexplain">
<BR>
                       
</SPAN>
<SPAN CLASS="regexplain">
-
</SPAN>
<SPAN CLASS="regexnest3">
(?:
</SPAN>
<SPAN CLASS="regexplain">
19
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexplain">
20
</SPAN>
<SPAN CLASS="regexnest3">
)
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\n
</SPAN>
<SPAN CLASS="regexplain">
<BR>
</SPAN>
<SPAN CLASS="regexplain">
Admitted:
</SPAN>
<SPAN CLASS="regexescaped">
\ 
</SPAN>
<SPAN CLASS="regexnest1">
(?'admitted'
</SPAN>
<SPAN CLASS="regexspecial">
\g'date'
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\n
</SPAN>
<SPAN CLASS="regexplain">
<BR>
</SPAN>
<SPAN CLASS="regexplain">
Released:
</SPAN>
<SPAN CLASS="regexescaped">
\ 
</SPAN>
<SPAN CLASS="regexnest1">
(?'released'
</SPAN>
<SPAN CLASS="regexspecial">
\g'date'
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT></p>

<p><A HREF="perl.html" TARGET="_top">
Perl
</A>
 needs slightly different syntax, which also works in PCRE:</p>
<p><TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
<SPAN CLASS="regexplain">
Name:
</SPAN>
<SPAN CLASS="regexescaped">
\ 
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\n
</SPAN>
<SPAN CLASS="regexplain">
<BR>
</SPAN>
<SPAN CLASS="regexplain">
Born:
</SPAN>
<SPAN CLASS="regexescaped">
\ 
</SPAN>
<SPAN CLASS="regexnest1">
(?'born'
</SPAN>
<SPAN CLASS="regexnest2">
(?'date'
</SPAN>
<SPAN CLASS="regexnest3">
(?:
</SPAN>
<SPAN CLASS="regexplain">
3
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
01
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
12
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
1
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest3">
)
</SPAN>
<SPAN CLASS="regexplain">
<BR>
                       
</SPAN>
<SPAN CLASS="regexplain">
-
</SPAN>
<SPAN CLASS="regexnest3">
(?:
</SPAN>
<SPAN CLASS="regexplain">
Jan
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexplain">
Feb
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexplain">
Mar
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexplain">
Apr
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexplain">
May
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexplain">
Jun
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexplain">
Jul
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexplain">
Aug
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexplain">
Sep
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexplain">
Oct
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexplain">
Nov
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexplain">
Dec
</SPAN>
<SPAN CLASS="regexnest3">
)
</SPAN>
<SPAN CLASS="regexplain">
<BR>
                       
</SPAN>
<SPAN CLASS="regexplain">
-
</SPAN>
<SPAN CLASS="regexnest3">
(?:
</SPAN>
<SPAN CLASS="regexplain">
19
</SPAN>
<SPAN CLASS="regexnest3">
|
</SPAN>
<SPAN CLASS="regexplain">
20
</SPAN>
<SPAN CLASS="regexnest3">
)
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\n
</SPAN>
<SPAN CLASS="regexplain">
<BR>
</SPAN>
<SPAN CLASS="regexplain">
Admitted:
</SPAN>
<SPAN CLASS="regexescaped">
\ 
</SPAN>
<SPAN CLASS="regexnest1">
(?'admitted'
</SPAN>
<SPAN CLASS="regexspecial">
(?&amp;date)
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\n
</SPAN>
<SPAN CLASS="regexplain">
<BR>
</SPAN>
<SPAN CLASS="regexplain">
Released:
</SPAN>
<SPAN CLASS="regexescaped">
\ 
</SPAN>
<SPAN CLASS="regexnest1">
(?'released'
</SPAN>
<SPAN CLASS="regexspecial">
(?&amp;date)
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT></p>


<H2>Capturing Groups Inside Recursion or Subroutine Calls</h2>
<p>There are further differences between Perl, PCRE, and Ruby when your regex makes a subroutine call or recursive call to a capturing group that contains other capturing groups.  The same issues also affect 
<A HREF="recurse.html" TARGET="_top">
recursion of the whole regular expression
</A>
 if it contains any capturing groups.  For the remainder of this topic, the term "recursion" applies equally to recursion of the whole regex, recursion into a capturing group, or a subroutine call to a capturing group.</p>
<p>PCRE and Boost back up and restores capturing groups when entering and exiting recursion.  When the regex engine enters recursion, it internally makes a copy of all capturing groups.  This does not affect the capturing groups.  Backreferences inside the recursion match text captured prior to the recursion unless and until the group they reference captures something during the recursion.  After the recursion, all capturing groups are replaced with the internal copy that was made at the start of the recursion.  Text captured during the recursion is discarded.  This means you cannot use capturing groups to retrieve parts of the text that were matched during recursion.</p>

<p>Perl 5.10, the first version to have recursion, through version 5.18, isolated capturing groups between each level of recursion.  When Perl 5.10's regex engine enters recursion, all capturing groups appear as they have not participated in the match yet.  Initially, all backreferences will fail.  During the recursion, capturing groups capture as normal.  Backreferences match text captured during the same recursion as normal.  When the regex engine exits from the recursion, all capturing groups revert to the state they were in prior to the recursion.  Perl 5.20 changed Perl's behavior to back up and restore capturing groups the way PCRE does.</p>
<p>For most practical purposes, however, you'll only use backreferences after their corresponding capturing groups.  Then the difference between the way Perl 5.10 through 5.18 deal with capturing groups during recursion and the way PCRE and later versions of Perl do is academic.</p>

<p>Ruby's behavior is completely different.  When Ruby's regex engine enters or exists recursion, it makes no changes to the text stored by capturing groups at all.  Backreferences match the text stored by the capturing group during the group's most recent match, irrespective of any recursion that may have happened.  After an overall match is found, each capturing group still stores the text of its most recent match, even if that was during a recursion.  This means you can use capturing groups to retrieve part of the text matched during the last recursion.</p>
<p>JGsoft V2 behaves like Ruby when you use the 
<tt>
\g
</tt>
 syntax borrowed from Ruby.  It behaves like Perl 5.20 and PCRE when you use any other syntax.</p>
<a name="palindrome">
</a>
<h2>Odd Length Palindromes in Perl and PCRE</h2>
<p>In Perl and PCRE you can use 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexnest1">
(?'word'
</SPAN>
<SPAN CLASS="regexnest2">
(?'letter'
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexspecial">
(?&amp;word)
</SPAN>
<SPAN CLASS="regexspecial">
\k'letter'
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 to match palindrome words such as 
<tt class=match>
a
</tt>
, 
<tt class=match>
dad
</tt>
, 
<tt class=match>
radar
</tt>
, 
<tt class=match>
racecar
</tt>
, and 
<tt class=match>
redivider
</tt>
.  This regex only matches palindrome words that are an odd number of letters long.  This covers most palindrome words in English.  To extend the regex to also handle palindrome words that are an even number of characters long we have to worry about differences in how Perl and PCRE 
<A HREF="recursebacktrack.html" TARGET="_top">
backtrack after a failed recursion attempt
</A>
 which is discussed later in this tutorial.  We gloss over these differences here because they only come into play when the subject string is not a palindrome and no match can be found.</p>
<p>Let's see how this regex matches 
<tt class=match>
radar
</tt>
.  The 
<A HREF="wordboundaries.html" TARGET="_top">
word boundary
</A>
 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 matches at the start of the string.  The regex engine enters the two capturing groups.  
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 matches 
<tt class=match>
r
</tt>
 which is then stored in the capturing group "letter".  Now the regex engine enters the first recursion of the group "word".  At this point, Perl forgets that the "letter" group matched 
<tt class=match>
r
</tt>
.  PCRE does not.  But this does not matter.  
<TT CLASS=code>
<SPAN CLASS="regexnest2">
(?'letter'
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
</TT>
 matches and captures 
<tt class=match>
a
</tt>
.  The regex enters the second recursion of the group "word". 
<TT CLASS=code>
<SPAN CLASS="regexnest2">
(?'letter'
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
</TT>
 captures 
<tt class=match>
d
</tt>
.  During the next two recursions, the group captures 
<tt class=match>
a
</tt>
 and 
<tt class=match>
r
</tt>
.  The fifth recursion fails because there are no characters left in the string for 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 to match.  The regex engine must backtrack.</p>
<p>Because 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
(?&amp;word)
</SPAN>
</TT>
 failed to match, 
<TT CLASS=code>
<SPAN CLASS="regexnest2">
(?'letter'
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
</TT>
 must give up its match.  The group reverts to 
<tt class=match>
a
</tt>
, which was the text the group held at the start of the recursion.  (It becomes empty in Perl 5.18 and prior.)  Again, this does not matter because the regex engine must now try the second alternative inside the group "word", which contains no backreferences.  The second 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 matches the final 
<tt class=match>
r
</tt>
 in the string.  The engine now exits from a successful recursion.  The text stored by the group "letter" is restored to what it had captured prior to entering the fourth recursion, which is 
<tt class=match>
a
</tt>
.</p>
<p>After matching 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
(?&amp;word)
</SPAN>
</TT>
 the engine reaches 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\k'letter'
</SPAN>
</TT>
.  The backreference fails because the regex engine has already reached the end of the subject string.  So it backtracks once more, making the capturing group give up the 
<tt class=string>
a
</tt>
.  The second alternative now matches the 
<tt class=match>
a
</tt>
.  The regex engine exits from the third recursion.  The group "letter" is restored to the 
<tt class=match>
d
</tt>
 matched during the second recursion.</p>
<p>The regex engine has again matched 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
(?&amp;word)
</SPAN>
</TT>
.  The backreference fails again because the group stores 
<tt class=match>
d
</tt>
 while the next character in the string is 
<tt class=string>
r
</tt>
.  Backtracking again, the second alternative matches 
<tt class=match>
d
</tt>
 and the group is restored to the 
<tt class=match>
a
</tt>
 matched during the first recursion.</p>
<p>Now, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\k'letter'
</SPAN>
</TT>
 matches the second 
<tt class=match>
a
</tt>
 in the string.  That's because the regex engine has arrived back at the first recursion during which the capturing group matched the first 
<tt class=match>
a
</tt>
.  The regex engine exits the first recursion.  The capturing group to the 
<tt class=match>
r
</tt>
 which it matched prior to the first recursion.</p>
<p>Finally, the backreference matches the second 
<tt class=match>
r
</tt>
.  Since the engine is not inside any recursion any more, it proceeds with the remainder of the regex after the group.  
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 matches at the end of the string.  The end of the regex is reached and 
<tt class=match>
radar
</tt>
 is returned as the overall match.  If you query the groups "word" and "letter" after the match you'll get 
<tt class=match>
radar
</tt>
 and 
<tt class=match>
r
</tt>
.  That's the text matched by these groups outside of all recursion.</p>
<h2>Why This Regex Does Not Work in Ruby</h2>
<p>To match palindromes this way in Ruby, you need to use a special 
<A HREF="recursebackref.html" TARGET="_top">
backreference that specifies a recursion level
</A>
.  If you use a normal backreference as in 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexnest1">
(?'word'
</SPAN>
<SPAN CLASS="regexnest2">
(?'letter'
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexspecial">
\g'word'
</SPAN>
<SPAN CLASS="regexspecial">
\k'letter'
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
, Ruby will not complain.  But it will not match palindromes longer than three letters either.  Instead this regex matches things like 
<tt class=match>
a
</tt>
, 
<tt class=match>
dad
</tt>
, 
<tt class=match>
radaa
</tt>
, 
<tt class=match>
raceccc
</tt>
, and 
<tt class=match>
rediviiii
</tt>
.</p>
<p>Let's see why this regex does not match 
<tt class=string>
radar
</tt>
 in Ruby.  Ruby starts out like Perl and PCRE, entering the recursions until there are no characters left in the string for 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 to match.</p>
<p>Because 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\g'word'
</SPAN>
</TT>
 failed to match, 
<TT CLASS=code>
<SPAN CLASS="regexnest2">
(?'letter'
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
</TT>
 must give up its match.  Ruby reverts it to 
<tt class=match>
a
</tt>
, which was the text the group most recently matched.  The second 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 matches the final 
<tt class=match>
r
</tt>
 in the string.  The engine now exits from a successful recursion.  The group "letter" continues to hold its most recent match 
<tt class=match>
a
</tt>
.</p>
<p>After matching 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\g'word'
</SPAN>
</TT>
 the engine reaches 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\k'letter'
</SPAN>
</TT>
.  The backreference fails because the regex engine has already reached the end of the subject string.  So it backtracks once more, reverting the group to the previously matched 
<tt class=string>
d
</tt>
.  The second alternative now matches the 
<tt class=match>
a
</tt>
.  The regex engine exits from the third recursion.</p>
<p>The regex engine has again matched 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\g'word'
</SPAN>
</TT>
.  The backreference fails again because the group stores 
<tt class=match>
d
</tt>
 while the next character in the string is 
<tt class=string>
r
</tt>
.  Backtracking again, the group reverts to 
<tt class=match>
a
</tt>
 and the second alternative matches 
<tt class=match>
d
</tt>
.</p>
<p>Now, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\k'letter'
</SPAN>
</TT>
 matches the second 
<tt class=match>
a
</tt>
 in the string.  The regex engine exits the first recursion which successfully matched 
<tt class=match>
ada
</tt>
.  The capturing group continues to hold 
<tt class=match>
a
</tt>
 which is its most recent match that wasn't backtracked.</p>
<p>The regex engine is now at the last character in the string.  This character is 
<tt class=string>
r
</tt>
.  The backreference fails because the group still holds 
<tt class=match>
a
</tt>
.  The engine can backtrack once more, forcing 
<TT CLASS=code>
<SPAN CLASS="regexnest2">
(?'letter'
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexspecial">
\g'word'
</SPAN>
<SPAN CLASS="regexspecial">
\k'letter'
</SPAN>
</TT>
 to give up the 
<tt class=match>
rada
</tt>
 it matched so far.  The regex engine is now back at the start of the string.  It can still try the second alternative in the group.  This matches the first 
<tt class=match>
r
</tt>
 in the string.  Since the engine is not inside any recursion any more, it proceeds with the remainder of the regex after the group.  
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 fails to match after the first 
<tt class=string>
r
</tt>
.  The regex engine has no further permutations to try.  The match attempt has failed.</p>
<p>If the subject string is 
<tt class=string>
radaa
</tt>
, Ruby's engine goes through nearly the same matching process as described above.  Only the events described in the last paragraph change.  When the regex engine reaches the last character in the string, that character is now 
<tt class=string>
a
</tt>
.  This time, the backreference matches.  Since the engine is not inside any recursion any more, it proceeds with the remainder of the regex after the group.  
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 matches at the end of the string.  The end of the regex is reached and 
<tt class=match>
radaa
</tt>
 is returned as the overall match.  If you query the groups "word" and "letter" after the match you'll get 
<tt class=match>
radaa
</tt>
 and 
<tt class=match>
a
</tt>
.  Those are the most recent matches of these groups that weren't backtracked.</p>
<p>Basically, in Ruby this regex matches any word that is an odd number of letters long and in which all the characters to the right of the middle letter are identical to the character just to the left of the middle letter.  That's because Ruby only restores capturing groups when they backtrack, but not when it exits from recursion.</p>
<p>The solution, specific to Ruby, is to use a 
<A HREF="recursebackref.html" TARGET="_top">
backreference that specifies a recursion level
</A>
 instead of the normal backreference used in the regex on this page.</p>

</DIV>
 
<div class=topad>
<A HREF="//www.regexbuddy.com/create.html" TARGET="_top">
</A>
</div>
 
<h1>
Backreferences That Specify a Recursion Level
</h1>
 
<p>Earlier topics in this tutorial explain 
<A HREF="recurse.html" TARGET="_top">
regular expression recursion
</A>
 and 
<A HREF="subroutine.html" TARGET="_top">
regular expression subroutines
</A>
. In this topic the word "recursion" refers to recursion of the whole regex, recursion of capturing groups, and subroutine calls to capturing groups. The previous topic also explained that these features 
<A HREF="recursecapture.html" TARGET="_top">
handle capturing groups differently
</A>
 in Ruby than they do in Perl and PCRE.</p>
 
<p>Perl, PCRE, and Boost restore capturing groups when they exit from recursion. This means that backreferences in Perl, PCRE, and Boost match the same text that was matched by the capturing group at the same recursion level. This makes it possible to do things like 
<a href="recursecapture.html#palindrome">
matching palindromes
</a>
.</p>
 
<p>Ruby does not restore capturing groups when it exits from recursion. 
<A HREF="backref.html" TARGET="_top">
Normal backreferences
</A>
 match the text that is the same as the most recent match of the capturing group that was not backtracked, regardless of whether the capturing group found its match at the same or a different recursion level as the backreference. Basically, normal backreferences in Ruby don't pay any attention to recursion.</p>
 
<p>But while the normal capturing group storage in Ruby does not get any special treatment for recursion, Ruby actually stores a full stack of matches for each capturing groups at all recursion levels. This stack even includes recursion levels that the regex engine has already exited from.</p>
 
<p>Backreferences in Ruby can match the same text as was matched by a capturing group at any recursion level relative to the recursion level that the backreference is evaluated at. You can do this with the same syntax for 
<A HREF="named.html" TARGET="_top">
named backreferences
</A>
 by adding a sign and a number after the name. In most situations you will use 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
+0
</SPAN>
</TT>
 to specify that you want the backreference to reuse the text from the capturing group at the same recursion level. You can specify a positive number to reference the capturing group at a deeper level of recursion. This would be a recursion the regex engine has already exited from. You can specify a negative number to reference the capturing group a level that is less deep. This would be a recursion that is still in progress.</p>
 
<p><a href="jgsoft.html#v2">
JGsoft V2
</a>
 also supports backreferences that specify a recursion level using the same syntax as Ruby. To get the same behavior with JGsoft V2 as with Ruby, you have to use Ruby's 
<tt>
\g
</tt>
 syntax for your subroutine calls.</p>
 
<a name="palindrome.html">
</a>

<H2>Odd Length Palindromes in Ruby</h2>
 
<p>In Ruby you can use 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexnest1">
(?'word'
</SPAN>
<SPAN CLASS="regexnest2">
(?'letter'
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexspecial">
\g'word'
</SPAN>
<SPAN CLASS="regexspecial">
\k'letter+0'
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 to match palindrome words such as 
<tt class=match>
a
</tt>
, 
<tt class=match>
dad
</tt>
, 
<tt class=match>
radar
</tt>
, 
<tt class=match>
racecar
</tt>
, and 
<tt class=match>
redivider
</tt>
. To keep this example simple, this regex only matches palindrome words that are an odd number of letters long.</p>
 
<p>Let's see how this regex matches 
<tt class=match>
radar
</tt>
. The 
<A HREF="wordboundaries.html" TARGET="_top">
word boundary
</A>
 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 matches at the start of the string. The regex engine enters the capturing group "word". 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 matches 
<tt class=match>
r
</tt>
 which is then stored in the stack for the capturing group "letter" at recursion level zero. Now the regex engine enters the first recursion of the group "word". 
<TT CLASS=code>
<SPAN CLASS="regexnest2">
(?'letter'
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
</TT>
 matches and captures 
<tt class=match>
a
</tt>
 at recursion level one. The regex enters the second recursion of the group "word". 
<TT CLASS=code>
<SPAN CLASS="regexnest2">
(?'letter'
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
</TT>
 captures 
<tt class=match>
d
</tt>
 at recursion level two. During the next two recursions, the group captures 
<tt class=match>
a
</tt>
 and 
<tt class=match>
r
</tt>
 at levels three and four. The fifth recursion fails because there are no characters left in the string for 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 to match. The regex engine must backtrack.</p>
 
<p>The regex engine must now try the second alternative inside the group "word". The second 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 in the regex matches the final 
<tt class=match>
r
</tt>
 in the string. The engine now exits from a successful recursion, going one level back up to the third recursion.</p>
 
<p>After matching 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\g'word'
</SPAN>
</TT>
 the engine reaches 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\k'letter+0'
</SPAN>
</TT>
. The backreference fails because the regex engine has already reached the end of the subject string. So it backtracks once more. The second alternative now matches the 
<tt class=match>
a
</tt>
. The regex engine exits from the third recursion.</p>
 
<p>The regex engine has again matched 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\g'word'
</SPAN>
</TT>
 and needs to attempt the backreference again. The backreference specifies 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
+0
</SPAN>
</TT>
 or the present level of recursion, which is 2. At this level, the capturing group matched 
<tt class=match>
d
</tt>
. The backreference fails because the next character in the string is 
<tt class=string>
r
</tt>
. Backtracking again, the second alternative matches 
<tt class=match>
d
</tt>
.</p>
 
<p>Now, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\k'letter+0'
</SPAN>
</TT>
 matches the second 
<tt class=match>
a
</tt>
 in the string. That's because the regex engine has arrived back at the first recursion during which the capturing group matched the first 
<tt class=match>
a
</tt>
. The regex engine exits the first recursion.</p>
 
<p>The regex engine is now back outside all recursion. That this level, the capturing group stored 
<tt class=match>
r
</tt>
. The backreference can now match the final 
<tt class=match>
r
</tt>
 in the string. Since the engine is not inside any recursion any more, it proceeds with the remainder of the regex after the group. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 matches at the end of the string. The end of the regex is reached and 
<tt class=match>
radar
</tt>
 is returned as the overall match.</p>
<H2>Backreferences to Other Recursion Levels</h2>
 
<p>Backreferences to other recursion levels can be easily understood if we modify our palindrome example. 
<tt class=match>
abcdefedcba
</tt>
 is also a palindrome matched by the previous regular expression. Consider the regular expression 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexnest1">
(?'word'
</SPAN>
<SPAN CLASS="regexnest2">
(?'letter'
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexspecial">
\g'word'
</SPAN>
<SPAN CLASS="regexnest2">
(?:
</SPAN>
<SPAN CLASS="regexspecial">
\k'letter-1'
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
z
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
. The backreference now wants a match the text one level less deep on the capturing group's stack. It is alternated with the letter 
<TT CLASS=code>
<SPAN CLASS="regexccrange">
z
</SPAN>
</TT>
 so that something can be matched when the backreference fails to match.</p>
 
<p>The new regex matches things like 
<tt class=match>
abcdefdcbaz
</tt>
. After a whole bunch of matching and backtracking, the second 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 matches 
<tt class=match>
f
</tt>
. The regex engine exits form a successful fifth recursion. The capturing group "letter" has stored the matches 
<tt class=match>
a
</tt>
, 
<tt class=match>
b
</tt>
, 
<tt class=match>
c
</tt>
, 
<tt class=match>
d
</tt>
, and 
<tt class=match>
e
</tt>
 at recursion levels zero to four. Other matches by that group were backtracked and thus not retained.</p>
 
<p>Now the engine evaluates the backreference 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\k'letter-1'
</SPAN>
</TT>
. The present level is 4 and the backreference specifies -1. Thus the engine attempts to match 
<tt class=match>
d
</tt>
, which succeeds. The engine exits from the fourth recursion.</p>
 
<p>The backreference continues to match 
<tt class=match>
c
</tt>
, 
<tt class=match>
b
</tt>
, and 
<tt class=match>
a
</tt>
 until the regex engine has exited the first recursion. Now, outside all recursion, the regex engine again reaches 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\k'letter-1'
</SPAN>
</TT>
. The present level is 0 and the backreference specifies -1. Since recursion level -1 never happened, the backreference fails to match. This is not an error but simply a 
<A HREF="backref2.html" TARGET="_top">
backreference to a non-participating capturing group
</A>
. But the backreference has an alternative. 
<TT CLASS=code>
<SPAN CLASS="regexccrange">
z
</SPAN>
</TT>
 matches 
<tt class=match>
z
</tt>
 and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 matches at the end of the string. 
<tt class=match>
abcdefdcbaz
</tt>
 was matched successfully.</p>
 
<p>You can take this as far as you like. The regular expression 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexnest1">
(?'word'
</SPAN>
<SPAN CLASS="regexnest2">
(?'letter'
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexspecial">
\g'word'
</SPAN>
<SPAN CLASS="regexnest2">
(?:
</SPAN>
<SPAN CLASS="regexspecial">
\k'letter-2'
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
z
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 matches 
<tt class=match>
abcdefcbazz
</tt>
. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexnest1">
(?'word'
</SPAN>
<SPAN CLASS="regexnest2">
(?'letter'
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexspecial">
\g'word'
</SPAN>
<SPAN CLASS="regexnest2">
(?:
</SPAN>
<SPAN CLASS="regexspecial">
\k'letter-99'
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
z
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 matches 
<tt class=match>
abcdefzzzzzz
</tt>
.</p>
 
<p>Going in the opposite direction, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexnest1">
(?'word'
</SPAN>
<SPAN CLASS="regexnest2">
(?'letter'
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexspecial">
\g'word'
</SPAN>
<SPAN CLASS="regexnest2">
(?:
</SPAN>
<SPAN CLASS="regexspecial">
\k'letter+1'
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
z
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 matches 
<tt class=match>
abcdefzedcb
</tt>
. Again, after a whole bunch of matching and backtracking, the second 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 matches 
<tt class=match>
f
</tt>
, the regex engine is back at recursion level 4, and the group "letter" has 
<tt class=match>
a
</tt>
, 
<tt class=match>
b
</tt>
, 
<tt class=match>
c
</tt>
, 
<tt class=match>
d
</tt>
, and 
<tt class=match>
e
</tt>
 at recursion levels zero to four on its stack.</p>
 
<p>Now the engine evaluates the backreference 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\k'letter+1'
</SPAN>
</TT>
. The present level is 4 and the backreference specifies +1. The capturing group was backtracked at recursion level 5. This means we have a backreference to a non-participating group, which fails to match. The alternative 
<TT CLASS=code>
<SPAN CLASS="regexccrange">
z
</SPAN>
</TT>
 does match. The engine exits from the fourth recursion.</p>
 
<p>At recursion level 3, the backreference points to recursion level 4. Since the capturing group successfully matched at recursion level 4, it still has that match on its stack, even though the regex engine has already exited from that recursion. Thus 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\k'letter+1'
</SPAN>
</TT>
 matches 
<tt class=match>
e
</tt>
. Recursion level 3 is exited successfully.</p>
 
<p>The backreference continues to match 
<tt class=match>
d
</tt>
 and 
<tt class=match>
c
</tt>
 until the regex engine has exited the first recursion. Now, outside all recursion, the regex engine again reaches 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\k'letter+1'
</SPAN>
</TT>
. The present level is 0 and the backreference specifies +1. The capturing group still retains all its previous successful recursion levels. So the backreference can still match the 
<tt class=match>
b
</tt>
 that the group captured during the first recursion. Now 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 matches at the end of the string. 
<tt class=match>
abcdefzdcb
</tt>
 was matched successfully.</p>
 
<p>You can take this as far as you like in this direction too. The regular expression 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexnest1">
(?'word'
</SPAN>
<SPAN CLASS="regexnest2">
(?'letter'
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexspecial">
\g'word'
</SPAN>
<SPAN CLASS="regexnest2">
(?:
</SPAN>
<SPAN CLASS="regexspecial">
\k'letter+2'
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
z
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 matches 
<tt class=match>
abcdefzzedc
</tt>
. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexnest1">
(?'word'
</SPAN>
<SPAN CLASS="regexnest2">
(?'letter'
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexspecial">
\g'word'
</SPAN>
<SPAN CLASS="regexnest2">
(?:
</SPAN>
<SPAN CLASS="regexspecial">
\k'letter+99'
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
z
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 matches 
<tt class=match>
abcdefzzzzzz
</tt>
.</p>

</div>

</DIV>
 
<div class=topad>
<A HREF="//www.regexbuddy.com/create.html" TARGET="_top">
</A>
</div>
 
<h1>
Recursion and Subroutine Calls May or May Not Be Atomic
</h1>
 
<p>Earlier topics in this tutorial explain 
<A HREF="recurse.html" TARGET="_top">
regular expression recursion
</A>
 and 
<A HREF="subroutine.html" TARGET="_top">
regular expression subroutines
</A>
. In this topic the word "recursion" refers to recursion of the whole regex, recursion of capturing groups, and subroutine calls to capturing groups.</p>
 
<p><A HREF="perl.html" TARGET="_top">
Perl
</A>
 and 
<A HREF="ruby.html" TARGET="_top">
Ruby
</A>
 backtrack into recursion if the remainder of the regex after the recursion fails. They try all permutations of the recursion as needed to allow the remainder of the regex to match. 
<A HREF="pcre.html" TARGET="_top">
PCRE
</A>
 treats recursion as 
<A HREF="atomic.html" TARGET="_top">
atomic
</A>
. PCRE backtracks normally during the recursion, but once the recursion has matched, it does not try any further permutations of the recursion, even when the remainder of the regex fails to match. The result is that Perl and Ruby may find regex matches that PCRE cannot find, or that Perl and Ruby may find different regex matches.</p>
 
<p>Consider the regular expression 
<TT CLASS=code>
<SPAN CLASS="regexplain">
aa
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexspecial">
(?R)
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
 in Perl or the equivalent 
<TT CLASS=code>
<SPAN CLASS="regexplain">
aa
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexspecial">
\g'0'
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
 in Ruby 2.0. PCRE supports either syntax. Let's see how Perl, Ruby, and PCRE go through the matching process of this regex when 
<tt class=string>
aaa
</tt>
 is the subject string.</p>
 
<p>The first alternative 
<TT CLASS=code>
<SPAN CLASS="regexplain">
aa
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
 fails because the 
<A HREF="anchors.html" TARGET="_top">
anchor
</A>
 cannot be matched between the second and third 
<tt class=string>
a
</tt>
 in the string. Attempting the second alternative at the start of the string, 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
 matches 
<tt class=match>
a
</tt>
. Now the regex engine enters the first recursion.</p>
 
<p>Inside the recursion, the first alternative matches the second and third 
<tt class=string>
a
</tt>
 in the string. The regex engine exists a successful recursion. But now, the 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
 that follows 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
(?R)
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\g'0'
</SPAN>
</TT>
 in the regex fails to match because the regex engine has already reached the end of the string. Thus the regex engine must backtrack. Here is where PCRE behaves differently than Perl or Ruby.</p>
 
<p>Perl and Ruby remember that inside the recursion the regex matched the second alternative and that there are three possible alternatives. Perl and Ruby backtrack 
<i>
into
</i>
 the recursion. The second alternative inside the recursion is backtracked, reducing the match so far to the first 
<tt class=match>
a
</tt>
 in the string. Now the third alternative is attempted. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
 matches the second 
<tt class=match>
a
</tt>
 in the string. The regex engine again exits successfully from the same recursion. This time, the 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
 that follows 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
(?R)
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\g'0'
</SPAN>
</TT>
 in the regex matches the third 
<tt class=match>
a
</tt>
 in the string. 
<tt class=match>
aaa
</tt>
 is found as the overall match.</p>
 
<p>PCRE, on the other hand, remembers nothing about the recursion other than that it matched 
<tt class=match>
aa
</tt>
 at the end of the string. PCRE does backtrack 
<i>
over
</i>
 the recursion, reducing the match so far to the first 
<tt class=match>
a
</tt>
 in the string. But this leaves the second alternative in the regex without any further permutations to try. Thus the 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
 at the start of the second alternative is also backtracked, reducing the match so far to nothing. PCRE continues the match attempt at the start of the string with the third alternative and finds that 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
 matches 
<tt class=match>
a
</tt>
 at the start of the string. In PCRE, this is the overall match.</p>
 
<p>You can make recursion in Perl and Ruby atomic by adding an atomic group. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
aa
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest1">
(?&gt;
</SPAN>
<SPAN CLASS="regexspecial">
(?R)
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
 in Perl and 
<TT CLASS=code>
<SPAN CLASS="regexplain">
aa
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest1">
(?&gt;
</SPAN>
<SPAN CLASS="regexspecial">
\g'0'
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
 in Ruby is the same as the original regexes in PCRE.</p>
 
<p><a href="jgsoft.html#v2">
JGsoft V2
</a>
 lets you choose whether recursion should be atomic or not. Atomic recursion gives better performance, but may exclude certain matches or find different matches as illustrated above. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
aa
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexspecial">
(?P&gt;0)
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
 is atomic in JGsoft V2. You can remember this because this syntax for recursion uses an angle bracket just like an atomic group. You can use a number or a name instead of zero for an atomic subroutine call to a numbered or named capturing group. Any other syntax for recursion is not atomic in JGsoft V2.</p>
 
<p><A HREF="boost.html" TARGET="_top">
Boost
</A>
 is of two minds. Recursion of the whole regex is atomic in Boost, like in PCRE. But Boost will backtrack into subroutine calls, like Perl. So you can do non-atomic recursion in Boost by wrapping the whole regex into a capturing group and then calling that.</p>
<H2>Palindromes of Any Length in Perl and Ruby</h2>
 
<p>The topic about 
<A HREF="recursecapture.html" TARGET="_top">
recursion and capturing groups
</A>
 explains a regular expression to match 
<a href="recursecapture.html#palindrome">
palindromes
</a>
 that are an odd number of characters long. The solution seems trivial. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexnest1">
(?'word'
</SPAN>
<SPAN CLASS="regexnest2">
(?'letter'
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexspecial">
(?&amp;word)
</SPAN>
<SPAN CLASS="regexspecial">
\k'letter'
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 does the trick in Perl. The quantifier 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
?
</SPAN>
</TT>
 makes the 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 that matches the letter in the middle of the palindrome optional. In Ruby we can use 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexnest1">
(?'word'
</SPAN>
<SPAN CLASS="regexnest2">
(?'letter'
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexspecial">
\g'word'
</SPAN>
<SPAN CLASS="regexspecial">
\k'letter+0'
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 which adds the same quantifier to the solution that specifies the 
<A HREF="recursebackref.html" TARGET="_top">
recursion level for the backreference
</A>
. In PCRE, the Perl solution still matches odd-length palindromes, but not even-length palindromes.</p>
 
<p>Let's see how these regexes match or fail to match 
<tt class=string>
deed
</tt>
. PCRE starts off the same as Perl and Ruby, just as in the original regex. The group "letter" matches 
<tt class=match>
d
</tt>
. During three consecutive recursions, the group captures 
<tt class=match>
e
</tt>
, 
<tt class=match>
e
</tt>
, and 
<tt class=match>
d
</tt>
. The fourth recursion fails, because there are no characters left the match. Back in the third recursion, the first alternative is backtracked and the second alternative matches 
<tt class=match>
d
</tt>
 at the end of the string. The engine exists the third recursion with a successful match. Back in the second recursion, the backreference fails because there are no characters left in the string.</p>
 
<p>Here the behavior diverges. Perl and Ruby backtrack 
<i>
into
</i>
 the third recursion and backtrack the quantifier 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
?
</SPAN>
</TT>
 that makes the second alternative optional. In the third recursion, the second alternative gives up the 
<tt class=string>
d
</tt>
 that it matched at the end of the string. The engine exists the third recursion again, this time with a successful zero-length match. Back in the second recursion, the backreference still fails because the group stored 
<tt class=match>
e
</tt>
 for the second recursion but the next character in the string is 
<tt class=string>
d
</tt>
. This the first alternative is backtracked and the second alternative matches the second 
<tt class=match>
e
</tt>
 in the string. The second recursion is exited with success.</p>
 
<p>In the first recursion, the backreference again fails. The group stored 
<tt class=match>
e
</tt>
 for the first recursion but the next character in the string is 
<tt class=string>
d
</tt>
. Again, Perl and Ruby backtrack into the second recursion to try the permutation where the second alternative finds a zero-length match. Back in the first recursion again, the backreference now matches the second 
<tt class=match>
e
</tt>
 in the string. The engine leaves the first recursion with success. Back in the overall match attempt, the backreference matches the final 
<tt class=match>
d
</tt>
 in the string. The word boundary succeeds and an overall match is found.</p>
 
<p>PCRE, however, does not backtrack into the third recursion. It does backtrack 
<i>
over
</i>
 the third recursion when it backtracks the first alternative in the second recursion. Now, the second alternative in the second alternative matches the second 
<tt class=match>
e
</tt>
 in the string. The second recursion is exited with success.</p>
 
<p>In the first recursion, the backreference again fails. The group stored 
<tt class=match>
e
</tt>
 for the first recursion but the next character in the string is 
<tt class=string>
d
</tt>
. Again, PCRE does not backtrack into the second recursion, but immediately fails the first alternative in the first recursion. The second alternative in the first recursion now matches the first 
<tt class=match>
e
</tt>
 in the string. PCRE exits the first recursion with success. Back in the overall match attempt, the backreference fails, because the group captured 
<tt class=match>
d
</tt>
 prior to the recursion, and the next character is the second 
<tt class=string>
e
</tt>
 in the string. Backtracking again, the second alternative in the overall regex match now matches the first 
<tt class=match>
d
</tt>
 in the string. Then the word boundary fails. PCRE did not find any matches.</p>
<H2>Palindromes of Any Length in PCRE</h2>
 
<p>To match palindromes of any length in PCRE, we need a regex that matches words of an even number of characters and of and number of characters separately. Free-spacing mode makes this regex easier to read:</p>
 
<p><TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexnest1">
(?'word'
</SPAN>
<SPAN CLASS="regexplain">
<BR>
   
</SPAN>
<SPAN CLASS="regexnest2">
(?'oddword'
</SPAN>
<SPAN CLASS="regexplain">
 
</SPAN>
<SPAN CLASS="regexnest3">
(?'oddletter'
</SPAN>
<SPAN CLASS="regexplain">
 
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest3">
)
</SPAN>
<SPAN CLASS="regexspecial">
(?P&gt;oddword)
</SPAN>
<SPAN CLASS="regexplain">
  
</SPAN>
<SPAN CLASS="regexspecial">
\k'oddletter'
</SPAN>
<SPAN CLASS="regexplain">
 
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexplain">
<BR>
 
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
 
</SPAN>
<SPAN CLASS="regexnest2">
(?'evenword'
</SPAN>
<SPAN CLASS="regexnest3">
(?'evenletter'
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest3">
)
</SPAN>
<SPAN CLASS="regexspecial">
(?P&gt;evenword)
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexspecial">
\k'evenletter'
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexplain">
<BR>
 
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT></p>
 
<p>Basically, this is two copies of the original regex combined with alternation. The first alternatives has the groups "word" and "letter" renamed to "oddword" and "oddletter". The second alternative has the groups "word" and "letter" renamed to "evenword" and "evenletter". The call 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
(?P&gt;evenword)
</SPAN>
</TT>
 is now made optional with a question mark instead of the alternative 
<TT CLASS=code>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
. A new group "word" combines the two groups "oddword" and "evenword" so that the word boundaries still apply to the whole regex.</p>
 
<p>The first alternative "oddword" in this regex matches a palindrome of odd length like 
<tt class=match>
radar
</tt>
 in exactly the same way as the regex discussed in the topic about 
<A HREF="recursecapture.html" TARGET="_top">
recursion and capturing groups
</A>
 does. The second alternative in the new regex is never attempted.</p>
 
<p>When the string is a palindrome of even length like 
<tt class=string>
deed
</tt>
, the new regex first tries all permutations of the first alternative. The second alternative "evenword" is attempted only after the first alternative fails to find a match.</p>
 
<p>The second alternative off in the same as the original regex. The group "evenletter" matches 
<tt class=match>
d
</tt>
. During three consecutive recursions, the group captures 
<tt class=match>
e
</tt>
, 
<tt class=match>
e
</tt>
, and 
<tt class=match>
d
</tt>
. The fourth recursion fails, because there are no characters left the match. Back in the third recursion, the regex engine notes that recursive call 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
(?P&gt;evenword)
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
</TT>
 is optional. It proceeds to the backreference 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\k'evenletter'
</SPAN>
</TT>
. The backreference fails because there are no characters left in the string. Since the recursion has no further alternatives to try, is is backtracked. The group "evenletter" must give up its most recent match and PCRE exits from the failed third recursion.</p>
 
<p>In the second recursion, the backreference fails because the capturing group matched 
<tt class=match>
e
</tt>
 during that recursion but the next character in the string is 
<tt class=string>
d
</tt>
. The group gives up another match and PCRE exits from the failed second recursion.</p>
 
<p>Back in the first recursion, the backreference succeeds. The group matched the first 
<tt class=match>
e
</tt>
 in the string during that recursion and the backreference matches the second. PCRE exits from the successful first recursion.</p>
 
<p>Back in the overall match attempt, the backreference succeeds again. The group matched the 
<tt class=match>
d
</tt>
 at the start of the string during the overall match attempt, and the backreference matches the final 
<tt class=match>
d
</tt>
. Exiting the groups "evenword" and "word", the word boundary matches at the end of the string. 
<tt class=match>
deed
</tt>
 is the overall match.</p>

</DIV>
 
<div class=topad>
<A HREF="//www.regexbuddy.com/create.html" TARGET="_top">
</A>
</div>
 
<H1>
POSIX Bracket Expressions
</h1>
 
<p>POSIX bracket expressions are a special kind of 
<A HREF="charclass.html" TARGET="_top">
character classes
</A>
. POSIX bracket expressions match one character out of a set of characters, just like regular character classes. They use the same syntax with square brackets. A hyphen creates a range, and a caret at the start negates the bracket expression.</p>
 
<p>One key syntactic difference is that the backslash is NOT a metacharacter in a POSIX bracket expression. So in POSIX, the regular expression 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
\d
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 matches a 
<tt class=match>
\
</tt>
 or a 
<tt class=match>
d
</tt>
. To match a 
<tt class=match>
]
</tt>
, put it as the first character after the opening 
<tt>
[
</tt>
 or the negating 
<tt>
^
</tt>
. To match a 
<tt class=match>
-
</tt>
, put it right before the closing 
<tt>
]
</tt>
. To match a 
<tt class=match>
^
</tt>
, put it before the final literal 
<tt>
-
</tt>
 or the closing 
<tt>
]
</tt>
. Put together, 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
]\d^
</SPAN>
<SPAN CLASS="regexccliteral">
-
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 matches 
<tt class=match>
]
</tt>
, 
<tt class=match>
\
</tt>
, 
<tt class=match>
d
</tt>
, 
<tt class=match>
^
</tt>
 or 
<tt class=match>
-
</tt>
.</p>
 
<p>The main purpose of bracket expressions is that they adapt to the user's or application's locale. A locale is a collection of rules and settings that describe language and cultural conventions, like sort order, date format, etc. The POSIX standard defines these locales.</p>
 
<p>Generally, only 
<A HREF="posix.html" TARGET="_top">
POSIX-compliant regular expression engines
</A>
 have proper and full support for POSIX bracket expressions. Some non-POSIX regex engines support POSIX character classes, but usually don't support collating sequences and character equivalents. Regular expression engines that support 
<A HREF="unicode.html" TARGET="_top">
Unicode
</A>
 use Unicode properties and scripts to provide functionality similar to POSIX bracket expressions. In Unicode regex engines, 
<A HREF="shorthand.html" TARGET="_top">
shorthand character classes
</A>
 like 
<TT CLASS=code>
<SPAN CLASS="regexescaped">
\w
</SPAN>
</TT>
 normally match all relevant Unicode characters, alleviating the need to use locales.</p>
 
<a name="class">
</a>

<H2>Character Classes</h2>
 
<p>Don't confuse the POSIX term "character class" with what is normally called a 
<A HREF="charclass.html" TARGET="_top">
regular expression character class
</A>
. 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
x
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 is an example of what this tutorial calls a "character class" and what POSIX calls a "bracket expression". 
<tt>
[:digit:]
</tt>
 is a POSIX character class, used inside a bracket expression like 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
x
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccspecial">
[:digit:]
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
. The POSIX character class names must be written all lowercase.</p>
 
<p>When used on ASCII strings, these two regular expressions find exactly the same matches: a single character that is either 
<tt class=match>
x
</tt>
, 
<tt class=match>
y
</tt>
, 
<tt class=match>
z
</tt>
, or a digit. When used on strings with non-ASCII characters, the 
<tt>
[:digit:]
</tt>
 class may include digits in other scripts, depending on the locale.</p>
 
<p>The POSIX standard defines 12 character classes. The table below lists all 12, plus the 
<tt>
[:ascii:]
</tt>
 and 
<tt>
[:word:]
</tt>
 classes that some regex flavors also support. The table also shows equivalent character classes that you can use in ASCII and 
<A HREF="unicode.html" TARGET="_top">
Unicode
</A>
 regular expressions if the POSIX classes are unavailable. The ASCII equivalents correspond exactly what is defined in the POSIX standard. The Unicode equivalents correspond to what most Unicode regex engines match. The POSIX standard does not define a Unicode locale. Some classes also have Perl-style 
<A HREF="shorthand.html" TARGET="_top">
shorthand
</A>
 equivalents.</p>
 
<p><A HREF="java.html" TARGET="_top">
Java
</A>
 does not support POSIX bracket expressions, but does support POSIX character classes using the 
<tt>
\p
</tt>
 operator. Though the 
<tt>
\p
</tt>
 syntax is borrowed from the syntax for 
<A HREF="unicode.html" TARGET="_top">
Unicode properties
</A>
, the POSIX classes in Java only match ASCII characters as indicated below. The class names are case sensitive. Unlike the POSIX syntax which can only be used inside a bracket expression, Java's 
<tt>
\p
</tt>
 can be used inside and outside bracket expressions.</p>
 
<P>The 
<A HREF="jgsoft.html" TARGET="_top">
JGsoft flavor
</A>
 supports both the POSIX and Java syntax. Originally it matched Unicode characters using either syntax. As of JGsoft V2, it matches only ASCII characters when using the POSIX syntax, and Unicode characters when using the Java syntax.</P>
 
<table class=reference>
 
<tr>
<th>
POSIX
</th>
<th>
Description
</th>
<th>
ASCII
</th>
<th>
Unicode
</th>
<th>
Shorthand
</th>
<th>
Java
</th>
</tr>
 
<tr>
<td>
<tt>
[:alnum:]
</tt>
</td>
 
<td>
Alphanumeric characters
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
\p{L}
</SPAN>
<SPAN CLASS="regexccspecial">
\p{Nl}
</SPAN>
<SPAN CLASS="regexplain">
<BR>
  
</SPAN>
<SPAN CLASS="regexccspecial">
\p{Nd}
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
</td>
 
<td>
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Alnum}
</SPAN>
</TT>
</td>
</tr>
 
<tr>
<td>
<tt>
[:alpha:]
</tt>
</td>
 
<td>
Alphabetic characters
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{L}
</SPAN>
<SPAN CLASS="regexspecial">
\p{Nl}
</SPAN>
</TT>
</td>
 
<td>
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Alpha}
</SPAN>
</TT>
</td>
</tr>
 
<tr>
<td>
<tt>
[:ascii:]
</tt>
</td>
 
<td>
ASCII characters
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
\x00
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
\x7F
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{InBasicLatin}
</SPAN>
</TT>
</td>
 
<td>
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{ASCII}
</SPAN>
</TT>
</td>
</tr>
 
<tr>
<td>
<tt>
[:blank:]
</tt>
</td>
 
<td>
Space and tab
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
 
</SPAN>
<SPAN CLASS="regexccspecial">
\t
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
\p{Zs}
</SPAN>
<SPAN CLASS="regexccspecial">
\t
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\h
</SPAN>
</TT>
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Blank}
</SPAN>
</TT>
</td>
</tr>
 
<tr>
<td>
<tt>
[:cntrl:]
</tt>
</td>
 
<td>
Control characters
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
\x00
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
\x1F
</SPAN>
<SPAN CLASS="regexccspecial">
\x7F
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Cc}
</SPAN>
</TT>
</td>
 
<td>
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Cntrl}
</SPAN>
</TT>
</td>
</tr>
 
<tr>
<td>
<tt>
[:digit:]
</tt>
</td>
 
<td>
Digits
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Nd}
</SPAN>
</TT>
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\d
</SPAN>
</TT>
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Digit}
</SPAN>
</TT>
</td>
</tr>
 
<tr>
<td>
<tt>
[:graph:]
</tt>
</td>
 
<td>
Visible characters (anything except spaces and control characters)
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
\x21
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
\x7E
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccspecial">
\p{Z}
</SPAN>
<SPAN CLASS="regexccspecial">
\p{C}
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
</td>
 
<td>
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Graph}
</SPAN>
</TT>
</td>
</tr>
 
<tr>
<td>
<tt>
[:lower:]
</tt>
</td>
 
<td>
Lowercase letters
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Ll}
</SPAN>
</TT>
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\l
</SPAN>
</TT>
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Lower}
</SPAN>
</TT>
</td>
</tr>
 
<tr>
<td>
<tt>
[:print:]
</tt>
</td>
 
<td>
Visible characters and spaces (anything except control characters)
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
\x20
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
\x7E
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\P{C}
</SPAN>
</TT>
</td>
 
<td>
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Print}
</SPAN>
</TT>
</td>
</tr>
 
<tr>
<td>
<tt>
[:punct:]
</tt>
</td>
 
<td>
Punctuation and symbols.
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
!"
</SPAN>
<SPAN CLASS="regexccspecial">
\#
</SPAN>
<SPAN CLASS="regexccliteral">
$%&amp;'()*+,
</SPAN>
<SPAN CLASS="regexplain">
<BR>
 
</SPAN>
<SPAN CLASS="regexccspecial">
\-
</SPAN>
<SPAN CLASS="regexccliteral">
./:;&lt;=&gt;?@
</SPAN>
<SPAN CLASS="regexccspecial">
\[
</SPAN>
<SPAN CLASS="regexplain">
<BR>
 
</SPAN>
<SPAN CLASS="regexccspecial">
\\
</SPAN>
<SPAN CLASS="regexccspecial">
\]
</SPAN>
<SPAN CLASS="regexccliteral">
^_`{|}~
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{P}
</SPAN>
</TT>
</td>
 
<td>
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Punct}
</SPAN>
</TT>
</td>
</tr>
 
<tr>
<td>
<tt>
[:space:]
</tt>
</td>
 
<td>
All whitespace characters, including line breaks
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
 
</SPAN>
<SPAN CLASS="regexccspecial">
\t
</SPAN>
<SPAN CLASS="regexccspecial">
\r
</SPAN>
<SPAN CLASS="regexccspecial">
\n
</SPAN>
<SPAN CLASS="regexccspecial">
\v
</SPAN>
<SPAN CLASS="regexccspecial">
\f
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
\p{Z}
</SPAN>
<SPAN CLASS="regexccspecial">
\t
</SPAN>
<SPAN CLASS="regexccspecial">
\r
</SPAN>
<SPAN CLASS="regexccspecial">
\n
</SPAN>
<SPAN CLASS="regexccspecial">
\v
</SPAN>
<SPAN CLASS="regexccspecial">
\f
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\s
</SPAN>
</TT>
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Space}
</SPAN>
</TT>
</td>
</tr>
 
<tr>
<td>
<tt>
[:upper:]
</tt>
</td>
 
<td>
Uppercase letters
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Lu}
</SPAN>
</TT>
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\u
</SPAN>
</TT>
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{Upper}
</SPAN>
</TT>
</td>
</tr>
 
<tr>
<td>
<tt>
[:word:]
</tt>
</td>
 
<td>
Word characters (letters, numbers and underscores)
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccliteral">
_
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
\p{L}
</SPAN>
<SPAN CLASS="regexccspecial">
\p{Nl}
</SPAN>
<SPAN CLASS="regexplain">
<BR>
  
</SPAN>
<SPAN CLASS="regexccspecial">
\p{Nd}
</SPAN>
<SPAN CLASS="regexccspecial">
\p{Pc}
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\w
</SPAN>
</TT>
</td>
 
<td>
</td>
</tr>
 
<tr>
<td>
<tt>
[:xdigit:]
</tt>
</td>
 
<td>
Hexadecimal digits
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
F
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
f
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
F
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
f
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
</td>
 
<td>
</td>
 
<td>
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{XDigit}
</SPAN>
</TT>
</td>
</tr>
 
</table>
 
<a name="coll">
</a>

<H2>Collating Sequences</h2>
 
<p>A POSIX locale can have collating sequences to describe how certain characters or groups of characters should be ordered. In Czech, for example, 
<tt class=string>
ch
</tt>
 as in 
<tt class=string>
chemie
</tt>
 ("chemistry" in Czech) is a 
<a href="https://en.wikipedia.org/wiki/Ch_(digraph)">
digraph
</a>
. This means it should be treated as if it were one character. It is ordered between 
<tt class=string>
h
</tt>
 and 
<tt class=string>
i
</tt>
 in the Czech alphabet. You can use the collating sequence element 
<tt>
[.ch.]
</tt>
 inside a bracket expression to match 
<tt class=match>
ch
</tt>
 when the Czech locale (cs-CZ) is active. The regex 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
[.ch.]
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexplain">
emie
</SPAN>
</TT>
 matches 
<tt class=match>
chemie
</tt>
. Notice the double square brackets. One pair for the bracket expression, and one pair for the collating sequence.</p>
 
<p>Other than POSIX-compliant engines part of a POSIX-compliant system, none of the regex flavors discussed in this tutorial support collating sequences.</p>
 
<p>Note that a fully POSIX-compliant regex engine treats 
<tt class=string>
ch
</tt>
 as a single character when the locale is set to Czech. This means that 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
x
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexplain">
emie
</SPAN>
</TT>
 also matches 
<tt class=match>
chemie
</tt>
. 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
x
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 matches a single character that is not an 
<tt class=string>
x
</tt>
, which includes 
<tt class=match>
ch
</tt>
 in the Czech POSIX locale.</p>
 
<p>In any other regular expression engine, or in a POSIX engine using a locale that does not treat 
<tt class=string>
ch
</tt>
 as a digraph, 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
x
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexplain">
emie
</SPAN>
</TT>
 matches the misspelled word 
<tt class=match>
cemie
</tt>
 but not 
<tt class=string>
chemie
</tt>
, as 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
x
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 cannot match the two characters 
<tt class=string>
ch
</tt>
.</p>
 
<p>Finally, note that not all regex engines claiming to implement POSIX regular expressions actually have full support for collating sequences. Sometimes, these engines use the regular expression syntax defined by POSIX, but don't have full locale support. You may want to try the above matches to see if the engine you're using does. 
<A HREF="tcl.html" TARGET="_top">
Tcl's regexp command
</A>
, for example, supports the syntax for collating sequences. But Tcl only supports the Unicode locale, which does not define any collating sequences. The result is that in Tcl, a collating sequence specifying a single character matches just that character. All other collating sequences result in an error.</p>
 
<a name="eq">
</a>
<h2>Character Equivalents</h2>
 
<p>A POSIX locale can define character equivalents that indicate that certain characters should be considered as identical for sorting. In French, for example, accents are ignored when ordering words. 
<tt class=string>
élève
</tt>
 comes before 
<tt class=string>
être
</tt>
 which comes before 
<tt class=string>
événement
</tt>
. 
<tt class=string>
é
</tt>
 and 
<tt class=string>
ê
</tt>
 are all the same as 
<tt class=string>
e
</tt>
, but 
<tt class=string>
l
</tt>
 comes before 
<tt class=string>
t
</tt>
 which comes before 
<tt class=string>
v
</tt>
. With the locale set to French, a POSIX-compliant regular expression engine matches 
<tt class=match>
e
</tt>
, 
<tt class=match>
é
</tt>
, 
<tt class=match>
è
</tt>
 and 
<tt class=match>
ê
</tt>
 when you use the collating sequence 
<tt>
[=e=]
</tt>
 in the bracket expression 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
[=e=]
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
.</p>
 
<p>If a character does not have any equivalents, the character equivalence token simply reverts to the character itself. 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
[=x=]
</SPAN>
<SPAN CLASS="regexccspecial">
[=z=]
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
, for example, is the same as 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
xz
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 in the French locale.</p>
 
<p>Like collating sequences, POSIX character equivalents are not available in any regex engine discussed in this tutorial, other than those following the POSIX standard. And those that do may not have the necessary POSIX locale support. Here too 
<A HREF="tcl.html" TARGET="_top">
Tcl's regexp command
</A>
 supports the syntax for character equivalents. But the Unicode locale, the only one Tcl supports, does not define any character equivalents. This effectively means that 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
[=e=]
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
e
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 are exactly the same in Tcl, and only match 
<tt class=match>
e
</tt>
, for any character you may try instead of "e".</p>

</DIV>
 
<div class=topad>
<A HREF="//www.regexbuddy.com/create.html" TARGET="_top">
</A>
</div>
 
<H1>
Zero-Length Regex Matches
</H1>
 
<P>We saw that 
<A HREF="anchors.html" TARGET="_top">
anchors
</A>
, 
<A HREF="wordboundaries.html" TARGET="_top">
word boundaries
</A>
, and 
<A HREF="lookaround.html" TARGET="_top">
lookaround
</A>
 match at a position, rather than matching a character. This means that when a regex only consists of one or more anchors, word boundaries, or lookaorunds, then it can result in a zero-length match. Depending on the situation, this can be very useful or undesirable.</p>
 
<P>In email, for example, it is common to prepend a "greater than" symbol and a space to each line of the quoted message. In 
<A HREF="dotnet.html" TARGET="_top">
VB.NET
</A>
, we can easily do this with 
<TT>
Dim Quoted As String = Regex.Replace(Original, "^", ">
&nbsp;", RegexOptions.Multiline)
</TT>
. We are using multi-line mode, so the regex 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
</TT>
 matches at the start of the quoted message, and after each newline. The Regex.Replace method removes the regex match from the string, and inserts the replacement string (greater than symbol and a space). Since the match does not include any characters, nothing is deleted. However, the match does include a starting position. The replacement string is inserted there, just like we want it.</P>
 
<P>Using 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
<SPAN CLASS="regexspecial">
\d
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
 to test if the user entered a number would give undesirable results. It causes the script to accept an empty string as a valid input. Let's see why.</P>
 
<P>There is only one "character" position in an empty string: the void after the string. The first token in the regex is 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
</TT>
. It matches the position before the void after the string, because it is preceded by the void before the string. The next token is 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\d
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
. One of the 
<A HREF="repeat.html" TARGET="_top">
star
</A>
's effects is that it makes the 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\d
</SPAN>
</TT>
, in this case, optional. The engine tries to match 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\d
</SPAN>
</TT>
 with the void after the string. That fails. But the star turns the failure of the 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\d
</SPAN>
</TT>
 into a zero-length success. The engine proceeds with the next regex token, without advancing the position in the string. So the engine arrives at 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
, and the void after the string. These match. At this point, the entire regex has matched the empty string, and the engine reports success.</P>
 
<P>The solution is to use the regex 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
<SPAN CLASS="regexspecial">
\d
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
 with the proper quantifier to require at least one digit to be entered. If you always make sure that your regexes cannot find zero-length matches, other than special cases such as matching the start or end of each line, then you can save yourself the headache you'll get from reading the remainder of this topic.</P>
<H2>Skipping Zero-Length Matches</h2>
 
<P>Not all flavors support zero-length matches. The TRegEx class in 
<A HREF="delphi.html" TARGET="_top">
Delphi
</A>
 XE5 and prior always skips zero-length matches. The TPerlRegEx class does too by default in XE5 and prior, but allows you to change this via the State property. In Delphi XE6 and later, TRegEx never skips zero-length matches while TPerlRegEx does not skip them by default but still allows you to skip them via the State property. 
<A HREF="pcre.html" TARGET="_top">
PCRE
</A>
 finds zero-length matches by default, but can skip them if you set PCRE_NOTEMPTY.</P>
 
<a name="advance">
</a>

<H2>Advancing After a Zero-Length Regex Match</h2>
 
<p>If a regex can find zero-length matches at any position in the string, then it will. The regex 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\d
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
 matches zero or more digits. If the subject string does not contain any digits, then this regex finds a zero-length match at every position in the string. It finds 4 matches in the string 
<tt class=match>
abc
</tt>
, one before each of the three letters, and one at the end of the string.</p>
 
<p>Things get tricky when a regex can find zero-length matches at any position as well as certain non-zero-length matches. Say we have the regex 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\d
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexplain">
x
</SPAN>
</TT>
, the subject string 
<tt class=string>
x1
</tt>
, and a regex engine allows zero-length matches. Which and how many matches do we get when iterating over all matches? The answer depends on how the regex engine advances after zero-length matches. The answer is tricky either way.</p>
 
<p>The first match attempt begins at the start of the string. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\d
</SPAN>
</TT>
 fails to match 
<tt class=string>
x
</tt>
. But the 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
 makes 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\d
</SPAN>
</TT>
 optional. The first alternative finds a zero-length match at the start of the string. Until here, all regex engines that allow zero-length matches do the same.</p>
 
<p>Now the regex engine is in a tricky situation. We're asking it to go through the entire string to find all non-overlapping regex matches. The first match ended at the start of the string, where the first match attempt began. The regex engine needs a way to avoid getting stuck in an infinite loop that forever finds the same zero-length match at the start of the string.</p>
 
<p>The simplest solution, which is used by most regex engines, is to start the next match attempt one character after the end of the previous match, if the previous match was zero-length. In this case, the second match attempt begins at the position between the 
<tt class=string>
x
</tt>
 and the 
<tt class=string>
1
</tt>
 in the string. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\d
</SPAN>
</TT>
 matches 
<tt class=match>
1
</tt>
. The end of the string is reached. The quantifier 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
 is satisfied with a single repetition. 
<tt class=match>
1
</tt>
 is returned as the overall match.</p>
 
<p>The other solution, which is used by 
<A HREF="perl.html" TARGET="_top">
Perl
</A>
, 
<A HREF="pcre.html" TARGET="_top">
PCRE
</A>
 is to always start the next match attempt at the end of the previous match, regardless of whether it was zero-length or not. If it was zero-length, the engine makes note of that, as it must not allow a zero-length match at the same position. Thus Perl and PCRE begin the second match attempt also at the start of the string. The first alternative again finds a zero-length match. But this is not a valid match, so the engine backtracks through the regular expression. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\d
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
 is forced to give up its zero-length match. Now the second alternative in the regex is attempted. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
x
</SPAN>
</TT>
 matches 
<tt class=match>
x
</tt>
 and the second match is found. The third match attempt begins at the position after the 
<tt class=match>
x
</tt>
 in the string. The first alternative matches 
<tt class=match>
1
</tt>
 and the third match is found.</p>
 
<p>But the regex engine isn't done yet. After 
<tt class=match>
x
</tt>
 is matched, it makes one more match attempt starting at the end of the string. Here too 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\d
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
</TT>
 finds a zero-length match. So depending on how the engine advances after zero-length matches, it finds either three or four matches.</p>
 
<p>One exception is the 
<A HREF="jgsoft.html" TARGET="_top">
JGsoft engine
</A>
. The JGsoft engine advances one character after a zero-length match, like most engines do. But it has an extra rule to skip zero-length matches at the position where the previous match ended, so you can never have a zero-length match immediately adjacent to a non-zero-length match. In our example the JGsoft engine only finds two matches: the zero-length match at the start of the string, and 
<tt class=match>
1
</tt>
.</p>
 
<p><A HREF="python.html" TARGET="_top">
Python
</A>
 advances after zero-length matches. The 
<tt>
gsub()
</tt>
 function to search-and-replace skips zero-length matches at the position where the previous non-zero-length match ended, but the 
<tt>
finditer()
</tt>
 function returns those matches. So a search-and-replace in Python gives the same results as the Just Great Software applications, but listing all matches adds the zero-length match at the end of the string.</p>
 
<p>The regexp functions in 
<A HREF="rlanguage.html" TARGET="_top">
R
</A>
 and 
<A HREF="php.html" TARGET="_top">
PHP
</A>
 are based on PCRE, so they avoid getting stuck on a zero-length match by backtracking like PCRE does. But the 
<tt>
gsub()
</tt>
 function to search-and-replace in R also skips zero-length matches at the position where the previous non-zero-length match ended, like Python does. The other regexp functions in R and all the functions in PHP do allow zero-length matches immediately adjacent to non-zero-length matches, just like PCRE itself.</p>
<H2>Caution for Programmers</H2>
 
<P>A regular expression such as 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
 all by itself can find a zero-length match at the end of the string. If you would query the engine for the character position, it would return the length of the string if string indexes are zero-based, or the length+1 if string indexes are one-based in your programming language. If you would query the engine for the length of the match, it would return zero.</P>
 
<P>What you have to watch out for is that String[Regex.MatchPosition] may cause an access violation or segmentation fault, because MatchPosition can point to the void after the string. This can also happen with 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
</TT>
 and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
 in 
<a href="anchors.html#multi">
multi-line mode
</a>
 if the last character in the string is a newline.</P>

</DIV>
 
<H1>
Continuing at The End of The Previous Match
</h1>
<P>The anchor 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\G
</SPAN>
</TT>
 matches at the position where the previous match ended.  During the first match attempt, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\G
</SPAN>
</TT>
 matches at the 
<A HREF="anchors.html#az">
start of the string
</A>
 in the way 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\A
</SPAN>
</TT>
 does.</P>
<P>Applying 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\G
</SPAN>
<SPAN CLASS="regexspecial">
\w
</SPAN>
</TT>
 to the string 
<TT CLASS=string>
test string
</TT>
 matches 
<TT CLASS=match>
t
</TT>
.  Applying it again matches 
<TT CLASS=match>
e
</TT>
.  The 3rd attempt yields 
<TT CLASS=match>
s
</TT>
 and the 4th attempt matches the second 
<TT CLASS=match>
t
</TT>
 in the string.  The fifth attempt fails.  During the fifth attempt, the only place in the string where 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\G
</SPAN>
</TT>
 matches is after the second 
<TT>
t
</TT>
.  But that position is not followed by a word character, so the match fails.</P>


<H2>End of The Previous Match vs. Start of The Match Attempt</H2>
<P>With some regex flavors or tools, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\G
</SPAN>
</TT>
 matches at the start of the match attempt, rather than at the end of the previous match.  This is the case with 
<A HREF="ruby.html" TARGET="_top">
Ruby
</A>
 and the 
<A HREF="jgsoft.html" TARGET="_top">
Just Great Software applications
</A>
.  In 
<A HREF="editpadpro.html" TARGET="_top">
EditPad Pro
</A>
 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\G
</SPAN>
</TT>
 matches at the position of the text cursor.  When a match is found, EditPad Pro will select the match, and move the text cursor to the end of the match.  The result is that 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\G
</SPAN>
</TT>
 matches at the end of the previous match result only when you do not move the text cursor between two searches.  All in all, this makes a lot of sense in the context of a text editor.</P>
<p>The distinction between the end of the previous match and the start of the match attempt is also important if your regular expression can find 
<A HREF="zerolength.html" TARGET="_top">
zero-length matches
</A>
.  Most regex engines 
<a href="zerolength.html#advance">
advance through the string after a zero-length match
</a>
.  In that case, the start of the match attempt is one character further in the string than the end of the previous match attempt.  
<A HREF="dotnet.html" TARGET="_top">
.NET
</A>
, 
<A HREF="java.html" TARGET="_top">
Java
</A>
, and 
<A HREF="boost.html" TARGET="_top">
Boost
</A>
 advance this way and also match 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\G
</SPAN>
</TT>
 at the end of the previous match attempt.  Thus 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\G
</SPAN>
</TT>
 fails to match when .NET, Java, and Boost have advanced after a zero-length match.</p>

<H2>\G Magic with Perl</H2>
<P>In 
<A HREF="perl.html" TARGET="_top">
Perl
</A>
, the position where the last match ended is a "magical" value that is remembered separately for each string variable.  The position is not associated with any regular expression.  This means that you can use 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\G
</SPAN>
</TT>
 to make a regex continue in a subject string where another regex left off.</P>
<P>If a match attempt fails, the stored position for 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\G
</SPAN>
</TT>
 is reset to the start of the string.  To avoid this, specify the continuation modifier 
<TT>
/c
</TT>
.</P>
<P>All this is very useful to make several regular expressions work together.  E.g. you could parse an HTML file in the following fashion:</P>
<PRE>
<SPAN CLASS=longcode>
<SPAN CLASS=reservedword>
while
</SPAN>
 ($string =~ m/&lt;/g) {
  
<SPAN CLASS=reservedword>
if
</SPAN>
 ($string =~ m/\GB&gt;/c) {
    
<SPAN CLASS=comment>
# Bold
</SPAN>
  } 
<SPAN CLASS=reservedword>
elsif
</SPAN>
 ($string =~ m/\GI&gt;/c) {
    
<SPAN CLASS=comment>
# Italics
</SPAN>
  } 
<SPAN CLASS=reservedword>
else
</SPAN>
 {
    
<SPAN CLASS=comment>
# ...etc...
</SPAN>
  }
}
</SPAN>
</PRE>
<P>The regex in the while loop searches for the tag's opening bracket, and the regexes inside the loop check which tag we found.  This way you can parse the tags in the file in the order they appear in the file, without having to write a single big regex that matches all tags you are interested in.</P>

<H2>\G in Other Programming Languages</H2>
<P>This flexibility is not available with most other programming languages.  E.g. in 
<A HREF="java.html" TARGET="_top">
Java
</A>
, the position for 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\G
</SPAN>
</TT>
 is remembered by the Matcher object.  The Matcher is strictly associated with a single regular expression and a single subject string.  What you can do though is to add a line of code to make the match attempt of the second Matcher start where the match of the first Matcher ended.  Then 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\G
</SPAN>
</TT>
 will match at this position.</P>
<a name="attemptstart">
</a>
<h2>Start of Match Attempt</h2>
<p>Normally, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\A
</SPAN>
</TT>
 is a 
<a href="anchors.html#az">
start-of-string anchor
</a>
.  But in Tcl, the anchor 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\A
</SPAN>
</TT>
 matches at the start of the match attempt rather than at the start of the string.  With the 
<A HREF="gnu.html" TARGET="_top">
GNU flavors
</A>
, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\`
</SPAN>
</TT>
 does the same.  This makes no difference if you're only making one call to 
<tt>
regexp
</tt>
 in Tcl or 
<tt>
regexec()
</tt>
 in the GNU library.  It can make a difference if you make a second call to find another match in the remainder of the string after the first match.  
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\A
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\`
</SPAN>
</TT>
 then matches at the end of the first match, instead of failing to match as start-of-string anchors normally do.  Strangely enough, the caret does not have this issue in either Tcl or GNU's library.</p>

</DIV>
 
<div class=topad>
<A HREF="//www.regexbuddy.com/create.html" TARGET="_top">
</A>
</div>
 
<H1>
The Premier website about Regular Expressions
</h1>
 
<P>A regular expression (regex or regexp for short) is a special text string for describing a search pattern. You can think of regular expressions as wildcards on steroids. You are probably familiar with wildcard notations such as *.txt to find all text files in a file manager. The regex equivalent is 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexescaped">
\.
</SPAN>
<SPAN CLASS="regexplain">
txt
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
.</P>
 
<P>But you can do much more with regular expressions. In a text editor like 
<A HREF="editpadpro.html" TARGET="_top">
EditPad Pro
</A>
 or a specialized text processing tool like 
<A HREF="powergrep.html" TARGET="_top">
PowerGREP
</A>
, you could use the regular expression 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccliteral">
._%+
</SPAN>
<SPAN CLASS="regexccliteral">
-
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexplain">
@
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccliteral">
.
</SPAN>
<SPAN CLASS="regexccliteral">
-
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexescaped">
\.
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
{2,}
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 to search for an email address. 
<I>
Any
</I>
 email address, to be exact. A very similar regular expression (replace the first 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 with 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
</TT>
 and the last one with 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
) can be used by a programmer to check whether the user entered a 
<A HREF="email.html" TARGET="_top">
properly formatted email address
</A>
. In just one line of code, whether that code is written in 
<A HREF="perl.html" TARGET="_top">
Perl
</A>
, 
<A HREF="php.html" TARGET="_top">
PHP
</A>
, 
<A HREF="java.html" TARGET="_top">
Java
</A>
, 
<A HREF="dotnet.html" TARGET="_top">
a .NET language
</A>
, or a multitude of other languages.</P>
<H2>Regular Expressions Quick Start</H2>
 
<P>If you just want to get your feet wet with regular expressions, take a look at the 
<A HREF="quickstart.html" TARGET="_top">
one-page regular expressions quick start
</A>
. While you can't learn to efficiently use regular expressions from this brief overview, it's enough to be able to throw together a bunch of simple regular expressions. Each section in the quick start links directly to detailed information in the tutorial.</P>
<H2>Complete Regular Expressions Tutorial</H2>
 
<P>Do not worry if the above example or the quick start make little sense to you. Any non-trivial regex looks daunting to anybody not familiar with them. But with just a bit of experience, you will soon be able to craft your own regular expressions like you have never done anything else. The 
<A HREF="tutorial.html" TARGET="_top">
free Regular-Expressions.info Tutorial
</A>
 explains everything bit by bit.</P>
 
<P>This tutorial is quite unique because it not only explains the regex syntax, but also describes in detail how the regex engine actually goes about its work. You will learn quite a lot, even if you have already been using regular expressions for some time. This will help you to understand quickly why a particular regex does not do what you initially expected, saving you lots of guesswork and head scratching when writing more complex regexes.</P>
<H2>Replacement Strings Tutorial</H2>
 
<P>A replacement string, also known as the replacement text, is the text that each regular expression match is replaced with during a search-and-replace. In most applications, the replacement text supports special syntax that allows you to reuse the text matched by the regular expression or parts thereof in the replacement. This website also includes a complete 
<A HREF="replacetutorial.html" TARGET="_top">
replacement strings tutorial
</A>
 that explains this syntax. While replacement strings are fairly simple compared with regular expressions, there is still great variety between the syntax used by various applications and their actual behavior.</P>
 
<H2>Applications &amp; Languages That Support Regexes</H2>
 
<P>There are many 
<A HREF="tools.html" TARGET="_top">
software applications and programming languages
</A>
 that support regular expressions. If you are a programmer, you can save yourself lots of time and effort. You can often accomplish with a single regular expression in one or a few lines of code what would otherwise take dozens or hundreds.</P>
 
<p>Many applications and programming languages have their own implementation of regular expressions, often with slight and sometimes with significant differences from other implementations. When two applications use a different implementation of regular expressions, we say that they use different "regular expression flavors". Unlike most other regex tutorials, the tutorial on this website covers all the popular regular expression flavors, and indicates the differences that you should watch out for.</p>
 
<H2>Not Only for Programmers</H2>
 
<P>If you are not a programmer, you can use regular expressions in many situations just as well. They make finding information a lot easier. You can use them in powerful 
<A HREF="replacetutorial.html" TARGET="_top">
search and replace
</A>
 operations to quickly make changes across large numbers of files. A simple example is 
<TT CLASS=code>
<SPAN CLASS="regexplain">
gr
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
ae
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexplain">
y
</SPAN>
</TT>
 which finds both spellings of the word gray in one operation, instead of two. There are many 
<A HREF="editpadpro.html" TARGET="_top">
text editors
</A>
 and 
<A HREF="powergrep.html" TARGET="_top">
search and replace tools
</A>
 with decent regex support.</P>
 
<H2>Further Reading</H2>
 
<P>If you're hungry for more information on regular expressions after reading this website, there are a 
<A HREF="books.html" TARGET="_top">
variety of books
</A>
 on the subject.</P>

</DIV>
 
<div class=topad>
<A HREF="//www.regexbuddy.com/create.html" TARGET="_top">
</A>
</div>
 
<H1>
Regular Expressions Quick Start
</h1>
 
<P>This quick start gets you up to speed quickly with regular expressions. Obviously, this brief introduction cannot explain everything there is to know about regular expressions. For detailed information, consult the 
<A HREF="tutorial.html" TARGET="_top">
regular expressions tutorial
</A>
. Each topic in the quick start corresponds with a topic in the tutorial, so you can easily go back and forth between the two.</P>
 
<p>Many applications and programming languages have their own implementation of regular expressions, often with slight and sometimes with significant differences from other implementations. When two applications use a different implementation of regular expressions, we say that they use different "regular expression flavors". This quick start explains the syntax supported by the most popular regular expression flavors.</p>
 
<H2>Text Patterns and Matches</H2>
 
<P>A regular expression, or regex for short, is a pattern describing a certain amount of text. On this website, regular expressions are highlighted in red as 
<TT CLASS=code>
<SPAN CLASS="regexplain">
regex
</SPAN>
</TT>
. This is actually a perfectly valid regex. It is the most basic pattern, simply matching the literal text 
<TT CLASS=match>
regex
</TT>
. Matches are highlighted in blue on this site. We use the term "string" to indicate the text that the regular expression is applied to. Strings are highlighted in 
<TT CLASS=string>
green
</TT>
.</P>
 
<p>Characters with special meanings in regular expressions are highlighted in various different colors. The regex 
<TT CLASS=code>
<SPAN CLASS="regexmeta">
(?
</SPAN>
<SPAN CLASS="regexmeta">
x
</SPAN>
<SPAN CLASS="regexmeta">
)
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
Rr
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexplain">
egex
</SPAN>
<SPAN CLASS="regexplain">
p
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexescaped">
\?
</SPAN>
</TT>
 shows meta tokens in purple, grouping in green, character classes in orange, quantifiers and other special tokens in blue, and escaped characters in gray.</p>
 
<H2>Literal Characters</H2>
 
<P>The most basic regular expression consists of a single literal character, such as 
<TT CLASS=code>
<SPAN CLASS="regexplain">
a
</SPAN>
</TT>
. It matches the first occurrence of that character in the string. If the string is 
<TT CLASS=string>
Jack is a boy
</TT>
, it matches the 
<TT CLASS=match>
a
</TT>
 after the 
<TT CLASS=string>
J
</TT>
.</P>
 
<P>This regex can match the second 
<TT CLASS=match>
a
</TT>
 too. It only does so when you tell the regex engine to start searching through the string after the first match. In a text editor, you can do so by using its "Find Next" or "Search Forward" function. In a programming language, there is usually a separate function that you can call to continue searching through the string after the previous match.</P>
 
<p>Twelve characters have special meanings in regular expressions: the backslash 
<TT CLASS=code>
<SPAN CLASS="regexerr">
\
</SPAN>
</TT>
, the caret 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
</TT>
, the dollar sign 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
, the period or dot 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
.
</SPAN>
</TT>
, the vertical bar or pipe symbol 
<TT CLASS=code>
<SPAN CLASS="regexerr">
|
</SPAN>
</TT>
, the question mark 
<TT CLASS=code>
<SPAN CLASS="regexerr">
?
</SPAN>
</TT>
, the asterisk or star 
<TT CLASS=code>
<SPAN CLASS="regexerr">
*
</SPAN>
</TT>
, the plus sign 
<TT CLASS=code>
<SPAN CLASS="regexerr">
+
</SPAN>
</TT>
, the opening parenthesis 
<TT CLASS=code>
<SPAN CLASS="regexerr">
(
</SPAN>
</TT>
, the closing parenthesis 
<TT CLASS=code>
<SPAN CLASS="regexerr">
)
</SPAN>
</TT>
, the opening square bracket 
<TT CLASS=code>
<SPAN CLASS="regexerr">
[
</SPAN>
</TT>
, and the opening curly brace 
<TT CLASS=code>
<SPAN CLASS="regexerr">
{
</SPAN>
</TT>
. These special characters are often called "metacharacters". Most of them are errors when used alone.</p>
 
<P>If you want to use any of these characters as a literal in a regex, you need to escape them with a backslash. If you want to match 
<TT CLASS=match>
1+1=2
</TT>
, the correct regex is 
<TT CLASS=code>
<SPAN CLASS="regexplain">
1
</SPAN>
<SPAN CLASS="regexescaped">
\+
</SPAN>
<SPAN CLASS="regexplain">
1=2
</SPAN>
</TT>
. Otherwise, the plus sign has a special meaning.</P>
 
<p><A HREF="characters.html" TARGET="_top">
Learn more about literal characters
</A></p>
 
<H2>Character Classes or Character Sets</H2>
 
<P>A "character class" matches only one out of several characters. To match an a or an e, use 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
ae
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
. You could use this in 
<TT CLASS=code>
<SPAN CLASS="regexplain">
gr
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
ae
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexplain">
y
</SPAN>
</TT>
 to match either 
<TT CLASS=match>
gray
</TT>
 or 
<TT CLASS=match>
grey
</TT>
. A character class matches only a single character. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
gr
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
ae
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexplain">
y
</SPAN>
</TT>
 does not match 
<TT CLASS=string>
graay
</TT>
, 
<TT CLASS=string>
graey
</TT>
 or any such thing. The order of the characters inside a character class does not matter.</P>
 
<P>You can use a hyphen inside a character class to specify a range of characters. 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 matches a 
<I>
single
</I>
 digit between 0 and 9. You can use more than one range. 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
f
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
F
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 matches a single hexadecimal digit, case insensitively. You can combine ranges and single characters. 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
f
</SPAN>
<SPAN CLASS="regexccliteral">
x
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
F
</SPAN>
<SPAN CLASS="regexccliteral">
X
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 matches a hexadecimal digit or the letter X.</P>
 
<P>Typing a caret after the opening square bracket negates the character class. The result is that the character class matches any character that is 
<I>
not
</I>
 in the character class. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
q
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
x
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 matches 
<tt class=match>
qu
</tt>
 in 
<tt class=string>
question
</tt>
. It does 
<i>
not
</i>
 match 
<tt class=string>
Iraq
</tt>
 since there is no character after the q for the negated character class to match.</P>
 
<p><A HREF="charclass.html" TARGET="_top">
Learn more about character classes
</A></p>
 
<h2>Shorthand Character Classes</h2>
 
<p><TT CLASS=code>
<SPAN CLASS="regexspecial">
\d
</SPAN>
</TT>
 matches a single character that is a digit, 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\w
</SPAN>
</TT>
 matches a "word character" (alphanumeric characters plus underscore), and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\s
</SPAN>
</TT>
 matches a whitespace character (includes tabs and line breaks). The actual characters matched by the shorthands depends on the software you're using. In modern applications, they include non-English letters and numbers.</p>
 
<p><A HREF="shorthand.html" TARGET="_top">
Learn more about shorthand character classes
</A></p>
 
<h2>Non-Printable Characters</h2>
 
<P>You can use special character sequences to put non-printable characters in your regular expression. Use 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\t
</SPAN>
</TT>
 to match a tab character (ASCII 0x09), 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\r
</SPAN>
</TT>
 for carriage return (0x0D) and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\n
</SPAN>
</TT>
 for line feed (0x0A). More exotic non-printables are 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\a
</SPAN>
</TT>
 (bell, 0x07), 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\e
</SPAN>
</TT>
 (escape, 0x1B), 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\f
</SPAN>
</TT>
 (form feed, 0x0C) and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\v
</SPAN>
</TT>
 (vertical tab, 0x0B). Remember that Windows text files use 
<TT CLASS=string>
\r\n
</TT>
 to terminate lines, while UNIX text files use 
<TT CLASS=string>
\n
</TT>
.</P>
 
<P>If your application supports 
<A HREF="unicode.html" TARGET="_top">
Unicode
</A>
, use 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\uFFFF
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\x{FFFF}
</SPAN>
</TT>
 to insert a Unicode character. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\u20AC
</SPAN>
</TT>
 or 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\x{20AC}
</SPAN>
</TT>
 matches the euro currency sign.</P>
 
<P>If your application does not support Unicode, use 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\xFF
</SPAN>
</TT>
 to match a specific character by its hexadecimal index in the character set. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\xA9
</SPAN>
</TT>
 matches the copyright symbol in the Latin-1 character set.</P>
 
<p>All non-printable characters can be used directly in the regular expression, or as part of a character class.</p>
 
<p><a href="charclass.html#nonprint">
Learn more about non-printable characters
</a></p>
 
<h2>The Dot Matches (Almost) Any Character</h2>
 
<P>The dot matches a single character, except line break characters. Most applications have a "dot matches all" or "single line" mode that makes the dot match any single character, including line breaks.</P>
 
<p><TT CLASS=code>
<SPAN CLASS="regexplain">
gr
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexplain">
y
</SPAN>
</TT>
 matches 
<TT CLASS=match>
gray
</TT>
, 
<TT CLASS=match>
grey
</TT>
, 
<TT CLASS=match>
gr%y
</TT>
, etc. Use the dot sparingly. Often, a character class or negated character class is faster and more precise.</p>
 
<p><A HREF="dot.html" TARGET="_top">
Learn more about the dot
</A></p>
 
<h2>Anchors</h2>
 
<p>Anchors do not match any characters. They match a position. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
</TT>
 matches at the start of the string, and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
 matches at the end of the string. Most regex engines have a "multi-line" mode that makes 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
</TT>
 match after any line break, and 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
 before any line break. E.g. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
 matches only the first 
<tt class=match>
b
</tt>
 in 
<tt class=string>
bob
</tt>
.</p>
 
<p><TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 matches at a word boundary. A word boundary is a position between a character that can be matched by 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\w
</SPAN>
</TT>
 and a character that cannot be matched by 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\w
</SPAN>
</TT>
. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 also matches at the start and/or end of the string if the first and/or last characters in the string are word characters. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\B
</SPAN>
</TT>
 matches at every position where 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 cannot match.</p>
 
<p><A HREF="anchors.html" TARGET="_top">
Learn more about anchors
</A></p>
 
<h2>Alternation</h2>
 
<p>Alternation is the regular expression equivalent of "or". 
<TT CLASS=code>
<SPAN CLASS="regexplain">
cat
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexplain">
dog
</SPAN>
</TT>
 matches 
<tt class=match>
cat
</tt>
 in 
<tt class=string>
About cats and dogs
</tt>
. If the regex is applied again, it matches 
<tt class=match>
dog
</tt>
. You can add as many alternatives as you want: 
<TT CLASS=code>
<SPAN CLASS="regexplain">
cat
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexplain">
dog
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexplain">
mouse
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexplain">
fish
</SPAN>
</TT>
.</p>
 
<p>Alternation has the lowest precedence of all regex operators. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
cat
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexplain">
dog food
</SPAN>
</TT>
 matches 
<tt class=match>
cat
</tt>
 or 
<tt class=match>
dog food
</tt>
. To create a regex that matches 
<tt class=match>
cat food
</tt>
 or 
<tt class=match>
dog food
</tt>
, you need to group the alternatives: 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
cat
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
dog
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
 food
</SPAN>
</TT>
.</p>
 
<p><A HREF="alternation.html" TARGET="_top">
Learn more about alternation
</A></p>
 
<h2>Repetition</h2>
 
<p>The question mark makes the preceding token in the regular expression optional. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
colo
</SPAN>
<SPAN CLASS="regexplain">
u
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexplain">
r
</SPAN>
</TT>
 matches 
<TT CLASS=match>
colour
</TT>
 or 
<TT CLASS=match>
color
</TT>
.</p>
 
<p>The asterisk or star tells the engine to attempt to match the preceding token zero or more times. The plus tells the engine to attempt to match the preceding token once or more. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
&lt;
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexplain">
&gt;
</SPAN>
</TT>
 matches an HTML tag without any attributes. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
&lt;
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccrange">
a
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
z
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexplain">
&gt;
</SPAN>
</TT>
 is easier to write but matches invalid tags such as 
<tt class=match>
&lt;1&gt;
</tt>
.</p>
 
<p>Use curly braces to specify a specific amount of repetition. Use 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
1
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
{3}
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 to match a number between 1000 and 9999. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
1
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
{2,4}
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 matches a number between 100 and 99999.</p>
 
<p><A HREF="repeat.html" TARGET="_top">
Learn more about quantifiers
</A></p>
 
<H2>Greedy and Lazy Repetition</H2>
 
<P>The repetition operators or quantifiers are greedy. They expand the match as far as they can, and only give back if they must to satisfy the remainder of the regex. The regex 
<TT CLASS=code>
<SPAN CLASS="regexplain">
&lt;
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexplain">
&gt;
</SPAN>
</TT>
 matches 
<TT CLASS=match>
&lt;EM&gt;first&lt;/EM&gt;
</TT>
 in 
<TT CLASS=string>
This is a &lt;EM&gt;first&lt;/EM&gt; test
</TT>
.</P>
 
<p>Place a question mark after the quantifier to make it lazy. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
&lt;
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexplain">
&gt;
</SPAN>
</TT>
 matches 
<TT CLASS=match>
&lt;EM&gt;
</TT>
 in the above string.</p>
 
<p>A better solution is to follow my advice to use the dot sparingly. Use 
<TT CLASS=code>
<SPAN CLASS="regexplain">
&lt;
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
&lt;&gt;
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexplain">
&gt;
</SPAN>
</TT>
 to quickly match an HTML tag without regard to attributes. The negated character class is more specific than the dot, which helps the regex engine find matches quickly.</p>
 
<p><a href="repeat.html#greedy">
Learn more about greedy and lazy quantifiers
</a></p>
 
<h2>Grouping and Capturing</h2>
 
<p>Place parentheses around multiple tokens to group them together. You can then apply a quantifier to the group. E.g. 
<TT CLASS=code>
<SPAN CLASS="regexplain">
Set
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
Value
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
</TT>
 matches 
<TT CLASS=match>
Set
</TT>
 or 
<TT CLASS=match>
SetValue
</TT>
.</p>
 
<p>Parentheses create a capturing group. The above example has one group. After the match, group number one contains nothing if 
<tt class=match>
Set
</tt>
 was matched. It contains 
<tt class=match>
Value
</tt>
 if 
<tt class=match>
SetValue
</tt>
 was matched. How to access the group's contents depends on the software or programming language you're using. Group zero always contains the entire regex match.</p>
 
<p>Use the special syntax 
<TT CLASS=code>
<SPAN CLASS="regexplain">
Set
</SPAN>
<SPAN CLASS="regexnest1">
(?:
</SPAN>
<SPAN CLASS="regexplain">
Value
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
</TT>
 to group tokens without creating a capturing group. This is more efficient if you don't plan to use the group's contents. Do not confuse the question mark in the non-capturing group syntax with the quantifier.</p>
 
<p><A HREF="brackets.html" TARGET="_top">
Learn more about grouping and capturing
</A></p>
 
<h2>Backreferences</h2>
 
<p>Within the regular expression, you can use the backreference 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\1
</SPAN>
</TT>
 to match the same text that was matched by the capturing group. 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
abc
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
=
</SPAN>
<SPAN CLASS="regexspecial">
\1
</SPAN>
</TT>
 matches 
<tt class=match>
a=a
</tt>
, 
<tt class=match>
b=b
</tt>
, and 
<tt class=match>
c=c
</tt>
. It does not match anything else. If your regex has multiple capturing groups, they are numbered counting their opening parentheses from left to right.</p>
 
<p><A HREF="backref.html" TARGET="_top">
Learn more about backreferences
</A></p>
 
<h2>Named Groups and Backreferences</h2>
 
<p>If your regex has many groups, keeping track of their numbers can get cumbersome. Make your regexes easier to read by naming your groups. 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?&lt;mygroup&gt;
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
abc
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
=
</SPAN>
<SPAN CLASS="regexspecial">
\k&lt;mygroup&gt;
</SPAN>
</TT>
 is identical to 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
abc
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
=
</SPAN>
<SPAN CLASS="regexspecial">
\1
</SPAN>
</TT>
, except that you can refer to the group by its name.</p>
 
<p><A HREF="named.html" TARGET="_top">
Learn more about named groups
</A></p>
 
<h2>Unicode Properties</h2>
 
<p><TT CLASS=code>
<SPAN CLASS="regexspecial">
\p{L}
</SPAN>
</TT>
 matches a single character that is in the given Unicode category. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
L
</SPAN>
</TT>
 stands for letter. 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\P{L}
</SPAN>
</TT>
 matches a single character that is not in the given Unicode category. You can find a 
<a href="unicode.html#category">
complete list of Unicode categories
</a>
 in the tutorial.</p>
 
<p><A HREF="unicode.html" TARGET="_top">
Learn more about Unicode regular expressions
</A></p>
 
<h2>Lookaround</h2>
 
<p>Lookaround is a special kind of group. The tokens inside the group are matched normally, but then the regex engine makes the group give up its match and keeps only the result. Lookaround matches a position, just like anchors. It does not expand the regex match.</p>
 
<p><TT CLASS=code>
<SPAN CLASS="regexplain">
q
</SPAN>
<SPAN CLASS="regexnest1">
(?=
</SPAN>
<SPAN CLASS="regexplain">
u
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 matches the 
<tt class=match>
q
</tt>
 in 
<tt class=string>
question
</tt>
, but not in 
<tt class=string>
Iraq
</tt>
. This is positive lookahead. The 
<TT CLASS=code>
<SPAN CLASS="regexplain">
u
</SPAN>
</TT>
 is not part of the overall regex match. The lookahead matches at each position in the string before a 
<tt class=string>
u
</tt>
.</p>
 
<p><TT CLASS=code>
<SPAN CLASS="regexplain">
q
</SPAN>
<SPAN CLASS="regexnest1">
(?!
</SPAN>
<SPAN CLASS="regexplain">
u
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
 matches 
<tt class=match>
q
</tt>
 in 
<tt class=string>
Iraq
</tt>
 but not in 
<tt class=string>
question
</tt>
. This is negative lookahead. The tokens inside the lookahead are attempted, their match is discarded, and the result is inverted.</p>
 
<p>To look backwards, use lookbehind. 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?&lt;=
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
 matches the 
<tt class=match>
b
</tt>
 in 
<tt class=string>
abc
</tt>
. This is positive lookbehind. 
<TT CLASS=code>
<SPAN CLASS="regexnest1">
(?&lt;!
</SPAN>
<SPAN CLASS="regexplain">
a
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
b
</SPAN>
</TT>
 fails to match 
<tt class=string>
abc
</tt>
.</p>
 
<p>You can use a full-fledged regular expression inside lookahead. Most applications only allow fixed-length expressions in lookbehind.</p>
 
<p><A HREF="lookaround.html" TARGET="_top">
Learn more about lookaround
</A></p>
 
<h2>Free-Spacing Syntax</h2>
 
<p>Many application have an option that may be labeled "free-spacing" or "ignore whitespace" or "comments" that makes the regular expression engine ignore unescaped spaces and line breaks and that makes the # character start a comment that runs until the end of the line. This allows you to use whitespace to format your regular expression in a way that makes it easier for humans to read and thus makes it easier to maintain.</p>
 
<p><A HREF="freespacing.html" TARGET="_top">
Learn more about free-spacing
</A></p>

</DIV>
</DIV>
<div class=topad>
<A HREF="//www.regexbuddy.com/create.html" TARGET="_top">
</A>
</div>
 
<H1>
Regular Expressions Tutorial
</h1>

<H2>What Regular Expressions Are Exactly - Terminology</H2>
 
<P>Basically, a regular expression is a pattern describing a certain amount of text. Their name comes from the mathematical theory on which they are based. But we will not dig into that. You will usually find the name abbreviated to &quot;regex&quot; or &quot;regexp&quot;. This tutorial uses &quot;regex&quot;, because it is easy to pronounce the plural &quot;regexes&quot;. On this website, regular expressions are highlighted in red as 
<TT CLASS=code>
<SPAN CLASS="regexplain">
regex
</SPAN>
</TT>
.</P>
 
<P>This first example is actually a perfectly valid regex. It is the most basic pattern, simply matching the literal text 
<TT CLASS=match>
regex
</TT>
. A "match" is the piece of text, or sequence of bytes or characters that pattern was found to correspond to by the regex processing software. Matches are highlighted in blue on this site.</P>
 
<P><TT CLASS=code>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccliteral">
._%+
</SPAN>
<SPAN CLASS="regexccliteral">
-
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexplain">
@
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccliteral">
.
</SPAN>
<SPAN CLASS="regexccliteral">
-
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexescaped">
\.
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
{2,}
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
</TT>
 is a more complex pattern. It describes a series of letters, digits, dots, underscores, percentage signs and hyphens, followed by an at sign, followed by another series of letters, digits and hyphens, finally followed by a single dot and two or more letters. In other words: this pattern describes an 
<A HREF="email.html" TARGET="_top">
email address
</A>
. This also shows the syntax highlighting applied to regular expressions on this site. Word boundaries and quantifiers are blue, character classes are orange, and escaped literals are gray. You'll see additional colors like green for grouping and purple for meta tokens later in the tutorial.</P>
 
<P>With the above regular expression pattern, you can search through a text file to find email addresses, or verify if a given string looks like an email address. This tutorial uses the term "string" to indicate the text that the regular expression is applied to. This website highlights them in 
<TT CLASS=string>
green
</TT>
. The term "string" or "character string" is used by programmers to indicate a sequence of characters. In practice, you can use regular expressions with whatever data you can access using the application or programming language you are working with.</P>
 
<A NAME="engine">
</A>

<H2>Different Regular Expression Engines</H2>
 
<P>A regular expression "engine" is a piece of software that can process regular expressions, trying to match the pattern to the given string. Usually, the engine is part of a larger application and you do not access the engine directly. Rather, the application invokes it for you when needed, making sure the right regular expression is applied to the right file or data.</P>
 
<P>As usual in the software world, different regular expression engines are not fully compatible with each other. The syntax and behavior of a particular engine is called a regular expression flavor. This tutorial covers all the popular regular expression flavors, including 
<A HREF="perl.html" TARGET="_top">
Perl
</A>
, 
<A HREF="pcre.html" TARGET="_top">
PCRE
</A>
, 
<A HREF="php.html" TARGET="_top">
PHP
</A>
, 
<A HREF="dotnet.html" TARGET="_top">
.NET
</A>
, 
<A HREF="java.html" TARGET="_top">
Java
</A>
, 
<A HREF="javascript.html" TARGET="_top">
JavaScript
</A>
, 
<A HREF="xregexp.html" TARGET="_top">
XRegExp
</A>
, 
<A HREF="vbscript.html" TARGET="_top">
VBScript
</A>
, 
<A HREF="python.html" TARGET="_top">
Python
</A>
, 
<A HREF="ruby.html" TARGET="_top">
Ruby
</A>
, 
<A HREF="delphi.html" TARGET="_top">
Delphi
</A>
, 
<A HREF="rlanguage.html" TARGET="_top">
R
</A>
, 
<A HREF="tcl.html" TARGET="_top">
Tcl
</A>
, 
<A HREF="posix.html" TARGET="_top">
POSIX
</A>
, and 
<A HREF="tools.html" TARGET="_top">
many others
</A>
. The tutorial alerts you when these flavors require different syntax or show different behavior. Even if your application is not explicitly covered by the tutorial, it likely uses a regex flavor that is covered, as most applications are developed using one of the programming environments or regex libraries just mentioned.</P>
<H2>Give Regexes a First Try</H2>
 
<P>You can easily try the following yourself in a text editor that supports regular expressions, such as 
<A HREF="editpadpro.html" TARGET="_top">
EditPad Pro
</A>
. If you do not have such an editor, you can 
<A HREF="//www.editpadpro.com/download.html" TARGET="_top">
download the free evaluation version of EditPad Pro
</A>
 to try this out. EditPad Pro's regex engine is fully functional in the demo version.</P>
 
<P><IMG SRC="https://www.regular-expressions.info/screens/eppeditpadpro.png" ALT="Highlighting regular expression matches in EditPad Pro" BORDER=0></P>
 
<P>As a quick test, copy and paste the text of this page into EditPad Pro. Then select Search|Multiline Search Panel in the menu. In the search panel that appears near the bottom, type in 
<TT CLASS=code>
<SPAN CLASS="regexplain">
regex
</SPAN>
</TT>
 in the box labeled "Search Text". Mark the "Regular expression" checkbox, and click the Find First button. This is the leftmost button on the search panel. See how EditPad Pro's regex engine finds the first match. Click the Find Next button, which sits next to the Find First button, to find further matches. When there are no further matches, the Find Next button's icon flashes briefly.</P>
 
<P>Now try to search using the regex 
<TT CLASS=code>
<SPAN CLASS="regexplain">
reg
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexplain">
ular expression
</SPAN>
<SPAN CLASS="regexplain">
s
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexnest1">
|
</SPAN>
<SPAN CLASS="regexplain">
ex
</SPAN>
<SPAN CLASS="regexnest2">
(
</SPAN>
<SPAN CLASS="regexplain">
p
</SPAN>
<SPAN CLASS="regexnest2">
|
</SPAN>
<SPAN CLASS="regexplain">
es
</SPAN>
<SPAN CLASS="regexnest2">
)
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
</TT>
. This regex finds all names, singular and plural, I have used on this page to say "regex". If we only had plain text search, we would have needed 5 searches. With regexes, we need just one search. Regexes save you time when using a tool like EditPad Pro. Select Count Matches in the Search menu to see how many times this regular expression can match the file you have open in EditPad Pro.</P>
 
<P>If you are a programmer, your software will run faster since even a simple regex engine applying the above regex once will outperform a state of the art plain text search algorithm searching through the data five times. Regular expressions also reduce development time. With a regex engine, it takes only one line (e.g. in Perl, PHP, Python, Ruby, Java, or .NET) or a couple of lines (e.g. in C using PCRE) of code to, say, check if the user's input looks like a 
<A HREF="email.html" TARGET="_top">
valid email address
</A>
.</P>
 
<P><A HREF="tutorialcnt.html" TARGET="_top">
Regex Tutorial Table of Contents
</A></P>
  
 
</DIV>
 
</div>
<H1>
Replacement Strings Tutorial
</H1>
 
<P>A replacement string, also known as the replacement text, is the text that each regular expression match is replaced with during a search-and-replace. In most applications, the replacement text supports special syntax that allows you to reuse the text matched by the regular expression or parts thereof in the replacement. This tutorial explains this syntax. While replacement strings are fairly simple compared with regular expressions, there is still great variety between the syntax used by various applications and their actual behavior.</P>
 
<P>On this website, replacement strings are shown as 
<TT CLASS=code>
<SPAN CLASS="replaceplain">
replace
</SPAN>
</TT>
 like you would enter them in the Replace box of an application. Literal text in the replacement is highlighted in yellow. As 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
$&amp;
</SPAN>
<SPAN CLASS="regexescaped">
\$
</SPAN>
</TT>
 shows, special tokens are highlighted in blue and escaped characters in gray.</P>
<H2>Table of Contents</h2>
 
<P><A HREF="replacecharacters.html" TARGET="_top">
Literal Characters and Special Characters
</A></P>
 
<P CLASS=indent>
The simplest replacement text consists of only literal characters. Certain characters have special meanings in replacement strings and have to be escaped. Escaping rules may get a bit complicated when using replacement strings in software source code.</P>
 
<P><A HREF="nonprint.html" TARGET="_top">
Non-Printable Characters
</A></P>
 
<P CLASS=indent>
Non-printable characters such as control characters and special spacing or line break characters are easier to enter using control character escapes or hexadecimal escapes.</P>
 
<P><A HREF="replacematch.html" TARGET="_top">
Matched Text
</A></P>
 
<p class=indent>
Reinserting the entire regex match into the replacement text allows a search-and-replace to insert text before and after regular expression matches without really replacing anything.</p>
 
<P><A HREF="replacebackref.html" TARGET="_top">
Backreferences
</A></P>
 
<p class=indent>
Backreferences to 
<A HREF="named.html" TARGET="_top">
named
</A>
 and 
<A HREF="brackets.html" TARGET="_top">
numbered capturing groups
</A>
 in the regular expression allow the replacement text to reuse parts of the text matched by the regular expression.</p>
 
<P><A HREF="replacecontext.html" TARGET="_top">
Match Context
</A></P>
 
<p class=indent>
Some applications support special tokens in replacement strings that allow you to insert the subject string or the part of the subject string before or after the regex match. This can be useful when the replacement text syntax is used to collect search matches and their context instead of making replacements in the subject string.</p>
 
<P><A HREF="replacecase.html" TARGET="_top">
Case Conversion
</A></P>
 
<p class=indent>
Some applications can insert the text matched by the regex or by capturing groups converted to uppercase or lowercase.</p>
 
<p><A HREF="replaceconditional.html" TARGET="_top">
Conditionals
</A></p>
 
<p class=indent>
Some applications can use one replacement or another replacement depending on whether a capturing group participated in the match. This allows you to use different replacements for different matches of the regular expression.</p>

</DIV>

</DIV>
</div>
<H1>
Specialized Tools and Utilities for Working with Regular Expressions
</h1>
 
<P>These tools and utilities have regular expressions as the core of their functionality.</P>
 
<P><A HREF="grep.html" TARGET="_top">
grep
</A>
 - The utility from the UNIX world that first made regular expressions popular</P>
 
<P><A HREF="powergrep.html" TARGET="_top">
PowerGREP
</A>
 - Next generation grep for Microsoft Windows</P>
 
<P><A HREF="regexbuddy.html" TARGET="_top">
RegexBuddy
</A>
 - Learn, create, understand, test, use and save regular expressions. RegexBuddy makes working with regular expressions easier than ever before.</P>
 
<P><A HREF="regexmagic.html" TARGET="_top">
RegexMagic
</A>
 - Generate regular expressions using RegexMagic's powerful patterns instead of the cryptic regular expression syntax.</P>
<H2>General Applications with Notable Support for Regular Expressions</H2>
 
<P>There are a lot of applications these days that support regular expressions in one way or another, enhancing certain part of their functionality. But certain applications stand out from the crowd by implementing a full-featured Perl-style regular expression flavor and allowing regular expressions to be used instead of literal search terms throughout the application.</P>
 
<P><A HREF="editpadlite.html" TARGET="_top">
EditPad Lite
</A>
 - Basic text editor that has all the essential features for text editing, including powerful regex-based search and replace.</P>
 
<P><A HREF="editpadpro.html" TARGET="_top">
EditPad Pro
</A>
 - Convenient text editor with a powerful regex-based search and replace feature, as well as regex-based customizable syntax coloring and file navigation.</P>
<H2>Programming Languages and Libraries</H2>
 
<P>If you are a programmer, you can save a lot of coding time by using regular expressions. With a regular expression, you can do powerful string parsing in only a handful lines of code, or maybe even just a single line. A regex is faster to write and easier to debug and maintain than dozens or hundreds of lines of code to achieve the same by hand.</P>
 
<p><A HREF="boost.html" TARGET="_top">
Boost
</A>
 - Free C++ source libraries with comprehensive regex support that was later standardized by C++11. But there are significant differences in Boost's regex flavors and the flavors in std::regex implementations.</p>
 
<P><A HREF="delphi.html" TARGET="_top">
Delphi
</A>
 - Delphi XE and later ship with RegularExpressions and RegularExpressionsCore units that wrap the PCRE library. For older Delphi versions, you can use the TPerlRegEx component, which is the unit that the RegularExpressionsCore unit is based on.</P>
 
<p><A HREF="gnu.html" TARGET="_top">
Gnulib
</A>
 - Gnulib or the GNU Portability Library includes many modules, including a regex module. It implements both 
<A HREF="posix.html" TARGET="_top">
POSIX
</A>
 flavors, as well as these two flavors with added 
<A HREF="gnu.html" TARGET="_top">
GNU extensions
</A>
.</p>
 
<P><A HREF="groovy.html" TARGET="_top">
Groovy
</A>
 - Groovy uses Java's java.util.regex package for regular expressions support. Groovy adds only a few language enhancements that allow you to instantiate the Pattern and Matcher classes with far fewer keystrokes.</P>
 
<P><A HREF="java.html" TARGET="_top">
Java
</A>
 - Java 4 and later include an excellent regular expressions library in the java.util.regex package.</P>
 
<P><A HREF="javascript.html" TARGET="_top">
JavaScript
</A>
 - If you use JavaScript to validate user input on a web page at the client side, using JavaScript's built-in regular expression support will greatly reduce the amount of code you need to write.</P>
 
<P><A HREF="dotnet.html" TARGET="_top">
.NET (dot net)
</A>
 - Microsoft's new development framework includes a poorly documented, but very powerful regular expression package, that you can use in any .NET-based programming language such as C# (C sharp) or VB.NET.</P>
 
<P><A HREF="pcre.html" TARGET="_top">
PCRE
</A>
 - Popular open source regular expression library written in ANSI C that you can link directly into your C and C++ applications, or use through an .so (UNIX/Linux) or a .dll (Windows).</P>
 
<P><A HREF="perl.html" TARGET="_top">
Perl
</A>
 - The text-processing language that gave regular expressions a second life, and introduced many new features. Regular expressions are an essential part of Perl.</P>
 
<P><A HREF="php.html" TARGET="_top">
PHP
</A>
 - Popular language for creating dynamic web pages, with three sets of regex functions. Two implement POSIX ERE, while the third is based on PCRE.</P>
 
<P><A HREF="posix.html" TARGET="_top">
POSIX
</A>
 - The POSIX standard defines two regular expression flavors that are implemented in many applications, programming languages and systems.</P>
 
<p><A HREF="powershell.html" TARGET="_top">
PowerShell
</A>
 - Windows PowerShell is a programming language from Microsoft that is primarily designed for system administration. Since PowerShell is built on top of .NET, it's built-in regex operators -match and -replace use the .NET regex flavor. PowerShell can also access the .NET Regex classes directly.</p>
 
<P><A HREF="python.html" TARGET="_top">
Python
</A>
 - Popular high-level scripting language with a comprehensive built-in regular expression library</P>
 
<P><A HREF="rlanguage.html" TARGET="_top">
R
</A>
 - The R Language is the programming languages used in the R Project for statistical computing. It has built-in support for regular expressions based on POSIX and PCRE.</P>
 
<P><A HREF="ruby.html" TARGET="_top">
Ruby
</A>
 - Another popular high-level scripting language with comprehensive regular expression support as a language feature.</P>
 
<p><A HREF="stdregex.html" TARGET="_top">
std::regex
</A>
 - Regex support part of the standard C++ library defined in C++11 and previously in TR1.</p>
 
<P><A HREF="tcl.html" TARGET="_top">
Tcl
</A>
 - Tcl, a popular "glue" language, offers three regex flavors. Two POSIX-compatible flavors, and an "advanced" Perl-style flavor.</P>
 
<P><A HREF="vbscript.html" TARGET="_top">
VBScript
</A>
 - Microsoft scripting language used in ASP (Active Server Pages) and Windows scripting, with a built-in RegExp object implementing the regex flavor defined in the JavaScript standard.</P>
 
<P><A HREF="vb.html" TARGET="_top">
Visual Basic 6
</A>
 - Last version of Visual Basic for Win32 development. You can use the VBScript RegExp object in your VB6 applications.</P>
 
<p><A HREF="wxwidgets.html" TARGET="_top">
wxWidgets
</A>
 - Popular open source windowing toolkit. The wxRegEx class encapsulates the "Advanced Regular Expression" engine originally developed for Tcl.</p>
 
<P><A HREF="xml.html" TARGET="_top">
XML Schema
</A>
 - The W3C XML Schema standard defines its own regular expression flavor for validating simple types using pattern facets.</p>
 
<p><A HREF="realbasic.html" TARGET="_top">
Xojo
</A>
 - Cross-platform development tool formerly known as REALbasic, with a built-in RegEx class based on PCRE.</p>
 
<P><A HREF="xpath.html" TARGET="_top">
XQuery and XPath
</A>
 - The W3C standard for XQuery 1.0 and XPath 2.0 Functions and Operators extends the XML Schema regex flavor to make it suitable for full text search.</p>
 
<p><A HREF="xregexp.html" TARGET="_top">
XRegExp
</A>
 - Open source JavaScript library that enhances the regex syntax and eliminates many cross-browser inconsistencies and bugs.</p>
 
<a name="db">
</a>
<H2>Databases</H2>
 
<P>Modern databases often offer built-in regular expression features that can be used in SQL statements to filter columns using a regular expression. With some databases you can also use regular expressions to extract the useful part of a column, or to modify columns using a search-and-replace.</p>
 
<p><A HREF="mysql.html" TARGET="_top">
MySQL
</A>
 - MySQL's REGEXP operator works just like the LIKE operator, except that it uses a POSIX Extended Regular Expression.</p>
 
<P><A HREF="oracle.html" TARGET="_top">
Oracle
</A>
 - Oracle Database 10g adds 4 regular expression functions that can be used in SQL and PL/SQL statements to filter rows and to extract and replace regex matches. Oracle implements POSIX Extended Regular Expressions.</p>
 
<P><A HREF="postgresql.html" TARGET="_top">
PostgreSQL
</A>
 - PostgreSQL provides matching operators and extraction and substitution functions using the "Advanced Regular Expression" engine also used by Tcl.</p>

</DIV>
</DIV>
<div class=topad>
<A HREF="//www.regexbuddy.com/benefits.html" TARGET="_top">
<img src="https://www.regular-expressions.info/ads/728/rxbexamples100.png" srcset="ads/728/rxbexamples100.png 1x, ads/728/rxbexamples125.png 1.25x, ads/728/rxbexamples150.png 1.5x, ads/728/rxbexamples175.png 1.75x, ads/728/rxbexamples200.png 2x, ads/728/rxbexamples250.png 2.5x, ads/728/rxbexamples300.png 3x, ads/728/rxbexamples350.png 3.5x, ads/728/rxbexamples400.png 4x" alt="RegexBuddy—The most comprehensive regular expression library!">
</A>
</div>
 
<H1>
Sample Regular Expressions
</h1>
 
<P>Below, you will find many example patterns that you can use for and adapt to your own purposes. Key techniques used in crafting each regex are explained, with links to the corresponding pages in the 
<A HREF="tutorial.html" TARGET="_top">
tutorial
</A>
 where these concepts and techniques are explained in great detail.</P>
 
<P>If you are new to regular expressions, you can take a look at these examples to see what is possible. Regular expressions are very powerful. They do take some time to learn. But you will earn back that time quickly when using regular expressions to automate searching or editing tasks in 
<A HREF="editpadpro.html" TARGET="_top">
EditPad Pro
</A>
 or 
<A HREF="powergrep.html" TARGET="_top">
PowerGREP
</A>
, or when writing scripts or applications in a 
<A HREF="tools.html" TARGET="_top">
variety of languages
</A>
.</P>
 
<P><A HREF="regexbuddy.html" TARGET="_top">
RegexBuddy
</A>
 offers the fastest way to get up to speed with regular expressions. RegexBuddy will analyze any regular expression and present it to you in a clearly to understand, detailed outline. The outline links to RegexBuddy's regex tutorial (the same one you find on this website), where you can always get in-depth information with a single click.</P>
 
<P>Oh, and you definitely do not need to be a programmer to take advantage of regular expressions!</P>
<H2>Grabbing HTML Tags</H2>
 
<P><TT CLASS=code>
<SPAN CLASS="regexplain">
&lt;TAG
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
&gt;
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexplain">
&gt;
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
&lt;/TAG&gt;
</SPAN>
</TT>
 matches the opening and closing pair of a specific HTML tag. Anything between the tags is captured into the first 
<A HREF="backref.html" TARGET="_top">
backreference
</A>
. The question mark in the regex makes the star 
<A HREF="repeat.html" TARGET="_top">
lazy
</A>
, to make sure it stops before the first closing tag rather than before the last, like a greedy star would do. This regex will not properly match tags nested inside themselves, like in 
<TT CLASS=string>
&lt;TAG&gt;one&lt;TAG&gt;two&lt;/TAG&gt;one&lt;/TAG&gt;
</TT>
.</P>
 
<P><TT CLASS=code>
<SPAN CLASS="regexplain">
&lt;
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccrange">
A
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
Z
</SPAN>
<SPAN CLASS="regexccrange">
0
</SPAN>
<SPAN CLASS="regexccrange">
-
</SPAN>
<SPAN CLASS="regexccrange">
9
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexspecial">
\b
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccspecial">
^
</SPAN>
<SPAN CLASS="regexccliteral">
&gt;
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexplain">
&gt;
</SPAN>
<SPAN CLASS="regexnest1">
(
</SPAN>
<SPAN CLASS="regexspecial">
.
</SPAN>
<SPAN CLASS="regexspecial">
*
</SPAN>
<SPAN CLASS="regexspecial">
?
</SPAN>
<SPAN CLASS="regexnest1">
)
</SPAN>
<SPAN CLASS="regexplain">
&lt;/
</SPAN>
<SPAN CLASS="regexspecial">
\1
</SPAN>
<SPAN CLASS="regexplain">
&gt;
</SPAN>
</TT>
 will match the opening and closing pair of any HTML tag. Be sure to turn off case sensitivity. The key in this solution is the use of the 
<A HREF="backref.html" TARGET="_top">
backreference
</A>
 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\1
</SPAN>
</TT>
 in the regex. Anything between the tags is captured into the second backreference. This solution will also not match tags nested in themselves.</P>
<H2>Trimming Whitespace</H2>
 
<P>You can easily trim unnecessary whitespace from the start and the end of a string or the lines in a text file by doing a regex search-and-replace. Search for 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
 
</SPAN>
<SPAN CLASS="regexccspecial">
\t
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
</TT>
 and replace with nothing to delete leading whitespace (spaces and tabs). Search for 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
 
</SPAN>
<SPAN CLASS="regexccspecial">
\t
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
 to trim trailing whitespace. Do both by 
<A HREF="alternation.html" TARGET="_top">
combining the regular expressions
</A>
 into 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
^
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
 
</SPAN>
<SPAN CLASS="regexccspecial">
\t
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexspecial">
|
</SPAN>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
 
</SPAN>
<SPAN CLASS="regexccspecial">
\t
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
<SPAN CLASS="regexspecial">
+
</SPAN>
<SPAN CLASS="regexspecial">
$
</SPAN>
</TT>
. Instead of 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
 
</SPAN>
<SPAN CLASS="regexccspecial">
\t
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 which matches a space or a tab, you can expand the 
<A HREF="charclass.html" TARGET="_top">
character class
</A>
 into 
<TT CLASS=code>
<SPAN CLASS="regexccopen">
[
</SPAN>
<SPAN CLASS="regexccliteral">
 
</SPAN>
<SPAN CLASS="regexccspecial">
\t
</SPAN>
<SPAN CLASS="regexccspecial">
\r
</SPAN>
<SPAN CLASS="regexccspecial">
\n
</SPAN>
<SPAN CLASS="regexccopen">
]
</SPAN>
</TT>
 if you also want to strip line breaks. Or you can use the 
<A HREF="shorthand.html" TARGET="_top">
shorthand
</A>
 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\s
</SPAN>
</TT>
 instead.</P>
<H2>More Detailed Examples</H2>
 
<P><A HREF="numericranges.html" TARGET="_top">
Numeric Ranges
</A>
. Since regular expressions work with text rather than numbers, matching specific numeric ranges requires a bit of extra care.</P>
 
<P><A HREF="floatingpoint.html" TARGET="_top">
Matching a Floating Point Number
</A>
. Also illustrates the common mistake of making everything in a regular expression optional.</P>
 
<P><A HREF="email.html" TARGET="_top">
Matching an Email Address
</A>
. There's a lot of controversy about what is a proper regex to match email addresses. It's a perfect example showing that you need to know exactly what you're trying to match (and what not), and that there's always a trade-off between regex complexity and accuracy.</P>
 
<p><A HREF="ip.html" TARGET="_top">
Matching an IP Address
</A>
.</p>
 
<P><A HREF="dates.html" TARGET="_top">
Matching Valid Dates
</A>
. A regular expression that matches 31-12-1999 but not 31-13-1999.</P>
 
<p><A HREF="creditcard.html" TARGET="_top">
Finding or Verifying Credit Card Numbers
</A>
. Validate credit card numbers entered on your order form. Find credit card numbers in documents for a security audit.</p>
 
<P><A HREF="completelines.html" TARGET="_top">
Matching Complete Lines
</A>
. Shows how to match complete lines in a text file rather than just the part of the line that satisfies a certain requirement. Also shows how to match lines in which a particular regex does 
<i>
not
</i>
 match.</P>
 
<P><A HREF="duplicatelines.html" TARGET="_top">
Removing Duplicate Lines or Items
</A>
. Illustrates simple yet clever use of capturing parentheses or backreferences.</P>
 
<P><A HREF="examplesprogrammer.html" TARGET="_top">
Regex Examples for Processing Source Code
</A>
. How to match common programming language syntax such as comments, strings, numbers, etc.</P>
 
<P><A HREF="near.html" TARGET="_top">
Two Words Near Each Other
</A>
. Shows how to use a regular expression to emulate the "near" operator that some tools have.</P>
 
<H2>Common Pitfalls</H2>
 
<p><A HREF="catastrophic.html" TARGET="_top">
Catastrophic Backtracking
</A>
. If your regular expression seems to take forever, or simply crashes your application, it has likely contracted a case of catastrophic backtracking. The solution is usually to be more specific about what you want to match, so the number of matches the engine has to try doesn't rise exponentially.</p>
 
<p><A HREF="floatingpoint.html" TARGET="_top">
Making Everything Optional
</A>
. If all the parts in your regex are optional, it will match a zero-length string anywhere. Your regex will need to express the facts that different parts are optional depending on which parts are present.</p>
 
<p><A HREF="captureall.html" TARGET="_top">
Repeating a Capturing Group vs. Capturing a Repeated Group
</A>
. Repeating a capturing group will capture only the last iteration of the group. Capture a repeated group if you want to capture all iterations.</p>
 
<p><A HREF="unicode8bit.html" TARGET="_top">
Mixing Unicode and 8-bit Character Codes
</A>
. Using 8-bit character codes like 
<TT CLASS=code>
<SPAN CLASS="regexspecial">
\x80
</SPAN>
</TT>
 with a Unicode engine and subject string may give unexpected results.</p>

</DIV>
</DIV>
<div class=topad>
<A HREF="//www.regexbuddy.com/benefits.html" TARGET="_top">
<img src="https://www.regular-expressions.info/ads/728/rxbreference100.png" srcset="ads/728/rxbreference100.png 1x, ads/728/rxbreference125.png 1.25x, ads/728/rxbreference150.png 1.5x, ads/728/rxbreference175.png 1.75x, ads/728/rxbreference200.png 2x, ads/728/rxbreference250.png 2.5x, ads/728/rxbreference300.png 3x, ads/728/rxbreference350.png 3.5x, ads/728/rxbreference400.png 4x" alt="RegexBuddy—Better than a regular expression reference!">
</A>
</div>
 
<h1>
Regular Expressions Reference
</h1>
 
<p>The regular expressions reference on this website functions both as a reference to all available regex syntax and as a comparison of the features supported by the regular expression flavors discussed in the 
<A HREF="tutorial.html" TARGET="_top">
tutorial
</A>
. The reference tables pack an incredible amount of information. To get the most out of them, follow this legend to learn how to read them.</p>
 
<p>The tables have six columns for each regular expression feature. The first four explain the feature.</p>
 
<table class=reference>
 
<tr>
<th>
Feature
</th>
<td>
The name of the feature, which also servers as a link to the relevant section in the tutorial.
</td>
</tr>
 
<tr>
<th>
Syntax
</th>
<td>
The actual regex syntax for this feature. If the syntax is fixed, it is simply shown as such. If the syntax has variable elements, the syntax is described.
</td>
</tr>
 
<tr>
<th>
Description
</th>
<td>
Summary of what the feature does.
</td>
</tr>
 
<tr>
<th>
Example
</th>
<td>
Functional regular expression that demonstrates the feature.
</td>
</tr>
 
</table>
 
<p>The final two columns indicate whether your two chosen regular expression flavors support this particular feature. You can change the flavors using the drop-down lists above the table. There are many possible indicators.</p>
 
<table class=reference>
 
<tr>
<td class=yes>
YES
</td>
<td>
All versions of this flavor support this feature.
</td>
</tr>
 
<tr>
<td class=yes>
3.0
</td>
<td>
Version 3.0 and all later versions of this flavor support this feature. Earlier versions do not support it.
</td>
</tr>
 
<tr>
<td class=yes>
2.0 only
</td>
<td>
Only version 2.0 supports this feature. Earlier and later versions do not support it.
</td>
</tr>
 
<tr>
<td class=yes>
2.0–2.9
</td>
<td>
Only versions 2.0 through 2.9 supports this feature. Earlier and later versions do not support it.
</td>
</tr>
 
<tr>
<td class=yes>
Unicode
</td>
<td>
This feature works with Unicode characters in all versions of this flavor.
</td>
</tr>
 
<tr>
<td class=yes>
code&nbsp;page
</td>
<td>
This feature works with the characters in the active code&nbsp;page in all versions of this flavor.
</td>
</tr>
 
<tr>
<td class=yes>
ASCII
</td>
<td>
This feature works with ASCII characters only in all versions of this flavor.
</td>
</tr>
 
<tr>
<td class=yes>
3.0 Unicode
</td>
<td>
This feature works with Unicode characters in versions 3.0 and later of this flavor. Earlier versions do not support it at all.
</td>
</tr>
 
<tr>
<td class=yes>
3.0 Unicode
<br>
2.0 ASCII
</td>
<td>
This feature works with Unicode characters in versions 3.0 and later this flavor. It works with ASCII characters in versions 2.0 through 2.9. Earlier versions do not support it at all.
</td>
</tr>
 
<tr>
<td class=yes>
3.0 Unicode
<br>
2.0 code page
</td>
<td>
This feature works with Unicode characters in versions 3.0 and later this flavor. It works with the characters in the active code&nbsp;page in versions 2.0 through 2.9. Earlier versions do not support it at all.
</td>
</tr>
 
<tr>
<td class=yes>
string
</td>
<td>
The regex flavor does not support this syntax. But string literals in the programming language that this regex flavor is normally used with do support this syntax.
</td>
</tr>
 
<tr>
<td class=yes>
3.0
<br>
1.0 string
</td>
<td>
Version 3.0 and later of this regex flavor support this syntax. Earlier versions of the regex flavor do not support this syntax. But string literals in the programming language that this regex flavor is normally used with have supported this syntax since version 1.0.
</td>
</tr>
 
<tr>
<td class=yes>
option
</td>
<td>
All versions of this regex flavor support this feature if you set a particular option or precede it with a particular 
<A HREF="refmodifiers.html" TARGET="_top">
mode modifier
</A>
.
</td>
</tr>
 
<tr>
<td class=yes>
option
<br>
3.0
</td>
<td>
Version 3.0 and all later versions of this regex flavor support this feature if you set a particular option or precede it with a particular 
<A HREF="refmodifiers.html" TARGET="_top">
mode modifier
</A>
. Earlier versions either do not support the syntax at all or do not support the mode modifier to change the behavior of the syntax to what the feature describes.
</td>
</tr>
 
<tr>
<td class=yes>
3.0
<br>
2.0 fail
</td>
<td>
Version 3.0 and all later versions of this regex flavor support this feature. Version 2.0 all later releases prior to 3.0 recognize the syntax, but always fail to match this regex token. Versions prior to 2.0 do not support the syntax.
</td>
</tr>
 
<tr>
<td>
no
</td>
<td>
No version of this flavor support this feature. No indication is given as to what this syntax actually does. The same syntax may be used for a different feature which is indicated elsewhere in the reference table. Or the syntax may trigger an error or it may be interpreted as plain text.
</td>
</tr>
 
<tr>
<td>
n/a
</td>
<td>
This feature is not applicable to this regex flavor. Features that describe the behavior of certain syntax introduced earlier in the reference table show n/a for flavors that do not support that syntax at all.
</td>
</tr>
 
<tr>
<td class=fail>
fail
</td>
<td>
The syntax is recognized by the flavor and regular expressions using it work, but this particular regex token always fails to match. The regex can only find matches if this token is made optional by alternation or a quantifier.
</td>
</tr>
 
<tr>
<td class=fail>
2.0–2.9 fail
</td>
<td>
Versions 2.0 through 2.9 recognize the syntax, but always fail to match this regex token. Earlier and later versions either don't recognize the syntax or treat it as a syntax error.
</td>
</tr>
 
<tr>
<td class=fail>
ignored
</td>
<td>
The syntax is recognized by the flavor but it does not do anything useful. This particular regex token always finds a zero-length match.
</td>
</tr>
 
<tr>
<td class=fail>
error
</td>
<td>
The syntax is recognized by the flavor but it is treated as a syntax error.
</td>
</tr>
 
</table>
 
<p>When this legend says "all versions" or "no version", that means all or none of the versions of each flavor that are covered by the reference tables:</p>
 
<table class=reference>
 
<tr>
<th>
<A HREF="jgsoft.html" TARGET="_top">
JGsoft
</A>
</th>
<td>
V1: EditPad Pro 6 and 7; PowerGREP 3 and 4; AceText 3
<br>
V2: PowerGREP 5
</td>
</tr>
 
<tr>
<th>
<A HREF="dotnet.html" TARGET="_top">
.NET
</A>
</th>
<td>
1.0–4.7.1
</td>
</tr>
 
<tr>
<th>
<A HREF="java.html" TARGET="_top">
Java
</A>
</th>
<td>
4–8
</td>
</tr>
 
<tr>
<th>
<A HREF="perl.html" TARGET="_top">
Perl
</A>
</th>
<td>
5.8–5.26
</td>
</tr>
 
<tr>
<th>
<A HREF="pcre.html" TARGET="_top">
PCRE
</A>
</th>
<td>
4.0–8.41
</td>
</tr>
 
<tr>
<th>
<A HREF="pcre2.html" TARGET="_top">
PCRE2
</A>
</th>
<td>
10.00–10.23
</td>
</tr>
 
<tr>
<th>
<A HREF="php.html" TARGET="_top">
PHP
</A>
</th>
<td>
5.0.0–7.1.14
</td>
</tr>
 
<tr>
<th>
<A HREF="delphi.html" TARGET="_top">
Delphi
</A>
</th>
<td>
XE–XE8 &amp; 10–10.2; TRegEx only; also applies to C++Builder XE–XE8 &amp; 10–10.2
</td>
</tr>
 
<tr>
<th>
<A HREF="rlanguage.html" TARGET="_top">
R
</A>
</th>
<td>
2.14.0–3.4.3
</td>
</tr>
 
<tr>
<th>
<A HREF="javascript.html" TARGET="_top">
JavaScript
</A>
</th>
<td>
Latest versions of Chrome, Edge, and Firefox
</td>
</tr>
 
<tr>
<th>
<A HREF="vbscript.html" TARGET="_top">
VBScript
</A>
</th>
<td>
VBscript and Internet Explorer in quirks mode
</td>
</tr>
 
<tr>
<th>
<A HREF="xregexp.html" TARGET="_top">
XRegExp
</A>
</th>
<td>
2.0.0–3.0.0
</td>
</tr>
 
<tr>
<th>
<A HREF="python.html" TARGET="_top">
Python
</A>
</th>
<td>
2.4–3.6
</td>
</tr>
 
<tr>
<th>
<A HREF="ruby.html" TARGET="_top">
Ruby
</A>
</th>
<td>
1.8–2.5
</td>
</tr>
 
<tr>
<th>
<A HREF="stdregex.html" TARGET="_top">
std::regex
</A>
</th>
<td>
Visual C++ 2008–2017 (Dinkumware 
<tt>
std
</tt>
 library)
</td>
</tr>
 
<tr>
<th>
<A HREF="boost.html" TARGET="_top">
boost::regex
</A>
</th>
<td>
1.38–1.39 & 1.42–1.65
</td>
</tr>
 
<tr>
<th>
<A HREF="tcl.html" TARGET="_top">
Tcl ARE
</A>
</th>
<td>
8.4–8.6
</td>
</tr>
 
<tr>
<th>
<a href="posix.html#bre">
POSIX BRE
</a>
</th>
<td>
IEEE Std 1003.1
</td>
</tr>
 
<tr>
<th>
<a href="posix.html#ere">
POSIX ERE
</a>
</th>
<td>
IEEE Std 1003.1
</td>
</tr>
 
<tr>
<th>
<a href="gnu.html#bre">
GNU BRE
</a>
</th>
<td>
</td>
</tr>
 
<tr>
<th>
<a href="gnu.html#ere">
GNU ERE
</a>
</th>
<td>
</td>
</tr>
 
<tr>
<th>
<A HREF="oracle.html" TARGET="_top">
Oracle
</A>
</th>
<td>
10gR1, 10gR2, 11gR1, 11gR2, 12c
</td>
</tr>
 
<tr>
<th>
<A HREF="xml.html" TARGET="_top">
XML
</A>
</th>
<td>
1.0–1.1
</td>
</tr>
 
<tr>
<th>
<A HREF="xpath.html" TARGET="_top">
XPath
</A>
</th>
<td>
2.0–3.1
</td>
</tr>
 
</table>
 
<p>For the 
<A HREF="dotnet.html" TARGET="_top">
.NET
</A>
 flavor, some features are indicated with "ECMA" or "non-ECMA". That means the feature is only supported when 
<a href="dotnet.html#ecmascript">
RegexOptions.ECMAScript
</a>
 is set or is not set. Features indicated with "non-ECMA Unicode" match ASCII characters when RegexOptions.ECMAScript is set and Unicode characters when RegexOptions.ECMAScript is not set. Everything that applies to .NET 2.0 or later also applies to any version of .NET Core. The Visual Studio IDE uses the non-ECMA .NET flavor starting with VS 2012.</p>
 
<p>For the 
<A HREF="stdregex.html" TARGET="_top">
std::regex
</A>
 and 
<A HREF="boost.html" TARGET="_top">
boost::regex
</A>
 flavor there are additional indicators ECMA, basic, extended, grep, egrep, and awk. When one or more of these appear, that means that the feature is only supported if you specify one of these grammars when compiling your regular expression. Features with Unicode indicators match Unicode characters when using std::wregex or boost::wregex on wide character strings. In the replacement string reference, the additional indicators are sed and default. When either one appears, the feature is only supported when you either pass or don't pass match_flag_type::format_sed to regex_replace(). For boost, there is one more replacement indicator "all" that indicates the feature is only supported when you pass match_flag_type::format_all to regex_replace().</p>
 
<p>For the 
<A HREF="pcre2.html" TARGET="_top">
PCRE2
</A>
 flavor, some replacement string features are indicated with "extended". This means the feature is only supported when you pass 
<a href="pcre2.html#subext">
PCRE2_SUBSTITUTE_EXTENDED
</a>
 to 
<tt>
pcre2_substitute
</tt>
.</p>

</div>

</DIV>

</DIV>
<div class=topad>
<A HREF="//www.regexbuddy.com/benefits.html" TARGET="_top">
<img src="https://www.regular-expressions.info/ads/728/rxbrefreplace100.png" srcset="ads/728/rxbrefreplace100.png 1x, ads/728/rxbrefreplace125.png 1.25x, ads/728/rxbrefreplace150.png 1.5x, ads/728/rxbrefreplace175.png 1.75x, ads/728/rxbrefreplace200.png 2x, ads/728/rxbrefreplace250.png 2.5x, ads/728/rxbrefreplace300.png 3x, ads/728/rxbrefreplace350.png 3.5x, ads/728/rxbrefreplace400.png 4x" alt="RegexBuddy—Better than a regular expression reference!">
</A>
</div>
 
<h1>
Replacement Strings Reference Table of Contents
</h1>
 
<P><A HREF="reference.html" TARGET="_top">
Introduction
</A></P>
 
<P CLASS=indent>
The introduction explains how to read the replacement strings reference tables.</P>
 
<P><A HREF="refreplacecharacters.html" TARGET="_top">
Literal Characters, Special Characters, and Non-Printable Characters
</A></P>
 
<P CLASS=indent>
The simplest replacement text consists of only literal characters. Certain characters have special meanings in replacement strings and have to be escaped. Escaping rules may get a bit complicated when using replacement strings in software source code. Non-printable characters such as control characters and special spacing or line break characters are easier to enter using control character escapes or hexadecimal escapes.</P>
 
<P><A HREF="refreplacebackref.html" TARGET="_top">
Matched Text and Backreferences
</A></P>
 
<p class=indent>
Reinserting the entire regex match into the replacement text allows a search-and-replace to insert text before and after regular expression matches without really replacing anything. Backreferences to 
<A HREF="named.html" TARGET="_top">
named
</A>
 and 
<A HREF="brackets.html" TARGET="_top">
numbered capturing groups
</A>
 in the regular expression allow the replacement text to reuse parts of the text matched by the regular expression.</p>
 
<P><A HREF="refreplacecase.html" TARGET="_top">
Match Context and Case Conversion
</A></P>
 
<p class=indent>
Some applications support special tokens in replacement strings that allow you to insert the subject string or the part of the subject string before or after the regex match. This can be useful when the replacement text syntax is used to collect search matches and their context instead of making replacements in the subject string.</p>
 
<p class=indent>
Some applications can insert the text matched by the regex or by capturing groups converted to uppercase or lowercase.</p>
 
<P><A HREF="refreplaceconditional.html" TARGET="_top">
Conditionals
</A></P>
 
<p class=indent>
Some applications can use one replacement or another replacement depending on whether a capturing group participated in the match. This allows you to use different replacements for different matches of the regular expression.</p>

</DIV>

</DIV>
</div>
<h1>
Books about Regular Expressions
</h1>
 
<ul>
 
<li>
<A HREF="cookbook.html" TARGET="_top">
Regular Expressions Cookbook by Jan Goyvaerts and Steven Levithan
</A>
</li>
 
<li>
<A HREF="book10mins.html" TARGET="_top">
Teach Yourself Regular Expressions in 10 Minutes by Ben Forta
</A>
</li>
 
<li>
<A HREF="hipowls.html" TARGET="_top">
Mastering Regular Expressions by Jeffrey Friedl
</A>
</li>
 
<li>
<A HREF="javabook.html" TARGET="_top">
Java Regular Expressions by Mehran Habibi
</A>
</li>
 
<li>
<A HREF="bookoracleref.html" TARGET="_top">
Oracle Regular Expressions Pocket Reference by Jonathan Gennick &amp; Peter Linsley
</A>
</li>
 
<li>
<A HREF="bookpocket.html" TARGET="_top">
Regular Expression Pocket Reference by Tony Stubblebine
</A>
</li>
 
<li>
<A HREF="bookrecipes.html" TARGET="_top">
Regular Expression Recipes by Nathan Good
</A>
</li>
 
<li>
<A HREF="bookrecipeswin.html" TARGET="_top">
Regular Expression Recipes for Windows Developers by Nathan Good
</A>
</li>
 
</ul>

</DIV>

</DIV>
</div>
<h1>
Printable PDF Download
</h1>
 
<p>The pages on this site are optimized for online reading. They don't print very well. Since many people prefer to read text printed on paper, all the information on this web site is now available as a downloadable PDF file.</p>
   
<p>Before you download the PDF, please 
<A HREF="donate.html" TARGET="_top">
make a donation
</A>
 to support this site first. If you donate 4.99 euro or more, you will be able to download the PDF instantly.</p>
 
<p>The PDF comes in two versions. One version is formatted for easy printing on ordinary letter-sized or A4 paper. The text spans about 300 pages. The other version is formatted on a smaller paper size but with the same font size for easy reading on tablets and e-readers with small screens. This version spans 400 pages. Compared with the cost of a 
<A HREF="books.html" TARGET="_top">
typical paperback on regular expressions
</A>
, 4.99 euro for what is arguably the world's most comprehensive tutorial and reference on regular expressions is certainly a bargain.</p>

</div>

</DIV>
 
</div>
<H1>
The Premier website about Regular Expressions
</h1>
 
<P>On this site, you can find everything you need to know about regular expressions:</P>
 
<UL>
 
<LI>
<A HREF="quickstart.html" TARGET="_top">
A quick start guide bringing you up to speed with regular expressions in no time
</A>
</LI>
 
<LI>
<A HREF="tutorial.html" TARGET="_top">
A complete tutorial teaching you everything about regular expressions
</A>
 and 
<A HREF="replacetutorial.html" TARGET="_top">
replacement strings
</A>
</LI>
 
<LI>
<A HREF="reference.html" TARGET="_top">
A concise reference listing all the regular expression tokens and the flavors that support them
</A>
</LI>
 
<LI>
<A HREF="examples.html" TARGET="_top">
A handy list of ready-to-use example regular expressions
</A>
</LI>
 
<LI>
<A HREF="tools.html" TARGET="_top">
A helpful description of all the popular tools and languages that support regular expressions
</A>
</LI>
 
</UL>
<H2>About The Author</H2>
 
<P>
<A HREF="//www.just-great-software.com/aboutjg.html" TARGET="_top">
Jan Goyvaerts
</A>
 is Chief Software Designer at his own software company 
<A HREF="//www.just-great-software.com/">
Just Great Software
</A>
. Just Great Software develops and publishes various software packages including PowerGREP, RegexBuddy, RegexMagic and EditPad&nbsp;Pro.</P>
 
<P><A HREF="//www.powergrep.com/">
PowerGREP
</A>
 is a knowledge worker's Swiss army knife for searching through, filtering and retrieving information from piles of files using regular expressions. 
<A HREF="//www.regexbuddy.com/">
RegexBuddy
</A>
 is your perfect assistant for working with regular expressions, making it easy to create, test and save regexes. 
<a href="//www.regexmagic.com/">
RegexMagic
</a>
 allows you to generate regular expressions using powerful RegexMagic patterns, without using the cryptic regex syntax at all. 
<A HREF="//www.editpadpro.com/">
EditPad&nbsp;Pro
</A>
 is a popular text editor with particularly strong support for regular expressions.
<br clear=all></P>
 
<a name="feedback">
</a>
<H2>Feedback Form</H2>
 
<P>Feel free to use the form below to send the author your feedback about this site. If you found any errors on the site, feel something is not explained clearly, or if you know of an important regex-related topic not discussed here, please let him know. He tries to reply to inquiries as time allows.</P>
 
<P>Note that this is not a place to request technical support with regular expressions or any regex-related product. If you have a problem with PowerGREP, RegexBuddy, RegexMagic, or EditPad&nbsp;Pro, please use the appropriate technical support contact addresses.</P>
 
<FORM ACTION="cgi-bin/feedback.pl" METHOD=POST>
 
<P>Your email address (if you want a reply):
<BR>
 
<INPUT TYPE=TEXT SIZE=50 NAME=e></P>
 
<P>Your feedback:
<BR>
 
<TEXTAREA ROWS=20 COLS=70 NAME=f>
</TEXTAREA></P>
 
<P><INPUT TYPE=SUBMIT VALUE="Send feedback"></P>
 
</FORM>

</DIV>
 
</div>
<h1>
RSS Feed for Site Updates&mdash;Regex Guru Blog
</h1>
 
<p>This web site wouldn't be the web's premier source of information on regular expressions if it wasn't updated constantly. All new articles are announced on the 
<a href="http://www.regexguru.com">
Regex Guru
</a>
 blog. Subscribe to the 
<a href="http://www.regexguru.com/feed/">
Regex Guru RSS feed
</a>
 if you'd like to stay up-to-date with changes and new additions to your favorite regex site, and with the wonderful world of regular expressions in general. The blog will also give you behind-the-scenes scoops and other news that you won't find on this site.</p>
 
<p>Browser URL: 
<a href="http://www.regexguru.com/feed/">
http://www.regexguru.com/feed/
</a></p>
 
<p>Newsreader URL: 
<a href="feed://www.regexguru.com/feed/">
feed://www.regexguru.com/feed/
</a></p>

</div>

</DIV>
 
<br><br><br><br><br>
<script>
  $(function() {
    var toc = $('#toc>ul');

    function makeLi(text, href) {
      return $('<a href="' + href + '" target="_self">' + text + '</a><br>');
    }

    $('h1').each(function(i) {
      var chapter = $(this), chapterNumber = i + 1;
      toc.append(
        makeLi(chapter.text(), '#chapter-' + chapterNumber)
      );
      chapter.attr('id', 'chapter-' + chapterNumber);
    });

  });
</script>
</body>
</html>
