<base target="_blank">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<style>
body {
 margin: auto;
 width: 80%;
 font-size: 24px;
 background-color: #000000;
 color: #007800;
}
a { text-decoration: none; 
	color: #28B8B8; }
a:visited {	color: #389898; }
A:hover {	color: yellow; }
A:focus {	color: red; }
code { color: #28B8B8;  background-color: #002030}
pre { color: gray;  background-color: #001010;  font-size: 16px; }
img { display: inline-block; width: 900px; margin-top: 2%;margin-bottom: 5%;}
pre { color: gray; background-color: #001010}
div { width: 45%; display: inline-block; padding: 3px; border-radius: 4px; border: 1px solid DarkSlateGray; margin: 3px; vertical-align:top;}
table{
	width: 100%;
	font-size: 22px;
	border-collapse: collapse;
	border: 1px solid gray;
}
th{
	border: 1px solid gray;
	font-weight:bold;
	color: lightgreen;
}
td{
	padding:10px;
	border: 1px dotted dimgray;
}
tr>th:first-child{
}
tr>td:first-child{
	color: lime;
	width:20%;
}

</style>

</head>
<body>
<h3>python Mathematical functions</h3>

<br>
<table>

<tr><td>math.ceil(x)</td><td>Return the ceiling of x as a float, the smallest integer value greater than or equal to x.<br>
<tr><td>math.copysign(x, y)</td><td>Return x with the sign of y. copysign copies the sign bit of an IEEE 754 float, copysign(1, -0.0) returns -1.0.</td></tr>
<tr><td>math.fabs(x)</td><td>Return the absolute value of x.</td></tr>
<tr><td>math.factorial(x)</td><td>Return x factorial. Raises ValueError if x is not integral or is negative.</td></tr>
<tr><td>math.floor(x)</td><td>Return the floor of x as a float, the largest integer value less than or equal to x.</td></tr>
<tr><td>math.fmod(x, y)</td><td>Return fmod(x, y), as defined by the platform C library. Note that the Python expression x % y may not return the same result. The intent of the C standard is that fmod(x, y) be exactly (mathematically; to infinite precision) equal to x - n*y for some integer n such that the result has the same sign as x and magnitude less than abs(y). Python’s x % y returns a result with the sign of y instead, and may not be exactly computable for float arguments. For example, fmod(-1e-100, 1e100) is -1e-100, but the result of Python’s -1e-100 % 1e100 is 1e100-1e-100, which cannot be represented exactly as a float, and rounds to the surprising 1e100. For this reason, function fmod() is generally preferred when working with floats, while Python’s x % y is preferred when working with integers.</td></tr>
<tr><td>math.frexp(x)</td><td>Return the mantissa and exponent of x as the pair (m, e). m is a float and e is an integer such that x == m * 2**e exactly. If x is zero, returns (0.0, 0), otherwise 0.5 <= abs(m) < 1. This is used to “pick apart” the internal representation of a float in a portable way.</td></tr>
<tr><td>math.fsum(iterable)</td><td>Return an accurate floating point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums:<br>
>>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1])<br>
0.99999999999999989<br>
>>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1])<br>
1.0<br></td></tr>
<tr><td>math.isinf(x)</td><td>Checks if the float x is positive or negative infinite.</td></tr>
<tr><td>math.isnan(x)</td><td>Checks if the float x is a NaN (not a number). NaNs are part of the IEEE 754 standards. Operation like but not limited to inf * 0, inf / inf or any operation involving a NaN, e.g. nan * 1, return a NaN.</td></tr>
<tr><td>math.ldexp(x, i)</td><td>Return x * (2**i). This is essentially the inverse of function frexp().</td></tr>
<tr><td>math.modf(x)</td><td>Return the fractional and integer parts of x. Both results carry the sign of x and are floats.</td></tr>
<tr><td>math.trunc(x)</td><td>Return the Real value x truncated to an Integral (usually a long integer). Delegates to x.__trunc__().</td></tr>

<tr><td colspan="2">9.1.2. Power and logarithmic functions</td></tr>
<tr><td>math.exp(x)</td><td>Return e**x.</td></tr>
<tr><td>math.log(x[, base])</td><td>Return the logarithm of x to the given base. If the base is not specified, return the natural logarithm of x (that is, the logarithm to base e).</td></tr>
<tr><td>math.log1p(x)</td><td>Return the natural logarithm of 1+x (base e). The result is calculated in a way which is accurate for x near zero.</td></tr>
<tr><td>math.log10(x)</td><td>Return the base-10 logarithm of x.</td></tr>
<tr><td>math.pow(x, y)</td><td>Return x raised to the power y. Exceptional cases follow Annex ‘F’ of the C99 standard as far as possible. In particular, pow(1.0, x) and pow(x, 0.0) always return 1.0, even when x is a zero or a NaN. If both x and y are finite, x is negative, and y is not an integer then pow(x, y) is undefined, and raises ValueError.</td></tr>
<tr><td>math.sqrt(x)</td><td>Return the square root of x.</td></tr>
<tr><td></td></tr>
<tr><td colspan="2">9.1.3. Trigonometric functions</td></tr>
<tr><td></td></tr>
<tr><td>math.acos(x)</td><td>Return the arc cosine of x, in radians.</td></tr>
<tr><td>math.asin(x)</td><td>Return the arc sine of x, in radians.</td></tr>
<tr><td>math.atan(x)</td><td>Return the arc tangent of x, in radians.</td></tr>
<tr><td>math.atan2(y, x)</td><td>Return atan(y / x), in radians. The result is between -pi and pi. The vector in the plane from the origin to point (x, y) makes this angle with the positive X axis. The point of atan2() is that the signs of both inputs are known to it, so it can compute the correct quadrant for the angle. For example, atan(1) and atan2(1, 1) are both pi/4, but atan2(-1, -1) is -3*pi/4.</td></tr>
<tr><td>math.cos(x)</td><td>Return the cosine of x radians.</td></tr>
<tr><td>math.hypot(x, y)</td><td>Return the Euclidean norm, sqrt(x*x + y*y). This is the length of the vector from the origin to point (x, y).</td></tr>
<tr><td>math.sin(x)</td><td>Return the sine of x radians.</td></tr>
<tr><td>math.tan(x)</td><td>Return the tangent of x radians.</td></tr>
<tr><td></td></tr>
<tr><td colspan="2">9.1.4. Angular conversion</td></tr>
<tr><td></td></tr>
<tr><td>math.degrees(x)</td><td>Converts angle x from radians to degrees.</td></tr>
<tr><td>math.radians(x)</td><td>Converts angle x from degrees to radians.</td></tr>
<tr><td></td></tr>
<tr><td colspan="2">9.1.5. Hyperbolic functions</td></tr>
<tr><td></td></tr>
<tr><td>math.acosh(x)</td><td>Return the inverse hyperbolic cosine of x.</td></tr>
<tr><td>math.asinh(x)</td><td>Return the inverse hyperbolic sine of x.</td></tr>
<tr><td>math.atanh(x)</td><td>Return the inverse hyperbolic tangent of x.</td></tr>
<tr><td>math.cosh(x)</td><td>Return the hyperbolic cosine of x.</td></tr>
<tr><td>math.sinh(x)</td><td>Return the hyperbolic sine of x.</td></tr>
<tr><td>math.tanh(x)</td><td>Return the hyperbolic tangent of x.</td></tr>
<tr><td></td></tr>
<tr><td colspan="2">9.1.6. Constants</td></tr>
<tr><td></td></tr>
<tr><td>math.pi</td><td>The mathematical constant pi.</td></tr>
<tr><td>math.e</td><td>The mathematical constant e.</td></tr>
</table>
Note: The math module consists mostly of thin wrappers around the<br>
platform C math library functions. Behavior in exceptional cases is loosely specified by the C standards, and Python inherits much of its math-function error-reporting behavior from the platform C implementation. As a result, the specific exceptions raised in error cases (and even whether some arguments are considered to be exceptional at all) are not defined in any useful cross-platform or cross-release way. For example, whether math.log(0) returns -Inf or raises ValueError or OverflowError isn’t defined, and in cases where math.log(0) raises OverflowError, math.log(0L)	may raise ValueError instead.All functions return a quiet NaN if at least one of the args is NaN. Signaling NaN*s raise an exception. The exception type still depends on the platform and libm implementation. It’s usually ``ValueError`` for *EDOM and OverflowError for errno ERANGE.<br>

See also:<br>
Module cmath<br>
Complex number versions of many of these functions.<br>
