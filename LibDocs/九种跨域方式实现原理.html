<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width"/>
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script>
$(document).ready(function(){
    $('h1, h2, h3, h4, h5, .goldword, strong,  div.title').click(function(){
    parent.history.back();
    return false;
    });
});
</script>
<style>
body{width:80%;margin-left: 10%}
strong, h1, h2 {color: gold;}
</style>
</head><body>
<center><h1>九种跨域方式实现原理</h1>
<div id="toc"></div></center>
<br>
<br>
<br>

<a href="https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651555851&idx=1&sn=8022abfe1f84b3ac8d29f1d1291b557b&chksm=80255fcab752d6dc44801850a345733c07ecfc731d38fba59443cc29bd1911f3433d54f15c21&scene=0&xtrack=1&pass_ticket=g4Zyt%2BARgLzIMYHqXIxHjza4MN9Dn64GZMnbIE4v4Szj9JR%2FJ2RzuZCckiiNIGV0#rd">九种跨域方式实现原理</a>
<br>
一、什么是跨域？
<h3>1.什么是同源策略及其限制内容？</h3>
<p>
同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击。所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。</p>
<p>
<img src="https://mmbiz.qpic.cn/mmbiz_png/12mPmHVcSunCAg9q4BGdFsUKRp4aibKOpDqBSNqn489wL8NVfia92ggiak9u5YYyERicbE6HySYP9dibCb2EogrJNGQ/640"  />
</p>
<p><strong>同源策略限制内容有：
</strong></p>
<ul>
<li>
<p>
Cookie、LocalStorage、IndexedDB 等存储性内容</p>
</li>
<li>
<p>
DOM 节点</p>
</li>
<li>
<p>
AJAX 请求发送后，结果被浏览器拦截了</p>
</li>
</ul>
<p>
但是有三个标签是允许跨域加载资源：</p>
<pre>
<code>
&lt;img&nbsp;src=XXX&gt;<br>
&lt;link&nbsp;href=XXX&gt;<br>
&lt;script&nbsp;src=XXX&gt;</code>
</pre>
<h3>
2.常见跨域场景</h3>
<p><strong>当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域
</strong>。不同域之间相互请求资源，就算作“跨域”。常见跨域场景如下图所示：
<br></p>
<figure>
<img src="https://mmbiz.qpic.cn/mmbiz_png/12mPmHVcSunCAg9q4BGdFsUKRp4aibKOpia2RSseWaibEtwTKfnIboLEwfJQiaQ2IwYB8FI5BSpaeuPXF46Xcfk4ibg/640"  />
</figure>
<p>
特别说明两点：</p>
<p><strong>第一：如果是协议和端口造成的跨域问题“前台”是无能为力的。
</strong></p>
<p><strong>第二：在跨域问题上，仅仅是通过“URL 的首部”来识别而不会根据域名对应的 IP 地址是否相同来判断。“URL 的首部”可以理解为“协议, 域名和端口必须匹配”
</strong>。</p>
<p>
这里你或许有个疑问：
<strong>请求跨域了，那么请求到底发出去没有？
</strong></p>
<p><strong>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了
</strong>。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会?因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。</p>
<h2>
二、跨域解决方案</h2>
<h3>
1.jsonp</h3>
<h4>
JSONP 原理</h4>
<p>
利用&nbsp;<code>script</code>&nbsp;标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP 请求一定需要对方的服务器做支持才可以。</p>
<h4>
JSONP 和 AJAX 对比</h4>
<p>
JSONP 和 AJAX 相同，都是客户端向服务器端发送请求，从服务器端获取数据的方式。但 AJAX 属于同源策略，JSONP 属于非同源策略（跨域请求）</p>
<h4>
JSONP 优缺点</h4>
<p>
JSONP 优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。
<strong>缺点是仅支持 get 方法具有局限性,不安全可能会遭受 XSS 攻击。
</strong></p>
<h4>
JSONP 的实现流程</h4>
<ul>
<li>
<p>
声明一个回调函数，其函数名(如 show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的 data)。</p>
</li>
<li>
<p>
创建一个<code>
script</code>
标签，把那个跨域的 API 数据接口地址，赋值给 script 的 src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=show）。</p>
</li>
<li>
<p>
服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是 show，它准备好的数据是<code>
show('我不爱你')</code>
。</p>
</li>
<li>
<p>
最后服务器把准备的数据通过 HTTP 协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。</p>
</li>
</ul>
<p>
在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要自己封装一个 JSONP 函数。</p>
<pre>
<code>
//&nbsp;index.html<br>

function&nbsp;jsonp
(
{&nbsp;url,&nbsp;params,&nbsp;callback&nbsp;}
)&nbsp;
{
<br>&nbsp;&nbsp;
return&nbsp;new&nbsp;Promise
((resolve,&nbsp;reject)&nbsp;={
<br>&nbsp;&nbsp;&nbsp;&nbsp;
let
&nbsp;script&nbsp;=&nbsp;
document
.createElement(
'script'
)
<br>&nbsp;&nbsp;&nbsp;&nbsp;
window
[callback]&nbsp;=&nbsp;

function
(
data
)&nbsp;
{
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(data)
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
document
.body.removeChild(script)
<br>&nbsp;&nbsp;&nbsp;&nbsp;}
<br>&nbsp;&nbsp;&nbsp;&nbsp;params&nbsp;=&nbsp;{&nbsp;...params,&nbsp;callback&nbsp;}&nbsp;
//&nbsp;wd=b&amp;callback=show<br>&nbsp;&nbsp;&nbsp;&nbsp;
let
&nbsp;arrs&nbsp;=&nbsp;[]
<br>&nbsp;&nbsp;&nbsp;&nbsp;
for
&nbsp;(
let
&nbsp;key&nbsp;
in
&nbsp;params)&nbsp;{
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arrs.push(
`
${key}=${params[key]}
`
)
<br>&nbsp;&nbsp;&nbsp;&nbsp;}
<br>&nbsp;&nbsp;&nbsp;&nbsp;script.src&nbsp;=&nbsp;
`
${url}
?
${arrs.join(
'&amp;'
)}
`<br>&nbsp;&nbsp;&nbsp;&nbsp;
document
.body.appendChild(script)
<br>&nbsp;&nbsp;})
<br>}
<br>jsonp({
<br>&nbsp;&nbsp;
url
:&nbsp;
'http://localhost:3000/say',<br>&nbsp;&nbsp;
params
:&nbsp;{&nbsp;
wd
:&nbsp;
'Iloveyou'
&nbsp;},
<br>&nbsp;&nbsp;
callback
:&nbsp;
'show'<br>}).then(data&nbsp;={
<br>&nbsp;&nbsp;
console
.log(data)
<br>})
<br>
</code>
</pre>
<p>
上面这段代码相当于向<code>
http://localhost:3000/say?wd=Iloveyou&amp;callback=show</code>
这个地址请求数据，然后后台返回<code>
show('我不爱你')</code>
，最后会运行 show()这个函数，打印出'我不爱你'</p>
<pre>
<code>
//&nbsp;server.js<br>
let
&nbsp;express&nbsp;=&nbsp;
require
(
'express'
)
<br>
let
&nbsp;app&nbsp;=&nbsp;express()
<br>app.get(
'/say'
,&nbsp;

function
(
req,&nbsp;res
)&nbsp;
{
<br>&nbsp;&nbsp;
let
&nbsp;{&nbsp;wd,&nbsp;callback&nbsp;}&nbsp;=&nbsp;req.query
<br>&nbsp;&nbsp;
console
.log(wd)&nbsp;
//&nbsp;Iloveyou<br>&nbsp;&nbsp;
console
.log(callback)&nbsp;
//&nbsp;show<br>&nbsp;&nbsp;res.end(
`
${callback}
('我不爱你')`
)
<br>})
<br>app.listen(
3000
)
<br>
</code>
</pre>
<h4>
5) jQuery 的 jsonp 形式</h4>
<p><strong>JSONP 都是 GET 和异步请求的，不存在其他的请求方式和同步请求，且 jQuery 默认就会给 JSONP 的请求清除缓存。
</strong></p>
<pre>
<code>$.ajax({
<br>
url:"http://crossdomain.com/jsonServerResponse",<br>
dataType
:
"jsonp",<br>
type
:
"get",//可以省略<br>jsonpCallback:
"show",//-&gt;自定义传递给服务器的函数名，而不是使用jQuery自动生成的，可省略<br>jsonp:
"callback",//-&gt;把传递函数名的那个形参callback，可省略<br>success:

function
&nbsp;(
data
)
{
<br>
console
.log(data);}
<br>});
<br>
</code>
</pre>
<h3>
2.cors</h3>
<p><strong>CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现
</strong>。</p>
<p>
浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。</p>
<p>
服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</p>
<p>
虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为
<strong>简单请求
</strong>和
<strong>复杂请求
</strong>。</p>
<h4>
1) 简单请求</h4>
<p>
只要同时满足以下两大条件，就属于简单请求</p>
<p>
条件 1：使用下列方法之一：</p>
<ul>
<li>
<p>
GET</p>
</li>
<li>
<p>
HEAD</p>
</li>
<li>
<p>
POST</p>
</li>
</ul>
<p>
条件 2：Content-Type 的值仅限于下列三者之一：</p>
<ul>
<li>
<p>
text/plain</p>
</li>
<li>
<p>
multipart/form-data</p>
</li>
<li>
<p>
application/x-www-form-urlencoded</p>
</li>
</ul>
<p>
请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器； XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。</p>
<h4>
2) 复杂请求</h4>
<p>
不符合以上条件的请求就肯定是复杂请求了。
<br>复杂请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为"预检"请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。</p>
<p>
我们用<code>
PUT</code>
向后台请求时，属于复杂请求，后台需做如下配置：</p>
<pre>
<code>
//&nbsp;允许哪个方法访问我<br>res.setHeader(
'Access-Control-Allow-Methods'
,&nbsp;
'PUT'
)
<br>
//&nbsp;预检的存活时间<br>res.setHeader(
'Access-Control-Max-Age'
,&nbsp;
6
)
<br>
//&nbsp;OPTIONS请求不做任何处理<br>
if
&nbsp;(req.method&nbsp;===&nbsp;
'OPTIONS'
)&nbsp;{
<br>&nbsp;&nbsp;res.end()
<br>}
<br>
//&nbsp;定义后台返回的内容<br>app.put(
'/getData'
,&nbsp;

function
(
req,&nbsp;res
)&nbsp;
{
<br>&nbsp;&nbsp;
console
.log(req.headers)
<br>&nbsp;&nbsp;res.end(
'我不爱你'
)
<br>})
<br>
</code>
</pre>
<p>
接下来我们看下一个完整复杂请求的例子，并且介绍下 CORS 请求相关的字段</p>
<pre>
<code>
//&nbsp;index.html<br>
let
&nbsp;xhr&nbsp;=&nbsp;
new
&nbsp;XMLHttpRequest()
<br>
document
.cookie&nbsp;=&nbsp;
'name=xiamen'&nbsp;//&nbsp;cookie不能跨域<br>xhr.withCredentials&nbsp;=&nbsp;
true&nbsp;//&nbsp;前端设置是否带cookie<br>xhr.open(
'PUT'
,&nbsp;
'http://localhost:4000/getData'
,&nbsp;
true
)
<br>xhr.setRequestHeader(
'name'
,&nbsp;
'xiamen'
)
<br>xhr.onreadystatechange&nbsp;=&nbsp;

function
()&nbsp;
{
<br>&nbsp;&nbsp;
if
&nbsp;(xhr.readyState&nbsp;===&nbsp;
4
)&nbsp;{
<br>&nbsp;&nbsp;&nbsp;&nbsp;
if
&nbsp;((xhr.status&nbsp;&gt;=&nbsp;
200
&nbsp;&amp;&amp;&nbsp;xhr.status&nbsp;&lt;&nbsp;
300
)&nbsp;||&nbsp;xhr.status&nbsp;===&nbsp;
304
)&nbsp;{
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
console
.log(xhr.response)
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//得到响应头，后台需设置Access-Control-Expose-Headers<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
console
.log(xhr.getResponseHeader(
'name'
))
<br>&nbsp;&nbsp;&nbsp;&nbsp;}
<br>&nbsp;&nbsp;}
<br>}
<br>xhr.send()
<br>
</code>
</pre>
<pre>
<code>
//server1.js<br>
let
&nbsp;express&nbsp;=&nbsp;require(
'express'
);
<br>
let
&nbsp;app&nbsp;=&nbsp;express();
<br>app.use(express.
static
(__dirname));
<br>app.listen(
3000
);
<br>
</code>
</pre>
<pre>
<code>
//server2.js<br>
let
&nbsp;express&nbsp;=&nbsp;
require
(
'express'
)
<br>
let
&nbsp;app&nbsp;=&nbsp;express()
<br>
let
&nbsp;whitList&nbsp;=&nbsp;[
'http://localhost:3000'
]&nbsp;
//设置白名单<br>app.use(

function
(
req,&nbsp;res,&nbsp;next
)&nbsp;
{
<br>&nbsp;&nbsp;
let
&nbsp;origin&nbsp;=&nbsp;req.headers.origin
<br>&nbsp;&nbsp;
if
&nbsp;(whitList.includes(origin))&nbsp;{
<br>&nbsp;&nbsp;&nbsp;&nbsp;
//&nbsp;设置哪个源可以访问我<br>&nbsp;&nbsp;&nbsp;&nbsp;res.setHeader(
'Access-Control-Allow-Origin'
,&nbsp;origin)
<br>&nbsp;&nbsp;&nbsp;&nbsp;
//&nbsp;允许携带哪个头访问我<br>&nbsp;&nbsp;&nbsp;&nbsp;res.setHeader(
'Access-Control-Allow-Headers'
,&nbsp;
'name'
)
<br>&nbsp;&nbsp;&nbsp;&nbsp;
//&nbsp;允许哪个方法访问我<br>&nbsp;&nbsp;&nbsp;&nbsp;res.setHeader(
'Access-Control-Allow-Methods'
,&nbsp;
'PUT'
)
<br>&nbsp;&nbsp;&nbsp;&nbsp;
//&nbsp;允许携带cookie<br>&nbsp;&nbsp;&nbsp;&nbsp;res.setHeader(
'Access-Control-Allow-Credentials'
,&nbsp;
true
)
<br>&nbsp;&nbsp;&nbsp;&nbsp;
//&nbsp;预检的存活时间<br>&nbsp;&nbsp;&nbsp;&nbsp;res.setHeader(
'Access-Control-Max-Age'
,&nbsp;
6
)
<br>&nbsp;&nbsp;&nbsp;&nbsp;
//&nbsp;允许返回的头<br>&nbsp;&nbsp;&nbsp;&nbsp;res.setHeader(
'Access-Control-Expose-Headers'
,&nbsp;
'name'
)
<br>&nbsp;&nbsp;&nbsp;&nbsp;
if
&nbsp;(req.method&nbsp;===&nbsp;
'OPTIONS'
)&nbsp;{
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res.end()&nbsp;
//&nbsp;OPTIONS请求不做任何处理<br>&nbsp;&nbsp;&nbsp;&nbsp;}
<br>&nbsp;&nbsp;}
<br>&nbsp;&nbsp;next()
<br>})
<br>app.put(
'/getData'
,&nbsp;

function
(
req,&nbsp;res
)&nbsp;
{
<br>&nbsp;&nbsp;
console
.log(req.headers)
<br>&nbsp;&nbsp;res.setHeader(
'name'
,&nbsp;
'jw'
)&nbsp;
//返回一个响应头，后台需设置<br>&nbsp;&nbsp;res.end(
'我不爱你'
)
<br>})
<br>app.get(
'/getData'
,&nbsp;

function
(
req,&nbsp;res
)&nbsp;
{
<br>&nbsp;&nbsp;
console
.log(req.headers)
<br>&nbsp;&nbsp;res.end(
'我不爱你'
)
<br>})
<br>app.use(express.static(__dirname))
<br>app.listen(
4000
)
<br>
</code>
</pre>
<p>
上述代码由<code>
http://localhost:3000/index.html</code>
向<code>
http://localhost:4000/</code>
跨域请求，正如我们上面所说的，后端是实现 CORS 通信的关键。</p>
<h3>
3.postMessage</h3>
<p>
postMessage 是 HTML5 XMLHttpRequest Level 2 中的 API，且是为数不多可以跨域操作的 window 属性之一，它可用于解决以下方面的问题：</p>
<ul>
<li>
<p>
页面和其打开的新窗口的数据传递</p>
</li>
<li>
<p>
多窗口之间消息传递</p>
</li>
<li>
<p>
页面与嵌套的 iframe 消息传递</p>
</li>
<li>
<p>
上面三个场景的跨域数据传递</p>
</li>
</ul>
<p><strong>postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递
</strong>。</p>
<p>
otherWindow.postMessage(message, targetOrigin, [transfer]);</p>
<ul>
<li>
<p>
message: 将要发送到其他 window 的数据。</p>
</li>
<li>
<p>
targetOrigin:通过窗口的 origin 属性来指定哪些窗口能接收到消息事件，其值可以是字符串"*"（表示无限制）或者一个 URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配 targetOrigin 提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。</p>
</li>
<li>
<p>
transfer(可选)：是一串和 message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</p>
</li>
</ul>
<p>
接下来我们看个例子：&nbsp;<code>
http://localhost:3000/a.html</code>
页面向<code>
http://localhost:4000/b.html</code>
传递“我爱你”,然后后者传回"我不爱你"。</p>
<pre>
<code>
//&nbsp;a.html<br>&nbsp;&nbsp;&lt;iframe&nbsp;src=
"http://localhost:4000/b.html"
&nbsp;frameborder=
"0"
&nbsp;id=
"frame"
&nbsp;onload=
"load()"
&gt;&lt;/iframe
//等它加载完触发一个事件<br>&nbsp;&nbsp;
//内嵌在http://localhost:3000/a.html<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&gt;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

function&nbsp;()&nbsp;{
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;frame&nbsp;=&nbsp;document.getElementById(
'frame'
)
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;frame.contentWindow.postMessage(
'我爱你'
,&nbsp;
'http://localhost:4000'
)&nbsp;
//发送数据<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window.onmessage&nbsp;=&nbsp;

(e)&nbsp;{&nbsp;
//接受返回数据<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(e.data)&nbsp;
//我不爱你<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/script&gt;
<br>
</code>
</pre>
<pre>
<code>
//&nbsp;b.html<br>&nbsp;&nbsp;
window
.onmessage&nbsp;=&nbsp;

function
(
e
)&nbsp;
{
<br>&nbsp;&nbsp;&nbsp;&nbsp;
console
.log(e.data)&nbsp;
//我爱你<br>&nbsp;&nbsp;&nbsp;&nbsp;e.source.postMessage(
'我不爱你'
,&nbsp;e.origin)
<br>&nbsp;}
<br>
</code>
</pre>
<h3>
4.websocket</h3>
<p>
Websocket 是 HTML5 的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket 和 HTTP 都是应用层协议，都基于 TCP 协议。但是&nbsp;
<strong>WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据
</strong>。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。</p>
<p>
原生 WebSocket API 使用起来不太方便，我们使用<code>
Socket.io</code>
，它很好地封装了 webSocket 接口，提供了更简单、灵活的接口，也对不支持 webSocket 的浏览器提供了向下兼容。</p>
<p>
我们先来看个例子：本地文件 socket.html 向<code>
localhost:3000</code>
发生数据和接受数据</p>
<pre>
<code>//&nbsp;socket.html
<br>
&lt;script
&gt;
<br>&nbsp;&nbsp;&nbsp;&nbsp;
let
&nbsp;socket&nbsp;=&nbsp;
new
&nbsp;WebSocket(
'ws://localhost:3000'
);
<br>&nbsp;&nbsp;&nbsp;&nbsp;socket.onopen&nbsp;=&nbsp;

function
&nbsp;()&nbsp;
{
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket.send(
'我爱你'
);
//向服务器发送数据<br>&nbsp;&nbsp;&nbsp;&nbsp;}
<br>&nbsp;&nbsp;&nbsp;&nbsp;socket.onmessage&nbsp;=&nbsp;

function
&nbsp;(
e
)&nbsp;
{
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
console
.log(e.data);
//接收服务器返回的数据<br>&nbsp;&nbsp;&nbsp;&nbsp;}
<br>&lt;/
script
&gt;<br>
</code>
</pre>
<pre>
<code>
//&nbsp;server.js<br>
let
&nbsp;express&nbsp;=&nbsp;
require
(
'express'
);
<br>
let
&nbsp;app&nbsp;=&nbsp;express();
<br>
let
&nbsp;WebSocket&nbsp;=&nbsp;
require
(
'ws'
);
//记得安装ws<br>
let
&nbsp;wss&nbsp;=&nbsp;
new
&nbsp;WebSocket.Server({
port
:
3000
});
<br>wss.on(
'connection',
function
(
ws
)&nbsp;
{
<br>&nbsp;&nbsp;ws.on(
'message'
,&nbsp;

function
&nbsp;(
data
)&nbsp;
{
<br>&nbsp;&nbsp;&nbsp;&nbsp;
console
.log(data);
<br>&nbsp;&nbsp;&nbsp;&nbsp;ws.send(
'我不爱你'
)
<br>&nbsp;&nbsp;});
<br>})
<br>
</code>
</pre>
<h3>
5. Node 中间件代理(两次跨域)</h3>
<p>
实现原理：
<strong>同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。
</strong>
<br>代理服务器，需要做以下几个步骤：</p>
<ul>
<li>
<p>
接受客户端请求 。</p>
</li>
<li>
<p>
将请求 转发给服务器。</p>
</li>
<li>
<p>
拿到服务器 响应 数据。</p>
</li>
<li>
<p>
将 响应 转发给客户端。<br>
</p>
<figure>
<br>
</figure>
<p>
<img data-copyright="0" src="https://mmbiz.qpic.cn/mmbiz_png/12mPmHVcSunCAg9q4BGdFsUKRp4aibKOpY0jKrYYth8MMIhj2uj9vyqAjZiabOFBaOaUfKBib8bdPXTUkLiaMbzeMA/640"  />
</p>
</li>
</ul>
<p>
我们先来看个例子：本地文件 index.html 文件，通过代理服务器<code>
http://localhost:3000</code>
向目标服务器<code>
http://localhost:4000</code>
请求数据。</p>
<pre>
<code>//&nbsp;index.html(http://127.0.0.1:5500)
<br>&nbsp;
&lt;script&nbsp;src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"
&gt;&lt;/
script
&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;
&lt;script
&gt;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$.ajax({
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
url
:&nbsp;
'http://localhost:3000',<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
type
:&nbsp;
'post',<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
data
:&nbsp;{&nbsp;
name
:&nbsp;
'xiamen'
,&nbsp;
password
:&nbsp;
'123456'
&nbsp;},
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
contentType
:&nbsp;
'application/json;charset=utf-8',<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
success
:&nbsp;

function
(
result
)&nbsp;
{
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
console
.log(result)&nbsp;
//&nbsp;{"title":"fontend","password":"123456"}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
error
:&nbsp;

function
(
msg
)&nbsp;
{
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
console
.log(msg)
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/
script
&gt;<br>
</code>
</pre>
<pre>
<code>
//&nbsp;server1.js&nbsp;代理服务器(http://localhost:3000)<br>
const
&nbsp;http&nbsp;=&nbsp;
require
(
'http'
)
<br>
//&nbsp;第一步：接受客户端请求<br>
const
&nbsp;server&nbsp;=&nbsp;http.createServer((request,&nbsp;response)&nbsp;={
<br>&nbsp;&nbsp;
//&nbsp;代理服务器，直接和浏览器直接交互，需要设置CORS&nbsp;的首部字段<br>&nbsp;&nbsp;response.writeHead(
200
,&nbsp;{
<br>&nbsp;&nbsp;&nbsp;&nbsp;
'Access-Control-Allow-Origin'
:&nbsp;
'*',<br>&nbsp;&nbsp;&nbsp;&nbsp;
'Access-Control-Allow-Methods'
:&nbsp;
'*',<br>&nbsp;&nbsp;&nbsp;&nbsp;
'Access-Control-Allow-Headers'
:&nbsp;
'Content-Type'<br>&nbsp;&nbsp;})
<br>&nbsp;&nbsp;
//&nbsp;第二步：将请求转发给服务器<br>&nbsp;&nbsp;
const
&nbsp;proxyRequest&nbsp;=&nbsp;http
<br>&nbsp;&nbsp;&nbsp;&nbsp;.request(
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
host
:&nbsp;
'127.0.0.1',<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
port
:&nbsp;
4000,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
url
:&nbsp;
'/',<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
method
:&nbsp;request.method,
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
headers
:&nbsp;request.headers
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serverResponse&nbsp;={
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//&nbsp;第三步：收到服务器的响应<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
var
&nbsp;body&nbsp;=&nbsp;
''<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serverResponse.on(
'data'
,&nbsp;chunk&nbsp;={
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;body&nbsp;+=&nbsp;chunk
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serverResponse.on(
'end'
,&nbsp;()&nbsp;={
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
console
.log(
'The&nbsp;data&nbsp;is&nbsp;'
&nbsp;+&nbsp;body)
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//&nbsp;第四步：将响应结果转发给浏览器<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.end(body)
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br>&nbsp;&nbsp;&nbsp;&nbsp;)
<br>&nbsp;&nbsp;&nbsp;&nbsp;.end()
<br>})
<br>server.listen(
3000
,&nbsp;()&nbsp;={
<br>&nbsp;&nbsp;
console
.log(
'The&nbsp;proxyServer&nbsp;is&nbsp;running&nbsp;at&nbsp;http://localhost:3000'
)
<br>})
<br>
</code>
</pre>
<pre>
<code>
//&nbsp;server2.js(http://localhost:4000)<br>
const
&nbsp;http&nbsp;=&nbsp;
require
(
'http'
)
<br>
const
&nbsp;data&nbsp;=&nbsp;{&nbsp;
title
:&nbsp;
'fontend'
,&nbsp;
password
:&nbsp;
'123456'
&nbsp;}
<br>
const
&nbsp;server&nbsp;=&nbsp;http.createServer((request,&nbsp;response)&nbsp;={
<br>&nbsp;&nbsp;
if
&nbsp;(request.url&nbsp;===&nbsp;
'/'
)&nbsp;{
<br>&nbsp;&nbsp;&nbsp;&nbsp;response.end(
JSON
.stringify(data))
<br>&nbsp;&nbsp;}
<br>})
<br>server.listen(
4000
,&nbsp;()&nbsp;={
<br>&nbsp;&nbsp;
console
.log(
'The&nbsp;server&nbsp;is&nbsp;running&nbsp;at&nbsp;http://localhost:4000'
)
<br>})
<br>
</code>
</pre>
<p>
上述代码经过两次跨域，值得注意的是浏览器向代理服务器发送请求，也遵循同源策略，最后在 index.html 文件打印出<code>
{"title":"fontend","password":"123456"}</code>
</p>
<h3>
6.nginx 反向代理</h3>
<p>
实现原理类似于 Node 中间件代理，需要你搭建一个中转 nginx 服务器，用于转发请求。</p>
<p>
使用 nginx 反向代理实现跨域，是最简单的跨域方式。只需要修改 nginx 的配置即可解决跨域问题，支持所有浏览器，支持 session，不需要修改任何代码，并且不会影响服务器性能。</p>
<p>
实现思路：通过 nginx 配置一个代理服务器（域名与 domain1 相同，端口不同）做跳板机，反向代理访问 domain2 接口，并且可以顺便修改 cookie 中 domain 信息，方便当前域 cookie 写入，实现跨域登录。</p>
<p>
先下载nginx，然后将 nginx 目录下的 nginx.conf 修改如下:</p>
<pre>
<code>
//&nbsp;proxy服务器<br>server&nbsp;{
<br>&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
80
;
<br>&nbsp;&nbsp;&nbsp;&nbsp;server_name&nbsp;&nbsp;www.domain1.com;
<br>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/&nbsp;{
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxy_pass&nbsp;&nbsp;&nbsp;http:
//www.domain2.com:8080;&nbsp;&nbsp;#反向代理<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxy_cookie_domain&nbsp;www.domain2.com&nbsp;www.domain1.com;&nbsp;
#修改cookie里域名<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index&nbsp;&nbsp;index.html&nbsp;index.htm;
<br>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add_header&nbsp;Access-Control-Allow-Origin&nbsp;http:
//www.domain1.com;&nbsp;&nbsp;#当前端只跨域不带cookie时，可为*<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add_header&nbsp;Access-Control-Allow-Credentials&nbsp;
true
;
<br>&nbsp;&nbsp;&nbsp;&nbsp;}
<br>}
<br>
</code>
</pre>
<p>
最后通过命令行<code>
nginx -s reload</code>
启动 nginx</p>
<pre>
<code>
//&nbsp;index.html<br>
var
&nbsp;xhr&nbsp;=&nbsp;
new
&nbsp;XMLHttpRequest();
<br>
//&nbsp;前端开关：浏览器是否读写cookie<br>xhr.withCredentials&nbsp;=&nbsp;
true
;
<br>
//&nbsp;访问nginx中的代理服务器<br>xhr.open(
'get'
,&nbsp;
'http://www.domain1.com:81/?user=admin'
,&nbsp;
true
);
<br>xhr.send();
<br>
</code>
</pre>
<pre>
<code>
//&nbsp;server.js<br>
var
&nbsp;http&nbsp;=&nbsp;
require
(
'http'
);
<br>
var
&nbsp;server&nbsp;=&nbsp;http.createServer();
<br>
var
&nbsp;qs&nbsp;=&nbsp;
require
(
'querystring'
);
<br>server.on(
'request'
,&nbsp;

function
(
req,&nbsp;res
)&nbsp;
{
<br>&nbsp;&nbsp;&nbsp;&nbsp;
var
&nbsp;params&nbsp;=&nbsp;qs.parse(req.url.substring(
2
));
<br>&nbsp;&nbsp;&nbsp;&nbsp;
//&nbsp;向前台写cookie<br>&nbsp;&nbsp;&nbsp;&nbsp;res.writeHead(
200
,&nbsp;{
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
'Set-Cookie'
:&nbsp;
'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'
&nbsp;&nbsp;&nbsp;
//&nbsp;HttpOnly:脚本无法读取<br>&nbsp;&nbsp;&nbsp;&nbsp;});
<br>&nbsp;&nbsp;&nbsp;&nbsp;res.write(
JSON
.stringify(params));
<br>&nbsp;&nbsp;&nbsp;&nbsp;res.end();
<br>});
<br>server.listen(
'8080'
);
<br>
console
.log(
'Server&nbsp;is&nbsp;running&nbsp;at&nbsp;port&nbsp;8080...'
);
<br>
</code>
</pre>
<h3>
7.window.name + iframe</h3>
<p>
window.name 属性的独特之处：name 值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</p>
<p>
其中 a.html 和 b.html 是同域的，都是<code>
http://localhost:3000</code>
;而 c.html 是<code>
http://localhost:4000</code>
</p>
<pre>
<code>&nbsp;//&nbsp;a.html(http://localhost:3000/b.html)
<br>&nbsp;&nbsp;
&lt;iframe&nbsp;src="http://localhost:4000/c.html"&nbsp;frameborder="0"&nbsp;onload="load()"&nbsp;id="iframe"
&gt;&lt;/
iframe
&gt;<br>&nbsp;&nbsp;
&lt;script
&gt;
<br>&nbsp;&nbsp;&nbsp;&nbsp;
let
&nbsp;first&nbsp;=&nbsp;
true<br>&nbsp;&nbsp;&nbsp;&nbsp;
//&nbsp;onload事件会触发2次，第1次加载跨域页，并留存数据于window.name<br>&nbsp;&nbsp;&nbsp;&nbsp;

function&nbsp;load
()&nbsp;
{
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if
(first){
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//&nbsp;第1次onload(跨域页)成功后，切换到同域代理页面<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
let
&nbsp;iframe&nbsp;=&nbsp;
document
.getElementById(
'iframe'
);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iframe.src&nbsp;=&nbsp;
'http://localhost:3000/b.html'
;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;first&nbsp;=&nbsp;
false
;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
else
{
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//&nbsp;第2次onload(同域b.html页)成功后，读取同域window.name中数据<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
console
.log(iframe.contentWindow.name);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<br>&nbsp;&nbsp;&nbsp;&nbsp;}
<br>&nbsp;&nbsp;&lt;/
script
&gt;<br>
</code>
</pre>
<p>
b.html 为中间代理页，与 a.html 同域，内容为空。</p>
<pre>
<code>&nbsp;//&nbsp;c.html(http://localhost:4000/c.html)
<br>&nbsp;&nbsp;
&lt;script
&gt;
<br>&nbsp;&nbsp;&nbsp;&nbsp;
window
.name&nbsp;=&nbsp;
'我不爱你'<br>&nbsp;&nbsp;&lt;/
script
&gt;<br>
</code>
</pre>
<p>
总结：通过 iframe 的 src 属性由外域转向本地域，跨域数据即由 iframe 的 window.name 从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p>
<h3>
8.location.hash + iframe</h3>
<p>
实现原理： a.html 欲与 c.html 跨域相互通信，通过中间页 b.html 来实现。 三个页面，不同域之间利用 iframe 的 location.hash 传值，相同域之间直接 js 访问来通信。</p>
<p>
具体实现步骤：一开始 a.html 给 c.html 传一个 hash 值，然后 c.html 收到 hash 值后，再把 hash 值传递给 b.html，最后 b.html 将结果放到 a.html 的 hash 值中。
<br>同样的，a.html 和 b.html 是同域的，都是<code>
http://localhost:3000</code>
;而 c.html 是<code>
http://localhost:4000</code>
</p>
<pre>
<code>&nbsp;//&nbsp;a.html
<br>&nbsp;&nbsp;
&lt;iframe&nbsp;src="http://localhost:4000/c.html#iloveyou"
&gt;&lt;/
iframe
&gt;<br>&nbsp;&nbsp;
&lt;script
&gt;
<br>&nbsp;&nbsp;&nbsp;&nbsp;
window
.onhashchange&nbsp;=&nbsp;

function
&nbsp;()&nbsp;
{&nbsp;
//检测hash的变化<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
console
.log(location.hash);
<br>&nbsp;&nbsp;&nbsp;&nbsp;}
<br>&nbsp;&nbsp;&lt;/
script
&gt;<br>
</code>
</pre>
<pre>
<code>&nbsp;//&nbsp;b.html
<br>&nbsp;&nbsp;
&lt;script
&gt;
<br>&nbsp;&nbsp;&nbsp;&nbsp;
window
.parent.parent.location.hash&nbsp;=&nbsp;location.hash
<br>&nbsp;&nbsp;&nbsp;&nbsp;
//b.html将结果放到a.html的hash值中，b.html可通过parent.parent访问a.html页面<br>&nbsp;&nbsp;&lt;/
script
&gt;<br>
</code>
</pre>
<pre>
<code>&nbsp;
//&nbsp;c.html<br>&nbsp;
console
.log(location.hash);
<br>&nbsp;&nbsp;
let
&nbsp;iframe&nbsp;=&nbsp;
document
.createElement(
'iframe'
);
<br>&nbsp;&nbsp;iframe.src&nbsp;=&nbsp;
'http://localhost:3000/b.html#idontloveyou'
;
<br>&nbsp;&nbsp;
document
.body.appendChild(iframe);
<br>
</code>
</pre>
<h3>
9.document.domain + iframe</h3>
<p><strong>该方式只能用于二级域名相同的情况下，比如&nbsp;
</strong>
<strong>
<code>a.test.com
</code>&nbsp;和&nbsp;
<code>b.test.com
</code>&nbsp;适用于该方式
</strong>。
<br>只需要给页面添加&nbsp;<code>
document.domain ='test.com'</code>
&nbsp;表示二级域名都相同就可以实现跨域。</p>
<p>
实现原理：两个页面都通过 js 强制设置 document.domain 为基础主域，就实现了同域。</p>
<p>
我们看个例子：页面<code>
a.zf1.cn:3000/a.html</code>
获取页面<code>
b.zf1.cn:3000/b.html</code>
中 a 的值</p>
<pre>
<code>//&nbsp;a.html
<br>
&lt;body
&gt;<br>&nbsp;helloa
<br>&nbsp;&nbsp;
&lt;iframe&nbsp;src="http://b.zf1.cn:3000/b.html"&nbsp;frameborder="0"&nbsp;onload="load()"&nbsp;id="frame"
&gt;&lt;/
iframe
&gt;<br>&nbsp;&nbsp;
&lt;script
&gt;
<br>&nbsp;&nbsp;&nbsp;&nbsp;
document
.domain&nbsp;=&nbsp;
'zf1.cn'<br>&nbsp;&nbsp;&nbsp;&nbsp;

function&nbsp;load
()&nbsp;
{
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
console
.log(frame.contentWindow.a);
<br>&nbsp;&nbsp;&nbsp;&nbsp;}
<br>&nbsp;&nbsp;&lt;/
script
&gt;<br>
&lt;/
body
&gt;<br>
</code>
</pre>
<pre>
<code>//&nbsp;b.html
<br>
&lt;body
&gt;<br>&nbsp;&nbsp;&nbsp;hellob
<br>&nbsp;&nbsp;&nbsp;
&lt;script
&gt;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
document
.domain&nbsp;=&nbsp;
'zf1.cn'<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
var
&nbsp;a&nbsp;=&nbsp;
100
;
<br>&nbsp;&nbsp;&nbsp;&lt;/
script
&gt;<br>
&lt;/
body
&gt;<br>
</code>
</pre>
<h2>
三、总结</h2>
<ul>
<li>
<p>
CORS 支持所有类型的 HTTP 请求，是跨域 HTTP 请求的根本解决方案</p>
</li>
<li>
<p>
JSONP 只支持 GET 请求，JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。</p>
</li>
<li>
<p>
不管是 Node 中间件代理还是 nginx 反向代理，主要是通过同源策略对服务器不加限制。</p>
</li>
<li>
<p>
日常工作中，用得比较多的跨域方案是 cors 和 nginx 反向代理</p>
</li>
</ul>
<h2>
参考文章</h2>
<ul>
<li>
<p>
跨域资源共享 CORS 详解</p>
</li>
<li>
<p>
前端面试之道</p>
</li>
<li>
<p>
window.postMessage</p>
</li>
<li>
<p>
前端常见跨域解决方案（全）</p>
</li>
<li>
<p>
深入跨域问题(4) - 利用代理解决跨域
<br>
<br>
<br>
<br>

<script>
	var toc = $('#toc');
	$('h2').each(function(i) {
		var topic = $(this), topicNumber = i + 1;
		toc.append('<a href="#topic-'+topicNumber+'" target="_self">'+topic.text()+'</a><br>');
		topic.attr('id', 'topic-' + topicNumber);
	});
</script>

</body>
</html>
