https://javascript.info
<base target="_blank"><html><head><title>Javascript Tutorial</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src="../lazyload.min.js"></script>
<script type='text/javascript' src='../mainscript.js'></script>
<script>
  var showTopicNumber = true;
  var bookid = "Javascript Tutorial" 
</script>
<style>
body{width:80%;margin-left: 10%; font-size:22px;}
h1, h2 {color: gold;}
strong {color: orange;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px;}
</style></head><body onkeypress="chkKey()"><center>
<h1>Javascript Tutorial</h1>
<a href="#mustWatch" class="red goldbs" target="_self">Must Watch!</a>
<br><br>
<div id="toc"></div></center>
<br><br>
<div id="mustWatch"><center><span class="red">MustWatch</span></center><br>
</div>
<pre>
<br>
<br>

<h2>What is JavaScript?</h2>
<em>JavaScript</em> was initially created to <em>“make webpages alive”</em>.

The programs in this language are called <em>scripts</em>. 
They can be written right in the HTML and execute automatically as the page loads.

Scripts are provided and executed as a plain text. 
They don’t need a special preparation or a compilation to run.

In this aspect, JavaScript is very different from another language called <a href="http://en.wikipedia.org/wiki/Java">Java</a>.

Why <u>Java</u>Script?
When JavaScript was created, it initially had another name: “LiveScript”. 
But Java language was very popular at that time, so it was decided that positioning a new language as a “younger brother” of Java would help.

But as it evolved, JavaScript became a fully independent language, with its own specification called <a href="http://en.wikipedia.org/wiki/ECMAScript">ECMAScript</a>, and now it has no relation to Java at all.

At present, JavaScript can execute not only in the browser, but also on the server, or actually on any device where there exists a special program called <a href="https://en.wikipedia.org/wiki/JavaScript_engine">the JavaScript engine</a>.

The browser has an embedded engine, sometimes it’s also called a “JavaScript virtual machine”.

Different engines have different “codenames”, for example:

<li><a href="https://en.wikipedia.org/wiki/V8_(JavaScript_engine)">V8</a> – in Chrome and Opera.</li><li><a href="https://en.wikipedia.org/wiki/SpiderMonkey">SpiderMonkey</a> – in Firefox.</li><li>…There are other codenames like “Trident”, “Chakra” for different versions of IE, “ChakraCore” for Microsoft Edge, “Nitro” and “SquirrelFish” for Safari etc.</li>

The terms above are good to remember, because they are used in developer articles on the internet. 
We’ll use them too. 
For instance, if “a feature X is supported by V8”, then it probably works in Chrome and Opera.

How engines work?
Engines are complicated. 
But the basics are easy.

<li>The engine (embedded if it’s a browser) reads (“parses”) the script.</li><li>Then it converts (“compiles”) the script to the machine language.</li><li>And then the machine code runs, pretty fast.</li>

The engine applies optimizations on every stage of the process. 
It even watches the compiled script as it runs, analyzes the data that flows through it and applies optimizations to the machine code based on that knowledge. 
At the end, scripts are quite fast.

<h2>What can in-browser JavaScript do?</h2>
The modern JavaScript is a “safe” programming language. 
It does not provide low-level access to memory or CPU, because it was initially created for browsers which do not require it.

The capabilities greatly depend on the environment that runs JavaScript. 
For instance, <a href="https://wikipedia.org/wiki/Node.js">Node.JS</a> supports functions that allow JavaScript to read/write arbitrary files, perform network requests etc.

In-browser JavaScript can do everything related to webpage manipulation, interaction with the user and the webserver.

For instance, in-browser JavaScript is able to:

<li>Add new HTML to the page, change the existing content, modify styles.</li><li>React to user actions, run on mouse clicks, pointer movements, key presses.</li><li>Send requests over the network to remote servers, download and upload files (so-called <a href="https://en.wikipedia.org/wiki/Ajax_(programming)">AJAX</a> and <a href="https://en.wikipedia.org/wiki/Comet_(programming)">COMET</a> technologies).</li><li>Get and set cookies, ask questions to the visitor, show messages.</li><li>Remember the data on the client-side (“local storage”).</li>

<h2>What CAN’T in-browser JavaScript do?</h2>
JavaScript’s abilities in the browser are limited for the sake of the user’s safety. 
The aim is to prevent an evil webpage from accessing private information or harming the user’s data.

The examples of such restrictions are:

JavaScript on a webpage may not read/write arbitrary files on the hard disk, copy them or execute programs. 
It has no direct access to OS system functions.

Modern browsers allow it to work with files, but the access is limited and only provided if the user does certain actions, like “dropping” a file into a browser window or selecting it via an <code>&lt;input&gt;</code> tag.

There are ways to interact with camera/microphone and other devices, but they require a user’s explicit permission. 
So a JavaScript-enabled page may not sneakily enable a web-camera, observe the surroundings and send the information to the <a href="https://en.wikipedia.org/wiki/National_Security_Agency">NSA</a>.

Different tabs/windows generally do not know about each other. 
Sometimes they do, for example when one window uses JavaScript to open the other one. 
But even in this case, JavaScript from one page may not access the other if they come from different sites (from a different domain, protocol or port).

This is called the “Same Origin Policy”. 
To work around that, <em>both pages</em> must contain a special JavaScript code that handles data exchange.

The limitation is again for user’s safety. 
A page from <code>http://anysite.com</code> which a user has opened must not be able to access another browser tab with the URL <code>http://gmail.com</code> and steal information from there.

JavaScript can easily communicate over the net to the server where the current page came from. 
But its ability to receive data from other sites/domains is crippled. 
Though possible, it requires explicit agreement (expressed in HTTP headers) from the remote side. 
Once again, that’s safety limitations.

<img src="https://javascript.info/article/intro/limitations.png">
Such limits do not exist if JavaScript is used outside of the browser, for example on a server. 
Modern browsers also allow installing plugin/extensions which may get extended permissions.

<h2>What makes JavaScript unique?</h2>
There are at least <em>three</em> great things about JavaScript:

<li>Full integration with HTML/CSS.</li><li>Simple things done simply.</li><li>Supported by all major browsers and enabled by default.</li>

Combined, these three things exist only in JavaScript and no other browser technology.

That’s what makes JavaScript unique. 
That’s why it’s the most widespread tool to create browser interfaces.

While planning to learn a new technology, it’s beneficial to check its perspectives. 
So let’s move on to the modern trends that include new languages and browser abilities.

<h2>Languages “over” JavaScript</h2>
The syntax of JavaScript does not suit everyone’s needs. 
Different people want different features.

That’s to be expected, because projects and requirements are different for everyone.

So recently a plethora of new languages appeared, which are <em>transpiled</em> (converted) to JavaScript before they run in the browser.

Modern tools make the transpilation very fast and transparent, actually allowing developers to code in another language and autoconverting it “under the hood”.

Examples of such languages:

<li><a href="http://coffeescript.org/">CoffeeScript</a> is a “syntactic sugar” for JavaScript, it introduces shorter syntax, allowing to write more precise and clear code. 
Usually Ruby devs like it.</li><li><a href="http://www.typescriptlang.org/">TypeScript</a> is concentrated on adding “strict data typing”, to simplify development and support of complex systems. 
It is developed by Microsoft.</li><li><a href="https://www.dartlang.org/">Dart</a> is a standalone language that has its own engine that runs in non-browser environments (like mobile apps). 
It was initially offered by Google as a replacement for JavaScript, but as of now, browsers require it to be transpiled to JavaScript just like the ones above.</li>

There are more. 
Of course even if we use one of those languages, we should also know JavaScript, to really understand what we’re doing.

<h4><a name="summary" href="#summary">Summary</a></h4><li>JavaScript was initially created as a browser-only language, but now it is used in many other environments as well.</li><li>At this moment, JavaScript has a unique position as the most widely-adopted browser language with full integration with HTML/CSS.</li><li>There are many languages that get “transpiled” to JavaScript and provide certain features. 
It is recommended to take a look at them, at least briefly, after mastering JavaScript.</li>

A code editor is the place where programmers spend most of their time.

There are two archetypes: IDE and lightweight editors. 
Many people feel comfortable choosing one tool of each type.

<h2>IDE</h2>
The term <a href="https://en.wikipedia.org/wiki/Integrated_development_environment">IDE</a> (Integrated Development Environment) means a powerful editor with many features that usually operates on a “whole project”. 
As the name suggests, that’s not just an editor, but a full-scale “development environment”.

An IDE loads the project (can be many files), allows navigation between files, provides autocompletion based on the whole project (not just the open file), integrates with a version management system (like <a href="https://git-scm.com/">git</a>), a testing environment and other “project-level” stuff.

If you haven’t considered selecting an IDE yet, look at the following variants:

<li><a href="http://www.jetbrains.com/webstorm/">WebStorm</a> for frontend development and other editors of the same company if you need additional languages.</li><li>Visual Studio is fine if you’re a .NET developer, and a free version is available (<a href="https://www.visualstudio.com/vs/community/">Visual Studio Community</a>)</li><li><a href="http://netbeans.org/">Netbeans</a>.</li>

All of the IDEs except Visual Studio are available on Windows, MacOs and Linux. 
Visual Studio doesn’t work on Linux.

Most IDEs are paid, but have a trial period. 
Their cost is usually negligible compared to a qualified developer’s salary, so just choose the best one for you.

<h2>Lightweight editors</h2>
“Lightweight editors” are not as powerful as IDEs, but they’re fast, elegant and simple.

They are mainly used to instantly open and edit a file.

The main difference between a “lightweight editor” and an “IDE” is that an IDE works on a project-level, so it loads much more data on start, analyzes the project structure if needed and so on. 
A lightweight editor is much faster if we need only one file.

In practice, lightweight editors may have a lot of plugins including directory-level syntax analyzers and autocompleters, so there’s no strict border between a lightweight editor and an IDE.

The following options deserve your attention:

<li><a href="https://code.visualstudio.com/">Visual Studio Code</a> (cross-platform, free).</li><li><a href="https://atom.io/">Atom</a> (cross-platform, free).</li><li><a href="http://www.sublimetext.com">Sublime Text</a> (cross-platform, shareware).</li><li><a href="https://notepad-plus-plus.org/">Notepad++</a> (Windows, free).</li><li><a href="http://www.vim.org/">Vim</a> and <a href="https://www.gnu.org/software/emacs/">Emacs</a> are also cool, if you know how to use them.</li>

<h2>My favorites</h2>
The personal preference of the author is to have both an IDE for projects and a lightweight editor for quick and easy file editing.

I’m using:

<li><a href="http://www.jetbrains.com/webstorm/">WebStorm</a> for JS, and if there is one more language in the project, then I switch to one of the other Jetbrains offerings listed above.</li><li>As a lightweight editor – <a href="http://www.sublimetext.com">Sublime Text</a> or <a href="https://atom.io/">Atom</a>.</li>

<h2>Let’s not argue</h2>
The editors in the lists above are those that either I or my friends who I consider good developers have been using for a long time and are happy with.

There are other great editors in our big world. 
Please choose the one you like the most.

The choice of an editor, like any other tool, is individual and depends on your projects, habits, personal preferences.

Code is prone to errors. 
You are quite likely to make errors… Oh, what am I talking about? You are <em>absolutely</em> going to make errors, at least if you’re a human, not a <a href="https://en.wikipedia.org/wiki/Bender_(Futurama)">robot</a>.

But in the browser, a user doesn’t see the errors by default. 
So, if something goes wrong in the script, we won’t see what’s broken and can’t fix it.

To see errors and get a lot of other useful information about scripts, browsers have embedded “developer tools”.

Most often developers lean towards Chrome or Firefox for development, because those browsers have the best developer tools. 
Other browsers also provide developer tools, sometimes with special features, but are usually playing “catch-up” to Chrome or Firefox. 
So most people have a “favorite” browser and switch to others if a problem is browser-specific.

Developer tools are really powerful, there are many features. 
To start, we’ll learn how to open them, look at errors and run JavaScript commands.

<h2>Google Chrome</h2>
Open the page <a href="/article/devtools/bug.html">bug.html</a>.

There’s an error in the JavaScript code on it. 
It’s hidden from a regular visitor’s eyes, so let’s open developer tools to see it.

Press <kbd>F12</kbd> or, if you’re on Mac, then <kbd>Cmd+Opt+J</kbd>.

The developer tools will open on the Console tab by default.

It looks somewhat like this:

<img src="https://javascript.info/article/devtools/chrome.png">
The exact look of developer tools depends on your version of Chrome. 
It changes from time to time, but should be similar.

<li>Here we can see the red-colored error message. 
In this case the script contains an unknown “lalala” command.</li><li>On the right, there is a clickable link to the source <code>bug.html:12</code> with the line number where the error has occurred.</li>

Below the error message there is a blue <code>&gt;</code> symbol. 
It marks a “command line” where we can type JavaScript commands and press <kbd>Enter</kbd> to run them (<kbd>Shift+Enter</kbd> to input multi-line commands).

Now we can see errors and that’s enough for the start. 
We’ll be back to developer tools later and cover debugging more in-depth in the chapter <a href="/debugging-chrome">Debugging in Chrome</a>.

<h2>Firefox, Edge and others</h2>
Most other browsers use <kbd>F12</kbd> to open developer tools.

The look &amp; feel of them is quite similar. 
Once you know how to use one of them (you can start with Chrome), you can easily switch to another.

<h2>Safari</h2>
Safari (Mac browser, not supported by Windows/Linux) is a little bit special here. 
We need to enable the “Develop menu” first.

Open Preferences and go to “Advanced” pane. 
There’s a checkbox at the bottom:

<img src="https://javascript.info/article/devtools/safari.png">
Now <kbd>Cmd+Opt+C</kbd> can toggle the console. 
Also note that the new top menu item named “Develop” has appeared. 
It has many commands and options.

<h4><a name="summary" href="#summary">Summary</a></h4><li>Developer tools allow us to see errors, run commands, examine variables and much more.</li><li>They can be opened with <kbd>F12</kbd> for most browsers under Windows. 
Chrome for Mac needs <kbd>Cmd+Opt+J</kbd>, Safari: <kbd>Cmd+Opt+C</kbd> (need to enable first).</li>

Now we have the environment ready. 
In the next section we’ll get down to JavaScript.

The tutorial that you’re reading is about core JavaScript, which is platform-independent. 
Further on, you will learn Node.JS and other platforms that use it.

But, we need a working environment to run our scripts, and, just because this book is online, the browser is a good choice. 
We’ll keep the amount of browser-specific commands (like <code>alert</code>) to a minimum, so that you don’t spend time on them if you plan to concentrate on another environment like Node.JS. 
On the other hand, browser details are explained in detail in the <a href="/ui">next part</a> of the tutorial.

So first, let’s see how to attach a script to a webpage. 
For server-side environments, you can just execute it with a command like <code>&quot;node my.js&quot;</code> for Node.JS.

<h2>The “script” tag</h2>
JavaScript programs can be inserted in any part of an HTML document with the help of the <code>&lt;script&gt;</code> tag.

For instance:

    

      <a href="#" title="show" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;body&gt;
  &lt;p&gt;Before the script...&lt;/p&gt;
  &lt;script&gt;
    alert( 'Hello, world!' );
  &lt;/script&gt;
  &lt;p&gt;...After the script.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</code>
  You can run the example by clicking on the “Play” button in its right-top corner.

The <code>&lt;script&gt;</code> tag contains JavaScript code which is automatically executed when the browser meets the tag.

<h2>The modern markup</h2>
The <code>&lt;script&gt;</code> tag has a few attributes that are rarely used nowadays, but we can find them in old code:

<dl>
<dt>The <code>type</code> attribute: <code>&lt;script <u>type</u>=…&gt;</code></dt>
<dd>

The old standard HTML4 required a script to have a type. 
Usually it was <code>type=&quot;text/javascript&quot;</code>. 
The modern HTML standard assumes this <code>type</code> by default. 
No attribute is required.

</dd>
<dt>The <code>language</code> attribute: <code>&lt;script <u>language</u>=…&gt;</code></dt>
<dd>

This attribute was meant to show the language of the script. 
As of now, this attribute makes no sense, the language is JavaScript by default. 
No need to use it.

</dd>
<dt>Comments before and after scripts.</dt>
<dd>

In really ancient books and guides, one may find comments inside <code>&lt;script&gt;</code>, like this:

    <code>&lt;script type=&quot;text/javascript&quot;&gt;&lt;!--
    ...
//--&gt;&lt;/script&gt;</code>
  These comments were supposed to hide the code from an old browser that didn’t know about a <code>&lt;script&gt;</code> tag. 
But all browsers born in the past 15+ years don’t have any issues. 
We mention it here, because such comments serve as a sign. 
If you see that somewhere – that code is probably really old and not worth looking into.

</dd>
</dl>

<h2>External scripts</h2>
If we have a lot of JavaScript code, we can put it into a separate file.

The script file is attached to HTML with the <code>src</code> attribute:

    <code>&lt;script src=&quot;/path/to/script.js&quot;&gt;&lt;/script&gt;</code>
  Here <code>/path/to/script.js</code> is an absolute path to the file with the script (from the site root).

It is also possible to provide a path relative to the current page. 
For instance, <code>src=&quot;script.js&quot;</code> would mean a file <code>&quot;script.js&quot;</code> in the current folder.

We can give a full URL as well, for instance:

    <code>&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js&quot;&gt;&lt;/script&gt;</code>
  To attach several scripts, use multiple tags:

    <code>&lt;script src=&quot;/js/script1.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;/js/script2.js&quot;&gt;&lt;/script&gt;
…</code>
  
Please note:
As a rule, only the simplest scripts are put into HTML. 
More complex ones reside in separate files.

The benefit of a separate file is that the browser will download it and then store in its <a href="https://en.wikipedia.org/wiki/Web_cache">cache</a>.

After this, other pages that want the same script will take it from the cache instead of downloading it. 
So the file is actually downloaded only once.

That saves traffic and makes pages faster.

If <code>src</code> is set, the script content is ignored.
A single <code>&lt;script&gt;</code> tag can’t have both the <code>src</code> attribute and the code inside.

This won’t work:

    <code>&lt;script src=&quot;file.js&quot;&gt;
  alert(1); // the content is ignored, because src is set
&lt;/script&gt;</code>
  We must choose: either it’s an external <code>&lt;script src=&quot;…&quot;&gt;</code> or a regular <code>&lt;script&gt;</code> with code.

The example above can be split into two scripts to work:

    <code>&lt;script src=&quot;file.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  alert(1);
&lt;/script&gt;</code>
  
<h4><a name="summary" href="#summary">Summary</a></h4><li>We can use a <code>&lt;script&gt;</code> tag to add JavaScript code to the page.</li><li>The <code>type</code> and <code>language</code> attributes are not required.</li><li>A script in an external file can be inserted with <code>&lt;script src=&quot;path/to/script.js&quot;&gt;&lt;/script&gt;</code>.</li>

There is much more to learn about browser scripts and their interaction with the web-page. 
But let’s keep in mind that this part of the tutorial is devoted to the JavaScript language, so we shouldn’t distract ourselves from it. 
We’ll be using a browser as a way to run JavaScript, which is very convenient for online reading, but yet one of many.

Do it in a sandbox, or on your hard drive, doesn’t matter, just ensure that it works.

<a href="https://en.js.cx/task/hello-alert/solution/" target="blank">Demo in new window</a>
<button type="button">solution</button>

<a href="http://plnkr.co/edit/5AmOR7Hcp4NwWZ4qbMDE?p=preview" target="_blank" data-plunk-id="5AmOR7Hcp4NwWZ4qbMDE">Open the solution in the sandbox.</a>
<button type="button" title="close"></button>

<h3><a href="#show-an-alert-with-an-external-script" name="show-an-alert-with-an-external-script">Show an alert with an external script</a></h3><a href="/task/hello-alert-ext" target="_blank"></a>

importance: 5

Take the solution of the previous task <a href="/task/hello-alert">Show an alert</a>. 
Modify it by extracting the script content into an external file <code>alert.js</code>, residing in the same folder.

Open the page, ensure that the alert works.

<button type="button">solution</button>

The HTML code:

    <code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;
  &lt;script src=&quot;alert.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code>
  For the file <code>alert.js</code> in the same folder:

    <code>alert(&quot;I'm JavaScript!&quot;);</code>
  <button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/first-steps" data-tooltip="JavaScript Fundamentals">Previous lesson</a><a href="/structure" data-tooltip="Code structure">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Fhello-world"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Fhello-world"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Fhello-world"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Fhello-world"></a>

The first thing to study is the building blocks of the code.

<h2>Statements</h2>
Statements are syntax constructs and commands that perform actions.

We’ve already seen a statement <code>alert('Hello, world!')</code>, which shows the message.

We can have as many statements in the code as we want. 
Another statement can be separated with a semicolon.

For example, here we split the message into two:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert('Hello'); alert('World');</code>
  Usually each statement is written on a separate line – thus the code becomes more readable:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert('Hello');
alert('World');</code>
  <h2>Semicolons</h2>
A semicolon may be omitted in most cases when a line break exists.

This would also work:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert('Hello')
alert('World')</code>
  Here JavaScript interprets the line break as an “implicit” semicolon. 
That’s also called an <a href="https://tc39.github.io/ecma262/#sec-automatic-semicolon-insertion">automatic semicolon insertion</a>.

<strong>In most cases a newline implies a semicolon. 
But “in most cases” does not mean “always”!</strong>

There are cases when a newline does not mean a semicolon, for example:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert(3 +
1
+ 2);</code>
  The code outputs <code>6</code>, because JavaScript does not insert semicolons here. 
It is intuitively obvious that if the line ends with a plus <code>&quot;+&quot;</code>, then it is an “incomplete expression”, no semicolon required. 
And in this case that works as intended.

<strong>But there are situations where JavaScript “fails” to assume a semicolon where it is really needed.</strong>

Errors which occur in such cases are quite hard to find and fix.

An example of an error
If you’re curious to see a concrete example of such an error, check this code out:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>[1, 2].forEach(alert)</code>
  No need to think about the meaning of the brackets <code>[]</code> and <code>forEach</code> yet. 
We’ll study them later, for now it does not matter. 
Let’s just remember the result: it shows <code>1</code>, then <code>2</code>.

Now let’s add an <code>alert</code> before the code and <em>not</em> finish it with a semicolon:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert(&quot;There will be an error&quot;)
[1, 2].forEach(alert)</code>
  Now if we run it, only the first <code>alert</code> is shown, and then we have an error!

But everything is fine again if we add a semicolon after <code>alert</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert(&quot;All fine now&quot;);
[1, 2].forEach(alert)</code>
  Now we have the “All fine now” message and then <code>1</code> and <code>2</code>.

The error in the no-semicolon variant occurs because JavaScript does not imply a semicolon before square brackets <code>[...]</code>.

So, because the semicolon is not auto-inserted, the code in the first example is treated as a single statement. 
That’s how the engine sees it:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert(&quot;There will be an error&quot;)[1, 2].forEach(alert)</code>
  But it should be two separate statements, not a single one. 
Such a merging in this case is just wrong, hence the error. 
There are other situations when such a thing happens.

It’s recommended to put semicolons between statements even if they are separated by newlines. 
This rule is widely adopted by the community. 
Let’s note once again – <em>it is possible</em> to leave out semicolons most of the time. 
But it’s safer – especially for a beginner – to use them.

<h2>Comments</h2>
As time goes on, the program becomes more and more complex. 
It becomes necessary to add <em>comments</em> which describe what happens and why.

Comments can be put into any place of the script. 
They don’t affect the execution, because the engine simply ignores them.

<strong>One-line comments start with two forward slash characters <code>//</code>.</strong>

The rest of the line is a comment. 
It may occupy a full line of its own or follow a statement.

Like here:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// This comment occupies a line of its own
alert('Hello');
alert('World'); // This comment follows the statement</code>
  <strong>Multiline comments start with a forward slash and an asterisk <code>/*</code> and end with an asterisk and a forward slash <code>*/</code>.</strong>

Like this:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>/* An example with two messages.
This is a multiline comment.
*/
alert('Hello');
alert('World');</code>
  The content of comments is ignored, so if we put code inside <code>/* … */</code> it won’t execute.

Sometimes it comes in handy to temporarily disable a part of code:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>/* Commenting out the code
alert('Hello');
*/
alert('World');</code>
  
Use hotkeys!
In most editors a line of code can be commented out by <kbd>Ctrl+/</kbd> hotkey for a single-line comment and something like <kbd>Ctrl+Shift+/</kbd> – for multiline comments (select a piece of code and press the hotkey). 
For Mac try <kbd>Cmd</kbd> instead of <kbd>Ctrl</kbd>.

Nested comments are not supported!
There may not be <code>/*...*/</code> inside another <code>/*...*/</code>.

Such code will die with an error:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>/*
  /* nested comment ?!? */
*/
alert( 'World' );</code>
  
Please, don’t hesitate to comment your code.

Comments increase the overall code footprint, but that’s not a problem at all. 
There are many tools which minify the code before publishing to the production server. 
They remove comments, so they don’t appear in the working scripts. 
Therefore comments do not have any negative effects on production at all.

Further in the tutorial, there will be a chapter <a href="/coding-style">Coding style</a> that also explains how to write better comments.

For a long time JavaScript was evolving without compatibility issues. 
New features were added to the language, but the old functionality did not change.

That had the benefit of never breaking existing code. 
But the downside was that any mistake or an imperfect decision made by JavaScript creators got stuck in the language forever.

It had been so until 2009 when ECMAScript 5 (ES5) appeared. 
It added new features to the language and modified some of the existing ones. 
To keep the old code working, most modifications are off by default. 
One needs to enable them explicitly with a special directive <code>&quot;use strict&quot;</code>.

<h2>“use strict”</h2>
The directive looks like a string: <code>&quot;use strict&quot;</code> or <code>'use strict'</code>. 
When it is located on the top of the script, then the whole script works the “modern” way.

For example

    <code>&quot;use strict&quot;;
// this code works the modern way
...</code>
  We will learn functions (a way to group commands) soon.

Looking ahead let’s just note that <code>&quot;use strict&quot;</code> can be put at the start of a function (most kinds of functions) instead of the whole script. 
Then strict mode is enabled in that function only. 
But usually people use it for the whole script.

Ensure that “use strict” is at the top
Please make sure that <code>&quot;use strict&quot;</code> is on the top of the script, otherwise the strict mode may not be enabled.

There is no strict mode here:

    <code>alert(&quot;some code&quot;);
// &quot;use strict&quot; below is ignored, must be on the top
&quot;use strict&quot;;
// strict mode is not activated</code>
  Only comments may appear above <code>&quot;use strict&quot;</code>.

There’s no way to cancel <code>use strict</code>
There is no directive <code>&quot;no use strict&quot;</code> or alike, that would return the old behavior.

Once we enter the strict mode, there’s no return.

<h2>Always “use strict”</h2>
The differences of <code>&quot;use strict&quot;</code> versus the “default” mode are still to be covered.

In the next chapters, as we learn language features, we’ll make notes about the differences of the strict mode. 
Luckily, there are not so many. 
And they actually make our life better.

At this point in time it’s enough to know about it in general:

<li>The <code>&quot;use strict&quot;</code> directive switches the engine to the “modern” mode, changing the behavior of some built-in features. 
We’ll see the details as we study.</li><li>The strict mode is enabled by <code>&quot;use strict&quot;</code> at the top. 
Also there are several language features like “classes” and “modules” that enable strict mode automatically.</li><li>The strict mode is supported by all modern browsers.</li><li>It’s always recommended to start scripts with <code>&quot;use strict&quot;</code>. 
All examples in this tutorial assume so, unless (very rarely) specified otherwise.</li>

Most of the time, a JavaScript application needs to work with information. 
Here are 2 examples:

<li>An online-shop – the information might include goods being sold and a shopping cart.</li><li>A chat application – the information might include users, messages, and much more.</li>

Variables are used to store this information.

<h2>A variable</h2>
A <a href="https://en.wikipedia.org/wiki/Variable_(computer_science)">variable</a> is a “named storage” for data. 
We can use variables to store goodies, visitors and other data.

To create a variable in JavaScript, we need to use the <code>let</code> keyword.

The statement below creates (in other words: <em>declares</em> or <em>defines</em>) a variable with the name “message”:

    <code>let message;</code>
  Now we can put some data into it by using the assignment operator <code>=</code>:

    <code>let message;
message = 'Hello'; // store the string</code>
  The string is now saved into the memory area associated with the variable. 
We can access it using the variable name:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let message;
message = 'Hello!';
alert(message); // shows the variable content</code>
  To be concise we can merge the variable declaration and assignment into a single line:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let message = 'Hello!'; // define the variable and assign the value
alert(message); // Hello!</code>
  We can also declare multiple variables in one line:

    <code>let user = 'John', age = 25, message = 'Hello';</code>
  That might seem shorter, but it’s not recommended. 
For the sake of better readability, please use a single line per variable.

The multiline variant is a bit longer, but easier to read:

    <code>let user = 'John';
let age = 25;
let message = 'Hello';</code>
  Some people also write many variables like that:

    <code>let user = 'John',
  age = 25,
  message = 'Hello';</code>
  …Or even in the “comma-first” style:

    <code>let user = 'John'
  , age = 25
  , message = 'Hello';</code>
  Technically, all these variants do the same. 
So, it’s a matter of personal taste and aesthetics.

<code>var</code> instead of <code>let</code>
In older scripts you may also find another keyword: <code>var</code> instead of <code>let</code>:

    <code>var message = 'Hello';</code>
  The <code>var</code> keyword is <em>almost</em> the same as <code>let</code>. 
It also declares a variable, but in a slightly different, “old-school” fashion.

There are subtle differences between <code>let</code> and <code>var</code>, but they do not matter for us yet. 
We’ll cover them in detail later, in the chapter <a href="/var">The old &quot;var&quot;</a>.

<h2>A real-life analogy</h2>
We can easily grasp the concept of a “variable” if we imagine it as a “box” for data, with a uniquely-named sticker on it.

For instance, the variable <code>message</code> can be imagined as a box labeled <code>&quot;message&quot;</code> with the value <code>&quot;Hello!&quot;</code> in it:

<img src="https://javascript.info/article/variables/variable.png">
We can put any value into the box.

Also we can change it. 
The value can be changed as many times as needed:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let message;
message = 'Hello!';
message = 'World!'; // value changed
alert(message);</code>
  When the value is changed, the old data is removed from the variable:

<img src="https://javascript.info/article/variables/variable-change.png">
We can also declare two variables and copy data from one into the other.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let hello = 'Hello world!';
let message;
// copy 'Hello world' from hello into message
message = hello;
// now two variables hold the same data
alert(hello); // Hello world!
alert(message); // Hello world!</code>
  
Functional languages
It may be interesting to know that there also exist <a href="https://en.wikipedia.org/wiki/Functional_programming">functional</a> programming languages that forbid changing a variable value. 
For example, <a href="http://www.scala-lang.org/">Scala</a> or <a href="http://www.erlang.org/">Erlang</a>.

In such languages, once the value is stored “in the box”, it’s there forever. 
If we need to store something else, the language forces us to create a new box (declare a new variable). 
We can’t reuse the old one.

Though it may seem a little bit odd at first sight, these languages are quite capable of serious development. 
More than that, there are areas like parallel computations where this limitation confers certain benefits. 
Studying such a language (even if not planning to use it soon) is recommended to broaden the mind.

<h2>Variable naming</h2>
There are two limitations for a variable name in JavaScript:

<li>The name must contain only letters, digits, symbols <code>$</code> and <code>_</code>.</li><li>The first character must not be a digit.</li>

Valid names, for instance:

    <code>let userName;
let test123;</code>
  When the name contains multiple words, <a href="https://en.wikipedia.org/wiki/CamelCase">camelCase</a> is commonly used. 
That is: words go one after another, each word starts with a capital letter: <code>myVeryLongName</code>.

What’s interesting – the dollar sign <code>'$'</code> and the underscore <code>'_'</code> can also be used in names. 
They are regular symbols, just like letters, without any special meaning.

These names are valid:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let $ = 1; // declared a variable with the name &quot;$&quot;
let _ = 2; // and now a variable with the name &quot;_&quot;
alert($ + _); // 3</code>
  Examples of incorrect variable names:

    <code>let 1a; // cannot start with a digit
let my-name; // a hyphen '-' is not allowed in the name</code>
  
Case matters
Variables named <code>apple</code> and <code>AppLE</code> – are two different variables.

Non-english letters are allowed, but not recommended
It is possible to use any language, including cyrillic letters or even hieroglyphs, like this:

    <code>let имя = '...';
let 我 = '...';</code>
  Technically, there is no error here, such names are allowed, but there is an international tradition to use English in variable names. 
Even if we’re writing a small script, it may have a long life ahead. 
People from other countries may need to read it some time.

Reserved names
There is a list of reserved words, which cannot be used as variable names, because they are used by the language itself.

For example, words <code>let</code>, <code>class</code>, <code>return</code>, <code>function</code> are reserved.

The code below gives a syntax error:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let let = 5; // can't name a variable &quot;let&quot;, error!
let return = 5; // also can't name it &quot;return&quot;, error!</code>
  

An assignment without <code>use strict</code>
Normally, we need to define a variable before using it. 
But in the old times, it was technically possible to create a variable by a mere assignment of the value, without <code>let</code>. 
This still works now if we don’t put <code>use strict</code>. 
The behavior is kept for compatibility with old scripts.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// note: no &quot;use strict&quot; in this example
num = 5; // the variable &quot;num&quot; is created if didn't exist
alert(num); // 5</code>
  That’s a bad practice, it gives an error in the strict mode:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>&quot;use strict&quot;;
num = 5; // error: num is not defined</code>
  
<h2>Constants</h2>
To declare a constant (unchanging) variable, one can use <code>const</code> instead of <code>let</code>:

    <code>const myBirthday = '18.04.1982';</code>
  Variables declared using <code>const</code> are called “constants”. 
They cannot be changed. 
An attempt to do it would cause an error:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>const myBirthday = '18.04.1982';
myBirthday = '01.01.2001'; // error, can't reassign the constant!</code>
  When a programmer is sure that the variable should never change, he can use <code>const</code> to guarantee it, and also to clearly show that fact to everyone.

<h3><a name="uppercase-constants" href="#uppercase-constants">Uppercase constants</a></h3>
There is a widespread practice to use constants as aliases for difficult-to-remember values that are known prior to execution.

Such constants are named using capital letters and underscores.

Like this:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>const COLOR_RED = &quot;#F00&quot;;
const COLOR_GREEN = &quot;#0F0&quot;;
const COLOR_BLUE = &quot;#00F&quot;;
const COLOR_ORANGE = &quot;#FF7F00&quot;;
// ...when we need to pick a color
let color = COLOR_ORANGE;
alert(color); // #FF7F00</code>
  Benefits:

<li><code>COLOR_ORANGE</code> is much easier to remember than <code>&quot;#FF7F00&quot;</code>.</li><li>It is much easier to mistype in <code>&quot;#FF7F00&quot;</code> than in <code>COLOR_ORANGE</code>.</li><li>When reading the code, <code>COLOR_ORANGE</code> is much more meaningful than <code>#FF7F00</code>.</li>

When should we use capitals for a constant, and when should we name them normally? Let’s make that clear.

Being a “constant” just means that the value never changes. 
But there are constants that are known prior to execution (like a hexadecimal value for red), and there are those that are <em>calculated</em> in run-time, during the execution, but do not change after the assignment.

For instance:

    <code>const pageLoadTime = /* time taken by a webpage to load */;</code>
  The value of <code>pageLoadTime</code> is not known prior to the page load, so it’s named normally. 
But it’s still a constant, because it doesn’t change after assignment.

In other words, capital-named constants are only used as aliases for “hard-coded” values.

<h2>Name things right</h2>
Talking about variables, there’s one more extremely important thing.

Please name the variables sensibly. 
Take time to think if needed.

Variable naming is one of the most important and complex skills in programming. 
A quick glance at variable names can reveal which code is written by a beginner and which by an experienced developer.

In a real project, most of the time is spent on modifying and extending the existing code base, rather than writing something completely separate from scratch. 
And when we return to the code after some time of doing something else, it’s much easier to find information that is well-labeled. 
Or, in other words, when the variables have good names.

Please spend some time thinking about the right name for a variable before declaring it. 
This will repay you a lot.

Some good-to-follow rules are:

<li>Use human-readable names like <code>userName</code> or <code>shoppingCart</code>.</li><li>Stay away from abbreviations or short names like <code>a</code>, <code>b</code>, <code>c</code>, unless you really know what you’re doing.</li><li>Make the name maximally descriptive and concise. 
Examples of bad names are <code>data</code> and <code>value</code>. 
Such a name says nothing. 
It is only ok to use them if it’s exceptionally obvious from the context which data or value is meant.</li><li>Agree on terms within your team and in your own mind. 
If a site visitor is called a “user” then we should name related variables like <code>currentUser</code> or <code>newUser</code>, but not <code>currentVisitor</code> or a <code>newManInTown</code>.</li>

Sounds simple? Indeed it is, but creating good descriptive-and-concise names in practice is not. 
Go for it.

Reuse or create?
And the last note. 
There are some lazy programmers who, instead of declaring a new variable, tend to reuse the existing ones.

As a result, the variable is like a box where people throw different things without changing the sticker. 
What is inside it now? Who knows… We need to come closer and check.

Such a programmer saves a little bit on variable declaration, but loses ten times more on debugging the code.

An extra variable is good, not evil.

Modern JavaScript minifiers and browsers optimize code well enough, so it won’t create performance issues. 
Using different variables for different values can even help the engine to optimize.

<h4><a name="summary" href="#summary">Summary</a4</h2>
We can declare variables to store data. 
That can be done using <code>var</code> or <code>let</code> or <code>const</code>.

<li><code>let</code> – is a modern variable declaration. 
The code must be in strict mode to use <code>let</code> in Chrome (V8).</li><li><code>var</code> – is an old-school variable declaration. 
Normally we don’t use it at all, but we’ll cover subtle differences from <code>let</code> in the chapter <a href="/var">The old &quot;var&quot;</a>, just in case you need them.</li><li><code>const</code> – is like <code>let</code>, but the value of the variable can’t be changed.</li>

Variables should be named in a way that allows us to easily understand what’s inside.

<li>Declare two variables: <code>admin</code> and <code>name</code>.</li><li>Assign the value <code>&quot;John&quot;</code> to <code>name</code>.</li><li>Copy the value from <code>name</code> to <code>admin</code>.</li><li>Show the value of <code>admin</code> using <code>alert</code> (must output “John”).</li>

<button type="button">solution</button>

In the code below, each line corresponds to the item in the task list.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let admin, name; // can declare two variables at once
name = &quot;John&quot;;
admin = name;
alert( admin ); // &quot;John&quot;</code>
  <button type="button" title="close"></button>

<h3><a href="#giving-the-right-name" name="giving-the-right-name">Giving the right name</a></h3><a href="/task/declare-variables" target="_blank"></a>

importance: 3

<li>Create the variable with the name of our planet. 
How would you name such a variable?</li><li>Create the variable to store the name of the current visitor. 
How would you name that variable?</li>

<button type="button">solution</button>

First, the variable for the name of our planet.

That’s simple:

    <code>let ourPlanetName = &quot;Earth&quot;;</code>
  Note, we could use a shorter name <code>planet</code>, but it might be not obvious what planet it refers to. 
It’s nice to be more verbose. 
At least until the variable isNotTooLong.

Second, the name of the current visitor:

    <code>let currentUserName = &quot;John&quot;;</code>
  Again, we could shorten that to <code>userName</code> if we know for sure that the user is current.

Modern editors and autocomplete make long variable names easy to write. 
Don’t save on them. 
A name with 3 words in it is fine.

And if your editor does not have proper autocompletion, get <a href="/editors">a new one</a>.

<button type="button" title="close"></button>

<h3><a href="#uppercase-const" name="uppercase-const">Uppercase const?</a></h3><a href="/task/uppercast-constant" target="_blank"></a>

importance: 4

Examine the following code:

    <code>const birthday = '18.04.1982';
const age = someCode(birthday);</code>
  Here we have a constant <code>birthday</code> date and the <code>age</code> is calculated from <code>birthday</code> with the help of some code (it is not provided for shortness, and because details don’t matter here).

Would it be right to use upper case for <code>birthday</code>? For <code>age</code>? Or even for both?

    <code>const BIRTHDAY = '18.04.1982'; // make uppercase?
const AGE = someCode(BIRTHDAY); // make uppercase?</code>
  <button type="button">solution</button>

We generally use upper case for constants that are “hard-coded”. 
Or, in other words, when the value is known prior to execution and directly written into the code.

In this code, <code>birthday</code> is exactly like that. 
So we could use the upper case for it.

In contrast, <code>age</code> is evaluated in run-time. 
Today we have one age, a year after we’ll have another one. 
It is constant in a sense that it does not change through the code execution. 
But it is a bit “less of a constant” than <code>birthday</code>, it is calculated, so we should keep the lower case for it.

<button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/strict-mode" data-tooltip="The modern mode, &quot;use strict&quot;">Previous lesson</a><a href="/types" data-tooltip="Data types">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Fvariables"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Fvariables"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Fvariables"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Fvariables"></a>

A variable in JavaScript can contain any data. 
A variable can at one moment be a string and later receive a numeric value:

    <code>// no error
let message = &quot;hello&quot;;
message = 123456;</code>
  Programming languages that allow such things are called “dynamically typed”, meaning that there are data types, but variables are not bound to any of them.

There are seven basic data types in JavaScript. 
Here we’ll study the basics, and in the next chapters we’ll talk about each of them in detail.

<h2>A number</h2>

    <code>let n = 123;
n = 12.345;</code>
  The <em>number</em> type serves both for integer and floating point numbers.

There are many operations for numbers, e.g. 
multiplication <code>*</code>, division <code>/</code>, addition <code>+</code>, subtraction <code>-</code> and so on.

Besides regular numbers, there are so-called “special numeric values” which also belong to that type: <code>Infinity</code>, <code>-Infinity</code> and <code>NaN</code>.

<li><code>Infinity</code> represents the mathematical <a href="https://en.wikipedia.org/wiki/Infinity">Infinity</a> ∞. 
It is a special value that’s greater than any number.

We can get it as a result of division by zero:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( 1 / 0 ); // Infinity</code>
  Or just mention it in the code directly:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( Infinity ); // Infinity</code>
  </li><li><code>NaN</code> represents a computational error. 
It is a result of an incorrect or an undefined mathematical operation, for instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( &quot;not a number&quot; / 2 ); // NaN, such division is erroneous</code>
  <code>NaN</code> is sticky. 
Any further operation on <code>NaN</code> would give <code>NaN</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( &quot;not a number&quot; / 2 + 5 ); // NaN</code>
  So, if there’s <code>NaN</code> somewhere in a mathematical expression, it propagates to the whole result.

</li>

Mathematical operations are safe
Doing maths is safe in JavaScript. 
We can do anything: divide by zero, treat non-numeric strings as numbers, etc.

The script will never stop with a fatal error (“die”). 
At worst we’ll get <code>NaN</code> as the result.

Special numeric values formally belong to the “number” type. 
Of course they are not numbers in a common sense of this word.

We’ll see more about working with numbers in the chapter <a href="/number">Numbers</a>.

<h2>A string</h2>
A string in JavaScript must be quoted.

    <code>let str = &quot;Hello&quot;;
let str2 = 'Single quotes are ok too';
let phrase = `can embed ${str}`;</code>
  In JavaScript, there are 3 types of quotes.

<li>Double quotes: <code>&quot;Hello&quot;</code>.</li><li>Single quotes: <code>'Hello'</code>.</li><li>Backticks: <code>`Hello`</code>.</li>

Double and single quotes are “simple” quotes. 
There’s no difference between them in JavaScript.

Backticks are “extended functionality” quotes. 
They allow us to embed variables and expressions into a string by wrapping them in <code>${…}</code>, for example:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let name = &quot;John&quot;;
// embed a variable
alert( `Hello, ${name}!` ); // Hello, John!
// embed an expression
alert( `the result is ${1 + 2}` ); // the result is 3</code>
  The expression inside <code>${…}</code> is evaluated and the result becomes a part of the string. 
We can put anything there: a variable like <code>name</code> or an arithmetical expression like <code>1 + 2</code> or something more complex.

Please note that this can only be done in backticks. 
Other quotes do not allow such embedding!

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( &quot;the result is ${1 + 2}&quot; ); // the result is ${1 + 2} (double quotes do nothing)</code>
  We’ll cover strings more thoroughly in the chapter <a href="/string">Strings</a>.

There is no <em>character</em> type.
In some languages, there is a special “character” type for a single character. 
For example, in the C language and in Java it is <code>char</code>.

In JavaScript, there is no such type. 
There’s only one type: <code>string</code>. 
A string may consist of only one character or many of them.

<h2>A boolean (logical type)</h2>
The boolean type has only two values: <code>true</code> and <code>false</code>.

This type is commonly used to store yes/no values: <code>true</code> means “yes, correct”, and <code>false</code> means “no, incorrect”.

For instance:

    <code>let nameFieldChecked = true; // yes, name field is checked
let ageFieldChecked = false; // no, age field is not checked</code>
  Boolean values also come as a result of comparisons:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let isGreater = 4 &gt; 1;
alert( isGreater ); // true (the comparison result is &quot;yes&quot;)</code>
  We’ll cover booleans more deeply later in the chapter <a href="/logical-operators">Logical operators</a>.

<h2>The “null” value</h2>
The special <code>null</code> value does not belong to any type of those described above.

It forms a separate type of its own, which contains only the <code>null</code> value:

    <code>let age = null;</code>
  In JavaScript <code>null</code> is not a “reference to a non-existing object” or a “null pointer” like in some other languages.

It’s just a special value which has the sense of “nothing”, “empty” or “value unknown”.

The code above states that the <code>age</code> is unknown or empty for some reason.

<h2>The “undefined” value</h2>
The special value <code>undefined</code> stands apart. 
It makes a type of its own, just like <code>null</code>.

The meaning of <code>undefined</code> is “value is not assigned”.

If a variable is declared, but not assigned, then its value is exactly <code>undefined</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let x;
alert(x); // shows &quot;undefined&quot;</code>
  Technically, it is possible to assign <code>undefined</code> to any variable:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let x = 123;
x = undefined;
alert(x); // &quot;undefined&quot;</code>
  …But it’s not recommended to do that. 
Normally, we use <code>null</code> to write an “empty” or an “unknown” value into the variable, and <code>undefined</code> is only used for checks, to see if the variable is assigned or similar.

<h2>Objects and Symbols</h2>
The <code>object</code> type is special.

All other types are called “primitive”, because their values can contain only a single thing (be it a string or a number or whatever). 
In contrast, objects are used to store collections of data and more complex entities. 
We’ll deal with them later in the chapter <a href="/object">Objects</a> after we know enough about primitives.

The <code>symbol</code> type is used to create unique identifiers for objects. 
We have to mention it here for completeness, but it’s better to study them after objects.

<h2>The typeof operator</h2>
The <code>typeof</code> operator returns the type of the argument. 
It’s useful when we want to process values of different types differently, or just want to make a quick check.

It supports two forms of syntax:

<li>As an operator: <code>typeof x</code>.</li><li>Function style: <code>typeof(x)</code>.</li>

In other words, it works both with parentheses or without them. 
The result is the same.

The call to <code>typeof x</code> returns a string with the type name:

    <code>typeof undefined // &quot;undefined&quot;
typeof 0 // &quot;number&quot;
typeof true // &quot;boolean&quot;
typeof &quot;foo&quot; // &quot;string&quot;
typeof Symbol(&quot;id&quot;) // &quot;symbol&quot;
typeof Math // &quot;object&quot;  (1)
typeof null // &quot;object&quot;  (2)
typeof alert // &quot;function&quot;  (3)</code>
  The last three lines may need additional explanations:

<li><code>Math</code> is a built-in object that provides mathematical operations. 
We will learn it in the chapter <a href="/number">Numbers</a>. 
Here it serves just as an example of an object.</li><li>The result of <code>typeof null</code> is <code>&quot;object&quot;</code>. 
That’s wrong. 
It is an officially recognized error in <code>typeof</code>, kept for compatibility. 
Of course, <code>null</code> is not an object. 
It is a special value with a separate type of its own. 
So, again, that’s an error in the language.</li><li>The result of <code>typeof alert</code> is <code>&quot;function&quot;</code>, because <code>alert</code> is a function of the language. 
We’ll study functions in the next chapters, and we’ll see that there’s no special “function” type in the language. 
Functions belong to the object type. 
But <code>typeof</code> treats them differently. 
Formally, it’s incorrect, but very convenient in practice.</li>

<h4><a name="summary" href="#summary">Summary</a4</h2>
There are 7 basic types in JavaScript.

<li><code>number</code> for numbers of any kind: integer or floating-point.</li><li><code>string</code> for strings. 
A string may have one or more characters, there’s no separate single-character type.</li><li><code>boolean</code> for <code>true</code>/<code>false</code>.</li><li><code>null</code> for unknown values – a standalone type that has a single value <code>null</code>.</li><li><code>undefined</code> for unassigned values – a standalone type that has a single value <code>undefined</code>.</li><li><code>object</code> for more complex data structures.</li><li><code>symbol</code> for unique identifiers.</li>

The <code>typeof</code> operator allows us to see which type is stored in the variable.

<li>Two forms: <code>typeof x</code> or <code>typeof(x)</code>.</li><li>Returns a string with the name of the type, like <code>&quot;string&quot;</code>.</li><li>For <code>null</code> returns <code>&quot;object&quot;</code> – that’s an error in the language, it’s not an object in fact.</li>

In the next chapters we’ll concentrate on primitive values and once we’re familiar with them, then we’ll move on to objects.

    <code>let name = &quot;Ilya&quot;;
alert( `hello ${1}` ); // ?
alert( `hello ${&quot;name&quot;}` ); // ?
alert( `hello ${name}` ); // ?</code>
  <button type="button">solution</button>

Backticks embed the expression inside <code>${...}</code> into the string.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let name = &quot;Ilya&quot;;
// the expression is a number 1
alert( `hello ${1}` ); // hello 1
// the expression is a string &quot;name&quot;
alert( `hello ${&quot;name&quot;}` ); // hello name
// the expression is a variable, embed it
alert( `hello ${name}` ); // hello Ilya</code>
  <button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/variables" data-tooltip="Variables">Previous lesson</a><a href="/type-conversions" data-tooltip="Type Conversions">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Ftypes"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Ftypes"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Ftypes"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Ftypes"></a>

Most of the time, operators and functions automatically convert a value to the right type. 
That’s called “type conversion”.

For example, <code>alert</code> automatically converts any value to a string to show it. 
Mathematical operations convert values to numbers.

There are also cases when we need to explicitly convert a value to put things right.

Not talking about objects yet
In this chapter we don’t cover objects yet. 
Here we study primitives first. 
Later, after we learn objects, we’ll see how object conversion works in the chapter <a href="/object-toprimitive">Object to primitive conversion</a>.

<h2>ToString</h2>
String conversion happens when we need the string form of a value.

For example, <code>alert(value)</code> does it to show the value.

We can also use a call <code>String(value)</code> function for that:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let value = true;
alert(typeof value); // boolean
value = String(value); // now value is a string &quot;true&quot;
alert(typeof value); // string</code>
  String conversion is mostly obvious. 
A <code>false</code> becomes <code>&quot;false&quot;</code>, <code>null</code> becomes <code>&quot;null&quot;</code> etc.

<h2>ToNumber</h2>
Numeric conversion happens in mathematical functions and expressions automatically.

For example, when division <code>/</code> is applied to non-numbers:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( &quot;6&quot; / &quot;2&quot; ); // 3, strings are converted to numbers</code>
  We can use a <code>Number(value)</code> function to explicitly convert a <code>value</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let str = &quot;123&quot;;
alert(typeof str); // string
let num = Number(str); // becomes a number 123
alert(typeof num); // number</code>
  Explicit conversion is usually required when we read a value from a string-based source like a text form, but we expect a number to be entered.

If the string is not a valid number, the result of such conversion is <code>NaN</code>, for instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let age = Number(&quot;an arbitrary string instead of a number&quot;);
alert(age); // NaN, conversion failed</code>
  Numeric conversion rules:

<table>
<thead>
<tr>
<th>Value</th>
<th>Becomes…</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>undefined</code></td>
<td><code>NaN</code></td>
</tr>
<tr>
<td><code>null</code></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>true and false</code></td>
<td><code>1</code> and <code>0</code></td>
</tr>
<tr>
<td><code>string</code></td>
<td>Whitespaces from the start and the end are removed. 
Then, if the remaining string is empty, the result is <code>0</code>. 
Otherwise, the number is “read” from the string. 
An error gives <code>NaN</code>.</td>
</tr>
</tbody>
</table>

Examples:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( Number(&quot;   123   &quot;) ); // 123
alert( Number(&quot;123z&quot;) );      // NaN (error reading a number at &quot;z&quot;)
alert( Number(true) );        // 1
alert( Number(false) );       // 0</code>
  Please note that <code>null</code> and <code>undefined</code> behave differently here: <code>null</code> becomes a zero, while <code>undefined</code> becomes <code>NaN</code>.

Addition ‘+’ concatenates strings
Almost all mathematical operations convert values to numbers. 
With a notable exception of the addition <code>+</code>. 
If one of the added values is a string, then another one is also converted to a string.

Then it concatenates (joins) them:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( 1 + '2' ); // '12' (string to the right)
alert( '1' + 2 ); // '12' (string to the left)</code>
  That only happens when one of the arguments is a string. 
Otherwise, values are converted to numbers.

<h2>ToBoolean</h2>
Boolean conversion is the simplest one.

It happens in logical operations (later we’ll meet condition tests and other kinds of them), but also can be performed manually with the call of <code>Boolean(value)</code>.

The conversion rule:

<li>Values that are intuitively “empty”, like <code>0</code>, an empty string, <code>null</code>, <code>undefined</code> and <code>NaN</code> become <code>false</code>.</li><li>Other values become <code>true</code>.</li>

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( Boolean(1) ); // true
alert( Boolean(0) ); // false
alert( Boolean(&quot;hello&quot;) ); // true
alert( Boolean(&quot;&quot;) ); // false</code>
  

Please note: the string with zero <code>&quot;0&quot;</code> is <code>true</code>
Some languages (namely PHP) treat <code>&quot;0&quot;</code> as <code>false</code>. 
But in JavaScript a non-empty string is always <code>true</code>.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( Boolean(&quot;0&quot;) ); // true
alert( Boolean(&quot; &quot;) ); // spaces, also true (any non-empty string is true)</code>
  
<h4><a name="summary" href="#summary">Summary</a4</h2>
There are three most widely used type conversions: to string, to number and to boolean.

<strong><code>ToString</code></strong> – Occurs when we output something, can be performed with <code>String(value)</code>. 
The conversion to string is usually obvious for primitive values.

<strong><code>ToNumber</code></strong> – Occurs in math operations, can be performed with <code>Number(value)</code>.

The conversion follows the rules:

<table>
<thead>
<tr>
<th>Value</th>
<th>Becomes…</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>undefined</code></td>
<td><code>NaN</code></td>
</tr>
<tr>
<td><code>null</code></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>true / false</code></td>
<td><code>1 / 0</code></td>
</tr>
<tr>
<td><code>string</code></td>
<td>The string is read “as is”, whitespaces from both sides are ignored. 
An empty string becomes <code>0</code>. 
An error gives <code>NaN</code>.</td>
</tr>
</tbody>
</table>

<strong><code>ToBoolean</code></strong> – Occurs in logical operations, or can be performed with <code>Boolean(value)</code>.

Follows the rules:

<table>
<thead>
<tr>
<th>Value</th>
<th>Becomes…</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0</code>, <code>null</code>, <code>undefined</code>, <code>NaN</code>, <code>&quot;&quot;</code></td>
<td><code>false</code></td>
</tr>
<tr>
<td>any other value</td>
<td><code>true</code></td>
</tr>
</tbody>
</table>

Most of these rules are easy to understand and memorize. 
The notable exceptions where people usually make mistakes are:

<li><code>undefined</code> is <code>NaN</code> as a number, not <code>0</code>.</li><li><code>&quot;0&quot;</code> and space-only strings like <code>&quot; &quot;</code> are true as a boolean.</li>

Objects are not covered here, we’ll return to them later in the chapter <a href="/object-toprimitive">Object to primitive conversion</a> that is devoted exclusively to objects, after we learn more basic things about JavaScript.

    <code>&quot;&quot; + 1 + 0
&quot;&quot; - 1 + 0
true + false
6 / &quot;3&quot;
&quot;2&quot; * &quot;3&quot;
4 + 5 + &quot;px&quot;
&quot;$&quot; + 4 + 5
&quot;4&quot; - 2
&quot;4px&quot; - 2
7 / 0
&quot;  -9\n&quot; + 5
&quot;  -9\n&quot; - 5
null + 1
undefined + 1</code>
  Think well, write down and then compare with the answer.

<button type="button">solution</button>

    <code>&quot;&quot; + 1 + 0 = &quot;10&quot; // (1)
&quot;&quot; - 1 + 0 = -1 // (2)
true + false = 1
6 / &quot;3&quot; = 2
&quot;2&quot; * &quot;3&quot; = 6
4 + 5 + &quot;px&quot; = &quot;9px&quot;
&quot;$&quot; + 4 + 5 = &quot;$45&quot;
&quot;4&quot; - 2 = 2
&quot;4px&quot; - 2 = NaN
7 / 0 = Infinity
&quot; -9\n&quot; + 5 = &quot; -9\n5&quot;
&quot; -9\n&quot; - 5 = -14
null + 1 = 1 // (3)
undefined + 1 = NaN // (4)</code>
  <li>The addition with a string <code>&quot;&quot; + 1</code> converts <code>1</code> to a string: <code>&quot;&quot; + 1 = &quot;1&quot;</code>, and then we have <code>&quot;1&quot; + 0</code>, the same rule is applied.</li><li>The subtraction <code>-</code> (like most math operations) only works with numbers, it converts an empty string <code>&quot;&quot;</code> to <code>0</code>.</li><li><code>null</code> becomes <code>0</code> after the numeric conversion.</li><li><code>undefined</code> becomes <code>NaN</code> after the numeric conversion.</li>

<button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/types" data-tooltip="Data types">Previous lesson</a><a href="/operators" data-tooltip="Operators">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Ftype-conversions"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Ftype-conversions"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Ftype-conversions"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Ftype-conversions"></a>

Many operators are known to us from school. 
They are addition <code>+</code>, a multiplication <code>*</code>, a subtraction <code>-</code> and so on.

In this chapter we concentrate on aspects that are not covered by school arithmetic.

<h2>Terms: “unary”, “binary”, “operand”</h2>
Before we move on, let’s grasp the common terminology.

<li><em>An operand</em> – is what operators are applied to. 
For instance in multiplication <code>5 * 2</code> there are two operands: the left operand is <code>5</code>, and the right operand is <code>2</code>. 
Sometimes people say “arguments” instead of “operands”.

</li><li>An operator is <em>unary</em> if it has a single operand. 
For example, the unary negation <code>-</code> reverses the sign of the number:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let x = 1;
x = -x;
alert( x ); // -1, unary negation was applied</code>
  </li><li>An operator is <em>binary</em> if it has two operands. 
The same minus exists in the binary form as well:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let x = 1, y = 3;
alert( y - x ); // 2, binary minus subtracts values</code>
  Formally, we’re talking about two different operators here: the unary negation (single operand, reverses the sign) and the binary subtraction (two operands, subtracts).

</li>

<h2>Strings concatenation, binary +</h2>
Now let’s see special features of JavaScript operators that are beyond school arithmetics.

Usually the plus operator <code>+</code> sums numbers.

But if the binary <code>+</code> is applied to strings, it merges (concatenates) them:

    <code>let s = &quot;my&quot; + &quot;string&quot;;
alert(s); // mystring</code>
  Note that if any of the operands is a string, then the other one is converted to a string too.

For example:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( '1' + 2 ); // &quot;12&quot;
alert( 2 + '1' ); // &quot;21&quot;</code>
  See, it doesn’t matter whether the first operand is a string or the second one. 
The rule is simple: if either operand is a string, then convert the other one into a string as well.

However, note that operations run from left to right. 
If there are two numbers followed by a string, the numbers will be added before being converted to a string:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert(2 + 2 + '1' ); // &quot;41&quot; and not &quot;221&quot;</code>
  String concatenation and conversion is a special feature of the binary plus <code>+</code>. 
Other arithmetic operators work only with numbers. 
They always convert their operands to numbers.

For instance, subtraction and division:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( 2 - '1' ); // 1
alert( '6' / '2' ); // 3</code>
  <h2>Numeric conversion, unary +</h2>
The plus <code>+</code> exists in two forms. 
The binary form that we used above and the unary form.

The unary plus or, in other words, the plus operator <code>+</code> applied to a single value, doesn’t do anything with numbers, but if the operand is not a number, then it is converted into it.

For example:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// No effect on numbers
let x = 1;
alert( +x ); // 1
let y = -2;
alert( +y ); // -2
// Converts non-numbers
alert( +true ); // 1
alert( +&quot;&quot; );   // 0</code>
  It actually does the same as <code>Number(...)</code>, but is shorter.

A need to convert strings to numbers arises very often. 
For example, if we are getting values from HTML form fields, then they are usually strings.

What if we want to sum them?

The binary plus would add them as strings:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let apples = &quot;2&quot;;
let oranges = &quot;3&quot;;
alert( apples + oranges ); // &quot;23&quot;, the binary plus concatenates strings</code>
  If we want to treat them as numbers, then we can convert and then sum:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let apples = &quot;2&quot;;
let oranges = &quot;3&quot;;
// both values converted to numbers before the binary plus
alert( +apples + +oranges ); // 5
// the longer variant
// alert( Number(apples) + Number(oranges) ); // 5</code>
  From a mathematician’s standpoint the abundance of pluses may seem strange. 
But from a programmer’s standpoint, there’s nothing special: unary pluses are applied first, they convert strings to numbers, and then the binary plus sums them up.

Why are unary pluses applied to values before the binary one? As we’re going to see, that’s because of their <em>higher precedence</em>.

<h2>Operators precedence</h2>
If an expression has more than one operator, the execution order is defined by their <em>precedence</em>, or, in other words, there’s an implicit priority order among the operators.

From school we all know that the multiplication in the expression <code>1 + 2 * 2</code> should be calculated before the addition. 
That’s exactly the precedence thing. 
The multiplication is said to have <em>a higher precedence</em> than the addition.

Parentheses override any precedence, so if we’re not satisfied with the order, we can use them, like: <code>(1 + 2) * 2</code>.

There are many operators in JavaScript. 
Every operator has a corresponding precedence number. 
The one with the bigger number executes first. 
If the precedence is the same, the execution order is from left to right.

An extract from the <a href="https://developer.mozilla.org/en/JavaScript/Reference/operators/operator_precedence">precedence table</a> (you don’t need to remember this, but note that unary operators are higher than corresponding binary ones):

<table>
<thead>
<tr>
<th>Precedence</th>
<th>Name</th>
<th>Sign</th>
</tr>
</thead>
<tbody>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>16</td>
<td>unary plus</td>
<td><code>+</code></td>
</tr>
<tr>
<td>16</td>
<td>unary negation</td>
<td><code>-</code></td>
</tr>
<tr>
<td>14</td>
<td>multiplication</td>
<td><code>*</code></td>
</tr>
<tr>
<td>14</td>
<td>division</td>
<td><code>/</code></td>
</tr>
<tr>
<td>13</td>
<td>addition</td>
<td><code>+</code></td>
</tr>
<tr>
<td>13</td>
<td>subtraction</td>
<td><code>-</code></td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>3</td>
<td>assignment</td>
<td><code>=</code></td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>

As we can see, the “unary plus” has a priority of <code>16</code>, which is higher than <code>13</code> for the “addition” (binary plus). 
That’s why in the expression <code>&quot;+apples + +oranges&quot;</code> unary pluses work first, and then the addition.

<h2>Assignment</h2>
Let’s note that an assignment <code>=</code> is also an operator. 
It is listed in the precedence table with the very low priority of <code>3</code>.

That’s why when we assign a variable, like <code>x = 2 * 2 + 1</code>, then the calculations are done first, and afterwards the <code>=</code> is evaluated, storing the result in <code>x</code>.

    <code>let x = 2 * 2 + 1;
alert( x ); // 5</code>
  It is possible to chain assignments:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let a, b, c;
a = b = c = 2 + 2;
alert( a ); // 4
alert( b ); // 4
alert( c ); // 4</code>
  Chained assignments evaluate from right to left. 
First the rightmost expression <code>2 + 2</code> is evaluated then assigned to the variables on the left: <code>c</code>, <code>b</code> and <code>a</code>. 
At the end, all variables share a single value.

The assignment operator <code>&quot;=&quot;</code> returns a value
An operator always returns a value. 
That’s obvious for most of them like an addition <code>+</code> or a multiplication <code>*</code>. 
But the assignment operator follows that rule too.

The call <code>x = value</code> writes the <code>value</code> into <code>x</code> <em>and then returns it</em>.

Here’s the demo that uses an assignment as part of a more complex expression:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let a = 1;
let b = 2;
let c = 3 - (a = b + 1);
alert( a ); // 3
alert( c ); // 0</code>
  In the example above, the result of <code>(a = b + 1)</code> is the value which is assigned to <code>a</code> (that is <code>3</code>). 
It is then used to subtract from <code>3</code>.

Funny code, isn’t it? We should understand how it works, because sometimes we can see it in 3rd-party libraries, but shouldn’t write anything like that ourselves. 
Such tricks definitely don’t make the code clearer and readable.

<h2>Remainder %</h2>
The remainder operator <code>%</code> despite its look does not have a relation to percents.

The result of <code>a % b</code> is the remainder of the integer division of <code>a</code> by <code>b</code>.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( 5 % 2 ); // 1 is a remainder of 5 divided by 2
alert( 8 % 3 ); // 2 is a remainder of 8 divided by 3
alert( 6 % 3 ); // 0 is a remainder of 6 divided by 3</code>
  <h2>Exponentiation **</h2>
The exponentiation operator <code>**</code> is a recent addition to the language.

For a natural number <code>b</code>, the result of <code>a ** b</code> is <code>a</code> multiplied by itself <code>b</code> times.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( 2 ** 2 ); // 4  (2 * 2)
alert( 2 ** 3 ); // 8  (2 * 2 * 2)
alert( 2 ** 4 ); // 16 (2 * 2 * 2 * 2)</code>
  The operator works for non-integer numbers of <code>a</code> and <code>b</code> as well, for instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( 4 ** (1/2) ); // 2 (power of 1/2 is the same as a square root, that's maths)
alert( 8 ** (1/3) ); // 2 (power of 1/3 is the same as a cubic root)</code>
  <h2>Increment/decrement</a></h2><!-- Can't use -- in title, because built-in parse turns it i– -->

Increasing or decreasing a number by one is among the most common numerical operations.

So, there are special operators for that:

<li><strong>Increment</strong> <code>++</code> increases a variable by 1:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let counter = 2;
counter++;      // works the same as counter = counter + 1, but is shorter
alert( counter ); // 3</code>
  </li><li><strong>Decrement</strong> <code>--</code> decreases a variable by 1:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let counter = 2;
counter--;      // works the same as counter = counter - 1, but is shorter
alert( counter ); // 1</code>
  </li>

Important:
Increment/decrement can be applied only to a variable. 
An attempt to use it on a value like <code>5++</code> will give an error.

Operators <code>++</code> and <code>--</code> can be placed both after and before the variable.

<li>When the operator goes after the variable, it is called a “postfix form”: <code>counter++</code>.</li><li>The “prefix form” is when the operator stands before the variable: <code>++counter</code>.</li>

Both of these records do the same: increase <code>counter</code> by <code>1</code>.

Is there any difference? Yes, but we can only see it if we use the returned value of <code>++/--</code>.

Let’s clarify. 
As we know, all operators return a value. 
Increment/decrement is not an exception here. 
The prefix form returns the new value, while the postfix form returns the old value (prior to increment/decrement).

To see the difference, here’s the example:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let counter = 1;
let a = ++counter; // (*)
alert(a); // 2</code>
  Here in the line <code>(*)</code> the prefix call <code>++counter</code> increments <code>counter</code> and returns the new value that is <code>2</code>. 
So the <code>alert</code> shows <code>2</code>.

Now let’s use the postfix form:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let counter = 1;
let a = counter++; // (*) changed ++counter to counter++
alert(a); // 1</code>
  In the line <code>(*)</code> the <em>postfix</em> form <code>counter++</code> also increments <code>counter</code>, but returns the <em>old</em> value (prior to increment). 
So the <code>alert</code> shows <code>1</code>.

To summarize:

<li>If the result of increment/decrement is not used, then there is no difference in which form to use:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let counter = 0;
counter++;
++counter;
alert( counter ); // 2, the lines above did the same</code>
  </li><li>If we’d like to increase the value <em>and</em> use the result of the operator right now, then we need the prefix form:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let counter = 0;
alert( ++counter ); // 1</code>
  </li><li>If we’d like to increment, but use the previous value, then we need the postfix form:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let counter = 0;
alert( counter++ ); // 0</code>
  </li>

Increment/decrement among other operators
Operators <code>++/--</code> can be used inside an expression as well. 
Their precedence is higher than most other arithmetical operations.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let counter = 1;
alert( 2 * ++counter ); // 4</code>
  Compare with:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let counter = 1;
alert( 2 * counter++ ); // 2, because counter++ returns the &quot;old&quot; value</code>
  Though technically allowable, such notation usually makes the code less readable. 
One line does multiple things – not good.

While reading the code, a fast “vertical” eye-scan can easily miss such <code>counter++</code>, and it won’t be obvious that the variable increases.

The “one line – one action” style is advised:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let counter = 1;
alert( 2 * counter );
counter++;</code>
  
<h2>Bitwise operators</h2>
Bitwise operators treat arguments as 32-bit integer numbers and work on the level of their binary representation.

These operators are not JavaScript-specific. 
They are supported in most programming languages.

The list of operators:

<li>AND ( <code>&amp;</code> )</li><li>OR ( <code>|</code> )</li><li>XOR ( <code>^</code> )</li><li>NOT ( <code>~</code> )</li><li>LEFT SHIFT ( <code>&lt;&lt;</code> )</li><li>RIGHT SHIFT ( <code>&gt;&gt;</code> )</li><li>ZERO-FILL RIGHT SHIFT ( <code>&gt;&gt;&gt;</code> )</li>

These operators are used very rarely. 
To understand them, we should delve into low-level number representation, and it would not be optimal to do that right now. 
Especially because we won’t need them any time soon. 
If you’re curious, you can read the <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators">Bitwise Operators</a> article in MDN. 
It would be more practical to do that when a real need arises.

<h2>Modify-in-place</h2>
We often need to apply an operator to a variable and store the new result in it.

For example:

    <code>let n = 2;
n = n + 5;
n = n * 2;</code>
  This notation can be shortened using operators <code>+=</code> and <code>*=</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let n = 2;
n += 5; // now n = 7 (same as n = n + 5)
n *= 2; // now n = 14 (same as n = n * 2)
alert( n ); // 14</code>
  Short “modify-and-assign” operators exist for all arithmetical and bitwise operators: <code>/=</code>, <code>-=</code> etc.

Such operators have the same precedence as a normal assignment, so they run after most other calculations:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let n = 2;
n *= 3 + 5;
alert( n ); // 16  (right part evaluated first, same as n *= 8)</code>
  <h2>Comma</h2>
The comma operator <code>,</code> is one of most rare and unusual operators. 
Sometimes it’s used to write shorter code, so we need to know it in order to understand what’s going on.

The comma operator allows us to evaluate several expressions, dividing them with a comma <code>,</code>. 
Each of them is evaluated, but the result of only the last one is returned.

For example:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let a = (1 + 2, 3 + 4);
alert( a ); // 7 (the result of 3 + 4)</code>
  Here, the first expression <code>1 + 2</code> is evaluated, and its result is thrown away, then <code>3 + 4</code> is evaluated and returned as the result.

Comma has a very low precedence
Please note that the comma operator has very low precedence, lower than <code>=</code>, so parentheses are important in the example above.

Without them: <code>a = 1 + 2, 3 + 4</code> evaluates <code>+</code> first, summing the numbers into <code>a = 3, 7</code>, then the assignment operator <code>=</code> assigns    <code>a = 3</code>, and then the number after the comma <code>7</code> is not processed anyhow, so it’s ignored.

Why do we need such an operator which throws away everything except the last part?

Sometimes people use it in more complex constructs to put several actions in one line.

For example:

    <code>// three operations in one line
for (a = 1, b = 3, c = a * b; a &lt; 10; a++) {
 ...
}</code>
  Such tricks are used in many JavaScript frameworks, that’s why we mention them. 
But usually they don’t improve the code readability, so we should think well before writing like that.

    <code>let a = 1, b = 1;
let c = ++a; // ?
let d = b++; // ?</code>
  <button type="button">solution</button>

The answer is:

<li><code>a = 2</code></li><li><code>b = 2</code></li><li><code>c = 2</code></li><li><code>d = 1</code></li>

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let a = 1, b = 1;
alert( ++a ); // 2, prefix form returns the new value
alert( b++ ); // 1, postfix form returns the old value
alert( a ); // 2, incremented once
alert( b ); // 2, incremented once</code>
  <button type="button" title="close"></button>

<h3><a href="#assignment-result" name="assignment-result">Assignment result</a></h3><a href="/task/assignment-result" target="_blank"></a>

importance: 3

What are the values of <code>a</code> and <code>x</code> after the code below?

    <code>let a = 2;
let x = 1 + (a *= 2);</code>
  <button type="button">solution</button>

The answer is:

<li><code>a = 4</code> (multiplied by 2)</li><li><code>x = 5</code> (calculated as 1 + 4)</li>

<button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/type-conversions" data-tooltip="Type Conversions">Previous lesson</a><a href="/comparison" data-tooltip="Comparisons">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Foperators"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Foperators"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Foperators"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Foperators"></a>

Many comparison operators we know from maths:

<li>Greater/less than: <code>a &gt; b</code>, <code>a &lt; b</code>.</li><li>Greater/less than or equals: <code>a &gt;= b</code>, <code>a &lt;= b</code>.</li><li>Equality check is written as <code>a == b</code> (please note the double equation sign <code>=</code>. 
A single symbol <code>a = b</code> would mean an assignment).</li><li>Not equals. 
In maths the notation is <code>≠</code>, in JavaScript it’s written as an assignment with an exclamation sign before it: <code>a != b</code>.</li>

<h2>Boolean is the result</h2>
Just as all other operators, a comparison returns a value. 
The value is of the boolean type.

<li><code>true</code> – means “yes”, “correct” or “the truth”.</li><li><code>false</code> – means “no”, “wrong” or “a lie”.</li>

For example:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( 2 &gt; 1 );  // true (correct)
alert( 2 == 1 ); // false (wrong)
alert( 2 != 1 ); // true (correct)</code>
  A comparison result can be assigned to a variable, just like any value:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let result = 5 &gt; 4; // assign the result of the comparison
alert( result ); // true</code>
  <h2>String comparison</h2>
To see which string is greater than the other, the so-called “dictionary” or “lexicographical” order is used.

In other words, strings are compared letter-by-letter.

For example:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( 'Z' &gt; 'A' ); // true
alert( 'Glow' &gt; 'Glee' ); // true
alert( 'Bee' &gt; 'Be' ); // true</code>
  The algorithm to compare two strings is simple:

<li>Compare first characters of both strings.</li><li>If the first one is greater(or less), then the first string is greater(or less) than the second. 
We’re done.</li><li>Otherwise if first characters are equal, compare the second characters the same way.</li><li>Repeat until the end of any string.</li><li>If both strings ended simultaneously, then they are equal. 
Otherwise the longer string is greater.</li>

In the example above, the comparison <code>'Z' &gt; 'A'</code> gets the result at the first step.

Strings <code>&quot;Glow&quot;</code> and <code>&quot;Glee&quot;</code> are compared character-by-character:

<li><code>G</code> is the same as <code>G</code>.</li><li><code>l</code> is the same as <code>l</code>.</li><li><code>o</code> is greater than <code>e</code>. 
Stop here. 
The first string is greater.</li>

Not a real dictionary, but Unicode order
The comparison algorithm given above is roughly equivalent to the one used in book dictionaries or phone books. 
But it’s not exactly the same.

For instance, case matters. 
A capital letter <code>&quot;A&quot;</code> is not equal to the lowercase <code>&quot;a&quot;</code>. 
Which one is greater? Actually, the lowercase <code>&quot;a&quot;</code> is. 
Why? Because the lowercase character has a greater index in the internal encoding table (Unicode). 
We’ll get back to specific details and consequences in the chapter <a href="/string">Strings</a>.

<h2>Comparison of different types</h2>
When compared values belong to different types, they are converted to numbers.

For example:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( '2' &gt; 1 ); // true, string '2' becomes a number 2
alert( '01' == 1 ); // true, string '01' becomes a number 1</code>
  For boolean values, <code>true</code> becomes <code>1</code> and <code>false</code> becomes <code>0</code>, that’s why:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( true == 1 ); // true
alert( false == 0 ); // true</code>
  
A funny consequence
It is possible that at the same time:

<li>Two values are equal.</li><li>One of them is <code>true</code> as a boolean and the other one is <code>false</code> as a boolean.</li>

For example:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let a = 0;
alert( Boolean(a) ); // false
let b = &quot;0&quot;;
alert( Boolean(b) ); // true
alert(a == b); // true!</code>
  From JavaScript’s standpoint that’s quite normal. 
An equality check converts using the numeric conversion (hence <code>&quot;0&quot;</code> becomes <code>0</code>), while <code>Boolean</code> conversion uses another set of rules.

<h2>Strict equality</h2>
A regular equality check <code>==</code> has a problem. 
It cannot differ <code>0</code> from <code>false</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( 0 == false ); // true</code>
  The same thing with an empty string:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( '' == false ); // true</code>
  That’s because operands of different types are converted to a number by the equality operator <code>==</code>. 
An empty string, just like <code>false</code>, becomes a zero.

What to do if we’d like to differentiate <code>0</code> from <code>false</code>?

<strong>A strict equality operator <code>===</code> checks the equality without type conversion.</strong>

In other words, if <code>a</code> and <code>b</code> are of different types, then <code>a === b</code> immediately returns <code>false</code> without an attempt to convert them.

Let’s try it:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( 0 === false ); // false, because the types are different</code>
  There also exists a “strict non-equality” operator <code>!==</code>, as an analogy for <code>!=</code>.

The strict equality check operator is a bit longer to write, but makes it obvious what’s going on and leaves less space for errors.

<h2>Comparison with null and undefined</h2>
Let’s see more edge cases.

There’s a non-intuitive behavior when <code>null</code> or <code>undefined</code> are compared with other values.

<dl>
<dt>For a strict equality check <code>===</code></dt>
<dd>

These values are different, because each of them belongs to a separate type of its own.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( null === undefined ); // false</code>
  </dd>
<dt>For a non-strict check <code>==</code></dt>
<dd>

There’s a special rule. 
These two are a “sweet couple”: they equal each other (in the sense of <code>==</code>), but not any other value.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( null == undefined ); // true</code>
  </dd>
<dt>For maths and other comparisons <code>&lt; &gt; &lt;= &gt;=</code></dt>
<dd>

Values <code>null/undefined</code> are converted to a number: <code>null</code> becomes <code>0</code>, while <code>undefined</code> becomes <code>NaN</code>.

</dd>
</dl>

Now let’s see funny things that happen when we apply those rules. 
And, what’s more important, how to not fall into a trap with these features.

<h3><a name="strange-result-null-vs-0" href="#strange-result-null-vs-0">Strange result: null vs 0</a></h3>
Let’s compare <code>null</code> with a zero:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( null &gt; 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null &gt;= 0 ); // (3) true</code>
  Yeah, mathematically that’s strange. 
The last result states that &quot;<code>null</code> is greater than or equal to zero&quot;. 
Then one of the comparisons above must be correct, but they are both false.

The reason is that an equality check <code>==</code> and comparisons <code>&gt; &lt; &gt;= &lt;=</code> work differently. 
Comparisons convert <code>null</code> to a number, hence treat it as <code>0</code>. 
That’s why (3) <code>null &gt;= 0</code> is true and (1) <code>null &gt; 0</code> is false.

On the other hand, the equality check <code>==</code> for <code>undefined</code> and <code>null</code> works by the rule, without any conversions. 
They equal each other and don’t equal anything else. 
That’s why (2) <code>null == 0</code> is false.

<h3><a name="an-incomparable-undefined" href="#an-incomparable-undefined">An incomparable undefined</a></h3>
The value <code>undefined</code> shouldn’t participate in comparisons at all:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( undefined &gt; 0 ); // false (1)
alert( undefined &lt; 0 ); // false (2)
alert( undefined == 0 ); // false (3)</code>
  Why does it dislike a zero so much? Always false!

We’ve got these results because:

<li>Comparisons <code>(1)</code> and <code>(2)</code> return <code>false</code> because <code>undefined</code> gets converted to <code>NaN</code>. 
And <code>NaN</code> is a special numeric value which returns <code>false</code> for all comparisons.</li><li>The equality check <code>(3)</code> returns <code>false</code>, because <code>undefined</code> only equals <code>null</code> and no other value.</li>

<h3><a name="evade-problems" href="#evade-problems">Evade problems</a></h3>
Why did we observe these examples? Should we remember these peculiarities all the time? Well, not really. 
Actually, these tricky things will gradually become familiar over time, but there’s a solid way to evade any problems with them.

Just treat any comparison with <code>undefined/null</code> except the strict equality <code>===</code> with exceptional care.

Don’t use comparisons <code>&gt;= &gt; &lt; &lt;=</code> with a variable which may be <code>null/undefined</code>, unless you are really sure what you’re doing. 
If a variable can have such values, then check for them separately.

<h4><a name="summary" href="#summary">Summary</a></h4><li>Comparison operators return a logical value.</li><li>Strings are compared letter-by-letter in the “dictionary” order.</li><li>When values of different types are compared, they get converted to numbers (with the exclusion of a strict equality check).</li><li>Values <code>null</code> and <code>undefined</code> equal <code>==</code> each other and do not equal any other value.</li><li>Be careful when using comparisons like <code>&gt;</code> or <code>&lt;</code> with variables that can occasionally be <code>null/undefined</code>. 
Making a separate check for <code>null/undefined</code> is a good idea.</li>

    <code>5 &gt; 4
&quot;apple&quot; &gt; &quot;pineapple&quot;
&quot;2&quot; &gt; &quot;12&quot;
undefined == null
undefined === null
null == &quot;\n0\n&quot;
null === +&quot;\n0\n&quot;</code>
  <button type="button">solution</button>

    <code>5 &gt; 4 → true
&quot;apple&quot; &gt; &quot;pineapple&quot; → false
&quot;2&quot; &gt; &quot;12&quot; → true
undefined == null → true
undefined === null → false
null == &quot;\n0\n&quot; → false
null === +&quot;\n0\n&quot; → false</code>
  Some of the reasons:

<li>Obviously, true.</li><li>Dictionary comparison, hence false.</li><li>Again, dictionary comparison, first char of <code>&quot;2&quot;</code> is greater than the first char of <code>&quot;1&quot;</code>.</li><li>Values <code>null</code> and <code>undefined</code> equal each other only.</li><li>Strict equality is strict. 
Different types from both sides lead to false.</li><li>See (4).</li><li>Strict equality of different types.</li>

<button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/operators" data-tooltip="Operators">Previous lesson</a><a href="/alert-prompt-confirm" data-tooltip="Interaction: alert, prompt, confirm">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Fcomparison"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Fcomparison"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Fcomparison"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Fcomparison"></a>

This part of the tutorial aims to cover JavaScript “as is”, without environment-specific tweaks.

But still we use a browser as the demo environment. 
So we should know at least a few user-interface functions. 
In this chapter we’ll get familiar with the browser functions <code>alert</code>, <code>prompt</code> and <code>confirm</code>.

<h2>alert</h2>
Syntax:

    <code>alert(message);</code>
  This shows a message and pauses the script execution until the user presses “OK”.

For example:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert(&quot;Hello&quot;);</code>
  The mini-window with the message is called a <em>modal window</em>. 
The word “modal” means that the visitor can’t interact with the rest of the page, press other buttons etc, until they have dealt with the window. 
In this case – until they press “OK”.

<h2>prompt</h2>
Function <code>prompt</code> accepts two arguments:

    <code>result = prompt(title[, default]);</code>
  It shows a modal window with a text message, an input field for the visitor and buttons OK/CANCEL.

<dl>
<dt><code>title</code></dt>
<dd>The text to show to the visitor.</dd>
<dt><code>default</code></dt>
<dd>An optional second parameter, the initial value for the input field.</dd>
</dl>

The visitor may type something in the prompt input field and press OK. 
Or they can cancel the input by pressing the CANCEL button or hitting the <kbd>Esc</kbd> key.

The call to <code>prompt</code> returns the text from the field or <code>null</code> if the input was canceled.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let age = prompt('How old are you?', 100);
alert(`You are ${age} years old!`); // You are 100 years old!</code>
  

IE: always supply a <code>default</code>
The second parameter is optional. 
But if we don’t supply it, Internet Explorer would insert the text <code>&quot;undefined&quot;</code> into the prompt.

Run this code in Internet Explorer to see that:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let test = prompt(&quot;Test&quot;);</code>
  So, to look good in IE, it’s recommended to always provide the second argument:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let test = prompt(&quot;Test&quot;, ''); // &lt;-- for IE</code>
  
<h2>confirm</h2>
The syntax:

    <code>result = confirm(question);</code>
  Function <code>confirm</code> shows a modal window with a <code>question</code> and two buttons: OK and CANCEL.

The result is <code>true</code> if OK is pressed and <code>false</code> otherwise.

For example:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let isBoss = confirm(&quot;Are you the boss?&quot;);
alert( isBoss ); // true if OK is pressed</code>
  <h4><a name="summary" href="#summary">Summary</a4</h2>
We covered 3 browser-specific functions to interact with the visitor:

<dl>
<dt><code>alert</code></dt>
<dd>shows a message.</dd>
<dt><code>prompt</code></dt>
<dd>shows a message asking the user to input text. 
It returns the text or, if CANCEL or <kbd>Esc</kbd> is clicked, all browsers return <code>null</code>.</dd>
<dt><code>confirm</code></dt>
<dd>shows a message and waits for the user to press “OK” or “CANCEL”. 
It returns <code>true</code> for OK and <code>false</code> for CANCEL/<kbd>Esc</kbd>.</dd>
</dl>

All these methods are modal: they pause the script execution and don’t allow the visitor to interact with the rest of the page until the message has been dismissed.

There are two limitations shared by all the methods above:

<li>The exact location of the modal window is determined by the browser. 
Usually it’s in the center.</li><li>The exact look of the window also depends on the browser. 
We can’t modify it.</li>

That is the price for simplicity. 
There are other ways to show nicer windows and richer interaction with the visitor, but if “bells and whistles” do not matter much, these methods work just fine.

<a href="#" onclick="event.preventDefault(); runDemo(this)">Run the demo</a>
<button type="button">solution</button>

JavaScript-code:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let name = prompt(&quot;What is your name?&quot;, &quot;&quot;);
alert(name);</code>
  The full page:

    <code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;
  &lt;script&gt;
    'use strict';
    let name = prompt(&quot;What is your name?&quot;, &quot;&quot;);
    alert(name);
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code>
  <button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/comparison" data-tooltip="Comparisons">Previous lesson</a><a href="/ifelse" data-tooltip="Conditional operators: if, '?'">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Falert-prompt-confirm"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Falert-prompt-confirm"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Falert-prompt-confirm"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Falert-prompt-confirm"></a>

Sometimes we need to perform different actions based on a condition.

There is the <code>if</code> statement for that and also the conditional (ternary) operator for conditional evaluation which we will be referring as  the “question mark” operator <code>?</code> for simplicity.

<h2>The “if” statement</h2>
The <code>if</code> statement gets a condition, evaluates it and, if the result is <code>true</code>, executes the code.

For example:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let year = prompt('In which year was ECMAScript-2015 specification published?', '');
if (year == 2015) alert( 'You are right!' );</code>
  In the example above, the condition is a simple equality check: <code>year == 2015</code>, but it can be much more complex.

If there is more than one statement to be executed, we have to wrap our code block inside curly braces:

    <code>if (year == 2015) {
  alert( &quot;That's correct!&quot; );
  alert( &quot;You're so smart!&quot; );
}</code>
  It is recommended to wrap your code block with curly braces <code>{}</code> every time with <code>if</code>, even if there is only one statement. 
That improves readability.

<h2>Boolean conversion</h2>
The <code>if (…)</code> statement evaluates the expression in parentheses and converts it to the boolean type.

Let’s recall the conversion rules from the chapter <a href="/type-conversions">Type Conversions</a>:

<li>A number <code>0</code>, an empty string <code>&quot;&quot;</code>, <code>null</code>, <code>undefined</code> and <code>NaN</code> become <code>false</code>. 
Because of that they are called “falsy” values.</li><li>Other values become <code>true</code>, so they are called “truthy”.</li>

So, the code under this condition would never execute:

    <code>if (0) { // 0 is falsy
  ...
}</code>
  …And inside this condition – always works:

    <code>if (1) { // 1 is truthy
  ...
}</code>
  We can also pass a pre-evaluated boolean value to <code>if</code>, like here:

    <code>let cond = (year == 2015); // equality evaluates to true or false
if (cond) {
  ...
}</code>
  <h2>The “else” clause</h2>
The <code>if</code> statement may contain an optional “else” block. 
It executes when the condition is wrong.

For example:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let year = prompt('In which year was ECMAScript-2015 specification published?', '');
if (year == 2015) {
  alert( 'You guessed it right!' );
} else {
  alert( 'How can you be so wrong?' ); // any value except 2015
}</code>
  <h2>Several conditions: “else if”</h2>
Sometimes we’d like to test several variants of a condition. 
There is an <code>else if</code> clause for that.

For example:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let year = prompt('In which year was ECMAScript-2015 specification published?', '');
if (year &lt; 2015) {
  alert( 'Too early...' );
} else if (year &gt; 2015) {
  alert( 'Too late' );
} else {
  alert( 'Exactly!' );
}</code>
  In the code above JavaScript first checks <code>year &lt; 2015</code>. 
If it is falsy it then goes to the next condition <code>year &gt; 2015</code>, and otherwise shows the last <code>alert</code>.

There can be more <code>else if</code> blocks. 
The ending <code>else</code> is optional.

<h2>Ternary operator ‘?’</h2>
Sometimes we need to assign a variable depending on a condition.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let accessAllowed;
let age = prompt('How old are you?', '');
if (age &gt; 18) {
  accessAllowed = true;
} else {
  accessAllowed = false;
}
alert(accessAllowed);</code>
  The so-called “ternary” or “question mark” operator lets us do that shorter and simpler.

The operator is represented by a question mark <code>?</code>. 
 The formal term “ternary” means that the operator has three operands. 
It is actually the one and only operator in JavaScript which has that many.

The syntax is:

    <code>let result = condition ? value1 : value2</code>
  The <code>condition</code> is evaluated, if it’s truthy then <code>value1</code> is returned, otherwise – <code>value2</code>.

For example:

    <code>let accessAllowed = (age &gt; 18) ? true : false;</code>
  Technically, we can omit parentheses around <code>age &gt; 18</code>. 
The question mark operator has a low precedence. 
It executes after the comparison <code>&gt;</code>, so that’ll do the same:

    <code>// the comparison operator &quot;age &gt; 18&quot; executes first anyway
// (no need to wrap it into parentheses)
let accessAllowed = age &gt; 18 ? true : false;</code>
  But parentheses make the code more readable, so it’s recommended to use them.

Please note:
In the example above it’s possible to evade the question mark operator, because the comparison by itself returns <code>true/false</code>:

    <code>// the same
let accessAllowed = age &gt; 18;</code>
  
<h2>Multiple ‘?’</h2>
A sequence of question mark <code>?</code> operators allows returning a value that depends on more than one condition.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let age = prompt('age?', 18);
let message = (age &lt; 3) ? 'Hi, baby!' :
  (age &lt; 18) ? 'Hello!' :
  (age &lt; 100) ? 'Greetings!' :
  'What an unusual age!';
alert( message );</code>
  It may be difficult at first to grasp what’s going on. 
But after a closer look we can see that it’s just an ordinary sequence of tests.

<li>The first question mark checks whether <code>age &lt; 3</code>.</li><li>If true – returns <code>'Hi, baby!'</code>, otherwise – goes after the colon <code>&quot;:&quot;</code> and checks for <code>age &lt; 18</code>.</li><li>If that’s true – returns <code>'Hello!'</code>, otherwise – goes after the next colon <code>&quot;:&quot;</code> and checks for <code>age &lt; 100</code>.</li><li>If that’s true – returns <code>'Greetings!'</code>, otherwise – goes after the last colon <code>&quot;:&quot;</code> and returns <code>'What an unusual age!'</code>.</li>

The same logic using <code>if..else</code>:

    <code>if (age &lt; 3) {
  message = 'Hi, baby!';
} else if (age &lt; 18) {
  message = 'Hello!';
} else if (age &lt; 100) {
  message = 'Greetings!';
} else {
  message = 'What an unusual age!';
}</code>
  <h2>Non-traditional use of ‘?’</h2>
Sometimes the question mark <code>?</code> is used as a replacement for <code>if</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let company = prompt('Which company created JavaScript?', '');
(company == 'Netscape') ?
   alert('Right!') : alert('Wrong.');</code>
  Depending on the condition <code>company == 'Netscape'</code>, either the first or the second part after <code>?</code> gets executed and shows the alert.

We don’t assign a result to a variable here. 
The idea is to execute different code depending on the condition.

<strong>It is not recommended to use the question mark operator in this way.</strong>

The notation seems to be shorter than <code>if</code>, which appeals to some programmers. 
But it is less readable.

Here is the same code with <code>if</code> for comparison:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let company = prompt('Which company created JavaScript?', '');
if (company == 'Netscape') {
  alert('Right!');
} else {
  alert('Wrong.');
}</code>
  Our eyes scan the code vertically. 
The constructs which span several lines are easier to understand than a long horizontal instruction set.

The idea of a question mark <code>?</code> is to return one or another value depending on the condition. 
Please use it for exactly that. 
There is <code>if</code> to execute different branches of the code.

    <code>if (&quot;0&quot;) {
  alert( 'Hello' );
}</code>
  <button type="button">solution</button>

<strong>Yes, it will.</strong>

Any string except an empty one (and <code>&quot;0&quot;</code> is not empty) becomes <code>true</code> in the logical context.

We can run and check:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>if (&quot;0&quot;) {
  alert( 'Hello' );
}</code>
  <button type="button" title="close"></button>

<h3><a href="#the-name-of-javascript" name="the-name-of-javascript">The name of JavaScript</a></h3><a href="/task/check-standard" target="_blank"></a>

importance: 2

Using the <code>if..else</code> construct, write the code which asks: ‘What is the “official” name of JavaScript?’

If the visitor enters “ECMAScript”, then output “Right!”, otherwise – output: “Didn’t know? ECMAScript!”

<img src="https://javascript.info/task/check-standard/ifelse_task2.png">
<a href="https://en.js.cx/task/check-standard/ifelse_task2/" target="blank">Demo in new window</a>
<button type="button">solution</button>

    

      <a href="#" title="show" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;
  &lt;script&gt;
    'use strict';
    let value = prompt('What is the &quot;official&quot; name of JavaScript?', '');
    if (value == 'ECMAScript') {
alert('Right!');
    } else {
alert(&quot;You don't know? ECMAScript!&quot;);
    }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code>
  <button type="button" title="close"></button>

<h3><a href="#show-the-sign" name="show-the-sign">Show the sign</a></h3><a href="/task/sign" target="_blank"></a>

importance: 2

Using <code>if..else</code>, write the code which gets a number via <code>prompt</code> and then shows in <code>alert</code>:

<li><code>1</code>, if the value is greater than zero,</li><li><code>-1</code>, if less than zero,</li><li><code>0</code>, if equals zero.</li>

In this task we assume that the input is always a number.

<a href="https://en.js.cx/task/sign/if_sign/" target="blank">Demo in new window</a>
<button type="button">solution</button>

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let value = prompt('Type a number', 0);
if (value &gt; 0) {
  alert( 1 );
} else if (value &lt; 0) {
  alert( -1 );
} else {
  alert( 0 );
}</code>
  <button type="button" title="close"></button>

<h3><a href="#check-the-login" name="check-the-login">Check the login</a></h3><a href="/task/check-login" target="_blank"></a>

importance: 3

Write the code which asks for a login with <code>prompt</code>.

If the visitor enters <code>&quot;Admin&quot;</code>, then <code>prompt</code> for a password, if the input is an empty line or <kbd>Esc</kbd> – show “Canceled.”, if it’s another string – then show “I don’t know you”.

The password is checked as follows:

<li>If it equals “TheMaster”, then show “Welcome!”,</li><li>Another string – show “Wrong password”,</li><li>For an empty string or cancelled input, show “Canceled.”</li>

The schema:

<img src="https://javascript.info/task/check-login/ifelse_task.png">
Please use nested <code>if</code> blocks. 
Mind the overall readability of the code.

Hint: passing an empty input to a prompt returns an empty string <code>''</code>. 
Pressing <kbd>ESC</kbd> during a prompt returns <code>null</code>.

<a href="#" onclick="event.preventDefault(); runDemo(this)">Run the demo</a>
<button type="button">solution</button>

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let userName = prompt(&quot;Who's there?&quot;, '');
if (userName == 'Admin') {
  let pass = prompt('Password?', '');
  if (pass == 'TheMaster') {
    alert( 'Welcome!' );
  } else if (pass == '' || pass == null) {
    alert( 'Canceled.' );
  } else {
    alert( 'Wrong password' );
  }
} else if (userName == '' || userName == null) {
  alert( 'Canceled' );
} else {
  alert( &quot;I don't know you&quot; );
}</code>
  Note the vertical indents inside the <code>if</code> blocks. 
They are technically not required, but make the code more readable.

<button type="button" title="close"></button>

<h3><a href="#rewrite-if-into" name="rewrite-if-into">Rewrite 'if' into '?'</a></h3><a href="/task/rewrite-if-question" target="_blank"></a>

importance: 5

Rewrite this <code>if</code> using the ternary operator <code>'?'</code>:

    <code>if (a + b &lt; 4) {
  result = 'Below';
} else {
  result = 'Over';
}</code>
  <button type="button">solution</button>

    <code>result = (a + b &lt; 4) ? 'Below' : 'Over';</code>
  <button type="button" title="close"></button>

<h3><a href="#rewrite-if-else-into" name="rewrite-if-else-into">Rewrite 'if..else' into '?'</a></h3><a href="/task/rewrite-if-else-question" target="_blank"></a>

importance: 5

Rewrite <code>if..else</code> using multiple ternary operators <code>'?'</code>.

For readability, it’s recommended to split the code into multiple lines.

    <code>let message;
if (login == 'Employee') {
  message = 'Hello';
} else if (login == 'Director') {
  message = 'Greetings';
} else if (login == '') {
  message = 'No login';
} else {
  message = '';
}</code>
  <button type="button">solution</button>

    <code>let message = (login == 'Employee') ? 'Hello' :
  (login == 'Director') ? 'Greetings' :
  (login == '') ? 'No login' :
  '';</code>
  <button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/alert-prompt-confirm" data-tooltip="Interaction: alert, prompt, confirm">Previous lesson</a><a href="/logical-operators" data-tooltip="Logical operators">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Fifelse"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Fifelse"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Fifelse"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Fifelse"></a>

There are three logical operators in JavaScript: <code>||</code> (OR), <code>&amp;&amp;</code> (AND), <code>!</code> (NOT).

Although they are called “logical”, they can be applied to values of any type, not only boolean. 
The result can also be of any type.

Let’s see the details.

<h2>|| (OR)</h2>
The “OR” operator is represented with two vertical line symbols:

    <code>result = a || b;</code>
  In classical programming, logical OR is meant to manipulate boolean values only. 
If any of its arguments are <code>true</code>, then it returns <code>true</code>, otherwise it returns <code>false</code>.

In JavaScript the operator is a little bit more tricky and powerful. 
But first let’s see what happens with boolean values.

There are four possible logical combinations:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false</code>
  As we can see, the result is always <code>true</code> except for the case when both operands are <code>false</code>.

If an operand is not boolean, then it’s converted to boolean for the evaluation.

For instance, a number <code>1</code> is treated as <code>true</code>, a number <code>0</code> – as <code>false</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>if (1 || 0) { // works just like if( true || false )
  alert( 'truthy!' );
}</code>
  Most of the time, OR <code>||</code> is used in an <code>if</code> statement to test if <em>any</em> of the given conditions is correct.

For example:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let hour = 9;
if (hour &lt; 10 || hour &gt; 18) {
  alert( 'The office is closed.' );
}</code>
  We can pass more conditions:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let hour = 12;
let isWeekend = true;
if (hour &lt; 10 || hour &gt; 18 || isWeekend) {
  alert( 'The office is closed.' ); // it is the weekend
}</code>
  <h2>OR seeks the first truthy value</h2>
The logic described above is somewhat classical. 
Now let’s bring in the “extra” features of JavaScript.

The extended algorithm works as follows.

Given multiple OR’ed values:

    <code>result = value1 || value2 || value3;</code>
  The OR <code>||</code> operator does the following:

<li>Evaluate operands from left to right.</li><li>For each operand, convert it to boolean. 
If the result is <code>true</code>, then stop and return the original value of that operand.</li><li>If all other operands have been assessed (i.e. 
all were <code>false</code>), return the last operand.</li>

A value is returned in its original form, without the conversion.

In other words, a chain of OR <code>&quot;||&quot;</code> returns the first truthy value or the last one if no such value is found.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( 1 || 0 ); // 1 (1 is truthy)
alert( true || 'no matter what' ); // (true is truthy)
alert( null || 1 ); // 1 (1 is the first truthy value)
alert( null || 0 || 1 ); // 1 (the first truthy value)
alert( undefined || null || 0 ); // 0 (all falsy, returns the last value)</code>
  That leads to some interesting usages compared to a “pure, classical, boolean-only OR”.

<li><strong>Getting the first truthy value from the list of variables or expressions.</strong>

Imagine we have several variables, which can either contain the data or be <code>null/undefined</code>. 
And we need to choose the first one with data.

We can use OR <code>||</code> for that:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let currentUser = null;
let defaultUser = &quot;John&quot;;
let name = currentUser || defaultUser || &quot;unnamed&quot;;
alert( name ); // selects &quot;John&quot; – the first truthy value</code>
  If both <code>currentUser</code> and <code>defaultUser</code> were falsy then <code>&quot;unnamed&quot;</code> would be the result.

</li><li><strong>Short-circuit evaluation.</strong>

Operands can be not only values, but arbitrary expressions. 
OR evaluates and tests them from left to right. 
The evaluation stops when a truthy value is reached, and the value is returned. 
The process is called “a short-circuit evaluation”, because it goes as short as possible from left to right.

This is clearly seen when the expression given as the second argument has a side effect. 
Like a variable assignment.

If we run the example below, <code>x</code> would not get assigned:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let x;
true || (x = 1);
alert(x); // undefined, because (x = 1) not evaluated</code>
  …And if the first argument is <code>false</code>, then <code>OR</code> goes on and evaluates the second one thus running the assignment:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let x;
false || (x = 1);
alert(x); // 1</code>
  An assignment is a simple case, other side effects can be involved.

As we can see, such a use case is a &quot;shorter way to do <code>if</code>&quot;. 
The first operand is converted to boolean and if it’s false then the second one is evaluated.

Most of time it’s better to use a “regular” <code>if</code> to keep the code easy to understand, but sometimes that can be handy.

</li>

<h2>&amp;&amp; (AND)</h2>
The AND operator is represented with two ampersands <code>&amp;&amp;</code>:

    <code>result = a &amp;&amp; b;</code>
  In classical programming AND returns <code>true</code> if both operands are truthy and <code>false</code> otherwise:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( true &amp;&amp; true );   // true
alert( false &amp;&amp; true );  // false
alert( true &amp;&amp; false );  // false
alert( false &amp;&amp; false ); // false</code>
  An example with <code>if</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let hour = 12;
let minute = 30;
if (hour == 12 &amp;&amp; minute == 30) {
  alert( 'Time is 12:30' );
}</code>
  Just as for OR, any value is allowed as an operand of AND:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>if (1 &amp;&amp; 0) { // evaluated as true &amp;&amp; false
  alert( &quot;won't work, because the result is falsy&quot; );
}</code>
  <h2>AND seeks the first falsy value</h2>
Given multiple AND’ed values:

    <code>result = value1 &amp;&amp; value2 &amp;&amp; value3;</code>
  The AND <code>&amp;&amp;</code> operator does the following:

<li>Evaluate operands from left to right.</li><li>For each operand, convert it to a boolean. 
If the result is <code>false</code>, stop and return the original value of that operand.</li><li>If all other operands have been assessed (i.e. 
all were truthy), return the last operand.</li>

In other words, AND returns the first falsy value or the last value if none were found.

The rules above are similar to OR. 
The difference is that AND returns the first <em>falsy</em> value while OR returns the first <em>truthy</em> one.

Examples:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// if the first operand is truthy,
// AND returns the second operand:
alert( 1 &amp;&amp; 0 ); // 0
alert( 1 &amp;&amp; 5 ); // 5
// if the first operand is falsy,
// AND returns it. 
The second operand is ignored
alert( null &amp;&amp; 5 ); // null
alert( 0 &amp;&amp; &quot;no matter what&quot; ); // 0</code>
  We can also pass several values in a row. 
See how the first falsy one is returned:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( 1 &amp;&amp; 2 &amp;&amp; null &amp;&amp; 3 ); // null</code>
  When all values are truthy, the last value is returned:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( 1 &amp;&amp; 2 &amp;&amp; 3 ); // 3, the last one</code>
  
AND <code>&amp;&amp;</code> executes before OR <code>||</code>
The precedence of the AND <code>&amp;&amp;</code> operator is higher than OR <code>||</code>, so it executes before OR.

In the code below <code>1 &amp;&amp; 0</code> is calculated first:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( 5 || 1 &amp;&amp; 0 ); // 5</code>
  
Just like OR, the AND <code>&amp;&amp;</code> operator can sometimes replace <code>if</code>.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let x = 1;
(x &gt; 0) &amp;&amp; alert( 'Greater than zero!' );</code>
  The action in the right part of <code>&amp;&amp;</code> would execute only if the evaluation reaches it. 
That is: only if <code>(x &gt; 0)</code> is true.

So we basically have an analogue for:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let x = 1;
if (x &gt; 0) {
  alert( 'Greater than zero!' );
}</code>
  The variant with <code>&amp;&amp;</code> appears to be shorter. 
But <code>if</code> is more obvious and tends to be a little bit more readable.

So it is recommended to use every construct for its purpose. 
Use <code>if</code> if we want if. 
And use <code>&amp;&amp;</code> if we want AND.

<h2>! (NOT)</h2>
The boolean NOT operator is represented with an exclamation sign <code>!</code>.

The syntax is pretty simple:

    <code>result = !value;</code>
  The operator accepts a single argument and does the following:

<li>Converts the operand to boolean type: <code>true/false</code>.</li><li>Returns an inverse value.</li>

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( !true ); // false
alert( !0 ); // true</code>
  A double NOT <code>!!</code> is sometimes used for converting a value to boolean type:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( !!&quot;non-empty string&quot; ); // true
alert( !!null ); // false</code>
  That is, the first NOT converts the value to boolean and returns the inverse, and the second NOT inverses it again. 
At the end we have a plain value-to-boolean conversion.

There’s a little more verbose way to do the same thing – a built-in <code>Boolean</code> function:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( Boolean(&quot;non-empty string&quot;) ); // true
alert( Boolean(null) ); // false</code>
  

    <code>alert( null || 2 || undefined );</code>
  <button type="button">solution</button>

The answer is <code>2</code>, that’s the first truthy value.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( null || 2 || undefined );</code>
  <button type="button" title="close"></button>

<h3><a href="#what-s-the-result-of-or-ed-alerts" name="what-s-the-result-of-or-ed-alerts">What's the result of OR'ed alerts?</a></h3><a href="/task/alert-or" target="_blank"></a>

importance: 3

What the code below will output?

    <code>alert( alert(1) || 2 || alert(3) );</code>
  <button type="button">solution</button>

The answer: first <code>1</code>, then <code>2</code>.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( alert(1) || 2 || alert(3) );</code>
  The call to <code>alert</code> does not return a value. 
Or, in other words, it returns <code>undefined</code>.

<li>The first OR <code>||</code> evaluates it’s left operand <code>alert(1)</code>. 
That shows the first message with <code>1</code>.</li><li>The <code>alert</code> returns <code>undefined</code>, so OR goes on to the second operand searching for a truthy value.</li><li>The second operand <code>2</code> is truthy, so the execution is halted, <code>2</code> is returned and then shown by the outer alert.</li>

There will be no <code>3</code>, because the evaluation does not reach <code>alert(3)</code>.

<button type="button" title="close"></button>

<h3><a href="#what-is-the-result-of-and" name="what-is-the-result-of-and">What is the result of AND?</a></h3><a href="/task/alert-1-null-2" target="_blank"></a>

importance: 5

What this code is going to show?

    <code>alert( 1 &amp;&amp; null &amp;&amp; 2 );</code>
  <button type="button">solution</button>

The answer: <code>null</code>, because it’s the first falsy value from the list.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( 1 &amp;&amp; null &amp;&amp; 2 );</code>
  <button type="button" title="close"></button>

<h3><a href="#what-is-the-result-of-and-ed-alerts" name="what-is-the-result-of-and-ed-alerts">What is the result of AND'ed alerts?</a></h3><a href="/task/alert-and" target="_blank"></a>

importance: 3

What will this code show?

    <code>alert( alert(1) &amp;&amp; alert(2) );</code>
  <button type="button">solution</button>

The answer: <code>1</code>, and then <code>undefined</code>.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( alert(1) &amp;&amp; alert(2) );</code>
  The call to <code>alert</code> returns <code>undefined</code> (it just shows a message, so there’s no meaningful return).

Because of that, <code>&amp;&amp;</code> evaluates the left operand (outputs <code>1</code>), and immediately stops, because <code>undefined</code> is a falsy value. 
And <code>&amp;&amp;</code> looks for a falsy value and returns it, so it’s done.

<button type="button" title="close"></button>

<h3><a href="#the-result-of-or-and-or" name="the-result-of-or-and-or">The result of OR AND OR</a></h3><a href="/task/alert-and-or" target="_blank"></a>

importance: 5

What will be the result?

    <code>alert( null || 2 &amp;&amp; 3 || 4 );</code>
  <button type="button">solution</button>

The answer: <code>3</code>.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( null || 2 &amp;&amp; 3 || 4 );</code>
  The precedence of AND <code>&amp;&amp;</code> is higher than <code>||</code>, so it executes first.

The result of <code>2 &amp;&amp; 3 = 3</code>, so the expression becomes:

    <code>null || 3 || 4</code>
  Now the result if the first truthy value: <code>3</code>.

<button type="button" title="close"></button>

<h3><a href="#check-the-range-between" name="check-the-range-between">Check the range between</a></h3><a href="/task/check-if-in-range" target="_blank"></a>

importance: 3

Write an “if” condition to check that <code>age</code> is between <code>14</code> and <code>90</code> inclusively.

“Inclusively” means that <code>age</code> can reach the edges <code>14</code> or <code>90</code>.

<button type="button">solution</button>

    <code>if (age &gt;= 14 &amp;&amp; age &lt;= 90)</code>
  <button type="button" title="close"></button>

<h3><a href="#check-the-range-outside" name="check-the-range-outside">Check the range outside</a></h3><a href="/task/check-if-out-range" target="_blank"></a>

importance: 3

Write an <code>if</code> condition to check that <code>age</code> is NOT between 14 and 90 inclusively.

Create two variants: the first one using NOT <code>!</code>, the second one – without it.

<button type="button">solution</button>

The first variant:

    <code>if (!(age &gt;= 14 &amp;&amp; age &lt;= 90))</code>
  The second variant:

    <code>if (age &lt; 14 || age &gt; 90)</code>
  <button type="button" title="close"></button>

<h3><a href="#a-question-about-if" name="a-question-about-if">A question about &quot;if&quot;</a></h3><a href="/task/if-question" target="_blank"></a>

importance: 5

Which of these <code>alert</code>s are going to execute?

What will be the results of the expressions inside <code>if(...)</code>?

    <code>if (-1 || 0) alert( 'first' );
if (-1 &amp;&amp; 0) alert( 'second' );
if (null || -1 &amp;&amp; 1) alert( 'third' );</code>
  <button type="button">solution</button>

The answer: the first and the third will execute.

Details:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// Runs.
// The result of -1 || 0 = -1, truthy
if (-1 || 0) alert( 'first' );
// Doesn't run
// -1 &amp;&amp; 0 = 0, falsy
if (-1 &amp;&amp; 0) alert( 'second' );
// Executes
// Operator &amp;&amp; has a higher precedence than ||
// so -1 &amp;&amp; 1 executes first, giving us the chain:
// null || -1 &amp;&amp; 1  -&gt;  null || 1  -&gt;  1
if (null || -1 &amp;&amp; 1) alert( 'third' );</code>
  <button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/ifelse" data-tooltip="Conditional operators: if, '?'">Previous lesson</a><a href="/while-for" data-tooltip="Loops: while and for">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Flogical-operators"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Flogical-operators"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Flogical-operators"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Flogical-operators"></a>

We often have a need to perform similar actions many times in a row.

For example, when we need to output goods from a list one after another. 
Or just run the same code for each number from 1 to 10.

<em>Loops</em> are a way to repeat the same part of code multiple times.

<h2>The “while” loop</h2>
The <code>while</code> loop has the following syntax:

    <code>while (condition) {
  // code
  // so-called &quot;loop body&quot;
}</code>
  While the <code>condition</code> is <code>true</code>, the <code>code</code> from the loop body is executed.

For instance, the loop below outputs <code>i</code> while <code>i &lt; 3</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let i = 0;
while (i &lt; 3) { // shows 0, then 1, then 2
  alert( i );
  i++;
}</code>
  A single execution of the loop body is called <em>an iteration</em>. 
The loop in the example above makes three iterations.

If there were no <code>i++</code> in the example above, the loop would repeat (in theory) forever. 
In practice, the browser provides ways to stop such loops, and for server-side JavaScript we can kill the process.

Any expression or a variable can be a loop condition, not just a comparison. 
They are evaluated and converted to a boolean by <code>while</code>.

For instance, the shorter way to write <code>while (i != 0)</code> could be <code>while (i)</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let i = 3;
while (i) { // when i becomes 0, the condition becomes falsy, and the loop stops
  alert( i );
  i--;
}</code>
  
Brackets are not required for a single-line body
If the loop body has a single statement, we can omit the brackets <code>{…}</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let i = 3;
while (i) alert(i--);</code>
  
<h2>The “do…while” loop</h2>
The condition check can be moved <em>below</em> the loop body using the <code>do..while</code> syntax:

    <code>do {
  // loop body
} while (condition);</code>
  The loop will first execute the body, then check the condition and, while it’s truthy, execute it again and again.

For example:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let i = 0;
do {
  alert( i );
  i++;
} while (i &lt; 3);</code>
  This form of syntax is rarely used except when you want the body of the loop to execute <strong>at least once</strong> regardless of the condition being truthy. 
Usually, the other form is preferred: <code>while(…) {…}</code>.

<h2>The “for” loop</h2>
The <code>for</code> loop is the most often used one.

It looks like this:

    <code>for (begin; condition; step) {
  // ... 
loop body ...
}</code>
  Let’s learn the meaning of these parts by example. 
The loop below runs <code>alert(i)</code> for <code>i</code> from <code>0</code> up to (but not including) <code>3</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>for (let i = 0; i &lt; 3; i++) { // shows 0, then 1, then 2
  alert(i);
}</code>
  Let’s examine the <code>for</code> statement part by part:

<table>
<thead>
<tr>
<th>part</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>begin</td>
<td><code>i = 0</code></td>
<td>Executes once upon entering the loop.</td>
</tr>
<tr>
<td>condition</td>
<td><code>i &lt; 3</code></td>
<td>Checked before every loop iteration, if fails the loop stops.</td>
</tr>
<tr>
<td>step</td>
<td><code>i++</code></td>
<td>Executes after the body on each iteration, but before the condition check.</td>
</tr>
<tr>
<td>body</td>
<td><code>alert(i)</code></td>
<td>Runs again and again while the condition is truthy</td>
</tr>
</tbody>
</table>

The general loop algorithm works like this:

    <code>Run begin
→ (if condition → run body and run step)
→ (if condition → run body and run step)
→ (if condition → run body and run step)
→ ...</code>
  If you are new to loops, then maybe it would help if you go back to the example and reproduce how it runs step-by-step on a piece of paper.

Here’s what exactly happens in our case:

    <code>// for (let i = 0; i &lt; 3; i++) alert(i)
// run begin
let i = 0
// if condition → run body and run step
if (i &lt; 3) { alert(i); i++ }
// if condition → run body and run step
if (i &lt; 3) { alert(i); i++ }
// if condition → run body and run step
if (i &lt; 3) { alert(i); i++ }
// ...finish, because now i == 3</code>
  
Inline variable declaration
Here the “counter” variable <code>i</code> is declared right in the loop. 
That’s called an “inline” variable declaration. 
Such variables are visible only inside the loop.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>for (let i = 0; i &lt; 3; i++) {
  alert(i); // 0, 1, 2
}
alert(i); // error, no such variable</code>
  Instead of defining a variable, we can use an existing one:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let i = 0;
for (i = 0; i &lt; 3; i++) { // use an existing variable
  alert(i); // 0, 1, 2
}
alert(i); // 3, visible, because declared outside of the loop</code>
  
<h3><a name="skipping-parts" href="#skipping-parts">Skipping parts</a></h3>
Any part of <code>for</code> can be skipped.

For example, we can omit <code>begin</code> if we don’t need to do anything at the loop start.

Like here:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let i = 0; // we have i already declared and assigned
for (; i &lt; 3; i++) { // no need for &quot;begin&quot;
  alert( i ); // 0, 1, 2
}</code>
  We can also remove the <code>step</code> part:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let i = 0;
for (; i &lt; 3;) {
  alert( i++ );
}</code>
  The loop became identical to <code>while (i &lt; 3)</code>.

We can actually remove everything, thus creating an infinite loop:

    <code>for (;;) {
  // repeats without limits
}</code>
  Please note that the two <code>for</code> semicolons <code>;</code> must be present, otherwise it would be a syntax error.

<h2>Breaking the loop</h2>
Normally the loop exits when the condition becomes falsy.

But we can force the exit at any moment. 
There’s a special <code>break</code> directive for that.

For example, the loop below asks the user for a series of numbers, but “breaks” when no number is entered:

    <code>let sum = 0;
while (true) {
  let value = +prompt(&quot;Enter a number&quot;, '');
  if (!value) break; // (*)
  sum += value;
}
alert( 'Sum: ' + sum );</code>
  The <code>break</code> directive is activated at the line <code>(*)</code> if the user enters an empty line or cancels the input. 
It stops the loop immediately, passing the control to the first line after the loop. 
Namely, <code>alert</code>.

The combination “infinite loop + <code>break</code> as needed” is great for situations when the condition must be checked not in the beginning/end of the loop, but in the middle, or even in several places of the body.

<h2>Continue to the next iteration</h2>
The <code>continue</code> directive is a “lighter version” of <code>break</code>. 
It doesn’t stop the whole loop. 
Instead it stops the current iteration and forces the loop to start a new one (if the condition allows).

We can use it if we’re done on the current iteration and would like to move on to the next.

The loop below uses <code>continue</code> to output only odd values:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>for (let i = 0; i &lt; 10; i++) {
  // if true, skip the remaining part of the body
  if (i % 2 == 0) continue;
  alert(i); // 1, then 3, 5, 7, 9
}</code>
  For even values of <code>i</code> the <code>continue</code> directive stops body execution, passing the control to the next iteration of <code>for</code> (with the next number). 
So the <code>alert</code> is only called for odd values.

The directive <code>continue</code> helps to decrease nesting level
A loop that shows odd values could look like this:

    <code>for (let i = 0; i &lt; 10; i++) {
  if (i % 2) {
    alert( i );
  }
}</code>
  From a technical point of view it’s identical to the example above. 
Surely, we can just wrap the code in the <code>if</code> block instead of <code>continue</code>.

But as a side-effect we got one more nesting level (the <code>alert</code> call inside the curly braces). 
If the code inside <code>if</code> is longer than a few lines, that may decrease the overall readability.

No <code>break/continue</code> to the right side of ‘?’
Please note that syntax constructs that are not expressions cannot be used with the ternary operator <code>?</code>. 
In particular, directives such as <code>break/continue</code> are disallowed there.

For example, if we take this code:

    <code>if (i &gt; 5) {
  alert(i);
} else {
  continue;
}</code>
  …And rewrite it using a question mark:

    <code>(i &gt; 5) ? alert(i) : continue; // continue not allowed here</code>
  …Then it stops working. 
The code like this will give a syntax error:

That’s just another reason not to use a question mark operator <code>?</code> instead of <code>if</code>.

<h2>Labels for break/continue</h2>
Sometimes we need to break out from multiple nested loops at once.

For example, in the code below we loop over <code>i</code> and <code>j</code> prompting for coordinates <code>(i, j)</code> from <code>(0,0)</code> to <code>(3,3)</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>for (let i = 0; i &lt; 3; i++) {
  for (let j = 0; j &lt; 3; j++) {
    let input = prompt(`Value at coords (${i},${j})`, '');
    // what if I want to exit from here to Done (below)?
  }
}
alert('Done!');</code>
  We need a way to stop the process if the user cancels the input.

The ordinary <code>break</code> after <code>input</code> would only break the inner loop. 
That’s not sufficient. 
Labels come to the rescue.

A <em>label</em> is an identifier with a colon before a loop:

    <code>labelName: for (...) {
  ...
}</code>
  The <code>break &lt;labelName&gt;</code> statement in the loop breaks out to the label.

Like here:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>outer: for (let i = 0; i &lt; 3; i++) {
  for (let j = 0; j &lt; 3; j++) {
    let input = prompt(`Value at coords (${i},${j})`, '');
    // if an empty string or canceled, then break out of both loops
    if (!input) break outer; // (*)
    // do something with the value...
  }
}
alert('Done!');</code>
  In the code above <code>break outer</code> looks upwards for the label named <code>outer</code> and breaks out of that loop.

So the control goes straight from <code>(*)</code> to <code>alert('Done!')</code>.

We can also move the label onto a separate line:

    <code>outer:
for (let i = 0; i &lt; 3; i++) { ... 
}</code>
  The <code>continue</code> directive can also be used with a label. 
In this case the execution jumps to the next iteration of the labeled loop.

Labels are not a “goto”
Labels do not allow us to jump into an arbitrary place of code.

For example, it is impossible to do this:

    <code>break label;  // jumps to label? No.
label: for (...)</code>
  The call to a <code>break/continue</code> is only possible from inside the loop, and the label must be somewhere upwards from the directive.

<h4><a name="summary" href="#summary">Summary</h4>
We covered 3 types of loops:

<li><code>while</code> – The condition is checked before each iteration.</li><li><code>do..while</code> – The condition is checked after each iteration.</li><li><code>for (;;)</code> – The condition is checked before each iteration, additional settings available.</li>

To make an “infinite” loop, usually the <code>while(true)</code> construct is used. 
Such a loop, just like any other, can be stopped with the <code>break</code> directive.

If we don’t want to do anything on the current iteration and would like to forward to the next one, the <code>continue</code> directive does it.

<code>break/continue</code> support labels before the loop. 
A label is the only way for <code>break/continue</code> to escape the nesting and go to the outer loop.

    <code>let i = 3;
while (i) {
  alert( i-- );
}</code>
  <button type="button">solution</button>

The answer: <code>1</code>.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let i = 3;
while (i) {
  alert( i-- );
}</code>
  Every loop iteration decreases <code>i</code> by <code>1</code>. 
The check <code>while(i)</code> stops the loop when <code>i = 0</code>.

Hence, the steps of the loop form the following sequence (“loop unrolled”):

    <code>let i = 3;
alert(i--); // shows 3, decreases i to 2
alert(i--) // shows 2, decreases i to 1
alert(i--) // shows 1, decreases i to 0
// done, while(i) check stops the loop</code>
  <button type="button" title="close"></button>

<h3><a href="#which-values-shows-the-while" name="which-values-shows-the-while">Which values shows the while?</a></h3><a href="/task/which-value-while" target="_blank"></a>

importance: 4

For every loop, write down which values it shows, in your opinion. 
And then compare with the answer.

Both loops <code>alert</code> same values or not?

<li>The prefix form <code>++i</code>:

    <code>let i = 0;
while (++i &lt; 5) alert( i );</code>
  </li><li>The postfix form <code>i++</code>

    <code>let i = 0;
while (i++ &lt; 5) alert( i );</code>
  </li>

<button type="button">solution</button>

The task demonstrates how postfix/prefix forms can lead to different results when used in comparisons.

<li><strong>From 1 to 4</strong>

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let i = 0;
while (++i &lt; 5) alert( i );</code>
  The first value is <code>i=1</code>, because <code>++i</code> first increments <code>i</code> and then returns the new value. 
So the first comparison is <code>1 &lt; 5</code> and the <code>alert</code> shows <code>1</code>.

Then follow <code>2,3,4…</code> – the values show up one after another. 
The comparison always uses the incremented value, because <code>++</code> is before the variable.

Finally, <code>i=4</code> is incremented to <code>5</code>, the comparison <code>while(5 &lt; 5)</code> fails, and the loop stops. 
So <code>5</code> is not shown.

</li><li><strong>From 1 to 5</strong>

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let i = 0;
while (i++ &lt; 5) alert( i );</code>
  The first value is again <code>i=1</code>. 
The postfix form of <code>i++</code> increments <code>i</code> and then returns the <em>old</em> value, so the comparison <code>i++ &lt; 5</code> will use <code>i=0</code> (contrary to <code>++i &lt; 5</code>).

But the <code>alert</code> call is separate. 
It’s another statement which executes after the increment and the comparison. 
So it gets the current <code>i=1</code>.

Then follow <code>2,3,4…</code>

Let’s stop on <code>i=4</code>. 
The prefix form <code>++i</code> would increment it and use <code>5</code> in the comparison. 
But here we have the postfix form <code>i++</code>. 
So it increments <code>i</code> to <code>5</code>, but returns the old value. 
Hence the comparison is actually <code>while(4 &lt; 5)</code> – true, and the control goes on to <code>alert</code>.

The value <code>i=5</code> is the last one, because on the next step <code>while(5 &lt; 5)</code> is false.

</li>

<button type="button" title="close"></button>

<h3><a href="#which-values-get-shown-by-the-for-loop" name="which-values-get-shown-by-the-for-loop">Which values get shown by the &quot;for&quot; loop?</a></h3><a href="/task/which-value-for" target="_blank"></a>

importance: 4

For each loop write down which values it is going to show. 
Then compare with the answer.

Both loops <code>alert</code> same values or not?

<li>The postfix form:

    <code>for (let i = 0; i &lt; 5; i++) alert( i );</code>
  </li><li>The prefix form:

    <code>for (let i = 0; i &lt; 5; ++i) alert( i );</code>
  </li>

<button type="button">solution</button>

<strong>The answer: from <code>0</code> to <code>4</code> in both cases.</strong>

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>for (let i = 0; i &lt; 5; ++i) alert( i );
for (let i = 0; i &lt; 5; i++) alert( i );</code>
  That can be easily deducted from the algorithm of <code>for</code>:

<li>Execute once <code>i = 0</code> before everything (begin).</li><li>Check the condition <code>i &lt; 5</code></li><li>If <code>true</code> – execute the loop body <code>alert(i)</code>, and then <code>i++</code></li>

The increment <code>i++</code> is separated from the condition check (2). 
That’s just another statement.

The value returned by the increment is not used here, so there’s no difference between <code>i++</code> and <code>++i</code>.

<button type="button" title="close"></button>

<h3><a href="#output-even-numbers-in-the-loop" name="output-even-numbers-in-the-loop">Output even numbers in the loop</a></h3><a href="/task/for-even" target="_blank"></a>

importance: 5

Use the <code>for</code> loop to output even numbers from <code>2</code> to <code>10</code>.

<a href="#" onclick="event.preventDefault(); runDemo(this)">Run the demo</a>
<button type="button">solution</button>

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>for (let i = 2; i &lt;= 10; i++) {
  if (i % 2 == 0) {
    alert( i );
  }
}</code>
  We use the “modulo” operator <code>%</code> to get the remainder and check for the evenness here.

<button type="button" title="close"></button>

<h3><a href="#replace-for-with-while" name="replace-for-with-while">Replace &quot;for&quot; with &quot;while&quot;</a></h3><a href="/task/replace-for-while" target="_blank"></a>

importance: 5

Rewrite the code changing the <code>for</code> loop to <code>while</code> without altering its behavior (the output should stay same).

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>for (let i = 0; i &lt; 3; i++) {
  alert( `number ${i}!` );
}</code>
  <button type="button">solution</button>

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let i = 0;
while (i &lt; 3) {
  alert( `number ${i}!` );
  i++;
}</code>
  <button type="button" title="close"></button>

<h3><a href="#repeat-until-the-input-is-correct" name="repeat-until-the-input-is-correct">Repeat until the input is correct</a></h3><a href="/task/repeat-until-correct" target="_blank"></a>

importance: 5

Write a loop which prompts for a number greater than <code>100</code>. 
If the visitor enters another number – ask him to input again.

The loop must ask for a number until either the visitor enters a number greater than <code>100</code> or cancels the input/enters an empty line.

Here we can assume that the visitor only inputs numbers. 
There’s no need to implement a special handling for a non-numeric input in this task.

<a href="#" onclick="event.preventDefault(); runDemo(this)">Run the demo</a>
<button type="button">solution</button>

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let num;
do {
  num = prompt(&quot;Enter a number greater than 100?&quot;, 0);
} while (num &lt;= 100 &amp;&amp; num);</code>
  The loop <code>do..while</code> repeats while both checks are truthy:

<li>The check for <code>num &lt;= 100</code> – that is, the entered value is still not greater than <code>100</code>.</li><li>The check <code>&amp;&amp; num</code> is false when <code>num</code> is <code>null</code> or a empty string. 
Then the <code>while</code> loop stops too.</li>

P.S. 
If <code>num</code> is <code>null</code> then <code>num &lt;= 100</code> is <code>true</code>, so without the 2nd check the loop wouldn’t stop if the user clicks CANCEL. 
Both checks are required.

<button type="button" title="close"></button>

<h3><a href="#output-prime-numbers" name="output-prime-numbers">Output prime numbers</a></h3><a href="/task/list-primes" target="_blank"></a>

importance: 3

An integer number greater than <code>1</code> is called a <a href="https://en.wikipedia.org/wiki/Prime_number">prime</a> if it cannot be divided without a remainder by anything except <code>1</code> and itself.

In other words, <code>n &gt; 1</code> is a prime if it can’t be evenly divided by anything except <code>1</code> and <code>n</code>.

For example, <code>5</code> is a prime, because it cannot be divided without a remainder by <code>2</code>, <code>3</code> and <code>4</code>.

<strong>Write the code which outputs prime numbers in the interval from <code>2</code> to <code>n</code>.</strong>

For <code>n = 10</code> the result will be <code>2,3,5,7</code>.

P.S. 
The code should work for any <code>n</code>, not be hard-tuned for any fixed value.

<button type="button">solution</button>

There are many algorithms for this task.

Let’s use a nested loop:

    <code>For each i in the interval {
  check if i has a divisor from 1..i
  if yes =&gt; the value is not a prime
  if no =&gt; the value is a prime, show it
}</code>
  The code using a label:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let n = 10;
nextPrime:
for (let i = 2; i &lt;= n; i++) { // for each i...
  for (let j = 2; j &lt; i; j++) { // look for a divisor..
    if (i % j == 0) continue nextPrime; // not a prime, go next i
  }
  alert( i ); // a prime
}</code>
  There’s a lot of space to opimize it. 
For instance, we could look for the divisors from <code>2</code> to square root of <code>i</code>. 
But anyway, if we want to be really efficient for large intervals, we need change the approach and rely on advanced maths and complex algorithms like <a href="https://en.wikipedia.org/wiki/Quadratic_sieve">Quadratic sieve</a>, <a href="https://en.wikipedia.org/wiki/General_number_field_sieve">General number field sieve</a> etc.

<button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/logical-operators" data-tooltip="Logical operators">Previous lesson</a><a href="/switch" data-tooltip="The &quot;switch&quot; statement">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Fwhile-for"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Fwhile-for"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Fwhile-for"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Fwhile-for"></a>

A <code>switch</code> statement can replace multiple <code>if</code> checks.

It gives a more descriptive way to compare a value with multiple variants.

<h2>The syntax</h2>
The <code>switch</code> has one or more <code>case</code> blocks and an optional default.

It looks like this:

    <code>switch(x) {
  case 'value1':  // if (x === 'value1')
    ...
    [break]
  case 'value2':  // if (x === 'value2')
    ...
    [break]
  default:
    ...
    [break]
}</code>
  <li>The value of <code>x</code> is checked for a strict equality to the value from the first <code>case</code> (that is, <code>value1</code>) then to the second (<code>value2</code>) and so on.</li><li>If the equality is found, <code>switch</code> starts to execute the code starting from the corresponding <code>case</code>, until the nearest <code>break</code> (or until the end of <code>switch</code>).</li><li>If no case is matched then the <code>default</code> code is executed (if it exists).</li>

<h2>An example</h2>
An example of <code>switch</code> (the executed code is highlighted):

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let a = 2 + 2;
switch (a) {
  case 3:
    alert( 'Too small' );
    break;
  case 4:
    alert( 'Exactly!' );
    break;
  case 5:
    alert( 'Too large' );
    break;
  default:
    alert( &quot;I don't know such values&quot; );
}</code>
  Here the <code>switch</code> starts to compare <code>a</code> from the first <code>case</code> variant that is <code>3</code>. 
The match fails.

Then <code>4</code>. 
That’s a match, so the execution starts from <code>case 4</code> until the nearest <code>break</code>.

<strong>If there is no <code>break</code> then the execution continues with the next <code>case</code> without any checks.</strong>

An example without <code>break</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let a = 2 + 2;
switch (a) {
  case 3:
    alert( 'Too small' );
  case 4:
    alert( 'Exactly!' );
  case 5:
    alert( 'Too big' );
  default:
    alert( &quot;I don't know such values&quot; );
}</code>
  In the example above we’ll see sequential execution of three <code>alert</code>s:

    <code>alert( 'Exactly!' );
alert( 'Too big' );
alert( &quot;I don't know such values&quot; );</code>
  
Any expression can be a <code>switch/case</code> argument
Both <code>switch</code> and <code>case</code> allow arbitrary expressions.

For example:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let a = &quot;1&quot;;
let b = 0;
switch (+a) {
  case b + 1:
    alert(&quot;this runs, because +a is 1, exactly equals b+1&quot;);
    break;
  default:
    alert(&quot;this doesn't run&quot;);
}</code>
  Here <code>+a</code> gives <code>1</code>, that’s compared with <code>b + 1</code> in <code>case</code>, and the corresponding code is executed.

<h2>Grouping of “case”</h2>
Several variants of <code>case</code> which share the same code can be grouped.

For example, if we want the same code to run for <code>case 3</code> and <code>case 5</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let a = 2 + 2;
switch (a) {
  case 4:
    alert('Right!');
    break;
  case 3:                    // (*) grouped two cases
  case 5:
    alert('Wrong!');
    alert(&quot;Why don't you take a math class?&quot;);
    break;
  default:
    alert('The result is strange. 
Really.');
}</code>
  Now both <code>3</code> and <code>5</code> show the same message.

The ability to “group” cases is a side-effect of how <code>switch/case</code> works without <code>break</code>. 
Here the execution of <code>case 3</code> starts from the line <code>(*)</code> and goes through <code>case 5</code>, because there’s no <code>break</code>.

<h2>Type matters</h2>
Let’s emphasize that the equality check is always strict. 
The values must be of the same type to match.

For example, let’s consider the code:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let arg = prompt(&quot;Enter a value?&quot;)
switch (arg) {
  case '0':
  case '1':
    alert( 'One or zero' );
    break;
  case '2':
    alert( 'Two' );
    break;
  case 3:
    alert( 'Never executes!' );
    break;
  default:
    alert( 'An unknown value' )
}</code>
  <li>For <code>0</code>, <code>1</code>, the first <code>alert</code> runs.</li><li>For <code>2</code> the second <code>alert</code> runs.</li><li>But for <code>3</code>, the result of the <code>prompt</code> is a string <code>&quot;3&quot;</code>, which is not strictly equal <code>===</code> to the number <code>3</code>. 
So we’ve got a dead code in <code>case 3</code>! The <code>default</code> variant will execute.</li>

    <code>switch (browser) {
  case 'Edge':
    alert( &quot;You've got the Edge!&quot; );
    break;
  case 'Chrome':
  case 'Firefox':
  case 'Safari':
  case 'Opera':
    alert( 'Okay we support these browsers too' );
    break;
  default:
    alert( 'We hope that this page looks ok!' );
}</code>
  <button type="button">solution</button>

To precisely match the functionality of <code>switch</code>, the <code>if</code> must use a strict comparison <code>'==='</code>.

For given strings though, a simple <code>'=='</code> works too.

    <code>if(browser == 'Edge') {
  alert(&quot;You've got the Edge!&quot;);
} else if (browser == 'Chrome'
 || browser == 'Firefox'
 || browser == 'Safari'
 || browser == 'Opera') {
  alert( 'Okay we support these browsers too' );
} else {
  alert( 'We hope that this page looks ok!' );
}</code>
  Please note: the construct <code>browser == 'Chrome' || browser == 'Firefox' …</code> is split into multiple lines for better readability.

But the <code>switch</code> construct is still cleaner and more descriptive.

<button type="button" title="close"></button>

<h3><a href="#rewrite-if-into-switch" name="rewrite-if-into-switch">Rewrite &quot;if&quot; into &quot;switch&quot;</a></h3><a href="/task/rewrite-if-switch" target="_blank"></a>

importance: 4

Rewrite the code below using a single <code>switch</code> statement:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let a = +prompt('a?', '');
if (a == 0) {
  alert( 0 );
}
if (a == 1) {
  alert( 1 );
}
if (a == 2 || a == 3) {
  alert( '2,3' );
}</code>
  <button type="button">solution</button>

The first two checks turn into two <code>case</code>. 
The third check is split into two cases:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let a = +prompt('a?', '');
switch (a) {
  case 0:
    alert( 0 );
    break;
  case 1:
    alert( 1 );
    break;
  case 2:
  case 3:
    alert( '2,3' );
    break;
}</code>
  Please note: the <code>break</code> at the bottom is not required. 
But we put it to make the code future-proof.

In the future, there is a chance that we’d want to add one more <code>case</code>, for example <code>case 4</code>. 
And if we forget to add a break before it, at the end of <code>case 3</code>, there will be an error. 
So that’s a kind of self-insurance.

<button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/while-for" data-tooltip="Loops: while and for">Previous lesson</a><a href="/function-basics" data-tooltip="Functions">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Fswitch"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Fswitch"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Fswitch"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Fswitch"></a>

Quite often we need to perform a similar action in many places of the script.

For example, we need to show a nice-looking message when a visitor logs in, logs out and maybe somewhere else.

Functions are the main “building blocks” of the program. 
They allow the code to be called many times without repetition.

We’ve already seen examples of built-in functions, like <code>alert(message)</code>, <code>prompt(message, default)</code> and <code>confirm(question)</code>. 
But we can create functions of our own as well.

<h2>Function Declaration</h2>
To create a function we can use a <em>function declaration</em>.

It looks like this:

    <code>function showMessage() {
  alert( 'Hello everyone!' );
}</code>
  The <code>function</code> keyword goes first, then goes the <em>name of the function</em>, then a list of <em>parameters</em> between the parentheses (empty in the example above) and finally the code of the function, also named “the function body”, between curly braces.

<img src="https://javascript.info/article/function-basics/function_basics.png">
Our new function can be called by its name: <code>showMessage()</code>.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function showMessage() {
  alert( 'Hello everyone!' );
}
showMessage();
showMessage();</code>
  The call <code>showMessage()</code> executes the code of the function. 
Here we will see the message two times.

This example clearly demonstrates one of the main purposes of functions: to avoid code duplication.

If we ever need to change the message or the way it is shown, it’s enough to modify the code in one place: the function which outputs it.

<h2>Local variables</h2>
A variable declared inside a function is only visible inside that function.

For example:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function showMessage() {
  let message = &quot;Hello, I'm JavaScript!&quot;; // local variable
  alert( message );
}
showMessage(); // Hello, I'm JavaScript!
alert( message ); // &lt;-- Error! The variable is local to the function</code>
  <h2>Outer variables</h2>
A function can access an outer variable as well, for example:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let userName = 'John';
function showMessage() {
  let message = 'Hello, ' + userName;
  alert(message);
}
showMessage(); // Hello, John</code>
  The function has full access to the outer variable. 
It can modify it as well.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let userName = 'John';
function showMessage() {
  userName = &quot;Bob&quot;; // (1) changed the outer variable
  let message = 'Hello, ' + userName;
  alert(message);
}
alert( userName ); // John before the function call
showMessage();
alert( userName ); // Bob, the value was modified by the function</code>
  The outer variable is only used if there’s no local one. 
So an occasional modification may happen if we forget <code>let</code>.

If a same-named variable is declared inside the function then it <em>shadows</em> the outer one. 
For instance, in the code below the function uses the local <code>userName</code>. 
The outer one is ignored:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let userName = 'John';
function showMessage() {
  let userName = &quot;Bob&quot;; // declare a local variable
  let message = 'Hello, ' + userName; // Bob
  alert(message);
}
// the function will create and use its own userName
showMessage();
alert( userName ); // John, unchanged, the function did not access the outer variable</code>
  
Global variables
Variables declared outside of any function, such as the outer <code>userName</code> in the code above, are called <em>global</em>.

Global variables are visible from any function (unless shadowed by locals).

Usually, a function declares all variables specific to its task. 
Global variables only store project-level data, so when it’s important that these variables are accesible from anywhere. 
Modern code has few or no globals. 
Most variables reside in their functions.

<h2>Parameters</h2>
We can pass arbitrary data to functions using parameters (also called <em>function arguments</em>) .

In the example below, the function has two parameters: <code>from</code> and <code>text</code>.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function showMessage(from, text) { // arguments: from, text
  alert(from + ': ' + text);
}
showMessage('Ann', 'Hello!'); // Ann: Hello! (*)
showMessage('Ann', &quot;What's up?&quot;); // Ann: What's up? (**)</code>
  When the function is called in lines <code>(*)</code> and <code>(**)</code>, the given values are copied to local variables <code>from</code> and <code>text</code>. 
Then the function uses them.

Here’s one more example: we have a variable <code>from</code> and pass it to the function. 
Please note: the function changes <code>from</code>, but the change is not seen outside, because a function always gets a copy of the value:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function showMessage(from, text) {
  from = '*' + from + '*'; // make &quot;from&quot; look nicer
  alert( from + ': ' + text );
}
let from = &quot;Ann&quot;;
showMessage(from, &quot;Hello&quot;); // *Ann*: Hello
// the value of &quot;from&quot; is the same, the function modified a local copy
alert( from ); // Ann</code>
  <h2>Default values</h2>
If a parameter is not provided, then its value becomes <code>undefined</code>.

For instance, the aforementioned function <code>showMessage(from, text)</code> can be called with a single argument:

    <code>showMessage(&quot;Ann&quot;);</code>
  That’s not an error. 
Such a call would output <code>&quot;Ann: undefined&quot;</code>. 
There’s no <code>text</code>, so it’s assumed that <code>text === undefined</code>.

If we want to use a “default” <code>text</code> in this case, then we can specify it after <code>=</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function showMessage(from, text = &quot;no text given&quot;) {
  alert( from + &quot;: &quot; + text );
}
showMessage(&quot;Ann&quot;); // Ann: no text given</code>
  Now if the <code>text</code> parameter is not passed, it will get the value <code>&quot;no text given&quot;</code>

Here <code>&quot;no text given&quot;</code> is a string, but it can be a more complex expression, which is only evaluated and assigned if the parameter is missing. 
So, this is also possible:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function showMessage(from, text = anotherFunction()) {
  // anotherFunction() only executed if no text given
  // its result becomes the value of text
}</code>
  
Default parameters old-style
Old editions of JavaScript did not support default parameters. 
So there are alternative ways to support them, that you can find mostly in the old scripts.

For instance, an explicit check for being <code>undefined</code>:

    <code>function showMessage(from, text) {
  if (text === undefined) {
    text = 'no text given';
  }
  alert( from + &quot;: &quot; + text );
}</code>
  …Or the <code>||</code> operator:

    <code>function showMessage(from, text) {
  // if text is falsy then text gets the &quot;default&quot; value
  text = text || 'no text given';
  ...
}</code>
  
<h2>Returning a value</h2>
A function can return a value back into the calling code as the result.

The simplest example would be a function that sums two values:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function sum(a, b) {
  return a + b;
}
let result = sum(1, 2);
alert( result ); // 3</code>
  The directive <code>return</code> can be in any place of the function. 
When the execution reaches it, the function stops, and the value is returned to the calling code (assigned to <code>result</code> above).

There may be many occurrences of <code>return</code> in a single function. 
For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function checkAge(age) {
  if (age &gt; 18) {
    return true;
  } else {
    return confirm('Got a permission from the parents?');
  }
}
let age = prompt('How old are you?', 18);
if ( checkAge(age) ) {
  alert( 'Access granted' );
} else {
  alert( 'Access denied' );
}</code>
  It is possible to use <code>return</code> without a value. 
That causes the function to exit immediately.

For example:

    <code>function showMovie(age) {
  if ( !checkAge(age) ) {
    return;
  }
  alert( &quot;Showing you the movie&quot; ); // (*)
  // ...
}</code>
  In the code above, if <code>checkAge(age)</code> returns <code>false</code>, then <code>showMovie</code> won’t proceed to the <code>alert</code>.

A function with an empty <code>return</code> or without it returns <code>undefined</code>
If a function does not return a value, it is the same as if it returns <code>undefined</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function doNothing() { /* empty */ }
alert( doNothing() === undefined ); // true</code>
  An empty <code>return</code> is also the same as <code>return undefined</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function doNothing() {
  return;
}
alert( doNothing() === undefined ); // true</code>
  

Never add a newline between <code>return</code> and the value
For a long expression in <code>return</code>, it might be tempting to put it on a separate line, like this:

    <code>return
 (some + long + expression + or + whatever * f(a) + f(b))</code>
  That doesn’t work, because JavaScript assumes a semicolon after <code>return</code>. 
That’ll work the same as:

    <code>return;
 (some + long + expression + or + whatever * f(a) + f(b))</code>
  So, it effectively becomes an empty return. 
We should put the value on the same line instead.

<h2>Naming a function</h2>
Functions are actions. 
So their name is usually a verb. 
It should briefly, but as accurately as possible describe what the function does. 
So that a person who reads the code gets the right clue.

It is a widespread practice to start a function with a verbal prefix which vaguely describes the action. 
There must be an agreement within the team on the meaning of the prefixes.

For instance, functions that start with <code>&quot;show&quot;</code> usually show something.

Function starting with…

<li><code>&quot;get…&quot;</code> – return a value,</li><li><code>&quot;calc…&quot;</code> – calculate something,</li><li><code>&quot;create…&quot;</code> – create something,</li><li><code>&quot;check…&quot;</code> – check something and return a boolean, etc.</li>

Examples of such names:

    <code>showMessage(..)     // shows a message
getAge(..)          // returns the age (gets it somehow)
calcSum(..)         // calculates a sum and returns the result
createForm(..)      // creates a form (and usually returns it)
checkPermission(..) // checks a permission, returns true/false</code>
  With prefixes in place, a glance at a function name gives an understanding what kind of work it does and what kind of value it returns.

One function – one action
A function should do exactly what is suggested by its name, no more.

Two independent actions usually deserve two functions, even if they are usually called together (in that case we can make a 3rd function that calls those two).

A few examples of breaking this rule:

<li><code>getAge</code> – would be bad if it shows an <code>alert</code> with the age (should only get).</li><li><code>createForm</code> – would be bad if it modifies the document, adding a form to it (should only create it and return).</li><li><code>checkPermission</code> – would be bad if displays the <code>access granted/denied</code> message (should only perform the check and return the result).</li>

These examples assume common meanings of prefixes. 
What they mean for you is determined by you and your team. 
Maybe it’s pretty normal for your code to behave differently. 
But you should have a firm understanding of what a prefix means, what a prefixed function can and cannot do. 
All same-prefixed functions should obey the rules. 
And the team should share the knowledge.

Ultrashort function names
Functions that are used <em>very often</em> sometimes have ultrashort names.

For example, the <a href="http://jquery.com">jQuery</a> framework defines a function <code>$</code>. 
The <a href="http://lodash.com/">LoDash</a> library has its core function named <code>_</code>.

These are exceptions. 
Generally functions names should be concise, but descriptive.

<h2>Functions == Comments</h2>
Functions should be short and do exactly one thing. 
If that thing is big, maybe it’s worth it to split the function into a few smaller functions. 
Sometimes following this rule may not be that easy, but it’s definitely a good thing.

A separate function is not only easier to test and debug – its very existence is a great comment!

For instance, compare the two functions <code>showPrimes(n)</code> below. 
Each one outputs <a href="https://en.wikipedia.org/wiki/Prime_number">prime numbers</a> up to <code>n</code>.

The first variant uses a label:

    <code>function showPrimes(n) {
  nextPrime: for (let i = 2; i &lt; n; i++) {
    for (let j = 2; j &lt; i; j++) {
if (i % j == 0) continue nextPrime;
    }
    alert( i ); // a prime
  }
}</code>
  The second variant uses an additional function <code>isPrime(n)</code> to test for primality:

    <code>function showPrimes(n) {
  for (let i = 2; i &lt; n; i++) {
    if (!isPrime(i)) continue;
    alert(i);  // a prime
  }
}
function isPrime(n) {
  for (let i = 2; i &lt; n; i++) {
    if ( n % i == 0) return false;
  }
  return true;
}</code>
  The second variant is easier to understand, isn’t it? Instead of the code piece we see a name of the action (<code>isPrime</code>). 
Sometimes people refer to such code as <em>self-describing</em>.

So, functions can be created even if we don’t intend to reuse them. 
They structure the code and make it readable.

<h4><a name="summary" href="#summary">Summary</a4</h2>
A function declaration looks like this:

    <code>function name(parameters, delimited, by, comma) {
  /* code */
}</code>
  <li>Values passed to a function as parameters are copied to its local variables.</li><li>A function may access outer variables. 
But it works only from inside out. 
The code outside of the function doesn’t see its local variables.</li><li>A function can return a value. 
If it doesn’t, then its result is <code>undefined</code>.</li>

To make the code clean and easy to understand, it’s recommended to use mainly local variables and parameters in the function, not outer variables.

It is always easier to understand a function which gets parameters, works with them and returns a result than a function which gets no parameters, but modifies outer variables as a side-effect.

Function naming:

<li>A name should clearly describe what the function does. 
When we see a function call in the code, a good name instantly gives us an understanding what it does and returns.</li><li>A function is an action, so function names are usually verbal.</li><li>There exist many well-known function prefixes like <code>create…</code>, <code>show…</code>, <code>get…</code>, <code>check…</code> and so on. 
Use them to hint what a function does.</li>

Functions are the main building blocks of scripts. 
Now we’ve covered the basics, so we actually can start creating and using them. 
But that’s only the beginning of the path. 
We are going to return to them many times, going more deeply into their advanced features.

Otherwise it asks for a confirmation and returns its result:

    <code>function checkAge(age) {
  if (age &gt; 18) {
    return true;
  } else {
    // ...
    return confirm('Did parents allow you?');
  }
}</code>
  Will the function work differently if <code>else</code> is removed?

    <code>function checkAge(age) {
  if (age &gt; 18) {
    return true;
  }
  // ...
  return confirm('Did parents allow you?');
}</code>
  Is there any difference in the behavior of these two variants?

<button type="button">solution</button>

No difference.

<button type="button" title="close"></button>

<h3><a href="#rewrite-the-function-using-or" name="rewrite-the-function-using-or">Rewrite the function using '?' or '||'</a></h3><a href="/task/rewrite-function-question-or" target="_blank"></a>

importance: 4

The following function returns <code>true</code> if the parameter <code>age</code> is greater than <code>18</code>.

Otherwise it asks for a confirmation and returns its result.

    <code>function checkAge(age) {
  if (age &gt; 18) {
    return true;
  } else {
    return confirm('Do you have your parents permission to access this page?');
  }
}</code>
  Rewrite it, to perform the same, but without <code>if</code>, in a single line.

Make two variants of <code>checkAge</code>:

<li>Using a question mark operator <code>?</code></li><li>Using OR <code>||</code></li>

<button type="button">solution</button>

Using a question mark operator <code>'?'</code>:

    <code>function checkAge(age) {
  return (age &gt; 18) ? true : confirm('Did parents allow you?');
}</code>
  Using OR <code>||</code> (the shortest variant):

    <code>function checkAge(age) {
  return (age &gt; 18) || confirm('Did parents allow you?');
}</code>
  Note that the parentheses around <code>age &gt; 18</code> are not required here. 
They exist for better readabilty.

<button type="button" title="close"></button>

<h3><a href="#function-min-a-b" name="function-min-a-b">Function min(a, b)</a></h3><a href="/task/min" target="_blank"></a>

importance: 1

Write a function <code>min(a,b)</code> which returns the least of two numbers <code>a</code> and <code>b</code>.

For instance:

    <code>min(2, 5) == 2
min(3, -1) == -1
min(1, 1) == 1</code>
  <button type="button">solution</button>

A solution using <code>if</code>:

    <code>function min(a, b) {
  if (a &lt; b) {
    return a;
  } else {
    return b;
  }
}</code>
  A solution with a question mark operator <code>'?'</code>:

    <code>function min(a, b) {
  return a &lt; b ? a : b;
}</code>
  P.S. 
In the case of an equality <code>a == b</code> it does not matter what to return.

<button type="button" title="close"></button>

<h3><a href="#function-pow-x-n" name="function-pow-x-n">Function pow(x,n)</a></h3><a href="/task/pow" target="_blank"></a>

importance: 4

Write a function <code>pow(x,n)</code> that returns <code>x</code> in power <code>n</code>. 
Or, in other words, multiplies <code>x</code> by itself <code>n</code> times and returns the result.

    <code>pow(3, 2) = 3 * 3 = 9
pow(3, 3) = 3 * 3 * 3 = 27
pow(1, 100) = 1 * 1 * ...*1 = 1</code>
  Create a web-page that prompts for <code>x</code> and <code>n</code>, and then shows the result of <code>pow(x,n)</code>.

<a href="#" onclick="event.preventDefault(); runDemo(this)">Run the demo</a>

P.S. 
In this task the function should support only natural values of <code>n</code>: integers up from <code>1</code>.

<button type="button">solution</button>

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function pow(x, n) {
  let result = x;
  for (let i = 1; i &lt; n; i++) {
    result *= x;
  }
  return result;
}
let x = prompt(&quot;x?&quot;, '');
let n = prompt(&quot;n?&quot;, '');
if (n &lt;= 1) {
  alert(`Power ${n} is not supported,
    use an integer greater than 0`);
} else {
  alert( pow(x, n) );
}</code>
  <button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/switch" data-tooltip="The &quot;switch&quot; statement">Previous lesson</a><a href="/function-expressions-arrows" data-tooltip="Function expressions and arrows">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Ffunction-basics"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Ffunction-basics"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Ffunction-basics"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Ffunction-basics"></a>

In JavaScript, a function is not a “magical language structure”, but a special kind of value.

The syntax that we used before is called a <em>Function Declaration</em>:

    <code>function sayHi() {
  alert( &quot;Hello&quot; );
}</code>
  There is another syntax for creating a function that is called a <em>Function Expression</em>.

It looks like this:

    <code>let sayHi = function() {
  alert( &quot;Hello&quot; );
};</code>
  Here, the function is created and assigned to the variable explicitly, like any other value. 
No matter how the function is defined, it’s just a value stored in the variable <code>sayHi</code>.

The meaning of these code samples is the same: &quot;create a function and put it into the variable <code>sayHi</code>&quot;.

We can even print out that value using <code>alert</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function sayHi() {
  alert( &quot;Hello&quot; );
}
alert( sayHi ); // shows the function code</code>
  Please note that the last line does not run the function, because there are no parentheses after <code>sayHi</code>. 
There are programming languages where any mention of a function name causes its execution, but JavaScript is not like that.

In JavaScript, a function is a value, so we can deal with it as a value. 
The code above shows its string representation, which is the source code.

It is a special value of course, in the sense that we can call it like <code>sayHi()</code>.

But it’s still a value. 
So we can work with it like with other kinds of values.

We can copy a function to another variable:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function sayHi() {   // (1) create
  alert( &quot;Hello&quot; );
}
let func = sayHi;    // (2) copy
func(); // Hello     // (3) run the copy (it works)!
sayHi(); // Hello    //     this still works too (why wouldn't it)</code>
  Here’s what happens above in detail:

<li>The Function Declaration <code>(1)</code> creates the function and puts it into the variable named <code>sayHi</code>.

</li><li>Line <code>(2)</code> copies it into the variable <code>func</code>.

Please note again: there are no parentheses after <code>sayHi</code>. 
If there were, then <code>func = sayHi()</code> would write  <em>the result of the call</em> <code>sayHi()</code> into <code>func</code>, not <em>the function</em> <code>sayHi</code> itself.

</li><li>Now the function can be called as both <code>sayHi()</code> and <code>func()</code>.

</li>

Note that we could also have used a Function Expression to declare <code>sayHi</code>, in the first line:

    <code>let sayHi = function() { ... 
};
let func = sayHi;
// ...</code>
  Everything would work the same. 
Even more obvious what’s going on, right?

Why there’s a semicolon at the end?
There might be a question, why does Function Expression have a semicolon <code>;</code> at the end, and Function Declaration does not:

    <code>function sayHi() {
  // ...
}
let sayHi = function() {
  // ...
};</code>
  The answer is simple:

<li>There’s no need for <code>;</code> at the end of code blocks and syntax structures that use them like <code>if { ... 
}</code>, <code>for { }</code>, <code>function f { }</code> etc.</li><li>A Function Expression is used inside the statement: <code>let sayHi = ...;</code>, as a value. 
It’s not a code block. 
The semicolon <code>;</code> is recommended at the end of statements, no matter what is the value. 
So the semicolon here is not related to the Function Expression itself in any way, it just terminates the statement.</li>

<h2>Callback functions</h2>
Let’s look at more examples of passing functions as values and using function expressions.

We’ll write a function <code>ask(question, yes, no)</code> with three parameters:

<dl>
<dt><code>question</code></dt>
<dd>Text of the question</dd>
<dt><code>yes</code></dt>
<dd>Function to run if the answer is “Yes”</dd>
<dt><code>no</code></dt>
<dd>Function to run if the answer is “No”</dd>
</dl>

The function should ask the <code>question</code> and, depending on the user’s answer, call <code>yes()</code> or <code>no()</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}
function showOk() {
  alert( &quot;You agreed.&quot; );
}
function showCancel() {
  alert( &quot;You canceled the execution.&quot; );
}
// usage: functions showOk, showCancel are passed as arguments to ask
ask(&quot;Do you agree?&quot;, showOk, showCancel);</code>
  Before we explore how we can write it in a much shorter way, let’s note that in the browser (and on the server-side in some cases) such functions are quite popular. 
The major difference between a real-life implementation and the example above is that real-life functions use more complex ways to interact with the user than a simple <code>confirm</code>. 
In the browser, such a function usually draws a nice-looking question window. 
But that’s another story.

<strong>The arguments of <code>ask</code> are called <em>callback functions</em> or just <em>callbacks</em>.</strong>

The idea is that we pass a function and expect it to be “called back” later if necessary. 
In our case, <code>showOk</code> becomes the callback for the “yes” answer, and <code>showCancel</code> for the “no” answer.

We can use Function Expressions to write the same function much shorter:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}
ask(
  &quot;Do you agree?&quot;,
  function() { alert(&quot;You agreed.&quot;); },
  function() { alert(&quot;You canceled the execution.&quot;); }
);</code>
  Here, functions are declared right inside the <code>ask(...)</code> call. 
They have no name, and so are called <em>anonymous</em>. 
Such functions are not accessible outside of <code>ask</code> (because they are not assigned to variables), but that’s just what we want here.

Such code appears in our scripts very naturally, it’s in the spirit of JavaScript.

A function is a value representing an “action”
Regular values like strings or numbers represent the <em>data</em>.

A function can be perceived as an <em>action</em>.

We can pass it between variables and run when we want.

<h2>Function Expression vs Function Declaration</h2>
Let’s formulate the key differences between Function Declarations and Expressions.

First, the syntax: how to see what is what in the code.

<li><em>Function Declaration:</em> a function, declared as a separate statement, in the main code flow.

    <code>// Function Declaration
function sum(a, b) {
  return a + b;
}</code>
  </li><li><em>Function Expression:</em> a function, created inside an expression or inside another syntax construct. 
Here, the function is created at the right side of the “assignment expression” <code>=</code>:

    <code>// Function Expression
let sum = function(a, b) {
  return a + b;
};</code>
  </li>

The more subtle difference is <em>when</em> a function is created by the JavaScript engine.

<strong>A Function Expression is created when the execution reaches it and is usable from then on.</strong>

Once the execution flow passes to the right side of the assignment <code>let sum = function…</code> – here we go, the function is created and can be used (assigned, called etc) from now on.

Function Declarations are different.

<strong>A Function Declaration is usable in the whole script/code block.</strong>

In other words, when JavaScript <em>prepares</em> to run the script or a code block, it first looks for Function Declarations in it and creates the functions. 
We can think of it as an “initialization stage”.

And after all of the Function Declarations are processed, the execution goes on.

As a result, a function declared as a Function Declaration can be called earlier than it is defined.

For example, this works:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>sayHi(&quot;John&quot;); // Hello, John
function sayHi(name) {
  alert( `Hello, ${name}` );
}</code>
  The Function Declaration <code>sayHi</code> is created when JavaScript is preparing to start the script and is visible everywhere in it.

…If it was a Function Expression, then it wouldn’t work:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>sayHi(&quot;John&quot;); // error!
let sayHi = function(name) {  // (*) no magic any more
  alert( `Hello, ${name}` );
};</code>
  Function Expressions are created when the execution reaches them. 
That would happen only in the line <code>(*)</code>. 
Too late.

<strong>When a Function Declaration is made within a code block, it is visible everywhere inside that block. 
But not outside of it.</strong>

Sometimes that’s handy to declare a local function only needed in that block alone. 
But that feature may also cause problems.

For instance, let’s imagine that we need to declare a function <code>welcome()</code> depending on the <code>age</code> variable that we get during runtime. 
And then we plan to use it some time later.

The code below doesn’t work:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let age = prompt(&quot;What is your age?&quot;, 18);
// conditionally declare a function
if (age &lt; 18) {
  function welcome() {
    alert(&quot;Hello!&quot;);
  }
} else {
  function welcome() {
    alert(&quot;Greetings!&quot;);
  }
}
// ...use it later
welcome(); // Error: welcome is not defined</code>
  That’s because a Function Declaration is only visible inside the code block in which it resides.

Here’s another example:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let age = 16; // take 16 as an example
if (age &lt; 18) {
  welcome();               // \   (runs)
                     //  |
  function welcome() {     //  |
    alert(&quot;Hello!&quot;);       //  |  Function Declaration is available
  }                        //  |  everywhere in the block where it's declared
                     //  |
  welcome();               // /   (runs)
} else {
  function welcome() {     //  for age = 16, this &quot;welcome&quot; is never created
    alert(&quot;Greetings!&quot;);
  }
}
// Here we're out of curly braces,
// so we can not see Function Declarations made inside of them.
welcome(); // Error: welcome is not defined</code>
  What can we do to make <code>welcome</code> visible outside of <code>if</code>?

The correct approach would be to use a Function Expression and assign <code>welcome</code> to the variable that is declared outside of <code>if</code> and has the proper visibility.

Now it works as intended:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let age = prompt(&quot;What is your age?&quot;, 18);
let welcome;
if (age &lt; 18) {
  welcome = function() {
    alert(&quot;Hello!&quot;);
  };
} else {
  welcome = function() {
    alert(&quot;Greetings!&quot;);
  };
}
welcome(); // ok now</code>
  Or we could simplify it even further using a question mark operator <code>?</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let age = prompt(&quot;What is your age?&quot;, 18);
let welcome = (age &lt; 18) ?
  function() { alert(&quot;Hello!&quot;); } :
  function() { alert(&quot;Greetings!&quot;); };
welcome(); // ok now</code>
  
When to choose Function Declaration versus Function Expression?
As a rule of thumb, when we need to declare a function, the first to consider is Function Declaration syntax, the one we used before. 
It gives more freedom in how to organize our code, because we can call such functions before they are declared.

It’s also a little bit easier to look up <code>function f(…) {…}</code> in the code than <code>let f = function(…) {…}</code>. 
Function Declarations are more “eye-catching”.

…But if a Function Declaration does not suit us for some reason (we’ve seen an example above), then Function Expression should be used.

<h2>Arrow functions</h2>
There’s one more very simple and concise syntax for creating functions, that’s often better than Function Expressions. 
It’s called “arrow functions”, because it looks like this:

    <code>let func = (arg1, arg2, ...argN) =&gt; expression</code>
  …This creates a function <code>func</code> that has arguments <code>arg1..argN</code>, evaluates the <code>expression</code> on the right side with their use and returns its result.

In other words, it’s roughly the same as:

    <code>let func = function(arg1, arg2, ...argN) {
  return expression;
}</code>
  …But much more concise.

Let’s see an example:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let sum = (a, b) =&gt; a + b;
/* The arrow function is a shorter form of:
let sum = function(a, b) {
  return a + b;
};
*/
alert( sum(1, 2) ); // 3</code>
  If we have only one argument, then parentheses can be omitted, making that even shorter:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// same as
// let double = function(n) { return n * 2 }
let double = n =&gt; n * 2;
alert( double(3) ); // 6</code>
  If there are no arguments, parentheses should be empty (but they should be present):

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let sayHi = () =&gt; alert(&quot;Hello!&quot;);
sayHi();</code>
  Arrow functions can be used in the same way as Function Expressions.

For instance, here’s the rewritten example with <code>welcome()</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let age = prompt(&quot;What is your age?&quot;, 18);
let welcome = (age &lt; 18) ?
  () =&gt; alert('Hello') :
  () =&gt; alert(&quot;Greetings!&quot;);
welcome(); // ok now</code>
  Arrow functions may appear unfamiliar and not very readable at first, but that quickly changes as the eyes get used to the structure.

They are very convenient for simple one-line actions, when we’re just too lazy to write many words.

Multiline arrow functions
The examples above took arguments from the left of <code>=&gt;</code> and evaluated the right-side expression with them.

Sometimes we need something a little bit more complex, like multiple expressions or statements. 
It is also possible, but we should enclose them in curly braces. 
Then use a normal <code>return</code> within them.

Like this:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let sum = (a, b) =&gt; {  // the curly brace opens a multiline function
  let result = a + b;
  return result; // if we use curly braces, use return to get results
};
alert( sum(1, 2) ); // 3</code>
  

More to come
Here we praised arrow functions for brevity. 
But that’s not all! Arrow functions have other interesting features. 
We’ll return to them later in the chapter <a href="/arrow-functions">Arrow functions revisited</a>.

For now, we can already use them for one-line actions and callbacks.

<h4><a name="summary" href="#summary">Summary</a></h4><li>Functions are values. 
They can be assigned, copied or declared in any place of the code.</li><li>If the function is declared as a separate statement in the main code flow, that’s called a “Function Declaration”.</li><li>If the function is created as a part of an expression, it’s called a “Function Expression”.</li><li>Function Declarations are processed before the code block is executed. 
They are visible everywhere in the block.</li><li>Function Expressions are created when the execution flow reaches them.</li>

In most cases when we need to declare a function, a Function Declaration is preferable, because it is visible prior to the declaration itself. 
That gives us more flexibility in code organization, and is usually more readable.

So we should use a Function Expression only when a Function Declaration is not fit for the task. 
We’ve seen a couple of examples of that in this chapter, and will see more in the future.

Arrow functions are handy for one-liners. 
They come in two flavors:

<li>Without curly braces: <code>(...args) =&gt; expression</code> – the right side is an expression: the function evaluates it and returns the result.</li><li>With curly braces: <code>(...args) =&gt; { body }</code> – brackets allow us to write multiple statements inside the function, but we need an explicit <code>return</code> to return something.</li>

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}
ask(
  &quot;Do you agree?&quot;,
  function() { alert(&quot;You agreed.&quot;); },
  function() { alert(&quot;You canceled the execution.&quot;); }
);</code>
  <button type="button">solution</button>

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}
ask(
  &quot;Do you agree?&quot;,
  () =&gt; alert(&quot;You agreed.&quot;),
  () =&gt; alert(&quot;You canceled the execution.&quot;)
);</code>
  Looks short and clean, right?

<button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/function-basics" data-tooltip="Functions">Previous lesson</a><a href="/javascript-specials" data-tooltip="JavaScript specials">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Ffunction-expressions-arrows"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Ffunction-expressions-arrows"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Ffunction-expressions-arrows"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Ffunction-expressions-arrows"></a>

This chapter briefly recaps the features of JavaScript that we’ve learned by now, paying special attention to subtle moments.

<h2>Code structure</h2>
Statements are delimited with a semicolon:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert('Hello'); alert('World');</code>
  Usually, a line-break is also treated as a delimiter, so that would also work:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert('Hello')
alert('World')</code>
  That’s called “automatic semicolon insertion”. 
Sometimes it doesn’t work, for instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert(&quot;There will be an error after this message&quot;)
[1, 2].forEach(alert)</code>
  Most codestyle guides agree that we should put a semicolon after each statement.

Semicolons are not required after code blocks <code>{...}</code> and syntax constructs with them like loops:

    <code>function f() {
  // no semicolon needed after function declaration
}
for(;;) {
  // no semicolon needed after the loop
}</code>
  …But even if we can put an “extra” semicolon somewhere, that’s not an error. 
It will be ignored.

More in: <a href="/structure">Code structure</a>.

<h2>Strict mode</h2>
To fully enable all features of modern JavaScript, we should start scripts with <code>&quot;use strict&quot;</code>.

    <code>'use strict';
...</code>
  The directive must be at the top of a script or at the beginning of a function.

Without <code>&quot;use strict&quot;</code>, everything still works, but some features behave in the old-fashion, “compatible” way. 
We’d generally prefer the modern behavior.

Some modern features of the language (like classes that we’ll study in the future) enable strict mode implicitly.

More in: <a href="/strict-mode">The modern mode, &quot;use strict&quot;</a>.

<h2>Variables</h2>
Can be declared using:

<li><code>let</code></li><li><code>const</code> (constant, can’t be changed)</li><li><code>var</code> (old-style, will see later)</li>

A variable name can include:

<li>Letters and digits, but the first character may not be a digit.</li><li>Characters <code>$</code> and <code>_</code> are normal, on par with letters.</li><li>Non-Latin alphabets and hieroglyphs are also allowed, but commonly not used.</li>

Variables are dynamically typed. 
They can store any value:

    <code>let x = 5;
x = &quot;John&quot;;</code>
  There are 7 data types:

<li><code>number</code> for both floating-point and integer numbers,</li><li><code>string</code> for strings,</li><li><code>boolean</code> for logical values: <code>true/false</code>,</li><li><code>null</code> – a type with a single value <code>null</code>, meaning “empty” or “does not exist”,</li><li><code>undefined</code> – a type with a single value <code>undefined</code>, meaning “not assigned”,</li><li><code>object</code> and <code>symbol</code> – for complex data structures and unique identifiers, we haven’t learnt them yet.</li>

The <code>typeof</code> operator returns the type for a value, with two exceptions:

    <code>typeof null == &quot;object&quot; // error in the language
typeof function(){} == &quot;function&quot; // functions are treated specially</code>
  More in: <a href="/variables">Variables</a> and <a href="/types">Data types</a>.

<h2>Interaction</h2>
We’re using a browser as a working environment, so basic UI functions will be:

<dl>
<dt><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/prompt"><code>prompt(question[, default])</code></a></dt>
<dd>Ask a <code>question</code>, and return either what the visitor entered or <code>null</code> if he pressed “cancel”.</dd>
<dt><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/confirm"><code>confirm(question)</code></a></dt>
<dd>Ask a <code>question</code> and suggest to choose between Ok and Cancel. 
The choice is returned as <code>true/false</code>.</dd>
<dt><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/alert"><code>alert(message)</code></a></dt>
<dd>Output a <code>message</code>.</dd>
</dl>

All these functions are <em>modal</em>, they pause the code execution and prevent the visitor from interacting with the page until he answers.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let userName = prompt(&quot;Your name?&quot;, &quot;Alice&quot;);
let isTeaWanted = confirm(&quot;Do you want some tea?&quot;);
alert( &quot;Visitor: &quot; + userName ); // Alice
alert( &quot;Tea wanted: &quot; + isTeaWanted ); // true</code>
  More in: <a href="/alert-prompt-confirm">Interaction: alert, prompt, confirm</a>.

<h2>Operators</h2>
JavaScript supports the following operators:

<dl>
<dt>Arithmetical</dt>
<dd>

Regular: <code>* + - /</code>, also <code>%</code> for the remainder and <code>**</code> for power of a number.

The binary plus <code>+</code> concatenates strings. 
And if any of the operands is a string, the other one is converted to string too:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( '1' + 2 ); // '12', string
alert( 1 + '2' ); // '12', string</code>
  </dd>
<dt>Assignments</dt>
<dd>

There is a simple assignment: <code>a = b</code> and combined ones like <code>a *= 2</code>.

</dd>
<dt>Bitwise</dt>
<dd>

Bitwise operators work with integers on bit-level: see the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators">docs</a> when they are needed.

</dd>
<dt>Ternary</dt>
<dd>

The only operator with three parameters: <code>cond ? resultA : resultB</code>. 
If <code>cond</code> is truthy, returns <code>resultA</code>, otherwise <code>resultB</code>.

</dd>
<dt>Logical operators</dt>
<dd>

Logical AND <code>&amp;&amp;</code> and OR <code>||</code> perform short-circuit evaluation and then return the value where it stopped.

</dd>
<dt>Comparisons</dt>
<dd>

Equality check <code>==</code> for values of different types converts them to a number (except <code>null</code> and <code>undefined</code> that equal each other and nothing else), so these are equal:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( 0 == false ); // true
alert( 0 == '' ); // true</code>
  Other comparisons convert to a number as well.

The strict equality operator <code>===</code> doesn’t do the conversion: different types always mean different values for it, so:

Values <code>null</code> and <code>undefined</code> are special: they equal <code>==</code> each other and don’t equal anything else.

Greater/less comparisons compare strings character-by-character, other types are converted to a number.

</dd>
<dt>Logical operators</dt>
<dd>

There are few others, like a comma operator.

</dd>
</dl>

More in: <a href="/operators">Operators</a>, <a href="/comparison">Comparisons</a>, <a href="/logical-operators">Logical operators</a>.

<h2>Loops</h2>

We covered 3 types of loops:

    <code>// 1
while (condition) {
  ...
}
// 2
do {
  ...
} while (condition);
// 3
for(let i = 0; i &lt; 10; i++) {
  ...
}</code>
  </li><li>The variable declared in <code>for(let...)</code> loop is visible only inside the loop. 
But we can also omit <code>let</code> and reuse an existing variable.

</li><li>Directives <code>break/continue</code> allow to exit the whole loop/current iteration. 
Use labels to break nested loops.

</li>

Details in: <a href="/while-for">Loops: while and for</a>.

Later we’ll study more types of loops to deal with objects.

<h2>The “switch” construct</h2>
The “switch” construct can replace multiple <code>if</code> checks. 
It uses <code>===</code> (strict equality) for comparisons.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let age = prompt('Your age?', 18);
switch (age) {
  case 18:
    alert(&quot;Won't work&quot;); // the result of prompt is a string, not a number
  case &quot;18&quot;:
    alert(&quot;This works!&quot;);
    break;
  default:
    alert(&quot;Any value not equal to one above&quot;);
}</code>
  Details in: <a href="/switch">The &quot;switch&quot; statement</a>.

<h2>Functions</h2>
We covered three ways to create a function in JavaScript:

<li>Function Declaration: the function in the main code flow

    <code>function sum(a, b) {
  let result = a + b;
  return result;
}</code>
  </li><li>Function Expression: the function in the context of an expression

    <code>let sum = function(a, b) {
  let result = a + b;
  return result;
}</code>
  Function expressions can have a name, like <code>sum = function name(a, b)</code>, but that <code>name</code> is only visible inside that function.

</li><li>Arrow functions:

    <code>// expression at the right side
let sum = (a, b) =&gt; a + b;
// or multi-line syntax with { ... 
}, need return here:
let sum = (a, b) =&gt; {
  // ...
  return a + b;
}
// without arguments
let sayHi = () =&gt; alert(&quot;Hello&quot;);
// with a single argument
let double = n =&gt; n * 2;</code>
  </li>

<li>Functions may have local variables: those declared inside its body. 
Such variables are only visible inside the function.</li><li>Parameters can have default values: <code>function sum(a = 1, b = 2) {...}</code>.</li><li>Functions always return something. 
If there’s no <code>return</code> statement, then the result is <code>undefined</code>.</li>

<table>
<thead>
<tr>
<th>Function Declaration</th>
<th>Function Expression</th>
</tr>
</thead>
<tbody>
<tr>
<td>visible in the whole code block</td>
<td>created when the execution reaches it</td>
</tr>
<tr>
<td>-</td>
<td>can have a name, visible only inside the function</td>
</tr>
</tbody>
</table>

More: see <a href="/function-basics">Functions</a>, <a href="/function-expressions-arrows">Function expressions and arrows</a>.

<h2>More to come</h2>
That was a brief list of JavaScript features. 
As of now we’ve studied only basics. 
Further in the tutorial you’ll find more specials and advanced features of JavaScript.

Before writing more complex code, let’s talk about debugging.

All modern browsers and most other environments support “debugging” – a special UI in developer tools that makes finding and fixing errors much easier.

We’ll be using Chrome here, because it’s probably the most feature-rich in this aspect.

<h2>The “sources” pane</h2>
Your Chrome version may look a little bit different, but it still should be obvious what’s there.

<li>Open the <a href="/article/debugging-chrome/debugging/index.html">example page</a> in Chrome.</li><li>Turn on developer tools with <kbd>F12</kbd> (Mac: <kbd>Cmd+Opt+I</kbd>).</li><li>Select the <code>sources</code> pane.</li>

Here’s what you should see if you are doing it for the first time:

<img src="https://javascript.info/article/debugging-chrome/chrome-open-sources.png">
The toggler button  opens the tab with files.

Let’s click it and select <code>index.html</code> and then <code>hello.js</code> in the tree view. 
Here’s what should show up:

<img src="https://javascript.info/article/debugging-chrome/chrome-tabs.png">
Here we can see three zones:

<li>The <strong>Resources zone</strong> lists HTML, JavaScript, CSS and other files, including images that are attached to the page. 
Chrome extensions may appear here too.</li><li>The <strong>Source zone</strong> shows the source code.</li><li>The <strong>Information and control zone</strong> is for debugging, we’ll explore it soon.</li>

Now you could click the same toggler  again to hide the resources list and give the code some space.

<h2>Console</h2>
If we press <code>Esc</code>, then a console opens below. 
We can type commands there and press <kbd>Enter</kbd> to execute.

After a statement is executed, its result is shown below.

For example, here <code>1+2</code> results in <code>3</code>, and <code>hello(&quot;debugger&quot;)</code> returns nothing, so the result is <code>undefined</code>:

<img src="https://javascript.info/article/debugging-chrome/chrome-sources-console.png">
<h2>Breakpoints</h2>
Let’s examine what’s going on within the code of the <a href="/article/debugging-chrome/debugging/index.html">example page</a>. 
In <code>hello.js</code>, click at line number <code>4</code>. 
Yes, right on the <code>4</code> digit, not on the code.

Congratulations! You’ve set a breakpoint. 
Please also click on the number for line <code>8</code>.

It should look like this (blue is where you should click):

<img src="https://javascript.info/article/debugging-chrome/chrome-sources-breakpoint.png">
A <em>breakpoint</em> is a point of code where the debugger will automatically pause the JavaScript execution.

While the code is paused, we can examine current variables, execute commands in the console etc. 
In other words, we can debug it.

We can always find a list of breakpoints in the right pane. 
That’s useful when we have many breakpoints in various files. 
It allows to:

<li>Quickly jump to the breakpoint in the code (by clicking on it in the right pane).</li><li>Temporarily disable the breakpoint by unchecking it.</li><li>Remove the breakpoint by right-clicking and selecting Remove.</li><li>…And so on.</li>

Conditional breakpoints
<em>Right click</em> on the line number allows to create a <em>conditional</em> breakpoint. 
It only triggers when the given expression is truthy.

That’s handy when we need to stop only for a certain variable value or for certain function parameters.

<h2>Debugger command</h2>
We can also pause the code by using the <code>debugger</code> command, like this:

    <code>function hello(name) {
  let phrase = `Hello, ${name}!`;
  debugger;  // &lt;-- the debugger stops here
  say(phrase);
}</code>
  That’s very convenient when we are in a code editor and don’t want to switch to the browser and look up the script in developer tools to set the breakpoint.

<h2>Pause and look around</h2>
In our example, <code>hello()</code> is called during the page load, so the easiest way to activate the debugger is to reload the page. 
So let’s press <kbd>F5</kbd> (Windows, Linux) or <kbd>Cmd+R</kbd> (Mac).

As the breakpoint is set, the execution pauses at the 4th line:

<img src="https://javascript.info/article/debugging-chrome/chrome-sources-debugger-pause.png">
Please open the informational dropdowns to the right (labeled with arrows). 
They allow you to examine the current code state:

<li><strong><code>Watch</code> – shows current values for any expressions.</strong>

You can click the plus <code>+</code> and input an expression. 
The debugger will show its value at any moment, automatically recalculating it in the process of execution.

</li><li><strong><code>Call Stack</code> – shows the nested calls chain.</strong>

At the current moment the debugger is inside <code>hello()</code> call, called by a script in <code>index.html</code> (no function there, so it’s called “anonymous”).

If you click on a stack item, the debugger jumps to the corresponding code, and all its variables can be examined as well.

</li><li><strong><code>Scope</code> – current variables.</strong>

<code>Local</code> shows local function variables. 
You can also see their values highlighted right over the source.

<code>Global</code> has global variables (out of any functions).

There’s also <code>this</code> keyword there that we didn’t study yet, but we’ll do that soon.

</li>

<h2>Tracing the execution</h2>
Now it’s time to <em>trace</em> the script.

There are buttons for it at the top of the right pane. 
Let’s engage them.

<dl>
<dt> – continue the execution, hotkey <kbd>F8</kbd>.</dt>
<dd>

Resumes the execution. 
If there are no additional breakpoints, then the execution just continues and the debugger loses control.

Here’s what we can see after a click on it:

<img src="https://javascript.info/article/debugging-chrome/chrome-sources-debugger-trace-1.png">
The execution has resumed, reached another breakpoint inside <code>say()</code> and paused there. 
Take a look at the “Call stack” at the right. 
It has increased by one more call. 
We’re inside <code>say()</code> now.

</dd>
<dt> – make a step (run the next command), but <em>don’t go into the function</em>, hotkey <kbd>F10</kbd>.</dt>
<dd>

If we click it now, <code>alert</code> will be shown. 
The important thing is that <code>alert</code> can be any function, the execution “steps over it”, skipping the function internals.

</dd>
<dt> – make a step, hotkey <kbd>F11</kbd>.</dt>
<dd>

The same as the previous one, but “steps into” nested functions. 
Clicking this will step through all script actions one by one.

</dd>
<dt> – continue the execution till the end of the current function, hotkey <kbd>Shift+F11</kbd>.</dt>
<dd>

The execution would stop at the very last line of the current function. 
That’s handy when we accidentally entered a nested call using , but it does not interest us, and we want to continue to its end as soon as possible.

</dd>
<dt> – enable/disable all breakpoints.</dt>
<dd>

That button does not move the execution. 
Just a mass on/off for breakpoints.

</dd>
<dt> – enable/disable automatic pause in case of an error.</dt>
<dd>

When enabled, and the developer tools is open, a script error automatically pauses the execution. 
Then we can analyze variables to see what went wrong. 
So if our script dies with an error, we can open debugger, enable this option and reload the page to see where it dies and what’s the context at that moment.

</dd>
</dl>

Continue to here
Right click on a line of code opens the context menu with a great option called “Continue to here”.

That’s handy when we want to move multiple steps forward, but we’re too lazy to set a breakpoint.

<h2>Logging</h2>
To output something to console, there’s <code>console.log</code> function.

For instance, this outputs values from <code>0</code> to <code>4</code> to console:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// open console to see
for (let i = 0; i &lt; 5; i++) {
  console.log(&quot;value&quot;, i);
}</code>
  Regular users don’t see that output, it is in the console. 
To see it, either open the Console tab of developer tools or press <kbd>Esc</kbd> while in another tab: that opens the console at the bottom.

If we have enough logging in our code, then we can see what’s going on from the records, without the debugger.

<h4><a name="summary" href="#summary">Summary</a4</h2>
As we can see, there are three main ways to pause a script:

<li>A breakpoint.</li><li>The <code>debugger</code> statements.</li><li>An error (if dev tools are open and the button  is “on”)</li>

Then we can examine variables and step on to see where the execution goes wrong.

There are many more options in developer tools than covered here. 
The full manual is at <a href="https://developers.google.com/web/tools/chrome-devtools">https://developers.google.com/web/tools/chrome-devtools</a>.

The information from this chapter is enough to begin debugging, but later, especially if you do a lot of browser stuff, please go there and look through more advanced capabilities of developer tools.

Oh, and also you can click at various places of dev tools and just see what’s showing up. 
That’s probably the fastest route to learn dev tools. 
Don’t forget about the right click as well!

Our code must be as clean and easy to read as possible.

That is actually an art of programming – to take a complex task and code it in a way that is both correct and human-readable.

One thing to help is the good code style.

<h2>Syntax</h2>
A cheatsheet with the rules (more details below):

<img src="https://javascript.info/article/coding-style/code-style.png">
<!--
```js
function pow(x, n) {
  let result = 1;
  for (let i = 0; i < n; i++) {
    result *= x;
  }
  return result;
}
let x = prompt("x?", "");
let n = prompt("n?", "");
if (n < 0) {
  alert(`Power ${n} is not supported,
    please enter an integer number, greater than 0`);
} else {
  alert( pow(x, n) );
}
```
-->

Now let’s discuss the rules and reasons for them in detail.

Nothing is “carved in stone” here. 
Everything is optional and can be changed: these are coding rules, not religious dogmas.

<h3><a name="curly-braces" href="#curly-braces">Curly braces</a></h3>
In most JavaScript projects curly braces are written on the same line as the corresponding keyword, not on the new line, a so-called “Egyptian” style. 
There’s also a space before an opening bracket.

Like this:

    <code>if (condition) {
  // do this
  // ...and that
  // ...and that
}</code>
  A single-line construct is an important edge case. 
Should we use brackets at all? If yes, then where?

Here are the annotated variants, so you can judge about their readability on your own:

<!--
```js no-beautify
if (n < 0) {alert(`Power ${n} is not supported`);}
if (n < 0) alert(`Power ${n} is not supported`);
if (n < 0)
  alert(`Power ${n} is not supported`);
if (n < 0) {
  alert(`Power ${n} is not supported`);
}
```
-->

<img src="https://javascript.info/article/coding-style/figure-bracket-style.png">
As a summary:

<li>For a really short code, one line is acceptable: like <code>if (cond) return null</code>.</li><li>But a separate line for each statement in brackets is usually better.</li>

<h3><a name="line-length" href="#line-length">Line length</a></h3>
The maximal line length should be limited. 
No one likes to eye-follow a long horizontal line. 
It’s better to split it.

The maximal line length is agreed on the team-level. 
It’s usually 80 or 120 characters.

<h3><a name="indents" href="#indents">Indents</a></h3>
There are two types of indents:

<li><strong>A horizontal indent: 2(4) spaces.</strong>

A horizontal indentation is made using either 2 or 4 spaces or the “Tab” symbol. 
Which one to choose is an old holy war. 
Spaces are more common nowadays.

One advantage of spaces over tabs is that spaces allow more flexible configurations of indents than the “Tab” symbol.

For instance, we can align the arguments with the opening bracket, like this:

    <code>show(parameters,
     aligned, // 5 spaces padding at the left
     one,
     after,
     another
  ) {
  // ...
}</code>
  </li><li><strong>A vertical indent: empty lines for splitting code into logical blocks.</strong>

Even a single function can often be divided in logical blocks. 
In the example below, the initialization of variables, the main loop and returning the result are split vertically:

    <code>function pow(x, n) {
  let result = 1;
  //              &lt;--
  for (let i = 0; i &lt; n; i++) {
    result *= x;
  }
  //              &lt;--
  return result;
}</code>
  Insert an extra newline where it helps to make the code more readable. 
There should not be more than nine lines of code without a vertical indentation.

</li>

<h3><a name="a-semicolon" href="#a-semicolon">A semicolon</a></h3>
A semicolon should be present after each statement. 
Even if it could possibly be skipped.

There are languages where a semicolon is truly optional. 
It’s rarely used there. 
But in JavaScript there are few cases when a line break is sometimes not interpreted as a semicolon. 
That leaves a place for programming errors.

As you become more mature as a programmer, you may choose a no-semicolon style, like <a href="https://standardjs.com/">StandardJS</a>, but that’s only when you know JavaScript well and understand possible pitfalls.

<h3><a name="nesting-levels" href="#nesting-levels">Nesting levels</a></h3>
There should not be too many nesting levels.

Sometimes it’s a good idea to use the <a href="/while-for#continue">“continue”</a> directive in the loop to evade extra nesting in <code>if(..) { ... 
}</code>:

Instead of:

    <code>for (let i = 0; i &lt; 10; i++) {
  if (cond) {
    ... 
// &lt;- one more nesting level
  }
}</code>
  We can write:

    <code>for (let i = 0; i &lt; 10; i++) {
  if (!cond) continue;
  ... 
 // &lt;- no extra nesting level
}</code>
  A similar thing can be done with <code>if/else</code> and <code>return</code>.

For example, two constructs below are identical.

The first one:

    <code>function pow(x, n) {
  if (n &lt; 0) {
    alert(&quot;Negative 'n' not supported&quot;);
  } else {
    let result = 1;
    for (let i = 0; i &lt; n; i++) {
result *= x;
    }
    return result;
  }
}</code>
  And this:

    <code>function pow(x, n) {
  if (n &lt; 0) {
    alert(&quot;Negative 'n' not supported&quot;);
    return;
  }
  let result = 1;
  for (let i = 0; i &lt; n; i++) {
    result *= x;
  }
  return result;
}</code>
  …But the second one is more readable, because the “edge case” of <code>n &lt; 0</code> is handled early on, and then we have the “main” code flow, without an additional nesting.

<h2>Functions below the code</h2>
If you are writing several “helper” functions and the code to use them, then there are three ways to place them.

<li>Functions above the code that uses them:

    <code>// function declarations
function createElement() {
  ...
}
function setHandler(elem) {
  ...
}
function walkAround() {
  ...
}
// the code which uses them
let elem = createElement();
setHandler(elem);
walkAround();</code>
  </li><li>Code first, then functions

    <code>// the code which uses the functions
let elem = createElement();
setHandler(elem);
walkAround();
// --- helper functions ---
function createElement() {
  ...
}
function setHandler(elem) {
  ...
}
function walkAround() {
  ...
}</code>
  </li><li>Mixed: a function is described where it’s first used.

</li>

Most of time, the second variant is preferred.

That’s because when reading a code, we first want to know “what it does”. 
If the code goes first, then it provides that information. 
And then maybe we won’t need to read functions at all, especially if their names are adequate to what they’re doing.

<h2>Style guides</h2>
A style guide contains general rules about “how to write”: which quotes to use, how many spaces to indent, where to put line breaks, etc. 
A lot of minor things.

In total, when all members of a team use the same style guide, the code looks uniform. 
No matter who of the team wrote it, it’s still the same style.

Surely, a team may think out a style guide themselves. 
But as of now, there’s no need to. 
There are many tried, worked-out style guides, which are easy to adopt.

For instance:

<li><a href="https://google.github.io/styleguide/javascriptguide.xml">Google JavaScript Style Guide</a></li><li><a href="https://github.com/airbnb/javascript">Airbnb JavaScript Style Guide</a></li><li><a href="https://github.com/rwaldron/idiomatic.js">Idiomatic.JS</a></li><li><a href="https://standardjs.com/">StandardJS</a></li><li>(there are more)</li>

If you’re a novice developer, then you could start with the cheatsheet above in the chapter, and later browse the style guides to pick up the common principles and maybe choose one.

<h2>Automated linters</h2>
There are tools that can check the code style automatically. 
They are called “linters”.

The great thing about them is that style-checking also finds some bugs, like a typo in a variable or function name.

So it’s recommended to install one, even if you don’t want to stick to a “code style”. 
They help to find typos – and that’s already good enough.

Most well-known tools are:

<li><a href="http://www.jslint.com/">JSLint</a> – one of the first linters.</li><li><a href="http://www.jshint.com/">JSHint</a> – more settings than JSLint.</li><li><a href="http://eslint.org/">ESLint</a> – probably the newest one.</li>

All of them can do the job. 
The author uses <a href="http://eslint.org/">ESLint</a>.

Most linters are integrated with editors: just enable the plugin in the editor and configure the style.

For instance, for ESLint you should do the following:

<li>Install <a href="https://nodejs.org/">Node.JS</a>.</li><li>Install ESLint with the command <code>npm install -g eslint</code> (npm is a JavaScript package installer).</li><li>Create a config file named <code>.eslintrc</code> in the root of your JavaScript project (in the folder that contains all your files).</li>

Here’s an example of <code>.eslintrc</code>:

    <code>{
  &quot;extends&quot;: &quot;eslint:recommended&quot;,
  &quot;env&quot;: {
    &quot;browser&quot;: true,
    &quot;node&quot;: true,
    &quot;es6&quot;: true
  },
  &quot;rules&quot;: {
    &quot;no-console&quot;: 0,
  },
  &quot;indent&quot;: 2
}</code>
  Here the directive <code>&quot;extends&quot;</code> denotes that we base on the “eslint:recommended” set of settings, and then we specify our own.

Then install/enable the plugin for your editor that integrates with ESLint. 
The majority of editors have it.

It is possible to download style rule sets from the web and extend them instead. 
See <a href="http://eslint.org/docs/user-guide/getting-started">http://eslint.org/docs/user-guide/getting-started</a> for more details about installation.

Using a linter has a great side-effect: linters catch typos. 
For instance, when an undefined variable is accessed, a linter detects it and (if integrated with an editor) highlights it. 
In most cases that’s a mistype. 
So we can fix it right ahead.

For that reason even if you’re not concerned about styles, using a linter is highly recommended.

Also certain IDEs support built-in linting, that also may be good, but not so tunable as ESLint.

<h4><a name="summary" href="#summary">Summary</a4</h2>
All syntax rules from this chapter and the style guides aim to increase readability, so all of them are debatable.

When we think about “how to write better?”, the sole criterion is “what makes the code more readable and easier to understand? what helps to avoid errors?” That’s the main thing to keep in mind when choosing the style or discussing which one is better.

Read style guides to see the latest ideas about that and follow those that you find the best.

    <code>function pow(x,n)
{
  let result=1;
  for(let i=0;i&lt;n;i++) {result*=x;}
  return result;
}
let x=prompt(&quot;x?&quot;,''), n=prompt(&quot;n?&quot;,'')
if (n&lt;=0)
{
  alert(`Power ${n} is not supported, please enter an integer number greater than zero`);
}
else
{
  alert(pow(x,n))
}</code>
  Fix it.

<button type="button">solution</button>

You could note the following:

    <code>function pow(x,n)  // &lt;- no space between arguments
{  // &lt;- figure bracket on a separate line
  let result=1;   // &lt;- no spaces to the both sides of =
  for(let i=0;i&lt;n;i++) {result*=x;}   // &lt;- no spaces
  // the contents of { ... 
} should be on a new line
  return result;
}
let x=prompt(&quot;x?&quot;,''), n=prompt(&quot;n?&quot;,'') // &lt;-- technically possible,
// but better make it 2 lines, also there's no spaces and ;
if (n&lt;0)  // &lt;- no spaces inside (n &lt; 0), and should be extra line above it
{   // &lt;- figure bracket on a separate line
  // below - a long line, may be worth to split into 2 lines
  alert(`Power ${n} is not supported, please enter an integer number greater than zero`);
}
else // &lt;- could write it on a single line like &quot;} else {&quot;
{
  alert(pow(x,n))  // no spaces and ;
}</code>
  The fixed variant:

    <code>function pow(x, n) {
  let result = 1;
  for (let i = 0; i &lt; n; i++) {
    result *= x;
  }
  return result;
}
let x = prompt(&quot;x?&quot;, &quot;&quot;);
let n = prompt(&quot;n?&quot;, &quot;&quot;);
if (n &lt; 0) {
  alert(`Power ${n} is not supported,
    please enter an integer number greater than zero`);
} else {
  alert( pow(x, n) );
}</code>
  <button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/debugging-chrome" data-tooltip="Debugging in Chrome">Previous lesson</a><a href="/comments" data-tooltip="Comments">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Fcoding-style"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Fcoding-style"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Fcoding-style"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Fcoding-style"></a>

As we know from the chapter <a href="/structure">Code structure</a>, comments can be single-line: starting with <code>//</code> and multiline: <code>/* ... 
*/</code>.

We normally use them to describe how and why the code works.

From the first sight, commenting might be obvious, but novices in programming usually get it wrong.

<h2>Bad comments</h2>
Novices tend to use comments to explain “what is going on in the code”. 
Like this:

    <code>// This code will do this thing (...) and that thing (...)
// ...and who knows what else...
very;
complex;
code;</code>
  But in good code the amount of such “explanatory” comments should be minimal. 
Seriously, code should be easy to understand without them.

There’s a great rule about that: “if the code is so unclear that it requires a comment, then maybe it should be rewritten instead”.

<h3><a name="recipe-factor-out-functions" href="#recipe-factor-out-functions">Recipe: factor out functions</a></h3>
Sometimes it’s beneficial to replace a code piece with a function, like here:

    <code>function showPrimes(n) {
  nextPrime:
  for (let i = 2; i &lt; n; i++) {
    // check if i is a prime number
    for (let j = 2; j &lt; i; j++) {
if (i % j == 0) continue nextPrime;
    }
    alert(i);
  }
}</code>
  The better variant, with a factored out function <code>isPrime</code>:

    <code>function showPrimes(n) {
  for (let i = 2; i &lt; n; i++) {
    if (!isPrime(i)) continue;
    alert(i);
  }
}
function isPrime(n) {
  for (let i = 2; i &lt; n; i++) {
    if (n % i == 0) return false;
  }
  return true;
}</code>
  Now we can understand the code easily. 
The function itself becomes the comment. 
Such code is called <em>self-descriptive</em>.

<h3><a name="recipe-create-functions" href="#recipe-create-functions">Recipe: create functions</a></h3>
And if we have a long “code sheet” like this:

    <code>// here we add whiskey
for(let i = 0; i &lt; 10; i++) {
  let drop = getWhiskey();
  smell(drop);
  add(drop, glass);
}
// here we add juice
for(let t = 0; t &lt; 3; t++) {
  let tomato = getTomato();
  examine(tomato);
  let juice = press(tomato);
  add(juice, glass);
}
// ...</code>
  Then it might be a better variant to refactor it into functions like:

    <code>addWhiskey(glass);
addJuice(glass);
function addWhiskey(container) {
  for(let i = 0; i &lt; 10; i++) {
    let drop = getWhiskey();
    //...
  }
}
function addJuice(container) {
  for(let t = 0; t &lt; 3; t++) {
    let tomato = getTomato();
    //...
  }
}</code>
  Once again, functions themselves tell what’s going on. 
There’s nothing to comment. 
And also the code structure is better when split. 
It’s clear what every function does, what it takes and what it returns.

In reality, we can’t totally avoid “explanatory” comments. 
There are complex algorithms. 
And there are smart “tweaks” for purposes of optimization. 
But generally we should try to keep the code simple and self-descriptive.

<h2>Good comments</h2>
So, explanatory comments are usually bad. 
Which comments are good?

<dl>
<dt>Describe the architecture</dt>
<dd>

Provide a high-level overview of components, how they interact, what’s the control flow in various situations… In short – the bird’s eye view of the code. 
There’s a special diagram language <a href="http://wikipedia.org/wiki/Unified_Modeling_Language">UML</a> for high-level architecture diagrams. 
Definitely worth studying.

</dd>
<dt>Document a function usage</dt>
<dd>

There’s a special syntax <a href="http://en.wikipedia.org/wiki/JSDoc">JSDoc</a> to document a function: usage, parameters, returned value.

For instance:

    <code>/**
 * Returns x raised to the n-th power.
 *
 * @param {number} x The number to raise.
 * @param {number} n The power, must be a natural number.
 * @return {number} x raised to the n-th power.
 */
function pow(x, n) {
  ...
}</code>
  Such comments allow us to understand the purpose of the function and use it the right way without looking in its code.

By the way, many editors like <a href="https://www.jetbrains.com/webstorm/">WebStorm</a> can understand them as well and use them to provide autocomplete and some automatic code-checking.

Also, there are tools like <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3</a> that can generate HTML-documentation from the comments. 
You can read more information about JSDoc at <a href="http://usejsdoc.org/">http://usejsdoc.org/</a>.

</dd>
<dt>Why is the task solved this way?</dt>
<dd>

What’s written is important. 
But what’s <em>not</em> written may be even more important to understand what’s going on. 
Why is the task solved exactly this way? The code gives no answer.

If there are many ways to solve the task, why this one? Especially when it’s not the most obvious one.

Without such comments the following situation is possible:

<li>You (or your colleague) open the code written some time ago, and see that it’s “suboptimal”.</li><li>You think: “How stupid I was then, and how much smarter I’m now”, and rewrite using the “more obvious and correct” variant.</li><li>…The urge to rewrite was good. 
But in the process you see that the “more obvious” solution is actually lacking. 
You even dimly remember why, because you already tried it long ago. 
You revert to the correct variant, but the time was wasted.</li>

Comments that explain the solution are very important. 
They help to continue development the right way.

</dd>
<dt>Any subtle features of the code? Where they are used?</dt>
<dd>

If the code has anything subtle and counter-intuitive, it’s definitely worth commenting.

</dd>
</dl>

<h4><a name="summary" href="#summary">Summary</a4</h2>
An important sign of a good developer is comments: their presence and even their absense.

Good comments allow us to maintain the code well, come back to it after a delay and use it more effectively.

<strong>Comment this:</strong>

<li>Overall architecture, high-level view.</li><li>Function usage.</li><li>Important solutions, especially when not immediately obvious.</li>

<strong>Avoid comments:</strong>

<li>That tell “how code works” and “what it does”.</li><li>Put them only if it’s impossible to make the code so simple and self-descriptive that it doesn’t require those.</li>

Comments are also used for auto-documenting tools like JSDoc3: they read them and generate HTML-docs (or docs in another format).

<blockquote>

Learning without thought is labor lost; thought without learning is perilous.

<footer>
  <cite>Confucius</cite>
 </footer></blockquote>
Programmer ninjas of the past used these tricks to make sharpen the mind of code maintainers.

Code review gurus look for them in test tasks.

Novice developers sometimes use them even better than programmer ninjas.

Read them carefully and find out who you are – a ninja, a novice, or maybe a code reviewer?

Irony detected
Many try to follow ninja paths. 
Few succeed.

<h2>Brevity is the soul of wit</h2>
Make the code as short as possible. 
Show how smart you are.

Let subtle language features guide you.

For instance, take a look at this ternary operator <code>'?'</code>:

    <code>// taken from a well-known javascript library
i = i ? i &lt; 0 ? Math.max(0, len + i) : i : 0;</code>
  Cool, right? If you write like that, the developer who comes across this line and tries to understand what is the value of <code>i</code> is going to have a merry time. 
Then come to you, seeking for an answer.

Tell him that shorter is always better. 
Initiate him into the paths of ninja.

<h2>One-letter variables</a></h2><blockquote classote">

The Dao hides in wordlessness. 
Only the Dao is well begun and well
completed.

<footer>
  <cite>Laozi (Tao Te Ching)</cite>
 </footer></blockquote>
Another way to code faster is to use single-letter variable names everywhere. 
Like <code>a</code>, <code>b</code> or <code>c</code>.

A short variable disappears in the code like a real ninja in the forest. 
No one will be able to find it using “search” of the editor. 
And even if someone does, he won’t be able to “decipher” what the name <code>a</code> or <code>b</code> means.

…But there’s an exception. 
A real ninja will never use <code>i</code> as the counter in a <code>&quot;for&quot;</code> loop. 
Anywhere, but not here. 
Look around, there are many more exotic letters. 
For instance, <code>x</code> or <code>y</code>.

An exotic variable as a loop counter is especially cool if the loop body takes 1-2 pages (make it longer if you can). 
Then if someone looks deep inside the loop, he won’t be able to quickly figure out that the variable named <code>x</code> is the loop counter.

<h2>Use abbreviations</h2>
If the team rules forbid the use of one-letter and vague names – shorten them, make abbreviations.

Like this:

<li><code>list</code> → <code>lst</code>.</li><li><code>userAgent</code> → <code>ua</code>.</li><li><code>browser</code> → <code>brsr</code>.</li><li>…etc</li>

Only the one with truly good intuition will be able to understand such names. 
Try to shorten everything. 
Only a worthy person should be able to uphold the development of your code.

<h2>Soar high. 
Be abstract.</a></h2><blockquote classote">

The great square is cornerlessThe great vessel is last complete,The great note is rarified sound,The great image has no form.

<footer>
  <cite>Laozi (Tao Te Ching)</cite>
 </footer></blockquote>
While choosing a name try to use the most abstract word. 
Like <code>obj</code>, <code>data</code>, <code>value</code>, <code>item</code>, <code>elem</code> and so on.

<li><strong>The ideal name for a variable is <code>data</code>.</strong> Use it everywhere you can. 
Indeed, every variable holds <em>data</em>, right?

…But what to do if <code>data</code> is already taken? Try <code>value</code>, it’s also universal. 
After all, a variable eventually gets a <em>value</em>.

</li><li><strong>Name a variable by its type: <code>str</code>, <code>num</code>…</strong>

Give them a try. 
A young initiate may wonder – are such names really useful for a ninja? Indeed, they are!

Sure, the variable name still means something. 
It says what’s inside the variable: a string, a number or something else. 
But when an outsider tries to understand the code, he’ll be surprised to see that there’s actually no information at all! And will ultimately fail to alter your well-thought code.

The value type is easy to find out by debugging. 
But what’s the meaning of the variable? Which string/number does it store?

There’s just no way to figure out without a good meditation!

</li><li><strong>…But what if there are no more such names?</strong> Just add a number: <code>data1, item2, elem5</code>…

</li>

<h2>Attention test</h2>
Only a truly attentive programmer should be able to understand your code. 
But how to check that?

<strong>One of the ways – use similar variable names, like <code>date</code> and <code>data</code>.</strong>

Mix them where you can.

A quick read of such code becomes impossible. 
And when there’s a typo… Ummm… We’re stuck for long, time to drink tea.

<h2>Smart synonyms</a></h2><blockquote classote">

The hardest thing of all is to find a black cat in a dark room, especially if there is no cat.

<footer>
  <cite>Confucius</cite>
 </footer></blockquote>
Using <em>similar</em> names for <em>same</em> things makes life more interesting and shows your creativity to the public.

For instance, consider function prefixes. 
If a function shows a message on the screen – start it with <code>display…</code>, like <code>displayMessage</code>. 
And then if another function shows on the screen something else, like a user name, start it with <code>show…</code> (like <code>showName</code>).

Insinuate that there’s a subtle difference between such functions, while there is none.

Make a pact with fellow ninjas of the team: if John starts “showing” functions with <code>display...</code> in his code, then Peter could use <code>render..</code>, and Ann – <code>paint...</code>. 
Note how much more interesting and diverse the code became.

…And now the hat trick!

For two functions with important differences – use the same prefix!

For instance, the function <code>printPage(page)</code> will use a printer. 
And the function <code>printText(text)</code> will put the text on-screen. 
Let an unfamiliar reader think well over similarly named function <code>printMessage</code>: “Where does it put the message? To a printer or on the screen?”. 
To make it really shine, <code>printMessage(message)</code> should output it in the new window!

<h2>Reuse names</a></h2><blockquote classote">

Once the whole is divided, the partsneed names.There are already enough names.One must know when to stop.

<footer>
  <cite>Laozi (Tao Te Ching)</cite>
 </footer></blockquote>
Add a new variable only when absolutely necessary.

Instead, reuse existing names. 
Just write new values into them.

In a function try to use only variables passed as parameters.

That would make it really hard to identify what’s exactly in the variable <em>now</em>. 
And also where it comes from. 
A person with weak intuition would have to analyze the code line-by-line and track the changes through every code branch.

<strong>An advanced variant of the approach is to covertly (!) replace the value with something alike in the middle of a loop or a function.</strong>

For instance:

    <code>function ninjaFunction(elem) {
  // 20 lines of code working with elem
  elem = clone(elem);
  // 20 more lines, now working with the clone of the elem!
}</code>
  A fellow programmer who wants to work with <code>elem</code> in the second half of the function will be surprised… Only during the debugging, after examining the code he will find out that he’s working with a clone!

Deadly effective even against an experienced ninja. 
Seen in code regularly.

<h2>Underscores for fun</h2>
Put underscores <code>_</code> and <code>__</code> before variable names. 
Like <code>_name</code> or <code>__value</code>. 
It would be great if only you knew their meaning. 
Or, better, add them just for fun, without particular meaning at all. 
Or different meanings in different places.

You kill two rabbits with one shot. 
First, the code becomes longer and less readable, and the second, a fellow developer may spend a long time trying to figure out what the underscores mean.

A smart ninja puts underscores at one spot of code and evades them at other places. 
That makes the code even more fragile and increases the probability of future errors.

<h2>Show your love</h2>
Let everyone see how magnificent your entities are! Names like <code>superElement</code>, <code>megaFrame</code> and <code>niceItem</code> will definitely enlighten a reader.

Indeed, from one hand, something is written: <code>super..</code>, <code>mega..</code>, <code>nice..</code> But from the other hand – that brings no details. 
A reader may decide to look for a hidden meaning and meditate for an hour or two.

<h2>Overlap outer variables</a></h2><blockquote classote">

When in the light, can’t see anything in the darkness.When in the darkness, can see everything in the light.

<footer>
  <cite>Guan Yin Zi</cite>
 </footer></blockquote>
Use same names for variables inside and outside a function. 
As simple. 
No efforts required.

    <code>let user = authenticateUser();
function render() {
  let user = anotherValue();
  ...
  ...many lines...
  ...
  ... 
// &lt;-- a programmer wants to work with user here and...
  ...
}</code>
  A programmer who jumps inside the <code>render</code> will probably fail to notice that there’s a local <code>user</code> shadowing the outer one.

Then he’ll try to work with <code>user</code> assuming that it’s the external variable, the result of <code>authenticateUser()</code>… The trap is sprung! Hello, debugger…

<h2>Side-effects everywhere!</h2>
There are functions that look like they don’t change anything. 
Like <code>isReady()</code>, <code>checkPermission()</code>, <code>findTags()</code>… They are assumed to carry out calculations, find and return the data, without changing anything outside of them. 
In other words, without “side-effects”.

<strong>A really beautiful trick is to add a “useful” action to them, besides the main task.</strong>

The expression of dazed surprise on the face of your colleague when he sees a function named <code>is..</code>, <code>check..</code> or <code>find...</code> changing something – will definitely broaden your boundaries of reason.

<strong>Another way to surprise is to return a non-standard result.</strong>

Show your original thinking! Let the call of <code>checkPermission</code> return not <code>true/false</code>, but a complex object with the results of the check.

Those developers who try to write <code>if (checkPermission(..))</code>, will wonder why it doesn’t work. 
Tell them: “Read the docs!”. 
And give this article.

<h2>Powerful functions!</a></h2><blockquote classote">

The great Tao flows everywhere,both to the left and to the right.

<footer>
  <cite>Laozi (Tao Te Ching)</cite>
 </footer></blockquote>
Don’t limit the function by what’s written in its name. 
Be broader.

For instance, a function <code>validateEmail(email)</code> could (besides checking the email for correctness) show an error message and ask to re-enter the email.

Additional actions should not be obvious from the function name. 
A true ninja coder will make them not obvious from the code as well.

<strong>Joining several actions into one protects your code from reuse.</strong>

Imagine, another developer wants only to check the email, and not output any message. 
Your function  <code>validateEmail(email)</code> that does both will not suit him. 
So he won’t break your meditation by asking anything about it.

<h4><a name="summary" href="#summary">Summary</a4</h2>
All “pieces of advice” above are from the real code… Sometimes, written by experienced developers. 
Maybe even more experienced than you are ;)

<li>Follow some of them, and your code will become full of surprises.</li><li>Follow many of them, and your code will become truly yours, no one would want to change it.</li><li>Follow all, and your code will become a valuable lesson for young developers looking for enlightenment.</li>

Automated testing will be used in further tasks.

It’s actually a part of the “educational minimum” of a developer.

<h2>Why we need tests?</h2>
When we write a function, we can usually imagine what it should do: which parameters give which results.

During development, we can check the function by running it and comparing the outcome with the expected one. 
For instance, we can do it in the console.

If something is wrong – then we fix the code, run again, check the result – and so on till it works.

But such manual “re-runs” are imperfect.

<strong>When testing a code by manual re-runs, it’s easy to miss something.</strong>

For instance, we’re creating a function <code>f</code>. 
Wrote some code, testing: <code>f(1)</code> works, but <code>f(2)</code> doesn’t work. 
We fix the code and now <code>f(2)</code> works. 
Looks complete? But we forgot to re-test <code>f(1)</code>. 
That may lead to an error.

That’s very typical. 
When we develop something, we keep a lot of possible use cases in mind. 
But it’s hard to expect a programmer to check all of them manually after every change. 
So it becomes easy to fix one thing and break another one.

<strong>Automated testing means that tests are written separately, in addition to the code. 
They can be executed easily and check all the main use cases.</strong>

<h2>Behavior Driven Development (BDD)</h2>
Let’s use a technique named <a href="http://en.wikipedia.org/wiki/Behavior-driven_development">Behavior Driven Development</a> or, in short, BDD. 
That approach is used among many projects. 
BDD is not just about testing. 
That’s more.

<strong>BDD is three things in one: tests AND documentation AND examples.</strong>

Enough words. 
Let’s see the example.

<h2>Development of “pow”: the spec</h2>
Let’s say we want to make a function <code>pow(x, n)</code> that raises <code>x</code> to an integer power <code>n</code>. 
We assume that <code>n≥0</code>.

That task is just an example: there’s the <code>**</code> operator in JavaScript that can do that, but here we concentrate on the development flow that can be applied to more complex tasks as well.

Before creating the code of <code>pow</code>, we can imagine what the function should do and describe it.

Such description is called a <em>specification</em> or, in short, a spec, and looks like this:

    <code>describe(&quot;pow&quot;, function() {
  it(&quot;raises to n-th power&quot;, function() {
    assert.equal(pow(2, 3), 8);
  });
});</code>
  A spec has three main building blocks that you can see above:

<dl>
<dt><code>describe(&quot;title&quot;, function() { ... 
})</code></dt>
<dd>

What functionality we’re describing. 
Uses to group “workers” – the <code>it</code> blocks. 
In our case we’re describing the function <code>pow</code>.

</dd>
<dt><code>it(&quot;title&quot;, function() { ... 
})</code></dt>
<dd>

In the title of <code>it</code> we <em>in a human-readable way</em> describe the particular use case, and the second argument is a function that tests it.

</dd>
<dt><code>assert.equal(value1, value2)</code></dt>
<dd>

The code inside <code>it</code> block, if the implementation is correct, should execute without errors.

Functions <code>assert.*</code> are used to check whether <code>pow</code> works as expected. 
Right here we’re using one of them – <code>assert.equal</code>, it compares arguments and yields an error if they are not equal. 
Here it checks that the result of <code>pow(2, 3)</code> equals <code>8</code>.

There are other types of comparisons and checks that we’ll see further.

</dd>
</dl>

<h2>The development flow</h2>
The flow of development usually looks like this:

<li>An initial spec is written, with tests for the most basic functionality.</li><li>An initial implementation is created.</li><li>To check whether it works, we run the testing framework <a href="http://mochajs.org/">Mocha</a> (more details soon) that runs the spec. 
Errors are displayed. 
We make corrections until everything works.</li><li>Now we have a working initial implementation with tests.</li><li>We add more use cases to the spec, probably not yet supported by the implementations. 
Tests start to fail.</li><li>Go to 3, update the implementation till tests give no errors.</li><li>Repeat steps 3-6 till the functionality is ready.</li>

So, the development is <em>iterative</em>. 
We write the spec, implement it, make sure tests pass, then write more tests, make sure they work etc. 
At the end we have both a working implementation and tests for it.

In our case, the first step is complete: we have an initial spec for <code>pow</code>. 
So let’s make an implementation. 
But before that let’s make a “zero” run of the spec, just to see that tests are working (they will all fail).

<h2>The spec in action</h2>
Here in the tutorial we’ll be using the following JavaScript libraries for tests:

<li><a href="http://mochajs.org/">Mocha</a> – the core framework: it provides common testing functions including <code>describe</code> and <code>it</code> and the main function that runs tests.</li><li><a href="http://chaijs.com">Chai</a> – the library with many assertions. 
It allows to use a lot of different assertions, for now we need only <code>assert.equal</code>.</li><li><a href="http://sinonjs.org/">Sinon</a> – a library to spy over functions, emulate built-in functions and more, we’ll need it much later.</li>

These libraries are suitable for both in-browser and server-side testing. 
Here we’ll consider the browser variant.

The full HTML page with these frameworks and <code>pow</code> spec:

    <code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;!-- add mocha css, to show results --&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/mocha/3.2.0/mocha.css&quot;&gt;
  &lt;!-- add mocha framework code --&gt;
  &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mocha/3.2.0/mocha.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    mocha.setup('bdd'); // minimal setup
  &lt;/script&gt;
  &lt;!-- add chai --&gt;
  &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/chai/3.5.0/chai.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    // chai has a lot of stuff, let's make assert global
    let assert = chai.assert;
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;script&gt;
    function pow(x, n) {
/* function code is to be written, empty now */
    }
  &lt;/script&gt;
  &lt;!-- the script with tests (describe, it...) --&gt;
  &lt;script src=&quot;test.js&quot;&gt;&lt;/script&gt;
  &lt;!-- the element with id=&quot;mocha&quot; will contain test results --&gt;
  &lt;div id=&quot;mocha&quot;&gt;&lt;/div&gt;
  &lt;!-- run tests! --&gt;
  &lt;script&gt;
    mocha.run();
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code>
  The page can be divided into four parts:

<li>The <code>&lt;head&gt;</code> – add third-party libraries and styles for tests.</li><li>The <code>&lt;script&gt;</code> with the function to test, in our case – with the code for <code>pow</code>.</li><li>The tests – in our case an external script <code>test.js</code> that has <code>describe(&quot;pow&quot;, ...)</code> from above.</li><li>The HTML element <code>&lt;div id=&quot;mocha&quot;&gt;</code> will be used by Mocha to output results.</li><li>The tests are started by the command <code>mocha.run()</code>.</li>

The result:

    

  <a href="http://plnkr.co/edit/DpoIGQujfeZhebARG4Jo?p=preview" target="_blank" title="open in sandbox"
  data-plunk-id="DpoIGQujfeZhebARG4Jo"></a>
    <iframe data-trusted="1" style="height:250px" src="https://en.js.cx/article/testing-mocha/pow-1/"></iframe>
  
As of now, the test fails, there’s an error. 
That’s logical: we have an empty function code in <code>pow</code>, so <code>pow(2,3)</code> returns <code>undefined</code> instead of <code>8</code>.

For the future, let’s note that there are advanced test-runners, like <a href="https://karma-runner.github.io/">karma</a> and others. 
So it’s generally not a problem to setup many different tests.

<h2>Initial implementation</h2>
Let’s make a simple implementation of <code>pow</code>, for tests to pass:

    <code>function pow() {
  return 8; // :) we cheat!
}</code>
  Wow, now it works!

    

  <a href="http://plnkr.co/edit/QghJUoiN8jFtVfljQXNC?p=preview" target="_blank" title="open in sandbox"
  data-plunk-id="QghJUoiN8jFtVfljQXNC"></a>
    <iframe data-trusted="1" style="height:250px" src="https://en.js.cx/article/testing-mocha/pow-min/"></iframe>
  
<h2>Improving the spec</h2>
What we’ve done is definitely a cheat. 
The function does not work: an attempt to calculate <code>pow(3,4)</code> would give an incorrect result, but tests pass.

…But the situation is quite typical, it happens in practice. 
Tests pass, but the function works wrong. 
Our spec is imperfect. 
We need to add more use cases to it.

Let’s add one more test to see if <code>pow(3, 4) = 81</code>.

We can select one of two ways to organize the test here:

<li>The first variant – add one more <code>assert</code> into the same <code>it</code>:

    <code>describe(&quot;pow&quot;, function() {
  it(&quot;raises to n-th power&quot;, function() {
    assert.equal(pow(2, 3), 8);
    assert.equal(pow(3, 4), 81);
  });
});</code>
  </li><li>The second – make two tests:

    <code>describe(&quot;pow&quot;, function() {
  it(&quot;2 raised to power 3 is 8&quot;, function() {
    assert.equal(pow(2, 3), 8);
  });
  it(&quot;3 raised to power 3 is 27&quot;, function() {
    assert.equal(pow(3, 3), 27);
  });
});</code>
  </li>

The principal difference is that when <code>assert</code> triggers an error, the <code>it</code> block immediately terminates. 
So, in the first variant if the first <code>assert</code> fails, then we’ll never see the result of the second <code>assert</code>.

Making tests separate is useful to get more information about what’s going on, so the second variant is better.

And besides that, there’s one more rule that’s good to follow.

<strong>One test checks one thing.</strong>

If we look at the test and see two independent checks in it, it’s better to split it into two simpler ones.

So let’s continue with the second variant.

The result:

    

  <a href="http://plnkr.co/edit/DEzWwmbmQqejOw0CX48A?p=preview" target="_blank" title="open in sandbox"
  data-plunk-id="DEzWwmbmQqejOw0CX48A"></a>
    <iframe data-trusted="1" style="height:250px" src="https://en.js.cx/article/testing-mocha/pow-2/"></iframe>
  
As we could expect, the second test failed. 
Sure, our function always returns <code>8</code>, while the <code>assert</code> expects <code>27</code>.

<h2>Improving the implementation</h2>
Let’s write something more real for tests to pass:

    <code>function pow(x, n) {
  let result = 1;
  for (let i = 0; i &lt; n; i++) {
    result *= x;
  }
  return result;
}</code>
  To be sure that the function works well, let’s test it for more values. 
Instead of writing <code>it</code> blocks manually, we can generate them in <code>for</code>:

    <code>describe(&quot;pow&quot;, function() {
  function makeTest(x) {
    let expected = x * x * x;
    it(`${x} in the power 3 is ${expected}`, function() {
assert.equal(pow(x, 3), expected);
    });
  }
  for (let x = 1; x &lt;= 5; x++) {
    makeTest(x);
  }
});</code>
  The result:

    

  <a href="http://plnkr.co/edit/l87TGEgMxDS4bLYxNmbk?p=preview" target="_blank" title="open in sandbox"
  data-plunk-id="l87TGEgMxDS4bLYxNmbk"></a>
    <iframe data-trusted="1" style="height:250px" src="https://en.js.cx/article/testing-mocha/pow-3/"></iframe>
  
<h2>Nested describe</h2>
We’re going to add even more tests. 
But before that let’s note that the helper function <code>makeTest</code> and <code>for</code> should be grouped together. 
We won’t need <code>makeTest</code> in other tests, it’s needed only in <code>for</code>: their common task is to check how <code>pow</code> raises into the given power.

Grouping is done with a nested <code>describe</code>:

    <code>describe(&quot;pow&quot;, function() {
  describe(&quot;raises x to power n&quot;, function() {
    function makeTest(x) {
let expected = x * x * x;
it(`${x} in the power 3 is ${expected}`, function() {
  assert.equal(pow(x, 3), expected);
});
    }
    for (let x = 1; x &lt;= 5; x++) {
makeTest(x);
    }
  });
  // ... 
more tests to follow here, both describe and it can be added
});</code>
  The nested <code>describe</code> defines a new “subgroup” of tests. 
In the output we can see the titled indentation:

    

  <a href="http://plnkr.co/edit/l3pTGpRdjaZCWJ3fCr0e?p=preview" target="_blank" title="open in sandbox"
  data-plunk-id="l3pTGpRdjaZCWJ3fCr0e"></a>
    <iframe data-trusted="1" style="height:250px" src="https://en.js.cx/article/testing-mocha/pow-4/"></iframe>
  
In the future we can add more <code>it</code> and <code>describe</code> on the top level with helper functions of their own, they won’t see <code>makeTest</code>.

<code>before/after</code> and <code>beforeEach/afterEach</code>
We can setup <code>before/after</code> functions that execute before/after running tests, and also <code>beforeEach/afterEach</code> functions that execute before/after <em>every</em> <code>it</code>.

For instance:

    <code>describe(&quot;test&quot;, function() {
  before(() =&gt; alert(&quot;Testing started – before all tests&quot;));
  after(() =&gt; alert(&quot;Testing finished – after all tests&quot;));
  beforeEach(() =&gt; alert(&quot;Before a test – enter a test&quot;));
  afterEach(() =&gt; alert(&quot;After a test – exit a test&quot;));
  it('test 1', () =&gt; alert(1));
  it('test 2', () =&gt; alert(2));
});</code>
  The running sequence will be:

    <code>Testing started – before all tests (before)
Before a test – enter a test (beforeEach)
1
After a test – exit a test   (afterEach)
Before a test – enter a test (beforeEach)
2
After a test – exit a test   (afterEach)
Testing finished – after all tests (after)</code>
  <a target="_blank" href="http://plnkr.co/edit/LNHgyY9xlBiPYKuPBEfl?p=preview">Open the example in the sandbox.</a>

Usually, <code>beforeEach/afterEach</code> (<code>before/each</code>) are used to perform initialization, zero out counters or do something else between the tests (or test groups).

<h2>Extending the spec</h2>
The basic functionality of <code>pow</code> is complete. 
The first iteration of the development is done. 
When we’re done celebrating and drinking champagne – let’s go on and improve it.

As it was said, the function <code>pow(x, n)</code> is meant to work with positive integer values <code>n</code>.

To indicate a mathematical error, JavaScript functions usually return <code>NaN</code>. 
Let’s do the same for invalid values of <code>n</code>.

Let’s first add the behavior to the spec(!):

    <code>describe(&quot;pow&quot;, function() {
  // ...
  it(&quot;for negative n the result is NaN&quot;, function() {
    assert.isNaN(pow(2, -1));
  });
  it(&quot;for non-integer n the result is NaN&quot;, function() {
    assert.isNaN(pow(2, 1.5));
  });
});</code>
  The result with new tests:

    

  <a href="http://plnkr.co/edit/sEEU3SBRyEWT5rNFYm3f?p=preview" target="_blank" title="open in sandbox"
  data-plunk-id="sEEU3SBRyEWT5rNFYm3f"></a>
    <iframe data-trusted="1" style="height:530px" src="https://en.js.cx/article/testing-mocha/pow-nan/"></iframe>
  
The newly added tests fail, because our implementation does not support them. 
That’s how BDD is done: first we write failing tests, and then make an implementation for them.

Other assertions
Please note the assertion <code>assert.isNaN</code>: it checks for <code>NaN</code>.

There are other assertions in Chai as well, for instance:

<li><code>assert.equal(value1, value2)</code> – checks the equality  <code>value1 == value2</code>.</li><li><code>assert.strictEqual(value1, value2)</code> – checks the strict equality <code>value1 === value2</code>.</li><li><code>assert.notEqual</code>, <code>assert.notStrictEqual</code> – inverse checks to the ones above.</li><li><code>assert.isTrue(value)</code> – checks that <code>value === true</code></li><li><code>assert.isFalse(value)</code> – checks that <code>value === false</code></li><li>…the full list is in the <a href="http://chaijs.com/api/assert/">docs</a></li>

So we should add a couple of lines to <code>pow</code>:

    <code>function pow(x, n) {
  if (n &lt; 0) return NaN;
  if (Math.round(n) != n) return NaN;
  let result = 1;
  for (let i = 0; i &lt; n; i++) {
    result *= x;
  }
  return result;
}</code>
  Now it works, all tests pass:

    

  <a href="http://plnkr.co/edit/JrEQGLs7A5HStqLVDMPD?p=preview" target="_blank" title="open in sandbox"
  data-plunk-id="JrEQGLs7A5HStqLVDMPD"></a>
    <iframe data-trusted="1" style="height:300px" src="https://en.js.cx/article/testing-mocha/pow-full/"></iframe>
  
<a target="_blank" href="http://plnkr.co/edit/JrEQGLs7A5HStqLVDMPD?p=preview">Open the full final example in the sandbox.</a>

<h4><a name="summary" href="#summary">Summary</a4</h2>
In BDD, the spec goes first, followed by implementation. 
At the end we have both the spec and the code.

The spec can be used in three ways:

<li><strong>Tests</strong> guarantee that the code works correctly.</li><li><strong>Docs</strong> – the titles of <code>describe</code> and <code>it</code> tell what the function does.</li><li><strong>Examples</strong> – the tests are actually working examples showing how a function can be used.</li>

With the spec, we can safely improve, change, even rewrite the function from scratch and make sure it still works right.

That’s especially important in large projects when a function is used in many places. 
When we change such a function, there’s just no way to manually check if every place that uses it still works right.

Without tests, people have two ways:

<li>To perform the change, no matter what. 
And then our users meet bugs and report them. 
If we can afford that.</li><li>Or people become afraid to modify such functions, if the punishment for errors is harsh. 
Then it becomes old, overgrown with cobwebs, no one wants to get into it, and that’s not good.</li>

<strong>Automatically tested code is contrary to that!</strong>

If the project is covered with tests, there’s just no such problem. 
We can run tests and see a lot of checks made in a matter of seconds.

<strong>Besides, a well-tested code has better architecture.</strong>

Naturally, that’s because it’s easier to change and improve it. 
But not only that.

To write tests, the code should be organized in such a way that every function has a clearly described task, well-defined input and output. 
That means a good architecture from the beginning.

In real life that’s sometimes not that easy. 
Sometimes it’s difficult to write a spec before the actual code, because it’s not yet clear how it should behave. 
But in general writing tests makes development faster and more stable.

<h2>What now?</h2>
Later in the tutorial you will meet many tasks with tests baked-in. 
So you’ll see more practical examples.

Writing tests requires good JavaScript knowledge. 
But we’re just starting to learn it. 
So, to settle down everything, as of now you’re not required to write tests, but you should already be able to read them even if they are a little bit more complex than in this chapter.

    <code>it(&quot;Raises x to the power n&quot;, function() {
  let x = 5;
  let result = x;
  assert.equal(pow(x, 1), result);
  result *= x;
  assert.equal(pow(x, 2), result);
  result *= x;
  assert.equal(pow(x, 3), result);
});</code>
  P.S. 
Syntactically the test is correct and passes.

<button type="button">solution</button>

The test demonstrates one of the temptations a developer meets when writing tests.

What we have here is actually 3 tests, but layed out as a single function with 3 asserts.

Sometimes it’s easier to write this way, but if an error occurs, it’s much less obvious what went wrong.

If an error happens inside a complex execution flow, then we’ll have to figure out the data at that point. 
We’ll actually have to <em>debug the test</em>.

It would be much better to break the test into multiple <code>it</code> blocks with clearly written inputs and outputs.

Like this:

    <code>describe(&quot;Raises x to power n&quot;, function() {
  it(&quot;5 in the power of 1 equals 5&quot;, function() {
    assert.equal(pow(5, 1), 5);
  });
  it(&quot;5 in the power of 2 equals 25&quot;, function() {
    assert.equal(pow(5, 2), 25);
  });
  it(&quot;5 in the power of 3 equals 125&quot;, function() {
    assert.equal(pow(5, 3), 125);
  });
});</code>
  We replaced the single <code>it</code> with <code>describe</code> and a group of <code>it</code> blocks. 
Now if something fails we would see clearly what the data was.

Also we can isolate a single test and run it in standalone mode by writing <code>it.only</code> instead of <code>it</code>:

    <code>describe(&quot;Raises x to power n&quot;, function() {
  it(&quot;5 in the power of 1 equals 5&quot;, function() {
    assert.equal(pow(5, 1), 5);
  });
  // Mocha will run only this block
  it.only(&quot;5 in the power of 2 equals 25&quot;, function() {
    assert.equal(pow(5, 2), 25);
  });
  it(&quot;5 in the power of 3 equals 125&quot;, function() {
    assert.equal(pow(5, 3), 125);
  });
});</code>
  <button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/ninja-code" data-tooltip="Ninja code">Previous lesson</a><a href="/polyfills" data-tooltip="Polyfills">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Ftesting-mocha"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Ftesting-mocha"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Ftesting-mocha"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Ftesting-mocha"></a>

The JavaScript language steadily evolves. 
New proposals to the language appear regularly, they are analyzed and, if considered worthy, are appended to the list at <a href="https://tc39.github.io/ecma262/">https://tc39.github.io/ecma262/</a> and then progress to the <a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">specification</a>.

Teams behind JavaScript engines have their own ideas about what to implement first. 
They may decide to implement proposals that are in draft and postpone things that are already in the spec, because they are less interesting or just harder to do.

So it’s quite common for an engine to implement only the part of the standard.

A good page to see the current state of support for language features is <a href="https://kangax.github.io/compat-table/es6/">https://kangax.github.io/compat-table/es6/</a> (it’s big, we have a lot to study yet).

<h2>Babel</h2>
When we use modern features of the language, some engines may fail to support such code. 
Just as said, not all features are implemented everywhere.

Here Babel comes to the rescue.

<a href="https://babeljs.io">Babel</a> is a <a href="https://en.wikipedia.org/wiki/Source-to-source_compiler">transpiler</a>. 
It rewrites modern JavaScript code into the previous standard.

Actually, there are two parts in Babel:

<li>First, the transpiler program, which rewrites the code. 
The developer runs it on his own computer. 
It rewrites the code into the older standard. 
And then the code is delivered to the website for users. 
Modern project build system like <a href="http://webpack.github.io/">webpack</a> or <a href="http://brunch.io/">brunch</a> provide means to run transpiler automatically on every code change, so that doesn’t involve any time loss from our side.

</li><li>Second, the polyfill.

The transpiler rewrites the code, so syntax features are covered. 
But for new functions we need to write a special script that implements them. 
JavaScript is a highly dynamic language, scripts may not just add new functions, but also modify built-in ones, so that they behave according to the modern standard.

There’s a term “polyfill” for scripts that “fill in” the gap and add missing implementations.

Two interesting polyfills are:

<li><a href="https://babeljs.io/docs/usage/polyfill/">babel polyfill</a> that supports a lot, but is big.</li><li><a href="http://polyfill.io">polyfill.io</a> service that allows to load/construct polyfills on-demand, depending on the features we need.</li>

</li>

So, we need to setup the transpiler and add the polyfill for old engines to support modern features.

If we orient towards modern engines and do not use features except those supported everywhere, then we don’t need to use Babel.

<h2>Examples in the tutorial</h2>
Most examples are runnable at-place, like this:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert('Press the &quot;Play&quot; button in the upper-right corner to run');</code>
  Examples that use modern JS will work only if your browser supports it.

<a href="https://www.google.com/chrome/browser/canary.html">Chrome Canary</a> is good for all examples, but other modern browsers are mostly fine too.

Note that on production we can use Babel to translate the code into suitable for less recent browsers, so there will be no such limitation, the code will run everywhere.

As we know from the chapter <a href="/types">Data types</a>, there are seven language types in JavaScript. 
Six of them are called “primitive”, because their values contain only a single thing (be it a string or a number or whatever).

In contrast, objects are used to store keyed collections of various data and more complex entities. 
In JavaScript, objects penetrate almost every aspect of the language. 
So we must understand them first before going in-depth anywhere else.

An object can be created with figure brackets <code>{…}</code> with an optional list of <em>properties</em>. 
A property is a “key: value” pair, where <code>key</code> is a string (also called a “property name”), and <code>value</code> can be anything.

We can imagine an object as a cabinet with signed files. 
Every piece of data is stored in its file by the key. 
It’s easy to find a file by its name or add/remove a file.

<img src="https://javascript.info/article/object/object.png">
An empty object (“empty cabinet”) can be created using one of two syntaxes:

    <code>let user = new Object(); // &quot;object constructor&quot; syntax
let user = {};  // &quot;object literal&quot; syntax</code>
  

<img src="https://javascript.info/article/object/object-user-empty.png">
Usually, the figure brackets <code>{...}</code> are used. 
That declaration is called an <em>object literal</em>.

<h2>Literals and properties</h2>
We can immediately put some properties into <code>{...}</code> as “key: value” pairs:

    <code>let user = {     // an object
  name: &quot;John&quot;,  // by key &quot;name&quot; store value &quot;John&quot;
  age: 30        // by key &quot;age&quot; store value 30
};</code>
  A property has a key (also known as “name” or “identifier”) before the colon <code>&quot;:&quot;</code> and a value to the right of it.

In the <code>user</code> object, there are two properties:

<li>The first property has the name <code>&quot;name&quot;</code> and the value <code>&quot;John&quot;</code>.</li><li>The second one has the name <code>&quot;age&quot;</code> and the value <code>30</code>.</li>

The resulting <code>user</code> object can be imagined as a cabinet with two signed files labeled “name” and “age”.

<img src="https://javascript.info/article/object/object-user.png">
We can add, remove and read files from it any time.

Property values are accessible using the dot notation:

    <code>// get fields of the object:
alert( user.name ); // John
alert( user.age ); // 30</code>
  The value can be of any type. 
Let’s add a boolean one:

    <code>user.isAdmin = true;</code>
  

<img src="https://javascript.info/article/object/object-user-isadmin.png">
To remove a property, we can use <code>delete</code> operator:

    <code>delete user.age;</code>
  

<img src="https://javascript.info/article/object/object-user-delete.png">
We can also use multiword property names, but then they must be quoted:

    <code>let user = {
  name: &quot;John&quot;,
  age: 30,
  &quot;likes birds&quot;: true  // multiword property name must be quoted
};</code>
  

<img src="https://javascript.info/article/object/object-user-props.png">
The last property in the list may end with a comma:

    <code>let user = {
  name: &quot;John&quot;,
  age: 30,
}</code>
  That is called a “trailing” or “hanging” comma. 
Makes it easier to add/remove/move around properties, because all lines become alike.

<h2>Square brackets</h2>
For multiword properties, the dot access doesn’t work:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// this would give a syntax error
user.likes birds = true</code>
  That’s because the dot requires the key to be a valid variable identifier. 
That is: no spaces and other limitations.

There’s an alternative “square bracket notation” that works with any string:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {};
// set
user[&quot;likes birds&quot;] = true;
// get
alert(user[&quot;likes birds&quot;]); // true
// delete
delete user[&quot;likes birds&quot;];</code>
  Now everything is fine. 
Please note that the string inside the brackets is properly quoted (any type of quotes will do).

Square brackets also provide a way to obtain the property name as the result of any expression – as opposed to a literal string – like from a variable as follows:

    <code>let key = &quot;likes birds&quot;;
// same as user[&quot;likes birds&quot;] = true;
user[key] = true;</code>
  Here, the variable <code>key</code> may be calculated at run-time or depend on the user input. 
And then we use it to access the property. 
That gives us a great deal of flexibility. 
The dot notation cannot be used in a similar way.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  name: &quot;John&quot;,
  age: 30
};
let key = prompt(&quot;What do you want to know about the user?&quot;, &quot;name&quot;);
// access by variable
alert( user[key] ); // John (if enter &quot;name&quot;)</code>
  <h3><a name="computed-properties" href="#computed-properties">Computed properties</a></h3>
We can use square brackets in an object literal. 
That’s called <em>computed properties</em>.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let fruit = prompt(&quot;Which fruit to buy?&quot;, &quot;apple&quot;);
let bag = {
  [fruit]: 5, // the name of the property is taken from the variable fruit
};
alert( bag.apple ); // 5 if fruit=&quot;apple&quot;</code>
  The meaning of a computed property is simple: <code>[fruit]</code> means that the property name should be taken from <code>fruit</code>.

So, if a visitor enters <code>&quot;apple&quot;</code>, <code>bag</code> will become <code>{apple: 5}</code>.

Essentially, that works the same as:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let fruit = prompt(&quot;Which fruit to buy?&quot;, &quot;apple&quot;);
let bag = {};
// take property name from the fruit variable
bag[fruit] = 5;</code>
  …But looks nicer.

We can use more complex expressions inside square brackets:

    <code>let fruit = 'apple';
let bag = {
  [fruit + 'Computers']: 5 // bag.appleComputers = 5
};</code>
  Square brackets are much more powerful than the dot notation. 
They allow any property names and variables. 
But they are also more cumbersome to write.

So most of the time, when property names are known and simple, the dot is used. 
And if we need something more complex, then we switch to square brackets.

Reserved words are allowed as property names
A variable cannot have a name equal to one of language-reserved words like “for”, “let”, “return” etc.

But for an object property, there’s no such restriction. 
Any name is fine:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let obj = {
  for: 1,
  let: 2,
  return: 3
}
alert( obj.for + obj.let + obj.return );  // 6</code>
  Basically, any name is allowed, but there’s a special one: <code>&quot;__proto__&quot;</code> that gets special treatment for historical reasons. 
For instance, we can’t set it to a non-object value:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let obj = {};
obj.__proto__ = 5;
alert(obj.__proto__); // [object Object], didn't work as intended</code>
  As we see from the code, the assignment to a primitive <code>5</code> is ignored.

That can become a source of bugs and even vulnerabilies if we intent to store arbitrary key-value pairs in an object, and allow a visitor to specify the keys.

In that case the visitor may choose “<strong>proto</strong>” as the key, and the assignment logic will be ruined (as shown above).

There is a way to make objects treat <code>__proto__</code> as a regular property, which we’ll cover later, but first we need to know more about objects.
There’s also another data structure <a href="/map-set-weakmap-weakset">Map</a>, that we’ll learn in the chapter <a href="/map-set-weakmap-weakset">Map, Set, WeakMap and WeakSet</a>, which supports arbitrary keys.

<h2>Property value shorthand</h2>
In real code we often use existing variables as values for property names.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function makeUser(name, age) {
  return {
    name: name,
    age: age
    // ...other properties
  };
}
let user = makeUser(&quot;John&quot;, 30);
alert(user.name); // John</code>
  In the example above, properties have the same names as variables. 
The use-case of making a property from a variable is so common, that there’s a special <em>property value shorthand</em> to make it shorter.

Instead of <code>name:name</code> we can just write <code>name</code>, like this:

    <code>function makeUser(name, age) {
  return {
    name, // same as name: name
    age   // same as age: age
    // ...
  };
}</code>
  We can use both normal properties and shorthands in the same object:

    <code>let user = {
  name,  // same as name:name
  age: 30
};</code>
  <h2>Existence check</h2>
A notable objects feature is that it’s possible to access any property. 
There will be no error if the property doesn’t exist! Accessing a non-existing property just returns <code>undefined</code>. 
It provides a very common way to test whether the property exists – to get it and compare vs undefined:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {};
alert( user.noSuchProperty === undefined ); // true means &quot;no such property&quot;</code>
  There also exists a special operator <code>&quot;in&quot;</code> to check for the existence of a property.

The syntax is:

    <code>&quot;key&quot; in object</code>
  For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = { name: &quot;John&quot;, age: 30 };
alert( &quot;age&quot; in user ); // true, user.age exists
alert( &quot;blabla&quot; in user ); // false, user.blabla doesn't exist</code>
  Please note that on the left side of <code>in</code> there must be a <em>property name</em>. 
That’s usually a quoted string.

If we omit quotes, that would mean a variable containing the actual name to be tested. 
For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = { age: 30 };
let key = &quot;age&quot;;
alert( key in user ); // true, takes the name from key and checks for such property</code>
  
Using “in” for properties that store <code>undefined</code>
Usually, the strict comparison <code>&quot;=== undefined&quot;</code> check works fine. 
But there’s a special case when it fails, but <code>&quot;in&quot;</code> works correctly.

It’s when an object property exists, but stores <code>undefined</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let obj = {
  test: undefined
};
alert( obj.test ); // it's undefined, so - no such property?
alert( &quot;test&quot; in obj ); // true, the property does exist!</code>
  In the code above, the property <code>obj.test</code> technically exists. 
So the <code>in</code> operator works right.

Situations like this happen very rarely, because <code>undefined</code> is usually not assigned. 
We mostly use <code>null</code> for “unknown” or “empty” values. 
So the <code>in</code> operator is an exotic guest in the code.

<h2>The “for…in” loop</h2>
To walk over all keys of an object, there exists a special form of the loop: <code>for..in</code>. 
This is a completely different thing from the <code>for(;;)</code> construct that we studied before.

The syntax:

    <code>for(key in object) {
  // executes the body for each key among object properties
}</code>
  For instance, let’s output all properties of <code>user</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  name: &quot;John&quot;,
  age: 30,
  isAdmin: true
};
for(let key in user) {
  // keys
  alert( key );  // name, age, isAdmin
  // values for the keys
  alert( user[key] ); // John, 30, true
}</code>
  Note that all “for” constructs allow us to declare the looping variable inside the loop, like <code>let key</code> here.

Also, we could use another variable name here instead of <code>key</code>. 
For instance, <code>&quot;for(let prop in obj)&quot;</code> is also widely used.

<h3><a name="ordered-like-an-object" href="#ordered-like-an-object">Ordered like an object</a></h3>
Are objects ordered? In other words, if we loop over an object, do we get all properties in the same order they were added? Can we rely on this?

The short answer is: “ordered in a special fashion”: integer properties are sorted, others appear in creation order. 
The details follow.

As an example, let’s consider an object with the phone codes:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let codes = {
  &quot;49&quot;: &quot;Germany&quot;,
  &quot;41&quot;: &quot;Switzerland&quot;,
  &quot;44&quot;: &quot;Great Britain&quot;,
  // ..,
  &quot;1&quot;: &quot;USA&quot;
};
for(let code in codes) {
  alert(code); // 1, 41, 44, 49
}</code>
  The object may be used to suggest a list of options to the user. 
If we’re making a site mainly for German audience then we probably want <code>49</code> to be the first.

But if we run the code, we see a totally different picture:

<li>USA (1) goes first</li><li>then Switzerland (41) and so on.</li>

The phone codes go in the ascending sorted order, because they are integers. 
So we see <code>1, 41, 44, 49</code>.

Integer properties? What’s that?
The “integer property” term here means a string that can be converted to-and-from an integer without a change.

So, “49” is an integer property name, because when it’s transformed to an integer number and back, it’s still the same. 
But “+49” and “1.2” are not:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// Math.trunc is a built-in function that removes the decimal part
alert( String(Math.trunc(Number(&quot;49&quot;))) ); // &quot;49&quot;, same, integer property
alert( String(Math.trunc(Number(&quot;+49&quot;))) ); // &quot;49&quot;, not same &quot;+49&quot; ⇒ not integer property
alert( String(Math.trunc(Number(&quot;1.2&quot;))) ); // &quot;1&quot;, not same &quot;1.2&quot; ⇒ not integer property</code>
  
…On the other hand, if the keys are non-integer, then they are listed in the creation order, for instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  name: &quot;John&quot;,
  surname: &quot;Smith&quot;
};
user.age = 25; // add one more
// non-integer properties are listed in the creation order
for (let prop in user) {
  alert( prop ); // name, surname, age
}</code>
  So, to fix the issue with the phone codes, we can “cheat” by making the codes non-integer. 
Adding a plus <code>&quot;+&quot;</code> sign before each code is enough.

Like this:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let codes = {
  &quot;+49&quot;: &quot;Germany&quot;,
  &quot;+41&quot;: &quot;Switzerland&quot;,
  &quot;+44&quot;: &quot;Great Britain&quot;,
  // ..,
  &quot;+1&quot;: &quot;USA&quot;
};
for(let code in codes) {
  alert( +code ); // 49, 41, 44, 1
}</code>
  Now it works as intended.

<h2>Copying by reference</h2>
One of the fundamental differences of objects vs primitives is that they are stored and copied “by reference”.

Primitive values: strings, numbers, booleans – are assigned/copied “as a whole value”.

For instance:

    <code>let message = &quot;Hello!&quot;;
let phrase = message;</code>
  As a result we have two independent variables, each one is storing the string <code>&quot;Hello!&quot;</code>.

<img src="https://javascript.info/article/object/variable-copy-value.png">
Objects are not like that.

<strong>A variable stores not the object itself, but its “address in memory”, in other words “a reference” to it.</strong>

Here’s the picture for the object:

    <code>let user = {
  name: &quot;John&quot;
};</code>
  

<img src="https://javascript.info/article/object/variable-contains-reference.png">
Here, the object is stored somewhere in memory. 
And the variable <code>user</code> has a “reference” to it.

<strong>When an object variable is copied – the reference is copied, the object is not duplicated.</strong>

If we imagine an object as a cabinet, then a variable is a key to it. 
Copying a variable duplicates the key, but not the cabinet itself.

For instance:

    <code>let user = { name: &quot;John&quot; };
let admin = user; // copy the reference</code>
  Now we have two variables, each one with the reference to the same object:

<img src="https://javascript.info/article/object/variable-copy-reference.png">
We can use any variable to access the cabinet and modify its contents:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = { name: 'John' };
let admin = user;
admin.name = 'Pete'; // changed by the &quot;admin&quot; reference
alert(user.name); // 'Pete', changes are seen from the &quot;user&quot; reference</code>
  The example above demonstrates that there is only one object. 
As if we had a cabinet with two keys and used one of them (<code>admin</code>) to get into it. 
Then, if we later use the other key (<code>user</code>) we would see changes.

<h3><a name="comparison-by-reference" href="#comparison-by-reference">Comparison by reference</a></h3>
The equality <code>==</code> and strict equality <code>===</code> operators for objects work exactly the same.

<strong>Two objects are equal only if they are the same object.</strong>

For instance, two variables reference the same object, they are equal:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let a = {};
let b = a; // copy the reference
alert( a == b ); // true, both variables reference the same object
alert( a === b ); // true</code>
  And here two independent objects are not equal, even though both are empty:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let a = {};
let b = {}; // two independent objects
alert( a == b ); // false</code>
  For comparisons like <code>obj1 &gt; obj2</code> or for a comparison against a primitive <code>obj == 5</code>, objects are converted to primitives. 
We’ll study how object conversions work very soon, but to tell the truth, such comparisons are necessary very rarely and usually are a result of a coding mistake.

<h3><a name="const-object" href="#const-object">Const object</a></h3>
An object declared as <code>const</code> <em>can</em> be changed.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>const user = {
  name: &quot;John&quot;
};
user.age = 25; // (*)
alert(user.age); // 25</code>
  It might seem that the line <code>(*)</code> would cause an error, but no, there’s totally no problem. 
That’s because <code>const</code> fixes the value of <code>user</code> itself. 
And here <code>user</code> stores the reference to the same object all the time. 
The line <code>(*)</code> goes <em>inside</em> the object, it doesn’t reassign <code>user</code>.

The <code>const</code> would give an error if we try to set <code>user</code> to something else, for instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>const user = {
  name: &quot;John&quot;
};
// Error (can't reassign user)
user = {
  name: &quot;Pete&quot;
};</code>
  …But what if we want to make constant object properties? So that <code>user.age = 25</code> would give an error. 
That’s possible too. 
We’ll cover it in the chapter <a href="/property-descriptors">Property flags and descriptors</a>.

<h2>Cloning and merging, Object.assign</h2>
So, copying an object variable creates one more reference to the same object.

But what if we need to duplicate an object? Create an independent copy, a clone?

That’s also doable, but a little bit more difficult, because there’s no built-in method for that in JavaScript. 
Actually, that’s rarely needed. 
Copying by reference is good most of the time.

But if we really want that, then we need to create a new object and replicate the structure of the existing one by iterating over its properties and copying them on the primitive level.

Like this:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  name: &quot;John&quot;,
  age: 30
};
let clone = {}; // the new empty object
// let's copy all user properties into it
for (let key in user) {
  clone[key] = user[key];
}
// now clone is a fully independant clone
clone.name = &quot;Pete&quot;; // changed the data in it
alert( user.name ); // still John in the original object</code>
  Also we can use the method <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign</a> for that.

The syntax is:

    <code>Object.assign(dest[, src1, src2, src3...])</code>
  <li>Arguments <code>dest</code>, and <code>src1, ..., srcN</code> (can be as many as needed) are objects.</li><li>It copies the properties of all objects <code>src1, ..., srcN</code> into <code>dest</code>. 
In other words, properties of all arguments starting from the 2nd are copied into the 1st. 
Then it returns <code>dest</code>.</li>

For instance, we can use it to merge several objects into one:

    <code>let user = { name: &quot;John&quot; };
let permissions1 = { canView: true };
let permissions2 = { canEdit: true };
// copies all properties from permissions1 and permissions2 into user
Object.assign(user, permissions1, permissions2);
// now user = { name: &quot;John&quot;, canView: true, canEdit: true }</code>
  If the receiving object (<code>user</code>) already has the same named property, it will be overwritten:

    <code>let user = { name: &quot;John&quot; };
// overwrite name, add isAdmin
Object.assign(user, { name: &quot;Pete&quot;, isAdmin: true });
// now user = { name: &quot;Pete&quot;, isAdmin: true }</code>
  We also can use <code>Object.assign</code> to replace the loop for simple cloning:

    <code>let user = {
  name: &quot;John&quot;,
  age: 30
};
let clone = Object.assign({}, user);</code>
  It copies all properties of <code>user</code> into the empty object and returns it. 
Actually, the same as the loop, but shorter.

Until now we assumed that all properties of <code>user</code> are primitive. 
But properties can be references to other objects. 
What to do with them?

Like this:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  name: &quot;John&quot;,
  sizes: {
    height: 182,
    width: 50
  }
};
alert( user.sizes.height ); // 182</code>
  Now it’s not enough to copy <code>clone.sizes = user.sizes</code>, because the <code>user.sizes</code> is an object, it will be copied by reference. 
So <code>clone</code> and <code>user</code> will share the same sizes:

Like this:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  name: &quot;John&quot;,
  sizes: {
    height: 182,
    width: 50
  }
};
let clone = Object.assign({}, user);
alert( user.sizes === clone.sizes ); // true, same object
// user and clone share sizes
user.sizes.width++;       // change a property from one place
alert(clone.sizes.width); // 51, see the result from the other one</code>
  To fix that, we should use the cloning loop that examines each value of <code>user[key]</code> and, if it’s an object, then replicate its structure as well. 
That is called a “deep cloning”.

There’s a standard algorithm for deep cloning that handles the case above and more complex cases, called the <a href="https://w3c.github.io/html/infrastructure.html#internal-structured-cloning-algorithm">Structured cloning algorithm</a>. 
In order not to reinvent the wheel, we can use a working implementation of it from the JavaScript library <a href="https://lodash.com">lodash</a>, the method is called <a href="https://lodash.com/docs#cloneDeep">_.cloneDeep(obj)</a>.

<h4><a name="summary" href="#summary">Summary</a4</h2>
Objects are associative arrays with several special features.

They store properties (key-value pairs), where:

<li>Property keys must be strings or symbols (usually strings).</li><li>Values can be of any type.</li>

To access a property, we can use:

<li>The dot notation: <code>obj.property</code>.</li><li>Square brackets notation <code>obj[&quot;property&quot;]</code>. 
Square brackets allow to take the key from a variable, like <code>obj[varWithKey]</code>.</li>

Additional operators:

<li>To delete a property: <code>delete obj.prop</code>.</li><li>To check if a property with the given key exists: <code>&quot;key&quot; in obj</code>.</li><li>To iterate over an object: <code>for(let key in obj)</code> loop.</li>

Objects are assigned and copied by reference. 
In other words, a variable stores not the “object value”, but a “reference” (address in memory) for the value. 
So copying such a variable or passing it as a function argument copies that reference, not the object. 
All operations via copied references (like adding/removing properties) are performed on the same single object.

To make a “real copy” (a clone) we can use <code>Object.assign</code> or  <a href="https://lodash.com/docs#cloneDeep">_.cloneDeep(obj)</a>.

What we’ve studied in this chapter is called a “plain object”, or just <code>Object</code>.

There are many other kinds of objects in JavaScript:

<li><code>Array</code> to store ordered data collections,</li><li><code>Date</code> to store the information about the date and time,</li><li><code>Error</code> to store the information about an error.</li><li>…And so on.</li>

They have their special features that we’ll study later. 
Sometimes people say something like “Array type” or “Date type”, but formally they are not types of their own, but belong to a single “object” data type. 
And they extend it in various ways.

Objects in JavaScript are very powerful. 
Here we’ve just scratched the surface of a topic that is really huge. 
We’ll be closely working with objects and learning more about them in further parts of the tutorial.

<li>Create an empty object <code>user</code>.</li><li>Add the property <code>name</code> with the value <code>John</code>.</li><li>Add the property <code>surname</code> with the value <code>Smith</code>.</li><li>Change the value of the <code>name</code> to <code>Pete</code>.</li><li>Remove the property <code>name</code> from the object.</li>

<button type="button">solution</button>

    <code>let user = {};
user.name = &quot;John&quot;;
user.surname = &quot;Smith&quot;;
user.name = &quot;Pete&quot;;
delete user.name;</code>
  <button type="button" title="close"></button>

<h3><a href="#check-for-emptiness" name="check-for-emptiness">Check for emptiness</a></h3><a href="/task/is-empty" target="_blank"></a>

importance: 5

Write the function <code>isEmpty(obj)</code> which returns <code>true</code> if the object has no properties, <code>false</code> otherwise.

Should work like that:

    <code>let schedule = {};
alert( isEmpty(schedule) ); // true
schedule[&quot;8:30&quot;] = &quot;get up&quot;;
alert( isEmpty(schedule) ); // false</code>
  <a href="http://plnkr.co/edit/5O2A59knPcjvDZVmYNzO?p=preview" target="_blank" data-plunk-id="5O2A59knPcjvDZVmYNzO">Open the sandbox with tests.</a>
<button type="button">solution</button>

Just loop over the object and <code>return false</code> immediately if there’s at least one property.

    <code>function isEmpty(obj) {
  for (let key in obj) {
    return false;
  }
  return true;
}</code>
  <a href="http://plnkr.co/edit/ghc5LgbADPtT435mU0Pm?p=preview" target="_blank" data-plunk-id="ghc5LgbADPtT435mU0Pm">Open the solution with tests in the sandbox.</a>
<button type="button" title="close"></button>

<h3><a href="#constant-objects" name="constant-objects">Constant objects?</a></h3><a href="/task/const-object" target="_blank"></a>

importance: 5

Is it possible to change an object declared with <code>const</code>, how do you think?

    <code>const user = {
  name: &quot;John&quot;
};
// does it work?
user.name = &quot;Pete&quot;;</code>
  <button type="button">solution</button>

Sure, it works, no problem.

The <code>const</code> only protects the variable itself from changing.

In other words, <code>user</code> stores a reference to the object. 
And it can’t be changed. 
But the content of the object can.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>const user = {
  name: &quot;John&quot;
};
// works
user.name = &quot;Pete&quot;;
// error
user = 123;</code>
  <button type="button" title="close"></button>

<h3><a href="#sum-object-properties" name="sum-object-properties">Sum object properties</a></h3><a href="/task/sum-object" target="_blank"></a>

importance: 5

We have an object storing salaries of our team:

    <code>let salaries = {
  John: 100,
  Ann: 160,
  Pete: 130
}</code>
  Write the code to sum all salaries and store in the variable <code>sum</code>. 
Should be <code>390</code> in the example above.

If <code>salaries</code> is empty, then the result must be <code>0</code>.

<button type="button">solution</button>

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let salaries = {
  John: 100,
  Ann: 160,
  Pete: 130
};
let sum = 0;
for (let key in salaries) {
  sum += salaries[key];
}
alert(sum); // 390</code>
  <button type="button" title="close"></button>

<h3><a href="#multiply-numeric-properties-by-2" name="multiply-numeric-properties-by-2">Multiply numeric properties by 2</a></h3><a href="/task/multiply-numeric" target="_blank"></a>

importance: 3

Create a function <code>multiplyNumeric(obj)</code> that multiplies all numeric properties of <code>obj</code> by <code>2</code>.

For instance:

    <code>// before the call
let menu = {
  width: 200,
  height: 300,
  title: &quot;My menu&quot;
};
multiplyNumeric(menu);
// after the call
menu = {
  width: 400,
  height: 600,
  title: &quot;My menu&quot;
};</code>
  Please note that <code>multiplyNumeric</code> does not need to return anything. 
It should modify the object in-place.

P.S. 
Use <code>typeof</code> to check for a number here.

<a href="http://plnkr.co/edit/yGyyV03DPTdiVFdw82gL?p=preview" target="_blank" data-plunk-id="yGyyV03DPTdiVFdw82gL">Open the sandbox with tests.</a>
<button type="button">solution</button>

<a href="http://plnkr.co/edit/v2QHwvKlIWHz35XMb8HA?p=preview" target="_blank" data-plunk-id="v2QHwvKlIWHz35XMb8HA">Open the solution with tests in the sandbox.</a>
<button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/object-basics" data-tooltip="Objects: the basics">Previous lesson</a><a href="/garbage-collection" data-tooltip="Garbage collection">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Fobject"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Fobject"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Fobject"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Fobject"></a>

Memory management in JavaScript is performed automatically and invisibly to us. 
We create primitives, objects, functions… All that takes memory.

What happens when something is not needed any more? How does the JavaScript engine discover it and clean it up?

<h2>Reachability</h2>
The main concept of memory management in JavaScript is <em>reachability</em>.

Simply put, “reachable” values are those that are accessible or usable somehow. 
They are guaranteed to be stored in memory.

<li>There’s a base set of inherently reachable values, that cannot be deleted for obvious reasons.

For instance:

<li>Local variables and parameters of the current function.</li><li>Variables and parameters for other functions on the current chain of nested calls.</li><li>Global variables.</li><li>(there are some other, internal ones as well)</li>

These values are called <em>roots</em>.

</li><li>Any other value is considered reachable if it’s reachable from a root by a reference or by a chain of references.

For instance, if there’s an object in a local variable, and that object has a property referencing another object, that object is considered reachable. 
And those that it references are also reachable. 
Detailed examples to follow.

</li>

There’s a background process in the JavaScript engine that is called <a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">garbage collector</a>. 
It monitors all objects and removes those that have become unreachable.

<h2>A simple example</h2>
Here’s the simplest example:

    <code>// user has a reference to the object
let user = {
  name: &quot;John&quot;
};</code>
  

<img src="https://javascript.info/article/garbage-collection/memory-user-john.png">
Here the arrow depicts an object reference. 
The global variable <code>&quot;user&quot;</code> references the object <code>{name: &quot;John&quot;}</code> (we’ll call it John for brevity). 
The <code>&quot;name&quot;</code> property of John stores a primitive, so it’s painted inside the object.

If the value of <code>user</code> is overwritten, the reference is lost:

    <code>user = null;</code>
  

<img src="https://javascript.info/article/garbage-collection/memory-user-john-lost.png">
Now John becomes unreachable. 
There’s no way to access it, no references to it. 
Garbage collector will junk the data and free the memory.

<h2>Two references</h2>
Now let’s imagine we copied the reference from <code>user</code> to <code>admin</code>:

    <code>// user has a reference to the object
let user = {
  name: &quot;John&quot;
};
let admin = user;</code>
  

<img src="https://javascript.info/article/garbage-collection/memory-user-john-admin.png">
Now if we do the same:

    <code>user = null;</code>
  …Then the object is still reachable via <code>admin</code> global variable, so it’s in memory. 
If we overwrite <code>admin</code> too, then it can be removed.

<h2>Interlinked objects</h2>
Now a more complex example. 
The family:

    <code>function marry(man, woman) {
  woman.husband = man;
  man.wife = woman;
  return {
    father: man,
    mother: woman
  }
}
let family = marry({
  name: &quot;John&quot;
}, {
  name: &quot;Ann&quot;
});</code>
  Function <code>marry</code> “marries” two objects by giving them references to each other and returns a new object that contains them both.

The resulting memory structure:

<img src="https://javascript.info/article/garbage-collection/family.png">
As of now, all objects are reachable.

Now let’s remove two references:

    <code>delete family.father;
delete family.mother.husband;</code>
  

<img src="https://javascript.info/article/garbage-collection/family-delete-refs.png">
It’s not enough to delete only one of these two references, because all objects would still be reachable.

But if we delete both, then we can see that John has no incoming reference any more:

<img src="https://javascript.info/article/garbage-collection/family-no-father.png">
Outgoing references do not matter. 
Only incoming ones can make an object reachable. 
So, John is now unreachable and will be removed from the memory with all its data that also became unaccessible.

After garbage collection:

<img src="https://javascript.info/article/garbage-collection/family-no-father-2.png">
<h2>Unreachable island</h2>
It is possible that the whole island of interlinked objects becomes unreachable and is removed from the memory.

The source object is the same as above. 
Then:

    <code>family = null;</code>
  The in-memory picture becomes:

<img src="https://javascript.info/article/garbage-collection/family-no-family.png">
This example demonstrates how important the concept of reachability is.

It’s obvious that John and Ann are still linked, both have incoming references. 
But that’s not enough.

The former <code>&quot;family&quot;</code> object has been unlinked from the root, there’s no reference to it any more, so the whole island becomes unreachable and will be removed.

<h2>Internal algorithms</h2>
The basic garbage collection algorithm is called “mark-and-sweep”.

The following “garbage collection” steps are regularly performed:

<li>The garbage collector takes roots and “marks” (remembers) them.</li><li>Then it visits and “marks” all references from them.</li><li>Then it visits marked objects and marks <em>their</em> references. 
All visited objects are remembered, so as not to visit the same object twice in the future.</li><li>…And so on until there are unvisited references (reachable from the roots).</li><li>All objects except marked ones are removed.</li>

For instance, let our object structure look like this:

<img src="https://javascript.info/article/garbage-collection/garbage-collection-1.png">
We can clearly see an “unreachable island” to the right side. 
Now let’s see how “mark-and-sweep” garbage collector deals with it.

The first step marks the roots:

<img src="https://javascript.info/article/garbage-collection/garbage-collection-2.png">
Then their references are marked:

<img src="https://javascript.info/article/garbage-collection/garbage-collection-3.png">
…And their references, while possible:

<img src="https://javascript.info/article/garbage-collection/garbage-collection-4.png">
Now the objects that could not be visited in the process are considered unreachable and will be removed:

<img src="https://javascript.info/article/garbage-collection/garbage-collection-5.png">
That’s the concept of how garbage collection works.

JavaScript engines apply many optimizations to make it run faster and not affect the execution.

Some of the optimizations:

<li><strong>Generational collection</strong> – objects are split into two sets: “new ones” and “old ones”. 
Many  objects appear, do their job and die fast, they can be cleaned up aggressively. 
Those that survive for long enough, become “old” and are examined less often.</li><li><strong>Incremental collection</strong> – if there are many objects, and we try to walk and mark the whole object set at once, it may take some time and introduce visible delays in the execution. 
So the engine tries to split the garbage collection into pieces. 
Then the pieces are executed one by one, separately. 
That requires some extra bookkeeping between them to track changes, but we have many tiny delays instead of a big one.</li><li><strong>Idle-time collection</strong> – the garbage collector tries to run only while the CPU is idle, to reduce the possible effect on the execution.</li>

There are other optimizations and flavours of garbage collection algorithms. 
As much as I’d like to describe them here, I have to hold off, because different engines implement different tweaks and techniques. 
And, what’s even more important, things change as engines develop, so going deeper “in advance”, without a real need is probably not worth that. 
Unless, of course, it is a matter of pure interest, then there will be some links for you below.

<h4><a name="summary" href="#summary">Summary</a4</h2>
The main things to know:

<li>Garbage collection is performed automatically. 
We cannot force or prevent it.</li><li>Objects are retained in memory while they are reachable.</li><li>Being referenced is not the same as being reachable (from a root): a pack of interlinked objects can become unreachable as a whole.</li>

Modern engines implement advanced algorithms of garbage collection.

A general book “The Garbage Collection Handbook: The Art of Automatic Memory Management” (R. 
Jones et al) covers some of them.

If you are familiar with low-level programming, the more detailed information about V8 garbage collector is in the article <a href="http://jayconrod.com/posts/55/a-tour-of-v8-garbage-collection">A tour of V8: Garbage Collection</a>.

<a href="http://v8project.blogspot.com/">V8 blog</a> also publishes articles about changes in memory management from time to time. 
Naturally, to learn the garbage collection, you’d better prepare by learning about V8 internals in general and read the blog of <a href="http://mrale.ph">Vyacheslav Egorov</a> who worked as one of V8 engineers. 
I’m saying: “V8”, because it is best covered with articles in the internet. 
For other engines, many approaches are similar, but garbage collection differs in many aspects.

In-depth knowledge of engines is good when you need low-level optimizations. 
It would be wise to plan that as the next step after you’re familiar with the language.

By specification, object property keys may be either of string type, or of symbol type. 
Not numbers, not booleans, only strings or symbols, these two types.

Till now we’ve only seen strings. 
Now let’s see the advantages that symbols can give us.

<h2>Symbols</h2>
“Symbol” value represents a unique identifier.

A value of this type can be created using <code>Symbol()</code>:

    <code>// id is a new symbol
let id = Symbol();</code>
  We can also give symbol a description (also called a symbol name), mostly useful for debugging purposes:

    <code>// id is a symbol with the description &quot;id&quot;
let id = Symbol(&quot;id&quot;);</code>
  Symbols are guaranteed to be unique. 
Even if we create many symbols with the same description, they are different values. 
The description is just a label that doesn’t affect anything.

For instance, here are two symbols with the same description – they are not equal:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let id1 = Symbol(&quot;id&quot;);
let id2 = Symbol(&quot;id&quot;);
alert(id1 == id2); // false</code>
  If you are familiar with Ruby or another language that also has some sort of “symbols” – please don’t be misguided. 
JavaScript symbols are different.

Symbols don’t auto-convert to a string
Most values in JavaScript support implicit conversion to a string. 
For instance, we can <code>alert</code> almost any value, and it will work. 
Symbols are special. 
They don’t auto-convert.

For instance, this <code>alert</code> will show an error:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let id = Symbol(&quot;id&quot;);
alert(id); // TypeError: Cannot convert a Symbol value to a string</code>
  If we really want to show a symbol, we need to call <code>.toString()</code> on it, like here:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let id = Symbol(&quot;id&quot;);
alert(id.toString()); // Symbol(id), now it works</code>
  That’s a “language guard” against messing up, because strings and symbols are fundamentally different and should not occasionally convert one into another.

<h2>“Hidden” properties</h2>
Symbols allow us to create “hidden” properties of an object, that no other part of code can occasionally access or overwrite.

For instance, if we want to store an “identifier” for the object <code>user</code>, we can use a symbol as a key for it:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = { name: &quot;John&quot; };
let id = Symbol(&quot;id&quot;);
user[id] = &quot;ID Value&quot;;
alert( user[id] ); // we can access the data using the symbol as the key</code>
  What’s the benefit over using <code>Symbol(&quot;id&quot;)</code> over a string <code>&quot;id&quot;</code>?

Let’s make the example a bit deeper to see that.

Imagine that another script wants to have its own “id” property inside <code>user</code>, for its own purposes. 
That may be another JavaScript library, so the scripts are completely unaware of each other.

Then that script can create its own <code>Symbol(&quot;id&quot;)</code>, like this:

    <code>// ...
let id = Symbol(&quot;id&quot;);
user[id] = &quot;Their id value&quot;;</code>
  There will be no conflict, because symbols are always different, even if they have the same name.

Now note that if we used a string <code>&quot;id&quot;</code> instead of a symbol for the same purpose, then there <em>would</em> be a conflict:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = { name: &quot;John&quot; };
// our script uses &quot;id&quot; property
user.id = &quot;ID Value&quot;;
// ...if later another script the uses &quot;id&quot; for its purposes...
user.id = &quot;Their id value&quot;
// boom! overwritten! it did not mean to harm the colleague, but did it!</code>
  <h3><a name="symbols-in-a-literal" href="#symbols-in-a-literal">Symbols in a literal</a></h3>
If we want to use a symbol in an object literal, we need square brackets.

Like this:

    <code>let id = Symbol(&quot;id&quot;);
let user = {
  name: &quot;John&quot;,
  [id]: 123 // not just &quot;id: 123&quot;
};</code>
  That’s because we need the value from the variable <code>id</code> as the key, not the string “id”.

<h3><a name="symbols-are-skipped-by-for-in" href="#symbols-are-skipped-by-for-in">Symbols are skipped by for…in</a></h3>
Symbolic properties do not participate in <code>for..in</code> loop.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let id = Symbol(&quot;id&quot;);
let user = {
  name: &quot;John&quot;,
  age: 30,
  [id]: 123
};
for (let key in user) alert(key); // name, age (no symbols)
// the direct access by the symbol works
alert( &quot;Direct: &quot; + user[id] );</code>
  That’s a part of the general “hiding” concept. 
If another script or a library loops over our object, it won’t unexpectedly access a symbolic property.

In contrast, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign</a> copies both string and symbol properties:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let id = Symbol(&quot;id&quot;);
let user = {
  [id]: 123
};
let clone = Object.assign({}, user);
alert( clone[id] ); // 123</code>
  There’s no paradox here. 
That’s by design. 
The idea is that when we clone an object or merge objects, we usually want <em>all</em> properties to be copied (including symbols like <code>id</code>).

Property keys of other types are coerced to strings
We can only use strings or symbols as keys in objects. 
Other types are converted to strings.

For instance, a number <code>0</code> becomes a string <code>&quot;0&quot;</code> when used as a property key:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let obj = {
  0: &quot;test&quot; // same as &quot;0&quot;: &quot;test&quot;
};
// both alerts access the same property (the number 0 is converted to string &quot;0&quot;)
alert( obj[&quot;0&quot;] ); // test
alert( obj[0] ); // test (same property)</code>
  
<h2>Global symbols</h2>
As we’ve seen, usually all symbols are different, even if they have the same names. 
But sometimes we want same-named symbols to be same entities.

For instance, different parts of our application want to access symbol <code>&quot;id&quot;</code> meaning exactly the same property.

To achieve that, there exists a <em>global symbol registry</em>. 
We can create symbols in it and access them later, and it guarantees that repeated accesses by the same name return exactly the same symbol.

In order to create or read a symbol in the registry, use <code>Symbol.for(key)</code>.

That call checks the global registry, and if there’s a symbol described as <code>key</code>, then returns it, otherwise creates a new symbol <code>Symbol(key)</code> and stores it in the registry by the given <code>key</code>.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// read from the global registry
let id = Symbol.for(&quot;id&quot;); // if the symbol did not exist, it is created
// read it again
let idAgain = Symbol.for(&quot;id&quot;);
// the same symbol
alert( id === idAgain ); // true</code>
  Symbols inside the registry are called <em>global symbols</em>. 
If we want an application-wide symbol, accessible everywhere in the code – that’s what they are for.

That sounds like Ruby
In some programming languages, like Ruby, there’s a single symbol per name.

In JavaScript, as we can see, that’s right for global symbols.

<h3><a name="symbol-keyfor" href="#symbol-keyfor">Symbol.keyFor</a></h3>
For global symbols, not only <code>Symbol.for(key)</code> returns a symbol by name, but there’s a reverse call: <code>Symbol.keyFor(sym)</code>, that does the reverse: returns a name by a global symbol.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let sym = Symbol.for(&quot;name&quot;);
let sym2 = Symbol.for(&quot;id&quot;);
// get name from symbol
alert( Symbol.keyFor(sym) ); // name
alert( Symbol.keyFor(sym2) ); // id</code>
  The <code>Symbol.keyFor</code> internally uses the global symbol registry to look up the key for the symbol. 
So it doesn’t work for non-global symbols. 
If the symbol is not global, it won’t be able to find it and return <code>undefined</code>.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( Symbol.keyFor(Symbol.for(&quot;name&quot;)) ); // name, global symbol
alert( Symbol.keyFor(Symbol(&quot;name2&quot;)) ); // undefined, the argument isn't a global symbol</code>
  <h2>System symbols</h2>
There exist many “system” symbols that JavaScript uses internally, and we can use them to fine-tune various aspects of our objects.

They are listed in the specification in the <a href="https://tc39.github.io/ecma262/#sec-well-known-symbols">Well-known symbols</a> table:

<li><code>Symbol.hasInstance</code></li><li><code>Symbol.isConcatSpreadable</code></li><li><code>Symbol.iterator</code></li><li><code>Symbol.toPrimitive</code></li><li>…and so on.</li>

For instance, <code>Symbol.toPrimitive</code> allows us to describe object to primitive conversion. 
We’ll see its use very soon.

Other symbols will also become familiar when we study the corresponding language features.

<h4><a name="summary" href="#summary">Summary</a4</h2>
<code>Symbol</code> is a primitive type for unique identifiers.

Symbols are created with <code>Symbol()</code> call with an optional description.

Symbols are always different values, even if they have the same name. 
If we want same-named symbols to be equal, then we should use the global registry: <code>Symbol.for(key)</code> returns (creates if needed) a global symbol with <code>key</code> as the name. 
Multiple calls of <code>Symbol.for</code> return exactly the same symbol.

Symbols have two main use cases:

<li>“Hidden” object properties.
If we want to add a property into an object that “belongs” to another script or a library, we can create a symbol and use it as a property key. 
A symbolic property does not appear in <code>for..in</code>, so it won’t be occasionally listed. 
Also it won’t be accessed directly, because another script does not have our symbol, so it will not occasionally intervene into its actions.

So we can “covertly” hide something into objects that we need, but others should not see, using symbolic properties.

</li><li>There are many system symbols used by JavaScript which are accessible as <code>Symbol.*</code>. 
We can use them to alter some built-in behaviors. 
For instance, later in the tutorial we’ll use <code>Symbol.iterator</code> for <a href="/iterable">iterables</a>, <code>Symbol.toPrimitive</code> to setup <a href="/object-toprimitive">object-to-primitive conversion</a> and so on.

</li>

Technically, symbols are not 100% hidden. 
There is a built-in method <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols">Object.getOwnPropertySymbols(obj)</a> that allows us to get all symbols. 
Also there is a method named <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys">Reflect.ownKeys(obj)</a> that returns <em>all</em> keys of an object including symbolic ones. 
So they are not really hidden. 
But most libraries, built-in methods and syntax constructs adhere to a common agreement that they are. 
And the one who explicitly calls the aforementioned methods probably understands well what he’s doing.

Objects are usually created to represent entities of the real world, like users, orders and so on:

    <code>let user = {
  name: &quot;John&quot;,
  age: 30
};</code>
  And, in the real world, a user can <em>act</em>: select something from the shopping cart, login, logout etc.

Actions are represented in JavaScript by functions in properties.

<h2>Method examples</h2>
For the start, let’s teach the <code>user</code> to say hello:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  name: &quot;John&quot;,
  age: 30
};
user.sayHi = function() {
  alert(&quot;Hello!&quot;);
};
user.sayHi(); // Hello!</code>
  Here we’ve just used a Function Expression to create the function and assign it to the property <code>user.sayHi</code> of the object.

Then we can call it. 
The user can now speak!

A function that is the property of an object is called its <em>method</em>.

So, here we’ve got a method <code>sayHi</code> of the object <code>user</code>.

Of course, we could use a pre-declared function as a method, like this:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  // ...
};
// first, declare
function sayHi() {
  alert(&quot;Hello!&quot;);
};
// then add as a method
user.sayHi = sayHi;
user.sayHi(); // Hello!</code>
  
Object-oriented programming
When we write our code using objects to represent entities, that’s called an <a href="https://en.wikipedia.org/wiki/Object-oriented_programming">object-oriented programming</a>, in short: “OOP”.

OOP is a big thing, an interesting science of its own. 
How to choose the right entities? How to organize the interaction between them? That’s architecture, and there are great books on that topic, like “Design Patterns: Elements of Reusable Object-Oriented Software” by E.Gamma, R.Helm, R.Johnson, J.Vissides or “Object-Oriented Analysis and Design with Applications” by G.Booch, and more. 
We’ll scratch the surface of that topic later in the chapter <a href="/object-oriented-programming">Objects, classes, inheritance</a>.

<h3><a name="method-shorthand" href="#method-shorthand">Method shorthand</a></h3>
There exists a shorter syntax for methods in an object literal:

    <code>// these objects do the same
let user = {
  sayHi: function() {
    alert(&quot;Hello&quot;);
  }
};
// method shorthand looks better, right?
let user = {
  sayHi() { // same as &quot;sayHi: function()&quot;
    alert(&quot;Hello&quot;);
  }
};</code>
  As demonstrated, we can omit <code>&quot;function&quot;</code> and just write <code>sayHi()</code>.

To tell the truth, the notations are not fully identical. 
There are subtle differences related to object inheritance (to be covered later), but for now they do not matter. 
In almost all cases the shorter syntax is preferred.

<h2>“this” in methods</h2>
It’s common that an object method needs to access the information stored in the object to do its job.

For instance, the code inside <code>user.sayHi()</code> may need the name of the <code>user</code>.

<strong>To access the object, a method can use the <code>this</code> keyword.</strong>

The value of <code>this</code> is the object “before dot”, the one used to call the method.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  name: &quot;John&quot;,
  age: 30,
  sayHi() {
    alert(this.name);
  }
};
user.sayHi(); // John</code>
  Here during the execution of <code>user.sayHi()</code>, the value of <code>this</code> will be <code>user</code>.

Technically, it’s also possible to access the object without <code>this</code>, by referencing it via the outer variable:

    <code>let user = {
  name: &quot;John&quot;,
  age: 30,
  sayHi() {
    alert(user.name); // &quot;user&quot; instead of &quot;this&quot;
  }
};</code>
  …But such code is unreliable. 
If we decide to copy <code>user</code> to another variable, e.g. 
<code>admin = user</code> and overwrite <code>user</code> with something else, then it will access the wrong object.

That’s demonstrated below:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  name: &quot;John&quot;,
  age: 30,
  sayHi() {
    alert( user.name ); // leads to an error
  }
};
let admin = user;
user = null; // overwrite to make things obvious
admin.sayHi(); // Whoops! inside sayHi(), the old name is used! error!</code>
  If we used <code>this.name</code> instead of <code>user.name</code> inside the <code>alert</code>, then the code would work.

<h2>“this” is not bound</h2>
In JavaScript, “this” keyword behaves unlike most other programming languages. 
First, it can be used in any function.

There’s no syntax error in the code like that:

    <code>function sayHi() {
  alert( this.name );
}</code>
  The value of <code>this</code> is evaluated during the run-time. 
And it can be anything.

For instance, the same function may have different “this” when called from different objects:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = { name: &quot;John&quot; };
let admin = { name: &quot;Admin&quot; };
function sayHi() {
  alert( this.name );
}
// use the same functions in two objects
user.f = sayHi;
admin.f = sayHi;
// these calls have different this
// &quot;this&quot; inside the function is the object &quot;before the dot&quot;
user.f(); // John  (this == user)
admin.f(); // Admin  (this == admin)
admin['f'](); // Admin (dot or square brackets access the method – doesn't matter)</code>
  Actually, we can call the function without an object at all:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function sayHi() {
  alert(this);
}
sayHi(); // undefined</code>
  In this case <code>this</code> is <code>undefined</code> in strict mode. 
If we try to access <code>this.name</code>, there will be an error.

In non-strict mode (if one forgets <code>use strict</code>) the value of <code>this</code> in such case will be the <em>global object</em> (<code>window</code> in a browser, we’ll get to it later). 
This is a historical behavior that <code>&quot;use strict&quot;</code> fixes.

Please note that usually a call of a function that uses <code>this</code> without an object is not normal, but rather a programming mistake. 
If a function has <code>this</code>, then it is usually meant to be called in the context of an object.

The consequences of unbound <code>this</code>
If you come from another programming language, then you are probably used to the idea of a &quot;bound <code>this</code>&quot;, where methods defined in an object always have <code>this</code> referencing that object.

In JavaScript <code>this</code> is “free”, its value is evaluated at call-time and does not depend on where the method was declared, but rather on what’s the object “before the dot”.

The concept of run-time evaluated <code>this</code> has both pluses and minuses. 
On the one hand, a function can be reused for different objects. 
On the other hand, greater flexibility opens a place for mistakes.

Here our position is not to judge whether this language design decision is good or bad. 
We’ll understand how to work with it, how to get benefits and evade problems.

<h2>Internals: Reference Type</h2>

In-depth language feature
This section covers an advanced topic, to understand certain edge-cases better.

If you want to go on faster, it can be skipped or postponed.

An intricate method call can lose <code>this</code>, for instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  name: &quot;John&quot;,
  hi() { alert(this.name); },
  bye() { alert(&quot;Bye&quot;); }
};
user.hi(); // John (the simple call works)
// now let's call user.hi or user.bye depending on the name
(user.name == &quot;John&quot; ? user.hi : user.bye)(); // Error!</code>
  On the last line there is a ternary operator that chooses either <code>user.hi</code> or <code>user.bye</code>. 
In this case the result is <code>user.hi</code>.

The method is immediately called with parentheses <code>()</code>. 
But it doesn’t work right!

You can see that the call results in an error, cause the value of <code>&quot;this&quot;</code> inside the call becomes <code>undefined</code>.

This works (object dot method):

    <code>user.hi();</code>
  This doesn’t (evaluated method):

    <code>(user.name == &quot;John&quot; ? user.hi : user.bye)(); // Error!</code>
  Why? If we want to understand why it happens, let’s get under the hood of how <code>obj.method()</code> call works.

Looking closely, we may notice two operations in <code>obj.method()</code> statement:

<li>First, the dot <code>'.'</code> retrieves the property <code>obj.method</code>.</li><li>Then parentheses <code>()</code> execute it.</li>

So, how does the information about <code>this</code> gets passed from the first part to the second one?

If we put these operations on separate lines, then <code>this</code> will be lost for sure:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  name: &quot;John&quot;,
  hi() { alert(this.name); }
}
// split getting and calling the method in two lines
let hi = user.hi;
hi(); // Error, because this is undefined</code>
  Here <code>hi = user.hi</code> puts the function into the variable, and then on the last line it is completely standalone, and so there’s no <code>this</code>.

<strong>To make <code>user.hi()</code> calls work, JavaScript uses a trick – the dot <code>'.'</code> returns not a function, but a value of the special <a href="https://tc39.github.io/ecma262/#sec-reference-specification-type">Reference Type</a>.</strong>

The Reference Type is a “specification type”. 
We can’t explicitly use it, but it is used internally by the language.

The value of Reference Type is a three-value combination <code>(base, name, strict)</code>, where:

<li><code>base</code> is the object.</li><li><code>name</code> is the property.</li><li><code>strict</code> is true if <code>use strict</code> is in effect.</li>

The result of a property access <code>user.hi</code> is not a function, but a value of Reference Type. 
For <code>user.hi</code> in strict mode it is:

    <code>// Reference Type value
(user, &quot;hi&quot;, true)</code>
  When parentheses <code>()</code> are called on the Reference Type, they receive the full information about the object and it’s method, and can set the right <code>this</code> (<code>=user</code> in this case).

Any other operation like assignment <code>hi = user.hi</code> discards the reference type as a whole, takes the value of <code>user.hi</code> (a function) and passes it on. 
So any further operation “loses” <code>this</code>.

So, as the result, the value of <code>this</code> is only passed the right way if the function is called directly using a dot <code>obj.method()</code> or square brackets <code>obj[method]()</code> syntax (they do the same here).

<h2>Arrow functions have no “this”</h2>
Arrow functions are special: they don’t have their “own” <code>this</code>. 
If we reference <code>this</code> from such a function, it’s taken from the outer “normal” function.

For instance, here <code>arrow()</code> uses <code>this</code> from the outer <code>user.sayHi()</code> method:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  firstName: &quot;Ilya&quot;,
  sayHi() {
    let arrow = () =&gt; alert(this.firstName);
    arrow();
  }
};
user.sayHi(); // Ilya</code>
  That’s a special feature of arrow functions, it’s useful when we actually do not want to have a separate <code>this</code>, but rather to take it from the outer context. 
Later in the chapter <a href="/arrow-functions">Arrow functions revisited</a> we’ll go more deeply into arrow functions.

<h4><a name="summary" href="#summary">Summary</a></h4><li>Functions that are stored in object properties are called “methods”.</li><li>Methods allow objects to “act” like <code>object.doSomething()</code>.</li><li>Methods can reference the object as <code>this</code>.</li>

The value of <code>this</code> is defined at run-time.

<li>When a function is declared, it may use <code>this</code>, but that <code>this</code> has no value until the function is called.</li><li>That function can be copied between objects.</li><li>When a function is called in the “method” syntax: <code>object.method()</code>, the value of <code>this</code> during the call is <code>object</code>.</li>

Please note that arrow functions are special: they have no <code>this</code>. 
When <code>this</code> is accessed inside an arrow function, it is taken from outside.

    <code>let user = {
  name: &quot;John&quot;,
  go: function() { alert(this.name) }
}
(user.go)()</code>
  P.S. 
There’s a pitfall :)

<button type="button">solution</button>

<strong>Error</strong>!

Try it:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  name: &quot;John&quot;,
  go: function() { alert(this.name) }
}
(user.go)() // error!</code>
  The error message in most browsers does not give understanding what went wrong.

<strong>The error appears because a semicolon is missing after <code>user = {...}</code>.</strong>

JavaScript does not assume a semicolon before a bracket <code>(user.go)()</code>, so it reads the code like:

    <code>let user = { go:... 
}(user.go)()</code>
  Then we can also see that such a joint expression is syntactically a call of the object <code>{ go: ... 
}</code> as a function with the argument <code>(user.go)</code>. 
And that also happens on the same line with <code>let user</code>, so the <code>user</code> object has not yet even been defined, hence the error.

If we insert the semicolon, all is fine:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  name: &quot;John&quot;,
  go: function() { alert(this.name) }
};
(user.go)() // John</code>
  Please note that brackets around <code>(user.go)</code> do nothing here. 
Usually they setup the order of operations, but here the dot <code>.</code> works first anyway, so there’s no effect. 
Only the semicolon thing matters.

<button type="button" title="close"></button>

<h3><a href="#explain-the-value-of-this" name="explain-the-value-of-this">Explain the value of &quot;this&quot;</a></h3><a href="/task/why-this" target="_blank"></a>

importance: 3

In the code below we intend to call <code>user.go()</code> method 4 times in a row.

But calls <code>(1)</code> and <code>(2)</code> works differently from <code>(3)</code> and <code>(4)</code>. 
Why?

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let obj, method;
obj = {
  go: function() { alert(this); }
};
obj.go();               // (1) [object Object]
(obj.go)();             // (2) [object Object]
(method = obj.go)();    // (3) undefined
(obj.go || obj.stop)(); // (4) undefined</code>
  <button type="button">solution</button>

Here’s the explanations.

<li>That’s a regular object method call.

</li><li>The same, brackets do not change the order of operations here, the dot is first anyway.

</li><li>Here we have a more complex call <code>(expression).method()</code>. 
The call works as if it were split into two lines:

    <code>f = obj.go; // calculate the expression
f();        // call what we have</code>
  Here <code>f()</code> is executed as a function, without <code>this</code>.

</li><li>The similar thing as <code>(3)</code>, to the left of the dot <code>.</code> we have an expression.

</li>

To explain the behavior of <code>(3)</code> and <code>(4)</code> we need to recall that property accessors (dot or square brackets) return a value of the Reference Type.

Any operation on it except a method call (like assignment <code>=</code> or <code>||</code>) turns it into an ordinary value, which does not carry the information allowing to set <code>this</code>.

<button type="button" title="close"></button>

<h3><a href="#using-this-in-object-literal" name="using-this-in-object-literal">Using &quot;this&quot; in object literal</a></h3><a href="/task/object-property-this" target="_blank"></a>

importance: 5

Here the function <code>makeUser</code> returns an object.

What is the result of accessing its <code>ref</code>? Why?

    <code>function makeUser() {
  return {
    name: &quot;John&quot;,
    ref: this
  };
};
let user = makeUser();
alert( user.ref.name ); // What's the result?</code>
  <button type="button">solution</button>

<strong>Answer: an error.</strong>

Try it:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function makeUser() {
  return {
    name: &quot;John&quot;,
    ref: this
  };
};
let user = makeUser();
alert( user.ref.name ); // Error: Cannot read property 'name' of undefined</code>
  That’s because rules that set <code>this</code> do not look at object literals.

Here the value of <code>this</code> inside <code>makeUser()</code> is <code>undefined</code>, because it is called as a function, not as a method.

And the object literal itself has no effect on <code>this</code>. 
The value of <code>this</code> is one for the whole function, code blocks and object literals do not affect it.

So <code>ref: this</code> actually takes current <code>this</code> of the function.

Here’s the opposite case:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function makeUser() {
  return {
    name: &quot;John&quot;,
    ref() {
return this;
    }
  };
};
let user = makeUser();
alert( user.ref().name ); // John</code>
  Now it works, because <code>user.ref()</code> is a method. 
And the value of <code>this</code> is set to the object before dot <code>.</code>.

<button type="button" title="close"></button>

<h3><a href="#create-a-calculator" name="create-a-calculator">Create a calculator</a></h3><a href="/task/calculator" target="_blank"></a>

importance: 5

Create an object <code>calculator</code> with three methods:

<li><code>read()</code> prompts for two values and saves them as object properties.</li><li><code>sum()</code> returns the sum of saved values.</li><li><code>mul()</code> multiplies saved values and returns the result.</li>

    <code>let calculator = {
  // ... 
your code ...
};
calculator.read();
alert( calculator.sum() );
alert( calculator.mul() );</code>
  <a href="#" onclick="event.preventDefault(); runDemo(this)">Run the demo</a>

<a href="http://plnkr.co/edit/H7av4KoTaAlB1T8nNpQ2?p=preview" target="_blank" data-plunk-id="H7av4KoTaAlB1T8nNpQ2">Open the sandbox with tests.</a>
<button type="button">solution</button>

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let calculator = {
  sum() {
    return this.a + this.b;
  },
  mul() {
    return this.a * this.b;
  },
  read() {
    this.a = +prompt('a?', 0);
    this.b = +prompt('b?', 0);
  }
};
calculator.read();
alert( calculator.sum() );
alert( calculator.mul() );</code>
  <a href="http://plnkr.co/edit/lxBVlCgNJehVJljHrnGR?p=preview" target="_blank" data-plunk-id="lxBVlCgNJehVJljHrnGR">Open the solution with tests in the sandbox.</a>
<button type="button" title="close"></button>

<h3><a href="#chaining" name="chaining">Chaining</a></h3><a href="/task/chain-calls" target="_blank"></a>

importance: 2

There’s a <code>ladder</code> object that allows to go up and down:

    <code>let ladder = {
  step: 0,
  up() {
    this.step++;
  },
  down() {
    this.step--;
  },
  showStep: function() { // shows the current step
    alert( this.step );
  }
};</code>
  Now, if we need to make several calls in sequence, can do it like this:

    <code>ladder.up();
ladder.up();
ladder.down();
ladder.showStep(); // 1</code>
  Modify the code of <code>up</code> and <code>down</code> to make the calls chainable, like this:

    <code>ladder.up().up().down().showStep(); // 1</code>
  Such approach is widely used across JavaScript libraries.

<a href="http://plnkr.co/edit/Sgw2uBVHOq9bza8ijp2k?p=preview" target="_blank" data-plunk-id="Sgw2uBVHOq9bza8ijp2k">Open the sandbox with tests.</a>
<button type="button">solution</button>

The solution is to return the object itself from every call.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let ladder = {
  step: 0,
  up() {
    this.step++;
    return this;
  },
  down() {
    this.step--;
    return this;
  },
  showStep() {
    alert( this.step );
    return this;
  }
}
ladder.up().up().down().up().down().showStep(); // 1</code>
  We also can write a single call per line. 
For long chains it’s more readable:

    <code>ladder
  .up()
  .up()
  .down()
  .up()
  .down()
  .showStep(); // 1</code>
  <a href="http://plnkr.co/edit/MUE9KTILdKfBhjGJ2lCI?p=preview" target="_blank" data-plunk-id="MUE9KTILdKfBhjGJ2lCI">Open the solution with tests in the sandbox.</a>
<button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/symbol" data-tooltip="Symbol type">Previous lesson</a><a href="/object-toprimitive" data-tooltip="Object to primitive conversion">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Fobject-methods"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Fobject-methods"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Fobject-methods"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Fobject-methods"></a>

What happens when objects are added <code>obj1 + obj2</code>, subtracted <code>obj1 - obj2</code> or printed using <code>alert(obj)</code>?

There are special methods in objects that do the conversion.

In the chapter <a href="/type-conversions">Type Conversions</a> we’ve seen the rules for numeric, string and boolean conversions of primitives. 
But we left a gap for objects. 
Now, as we know about methods and symbols it becomes possible to close it.

For objects, there’s no to-boolean conversion, because all objects are <code>true</code> in a boolean context. 
So there are only string and numeric conversions.

The numeric conversion happens when we subtract objects or apply mathematical functions. 
For instance, <code>Date</code> objects (to be covered in the chapter <a href="/date">Date and time</a>) can be subtracted, and the result of <code>date1 - date2</code> is the time difference between two dates.

As for the string conversion – it usually happens when we output an object like <code>alert(obj)</code> and in similar contexts.

<h2>ToPrimitive</h2>
When an object is used in the context where a primitive is required, for instance, in an <code>alert</code> or mathematical operations, it’s converted to a primitive value using the <code>ToPrimitive</code> algorithm (<a href="https://tc39.github.io/ecma262/#sec-toprimitive">specification</a>).

That algorithm allows us to customize the conversion using a special object method.

Depending on the context, the conversion has a so-called “hint”.

There are three variants:

<dl>
<dt><code>&quot;string&quot;</code></dt>
<dd>

When an operation expects a string, for object-to-string conversions, like <code>alert</code>:

    <code>// output
alert(obj);
// using object as a property key
anotherObj[obj] = 123;</code>
  </dd>
<dt><code>&quot;number&quot;</code></dt>
<dd>

When an operation expects a number, for object-to-number conversions, like maths:

    <code>// explicit conversion
let num = Number(obj);
// maths (except binary plus)
let n = +obj; // unary plus
let delta = date1 - date2;
// less/greater comparison
let greater = user1 &gt; user2;</code>
  </dd>
<dt><code>&quot;default&quot;</code></dt>
<dd>

Occurs in rare cases when the operator is “not sure” what type to expect.

For instance, binary plus <code>+</code> can work both with strings (concatenates them) and numbers (adds them), so both strings and numbers would do. 
Or when an object is compared using <code>==</code> with a string, number or a symbol.

    <code>// binary plus
let total = car1 + car2;
// obj == string/number/symbol
if (user == 1) { ... 
};</code>
  The greater/less operator <code>&lt;&gt;</code> can work with both strings and numbers too. 
Still, it uses “number” hint, not “default”. 
That’s for historical reasons.

In practice, all built-in objects except for one case (<code>Date</code> object, we’ll learn it later) implement <code>&quot;default&quot;</code> conversion the same way as <code>&quot;number&quot;</code>. 
And probably we should do the same.

</dd>
</dl>

Please note – there are only three hints. 
It’s that simple. 
There is no “boolean” hint (all objects are <code>true</code> in boolean context) or anything else. 
And if we treat <code>&quot;default&quot;</code> and <code>&quot;number&quot;</code> the same, like most built-ins do, then there are only two conversions.

<strong>To do the conversion, JavaScript tries to find and call three object methods:</strong>

<li>Call <code>obj[Symbol.toPrimitive](hint)</code> if the method exists,</li><li>Otherwise if hint is <code>&quot;string&quot;</code>
<li>try <code>obj.toString()</code> and <code>obj.valueOf()</code>, whatever exists.</li>

</li><li>Otherwise if hint is <code>&quot;number&quot;</code> or <code>&quot;default&quot;</code>
<li>try <code>obj.valueOf()</code> and <code>obj.toString()</code>, whatever exists.</li>

</li>

<h2>Symbol.toPrimitive</h2>
Let’s start from the first method. 
There’s a built-in symbol named <code>Symbol.toPrimitive</code> that should be used to name the conversion method, like this:

    <code>obj[Symbol.toPrimitive] = function(hint) {
  // return a primitive value
  // hint = one of &quot;string&quot;, &quot;number&quot;, &quot;default&quot;
}</code>
  For instance, here <code>user</code> object implements it:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  name: &quot;John&quot;,
  money: 1000,
  [Symbol.toPrimitive](hint) {
    alert(`hint: ${hint}`);
    return hint == &quot;string&quot; ? `{name: &quot;${this.name}&quot;}` : this.money;
  }
};
// conversions demo:
alert(user); // hint: string -&gt; {name: &quot;John&quot;}
alert(+user); // hint: number -&gt; 1000
alert(user + 500); // hint: default -&gt; 1500</code>
  As we can see from the code, <code>user</code> becomes a self-descriptive string or a money amount depending on the conversion. 
The single method <code>user[Symbol.toPrimitive]</code> handles all conversion cases.

<h2>toString/valueOf</h2>
Methods <code>toString</code> and <code>valueOf</code> come from ancient times. 
They are not symbols (symbols did not exist that long ago), but rather “regular” string-named methods. 
They provide an alternative “old-style” way to implement the conversion.

If there’s no <code>Symbol.toPrimitive</code> then JavaScript tries to find them and try in the order:

<li><code>toString -&gt; valueOf</code> for “string” hint.</li><li><code>valueOf -&gt; toString</code> otherwise.</li>

For instance, here <code>user</code> does the same as above using a combination of <code>toString</code> and <code>valueOf</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  name: &quot;John&quot;,
  money: 1000,
  // for hint=&quot;string&quot;
  toString() {
    return `{name: &quot;${this.name}&quot;}`;
  },
  // for hint=&quot;number&quot; or &quot;default&quot;
  valueOf() {
    return this.money;
  }
};
alert(user); // toString -&gt; {name: &quot;John&quot;}
alert(+user); // valueOf -&gt; 1000
alert(user + 500); // valueOf -&gt; 1500</code>
  Often we want a single “catch-all” place to handle all primitive conversions. 
In this case we can implement <code>toString</code> only, like this:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  name: &quot;John&quot;,
  toString() {
    return this.name;
  }
};
alert(user); // toString -&gt; John
alert(user + 500); // toString -&gt; John500</code>
  In the absence of <code>Symbol.toPrimitive</code> and <code>valueOf</code>, <code>toString</code> will handle all primitive conversions.

<h2>ToPrimitive and ToString/ToNumber</h2>
The important thing to know about all primitive-conversion methods is that they do not necessarily return the “hinted” primitive.

There is no control whether <code>toString()</code> returns exactly a string, or whether <code>Symbol.toPrimitive</code> method returns a number for a hint “number”.

<strong>The only mandatory thing: these methods must return a primitive.</strong>

An operation that initiated the conversion gets that primitive, and then continues to work with it, applying further conversions if necessary.

For instance:

<li>Mathematical operations (except binary plus) perform <code>ToNumber</code> conversion:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let obj = {
  toString() { // toString handles all conversions in the absence of other methods
    return &quot;2&quot;;
  }
};
alert(obj * 2); // 4, ToPrimitive gives &quot;2&quot;, then it becomes 2</code>
  </li><li>Binary plus checks the primitive – if it’s a string, then it does concatenation, otherwise it performs <code>ToNumber</code> and works with numbers.

String example:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let obj = {
  toString() {
    return &quot;2&quot;;
  }
};
alert(obj + 2); // 22 (ToPrimitive returned string =&gt; concatenation)</code>
  Number example:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let obj = {
  toString() {
    return true;
  }
};
alert(obj + 2); // 3 (ToPrimitive returned boolean, not string =&gt; ToNumber)</code>
  </li>

Historical notes
For historical reasons, methods <code>toString</code> or <code>valueOf</code> <em>should</em> return a primitive: if any of them returns an object, then there’s no error, but that object is ignored (like if the method didn’t exist).

In contrast, <code>Symbol.toPrimitive</code> <em>must</em> return a primitive, otherwise, there will be an error.

<h4><a name="summary" href="#summary">Summary</a4</h2>
The object-to-primitive conversion is called automatically by many built-in functions and operators that expect a primitive as a value.

There are 3 types (hints) of it:

<li><code>&quot;string&quot;</code> (for <code>alert</code> and other string conversions)</li><li><code>&quot;number&quot;</code> (for maths)</li><li><code>&quot;default&quot;</code> (few operators)</li>

The specification describes explicitly which operator uses which hint. 
There are very few operators that “don’t know what to expect” and use the <code>&quot;default&quot;</code> hint. 
Usually for built-in objects <code>&quot;default&quot;</code> hint is handled the same way as <code>&quot;number&quot;</code>, so in practice the last two are often merged together.

The conversion algorithm is:

<li>Call <code>obj[Symbol.toPrimitive](hint)</code> if the method exists,</li><li>Otherwise if hint is <code>&quot;string&quot;</code>
<li>try <code>obj.toString()</code> and <code>obj.valueOf()</code>, whatever exists.</li>

</li><li>Otherwise if hint is <code>&quot;number&quot;</code> or <code>&quot;default&quot;</code>
<li>try <code>obj.valueOf()</code> and <code>obj.toString()</code>, whatever exists.</li>

</li>

In practice, it’s often enough to implement only <code>obj.toString()</code> as a “catch-all” method for all conversions that return a “human-readable” representation of an object, for logging or debugging purposes.

The regular <code>{...}</code> syntax allows to create one object. 
But often we need to create many similar objects, like multiple users or menu items and so on.

That can be done using constructor functions and the <code>&quot;new&quot;</code> operator.

<h2>Constructor function</h2>
Constructor functions technically are regular functions. 
There are two conventions though:

<li>They are named with capital letter first.</li><li>They should be executed only with <code>&quot;new&quot;</code> operator.</li>

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function User(name) {
  this.name = name;
  this.isAdmin = false;
}
let user = new User(&quot;Jack&quot;);
alert(user.name); // Jack
alert(user.isAdmin); // false</code>
  When a function is executed as <code>new User(...)</code>, it does the following steps:

<li>A new empty object is created and assigned to <code>this</code>.</li><li>The function body executes. 
Usually it modifies <code>this</code>, adds new properties to it.</li><li>The value of <code>this</code> is returned.</li>

In other words, <code>new User(...)</code> does something like:

    <code>function User(name) {
  // this = {};  (implicitly)
  // add properties to this
  this.name = name;
  this.isAdmin = false;
  // return this;  (implicitly)
}</code>
  So the result of <code>new User(&quot;Jack&quot;)</code> is the same object as:

    <code>let user = {
  name: &quot;Jack&quot;,
  isAdmin: false
};</code>
  Now if we want to create other users, we can call <code>new User(&quot;Ann&quot;)</code>, <code>new User(&quot;Alice&quot;)</code> and so on. 
Much shorter than using literals every time, and also easy to read.

That’s the main purpose of constructors – to implement reusable object creation code.

Let’s note once again – technically, any function can be used as a constructor. 
That is: any function can be run with <code>new</code>, and it will execute the algorithm above. 
The “capital letter first” is a common agreement, to make it clear that a function is to be run with <code>new</code>.

new function() { … }
If we have many lines of code all about creation of a single complex object, we can wrap them in constructor function, like this:

    <code>let user = new function() {
  this.name = &quot;John&quot;;
  this.isAdmin = false;
  // ...other code for user creation
  // maybe complex logic and statements
  // local variables etc
};</code>
  The constructor can’t be called again, because it is not saved anywhere, just created and called. 
So this trick aims to encapsulate the code that constructs the single object, without future reuse.

<h2>Dual-syntax constructors: new.target</h2>
Inside a function, we can check whether it was called with <code>new</code> or without it, using a special <code>new.target</code> property.

It is empty for regular calls and equals the function if called with <code>new</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function User() {
  alert(new.target);
}
// without new:
User(); // undefined
// with new:
new User(); // function User { ... 
}</code>
  That can be used to allow both <code>new</code> and regular syntax to work the same:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function User(name) {
  if (!new.target) { // if you run me without new
    return new User(name); // ...I will add new for you
  }
  this.name = name;
}
let john = User(&quot;John&quot;); // redirects call to new User
alert(john.name); // John</code>
  This approach is sometimes used in libraries to make the syntax more flexible. 
Probably not a good thing to use everywhere though, because omitting <code>new</code> makes it a bit less obvious what’s going on. 
With <code>new</code> we all know that the new object is being created, that’s a good thing.

<h2>Return from constructors</h2>
Usually, constructors do not have a <code>return</code> statement. 
Their task is to write all necessary stuff into <code>this</code>, and it automatically becomes the result.

But if there is a <code>return</code> statement, then the rule is simple:

<li>If <code>return</code> is called with object, then it is returned instead of <code>this</code>.</li><li>If <code>return</code> is called with a primitive, it’s ignored.</li>

In other words, <code>return</code> with an object returns that object, in all other cases <code>this</code> is returned.

For instance, here <code>return</code> overrides <code>this</code> by returning an object:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function BigUser() {
  this.name = &quot;John&quot;;
  return { name: &quot;Godzilla&quot; };  // &lt;-- returns an object
}
alert( new BigUser().name );  // Godzilla, got that object ^^</code>
  And here’s an example with an empty <code>return</code> (or we could place a primitive after it, doesn’t matter):

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function SmallUser() {
  this.name = &quot;John&quot;;
  return; // finishes the execution, returns this
  // ...
}
alert( new SmallUser().name );  // John</code>
  Usually constructors don’t have a <code>return</code> statement. 
Here we mention the special behavior with returning objects mainly for the sake of completeness.

Omitting parentheses
By the way, we can omit parentheses after <code>new</code>, if it has no arguments:

    <code>let user = new User; // &lt;-- no parentheses
// same as
let user = new User();</code>
  Omitting parentheses here is not considered a “good style”, but the syntax is permitted by specification.

<h2>Methods in constructor</h2>
Using constructor functions to create objects gives a great deal of flexibility. 
The constructor function may have parameters that define how to construct the object, and what to put in it.

Of course, we can add to <code>this</code> not only properties, but methods as well.

For instance, <code>new User(name)</code> below creates an object with the given <code>name</code> and the method <code>sayHi</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function User(name) {
  this.name = name;
  this.sayHi = function() {
    alert( &quot;My name is: &quot; + this.name );
  };
}
let john = new User(&quot;John&quot;);
john.sayHi(); // My name is: John
/*
john = {
   name: &quot;John&quot;,
   sayHi: function() { ... 
}
}
*/</code>
  <h4><a name="summary" href="#summary">Summary</a></h4><li>Constructor functions or, briefly, constructors, are regular functions, but there’s a common agreement to name them with capital letter first.</li><li>Constructor functions should only be called using <code>new</code>. 
Such a call implies a creation of empty <code>this</code> at the start and returning the populated one at the end.</li>

We can use constructor functions to make multiple similar objects.

JavaScript provides constructor functions for many built-in language objects: like <code>Date</code> for dates, <code>Set</code> for sets and others that we plan to study.

Objects, we’ll be back!
In this chapter we only cover the basics about objects and constructors. 
They are essential for learning more about data types and functions in the next chapters.

After we learn that, in the chapter <a href="/object-oriented-programming">Objects, classes, inheritance</a> we return to objects and cover them in-depth, including inheritance and classes.

    <code>function A() { ... 
}
function B() { ... 
}
let a = new A;
let b = new B;
alert( a == b ); // true</code>
  If it is, then provide an example of their code.

<button type="button">solution</button>

Yes, it’s possible.

If a function returns an object then <code>new</code> returns it instead of <code>this</code>.

So thay can, for instance, return the same externally defined object <code>obj</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let obj = {};
function A() { return obj; }
function B() { return obj; }
alert( new A() == new B() ); // true</code>
  <button type="button" title="close"></button>

<h3><a href="#create-new-calculator" name="create-new-calculator">Create new Calculator</a></h3><a href="/task/calculator-constructor" target="_blank"></a>

importance: 5

Create a constructor function <code>Calculator</code> that creates objects with 3 methods:

<li><code>read()</code> asks for two values using <code>prompt</code> and remembers them in object properties.</li><li><code>sum()</code> returns the sum of these properties.</li><li><code>mul()</code> returns the multiplication product of these properties.</li>

For instance:

    <code>let calculator = new Calculator();
calculator.read();
alert( &quot;Sum=&quot; + calculator.sum() );
alert( &quot;Mul=&quot; + calculator.mul() );</code>
  <a href="#" onclick="event.preventDefault(); runDemo(this)">Run the demo</a>

<a href="http://plnkr.co/edit/vsilDmkdOZkftqI8eZIl?p=preview" target="_blank" data-plunk-id="vsilDmkdOZkftqI8eZIl">Open the sandbox with tests.</a>
<button type="button">solution</button>

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function Calculator() {
  this.read = function() {
    this.a = +prompt('a?', 0);
    this.b = +prompt('b?', 0);
  };
  this.sum = function() {
    return this.a + this.b;
  };
  this.mul = function() {
    return this.a * this.b;
  };
}
let calculator = new Calculator();
calculator.read();
alert( &quot;Sum=&quot; + calculator.sum() );
alert( &quot;Mul=&quot; + calculator.mul() );</code>
  <a href="http://plnkr.co/edit/adHC1ycmyjUICiSlsKAQ?p=preview" target="_blank" data-plunk-id="adHC1ycmyjUICiSlsKAQ">Open the solution with tests in the sandbox.</a>
<button type="button" title="close"></button>

<h3><a href="#create-new-accumulator" name="create-new-accumulator">Create new Accumulator</a></h3><a href="/task/accumulator" target="_blank"></a>

importance: 5

Create a constructor function <code>Accumulator(startingValue)</code>.

Object that it creates should:

<li>Store the “current value” in the property <code>value</code>. 
The starting value is set to the argument of the constructor <code>startingValue</code>.</li><li>The <code>read()</code> method should use <code>prompt</code> to read a new number and add it to <code>value</code>.</li>

In other words, the <code>value</code> property is the sum of all user-entered values with the initial value  <code>startingValue</code>.

Here’s the demo of the code:

    <code>let accumulator = new Accumulator(1); // initial value 1
accumulator.read(); // adds the user-entered value
accumulator.read(); // adds the user-entered value
alert(accumulator.value); // shows the sum of these values</code>
  <a href="#" onclick="event.preventDefault(); runDemo(this)">Run the demo</a>

<a href="http://plnkr.co/edit/uKdZnwR9KzNURvxZFzNs?p=preview" target="_blank" data-plunk-id="uKdZnwR9KzNURvxZFzNs">Open the sandbox with tests.</a>
<button type="button">solution</button>

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function Accumulator(startingValue) {
  this.value = startingValue;
  this.read = function() {
    this.value += +prompt('How much to add?', 0);
  };
}
let accumulator = new Accumulator(1);
accumulator.read();
accumulator.read();
alert(accumulator.value);</code>
  <a href="http://plnkr.co/edit/k4eKaquxqX68t7OTMnI6?p=preview" target="_blank" data-plunk-id="k4eKaquxqX68t7OTMnI6">Open the solution with tests in the sandbox.</a>
<button type="button" title="close"></button>

<h3><a href="#create-an-extendable-calculator" name="create-an-extendable-calculator">Create an extendable calculator</a></h3><a href="/task/calculator-extendable" target="_blank"></a>

importance: 5

Create a constructor function <code>Calculator</code> that creates “extendable” calculator objects.

The task consists of two parts.

<li>First, implement the method <code>calculate(str)</code> that takes a string like <code>&quot;1 + 2&quot;</code> in the format “NUMBER operator NUMBER” (space-delimited) and returns the result. 
Should understand plus <code>+</code> and minus <code>-</code>.

Usage example:

    <code>let calc = new Calculator;
alert( calc.calculate(&quot;3 + 7&quot;) ); // 10</code>
  </li><li>Then add the method <code>addOperator(name, func)</code> that teaches the calculator a new operation. 
It takes the operator <code>name</code> and the two-argument function <code>func(a,b)</code> that implements it.

For instance, let’s add the multiplication <code>*</code>, division <code>/</code> and power <code>**</code>:

    <code>let powerCalc = new Calculator;
powerCalc.addMethod(&quot;*&quot;, (a, b) =&gt; a * b);
powerCalc.addMethod(&quot;/&quot;, (a, b) =&gt; a / b);
powerCalc.addMethod(&quot;**&quot;, (a, b) =&gt; a ** b);
let result = powerCalc.calculate(&quot;2 ** 3&quot;);
alert( result ); // 8</code>
  </li>

<li>No brackets or complex expressions in this task.</li><li>The numbers and the operator are delimited with exactly one space.</li><li>There may be error handling if you’d like to add it.</li>

<a href="http://plnkr.co/edit/vCf22OGYDXKjjzwkh0jc?p=preview" target="_blank" data-plunk-id="vCf22OGYDXKjjzwkh0jc">Open the sandbox with tests.</a>
<button type="button">solution</button>

<li>Please note how methods are stored. 
They are simply added to the internal object.</li><li>All tests and numeric conversions are done in the <code>calculate</code> method. 
In future it may be extended to support more complex expressions.</li>

<a href="http://plnkr.co/edit/KAgnUzk2uCspMmJIBZqN?p=preview" target="_blank" data-plunk-id="KAgnUzk2uCspMmJIBZqN">Open the solution with tests in the sandbox.</a>
<button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/object-toprimitive" data-tooltip="Object to primitive conversion">Previous lesson</a><a href="/data-types" data-tooltip="Data types">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Fconstructor-new"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Fconstructor-new"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Fconstructor-new"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Fconstructor-new"></a>

JavaScript allows us to work with primitives (strings, numbers etc) as if they were objects.

They also provide methods to call and such. 
We will study those soon, but first we’ll see how it works, because, of course, primitives are not objects (and here we will make it even more clear).

Let’s look at the key distinction between primitives and objects.

A primitive

<dl>
<dt>An object</dt>
<dd>Is capable of storing multiple values as properties.
Can be created with <code>{}</code>, for instance: <code>{name: &quot;John&quot;, age: 30}</code>. 
There are other kinds of objects in JavaScript, e.g. 
functions are objects.</dd>
</dl>

One of the best things about objects is that we can store a function as one of its properties:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let john = {
  name: &quot;John&quot;,
  sayHi: function() {
    alert(&quot;Hi buddy!&quot;);
  }
};
john.sayHi(); // Hi buddy!</code>
  So here we’ve made an object <code>john</code> with the method <code>sayHi</code>.

Many built-in objects already exist, such as those that work with dates, errors, HTML elements etc. 
They have different properties and methods.

But, these features come with a cost!

Objects are “heavier” than primitives. 
They require additional resources to support the internal machinery. 
But as properties and methods are very useful in programming, JavaScript engines try to optimize them to reduce the additional burden.

<h2>A primitive as an object</h2>
Here’s the paradox faced by the creator of JavaScript:

<li>There are many things one would want to do with a primitive like a string or a number. 
It would be great to access them as methods.</li><li>Primitives must be as fast and lightweight as possible.</li>

The solution looks a little bit awkward, but here it is:

<li>Primitives are still primitive. 
A single value, as desired.</li><li>The language allows access to methods and properties of strings, numbers, booleans and symbols.</li><li>When this happens, a special “object wrapper” is created that provides the extra functionality, and then is destroyed.</li>

The “object wrappers” are different for each primitive type and are called: <code>String</code>, <code>Number</code>, <code>Boolean</code> and <code>Symbol</code>. 
Thus, they provide different sets of methods.

For instance, there exists a method <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase">str.toUpperCase()</a> that returns a capitalized string.

Here’s how it works:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let str = &quot;Hello&quot;;
alert( str.toUpperCase() ); // HELLO</code>
  Simple, right? Here’s what actually happens in <code>str.toUpperCase()</code>:

<li>The string <code>str</code> is a primitive. 
So in the moment of accessing its property, a special object is created that knows the value of the string, and has useful methods, like <code>toUpperCase()</code>.</li><li>That method runs and returns a new string (shown by <code>alert</code>).</li><li>The special object is destroyed, leaving the primitive <code>str</code> alone.</li>

So primitives can provide methods, but they still remain lightweight.

The JavaScript engine highly optimizes this process. 
It may even skip the creation of the extra object at all. 
But it must still adhere to the specification and behave as if it creates one.

A number has methods of its own, for instance, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed">toFixed(n)</a> rounds the number to the given precision:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let n = 1.23456;
alert( n.toFixed(2) ); // 1.23</code>
  We’ll see more specific methods in chapters <a href="/number">Numbers</a> and <a href="/string">Strings</a>.

Constructors <code>String/Number/Boolean</code> are for internal use only
Some languages like Java allow us to create “wrapper objects” for primitives explicitly using a syntax like <code>new Number(1)</code> or <code>new Boolean(false)</code>.

In JavaScript, that’s also possible for historical reasons, but highly <strong>unrecommended</strong>. 
Things will go crazy in several places.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( typeof 1 ); // &quot;number&quot;
alert( typeof new Number(1) ); // &quot;object&quot;!</code>
  And because what follows, <code>zero</code>, is an object, the alert will show up:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let zero = new Number(0);
if (zero) { // zero is true, because it's an object
  alert( &quot;zero is truthy?!?&quot; );
}</code>
  On the other hand, using the same functions <code>String/Number/Boolean</code> without <code>new</code> is a totally sane and useful thing. 
They convert a value to the corresponding type: to a string, a number, or a boolean (primitive).

For example, this is entirely valid:

    <code>let num = Number(&quot;123&quot;); // convert a string to number</code>
  

null/undefined have no methods
The special primitives <code>null</code> and <code>undefined</code> are exceptions. 
They have no corresponding “wrapper objects” and provide no methods. 
In a sense, they are “the most primitive”.

An attempt to access a property of such value would give the error:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert(null.test); // error</code>
  
<h4><a name="summary" href="#summary">Summary</a></h4><li>Primitives except <code>null</code> and <code>undefined</code> provide many helpful methods. 
We will study those in the upcoming chapters.</li><li>Formally, these methods work via temporary objects, but JavaScript engines are well tuned to optimize that internally, so they are not expensive to call.</li>

    <code>let str = &quot;Hello&quot;;
str.test = 5;
alert(str.test);</code>
  How do you think, will it work? What will be shown?

<button type="button">solution</button>

Try running it:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let str = &quot;Hello&quot;;
str.test = 5; // (*)
alert(str.test);</code>
  There may be two kinds of result:

<li><code>undefined</code></li><li>An error.</li>

Why? Let’s replay what’s happening at line <code>(*)</code>:

<li>When a property of <code>str</code> is accessed, a “wrapper object” is created.</li><li>The operation with the property is carried out on it. 
So, the object gets the <code>test</code> property.</li><li>The operation finishes and the “wrapper object” disappears.</li>

So, on the last line, <code>str</code> has no trace of the property. 
A new wrapper object for every object operation on a string.

Some browsers though may decide to further limit the programmer and disallow to assign properties to primitives at all. 
That’s why in practice we can also see errors at line <code>(*)</code>. 
It’s a little bit farther from the specification though.

<strong>This example clearly shows that primitives are not objects.</strong>

They just can not store data.

All property/method operations are performed with the help of temporary objects.

<button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/data-types" data-tooltip="Data types">Previous lesson</a><a href="/number" data-tooltip="Numbers">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Fprimitives-methods"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Fprimitives-methods"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Fprimitives-methods"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Fprimitives-methods"></a>

All numbers in JavaScript are stored in 64-bit format <a href="http://en.wikipedia.org/wiki/IEEE_754-1985">IEEE-754</a>, also known as “double precision”.

Let’s recap and expand upon what we currently know about them.

<h2>More ways to write a number</h2>
Imagine we need to write 1 billion. 
The obvious way is:

    <code>let billion = 1000000000;</code>
  But in real life we usually avoid writing a long string of zeroes as it’s easy to mistype. 
Also, we are lazy. 
We will usually write something like <code>&quot;1bn&quot;</code> for a billion or <code>&quot;7.3bn&quot;</code> for 7 billion 300 million. 
The same is true for most large numbers.

In JavaScript, we shorten a number by appending the letter <code>&quot;e&quot;</code> to the number and specifying the zeroes count:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let billion = 1e9;  // 1 billion, literally: 1 and 9 zeroes
alert( 7.3e9 );  // 7.3 billions (7,300,000,000)</code>
  In other words, <code>&quot;e&quot;</code> multiplies the number by <code>1</code> with the given zeroes count.

    <code>1e3 = 1 * 1000
1.23e6 = 1.23 * 1000000</code>
  Now let’s write something very small. 
Say, 1 microsecond (one millionth of a second):

    <code>let ms = 0.000001;</code>
  Just like before, using <code>&quot;e&quot;</code> can help. 
If we’d like to avoid writing the zeroes explicitly, we could say:

    <code>let ms = 1e-6; // six zeroes to the left from 1</code>
  If we count the zeroes in <code>0.000001</code>, there are 6 of them. 
So naturally it’s <code>1e-6</code>.

In other words, a negative number after <code>&quot;e&quot;</code> means a division by 1 with the given number of zeroes:

    <code>// -3 divides by 1 with 3 zeroes
1e-3 = 1 / 1000 (=0.001)
// -6 divides by 1 with 6 zeroes
1.23e-6 = 1.23 / 1000000 (=0.00000123)</code>
  <h3><a name="hex-binary-and-octal-numbers" href="#hex-binary-and-octal-numbers">Hex, binary and octal numbers</a></h3>
<a href="https://en.wikipedia.org/wiki/Hexadecimal">Hexadecimal</a> numbers are widely used in JavaScript to represent colors, encode characters, and for many other things. 
So naturally, there exists a shorter way to write them: <code>0x</code> and then the number.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( 0xff ); // 255
alert( 0xFF ); // 255 (the same, case doesn't matter)</code>
  Binary and octal numeral systems are rarely used, but also supported using the <code>0b</code> and <code>0o</code> prefixes:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let a = 0b11111111; // binary form of 255
let b = 0o377; // octal form of 255
alert( a == b ); // true, the same number 255 at both sides</code>
  There are only 3 numeral systems with such support. 
For other numeral systems, we should use the function <code>parseInt</code> (which we will see later in this chapter).

<h2>toString(base)</h2>
The method <code>num.toString(base)</code> returns a string representation of <code>num</code> in the numeral system with the given <code>base</code>.

For example:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let num = 255;
alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111</code>
  The <code>base</code> can vary from <code>2</code> to <code>36</code>. 
By default it’s <code>10</code>.

Common use cases for this are:

<li><strong>base=16</strong> is used for hex colors, character encodings etc, digits can be <code>0..9</code> or <code>A..F</code>.

</li><li><strong>base=2</strong> is mostly for debugging bitwise operations, digits can be <code>0</code> or <code>1</code>.

</li><li><strong>base=36</strong> is the maximum, digits can be <code>0..9</code> or <code>A..Z</code>. 
The whole latin alphabet is used to represent a number. 
A funny, but useful case for <code>36</code> is when we need to turn a long numeric identifier into something shorter, for example to make a short url. 
Can simply represent it in the numeral system with base <code>36</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( 123456..toString(36) ); // 2n9c</code>
  </li>

Two dots to call a method
Please note that two dots in <code>123456..toString(36)</code> is not a typo. 
If we want to call a method directly on a number, like <code>toString</code> in the example above, then we need to place two dots <code>..</code> after it.

If we placed a single dot: <code>123456.toString(36)</code>, then there would be an error, because JavaScript syntax implies the decimal part after the first dot. 
And if we place one more dot, then JavaScript knows that the decimal part is empty and now goes the method.

Also could write <code>(123456).toString(36)</code>.

<h2>Rounding</h2>
One of the most used operations when working with numbers is rounding.

There are several built-in functions for rounding:

<dl>
<dt><code>Math.floor</code></dt>
<dd>Rounds down: <code>3.1</code> becomes <code>3</code>, and <code>-1.1</code> becomes <code>-2</code>.</dd>
<dt><code>Math.ceil</code></dt>
<dd>Rounds up: <code>3.1</code> becomes <code>4</code>, and <code>-1.1</code> becomes <code>-1</code>.</dd>
<dt><code>Math.round</code></dt>
<dd>Rounds to the nearest integer: <code>3.1</code> becomes <code>3</code>, <code>3.6</code> becomes <code>4</code> and <code>-1.1</code> becomes <code>-1</code>.</dd>
<dt><code>Math.trunc</code> (not supported by Internet Explorer)</dt>
<dd>Removes anything after the decimal point without rounding: <code>3.1</code> becomes <code>3</code>, <code>-1.1</code> becomes <code>-1</code>.</dd>
</dl>

Here’s the table to summarize the differences between them:

<table>
<thead>
<tr>
<th></th>
<th><code>Math.floor</code></th>
<th><code>Math.ceil</code></th>
<th><code>Math.round</code></th>
<th><code>Math.trunc</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>3.1</code></td>
<td><code>3</code></td>
<td><code>4</code></td>
<td><code>3</code></td>
<td><code>3</code></td>
</tr>
<tr>
<td><code>3.6</code></td>
<td><code>3</code></td>
<td><code>4</code></td>
<td><code>4</code></td>
<td><code>3</code></td>
</tr>
<tr>
<td><code>-1.1</code></td>
<td><code>-2</code></td>
<td><code>-1</code></td>
<td><code>-1</code></td>
<td><code>-1</code></td>
</tr>
<tr>
<td><code>-1.6</code></td>
<td><code>-2</code></td>
<td><code>-1</code></td>
<td><code>-2</code></td>
<td><code>-1</code></td>
</tr>
</tbody>
</table>

These functions cover all of the possible ways to deal with the decimal part of a number. 
But what if we’d like to round the number to <code>n-th</code> digit after the decimal?

For instance, we have <code>1.2345</code> and want to round it to 2 digits, getting only <code>1.23</code>.

There are two ways to do so:

<li>Multiply-and-divide.

For example, to round the number to the 2nd digit after the decimal, we can multiply the number by <code>100</code>, call the rounding function and then divide it back.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let num = 1.23456;
alert( Math.floor(num * 100) / 100 ); // 1.23456 -&gt; 123.456 -&gt; 123 -&gt; 1.23</code>
  </li><li>The method <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed">toFixed(n)</a> rounds the number to <code>n</code> digits after the point and returns a string representation of the result.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let num = 12.34;
alert( num.toFixed(1) ); // &quot;12.3&quot;</code>
  This rounds up or down to the nearest value, similar to <code>Math.round</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let num = 12.36;
alert( num.toFixed(1) ); // &quot;12.4&quot;</code>
  Please note that result of <code>toFixed</code> is a string. 
If the decimal part is shorter than required, zeroes are appended to the end:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let num = 12.34;
alert( num.toFixed(5) ); // &quot;12.34000&quot;, added zeroes to make exactly 5 digits</code>
  We can convert it to a number using the unary plus or a <code>Number()</code> call: <code>+num.toFixed(5)</code>.

</li>

<h2>Imprecise calculations</h2>
Internally, a number is represented in 64-bit format <a href="http://en.wikipedia.org/wiki/IEEE_754-1985">IEEE-754</a>, so there are exactly 64 bits to store a number: 52 of them are used to store the digits, 11 of them store the position of the decimal point (they are zero for integer numbers), and 1 bit is for the sign.

If a number is too big, it would overflow the 64-bit storage, potentially giving an infinity:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( 1e500 ); // Infinity</code>
  What may be a little less obvious, but happens quite often, is the loss of precision.

Consider this (falsy!) test:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( 0.1 + 0.2 == 0.3 ); // false</code>
  That’s right, if we check whether the sum of <code>0.1</code> and <code>0.2</code> is <code>0.3</code>, we get <code>false</code>.

Strange! What is it then if not <code>0.3</code>?

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( 0.1 + 0.2 ); // 0.30000000000000004</code>
  Ouch! There are more consequences than an incorrect comparison here. 
Imagine you’re making an e-shopping site and the visitor puts <code>$0.10</code> and <code>$0.20</code> goods into his chart. 
The order total will be <code>$0.30000000000000004</code>. 
That would surprise anyone.

But why does this happen?

A number is stored in memory in its binary form, a sequence of ones and zeroes. 
But fractions like <code>0.1</code>, <code>0.2</code> that look simple in the decimal numeric system are actually unending fractions in their binary form.

In other words, what is <code>0.1</code>? It is one divided by ten <code>1/10</code>, one-tenth. 
In decimal numeral system such numbers are easily representable. 
Compare it to one-third: <code>1/3</code>. 
It becomes an endless fraction <code>0.33333(3)</code>.

So, division by powers <code>10</code> is guaranteed to work well in the decimal system, but division by <code>3</code> is not. 
For the same reason, in the binary numeral system, the division by powers of <code>2</code> is guaranteed to work, but <code>1/10</code> becomes an endless binary fraction.

There’s just no way to store <em>exactly 0.1</em> or <em>exactly 0.2</em> using the binary system, just like there is no way to store one-third as a decimal fraction.

The numeric format IEEE-754 solves this by rounding to the nearest possible number. 
These rounding rules normally don’t allow us to see that “tiny precision loss”, so the number shows up as <code>0.3</code>. 
But beware, the loss still exists.

We can see this in action:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( 0.1.toFixed(20) ); // 0.10000000000000000555</code>
  And when we sum two numbers, their “precision losses” add up.

That’s why <code>0.1 + 0.2</code> is not exactly <code>0.3</code>.

Not only JavaScript
The same issue exists in many other programming languages.

PHP, Java, C, Perl, Ruby give exactly the same result, because they are based on the same numeric format.

Can we work around the problem? Sure, there’re a number of ways:

<li>We can round the result with the help of a method <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed">toFixed(n)</a>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let sum = 0.1 + 0.2;
alert( sum.toFixed(2) ); // 0.30</code>
  Please note that <code>toFixed</code> always returns a string. 
It ensures that it has 2 digits after the decimal point. 
That’s actually convenient if we have an e-shopping and need to show <code>$0.30</code>. 
For other cases, we can use the unary plus to coerce it into a number:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let sum = 0.1 + 0.2;
alert( +sum.toFixed(2) ); // 0.3</code>
  </li><li>We can temporarily turn numbers into integers for the maths and then revert it back. 
It works like this:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3</code>
  This works because when we do <code>0.1 * 10 = 1</code> and <code>0.2 * 10 = 2</code> then both numbers become integers, and there’s no precision loss.

</li><li>If we were dealing with a shop, then the most radical solution would be to store all prices in cents and use no fractions at all. 
But what if we apply a discount of 30%? In practice, totally evading fractions is rarely feasible, so the solutions above help avoid this pitfall.

</li>

The funny thing
Try running this:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// Hello! I'm a self-increasing number!
alert( 9999999999999999 ); // shows 10000000000000000</code>
  This suffers from the same issue: a loss of precision. 
There are 64 bits for the number, 52 of them can be used to store digits, but that’s not enough. 
So the least significant digits disappear.

JavaScript doesn’t trigger an error in such events. 
It does its best to fit the number into the desired format, but unfortunately, this format is not big enough.

Two zeroes
Another funny consequence of the internal representation of numbers is the existence of two zeroes: <code>0</code> and <code>-0</code>.

That’s because a sign is represented by a single bit, so every number can be positive or negative, including a zero.

In most cases the distinction is unnoticeable, because operators are suited to treat them as the same.

<h2>Tests: isFinite and isNaN</h2>
Remember these two special numeric values?

<li><code>Infinite</code> (and <code>-Infinite</code>) is a special numeric value that is greater (less) than anything.</li><li><code>NaN</code> represents an error.</li>

They belong to the type <code>number</code>, but are not “normal” numbers, so there are special functions to check for them:

<li><code>isNaN(value)</code> converts its argument to a number and then tests it for being <code>NaN</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( isNaN(NaN) ); // true
alert( isNaN(&quot;str&quot;) ); // true</code>
  But do we need this function? Can’t we just use the comparison <code>=== NaN</code>? Sorry, but the answer is no. 
The value <code>NaN</code> is unique in that it does not equal anything, including itself:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( NaN === NaN ); // false</code>
  </li><li><code>isFinite(value)</code> converts its argument to a number and returns <code>true</code> if it’s a regular number, not <code>NaN/Infinity/-Infinity</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( isFinite(&quot;15&quot;) ); // true
alert( isFinite(&quot;str&quot;) ); // false, because a special value: NaN
alert( isFinite(Infinity) ); // false, because a special value: Infinity</code>
  </li>

Sometimes <code>isFinite</code> is used to validate whether a string value is a regular number:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let num = +prompt(&quot;Enter a number&quot;, '');
// will be true unless you enter Infinity, -Infinity or not a number
alert( isFinite(num) );</code>
  Please note that an empty or a space-only string is treated as <code>0</code> in all numeric functions including <code>isFinite</code>.

Compare with <code>Object.is</code>
There is a special built-in method <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is">Object.is</a> that compares values like <code>===</code>, but is more reliable for two edge cases:

<li>It works with <code>NaN</code>: <code>Object.is(NaN, NaN) === true</code>, that’s a good thing.</li><li>Values <code>0</code> and <code>-0</code> are different: <code>Object.is(0, -0) === false</code>, it rarely matters, but these values technically are different.</li>

In all other cases, <code>Object.is(a, b)</code> is the same as <code>a === b</code>.

This way of comparison is often used in JavaScript specification. 
When an internal algorithm needs to compare two values for being exactly the same, it uses <code>Object.is</code> (internally called <a href="https://tc39.github.io/ecma262/#sec-samevalue">SameValue</a>).

<h2>parseInt and parseFloat</h2>
Numeric conversion using a plus <code>+</code> or <code>Number()</code> is strict. 
If a value is not exactly a number, it fails:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( +&quot;100px&quot; ); // NaN</code>
  The sole exception is spaces at the beginning or at the end of the string, as they are ignored.

But in real life we often have values in units, like <code>&quot;100px&quot;</code> or <code>&quot;12pt&quot;</code> in CSS. 
Also in many countries the currency symbol goes after the amount, so we have <code>&quot;19€&quot;</code> and would like to extract a numeric value out of that.

That’s what <code>parseInt</code> and <code>parseFloat</code> are for.

They “read” a number from a string until they can. 
In case of an error, the gathered number is returned. 
The function <code>parseInt</code> returns an integer, whilst <code>parseFloat</code> will return a floating-point number:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5
alert( parseInt('12.3') ); // 12, only the integer part is returned
alert( parseFloat('12.3.4') ); // 12.3, the second point stops the reading</code>
  There are situations when <code>parseInt/parseFloat</code> will return <code>NaN</code>. 
It happens when no digits could be read:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( parseInt('a123') ); // NaN, the first symbol stops the process</code>
  
The second argument of <code>parseInt(str, radix)</code>
The <code>parseInt()</code> function has an optional second parameter. 
It specifies the base of the numeral system, so <code>parseInt</code> can also parse strings of hex numbers, binary numbers and so on:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( parseInt('0xff', 16) ); // 255
alert( parseInt('ff', 16) ); // 255, without 0x also works
alert( parseInt('2n9c', 36) ); // 123456</code>
  
<h2>Other math functions</h2>
JavaScript has a built-in <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math">Math</a> object which contains a small library of mathematical functions and constants.

A few examples:

<dl>
<dt><code>Math.random()</code></dt>
<dd>

Returns a random number from 0 to 1 (not including 1)

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( Math.random() ); // 0.1234567894322
alert( Math.random() ); // 0.5435252343232
alert( Math.random() ); // ... 
(any random numbers)</code>
  </dd>
<dt><code>Math.max(a, b, c...)</code> / <code>Math.min(a, b, c...)</code></dt>
<dd>

Returns the greatest/smallest from the arbitrary number of arguments.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( Math.max(3, 5, -10, 0, 1) ); // 5
alert( Math.min(1, 2) ); // 1</code>
  </dd>
<dt><code>Math.pow(n, power)</code></dt>
<dd>

Returns <code>n</code> raised the given power

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( Math.pow(2, 10) ); // 2 in power 10 = 1024</code>
  </dd>
</dl>

There are more functions and constants in <code>Math</code> object, including trigonometry, which you can find in the <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math">docs for the Math</a> object.

<h4><a name="summary" href="#summary">Summary</a4</h2>
To write big numbers:

<li>Append <code>&quot;e&quot;</code> with the zeroes count to the number. 
Like: <code>123e6</code> is <code>123</code> with 6 zeroes.</li><li>A negative number after <code>&quot;e&quot;</code> causes the number to be divided by 1 with given zeroes. 
That’s for one-millionth or such.</li>

For different numeral systems:

<li>Can write numbers directly in hex (<code>0x</code>), octal (<code>0o</code>) and binary (<code>0b</code>) systems</li><li><code>parseInt(str, base)</code> parses an integer from any numeral system with base: <code>2 ≤ base ≤ 36</code>.</li><li><code>num.toString(base)</code> converts a number to a string in the numeral system with the given <code>base</code>.</li>

For converting values like <code>12pt</code> and <code>100px</code> to a number:

<li>Use <code>parseInt/parseFloat</code> for the “soft” conversion, which reads a number from a string and then returns the value they could read before the error.</li>

For fractions:

<li>Round using <code>Math.floor</code>, <code>Math.ceil</code>, <code>Math.trunc</code>, <code>Math.round</code> or <code>num.toFixed(precision)</code>.</li><li>Make sure to remember there’s a loss of precision when working with fractions.</li>

More mathematical functions:

<li>See the <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math">Math</a> object when you need them. 
The library is very small, but can cover basic needs.</li>

<a href="#" onclick="event.preventDefault(); runDemo(this)">Run the demo</a>

P.S. 
There is a gotcha with types.

<button type="button">solution</button>

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let a = +prompt(&quot;The first number?&quot;, &quot;&quot;);
let b = +prompt(&quot;The second number?&quot;, &quot;&quot;);
alert( a + b );</code>
  Note the unary plus <code>+</code> before <code>prompt</code>. 
It immediately converts the value to a number.

Otherwise, <code>a</code> and <code>b</code> would be string their sum would be their concatenation, that is: <code>&quot;1&quot; + &quot;2&quot; = &quot;12&quot;</code>.

<button type="button" title="close"></button>

<h3><a href="#why-6-35-tofixed-1-6-3" name="why-6-35-tofixed-1-6-3">Why 6.35.toFixed(1) == 6.3?</a></h3><a href="/task/why-rounded-down" target="_blank"></a>

importance: 4

According to the documentation <code>Math.round</code> and <code>toFixed</code> both round to the nearest number: <code>0..4</code> lead down while <code>5..9</code> lead up.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( 1.35.toFixed(1) ); // 1.4</code>
  In the similar example below, why is <code>6.35</code> rounded to <code>6.3</code>, not <code>6.4</code>?

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( 6.35.toFixed(1) ); // 6.3</code>
  How to round <code>6.35</code> the right way?

<button type="button">solution</button>

Internally the decimal fraction <code>6.35</code> is an endless binary. 
As always in such cases, it is stored with a precision loss.

Let’s see:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( 6.35.toFixed(20) ); // 6.34999999999999964473</code>
  The precision loss can cause both increase and decrease of a number. 
In this particular case the number becomes a tiny bit less, that’s why it rounded down.

And what’s for <code>1.35</code>?

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( 1.35.toFixed(20) ); // 1.35000000000000008882</code>
  Here the precision loss made the number a little bit greater, so it rounded up.

<strong>How can we fix the problem with <code>6.35</code> if we want it to be rounded the right way?</strong>

We should bring it closer to an integer prior to rounding:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( (6.35 * 10).toFixed(20) ); // 63.50000000000000000000</code>
  Note that <code>63.5</code> has no precision loss at all. 
That’s because the decimal part <code>0.5</code> is actually <code>1/2</code>. 
Fractions divided by powers of <code>2</code> are exactly represented in the binary system, now we can round it:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( Math.round(6.35 * 10) / 10); // 6.35 -&gt; 63.5 -&gt; 64(rounded) -&gt; 6.4</code>
  <button type="button" title="close"></button>

<h3><a href="#repeat-until-the-input-is-a-number" name="repeat-until-the-input-is-a-number">Repeat until the input is a number</a></h3><a href="/task/repeat-until-number" target="_blank"></a>

importance: 5

Create a function <code>readNumber</code> which prompts for a number until the visitor enters a valid numeric value.

The resulting value must be returned as a number.

The visitor can also stop the process by entering an empty line or pressing “CANCEL”. 
In that case, the function should return <code>null</code>.

<a href="#" onclick="event.preventDefault(); runDemo(this)">Run the demo</a>

<a href="http://plnkr.co/edit/UBlLg3VHdNALI7MfbnjS?p=preview" target="_blank" data-plunk-id="UBlLg3VHdNALI7MfbnjS">Open the sandbox with tests.</a>
<button type="button">solution</button>

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function readNumber() {
  let num;
  do {
    num = prompt(&quot;Enter a number please?&quot;, 0);
  } while ( !isFinite(num) );
  if (num === null || num === '') return null;
  return +num;
}
alert(`Read: ${readNumber()}`);</code>
  The solution is a little bit more intricate that it could be because we need to handle <code>null</code>/empty lines.

So we actually accept the input until it is a “regular number”. 
Both <code>null</code> (cancel) and empty line also fit that condition, because in numeric form they are <code>0</code>.

After we stopped, we need to treat <code>null</code> and empty line specially (return <code>null</code>), because converting them to a number would return <code>0</code>.

<a href="http://plnkr.co/edit/Kr22s0MIHmEaiPptXewM?p=preview" target="_blank" data-plunk-id="Kr22s0MIHmEaiPptXewM">Open the solution with tests in the sandbox.</a>
<button type="button" title="close"></button>

<h3><a href="#an-occasional-infinite-loop" name="an-occasional-infinite-loop">An occasional infinite loop</a></h3><a href="/task/endless-loop-error" target="_blank"></a>

importance: 4

This loop is infinite. 
It never ends. 
Why?

    <code>let i = 0;
while (i != 10) {
  i += 0.2;
}</code>
  <button type="button">solution</button>

That’s because <code>i</code> would never equal <code>10</code>.

Run it to see the <em>real</em> values of <code>i</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let i = 0;
while (i &lt; 11) {
  i += 0.2;
  if (i &gt; 9.8 &amp;&amp; i &lt; 10.2) alert( i );
}</code>
  None of them is exactly <code>10</code>.

Such things happen because of the precision losses when adding fractions like <code>0.2</code>.

Conclusion: evade equality checks when working with decimal fractions.

<button type="button" title="close"></button>

<h3><a href="#a-random-number-from-min-to-max" name="a-random-number-from-min-to-max">A random number from min to max</a></h3><a href="/task/random-min-max" target="_blank"></a>

importance: 2

The built-in function <code>Math.random()</code> creates a random value from <code>0</code> to <code>1</code> (not including <code>1</code>).

Write the function <code>random(min, max)</code> to generate a random floating-point number from <code>min</code> to <code>max</code> (not including <code>max</code>).

Examples of its work:

    <code>alert( random(1, 5) ); // 1.2345623452
alert( random(1, 5) ); // 3.7894332423
alert( random(1, 5) ); // 4.3435234525</code>
  <button type="button">solution</button>

We need to “map” all values from the interval 0…1 into values from <code>min</code> to <code>max</code>.

That can be done in two stages:

<li>If we multiply a random number from 0…1 by <code>max-min</code>, then it the interval of possible values increases <code>0..1</code> to <code>0..max-min</code>.</li><li>Now if we add <code>min</code>, the possible interval becomes from <code>min</code> to <code>max</code>.</li>

The function:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function random(min, max) {
  return min + Math.random() * (max - min);
}
alert( random(1, 5) );
alert( random(1, 5) );
alert( random(1, 5) );</code>
  <button type="button" title="close"></button>

<h3><a href="#a-random-integer-from-min-to-max" name="a-random-integer-from-min-to-max">A random integer from min to max</a></h3><a href="/task/random-int-min-max" target="_blank"></a>

importance: 2

Create a function <code>randomInteger(min, max)</code> that generates a random <em>integer</em> number from <code>min</code> to <code>max</code> including both <code>min</code> and <code>max</code> as possible values.

Any number from the interval <code>min..max</code> must appear with the same probability.

Examples of its work:

    <code>alert( random(1, 5) ); // 1
alert( random(1, 5) ); // 3
alert( random(1, 5) ); // 5</code>
  You can use the solution of the <a href="/task/random-min-max">previous task</a> as the base.

<button type="button">solution</button>

<button type="button" onclick="showStep(this)">The simple but wrong solution</button>

<h4>The simple but wrong solution</h4>
The simplest, but wrong solution would be to generate a value from <code>min</code> to <code>max</code> and round it:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function randomInteger(min, max) {
  let rand = min + Math.random() * (max - min);
  return Math.round(rand);
}
alert( randomInteger(1, 3) );</code>
  The function works, but it is incorrect. 
The probability to get edge values <code>min</code> and <code>max</code> is two times less than any other.

If you run the example above many times, you would easily see that <code>2</code> appears the most often.

That happens because <code>Math.round()</code> gets random numbers from the interval <code>1..3</code> and rounds them as follows:

    <code>values from 1    ... 
to 1.4999999999  become 1
values from 1.5  ... 
to 2.4999999999  become 2
values from 2.5  ... 
to 2.9999999999  become 3</code>
  Now we can clearly see that <code>1</code> gets twice less values than <code>2</code>. 
And the same with <code>3</code>.

<button type="button" onclick="showStep(this)">The correct solution</button>

<h4>The correct solution</h4>
There are many correct solutions to the task. 
One of them is to adjust interval borders. 
To ensure the same intervals, we can generate values from <code>0.5 to 3.5</code>, thus adding the required probabilities to the edges:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function randomInteger(min, max) {
  // now rand is from  (min-0.5) to (max+0.5)
  let rand = min - 0.5 + Math.random() * (max - min + 1);
  return Math.round(rand);
}
alert( randomInteger(1, 3) );</code>
  An alternative way could be to use <code>Math.floor</code> for a random number from <code>min</code> to <code>max+1</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function randomInteger(min, max) {
  // here rand is from min to (max+1)
  let rand = min + Math.random() * (max + 1 - min);
  return Math.floor(rand);
}
alert( randomInteger(1, 3) );</code>
  Now all intervals are mapped this way:

    <code>values from 1  ... 
to 1.9999999999  become 1
values from 2  ... 
to 2.9999999999  become 2
values from 3  ... 
to 3.9999999999  become 3</code>
  All intervals have the same length, making the final distribution uniform.

<button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/primitives-methods" data-tooltip="Methods of primitives">Previous lesson</a><a href="/string" data-tooltip="Strings">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Fnumber"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Fnumber"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Fnumber"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Fnumber"></a>

In JavaScript, the textual data is stored as strings. 
There is no separate type for a single character.

The internal format for strings is always <a href="https://en.wikipedia.org/wiki/UTF-16">UTF-16</a>, it is not tied to the page encoding.

<h2>Quotes</h2>
Let’s recall the kinds of quotes.

Strings can be enclosed within either single quotes, double quotes or backticks:

    <code>let single = 'single-quoted';
let double = &quot;double-quoted&quot;;
let backticks = `backticks`;</code>
  Single and double quotes are essentially the same. 
Backticks, however, allow us to embed any expression into the string, including function calls:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function sum(a, b) {
  return a + b;
}
alert(`1 + 2 = ${sum(1, 2)}.`); // 1 + 2 = 3.</code>
  Another advantage of using backticks is that they allow a string to span multiple lines:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let guestList = `Guests:
 * John
 * Pete
 * Mary
`;
alert(guestList); // a list of guests, multiple lines</code>
  If we try to use single or double quotes in the same way, there will be an error:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let guestList = &quot;Guests:  // Error: Unexpected token ILLEGAL
  * John&quot;;</code>
  Single and double quotes come from ancient times of language creation when the need for multiline strings was not taken into account. 
Backticks appeared much later and thus are more versatile.

Backticks also allow us to specify a “template function” before the first backtick. 
The syntax is: <code>func`string`</code>. 
The function <code>func</code> is called automatically, receives the string and embedded expressions and can process them. 
You can read more about it in the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals">docs</a>. 
This is called “tagged templates”. 
This feature makes it easier to wrap strings into custom templating or other functionality, but it is rarely used.

<h2>Special characters</h2>
It is still possible to create multiline strings with single quotes by using a so-called “newline character”, written as <code>\n</code>, which denotes a line break:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let guestList = &quot;Guests:\n * John\n * Pete\n * Mary&quot;;
alert(guestList); // a multiline list of guests</code>
  For example, these two lines describe the same:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( &quot;Hello\nWorld&quot; ); // two lines using a &quot;newline symbol&quot;
// two lines using a normal newline and backticks
alert( `Hello
World` );</code>
  There are other, less common “special” characters as well. 
Here’s the list:

<table>
<thead>
<tr>
<th>Character</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\b</code></td>
<td>Backspace</td>
</tr>
<tr>
<td><code>\f</code></td>
<td>Form feed</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>New line</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>Carriage return</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>Tab</td>
</tr>
<tr>
<td><code>\uNNNN</code></td>
<td>A unicode symbol with the hex code <code>NNNN</code>, for instance <code>\u00A9</code> – is a unicode for the copyright symbol <code>©</code>. 
It must be exactly 4 hex digits.</td>
</tr>
<tr>
<td><code>\u{NNNNNNNN}</code></td>
<td>Some rare characters are encoded with two unicode symbols, taking up to 4 bytes. 
This long unicode requires braces around it.</td>
</tr>
</tbody>
</table>

Examples with unicode:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( &quot;\u00A9&quot; ); // ©
alert( &quot;\u{20331}&quot; ); // 佫, a rare chinese hieroglyph (long unicode)
alert( &quot;\u{1F60D}&quot; ); // 😍, a smiling face symbol (another long unicode)</code>
  All special characters start with a backslash character <code>\</code>. 
It is also called an “escape character”.

We would also use it if we want to insert a quote into the string.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( 'I\'m the Walrus!' ); // I'm the Walrus!</code>
  As you can see, we have to prepend the inner quote by the backslash <code>\'</code>, because otherwise it would indicate the string end.

Of course, that refers only to the quotes that are same as the enclosing ones. 
So, as a more elegant solution, we could switch to double quotes or backticks instead:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( `I'm the Walrus!` ); // I'm the Walrus!</code>
  Note that the backslash <code>\</code> serves for the correct reading of the string by JavaScript, then disappears. 
The in-memory string has no <code>\</code>. 
You can clearly see that in <code>alert</code> from the examples above.

But what if we need to show an actual backslash <code>\</code> within the string?

That’s possible, but we need to double it like <code>\\</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( `The backslash: \\` ); // The backslash: \</code>
  <h2>String length</h2>
The <code>length</code> property has the string length:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( `My\n`.length ); // 3</code>
  Note that <code>\n</code> is a single “special” character, so the length is indeed <code>3</code>.

<code>length</code> is a property
People with a background in some other languages sometimes mistype by calling <code>str.length()</code> instead of just <code>str.length</code>. 
That doesn’t work.

Please note that <code>str.length</code> is a numeric property, not a function. 
There is no need to add brackets after it.

<h2>Accessing characters</h2>
To get a character at position <code>pos</code>, use square brackets <code>[pos]</code> or call the method <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charAt">str.charAt(pos)</a>. 
The first character starts from the zero position:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let str = `Hello`;
// the first character
alert( str[0] ); // H
alert( str.charAt(0) ); // H
// the last character
alert( str[str.length - 1] ); // o</code>
  The square brackets are a modern way of getting a character, while <code>charAt</code> exists mostly for historical reasons.

The only difference between them is that if no character is found, <code>[]</code> returns <code>undefined</code>, and <code>charAt</code> returns an empty string:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let str = `Hello`;
alert( str[1000] ); // undefined
alert( str.charAt(1000) ); // '' (an empty string)</code>
  We can also iterate over characters using <code>for..of</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>for (let char of &quot;Hello&quot;) {
  alert(char); // H,e,l,l,o (char becomes &quot;H&quot;, then &quot;e&quot;, then &quot;l&quot; etc)
}</code>
  <h2>Strings are immutable</h2>
Strings can’t be changed in JavaScript. 
It is impossible to change a character.

Let’s try it to show that it doesn’t work:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let str = 'Hi';
str[0] = 'h'; // error
alert( str[0] ); // doesn't work</code>
  The usual workaround is to create a whole new string and assign it to <code>str</code> instead of the old one.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let str = 'Hi';
str = 'h' + str[1];  // replace the string
alert( str ); // hi</code>
  In the following sections we’ll see more examples of this.

<h2>Changing the case</h2>
Methods <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase">toLowerCase()</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase">toUpperCase()</a> change the case:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( 'Interface'.toUpperCase() ); // INTERFACE
alert( 'Interface'.toLowerCase() ); // interface</code>
  Or, if we want a single character lowercased:

    <code>alert( 'Interface'[0].toLowerCase() ); // 'i'</code>
  <h2>Searching for a substring</h2>
There are multiple ways to look for a substring within a string.

<h3><a name="str-indexof" href="#str-indexof">str.indexOf</a></h3>
The first method is <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf">str.indexOf(substr, pos)</a>.

It looks for the <code>substr</code> in <code>str</code>, starting from the given position <code>pos</code>, and returns the position where the match was found or <code>-1</code> if nothing can be found.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let str = 'Widget with id';
alert( str.indexOf('Widget') ); // 0, because 'Widget' is found at the beginning
alert( str.indexOf('widget') ); // -1, not found, the search is case-sensitive
alert( str.indexOf(&quot;id&quot;) ); // 1, &quot;id&quot; is found at the position 1 (..idget with id)</code>
  The optional second parameter allows us to search starting from the given position.

For instance, the first occurrence of <code>&quot;id&quot;</code> is at position <code>1</code>. 
To look for the next occurrence, let’s start the search from position <code>2</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let str = 'Widget with id';
alert( str.indexOf('id', 2) ) // 12</code>
  If we’re interested in all occurrences, we can run <code>indexOf</code> in a loop. 
Every new call is made with the position after the previous match:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let str = 'As sly as a fox, as strong as an ox';
let target = 'as'; // let's look for it
let pos = 0;
while (true) {
  let foundPos = str.indexOf(target, pos);
  if (foundPos == -1) break;
  alert( `Found at ${foundPos}` );
  pos = foundPos + 1; // continue the search from the next position
}</code>
  The same algorithm can be layed out shorter:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let str = &quot;As sly as a fox, as strong as an ox&quot;;
let target = &quot;as&quot;;
let pos = -1;
while ((pos = str.indexOf(target, pos + 1)) != -1) {
  alert( pos );
}</code>
  
<code>str.lastIndexOf(pos)</code>
There is also a similar method <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf">str.lastIndexOf(pos)</a> that searches from the end of a string to its beginning.

It would list the occurrences in the reverse order.

There is a slight inconvenience with <code>indexOf</code> in the <code>if</code> test. 
We can’t put it in the <code>if</code> like this:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let str = &quot;Widget with id&quot;;
if (str.indexOf(&quot;Widget&quot;)) {
    alert(&quot;We found it&quot;); // doesn't work!
}</code>
  The <code>alert</code> in the example above doesn’t show because <code>str.indexOf(&quot;Widget&quot;)</code> returns <code>0</code> (meaning that it found the match at the starting position). 
Right, but <code>if</code> considers <code>0</code> to be <code>false</code>.

So, we should actually check for <code>-1</code>, like this:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let str = &quot;Widget with id&quot;;
if (str.indexOf(&quot;Widget&quot;) != -1) {
    alert(&quot;We found it&quot;); // works now!
}</code>
  
The bitwise NOT trick
One of the old tricks used here is the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Bitwise_NOT">bitwise NOT</a> <code>~</code> operator. 
It converts the number to a 32-bit integer (removes the decimal part if exists) and then reverses all bits in its binary representation.

For 32-bit integers the call <code>~n</code> means exactly the same as <code>-(n+1)</code> (due to IEEE-754 format).

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( ~2 ); // -3, the same as -(2+1)
alert( ~1 ); // -2, the same as -(1+1)
alert( ~0 ); // -1, the same as -(0+1)
alert( ~-1 ); // 0, the same as -(-1+1)</code>
  As we can see, <code>~n</code> is zero only if <code>n == -1</code>.

So, the test <code>if ( ~str.indexOf(&quot;...&quot;) )</code> is truthy that the result of <code>indexOf</code> is not <code>-1</code>. 
In other words, when there is a match.

People use it to shorten <code>indexOf</code> checks:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let str = &quot;Widget&quot;;
if (~str.indexOf(&quot;Widget&quot;)) {
  alert( 'Found it!' ); // works
}</code>
  It is usually not recommended to use language features in a non-obvious way, but this particular trick is widely used in old code, so we should understand it.

Just remember: <code>if (~str.indexOf(...))</code> reads as “if found”.

<h3><a name="includes-startswith-endswith" href="#includes-startswith-endswith">includes, startsWith, endsWith</a></h3>
The more modern method <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes">str.includes(substr, pos)</a> returns <code>true/false</code> depending on whether <code>str</code> contains <code>substr</code> within.

It’s the right choice if we need to test for the match, but don’t need its position:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( &quot;Widget with id&quot;.includes(&quot;Widget&quot;) ); // true
alert( &quot;Hello&quot;.includes(&quot;Bye&quot;) ); // false</code>
  The optional second argument of <code>str.includes</code> is the position to start searching from:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( &quot;Midget&quot;.includes(&quot;id&quot;) ); // true
alert( &quot;Midget&quot;.includes(&quot;id&quot;, 3) ); // false, from position 3 there is no &quot;id&quot;</code>
  The methods <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith">str.startsWith</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith">str.endsWith</a> do exactly what they say:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( &quot;Widget&quot;.startsWith(&quot;Wid&quot;) ); // true, &quot;Widget&quot; starts with &quot;Wid&quot;
alert( &quot;Widget&quot;.endsWith(&quot;get&quot;) );   // true, &quot;Widget&quot; ends with &quot;get&quot;</code>
  <h2>Getting a substring</h2>
There are 3 methods in JavaScript to get a substring: <code>substring</code>, <code>substr</code> and <code>slice</code>.

<dl>
<dt><code>str.slice(start [, end])</code></dt>
<dd>

Returns the part of the string from <code>start</code> to (but not including) <code>end</code>.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let str = &quot;stringify&quot;;
alert( str.slice(0, 5) ); // 'strin', the substring from 0 to 5 (not including 5)
alert( str.slice(0, 1) ); // 's', from 0 to 1, but not including 1, so only character at 0</code>
  If there is no second argument, then <code>slice</code> goes till the end of the string:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let str = &quot;stringify&quot;;
alert( str.slice(2) ); // ringify, from the 2nd position till the end</code>
  Negative values for <code>start/end</code> are also possible. 
They mean the position is counted from the string end:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let str = &quot;stringify&quot;;
// start at the 4th position from the right, end at the 1st from the right
alert( str.slice(-4, -1) ); // gif</code>
  </dd>
<dt><code>str.substring(start [, end])</code></dt>
<dd>

Returns the part of the string <em>between</em> <code>start</code> and <code>end</code>.

This is almost the same as <code>slice</code>, but it allows <code>start</code> to be greater than <code>end</code>.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let str = &quot;stringify&quot;;
// these are same for substring
alert( str.substring(2, 6) ); // &quot;ring&quot;
alert( str.substring(6, 2) ); // &quot;ring&quot;
// ...but not for slice:
alert( str.slice(2, 6) ); // &quot;ring&quot; (the same)
alert( str.slice(6, 2) ); // &quot;&quot; (an empty string)</code>
  Negative arguments are (unlike slice) not supported, they are treated as <code>0</code>.

</dd>
<dt><code>str.substr(start [, length])</code></dt>
<dd>

Returns the part of the string from <code>start</code>, with the given <code>length</code>.

In contrast with the previous methods, this one allows us to specify the <code>length</code> instead of the ending position:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let str = &quot;stringify&quot;;
alert( str.substr(2, 4) ); // ring, from the 2nd position get 4 characters</code>
  The first argument may be negative, to count from the end:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let str = &quot;stringify&quot;;
alert( str.substr(-4, 2) ); // gi, from the 4th position get 2 characters</code>
  </dd>
</dl>

Let’s recap these methods to avoid any confusion:

<table>
<thead>
<tr>
<th>method</th>
<th>selects…</th>
<th>negatives</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>slice(start, end)</code></td>
<td>from <code>start</code> to <code>end</code> (not including <code>end</code>)</td>
<td>allows negatives</td>
</tr>
<tr>
<td><code>substring(start, end)</code></td>
<td>between <code>start</code> and <code>end</code></td>
<td>negative values mean <code>0</code></td>
</tr>
<tr>
<td><code>substr(start, length)</code></td>
<td>from <code>start</code> get <code>length</code> characters</td>
<td>allows negative <code>start</code></td>
</tr>
</tbody>
</table>

Which one to choose?
All of them can do the job. 
Formally, <code>substr</code> has a minor drawback: it is described not in the core JavaScript specification, but in Annex B, which covers browser-only features that exist mainly for historical reasons. 
So, non-browser environments may fail to support it. 
But in practice it works everywhere.

The author finds himself using <code>slice</code> almost all the time.

<h2>Comparing strings</h2>
As we know from the chapter <a href="/comparison">Comparisons</a>, strings are compared character-by-character in alphabetical order.

Although, there are some oddities.

<li>A lowercase letter is always greater than the uppercase:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( 'a' &gt; 'Z' ); // true</code>
  </li><li>Letters with diacritical marks are “out of order”:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( 'Österreich' &gt; 'Zealand' ); // true</code>
  This may lead to strange results if we sort these country names. 
Usually people would expect <code>Zealand</code> to come after <code>Österreich</code> in the list.

</li>

To understand what happens, let’s review the internal representation of strings in JavaScript.

All strings are encoded using <a href="https://en.wikipedia.org/wiki/UTF-16">UTF-16</a>. 
That is: each character has a corresponding numeric code. 
There are special methods that allow to get the character for the code and back.

<dl>
<dt><code>str.codePointAt(pos)</code></dt>
<dd>

Returns the code for the character at position <code>pos</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// different case letters have different codes
alert( &quot;z&quot;.codePointAt(0) ); // 122
alert( &quot;Z&quot;.codePointAt(0) ); // 90</code>
  </dd>
<dt><code>String.fromCodePoint(code)</code></dt>
<dd>

Creates a character by its numeric <code>code</code>

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( String.fromCodePoint(90) ); // Z</code>
  We can also add unicode characters by their codes using <code>\u</code> followed by the hex code:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// 90 is 5a in hexadecimal system
alert( '\u005a' ); // Z</code>
  </dd>
</dl>

Now let’s see the characters with codes <code>65..220</code> (the latin alphabet and a little bit extra) by making a string of them:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let str = '';
for (let i = 65; i &lt;= 220; i++) {
  str += String.fromCodePoint(i);
}
alert( str );
// ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
// ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜ</code>
  See? Capital characters go first, then a few special ones, then lowercase characters.

Now it becomes obvious why <code>a &gt; Z</code>.

The characters are compared by their numeric code. 
The greater code means that the character is greater. 
The code for <code>a</code> (97) is greater than the code for <code>Z</code> (90).

<li>All lowercase letters go after uppercase letters because their codes are greater.</li><li>Some letters like <code>Ö</code> stand apart from the main alphabet. 
Here, it’s code is greater than anything from <code>a</code> to <code>z</code>.</li>

<h3><a name="correct-comparisons" href="#correct-comparisons">Correct comparisons</a></h3>
The “right” algorithm to do string comparisons is more complex than it may seem, because alphabets are different for different languages. 
The same-looking letter may be located differently in different alphabets.

So, the browser needs to know the language to compare.

Luckily, all modern browsers (IE10- requires the additional library <a href="https://github.com/andyearnshaw/Intl.js/">Intl.JS</a>) support the internationalization standard <a href="http://www.ecma-international.org/ecma-402/1.0/ECMA-402.pdf">ECMA 402</a>.

It provides a special method to compare strings in different languages, following their rules.

The call <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare">str.localeCompare(str2)</a>:

<li>Returns <code>1</code> if <code>str</code> is greater than <code>str2</code> according to the language rules.</li><li>Returns <code>-1</code> if <code>str</code> is less than <code>str2</code>.</li><li>Returns <code>0</code> if they are equal.</li>

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( 'Österreich'.localeCompare('Zealand') ); // -1</code>
  This method actually has two additional arguments specified in <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare">the documentation</a>, which allows it to specify the language (by default taken from the environment) and setup additional rules like case sensitivity or should <code>&quot;a&quot;</code> and <code>&quot;á&quot;</code> be treated as the same etc.

<h2>Internals, Unicode</h2>

Advanced knowledge
The section goes deeper into string internals. 
This knowledge will be useful for you if you plan to deal with emoji, rare mathematical of hieroglyphs characters or other rare symbols.

You can skip the section if you don’t plan to support them.

<h3><a name="surrogate-pairs" href="#surrogate-pairs">Surrogate pairs</a></h3>
Most symbols have a 2-byte code. 
Letters in most european languages, numbers, and even most hieroglyphs, have a 2-byte representation.

But 2 bytes only allow 65536 combinations and that’s not enough for every possible symbol. 
So rare symbols are encoded with a pair of 2-byte characters called “a surrogate pair”.

The length of such symbols is <code>2</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( '𝒳'.length ); // 2, MATHEMATICAL SCRIPT CAPITAL X
alert( '😂'.length ); // 2, FACE WITH TEARS OF JOY
alert( '𩷶'.length ); // 2, a rare chinese hieroglyph</code>
  Note that surrogate pairs did not exist at the time when JavaScript was created, and thus are not correctly processed by the language!

We actually have a single symbol in each of the strings above, but the <code>length</code> shows a length of <code>2</code>.

<code>String.fromCodePoint</code> and <code>str.codePointAt</code> are few rare methods that deal with surrogate pairs right. 
They recently appeared in the language. 
Before them, there were only <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode">String.fromCharCode</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt">str.charCodeAt</a>. 
These methods are actually the same as <code>fromCodePoint/codePointAt</code>, but don’t work with surrogate pairs.

But, for instance, getting a symbol can be tricky, because surrogate pairs are treated as two characters:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( '𝒳'[0] ); // strange symbols...
alert( '𝒳'[1] ); // ...pieces of the surrogate pair</code>
  Note that pieces of the surrogate pair have no meaning without each other. 
So the alerts in the example above actually display garbage.

Technically, surrogate pairs are also detectable by their codes: if a character has the code in the interval of <code>0xd800..0xdbff</code>, then it is the first part of the surrogate pair. 
The next character (second part) must have the code in interval <code>0xdc00..0xdfff</code>. 
These intervals are reserved exclusively for surrogate pairs by the standard.

In the case above:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// charCodeAt is not surrogate-pair aware, so it gives codes for parts
alert( '𝒳'.charCodeAt(0).toString(16) ); // d835, between 0xd800 and 0xdbff
alert( '𝒳'.charCodeAt(1).toString(16) ); // dcb3, between 0xdc00 and 0xdfff</code>
  You will find more ways to deal with surrogate pairs later in the chapter <a href="/iterable">Iterables</a>. 
There are probably special libraries for that too, but nothing famous enough to suggest here.

<h3><a name="diacritical-marks-and-normalization" href="#diacritical-marks-and-normalization">Diacritical marks and normalization</a></h3>
In many languages there are symbols that are composed of the base character with a mark above/under it.

For instance, the letter <code>a</code> can be the base character for: <code>àáâäãåā</code>. 
Most common “composite” character have their own code in the UTF-16 table. 
But not all of them, because there are too many possible combinations.

To support arbitrary compositions, UTF-16 allows us to use several unicode characters. 
The base character and one or many “mark” characters that “decorate” it.

For instance, if we have <code>S</code> followed by the special “dot above” character (code <code>\u0307</code>), it is shown as Ṡ.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( 'S\u0307' ); // Ṡ</code>
  If we need an additional mark above the letter (or below it) – no problem, just add the necessary mark character.

For instance, if we append a character “dot below” (code <code>\u0323</code>), then we’ll have “S with dots above and below”: <code>Ṩ</code>.

For example:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( 'S\u0307\u0323' ); // Ṩ</code>
  This provides great flexibility, but also an interesting problem: two characters may visually look the same, but be represented with different unicode compositions.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( 'S\u0307\u0323' ); // Ṩ, S + dot above + dot below
alert( 'S\u0323\u0307' ); // Ṩ, S + dot below + dot above
alert( 'S\u0307\u0323' == 'S\u0323\u0307' ); // false</code>
  To solve this, there exists a “unicode normalization” algorithm that brings each string to the single “normal” form.

It is implemented by <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize">str.normalize()</a>.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( &quot;S\u0307\u0323&quot;.normalize() == &quot;S\u0323\u0307&quot;.normalize() ); // true</code>
  It’s funny that in our situation <code>normalize()</code> actually brings together a sequence of 3 characters to one: <code>\u1e68</code> (S with two dots).

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( &quot;S\u0307\u0323&quot;.normalize().length ); // 1
alert( &quot;S\u0307\u0323&quot;.normalize() == &quot;\u1e68&quot; ); // true</code>
  In reality, this is not always the case. 
The reason being that the symbol <code>Ṩ</code> is “common enough”, so UTF-16 creators included it in the main table and gave it the code.

If you want to learn more about normalization rules and variants – they are described in the appendix of the Unicode standard: <a href="http://www.unicode.org/reports/tr15/">Unicode Normalization Forms</a>, but for most practical purposes the information from this section is enough.

<h4><a name="summary" href="#summary">Summary</a></h4><li>There are 3 types of quotes. 
Backticks allow a string to span multiple lines and embed expressions.</li><li>Strings in JavaScript are encoded using UTF-16.</li><li>We can use special characters like <code>\n</code> and insert letters by their unicode using <code>\u...</code>.</li><li>To get a character, use: <code>[]</code>.</li><li>To get a substring, use: <code>slice</code> or <code>substring</code>.</li><li>To lowercase/uppercase a string, use: <code>toLowerCase/toUpperCase</code>.</li><li>To look for a substring, use: <code>indexOf</code>, or <code>includes/startsWith/endsWith</code> for simple checks.</li><li>To compare strings according to the language, use: <code>localeCompare</code>, otherwise they are compared by character codes.</li>

There are several other helpful methods in strings:

<li><code>str.trim()</code> – removes (“trims”) spaces from the beginning and end of the string.</li><li><code>str.repeat(n)</code> – repeats the string <code>n</code> times.</li><li>…and more. 
See the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String">manual</a> for details.</li>

Strings also have methods for doing search/replace with regular expressions. 
But that topic deserves a separate chapter, so we’ll return to that later.

    <code>ucFirst(&quot;john&quot;) == &quot;John&quot;;</code>
  <a href="http://plnkr.co/edit/jkpZQpTFUjZoY3nFhzfm?p=preview" target="_blank" data-plunk-id="jkpZQpTFUjZoY3nFhzfm">Open the sandbox with tests.</a>
<button type="button">solution</button>

We can’t “replace” the first character, because strings in JavaScript are immutable.

But we can make a new string based on the existing one, with the uppercased first character:

    <code>let newStr = str[0].toUpperCase() + str.slice(1);</code>
  There’s a small problem though. 
If <code>str</code> is empty, then <code>str[0]</code> is undefined, so we’ll get an error.

There are two variants here:

<li>Use <code>str.charAt(0)</code>, as it always returns a string (maybe empty).</li><li>Add a test for an empty string.</li>

Here’s the 2nd variant:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function ucFirst(str) {
  if (!str) return str;
  return str[0].toUpperCase() + str.slice(1);
}
alert( ucFirst(&quot;john&quot;) ); // John</code>
  <a href="http://plnkr.co/edit/L846AsiE1zo0jJxT1T9D?p=preview" target="_blank" data-plunk-id="L846AsiE1zo0jJxT1T9D">Open the solution with tests in the sandbox.</a>
<button type="button" title="close"></button>

<h3><a href="#check-for-spam" name="check-for-spam">Check for spam</a></h3><a href="/task/check-spam" target="_blank"></a>

importance: 5

Write a function <code>checkSpam(str)</code> that returns <code>true</code> if <code>str</code> contains ‘viagra’ or ‘XXX’, otherwise `false.

The function must be case-insensitive:

    <code>checkSpam('buy ViAgRA now') == true
checkSpam('free xxxxx') == true
checkSpam(&quot;innocent rabbit&quot;) == false</code>
  <a href="http://plnkr.co/edit/cwgXbZg4juEn9vtteRDl?p=preview" target="_blank" data-plunk-id="cwgXbZg4juEn9vtteRDl">Open the sandbox with tests.</a>
<button type="button">solution</button>

To make the search case-insensitive, let’s bring the stirng to lower case and then search:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function checkSpam(str) {
  let lowerStr = str.toLowerCase();
  return lowerStr.includes('viagra') || lowerStr.includes('xxx');
}
alert( checkSpam('buy ViAgRA now') );
alert( checkSpam('free xxxxx') );
alert( checkSpam(&quot;innocent rabbit&quot;) );</code>
  <a href="http://plnkr.co/edit/zsYta2ZnunXtzA7JzgCb?p=preview" target="_blank" data-plunk-id="zsYta2ZnunXtzA7JzgCb">Open the solution with tests in the sandbox.</a>
<button type="button" title="close"></button>

<h3><a href="#truncate-the-text" name="truncate-the-text">Truncate the text</a></h3><a href="/task/truncate" target="_blank"></a>

importance: 5

Create a function <code>truncate(str, maxlength)</code> that checks the length of the <code>str</code> and, if it exceeds <code>maxlength</code> – replaces the end of <code>str</code> with the ellipsis character <code>&quot;…&quot;</code>, to make its length equal to <code>maxlength</code>.

The result of the function should be the truncated (if needed) string.

For instance:

    <code>truncate(&quot;What I'd like to tell on this topic is:&quot;, 20) = &quot;What I'd like to te…&quot;
truncate(&quot;Hi everyone!&quot;, 20) = &quot;Hi everyone!&quot;</code>
  <a href="http://plnkr.co/edit/WtKSHCRrcylXOBhfWsyd?p=preview" target="_blank" data-plunk-id="WtKSHCRrcylXOBhfWsyd">Open the sandbox with tests.</a>
<button type="button">solution</button>

The maximal length must be <code>maxlength</code>, so we need to cut it a little shorter, to give space for the ellipsis.

Note that there is actually a single unicode character for an ellipsis. 
That’s not three dots.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function truncate(str, maxlength) {
  return (str.length &gt; maxlength) ?
    str.slice(0, maxlength - 1) + '…' : str;
}</code>
  <a href="http://plnkr.co/edit/cBh7vhFKodMBs0Cw3WFV?p=preview" target="_blank" data-plunk-id="cBh7vhFKodMBs0Cw3WFV">Open the solution with tests in the sandbox.</a>
<button type="button" title="close"></button>

<h3><a href="#extract-the-money" name="extract-the-money">Extract the money</a></h3><a href="/task/extract-currency" target="_blank"></a>

importance: 4

We have a cost in the form <code>&quot;$120&quot;</code>. 
That is: the dollar sign goes first, and then the number.

Create a function <code>extractCurrencyValue(str)</code> that would extract the numeric value from such string and return it.

The example:

    <code>alert( extractCurrencyValue('$120') === 120 ); // true</code>
  <a href="http://plnkr.co/edit/DgSPKmfmQC18ApAYLxMr?p=preview" target="_blank" data-plunk-id="DgSPKmfmQC18ApAYLxMr">Open the sandbox with tests.</a>
<button type="button">solution</button>

<a href="http://plnkr.co/edit/ME8EVErxR2UErybCOKIz?p=preview" target="_blank" data-plunk-id="ME8EVErxR2UErybCOKIz">Open the solution with tests in the sandbox.</a>
<button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/number" data-tooltip="Numbers">Previous lesson</a><a href="/array" data-tooltip="Arrays">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Fstring"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Fstring"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Fstring"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Fstring"></a>

Objects allow to store keyed collections of values. 
That’s fine.

But quite often we find that we need an <em>ordered collection</em>, where we have a 1st, a 2nd, a 3rd element and so on. 
For example, we need that to store a list of something: users, goods, HTML elements etc.

It is not convenient to use an object here, because it provides no methods to manage the order of elements. 
We can’t insert a new property “between” the existing ones. 
Objects are just not meant for such use.

There exists a special data structure named <code>Array</code>, to store ordered collections.

<h2>Declaration</h2>
There are two syntaxes for creating an empty array:

    <code>let arr = new Array();
let arr = [];</code>
  Almost all the time, the second syntax is used. 
We can supply initial elements in the brackets:

    <code>let fruits = [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Plum&quot;];</code>
  Array elements are numbered, starting with zero.

We can get an element by its number in square brackets:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let fruits = [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Plum&quot;];
alert( fruits[0] ); // Apple
alert( fruits[1] ); // Orange
alert( fruits[2] ); // Plum</code>
  We can replace an element:

    <code>fruits[2] = 'Pear'; // now [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Pear&quot;]</code>
  …Or add a new one to the array:

    <code>fruits[3] = 'Lemon'; // now [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Lemon&quot;]</code>
  The total count of the elements in the array is its <code>length</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let fruits = [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Plum&quot;];
alert( fruits.length ); // 3</code>
  We can also use <code>alert</code> to show the whole array.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let fruits = [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Plum&quot;];
alert( fruits ); // Apple,Orange,Plum</code>
  An array can store elements of any type.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// mix of values
let arr = [ 'Apple', { name: 'John' }, true, function() { alert('hello'); } ];
// get the object at index 1 and then show its name
alert( arr[1].name ); // John
// get the function at index 3 and run it
arr[3](); // hello</code>
  
Trailing comma
An array, just like an object, may end with a comma:

    <code>let fruits = [
  &quot;Apple&quot;,
  &quot;Orange&quot;,
  &quot;Plum&quot;,
];</code>
  The “trailing comma” style makes it easier to insert/remove items, because all lines become alike.

<h2>Methods pop/push, shift/unshift</h2>
A <a href="https://en.wikipedia.org/wiki/Queue_(abstract_data_type)">queue</a> is one of most common uses of an array. 
In computer science, this means an ordered collection of elements which supports two operations:

<li><code>push</code> appends an element to the end.</li><li><code>shift</code> get an element from the beginning, advancing the queue, so that the 2nd element becomes the 1st.</li>

<img src="https://javascript.info/article/array/queue.png">
Arrays support both operations.

In practice we meet it very often. 
For example, a queue of messages that need to be shown on-screen.

There’s another use case for arrays – the data structure named <a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)">stack</a>.

It supports two operations:

<li><code>push</code> adds an element to the end.</li><li><code>pop</code> takes an element from the end.</li>

So new elements are added or taken always from the “end”.

A stack is usually illustrated as a pack of cards: new cards are added to the top or taken from the top:

<img src="https://javascript.info/article/array/stack.png">
For stacks, the latest pushed item is received first, that’s also called LIFO (Last-In-First-Out) principle. 
For queues, we have FIFO (First-In-First-Out).

Arrays in JavaScript can work both as a queue and as a stack. 
They allow to add/remove elements both to/from the beginning or the end.

In computer science the data structure that allows it is called <a href="https://en.wikipedia.org/wiki/Double-ended_queue">deque</a>.

<strong>Methods that work with the end of the array:</strong>

<dl>
<dt><code>pop</code></dt>
<dd>

Extracts the last element of the array and returns it:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let fruits = [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Pear&quot;];
alert( fruits.pop() ); // remove &quot;Pear&quot; and alert it
alert( fruits ); // Apple, Orange</code>
  </dd>
<dt><code>push</code></dt>
<dd>

Append the element to the end of the array:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let fruits = [&quot;Apple&quot;, &quot;Orange&quot;];
fruits.push(&quot;Pear&quot;);
alert( fruits ); // Apple, Orange, Pear</code>
  The call <code>fruits.push(...)</code> is equal to <code>fruits[fruits.length] = ...</code>.

</dd>
</dl>

<strong>Methods that work with the beginning of the array:</strong>

<dl>
<dt><code>shift</code></dt>
<dd>

Extracts the first element of the array and returns it:

    <code>let fruits = [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Pear&quot;];
alert( fruits.shift() ); // remove Apple and alert it
alert( fruits ); // Orange, Pear</code>
  </dd>
<dt><code>unshift</code></dt>
<dd>

Add the element to the beginning of the array:

    <code>let fruits = [&quot;Orange&quot;, &quot;Pear&quot;];
fruits.unshift('Apple');
alert( fruits ); // Apple, Orange, Pear</code>
  </dd>
</dl>

Methods <code>push</code> and <code>unshift</code> can add multiple elements at once:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let fruits = [&quot;Apple&quot;];
fruits.push(&quot;Orange&quot;, &quot;Peach&quot;);
fruits.unshift(&quot;Pineapple&quot;, &quot;Lemon&quot;);
// [&quot;Pineapple&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Orange&quot;, &quot;Peach&quot;]
alert( fruits );</code>
  <h2>Internals</h2>
An array is a special kind of object. 
The square brackets used to access a property <code>arr[0]</code> actually come from the object syntax. 
Numbers are used as keys.

They extend objects providing special methods to work with ordered collections of data and also the <code>length</code> property. 
But at the core it’s still an object.

Remember, there are only 7 basic types in JavaScript. 
Array is an object and thus behaves like an object.

For instance, it is copied by reference:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let fruits = [&quot;Banana&quot;]
let arr = fruits; // copy by reference (two variables reference the same array)
alert( arr === fruits ); // true
arr.push(&quot;Pear&quot;); // modify the array by reference
alert( fruits ); // Banana, Pear - 2 items now</code>
  …But what makes arrays really  special is their internal representation. 
The engine tries to store its elements in the contiguous memory area, one after another, just as depicted on the illustrations in this chapter, and there are other optimizations as well, to make arrays work really fast.

But they all break if we quit working with an array as with an “ordered collection” and start working with it as if it were a regular object.

For instance, technically we can do this:

    <code>let fruits = []; // make an array
fruits[99999] = 5; // assign a property with the index far greater than its length
fruits.age = 25; // create a property with an arbitrary name</code>
  That’s possible, because arrays are objects at their base. 
We can add any properties to them.

But the engine will see that we’re working with the array as with a regular object. 
Array-specific optimizations are not suited for such cases and will be turned off, their benefits disappear.

The ways to misuse an array:

<li>Add a non-numeric property like <code>arr.test = 5</code>.</li><li>Make holes, like: add <code>arr[0]</code> and then <code>arr[1000]</code> (and nothing between them).</li><li>Fill the array in the reverse order, like <code>arr[1000]</code>, <code>arr[999]</code> and so on.</li>

Please think of arrays as special structures to work with the <em>ordered data</em>. 
They provide special methods for that. 
Arrays are carefully tuned inside JavaScript engines to work with contiguous ordered data, please use them this way. 
And if you need arbitrary keys, chances are high that you actually require a regular object <code>{}</code>.

<h2>Performance</h2>
Methods <code>push/pop</code> run fast, while <code>shift/unshift</code> are slow.

<img src="https://javascript.info/article/array/array-speed.png">
Why is it faster to work with the end of an array than with its beginning? Let’s see what happens during the execution:

    <code>fruits.shift(); // take 1 element from the start</code>
  It’s not enough to take and remove the element with the number <code>0</code>. 
Other elements need to be renumbered as well.

The <code>shift</code> operation must do 3 things:

<li>Remove the element with the index <code>0</code>.</li><li>Move all elements to the left, renumber them from the index <code>1</code> to <code>0</code>, from <code>2</code> to <code>1</code> and so on.</li><li>Update the <code>length</code> property.</li>

<img src="https://javascript.info/article/array/array-shift.png">
<strong>The more elements in the array, the more time to move them, more in-memory operations.</strong>

The similar thing happens with <code>unshift</code>: to add an element to the beginning of the array, we need first to move existing elements to the right, increasing their indexes.

And what’s with <code>push/pop</code>? They do not need to move anything. 
To extract an element from the end, the <code>pop</code> method cleans the index and shortens <code>length</code>.

The actions for the <code>pop</code> operation:

    <code>fruits.pop(); // take 1 element from the end</code>
  

<img src="https://javascript.info/article/array/array-pop.png">
<strong>The <code>pop</code> method does not need to move anything, because other elements keep their indexes. 
That’s why it’s blazingly fast.</strong>

The similar thing with the <code>push</code> method.

<h2>Loops</h2>
One of the oldest ways to cycle array items is the <code>for</code> loop over indexes:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let arr = [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Pear&quot;];
for (let i = 0; i &lt; arr.length; i++) {
  alert( arr[i] );
}</code>
  But for arrays there is another form of loop, <code>for..of</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let fruits = [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Plum&quot;];
// iterates over array elements
for (let fruit of fruits) {
  alert( fruit );
}</code>
  The <code>for..of</code> doesn’t give access to the number of the current element, just its value, but in most cases that’s enough. 
And it’s shorter.

Technically, because arrays are objects, it is also possible to use <code>for..in</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let arr = [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Pear&quot;];
for (let key in arr) {
  alert( arr[key] ); // Apple, Orange, Pear
}</code>
  But that’s actually a bad idea. 
There are potential problems with it:

<li>The loop <code>for..in</code> iterates over <em>all properties</em>, not only the numeric ones.

There are so-called “array-like” objects in the browser and in other environments, that <em>look like arrays</em>. 
That is, they have <code>length</code> and indexes properties, but they may also have other non-numeric properties and methods, which we usually don’t need. 
The <code>for..in</code> loop will list them though. 
So if we need to work with array-like objects, then these “extra” properties can become a problem.

</li><li>The <code>for..in</code> loop is optimized for generic objects, not arrays, and thus is 10-100 times slower. 
Of course, it’s still very fast. 
The speedup may matter only in bottlenecks or just irrelevant. 
But still we should be aware of the difference.

</li>

Generally, we shouldn’t use <code>for..in</code> for arrays.

<h2>A word about “length”</h2>
The <code>length</code> property automatically updates when we modify the array. 
To be precise, it is actually not the count of values in the array, but the greatest numeric index plus one.

For instance, a single element with a large index gives a big length:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let fruits = [];
fruits[123] = &quot;Apple&quot;;
alert( fruits.length ); // 124</code>
  Note that we usually don’t use arrays like that.

Another interesting thing about the <code>length</code> property is that it’s writable.

If we increase it manually, nothing interesting happens. 
But if we decrease it, the array is truncated. 
The process is irreversible, here’s the example:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let arr = [1, 2, 3, 4, 5];
arr.length = 2; // truncate to 2 elements
alert( arr ); // [1, 2]
arr.length = 5; // return length back
alert( arr[3] ); // undefined: the values do not return</code>
  So, the simplest way to clear the array is: <code>arr.length = 0;</code>.

<h2>new Array()</h2>
There is one more syntax to create an array:

    <code>let arr = new Array(&quot;Apple&quot;, &quot;Pear&quot;, &quot;etc&quot;);</code>
  It’s rarely used, because square brackets <code>[]</code> are shorter. 
Also there’s a tricky feature with it.

If <code>new Array</code> is called with a single argument which is a number, then it creates an array <em>without items, but with the given length</em>.

Let’s see how one can shoot himself in the foot:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let arr = new Array(2); // will it create an array of [2] ?
alert( arr[0] ); // undefined! no elements.
alert( arr.length ); // length 2</code>
  In the code above, <code>new Array(number)</code> has all elements <code>undefined</code>.

To evade such surprises, we usually use square brackets, unless we really know what we’re doing.

<h2>Multidimensional arrays</h2>
Arrays can have items that are also arrays. 
We can use it for multidimensional arrays, to store matrices:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];
alert( matrix[1][1] ); // the central element</code>
  <h2>toString</h2>
Arrays have their own implementation of <code>toString</code> method that returns a comma-separated list of elements.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let arr = [1, 2, 3];
alert( arr ); // 1,2,3
alert( String(arr) === '1,2,3' ); // true</code>
  Also, let’s try this:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( [] + 1 ); // &quot;1&quot;
alert( [1] + 1 ); // &quot;11&quot;
alert( [1,2] + 1 ); // &quot;1,21&quot;</code>
  Arrays do not have <code>Symbol.toPrimitive</code>, neither a viable <code>valueOf</code>, they implement only <code>toString</code> conversion, so here <code>[]</code> becomes an empty string, <code>[1]</code> becomes <code>&quot;1&quot;</code> and <code>[1,2]</code> becomes <code>&quot;1,2&quot;</code>.

When the binary plus <code>&quot;+&quot;</code> operator adds something to a string, it converts it to a string as well, so the next step looks like this:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( &quot;&quot; + 1 ); // &quot;1&quot;
alert( &quot;1&quot; + 1 ); // &quot;11&quot;
alert( &quot;1,2&quot; + 1 ); // &quot;1,21&quot;</code>
  <h4><a name="summary" href="#summary">Summary</a4</h2>
Array is a special kind of objects, suited to store and manage ordered data items.

<li>The declaration:

    <code>// square brackets (usual)
let arr = [item1, item2...];
// new Array (exceptionally rare)
let arr = new Array(item1, item2...);</code>
  The call to <code>new Array(number)</code> creates an array with the given length, but without elements.

</li><li>The <code>length</code> property is the array length or, to be precise, its last numeric index plus one. 
It is auto-adjusted by array methods.

</li><li>If we shorten <code>length</code> manually, the array is truncated.

</li>

We can use an array as a deque with the following operations:

<li><code>push(...items)</code> adds <code>items</code> to the end.</li><li><code>pop()</code> removes the element from the end and returns it.</li><li><code>shift()</code> removes the element from the beginning and returns it.</li><li><code>unshift(...items)</code> adds items to the beginning.</li>

To loop over the elements of the array:

<li><code>for (let i=0; i&lt;arr.length; i++)</code> – works fastest, old-browser-compatible.</li><li><code>for (let item of arr)</code> – the modern syntax for items only,</li><li><code>for (let i in arr)</code> – never use.</li>

We will return to arrays and study more methods to add, remove, extract elements and sort arrays in the chapter <a href="/array-methods">Array methods</a>.

    <code>let fruits = [&quot;Apples&quot;, &quot;Pear&quot;, &quot;Orange&quot;];
// push a new value into the &quot;copy&quot;
let shoppingCart = fruits;
shoppingCart.push(&quot;Banana&quot;);
// what's in fruits?
alert( fruits.length ); // ?</code>
  <button type="button">solution</button>

The result is <code>4</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let fruits = [&quot;Apples&quot;, &quot;Pear&quot;, &quot;Orange&quot;];
let shoppingCart = fruits;
shoppingCart.push(&quot;Banana&quot;);
alert( fruits.length ); // 4</code>
  That’s because arrays are objects. 
So both <code>shoppingCart</code> and <code>fruits</code> are the references to the same array.

<button type="button" title="close"></button>

<h3><a href="#array-operations" name="array-operations">Array operations.</a></h3><a href="/task/create-array" target="_blank"></a>

importance: 5

Let’s try 5 array operations.

<li>Create an array <code>styles</code> with items “Jazz” and “Blues”.</li><li>Append “Rock-n-Roll” to the end.</li><li>Replace the value in the middle by “Classics”. 
Your code for finding the middle value should work for any arrays with odd length.</li><li>Strip off the first value of the array and show it.</li><li>Prepend <code>Rap</code> and <code>Reggae</code> to the array.</li>

The array in the process:

    <code>Jazz, Blues
Jazz, Bues, Rock-n-Roll
Jazz, Classics, Rock-n-Roll
Classics, Rock-n-Roll
Rap, Reggae, Classics, Rock-n-Roll</code>
  <button type="button">solution</button>

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let styles = [&quot;Jazz&quot;, &quot;Blues&quot;];
styles.push(&quot;Rock-n-Roll&quot;);
styles[Math.floor((styles.length - 1) / 2)] = &quot;Classics&quot;;
alert( styles.shift() );
styles.unshift(&quot;Rap&quot;, &quot;Reggie&quot;);</code>
  <button type="button" title="close"></button>

<h3><a href="#calling-in-an-array-context" name="calling-in-an-array-context">Calling in an array context</a></h3><a href="/task/call-array-this" target="_blank"></a>

importance: 5

What is the result? Why?

    <code>let arr = [&quot;a&quot;, &quot;b&quot;];
arr.push(function() {
  alert( this );
})
arr[2](); // ?</code>
  <button type="button">solution</button>

The call <code>arr[2]()</code> is syntactically the good old <code>obj[method]()</code>, in the role of <code>obj</code> we have <code>arr</code>, and in the role of <code>method</code> we have <code>2</code>.

So we have a call of the function <code>arr[2]</code> as an object method. 
Naturally, it receives <code>this</code> referencing the object <code>arr</code> and outputs the array:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let arr = [&quot;a&quot;, &quot;b&quot;];
arr.push(function() {
  alert( this );
})
arr[2](); // &quot;a&quot;,&quot;b&quot;,function</code>
  The array has 3 values: initially it had two, plus the function.

<button type="button" title="close"></button>

<h3><a href="#sum-input-numbers" name="sum-input-numbers">Sum input numbers</a></h3><a href="/task/array-input-sum" target="_blank"></a>

importance: 4

Write the function <code>sumInput()</code> that:

<li>Asks the user for values using <code>prompt</code> and stores the values in the array.</li><li>Finishes asking when the user enters a non-numeric value, an empty string, or presses “Cancel”.</li><li>Calculates and returns the sum of array items.</li>

P.S. 
A zero <code>0</code> is a valid number, please don’t stop the input on zero.

<a href="#" onclick="event.preventDefault(); runDemo(this)">Run the demo</a>
<button type="button">solution</button>

Please note the subtle, but important detail of the solution. 
We don’t convert <code>value</code> to number instantly after <code>prompt</code>, because after <code>value = +value</code> we would not be able to tell an empty string (stop sign) from the zero (valid number). 
We do it later instead.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function sumInput() {
  let numbers = [];
  while (true) {
    let value = prompt(&quot;A number please?&quot;, 0);
    // should we cancel?
    if (value === &quot;&quot; || value === null || !isFinite(value)) break;
    numbers.push(+value);
  }
  let sum = 0;
  for (let number of numbers) {
    sum += number;
  }
  return sum;
}
alert( sumInput() );</code>
  <button type="button" title="close"></button>

<h3><a href="#a-maximal-subarray" name="a-maximal-subarray">A maximal subarray</a></h3><a href="/task/maximal-subarray" target="_blank"></a>

importance: 2

The input is an array of numbers, e.g. 
<code>arr = [1, -2, 3, 4, -9, 6]</code>.

The task is: find the contiguous subarray of <code>arr</code> with the maximal sum of items.

Write the function <code>getMaxSubSum(arr)</code> that will find return that sum.

For instance:

    <code>getMaxSubSum([-1, 2, 3, -9]) = 5 (the sum of highlighted items)
getMaxSubSum([2, -1, 2, 3, -9]) = 6
getMaxSubSum([-1, 2, 3, -9, 11]) = 11
getMaxSubSum([-2, -1, 1, 2]) = 3
getMaxSubSum([100, -9, 2, -3, 5]) = 100
getMaxSubSum([1, 2, 3]) = 6 (take all)</code>
  If all items are negative, it means that we take none (the subarray is empty), so the sum is zero:

    <code>getMaxSubSum([-1, -2, -3]) = 0</code>
  Please try to think of a fast solution: <a href="https://en.wikipedia.org/wiki/Big_O_notation">O(n<sup>2</sup>)</a> or even O(n) if you can.

<a href="http://plnkr.co/edit/UHrd7pOZxSmJgM2hvLyU?p=preview" target="_blank" data-plunk-id="UHrd7pOZxSmJgM2hvLyU">Open the sandbox with tests.</a>
<button type="button">solution</button>

<button type="button" onclick="showStep(this)">The slow solution</button>

<h4>The slow solution</h4>
We can calculate all possible subsums.

The simplest way is to take every element and calculate sums of all subarrays starting from it.

For instance, for <code>[-1, 2, 3, -9, 11]</code>:

    <code>// Starting from -1:
-1
-1 + 2
-1 + 2 + 3
-1 + 2 + 3 + (-9)
-1 + 2 + 3 + (-9) + 11
// Starting from 2:
2
2 + 3
2 + 3 + (-9)
2 + 3 + (-9) + 11
// Starting from 3:
3
3 + (-9)
3 + (-9) + 11
// Starting from -9
-9
-9 + 11
// Starting from -11
-11</code>
  The code is actually a nested loop: the external loop over array elements, and the internal counts subsums starting with the current element.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function getMaxSubSum(arr) {
  let maxSum = 0; // if we take no elements, zero will be returned
  for (let i = 0; i &lt; arr.length; i++) {
    let sumFixedStart = 0;
    for (let j = i; j &lt; arr.length; j++) {
sumFixedStart += arr[j];
maxSum = Math.max(maxSum, sumFixedStart);
    }
  }
  return maxSum;
}
alert( getMaxSubSum([-1, 2, 3, -9]) ); // 5
alert( getMaxSubSum([-1, 2, 3, -9, 11]) ); // 11
alert( getMaxSubSum([-2, -1, 1, 2]) ); // 3
alert( getMaxSubSum([1, 2, 3]) ); // 6
alert( getMaxSubSum([100, -9, 2, -3, 5]) ); // 100</code>
  The solution has a time complexety of <a href="https://en.wikipedia.org/wiki/Big_O_notation">O(n<sup>2</sup>)</a>. 
In other words, if we increase the array size 2 times, the algorithm will work 4 times longer.

For big arrays (1000, 10000 or more items) such algorithms can lead to a seroius sluggishness.

<button type="button" onclick="showStep(this)">Fast solution</button>

<h4>Fast solution</h4>
Let’s walk the array and keep the current partial sum of elements in the variable <code>s</code>. 
If <code>s</code> becomes negative at some point, then assign <code>s=0</code>. 
The maximum of all such <code>s</code> will be the answer.

If the description is too vague, please see the code, it’s short enough:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function getMaxSubSum(arr) {
  let maxSum = 0;
  let partialSum = 0;
  for (let item of arr) { // for each item of arr
    partialSum += item; // add it to partialSum
    maxSum = Math.max(maxSum, partialSum); // remember the maximum
    if (partialSum &lt; 0) partialSum = 0; // zero if negative
  }
  return maxSum;
}
alert( getMaxSubSum([-1, 2, 3, -9]) ); // 5
alert( getMaxSubSum([-1, 2, 3, -9, 11]) ); // 11
alert( getMaxSubSum([-2, -1, 1, 2]) ); // 3
alert( getMaxSubSum([100, -9, 2, -3, 5]) ); // 100
alert( getMaxSubSum([1, 2, 3]) ); // 6
alert( getMaxSubSum([-1, -2, -3]) ); // 0</code>
  The algorithm requires exactly 1 array pass, so the time complexity is O(n).

You can find more detail information about the algorithm here: <a href="http://en.wikipedia.org/wiki/Maximum_subarray_problem">Maximum subarray problem</a>. 
If it’s still not obvious why that works, then please trace the algorithm on the examples above, see how it works, that’s better than any words.

<a href="http://plnkr.co/edit/6cxNY5xLMMtuoEYfgeD5?p=preview" target="_blank" data-plunk-id="6cxNY5xLMMtuoEYfgeD5">Open the solution with tests in the sandbox.</a>
<button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/string" data-tooltip="Strings">Previous lesson</a><a href="/array-methods" data-tooltip="Array methods">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Farray"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Farray"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Farray"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Farray"></a>

Arrays provide a lot of methods. 
To make things easier, in this chapter they are split into groups.

<h2>Add/remove items</h2>
We already know methods that add and remove items from the beginning or the end:

<li><code>arr.push(...items)</code> – adds items to the end,</li><li><code>arr.pop()</code> – extracts an item from the end,</li><li><code>arr.shift()</code> – extracts an item from the beginning,</li><li><code>arr.unshift(...items)</code> – adds items to the beginning.</li>

Here are few others.

<h3><a name="splice" href="#splice">splice</a></h3>
How to delete an element from the array?

The arrays are objects, so we can try to use <code>delete</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let arr = [&quot;I&quot;, &quot;go&quot;, &quot;home&quot;];
delete arr[1]; // remove &quot;go&quot;
alert( arr[1] ); // undefined
// now arr = [&quot;I&quot;,  , &quot;home&quot;];
alert( arr.length ); // 3</code>
  The element was removed, but the array still has 3 elements, we can see that <code>arr.length == 3</code>.

That’s natural, because <code>delete obj.key</code> removes a value by the <code>key</code>. 
It’s all it does. 
Fine for objects. 
But for arrays we usually want the rest of elements to shift and occupy the freed place. 
We expect to have a shorter array now.

So, special methods should be used.

The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice">arr.splice(str)</a> method is a swiss army knife for arrays. 
It can do everything: add, remove and insert elements.

The syntax is:

    <code>arr.splice(index[, deleteCount, elem1, ..., elemN])</code>
  It starts from the position <code>index</code>: removes <code>deleteCount</code> elements and then inserts <code>elem1, ..., elemN</code> at their place. 
Returns the array of removed elements.

This method is easy to grasp by examples.

Let’s start with the deletion:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let arr = [&quot;I&quot;, &quot;study&quot;, &quot;JavaScript&quot;];
arr.splice(1, 1); // from index 1 remove 1 element
alert( arr ); // [&quot;I&quot;, &quot;JavaScript&quot;]</code>
  Easy, right? Starting from the index <code>1</code> it removed <code>1</code> element.

In the next example we remove 3 elements and replace them with the other two:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let arr = [&quot;I&quot;, &quot;study&quot;, &quot;JavaScript&quot;, &quot;right&quot;, &quot;now&quot;];
// remove 3 first elements and replace them with another
arr.splice(0, 3, &quot;Let's&quot;, &quot;dance&quot;);
alert( arr ) // now [&quot;Let's&quot;, &quot;dance&quot;, &quot;right&quot;, &quot;now&quot;]</code>
  Here we can see that <code>splice</code> returns the array of removed elements:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let arr = [&quot;I&quot;, &quot;study&quot;, &quot;JavaScript&quot;, &quot;right&quot;, &quot;now&quot;];
// remove 2 first elements
let removed = arr.splice(0, 2);
alert( removed ); // &quot;I&quot;, &quot;study&quot; &lt;-- array of removed elements</code>
  The <code>splice</code> method is also able to insert the elements without any removals. 
For that we need to set <code>deleteCount</code> to <code>0</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let arr = [&quot;I&quot;, &quot;study&quot;, &quot;JavaScript&quot;];
// from index 2
// delete 0
// then insert &quot;complex&quot; and &quot;language&quot;
arr.splice(2, 0, &quot;complex&quot;, &quot;language&quot;);
alert( arr ); // &quot;I&quot;, &quot;study&quot;, &quot;complex&quot;, &quot;language&quot;, &quot;JavaScript&quot;</code>
  
Negative indexes allowed
Here and in other array methods, negative indexes are allowed. 
They specify the position from the end of the array, like here:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let arr = [1, 2, 5];
// from index -1 (one step from the end)
// delete 0 elements,
// then insert 3 and 4
arr.splice(-1, 0, 3, 4);
alert( arr ); // 1,2,3,4,5</code>
  
<h3><a name="slice" href="#slice">slice</a></h3>
The method <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice">arr.slice</a> is much simpler than similar-looking <code>arr.splice</code>.

The syntax is:

    <code>arr.slice(start, end)</code>
  It returns a new array where it copies all items start index <code>&quot;start&quot;</code> to <code>&quot;end&quot;</code> (not including <code>&quot;end&quot;</code>). 
Both <code>start</code> and <code>end</code> can be negative, in that case position from array end is assumed.

It works like <code>str.slice</code>, but makes subarrays instead of substrings.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let str = &quot;test&quot;;
let arr = [&quot;t&quot;, &quot;e&quot;, &quot;s&quot;, &quot;t&quot;];
alert( str.slice(1, 3) ); // es
alert( arr.slice(1, 3) ); // e,s
alert( str.slice(-2) ); // st
alert( arr.slice(-2) ); // s,t</code>
  <h3><a name="concat" href="#concat">concat</a></h3>
The method <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat">arr.concat</a> joins the array with other arrays and/or items.

The syntax is:

    <code>arr.concat(arg1, arg2...)</code>
  It accepts any number of arguments – either arrays or values.

The result is a new array containing items from <code>arr</code>, then <code>arg1</code>, <code>arg2</code> etc.

If an argument is an array or has <code>Symbol.isConcatSpreadable</code> property, then all its elements are copied. 
Otherwise, the argument itself is copied.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let arr = [1, 2];
// merge arr with [3,4]
alert( arr.concat([3, 4])); // 1,2,3,4
// merge arr with [3,4] and [5,6]
alert( arr.concat([3, 4], [5, 6])); // 1,2,3,4,5,6
// merge arr with [3,4], then add values 5 and 6
alert( arr.concat([3, 4], 5, 6)); // 1,2,3,4,5,6</code>
  Normally, it only copies elements from arrays (“spreads” them). 
Other objects, even if they look like arrays, added as a whole:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let arr = [1, 2];
let arrayLike = {
  0: &quot;something&quot;,
  length: 1
};
alert( arr.concat(arrayLike) ); // 1,2,[object Object]
//[1, 2, arrayLike]</code>
  …But if an array-like object has <code>Symbol.isConcatSpreadable</code> property, then its elements are added instead:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let arr = [1, 2];
let arrayLike = {
  0: &quot;something&quot;,
  1: &quot;else&quot;,
  [Symbol.isConcatSpreadable]: true,
  length: 2
};
alert( arr.concat(arrayLike) ); // 1,2,something,else</code>
  <h2>Searching in array</h2>
These are methods to search for something in an array.

<h3><a name="indexof-lastindexof-and-includes" href="#indexof-lastindexof-and-includes">indexOf/lastIndexOf and includes</a></h3>
The methods <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf">arr.indexOf</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf">arr.lastIndexOf</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes">arr.includes</a> have the same syntax and do essentially the same as their string counterparts, but operate on items instead of characters:

<li><code>arr.indexOf(item, from)</code> looks for <code>item</code> starting from index <code>from</code>, and returns the index where it was found, otherwise <code>-1</code>.</li><li><code>arr.lastIndexOf(item, from)</code> – same, but looks from right to left.</li><li><code>arr.includes(item, from)</code> – looks for <code>item</code> starting from index <code>from</code>, returns <code>true</code> if found.</li>

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let arr = [1, 0, false];
alert( arr.indexOf(0) ); // 1
alert( arr.indexOf(false) ); // 2
alert( arr.indexOf(null) ); // -1
alert( arr.includes(1) ); // true</code>
  Note that the methods use <code>===</code> comparison. 
So, if we look for <code>false</code>, it finds exactly <code>false</code> and not the zero.

If we want to check for inclusion, and don’t want to know the exact index, then <code>arr.includes</code> is preferred.

Also, a very minor difference of <code>includes</code> is that it correctly handles <code>NaN</code>, unlike <code>indexOf/lastIndexOf</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>const arr = [NaN];
alert( arr.indexOf(NaN) ); // -1 (should be 0, but === equality doesn't work for NaN)
alert( arr.includes(NaN) );// true (correct)</code>
  <h3><a name="find-and-findindex" href="#find-and-findindex">find and findIndex</a></h3>
Imagine we have an array of objects. 
How do we find an object with the specific condition?

Here the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find">arr.find</a> method comes in handy.

The syntax is:

    <code>let result = arr.find(function(item, index, array) {
  // should return true if the item is what we are looking for
});</code>
  The function is called repetitively for each element of the array:

<li><code>item</code> is the element.</li><li><code>index</code> is its index.</li><li><code>array</code> is the array itself.</li>

If it returns <code>true</code>, the search is stopped, the <code>item</code> is returned. 
If nothing found, <code>undefined</code> is returned.

For example, we have an array of users, each with the fields <code>id</code> and <code>name</code>. 
Let’s find the one with <code>id == 1</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let users = [
  {id: 1, name: &quot;John&quot;},
  {id: 2, name: &quot;Pete&quot;},
  {id: 3, name: &quot;Mary&quot;}
];
let user = users.find(item =&gt; item.id == 1);
alert(user.name); // John</code>
  In real life arrays of objects is a common thing, so the <code>find</code> method is very useful.

Note that in the example we provide to <code>find</code> a single-argument function <code>item =&gt; item.id == 1</code>. 
Other parameters of <code>find</code> are rarely used.

The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex">arr.findIndex</a> method is essentially the same, but it returns the index where the element was found instead of the element itself.

<h3><a name="filter" href="#filter">filter</a></h3>
The <code>find</code> method looks for a single (first) element that makes the function return <code>true</code>.

If there may be many, we can use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter">arr.filter(fn)</a>.

The syntax is roughly the same as <code>find</code>, but it returns an array of matching elements:

    <code>let results = arr.filter(function(item, index, array) {
  // should return true if the item passes the filter
});</code>
  For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let users = [
  {id: 1, name: &quot;John&quot;},
  {id: 2, name: &quot;Pete&quot;},
  {id: 3, name: &quot;Mary&quot;}
];
// returns array of the first two users
let someUsers = users.filter(item =&gt; item.id &lt; 3);
alert(someUsers.length); // 2</code>
  <h2>Transform an array</h2>
This section is about the methods transforming or reordering the array.

<h3><a name="map" href="#map">map</a></h3>
The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map">arr.map</a> method is one of the most useful and often used.

The syntax is:

    <code>let result = arr.map(function(item, index, array) {
  // returns the new value instead of item
})</code>
  It calls the function for each element of the array and returns the array of results.

For instance, here we transform each element into its length:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let lengths = [&quot;Bilbo&quot;, &quot;Gandalf&quot;, &quot;Nazgul&quot;].map(item =&gt; item.length)
alert(lengths); // 5,7,6</code>
  <h3><a name="sort-fn" href="#sort-fn">sort(fn)</a></h3>
The method <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort">arr.sort</a> sorts the array <em>in place</em>.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let arr = [ 1, 2, 15 ];
// the method reorders the content of arr (and returns it)
arr.sort();
alert( arr );  // 1, 15, 2</code>
  Did you notice anything strange in the outcome?

The order became <code>1, 15, 2</code>. 
Incorrect. 
But why?

<strong>The items are sorted as strings by default.</strong>

Literally, all elements are converted to strings and then compared. 
So, the lexicographic ordering is applied and indeed <code>&quot;2&quot; &gt; &quot;15&quot;</code>.

To use our own sorting order, we need to supply a function of two arguments as the argument of <code>arr.sort()</code>.

The function should work like this:

    <code>function compare(a, b) {
  if (a &gt; b) return 1;
  if (a == b) return 0;
  if (a &lt; b) return -1;
}</code>
  For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function compareNumeric(a, b) {
  if (a &gt; b) return 1;
  if (a == b) return 0;
  if (a &lt; b) return -1;
}
let arr = [ 1, 2, 15 ];
arr.sort(compareNumeric);
alert(arr);  // 1, 2, 15</code>
  Now it works as intended.

Let’s step aside and think what’s happening. 
The <code>arr</code> can be array of anything, right? It may contain numbers or strings or html elements or whatever. 
We have a set of <em>something</em>. 
To sort it, we need an <em>ordering function</em> that knows how to compare its elements. 
The default is a string order.

The <code>arr.sort(fn)</code> method has a built-in implementation of sorting algorithm. 
We don’t need to care how it exactly works (an optimized <a href="https://en.wikipedia.org/wiki/Quicksort">quicksort</a> most of the time). 
It will walk the array, compare its elements using the provided function and reorder them, all we need is to provide the <code>fn</code> which does the comparison.

By the way, if we ever want to know which elements are compared – nothing prevents from alerting them:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>[1, -2, 15, 2, 0, 8].sort(function(a, b) {
  alert( a + &quot; &lt;&gt; &quot; + b );
});</code>
  The algorithm may compare an element multiple times in the process, but it tries to make as few comparisons as possible.

A comparison function may return any number
Actually, a comparison function is only required to return a positive number to say “greater” and a negative number to say “less”.

That allows to write shorter functions:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let arr = [ 1, 2, 15 ];
arr.sort(function(a, b) { return a - b; });
alert(arr);  // 1, 2, 15</code>
  

Arrow functions for the best
Remember Article &quot;function-expression&quot; not found? We can use them here for neater sorting:

    <code>arr.sort( (a, b) =&gt; a - b );</code>
  This works exactly the same as the other, longer, version above.

<h3><a name="reverse" href="#reverse">reverse</a></h3>
The method <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse">arr.reverse</a> reverses the order of elements in <code>arr</code>.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let arr = [1, 2, 3, 4, 5];
arr.reverse();
alert( arr ); // 5,4,3,2,1</code>
  It also returns the array <code>arr</code> after the reversal.

<h3><a name="split-and-join" href="#split-and-join">split and join</a></h3>
Here’s the situation from the real life. 
We are writing a messaging app, and the person enters the comma-delimited list of receivers: <code>John, Pete, Mary</code>. 
But for us an array of names would be much more comfortable than a single string. 
How to get it?

The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split">str.split(delim)</a> method does exactly that. 
It splits the string into an array by the given delimiter <code>delim</code>.

In the example below, we split by a comma followed by space:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let names = 'Bilbo, Gandalf, Nazgul';
let arr = names.split(', ');
for (let name of arr) {
  alert( `A message to ${name}.` ); // A message to Bilbo  (and other names)
}</code>
  The <code>split</code> method has an optional second numeric argument – a limit on the array length. 
If it is provided, then the extra elements are ignored. 
In practice it is rarely used though:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let arr = 'Bilbo, Gandalf, Nazgul, Saruman'.split(', ', 2);
alert(arr); // Bilbo, Gandalf</code>
  
Split into letters
The call to <code>split(s)</code> with an empty <code>s</code> would split the string into an array of letters:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let str = &quot;test&quot;;
alert( str.split('') ); // t,e,s,t</code>
  
The call <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join">arr.join(str)</a> does the reverse to <code>split</code>. 
It creates a string of <code>arr</code> items glued by <code>str</code> between them.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let arr = ['Bilbo', 'Gandalf', 'Nazgul'];
let str = arr.join(';');
alert( str ); // Bilbo;Gandalf;Nazgul</code>
  <h3><a name="reduce-reduceright" href="#reduce-reduceright">reduce/reduceRight</a></h3>
When we need to iterate over an array – we can use <code>forEach</code>.

When we need to iterate and return the data for each element – we can use <code>map</code>.

The methods <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">arr.reduce</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight">arr.reduceRight</a> also belong to that breed, but are a little bit more intricate. 
They are used to calculate a single value based on the array.

The syntax is:

    <code>let value = arr.reduce(function(previousValue, item, index, arr) {
  // ...
}, initial);</code>
  The function is applied to the elements. 
You may notice the familiar arguments, starting from the 2nd:

<li><code>item</code> – is the current array item.</li><li><code>index</code> – is its position.</li><li><code>arr</code> – is the array.</li>

So far, like <code>forEach/map</code>. 
But there’s one more argument:

<li><code>previousValue</code> – is the result of the previous function call, <code>initial</code> for the first call.</li>

The easiest way to grasp that is by example.

Here we get a sum of array in one line:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let arr = [1, 2, 3, 4, 5];
let result = arr.reduce((sum, current) =&gt; sum + current, 0);
alert(result); // 15</code>
  Here we used the most common variant of <code>reduce</code> which uses only 2 arguments.

Let’s see the details of what’s going on.

<li>On the first run, <code>sum</code> is the initial value (the last argument of <code>reduce</code>), equals <code>0</code>, and <code>current</code> is the first array element, equals <code>1</code>. 
So the result is <code>1</code>.</li><li>On the second run, <code>sum = 1</code>, we add the second array element (<code>2</code>) to it and return.</li><li>On the 3rd run, <code>sum = 3</code> and we add one more element to it, and so on…</li>

The calculation flow:

<img src="https://javascript.info/article/array-methods/reduce.png">
Or in the form of a table, where each row represents is a function call on the next array element:

<table>
<thead>
<tr>
<th></th>
<th><code>sum</code></th>
<th><code>current</code></th>
<th><code>result</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>the first call</td>
<td><code>0</code></td>
<td><code>1</code></td>
<td><code>1</code></td>
</tr>
<tr>
<td>the second call</td>
<td><code>1</code></td>
<td><code>2</code></td>
<td><code>3</code></td>
</tr>
<tr>
<td>the third call</td>
<td><code>3</code></td>
<td><code>3</code></td>
<td><code>6</code></td>
</tr>
<tr>
<td>the fourth call</td>
<td><code>6</code></td>
<td><code>4</code></td>
<td><code>10</code></td>
</tr>
<tr>
<td>the fifth call</td>
<td><code>10</code></td>
<td><code>5</code></td>
<td><code>15</code></td>
</tr>
</tbody>
</table>

As we can see, the result of the previous call becomes the first argument of the next one.

We also can omit the initial value:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let arr = [1, 2, 3, 4, 5];
// removed initial value from reduce (no 0)
let result = arr.reduce((sum, current) =&gt; sum + current);
alert( result ); // 15</code>
  The result is the same. 
That’s because if there’s no initial, then <code>reduce</code> takes the first element of the array as the initial value and starts the iteration from the 2nd element.

The calculation table is the same as above, minus the first row.

But such use requires an extreme care. 
If the array is empty, then <code>reduce</code> call without initial value gives an error.

Here’s an example:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let arr = [];
// Error: Reduce of empty array with no initial value
// if the initial value existed, reduce would return it for the empty arr.
arr.reduce((sum, current) =&gt; sum + current);</code>
  So it’s advised to always specify the initial value.

The method <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight">arr.reduceRight</a> does the same, but goes from right to left.

<h2>Iterate: forEach</h2>
The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">arr.forEach</a> method allows to run a function for every element of the array.

The syntax:

    <code>arr.forEach(function(item, index, array) {
  // ... 
do something with item
});</code>
  For instance, this shows each element of the array:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// for each element call alert
[&quot;Bilbo&quot;, &quot;Gandalf&quot;, &quot;Nazgul&quot;].forEach(alert);</code>
  And this code is more elaborate about their positions in the target array:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>[&quot;Bilbo&quot;, &quot;Gandalf&quot;, &quot;Nazgul&quot;].forEach((item, index, array) =&gt; {
  alert(`${item} is at index ${index} in ${array}`);
});</code>
  The result of the function (if it returns any) is thrown away and ignored.

<h2>Array.isArray</h2>
Arrays do not form a separate language type. 
They are based on objects.

So <code>typeof</code> does not help to distinguish a plain object from an array:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert(typeof {}); // object
alert(typeof []); // same</code>
  …But arrays are used so often that there’s a special method for that: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray">Array.isArray(value)</a>. 
It returns <code>true</code> if the <code>value</code> is an array, and <code>false</code> otherwise.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert(Array.isArray({})); // false
alert(Array.isArray([])); // true</code>
  <h2>Most methods support “thisArg”</h2>
Almost all array methods that call functions – like <code>find</code>, <code>filter</code>, <code>map</code>, with a notable exception of <code>sort</code>, accept an optional additional parameter <code>thisArg</code>.

That parameter is not explained in the sections above, because it’s rarely used. 
But for completeness we have to cover it.

Here’s the full syntax of these methods:

    <code>arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
// ...
// thisArg is the optional last argument</code>
  The value of <code>thisArg</code> parameter becomes <code>this</code> for <code>func</code>.

For instance, here we use an object method as a filter and <code>thisArg</code> comes in handy:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  age: 18,
  younger(otherUser) {
    return otherUser.age &lt; this.age;
  }
};
let users = [
  {age: 12},
  {age: 16},
  {age: 32}
];
// find all users younger than user
let youngerUsers = users.filter(user.younger, user);
alert(youngerUsers.length); // 2</code>
  In the call above, we use <code>user.younger</code> as a filter and also provide <code>user</code> as the context for it. 
If we didn’t provide the context, <code>users.filter(user.younger)</code> would call <code>user.younger</code> as a standalone function, with <code>this=undefined</code>. 
That would mean an instant error.

<h4><a name="summary" href="#summary">Summary</a4</h2>
A cheatsheet of array methods:

<li>To add/remove elements:

<li><code>push(...items)</code> – adds items to the end,</li><li><code>pop()</code> – extracts an item from the end,</li><li><code>shift()</code> – extracts an item from the beginning,</li><li><code>unshift(...items)</code> – adds items to the beginning.</li><li><code>splice(pos, deleteCount, ...items)</code> – at index <code>pos</code> delete <code>deleteCount</code> elements and insert <code>items</code>.</li><li><code>slice(start, end)</code> – creates a new array, copies elements from position <code>start</code> till <code>end</code> (not inclusive) into it.</li><li><code>concat(...items)</code> – returns a new array: copies all members of the current one and adds <code>items</code> to it. 
If any of <code>items</code> is an array, then its elements are taken.</li>

</li><li>To search among elements:

<li><code>indexOf/lastIndexOf(item, pos)</code> – look for <code>item</code> starting from position <code>pos</code>, return the index or <code>-1</code> if not found.</li><li><code>includes(value)</code> – returns <code>true</code> if the array has <code>value</code>, otherwise <code>false</code>.</li><li><code>find/filter(func)</code> – filter elements through the function, return first/all values that make it return <code>true</code>.</li><li><code>findIndex</code> is like <code>find</code>, but returns the index instead of a value.</li>

</li><li>To transform the array:

<li><code>map(func)</code> – creates a new array from results of calling <code>func</code> for every element.</li><li><code>sort(func)</code> – sorts the array in-place, then returns it.</li><li><code>reverse()</code> – reverses the array in-place, then returns it.</li><li><code>split/join</code> – convert a string to array and back.</li><li><code>reduce(func, initial)</code> – calculate a single value over the array by calling <code>func</code> for each element and passing an intermediate result between the calls.</li>

</li><li>To iterate over elements:

<li><code>forEach(func)</code> – calls <code>func</code> for every element, does not return anything.</li>

</li><li>Additionally:

<li><code>Array.isArray(arr)</code> checks <code>arr</code> for being an array.</li>

</li>

Please note that methods <code>sort</code>, <code>reverse</code> and <code>splice</code> modify the array itself.

These methods are the most used ones, they cover 99% of use cases. 
But there are few others:

<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some">arr.some(fn)</a>/<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every">arr.every(fn)</a> checks the array.

The function <code>fn</code> is called on each element of the array similar to <code>map</code>. 
If any/all results are <code>true</code>, returns <code>true</code>, otherwise <code>false</code>.

</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill">arr.fill(value, start, end)</a> – fills the array with repeating <code>value</code> from index <code>start</code> to <code>end</code>.

</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin">arr.copyWithin(target, start, end)</a> – copies its elements from position <code>start</code> till position <code>end</code> into <em>itself</em>, at position <code>target</code> (overwrites existing).

</li>

For the full list, see the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">manual</a>.

From the first sight it may seem that there are so many methods, quite difficult to remember. 
But actually that’s much easier than it seems.

Look through the cheatsheet just to be aware of them. 
Then solve the tasks of this chapter to practice, so that you have experience with array methods.

Afterwards whenever you need to do something with an array, and you don’t know how – come here, look at the cheatsheet and find the right method. 
Examples will help you to write it correctly. 
Soon you’ll automatically remember the methods, without specific efforts from your side.

That is: removes all dashes, each word after dash becomes uppercased.

Examples:

    <code>camelize(&quot;background-color&quot;) == 'backgroundColor';
camelize(&quot;list-style-image&quot;) == 'listStyleImage';
camelize(&quot;-webkit-transition&quot;) == 'WebkitTransition';</code>
  P.S. 
Hint: use <code>split</code> to split the string into an array, transform it and <code>join</code> back.

<a href="http://plnkr.co/edit/9vtkVJmOXuF8VxfIxKaK?p=preview" target="_blank" data-plunk-id="9vtkVJmOXuF8VxfIxKaK">Open the sandbox with tests.</a>
<button type="button">solution</button>

<a href="http://plnkr.co/edit/vjrhuOwdHtdDKcst5dLK?p=preview" target="_blank" data-plunk-id="vjrhuOwdHtdDKcst5dLK">Open the solution with tests in the sandbox.</a>
<button type="button" title="close"></button>

<h3><a href="#filter-range" name="filter-range">Filter range</a></h3><a href="/task/filter-range" target="_blank"></a>

importance: 4

Write a function <code>filterRange(arr, a, b)</code> that gets an array <code>arr</code>, looks for elements between <code>a</code> and <code>b</code> in it and returns an array of them.

The function should not modify the array. 
It should return the new array.

For instance:

    <code>let arr = [5, 3, 8, 1];
let filtered = filterRange(arr, 1, 4);
alert( filtered ); // 3,1 (matching values)
alert( arr ); // 5,3,8,1 (not modified)</code>
  <a href="http://plnkr.co/edit/QrSggoIfdmUasaiV9Qoj?p=preview" target="_blank" data-plunk-id="QrSggoIfdmUasaiV9Qoj">Open the sandbox with tests.</a>
<button type="button">solution</button>

<a href="http://plnkr.co/edit/YT1qYB7OKLJ3Mh1yhv4l?p=preview" target="_blank" data-plunk-id="YT1qYB7OKLJ3Mh1yhv4l">Open the solution with tests in the sandbox.</a>
<button type="button" title="close"></button>

<h3><a href="#filter-range-in-place" name="filter-range-in-place">Filter range &quot;in place&quot;</a></h3><a href="/task/filter-range-in-place" target="_blank"></a>

importance: 4

Write a function <code>filterRangeInPlace(arr, a, b)</code> that gets an array <code>arr</code> and removes from it all values except those that are between <code>a</code> and <code>b</code>. 
The test is: <code>a ≤ arr[i] ≤ b</code>.

The function should only modify the array. 
It should not return anything.

For instance:

    <code>let arr = [5, 3, 8, 1];
filterRangeInPlace(arr, 1, 4); // removed the numbers except from 1 to 4
alert( arr ); // [3, 1]</code>
  <a href="http://plnkr.co/edit/4fOH0XLlmVAeQk8FrNoo?p=preview" target="_blank" data-plunk-id="4fOH0XLlmVAeQk8FrNoo">Open the sandbox with tests.</a>
<button type="button">solution</button>

<a href="http://plnkr.co/edit/AL5wsoTXl4I1fVC9n8CQ?p=preview" target="_blank" data-plunk-id="AL5wsoTXl4I1fVC9n8CQ">Open the solution with tests in the sandbox.</a>
<button type="button" title="close"></button>

<h3><a href="#sort-in-the-reverse-order" name="sort-in-the-reverse-order">Sort in the reverse order</a></h3><a href="/task/sort-back" target="_blank"></a>

importance: 4

    <code>let arr = [5, 2, 1, -10, 8];
// ... 
your code to sort it in the reverse order
alert( arr ); // 8, 5, 2, 1, -10</code>
  <button type="button">solution</button>

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let arr = [5, 2, 1, -10, 8];
arr.sort((a, b) =&gt; b - a);
alert( arr );</code>
  <button type="button" title="close"></button>

<h3><a href="#copy-and-sort-array" name="copy-and-sort-array">Copy and sort array</a></h3><a href="/task/copy-sort-array" target="_blank"></a>

importance: 5

We have an array of strings <code>arr</code>. 
We’d like to have a sorted copy of it, but keep <code>arr</code> unmodified.

Create a function <code>copySorted(arr)</code> that returns such a copy.

    <code>let arr = [&quot;HTML&quot;, &quot;JavaScript&quot;, &quot;CSS&quot;];
let sorted = copySorted(arr);
alert( sorted ); // CSS, HTML, JavaScript
alert( arr ); // HTML, JavaScript, CSS (no changes)</code>
  <button type="button">solution</button>

We can use <code>slice()</code> to make a copy and run the sort on it:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function copySorted(arr) {
  return arr.slice().sort();
}
let arr = [&quot;HTML&quot;, &quot;JavaScript&quot;, &quot;CSS&quot;];
let sorted = copySorted(arr);
alert( sorted );
alert( arr );</code>
  <button type="button" title="close"></button>

<h3><a href="#map-to-names" name="map-to-names">Map to names</a></h3><a href="/task/array-get-names" target="_blank"></a>

importance: 5

You have an array of <code>user</code> objects, each one has <code>user.name</code>. 
Write the code that converts it into an array of names.

For instance:

    <code>let john = { name: &quot;John&quot;, age: 25 };
let pete = { name: &quot;Pete&quot;, age: 30 };
let mary = { name: &quot;Mary&quot;, age: 28 };
let users = [ john, pete, mary ];
let names = /* ... 
your code */
alert( names ); // John, Pete, Mary</code>
  <button type="button">solution</button>

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let john = { name: &quot;John&quot;, age: 25 };
let pete = { name: &quot;Pete&quot;, age: 30 };
let mary = { name: &quot;Mary&quot;, age: 28 };
let users = [ john, pete, mary ];
let names = users.map(item =&gt; item.name);
alert( names ); // John, Pete, Mary</code>
  <button type="button" title="close"></button>

<h3><a href="#map-to-objects" name="map-to-objects">Map to objects</a></h3><a href="/task/map-objects" target="_blank"></a>

importance: 5

You have an array of <code>user</code> objects, each one has <code>name</code>, <code>surname</code> and <code>id</code>.

Write the code to create another array from it, of objects with <code>id</code> and <code>fullName</code>, where <code>fullName</code> is generated from <code>name</code> and <code>surname</code>.

For instance:

    <code>let john = { name: &quot;John&quot;, surname: &quot;Smith&quot;, id: 1 };
let pete = { name: &quot;Pete&quot;, surname: &quot;Hunt&quot;, id: 2 };
let mary = { name: &quot;Mary&quot;, surname: &quot;Key&quot;, id: 3 };
let users = [ john, pete, mary ];
let usersMapped = /* ... 
your code ... 
*/
/*
usersMapped = [
  { fullName: &quot;John Smith&quot;, id: 1 },
  { fullName: &quot;Pete Hunt&quot;, id: 2 },
  { fullName: &quot;Mary Key&quot;, id: 3 }
]
*/
alert( usersMapped[0].id ) // 1
alert( usersMapped[0].fullName ) // John Smith</code>
  So, actually you need to map one array of objects to another. 
Try using <code>=&gt;</code> here. 
There’s a small catch.

<button type="button">solution</button>

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let john = { name: &quot;John&quot;, surname: &quot;Smith&quot;, id: 1 };
let pete = { name: &quot;Pete&quot;, surname: &quot;Hunt&quot;, id: 2 };
let mary = { name: &quot;Mary&quot;, surname: &quot;Key&quot;, id: 3 };
let users = [ john, pete, mary ];
let usersMapped = users.map(user =&gt; ({
  fullName: `${user.name} ${user.surname}`,
  id: user.id
}));
/*
usersMapped = [
  { fullName: &quot;John Smith&quot;, id: 1 },
  { fullName: &quot;Pete Hunt&quot;, id: 2 },
  { fullName: &quot;Mary Key&quot;, id: 3 }
]
*/
alert( usersMapped[0].id ); // 1
alert( usersMapped[0].fullName ); // John Smith</code>
  Please note that in for the arrow functions we need to use additional brackets.

We can’t write like this:

    <code>let usersMapped = users.map(user =&gt; {
  fullName: `${user.name} ${user.surname}`,
  id: user.id
});</code>
  As we remember, there are two arrow functions: without body <code>value =&gt; expr</code> and with body <code>value =&gt; {...}</code>.

Here JavaScript would treat <code>{</code> as the start of function body, not the start of the object. 
The workaround is to wrap them in the “normal” brackets:

    <code>let usersMapped = users.map(user =&gt; ({
  fullName: `${user.name} ${user.surname}`,
  id: user.id
}));</code>
  Now fine.

<button type="button" title="close"></button>

<h3><a href="#sort-objects" name="sort-objects">Sort objects</a></h3><a href="/task/sort-objects" target="_blank"></a>

importance: 5

Write the function <code>sortByName(users)</code> that gets an array of objects with property <code>name</code> and sorts it.

For instance:

    <code>let john = { name: &quot;John&quot;, age: 25 };
let pete = { name: &quot;Pete&quot;, age: 30 };
let mary = { name: &quot;Mary&quot;, age: 28 };
let arr = [ john, pete, mary ];
sortByName(arr);
// now: [john, mary, pete]
alert(arr[1].name); // Mary</code>
  <button type="button">solution</button>

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function sortByName(arr) {
  arr.sort((a, b) =&gt; a.name &gt; b.name);
}
let john = { name: &quot;John&quot;, age: 25 };
let pete = { name: &quot;Pete&quot;, age: 30 };
let mary = { name: &quot;Mary&quot;, age: 28 };
let arr = [ john, pete, mary ];
sortByName(arr);
// now sorted is: [john, mary, pete]
alert(arr[1].name); // Mary</code>
  <button type="button" title="close"></button>

<h3><a href="#shuffle-an-array" name="shuffle-an-array">Shuffle an array</a></h3><a href="/task/shuffle" target="_blank"></a>

importance: 3

Write the function <code>shuffle(array)</code> that shuffles (randomly reorders) elements of the array.

Multiple runs of <code>shuffle</code> may lead to different orders of elements. 
For instance:

    <code>let arr = [1, 2, 3];
shuffle(arr);
// arr = [3, 2, 1]
shuffle(arr);
// arr = [2, 1, 3]
shuffle(arr);
// arr = [3, 1, 2]
// ...</code>
  All element orders should have an equal probability. 
For instance, <code>[1,2,3]</code> can be reordered as <code>[1,2,3]</code> or <code>[1,3,2]</code> or <code>[3,1,2]</code> etc, with equal probability of each case.

<button type="button">solution</button>

The simple solution could be:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function shuffle(array) {
  array.sort(() =&gt; Math.random() - 0.5);
}
let arr = [1, 2, 3];
shuffle(arr);
alert(arr);</code>
  That somewhat works, because <code>Math.random() - 0.5</code> is a random number that may be positive or negative, so the sorting function reorders elements randomly.

But because the sorting function is not meant to be used this way, not all permutations have the same probability.

For instance, consider the code below. 
It runs <code>shuffle</code> 1000000 times and counts appearances of all possible results:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function shuffle(array) {
  array.sort(() =&gt; Math.random() - 0.5);
}
// counts of appearances for all possible permutations
let count = {
  '123': 0,
  '132': 0,
  '213': 0,
  '231': 0,
  '321': 0,
  '312': 0
};
for (let i = 0; i &lt; 1000000; i++) {
  let array = [1, 2, 3];
  shuffle(array);
  count[array.join('')]++;
}
// show counts of all possible permutations
for (let key in count) {
  alert(`${key}: ${count[key]}`);
}</code>
  An example result (for V8, July 2017):

    <code>123: 250706
132: 124425
213: 249618
231: 124880
312: 125148
321: 125223</code>
  We can see the bias clearly: <code>123</code> and <code>213</code> appear much more often than others.

The result of the code may vary between JavaScript engines, but we can already see that the approach is unreliable.

Why it doesn’t work? Generally speaking, <code>sort</code> is a “black box”: we throw an array and a comparison function into it and expect the array to be sorted. 
But due to the utter randomness of the comparison the black box goes mad, and how exactly it goes mad depends on the concrete implementation that differs between engines.

There are other good ways to do the task. 
For instance, there’s a great algorithm called <a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle">Fisher-Yates shuffle</a>. 
The idea is to walk the array in the reverse order and swap each element with a random one before it:

    <code>function shuffle(array) {
  for (let i = array.length - 1; i &gt; 0; i--) {
    let j = Math.floor(Math.random() * (i + 1)); // random index from 0 to i
    [array[i], array[j]] = [array[j], array[i]]; // swap elements
  }
}</code>
  Let’s test it the same way:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function shuffle(array) {
  for (let i = array.length - 1; i &gt; 0; i--) {
    let j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}
// counts of appearances for all possible permutations
let count = {
  '123': 0,
  '132': 0,
  '213': 0,
  '231': 0,
  '321': 0,
  '312': 0
};
for (let i = 0; i &lt; 1000000; i++) {
  let array = [1, 2, 3];
  shuffle(array);
  count[array.join('')]++;
}
// show counts of all possible permutations
for (let key in count) {
  alert(`${key}: ${count[key]}`);
}</code>
  The example output:

    <code>123: 166693
132: 166647
213: 166628
231: 167517
312: 166199
321: 166316</code>
  Looks good now: all permutations appear with the same probability.

Also, performance-wise the Fisher-Yates algorithm is much better, there’s no “sorting” overhead.

<button type="button" title="close"></button>

<h3><a href="#get-average-age" name="get-average-age">Get average age</a></h3><a href="/task/average-age" target="_blank"></a>

importance: 4

Write the function <code>getAverageAge(users)</code> that gets an array of objects with property <code>age</code> and gets the average.

The formula for the average is <code>(age1 + age2 + ... 
+ ageN) / N</code>.

For instance:

    <code>let john = { name: &quot;John&quot;, age: 25 };
let pete = { name: &quot;Pete&quot;, age: 30 };
let mary = { name: &quot;Mary&quot;, age: 29 };
let arr = [ john, pete, mary ];
alert( getAverageAge(arr) ); // (25 + 30 + 29) / 3 = 28</code>
  <button type="button">solution</button>

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function getAverageAge(users) {
  return users.reduce((prev, user) =&gt; prev + user.age, 0) / users.length;
}
let john = { name: &quot;John&quot;, age: 25 };
let pete = { name: &quot;Pete&quot;, age: 30 };
let mary = { name: &quot;Mary&quot;, age: 29 };
let arr = [ john, pete, mary ];
alert( getAverageAge(arr) ); // 28</code>
  <button type="button" title="close"></button>

<h3><a href="#filter-unique-array-members" name="filter-unique-array-members">Filter unique array members</a></h3><a href="/task/array-unique" target="_blank"></a>

importance: 4

Let <code>arr</code> be an array.

Create a function <code>unique(arr)</code> that should return an array with unique items of <code>arr</code>.

For instance:

    <code>function unique(arr) {
  /* your code */
}
let strings = [&quot;Hare&quot;, &quot;Krishna&quot;, &quot;Hare&quot;, &quot;Krishna&quot;,
  &quot;Krishna&quot;, &quot;Krishna&quot;, &quot;Hare&quot;, &quot;Hare&quot;, &quot;:-O&quot;
];
alert( unique(strings) ); // Hare, Krishna, :-O</code>
  <a href="http://plnkr.co/edit/WCPR3saRXAFj0v8g52su?p=preview" target="_blank" data-plunk-id="WCPR3saRXAFj0v8g52su">Open the sandbox with tests.</a>
<button type="button">solution</button>

Let’s walk the array items:

<li>For each item we’ll check if the resulting array already has that item.</li><li>If it is so, then ignore, otherwise add to results.</li>

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function unique(arr) {
  let result = [];
  for (let str of arr) {
    if (!result.includes(str)) {
result.push(str);
    }
  }
  return result;
}
let strings = [&quot;Hare&quot;, &quot;Krishna&quot;, &quot;Hare&quot;, &quot;Krishna&quot;,
  &quot;Krishna&quot;, &quot;Krishna&quot;, &quot;Hare&quot;, &quot;Hare&quot;, &quot;:-O&quot;
];
alert( unique(strings) ); // Hare, Krishna, :-O</code>
  The code works, but there’s a potential performance problem in it.

The method <code>result.includes(str)</code> internally walks the array <code>result</code> and compares each element against <code>str</code> to find the match.

So if there are <code>100</code> elements in <code>result</code> and no one matches <code>str</code>, then it will walk the whole <code>result</code> and do exactly <code>100</code> comparisons. 
And if <code>result</code> is large, like <code>10000</code>, then there would be <code>10000</code> comparisons.

That’s not a problem by itself, because JavaScript engines are very fast, so walk <code>10000</code> array is a matter of microseconds.

But we do such test for each element of <code>arr</code>, in the <code>for</code> loop.

So if <code>arr.length</code> is <code>10000</code> we’ll have something like <code>10000*10000</code> = 100 millions of comparisons. 
That’s a lot.

So the solution is only good for small arrays.

Further in the chapter <a href="/map-set-weakmap-weakset">Map, Set, WeakMap and WeakSet</a> we’ll see how to optimize it.

<a href="http://plnkr.co/edit/lTSytTlmQq8knrv9umpJ?p=preview" target="_blank" data-plunk-id="lTSytTlmQq8knrv9umpJ">Open the solution with tests in the sandbox.</a>
<button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/array" data-tooltip="Arrays">Previous lesson</a><a href="/iterable" data-tooltip="Iterables">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Farray-methods"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Farray-methods"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Farray-methods"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Farray-methods"></a>

<em>Iterable</em> objects is a generalization of arrays. 
That’s a concept that allows to make any object useable in a <code>for..of</code> loop.

Arrays by themselves are iterable. 
But not only arrays. 
Strings are iterable too, and many other built-in objects as well.

Iterables are widely used by the core JavaScript. 
As we’ll see many built-in operators and methods rely on them.

<h2>Symbol.iterator</h2>
We can easily grasp the concept of iterables by making one of our own.

For instance, we have an object, that is not an array, but looks suitable for <code>for..of</code>.

Like a <code>range</code> object that represents an interval of numbers:

    <code>let range = {
  from: 1,
  to: 5
};
// We want the for..of to work:
// for(let num of range) ... 
num=1,2,3,4,5</code>
  To make the <code>range</code> iterable (and thus let <code>for..of</code> work) we need to add a method to the object named <code>Symbol.iterator</code> (a special built-in symbol just for that).

<li>When <code>for..of</code> starts, it calls that method (or errors if not found).</li><li>The method must return an <em>iterator</em> – an object with the method <code>next</code>.</li><li>When <code>for..of</code> wants the next value, it calls <code>next()</code> on that object.</li><li>The result of <code>next()</code> must have the form <code>{done: Boolean, value: any}</code>, where <code>done=true</code>  means that the iteration is finished, otherwise <code>value</code> must be the new value.</li>

Here’s the full implementation for <code>range</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let range = {
  from: 1,
  to: 5
};
// 1. 
call to for..of initially calls this
range[Symbol.iterator] = function() {
  // 2. 
...it returns the iterator:
  return {
    current: this.from,
    last: this.to,
    // 3. 
next() is called on each iteration by the for..of loop
    next() {
// 4. 
it should return the value as an object {done:.., value :...}
if (this.current &lt;= this.last) {
  return { done: false, value: this.current++ };
} else {
  return { done: true };
}
    }
  };
};
// now it works!
for (let num of range) {
  alert(num); // 1, then 2, 3, 4, 5
}</code>
  There is an important separation of concerns in this code:

<li>The <code>range</code> itself does not have the <code>next()</code> method.</li><li>Instead, another object, a so-called “iterator” is created by the call to <code>range[Symbol.iterator]()</code>, and it handles the iteration.</li>

So, the iterator object is separate from the object it iterates over.

Technically, we may merge them and use <code>range</code> itself as the iterator to make the code simpler.

Like this:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let range = {
  from: 1,
  to: 5,
  [Symbol.iterator]() {
    this.current = this.from;
    return this;
  },
  next() {
    if (this.current &lt;= this.to) {
return { done: false, value: this.current++ };
    } else {
return { done: true };
    }
  }
};
for (let num of range) {
  alert(num); // 1, then 2, 3, 4, 5
}</code>
  Now <code>range[Symbol.iterator]()</code> returns the <code>range</code> object itself:  it has the necessary <code>next()</code> method and remembers the current iteration progress in <code>this.current</code>. 
Sometimes that’s fine too. 
The downside is that now it’s impossible to have two <code>for..of</code> loops running over the object simultaneously: they’ll share the iteration state, because there’s only one iterator – the object itself.

Infinite iterators
Infinite iterators are also doable. 
For instance, the <code>range</code> becomes infinite for <code>range.to = Infinity</code>. 
Or we can make an iterable object that generates an infinite sequence of pseudorandom numbers. 
Also can be useful.

There are no limitations on <code>next</code>, it can return more and more values, that’s normal.

Of course, the <code>for..of</code> loop over such an iterable would be endless. 
But we can always stop it using <code>break</code>.

<h2>String is iterable</h2>
Arrays and strings are most widely used built-in iterables.

For a string, <code>for..of</code> loops over its characters:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>for (let char of &quot;test&quot;) {
  alert( char ); // t, then e, then s, then t
}</code>
  And it works right with surrogate pairs!

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let str = '𝒳😂';
for (let char of str) {
    alert( char ); // 𝒳, and then 😂
}</code>
  <h2>Calling an iterator explicitly</h2>
Normally, internals of iterables are hidden from the external code. 
There’s a <code>for..of</code> loop, that works, that’s all it needs to know.

But to understand things a little bit deeper let’s see how to create an iterator explicitly.

We’ll iterate over a string the same way as <code>for..of</code>, but with direct calls. 
This code gets a string iterator and calls it “manually”:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let str = &quot;Hello&quot;;
// does the same as
// for (let char of str) alert(char);
let iterator = str[Symbol.iterator]();
while (true) {
  let result = iterator.next();
  if (result.done) break;
  alert(result.value); // outputs characters one by one
}</code>
  That is rarely needed, but gives us more control over the process than <code>for..of</code>. 
For instance, we can split the iteration process: iterate a bit, then stop, do something else, and then resume later.

<h2>Iterables and array-likes</h2>
There are two official terms that look similar, but are very different. 
Please make sure you understand them well to avoid the confusion.

<li><em>Iterables</em> are objects that implement the <code>Symbol.iterator</code> method, as described above.</li><li><em>Array-likes</em> are objects that have indexes and <code>length</code>, so they look like arrays.</li>

Naturally, these properties can combine. 
For instance, strings are both iterable (<code>for..of</code> works on them) and array-like (they have numeric indexes and <code>length</code>).

But an iterable may be not array-like. 
And vice versa an array-like may be not iterable.

For example, the <code>range</code> in the example above is iterable, but not array-like, because it does not have indexed properties and <code>length</code>.

And here’s the object that is array-like, but not iterable:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let arrayLike = { // has indexes and length =&gt; array-like
  0: &quot;Hello&quot;,
  1: &quot;World&quot;,
  length: 2
};
// Error (no Symbol.iterator)
for (let item of arrayLike) {}</code>
  What do they have in common? Both iterables and array-likes are usually <em>not arrays</em>, they don’t have <code>push</code>, <code>pop</code> etc. 
That’s rather inconvenient if we have such an object and want to work with it as with an array.

<h2>Array.from</h2>
There’s a universal method <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from">Array.from</a> that brings them together. 
It takes an iterable or array-like value and makes a “real” <code>Array</code> from it. 
Then we can call array methods on it.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let arrayLike = {
  0: &quot;Hello&quot;,
  1: &quot;World&quot;,
  length: 2
};
let arr = Array.from(arrayLike); // (*)
alert(arr.pop()); // World (method works)</code>
  <code>Array.from</code> at the line <code>(*)</code> takes the object, examines it for being an iterable or array-like, then makes a new array and copies there all items.

The same happens for an iterable:

    <code>// assuming that range is taken from the example above
let arr = Array.from(range);
alert(arr); // 1,2,3,4,5 (array toString conversion works)</code>
  The full syntax for <code>Array.from</code> allows to provide an optional “mapping” function:

    <code>Array.from(obj[, mapFn, thisArg])</code>
  The second argument <code>mapFn</code> should be the function to apply to each element before adding to the array, and <code>thisArg</code> allows to set <code>this</code> for it.

For instance:

    <code>// assuming that range is taken from the example above
// square each number
let arr = Array.from(range, num =&gt; num * num);
alert(arr); // 1,4,9,16,25</code>
  Here we use <code>Array.from</code> to turn a string into an array of characters:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let str = '𝒳😂';
// splits str into array of characters
let chars = Array.from(str);
alert(chars[0]); // 𝒳
alert(chars[1]); // 😂
alert(chars.length); // 2</code>
  Unlike <code>str.split</code>, it relies on the iterable nature of the string and so, just like <code>for..of</code>, correctly works with surrogate pairs.

Technically here it does the same as:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let str = '𝒳😂';
let chars = []; // Array.from internally does the same loop
for (let char of str) {
  chars.push(char);
}
alert(chars);</code>
  …But is shorter.

We can even build surrogate-aware <code>slice</code> on it:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function slice(str, start, end) {
  return Array.from(str).slice(start, end).join('');
}
let str = '𝒳😂𩷶';
alert( slice(str, 1, 3) ); // 😂𩷶
// native method does not support surrogate pairs
alert( str.slice(1, 3) ); // garbage (two pieces from different surrogate pairs)</code>
  <h4><a name="summary" href="#summary">Summary</a4</h2>
Objects that can be used in <code>for..of</code> are called <em>iterable</em>.

<li>Technically, iterables must implement the method named <code>Symbol.iterator</code>.
<li>The result of <code>obj[Symbol.iterator]</code> is called an <em>iterator</em>. 
It handles the further iteration process.</li><li>An iterator must have the method named <code>next()</code> that returns an object <code>{done: Boolean, value: any}</code>, here <code>done:true</code> denotes the iteration end, otherwise the <code>value</code> is the next value.</li>

</li><li>The <code>Symbol.iterator</code> method is called automatically by <code>for..of</code>, but we also can do it directly.</li><li>Built-in iterables like strings or arrays, also implement <code>Symbol.iterator</code>.</li><li>String iterator knows about surrogate pairs.</li>

Objects that have indexed properties and <code>length</code> are called <em>array-like</em>. 
Such objects may also have other properties and methods, but lack the built-in methods of arrays.

If we look inside the specification – we’ll see that most built-in methods assume that they work with iterables or array-likes instead of “real” arrays, because that’s more abstract.

<code>Array.from(obj[, mapFn, thisArg])</code> makes a real <code>Array</code> of an iterable or array-like <code>obj</code>, and we can then use array methods on it. 
The optional arguments <code>mapFn</code> and <code>thisArg</code> allow us to apply a function to each item.

Now we’ve learned about the following complex data structures:

<li>Objects for storing keyed collections.</li><li>Arrays for storing ordered collections.</li>

But that’s not enough for real life. 
That’s why <code>Map</code> and <code>Set</code> also exist.

<h2>Map</h2>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">Map</a> is a collection of keyed data items, just like an <code>Object</code>. 
But the main difference is that <code>Map</code> allows keys of any type.

The main methods are:

<li><code>new Map()</code> – creates the map.</li><li><code>map.set(key, value)</code> – stores the value by the key.</li><li><code>map.get(key)</code> – returns the value by the key, <code>undefined</code> if <code>key</code> doesn’t exist in map.</li><li><code>map.has(key)</code> – returns <code>true</code> if the <code>key</code> exists, <code>false</code> otherwise.</li><li><code>map.delete(key)</code> – removes the value by the key.</li><li><code>map.clear()</code> – clears the map</li><li><code>map.size</code> – returns the current element count.</li>

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let map = new Map();
map.set('1', 'str1');   // a string key
map.set(1, 'num1');     // a numeric key
map.set(true, 'bool1'); // a boolean key
// remember the regular Object? it would convert keys to string
// Map keeps the type, so these two are different:
alert( map.get(1)   ); // 'num1'
alert( map.get('1') ); // 'str1'
alert( map.size ); // 3</code>
  As we can see, unlike objects, keys are not converted to strings. 
Any type of key is possible.

<strong>Map can also use objects as keys.</strong>

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let john = { name: &quot;John&quot; };
// for every user, let's store his visits count
let visitsCountMap = new Map();
// john is the key for the map
visitsCountMap.set(john, 123);
alert( visitsCountMap.get(john) ); // 123</code>
  Using objects as keys is one of most notable and important <code>Map</code> features. 
For string keys, <code>Object</code> can be fine, but it would be difficult to replace the <code>Map</code> with a regular <code>Object</code> in the example above.

In the old times, before <code>Map</code> existed, people added unique identifiers to objects for that:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// we add the id field
let john = { name: &quot;John&quot;, id: 1 };
let visitsCounts = {};
// now store the value by id
visitsCounts[john.id] = 123;
alert( visitsCounts[john.id] ); // 123</code>
  …But <code>Map</code> is much more elegant.

How <code>Map</code> compares keys
To test values for equivalence, <code>Map</code> uses the algorithm <a href="https://tc39.github.io/ecma262/#sec-samevaluezero">SameValueZero</a>. 
It is roughly the same as strict equality <code>===</code>, but the difference is that <code>NaN</code> is considered equal to <code>NaN</code>. 
So <code>NaN</code> can be used as the key as well.

This algorithm can’t be changed or customized.

Chaining
Every <code>map.set</code> call returns the map itself, so we can “chain” the calls:

    <code>map.set('1', 'str1')
  .set(1, 'num1')
  .set(true, 'bool1');</code>
  
<h2>Map from Object</h2>
When a <code>Map</code> is created, we can pass an array (or another iterable) with key-value pairs, like this:

    <code>// array of [key, value] pairs
let map = new Map([
  ['1',  'str1'],
  [1,    'num1'],
  [true, 'bool1']
]);</code>
  There is a built-in method <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries">Object.entries(obj)</a> that returns an array of key/value pairs for an object exactly in that format.

So we can initialize a map from an object like this:

    <code>let map = new Map(Object.entries({
  name: &quot;John&quot;,
  age: 30
}));</code>
  Here, <code>Object.entries</code> returns the array of key/value pairs: <code>[ [&quot;name&quot;,&quot;John&quot;], [&quot;age&quot;, 30] ]</code>. 
That’s what <code>Map</code> needs.

<h2>Iteration over Map</h2>
For looping over a <code>map</code>, there are 3 methods:

<li><code>map.keys()</code> – returns an iterable for keys,</li><li><code>map.values()</code> – returns an iterable for values,</li><li><code>map.entries()</code> – returns an iterable for entries <code>[key, value]</code>, it’s used by default in <code>for..of</code>.</li>

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let recipeMap = new Map([
  ['cucumber', 500],
  ['tomatoes', 350],
  ['onion',    50]
]);
// iterate over keys (vegetables)
for (let vegetable of recipeMap.keys()) {
  alert(vegetable); // cucumber, tomatoes, onion
}
// iterate over values (amounts)
for (let amount of recipeMap.values()) {
  alert(amount); // 500, 350, 50
}
// iterate over [key, value] entries
for (let entry of recipeMap) { // the same as of recipeMap.entries()
  alert(entry); // cucumber,500 (and so on)
}</code>
  
The insertion order is used
The iteration goes in the same order as the values were inserted. 
<code>Map</code> preserves this order, unlike a regular <code>Object</code>.

Besides that, <code>Map</code> has a built-in <code>forEach</code> method, similar to <code>Array</code>:

    <code>recipeMap.forEach( (value, key, map) =&gt; {
  alert(`${key}: ${value}`); // cucumber: 500 etc
});</code>
  <h2>Set</h2>
A <code>Set</code> is a collection of values, where each value may occur only once.

Its main methods are:

<li><code>new Set(iterable)</code> – creates the set, optionally from an array of values (any iterable will do).</li><li><code>set.add(value)</code> – adds a value, returns the set itself.</li><li><code>set.delete(value)</code> – removes the value, returns <code>true</code> if <code>value</code> existed at the moment of the call, otherwise <code>false</code>.</li><li><code>set.has(value)</code> – returns <code>true</code> if the value exists in the set, otherwise <code>false</code>.</li><li><code>set.clear()</code> – removes everything from the set.</li><li><code>set.size</code> – is the elements count.</li>

For example, we have visitors coming, and we’d like to remember everyone. 
But repeated visits should not lead to duplicates. 
A visitor must be “counted” only once.

<code>Set</code> is just the right thing for that:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let set = new Set();
let john = { name: &quot;John&quot; };
let pete = { name: &quot;Pete&quot; };
let mary = { name: &quot;Mary&quot; };
// visits, some users come multiple times
set.add(john);
set.add(pete);
set.add(mary);
set.add(john);
set.add(mary);
// set keeps only unique values
alert( set.size ); // 3
for (let user of set) {
  alert(user.name); // John (then Pete and Mary)
}</code>
  The alternative to <code>Set</code> could be an array of users, and the code to check for duplicates on every insertion using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find">arr.find</a>. 
But the performance would be much worse, because this method walks through the whole array checking every element. 
<code>Set</code> is much better optimized internally for uniqueness checks.

<h2>Iteration over Set</h2>
We can loop over a set either with <code>for..of</code> or using <code>forEach</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let set = new Set([&quot;oranges&quot;, &quot;apples&quot;, &quot;bananas&quot;]);
for (let value of set) alert(value);
// the same with forEach:
set.forEach((value, valueAgain, set) =&gt; {
  alert(value);
});</code>
  Note the funny thing. 
The <code>forEach</code> function in the <code>Set</code> has 3 arguments: a value, then <em>again a value</em>, and then the target object. 
Indeed, the same value appears in the arguments twice.

That’s for compatibility with <code>Map</code> where <code>forEach</code> has three arguments.

The same methods <code>Map</code> has for iterators are also supported:

<li><code>set.keys()</code> – returns an iterable object for values,</li><li><code>set.values()</code> – same as <code>set.keys</code>, for compatibility with <code>Map</code>,</li><li><code>set.entries()</code> – returns an iterable object for entries <code>[value, value]</code>, exists for compatibility with <code>Map</code>.</li>

<h2>WeakMap and WeakSet</h2>
<code>WeakSet</code> is a special kind of <code>Set</code> that does not prevent JavaScript from removing its items from memory. 
<code>WeakMap</code> is the same thing for <code>Map</code>.

As we know from the chapter <a href="/garbage-collection">Garbage collection</a>, JavaScript engine stores a value in memory while it is reachable (and can potentially be used).

For instance:

    <code>let john = { name: &quot;John&quot; };
// the object can be accessed, john is the reference to it
// overwrite the reference
john = null;
// the object will be removed from memory</code>
  Usually, properties of an object or elements of an array or another data structure are considered reachable and kept in memory while that data structure is in memory.

In a regular <code>Map</code>, it does not matter if we store an object as a key or as a value. 
It’s kept in memory even if there are no more references to it.

For instance:

    <code>let john = { name: &quot;John&quot; };
let map = new Map();
map.set(john, &quot;...&quot;);
john = null; // overwrite the reference
// john is stored inside the map
// we can get it by using map.keys()</code>
  With the exception of <code>WeakMap/WeakSet</code>.

<strong><code>WeakMap/WeakSet</code> does not prevent the object removal from the memory.</strong>

Let’s start with <code>WeakMap</code>.

The first difference from <code>Map</code> is that its keys must be  objects, not primitive values:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let weakMap = new WeakMap();
let obj = {};
weakMap.set(obj, &quot;ok&quot;); // works fine (object key)
weakMap.set(&quot;test&quot;, &quot;Whoops&quot;); // Error, because &quot;test&quot; is a primitive</code>
  Now, if we use an object as the key in it, and there are no other references to that object – it will be removed from memory (and from the map) automatically.

    <code>let john = { name: &quot;John&quot; };
let weakMap = new WeakMap();
weakMap.set(john, &quot;...&quot;);
john = null; // overwrite the reference
// john is removed from memory!</code>
  Compare it with the regular <code>Map</code> example above. 
Now if <code>john</code> only exists as the key of <code>WeakMap</code> – it is to be automatically deleted.

…And <code>WeakMap</code> does not support methods <code>keys()</code>, <code>values()</code>, <code>entries()</code>, we can not iterate over it. 
So there’s really no way to receive all keys or values from it.

<code>WeakMap</code> has only the following methods:

<li><code>weakMap.get(key)</code></li><li><code>weakMap.set(key, value)</code></li><li><code>weakMap.delete(key, value)</code></li><li><code>weakMap.has(key)</code></li>

Why such a limitation? That’s for technical reasons. 
If the object has lost all other references (like <code>john</code> in the code above), then it is to be deleted automatically. 
But technically it’s not exactly specified <em>when the cleanup happens</em>.

The JavaScript engine decides that. 
It may choose to perform the memory cleanup immediately or to wait and do the cleaning later when more deletions happen. 
So, technically the current element count of the <code>WeakMap</code> is not known. 
The engine may have cleaned it up or not, or did it partially. 
For that reason, methods that access <code>WeakMap</code> as a whole are not supported.

Now where do we need such thing?

The idea of <code>WeakMap</code> is that we can store something for an object that exists only while the object exists. 
But we do not force the object to live by the mere fact that we store something for it.

    <code>weakMap.put(john, &quot;secret documents&quot;);
// if john dies, secret documents will be destroyed</code>
  That’s useful for situations when we have a main storage for the objects somewhere and need to keep additional information that is only relevant while the object lives.

Let’s look at an example.

For instance, we have code that keeps a visit count for each user. 
The information is stored in a map: a user is the key and the visit count is the value. 
When a user leaves, we don’t want to store his visit count anymore.

One way would be to keep track of leaving users and clean up the storage manually:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let john = { name: &quot;John&quot; };
// map: user =&gt; visits count
let visitsCountMap = new Map();
// john is the key for the map
visitsCountMap.set(john, 123);
// now john leaves us, we don't need him anymore
john = null;
// but it's still in the map, we need to clean it!
alert( visitsCountMap.size ); // 1
// it's also in the memory, because Map uses it as the key</code>
  Another way would be to use <code>WeakMap</code>:

    <code>let john = { name: &quot;John&quot; };
let visitsCountMap = new WeakMap();
visitsCountMap.set(john, 123);
// now john leaves us, we don't need him anymore
john = null;
// there are no references except WeakMap,
// so the object is removed both from the memory and from visitsCountMap automatically</code>
  With a regular <code>Map</code>, cleaning up after a user has left becomes a tedious task: we not only need to remove the user from its main storage (be it a variable or an array), but also need to clean up the additional stores like <code>visitsCountMap</code>. 
And it can become cumbersome in more complex cases when users are managed in one place of the code and the additional structure is at another place and is getting no information about removals.

<code>WeakMap</code> can make things simpler, because it is cleaned up automatically. 
The information in it like visits count in the example above lives only while the key object exists.

<code>WeakSet</code> behaves similarly:

<li>It is analogous to <code>Set</code>, but we may only add objects to <code>WeakSet</code> (not primitives).</li><li>An object exists in the set while it has reachable from somewhere else.</li><li>Like <code>Set</code>, it supports <code>add</code>, <code>has</code> and <code>delete</code>, but not <code>size</code>, <code>keys()</code> and no iterations.</li>

For instance, we can use it to keep track of whether an item is checked:

    <code>let messages = [
    {text: &quot;Hello&quot;, from: &quot;John&quot;},
    {text: &quot;How goes?&quot;, from: &quot;John&quot;},
    {text: &quot;See you soon&quot;, from: &quot;Alice&quot;}
];
// fill it with array elements (3 items)
let unreadSet = new WeakSet(messages);
// we can use unreadSet to see whether a message is unread
alert(unreadSet.has(messages[1])); // true
// remove it from the set after reading
unreadSet.delete(messages[1]); // true
// and when we shift our messages history, the set is cleaned up automatically
messages.shift();
// no need to clean unreadSet, it now has 2 items
// unfortunately, there's no method to get the exact count of items, so can't show it</code>
  The most notable limitation of <code>WeakMap</code> and <code>WeakSet</code> is the absence of iterations, and inability to get all current content. 
That may appear inconvenient, but actually does not prevent <code>WeakMap/WeakSet</code> from doing their main job – be an “additional” storage of data for objects which are stored/managed at another place.

<h4><a name="summary" href="#summary">Summary</a></h4><li><code>Map</code> – is a collection of keyed values.

The differences from a regular <code>Object</code>:

<li>Any keys, objects can be keys.</li><li>Iterates in the insertion order.</li><li>Additional convenient methods, the <code>size</code> property.</li>

</li><li><code>Set</code> – is a collection of unique values.

<li>Unlike an array, does not allow to reorder elements.</li><li>Keeps the insertion order.</li>

</li><li><code>WeakMap</code> – a variant of <code>Map</code> that allows only objects as keys and removes them once they become inaccessible by other means.

<li>It does not support operations on the structure as a whole: no <code>size</code>, no <code>clear()</code>, no iterations.</li>

</li><li><code>WeakSet</code> – is a variant of <code>Set</code> that only stores objects and removes them once they become inaccessible by other means.

<li>Also does not support <code>size/clear()</code> and iterations.</li>

</li>

<code>WeakMap</code> and <code>WeakSet</code> are used as “secondary” data structures in addition to the “main” object storage. 
Once the object is removed from the main storage, so it only stays in <code>WeakMap/WeakSet</code>, they clean up automatically.

Create a function <code>unique(arr)</code> that should return an array with unique items of <code>arr</code>.

For instance:

    <code>function unique(arr) {
  /* your code */
}
let values = [&quot;Hare&quot;, &quot;Krishna&quot;, &quot;Hare&quot;, &quot;Krishna&quot;,
  &quot;Krishna&quot;, &quot;Krishna&quot;, &quot;Hare&quot;, &quot;Hare&quot;, &quot;:-O&quot;
];
alert( unique(values) ); // Hare, Krishna, :-O</code>
  P.S. 
Here strings are used, but can be values of any type.

P.P.S. 
Use <code>Set</code> to store unique values.

<a href="http://plnkr.co/edit/5723QOW4plHd72CFnXkt?p=preview" target="_blank" data-plunk-id="5723QOW4plHd72CFnXkt">Open the sandbox with tests.</a>
<button type="button">solution</button>

<a href="http://plnkr.co/edit/K1mUBA0aoBVuzuGORbwa?p=preview" target="_blank" data-plunk-id="K1mUBA0aoBVuzuGORbwa">Open the solution with tests in the sandbox.</a>
<button type="button" title="close"></button>

<h3><a href="#filter-anagrams" name="filter-anagrams">Filter anagrams</a></h3><a href="/task/filter-anagrams" target="_blank"></a>

importance: 4

<a href="https://en.wikipedia.org/wiki/Anagram">Anagrams</a> are words that have the same number of same letters, but in different order.

For instance:

    <code>nap - pan
ear - are - era
cheaters - hectares - teachers</code>
  Write a function <code>aclean(arr)</code> that returns an array cleaned from anagrams.

For instance:

    <code>let arr = [&quot;nap&quot;, &quot;teachers&quot;, &quot;cheaters&quot;, &quot;PAN&quot;, &quot;ear&quot;, &quot;era&quot;, &quot;hectares&quot;];
alert( aclean(arr) ); // &quot;nap,teachers,ear&quot; or &quot;PAN,cheaters,era&quot;</code>
  From every anagram group should remain only one word, no matter which one.

<a href="http://plnkr.co/edit/mOXBagh2btVcbeVvyR6s?p=preview" target="_blank" data-plunk-id="mOXBagh2btVcbeVvyR6s">Open the sandbox with tests.</a>
<button type="button">solution</button>

To find all anagrams, let’s split every word to letters and sort them. 
When letter-sorted, all anagrams are same.

For instance:

    <code>nap, pan -&gt; anp
ear, era, are -&gt; aer
cheaters, hectares, teachers -&gt; aceehrst
...</code>
  We’ll use the letter-sorted variants as map keys to store only one value per each key:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function aclean(arr) {
  let map = new Map();
  for (let word of arr) {
    // split the word by letters, sort them and join back
    let sorted = word.toLowerCase().split('').sort().join(''); // (*)
    map.set(sorted, word);
  }
  return Array.from(map.values());
}
let arr = [&quot;nap&quot;, &quot;teachers&quot;, &quot;cheaters&quot;, &quot;PAN&quot;, &quot;ear&quot;, &quot;era&quot;, &quot;hectares&quot;];
alert( aclean(arr) );</code>
  Letter-sorting is done by the chain of calls in the line <code>(*)</code>.

For convenience let’s split it into multiple lines:

    <code>let sorted = arr[i] // PAN
  .toLowerCase() // pan
  .split('') // ['p','a','n']
  .sort() // ['a','n','p']
  .join(''); // anp</code>
  Two different words <code>'PAN'</code> and <code>'nap'</code> receive the same letter-sorted form <code>'anp'</code>.

The next line put the word into the map:

    <code>map.set(sorted, word);</code>
  If we ever meet a word the same letter-sorted form again, then it would overwrite the previous value with the same key in the map. 
So we’ll always have at maximum one word per letter-form.

At the end <code>Array.from(map.values())</code> takes an iterable over map values (we don’t need keys in the result) and returns an array of them.

Here we could also use a plain object instead of the <code>Map</code>, because keys are strings.

That’s how the solution can look:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function aclean(arr) {
  let obj = {};
  for (let i = 0; i &lt; arr.length; i++) {
    let sorted = arr[i].toLowerCase().split(&quot;&quot;).sort().join(&quot;&quot;);
    obj[sorted] = arr[i];
  }
  return Array.from(Object.values(obj));
}
let arr = [&quot;nap&quot;, &quot;teachers&quot;, &quot;cheaters&quot;, &quot;PAN&quot;, &quot;ear&quot;, &quot;era&quot;, &quot;hectares&quot;];
alert( aclean(arr) );</code>
  <a href="http://plnkr.co/edit/aRcFAWDuMSZOOwfJVIrR?p=preview" target="_blank" data-plunk-id="aRcFAWDuMSZOOwfJVIrR">Open the solution with tests in the sandbox.</a>
<button type="button" title="close"></button>

<h3><a href="#iterable-keys" name="iterable-keys">Iterable keys</a></h3><a href="/task/iterable-keys" target="_blank"></a>

importance: 5

We want to get an array of <code>map.keys()</code> and go on working with it (apart from the map itself).

But there’s a problem:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let map = new Map();
map.set(&quot;name&quot;, &quot;John&quot;);
let keys = map.keys();
// Error: numbers.push is not a function
keys.push(&quot;more&quot;);</code>
  Why? How can we fix the code to make <code>keys.push</code> work?

<button type="button">solution</button>

That’s because <code>map.keys()</code> returns an iterable, but not an array.

We can convert it into an array using <code>Array.from</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let map = new Map();
map.set(&quot;name&quot;, &quot;John&quot;);
let keys = Array.from(map.keys());
keys.push(&quot;more&quot;);
alert(keys); // name, more</code>
  <button type="button" title="close"></button>

<h3><a href="#store-unread-flags" name="store-unread-flags">Store &quot;unread&quot; flags</a></h3><a href="/task/recipients-read" target="_blank"></a>

importance: 5

There’s an array of messages:

    <code>let messages = [
    {text: &quot;Hello&quot;, from: &quot;John&quot;},
    {text: &quot;How goes?&quot;, from: &quot;John&quot;},
    {text: &quot;See you soon&quot;, from: &quot;Alice&quot;}
];</code>
  Your code can access it, but the messages are managed by someone else’s code. 
New messages are added, old ones are removed regularly by that code, and you don’t know the exact moments when it happens.

Now, which data structure you could use to store information whether the message “have been read”? The structure must be well-suited to give the answer “was it read?” for the given message object.

P.S. 
When a message is removed from <code>messages</code>, it should disappear from your structure as well.

P.P.S. 
We shouldn’t modify message objects directly. 
If they are managed by someone else’s code, then adding extra properties to them may have bad consequences.

<button type="button">solution</button>

The sane choice here is a <code>WeakSet</code>:

    <code>let messages = [
    {text: &quot;Hello&quot;, from: &quot;John&quot;},
    {text: &quot;How goes?&quot;, from: &quot;John&quot;},
    {text: &quot;See you soon&quot;, from: &quot;Alice&quot;}
];
let readMessages = new WeakSet();
// two messages have been read
readMessages.add(messages[0]);
readMessages.add(messages[1]);
// readMessages has 2 elements
// ...let's read the first message again!
readMessages.add(messages[0]);
// readMessages still has 2 unique elements
// answer: was the message[0] read?
alert(&quot;Read message 0: &quot; + readMessages.has(messages[0])); // true
messages.shift();
// now readMessages has 1 element (technically memory may be cleaned later)</code>
  The <code>WeakSet</code> allows to store a set of messages and easily check for the existance of a message in it.

It cleans up itself automatically. 
The tradeoff is that we can’t iterate over it. 
We can’t get “all read messages” directly. 
But we can do it by iterating over all messages and filtering those that are in the set.

P.S. 
Adding a property of our own to each message may be dangerous if messages are managed by someone else’s code, but we can make it a symbol to evade conflicts.

Like this:

    <code>// the symbolic property is only known to our code
let isRead = Symbol(&quot;isRead&quot;);
messages[0][isRead] = true;</code>
  Now even if someone else’s code uses <code>for..in</code> loop for message properties, our secret flag won’t appear.

<button type="button" title="close"></button>

<h3><a href="#store-read-dates" name="store-read-dates">Store read dates</a></h3><a href="/task/recipients-when-read" target="_blank"></a>

importance: 5

There’s an array of messages as in the <a href="/task/recipients-read">previous task</a>. 
The situation is similar.

    <code>let messages = [
    {text: &quot;Hello&quot;, from: &quot;John&quot;},
    {text: &quot;How goes?&quot;, from: &quot;John&quot;},
    {text: &quot;See you soon&quot;, from: &quot;Alice&quot;}
];</code>
  The question now is: which data structure you’d suggest to store the information: “when the message was read?”.

In the previous task we only needed to store the “yes/no” fact. 
Now we need to store the date and it, once again, should disappear if the message is gone.

<button type="button">solution</button>

To store a date, we can use <code>WeakMap</code>:

    <code>let messages = [
    {text: &quot;Hello&quot;, from: &quot;John&quot;},
    {text: &quot;How goes?&quot;, from: &quot;John&quot;},
    {text: &quot;See you soon&quot;, from: &quot;Alice&quot;}
];
let readMap = new WeakMap();
readMap.set(messages[0], new Date(2017, 1, 1));
// Date object we'll study later</code>
  <button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/iterable" data-tooltip="Iterables">Previous lesson</a><a href="/keys-values-entries" data-tooltip="Object.keys, values, entries">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Fmap-set-weakmap-weakset"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Fmap-set-weakmap-weakset"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Fmap-set-weakmap-weakset"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Fmap-set-weakmap-weakset"></a>

Let’s step away from the individual data structures and talk about the iterations over them.

In the previous chapter we saw methods <code>map.keys()</code>, <code>map.values()</code>, <code>map.entries()</code>.

These methods are generic, there is a common agreement to use them for data structures. 
If we ever create a data structure of our own, we should implement them too.

They are supported for:

<li><code>Map</code></li><li><code>Set</code></li><li><code>Array</code> (except <code>arr.values()</code>)</li>

Plain objects also support similar methods, but the syntax is a bit different.

<h2>Object.keys, values, entries</h2>
For plain objects, the following methods are available:

<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys">Object.keys(obj)</a> – returns an array of keys.</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values">Object.values(obj)</a> – returns an array of values.</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries">Object.entries(obj)</a> – returns an array of <code>[key, value]</code> pairs.</li>

…But please note the distinctions (compared to map for example):

<table>
<thead>
<tr>
<th></th>
<th>Map</th>
<th>Object</th>
</tr>
</thead>
<tbody>
<tr>
<td>Call syntax</td>
<td><code>map.keys()</code></td>
<td><code>Object.keys(obj)</code>, but not <code>obj.keys()</code></td>
</tr>
<tr>
<td>Returns</td>
<td>iterable</td>
<td>“real” Array</td>
</tr>
</tbody>
</table>

The first difference is that we have to call <code>Object.keys(obj)</code>, and not <code>obj.keys()</code>.

Why so? The main reason is flexibility. 
Remember, objects are a base of all complex structures in JavaScript. 
So we may have an object of our own like <code>order</code> that implements its own <code>order.values()</code> method. 
And we still can call <code>Object.values(order)</code> on it.

The second difference is that <code>Object.*</code> methods return “real” array objects, not just an iterable. 
That’s mainly for historical reasons.

For instance:

    <code>let user = {
  name: &quot;John&quot;,
  age: 30
};</code>
  <li><code>Object.keys(user) = [name, age]</code></li><li><code>Object.values(user) = [&quot;John&quot;, 30]</code></li><li><code>Object.entries(user) = [ [&quot;name&quot;,&quot;John&quot;], [&quot;age&quot;,30] ]</code></li>

Here’s an example of using <code>Object.values</code> to loop over property values:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  name: &quot;John&quot;,
  age: 30
};
// loop over values
for (let value of Object.values(user)) {
  alert(value); // John, then 30
}</code>
  <h2>Object.keys/values/entries ignore symbolic properties</h2>
Just like a <code>for..in</code> loop, these methods ignore properties that use <code>Symbol(...)</code> as keys.

Usually that’s convenient. 
But if we want symbolic keys too, then there’s a separate method <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols">Object.getOwnPropertySymbols</a> that returns an array of only symbolic keys. 
Also, the method <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys">Reflect.ownKeys(obj)</a> returns <em>all</em> keys.

Write the function <code>sumSalaries(salaries)</code> that returns the sum of all salaries using <code>Object.values</code> and the <code>for..of</code> loop.

If <code>salaries</code> is empty, then the result must be <code>0</code>.

For instance:

    <code>let salaries = {
  &quot;John&quot;: 100,
  &quot;Pete&quot;: 300,
  &quot;Mary&quot;: 250
};
alert( sumSalaries(salaries) ); // 650</code>
  <a href="http://plnkr.co/edit/zAop4fRA5aFSzxDkiK6o?p=preview" target="_blank" data-plunk-id="zAop4fRA5aFSzxDkiK6o">Open the sandbox with tests.</a>
<button type="button">solution</button>

<a href="http://plnkr.co/edit/2CbjEnAipkl3SEeeaWOA?p=preview" target="_blank" data-plunk-id="2CbjEnAipkl3SEeeaWOA">Open the solution with tests in the sandbox.</a>
<button type="button" title="close"></button>

<h3><a href="#count-properties" name="count-properties">Count properties</a></h3><a href="/task/count-properties" target="_blank"></a>

importance: 5

Write a function <code>count(obj)</code> that returns the number of properties in the object:

    <code>let user = {
  name: 'John',
  age: 30
};
alert( count(user) ); // 2</code>
  Try to make the code as short as possible.

P.S. 
Ignore symbolic properties, count only “regular” ones.

<a href="http://plnkr.co/edit/1FEVH791nOxCZrF6pYLQ?p=preview" target="_blank" data-plunk-id="1FEVH791nOxCZrF6pYLQ">Open the sandbox with tests.</a>
<button type="button">solution</button>

<a href="http://plnkr.co/edit/KmsTIL7INmcRlaCbrKrz?p=preview" target="_blank" data-plunk-id="KmsTIL7INmcRlaCbrKrz">Open the solution with tests in the sandbox.</a>
<button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/map-set-weakmap-weakset" data-tooltip="Map, Set, WeakMap and WeakSet">Previous lesson</a><a href="/destructuring-assignment" data-tooltip="Destructuring assignment">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Fkeys-values-entries"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Fkeys-values-entries"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Fkeys-values-entries"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Fkeys-values-entries"></a>

The two most used data structures in JavaScript are <code>Object</code> and <code>Array</code>.

Objects allow us to pack many pieces of information into a single entity and arrays allow us to store ordered collections. 
So we can make an object or an array and handle it as a single entity, or maybe pass it to a function call.

<em>Destructuring assignment</em> is a special syntax that allows us to “unpack” arrays or objects into a bunch of variables, as sometimes they are more convenient. 
Destructuring also works great with complex functions that have a lot of parameters, default values, and soon we’ll see how these are handled too.

<h2>Array destructuring</h2>
An example of how the array is destructured into variables:

    <code>// we have an array with the name and surname
let arr = [&quot;Ilya&quot;, &quot;Kantor&quot;]
// destructuring assignment
let [firstName, surname] = arr;
alert(firstName); // Ilya
alert(surname);  // Kantor</code>
  Now we can work with variables instead of array members.

It looks great when combined with <code>split</code> or other array-returning methods:

    <code>let [firstName, surname] = &quot;Ilya Kantor&quot;.split(' ');</code>
  
“Destructuring” does not mean “destructive”
It’s called “destructuring assignment”, because it “destructurizes” by copying items into variables. 
But the array itself is not modified.

It’s just a shorter way to write:

    <code>// let [firstName, surname] = arr;
let firstName = arr[0];
let surname = arr[1];</code>
  

Ignore first elements
Unwanted elements of the array can also be thrown away via an extra comma:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// first and second elements are not needed
let [, , title] = [&quot;Julius&quot;, &quot;Caesar&quot;, &quot;Consul&quot;, &quot;of the Roman Republic&quot;];
alert( title ); // Consul</code>
  In the code above, although the first and second elements of the array are skipped, the third one is assigned to <code>title</code>, and the rest are also skipped.

Works with any iterable on the right-side
…Actually, we can use it with any iterable, not only arrays:

    <code>let [a, b, c] = &quot;abc&quot;; // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
let [one, two, three] = new Set([1, 2, 3]);</code>
  

Assign to anything at the left-side
We can use any “assignables” at the left side.

For instance, an object property:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {};
[user.name, user.surname] = &quot;Ilya Kantor&quot;.split(' ');
alert(user.name); // Ilya</code>
  

Looping with .entries()
In the previous chapter we saw the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries">Object.entries(obj)</a> method.

We can use it with destructuring to loop over keys-and-values of an object:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  name: &quot;John&quot;,
  age: 30
};
// loop over keys-and-values
for (let [key, value] of Object.entries(user)) {
  alert(`${key}:${value}`); // name:John, then age:30
}</code>
  …And the same for a map:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = new Map();
user.set(&quot;name&quot;, &quot;John&quot;);
user.set(&quot;age&quot;, &quot;30&quot;);
for (let [key, value] of user.entries()) {
  alert(`${key}:${value}`); // name:John, then age:30
}</code>
  
<h3><a name="the-rest" href="#the-rest">The rest ‘…’</a></h3>
If we want not just to get first values, but also to gather all that follows – we can add one more parameter that gets “the rest” using three dots <code>&quot;...&quot;</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let [name1, name2, ...rest] = [&quot;Julius&quot;, &quot;Caesar&quot;, &quot;Consul&quot;, &quot;of the Roman Republic&quot;];
alert(name1); // Julius
alert(name2); // Caesar
alert(rest[0]); // Consul
alert(rest[1]); // of the Roman Republic
alert(rest.length); // 2</code>
  The value of <code>rest</code> is the array of the remaining array elements. 
We can use any other variable name in place of <code>rest</code>, just make sure it has three dots before it and goes last in the destructuring assignment.

<h3><a name="default-values" href="#default-values">Default values</a></h3>
If there are fewer values in the array than variables in the assignment, there will be no error. 
Absent values are considered undefined:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let [firstName, surname] = [];
alert(firstName); // undefined</code>
  If we want a “default” value to replace the missing one, we can provide it using <code>=</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// default values
let [name = &quot;Guest&quot;, surname = &quot;Anonymous&quot;] = [&quot;Julius&quot;];
alert(name);    // Julius (from array)
alert(surname); // Anonymous (default used)</code>
  Default values can be more complex expressions or even function calls. 
They are evaluated only if the value is not provided.

For instance, here we use the <code>prompt</code> function for two defaults. 
But it will run only for the missing one:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// runs only prompt for surname
let [name = prompt('name?'), surname = prompt('surname?')] = [&quot;Julius&quot;];
alert(name);    // Julius (from array)
alert(surname); // whatever prompt gets</code>
  <h2>Object destructuring</h2>
The destructuring assignment also works with objects.

The basic syntax is:

    <code>let {var1, var2} = {var1:…, var2…}</code>
  We have an existing object at the right side, that we want to split into variables. 
The left side contains a “pattern” for corresponding properties. 
In the simple case, that’s a list of variable names in <code>{...}</code>.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let options = {
  title: &quot;Menu&quot;,
  width: 100,
  height: 200
};
let {title, width, height} = options;
alert(title);  // Menu
alert(width);  // 100
alert(height); // 200</code>
  Properties <code>options.title</code>, <code>options.width</code> and <code>options.height</code> are assigned to the corresponding variables. 
The order does not matter. 
This works too:

    <code>// changed the order of properties in let {...}
let {height, width, title} = { title: &quot;Menu&quot;, height: 200, width: 100 }</code>
  The pattern on the left side may be more complex and specify the mapping between properties and variables.

If we want to assign a property to a variable with another name, for instance, <code>options.width</code> to go into the variable named <code>w</code>, then we can set it using a colon:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let options = {
  title: &quot;Menu&quot;,
  width: 100,
  height: 200
};
// { sourceProperty: targetVariable }
let {width: w, height: h, title} = options;
// width -&gt; w
// height -&gt; h
// title -&gt; title
alert(title);  // Menu
alert(w);      // 100
alert(h);      // 200</code>
  The colon shows “what : goes where”. 
In the example above the property <code>width</code> goes to <code>w</code>, property <code>height</code> goes to <code>h</code>, and <code>title</code> is assigned to the same name.

For potentially missing properties we can set default values using <code>&quot;=&quot;</code>, like this:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let options = {
  title: &quot;Menu&quot;
};
let {width = 100, height = 200, title} = options;
alert(title);  // Menu
alert(width);  // 100
alert(height); // 200</code>
  Just like with arrays or function parameters, default values can be any expressions or even function calls. 
They will be evaluated if the value is not provided.

The code below asks for width, but not the title.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let options = {
  title: &quot;Menu&quot;
};
let {width = prompt(&quot;width?&quot;), title = prompt(&quot;title?&quot;)} = options;
alert(title);  // Menu
alert(width);  // (whatever you the result of prompt is)</code>
  We also can combine both the colon and equality:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let options = {
  title: &quot;Menu&quot;
};
let {width: w = 100, height: h = 200, title} = options;
alert(title);  // Menu
alert(w);      // 100
alert(h);      // 200</code>
  <h3><a name="the-rest-operator" href="#the-rest-operator">The rest operator</a></h3>
What if the object has more properties than we have variables? Can we take some and then assign the “rest” somewhere?

The specification for using the rest operator (three dots) here is almost in the standard, but most browsers do not support it yet.

It looks like this:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let options = {
  title: &quot;Menu&quot;,
  height: 200,
  width: 100
};
let {title, ...rest} = options;
// now title=&quot;Menu&quot;, rest={height: 200, width: 100}
alert(rest.height);  // 200
alert(rest.width);   // 100</code>
  
Gotcha without <code>let</code>
In the examples above variables were declared right before the assignment: <code>let {…} = {…}</code>. 
Of course, we could use existing variables too. 
But there’s a catch.

This won’t work:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let title, width, height;
// error in this line
{title, width, height} = {title: &quot;Menu&quot;, width: 200, height: 100};</code>
  The problem is that JavaScript treats <code>{...}</code> in the main code flow (not inside another expression) as a code block. 
Such code blocks can be used to group statements, like this:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>{
  // a code block
  let message = &quot;Hello&quot;;
  // ...
  alert( message );
}</code>
  To show JavaScript that it’s not a code block, we can wrap the whole assignment in brackets <code>(...)</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let title, width, height;
// okay now
({title, width, height} = {title: &quot;Menu&quot;, width: 200, height: 100});
alert( title ); // Menu</code>
  
<h2>Nested destructuring</h2>
If an object or an array contain other objects and arrays, we can use more complex left-side patterns to extract deeper portions.

In the code below <code>options</code> has another object in the property <code>size</code> and an array in the property <code>items</code>. 
The pattern at the left side of the assignment has the same structure:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let options = {
  size: {
    width: 100,
    height: 200
  },
  items: [&quot;Cake&quot;, &quot;Donut&quot;],
  extra: true    // something extra that we will not destruct
};
// destructuring assignment on multiple lines for clarity
let {
  size: { // put size here
    width,
    height
  },
  items: [item1, item2], // assign items here
  title = &quot;Menu&quot; // not present in the object (default value is used)
} = options;
alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
alert(item1);  // Cake
alert(item2);  // Donut</code>
  The whole <code>options</code> object except <code>extra</code> that was not mentioned, is assigned to corresponding variables.

<img src="https://javascript.info/article/destructuring-assignment/destructuring-complex.png">
Finally, we have <code>width</code>, <code>height</code>, <code>item1</code>, <code>item2</code> and <code>title</code> from the default value.

That often happens with destructuring assignments. 
We have a complex object with many properties and want to extract only what we need.

Even here it happens:

    <code>// take size as a whole into a variable, ignore the rest
let { size } = options;</code>
  <h2>Smart function parameters</h2>
There are times when a function may have many parameters, most of which are optional. 
That’s especially true for user interfaces. 
Imagine a function that creates a menu. 
It may have a width, a height, a title, items list and so on.

Here’s a bad way to write such function:

    <code>function showMenu(title = &quot;Untitled&quot;, width = 200, height = 100, items = []) {
  // ...
}</code>
  In real-life the problem is how to remember the order of arguments. 
Usually IDEs try to help us, especially if the code is well-documented, but still… Another problem is how to call a function when most parameters are ok by default.

Like this?

    <code>showMenu(&quot;My Menu&quot;, undefined, undefined, [&quot;Item1&quot;, &quot;Item2&quot;])</code>
  That’s ugly. 
And becomes unreadable when we deal with more parameters.

Destructuring comes to the rescue!

We can pass parameters as an object, and the function immediately destructurizes them into variables:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// we pass object to function
let options = {
  title: &quot;My menu&quot;,
  items: [&quot;Item1&quot;, &quot;Item2&quot;]
};
// ...and it immediately expands it to variables
function showMenu({title = &quot;Untitled&quot;, width = 200, height = 100, items = []}) {
  // title, items – taken from options,
  // width, height – defaults used
  alert( `${title} ${width} ${height}` ); // My Menu 200 100
  alert( items ); // Item1, Item2
}
showMenu(options);</code>
  We can also use more complex destructuring with nested objects and colon mappings:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let options = {
  title: &quot;My menu&quot;,
  items: [&quot;Item1&quot;, &quot;Item2&quot;]
};
function showMenu({
  title = &quot;Untitled&quot;,
  width: w = 100,  // width goes to w
  height: h = 200, // height goes to h
  items: [item1, item2] // items first element goes to item1, second to item2
}) {
  alert( `${title} ${w} ${h}` ); // My Menu 100 200
  alert( item1 ); // Item1
  alert( item2 ); // Item2
}
showMenu(options);</code>
  The syntax is the same as for a destructuring assignment:

    <code>function({
  incomingProperty: parameterName = defaultValue
  ...
})</code>
  Please note that such destructuring assumes that <code>showMenu()</code> does have an argument. 
If we want all values by default, then we should specify an empty object:

    <code>showMenu({});
showMenu(); // this would give an error</code>
  We can fix this by making <code>{}</code> the default value for the whole destructuring thing:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// simplified parameters a bit for clarity
function showMenu({ title = &quot;Menu&quot;, width = 100, height = 200 } = {}) {
  alert( `${title} ${width} ${height}` );
}
showMenu(); // Menu 100 200</code>
  In the code above, the whole arguments object is <code>{}</code> by default, so there’s always something to destructurize.

<h4><a name="summary" href="#summary">Summary</a></h4><li>Destructuring assignment allows for instantly mapping an object or array onto many variables.

</li><li>The object syntax:

    <code>let {prop : varName = default, ...} = object</code>
  This means that property <code>prop</code> should go into the variable <code>varName</code> and, if no such property exists, then <code>default</code> value should be used.

</li><li>The array syntax:

    <code>let [item1 = default, item2, ...rest] = array</code>
  The first item goes to <code>item1</code>, the second goes into <code>item2</code>, all the rest makes the array <code>rest</code>.

</li><li>For more complex cases, the left side must have the same structure as the right one.

</li>

    <code>let user = {
  name: &quot;John&quot;,
  years: 30
};</code>
  Write the destructuring assignment that reads:

<li><code>name</code> property into the variable <code>name</code>.</li><li><code>years</code> property into the variable <code>age</code>.</li><li><code>isAdmin</code> property into the variable <code>isAdmin</code> (false if absent)</li>

The values after the assignment should be:

    <code>let user = { name: &quot;John&quot;, years: 30 };
// your code to the left side:
// ... 
= user
alert( name ); // John
alert( age ); // 30
alert( isAdmin ); // false</code>
  <button type="button">solution</button>

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  name: &quot;John&quot;,
  years: 30
};
let {name, years: age, isAdmin = false} = user;
alert( name ); // John
alert( age ); // 30
alert( isAdmin ); // false</code>
  <button type="button" title="close"></button>

<h3><a href="#the-maximal-salary" name="the-maximal-salary">The maximal salary</a></h3><a href="/task/max-salary" target="_blank"></a>

importance: 5

There is a <code>salaries</code> object:

    <code>let salaries = {
  &quot;John&quot;: 100,
  &quot;Pete&quot;: 300,
  &quot;Mary&quot;: 250
};</code>
  Create the function <code>topSalary(salaries)</code> that returns the name of the top-paid person.

<li>If <code>salaries</code> is empty, it should return <code>null</code>.</li><li>If there are multiple top-paid persons, return any of them.</li>

P.S. 
Use <code>Object.entries</code> and destructuring to iterate over key/value pairs.

<a href="http://plnkr.co/edit/aePioeOVl8dRbT28tE1d?p=preview" target="_blank" data-plunk-id="aePioeOVl8dRbT28tE1d">Open the sandbox with tests.</a>
<button type="button">solution</button>

<a href="http://plnkr.co/edit/TqVaqM3Hk0VFSA1pEtUa?p=preview" target="_blank" data-plunk-id="TqVaqM3Hk0VFSA1pEtUa">Open the solution with tests in the sandbox.</a>
<button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/keys-values-entries" data-tooltip="Object.keys, values, entries">Previous lesson</a><a href="/date" data-tooltip="Date and time">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Fdestructuring-assignment"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Fdestructuring-assignment"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Fdestructuring-assignment"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Fdestructuring-assignment"></a>

Let’s meet a new built-in object: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date">Date</a>. 
It stores the date, time and provides methods for date/time management.

For instance, we can use it to store creation/modification times, or to measure time, or just to print out the current date.

<h2>Creation</h2>
To create a new <code>Date</code> object call <code>new Date()</code> with one of the following arguments:

<dl>
<dt><code>new Date()</code></dt>
<dd>

Without arguments – create a <code>Date</code> object for the current date and time:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let now = new Date();
alert( now ); // shows current date/time</code>
  </dd>
<dt><code>new Date(milliseconds)</code></dt>
<dd>

Create a <code>Date</code> object with the time equal to number of milliseconds (1/1000 of a second) passed after the Jan 1st of 1970 UTC+0.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// 0 means 01.01.1970 UTC+0
let Jan01_1970 = new Date(0);
alert( Jan01_1970 );
// now add 24 hours, get 02.01.1970 UTC+0
let Jan02_1970 = new Date(24 * 3600 * 1000);
alert( Jan02_1970 );</code>
  The number of milliseconds that has passed since the beginning of 1970 is called a <em>timestamp</em>.

It’s a lightweight numeric representation of a date. 
We can always create a date from a timestamp using <code>new Date(timestamp)</code> and convert the existing <code>Date</code> object to a timestamp using the <code>date.getTime()</code> method (see below).

</dd>
<dt><code>new Date(datestring)</code></dt>
<dd>

If there is a single argument, and it’s a string, then it is parsed with the <code>Date.parse</code> algorithm (see below).

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let date = new Date(&quot;2017-01-26&quot;);
alert(date); // Thu Jan 26 2017 ...</code>
  </dd>
<dt><code>new Date(year, month, date, hours, minutes, seconds, ms)</code></dt>
<dd>

Create the date with the given components in the local time zone. 
Only two first arguments are obligatory.

Note:

<li>The <code>year</code> must have 4 digits: <code>2013</code> is okay, <code>98</code> is not.</li><li>The <code>month</code> count starts with <code>0</code> (Jan), up to <code>11</code> (Dec).</li><li>The <code>date</code> parameter is actually the day of month, if absent then <code>1</code> is assumed.</li><li>If <code>hours/minutes/seconds/ms</code> is absent, they are assumed to be equal <code>0</code>.</li>

For instance:

    <code>new Date(2011, 0, 1, 0, 0, 0, 0); // // 1 Jan 2011, 00:00:00
new Date(2011, 0, 1); // the same, hours etc are 0 by default</code>
  The minimal precision is 1 ms (1/1000 sec):

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let date = new Date(2011, 0, 1, 2, 3, 4, 567);
alert( date ); // 1.01.2011, 02:03:04.567</code>
  </dd>
</dl>

<h2>Access date components</h2>
There are many methods to access the year, month and so on from the <code>Date</code> object. 
But they can be easily remembered when categorized.

<dl>
<dt><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getFullYear">getFullYear()</a></dt>
<dd>Get the year (4 digits)</dd>
<dt><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getMonth">getMonth()</a></dt>
<dd>Get the month, <strong>from 0 to 11</strong>.</dd>
<dt><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getDate">getDate()</a></dt>
<dd>Get the day of month, from 1 to 31, the name of the method does look a little bit strange.</dd>
<dt><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getHours">getHours()</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getMinutes">getMinutes()</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getSeconds">getSeconds()</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getMilliseconds">getMilliseconds()</a></dt>
<dd>Get the corresponding time components.</dd>
</dl>

Not <code>getYear()</code>, but <code>getFullYear()</code>
Many JavaScript engines implement a non-standard method <code>getYear()</code>. 
This method is deprecated. 
It returns 2-digit year sometimes. 
Please never use it. 
There is <code>getFullYear()</code> for the year.

Additionally, we can get a day of week:

<dl>
<dt><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getDay">getDay()</a></dt>
<dd>Get the day of week, from <code>0</code> (Sunday) to <code>6</code> (Saturday). 
The first day is always Sunday, in some countries that’s not so, but can’t be changed.</dd>
</dl>

<strong>All the methods above return the components relative to the local time zone.</strong>

There are also their UTC-counterparts, that return day, month, year and so on for the time zone UTC+0: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getUTCFullYear">getUTCFullYear()</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getUTCMonth">getUTCMonth()</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getUTCDay">getUTCDay()</a>. 
Just insert the <code>&quot;UTC&quot;</code> right after <code>&quot;get&quot;</code>.

If your local time zone is shifted relative to UTC, then the code below shows different hours:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// current date
let date = new Date();
// the hour in your current time zone
alert( date.getHours() );
// the hour in UTC+0 time zone (London time without daylight savings)
alert( date.getUTCHours() );</code>
  Besides the given methods, there are two special ones, that do not have a UTC-variant:

<dl>
<dt><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getTime">getTime()</a></dt>
<dd>

Returns the timestamp for the date – a number of milliseconds passed from the January 1st of 1970 UTC+0.

</dd>
<dt><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset">getTimezoneOffset()</a></dt>
<dd>

Returns the difference between the local time zone and UTC, in minutes:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// if you are in timezone UTC-1, outputs 60
// if you are in timezone UTC+3, outputs -180
alert( new Date().getTimezoneOffset() );</code>
  </dd>
</dl>

<h2>Setting date components</h2>
The following methods allow to set date/time components:

<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/setFullYear"><code>setFullYear(year [, month, date])</code></a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/setMonth"><code>setMonth(month [, date])</code></a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/setDate"><code>setDate(date)</code></a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/setHours"><code>setHours(hour [, min, sec, ms])</code></a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/setMinutes"><code>setMinutes(min [, sec, ms])</code></a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/setSeconds"><code>setSeconds(sec [, ms])</code></a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/setMilliseconds"><code>setMilliseconds(ms)</code></a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/setTime"><code>setTime(milliseconds)</code></a> (sets the whole date by milliseconds since 01.01.1970 UTC)</li>

Every one of them except <code>setTime()</code> has a UTC-variant, for instance: <code>setUTCHours()</code>.

As we can see, some methods can set multiple components at once, for example <code>setHours</code>. 
The components that are not mentioned are not modified.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let today = new Date();
today.setHours(0);
alert(today); // still today, but the hour is changed to 0
today.setHours(0, 0, 0, 0);
alert(today); // still today, now 00:00:00 sharp.</code>
  <h2>Autocorrection</h2>
The <em>autocorrection</em> is a very handy feature of <code>Date</code> objects. 
We can set out-of-range values, and it will auto-adjust itself.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let date = new Date(2013, 0, 32); // 32 Jan 2013 ?!?
alert(date); // ...is 1st Feb 2013!</code>
  Out-of-range date components are distributed automatically.

Let’s say we need to increase the date “28 Feb 2016” by 2 days. 
It may be “2 Mar” or “1 Mar” in case of a leap-year. 
We don’t need to think about it. 
Just add 2 days. 
The <code>Date</code> object will do the rest:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let date = new Date(2016, 1, 28);
date.setDate(date.getDate() + 2);
alert( date ); // 1 Mar 2016</code>
  That feature is often used to get the date after the given period of time. 
For instance, let’s get the date for “70 seconds after now”:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let date = new Date();
date.setSeconds(date.getSeconds() + 70);
alert( date ); // shows the correct date</code>
  We can also set zero or even negative values. 
For example:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let date = new Date(2016, 0, 2); // 2 Jan 2016
date.setDate(1); // set day 1 of month
alert( date );
date.setDate(0); // min day is 1, so the last day of the previous month is assumed
alert( date ); // 31 Dec 2015</code>
  <h2>Date to number, date diff</h2>
When a <code>Date</code> object is converted to number, it becomes the timestamp same as <code>date.getTime()</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let date = new Date();
alert(+date); // the number of milliseconds, same as date.getTime()</code>
  The important side effect: dates can be subtracted, the result is their difference in ms.

That can be used for time measurements:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let start = new Date(); // start counting
// do the job
for (let i = 0; i &lt; 100000; i++) {
  let doSomething = i * i * i;
}
let end = new Date(); // done
alert( `The loop took ${end - start} ms` );</code>
  <h2>Date.now()</h2>
If we only want to measure the difference, we don’t need the <code>Date</code> object.

There’s a special method <code>Date.now()</code> that returns the current timestamp.

It is semantically equivalent to <code>new Date().getTime()</code>, but it doesn’t create an intermediate <code>Date</code> object. 
So it’s faster and doesn’t put pressure on garbage collection.

It is used mostly for convenience or when performance matters, like in games in JavaScript or other specialized applications.

So this is probably better:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let start = Date.now(); // milliseconds count from 1 Jan 1970
// do the job
for (let i = 0; i &lt; 100000; i++) {
  let doSomething = i * i * i;
}
let end = Date.now(); // done
alert( `The loop took ${end - start} ms` ); // subtract numbers, not dates</code>
  <h2>Benchmarking</h2>
If we want a reliable benchmark of CPU-hungry function, we should be careful.

For instance, let’s measure two functions that calculate the difference between two dates: which one is faster?

    <code>// we have date1 and date2, which function faster returns their difference in ms?
function diffSubtract(date1, date2) {
  return date2 - date1;
}
// or
function diffGetTime(date1, date2) {
  return date2.getTime() - date1.getTime();
}</code>
  These two do exactly the same thing, but one of them uses an explicit <code>date.getTime()</code> to get the date in ms, and the other one relies on a date-to-number transform. 
Their result is always the same.

So, which one is faster?

The first idea may be to run them many times in a row and measure the time difference. 
For our case, functions are very simple, so we have to do it around 100000 times.

Let’s measure:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function diffSubtract(date1, date2) {
  return date2 - date1;
}
function diffGetTime(date1, date2) {
  return date2.getTime() - date1.getTime();
}
function bench(f) {
  let date1 = new Date(0);
  let date2 = new Date();
  let start = Date.now();
  for (let i = 0; i &lt; 100000; i++) f(date1, date2);
  return Date.now() - start;
}
alert( 'Time of diffSubtract: ' + bench(diffSubtract) + 'ms' );
alert( 'Time of diffGetTime: ' + bench(diffGetTime) + 'ms' );</code>
  Wow! Using <code>getTime()</code> is so much faster! That’s because there’s no type conversion, it is much easier for engines to optimize.

Okay, we have something. 
But that’s not a good benchmark yet.

Imagine that at the time of running <code>bench(diffSubtract)</code> CPU was doing something in parallel, and it was taking resources. 
And by the time of running <code>bench(diffGetTime)</code> the work has finished.

A pretty real scenario for a modern multi-process OS.

As a result, the first benchmark will have less CPU resources than the second. 
That may lead to wrong results.

<strong>For more reliable benchmarking, the whole pack of benchmarks should be rerun multiple times.</strong>

Here’s the code example:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function diffSubtract(date1, date2) {
  return date2 - date1;
}
function diffGetTime(date1, date2) {
  return date2.getTime() - date1.getTime();
}
function bench(f) {
  let date1 = new Date(0);
  let date2 = new Date();
  let start = Date.now();
  for (let i = 0; i &lt; 100000; i++) f(date1, date2);
  return Date.now() - start;
}
let time1 = 0;
let time2 = 0;
// run bench(upperSlice) and bench(upperLoop) each 10 times alternating
for (let i = 0; i &lt; 10; i++) {
  time1 += bench(diffSubtract);
  time2 += bench(diffGetTime);
}
alert( 'Total time for diffSubtract: ' + time1 );
alert( 'Total time for diffGetTime: ' + time2 );</code>
  Modern JavaScript engines start applying advanced optimizations only to “hot code” that executes many times (no need to optimize rarely executed things). 
So, in the example above, first executions are not well-optimized. 
We may want to add a heat-up run:

    <code>// added for &quot;heating up&quot; prior to the main loop
bench(diffSubtract);
bench(diffGetTime);
// now benchmark
for (let i = 0; i &lt; 10; i++) {
  time1 += bench(diffSubtract);
  time2 += bench(diffGetTime);
}</code>
  

Be careful doing microbenchmarking
Modern JavaScript engines perform many optimizations. 
They may tweak results of “artificial tests” compared to “normal usage”, especially when we benchmark something very small. 
So if you seriously want to understand performance, then please study how the JavaScript engine works. 
And then you probably won’t need microbenchmarks at all.

The great pack of articles about V8 can be found at <a href="http://mrale.ph">http://mrale.ph</a>.

<h2>Date.parse from a string</h2>
The method <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse">Date.parse(str)</a> can read a date from a string.

The string format should be: <code>YYYY-MM-DDTHH:mm:ss.sssZ</code>, where:

<li><code>YYYY-MM-DD</code> – is the date: year-month-day.</li><li>The character <code>&quot;T&quot;</code> is used as the delimiter.</li><li><code>HH:mm:ss.sss</code> – is the time: hours, minutes, seconds and milliseconds.</li><li>The optional <code>'Z'</code> part denotes the time zone in the format <code>+-hh:mm</code>. 
A single letter <code>Z</code> that would mean UTC+0.</li>

Shorter variants are also possible, like <code>YYYY-MM-DD</code> or <code>YYYY-MM</code> or even <code>YYYY</code>.

The call to <code>Date.parse(str)</code> parses the string in the given format and returns the timestamp (number of milliseconds from 1 Jan 1970 UTC+0). 
If the format is invalid, returns <code>NaN</code>.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let ms = Date.parse('2012-01-26T13:51:50.417-07:00');
alert(ms); // 1327611110417  (timestamp)</code>
  We can instantly create a <code>new Date</code> object from the timestamp:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let date = new Date( Date.parse('2012-01-26T13:51:50.417-07:00') );
alert(date);</code>
  <h4><a name="summary" href="#summary">Summary</a></h4><li>Date and time in JavaScript are represented with the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date">Date</a> object. 
We can’t create “only date” or “only time”: <code>Date</code> objects always carry both.</li><li>Months are counted from zero (yes, January is a zero month).</li><li>Days of week in <code>getDay()</code> are also counted from zero (that’s Sunday).</li><li><code>Date</code> auto-corrects itself when out-of-range components are set. 
Good for adding/subtracting days/months/hours.</li><li>Dates can be subtracted, giving their difference in milliseconds. 
That’s because a <code>Date</code> becomes the timestamp when converted to a number.</li><li>Use <code>Date.now()</code> to get the current timestamp fast.</li>

Note that unlike many other systems, timestamps in JavaScript are in milliseconds, not in seconds.

Also, sometimes we need more precise time measurements. 
JavaScript itself does not have a way to measure time in microseconds (1 millionth of a second), but most environments provide it. 
For instance, browser has <a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/now">performance.now()</a> that gives the number of milliseconds from the start of page loading with microsecond precision (3 digits after the point):

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert(`Loading started ${performance.now()}ms ago`);
// Something like: &quot;Loading started 34731.26000000001ms ago&quot;
// .26 is microseconds (260 microseconds)
// more than 3 digits after the decimal point are precision errors, but only the first 3 are correct</code>
  Node.JS has <code>microtime</code> module and other ways. 
Technically, any device and environment allows to get more precision, it’s just not in <code>Date</code>.

Show it using <code>alert</code>.

<button type="button">solution</button>

The <code>new Date</code> constructor uses the local time zone by default. 
So the only important thing to remember is that months start from zero.

So February has number 1.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let d = new Date(2012, 1, 20, 3, 12);
alert( d );</code>
  <button type="button" title="close"></button>

<h3><a href="#show-a-weekday" name="show-a-weekday">Show a weekday</a></h3><a href="/task/get-week-day" target="_blank"></a>

importance: 5

Write a function <code>getWeekDay(date)</code> to show the weekday in short format: ‘MO’, ‘TU’, ‘WE’, ‘TH’, ‘FR’, ‘SA’, ‘SU’.

For instance:

    <code>let date = new Date(2012, 0, 3);  // 3 Jan 2012
alert( getWeekDay(date) );        // should output &quot;TU&quot;</code>
  <a href="http://plnkr.co/edit/SRHlW0yuwHfK7OUnaBZ3?p=preview" target="_blank" data-plunk-id="SRHlW0yuwHfK7OUnaBZ3">Open the sandbox with tests.</a>
<button type="button">solution</button>

The method <code>date.getDay()</code> returns the number of the weekday, starting from sunday.

Let’s make an array of weekdays, so that we can get the proper day name by its number:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function getWeekDay(date) {
  let days = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];
  return days[date.getDay()];
}
let date = new Date(2014, 0, 3); // 3 Jan 2014
alert( getWeekDay(date) ); // FR</code>
  <a href="http://plnkr.co/edit/y9vVaC2RDgfZbtByXd03?p=preview" target="_blank" data-plunk-id="y9vVaC2RDgfZbtByXd03">Open the solution with tests in the sandbox.</a>
<button type="button" title="close"></button>

<h3><a href="#european-weekday" name="european-weekday">European weekday</a></h3><a href="/task/weekday" target="_blank"></a>

importance: 5

European countries have days of week starting with monday (number 1), then tuesday (number 2) and till sunday (number 7). 
Write a function <code>getLocalDay(date)</code> that returns the “european” day of week for <code>date</code>.

    <code>let date = new Date(2012, 0, 3);  // 3 Jan 2012
alert( getLocalDay(date) );       // tuesday, should show 2</code>
  <a href="http://plnkr.co/edit/hJFIBCvZMUBncBwLU1Y2?p=preview" target="_blank" data-plunk-id="hJFIBCvZMUBncBwLU1Y2">Open the sandbox with tests.</a>
<button type="button">solution</button>

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function getLocalDay(date) {
  let day = date.getDay();
  if (day == 0) { // 0 becomes 7
    day = 7;
  }
  return day;
}
alert( getLocalDay(new Date(2012, 0, 3)) ); // 2</code>
  <a href="http://plnkr.co/edit/rQzokFiAwOXAIxtxYSCG?p=preview" target="_blank" data-plunk-id="rQzokFiAwOXAIxtxYSCG">Open the solution with tests in the sandbox.</a>
<button type="button" title="close"></button>

<h3><a href="#which-day-of-month-was-many-days-ago" name="which-day-of-month-was-many-days-ago">Which day of month was many days ago?</a></h3><a href="/task/get-date-ago" target="_blank"></a>

importance: 4

Create a function <code>getDateAgo(date, days)</code> to return the day of month <code>days</code> ago from the <code>date</code>.

For instance, if today is 20th, then <code>getDateAgo(new Date(), 1)</code> should be 19th and <code>getDateAgo(new Date(), 2)</code> should be 18th.

Should also work over months/years reliably:

    <code>let date = new Date(2015, 0, 2);
alert( getDateAgo(date, 1) ); // 1, (1 Jan 2015)
alert( getDateAgo(date, 2) ); // 31, (31 Dec 2014)
alert( getDateAgo(date, 365) ); // 2, (2 Jan 2014)</code>
  P.S. 
The function should not modify the given <code>date</code>.

<a href="http://plnkr.co/edit/1UsWlTJtd6exGZRAmAPf?p=preview" target="_blank" data-plunk-id="1UsWlTJtd6exGZRAmAPf">Open the sandbox with tests.</a>
<button type="button">solution</button>

The idea is simple: to substract given number of days from <code>date</code>:

    <code>function getDateAgo(date, days) {
  date.setDate(date.getDate() - days);
  return date.getDate();
}</code>
  …But the function should not change <code>date</code>. 
That’s an important thing, because the outer code which gives us the date does not expect it to change.

To implement it let’s clone the date, like this:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function getDateAgo(date, days) {
  let dateCopy = new Date(date);
  dateCopy.setDate(date.getDate() - days);
  return dateCopy.getDate();
}
let date = new Date(2015, 0, 2);
alert( getDateAgo(date, 1) ); // 1, (1 Jan 2015)
alert( getDateAgo(date, 2) ); // 31, (31 Dec 2014)
alert( getDateAgo(date, 365) ); // 2, (2 Jan 2014)</code>
  <a href="http://plnkr.co/edit/FJCM2tlMY0l68zZ4zroJ?p=preview" target="_blank" data-plunk-id="FJCM2tlMY0l68zZ4zroJ">Open the solution with tests in the sandbox.</a>
<button type="button" title="close"></button>

<h3><a href="#last-day-of-month" name="last-day-of-month">Last day of month?</a></h3><a href="/task/last-day-of-month" target="_blank"></a>

importance: 5

Write a function <code>getLastDayOfMonth(year, month)</code> that returns the last day of month. 
Sometimes it is 30th, 31st or even 28/29th for Feb.

Parameters:

<li><code>year</code> – four-digits year, for instance 2012.</li><li><code>month</code> – month, from 0 to 11.</li>

For instance, <code>getLastDayOfMonth(2012, 1) = 29</code> (leap year, Feb).

<a href="http://plnkr.co/edit/9Uxmi7diINm08sJd8UlA?p=preview" target="_blank" data-plunk-id="9Uxmi7diINm08sJd8UlA">Open the sandbox with tests.</a>
<button type="button">solution</button>

Let’s create a date using the next month, but pass zero as the day:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function getLastDayOfMonth(year, month) {
  let date = new Date(year, month + 1, 0);
  return date.getDate();
}
alert( getLastDayOfMonth(2012, 0) ); // 31
alert( getLastDayOfMonth(2012, 1) ); // 29
alert( getLastDayOfMonth(2013, 1) ); // 28</code>
  Normally, dates start from 1, but technically we can pass any number, the date will autoadjust itself. 
So when we pass 0, then it means “one day before 1st day of the month”, in other words: “the last day of the previous month”.

<a href="http://plnkr.co/edit/cwFfgJPeCnO4HSWpqVEr?p=preview" target="_blank" data-plunk-id="cwFfgJPeCnO4HSWpqVEr">Open the solution with tests in the sandbox.</a>
<button type="button" title="close"></button>

<h3><a href="#how-many-seconds-has-passed-today" name="how-many-seconds-has-passed-today">How many seconds has passed today?</a></h3><a href="/task/get-seconds-today" target="_blank"></a>

importance: 5

Write a function <code>getSecondsToday()</code> that returns the number of seconds from the beginning of today.

For instance, if now <code>10:00 am</code>, and there was no daylight savings shift, then:

    <code>getSecondsToday() == 36000 // (3600 * 10)</code>
  The function should work in any day. 
That is, it should not have a hard-coded value of “today”.

<button type="button">solution</button>

To get the number of seconds, we can generate a date using the current day and time 00:00:00, then substract it from “now”.

The difference is the number of milliseconds from the beginning of the day, that we should divide by 1000 to get seconds:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function getSecondsToday() {
  let now = new Date();
  // create an object using the current day/month/year
  let today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  let diff = now - today; // ms difference
  return Math.round(diff / 1000); // make seconds
}
alert( getSecondsToday() );</code>
  An alternative solution would be to get hours/minutes/seconds and convert them to seconds:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function getSecondsToday() {
  let d = new Date();
  return d.getHours() * 3600 + d.getMinutes() * 60 + d.getSeconds();
};</code>
  <button type="button" title="close"></button>

<h3><a href="#how-many-seconds-till-tomorrow" name="how-many-seconds-till-tomorrow">How many seconds till tomorrow?</a></h3><a href="/task/get-seconds-to-tomorrow" target="_blank"></a>

importance: 5

Create a function <code>getSecondsToTomorrow()</code> that returns the number of seconds till tomorrow.

For instance, if now is <code>23:00</code>, then:

    <code>getSecondsToTomorrow() == 3600</code>
  P.S. 
The function should work at any day, the “today” is not hardcoded.

<button type="button">solution</button>

To get the number of milliseconds till tomorrow, we can from “tomorrow 00:00:00” substract the current date.

First, we generate that “tomorrow”, and then do it:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function getSecondsToTomorrow() {
  let now = new Date();
  // tomorrow date
  let tomorrow = new Date(now.getFullYear(), now.getMonth(), now.getDate()+1);
  let diff = tomorrow - now; // difference in ms
  return Math.round(diff / 1000); // convert to seconds
}</code>
  Alternative solution:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function getSecondsToTomorrow() {
  let now = new Date();
  let hour = now.getHours();
  let minutes = now.getMinutes();
  let seconds = now.getSeconds();
  let totalSecondsToday = (hour * 60 + minutes) * 60 + seconds;
  let totalSecondsInADay = 86400;
  return totalSecondsInADay - totalSecondsToday;
}</code>
  Please note that many countries have Daylight Savings Time (DST), so there may be days with 23 or 25 hours. 
We may want to treat such days separately.

<button type="button" title="close"></button>

<h3><a href="#format-the-relative-date" name="format-the-relative-date">Format the relative date</a></h3><a href="/task/format-date-relative" target="_blank"></a>

importance: 4

Write a function <code>formatDate(date)</code> that should format <code>date</code> as follows:

<li>If since <code>date</code> passed less than 1 second, then <code>&quot;right now&quot;</code>.</li><li>Otherwise, if since <code>date</code> passed less than 1 minute, then <code>&quot;n sec. 
ago&quot;</code>.</li><li>Otherwise, if less than an hour, then <code>&quot;m min. 
ago&quot;</code>.</li><li>Otherwise, the full date in the format <code>&quot;DD.MM.YY HH:mm&quot;</code>. 
That is: <code>&quot;day.month.year hours:minutes&quot;</code>, all in 2-digit format, e.g. 
<code>31.12.16 10:00</code>.</li>

For instance:

    <code>alert( formatDate(new Date(new Date - 1)) ); // &quot;right now&quot;
alert( formatDate(new Date(new Date - 30 * 1000)) ); // &quot;30 sec. 
ago&quot;
alert( formatDate(new Date(new Date - 5 * 60 * 1000)) ); // &quot;5 min. 
ago&quot;
// yesterday's date like 31.12.2016, 20:00
alert( formatDate(new Date(new Date - 86400 * 1000)) );</code>
  <a href="http://plnkr.co/edit/EVi38ofsvqRzIyri0duv?p=preview" target="_blank" data-plunk-id="EVi38ofsvqRzIyri0duv">Open the sandbox with tests.</a>
<button type="button">solution</button>

To get the time from <code>date</code> till now – let’s substract the dates.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function formatDate(date) {
  let diff = new Date() - date; // the difference in milliseconds
  if (diff &lt; 1000) { // less than 1 second
    return 'right now';
  }
  let sec = Math.floor(diff / 1000); // convert diff to seconds
  if (sec &lt; 60) {
    return sec + ' sec. 
ago';
  }
  let min = Math.floor(diff / 60000); // convert diff to minutes
  if (min &lt; 60) {
    return min + ' min. 
ago';
  }
  // format the date
  // add leading zeroes to single-digit day/month/hours/minutes
  let d = date;
  d = [
    '0' + d.getDate(),
    '0' + (d.getMonth() + 1),
    '' + d.getFullYear(),
    '0' + d.getHours(),
    '0' + d.getMinutes()
  ].map(component =&gt; component.slice(-2)); // take last 2 digits of every component
  // join the components into date
  return d.slice(0, 3).join('.') + ' ' + d.slice(3).join(':');
}
alert( formatDate(new Date(new Date - 1)) ); // &quot;right now&quot;
alert( formatDate(new Date(new Date - 30 * 1000)) ); // &quot;30 sec. 
ago&quot;
alert( formatDate(new Date(new Date - 5 * 60 * 1000)) ); // &quot;5 min. 
ago&quot;
// yesterday's date like 31.12.2016, 20:00
alert( formatDate(new Date(new Date - 86400 * 1000)) );</code>
  Alternative solution:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function formatDate(date) {
  let dayOfMonth = date.getDate();
  let month = date.getMonth() + 1;
  let year = date.getFullYear();
  let hour = date.getHours();
  let minutes = date.getMinutes();
  let diffMs = new Date() - date;
  let diffSec = Math.round(diffMs / 1000);
  let diffMin = diffSec / 60;
  let diffHour = diffMin / 60;
  // formatting
  year = year.toString().slice(-2);
  month = month &lt; 10 ? '0' + month : month;
  dayOfMonth = dayOfMonth &lt; 10 ? '0' + dayOfMonth : dayOfMonth;
  if (diffSec &lt; 1) {
    return 'right now';
  } else if (diffMin &lt; 1) {
    return `${diffSec} sec. 
ago`
  } else if (diffHour &lt; 1) {
    return `${diffMin} min. 
ago`
  } else {
    return `${dayOfMonth}.${month}.${year} ${hour}:${minutes}`
  }
}</code>
  <a href="http://plnkr.co/edit/6VSJDxqff7UB0cEwjoDs?p=preview" target="_blank" data-plunk-id="6VSJDxqff7UB0cEwjoDs">Open the solution with tests in the sandbox.</a>
<button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/destructuring-assignment" data-tooltip="Destructuring assignment">Previous lesson</a><a href="/json" data-tooltip="JSON methods, toJSON">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Fdate"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Fdate"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Fdate"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Fdate"></a>

Let’s say we have a complex object, and we’d like to convert it into a string, to send it over a network, or just to output it for logging purposes.

Naturally, such a string should include all important properties.

We could implement the conversion like this:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  name: &quot;John&quot;,
  age: 30,
  toString() {
    return `{name: &quot;${this.name}&quot;, age: ${this.age}}`;
  }
};
alert(user); // {name: &quot;John&quot;, age: 30}</code>
  …But in the process of development, new properties are added, old properties are renamed and removed. 
Updating such <code>toString</code> every time can become a pain. 
We could try to loop over properties in it, but what if the object is complex and has nested objects in properties? We’d need to implement their conversion as well. 
And, if we’re sending the object over a network, then we also need to supply the code to “read” our object on the receiving side.

Luckily, there’s no need to write the code to handle all this. 
The task has been solved already.

<h2>JSON.stringify</h2>
The <a href="http://en.wikipedia.org/wiki/JSON">JSON</a> (JavaScript Object Notation) is a general format to represent values and objects. 
It is described as in <a href="http://tools.ietf.org/html/rfc4627">RFC 4627</a> standard. 
Initially it was made for JavaScript, but many other languages have libraries to handle it as well. 
 So it’s easy to use JSON for data exchange when the client uses JavaScript and the server is written on Ruby/PHP/Java/Whatever.

JavaScript provides methods:

<li><code>JSON.stringify</code> to convert objects into JSON.</li><li><code>JSON.parse</code> to convert JSON back into an object.</li>

For instance, here we <code>JSON.stringify</code> a student:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let student = {
  name: 'John',
  age: 30,
  isAdmin: false,
  courses: ['html', 'css', 'js'],
  wife: null
};
let json = JSON.stringify(student);
alert(typeof json); // we've got a string!
alert(json);
/* JSON-encoded object:
{
  &quot;name&quot;: &quot;John&quot;,
  &quot;age&quot;: 30,
  &quot;isAdmin&quot;: false,
  &quot;courses&quot;: [&quot;html&quot;, &quot;css&quot;, &quot;js&quot;],
  &quot;wife&quot;: null
}
*/</code>
  The method <code>JSON.stringify(student)</code> takes the object and converts it into a string.

The resulting <code>json</code> string is a called <em>JSON-encoded</em> or <em>serialized</em> or <em>stringified</em> or <em>marshalled</em> object. 
We are ready to send it over the wire or put into plain data store.

Please note that JSON-encoded object has several important differences from the object literal:

<li>Strings use double quotes. 
No single quotes or backticks in JSON. 
So <code>'John'</code> becomes <code>&quot;John&quot;</code>.</li><li>Object property names are double-quoted also. 
That’s obligatory. 
So <code>age:30</code> becomes <code>&quot;age&quot;:30</code>.</li>

<code>JSON.stringify</code> can be applied to primitives as well.

Natively supported JSON types are:

<li>Objects <code>{ ... 
}</code></li><li>Arrays <code>[ ... 
]</code></li><li>Primitives:
<li>strings,</li><li>numbers,</li><li>boolean values <code>true/false</code>,</li><li><code>null</code>.</li>

</li>

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// a number in JSON is just a number
alert( JSON.stringify(1) ) // 1
// a string in JSON is still a string, but double-quoted
alert( JSON.stringify('test') ) // &quot;test&quot;
alert( JSON.stringify(true) ); // true
alert( JSON.stringify([1, 2, 3]) ); // [1,2,3]</code>
  JSON is data-only cross-language specification, so some JavaScript-specific object properties are skipped by <code>JSON.stringify</code>.

Namely:

<li>Function properties (methods).</li><li>Symbolic properties.</li><li>Properties that store <code>undefined</code>.</li>

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  sayHi() { // ignored
    alert(&quot;Hello&quot;);
  },
  [Symbol(&quot;id&quot;)]: 123, // ignored
  something: undefined // ignored
};
alert( JSON.stringify(user) ); // {} (empty object)</code>
  Usually that’s fine. 
If that’s not what we want, then soon we’ll see how to customize the process.

The great thing is that nested objects are supported and converted automatically.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let meetup = {
  title: &quot;Conference&quot;,
  room: {
    number: 123,
    participants: [&quot;john&quot;, &quot;ann&quot;]
  }
};
alert( JSON.stringify(meetup) );
/* The whole structure is stringified:
{
  &quot;title&quot;:&quot;Conference&quot;,
  &quot;room&quot;:{&quot;number&quot;:23,&quot;participants&quot;:[&quot;john&quot;,&quot;ann&quot;]},
}
*/</code>
  The important limitation: there must be no circular references.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let room = {
  number: 23
};
let meetup = {
  title: &quot;Conference&quot;,
  participants: [&quot;john&quot;, &quot;ann&quot;]
};
meetup.place = room;       // meetup references room
room.occupiedBy = meetup; // room references meetup
JSON.stringify(meetup); // Error: Converting circular structure to JSON</code>
  Here, the conversion fails, because of circular reference: <code>room.occupiedBy</code> references <code>meetup</code>, and <code>meetup.place</code> references <code>room</code>:

<img src="https://javascript.info/article/json/json-meetup.png">
<h2>Excluding and transforming: replacer</h2>
The full syntax of <code>JSON.stringify</code> is:

    <code>let json = JSON.stringify(value[, replacer, space])</code>
  <dl>
<dt>value</dt>
<dd>A value to encode.</dd>
<dt>replacer</dt>
<dd>Array of properties to encode or a mapping function <code>function(key, value)</code>.</dd>
<dt>space</dt>
<dd>Amount of space to use for formatting</dd>
</dl>

Most of time, <code>JSON.stringify</code> is used with first argument only. 
But if we need to fine-tune the replacement process, like to filter out circular references, we can use the second argument of <code>JSON.stringify</code>.

If we pass an array of properties to it, only these properties will be encoded.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let room = {
  number: 23
};
let meetup = {
  title: &quot;Conference&quot;,
  participants: [{name: &quot;John&quot;}, {name: &quot;Alice&quot;}],
  place: room // meetup references room
};
room.occupiedBy = meetup; // room references meetup
alert( JSON.stringify(meetup, ['title', 'participants']) );
// {&quot;title&quot;:&quot;Conference&quot;,&quot;participants&quot;:[{},{}]}</code>
  Here we are probably too strict. 
The property list is applied to the whole object structure. 
So participants are empty, because <code>name</code> is not in the list.

Let’s include every property except <code>room.occupiedBy</code> that would cause the circular reference:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let room = {
  number: 23
};
let meetup = {
  title: &quot;Conference&quot;,
  participants: [{name: &quot;John&quot;}, {name: &quot;Alice&quot;}],
  place: room // meetup references room
};
room.occupiedBy = meetup; // room references meetup
alert( JSON.stringify(meetup, ['title', 'participants', 'place', 'name', 'number']) );
/*
{
  &quot;title&quot;:&quot;Conference&quot;,
  &quot;participants&quot;:[{&quot;name&quot;:&quot;John&quot;},{&quot;name&quot;:&quot;Alice&quot;}],
  &quot;place&quot;:{&quot;number&quot;:23}
}
*/</code>
  Now everything except <code>occupiedBy</code> is serialized. 
But the list of properties is quite long.

Fortunately, we can use a function instead of an array as the <code>replacer</code>.

The function will be called for every <code>(key,value)</code> pair and should return the “replaced” value, which will be used instead of the original one.

In our case, we can return <code>value</code> “as is” for everything except <code>occupiedBy</code>. 
To ignore <code>occupiedBy</code>, the code below returns <code>undefined</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let room = {
  number: 23
};
let meetup = {
  title: &quot;Conference&quot;,
  participants: [{name: &quot;John&quot;}, {name: &quot;Alice&quot;}],
  place: room // meetup references room
};
room.occupiedBy = meetup; // room references meetup
alert( JSON.stringify(meetup, function replacer(key, value) {
  alert(`${key}: ${value}`); // to see what replacer gets
  return (key == 'occupiedBy') ? undefined : value;
}));
/* key:value pairs that come to replacer:
:             [object Object]
title:        Conference
participants: [object Object],[object Object]
0:            [object Object]
name:         John
1:            [object Object]
name:         Alice
place:        [object Object]
number:       23
*/</code>
  Please note that <code>replacer</code> function gets every key/value pair including nested objects and array items. 
It is applied recursively. 
The value of <code>this</code> inside <code>replacer</code> is the object that contains the current property.

The first call is special. 
It is made using a special “wrapper object”: <code>{&quot;&quot;: meetup}</code>. 
In other words, the first <code>(key,value)</code> pair has an empty key, and the value is the target object as a whole. 
That’s why the first line is <code>&quot;:[object Object]&quot;</code> in the example above.

The idea is to provide as much power for <code>replacer</code> as possible: it has a chance to analyze and replace/skip the whole object if necessary.

<h2>Formatting: spacer</h2>
The third argument of <code>JSON.stringify(value, replacer, spaces)</code> is the number of spaces to use for pretty formatting.

Previously, all stringified objects had no indents and extra spaces. 
That’s fine if we want to send an object over a network. 
The <code>spacer</code> argument is used exclusively for a nice output.

Here <code>spacer = 2</code> tells JavaScript to show nested objects on multiple lines, with indentation of 2 spaces inside an object:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  name: &quot;John&quot;,
  age: 25,
  roles: {
    isAdmin: false,
    isEditor: true
  }
};
alert(JSON.stringify(user, null, 2));
/* two-space indents:
{
  &quot;name&quot;: &quot;John&quot;,
  &quot;age&quot;: 25,
  &quot;roles&quot;: {
    &quot;isAdmin&quot;: false,
    &quot;isEditor&quot;: true
  }
}
*/
/* for JSON.stringify(user, null, 4) the result would be more indented:
{
    &quot;name&quot;: &quot;John&quot;,
    &quot;age&quot;: 25,
    &quot;roles&quot;: {
  &quot;isAdmin&quot;: false,
  &quot;isEditor&quot;: true
    }
}
*/</code>
  The <code>spaces</code> parameter is used solely for logging and nice-output purposes.

<h2>Custom “toJSON”</h2>
Like <code>toString</code> for a string conversion, an object may provide method <code>toJSON</code> for to-JSON conversion. 
<code>JSON.stringify</code> automatically calls it if available.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let room = {
  number: 23
};
let meetup = {
  title: &quot;Conference&quot;,
  date: new Date(Date.UTC(2017, 0, 1)),
  room
};
alert( JSON.stringify(meetup) );
/*
  {
    &quot;title&quot;:&quot;Conference&quot;,
    &quot;date&quot;:&quot;2017-01-01T00:00:00.000Z&quot;,  // (1)
    &quot;room&quot;: {&quot;number&quot;:23}               // (2)
  }
*/</code>
  Here we can see that <code>date</code> <code>(1)</code> became a string. 
That’s because all dates have a built-in <code>toJSON</code> method which returns such kind of string.

Now let’s add a custom <code>toJSON</code> for our object <code>room</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let room = {
  number: 23,
  toJSON() {
    return this.number;
  }
};
let meetup = {
  title: &quot;Conference&quot;,
  room
};
alert( JSON.stringify(room) ); // 23
alert( JSON.stringify(meetup) );
/*
  {
    &quot;title&quot;:&quot;Conference&quot;,
    &quot;room&quot;: 23
  }
*/</code>
  As we can see, <code>toJSON</code> is used both for the direct call <code>JSON.stringify(room)</code> and for the nested object.

<h2>JSON.parse</h2>
To decode a JSON-string, we need another method named <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse">JSON.parse</a>.

The syntax:

    <code>let value = JSON.parse(str[, reviver]);</code>
  <dl>
<dt>str</dt>
<dd>JSON-string to parse.</dd>
<dt>reviver</dt>
<dd>Optional function(key,value) that will be called for each <code>(key,value)</code> pair and can transform the value.</dd>
</dl>

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// stringified array
let numbers = &quot;[0, 1, 2, 3]&quot;;
numbers = JSON.parse(numbers);
alert( numbers[1] ); // 1</code>
  Or for nested objects:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = '{ &quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 35, &quot;isAdmin&quot;: false, &quot;friends&quot;: [0,1,2,3] }';
user = JSON.parse(user);
alert( user.friends[1] ); // 1</code>
  The JSON may be as complex as necessary, objects and arrays can include other objects and arrays. 
But they must obey the format.

Here are typical mistakes in hand-written JSON (sometimes we have to write it for debugging purposes):

    <code>let json = `{
  name: &quot;John&quot;,                     // mistake: property name without quotes
  &quot;surname&quot;: 'Smith',               // mistake: single quotes in value (must be double)
  'isAdmin': false                  // mistake: single quotes in key (must be double)
  &quot;birthday&quot;: new Date(2000, 2, 3), // mistake: no &quot;new&quot; is allowed, only bare values
  &quot;friends&quot;: [0,1,2,3]              // here all fine
}`;</code>
  Besides, JSON does not support comments. 
Adding a comment to JSON makes it invalid.

There’s another format named <a href="http://json5.org/">JSON5</a>, which allows unquoted keys, comments etc. 
But this is a standalone library, not in the specification of the language.

The regular JSON is that strict not because its developers are lazy, but to allow easy, reliable and very fast implementations of the parsing algorithm.

<h2>Using reviver</h2>
Imagine, we got a stringified <code>meetup</code> object from the server.

It looks like this:

    <code>// title: (meetup title), date: (meetup date)
let str = '{&quot;title&quot;:&quot;Conference&quot;,&quot;date&quot;:&quot;2017-11-30T12:00:00.000Z&quot;}';</code>
  …And now we need to <em>deserialize</em> it, to turn back into JavaScript object.

Let’s do it by calling <code>JSON.parse</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let str = '{&quot;title&quot;:&quot;Conference&quot;,&quot;date&quot;:&quot;2017-11-30T12:00:00.000Z&quot;}';
let meetup = JSON.parse(str);
alert( meetup.date.getDate() ); // Error!</code>
  Whoops! An error!

The value of <code>meetup.date</code> is a string, not a <code>Date</code> object. 
How could <code>JSON.parse</code> know that it should transform that string into a <code>Date</code>?

Let’s pass to <code>JSON.parse</code> the reviving function that returns all values “as is”, but <code>date</code> will become a <code>Date</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let str = '{&quot;title&quot;:&quot;Conference&quot;,&quot;date&quot;:&quot;2017-11-30T12:00:00.000Z&quot;}';
let meetup = JSON.parse(str, function(key, value) {
  if (key == 'date') return new Date(value);
  return value;
});
alert( meetup.date.getDate() ); // now works!</code>
  By the way, that works for nested objects as well:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let schedule = `{
  &quot;meetups&quot;: [
    {&quot;title&quot;:&quot;Conference&quot;,&quot;date&quot;:&quot;2017-11-30T12:00:00.000Z&quot;},
    {&quot;title&quot;:&quot;Birthday&quot;,&quot;date&quot;:&quot;2017-04-18T12:00:00.000Z&quot;}
  ]
}`;
schedule = JSON.parse(schedule, function(key, value) {
  if (key == 'date') return new Date(value);
  return value;
});
alert( schedule.meetups[1].date.getDate() ); // works!</code>
  <h4><a name="summary" href="#summary">Summary</a></h4><li>JSON is a data format that has its own independent standard and libraries for most programming languages.</li><li>JSON supports plain objects, arrays, strings, numbers, booleans and <code>null</code>.</li><li>JavaScript provides methods <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify">JSON.stringify</a> to serialize into JSON and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse">JSON.parse</a> to read from JSON.</li><li>Both methods support transformer functions for smart reading/writing.</li><li>If an object has <code>toJSON</code>, then it is called by <code>JSON.stringify</code>.</li>

    <code>let user = {
  name: &quot;John Smith&quot;,
  age: 35
};</code>
  <button type="button">solution</button>

    <code>let user = {
  name: &quot;John Smith&quot;,
  age: 35
};
let user2 = JSON.parse(JSON.stringify(user));</code>
  <button type="button" title="close"></button>

<h3><a href="#exclude-backreferences" name="exclude-backreferences">Exclude backreferences</a></h3><a href="/task/serialize-event-circular" target="_blank"></a>

importance: 5

In simple cases of circular references, we can exclude an offending property from serialization by its name.

But sometimes there are many backreferences. 
And names may be used both in circular references and normal properties.

Write <code>replacer</code> function to stringify everything, but remove properties that reference <code>meetup</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let room = {
  number: 23
};
let meetup = {
  title: &quot;Conference&quot;,
  occupiedBy: [{name: &quot;John&quot;}, {name: &quot;Alice&quot;}],
  place: room
};
// circular references
room.occupiedBy = meetup;
meetup.self = meetup;
alert( JSON.stringify(meetup, function replacer(key, value) {
  /* your code */
}));
/* result should be:
{
  &quot;title&quot;:&quot;Conference&quot;,
  &quot;occupiedBy&quot;:[{&quot;name&quot;:&quot;John&quot;},{&quot;name&quot;:&quot;Alice&quot;}],
  &quot;place&quot;:{&quot;number&quot;:23}
}
*/</code>
  <button type="button">solution</button>

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let room = {
  number: 23
};
let meetup = {
  title: &quot;Conference&quot;,
  occupiedBy: [{name: &quot;John&quot;}, {name: &quot;Alice&quot;}],
  place: room
};
room.occupiedBy = meetup;
meetup.self = meetup;
alert( JSON.stringify(meetup, function replacer(key, value) {
  return (key != &quot;&quot; &amp;&amp; value == meetup) ? undefined : value;
}));
/*
{
  &quot;title&quot;:&quot;Conference&quot;,
  &quot;occupiedBy&quot;:[{&quot;name&quot;:&quot;John&quot;},{&quot;name&quot;:&quot;Alice&quot;}],
  &quot;place&quot;:{&quot;number&quot;:23}
}
*/</code>
  Here we also need to test <code>key==&quot;&quot;</code> to exclude the first call where it is normal that <code>value</code> is <code>meetup</code>.

<button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/date" data-tooltip="Date and time">Previous lesson</a><a href="/advanced-functions" data-tooltip="Advanced working with functions">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Fjson"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Fjson"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Fjson"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Fjson"></a>

Let’s return to functions and study them more in-depth.

Our first topic will be <em>recursion</em>.

If you are not new to programming, then it is probably familiar and you could skip this chapter.

Recursion is a programming pattern that is useful in situations when a task can be naturally split into several tasks of the same kind, but simpler. 
Or when a task can be simplified into an easy action plus a simpler variant of the same task. 
Or, as we’ll see soon, to deal with certain data structures.

When a function solves a task, in the process it can call many other functions. 
A partial case of this is when a function calls <em>itself</em>. 
That’s called <em>recursion</em>.

<h2>Two ways of thinking</h2>
For something simple to start with – let’s write a function <code>pow(x, n)</code> that raises <code>x</code> to a natural power of <code>n</code>. 
In other words, multiplies <code>x</code> by itself <code>n</code> times.

    <code>pow(2, 2) = 4
pow(2, 3) = 8
pow(2, 4) = 16</code>
  There are two ways to implement it.

<li>Iterative thinking: the <code>for</code> loop:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function pow(x, n) {
  let result = 1;
  // multiply result by x n times in the loop
  for (let i = 0; i &lt; n; i++) {
    result *= x;
  }
  return result;
}
alert( pow(2, 3) ); // 8</code>
  </li><li>Recursive thinking: simplify the task and call self:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}
alert( pow(2, 3) ); // 8</code>
  </li>

Please note how the recursive variant is fundamentally different.

When <code>pow(x, n)</code> is called, the execution splits into two branches:

    <code>              if n==1  = x
       /
pow(x, n) =
       \
        else     = x * pow(x, n - 1)</code>
  <li>If <code>n == 1</code>, then everything is trivial. 
It is called <em>the base</em> of recursion, because it immediately produces the obvious result: <code>pow(x, 1)</code> equals <code>x</code>.</li><li>Otherwise, we can represent <code>pow(x, n)</code> as <code>x * pow(x, n - 1)</code>. 
In maths, one would write <code>x<sup>n</sup> = x * x<sup>n-1</sup></code>. 
This is called <em>a recursive step</em>: we transform the task into a simpler action (multiplication by <code>x</code>) and a simpler call of the same task (<code>pow</code> with lower <code>n</code>). 
Next steps simplify it further and further until <code>n</code> reaches <code>1</code>.</li>

We can also say that <code>pow</code> <em>recursively calls itself</em> till <code>n == 1</code>.

<img src="https://javascript.info/article/recursion/recursion-pow.png">
For example, to calculate <code>pow(2, 4)</code> the recursive variant does these steps:

<li><code>pow(2, 4) = 2 * pow(2, 3)</code></li><li><code>pow(2, 3) = 2 * pow(2, 2)</code></li><li><code>pow(2, 2) = 2 * pow(2, 1)</code></li><li><code>pow(2, 1) = 2</code></li>

So, the recursion reduces a function call to a simpler one, and then – to even more simpler, and so on, until the result becomes obvious.

Recursion is usually shorter
A recursive solution is usually shorter than an iterative one.

Here we can rewrite the same using the ternary <code>?</code> operator instead of <code>if</code> to make <code>pow(x, n)</code> more terse and still very readable:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function pow(x, n) {
  return (n == 1) ? x : (x * pow(x, n - 1));
}</code>
  
The maximal number of nested calls (including the first one) is called <em>recursion depth</em>. 
In our case, it will be exactly <code>n</code>.

The maximal recursion depth is limited by JavaScript engine. 
We can make sure about 10000, some engines allow more, but 100000 is probably out of limit for the majority of them. 
There are automatic optimizations that help alleviate this (“tail calls optimizations”), but they are not yet supported everywhere and work only in simple cases.

That limits the application of recursion, but it still remains very wide. 
There are many tasks where recursive way of thinking gives simpler code, easier to maintain.

<h2>The execution stack</h2>
Now let’s examine how recursive calls work. 
For that we’ll look under the hood of functions.

The information about a function run is stored in its <em>execution context</em>.

The <a href="https://tc39.github.io/ecma262/#sec-execution-contexts">execution context</a> is an internal data structure that contains details about the execution of a function: where the control flow is now, the current variables, the value of <code>this</code> (we don’t use it here) and few other internal details.

One function call has exactly one execution context associated with it.

When a function makes a nested call, the following happens:

<li>The current function is paused.</li><li>The execution context associated with it is remembered in a special data structure called <em>execution context stack</em>.</li><li>The nested call executes.</li><li>After it ends, the old execution context is retrieved from the stack, and the outer function is resumed from where it stopped.</li>

Let’s see what happens during the <code>pow(2, 3)</code> call.

<h3><a name="pow-2-3" href="#pow-2-3">pow(2, 3)</a></h3>
In the beginning of the call <code>pow(2, 3)</code> the execution context will store variables: <code>x = 2, n = 3</code>, the execution flow is at line <code>1</code> of the function.

We can sketch it as:

  <li>
    Context: { x: 2, n: 3, at line 1 }
    pow(2, 3)
  </li>

That’s when the function starts to execute. 
The condition <code>n == 1</code> is false, so the flow continues into the second branch of <code>if</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}
alert( pow(2, 3) );</code>
  The variables are same, but the line changes, so the context is now:

  <li>
    Context: { x: 2, n: 3, at line 5 }
    pow(2, 3)
  </li>

To calculate <code>x * pow(x, n - 1)</code>, we need to make a subcall of <code>pow</code> with new arguments <code>pow(2, 2)</code>.

<h3><a name="pow-2-2" href="#pow-2-2">pow(2, 2)</a></h3>
To do a nested call, JavaScript remembers the current execution context in the <em>execution context stack</em>.

Here we call the same function <code>pow</code>, but it absolutely doesn’t matter. 
The process is the same for all functions:

<li>The current context is “remembered” on top of the stack.</li><li>The new context is created for the subcall.</li><li>When the subcall is finished – the previous context is popped from the stack, and its execution continues.</li>

Here’s the context stack when we entered the subcall <code>pow(2, 2)</code>:

  <li>
    Context: { x: 2, n: 2, at line 1 }
    pow(2, 2)
  </li>
  <li>
    Context: { x: 2, n: 3, at line 5 }
    pow(2, 3)
  </li>

The new current execution context is on top (and bold), and previous remembered contexts are below.

When we finish the subcall – it is easy to resume the previous context, because it keeps both variables and the exact place of the code where it stopped. 
Here in the picture we use the word “line”, but of course it’s more precise.

<h3><a name="pow-2-1" href="#pow-2-1">pow(2, 1)</a></h3>
The process repeats: a new subcall is made at line <code>5</code>, now with arguments <code>x=2</code>, <code>n=1</code>.

A new execution context is created, the previous one is pushed on top of the stack:

  <li>
    Context: { x: 2, n: 1, at line 1 }
    pow(2, 1)
  </li>
  <li>
    Context: { x: 2, n: 2, at line 5 }
    pow(2, 2)
  </li>
  <li>
    Context: { x: 2, n: 3, at line 5 }
    pow(2, 3)
  </li>

There are 2 old contexts now and 1 currently running for <code>pow(2, 1)</code>.

<h3><a name="the-exit" href="#the-exit">The exit</a></h3>
During the execution of <code>pow(2, 1)</code>, unlike before, the condition <code>n == 1</code> is truthy, so the first branch of <code>if</code> works:

    <code>function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}</code>
  There are no more nested calls, so the function finishes, returning <code>2</code>.

As the function finishes, its execution context is not needed anymore, so it’s removed from the memory. 
The previous one is restored off the top of the stack:

  <li>
    Context: { x: 2, n: 2, at line 5 }
    pow(2, 2)
  </li>
  <li>
    Context: { x: 2, n: 3, at line 5 }
    pow(2, 3)
  </li>

The execution of <code>pow(2, 2)</code> is resumed. 
It has the result of the subcall <code>pow(2, 1)</code>, so it also can finish the evaluation of <code>x * pow(x, n - 1)</code>, returning <code>4</code>.

Then the previous context is restored:

  <li>
    Context: { x: 2, n: 3, at line 5 }
    pow(2, 3)
  </li>

When it finishes, we have a result of <code>pow(2, 3) = 8</code>.

The recursion depth in this case was: <strong>3</strong>.

As we can see from the illustrations above, recursion depth equals the maximal number of context in the stack.

Note the memory requirements. 
Contexts take memory. 
In our case, raising to the power of <code>n</code> actually requires the memory for <code>n</code> contexts, for all lower values of <code>n</code>.

A loop-based algorithm is more memory-saving:

    <code>function pow(x, n) {
  let result = 1;
  for (let i = 0; i &lt; n; i++) {
    result *= x;
  }
  return result;
}</code>
  The iterative <code>pow</code> uses a single context changing <code>i</code> and <code>result</code> in the process. 
Its memory requirements are small, fixed and do not depend on <code>n</code>.

<strong>Any recursion can be rewritten as a loop. 
The loop variant usually can be made more effective.</strong>

…But sometimes the rewrite is non-trivial, especially when function uses different recursive subcalls depending on conditions and merges their results or when the branching is more intricate. 
And the optimization may be unneeded and totally not worth the efforts.

Recursion can give a shorter code, easier to understand and support. 
Optimizations are not required in every place, mostly we need a good code, that’s why it’s used.

<h2>Recursive traversals</h2>
Another great application of the recursion is a recursive traversal.

Imagine, we have a company. 
The staff structure can be presented as an object:

    <code>let company = {
  sales: [{
    name: 'John',
    salary: 1000
  }, {
    name: 'Alice',
    salary: 600
  }],
  development: {
    sites: [{
name: 'Peter',
salary: 2000
    }, {
name: 'Alex',
salary: 1800
    }],
    internals: [{
name: 'Jack',
salary: 1300
    }]
  }
};</code>
  In other words, a company has departments.

<li>A department may have an array of staff. 
For instance, <code>sales</code> department has 2 employees: John and Alice.

</li><li>Or a department may split into subdepartments, like <code>development</code> has two branches: <code>sites</code> and <code>internals</code>. 
Each of them has the own staff.

</li><li>It is also possible that when a subdepartment grows, it divides into subsubdepartments (or teams).

For instance, the <code>sites</code> department in the future may be split into teams for <code>siteA</code> and <code>siteB</code>. 
And they, potentially, can split even more. 
That’s not on the picture, just something to have in mind.

</li>

Now let’s say we want a function to get the sum of all salaries. 
How can we do that?

An iterative approach is not easy, because the structure is not simple. 
The first idea may be to make a <code>for</code> loop over <code>company</code> with nested subloop over 1st level departments. 
But then we need more nested subloops to iterate over the staff in 2nd level departments like <code>sites</code>. 
…And then another subloop inside those for 3rd level departments that might appear in the future? Should we stop on level 3 or make 4 levels of loops? If we put 3-4 nested subloops in the code to traverse a single object, it becomes rather ugly.

Let’s try recursion.

As we can see, when our function gets a department to sum, there are two possible cases:

<li>Either it’s a “simple” department with an <em>array of people</em> – then we can sum the salaries in a simple loop.</li><li>Or it’s <em>an object with <code>N</code> subdepartments</em> – then we can make <code>N</code> recursive calls to get the sum for each of the subdeps and combine the results.</li>

The (1) is the base of recursion, the trivial case.

The (2) is the recursive step. 
A complex task is split into subtasks for smaller departments. 
They may in turn split again, but sooner or later the split will finish at (1).

The algorithm is probably even easier to read from the code:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let company = { // the same object, compressed for brevity
  sales: [{name: 'John', salary: 1000}, {name: 'Alice', salary: 600 }],
  development: {
    sites: [{name: 'Peter', salary: 2000}, {name: 'Alex', salary: 1800 }],
    internals: [{name: 'Jack', salary: 1300}]
  }
};
// The function to do the job
function sumSalaries(department) {
  if (Array.isArray(department)) { // case (1)
    return department.reduce((prev, current) =&gt; prev + current.salary, 0); // sum the array
  } else { // case (2)
    let sum = 0;
    for (let subdep of Object.values(department)) {
sum += sumSalaries(subdep); // recursively call for subdepartments, sum the results
    }
    return sum;
  }
}
alert(sumSalaries(company)); // 6700</code>
  The code is short and easy to understand (hopefully?). 
That’s the power of recursion. 
It also works for any level of subdepartment nesting.

Here’s the diagram of calls:

<img src="https://javascript.info/article/recursion/recursive-salaries.png">
We can easily see the principle: for an object <code>{...}</code> subcalls are made, while arrays <code>[...]</code> are the “leaves” of the recursion tree, they give immediate result.

Note that the code uses smart features that we’ve covered before:

<li>Method <code>arr.reduce</code> explained in the chapter <a href="/array-methods">Array methods</a> to get the sum of the array.</li><li>Loop <code>for(val of Object.values(obj))</code> to iterate over object values: <code>Object.values</code> returns an array of them.</li>

<h2>Recursive structures</h2>
A recursive (recursively-defined) data structure is a structure that replicates itself in parts.

We’ve just seen it in the example of a company structure above.

A company <em>department</em> is:

<li>Either an array of people.</li><li>Or an object with <em>departments</em>.</li>

For web-developers there are much better-known examples: HTML and XML documents.

In the HTML document, an <em>HTML-tag</em> may contain a list of:

<li>Text pieces.</li><li>HTML-comments.</li><li>Other <em>HTML-tags</em> (that in turn may contain text pieces/comments or other tags etc).</li>

That’s once again a recursive definition.

For better understanding, we’ll cover one more recursive structure named “Linked list” that might be a better alternative for arrays in some cases.

<h3><a name="linked-list" href="#linked-list">Linked list</a></h3>
Imagine, we want to store an ordered list of objects.

The natural choice would be an array:

    <code>let arr = [obj1, obj2, obj3];</code>
  …But there’s a problem with arrays. 
The “delete element” and “insert element” operations are expensive. 
For instance, <code>arr.unshift(obj)</code> operation has to renumber all elements to make room for a new <code>obj</code>, and if the array is big, it takes time. 
Same with <code>arr.shift()</code>.

The only structural modifications that do not require mass-renumbering are those that operate with the end of array: <code>arr.push/pop</code>. 
So an array can be quite slow for big queues.

Alternatively, if we really need fast insertion/deletion, we can choose another data structure called a <a href="https://en.wikipedia.org/wiki/Linked_list">linked list</a>.

The <em>linked list element</em> is recursively defined as an object with:

<li><code>value</code>.</li><li><code>next</code> property referencing the next <em>linked list element</em> or <code>null</code> if that’s the end.</li>

For instance:

    <code>let list = {
  value: 1,
  next: {
    value: 2,
    next: {
value: 3,
next: {
  value: 4,
  next: null
}
    }
  }
};</code>
  Graphical representation of the list:

<img src="https://javascript.info/article/recursion/linked-list.png">
An alternative code for creation:

    <code>let list = { value: 1 };
list.next = { value: 2 };
list.next.next = { value: 3 };
list.next.next.next = { value: 4 };</code>
  Here we can even more clearer see that there are multiple objects, each one has the <code>value</code> and <code>next</code> pointing to the neighbour. 
The <code>list</code> variable is the first object in the chain, so following <code>next</code> pointers from it we can reach any element.

The list can be easily split into multiple parts and later joined back:

    <code>let secondList = list.next.next;
list.next.next = null;</code>
  

<img src="https://javascript.info/article/recursion/linked-list-split.png">
To join:

    <code>list.next.next = secondList;</code>
  And surely we can insert or remove items in any place.

For instance, to prepend a new value, we need to update the head of the list:

    <code>let list = { value: 1 };
list.next = { value: 2 };
list.next.next = { value: 3 };
list.next.next.next = { value: 4 };
// prepend the new value to the list
list = { value: &quot;new item&quot;, next: list };</code>
  

<img src="https://javascript.info/article/recursion/linked-list-0.png">
To remove a value from the middle, change <code>next</code> of the previous one:

    <code>list.next = list.next.next;</code>
  

<img src="https://javascript.info/article/recursion/linked-list-remove-1.png">
We made <code>list.next</code> jump over <code>1</code> to value <code>2</code>. 
The value <code>1</code> is now excluded from the chain. 
If it’s not stored anywhere else, it will be automatically removed from the memory.

Unlike arrays, there’s no mass-renumbering, we can easily rearrange elements.

Naturally, lists are not always better than arrays. 
Otherwise everyone would use only lists.

The main drawback is that we can’t easily access an element by its number. 
In an array that’s easy: <code>arr[n]</code> is a direct reference. 
But in the list we need to start from the first item and go <code>next</code> <code>N</code> times to get the Nth element.

…But we don’t always need such operations. 
For instance, when we need a queue or even a <a href="https://en.wikipedia.org/wiki/Double-ended_queue">deque</a> – the ordered structure that must allow very fast adding/removing elements from both ends.

Sometimes it’s worth to add another variable named <code>tail</code> to track the last element of the list (and update it when adding/removing elements from the end). 
For large sets of elements the speed difference versus arrays is huge.

<h4><a name="summary" href="#summary">Summary</a4</h2>
Terms:

<li><em>Recursion</em>  is a programming term that means a “self-calling” function. 
Such functions can be used to solve certain tasks in elegant ways.

When a function calls itself, that’s called a <em>recursion step</em>. 
The <em>basis</em> of recursion is function arguments that make the task so simple that the function does not make further calls.

</li><li>A <a href="https://en.wikipedia.org/wiki/Recursive_data_type">recursively-defined</a> data structure is a data structure that can be defined using itself.

For instance, the linked list can be defined as a data structure consisting of an object referencing a list (or null).

    <code>list = { value, next -&gt; list }</code>
  Trees like HTML elements tree or the department tree from this chapter are also naturally recursive: they branch and every branch can have other branches.

Recursive functions can be used to walk them as we’ve seen in the <code>sumSalary</code> example.

</li>

Any recursive function can be rewritten into an iterative one. 
And that’s sometimes required to optimize stuff. 
But for many tasks a recursive solution is fast enough and easier to write and support.

For instance:

    <code>sumTo(1) = 1
sumTo(2) = 2 + 1 = 3
sumTo(3) = 3 + 2 + 1 = 6
sumTo(4) = 4 + 3 + 2 + 1 = 10
...
sumTo(100) = 100 + 99 + ... 
+ 2 + 1 = 5050</code>
  Make 3 solution variants:

<li>Using a for loop.</li><li>Using a recursion, cause <code>sumTo(n) = n + sumTo(n-1)</code> for <code>n &gt; 1</code>.</li><li>Using the <a href="https://en.wikipedia.org/wiki/Arithmetic_progression">arithmetic progression</a> formula.</li>

An example of the result:

    <code>function sumTo(n) { /*... 
your code ... 
*/ }
alert( sumTo(100) ); // 5050</code>
  P.S. 
Which solution variant is the fastest? The slowest? Why?

P.P.S. 
Can we use recursion to count <code>sumTo(100000)</code>?

<button type="button">solution</button>

The solution using a loop:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function sumTo(n) {
  let sum = 0;
  for (let i = 1; i &lt;= n; i++) {
    sum += i;
  }
  return sum;
}
alert( sumTo(100) );</code>
  The solution using recursion:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function sumTo(n) {
  if (n == 1) return 1;
  return n + sumTo(n - 1);
}
alert( sumTo(100) );</code>
  The solution using the formula: <code>sumTo(n) = n*(n+1)/2</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function sumTo(n) {
  return n * (n + 1) / 2;
}
alert( sumTo(100) );</code>
  P.S. 
Naturally, the formula is the fastest solution. 
It uses only 3 operations for any number <code>n</code>. 
The math helps!

The loop variant is the second in terms of speed. 
In both the recursive and the loop variant we sum the same numbers. 
But the recursion involves nested calls and execution stack management. 
That also takes resources, so it’s slower.

P.P.S. 
The standard describes a “tail call” optimization: if the recursive call is the very last one in the function (like in <code>sumTo</code> above), then the outer function will not need to resume the execution and we don’t need to remember its execution context. 
In that case <code>sumTo(100000)</code> is countable. 
But if your JavaScript engine does not support it, there will be an error: maximum stack size exceeded, because there’s usually a limitation on the total stack size.

<button type="button" title="close"></button>

<h3><a href="#calculate-factorial" name="calculate-factorial">Calculate factorial</a></h3><a href="/task/factorial" target="_blank"></a>

importance: 4

The <a href="https://en.wikipedia.org/wiki/Factorial">factorial</a> of a natural number is a number multiplied by <code>&quot;number minus one&quot;</code>, then by <code>&quot;number minus two&quot;</code>, and so on till <code>1</code>. 
The factorial of <code>n</code> is denoted as <code>n!</code>

We can write a definition of factorial like this:

    <code>n! = n * (n - 1) * (n - 2) * ...*1</code>
  Values of factorials for different <code>n</code>:

    <code>1! = 1
2! = 2 * 1 = 2
3! = 3 * 2 * 1 = 6
4! = 4 * 3 * 2 * 1 = 24
5! = 5 * 4 * 3 * 2 * 1 = 120</code>
  The task is to write a function <code>factorial(n)</code> that calculates <code>n!</code> using recursive calls.

    <code>alert( factorial(5) ); // 120</code>
  P.S. 
Hint: <code>n!</code> can be written as <code>n * (n-1)!</code> For instance: <code>3! = 3*2! = 3*2*1! = 6</code>

<button type="button">solution</button>

By definition, a factorial is <code>n!</code> can be written as <code>n * (n-1)!</code>.

In other words, the result of <code>factorial(n)</code> can be calculated as <code>n</code> multiplied by the result of <code>factorial(n-1)</code>. 
And the call for <code>n-1</code> can recursively descend lower, and lower, till <code>1</code>.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function factorial(n) {
  return (n != 1) ? n * factorial(n - 1) : 1;
}
alert( factorial(5) ); // 120</code>
  The basis of recursion is the value <code>1</code>. 
We can also make <code>0</code> the basis here, doesn’t matter much, but gives one more recursive step:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function factorial(n) {
  return n ? n * factorial(n - 1) : 1;
}
alert( factorial(5) ); // 120</code>
  <button type="button" title="close"></button>

<h3><a href="#fibonacci-numbers" name="fibonacci-numbers">Fibonacci numbers</a></h3><a href="/task/fibonacci-numbers" target="_blank"></a>

importance: 5

The sequence of <a href="https://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci numbers</a> has the formula <code>F<sub>n</sub> = F<sub>n-1</sub> + F<sub>n-2</sub></code>. 
In other words, the next number is a sum of the two preceding ones.

First two numbers are <code>1</code>, then <code>2(1+1)</code>, then <code>3(1+2)</code>, <code>5(2+3)</code> and so on: <code>1, 1, 2, 3, 5, 8, 13, 21...</code>.

Fibonacci numbers are related to the <a href="https://en.wikipedia.org/wiki/Golden_ratio">Golden ratio</a> and many natural phenomena around us.

Write a function <code>fib(n)</code> that returns the <code>n-th</code> Fibonacci number.

An example of work:

    <code>function fib(n) { /* your code */ }
alert(fib(3)); // 2
alert(fib(7)); // 13
alert(fib(77)); // 5527939700884757</code>
  P.S. 
The function should be fast. 
The call to <code>fib(77)</code> should take no more than a fraction of a second.

<button type="button">solution</button>

The first solution we could try here is the recursive one.

Fibonacci numbers are recursive by definition:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function fib(n) {
  return n &lt;= 1 ? n : fib(n - 1) + fib(n - 2);
}
alert( fib(3) ); // 2
alert( fib(7) ); // 13
// fib(77); // will be extremely slow!</code>
  …But for big values of <code>n</code> it’s very slow. 
For instance, <code>fib(77)</code> may hang up the engine for some time eating all CPU resources.

That’s because the function makes too many subcalls. 
The same values are re-evaluated again and again.

For instance, let’s see a piece of calculations for <code>fib(5)</code>:

    <code>...
fib(5) = fib(4) + fib(3)
fib(4) = fib(3) + fib(2)
...</code>
  Here we can see that the value of <code>fib(3)</code> is needed for both <code>fib(5)</code> and <code>fib(4)</code>. 
So <code>fib(3)</code> will be called and evaluated two times completely independently.

Here’s the full recursion tree:

<img src="https://javascript.info/task/fibonacci-numbers/fibonacci-recursion-tree.png">
We can clearly notice that <code>fib(3)</code> is evaluated two times and <code>fib(2)</code> is evaluated three times. 
The total amount of computations grows much faster than <code>n</code>, making it enormous even for <code>n=77</code>.

We can optimize that by remembering already-evaluated values: if a value of say <code>fib(3)</code> is calculated once, then we can just reuse it in future computations.

Another variant would be to give up recursion and use a totally different loop-based algorithm.

Instead of going from <code>n</code> down to lower values, we can make a loop that starts from <code>1</code> and <code>2</code>, then gets <code>fib(3)</code> as their sum, then <code>fib(4)</code> as the sum of two previous values, then <code>fib(5)</code> and goes up and up, till it gets to the needed value. 
On each step we only need to remember two previous values.

Here are the steps of the new algorithm in details.

The start:

    <code>// a = fib(1), b = fib(2), these values are by definition 1
let a = 1, b = 1;
// get c = fib(3) as their sum
let c = a + b;
/* we now have fib(1), fib(2), fib(3)
a  b  c
1, 1, 2
*/</code>
  Now we want to get <code>fib(4) = fib(2) + fib(3)</code>.

Let’s shift the variables: <code>a,b</code> will get <code>fib(2),fib(3)</code>, and <code>c</code> will get their sum:

    <code>a = b; // now a = fib(2)
b = c; // now b = fib(3)
c = a + b; // c = fib(4)
/* now we have the sequence:
   a  b  c
1, 1, 2, 3
*/</code>
  The next step gives another sequence number:

    <code>a = b; // now a = fib(3)
b = c; // now b = fib(4)
c = a + b; // c = fib(5)
/* now the sequence is (one more number):
a  b  c
1, 1, 2, 3, 5
*/</code>
  …And so on until we get the needed value. 
That’s much faster than recursion and involves no duplicate computations.

The full code:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function fib(n) {
  let a = 1;
  let b = 1;
  for (let i = 3; i &lt;= n; i++) {
    let c = a + b;
    a = b;
    b = c;
  }
  return b;
}
alert( fib(3) ); // 2
alert( fib(7) ); // 13
alert( fib(77) ); // 5527939700884757</code>
  The loop starts with <code>i=3</code>, because the first and the second sequence values are hard-coded into variables <code>a=1</code>, <code>b=1</code>.

The approach is called <a href="https://en.wikipedia.org/wiki/Dynamic_programming">dynamic programming bottom-up</a>.

<button type="button" title="close"></button>

<h3><a href="#output-a-single-linked-list" name="output-a-single-linked-list">Output a single-linked list</a></h3><a href="/task/output-single-linked-list" target="_blank"></a>

importance: 5

Let’s say we have a single-linked list (as described in the chapter <a href="/recursion">Recursion and stack</a>):

    <code>let list = {
  value: 1,
  next: {
    value: 2,
    next: {
value: 3,
next: {
  value: 4,
  next: null
}
    }
  }
};</code>
  Write a function <code>printList(list)</code> that outputs list items one-by-one.

Make two variants of the solution: using a loop and using recursion.

What’s better: with recursion or without it?

<button type="button">solution</button>

<button type="button" onclick="showStep(this)">Loop-based solution</button>

<h4>Loop-based solution</h4>
The loop-based variant of the solution:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let list = {
  value: 1,
  next: {
    value: 2,
    next: {
value: 3,
next: {
  value: 4,
  next: null
}
    }
  }
};
function printList(list) {
  let tmp = list;
  while (tmp) {
    alert(tmp.value);
    tmp = tmp.next;
  }
}
printList(list);</code>
  Please note that we use a temporary variable <code>tmp</code> to walk over the list. 
Technically, we could use a function parameter <code>list</code> instead:

    <code>function printList(list) {
  while(list) {
    alert(list.value);
    list = list.next;
  }
}</code>
  …But that would be unwise. 
In the future we may need to extend a function, do something else with the list. 
If we change <code>list</code>, then we loose such ability.

Talking about good variable names, <code>list</code> here is the list itself. 
The first element of it. 
And it should remain like that. 
That’s clear and reliable.

From the other side, the role of <code>tmp</code> is exclusively a list traversal, like <code>i</code> in the <code>for</code> loop.

<button type="button" onclick="showStep(this)">Recursive solution</button>

<h4>Recursive solution</h4>
The recursive variant of <code>printList(list)</code> follows a simple logic: to output a list we should output the current element <code>list</code>, then do the same for <code>list.next</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let list = {
  value: 1,
  next: {
    value: 2,
    next: {
value: 3,
next: {
  value: 4,
  next: null
}
    }
  }
};
function printList(list) {
  alert(list.value); // output the current item
  if (list.next) {
    printList(list.next); // do the same for the rest of the list
  }
}
printList(list);</code>
  Now what’s better?

Technically, the loop is more effective. 
These two variants do the same, but the loop does not spend resources for nested function calls.

From the other side, the recursive variant is shorter and sometimes easier to understand.

<button type="button" title="close"></button>

<h3><a href="#output-a-single-linked-list-in-the-reverse-order" name="output-a-single-linked-list-in-the-reverse-order">Output a single-linked list in the reverse order</a></h3><a href="/task/output-single-linked-list-reverse" target="_blank"></a>

importance: 5

Output a single-linked list from the previous task <a href="/task/output-single-linked-list">Output a single-linked list</a> in the reverse order.

Make two solutions: using a loop and using a recursion.

<button type="button">solution</button>

<button type="button" onclick="showStep(this)">Using a recursion</button>

<h4>Using a recursion</h4>
The recursive logic is a little bit tricky here.

We need to first output the rest of the list and <em>then</em> output the current one:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let list = {
  value: 1,
  next: {
    value: 2,
    next: {
value: 3,
next: {
  value: 4,
  next: null
}
    }
  }
};
function printReverseList(list) {
  if (list.next) {
    printReverseList(list.next);
  }
  alert(list.value);
}
printReverseList(list);</code>
  
<button type="button" onclick="showStep(this)">Using a loop</button>

<h4>Using a loop</h4>
The loop variant is also a little bit more complicated then the direct output.

There is no way to get the last value in our <code>list</code>. 
We also can’t “go back”.

So what we can do is to first go through the items in the direct order and rememeber them in an array, and then output what we remembered in the reverse order:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let list = {
  value: 1,
  next: {
    value: 2,
    next: {
value: 3,
next: {
  value: 4,
  next: null
}
    }
  }
};
function printReverseList(list) {
  let arr = [];
  let tmp = list;
  while (tmp) {
    arr.push(tmp.value);
    tmp = tmp.next;
  }
  for (let i = arr.length - 1; i &gt;= 0; i--) {
    alert( arr[i] );
  }
}
printReverseList(list);</code>
  Please note that the recursive solution actually does exactly the same: it follows the list, remembers the items in the chain of nested calls (in the execution context stack), and then outputs them.

<button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/advanced-functions" data-tooltip="Advanced working with functions">Previous lesson</a><a href="/rest-parameters-spread-operator" data-tooltip="Rest parameters and spread operator">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Frecursion"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Frecursion"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Frecursion"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Frecursion"></a>

Many JavaScript built-in functions support an arbitrary number of arguments.

For instance:

<li><code>Math.max(arg1, arg2, ..., argN)</code> – returns the greatest of the arguments.</li><li><code>Object.assign(dest, src1, ..., srcN)</code> – copies properties from <code>src1..N</code> into <code>dest</code>.</li><li>…and so on.</li>

In this chapter we’ll learn how to do the same. 
And, more importantly, how to feel comfortable working with such functions and arrays.

<h2>Rest parameters <code>...</code></h2>
A function can be called with any number of arguments, no matter how it is defined.

Like here:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function sum(a, b) {
  return a + b;
}
alert( sum(1, 2, 3, 4, 5) );</code>
  There will be no error because of “excessive” arguments. 
But of course in the result only the first two will be counted.

The rest parameters can be mentioned in a function definition with three dots <code>...</code>. 
They literally mean “gather the remaining parameters into an array”.

For instance, to gather all arguments into array <code>args</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function sumAll(...args) { // args is the name for the array
  let sum = 0;
  for (let arg of args) sum += arg;
  return sum;
}
alert( sumAll(1) ); // 1
alert( sumAll(1, 2) ); // 3
alert( sumAll(1, 2, 3) ); // 6</code>
  We can choose to get the first parameters as variables, and gather only the rest.

Here the first two arguments go into variables and the rest go into <code>titles</code> array:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function showName(firstName, lastName, ...titles) {
  alert( firstName + ' ' + lastName ); // Julius Caesar
  // the rest go into titles array
  // i.e. 
titles = [&quot;Consul&quot;, &quot;Imperator&quot;]
  alert( titles[0] ); // Consul
  alert( titles[1] ); // Imperator
  alert( titles.length ); // 2
}
showName(&quot;Julius&quot;, &quot;Caesar&quot;, &quot;Consul&quot;, &quot;Imperator&quot;);</code>
  

The rest parameters must be at the end
The rest parameters gather all remaining arguments, so the following has no sense:

    <code>function f(arg1, ...rest, arg2) { // arg2 after ...rest ?!
  // error
}</code>
  The <code>...rest</code> must always be last.

<h2>The “arguments” variable</h2>
There is also a special array-like object named <code>arguments</code> that contains all arguments by their index.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function showName() {
  alert( arguments.length );
  alert( arguments[0] );
  alert( arguments[1] );
  // it's iterable
  // for(let arg of arguments) alert(arg);
}
// shows: 2, Julius, Caesar
showName(&quot;Julius&quot;, &quot;Caesar&quot;);
// shows: 1, Ilya, undefined (no second argument)
showName(&quot;Ilya&quot;);</code>
  In old times, rest parameters did not exist in the language, and using <code>arguments</code> was the only way to get all arguments of the function, no matter their total number.

And it still works, we can use it today.

But the downside is that although <code>arguments</code> is both array-like and iterable, it’s not an array. 
It does not support array methods, so we can’t call <code>arguments.map(...)</code> for example.

Also, it always contains all arguments. 
We can’t capture them partially, like we did with rest parameters.

So when we need these features, then rest parameters are preferred.

Arrow functions do not have <code>&quot;arguments&quot;</code>
If we access the <code>arguments</code> object from an arrow function, it takes them from the outer “normal” function.

Here’s an example:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function f() {
  let showArg = () =&gt; alert(arguments[0]);
  showArg();
}
f(1); // 1</code>
  As we remember, arrow functions don’t have their own <code>this</code>. 
Now we know they don’t have the special <code>arguments</code> object either.

<h2>Spread operator</h2>
We’ve just seen how to get an array from the list of parameters.

But sometimes we need to do exactly the reverse.

For instance, there’s a built-in function <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/max">Math.max</a> that returns the greatest number from a list:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert( Math.max(3, 5, 1) ); // 5</code>
  Now let’s say we have an array <code>[3, 5, 1]</code>. 
How do we call <code>Math.max</code> with it?

Passing it “as it” won’t work, because <code>Math.max</code> expects a list of numeric arguments, not a single array:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let arr = [3, 5, 1];
alert( Math.max(arr) ); // NaN</code>
  And surely we can’t manually list items in the code <code>Math.max(arg[0], arg[1], arg[2])</code>, because we may be unsure how many there are. 
As our script executes, there could be a lot, or there could be none. 
And that would get ugly.

<em>Spread operator</em> to the rescue! It looks similar to rest parameters, also using <code>...</code>, but does quite the opposite.

When <code>...arr</code> is used in the function call, it “expands” an iterable object <code>arr</code> into the list of arguments.

For <code>Math.max</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let arr = [3, 5, 1];
alert( Math.max(...arr) ); // 5 (spread turns array into a list of arguments)</code>
  We also can pass multiple iterables this way:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let arr1 = [1, -2, 3, 4];
let arr2 = [8, 3, -8, 1];
alert( Math.max(...arr1, ...arr2) ); // 8</code>
  We can even combine the spread operator with normal values:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let arr1 = [1, -2, 3, 4];
let arr2 = [8, 3, -8, 1];
alert( Math.max(1, ...arr1, 2, ...arr2, 25) ); // 25</code>
  Also, the spread operator can be used to merge arrays:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let arr = [3, 5, 1];
let arr2 = [8, 9, 15];
let merged = [0, ...arr, 2, ...arr2];
alert(merged); // 0,3,5,1,2,8,9,15 (0, then arr, then 2, then arr2)</code>
  In the examples above we used an array to demonstrate the spread operator, but any iterable will do.

For instance, here we use the spread operator to turn the string into array of characters:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let str = &quot;Hello&quot;;
alert( [...str] ); // H,e,l,l,o</code>
  The spread operator internally uses iterators to gather elements, the same way as <code>for..of</code> does.

So, for a string, <code>for..of</code> returns characters and <code>...str</code> becomes <code>&quot;H&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;</code>. 
The list of characters is passed to array initializer <code>[...str]</code>.

For this particular task we could also use <code>Array.from</code>, because it converts an iterable (like a string) into an array:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let str = &quot;Hello&quot;;
// Array.from converts an iterable into an array
alert( Array.from(str) ); // H,e,l,l,o</code>
  The result is the same as <code>[...str]</code>.

But there’s a subtle difference between <code>Array.from(obj)</code> and <code>[...obj]</code>:

<li><code>Array.from</code> operates on both array-likes and iterables.</li><li>The spread operator operates only on iterables.</li>

So, for the task of turning something into an array, <code>Array.from</code> tends to be more universal.

<h4><a name="summary" href="#summary">Summary</a4</h2>
When we see <code>&quot;...&quot;</code> in the code, it is either rest parameters or the spread operator.

There’s an easy way to distinguish between them:

<li>When <code>...</code> is at the end of function parameters, it’s “rest parameters” and gathers the rest of the list of arguments into an array.</li><li>When <code>...</code> occurs in a function call or alike, it’s called a “spread operator” and expands an array into a list.</li>

Use patterns:

<li>Rest parameters are used to create functions that accept any number of arguments.</li><li>The spread operator is used to pass an array to functions that normally require a list of many arguments.</li>

Together they help to travel between a list and an array of parameters with ease.

All arguments of a function call are also available in “old-style” <code>arguments</code>: array-like iterable object.

JavaScript is a very function-oriented language. 
It gives us a lot of freedom. 
A function can be created at one moment, then copied to another variable or passed as an argument to another function and called from a totally different place later.

We know that a function can access variables outside of it; this feature is used quite often.

But what happens when an outer variable changes? Does a function get the most recent value or the one that existed when the function was created?

Also, what happens when a function travels to another place in the code and is called from there – does it get access to the outer variables of the new place?

Different languages behave differently here, and in this chapter we cover the behaviour of JavaScript.

<h2>A couple of questions</h2>
Let’s consider two situations to begin with, and then study the internal mechanics piece-by-piece, so that you’ll be able to answer the following questions and more complex ones in the future.

<li>The function <code>sayHi</code> uses an external variable <code>name</code>. 
When the function runs, which value is it going to use?

    <code>let name = &quot;John&quot;;
function sayHi() {
  alert(&quot;Hi, &quot; + name);
}
name = &quot;Pete&quot;;
sayHi(); // what will it show: &quot;John&quot; or &quot;Pete&quot;?</code>
  Such situations are common both in browser and server-side development. 
A function may be scheduled to execute later than it is created, for instance after a user action or a network request.

So, the question is: does it pick up the latest changes?

</li><li>The function <code>makeWorker</code> makes another function and returns it. 
That new function can be called from somewhere else. 
Will it have access to the outer variables from its creation place, or the invocation place, or both?

    <code>function makeWorker() {
  let name = &quot;Pete&quot;;
  return function() {
    alert(name);
  };
}
let name = &quot;John&quot;;
// create a function
let work = makeWorker();
// call it
work(); // what will it show? &quot;Pete&quot; (name where created) or &quot;John&quot; (name where called)?</code>
  </li>

<h2>Lexical Environment</h2>
To understand what’s going on, let’s first discuss what a “variable” actually is.

In JavaScript, every running function, code block, and the script as a whole have an associated object known as the <em>Lexical Environment</em>.

The Lexical Environment object consists of two parts:

<li><em>Environment Record</em> – an object that has all local variables as its properties (and some other information like the value of <code>this</code>).</li><li>A reference to the <em>outer lexical environment</em>, usually the one associated with the code lexically right outside of it (outside of the current curly brackets).</li>

So, a “variable” is just a property of the special internal object, Environment Record. 
“To get or change a variable” means “to get or change a property of the Lexical Environment”.

For instance, in this simple code, there is only one Lexical Environment:

<img src="https://javascript.info/article/closure/lexical-environment-global.png">
This is a so-called global Lexical Environment, associated with the whole script. 
For browsers, all <code>&lt;script&gt;</code> tags share the same global environment.

On the picture above, the rectangle means Environment Record (variable store) and the arrow means the outer reference. 
The global Lexical Environment has no outer reference, so it points to <code>null</code>.

Here’s the bigger picture of how <code>let</code> variables work:

<img src="https://javascript.info/article/closure/lexical-environment-global-2.png">
Rectangles on the right-hand side demonstrate how the global Lexical Environment changes during the execution:

<li>When the script starts, the Lexical Environment is empty.</li><li>The <code>let phrase</code> definition appears. 
It has been assigned no value, so <code>undefined</code> is stored.</li><li><code>phrase</code> is assigned a value.</li><li><code>phrase</code> refers to a new value.</li>

Everything looks simple for now, right?

To summarize:

<li>A variable is a property of a special internal object, associated with the currently executing block/function/script.</li><li>Working with variables is actually working with the properties of that object.</li>

<h3><a name="function-declaration" href="#function-declaration">Function Declaration</a></h3>
Function Declarations are special. 
Unlike <code>let</code> variables, they are processed not when the execution reaches them, but when a Lexical Environment is created. 
For the global Lexical Environment, it means the moment when the script is started.

That is why we can call a function declaration before it is defined.

The code below demonstrates that the Lexical Environment is non-empty from the beginning. 
It has <code>say</code>, because that’s a Function Declaration. 
And later it gets <code>phrase</code>, declared with <code>let</code>:

<img src="https://javascript.info/article/closure/lexical-environment-global-3.png">
<h3><a name="inner-and-outer-lexical-environment" href="#inner-and-outer-lexical-environment">Inner and outer Lexical Environment</a></h3>
During the call, <code>say()</code> uses an outer variable, so let’s look at the details of what’s going on.

First, when a function runs, a new function Lexical Environment is created automatically. 
That’s a general rule for all functions. 
That Lexical Environment is used to store local variables and parameters of the call.

<!--
    ```js
    let phrase = "Hello";
    
    function say(name) {
     alert( `${phrase}, ${name}` );
    }
    
    say("John"); // Hello, John
    ```-->

Here’s the picture of Lexical Environments when the execution is inside <code>say(&quot;John&quot;)</code>, at the line labelled with an arrow:

<img src="https://javascript.info/article/closure/lexical-environment-simple.png">
During the function call we have two Lexical Environments: the inner one (for the function call) and the outer one (global):

<li>The inner Lexical Environment corresponds to the current execution of  <code>say</code>. 
It has a single variable: <code>name</code>, the function argument. 
We called <code>say(&quot;John&quot;)</code>, so the value of <code>name</code> is <code>&quot;John&quot;</code>.</li><li>The outer Lexical Environment is the global Lexical Environment.</li>

The inner Lexical Environment has the <code>outer</code> reference to the outer one.

<strong>When code wants to access a variable – it is first searched for in the inner Lexical Environment, then in the outer one, then the more outer one and so on until the end of the chain.</strong>

If a variable is not found anywhere, that’s an error in strict mode. 
Without <code>use strict</code>, an assignment to an undefined variable creates a new global variable, for backwards compatibility.

Let’s see how the search proceeds in our example:

<li>When the <code>alert</code> inside <code>say</code> wants to access <code>name</code>, it finds it immediately in the function Lexical Environment.</li><li>When it wants to access <code>phrase</code>, then there is no <code>phrase</code> locally, so it follows the <code>outer</code> reference and finds it globally.</li>

<img src="https://javascript.info/article/closure/lexical-environment-simple-lookup.png">
Now we can give the answer to the first question from the beginning of the chapter.

<strong>A function gets outer variables as they are now; it uses the most recent values.</strong>

That’s because of the described mechanism. 
Old variable values are not saved anywhere. 
When a function wants them, it takes the current values from its own or an outer Lexical Environment.

So the answer to the first question is <code>Pete</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let name = &quot;John&quot;;
function sayHi() {
  alert(&quot;Hi, &quot; + name);
}
name = &quot;Pete&quot;; // (*)
sayHi(); // Pete</code>
  The execution flow of the code above:

<li>The global Lexical Environment has <code>name: &quot;John&quot;</code>.</li><li>At the line <code>(*)</code> the global variable is changed, now it has <code>name: &quot;Pete&quot;</code>.</li><li>When the function <code>say()</code>, is executed and takes <code>name</code> from outside. 
Here that’s from the global Lexical Environment where it’s already <code>&quot;Pete&quot;</code>.</li>

One call – one Lexical Environment
Please note that a new function Lexical Environment is created each time a function runs.

And if a function is called multiple times, then each invocation will have its own Lexical Environment, with local variables and parameters specific for that very run.

Lexical Environment is a specification object
“Lexical Environment” is a specification object. 
We can’t get this object in our code and manipulate it directly. 
JavaScript engines also may optimize it, discard variables that are unused to save memory and perform other internal tricks, but the visible behavior should be as described.

<h2>Nested functions</h2>
A function is called “nested” when it is created inside another function.

It is easily possible to do this with JavaScript.

We can use it to organize our code, like this:

    <code>function sayHiBye(firstName, lastName) {
  // helper nested function to use below
  function getFullName() {
    return firstName + &quot; &quot; + lastName;
  }
  alert( &quot;Hello, &quot; + getFullName() );
  alert( &quot;Bye, &quot; + getFullName() );
}</code>
  Here the <em>nested</em> function <code>getFullName()</code> is made for convenience. 
It can access the outer variables and so can return the full name.

What’s more interesting, a nested function can be returned: either as a property of a new object (if the outer function creates an object with methods) or as a result by itself. 
It can then be used somewhere else. 
No matter where, it still has access to the same outer variables.

An example with the constructor function (see the chapter <a href="/constructor-new">Constructor, operator &quot;new&quot;</a>):

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// constructor function returns a new object
function User(name) {
  // the object method is created as a nested function
  this.sayHi = function() {
    alert(name);
  };
}
let user = new User(&quot;John&quot;);
user.sayHi(); // the method code has access to the outer &quot;name&quot;</code>
  An example with returning a function:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function makeCounter() {
  let count = 0;
  return function() {
    return count++; // has access to the outer counter
  };
}
let counter = makeCounter();
alert( counter() ); // 0
alert( counter() ); // 1
alert( counter() ); // 2</code>
  Let’s go on with the <code>makeCounter</code> example. 
It creates the “counter” function that returns the next number on each invocation. 
Despite being simple, slightly modified variants of that code have practical uses, for instance, as a <a href="https://en.wikipedia.org/wiki/Pseudorandom_number_generator">pseudorandom number generator</a>, and more. 
So the example is not as artificial as it may appear.

How does the counter work internally?

When the inner function runs, the variable in <code>count++</code> is searched from inside out. 
For the example above, the order will be:

<img src="https://javascript.info/article/closure/lexical-search-order.png">
<li>The locals of the nested function…</li><li>The variables of the outer function…</li><li>And so on until it reaches global variables.</li>

In this example <code>count</code> is found on  step <code>2</code>. 
When an outer variable is modified, it’s changed where it’s found. 
So <code>count++</code> finds the outer variable and increases it in the Lexical Environment where it belongs. 
Like if we had <code>let count = 1</code>.

Here are two questions to consider:

<li>Can we somehow reset the <code>counter</code> from the code that doesn’t belong to <code>makeCounter</code>? E.g. 
after <code>alert</code> calls in the example above.</li><li>If we call <code>makeCounter()</code> multiple times – it returns many <code>counter</code> functions. 
Are they independent or do they share the same <code>count</code>?</li>

Try to answer them before you continue reading.

…

All done?

Okay, let’s go over the answers.

<li>There is no way. 
The <code>counter</code> is a local function variable, we can’t access it from the outside.</li><li>For every call to <code>makeCounter()</code> a new function Lexical Environment is created, with its own <code>counter</code>. 
So the resulting <code>counter</code> functions are independent.</li>

Here’s the demo:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function makeCounter() {
  let count = 0;
  return function() {
    return count++;
  };
}
let counter1 = makeCounter();
let counter2 = makeCounter();
alert( counter1() ); // 0
alert( counter1() ); // 1
alert( counter2() ); // 0 (independent)</code>
  Hopefully, the situation with outer variables is quite clear for you now. 
But in more complex situations a deeper understanding of internals may be required. 
So let’s dive deeper.

<h2>Environments in detail</h2>
Now that you understand how closures work generally, we can descend to the very nuts and bolts.

Here’s what’s going on in the <code>makeCounter</code> example step-by-step, follow it to make sure that you understand everything. 
Please note the additional <code>[[Environment]]</code> property that we didn’t cover yet.

<li>When the script has just started, there is only global Lexical Environment:

<img src="https://javascript.info/article/closure/lexenv-nested-makecounter-1.png">
At that starting moment there is only <code>makeCounter</code> function, because it’s a Function Declaration. 
It did not run yet.

All functions “on birth” receive a hidden property <code>[[Environment]]</code> with a reference to the Lexical Environment of their creation. 
We didn’t talk about it yet, but that’s how the function knows where it was made.

Here, <code>makeCounter</code> is created in the global Lexical Environment, so <code>[[Environment]]</code> keeps a reference to it.

In other words, a function is “imprinted” with a reference to the Lexical Environment where it was born. 
And <code>[[Environment]]</code> is the hidden function property that has that reference.

</li><li>The code runs on, and the call to <code>makeCounter()</code> is performed. 
Here’s a snapshot of the moment when the execution is on the first line inside <code>makeCounter()</code>:

<img src="https://javascript.info/article/closure/lexenv-nested-makecounter-2.png">
At the moment of the call of <code>makeCounter()</code>, the Lexical Environment is created, to hold its variables and arguments.

As all Lexical Environments, it stores two things:

<li>An Environment Record with local variables. 
In our case <code>count</code> is the only local variable (appearing when the line with <code>let count</code> is executed).</li><li>The outer lexical reference, which is set to <code>[[Environment]]</code> of the function. 
Here <code>[[Environment]]</code> of <code>makeCounter</code> references the global Lexical Environment.</li>

So, now we have two Lexical Environments: the first one is global, the second one is for the current <code>makeCounter</code> call, with the outer reference to global.

</li><li>During the execution of <code>makeCounter()</code>, a tiny nested function is created.

It doesn’t matter whether the function is created using Function Declaration or Function Expression. 
All functions get the <code>[[Environment]]</code> property that references the Lexical Environment in which they were made. 
So our new tiny nested function gets it as well.

For our new nested function the value of <code>[[Environment]]</code> is the current Lexical Environment of <code>makeCounter()</code> (where it was born):

<img src="https://javascript.info/article/closure/lexenv-nested-makecounter-3.png">
Please note that on this step the inner function was created, but not yet called. 
The code inside <code>function() { return count++; }</code> is not running, we’re going to return it.

</li><li>As the execution goes on, the call to <code>makeCounter()</code> finishes, and the result (the tiny nested function) is assigned to the global variable <code>counter</code>:

<img src="https://javascript.info/article/closure/lexenv-nested-makecounter-4.png">
That function has only one line: <code>return count++</code>, that will be executed when we run it.

</li><li>When the <code>counter()</code> is called, an “empty” Lexical Environment is created for it. 
It has no local variables by itself. 
But the <code>[[Environment]]</code> of <code>counter</code> is used as the outer reference for it, so it has access to the variables of the former <code>makeCounter()</code> call where it was created:

<img src="https://javascript.info/article/closure/lexenv-nested-makecounter-5.png">
Now if it accesses a variable, it first searches its own Lexical Environment (empty), then the Lexical Environment of the former <code>makeCounter()</code> call, then the global one.

When it looks for <code>count</code>, it finds it among the variables <code>makeCounter</code>, in the nearest outer Lexical Environment.

Please note how memory management works here. 
Although <code>makeCounter()</code> call finished some time ago, its Lexical Environment was retained in memory, because there’s a nested function with <code>[[Environment]]</code> referencing it.

Generally, a Lexical Environment object lives as long as there is a function which may use it. 
And only when there are none remaining, it is cleared.

</li><li>The call to <code>counter()</code> not only returns the value of <code>count</code>, but also increases it. 
Note that the modification is done “in place”. 
The value of <code>count</code> is modified exactly in the environment where it was found.

<img src="https://javascript.info/article/closure/lexenv-nested-makecounter-6.png">
So we return to the previous step with the only change – the new value of <code>count</code>. 
The following calls all do the same.

</li><li>Next <code>counter()</code> invocations do the same.

</li>

The answer to the second question from the beginning of the chapter should now be obvious.

The <code>work()</code> function in the code below uses the <code>name</code> from the place of its origin through the outer lexical environment reference:

<img src="https://javascript.info/article/closure/lexenv-nested-work.png">
So, the result is <code>&quot;Pete&quot;</code> here.

But if there were no <code>let name</code> in <code>makeWorker()</code>, then the search would go outside and take the global variable as we can see from the chain above. 
In that case it would be <code>&quot;John&quot;</code>.

Closures
There is a general programming term “closure”, that developers generally should know.

A <a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">closure</a> is a function that remembers its outer variables and can access them. 
In some languages, that’s not possible, or a function should be written in a special way to make it happen. 
But as explained above, in JavaScript all functions are naturally closures (there is only one exclusion, to be covered in <a href="/new-function">The &quot;new Function&quot; syntax</a>).

That is: they automatically remember where they were created using a hidden <code>[[Environment]]</code> property, and all of them can access outer variables.

When on an interview, a frontend developer gets a question about “what’s a closure?”, a valid answer would be a definition of the closure and an explanation that all functions in JavaScript are closures, and maybe few more words about technical details: the <code>[[Environment]]</code> property and how Lexical Environments work.

<h2>Code blocks and loops, IIFE</h2>
The examples above concentrated on functions. 
But Lexical Environments also exist for code blocks <code>{...}</code>.

They are created when a code block runs and contain block-local variables. 
Here are a couple of examples.

<h2>If</h2>
In the example below, when the execution goes into <code>if</code> block, the new “if-only” Lexical Environment is created for it:

<!--
    ```js run
    let phrase = "Hello";
    
    if (true) {
  let user = "John";
  alert(`${phrase}, ${user}`); // Hello, John
    }
    alert(user); // Error, can't see such variable!
    ```-->

<img src="https://javascript.info/article/closure/lexenv-if.png">
The new Lexical Environment gets the enclosing one as the outer reference, so <code>phrase</code> can be found. 
But all variables and Function Expressions declared inside <code>if</code> reside in that Lexical Environment and can’t be seen from the outside.

For instance, after <code>if</code> finishes, the <code>alert</code> below won’t see the <code>user</code>, hence the error.

<h2>For, while</h2>
For a loop, every iteration has a separate Lexical Environment. 
If a variable is declared in <code>for</code>, then it’s also local to that Lexical Environment:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>for (let i = 0; i &lt; 10; i++) {
  // Each loop has its own Lexical Environment
  // {i: value}
}
alert(i); // Error, no such variable</code>
  That’s actually an exception, because <code>let i</code> is visually outside of <code>{...}</code>. 
But in fact each run of the loop has its own Lexical Environment with the current <code>i</code> in it.

After the loop, <code>i</code> is not visible.

<h3><a name="code-blocks" href="#code-blocks">Code blocks</a></h3>
We also can use a “bare” code block <code>{…}</code> to isolate variables into a “local scope”.

For instance, in a web browser all scripts share the same global area. 
So if we create a global variable in one script, it becomes available to others. 
But that becomes a source of conflicts if two scripts use the same variable name and overwrite each other.

That may happen if the variable name is a widespread word, and script authors are unaware of each other.

If we’d like to avoid that, we can use a code block to isolate the whole script or a part of it:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>{
  // do some job with local variables that should not be seen outside
  let message = &quot;Hello&quot;;
  alert(message); // Hello
}
alert(message); // Error: message is not defined</code>
  The code outside of the block (or inside another script) doesn’t see variables inside the block, because the block has its own Lexical Environment.

<h3><a name="iife" href="#iife">IIFE</a></h3>
In old scripts, one can find so-called “immediately-invoked function expressions” (abbreviated as IIFE) used for this purpose.

They look like this:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>(function() {
  let message = &quot;Hello&quot;;
  alert(message); // Hello
})();</code>
  Here a Function Expression is created and immediately called. 
So the code executes right away and has its own private variables.

The Function Expression is wrapped with brackets <code>(function {...})</code>, because when JavaScript meets <code>&quot;function&quot;</code> in the main code flow, it understands it as the start of a Function Declaration. 
But a Function Declaration must have a name, so there will be an error:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// Error: Unexpected token (
function() { // &lt;-- JavaScript cannot find function name, meets ( and gives error
  let message = &quot;Hello&quot;;
  alert(message); // Hello
}();</code>
  We can say “okay, let it be so Function Declaration, let’s add a name”, but it won’t work. 
JavaScript does not allow Function Declarations to be called immediately:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// syntax error because of brackets below
function go() {
}(); // &lt;-- can't call Function Declaration immediately</code>
  So, round brackets are needed to show JavaScript that the function is created in the context of another expression, and hence it’s a Function Expression. 
It needs no name and can be called immediately.

There are other ways to tell JavaScript that we mean Function Expression:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// Ways to create IIFE
(function() {
  alert(&quot;Brackets around the function&quot;);
})();
(function() {
  alert(&quot;Brackets around the whole thing&quot;);
}());
!function() {
  alert(&quot;Bitwise NOT operator starts the expression&quot;);
}();
+function() {
  alert(&quot;Unary plus starts the expression&quot;);
}();</code>
  In all the above cases we declare a Function Expression and run it immediately.

<h2>Garbage collection</h2>
Lexical Environment objects that we’ve been talking about are subject to the same memory management rules as regular values.

<li>Usually, Lexical Environment is cleaned up after the function run. 
For instance:

    <code>function f() {
  let value1 = 123;
  let value2 = 456;
}
f();</code>
  Here two values are technically the properties of the Lexical Environment. 
But after <code>f()</code> finishes that Lexical Environment becomes unreachable, so it’s deleted from the memory.

</li><li>…But if there’s a nested function that is still reachable after the end of <code>f</code>, then its <code>[[Environment]]</code> reference keeps the outer lexical environment alive as well:

    <code>function f() {
  let value = 123;
  function g() { alert(value); }
  return g;
}
let g = f(); // g is reachable, and keeps the outer lexical environment in memory</code>
  </li><li>Please note that if <code>f()</code> is called many times, and resulting functions are saved, then the corresponding Lexical Environment objects will also be retained in memory. 
All 3 of them in the code below:

    <code>function f() {
  let value = Math.random();
  return function() { alert(value); };
}
// 3 functions in array, every one of them links to Lexical Environment
// from the corresponding f() run
//         LE   LE   LE
let arr = [f(), f(), f()];</code>
  </li><li>A Lexical Environment object dies when it becomes unreachable: when no nested functions remain that reference it. 
In the code below, after <code>g</code> becomes unreachable, the <code>value</code> is also cleaned from memory;

    <code>function f() {
  let value = 123;
  function g() { alert(value); }
  return g;
}
let g = f(); // while g is alive
// there corresponding Lexical Environment lives
g = null; // ...and now the memory is cleaned up</code>
  </li>

<h3><a name="real-life-optimizations" href="#real-life-optimizations">Real-life optimizations</a></h3>
As we’ve seen, in theory while a function is alive, all outer variables are also retained.

But in practice, JavaScript engines try to optimize that. 
They analyze variable usage and if it’s easy to see that an outer variable is not used – it is removed.

<strong>An important side effect in V8 (Chrome, Opera) is that such variable will become unavailable in debugging.</strong>

Try running the example below in Chrome with the Developer Tools open.

When it pauses, in the console type <code>alert(value)</code>.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function f() {
  let value = Math.random();
  function g() {
    debugger; // in console: type alert( value ); No such variable!
  }
  return g;
}
let g = f();
g();</code>
  As you could see – there is no such variable! In theory, it should be accessible, but the engine optimized it out.

That may lead to funny (if not such time-consuming) debugging issues. 
One of them – we can see a same-named outer variable instead of the expected one:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let value = &quot;Surprise!&quot;;
function f() {
  let value = &quot;the closest value&quot;;
  function g() {
    debugger; // in console: type alert( value ); Surprise!
  }
  return g;
}
let g = f();
g();</code>
  

See ya!
This feature of V8 is good to know. 
If you are debugging with Chrome/Opera, sooner or later you will meet it.

That is not a bug in the debugger, but rather a special feature of V8. 
Perhaps it will be changed sometime.
You always can check for it by running the examples on this page.

Are they independent? What is the second counter going to show? <code>0,1</code> or <code>2,3</code> or something else?

    <code>function makeCounter() {
  let count = 0;
  return function() {
    return count++;
  };
}
let counter = makeCounter();
let counter2 = makeCounter();
alert( counter() ); // 0
alert( counter() ); // 1
alert( counter2() ); // ?
alert( counter2() ); // ?</code>
  <button type="button">solution</button>

The answer: <strong>0,1.</strong>

Functions <code>counter</code> and <code>counter2</code> are created by different invocations of <code>makeCounter</code>.

So they have independent outer Lexical Environments, each one has its own <code>count</code>.

<button type="button" title="close"></button>

<h3><a href="#counter-object" name="counter-object">Counter object</a></h3><a href="/task/counter-object-independent" target="_blank"></a>

importance: 5

Here a counter object is made with the help of the constructor function.

Will it work? What will it show?

    <code>function Counter() {
  let count = 0;
  this.up = function() {
    return ++count;
  };
  this.down = function() {
    return --count;
  };
}
let counter = new Counter();
alert( counter.up() ); // ?
alert( counter.up() ); // ?
alert( counter.down() ); // ?</code>
  <button type="button">solution</button>

Surely it will work just fine.

Both nested functions are created within the same outer Lexical Environment, so they share access to the same <code>count</code> variable:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function Counter() {
  let count = 0;
  this.up = function() {
    return ++count;
  };
  this.down = function() {
    return --count;
  };
}
let counter = new Counter();
alert( counter.up() ); // 1
alert( counter.up() ); // 2
alert( counter.down() ); // 1</code>
  <button type="button" title="close"></button>

<h3><a href="#function-in-if" name="function-in-if">Function in if</a></h3><a href="/task/function-in-if" target="_blank"></a>

Look at the code. 
What will be result of the call at the last line?

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let phrase = &quot;Hello&quot;;
if (true) {
  let user = &quot;John&quot;;
  function sayHi() {
    alert(`${phrase}, ${user}`);
  }
}
sayHi();</code>
  <button type="button">solution</button>

The result is <strong>an error</strong>.

The function <code>sayHi</code> is declared inside the <code>if</code>, so it only lives inside it. 
There is no <code>sayHi</code> outside.

<button type="button" title="close"></button>

<h3><a href="#sum-with-closures" name="sum-with-closures">Sum with closures</a></h3><a href="/task/closure-sum" target="_blank"></a>

importance: 4

Write function <code>sum</code> that works like this: <code>sum(a)(b) = a+b</code>.

Yes, exactly this way, via double brackets (not a mistype).

For instance:

    <code>sum(1)(2) = 3
sum(5)(-1) = 4</code>
  <button type="button">solution</button>

For the second brackets to work, the first ones must return a function.

Like this:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function sum(a) {
  return function(b) {
    return a + b; // takes &quot;a&quot; from the outer lexical environment
  };
}
alert( sum(1)(2) ); // 3
alert( sum(5)(-1) ); // 4</code>
  <button type="button" title="close"></button>

<h3><a href="#filter-through-function" name="filter-through-function">Filter through function</a></h3><a href="/task/filter-through-function" target="_blank"></a>

importance: 5

We have a built-in method <code>arr.filter(f)</code> for arrays. 
It filters all elements through the function <code>f</code>. 
If it returns <code>true</code>, then that element is returned in the resulting array.

Make a set of “ready to use” filters:

<li><code>inBetween(a, b)</code> – between <code>a</code> and <code>b</code> or equal to them (inclusively).</li><li><code>inArray([...])</code> – in the given array.</li>

The usage must be like this:

<li><code>arr.filter(inBetween(3,6))</code> – selects only values between 3 and 6.</li><li><code>arr.filter(inArray([1,2,3]))</code> – selects only elements matching with one of the members of <code>[1,2,3]</code>.</li>

For instance:

    <code>/* .. 
your code for inBetween and inArray */
let arr = [1, 2, 3, 4, 5, 6, 7];
alert( arr.filter(inBetween(3, 6)) ); // 3,4,5,6
alert( arr.filter(inArray([1, 2, 10])) ); // 1,2</code>
  <a href="http://plnkr.co/edit/ISIjrKehp65M3KQmIwte?p=preview" target="_blank" data-plunk-id="ISIjrKehp65M3KQmIwte">Open the sandbox with tests.</a>
<button type="button">solution</button>

<button type="button" onclick="showStep(this)">Filter inBetween</button>

<h4>Filter inBetween</h4>

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function inBetween(a, b) {
  return function(x) {
    return x &gt;= a &amp;&amp; x &lt;= b;
  };
}
let arr = [1, 2, 3, 4, 5, 6, 7];
alert( arr.filter(inBetween(3, 6)) ); // 3,4,5,6</code>
  
<button type="button" onclick="showStep(this)">Filter inArray</button>

<h4>Filter inArray</h4>

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function inArray(arr) {
  return function(x) {
    return arr.includes(x);
  };
}
let arr = [1, 2, 3, 4, 5, 6, 7];
alert( arr.filter(inArray([1, 2, 10])) ); // 1,2</code>
  <a href="http://plnkr.co/edit/hZOKDoUE3UixVYLJisFy?p=preview" target="_blank" data-plunk-id="hZOKDoUE3UixVYLJisFy">Open the solution with tests in the sandbox.</a>
<button type="button" title="close"></button>

<h3><a href="#sort-by-field" name="sort-by-field">Sort by field</a></h3><a href="/task/sort-by-field" target="_blank"></a>

importance: 5

We’ve got an array of objects to sort:

    <code>let users = [
  { name: &quot;John&quot;, age: 20, surname: &quot;Johnson&quot; },
  { name: &quot;Pete&quot;, age: 18, surname: &quot;Peterson&quot; },
  { name: &quot;Ann&quot;, age: 19, surname: &quot;Hathaway&quot; }
];</code>
  The usual way to do that would be:

    <code>// by name (Ann, John, Pete)
users.sort((a, b) =&gt; a.name &gt; b.name ? 1 : -1);
// by age (Pete, Ann, John)
users.sort((a, b) =&gt; a.age &gt; b.age ? 1 : -1);</code>
  Can we make it even less verbose, like this?

    <code>users.sort(byField('name'));
users.sort(byField('age'));</code>
  So, instead of writing a function, just put <code>byField(fieldName)</code>.

Write the function <code>byField</code> that can be used for that.

<button type="button">solution</button>

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let users = [
  { name: &quot;John&quot;, age: 20, surname: &quot;Johnson&quot; },
  { name: &quot;Pete&quot;, age: 18, surname: &quot;Peterson&quot; },
  { name: &quot;Ann&quot;, age: 19, surname: &quot;Hathaway&quot; }
];
function byField(field) {
  return (a, b) =&gt; a[field] &gt; b[field] ? 1 : -1;
}
users.sort(byField('name'));
users.forEach(user =&gt; alert(user.name)); // Ann, John, Pete
users.sort(byField('age'));
users.forEach(user =&gt; alert(user.name)); // Pete, Ann, John</code>
  <button type="button" title="close"></button>

<h3><a href="#army-of-functions" name="army-of-functions">Army of functions</a></h3><a href="/task/make-army" target="_blank"></a>

importance: 5

The following code creates an array of <code>shooters</code>.

Every function is meant to output its number. 
But something is wrong…

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function makeArmy() {
  let shooters = [];
  let i = 0;
  while (i &lt; 10) {
    let shooter = function() { // shooter function
alert( i ); // should show its number
    };
    shooters.push(shooter);
    i++;
  }
  return shooters;
}
let army = makeArmy();
army[0](); // the shooter number 0 shows 10
army[5](); // and number 5 also outputs 10...
// ... 
all shooters show 10 instead of their 0, 1, 2, 3...</code>
  Why all shooters show the same? Fix the code so that they work as intended.

<a href="http://plnkr.co/edit/sdw9JMeicGMnAh8aRA6D?p=preview" target="_blank" data-plunk-id="sdw9JMeicGMnAh8aRA6D">Open the sandbox with tests.</a>
<button type="button">solution</button>

Let’s examine what’s done inside <code>makeArmy</code>, and the solution will become obvious.

<li>It creates an empty array <code>shooters</code>:

    <code>let shooters = [];</code>
  </li><li>Fills it in the loop via <code>shooters.push(function...)</code>.

Every element is a function, so the resulting array looks like this:

    <code>shooters = [
  function () { alert(i); },
  function () { alert(i); },
  function () { alert(i); },
  function () { alert(i); },
  function () { alert(i); },
  function () { alert(i); },
  function () { alert(i); },
  function () { alert(i); },
  function () { alert(i); },
  function () { alert(i); }
];</code>
  </li><li>The array is returned from the function.

</li>

Then, later, the call to <code>army[5]()</code> will get the element <code>army[5]</code> from the array (it will be a function) and call it.

Now why all such functions show the same?

That’s because there’s no local variable <code>i</code> inside <code>shooter</code> functions. 
When such a function is called, it takes <code>i</code> from its outer lexical environment.

What will be the value of <code>i</code>?

If we look at the source:

    <code>function makeArmy() {
  ...
  let i = 0;
  while (i &lt; 10) {
    let shooter = function() { // shooter function
alert( i ); // should show its number
    };
    ...
  }
  ...
}</code>
  …We can see that it lives in the lexical environment associated with the current <code>makeArmy()</code> run. 
But when <code>army[5]()</code> is called, <code>makeArmy</code> has already finished its job, and <code>i</code> has the last value: <code>10</code> (the end of <code>while</code>).

As a result, all <code>shooter</code> functions get from the outer lexical envrironment the same, last value <code>i=10</code>.

The fix can be very simple:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function makeArmy() {
  let shooters = [];
  for(let i = 0; i &lt; 10; i++) {
    let shooter = function() { // shooter function
alert( i ); // should show its number
    };
    shooters.push(shooter);
  }
  return shooters;
}
let army = makeArmy();
army[0](); // 0
army[5](); // 5</code>
  Now it works correctly, because every time the code block in <code>for (..) {...}</code> is executed, a new Lexical Environment is created for it, with the corresponding value of <code>i</code>.

So, the value of <code>i</code> now lives a little bit closer. 
Not in <code>makeArmy()</code> Lexical Environment, but in the Lexical Environment that corresponds the current loop iteration. 
A <code>shooter</code> gets the value exactly from the one where it was created.

<img src="https://javascript.info/task/make-army/lexenv-makearmy.png">
Here we rewrote <code>while</code> into <code>for</code>.

Another trick could be possible, let’s see it for better understanding of the subject:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function makeArmy() {
  let shooters = [];
  let i = 0;
  while (i &lt; 10) {
    let j = i;
    let shooter = function() { // shooter function
alert( j ); // should show its number
    };
    shooters.push(shooter);
    i++;
  }
  return shooters;
}
let army = makeArmy();
army[0](); // 0
army[5](); // 5</code>
  The <code>while</code> loop, just like <code>for</code>, makes a new Lexical Environment for each run. 
So here we make sure that it gets the right value for a <code>shooter</code>.

We copy <code>let j = i</code>. 
This makes a loop body local <code>j</code> and copies the value of <code>i</code> to it. 
Primitives are copied “by value”, so we actually get a complete independent copy of <code>i</code>, belonging to the current loop iteration.

<a href="http://plnkr.co/edit/k3o1vZs45MG44WMmOuRg?p=preview" target="_blank" data-plunk-id="k3o1vZs45MG44WMmOuRg">Open the solution with tests in the sandbox.</a>
<button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/rest-parameters-spread-operator" data-tooltip="Rest parameters and spread operator">Previous lesson</a><a href="/var" data-tooltip="The old &quot;var&quot;">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Fclosure"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Fclosure"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Fclosure"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Fclosure"></a>

In the very first chapter about <a href="/variables">variables</a>, we mentioned three ways of variable declaration:

<li><code>let</code></li><li><code>const</code></li><li><code>var</code></li>

<code>let</code> and <code>const</code> behave exactly the same way in terms of Lexical Environments.

But <code>var</code> is a very different beast, that originates from very old times. 
It’s generally not used in modern scripts, but still lurks in the old ones.

If you don’t plan meeting such scripts you may even skip this chapter or postpone it, but then there’s a chance that it bites you later.

From the first sight, <code>var</code> behaves similar to <code>let</code>. 
That is, declares a variable:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function sayHi() {
  var phrase = &quot;Hello&quot;; // local variable, &quot;var&quot; instead of &quot;let&quot;
  alert(phrase); // Hello
}
sayHi();
alert(phrase); // Error, phrase is not defined</code>
  …But here are the differences.

<h2>“var” has no block scope</h2>
<code>var</code> variables are either function-wide or global, they are visible through blocks.

For instance:

    <code>if (true) {
  var test = true; // use &quot;var&quot; instead of &quot;let&quot;
}
alert(test); // true, the variable lives after if</code>
  If we used <code>let test</code> on the 2nd line, then it wouldn’t be visible to <code>alert</code>. 
But <code>var</code> ignores code blocks, so we’ve got a global <code>test</code>.

The same thing for loops: <code>var</code> cannot be block- or loop-local:

    <code>for (var i = 0; i &lt; 10; i++) {
  // ...
}
alert(i); // 10, &quot;i&quot; is visible after loop, it's a global variable</code>
  If a code block is inside a function, then <code>var</code> becomes a function-level variable:

    <code>function sayHi() {
  if (true) {
    var phrase = &quot;Hello&quot;;
  }
  alert(phrase); // works
}
sayHi();
alert(phrase); // Error: phrase is not defined</code>
  As we can see, <code>var</code> pierces through <code>if</code>, <code>for</code> or other code blocks. 
That’s because a long time ago in JavaScript blocks had no Lexical Environments. 
And <code>var</code> is a reminiscence of that.

<h2>“var” are processed at the function start</h2>
<code>var</code> declarations are processed when the function starts (or script starts for globals).

In other words, <code>var</code> variables are defined from the beginning of the function, no matter where the definition is (assuming that the definition is not in the nested function).

So this code:

    <code>function sayHi() {
  phrase = &quot;Hello&quot;;
  alert(phrase);
  var phrase;
}</code>
  …Is technically the same as this (moved <code>var phrase</code> above):

    <code>function sayHi() {
  var phrase;
  phrase = &quot;Hello&quot;;
  alert(phrase);
}</code>
  …Or even as this (remember, code blocks are ignored):

    <code>function sayHi() {
  phrase = &quot;Hello&quot;; // (*)
  if (false) {
    var phrase;
  }
  alert(phrase);
}</code>
  People also call such behavior “hoisting” (raising), because all <code>var</code> are “hoisted” (raised) to the top of the function.

So in the example above, <code>if (false)</code> branch never executes, but that doesn’t matter. 
The <code>var</code> inside it is processed in the beginning of the function, so at the moment of <code>(*)</code> the variable exists.

<strong>Declarations are hoisted, but assignments are not.</strong>

That’s better to demonstrate with an example, like this:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function sayHi() {
  alert(phrase);
  var phrase = &quot;Hello&quot;;
}
sayHi();</code>
  The line <code>var phrase = &quot;Hello&quot;</code> has two actions in it:

<li>Variable declaration <code>var</code></li><li>Variable assignment <code>=</code>.</li>

The declaration is processed at the start of function execution (“hoisted”), but the assignment always works at the place where it appears. 
So the code works essentially like this:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function sayHi() {
  var phrase; // declaration works at the start...
  alert(phrase); // undefined
  phrase = &quot;Hello&quot;; // ...assignment - when the execution reaches it.
}
sayHi();</code>
  Because all <code>var</code> declarations are processed at the function start, we can reference them at any place. 
But variables are undefined until the assignments.

In both examples above <code>alert</code> runs without an error, because the variable <code>phrase</code> exists. 
But its value is not yet assigned, so it shows <code>undefined</code>.

<h4><a name="summary" href="#summary">Summary</a4</h2>
There are two main differences of <code>var</code>:

<li>Variables have no block scope, they are visible minimum at the function level.</li><li>Variable declarations are processed at function start.</li>

There’s one more minor difference related to the global object, we’ll cover that in the next chapter.

These differences are actually a bad thing most of the time. 
First, we can’t create block-local variables. 
And hoisting just creates more space for errors. 
So, for new scripts <code>var</code> is used exceptionally rarely.

When JavaScript was created, there was an idea of a “global object” that provides all global variables and functions. 
It was planned that multiple in-browser scripts would use that single global object and share variables through it.

Since then, JavaScript greatly evolved, and that idea of linking code through global variables became much less appealing. 
In modern JavaScript, the concept of modules took its place.

But the global object still remains in the specification.

In a browser it is named “window”, for Node.JS it is “global”, for other environments it may have another name.

It does two things:

<li>Provides access to built-in functions and values, defined by the specification and the environment.
For instance, we can call <code>alert</code> directly or as a method of <code>window</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert(&quot;Hello&quot;);
// the same as
window.alert(&quot;Hello&quot;);</code>
  The same applies to other built-ins. 
E.g. 
we can use <code>window.Array</code> instead of <code>Array</code>.

</li><li>Provides access to global Function Declarations and <code>var</code> variables. 
We can read and write them using its properties, for instance:

 <!-- no-strict to move variables out of eval -->

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>var phrase = &quot;Hello&quot;;
function sayHi() {
  alert(phrase);
}
// can read from window
alert( window.phrase ); // Hello (global var)
alert( window.sayHi ); // function (global function declaration)
// can write to window (creates a new global variable)
window.test = 5;
alert(test); // 5</code>
  </li>

…But the global object does not have variables declared with <code>let/const</code>!

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = &quot;John&quot;;
alert(user); // John
alert(window.user); // undefined, don't have let
alert(&quot;user&quot; in window); // false</code>
  
The global object is not a global Environment Record
In versions of ECMAScript prior to ES-2015, there were no <code>let/const</code> variables, only <code>var</code>. 
And global object was used as a global Environment Record (wordings were a bit different, but that’s the gist).

But starting from ES-2015, these entities are split apart. 
There’s a global Lexical Environment with its Environment Record. 
And there’s a global object that provides <em>some</em> of the global variables.

As a practical difference, global <code>let/const</code> variables are definitively properties of the global Environment Record, but they do not exist in the global object.

Naturally, that’s because the idea of a global object as a way to access “all global things” comes from ancient times. 
Nowadays is not considered to be a good thing. 
Modern language features like <code>let/const</code> do not make friends with it, but old ones are still compatible.

<h2>Uses of “window”</h2>
In server-side environments like Node.JS, the <code>global</code> object is used exceptionally rarely. 
Probably it would be fair to say “never”.

In-browser <code>window</code> is sometimes used though.

Usually, it’s not a good idea to use it, but here are some examples you can meet.

<li>To access exactly the global variable if the function has the local one with the same name.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>var user = &quot;Global&quot;;
function sayHi() {
  var user = &quot;Local&quot;;
  alert(window.user); // Global
}
sayHi();</code>
  Such use is a workaround. 
Would be better to name variables differently, that won’t require use to write the code it this way. 
And please note <code>&quot;var&quot;</code> before <code>user</code>. 
The trick doesn’t work with <code>let</code> variables.

</li><li>To check if a certain global variable or a builtin exists.

For instance, we want to check whether a global function <code>XMLHttpRequest</code> exists.

We can’t write <code>if (XMLHttpRequest)</code>, because if there’s no <code>XMLHttpRequest</code>, there will be an error (variable not defined).

But we can read it from <code>window.XMLHttpRequest</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>if (window.XMLHttpRequest) {
  alert('XMLHttpRequest exists!')
}</code>
  If there is no such global function then <code>window.XMLHttpRequest</code> is just a non-existing object property. 
That’s <code>undefined</code>, no error, so it works.

We can also write the test without <code>window</code>:

    <code>if (typeof XMLHttpRequest == 'function') {
  /* is there a function XMLHttpRequest? */
}</code>
  This doesn’t use <code>window</code>, but is (theoretically) less reliable, because <code>typeof</code> may use a local XMLHttpRequest, and we want the global one.

</li><li>To take the variable from the right window. 
That’s probably the most valid use case.

A browser may open multiple windows and tabs. 
A window may also embed another one in <code>&lt;iframe&gt;</code>. 
Every browser window has its own <code>window</code> object and global variables. 
JavaScript allows windows that come from the same site (same protocol, host, port) to access variables from each other.

That use is a little bit beyond our scope for now, but it looks like:

    

      <a href="#" title="show" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>&lt;iframe src=&quot;/&quot; id=&quot;iframe&quot;&gt;&lt;/iframe&gt;
&lt;script&gt;
  alert( innerWidth ); // get innerWidth property of the current window (browser only)
  alert( Array ); // get Array of the current window (javascript core builtin)
  // when the iframe loads...
  iframe.onload = function() {
    // get width of the iframe window
    alert( iframe.contentWindow.innerWidth );
    // get the builtin Array from the iframe window
    alert( iframe.contentWindow.Array );
  };
&lt;/script&gt;</code>
  Here, first two alerts use the current window, and the latter two take variables from <code>iframe</code> window. 
Can be any variables if <code>iframe</code> originates from the same protocol/host/port.

</li>

<h2>“this” and global object</h2>
Sometimes, the value of <code>this</code> is exactly the global object. 
That’s rarely used, but some scripts rely on that.

<li>In the browser, the value of <code>this</code> in the global area is <code>window</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// outside of functions
alert( this === window ); // true</code>
  Other, non-browser environments, may use another value for <code>this</code> in such cases.

</li><li>When a function with <code>this</code> is called in non-strict mode, it gets the global object as <code>this</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// not in strict mode (!)
function f() {
  alert(this); // [object Window]
}
f(); // called without an object</code>
  By specification, <code>this</code> in this case must be the global object, even in non-browser environments like Node.JS. 
That’s for compatibility with old scripts, in strict mode <code>this</code> would be <code>undefined</code>.

</li>

As we already know, functions in JavaScript are values.

Every value in JavaScript has a type. 
What type is a function?

In JavaScript, functions are objects.

A good way to imagine functions is as callable “action objects”. 
We can not only call them, but also treat them as objects: add/remove properties, pass by reference etc.

<h2>The “name” property</h2>
Function objects contain a few useable properties.

For instance, a function’s name is accessible as the “name” property:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function sayHi() {
  alert(&quot;Hi&quot;);
}
alert(sayHi.name); // sayHi</code>
  What’s more funny, the name-assigning logic is smart. 
It also assigns the correct name to functions that are used in assignments:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let sayHi = function() {
  alert(&quot;Hi&quot;);
}
alert(sayHi.name); // sayHi (works!)</code>
  It also works if the assignment is done via a default value:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function f(sayHi = function() {}) {
  alert(sayHi.name); // sayHi (works!)
}
f();</code>
  In the specification, this feature is called a “contextual name”. 
If the function does not provide one, then in an assignment it is figured out from the context.

Object methods have names too:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  sayHi() {
    // ...
  },
  sayBye: function() {
    // ...
  }
}
alert(user.sayHi.name); // sayHi
alert(user.sayBye.name); // sayBye</code>
  There’s no magic though. 
There are cases when there’s no way to figure out the right name. 
In that case, the name property empty, like here:

    <code>// function created inside array
let arr = [function() {}];
alert( arr[0].name ); // &lt;empty string&gt;
// the engine has no way to set up the right name, so there is none</code>
  In practice, however, most functions do have a name.

<h2>The “length” property</h2>
There is another built-in property “length” that returns the number of function parameters, for instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function f1(a) {}
function f2(a, b) {}
function many(a, b, ...more) {}
alert(f1.length); // 1
alert(f2.length); // 2
alert(many.length); // 2</code>
  Here we can see that rest parameters are not counted.

The <code>length</code> property is sometimes used for introspection in functions that operate on other functions.

For instance, in the code below the <code>ask</code> function accepts a <code>question</code> to ask and an arbitrary number of <code>handler</code> functions to call.

Once a user provides their answer, the function calls the handlers. 
We can pass two kinds of handlers:

<li>A zero-argument function, which is only called when the user gives a positive answer.</li><li>A function with arguments, which is called in either case and returns an answer.</li>

The idea is that we have a simple, no-arguments handler syntax for positive cases (most frequent variant), but are able to provide universal handlers as well.

To call <code>handlers</code> the right way, we examine the <code>length</code> property:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function ask(question, ...handlers) {
  let isYes = confirm(question);
  for(let handler of handlers) {
    if (handler.length == 0) {
if (isYes) handler();
    } else {
handler(isYes);
    }
  }
}
// for positive answer, both handlers are called
// for negative answer, only the second one
ask(&quot;Question?&quot;, () =&gt; alert('You said yes'), result =&gt; alert(result));</code>
  This is a particular case of so-called <a href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)">polymorphism</a> – treating arguments differently depending on their type or, in our case depending on the <code>length</code>. 
The idea does have a use in JavaScript libraries.

<h2>Custom properties</h2>
We can also add properties of our own.

Here we add the <code>counter</code> property to track the total calls count:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function sayHi() {
  alert(&quot;Hi&quot;);
  // let's count how many times we run
  sayHi.counter++;
}
sayHi.counter = 0; // initial value
sayHi(); // Hi
sayHi(); // Hi
alert( `Called ${sayHi.counter} times` ); // Called 2 times</code>
  

A property is not a variable
A property assigned to a function like <code>sayHi.counter = 0</code> does <em>not</em> define a local variable <code>counter</code> inside it. 
In other words, a property <code>counter</code> and a variable <code>let counter</code> are two unrelated things.

We can treat a function as an object, store properties in it, but that has no effect on its execution. 
Variables never use function properties and vice versa. 
These are just parallel words.

Function properties can replace closures sometimes. 
For instance, we can rewrite the counter function example from the chapter <a href="/closure">Closure</a> to use a function property:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function makeCounter() {
  // instead of:
  // let count = 0
  function counter() {
    return counter.count++;
  };
  counter.count = 0;
  return counter;
}
let counter = makeCounter();
alert( counter() ); // 0
alert( counter() ); // 1</code>
  The <code>count</code> is now stored in the function directly, not in its outer Lexical Environment.

Is it better or worse than using a closure?

The main difference is that if the value of <code>count</code> lives in an outer variable, then external code is unable to access it. 
Only nested functions may modify it. 
And if it’s bound to a function, then such a thing is possible:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function makeCounter() {
  function counter() {
    return counter.count++;
  };
  counter.count = 0;
  return counter;
}
let counter = makeCounter();
counter.count = 10;
alert( counter() ); // 10</code>
  So the choice of implementation depends on our aims.

<h2>Named Function Expression</h2>
Named Function Expression, or NFE, is a term for Function Expressions that have a name.

For instance, let’s take an ordinary Function Expression:

    <code>let sayHi = function(who) {
  alert(`Hello, ${who}`);
};</code>
  And add a name to it:

    <code>let sayHi = function func(who) {
  alert(`Hello, ${who}`);
};</code>
  Did we achieve anything here? What’s the purpose of that additional <code>&quot;func&quot;</code> name?

First let’s note, that we still have a Function Expression. 
Adding the name <code>&quot;func&quot;</code> after <code>function</code> did not make it a Function Declaration, because it is still created as a part of an assignment expression.

Adding such a name also did not break anything.

The function is still available as <code>sayHi()</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let sayHi = function func(who) {
  alert(`Hello, ${who}`);
};
sayHi(&quot;John&quot;); // Hello, John</code>
  There are two special things about the name <code>func</code>:

<li>It allows the function to reference itself internally.</li><li>It is not visible outside of the function.</li>

For instance, the function <code>sayHi</code> below calls itself again with <code>&quot;Guest&quot;</code> if no <code>who</code> is provided:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let sayHi = function func(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
    func(&quot;Guest&quot;); // use func to re-call itself
  }
};
sayHi(); // Hello, Guest
// But this won't work:
func(); // Error, func is not defined (not visible outside of the function)</code>
  Why do we use <code>func</code>? Maybe just use <code>sayHi</code> for the nested call?

Actually, in most cases we can:

    <code>let sayHi = function(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
    sayHi(&quot;Guest&quot;);
  }
};</code>
  The problem with that code is that the value of <code>sayHi</code> may change. 
The function may go to another variable, and the code will start to give errors:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let sayHi = function(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
    sayHi(&quot;Guest&quot;); // Error: sayHi is not a function
  }
};
let welcome = sayHi;
sayHi = null;
welcome(); // Error, the nested sayHi call doesn't work any more!</code>
  That happens because the function takes <code>sayHi</code> from its outer lexical environment. 
There’s no local <code>sayHi</code>, so the outer variable is used. 
And at the moment of the call that outer <code>sayHi</code> is <code>null</code>.

The optional name which we can put into the Function Expression is meant to solve exactly these kinds of problems.

Let’s use it to fix our code:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let sayHi = function func(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
    func(&quot;Guest&quot;); // Now all fine
  }
};
let welcome = sayHi;
sayHi = null;
welcome(); // Hello, Guest (nested call works)</code>
  Now it works, because the name <code>&quot;func&quot;</code> is function-local. 
It is not taken from outside (and not visible there). 
The specification guarantees that it will always reference the current function.

The outer code still has it’s variable <code>sayHi</code> or <code>welcome</code>. 
And <code>func</code> is an “internal function name”, how the function can call itself internally.

There’s no such thing for Function Declaration
The “internal name” feature described here is only available for Function Expressions, not to Function Declarations. 
For Function Declarations, there’s just no syntax possibility to add a one more “internal” name.

Sometimes, when we need a reliable internal name, it’s the reason to rewrite a Function Declaration to Named Function Expression form.

<h4><a name="summary" href="#summary">Summary</a4</h2>
Functions are objects.

Here we covered their properties:

<li><code>name</code> – the function name. 
Exists not only when given in the function definition, but also for assignments and object properties.</li><li><code>length</code> – the number of arguments in the function definition. 
Rest parameters are not counted.</li>

If the function is declared as a Function Expression (not in the main code flow), and it carries the name, then it is called a Named Function Expression. 
The name can be used inside to reference itself, for recursive calls or such.

Also, functions may carry additional properties. 
Many well-known JavaScript libraries make great use of this feature.

They create a “main” function and attach many other “helper” functions to it. 
For instance, the <a href="https://jquery.com">jquery</a> library creates a function named <code>$</code>. 
The <a href="https://lodash.com">lodash</a> library creates a function <code>_</code>. 
And then adds <code>_.clone</code>, <code>_.keyBy</code> and other properties to (see the <a href="https://lodash.com/docs">docs</a> when you want learn more about them). 
Actually, they do it to lessen their pollution of the global space, so that a single library gives only one global variable. 
That reduces the possibility of naming conflicts.

So, a function can do a useful job by itself and also carry a bunch of other functionality in properties.

<li><code>counter()</code> should return the next number (as before).</li><li><code>counter.set(value)</code> should set the <code>count</code> to <code>value</code>.</li><li><code>counter.decrease(value)</code> should decrease the <code>count</code> by 1.</li>

See the sandbox code for the complete usage example.

P.S. 
You can use either a closure or the function property to keep the current count. 
Or write both variants.

<a href="http://plnkr.co/edit/KNXgaGgXsHDySyBhHmp5?p=preview" target="_blank" data-plunk-id="KNXgaGgXsHDySyBhHmp5">Open the sandbox with tests.</a>
<button type="button">solution</button>

The solution uses <code>count</code> in the local variable, but addition methods are written right into the <code>counter</code>. 
They share the same outer lexical environment and also can access the current <code>count</code>.

<a href="http://plnkr.co/edit/tosTNMw0flKioNx8mPHd?p=preview" target="_blank" data-plunk-id="tosTNMw0flKioNx8mPHd">Open the solution with tests in the sandbox.</a>
<button type="button" title="close"></button>

<h3><a href="#sum-with-an-arbitrary-amount-of-brackets" name="sum-with-an-arbitrary-amount-of-brackets">Sum with an arbitrary amount of brackets</a></h3><a href="/task/sum-many-brackets" target="_blank"></a>

importance: 2

Write function <code>sum</code> that would work like this:

    <code>sum(1)(2) == 3; // 1 + 2
sum(1)(2)(3) == 6; // 1 + 2 + 3
sum(5)(-1)(2) == 6
sum(6)(-1)(-2)(-3) == 0
sum(0)(1)(2)(3)(4)(5) == 15</code>
  P.S. 
Hint: you may need to setup custom object to primitive conversion for your function.

<button type="button">solution</button>

<li>For the whole thing to work <em>anyhow</em>, the result of <code>sum</code> must be function.</li><li>That function must keep in memory the current value between calls.</li><li>According to the task, the function must become the number when used in <code>==</code>. 
Functions are objects, so the conversion happens as described in the chapter <a href="/object-toprimitive">Object to primitive conversion</a>, and we can provide our own method that returns the number.</li>

Now the code:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function sum(a) {
  let currentSum = a;
  function f(b) {
    currentSum += b;
    return f;
  }
  f.toString = function() {
    return currentSum;
  };
  return f;
}
alert( sum(1)(2) ); // 3
alert( sum(5)(-1)(2) ); // 6
alert( sum(6)(-1)(-2)(-3) ); // 0
alert( sum(0)(1)(2)(3)(4)(5) ); // 15</code>
  Please note that the <code>sum</code> function actually works only once. 
It returns function <code>f</code>.

Then, on each subsequent call, <code>f</code> adds its parameter to the sum <code>currentSum</code>, and returns itself.

<strong>There is no recursion in the last line of <code>f</code>.</strong>

Here is what recursion looks like:

    <code>function f(b) {
  currentSum += b;
  return f(); // &lt;-- recursive call
}</code>
  And in our case, we just return the function, without calling it:

    <code>function f(b) {
  currentSum += b;
  return f; // &lt;-- does not call itself, returns itself
}</code>
  This <code>f</code> will be used in the next call, again return itself, so many times as needed. 
Then, when used as a number or a string – the <code>toString</code> returns the <code>currentSum</code>. 
We could also use <code>Symbol.toPrimitive</code> or <code>valueOf</code> here for the conversion.

<button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/global-object" data-tooltip="Global object">Previous lesson</a><a href="/new-function" data-tooltip="The &quot;new Function&quot; syntax">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Ffunction-object"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Ffunction-object"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Ffunction-object"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Ffunction-object"></a>

There’s one more way to create a function. 
It’s rarely used, but sometimes there’s no alternative.

<h2>Syntax</h2>
The syntax for creating a function:

    <code>let func = new Function ([arg1[, arg2[, ...argN]],] functionBody)</code>
  In other words, function parameters (or, more precisely, names for them) go first, and the body is last. 
All arguments are strings.

It’s easier to understand by looking at an example. 
Here’s a function with two arguments:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let sum = new Function('a', 'b', 'return a + b');
alert( sum(1, 2) ); // 3</code>
  If there are no arguments, then there’s only a single argument, the function body:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let sayHi = new Function('alert(&quot;Hello&quot;)');
sayHi(); // Hello</code>
  The major difference from other ways we’ve seen is that the function is created literally from a string, that is passed at run time.

All previous declarations required us, programmers, to write the function code in the script.

But <code>new Function</code> allows to turn any string into a function. 
For example, we can receive a new function from a server and then execute it:

    <code>let str = ... 
receive the code from a server dynamically ...
let func = new Function(str);
func();</code>
  It is used in very specific cases, like when we receive code from a server, or to dynamically compile a function from a template. 
The need for that usually arises at advanced stages of development.

<h2>Closure</h2>
Usually, a function remembers where it was born in the special property <code>[[Environment]]</code>. 
It references the Lexical Environment from where it’s created.

But when a function is created using <code>new Function</code>, its <code>[[Environment]]</code> references not the current Lexical Environment, but instead the global one.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function getFunc() {
  let value = &quot;test&quot;;
  let func = new Function('alert(value)');
  return func;
}
getFunc()(); // error: value is not defined</code>
  Compare it with the regular behavior:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function getFunc() {
  let value = &quot;test&quot;;
  let func = function() { alert(value); };
  return func;
}
getFunc()(); // &quot;test&quot;, from the Lexical Environment of getFunc</code>
  This special feature of <code>new Function</code> looks strange, but appears very useful in practice.

Imagine that we must create a function from a string. 
The code of that function is not known at the time of writing the script (that’s why we don’t use regular functions), but will be known in the process of execution. 
We may receive it from the server or from another source.

Our new function needs to interact with the main script.

Perhaps we want it to be able to access outer local variables?

The problem is that before JavaScript is published to production, it’s compressed using a <em>minifier</em> – a special program that shrinks code by removing extra comments, spaces and – what’s important, renames local variables into shorter ones.

For instance, if a function has <code>let userName</code>, minifier replaces it <code>let a</code> (or another letter if this one is occupied), and does it everywhere. 
That’s usually a safe thing to do, because the variable is local, nothing outside the function can access it. 
And inside the function, minifier replaces every mention of it. 
Minifiers are smart, they analyze the code structure, so they don’t break anything. 
They’re not just a dumb find-and-replace.

But, if <code>new Function</code> could access outer variables, then it would be unable to find <code>userName</code>, since this is passed in as a string <em>after</em> the code is minified.

<strong>Even if we could access outer lexical environment in <code>new Function</code>, we would have problems with minifiers.</strong>

The “special feature” of <code>new Function</code> saves us from mistakes.

And it enforces better code. 
If we need to pass something to a function created by <code>new Function</code>, we should pass it explicitly as an argument.

Our “sum” function actually does that right:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let sum = new Function('a', 'b', 'return a + b');
let a = 1, b = 2;
// outer values are passed as arguments
alert( sum(a, b) ); // 3</code>
  <h4><a name="summary" href="#summary">Summary</a4</h2>
The syntax:

    <code>let func = new Function(arg1, arg2, ..., body);</code>
  For historical reasons, arguments can also be given as a comma-separated list.

These three mean the same:

    <code>new Function('a', 'b', 'return a + b'); // basic syntax
new Function('a,b', 'return a + b'); // comma-separated
new Function('a , b', 'return a + b'); // comma-separated with spaces</code>
  Functions created with <code>new Function</code>, have <code>[[Environment]]</code> referencing the global Lexical Environment, not the outer one. 
Hence, they cannot use outer variables. 
But that’s actually good, because it saves us from errors. 
Passing parameters explicitly is a much better method architecturally and causes no problems with minifiers.

We may decide to execute a function not right now, but at a certain time later. 
That’s called “scheduling a call”.

There are two methods for it:

<li><code>setTimeout</code> allows to run a function once after the interval of time.</li><li><code>setInterval</code> allows to run a function regularly with the interval between the runs.</li>

These methods are not a part of JavaScript specification. 
But most environments have the internal scheduler and provide these methods. 
In particular, they are supported in all browsers and Node.JS.

<h2>setTimeout</h2>
The syntax:

    <code>let timerId = setTimeout(func|code, delay[, arg1, arg2...])</code>
  Parameters:

<dl>
<dt><code>func|code</code></dt>
<dd>Function or a string of code to execute.
Usually, that’s a function. 
For historical reasons, a string of code can be passed, but that’s not recommended.</dd>
<dt><code>delay</code></dt>
<dd>The delay before run, in milliseconds (1000 ms = 1 second).</dd>
<dt><code>arg1</code>, <code>arg2</code>…</dt>
<dd>Arguments for the function (not supported in IE9-)</dd>
</dl>

For instance, this code calls <code>sayHi()</code> after one second:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function sayHi() {
  alert('Hello');
}
setTimeout(sayHi, 1000);</code>
  With arguments:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function sayHi(phrase, who) {
  alert( phrase + ', ' + who );
}
setTimeout(sayHi, 1000, &quot;Hello&quot;, &quot;John&quot;); // Hello, John</code>
  If the first argument is a string, then JavaScript creates a function from it.

So, this will also work:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>setTimeout(&quot;alert('Hello')&quot;, 1000);</code>
  But using strings is not recommended, use functions instead of them, like this:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>setTimeout(() =&gt; alert('Hello'), 1000);</code>
  
Pass a function, but don’t run it
Novice developers sometimes make a mistake by adding brackets <code>()</code> after the function:

    <code>// wrong!
setTimeout(sayHi(), 1000);</code>
  That doesn’t work, because <code>setTimeout</code> expects a reference to function. 
And here <code>sayHi()</code> runs the function, and the <em>result of its execution</em> is passed to <code>setTimeout</code>. 
In our case the result of <code>sayHi()</code> is <code>undefined</code> (the function returns nothing), so nothing is scheduled.

<h3><a name="canceling-with-cleartimeout" href="#canceling-with-cleartimeout">Canceling with clearTimeout</a></h3>
A call to <code>setTimeout</code> returns a “timer identifier” <code>timerId</code> that we can use to cancel the execution.

The syntax to cancel:

    <code>let timerId = setTimeout(...);
clearTimeout(timerId);</code>
  In the code below, we schedule the function and then cancel it (changed our mind). 
As a result, nothing happens:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let timerId = setTimeout(() =&gt; alert(&quot;never happens&quot;), 1000);
alert(timerId); // timer identifier
clearTimeout(timerId);
alert(timerId); // same identifier (doesn't become null after canceling)</code>
  As we can see from <code>alert</code> output, in a browser the timer identifier is a number. 
In other environments, this can be something else. 
For instance, Node.JS returns a timer object with additional methods.

Again, there is no universal specification for these methods, so that’s fine.

For browsers, timers are described in the <a href="https://www.w3.org/TR/html5/webappapis.html#timers">timers section</a> of HTML5 standard.

<h2>setInterval</h2>
The <code>setInterval</code> method has the same syntax as <code>setTimeout</code>:

    <code>let timerId = setInterval(func|code, delay[, arg1, arg2...])</code>
  All arguments have the same meaning. 
But unlike <code>setTimeout</code> it runs the function not only once, but regularly after the given interval of time.

To stop further calls, we should call <code>clearInterval(timerId)</code>.

The following example will show the message every 2 seconds. 
After 5 seconds, the output is stopped:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// repeat with the interval of 2 seconds
let timerId = setInterval(() =&gt; alert('tick'), 2000);
// after 5 seconds stop
setTimeout(() =&gt; { clearInterval(timerId); alert('stop'); }, 5000);</code>
  
Modal windows freeze time in Chrome/Opera/Safari
In browsers IE and Firefox the internal timer continues “ticking” while showing <code>alert/confirm/prompt</code>, but in Chrome, Opera and Safari the internal timer becomes “frozen”.

So if you run the code above and don’t dismiss the <code>alert</code> window for some time, then in Firefox/IE next <code>alert</code> will be shown immediately as you do it (2 seconds passed from the previous invocation), and in Chrome/Opera/Safari – after 2 more seconds (timer did not tick during the <code>alert</code>).

<h2>Recursive setTimeout</h2>
There are two ways of running something regularly.

One is <code>setInterval</code>. 
The other one is a recursive <code>setTimeout</code>, like this:

    <code>/** instead of:
let timerId = setInterval(() =&gt; alert('tick'), 2000);
*/
let timerId = setTimeout(function tick() {
  alert('tick');
  timerId = setTimeout(tick, 2000); // (*)
}, 2000);</code>
  The <code>setTimeout</code> above schedules the next call right at the end of the current one <code>(*)</code>.

The recursive <code>setTimeout</code> is a more flexible method than <code>setInterval</code>. 
This way the next call may be scheduled differently, depending on the results of the current one.

For instance, we need to write a service that sends a request to the server every 5 seconds asking for data, but in case the server is overloaded, it should increase the interval to 10, 20, 40 seconds…

Here’s the pseudocode:

    <code>let delay = 5000;
let timerId = setTimeout(function request() {
  ...send request...
  if (request failed due to server overload) {
    // increase the interval to the next run
    delay *= 2;
  }
  timerId = setTimeout(request, delay);
}, delay);</code>
  And if we regularly have CPU-hungry tasks, then we can measure the time taken by the execution and plan the next call sooner or later.

<strong>Recursive <code>setTimeout</code> guarantees a delay between the executions, <code>setInterval</code> – does not.</strong>

Let’s compare two code fragments. 
The first one uses <code>setInterval</code>:

    <code>let i = 1;
setInterval(function() {
  func(i);
}, 100);</code>
  The second one uses recursive <code>setTimeout</code>:

    <code>let i = 1;
setTimeout(function run() {
  func(i);
  setTimeout(run, 100);
}, 100);</code>
  For <code>setInterval</code> the internal scheduler will run <code>func(i)</code> every 100ms:

<img src="https://javascript.info/article/settimeout-setinterval/setinterval-interval.png">
Did you notice?

<strong>The real delay between <code>func</code> calls for <code>setInterval</code> is less than in the code!</strong>

That’s normal, because the time taken by <code>func</code>'s execution “consumes” a part of the interval.

It is possible that <code>func</code>'s execution turns out to be longer than we expected and takes more than 100ms.

In this case the engine waits for <code>func</code> to complete, then checks the scheduler and if the time is up, runs it again <em>immediately</em>.

In the edge case, if the function always executes longer than <code>delay</code> ms, then the calls will happen without a pause at all.

And here is the picture for the recursive <code>setTimeout</code>:

<img src="https://javascript.info/article/settimeout-setinterval/settimeout-interval.png">
<strong>The recursive <code>setTimeout</code> guarantees the fixed delay (here 100ms).</strong>

That’s because a new call is planned at the end of the previous one.

Garbage collection
When a function is passed in <code>setInterval/setTimeout</code>, an internal reference is created to it and saved in the scheduler. 
It prevents the function from being garbage collected, even if there are no other references to it.

    <code>// the function stays in memory until the scheduler calls it
setTimeout(function() {...}, 100);</code>
  For <code>setInterval</code> the function stays in memory until <code>clearInterval</code> is called.

There’s a side-effect. 
A function references the outer lexical environment, so, while it lives, outer variables live too. 
They may take much more memory than the function itself. 
So when we don’t need the scheduled function anymore, it’s better to cancel it, even if it’s very small.

<h2>setTimeout(…,0)</h2>
There’s a special use case: <code>setTimeout(func, 0)</code>.

This schedules the execution of <code>func</code> as soon as possible. 
But scheduler will invoke it only after the current code is complete.

So the function is scheduled to run “right after” the current code. 
In other words, <em>asynchronously</em>.

For instance, this outputs “Hello”, then immediately “World”:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>setTimeout(() =&gt; alert(&quot;World&quot;), 0);
alert(&quot;Hello&quot;);</code>
  The first line “puts the call into calendar after 0ms”. 
But the scheduler will only “check the calendar” after the current code is complete, so <code>&quot;Hello&quot;</code> is first, and <code>&quot;World&quot;</code> – after it.

<h3><a name="splitting-cpu-hungry-tasks" href="#splitting-cpu-hungry-tasks">Splitting CPU-hungry tasks</a></h3>
There’s a trick to split CPU-hungry tasks using <code>setTimeout</code>.

For instance, a syntax-highlighting script (used to colorize code examples on this page) is quite CPU-heavy. 
To highlight the code, it performs the analysis, creates many colored elements, adds them to the document – for a big text that takes a lot. 
It may even cause the browser to “hang”, which is unacceptable.

So we can split the long text into pieces. 
First 100 lines, then plan another 100 lines using <code>setTimeout(...,0)</code>, and so on.

For clarity, let’s take a simpler example for consideration. 
We have a function to count from <code>1</code> to <code>1000000000</code>.

If you run it, the CPU will hang. 
For server-side JS that’s clearly noticeable, and if you are running it in-browser, then try to click other buttons on the page – you’ll see that whole JavaScript actually is paused, no other actions work until it finishes.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let i = 0;
let start = Date.now();
function count() {
  // do a heavy job
  for (let j = 0; j &lt; 1e9; j++) {
    i++;
  }
  alert(&quot;Done in &quot; + (Date.now() - start) + 'ms');
}
count();</code>
  The browser may even show “the script takes too long” warning (but hopefully it won’t, because the number is not very big).

Let’s split the job using the nested <code>setTimeout</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let i = 0;
let start = Date.now();
function count() {
  // do a piece of the heavy job (*)
  do {
    i++;
  } while (i % 1e6 != 0);
  if (i == 1e9) {
    alert(&quot;Done in &quot; + (Date.now() - start) + 'ms');
  } else {
    setTimeout(count, 0); // schedule the new call (**)
  }
}
count();</code>
  Now the browser UI is fully functional during the “counting” process.

We do a part of the job <code>(*)</code>:

<li>First run: <code>i=1...1000000</code>.</li><li>Second run: <code>i=1000001..2000000</code>.</li><li>…and so on, the <code>while</code> checks if <code>i</code> is evenly divided by <code>1000000</code>.</li>

Then the next call is scheduled in <code>(*)</code> if we’re not done yet.

Pauses between <code>count</code> executions provide just enough “breath” for the JavaScript engine to do something else, to react to other user actions.

The notable thing is that both variants – with and without splitting the job by <code>setTimeout</code> – are comparable in speed. 
There’s no much difference in the overall counting time.

To make them closer, let’s make an improvement.

We’ll move the scheduling in the beginning of the <code>count()</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let i = 0;
let start = Date.now();
function count() {
  // move the scheduling at the beginning
  if (i &lt; 1e9 - 1e6) {
    setTimeout(count, 0); // schedule the new call
  }
  do {
    i++;
  } while (i % 1e6 != 0);
  if (i == 1e9) {
    alert(&quot;Done in &quot; + (Date.now() - start) + 'ms');
  }
}
count();</code>
  Now when we start to <code>count()</code> and know that we’ll need to <code>count()</code> more, we schedule that immediately, before doing the job.

If you run it, it’s easy to notice that it takes significantly less time.

Minimal delay of nested timers in-browser
In the browser, there’s a limitation of how often nested timers can run. 
The <a href="https://www.w3.org/TR/html5/webappapis.html#timers">HTML5 standard</a> says: “after five nested timers, the interval is forced to be at least four milliseconds.”.

Let’s demonstrate what it means with the example below. 
The <code>setTimeout</code> call in it re-schedules itself after <code>0ms</code>. 
Each call remembers the real time from the previous one in the <code>times</code> array. 
What do the real delays look like? Let’s see:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let start = Date.now();
let times = [];
setTimeout(function run() {
  times.push(Date.now() - start); // remember delay from the previous call
  if (start + 100 &lt; Date.now()) alert(times); // show the delays after 100ms
  else setTimeout(run, 0); // else re-schedule
}, 0);
// an example of the output:
// 1,1,1,1,9,15,20,24,30,35,40,45,50,55,59,64,70,75,80,85,90,95,100</code>
  First timers run immediately (just as written in the spec), and then the delay comes into play and we see <code>9, 15, 20, 24...</code>.

That limitation comes from ancient times and many scripts rely on it, so it exists for historical reasons.

For server-side JavaScript, that limitation does not exist, and there exist other ways to schedule an immediate asynchronous job, like <a href="https://nodejs.org/api/process.html">process.nextTick</a> and <a href="https://nodejs.org/api/timers.html">setImmediate</a> for Node.JS. 
So the notion is browser-specific only.

<h3><a name="allowing-the-browser-to-render" href="#allowing-the-browser-to-render">Allowing the browser to render</a></h3>
Another benefit for in-browser scripts is that they can show a progress bar or something to the user. 
That’s because the browser usually does all “repainting” after the script is complete.

So if we do a single huge function then even if it changes something, the changes are not reflected in the document till it finishes.

Here’s the demo:

    

      <a href="#" title="show" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>&lt;div id=&quot;progress&quot;&gt;&lt;/div&gt;
&lt;script&gt;
  let i = 0;
  function count() {
    for (let j = 0; j &lt; 1e6; j++) {
i++;
// put the current i into the &lt;div&gt;
// (we'll talk more about innerHTML in the specific chapter, should be obvious here)
progress.innerHTML = i;
    }
  }
  count();
&lt;/script&gt;</code>
  If you run it, the changes to <code>i</code> will show up after the whole count finishes.

And if we use <code>setTimeout</code> to split it into pieces then changes are applied in-between the runs, so this looks better:

    

      <a href="#" title="show" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>&lt;div id=&quot;progress&quot;&gt;&lt;/div&gt;
&lt;script&gt;
  let i = 0;
  function count() {
    // do a piece of the heavy job (*)
    do {
i++;
progress.innerHTML = i;
    } while (i % 1e3 != 0);
    if (i &lt; 1e9) {
setTimeout(count, 0);
    }
  }
  count();
&lt;/script&gt;</code>
  Now the <code>&lt;div&gt;</code> shows increasing values of <code>i</code>.

<h4><a name="summary" href="#summary">Summary</a></h4><li>Methods <code>setInterval(func, delay, ...args)</code> and <code>setTimeout(func, delay, ...args)</code> allow to run the <code>func</code> regularly/once after <code>delay</code> milliseconds.</li><li>To cancel the execution, we should call <code>clearInterval/clearTimeout</code> with the value returned by <code>setInterval/setTimeout</code>.</li><li>Nested <code>setTimeout</code> calls is a more flexible alternative to <code>setInterval</code>. 
Also they can guarantee the minimal time <em>between</em> the executions.</li><li>Zero-timeout scheduling <code>setTimeout(...,0)</code> is used to schedule the call “as soon as possible, but after the current code is complete”.</li>

Some use cases of <code>setTimeout(...,0)</code>:

<li>To split CPU-hungry tasks into pieces, so that the script doesn’t “hang”</li><li>To let the browser do something else while the process is going on (paint the progress bar).</li>

Please note that all scheduling methods do not <em>guarantee</em> the exact delay. 
We should not rely on that in the scheduled code.

For example, the in-browser timer may slow down for a lot of reasons:

<li>The CPU is overloaded.</li><li>The browser tab is in the background mode.</li><li>The laptop is on battery.</li>

All that may increase the minimal timer resolution (the minimal delay) to 300ms or even 1000ms depending on the browser and settings.

Make two variants of the solution.

<li>Using <code>setInterval</code>.</li><li>Using recursive <code>setTimeout</code>.</li>

<button type="button">solution</button>

Using <code>setInterval</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function printNumbers(from, to) {
  let current = from;
  let timerId = setInterval(function() {
    alert(current);
    if (current == to) {
clearInterval(timerId);
    }
    current++;
  }, 1000);
}
// usage:
printNumbers(5, 10);</code>
  Using recursive <code>setTimeout</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function printNumbers(from, to) {
  let current = from;
  setTimeout(function go() {
    alert(current);
    if (current &lt; to) {
setTimeout(go, 1000);
    }
    current++;
  }, 1000);
}
// usage:
printNumbers(5, 10);</code>
  Note that in both solutions, there is an initial delay before the first output. 
Sometimes we need to add a line to make the first output immediately, that’s easy to do.

<button type="button" title="close"></button>

<h3><a href="#rewrite-settimeout-with-setinterval" name="rewrite-settimeout-with-setinterval">Rewrite setTimeout with setInterval</a></h3><a href="/task/rewrite-settimeout" target="_blank"></a>

importance: 4

Here’s the function that uses nested <code>setTimeout</code> to split a job into pieces.

Rewrite it to <code>setInterval</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let i = 0;
let start = Date.now();
function count() {
  if (i == 1000000000) {
    alert(&quot;Done in &quot; + (Date.now() - start) + 'ms');
  } else {
    setTimeout(count, 0);
  }
  // a piece of heavy job
  for(let j = 0; j &lt; 1000000; j++) {
    i++;
  }
}
count();</code>
  <button type="button">solution</button>

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let i = 0;
let start = Date.now();
let timer = setInterval(count, 0);
function count() {
  for(let j = 0; j &lt; 1000000; j++) {
    i++;
  }
  if (i == 1000000000) {
    alert(&quot;Done in &quot; + (Date.now() - start) + 'ms');
    clearInterval(timer);
  }
}</code>
  <button type="button" title="close"></button>

<h3><a href="#what-will-settimeout-show" name="what-will-settimeout-show">What will setTimeout show?</a></h3><a href="/task/settimeout-result" target="_blank"></a>

importance: 5

In the code below there’s a <code>setTimeout</code> call scheduled, then a heavy calculation is run, that takes more than 100ms to finish.

When will the scheduled function run?

<li>After the loop.</li><li>Before the loop.</li><li>In the beginning of the loop.</li>

What is <code>alert</code> going to show?

    <code>let i = 0;
setTimeout(() =&gt; alert(i), 100); // ?
// assume that the time to execute this function is &gt;100ms
for(let j = 0; j &lt; 100000000; j++) {
  i++;
}</code>
  <button type="button">solution</button>

Any <code>setTimeout</code> will run only after the current code has finished.

The <code>i</code> will be the last one: <code>100000000</code>.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let i = 0;
setTimeout(() =&gt; alert(i), 100); // 100000000
// assume that the time to execute this function is &gt;100ms
for(let j = 0; j &lt; 100000000; j++) {
  i++;
}</code>
  <button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/new-function" data-tooltip="The &quot;new Function&quot; syntax">Previous lesson</a><a href="/call-apply-decorators" data-tooltip="Decorators and forwarding, call/apply">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Fsettimeout-setinterval"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Fsettimeout-setinterval"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Fsettimeout-setinterval"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Fsettimeout-setinterval"></a>

JavaScript gives exceptional flexibility when dealing with functions. 
They can be passed around, used as objects, and now we’ll see how to <em>forward</em> calls between them and <em>decorate</em> them.

<h2>Transparent caching</h2>
Let’s say we have a function <code>slow(x)</code> which is CPU-heavy, but its results are stable. 
In other words, for the same <code>x</code> it always returns the same result.

If the function is called often, we may want to cache (remember) the results for different <code>x</code> to avoid spending extra-time on recalculations.

But instead of adding that functionality into <code>slow()</code> we’ll create a wrapper. 
As we’ll see, there are many benefits of doing so.

Here’s the code, and explanations follow:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function slow(x) {
  // there can be a heavy CPU-intensive job here
  alert(`Called with ${x}`);
  return x;
}
function cachingDecorator(func) {
  let cache = new Map();
  return function(x) {
    if (cache.has(x)) { // if the result is in the map
return cache.get(x); // return it
    }
    let result = func(x); // otherwise call func
    cache.set(x, result); // and cache (remember) the result
    return result;
  };
}
slow = cachingDecorator(slow);
alert( slow(1) ); // slow(1) is cached
alert( &quot;Again: &quot; + slow(1) ); // the same
alert( slow(2) ); // slow(2) is cached
alert( &quot;Again: &quot; + slow(2) ); // the same as the previous line</code>
  In the code above <code>cachingDecorator</code> is a <em>decorator</em>: a special function that takes another function and alters its behavior.

The idea is that we can call <code>cachingDecorator</code> for any function, and it will return the caching wrapper. 
That’s great, because we can have many functions that could use such a feature, and all we need to do is to apply <code>cachingDecorator</code> to them.

By separating caching from the main function code we also keep the main code simpler.

Now let’s get into details of how it works.

The result of <code>cachingDecorator(func)</code> is a “wrapper”: <code>function(x)</code> that “wraps” the call of <code>func(x)</code> into caching logic:

<img src="https://javascript.info/article/call-apply-decorators/decorator-makecaching-wrapper.png">
As we can see, the wrapper returns the result of <code>func(x)</code> “as is”. 
From an outside code, the wrapped <code>slow</code> function still does the same. 
It just got a caching aspect added to its behavior.

To summarize, there are several benefits of using a separate <code>cachingDecorator</code> instead of altering the code of <code>slow</code> itself:

<li>The <code>cachingDecorator</code> is reusable. 
We can apply it to another function.</li><li>The caching logic is separate, it did not increase the complexity of <code>slow</code> itself (if there were any).</li><li>We can combine multiple decorators if needed (other decorators will follow).</li>

<h2>Using “func.call” for the context</h2>
The caching decorator mentioned above is not suited to work with object methods.

For instance, in the code below <code>worker.slow()</code> stops working after the decoration:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// we'll make worker.slow caching
let worker = {
  someMethod() {
    return 1;
  },
  slow(x) {
    // actually, there can be a scary CPU-heavy task here
    alert(&quot;Called with &quot; + x);
    return x * this.someMethod(); // (*)
  }
};
// same code as before
function cachingDecorator(func) {
  let cache = new Map();
  return function(x) {
    if (cache.has(x)) {
return cache.get(x);
    }
    let result = func(x); // (**)
    cache.set(x, result);
    return result;
  };
}
alert( worker.slow(1) ); // the original method works
worker.slow = cachingDecorator(worker.slow); // now make it caching
alert( worker.slow(2) ); // Whoops! Error: Cannot read property 'someMethod' of undefined</code>
  The error occurs in the line <code>(*)</code> that tries to access <code>this.someMethod</code> and fails. 
Can you see why?

The reason is that the wrapper calls the original function as <code>func(x)</code> in the line <code>(**)</code>. 
And, when called like that, the function gets <code>this = undefined</code>.

We would observe a similar symptom if we tried to run:

    <code>let func = worker.slow;
func(2);</code>
  So, the wrapper passes the call to the original method, but without the context <code>this</code>. 
Hence the error.

Let’s fix it.

There’s a special built-in function method <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call">func.call(context, …args)</a> that allows to call a function explicitly setting <code>this</code>.

The syntax is:

    <code>func.call(context, arg1, arg2, ...)</code>
  It runs <code>func</code> providing the first argument as <code>this</code>, and the next as the arguments.

To put it simply, these two calls do almost the same:

    <code>func(1, 2, 3);
func.call(obj, 1, 2, 3)</code>
  They both call <code>func</code> with arguments <code>1</code>, <code>2</code> and <code>3</code>. 
The only difference is that <code>func.call</code> also sets <code>this</code> to <code>obj</code>.

As an example, in the code below we call <code>sayHi</code> in the context of different objects: <code>sayHi.call(user)</code> runs <code>sayHi</code> providing <code>this=user</code>, and the next line sets <code>this=admin</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function sayHi() {
  alert(this.name);
}
let user = { name: &quot;John&quot; };
let admin = { name: &quot;Admin&quot; };
// use call to pass different objects as &quot;this&quot;
sayHi.call( user ); // this = John
sayHi.call( admin ); // this = Admin</code>
  And here we use <code>call</code> to call <code>say</code> with the given context and phrase:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function say(phrase) {
  alert(this.name + ': ' + phrase);
}
let user = { name: &quot;John&quot; };
// user becomes this, and &quot;Hello&quot; becomes the first argument
say.call( user, &quot;Hello&quot; ); // John: Hello</code>
  In our case, we can use <code>call</code> in the wrapper to pass the context to the original function:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let worker = {
  someMethod() {
    return 1;
  },
  slow(x) {
    alert(&quot;Called with &quot; + x);
    return x * this.someMethod(); // (*)
  }
};
function cachingDecorator(func) {
  let cache = new Map();
  return function(x) {
    if (cache.has(x)) {
return cache.get(x);
    }
    let result = func.call(this, x); // &quot;this&quot; is passed correctly now
    cache.set(x, result);
    return result;
  };
}
worker.slow = cachingDecorator(worker.slow); // now make it caching
alert( worker.slow(2) ); // works
alert( worker.slow(2) ); // works, doesn't call the original (cached)</code>
  Now everything is fine.

To make it all clear, let’s see more deeply how <code>this</code> is passed along:

<li>After the decoration <code>worker.slow</code> is now the wrapper <code>function (x) { ... 
}</code>.</li><li>So when <code>worker.slow(2)</code> is executed, the wrapper gets <code>2</code> as an argument and <code>this=worker</code> (it’s the object before dot).</li><li>Inside the wrapper, assuming the result is not yet cached, <code>func.call(this, x)</code> passes the current <code>this</code> (<code>=worker</code>) and the current argument (<code>=2</code>) to the original method.</li>

<h2>Going multi-argument with “func.apply”</h2>
Now let’s make <code>cachingDecorator</code> even more universal. 
Till now it was working only with single-argument functions.

Now how to cache the multi-argument <code>worker.slow</code> method?

    <code>let worker = {
  slow(min, max) {
    return min + max; // scary CPU-hogger is assumed
  }
};
// should remember same-argument calls
worker.slow = cachingDecorator(worker.slow);</code>
  We have two tasks to solve here.

First is how to use both arguments <code>min</code> and <code>max</code> for the key in <code>cache</code> map. 
Previously, for a single argument <code>x</code> we could just <code>cache.set(x, result)</code> to save the result and <code>cache.get(x)</code> to retrieve it. 
But now we need to remember the result for a <em>combination of arguments</em> <code>(min,max)</code>. 
The native <code>Map</code> takes single value only as the key.

There are many solutions possible:

<li>Implement a new (or use a third-party) map-like data structure that is more versatile and allows multi-keys.</li><li>Use nested maps: <code>cache.set(min)</code> will be a <code>Map</code> that stores the pair <code>(max, result)</code>. 
So we can get <code>result</code> as <code>cache.get(min).get(max)</code>.</li><li>Join two values into one. 
In our particular case we can just use a string <code>&quot;min,max&quot;</code> as the <code>Map</code> key. 
For flexibility, we can allow to provide a <em>hashing function</em> for the decorator, that knows how to make one value from many.</li>

For many practical applications, the 3rd variant is good enough, so we’ll stick to it.

The second task to solve is how to pass many arguments to <code>func</code>. 
Currently, the wrapper <code>function(x)</code> assumes a single argument, and <code>func.call(this, x)</code> passes it.

Here we can use another built-in method <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">func.apply</a>.

The syntax is:

    <code>func.apply(context, args)</code>
  It runs the <code>func</code> setting <code>this=context</code> and using an array-like object <code>args</code> as the list of arguments.

For instance, these two calls are almost the same:

    <code>func(1, 2, 3);
func.apply(context, [1, 2, 3])</code>
  Both run <code>func</code> giving it arguments <code>1,2,3</code>. 
But <code>apply</code> also sets <code>this=context</code>.

For instance, here <code>say</code> is called with <code>this=user</code> and <code>messageData</code> as a list of arguments:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function say(time, phrase) {
  alert(`[${time}] ${this.name}: ${phrase}`);
}
let user = { name: &quot;John&quot; };
let messageData = ['10:00', 'Hello']; // become time and phrase
// user becomes this, messageData is passed as a list of arguments (time, phrase)
say.apply(user, messageData); // [10:00] John: Hello (this=user)</code>
  The only syntax difference between <code>call</code> and <code>apply</code> is that <code>call</code> expects a list of arguments, while <code>apply</code> takes an array-like object with them.

We already know the spread operator <code>...</code> from the chapter <a href="/rest-parameters-spread-operator">Rest parameters and spread operator</a> that can pass an array (or any iterable) as a list of arguments. 
So if we use it with <code>call</code>, we can achieve almost the same as <code>apply</code>.

These two calls are almost equivalent:

    <code>let args = [1, 2, 3];
func.call(context, ...args); // pass an array as list with spread operator
func.apply(context, args);   // is same as using apply</code>
  If we look more closely, there’s a minor difference between such uses of <code>call</code> and <code>apply</code>.

<li>The spread operator <code>...</code> allows to pass <em>iterable</em> <code>args</code> as the list to <code>call</code>.</li><li>The <code>apply</code> accepts only <em>array-like</em> <code>args</code>.</li>

So, these calls complement each other. 
Where we expect an iterable, <code>call</code> works, where we expect an array-like, <code>apply</code> works.

And if <code>args</code> is both iterable and array-like, like a real array, then we technically could use any of them, but <code>apply</code> will probably be faster, because it’s a single operation. 
Most JavaScript engines internally optimize is better than a pair <code>call + spread</code>.

One of the most important uses of <code>apply</code> is passing the call to another function, like this:

    <code>let wrapper = function() {
  return anotherFunction.apply(this, arguments);
};</code>
  That’s called <em>call forwarding</em>. 
The <code>wrapper</code> passes everything it gets: the context <code>this</code> and arguments to <code>anotherFunction</code> and returns back its result.

When an external code calls such <code>wrapper</code>, it is indistinguishable from the call of the original function.

Now let’s bake it all into the more powerful <code>cachingDecorator</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let worker = {
  slow(min, max) {
    alert(`Called with ${min},${max}`);
    return min + max;
  }
};
function cachingDecorator(func, hash) {
  let cache = new Map();
  return function() {
    let key = hash(arguments); // (*)
    if (cache.has(key)) {
return cache.get(key);
    }
    let result = func.apply(this, arguments); // (**)
    cache.set(key, result);
    return result;
  };
}
function hash(args) {
  return args[0] + ',' + args[1];
}
worker.slow = cachingDecorator(worker.slow, hash);
alert( worker.slow(3, 5) ); // works
alert( &quot;Again &quot; + worker.slow(3, 5) ); // same (cached)</code>
  Now the wrapper operates with any number of arguments.

There are two changes:

<li>In the line <code>(*)</code> it calls <code>hash</code> to create a single key from <code>arguments</code>. 
Here we use a simple “joining” function that turns arguments <code>(3, 5)</code> into the key <code>&quot;3,5&quot;</code>. 
More complex cases may require other hashing functions.</li><li>Then <code>(**)</code> uses <code>func.apply</code> to pass both the context and all arguments the wrapper got (no matter how many) to the original function.</li>

<h2>Borrowing a method</h2>
Now let’s make one more minor improvement in the hashing function:

    <code>function hash(args) {
  return args[0] + ',' + args[1];
}</code>
  As of now, it works only on two arguments. 
It would be better if it could glue any number of <code>args</code>.

The natural solution would be to use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join">arr.join</a> method:

    <code>function hash(args) {
  return args.join();
}</code>
  …Unfortunately, that won’t work. 
Because we are calling <code>hash(arguments)</code> and <code>arguments</code> object is both iterable and array-like, but not a real array.

So calling <code>join</code> on it would fail, as we can see below:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function hash() {
  alert( arguments.join() ); // Error: arguments.join is not a function
}
hash(1, 2);</code>
  Still, there’s an easy way to use array join:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function hash() {
  alert( [].join.call(arguments) ); // 1,2
}
hash(1, 2);</code>
  The trick is called <em>method borrowing</em>.

We take (borrow) a join method from a regular array <code>[].join</code>. 
And use <code>[].join.call</code> to run it in the context of <code>arguments</code>.

Why does it work?

That’s because the internal algorithm of the native method <code>arr.join(glue)</code> is very simple.

Taken from the specification almost “as-is”:

<li>Let <code>glue</code> be the first argument or, if no arguments, then a comma <code>&quot;,&quot;</code>.</li><li>Let <code>result</code> be an empty string.</li><li>Append <code>this[0]</code> to <code>result</code>.</li><li>Append <code>glue</code> and <code>this[1]</code>.</li><li>Append <code>glue</code> and <code>this[2]</code>.</li><li>…Do so until <code>this.length</code> items are glued.</li><li>Return <code>result</code>.</li>

So, technically it takes <code>this</code> and joins <code>this[0]</code>, <code>this[1]</code> …etc together. 
It’s intentionally written in a way that allows any array-like <code>this</code> (not a coincidence, many methods follow this practice). 
That’s why it also works with <code>this=arguments</code>.

<h4><a name="summary" href="#summary">Summary</a4</h2>
<em>Decorator</em> is a wrapper around a function that alters its behavior. 
The main job is still carried out by the function.

It is generally safe to replace a function or a method with a decorated one, except for one little thing. 
If the original function had properties on it, like <code>func.calledCount</code> or whatever, then the decorated one will not provide them. 
Because that is a wrapper. 
So one needs to be careful if one uses them. 
Some decorators provide their own properties.

Decorators can be seen as “features” or “aspects” that can be added to a function. 
We can add one or add many. 
And all this without changing its code!

To implement <code>cachingDecorator</code>, we studied methods:

<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call">func.call(context, arg1, arg2…)</a> – calls <code>func</code> with given context and arguments.</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">func.apply(context, args)</a> – calls <code>func</code> passing <code>context</code> as <code>this</code> and array-like <code>args</code> into a list of arguments.</li>

The generic <em>call forwarding</em> is usually done with <code>apply</code>:

    <code>let wrapper = function() {
  return original.apply(this, arguments);
}</code>
  We also saw an example of <em>method borrowing</em> when we take a method from an object and <code>call</code> it in the context of another object. 
It is quite common to take array methods and apply them to arguments. 
The alternative is to use rest parameters object that is a real array.

There are many decorators there in the wild. 
Check how well you got them by solving the tasks of this chapter.

Every call is saved as an array of arguments.

For instance:

    <code>function work(a, b) {
  alert( a + b ); // work is an arbitrary function or method
}
work = spy(work);
work(1, 2); // 3
work(4, 5); // 9
for (let args of work.calls) {
  alert( 'call:' + args.join() ); // &quot;call:1,2&quot;, &quot;call:4,5&quot;
}</code>
  P.S. 
That decorator is sometimes useful for unit-testing, it’s advanced form is <code>sinon.spy</code> in <a href="http://sinonjs.org/">Sinon.JS</a> library.

<a href="http://plnkr.co/edit/1CppV1N5lDbHlBDp3hfh?p=preview" target="_blank" data-plunk-id="1CppV1N5lDbHlBDp3hfh">Open the sandbox with tests.</a>
<button type="button">solution</button>

Here we can use <code>calls.push(args)</code> to store all arguments in the log and <code>f.apply(this, args)</code> to forward the call.

<a href="http://plnkr.co/edit/5AdFdaIHwN7Y1cNAno8l?p=preview" target="_blank" data-plunk-id="5AdFdaIHwN7Y1cNAno8l">Open the solution with tests in the sandbox.</a>
<button type="button" title="close"></button>

<h3><a href="#delaying-decorator" name="delaying-decorator">Delaying decorator</a></h3><a href="/task/delay" target="_blank"></a>

importance: 5

Create a decorator <code>delay(f, ms)</code> that delays each call of <code>f</code> by <code>ms</code> milliseconds.

For instance:

    <code>function f(x) {
  alert(x);
}
// create wrappers
let f1000 = delay(f, 1000);
let f1500 = delay(f, 1500);
f1000(&quot;test&quot;); // shows &quot;test&quot; after 1000ms
f1500(&quot;test&quot;); // shows &quot;test&quot; after 1500ms</code>
  In other words, <code>delay(f, ms)</code> returns a &quot;delayed by <code>ms</code>&quot; variant of <code>f</code>.

In the code above, <code>f</code> is a function of a single argument, but your solution should pass all arguments and the context <code>this</code>.

<a href="http://plnkr.co/edit/VgFmZ8tPKTzZkAtIq8RC?p=preview" target="_blank" data-plunk-id="VgFmZ8tPKTzZkAtIq8RC">Open the sandbox with tests.</a>
<button type="button">solution</button>

The solution:

    <code>function delay(f, ms) {
  return function() {
    setTimeout(() =&gt; f.apply(this, arguments), ms);
  };
}</code>
  Please note how an arrow function is used here. 
As we know, arrow functions do not have own <code>this</code> and <code>arguments</code>, so <code>f.apply(this, arguments)</code> takes <code>this</code> and <code>arguments</code> from the wrapper.

If we pass a regular function, <code>setTimeout</code> would call it without arguments and <code>this=window</code> (in-browser), so we’d need to write a bit more code to pass them from the wrapper:

    <code>function delay(f, ms) {
  // added variables to pass this and arguments from the wrapper inside setTimeout
  return function(...args) {
    let savedThis = this;
    setTimeout(function() {
f.apply(savedThis, args);
    }, ms);
  };
}</code>
  <a href="http://plnkr.co/edit/Vcto5bmuW2KIaNuCb7az?p=preview" target="_blank" data-plunk-id="Vcto5bmuW2KIaNuCb7az">Open the solution with tests in the sandbox.</a>
<button type="button" title="close"></button>

<h3><a href="#debounce-decorator" name="debounce-decorator">Debounce decorator</a></h3><a href="/task/debounce" target="_blank"></a>

importance: 5

The result of <code>debounce(f, ms)</code> decorator should be a wrapper that passes the call to <code>f</code> at maximum once per <code>ms</code> milliseconds.

In other words, when we call a “debounced” function, it guarantees that all other future in the closest <code>ms</code> milliseconds will be ignored.

For instance:

    <code>let f = debounce(alert, 1000);
f(1); // runs immediately
f(2); // ignored
setTimeout( () =&gt; f(3), 100); // ignored ( only 100 ms passed )
setTimeout( () =&gt; f(4), 1100); // runs
setTimeout( () =&gt; f(5), 1500); // ignored (less than 1000 ms from the last run)</code>
  In practice <code>debounce</code> is useful for functions that retrieve/update something when we know that nothing new can be done in such a short period of time, so it’s better not to waste resources.

<a href="http://plnkr.co/edit/8VerOrx8r9lb6NCgaCRy?p=preview" target="_blank" data-plunk-id="8VerOrx8r9lb6NCgaCRy">Open the sandbox with tests.</a>
<button type="button">solution</button>

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function debounce(f, ms) {
  let isCooldown = false;
  return function() {
    if (isCooldown) return;
    f.apply(this, arguments);
    isCooldown = true;
    setTimeout(() =&gt; isCooldown = false, ms);
  };
}</code>
  The call to <code>debounce</code> returns a wrapper. 
There may be two states:

<li><code>isCooldown = false</code> – ready to run.</li><li><code>isCooldown = true</code> – waiting for the timeout.</li>

In the first call <code>isCooldown</code> is falsy, so the call proceeds, and the state changes to <code>true</code>.

While <code>isCooldown</code> is true, all other calls are ignored.

Then <code>setTimeout</code> reverts it to <code>false</code> after the given delay.

<a href="http://plnkr.co/edit/0qqTJwPO4zMsGwwudsKG?p=preview" target="_blank" data-plunk-id="0qqTJwPO4zMsGwwudsKG">Open the solution with tests in the sandbox.</a>
<button type="button" title="close"></button>

<h3><a href="#throttle-decorator" name="throttle-decorator">Throttle decorator</a></h3><a href="/task/throttle" target="_blank"></a>

importance: 5

Create a “throttling” decorator <code>throttle(f, ms)</code> – that returns a wrapper, passing the call to <code>f</code> at maximum once per <code>ms</code> milliseconds. 
Those calls that fall into the “cooldown” period, are ignored.

<strong>The difference with <code>debounce</code> – if an ignored call is the last during the cooldown, then it executes at the end of the delay.</strong>

Let’s check the real-life application to better understand that requirement and to see where it comes from.

<strong>For instance, we want to track mouse movements.</strong>

In browser we can setup a function to run at every mouse micro-movement and get the pointer location as it moves. 
During an active mouse usage, this function usually runs very frequently, can be something like 100 times per second (every 10 ms).

<strong>The tracking function should update some information on the web-page.</strong>

Updating function <code>update()</code> is too heavy to do it on every micro-movement. 
There is also no sense in making it more often than once per 100ms.

So we’ll assign <code>throttle(update, 100)</code> as the function to run on each mouse move instead of the original <code>update()</code>. 
The decorator will be called often, but <code>update()</code> will be called at maximum once per 100ms.

Visually, it will look like this:

<li>For the first mouse movement the decorated variant passes the call to <code>update</code>. 
That’s important, the user sees our reaction to his move immediately.</li><li>Then as the mouse moves on, until <code>100ms</code> nothing happens. 
The decorated variant ignores calls.</li><li>At the end of <code>100ms</code> – one more <code>update</code> happens with the last coordinates.</li><li>Then, finally, the mouse stops somewhere. 
The decorated variant waits until <code>100ms</code> expire and then runs <code>update</code> runs with last coordinates. 
So, perhaps the most important, the final mouse coordinates are processed.</li>

A code example:

    <code>function f(a) {
  console.log(a)
};
// f1000 passes calls to f at maximum once per 1000 ms
let f1000 = throttle(f, 1000);
f1000(1); // shows 1
f1000(2); // (throttling, 1000ms not out yet)
f1000(3); // (throttling, 1000ms not out yet)
// when 1000 ms time out...
// ...outputs 3, intermediate value 2 was ignored</code>
  P.S. 
Arguments and the context <code>this</code> passed to <code>f1000</code> should be passed to the original <code>f</code>.

<a href="http://plnkr.co/edit/py3KSMjPaPXGjfLrio3n?p=preview" target="_blank" data-plunk-id="py3KSMjPaPXGjfLrio3n">Open the sandbox with tests.</a>
<button type="button">solution</button>

    <code>function throttle(func, ms) {
  let isThrottled = false,
    savedArgs,
    savedThis;
  function wrapper() {
    if (isThrottled) { // (2)
savedArgs = arguments;
savedThis = this;
return;
    }
    func.apply(this, arguments); // (1)
    isThrottled = true;
    setTimeout(function() {
isThrottled = false; // (3)
if (savedArgs) {
  wrapper.apply(savedThis, savedArgs);
  savedArgs = savedThis = null;
}
    }, ms);
  }
  return wrapper;
}</code>
  A call to <code>throttle(func, ms)</code> returns <code>wrapper</code>.

<li>During the first call, the <code>wrapper</code> just runs <code>func</code> and sets the cooldown state (<code>isThrottled = true</code>).</li><li>In this state all calls memorized in <code>savedArgs/savedThis</code>. 
Please note that both the context and the arguments are equally important and should be memorized. 
We need them simultaneously to reproduce the call.</li><li>…Then after <code>ms</code> milliseconds pass, <code>setTimeout</code> triggers. 
The cooldown state is removed (<code>isThrottled = false</code>). 
And if we had ignored calls, then <code>wrapper</code> is executed with last memorized arguments and context.</li>

The 3rd step runs not <code>func</code>, but <code>wrapper</code>, because we not only need to execute <code>func</code>, but once again enter the cooldown state and setup the timeout to reset it.

<a href="http://plnkr.co/edit/sTjuJ30s7X0LxdQe54m5?p=preview" target="_blank" data-plunk-id="sTjuJ30s7X0LxdQe54m5">Open the solution with tests in the sandbox.</a>
<button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/settimeout-setinterval" data-tooltip="Scheduling: setTimeout and setInterval">Previous lesson</a><a href="/bind" data-tooltip="Function binding">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Fcall-apply-decorators"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Fcall-apply-decorators"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Fcall-apply-decorators"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Fcall-apply-decorators"></a>

When using <code>setTimeout</code> with object methods or passing object methods along, there’s a known problem: &quot;losing <code>this</code>&quot;.

Suddenly, <code>this</code> just stops working right. 
The situation is typical for novice developers, but happens with experienced ones as well.

<h2>Losing “this”</h2>
We already know that in JavaScript it’s easy to lose <code>this</code>. 
Once a method is passed somewhere separately from the object – <code>this</code> is lost.

Here’s how it may happen with <code>setTimeout</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  firstName: &quot;John&quot;,
  sayHi() {
    alert(`Hello, ${this.firstName}!`);
  }
};
setTimeout(user.sayHi, 1000); // Hello, undefined!</code>
  As we can see, the output shows not “John” as <code>this.firstName</code>, but <code>undefined</code>!

That’s because <code>setTimeout</code> got the function <code>user.sayHi</code>, separately from the object. 
The last line can be rewritten as:

    <code>let f = user.sayHi;
setTimeout(f, 1000); // lost user context</code>
  The method <code>setTimeout</code> in-browser is a little special: it sets <code>this=window</code> for the function call (for Node.JS, <code>this</code> becomes the timer object, but doesn’t really matter here). 
So for <code>this.firstName</code> it tries to get <code>window.firstName</code>, which does not exist. 
In other similar cases as we’ll see, usually <code>this</code> just becomes <code>undefined</code>.

The task is quite typical – we want to pass an object method somewhere else (here – to the scheduler) where it will be called. 
How to make sure that it will be called in the right context?

<h2>Solution 1: a wrapper</h2>
The simplest solution is to use an wrapping function:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  firstName: &quot;John&quot;,
  sayHi() {
    alert(`Hello, ${this.firstName}!`);
  }
};
setTimeout(function() {
  user.sayHi(); // Hello, John!
}, 1000);</code>
  Now it works, because it receives <code>user</code> from the outer lexical environment, and then calls the method normally.

The same, but shorter:

    <code>setTimeout(() =&gt; user.sayHi(), 1000); // Hello, John!</code>
  Looks fine, but a slight vulnerability appears in our code structure.

What if before <code>setTimeout</code> triggers (there’s one second delay!) <code>user</code> changes value? Then, suddenly, it will call the wrong object!

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  firstName: &quot;John&quot;,
  sayHi() {
    alert(`Hello, ${this.firstName}!`);
  }
};
setTimeout(() =&gt; user.sayHi(), 1000);
// ...within 1 second
user = { sayHi() { alert(&quot;Another user in setTimeout!&quot;); } };
// Another user in setTimeout?!?</code>
  The next solution guarantees that such thing won’t happen.

<h2>Solution 2: bind</h2>
Functions provide a built-in method <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">bind</a> that allows to fix <code>this</code>.

The basic syntax is:

    <code>// more complex syntax will be little later
let boundFunc = func.bind(context);</code>
  The result of <code>func.bind(context)</code> is a special function-like “exotic object”, that is callable as function and transparently passes the call to <code>func</code> setting <code>this=context</code>.

In other words, calling <code>boundFunc</code> is like <code>func</code> with fixed <code>this</code>.

For instance, here <code>funcUser</code> passes a call to <code>func</code> with <code>this=user</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  firstName: &quot;John&quot;
};
function func() {
  alert(this.firstName);
}
let funcUser = func.bind(user);
funcUser(); // John</code>
  Here <code>func.bind(user)</code> as a “bound variant” of <code>func</code>, with fixed <code>this=user</code>.

All arguments are passed to the original <code>func</code> “as is”, for instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  firstName: &quot;John&quot;
};
function func(phrase) {
  alert(phrase + ', ' + this.firstName);
}
// bind this to user
let funcUser = func.bind(user);
funcUser(&quot;Hello&quot;); // Hello, John (argument &quot;Hello&quot; is passed, and this=user)</code>
  Now let’s try with an object method:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  firstName: &quot;John&quot;,
  sayHi() {
    alert(`Hello, ${this.firstName}!`);
  }
};
let sayHi = user.sayHi.bind(user); // (*)
sayHi(); // Hello, John!
setTimeout(sayHi, 1000); // Hello, John!</code>
  In the line <code>(*)</code> we take the method <code>user.sayHi</code> and bind it to <code>user</code>. 
The <code>sayHi</code> is a “bound” function, that can be called alone or passed to <code>setTimeout</code> – doesn’t matter, the context will be right.

Here we can see that arguments are passed “as is”, only <code>this</code> is fixed by <code>bind</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  firstName: &quot;John&quot;,
  say(phrase) {
    alert(`${phrase}, ${this.firstName}!`);
  }
};
let say = user.say.bind(user);
say(&quot;Hello&quot;); // Hello, John (&quot;Hello&quot; argument is passed to say)
say(&quot;Bye&quot;); // Bye, John (&quot;Bye&quot; is passed to say)</code>
  
Convenience method: <code>bindAll</code>
If an object has many methods and we plan to actively pass it around, then we could bind them all in a loop:

    <code>for (let key in user) {
  if (typeof user[key] == 'function') {
    user[key] = user[key].bind(user);
  }
}</code>
  JavaScript libraries also provide functions for convenient mass binding , e.g. 
<a href="http://lodash.com/docs#bindAll">_.bindAll(obj)</a> in lodash.

<h4><a name="summary" href="#summary">Summary</a4</h2>
Method <code>func.bind(context, ...args)</code> returns a “bound variant” of function <code>func</code> that fixes the context <code>this</code> and first arguments if given.

Usually we apply <code>bind</code> to fix <code>this</code> in an object method, so that we can pass it somewhere. 
For example, to <code>setTimeout</code>. 
There are more reasons to <code>bind</code> in the modern development, we’ll meet them later.

    <code>function f() {
  alert( this ); // ?
}
let user = {
  g: f.bind(null)
};
user.g();</code>
  <button type="button">solution</button>

The answer: <code>null</code>.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function f() {
  alert( this ); // null
}
let user = {
  g: f.bind(null)
};
user.g();</code>
  The context of a bound function is hard-fixed. 
There’s just no way to further change it.

So even while we run <code>user.g()</code>, the original function is called with <code>this=null</code>.

<button type="button" title="close"></button>

<h3><a href="#second-bind" name="second-bind">Second bind</a></h3><a href="/task/second-bind" target="_blank"></a>

importance: 5

Can we change <code>this</code> by additional binding?

What will be the output?

    <code>function f() {
  alert(this.name);
}
f = f.bind( {name: &quot;John&quot;} ).bind( {name: &quot;Ann&quot; } );
f();</code>
  <button type="button">solution</button>

The answer: <strong>John</strong>.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function f() {
  alert(this.name);
}
f = f.bind( {name: &quot;John&quot;} ).bind( {name: &quot;Pete&quot;} );
f(); // John</code>
  The exotic <a href="https://tc39.github.io/ecma262/#sec-bound-function-exotic-objects">bound function</a> object returned by <code>f.bind(...)</code> remembers the context (and arguments if provided) only at creation time.

A function cannot be re-bound.

<button type="button" title="close"></button>

<h3><a href="#function-property-after-bind" name="function-property-after-bind">Function property after bind</a></h3><a href="/task/function-property-after-bind" target="_blank"></a>

importance: 5

There’s a value in the property of a function. 
Will it change after <code>bind</code>? Why, elaborate?

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function sayHi() {
  alert( this.name );
}
sayHi.test = 5;
let bound = sayHi.bind({
  name: &quot;John&quot;
});
alert( bound.test ); // what will be the output? why?</code>
  <button type="button">solution</button>

The answer: <code>undefined</code>.

The result of <code>bind</code> is another object. 
It does not have the <code>test</code> property.

<button type="button" title="close"></button>

<h3><a href="#ask-losing-this" name="ask-losing-this">Ask losing this</a></h3><a href="/task/question-use-bind" target="_blank"></a>

importance: 5

The call to <code>askPassword()</code> in the code below should check the password and then call <code>user.loginOk/loginFail</code> depending on the answer.

But it leads to an error. 
Why?

Fix the highlighted line for everything to start working right (other lines are not to be changed).

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function askPassword(ok, fail) {
  let password = prompt(&quot;Password?&quot;, '');
  if (password == &quot;rockstar&quot;) ok();
  else fail();
}
let user = {
  name: 'John',
  loginOk() {
    alert(`${this.name} logged in`);
  },
  loginFail() {
    alert(`${this.name} failed to log in`);
  },
};
askPassword(user.loginOk, user.loginFail);</code>
  <button type="button">solution</button>

The error occurs because <code>ask</code> gets functions <code>loginOk/loginFail</code> without the object.

When it calls them, they naturally assume <code>this=undefined</code>.

Let’s <code>bind</code> the context:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function askPassword(ok, fail) {
  let password = prompt(&quot;Password?&quot;, '');
  if (password == &quot;rockstar&quot;) ok();
  else fail();
}
let user = {
  name: 'John',
  loginOk() {
    alert(`${this.name} logged in`);
  },
  loginFail() {
    alert(`${this.name} failed to log in`);
  },
};
askPassword(user.loginOk.bind(user), user.loginFail.bind(user));</code>
  Now it works.

An alternative solution could be:

    <code>//...
askPassword(() =&gt; user.loginOk(), () =&gt; user.loginFail());</code>
  Usually that also works, but may fail in more complex situations where <code>user</code> has a chance of being overwritten between the moments of asking and running <code>() =&gt; user.loginOk()</code>.

<button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/call-apply-decorators" data-tooltip="Decorators and forwarding, call/apply">Previous lesson</a><a href="/currying-partials" data-tooltip="Currying and partials">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Fbind"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Fbind"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Fbind"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Fbind"></a>

Until now we have only been talking about binding <code>this</code>. 
Let’s take it a step further.

We can bind not only <code>this</code>, but also arguments. 
That’s rarely done, but sometimes can be handy.

The full syntax of <code>bind</code>:

    <code>let bound = func.bind(context, arg1, arg2, ...);</code>
  It allows to bind context as <code>this</code> and starting arguments of the function.

For instance, we have a multiplication function <code>mul(a, b)</code>:

    <code>function mul(a, b) {
  return a * b;
}</code>
  Let’s use <code>bind</code> to create a function <code>double</code> on its base:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let double = mul.bind(null, 2);
alert( double(3) ); // = mul(2, 3) = 6
alert( double(4) ); // = mul(2, 4) = 8
alert( double(5) ); // = mul(2, 5) = 10</code>
  The call to <code>mul.bind(null, 2)</code> creates a new function <code>double</code> that passes calls to <code>mul</code>, fixing <code>null</code> as the context and <code>2</code> as the first argument. 
Further arguments are passed “as is”.

That’s called <a href="https://en.wikipedia.org/wiki/Partial_application">partial function application</a> – we create a new function by fixing some parameters of the existing one.

Please note that here we actually don’t use <code>this</code> here. 
But <code>bind</code> requires it, so we must put in something like <code>null</code>.

The function <code>triple</code> in the code below triples the value:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let triple = mul.bind(null, 3);
alert( triple(3) ); // = mul(3, 3) = 9
alert( triple(4) ); // = mul(3, 4) = 12
alert( triple(5) ); // = mul(3, 5) = 15</code>
  Why do we usually make a partial function?

Here our benefit is that we created an independent function with a readable name (<code>double</code>, <code>triple</code>). 
We can use it and don’t write the first argument of every time, cause it’s fixed with <code>bind</code>.

In other cases, partial application is useful when we have a very generic function, and want a less universal variant of it for convenience.

For instance, we have a function <code>send(from, to, text)</code>. 
Then, inside a <code>user</code> object we may want to use a partial variant of it: <code>sendTo(to, text)</code> that sends from the current user.

<h2>Going partial without context</h2>
What if we’d like to fix some arguments, but not bind <code>this</code>?

The native <code>bind</code> does not allow that. 
We can’t just omit the context and jump to arguments.

Fortunately, a <code>partial</code> function for binding only arguments can be easily implemented.

Like this:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function partial(func, ...argsBound) {
  return function(...args) { // (*)
    return func.call(this, ...argsBound, ...args);
  }
}
// Usage:
let user = {
  firstName: &quot;John&quot;,
  say(time, phrase) {
    alert(`[${time}] ${this.firstName}: ${phrase}!`);
  }
};
// add a partial method that says something now by fixing the first argument
user.sayNow = partial(user.say, new Date().getHours() + ':' + new Date().getMinutes());
user.sayNow(&quot;Hello&quot;);
// Something like:
// [10:00] John: Hello!</code>
  The result of <code>partial(func[, arg1, arg2...])</code> call is a wrapper <code>(*)</code> that calls <code>func</code> with:

<li>Same <code>this</code> as it gets (for <code>user.sayNow</code> call it’s <code>user</code>)</li><li>Then gives it <code>...argsBound</code> – arguments from the <code>partial</code> call (<code>&quot;10:00&quot;</code>)</li><li>Then gives it <code>...args</code> – arguments given to the wrapper (<code>&quot;Hello&quot;</code>)</li>

So easy to do it with the spread operator, right?

Also there’s a ready <a href="https://lodash.com/docs#partial">_.partial</a> implementation from lodash library.

<h2>Currying</h2>
Sometimes people mix up partial function application mentioned above with another thing named “currying”. 
That’s another interesting technique of working with functions that we just have to mention here.

<a href="https://en.wikipedia.org/wiki/Currying">Currying</a> is translating a function from callable as <code>f(a, b, c)</code> into callable as <code>f(a)(b)(c)</code>.

Let’s make <code>curry</code> function that performs currying for binary functions. 
In other words, it translates <code>f(a, b)</code> into <code>f(a)(b)</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function curry(func) {
  return function(a) {
    return function(b) {
return func(a, b);
    };
  };
}
// usage
function sum(a, b) {
  return a + b;
}
let carriedSum = curry(sum);
alert( carriedSum(1)(2) ); // 3</code>
  As you can see, the implementation is a series of wrappers.

<li>The result of <code>curry(func)</code> is a wrapper <code>function(a)</code>.</li><li>When it is called like <code>sum(1)</code>, the argument is saved in the Lexical Environment, and a new wrapper is returned <code>function(b)</code>.</li><li>Then <code>sum(1)(2)</code> finally calls <code>function(b)</code> providing <code>2</code>, and it passes the call to the original multi-argument <code>sum</code>.</li>

More advanced implementations of currying like <a href="https://lodash.com/docs#curry">_.curry</a> from lodash library do something more sophisticated. 
They return a wrapper that allows a function to be called normally when all arguments are supplied <em>or</em> returns a partial otherwise.

    <code>function curry(f) {
  return function(...args) {
    // if args.length == f.length (as many arguments as f has),
    //   then pass the call to f
    // otherwise return a partial function that fixes args as first arguments
  };
}</code>
  <h2>Currying? What for?</h2>
Advanced currying allows both to keep the function callable normally and to get partials easily. 
To understand the benefits we definitely need a worthy real-life example.

For instance, we have the logging function <code>log(date, importance, message)</code> that formats and outputs the information. 
In real projects such functions also have many other useful features like: sending it over the network or filtering:

    <code>function log(date, importance, message) {
  alert(`[${date.getHours()}:${date.getMinutes()}] [${importance}] ${message}`);
}</code>
  Let’s curry it!

    <code>log = _.curry(log);</code>
  After that <code>log</code> still works the normal way:

    <code>log(new Date(), &quot;DEBUG&quot;, &quot;some debug&quot;);</code>
  …But also can be called in the curried form:

    <code>log(new Date())(&quot;DEBUG&quot;)(&quot;some debug&quot;); // log(a)(b)(c)</code>
  Let’s get a convenience function for today’s logs:

    <code>// todayLog will be the partial of log with fixed first argument
let todayLog = log(new Date());
// use it
todayLog(&quot;INFO&quot;, &quot;message&quot;); // [HH:mm] INFO message</code>
  And now a convenience function for today’s debug messages:

    <code>let todayDebug = todayLog(&quot;DEBUG&quot;);
todayDebug(&quot;message&quot;); // [HH:mm] DEBUG message</code>
  So:

<li>We didn’t lose anything after currying: <code>log</code> is still callable normally.</li><li>We were able to generate partial functions that are convenient in many cases.</li>

<h2>Advanced curry implementation</h2>
In case you’re interested, here’s the “advanced” curry implementation that we could use above.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function curry(func) {
  return function curried(...args) {
    if (args.length &gt;= func.length) {
return func.apply(this, args);
    } else {
return function(...args2) {
  return curried.apply(this, args.concat(args2));
}
    }
  };
}
function sum(a, b, c) {
  return a + b + c;
}
let curriedSum = curry(sum);
// still callable normally
alert( curriedSum(1, 2, 3) ); // 6
// get the partial with curried(1) and call it with 2 other arguments
alert( curriedSum(1)(2,3) ); // 6
// full curried form
alert( curriedSum(1)(2)(3) ); // 6</code>
  The new <code>curry</code> may look complicated, but it’s actually pretty easy to understand.

The result of <code>curry(func)</code> is the wrapper <code>curried</code> that looks like this:

    <code>// func is the function to transform
function curried(...args) {
  if (args.length &gt;= func.length) { // (1)
    return func.apply(this, args);
  } else {
    return function pass(...args2) { // (2)
return curried.apply(this, args.concat(args2));
    }
  }
};</code>
  When we run it, there are two branches:

<li>Call now: if passed <code>args</code> count is the same as the original function has in its definition (<code>func.length</code>) or longer, then just pass the call to it.</li><li>Get a partial: otherwise, <code>func</code> is not called yet. 
Instead, another wrapper <code>pass</code> is returned, that will re-apply <code>curried</code> providing previous arguments together with the new ones. 
Then on a new call, again, we’ll get either a new partial (if not enough arguments) or, finally, the result.</li>

For instance, let’s see what happens in the case of <code>sum(a, b, c)</code>. 
Three arguments, so <code>sum.length = 3</code>.

For the call <code>curried(1)(2)(3)</code>:

<li>The first call <code>curried(1)</code> remembers <code>1</code> in its Lexical Environment, and returns a wrapper <code>pass</code>.

</li><li>The wrapper <code>pass</code> is called with <code>(2)</code>: it takes previous args (<code>1</code>), concatenates them with what it got <code>(2)</code> and calls <code>curried(1, 2)</code> with them together.

As the argument count is still less than 3, <code>curry</code> returns <code>pass</code>.

</li><li>The wrapper <code>pass</code> is called again with <code>(3)</code>,  for the next call <code>pass(3)</code> takes previous args (<code>1</code>, <code>2</code>) and adds <code>3</code> to them, making the call <code>curried(1, 2, 3)</code> – there are <code>3</code> arguments at last, they are given to the original function.

</li>

If that’s still not obvious, just trace the calls sequence in your mind or on the paper.

Fixed-length functions only
The currying requires the function to have a known fixed number of arguments.

A little more than currying
By definition, currying should convert <code>sum(a, b, c)</code> into <code>sum(a)(b)(c)</code>.

But most implementations of currying in JavaScript are advanced, as described: they also keep the function callable in the multi-argument variant.

<h4><a name="summary" href="#summary">Summary</a></h4><li>When we fix some arguments of an existing function, the resulting (less universal) function is called <em>a partial</em>. 
We can use <code>bind</code> to get a partial, but there are other ways also.

Partials are convenient when we don’t want to repeat the same argument over and over again. 
Like if we have a <code>send(from, to)</code> function, and <code>from</code> should always be the same for our task, we can get a partial and go on with it.

</li><li><em>Currying</em> is a transform that makes <code>f(a,b,c)</code> callable as <code>f(a)(b)(c)</code>. 
JavaScript implementations usually both keep the function callable normally and return the partial if arguments count is not enough.

Currying is great when we want easy partials. 
As we’ve seen in the logging example: the universal function <code>log(date, importance, message)</code> after currying gives us partials when called with one argument like <code>log(date)</code> or two arguments <code>log(date, importance)</code>.

</li>

The <code>user</code> object was modified. 
Now instead of two functions <code>loginOk/loginFail</code>, it has a single function <code>user.login(true/false)</code>.

What to pass <code>askPassword</code> in the code below, so that it calls <code>user.login(true)</code> as <code>ok</code> and <code>user.login(false)</code> as <code>fail</code>?

    <code>function askPassword(ok, fail) {
  let password = prompt(&quot;Password?&quot;, '');
  if (password == &quot;rockstar&quot;) ok();
  else fail();
}
let user = {
  name: 'John',
  login(result) {
    alert( this.name + (result ? ' logged in' : ' failed to log in') );
  }
};
askPassword(?, ?); // ?</code>
  Your changes should only modify the highlighted fragment.

<button type="button">solution</button>

<li>Either use a wrapper function, an arrow to be concise:

    <code>askPassword(() =&gt; user.login(true), () =&gt; user.login(false));</code>
  Now it gets <code>user</code> from outer variables and runs it the normal way.

</li><li>Or create a partial function from <code>user.login</code> that uses <code>user</code> as the context and has the correct first argument:

    <code>askPassword(user.login.bind(user, true), user.login.bind(user, false));</code>
  </li>

<button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/bind" data-tooltip="Function binding">Previous lesson</a><a href="/arrow-functions" data-tooltip="Arrow functions revisited">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Fcurrying-partials"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Fcurrying-partials"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Fcurrying-partials"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Fcurrying-partials"></a>

Let’s revisit arrow functions.

Arrow functions are not just a “shorthand” for writing small stuff.

JavaScript is full of situations where we need to write a small function, that’s executed somewhere else.

For instance:

<li><code>arr.forEach(func)</code> – <code>func</code> is executed by <code>forEach</code> for every array item.</li><li><code>setTimeout(func)</code> – <code>func</code> is executed by the built-in scheduler.</li><li>…there are more.</li>

It’s in the very spirit of JavaScript to create a function and pass it somewhere.

And in such functions we usually don’t want to leave the current context.

<h2>Arrow functions have no “this”</h2>
As we remember from the chapter <a href="/object-methods">Object methods, &quot;this&quot;</a>, arrow functions do not have <code>this</code>. 
If <code>this</code> is accessed, it is taken from the outside.

For instance, we can use it to iterate inside an object method:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let group = {
  title: &quot;Our Group&quot;,
  students: [&quot;John&quot;, &quot;Pete&quot;, &quot;Alice&quot;],
  showList() {
    this.students.forEach(
student =&gt; alert(this.title + ': ' + student)
    );
  }
};
group.showList();</code>
  Here in <code>forEach</code>, the arrow function is used, so <code>this.title</code> in it is exactly the same as in the outer method <code>showList</code>. 
That is: <code>group.title</code>.

If we used a “regular” function, there would be an error:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let group = {
  title: &quot;Our Group&quot;,
  students: [&quot;John&quot;, &quot;Pete&quot;, &quot;Alice&quot;],
  showList() {
    this.students.forEach(function(student) {
// Error: Cannot read property 'title' of undefined
alert(this.title + ': ' + student)
    });
  }
};
group.showList();</code>
  The error occurs because <code>forEach</code> runs functions with <code>this=undefined</code> by default, so the attempt to access <code>undefined.title</code> is made.

That doesn’t affect arrow functions, because they just don’t have <code>this</code>.

Arrow functions can’t run with <code>new</code>
Not having <code>this</code> naturally means another limitation: arrow functions can’t be used as constructors. 
They can’t be called with <code>new</code>.

Arrow functions VS bind
There’s a subtle difference between an arrow function <code>=&gt;</code> and a regular function called with <code>.bind(this)</code>:

<li><code>.bind(this)</code> creates a “bound version” of the function.</li><li>The arrow <code>=&gt;</code> doesn’t create any binding. 
The function simply doesn’t have <code>this</code>. 
The lookup of <code>this</code> is made exactly the same way as a regular variable search: in the outer lexical environment.</li>

<h2>Arrows have no “arguments”</h2>
Arrow functions also have no <code>arguments</code> variable.

That’s great for decorators, when we need to forward a call with the current <code>this</code> and <code>arguments</code>.

For instance, <code>defer(f, ms)</code> gets a function and returns a wrapper around it that delays the call by <code>ms</code> milliseconds:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function defer(f, ms) {
  return function() {
    setTimeout(() =&gt; f.apply(this, arguments), ms)
  };
}
function sayHi(who) {
  alert('Hello, ' + who);
}
let sayHiDeferred = defer(sayHi, 2000);
sayHiDeferred(&quot;John&quot;); // Hello, John after 2 seconds</code>
  The same without an arrow function would look like:

    <code>function defer(f, ms) {
  return function(...args) {
    let ctx = this;
    setTimeout(function() {
return f.apply(ctx, args);
    }, ms);
  };
}</code>
  Here we had to create additional variables <code>args</code> and <code>ctx</code> so that the function inside <code>setTimeout</code> could take them.

<h4><a name="summary" href="#summary">Summary</a4</h2>
Arrow functions:

<li>Do not have <code>this</code>.</li><li>Do not have <code>arguments</code>.</li><li>Can’t be called with <code>new</code>.</li><li>(They also don’t have <code>super</code>, but we didn’t study it. 
Will be in the chapter <a href="/class-inheritance">Class inheritance, super</a>).</li>

That’s because they are meant for short pieces of code that do not have their own “context”, but rather works in the current one. 
And they really shine in that use case.

As we know, objects can store properties.

Till now, a property was a simple “key-value” pair to us. 
But an object property is actually more complex and tunable thing.

<h2>Property flags</h2>
Object properties, besides a <strong><code>value</code></strong>, have three special attributes (so-called “flags”):

<li><strong><code>writable</code></strong> – if <code>true</code>, can be changed, otherwise it’s read-only.</li><li><strong><code>enumerable</code></strong> – if <code>true</code>, then listed in loops, otherwise not listed.</li><li><strong><code>configurable</code></strong> – if <code>true</code>, the property can be deleted and these attributes can be modified, otherwise not.</li>

We didn’t see them yet, because generally they do not show up. 
When we create a property “the usual way”, all of them are <code>true</code>. 
But we also can change them anytime.

First, let’s see how to get those flags.

The method <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor">Object.getOwnPropertyDescriptor</a> allows to query the <em>full</em> information about a property.

The syntax is:

    <code>let descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);</code>
  <dl>
<dt><code>obj</code></dt>
<dd>The object to get information from.</dd>
<dt><code>propertyName</code></dt>
<dd>The name of the property.</dd>
</dl>

The returned value is a so-called “property descriptor” object: it contains the value and all the flags.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  name: &quot;John&quot;
};
let descriptor = Object.getOwnPropertyDescriptor(user, 'name');
alert( JSON.stringify(descriptor, null, 2 ) );
/* property descriptor:
{
  &quot;value&quot;: &quot;John&quot;,
  &quot;writable&quot;: true,
  &quot;enumerable&quot;: true,
  &quot;configurable&quot;: true
}
*/</code>
  To change the flags, we can use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty</a>.

The syntax is:

    <code>Object.defineProperty(obj, propertyName, descriptor)</code>
  <dl>
<dt><code>obj</code>, <code>propertyName</code></dt>
<dd>The object and property to work on.</dd>
<dt><code>descriptor</code></dt>
<dd>Property descriptor to apply.</dd>
</dl>

If the property exists, <code>defineProperty</code> updates its flags. 
Otherwise, it creates the property with the given value and flags; in that case, if a flag is not supplied, it is assumed <code>false</code>.

For instance, here a property <code>name</code> is created with all falsy flags:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {};
Object.defineProperty(user, &quot;name&quot;, {
  value: &quot;John&quot;
});
let descriptor = Object.getOwnPropertyDescriptor(user, 'name');
alert( JSON.stringify(descriptor, null, 2 ) );
/*
{
  &quot;value&quot;: &quot;John&quot;,
  &quot;writable&quot;: false,
  &quot;enumerable&quot;: false,
  &quot;configurable&quot;: false
}
 */</code>
  Compare it with “normally created” <code>user.name</code> above: now all flags are falsy. 
If that’s not what we want then we’d better set them to <code>true</code> in <code>descriptor</code>.

Now let’s see effects of the flags by example.

<h2>Read-only</h2>
Let’s make <code>user.name</code> read-only by changing <code>writable</code> flag:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  name: &quot;John&quot;
};
Object.defineProperty(user, &quot;name&quot;, {
  writable: false
});
user.name = &quot;Pete&quot;; // Error: Cannot assign to read only property 'name'...</code>
  Now no one can change the name of our user, unless he applies his own <code>defineProperty</code> to override ours.

Here’s the same operation, but for the case when a property doesn’t exist:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = { };
Object.defineProperty(user, &quot;name&quot;, {
  value: &quot;Pete&quot;,
  // for new properties need to explicitly list what's true
  enumerable: true,
  configurable: true
});
alert(user.name); // Pete
user.name = &quot;Alice&quot;; // Error</code>
  <h2>Non-enumerable</h2>
Now let’s add a custom <code>toString</code> to <code>user</code>.

Normally, a built-in <code>toString</code> for objects is non-enumerable, it does not show up in <code>for..in</code>. 
But if we add <code>toString</code> of our own, then by default it shows up in <code>for..in</code>, like this:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  name: &quot;John&quot;,
  toString() {
    return this.name;
  }
};
// By default, both our properties are listed:
for (let key in user) alert(key); // name, toString</code>
  If we don’t like it, then we can set <code>enumerable:false</code>. 
Then it won’t appear in <code>for..in</code> loop, just like the built-in one:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  name: &quot;John&quot;,
  toString() {
    return this.name;
  }
};
Object.defineProperty(user, &quot;toString&quot;, {
  enumerable: false
});
// Now our toString disappears:
for (let key in user) alert(key); // name</code>
  Non-enumerable properties are also excluded from <code>Object.keys</code>:

    <code>alert(Object.keys(user)); // name</code>
  <h2>Non-configurable</h2>
The non-configurable flag (<code>configurable:false</code>) is sometimes preset for built-in objects and properties.

A non-configurable property can not be deleted or altered with <code>defineProperty</code>.

For instance, <code>Math.PI</code> is both read-only, non-enumerable and non-configurable:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let descriptor = Object.getOwnPropertyDescriptor(Math, 'PI');
alert( JSON.stringify(descriptor, null, 2 ) );
/*
{
  &quot;value&quot;: 3.141592653589793,
  &quot;writable&quot;: false,
  &quot;enumerable&quot;: false,
  &quot;configurable&quot;: false
}
*/</code>
  So, a programmer is unable to change the value of <code>Math.PI</code> or overwrite it.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>Math.PI = 3; // Error
// delete Math.PI won't work either</code>
  Making a property non-configurable is a one-way road. 
We cannot change it back, because <code>defineProperty</code> doesn’t work on non-configurable properties.

Here we are making <code>user.name</code> a “forever sealed” constant:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = { };
Object.defineProperty(user, &quot;name&quot;, {
  value: &quot;John&quot;,
  writable: false,
  configurable: false
});
// won't be able to change user.name or its flags
// all this won't work:
//   user.name = &quot;Pete&quot;
//   delete user.name
//   defineProperty(user, &quot;name&quot;, ...)
Object.defineProperty(user, &quot;name&quot;, {writable: true}); // Error</code>
  
Errors appear only in use strict
In the non-strict mode, no errors occur when writing to read-only properties and such. 
But the operation still won’t succeed. 
Flag-violating actions are just silently ignored in non-strict.

<h2>Object.defineProperties</h2>
There’s a method <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties">Object.defineProperties(obj, descriptors)</a> that allows to define many properties at once.

The syntax is:

    <code>Object.defineProperties(obj, {
  prop1: descriptor1,
  prop2: descriptor2
  // ...
});</code>
  For instance:

    <code>Object.defineProperties(user, {
  name: { value: &quot;John&quot;, writable: false },
  surname: { value: &quot;Smith&quot;, writable: false },
  // ...
});</code>
  So, we can set many properties at once.

<h2>Object.getOwnPropertyDescriptors</h2>
To get all property descriptors at once, we can use the method <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors">Object.getOwnPropertyDescriptors(obj)</a>.

Together with <code>Object.defineProperties</code> it can be used as a “flags-aware” way of cloning an object:

    <code>let clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj));</code>
  Normally when we clone an object, we use an assignment to copy properties, like this:

    <code>for (let key in user) {
  clone[key] = user[key]
}</code>
  …But that does not copy flags. 
So if we want a “better” clone then <code>Object.defineProperties</code> is preferred.

Another difference is that <code>for..in</code> ignores symbolic properties, but <code>Object.getOwnPropertyDescriptors</code> returns <em>all</em> property descriptors including symbolic ones.

<h2>Sealing an object globally</h2>
Property descriptors work at the level of individual properties.

There are also methods that limit access to the <em>whole</em> object:

<dl>
<dt><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions">Object.preventExtensions(obj)</a></dt>
<dd>Forbids to add properties to the object.</dd>
<dt><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal">Object.seal(obj)</a></dt>
<dd>Forbids to add/remove properties, sets for all existing properties <code>configurable: false</code>.</dd>
<dt><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze">Object.freeze(obj)</a></dt>
<dd>Forbids to add/remove/change properties, sets for all existing properties <code>configurable: false, writable: false</code>.</dd>
</dl>

And also there are tests for them:

<dl>
<dt><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible">Object.isExtensible(obj)</a></dt>
<dd>Returns <code>false</code> if adding properties is forbidden, otherwise <code>true</code>.</dd>
<dt><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed">Object.isSealed(obj)</a></dt>
<dd>Returns <code>true</code> if adding/removing properties is forbidden, and all existing properties have <code>configurable: false</code>.</dd>
<dt><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen">Object.isFrozen(obj)</a></dt>
<dd>Returns <code>true</code> if adding/removing/changing properties is forbidden, and all current properties are <code>configurable: false, writable: false</code>.</dd>
</dl>

These methods are rarely used in practice.

There are two kinds of properties.

The first kind is <em>data properties</em>. 
We already know how to work with them. 
Actually, all properties that we’ve been using till now were data properties.

The second type of properties is something new. 
It’s <em>accessor properties</em>. 
They are essentially functions that work on getting and setting a value, but look like regular properties to an external code.

<h2>Getters and setters</h2>
Accessor properties are represented by “getter” and “setter” methods. 
In an object literal they are denoted by <code>get</code> and <code>set</code>:

    <code>let obj = {
  get propName() {
    // getter, the code executed on getting obj.propName
  },
  set propName(value) {
    // setter, the code executed on setting obj.propName = value
  }
};</code>
  The getter works when <code>obj.propName</code> is read, the setter – when it is assigned.

For instance, we have a <code>user</code> object with <code>name</code> and <code>surname</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  name: &quot;John&quot;,
  surname: &quot;Smith&quot;
};</code>
  Now we want to add a “fullName” property, that should be “John Smith”. 
Of course, we don’t want to copy-paste existing information, so we can implement it as an accessor:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  name: &quot;John&quot;,
  surname: &quot;Smith&quot;,
  get fullName() {
    return `${this.name} ${this.surname}`;
  }
};
alert(user.fullName); // John Smith</code>
  From outside, an accessor property looks like a regular one. 
That’s the idea of accessor properties. 
We don’t <em>call</em> <code>user.fullName</code> as a function, we <em>read</em> it normally: the getter runs behind the scenes.

As of now, <code>fullName</code> has only a getter. 
If we attempt to assign <code>user.fullName=</code>, there will be an error.

Let’s fix it by adding a setter for <code>user.fullName</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  name: &quot;John&quot;,
  surname: &quot;Smith&quot;,
  get fullName() {
    return `${this.name} ${this.surname}`;
  },
  set fullName(value) {
    [this.name, this.surname] = value.split(&quot; &quot;);
  }
};
// set fullName is executed with the given value.
user.fullName = &quot;Alice Cooper&quot;;
alert(user.name); // Alice
alert(user.surname); // Cooper</code>
  Now we have a “virtual” property. 
It is readable and writable, but in fact does not exist.

Accessor properties are only accessible with get/set
A property can either be a “data property” or an “accessor property”, but not both.

Once a property is defined with <code>get prop()</code> or <code>set prop()</code>, it’s an accessor property. 
So there must be a getter to read it, and must be a setter if we want to assign it.

Sometimes it’s normal that there’s only a setter or only a getter. 
But the property won’t be readable or writable in that case.

<h2>Accessor descriptors</h2>
Descriptors for accessor properties are different – as compared with data properties.

For accessor properties, there is no <code>value</code> and <code>writable</code>, but instead there are <code>get</code> and <code>set</code> functions.

So an accessor descriptor may have:

<li><strong><code>get</code></strong> – a function without arguments, that works when a property is read,</li><li><strong><code>set</code></strong> – a function with one argument, that is called when the property is set,</li><li><strong><code>enumerable</code></strong> – same as for data properties,</li><li><strong><code>configurable</code></strong> – same as for data properties.</li>

For instance, to create an accessor <code>fullName</code> with <code>defineProperty</code>, we can pass a descriptor with <code>get</code> and <code>set</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  name: &quot;John&quot;,
  surname: &quot;Smith&quot;
};
Object.defineProperty(user, 'fullName', {
  get() {
    return `${this.name} ${this.surname}`;
  },
  set(value) {
    [this.name, this.surname] = value.split(&quot; &quot;);
  }
});
alert(user.fullName); // John Smith
for(let key in user) alert(key); // name, surname</code>
  Please note once again that a property can be either an accessor or a data property, not both.

If we try to supply both <code>get</code> and <code>value</code> in the same descriptor, there will be an error:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// Error: Invalid property descriptor.
Object.defineProperty({}, 'prop', {
  get() {
    return 1
  },
  value: 2
});</code>
  <h2>Smarter getters/setters</h2>
Getters/setters can be used as wrappers over “real” property values to gain more control over them.

For instance, if we want to forbid too short names for <code>user</code>, we can store <code>name</code> in a special property <code>_name</code>. 
And filter assignments in the setter:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  get name() {
    return this._name;
  },
  set name(value) {
    if (value.length &lt; 4) {
alert(&quot;Name is too short, need at least 4 characters&quot;);
return;
    }
    this._name = value;
  }
};
user.name = &quot;Pete&quot;;
alert(user.name); // Pete
user.name = &quot;&quot;; // Name is too short...</code>
  Technically, the external code may still access the name directly by using <code>user._name</code>. 
But there is a widely known agreement that properties starting with an underscore <code>&quot;_&quot;</code> are internal and should not be touched from outside the object.

<h2>Using for compatibility</h2>
One of the great ideas behind getters and setters – they allow to take control over a “normal” data property and tweak it at any moment.

For instance, we started implementing user objects using data properties <code>name</code> and <code>age</code>:

    <code>function User(name, age) {
  this.name = name;
  this.age = age;
}
let john = new User(&quot;John&quot;, 25);
alert( john.age ); // 25</code>
  …But sooner or later, things may change. 
Instead of <code>age</code> we may decide to store <code>birthday</code>, because it’s more precise and convenient:

    <code>function User(name, birthday) {
  this.name = name;
  this.birthday = birthday;
}
let john = new User(&quot;John&quot;, new Date(1992, 6, 1));</code>
  Now what to do with the old code that still uses <code>age</code> property?

We can try to find all such places and fix them, but that takes time and can be hard to do if that code is written by other people. 
And besides, <code>age</code> is a nice thing to have in <code>user</code>, right? In some places it’s just what we want.

Adding a getter for <code>age</code> mitigates the problem:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function User(name, birthday) {
  this.name = name;
  this.birthday = birthday;
  // age is calculated from the current date and birthday
  Object.defineProperty(this, &quot;age&quot;, {
    get() {
let todayYear = new Date().getFullYear();
return todayYear - this.birthday.getFullYear();
    }
  });
}
let john = new User(&quot;John&quot;, new Date(1992, 6, 1));
alert( john.birthday ); // birthday is available
alert( john.age );      // ...as well as the age</code>
  Now the old code works too and we’ve got a nice additional property.

In programming, we often want to take something and extend it.

For instance, we have a <code>user</code> object with its properties and methods, and want to make <code>admin</code> and <code>guest</code> as slightly modified variants of it. 
We’d like to reuse what we have in <code>user</code>, not copy/reimplement its methods, just build a new object on top of it.

<em>Prototypal inheritance</em> is a language feature that helps in that.

<h2>[[Prototype]]</h2>
In JavaScript, objects have a special hidden property <code>[[Prototype]]</code> (as named in the specification), that is either <code>null</code> or references another object. 
That object is called “a prototype”:

<img src="https://javascript.info/article/prototype-inheritance/object-prototype-empty.png">
That <code>[[Prototype]]</code> has a “magical” meaning. 
When we want to read a property from <code>object</code>, and it’s missing, JavaScript automatically takes it from the prototype. 
In programming, such thing is called “prototypal inheritance”. 
Many cool language features and programming techniques are based on it.

The property <code>[[Prototype]]</code> is internal and hidden, but there are many ways to set it.

One of them is to use <code>__proto__</code>, like this:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let animal = {
  eats: true
};
let rabbit = {
  jumps: true
};
rabbit.__proto__ = animal;</code>
  Please note that <code>__proto__</code> is <em>not the same</em> as <code>[[Prototype]]</code>. 
That’s a getter/setter for it. 
We’ll talk about other ways of setting it later, but for now <code>__proto__</code> will do just fine.

If we look for a property in <code>rabbit</code>, and it’s missing, JavaScript automatically takes it from <code>animal</code>.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let animal = {
  eats: true
};
let rabbit = {
  jumps: true
};
rabbit.__proto__ = animal; // (*)
// we can find both properties in rabbit now:
alert( rabbit.eats ); // true (**)
alert( rabbit.jumps ); // true</code>
  Here the line <code>(*)</code> sets <code>animal</code> to be a prototype of <code>rabbit</code>.

Then, when <code>alert</code> tries to read property <code>rabbit.eats</code> <code>(**)</code>, it’s not in <code>rabbit</code>, so JavaScript follows the <code>[[Prototype]]</code> reference and finds it in <code>animal</code> (look from the bottom up):

<img src="https://javascript.info/article/prototype-inheritance/proto-animal-rabbit.png">
Here we can say that &quot;<code>animal</code> is the prototype of <code>rabbit</code>&quot; or &quot;<code>rabbit</code> prototypally inherits from <code>animal</code>&quot;.

So if <code>animal</code> has a lot of useful properties and methods, then they become automatically available in <code>rabbit</code>. 
Such properties are called “inherited”.

If we have a method in <code>animal</code>, it can be called on <code>rabbit</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let animal = {
  eats: true,
  walk() {
    alert(&quot;Animal walk&quot;);
  }
};
let rabbit = {
  jumps: true,
  __proto__: animal
};
// walk is taken from the prototype
rabbit.walk(); // Animal walk</code>
  The method is automatically taken from the prototype, like this:

<img src="https://javascript.info/article/prototype-inheritance/proto-animal-rabbit-walk.png">
The prototype chain can be longer:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let animal = {
  eats: true,
  walk() {
    alert(&quot;Animal walk&quot;);
  }
};
let rabbit = {
  jumps: true,
  __proto__: animal
};
let longEar = {
  earLength: 10,
  __proto__: rabbit
}
// walk is taken from the prototype chain
longEar.walk(); // Animal walk
alert(longEar.jumps); // true (from rabbit)</code>
  

<img src="https://javascript.info/article/prototype-inheritance/proto-animal-rabbit-chain.png">
There are actually only two limitations:

<li>The references can’t go in circles. 
JavaScript will throw an error if we try to assign <code>__proto__</code> in a circle.</li><li>The value of <code>__proto__</code> can be either an object or <code>null</code>. 
All other values (like primitives) are ignored.</li>

Also it may be obvious, but still: there can be only one <code>[[Prototype]]</code>. 
An object may not inherit from two others.

<h2>Read/write rules</h2>
The prototype is only used for reading properties.

For data properties (not getters/setters) write/delete operations work directly with the object.

In the example below, we assign its own <code>walk</code> method to <code>rabbit</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let animal = {
  eats: true,
  walk() {
    /* this method won't be used by rabbit */
  }
};
let rabbit = {
  __proto__: animal
}
rabbit.walk = function() {
  alert(&quot;Rabbit! Bounce-bounce!&quot;);
};
rabbit.walk(); // Rabbit! Bounce-bounce!</code>
  From now on, <code>rabbit.walk()</code> call finds the method immediately in the object and executes it, without using the prototype:

<img src="https://javascript.info/article/prototype-inheritance/proto-animal-rabbit-walk-2.png">
For getters/setters – if we read/write a property, they are looked up in the prototype and invoked.

For instance, check out <code>admin.fullName</code> property in the code below:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  name: &quot;John&quot;,
  surname: &quot;Smith&quot;,
  set fullName(value) {
    [this.name, this.surname] = value.split(&quot; &quot;);
  },
  get fullName() {
    return `${this.name} ${this.surname}`;
  }
};
let admin = {
  __proto__: user,
  isAdmin: true
};
alert(admin.fullName); // John Smith (*)
// setter triggers!
admin.fullName = &quot;Alice Cooper&quot;; // (**)</code>
  Here in the line <code>(*)</code> the property <code>admin.fullName</code> has a getter in the prototype <code>user</code>, so it is called. 
And in the line <code>(**)</code> the property has a setter in the prototype, so it is called.

<h2>The value of “this”</h2>
An interesting question may arise in the example above: what’s the value of <code>this</code> inside <code>set fullName(value)</code>? Where the properties <code>this.name</code> and <code>this.surname</code> are written: <code>user</code> or <code>admin</code>?

The answer is simple: <code>this</code> is not affected by prototypes at all.

<strong>No matter where the method is found: in an object or its prototype. 
In a method call, <code>this</code> is always the object before the dot.</strong>

So, the setter actually uses <code>admin</code> as <code>this</code>, not <code>user</code>.

That is actually a super-important thing, because we may have a big object with many methods and inherit from it. 
Then we can run its methods on inherited objects and they will modify the state of these objects, not the big one.

For instance, here <code>animal</code> represents a “method storage”, and <code>rabbit</code> makes use of it.

The call <code>rabbit.sleep()</code> sets <code>this.isSleeping</code> on the <code>rabbit</code> object:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// animal has methods
let animal = {
  walk() {
    if (!this.isSleeping) {
alert(`I walk`);
    }
  },
  sleep() {
    this.isSleeping = true;
  }
};
let rabbit = {
  name: &quot;White Rabbit&quot;,
  __proto__: animal
};
// modifies rabbit.isSleeping
rabbit.sleep();
alert(rabbit.isSleeping); // true
alert(animal.isSleeping); // undefined (no such property in the prototype)</code>
  The resulting picture:

<img src="https://javascript.info/article/prototype-inheritance/proto-animal-rabbit-walk-3.png">
If we had other objects like <code>bird</code>, <code>snake</code> etc inheriting from <code>animal</code>, they would also gain access to methods of <code>animal</code>. 
But <code>this</code> in each method would be the corresponding object, evaluated at the call-time (before dot), not <code>animal</code>. 
So when we write data into <code>this</code>, it is stored into these objects.

As a result, methods are shared, but the object state is not.

<h4><a name="summary" href="#summary">Summary</a></h4><li>In JavaScript, all objects have a hidden <code>[[Prototype]]</code> property that’s either another object or <code>null</code>.</li><li>We can use <code>obj.__proto__</code> to access it (there are other ways too, to be covered soon).</li><li>The object referenced by <code>[[Prototype]]</code> is called a “prototype”.</li><li>If we want to read a property of <code>obj</code> or call a method, and it doesn’t exist, then JavaScript tries to find it in the prototype. 
Write/delete operations work directly on the object, they don’t use the prototype (unless the property is actually a setter).</li><li>If we call <code>obj.method()</code>, and the <code>method</code> is taken from the prototype, <code>this</code> still references <code>obj</code>. 
So methods always work with the current object even if they are inherited.</li>

Which values are shown in the process?

    <code>let animal = {
  jumps: null
};
let rabbit = {
  __proto__: animal,
  jumps: true
};
alert( rabbit.jumps ); // ? (1)
delete rabbit.jumps;
alert( rabbit.jumps ); // ? (2)
delete animal.jumps;
alert( rabbit.jumps ); // ? (3)</code>
  There should be 3 answers.

<button type="button">solution</button>

<li><code>true</code>, taken from <code>rabbit</code>.</li><li><code>null</code>, taken from <code>animal</code>.</li><li><code>undefined</code>, there’s no such property any more.</li>

<button type="button" title="close"></button>

<h3><a href="#searching-algorithm" name="searching-algorithm">Searching algorithm</a></h3><a href="/task/search-algorithm" target="_blank"></a>

importance: 5

The task has two parts.

We have an object:

    <code>let head = {
  glasses: 1
};
let table = {
  pen: 3
};
let bed = {
  sheet: 1,
  pillow: 2
};
let pockets = {
  money: 2000
};</code>
  <li>Use <code>__proto__</code> to assign prototypes in a way that any property lookup will follow the path: <code>pockets</code> → <code>bed</code> → <code>table</code> → <code>head</code>. 
For instance, <code>pockets.pen</code> should be <code>3</code> (found in <code>table</code>), and <code>bed.glasses</code> should be <code>1</code> (found in <code>head</code>).</li><li>Answer the question: is it faster to get <code>glasses</code> as <code>pockets.glasses</code> or <code>head.glasses</code>? Benchmark if needed.</li>

<button type="button">solution</button>

<li>Let’s add <code>__proto__</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let head = {
  glasses: 1
};
let table = {
  pen: 3,
  __proto__: head
};
let bed = {
  sheet: 1,
  pillow: 2,
  __proto__: table
};
let pockets = {
  money: 2000,
  __proto__: bed
};
alert( pockets.pen ); // 3
alert( bed.glasses ); // 1
alert( table.money ); // undefined</code>
  </li><li>In modern engines, performance-wise, there’s no difference whether we take a property from an object or its prototype. 
They remember where the property was found and reuse it in the next request.

For instance, for <code>pockets.glasses</code> they remember where they found <code>glasses</code> (in <code>head</code>), and next time will search right there. 
They are also smart enough to update internal caches if something changes, so that optimization is safe.

</li>

<button type="button" title="close"></button>

<h3><a href="#where-it-writes" name="where-it-writes">Where it writes?</a></h3><a href="/task/proto-and-this" target="_blank"></a>

importance: 5

We have <code>rabbit</code> inheriting from <code>animal</code>.

If we call <code>rabbit.eat()</code>, which object receives the <code>full</code> property: <code>animal</code> or <code>rabbit</code>?

    <code>let animal = {
  eat() {
    this.full = true;
  }
};
let rabbit = {
  __proto__: animal
};
rabbit.eat();</code>
  <button type="button">solution</button>

<strong>The answer: <code>rabbit</code>.</strong>

That’s because <code>this</code> is an object before the dot, so <code>rabbit.eat()</code> modifies <code>rabbit</code>.

Property lookup and execution are two different things.
The method <code>rabbit.eat</code> is first found in the prototype, then executed with <code>this=rabbit</code>

<button type="button" title="close"></button>

<h3><a href="#why-two-hamsters-are-full" name="why-two-hamsters-are-full">Why two hamsters are full?</a></h3><a href="/task/hamster-proto" target="_blank"></a>

importance: 5

We have two hamsters: <code>speedy</code> and <code>lazy</code> inheriting from the general <code>hamster</code> object.

When we feed one of them, the other one is also full. 
Why? How to fix it?

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let hamster = {
  stomach: [],
  eat(food) {
    this.stomach.push(food);
  }
};
let speedy = {
  __proto__: hamster
};
let lazy = {
  __proto__: hamster
};
// This one found the food
speedy.eat(&quot;apple&quot;);
alert( speedy.stomach ); // apple
// This one also has it, why? fix please.
alert( lazy.stomach ); // apple</code>
  <button type="button">solution</button>

Let’s look carefully at what’s going on in the call <code>speedy.eat(&quot;apple&quot;)</code>.

<li>The method <code>speedy.eat</code> is found in the prototype (<code>=hamster</code>), then executed with <code>this=speedy</code> (the object before the dot).

</li><li>Then <code>this.stomach.push()</code> needs to find <code>stomach</code> property and call <code>push</code> on it. 
It looks for <code>stomach</code> in <code>this</code> (<code>=speedy</code>), but nothing found.

</li><li>Then it follows the prototype chain and finds <code>stomach</code> in <code>hamster</code>.

</li><li>Then it calls <code>push</code> on it, adding the food into <em>the stomach of the prototype</em>.

</li>

So all hamsters share a single stomach!

Every time the <code>stomach</code> is taken from the prototype, then <code>stomach.push</code> modifies it “at place”.

Please note that such thing doesn’t happen in case of a simple assignment <code>this.stomach=</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let hamster = {
  stomach: [],
  eat(food) {
    // assign to this.stomach instead of this.stomach.push
    this.stomach = [food];
  }
};
let speedy = {
   __proto__: hamster
};
let lazy = {
  __proto__: hamster
};
// Speedy one found the food
speedy.eat(&quot;apple&quot;);
alert( speedy.stomach ); // apple
// Lazy one's stomach is empty
alert( lazy.stomach ); // &lt;nothing&gt;</code>
  Now all works fine, because <code>this.stomach=</code> does not perform a lookup of <code>stomach</code>. 
The value is written directly into <code>this</code> object.

Also we can totally evade the problem by making sure that each hamster has his own stomach:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let hamster = {
  stomach: [],
  eat(food) {
    this.stomach.push(food);
  }
};
let speedy = {
  __proto__: hamster,
  stomach: []
};
let lazy = {
  __proto__: hamster,
  stomach: []
};
// Speedy one found the food
speedy.eat(&quot;apple&quot;);
alert( speedy.stomach ); // apple
// Lazy one's stomach is empty
alert( lazy.stomach ); // &lt;nothing&gt;</code>
  As a common solution, all properties that describe the state of a particular object, like <code>stomach</code> above, are usually written into that object. 
That prevents such problems.

<button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/property-accessors" data-tooltip="Property getters and setters">Previous lesson</a><a href="/function-prototype" data-tooltip="F.prototype">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Fprototype-inheritance"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Fprototype-inheritance"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Fprototype-inheritance"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Fprototype-inheritance"></a>

In modern JavaScript we can set a prototype using <code>__proto__</code>, as described in the previous article. 
But it wasn’t like that all the time.

JavaScript has had prototypal inheritance from the beginning. 
It was one of the core features of the language.

But in the old times, there was another (and the only) way to set it: to use a <code>&quot;prototype&quot;</code> property of the constructor function. 
And there are still many scripts that use it.

<h2>The “prototype” property</h2>
As we know already, <code>new F()</code> creates a new object.

When a new object is created with <code>new F()</code>, the object’s <code>[[Prototype]]</code> is set to <code>F.prototype</code>.

In other words, if <code>F</code> has a <code>prototype</code> property with a value of the object type, then <code>new</code> operator uses it to set <code>[[Prototype]]</code> for the new object.

Please note that <code>F.prototype</code> here means a regular property named <code>&quot;prototype&quot;</code> on <code>F</code>. 
It sounds something similar to the term “prototype”, but here we really mean a regular property with this name.

Here’s the example:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let animal = {
  eats: true
};
function Rabbit(name) {
  this.name = name;
}
Rabbit.prototype = animal;
let rabbit = new Rabbit(&quot;White Rabbit&quot;); //  rabbit.__proto__ == animal
alert( rabbit.eats ); // true</code>
  Setting <code>Rabbit.prototype = animal</code> literally states the following: &quot;When a <code>new Rabbit</code> is created, assign its <code>[[Prototype]]</code> to <code>animal</code>&quot;.

That’s the resulting picture:

<img src="https://javascript.info/article/function-prototype/proto-constructor-animal-rabbit.png">
On the picture, <code>&quot;prototype&quot;</code> is a horizontal arrow, it’s a regular property, and <code>[[Prototype]]</code> is vertical, meaning the inheritance of <code>rabbit</code> from <code>animal</code>.

<h2>Default F.prototype, constructor property</h2>
Every function has the <code>&quot;prototype&quot;</code> property even if we don’t supply it.

The default <code>&quot;prototype&quot;</code> is an object with the only property <code>constructor</code> that points back to the function itself.

Like this:

    <code>function Rabbit() {}
/* default prototype
Rabbit.prototype = { constructor: Rabbit };
*/</code>
  

<img src="https://javascript.info/article/function-prototype/function-prototype-constructor.png">
We can check it:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function Rabbit() {}
// by default:
// Rabbit.prototype = { constructor: Rabbit }
alert( Rabbit.prototype.constructor == Rabbit ); // true</code>
  Naturally, if we do nothing, the <code>constructor</code> property is available to all rabbits through  <code>[[Prototype]]</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function Rabbit() {}
// by default:
// Rabbit.prototype = { constructor: Rabbit }
let rabbit = new Rabbit(); // inherits from {constructor: Rabbit}
alert(rabbit.constructor == Rabbit); // true (from prototype)</code>
  

<img src="https://javascript.info/article/function-prototype/rabbit-prototype-constructor.png">
We can use <code>constructor</code> property to create a new object using the same constructor as the existing one.

Like here:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function Rabbit(name) {
  this.name = name;
  alert(name);
}
let rabbit = new Rabbit(&quot;White Rabbit&quot;);
let rabbit2 = new rabbit.constructor(&quot;Black Rabbit&quot;);</code>
  That’s handy when we have an object, don’t know which constructor was used for it (e.g. 
it comes from a 3rd party library), and we need to create another one of the same kind.

But probably the most important thing about <code>&quot;constructor&quot;</code> is that…

<strong>…JavaScript itself does not ensure the right <code>&quot;constructor&quot;</code> value.</strong>

Yes, it exists in the default <code>&quot;prototype&quot;</code> for functions, but that’s all. 
What happens with it later – is totally on us.

In particular, if we replace the default prototype as a whole, then there will be no <code>&quot;constructor&quot;</code> in it.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function Rabbit() {}
Rabbit.prototype = {
  jumps: true
};
let rabbit = new Rabbit();
alert(rabbit.constructor === Rabbit); // false</code>
  So, to keep the right <code>&quot;constructor&quot;</code> we can choose to add/remove properties to the default <code>&quot;prototype&quot;</code> instead of overwriting it as a whole:

    <code>function Rabbit() {}
// Not overwrite Rabbit.prototype totally
// just add to it
Rabbit.prototype.jumps = true
// the default Rabbit.prototype.constructor is preserved</code>
  Or, alternatively, recreate the <code>constructor</code> property it manually:

    <code>Rabbit.prototype = {
  jumps: true,
  constructor: Rabbit
};
// now constructor is also correct, because we added it</code>
  <h4><a name="summary" href="#summary">Summary</a4</h2>
In this chapter we briefly described the way of setting a <code>[[Prototype]]</code> for objects created via a constructor function. 
Later we’ll see more advanced programming patterns that rely on it.

Everything is quite simple, just few notes to make things clear:

<li>The <code>F.prototype</code> property is not the same as <code>[[Prototype]]</code>. 
The only thing <code>F.prototype</code> does: it sets <code>[[Prototype]]</code> of new objects when <code>new F()</code> is called.</li><li>The value of <code>F.prototype</code> should be either an object or null: other values won’t work.</li><li>The <code>&quot;prototype&quot;</code> property only has such a special effect when is set to a constructor function, and invoked with <code>new</code>.</li>

On regular objects the <code>prototype</code> is nothing special:

    <code>let user = {
  name: &quot;John&quot;,
  prototype: &quot;Bla-bla&quot; // no magic at all
};</code>
  By default all functions have <code>F.prototype = { constructor: F }</code>, so we can get the constructor of an object by accessing its <code>&quot;constructor&quot;</code> property.

In the start, we have this code:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function Rabbit() {}
Rabbit.prototype = {
  eats: true
};
let rabbit = new Rabbit();
alert( rabbit.eats ); // true</code>
  <li>We added one more string (emphasized), what <code>alert</code> shows now?

    <code>function Rabbit() {}
Rabbit.prototype = {
  eats: true
};
let rabbit = new Rabbit();
Rabbit.prototype = {};
alert( rabbit.eats ); // ?</code>
  </li><li>…And if the code is like this (replaced one line)?

    <code>function Rabbit() {}
Rabbit.prototype = {
  eats: true
};
let rabbit = new Rabbit();
Rabbit.prototype.eats = false;
alert( rabbit.eats ); // ?</code>
  </li><li>Like this (replaced one line)?

    <code>function Rabbit() {}
Rabbit.prototype = {
  eats: true
};
let rabbit = new Rabbit();
delete rabbit.eats;
alert( rabbit.eats ); // ?</code>
  </li><li>The last variant:

    <code>function Rabbit() {}
Rabbit.prototype = {
  eats: true
};
let rabbit = new Rabbit();
delete Rabbit.prototype.eats;
alert( rabbit.eats ); // ?</code>
  </li>

<button type="button">solution</button>

Answers:

<li><code>true</code>.

The assignment to <code>Rabbit.prototype</code> sets up <code>[[Prototype]]</code> for new objects, but it does not affect the existing ones.

</li><li><code>false</code>.

Objects are assigned by reference. 
The object from <code>Rabbit.prototype</code> is not duplicated, it’s still a single object is referenced both by <code>Rabbit.prototype</code> and by the <code>[[Prototype]]</code> of <code>rabbit</code>.

So when we change its content through one reference, it is visible through the other one.

</li><li><code>true</code>.

All <code>delete</code> operations are applied directly to the object. 
Here <code>delete rabbit.eats</code> tries to remove <code>eats</code> property from <code>rabbit</code>, but it doesn’t have it. 
So the operation won’t have any effect.

</li><li><code>undefined</code>.

The property <code>eats</code> is deleted from the prototype, it doesn’t exist any more.

</li>

<button type="button" title="close"></button>

<h3><a href="#create-an-object-with-the-same-constructor" name="create-an-object-with-the-same-constructor">Create an object with the same constructor</a></h3><a href="/task/new-object-same-constructor" target="_blank"></a>

importance: 5

Imagine, we have an arbitrary object <code>obj</code>, created by a constructor function – we don’t know which one, but we’d like to create a new object using it.

Can we do it like that?

    <code>let obj2 = new obj.constructor();</code>
  Give an example of a constructor function for <code>obj</code> which lets such code work right. 
And an example that makes it work wrong.

<button type="button">solution</button>

We can use such approach if we are sure that <code>&quot;constructor&quot;</code> property has the correct value.

For instance, if we don’t touch the default <code>&quot;prototype&quot;</code>, then this code works for sure:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function User(name) {
  this.name = name;
}
let user = new User('John');
let user2 = new user.constructor('Pete');
alert( user2.name ); // Pete (worked!)</code>
  It worked, because <code>User.prototype.constructor == User</code>.

…But if someone, so to say, overwrites <code>User.prototype</code> and forgets to recreate <code>&quot;constructor&quot;</code>, then it would fail.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function User(name) {
  this.name = name;
}
User.prototype = {}; // (*)
let user = new User('John');
let user2 = new user.constructor('Pete');
alert( user2.name ); // undefined</code>
  Why <code>user2.name</code> is <code>undefined</code>?

Here’s how <code>new user.constructor('Pete')</code> works:

<li>First, it looks for <code>constructor</code> in <code>user</code>. 
Nothing.</li><li>Then it follows the prototype chain. 
The prototype of <code>user</code> is <code>User.prototype</code>, and it also has nothing.</li><li>The value of <code>User.prototype</code> is a plain object <code>{}</code>, its prototype is <code>Object.prototype</code>. 
And there is <code>Object.prototype.constructor == Object</code>. 
So it is used.</li>

At the end, we have <code>let user2 = new Object('Pete')</code>. 
The built-in <code>Object</code> constructor ignores arguments, it always creates an empty object – that’s what we have in <code>user2</code> after all.

<button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/prototype-inheritance" data-tooltip="Prototypal inheritance">Previous lesson</a><a href="/native-prototypes" data-tooltip="Native prototypes">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Ffunction-prototype"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Ffunction-prototype"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Ffunction-prototype"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Ffunction-prototype"></a>

The <code>&quot;prototype&quot;</code> property is widely used by the core of JavaScript itself. 
All built-in constructor functions use it.

We’ll see how it is for plain objects first, and then for more complex ones.

<h2>Object.prototype</h2>
Let’s say we output an empty object:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let obj = {};
alert( obj ); // &quot;[object Object]&quot; ?</code>
  Where’s the code that generates the string <code>&quot;[object Object]&quot;</code>? That’s a built-in <code>toString</code> method, but where is it? The <code>obj</code> is empty!

…But the short notation <code>obj = {}</code> is the same as <code>obj = new Object()</code>, where <code>Object</code> – is a built-in object constructor function. 
And that function has <code>Object.prototype</code> that references a huge object with <code>toString</code> and other functions.

Like this (all that is built-in):

<img src="https://javascript.info/article/native-prototypes/object-prototype.png">
When <code>new Object()</code> is called (or a literal object <code>{...}</code> is created), the <code>[[Prototype]]</code> of it is set to <code>Object.prototype</code> by the rule that we’ve discussed in the previous chapter:

<img src="https://javascript.info/article/native-prototypes/object-prototype-1.png">
Afterwards when <code>obj.toString()</code> is called – the method is taken from <code>Object.prototype</code>.

We can check it like this:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let obj = {};
alert(obj.__proto__ === Object.prototype); // true
// obj.toString === obj.__proto__.toString == Object.prototype.toString</code>
  Please note that there is no additional <code>[[Prototype]]</code> in the chain above <code>Object.prototype</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>alert(Object.prototype.__proto__); // null</code>
  <h2>Other built-in prototypes</h2>
Other built-in objects such as <code>Array</code>, <code>Date</code>, <code>Function</code> and others also keep methods in prototypes.

For instance, when we create an array <code>[1, 2, 3]</code>, the default <code>new Array()</code> constructor is  used internally. 
So the array data is written into the new object, and <code>Array.prototype</code> becomes its prototype and provides methods. 
That’s very memory-efficient.

By specification, all built-in prototypes have <code>Object.prototype</code> on the top. 
Sometimes people say that “everything inherits from objects”.

Here’s the overall picture (for 3 built-ins to fit):

<img src="https://javascript.info/article/native-prototypes/native-prototypes-classes.png">
Let’s check the prototypes manually:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let arr = [1, 2, 3];
// it inherits from Array.prototype?
alert( arr.__proto__ === Array.prototype ); // true
// then from Object.prototype?
alert( arr.__proto__.__proto__ === Object.prototype ); // true
// and null on the top.
alert( arr.__proto__.__proto__.__proto__ ); // null</code>
  Some methods in prototypes may overlap, for instance, <code>Array.prototype</code> has its own <code>toString</code> that lists comma-delimited elements:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let arr = [1, 2, 3]
alert(arr); // 1,2,3 &lt;-- the result of Array.prototype.toString</code>
  As we’ve seen before, <code>Object.prototype</code> has <code>toString</code> as well, but <code>Array.prototype</code> is closer in the chain, so the array variant is used.

<img src="https://javascript.info/article/native-prototypes/native-prototypes-array-tostring.png">
In-browser tools like Chrome developer console also show inheritance (may need to use <code>console.dir</code> for built-in objects):

<img src="https://javascript.info/article/native-prototypes/console_dir_array.png">
Other built-in objects also work the same way. 
Even functions. 
They are objects of a built-in <code>Function</code> constructor, and their methods: <code>call/apply</code> and others are taken from <code>Function.prototype</code>. 
Functions have their own <code>toString</code> too.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function f() {}
alert(f.__proto__ == Function.prototype); // true
alert(f.__proto__.__proto__ == Object.prototype); // true, inherit from objects</code>
  <h2>Primitives</h2>
The most intricate thing happens with strings, numbers and booleans.

As we remember, they are not objects. 
But if we try to access their properties, then temporary wrapper objects are created using built-in constructors <code>String</code>, <code>Number</code>, <code>Boolean</code>, they provide the methods and disappear.

These objects are created invisibly to us and most engines optimize them out, but the specification describes it exactly this way. 
Methods of these objects also reside in prototypes, available as <code>String.prototype</code>, <code>Number.prototype</code> and <code>Boolean.prototype</code>.

Values <code>null</code> and <code>undefined</code> have no object wrappers
Special values <code>null</code> and <code>undefined</code> stand apart. 
They have no object wrappers, so methods and properties are not available for them. 
And there are no corresponding prototypes too.

<h2>Changing native prototypes</h2>
Native prototypes can be modified. 
For instance, if we add a method to <code>String.prototype</code>,  it becomes available to all strings:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>String.prototype.show = function() {
  alert(this);
};
&quot;BOOM!&quot;.show(); // BOOM!</code>
  During the process of development we may have ideas which new built-in methods we’d like to have. 
And there may be a slight temptation to add them to native prototypes. 
But that is generally a bad idea.

Prototypes are global, so it’s easy to get a conflict. 
If two libraries add a method <code>String.prototype.show</code>, then one of them overwrites the other one.

In modern programming, there is only one case when modifying native prototypes is approved. 
That’s polyfills. 
In other words, if there’s a method in JavaScript specification that is not yet supported by our JavaScript engine (or any of those that we want to support), then may implement it manually and populate the built-in prototype with it.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>if (!String.prototype.repeat) { // if there's no such method
  // add it to the prototype
  String.prototype.repeat = function(n) {
    // repeat the string n times
    // actually, the code should be more complex than that,
    // throw errors for negative values of &quot;n&quot;
    // the full algorithm is in the specification
    return new Array(n + 1).join(this);
  };
}
alert( &quot;La&quot;.repeat(3) ); // LaLaLa</code>
  <h2>Borrowing from prototypes</h2>
In the chapter <a href="/call-apply-decorators#method-borrowing">Decorators and forwarding, call/apply</a> we talked about method borrowing:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function showArgs() {
  // borrow join from array and call in the context of arguments
  alert( [].join.call(arguments, &quot; - &quot;) );
}
showArgs(&quot;John&quot;, &quot;Pete&quot;, &quot;Alice&quot;); // John - Pete - Alice</code>
  Because <code>join</code> resides in <code>Array.prototype</code>, we can call it from there directly and rewrite it as:

    <code>function showArgs() {
  alert( Array.prototype.join.call(arguments, &quot; - &quot;) );
}</code>
  That’s more efficient, because it avoids the creation of an extra array object <code>[]</code>. 
On the other hand, it is longer to write.

<h4><a name="summary" href="#summary">Summary</a></h4><li>All built-in objects follow the same pattern:
<li>The methods are stored in the prototype (<code>Array.prototype</code>, <code>Object.prototype</code>, <code>Date.prototype</code> etc).</li><li>The object itself stores only the data (array items, object properties, the date).</li>

</li><li>Primitives also store methods in prototypes of wrapper objects: <code>Number.prototype</code>, <code>String.prototype</code>, <code>Boolean.prototype</code>. 
There are no wrapper objects only for <code>undefined</code> and <code>null</code>.</li><li>Built-in prototypes can be modified or populated with new methods. 
But it’s not recommended to change them. 
Probably the only allowable cause is when we add-in a new standard, but not yet supported by the engine JavaScript method.</li>

After you do it, such code should work:

    <code>function f() {
  alert(&quot;Hello!&quot;);
}
f.defer(1000); // shows &quot;Hello!&quot; after 1 second</code>
  <button type="button">solution</button>

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>Function.prototype.defer = function(ms) {
  setTimeout(this, ms);
};
function f() {
  alert(&quot;Hello!&quot;);
}
f.defer(1000); // shows &quot;Hello!&quot; after 1 sec</code>
  <button type="button" title="close"></button>

<h3><a href="#add-the-decorating-defer-to-functions" name="add-the-decorating-defer-to-functions">Add the decorating &quot;defer()&quot; to functions</a></h3><a href="/task/defer-to-prototype-extended" target="_blank"></a>

importance: 4

Add to the prototype of all functions the method <code>defer(ms)</code>, that returns a wrapper, delaying the call by <code>ms</code> milliseconds.

Here’s an example of how it should work:

    <code>function f(a, b) {
  alert( a + b );
}
f.defer(1000)(1, 2); // shows 3 after 1 second</code>
  Please note that the arguments should be passed to the original function.

<button type="button">solution</button>

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>Function.prototype.defer = function(ms) {
  let f = this;
  return function(...args) {
    setTimeout(() =&gt; f.apply(this, args), ms);
  }
};
// check it
function f(a, b) {
  alert( a + b );
}
f.defer(1000)(1, 2); // shows 3 after 1 sec</code>
  <button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/function-prototype" data-tooltip="F.prototype">Previous lesson</a><a href="/prototype-methods" data-tooltip="Methods for prototypes">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Fnative-prototypes"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Fnative-prototypes"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Fnative-prototypes"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Fnative-prototypes"></a>

In this chapter we cover additional methods to work with a prototype.

There are also other ways to get/set a prototype, besides those that we already know:

<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create">Object.create(proto[, descriptors])</a> – creates an empty object with given <code>proto</code> as <code>[[Prototype]]</code> and optional property descriptors.</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf">Object.getPrototypeOf(obj)</a> – returns the <code>[[Prototype]]</code> of <code>obj</code>.</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf">Object.setPrototypeOf(obj, proto)</a> – sets the <code>[[Prototype]]</code> of <code>obj</code> to <code>proto</code>.</li>

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let animal = {
  eats: true
};
// create a new object with animal as a prototype
let rabbit = Object.create(animal);
alert(rabbit.eats); // true
alert(Object.getPrototypeOf(rabbit) === animal); // get the prototype of rabbit
Object.setPrototypeOf(rabbit, {}); // change the prototype of rabbit to {}</code>
  <code>Object.create</code> has an optional second argument: property descriptors. 
We can provide additional properties to the new object there, like this:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let animal = {
  eats: true
};
let rabbit = Object.create(animal, {
  jumps: {
    value: true
  }
});
alert(rabbit.jumps); // true</code>
  The descriptors are in the same format as described in the chapter <a href="/property-descriptors">Property flags and descriptors</a>.

We can use <code>Object.create</code> to perform an object cloning more powerful than copying properties in <code>for..in</code>:

    <code>// fully identical shallow clone of obj
let clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));</code>
  This call makes a truly exact copy of <code>obj</code>, including all properties: enumerable and non-enumerable, data properties and setters/getters – everything, and with the right <code>[[Prototype]]</code>.

<h2>Brief history</h2>
If we count all the ways to manage <code>[[Prototype]]</code>, there’s a lot! Many ways to do the same!

Why so?

That’s for historical reasons.

<li>The <code>&quot;prototype&quot;</code> property of a constructor function works since very ancient times.</li><li>Later in the year 2012: <code>Object.create</code> appeared in the standard. 
It allowed to create objects with the given prototype, but did not allow to get/set it. 
So browsers implemented non-standard <code>__proto__</code> accessor that allowed to get/set a prototype at any time.</li><li>Later in the year 2015: <code>Object.setPrototypeOf</code> and <code>Object.getPrototypeOf</code> were added to the standard. 
The <code>__proto__</code> was de-facto implemented everywhere, so it made its way to the Annex B of the standard, that is optional for non-browser environments.</li>

As of now we have all these ways at our disposal.

Technically, we can get/set <code>[[Prototype]]</code> at any time. 
But usually we only set it once at the object creation time, and then do not modify: <code>rabbit</code> inherits from <code>animal</code>, and that is not going to change. 
And JavaScript engines are highly optimized to that. 
Changing a prototype “on-the-fly” with <code>Object.setPrototypeOf</code> or <code>obj.__proto__=</code> is a very slow operation. 
But it is possible.

<h2>“Very plain” objects</h2>
As we know, objects can be used as associative arrays to store key/value pairs.

…But if we try to store <em>user-provided</em> keys in it (for instance, a user-entered dictionary), we can see an interesting glitch: all keys work fine except <code>&quot;__proto__&quot;</code>.

Check out the example:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let obj = {};
let key = prompt(&quot;What's the key?&quot;, &quot;__proto__&quot;);
obj[key] = &quot;some value&quot;;
alert(obj[key]); // [object Object], not &quot;some value&quot;!</code>
  Here if the user types in <code>__proto__</code>, the assignment is ignored!

That shouldn’t surprise us. 
The <code>__proto__</code> property is special: it must be either an object or <code>null</code>, a string can not become a prototype.

But we did not intend to implement such behavior, right? We want to store key/value pairs, and the key named <code>&quot;__proto__&quot;</code> was not properly saved. 
So that’s a bug. 
Here the consequences are not terrible. 
But in other cases the prototype may indeed be changed, so the execution may go wrong in totally unexpected ways.

What’s worst – usually developers do not think about such possibility at all. 
That makes such bugs hard to notice and even turn them into vulnerabilities, especially when JavaScript is used on server-side.

Such thing happens only with <code>__proto__</code>. 
All other properties are “assignable” normally.

How to evade the problem?

First, we can just switch to using <code>Map</code>, then everything’s fine.

But <code>Object</code> also can serve us well here, because language creators gave a thought to that problem long ago.

The <code>__proto__</code> is not a property of an object, but an accessor property of <code>Object.prototype</code>:

<img src="https://javascript.info/article/prototype-methods/object-prototype-2.png">
So, if <code>obj.__proto__</code> is read or assigned, the corresponding getter/setter is called from its prototype, and it gets/sets <code>[[Prototype]]</code>.

As it was said in the beginning: <code>__proto__</code> is a way to access <code>[[Prototype]]</code>, it is not <code>[[Prototype]]</code> itself.

Now, if we want to use an object as an associative array, we can do it with a little trick:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let obj = Object.create(null);
let key = prompt(&quot;What's the key?&quot;, &quot;__proto__&quot;);
obj[key] = &quot;some value&quot;;
alert(obj[key]); // &quot;some value&quot;</code>
  <code>Object.create(null)</code> creates an empty object without a prototype (<code>[[Prototype]]</code> is <code>null</code>):

<img src="https://javascript.info/article/prototype-methods/object-prototype-null.png">
So, there is no inherited getter/setter for <code>__proto__</code>. 
Now it is processed as a regular data property, so the example above works right.

We can call such object “very plain” or “pure dictionary objects”, because they are even simpler than regular plain object <code>{...}</code>.

A downside is that such objects lack any built-in object methods, e.g. 
<code>toString</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let obj = Object.create(null);
alert(obj); // Error (no toString)</code>
  …But that’s usually fine for associative arrays.

Please note that most object-related methods are <code>Object.something(...)</code>, like <code>Object.keys(obj)</code> – they are not in the prototype, so they will keep working on such objects:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let chineseDictionary = Object.create(null);
chineseDictionary.hello = &quot;ni hao&quot;;
chineseDictionary.bye = &quot;zai jian&quot;;
alert(Object.keys(chineseDictionary)); // hello,bye</code>
  <h2>Getting all properties</h2>
There are many ways to get keys/values from an object.

We already know these ones:

<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys">Object.keys(obj)</a> / <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values">Object.values(obj)</a> / <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries">Object.entries(obj)</a> – returns an array of enumerable own string property names/values/key-value pairs. 
These methods only list <em>enumerable</em> properties, and those that have <em>strings as keys</em>.</li>

If we want symbolic properties:

<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols">Object.getOwnPropertySymbols(obj)</a> – returns an array of all own symbolic property names.</li>

If we want non-enumerable properties:

<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames">Object.getOwnPropertyNames(obj)</a> – returns an array of all own string property names.</li>

If we want <em>all</em> properties:

<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys">Reflect.ownKeys(obj)</a> – returns an array of all own property names.</li>

These methods are a bit different about which properties they return, but all of them operate on the object itself. 
Properties from the prototype are not listed.

The <code>for..in</code> loop is different: it loops over inherited properties too.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let animal = {
  eats: true
};
let rabbit = {
  jumps: true,
  __proto__: animal
};
// only own keys
alert(Object.keys(rabbit)); // jumps
// inherited keys too
for(let prop in rabbit) alert(prop); // jumps, then eats</code>
  If we want to distinguish inherited properties, there’s a built-in method <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty">obj.hasOwnProperty(key)</a>: it returns <code>true</code> if <code>obj</code> has its own (not inherited) property named <code>key</code>.

So we can filter out inherited properties (or do something else with them):

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let animal = {
  eats: true
};
let rabbit = {
  jumps: true,
  __proto__: animal
};
for(let prop in rabbit) {
  let isOwn = rabbit.hasOwnProperty(prop);
  alert(`${prop}: ${isOwn}`); // jumps:true, then eats:false
}</code>
  Here we have the following inheritance chain: <code>rabbit</code>, then <code>animal</code>, then <code>Object.prototype</code> (because <code>animal</code> is a literal object <code>{...}</code>, so it’s by default), and then <code>null</code> above it:

<img src="https://javascript.info/article/prototype-methods/rabbit-animal-object.png">
Note, there’s one funny thing. 
Where is the method <code>rabbit.hasOwnProperty</code> coming from? Looking at the chain we can see that the method is provided by <code>Object.prototype.hasOwnProperty</code>. 
In other words, it’s inherited.

…But why <code>hasOwnProperty</code> does not appear in <code>for..in</code> loop, if it lists all inherited properties?  The answer is simple: it’s not enumerable. 
Just like all other properties of <code>Object.prototype</code>. 
That’s why they are not listed.

<h4><a name="summary" href="#summary">Summary</a4</h2>
Here’s a brief list of methods we discussed in this chapter – as a recap:

<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create">Object.create(proto[, descriptors])</a> – creates an empty object with given <code>proto</code> as <code>[[Prototype]]</code> (can be <code>null</code>) and optional property descriptors.</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object.getPrototypeOf">Object.getPrototypeOf(obj)</a> – returns the <code>[[Prototype]]</code> of <code>obj</code> (same as <code>__proto__</code> getter).</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object.setPrototypeOf">Object.setPrototypeOf(obj, proto)</a> – sets the <code>[[Prototype]]</code> of <code>obj</code> to <code>proto</code> (same as <code>__proto__</code> setter).</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys">Object.keys(obj)</a> / <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values">Object.values(obj)</a> / <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries">Object.entries(obj)</a> – returns an array of enumerable own string property names/values/key-value pairs.</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols">Object.getOwnPropertySymbols(obj)</a> – returns an array of all own symbolic property names.</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames">Object.getOwnPropertyNames(obj)</a> – returns an array of all own string property names.</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys">Reflect.ownKeys(obj)</a> – returns an array of all own property names.</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty">obj.hasOwnProperty(key)</a>: it returns <code>true</code> if <code>obj</code> has its own (not inherited) property named <code>key</code>.</li>

We also made it clear that <code>__proto__</code> is a getter/setter for <code>[[Prototype]]</code> and resides in <code>Object.prototype</code>, just as other methods.

We can create an object without a prototype by <code>Object.create(null)</code>. 
Such objects are used as “pure dictionaries”, they have no issues with <code>&quot;__proto__&quot;</code> as the key.

All methods that return object properties (like <code>Object.keys</code> and others) – return “own” properties. 
If we want inherited ones, then we can use <code>for..in</code>.

Add method <code>dictionary.toString()</code> into it, that should return a comma-delimited list of keys. 
Your <code>toString</code> should not show up in <code>for..in</code> over the object.

Here’s how it should work:

    <code>let dictionary = Object.create(null);
// your code to add dictionary.toString method
// add some data
dictionary.apple = &quot;Apple&quot;;
dictionary.__proto__ = &quot;test&quot;; // __proto__ is a regular property key here
// only apple and __proto__ are in the loop
for(let key in dictionary) {
  alert(key); // &quot;apple&quot;, then &quot;__proto__&quot;
}
// your toString in action
alert(dictionary); // &quot;apple,__proto__&quot;</code>
  <button type="button">solution</button>

The method can take all enumerable keys using <code>Object.keys</code> and output their list.

To make <code>toString</code> non-enumerable, let’s define it using a property descriptor. 
The syntax of <code>Object.create</code> allows to provide an object with property descriptors as the second argument.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let dictionary = Object.create(null, {
  toString: { // define toString property
    value() { // the value is a function
return Object.keys(this).join();
    }
  }
});
dictionary.apple = &quot;Apple&quot;;
dictionary.__proto__ = &quot;test&quot;;
// apple and __proto__ is in the loop
for(let key in dictionary) {
  alert(key); // &quot;apple&quot;, then &quot;__proto__&quot;
}
// comma-separated list of properties by toString
alert(dictionary); // &quot;apple,__proto__&quot;</code>
  When we create a property using a descriptor, its flags are <code>false</code> by default. 
So in the code above, <code>dictionary.toString</code> is non-enumerable.

<button type="button" title="close"></button>

<h3><a href="#the-difference-beteeen-calls" name="the-difference-beteeen-calls">The difference beteeen calls</a></h3><a href="/task/compare-calls" target="_blank"></a>

importance: 5

Let’s create a new <code>rabbit</code> object:

    <code>function Rabbit(name) {
  this.name = name;
}
Rabbit.prototype.sayHi = function() {
  alert(this.name);
};
let rabbit = new Rabbit(&quot;Rabbit&quot;);</code>
  These calls do the same thing or not?

    <code>rabbit.sayHi();
Rabbit.prototype.sayHi();
Object.getPrototypeOf(rabbit).sayHi();
rabbit.__proto__.sayHi();</code>
  <button type="button">solution</button>

The first call has <code>this == rabbit</code>, the other ones have <code>this</code> equal to <code>Rabbit.prototype</code>, because it’s actually the object before the dot.

So only the first call shows <code>Rabbit</code>, other ones show <code>undefined</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function Rabbit(name) {
  this.name = name;
}
Rabbit.prototype.sayHi = function() {
  alert( this.name );
}
let rabbit = new Rabbit(&quot;Rabbit&quot;);
rabbit.sayHi();                        // Rabbit
Rabbit.prototype.sayHi();              // undefined
Object.getPrototypeOf(rabbit).sayHi(); // undefined
rabbit.__proto__.sayHi();              // undefined</code>
  <button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/native-prototypes" data-tooltip="Native prototypes">Previous lesson</a><a href="/class-patterns" data-tooltip="Class patterns">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Fprototype-methods"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Fprototype-methods"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Fprototype-methods"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Fprototype-methods"></a>

<blockquote>

In object-oriented programming, a <em>class</em> is an extensible program-code-template for creating objects, providing initial values for state (member variables) and implementations of behavior (member functions or methods).

<footer>
  <cite>Wikipedia</cite>
 </footer></blockquote>
There’s a special syntax construct and a keyword <code>class</code> in JavaScript. 
But before studying it, we should consider that the term “class” comes from the theory of object-oriented programming. 
The definition is cited above, and it’s language-independent.

In JavaScript there are several well-known programming patterns to make classes even without using the <code>class</code> keyword. 
And here we’ll talk about them first.

The <code>class</code> construct will be described in the next chapter, but in JavaScript it’s a “syntax sugar” and an extension of one of the patterns that we’ll study here.

<h2>Functional class pattern</h2>
The constructor function below can be considered a “class” according to the definition:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function User(name) {
  this.sayHi = function() {
    alert(name);
  };
}
let user = new User(&quot;John&quot;);
user.sayHi(); // John</code>
  It follows all parts of the definition:

<li>It is a “program-code-template” for creating objects (callable with <code>new</code>).</li><li>It provides initial values for the state (<code>name</code> from parameters).</li><li>It provides methods (<code>sayHi</code>).</li>

This is called <em>functional class pattern</em>.

In the functional class pattern, local variables and nested functions inside <code>User</code>, that are not assigned to <code>this</code>, are visible from inside, but not accessible by the outer code.

So we can easily add internal functions and variables, like <code>calcAge()</code> here:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function User(name, birthday) {
  // only visible from other methods inside User
  function calcAge() {
    return new Date().getFullYear() - birthday.getFullYear();
  }
  this.sayHi = function() {
    alert(`${name}, age:${calcAge()}`);
  };
}
let user = new User(&quot;John&quot;, new Date(2000, 0, 1));
user.sayHi(); // John, age:17</code>
  In this code variables <code>name</code>, <code>birthday</code> and the function <code>calcAge()</code> are internal, <em>private</em> to the object. 
They are only visible from inside of it.

On the other hand, <code>sayHi</code> is the external, <em>public</em> method. 
The external code that creates <code>user</code> can access it.

This way we can hide internal implementation details and helper methods from the outer code. 
Only what’s assigned to <code>this</code> becomes visible outside.

<h2>Factory class pattern</h2>
We can create a class without using <code>new</code> at all.

Like this:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function User(name, birthday) {
  // only visible from other methods inside User
  function calcAge() {
    return new Date().getFullYear() - birthday.getFullYear();
  }
  return {
    sayHi() {
alert(`${name}, age:${calcAge()}`);
    }
  };
}
let user = User(&quot;John&quot;, new Date(2000, 0, 1));
user.sayHi(); // John, age:17</code>
  As we can see, the function <code>User</code> returns an object with public properties and methods. 
The only benefit of this method is that we can omit <code>new</code>: write <code>let user = User(...)</code> instead of <code>let user = new User(...)</code>. 
In other aspects it’s almost the same as the functional pattern.

<h2>Prototype-based classes</h2>
Prototype-based classes are the most important and generally the best. 
Functional and factory class patterns are rarely used in practice.

Soon you’ll see why.

Here’s the same class rewritten using prototypes:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function User(name, birthday) {
  this._name = name;
  this._birthday = birthday;
}
User.prototype._calcAge = function() {
  return new Date().getFullYear() - this._birthday.getFullYear();
};
User.prototype.sayHi = function() {
  alert(`${this._name}, age:${this._calcAge()}`);
};
let user = new User(&quot;John&quot;, new Date(2000, 0, 1));
user.sayHi(); // John, age:17</code>
  The code structure:

<li>The constructor <code>User</code> only initializes the current object state.</li><li>Methods are added to <code>User.prototype</code>.</li>

As we can see, methods are lexically not inside <code>function User</code>, they do not share a common lexical environment. 
If we declare variables inside <code>function User</code>, then they won’t be visible to methods.

So, there is a widely known agreement that internal properties and methods are prepended with an underscore <code>&quot;_&quot;</code>. 
Like <code>_name</code> or <code>_calcAge()</code>. 
Technically, that’s just an agreement, the outer code still can access them. 
But most developers recognize the meaning of <code>&quot;_&quot;</code> and try not to touch prefixed properties and methods in the external code.

Here are the advantages over the functional pattern:

<li>In the functional pattern, each object has its own copy of every method. 
We assign a separate copy of <code>this.sayHi = function() {...}</code> and other methods in the constructor.</li><li>In the prototypal pattern, all methods are in <code>User.prototype</code> that is shared between all user objects. 
An object itself only stores the data.</li>

So the prototypal pattern is more memory-efficient.

…But not only that. 
Prototypes allow us to setup the inheritance in a really efficient way. 
Built-in JavaScript objects all use prototypes. 
Also there’s a special syntax construct: “class” that provides nice-looking syntax for them. 
And there’s more, so let’s go on with them.

<h2>Prototype-based inheritance for classes</h2>
Let’s say we have two prototype-based classes.

<code>Rabbit</code>:

    <code>function Rabbit(name) {
  this.name = name;
}
Rabbit.prototype.jump = function() {
  alert(`${this.name} jumps!`);
};
let rabbit = new Rabbit(&quot;My rabbit&quot;);</code>
  

<img src="https://javascript.info/article/class-patterns/rabbit-animal-independent-1.png">
…And <code>Animal</code>:

    <code>function Animal(name) {
  this.name = name;
}
Animal.prototype.eat = function() {
  alert(`${this.name} eats.`);
};
let animal = new Animal(&quot;My animal&quot;);</code>
  

<img src="https://javascript.info/article/class-patterns/rabbit-animal-independent-2.png">
Right now they are fully independent.

But we’d want <code>Rabbit</code> to extend <code>Animal</code>. 
In other words, rabbits should be based on animals, have access to methods of <code>Animal</code> and extend them with its own methods.

What does it mean in the language of prototypes?

Right now methods for <code>rabbit</code> objects are in <code>Rabbit.prototype</code>. 
We’d like <code>rabbit</code> to use <code>Animal.prototype</code> as a “fallback”, if the method is not found in <code>Rabbit.prototype</code>.

So the prototype chain should be <code>rabbit</code> → <code>Rabbit.prototype</code> → <code>Animal.prototype</code>.

Like this:

<img src="https://javascript.info/article/class-patterns/class-inheritance-rabbit-animal.png">
The code to implement that:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// Same Animal as before
function Animal(name) {
  this.name = name;
}
// All animals can eat, right?
Animal.prototype.eat = function() {
  alert(`${this.name} eats.`);
};
// Same Rabbit as before
function Rabbit(name) {
  this.name = name;
}
Rabbit.prototype.jump = function() {
  alert(`${this.name} jumps!`);
};
// setup the inheritance chain
Rabbit.prototype.__proto__ = Animal.prototype; // (*)
let rabbit = new Rabbit(&quot;White Rabbit&quot;);
rabbit.eat(); // rabbits can eat too
rabbit.jump();</code>
  The line <code>(*)</code> sets up the prototype chain. 
So that <code>rabbit</code> first searches methods in <code>Rabbit.prototype</code>, then <code>Animal.prototype</code>. 
And then, just for completeness, let’s mention that if the method is not found in <code>Animal.prototype</code>, then the search continues in <code>Object.prototype</code>, because <code>Animal.prototype</code> is a regular plain object, so it inherits from it.

So here’s the full picture:

<img src="https://javascript.info/article/class-patterns/class-inheritance-rabbit-animal-2.png">
<h4><a name="summary" href="#summary">Summary</a4</h2>
The term “class” comes from the object-oriented programming. 
In JavaScript it usually means the functional class pattern or the prototypal pattern. 
The prototypal pattern is more powerful and memory-efficient, so it’s recommended to stick to it.

According to the prototypal pattern:

<li>Methods are stored in <code>Class.prototype</code>.</li><li>Prototypes inherit from each other.</li>

In the next chapter we’ll study <code>class</code> keyword and construct. 
It allows to write prototypal classes shorter and provides some additional benefits.

What’s wrong? What are consequences going to be?

    <code>function Animal(name) {
  this.name = name;
}
Animal.prototype.walk = function() {
  alert(this.name + ' walks');
};
function Rabbit(name) {
  this.name = name;
}
Rabbit.prototype = Animal.prototype;
Rabbit.prototype.walk = function() {
  alert(this.name + &quot; bounces!&quot;);
};</code>
  <button type="button">solution</button>

Here’s the line with the error:

    <code>Rabbit.prototype = Animal.prototype;</code>
  Here <code>Rabbit.prototype</code> and <code>Animal.prototype</code> become the same object. 
So methods of both classes become mixed in that object.

As a result, <code>Rabbit.prototype.walk</code> overwrites <code>Animal.prototype.walk</code>, so all animals start to bounce:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function Animal(name) {
  this.name = name;
}
Animal.prototype.walk = function() {
  alert(this.name + ' walks');
};
function Rabbit(name) {
  this.name = name;
}
Rabbit.prototype = Animal.prototype;
Rabbit.prototype.walk = function() {
  alert(this.name + &quot; bounces!&quot;);
};
let animal = new Animal(&quot;pig&quot;);
animal.walk(); // pig bounces!</code>
  The correct variant would be:

    <code>Rabbit.prototype.__proto__ = Animal.prototype;
// or like this:
Rabbit.prototype = Object.create(Animal.prototype);</code>
  That makes prototypes separate, each of them stores methods of the corresponding class, but <code>Rabbit.prototype</code> inherits from <code>Animal.prototype</code>.

<button type="button" title="close"></button>

<h3><a href="#rewrite-to-prototypes" name="rewrite-to-prototypes">Rewrite to prototypes</a></h3><a href="/task/rewrite-to-prototypes" target="_blank"></a>

importance: 5

The <code>Clock</code> class is written in functional style. 
Rewrite it using prototypes.

P.S. 
The clock ticks in the console, open it to see.

<a href="http://plnkr.co/edit/KLE8bfUHtRmuGHdZiqC1?p=preview" target="_blank" data-plunk-id="KLE8bfUHtRmuGHdZiqC1">Open the sandbox for the task.</a>
<button type="button">solution</button>

Please note that properties that were internal in functional style (<code>template</code>, <code>timer</code>) and the internal method <code>render</code> are marked private with the underscore <code>_</code>.

<a href="http://plnkr.co/edit/Fq5uDZuNFFJGIpkcA41A?p=preview" target="_blank" data-plunk-id="Fq5uDZuNFFJGIpkcA41A">Open the solution in the sandbox.</a>
<button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/prototype-methods" data-tooltip="Methods for prototypes">Previous lesson</a><a href="/class" data-tooltip="Classes">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Fclass-patterns"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Fclass-patterns"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Fclass-patterns"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Fclass-patterns"></a>

The “class” construct allows to define prototype-based classes with a clean, nice-looking syntax.

<h2>The “class” syntax</h2>
The <code>class</code> syntax is versatile, we’ll start with a simple example first.

Here’s a prototype-based class <code>User</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function User(name) {
  this.name = name;
}
User.prototype.sayHi = function() {
  alert(this.name);
}
let user = new User(&quot;John&quot;);
user.sayHi();</code>
  …And that’s the same using <code>class</code> syntax:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>class User {
  constructor(name) {
    this.name = name;
  }
  sayHi() {
    alert(this.name);
  }
}
let user = new User(&quot;John&quot;);
user.sayHi();</code>
  It’s easy to see that the two examples are alike. 
Just please note that methods in a class do not have a comma between them. 
Novice developers sometimes forget it and put a comma between class methods, and things don’t work. 
That’s not a literal object, but a class syntax.

So, what exactly does <code>class</code> do? We may think that it defines a new language-level entity, but that would be wrong.

The <code>class User {...}</code> here actually does two things:

<li>Declares a variable <code>User</code> that references the function named <code>&quot;constructor&quot;</code>.</li><li>Puts methods listed in the definition into <code>User.prototype</code>. 
Here, it includes <code>sayHi</code> and the <code>constructor</code>.</li>

Here’s the code to dig into the class and see that:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>class User {
  constructor(name) { this.name = name; }
  sayHi() { alert(this.name); }
}
// proof: User is the &quot;constructor&quot; function
alert(User === User.prototype.constructor); // true
// proof: there are two methods in its &quot;prototype&quot;
alert(Object.getOwnPropertyNames(User.prototype)); // constructor, sayHi</code>
  Here’s the illustration of what <code>class User</code> creates:

<img src="https://javascript.info/article/class/class-user.png">
So <code>class</code> is a special syntax to define a constructor together with its prototype methods.

…But not only that. 
There are minor tweaks here and there:

<dl>
<dt>Constructors require <code>new</code></dt>
<dd>Unlike a regular function, a class <code>constructor</code> can’t be called without <code>new</code>:</dd>
</dl>

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>class User {
  constructor() {}
}
alert(typeof User); // function
User(); // Error: Class constructor User cannot be invoked without 'new'</code>
  <dl>
<dt>Different string output</dt>
<dd>If we output it like <code>alert(User)</code>, some engines show <code>&quot;class User...&quot;</code>, while others show <code>&quot;function User...&quot;</code>.</dd>
</dl>

Please don’t be confused: the string representation may vary, but that’s still a function, there is no separate “class” entity in JavaScript language.

<dl>
<dt>Class methods are non-enumerable</dt>
<dd>A class definition sets <code>enumerable</code> flag to <code>false</code> for all methods in the <code>&quot;prototype&quot;</code>. 
That’s good, because if we <code>for..in</code> over an object, we usually don’t want its class methods.</dd>
<dt>Classes have a default <code>constructor() {}</code></dt>
<dd>If there’s no <code>constructor</code> in the <code>class</code> construct, then an empty function is generated, same as if we had written <code>constructor() {}</code>.</dd>
<dt>Classes always <code>use strict</code></dt>
<dd>All code inside the class construct is automatically in strict mode.</dd>
</dl>

<h3><a name="getters-setters" href="#getters-setters">Getters/setters</a></h3>
Classes may also include getters/setters. 
Here’s an example with <code>user.name</code> implemented using them:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>class User {
  constructor(name) {
    // invokes the setter
    this.name = name;
  }
  get name() {
    return this._name;
  }
  set name(value) {
    if (value.length &lt; 4) {
alert(&quot;Name is too short.&quot;);
return;
    }
    this._name = value;
  }
}
let user = new User(&quot;John&quot;);
alert(user.name); // John
user = new User(&quot;&quot;); // Name too short.</code>
  Internally, getters and setters are also created on the <code>User</code> prototype, like this:

    <code>Object.defineProperties(User.prototype, {
  name: {
    get() {
return this._name
    },
    set(name) {
// ...
    }
  }
});</code>
  <h3><a name="only-methods" href="#only-methods">Only methods</a></h3>
Unlike object literals, no <code>property:value</code> assignments are allowed inside <code>class</code>. 
There may be only methods and getters/setters. 
There is some work going on in the specification to lift that limitation, but it’s not yet there.

If we really need to put a non-function value into the prototype, then we can alter <code>prototype</code> manually, like this:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>class User { }
User.prototype.test = 5;
alert( new User().test ); // 5</code>
  So, technically that’s possible, but we should know why we’re doing it. 
Such properties will be shared among all objects of the class.

An “in-class” alternative is to use a getter:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>class User {
  get test() {
    return 5;
  }
}
alert( new User().test ); // 5</code>
  From the external code, the usage is the same. 
But the getter variant is a bit slower.

<h2>Class Expression</h2>
Just like functions, classes can be defined inside another expression, passed around, returned etc.

Here’s a class-returning function (“class factory”):

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function makeClass(phrase) {
  // declare a class and return it
  return class {
    sayHi() {
alert(phrase);
    };
  };
}
let User = makeClass(&quot;Hello&quot;);
new User().sayHi(); // Hello</code>
  That’s quite normal if we recall that <code>class</code> is just a special form of a function-with-prototype definition.

And, like Named Function Expressions, such classes also may have a name, that is visible inside that class only:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// &quot;Named Class Expression&quot; (alas, no such term, but that's what's going on)
let User = class MyClass {
  sayHi() {
    alert(MyClass); // MyClass is visible only inside the class
  }
};
new User().sayHi(); // works, shows MyClass definition
alert(MyClass); // error, MyClass not visible outside of the class</code>
  <h2>Static methods</h2>
We can also assign methods to the class function, not to its <code>&quot;prototype&quot;</code>. 
Such methods are called <em>static</em>.

An example:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>class User {
  static staticMethod() {
    alert(this === User);
  }
}
User.staticMethod(); // true</code>
  That actually does the same as assigning it as a function property:

    <code>function User() { }
User.staticMethod = function() {
  alert(this === User);
};</code>
  The value of <code>this</code> inside <code>User.staticMethod()</code> is the class constructor <code>User</code> itself (the “object before dot” rule).

Usually, static methods are used to implement functions that belong to the class, but not to any particular object of it.

For instance, we have <code>Article</code> objects and need a function to compare them. 
The natural choice would be <code>Article.compare</code>, like this:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>class Article {
  constructor(title, date) {
    this.title = title;
    this.date = date;
  }
  static compare(articleA, articleB) {
    return articleA.date - articleB.date;
  }
}
// usage
let articles = [
  new Article(&quot;Mind&quot;, new Date(2016, 1, 1)),
  new Article(&quot;Body&quot;, new Date(2016, 0, 1)),
  new Article(&quot;JavaScript&quot;, new Date(2016, 11, 1))
];
articles.sort(Article.compare);
alert( articles[0].title ); // Body</code>
  Here <code>Article.compare</code> stands “over” the articles, as a means to compare them. 
It’s not a method of an article, but rather of the whole class.

Another example would be a so-called “factory” method. 
Imagine, we need few ways to create an article:

<li>Create by given parameters (<code>title</code>, <code>date</code> etc).</li><li>Create an empty article with today’s date.</li><li>…</li>

The first way can be implemented by the constructor. 
And for the second one we can make a static method of the class.

Like <code>Article.createTodays()</code> here:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>class Article {
  constructor(title, date) {
    this.title = title;
    this.date = date;
  }
  static createTodays() {
    // remember, this = Article
    return new this(&quot;Today's digest&quot;, new Date());
  }
}
let article = Article.createTodays();
alert( article.title ); // Todays digest</code>
  Now every time we need to create a today’s digest, we can call <code>Article.createTodays()</code>. 
Once again, that’s not a method of an article, but a method of the whole class.

Static methods are also used in database-related classes to search/save/remove entries from the database, like this:

    <code>// assuming Article is a special class for managing articles
// static method to remove the article:
Article.remove({id: 12345});</code>
  <h4><a name="summary" href="#summary">Summary</a4</h2>
The basic class syntax looks like this:

    <code>class MyClass {
  constructor(...) {
    // ...
  }
  method1(...) {}
  method2(...) {}
  get something(...) {}
  set something(...) {}
  static staticMethod(..) {}
  // ...
}</code>
  The value of <code>MyClass</code> is a function provided as <code>constructor</code>. 
If there’s no <code>constructor</code>, then an empty function.

In any case, methods listed in the class declaration become members of its <code>prototype</code>, with the exception of static methods that are written into the function itself and callable as <code>MyClass.staticMethod()</code>. 
Static methods are used when we need a function bound to a class, but not to any object of that class.

In the next chapter we’ll learn more about classes, including inheritance.

P.S. 
The clock ticks in the console, open it to see.

<a href="http://plnkr.co/edit/DbapfmzhczwDfu27e1Wb?p=preview" target="_blank" data-plunk-id="DbapfmzhczwDfu27e1Wb">Open the sandbox for the task.</a>
<button type="button">solution</button>

<a href="http://plnkr.co/edit/1alwgdIhuYgwVhGek6yT?p=preview" target="_blank" data-plunk-id="1alwgdIhuYgwVhGek6yT">Open the solution in the sandbox.</a>
<button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/class-patterns" data-tooltip="Class patterns">Previous lesson</a><a href="/class-inheritance" data-tooltip="Class inheritance, super">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Fclass"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Fclass"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Fclass"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Fclass"></a>

Classes can extend one another. 
There’s a nice syntax, technically based on the prototypal inheritance.

To inherit from another class, we should specify <code>&quot;extends&quot;</code> and the parent class before the brackets <code>{..}</code>.

Here <code>Rabbit</code> inherits from <code>Animal</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }
  run(speed) {
    this.speed += speed;
    alert(`${this.name} runs with speed ${this.speed}.`);
  }
  stop() {
    this.speed = 0;
    alert(`${this.name} stopped.`);
  }
}
// Inherit from Animal
class Rabbit extends Animal {
  hide() {
    alert(`${this.name} hides!`);
  }
}
let rabbit = new Rabbit(&quot;White Rabbit&quot;);
rabbit.run(5); // White Rabbit runs with speed 5.
rabbit.hide(); // White Rabbit hides!</code>
  The <code>extends</code> keyword actually adds a <code>[[Prototype]]</code> reference from <code>Rabbit.prototype</code> to <code>Animal.prototype</code>, just as you expect it to be, and as we’ve seen before.

<img src="https://javascript.info/article/class-inheritance/animal-rabbit-extends.png">
So now <code>rabbit</code> has access both to its own methods and to methods of <code>Animal</code>.

Any expression is allowed after <code>extends</code>
Class syntax allows to specify not just a class, but any expression after <code>extends</code>.

For instance, a function call that generates the parent class:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function f(phrase) {
  return class {
    sayHi() { alert(phrase) }
  }
}
class User extends f(&quot;Hello&quot;) {}
new User().sayHi(); // Hello</code>
  Here <code>class User</code> inherits from the result of <code>f(&quot;Hello&quot;)</code>.

That may be useful for advanced programming patterns when we use functions to generate classes depending on many conditions and can inherit from them.

<h2>Overriding a method</h2>
Now let’s move forward and override a method. 
As of now, <code>Rabbit</code> inherits the <code>stop</code> method that sets <code>this.speed = 0</code> from <code>Animal</code>.

If we specify our own <code>stop</code> in <code>Rabbit</code>, then it will be used instead:

    <code>class Rabbit extends Animal {
  stop() {
    // ...this will be used for rabbit.stop()
  }
}</code>
  …But usually we don’t want to totally replace a parent method, but rather to build on top of it, tweak or extend its functionality. 
We do something in our method, but call the parent method before/after it or in the process.

Classes provide <code>&quot;super&quot;</code> keyword for that.

<li><code>super.method(...)</code> to call a parent method.</li><li><code>super(...)</code> to call a parent constructor (inside our constructor only).</li>

For instance, let our rabbit autohide when stopped:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }
  run(speed) {
    this.speed += speed;
    alert(`${this.name} runs with speed ${this.speed}.`);
  }
  stop() {
    this.speed = 0;
    alert(`${this.name} stopped.`);
  }
}
class Rabbit extends Animal {
  hide() {
    alert(`${this.name} hides!`);
  }
  stop() {
    super.stop(); // call parent stop
    this.hide(); // and then hide
  }
}
let rabbit = new Rabbit(&quot;White Rabbit&quot;);
rabbit.run(5); // White Rabbit runs with speed 5.
rabbit.stop(); // White Rabbit stopped. 
White rabbit hides!</code>
  Now <code>Rabbit</code> has the <code>stop</code> method that calls the parent <code>super.stop()</code> in the process.

Arrow functions have no <code>super</code>
As was mentioned in the chapter <a href="/arrow-functions">Arrow functions revisited</a>, arrow functions do not have <code>super</code>.

If accessed, it’s taken from the outer function. 
For instance:

    <code>class Rabbit extends Animal {
  stop() {
    setTimeout(() =&gt; super.stop(), 1000); // call parent stop after 1sec
  }
}</code>
  The <code>super</code> in the arrow function is the same as in <code>stop()</code>, so it works as intended. 
If we specified a “regular” function here, there would be an error:

    <code>// Unexpected super
setTimeout(function() { super.stop() }, 1000);</code>
  
<h2>Overriding constructor</h2>
With constructors it gets a little bit tricky.

Till now, <code>Rabbit</code> did not have its own <code>constructor</code>.

According to the <a href="https://tc39.github.io/ecma262/#sec-runtime-semantics-classdefinitionevaluation">specification</a>, if a class extends another class and has no <code>constructor</code>, then the following <code>constructor</code> is generated:

    <code>class Rabbit extends Animal {
  // generated for extending classes without own constructors
  constructor(...args) {
    super(...args);
  }
}</code>
  As we can see, it basically calls the parent <code>constructor</code> passing it all the arguments. 
That happens if we don’t write a constructor of our own.

Now let’s add a custom constructor to <code>Rabbit</code>. 
It will specify the <code>earLength</code> in addition to <code>name</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }
  // ...
}
class Rabbit extends Animal {
  constructor(name, earLength) {
    this.speed = 0;
    this.name = name;
    this.earLength = earLength;
  }
  // ...
}
// Doesn't work!
let rabbit = new Rabbit(&quot;White Rabbit&quot;, 10); // Error: this is not defined.</code>
  Whoops! We’ve got an error. 
Now we can’t create rabbits. 
What went wrong?

The short answer is: constructors in inheriting classes must call <code>super(...)</code>, and (!) do it before using <code>this</code>.

…But why? What’s going on here? Indeed, the requirement seems strange.

Of course, there’s an explanation. 
Let’s get into details, so you’d really understand what’s going on.

In JavaScript, there’s a distinction between a “constructor function of an inheriting class” and all others. 
In an inheriting class, the corresponding constructor function is labelled with a special internal property <code>[[ConstructorKind]]:&quot;derived&quot;</code>.

The difference is:

<li>When a normal constructor runs, it creates an empty object as <code>this</code> and continues with it.</li><li>But when a derived constructor runs, it doesn’t do it. 
It expects the parent constructor to do this job.</li>

So if we’re making a constructor of our own, then we must call <code>super</code>, because otherwise the object with <code>this</code> reference to it won’t be created. 
And we’ll get an error.

For <code>Rabbit</code> to work, we need to call <code>super()</code> before using <code>this</code>, like here:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }
  // ...
}
class Rabbit extends Animal {
  constructor(name, earLength) {
    super(name);
    this.earLength = earLength;
  }
  // ...
}
// now fine
let rabbit = new Rabbit(&quot;White Rabbit&quot;, 10);
alert(rabbit.name); // White Rabbit
alert(rabbit.earLength); // 10</code>
  <h2>Super: internals, [[HomeObject]]</h2>
Let’s get a little deeper under the hood of <code>super</code>. 
We’ll see some interesting things by the way.

First to say, from all that we’ve learned till now, it’s impossible for <code>super</code> to work.

Yeah, indeed, let’s ask ourselves, how it could technically work? When an object method runs, it gets the current object as <code>this</code>. 
If we call <code>super.method()</code> then, how to retrieve the <code>method</code>? Naturally, we need to take the <code>method</code> from the prototype of the current object. 
How, technically, we (or a JavaScript engine) can do it?

Maybe we can get the method from <code>[[Prototype]]</code> of <code>this</code>, as <code>this.__proto__.method</code>? Unfortunately, that doesn’t work.

Let’s try to do it. 
Without classes, using plain objects for the sake of simplicity.

Here, <code>rabbit.eat()</code> should call <code>animal.eat()</code> method of the parent object:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let animal = {
  name: &quot;Animal&quot;,
  eat() {
    alert(`${this.name} eats.`);
  }
};
let rabbit = {
  __proto__: animal,
  name: &quot;Rabbit&quot;,
  eat() {
    // that's how super.eat() could presumably work
    this.__proto__.eat.call(this); // (*)
  }
};
rabbit.eat(); // Rabbit eats.</code>
  At the line <code>(*)</code> we take <code>eat</code> from the prototype (<code>animal</code>) and call it in the context of the current object. 
Please note that <code>.call(this)</code> is important here, because a simple <code>this.__proto__.eat()</code> would execute parent <code>eat</code> in the context of the prototype, not the current object.

And in the code above it actually works as intended: we have the correct <code>alert</code>.

Now let’s add one more object to the chain. 
We’ll see how things break:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let animal = {
  name: &quot;Animal&quot;,
  eat() {
    alert(`${this.name} eats.`);
  }
};
let rabbit = {
  __proto__: animal,
  eat() {
    // ...bounce around rabbit-style and call parent (animal) method
    this.__proto__.eat.call(this); // (*)
  }
};
let longEar = {
  __proto__: rabbit,
  eat() {
    // ...do something with long ears and call parent (rabbit) method
    this.__proto__.eat.call(this); // (**)
  }
};
longEar.eat(); // Error: Maximum call stack size exceeded</code>
  The code doesn’t work anymore! We can see the error trying to call <code>longEar.eat()</code>.

It may be not that obvious, but if we trace <code>longEar.eat()</code> call, then we can see why. 
In both lines <code>(*)</code> and <code>(**)</code> the value of <code>this</code> is the current object (<code>longEar</code>). 
That’s essential: all object methods get the current object as <code>this</code>, not a prototype or something.

So, in both lines <code>(*)</code> and <code>(**)</code> the value of <code>this.__proto__</code> is exactly the same: <code>rabbit</code>. 
They both call <code>rabbit.eat</code> without going up the chain in the endless loop.

Here’s the picture of what happens:

<img src="https://javascript.info/article/class-inheritance/this-super-loop.png">
<li>Inside <code>longEar.eat()</code>, the line <code>(**)</code> calls <code>rabbit.eat</code> providing it with <code>this=longEar</code>.

    <code>// inside longEar.eat() we have this = longEar
this.__proto__.eat.call(this) // (**)
// becomes
longEar.__proto__.eat.call(this)
// that is
rabbit.eat.call(this);</code>
  </li><li>Then in the line <code>(*)</code> of <code>rabbit.eat</code>, we’d like to pass the call even higher in the chain, but <code>this=longEar</code>, so <code>this.__proto__.eat</code> is again <code>rabbit.eat</code>!

    <code>// inside rabbit.eat() we also have this = longEar
this.__proto__.eat.call(this) // (*)
// becomes
longEar.__proto__.eat.call(this)
// or (again)
rabbit.eat.call(this);</code>
  </li><li>…So <code>rabbit.eat</code> calls itself in the endless loop, because it can’t ascend any further.

</li>

The problem can’t be solved by using <code>this</code> alone.

<h3><a name="homeobject" href="#homeobject"><code>[[HomeObject]]</code></a></h3>
To provide the solution, JavaScript adds one more special internal property for functions: <code>[[HomeObject]]</code>.

<strong>When a function is specified as a class or object method, its <code>[[HomeObject]]</code> property becomes that object.</strong>

This actually violates the idea of “unbound” functions, because methods remember their objects. 
And <code>[[HomeObject]]</code> can’t be changed, so this bound is forever. 
So that’s a very important change in the language.

But this change is safe. 
<code>[[HomeObject]]</code> is used only for calling parent methods in <code>super</code>, to resolve the prototype. 
So it doesn’t break compatibility.

Let’s see how it works for <code>super</code> – again, using plain objects:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let animal = {
  name: &quot;Animal&quot;,
  eat() {         // [[HomeObject]] == animal
    alert(`${this.name} eats.`);
  }
};
let rabbit = {
  __proto__: animal,
  name: &quot;Rabbit&quot;,
  eat() {         // [[HomeObject]] == rabbit
    super.eat();
  }
};
let longEar = {
  __proto__: rabbit,
  name: &quot;Long Ear&quot;,
  eat() {         // [[HomeObject]] == longEar
    super.eat();
  }
};
longEar.eat();  // Long Ear eats.</code>
  Every method remembers its object in the internal <code>[[HomeObject]]</code> property. 
Then <code>super</code> uses it to resolve the parent prototype.

<code>[[HomeObject]]</code> is defined for methods defined both in classes and in plain objects. 
But for objects, methods must be specified exactly the given way: as <code>method()</code>, not as <code>&quot;method: function()&quot;</code>.

In the example below a non-method syntax is used for comparison. 
<code>[[HomeObject]]</code> property is not set and the inheritance doesn’t work:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let animal = {
  eat: function() { // should be the short syntax: eat() {...}
    // ...
  }
};
let rabbit = {
  __proto__: animal,
  eat: function() {
    super.eat();
  }
};
rabbit.eat();  // Error calling super (because there's no [[HomeObject]])</code>
  <h2>Static methods and inheritance</h2>
The <code>class</code> syntax supports inheritance for static properties too.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>class Animal {
  constructor(name, speed) {
    this.speed = speed;
    this.name = name;
  }
  run(speed = 0) {
    this.speed += speed;
    alert(`${this.name} runs with speed ${this.speed}.`);
  }
  static compare(animalA, animalB) {
    return animalA.speed - animalB.speed;
  }
}
// Inherit from Animal
class Rabbit extends Animal {
  hide() {
    alert(`${this.name} hides!`);
  }
}
let rabbits = [
  new Rabbit(&quot;White Rabbit&quot;, 10),
  new Rabbit(&quot;Black Rabbit&quot;, 5)
];
rabbits.sort(Rabbit.compare);
rabbits[0].run(); // Black Rabbit runs with speed 5.</code>
  Now we can call <code>Rabbit.compare</code> assuming that the inherited <code>Animal.compare</code> will be called.

How does it work? Again, using prototypes. 
As you might have already guessed, extends also gives <code>Rabbit</code> the <code>[[Prototype]]</code> reference to <code>Animal</code>.

<img src="https://javascript.info/article/class-inheritance/animal-rabbit-static.png">
So, <code>Rabbit</code> function now inherits from <code>Animal</code> function. 
And <code>Animal</code> function normally has <code>[[Prototype]]</code> referencing <code>Function.prototype</code>, because it doesn’t <code>extend</code> anything.

Here, let’s check that:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>class Animal {}
class Rabbit extends Animal {}
// for static propertites and methods
alert(Rabbit.__proto__ === Animal); // true
// and the next step is Function.prototype
alert(Animal.__proto__ === Function.prototype); // true
// that's in addition to the &quot;normal&quot; prototype chain for object methods
alert(Rabbit.prototype.__proto__ === Animal.prototype);</code>
  This way <code>Rabbit</code> has access to all static methods of <code>Animal</code>.

<h3><a name="no-static-inheritance-in-built-ins" href="#no-static-inheritance-in-built-ins">No static inheritance in built-ins</a></h3>
Please note that built-in classes don’t have such static <code>[[Prototype]]</code> reference. 
For instance, <code>Object</code> has <code>Object.defineProperty</code>, <code>Object.keys</code> and so on, but <code>Array</code>, <code>Date</code> etc do not inherit them.

Here’s the picture structure for <code>Date</code> and <code>Object</code>:

<img src="https://javascript.info/article/class-inheritance/object-date-inheritance.png">
Note, there’s no link between <code>Date</code> and <code>Object</code>. 
Both <code>Object</code> and <code>Date</code> exist independently. 
<code>Date.prototype</code> inherits from <code>Object.prototype</code>, but that’s all.

Such difference exists for historical reasons: there was no thought about class syntax and inheriting static methods at the dawn of JavaScript language.

<h2>Natives are extendable</h2>
Built-in classes like Array, Map and others are extendable also.

For instance, here <code>PowerArray</code> inherits from the native <code>Array</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// add one more method to it (can do more)
class PowerArray extends Array {
  isEmpty() {
    return this.length === 0;
  }
}
let arr = new PowerArray(1, 2, 5, 10, 50);
alert(arr.isEmpty()); // false
let filteredArr = arr.filter(item =&gt; item &gt;= 10);
alert(filteredArr); // 10, 50
alert(filteredArr.isEmpty()); // false</code>
  Please note one very interesting thing. 
Built-in methods like <code>filter</code>, <code>map</code> and others – return new objects of exactly the inherited type. 
They rely on the <code>constructor</code> property to do so.

In the example above,

    <code>arr.constructor === PowerArray</code>
  So when <code>arr.filter()</code> is called, it internally creates the new array of results exactly as <code>new PowerArray</code>. 
And we can keep using its methods further down the chain.

Even more, we can customize that behavior. 
The static getter <code>Symbol.species</code>, if exists, returns the constructor to use in such cases.

For example, here due to <code>Symbol.species</code> built-in methods like <code>map</code>, <code>filter</code> will return “normal” arrays:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>class PowerArray extends Array {
  isEmpty() {
    return this.length === 0;
  }
  // built-in methods will use this as the constructor
  static get [Symbol.species]() {
    return Array;
  }
}
let arr = new PowerArray(1, 2, 5, 10, 50);
alert(arr.isEmpty()); // false
// filter creates new array using arr.constructor[Symbol.species] as constructor
let filteredArr = arr.filter(item =&gt; item &gt;= 10);
// filteredArr is not PowerArray, but Array
alert(filteredArr.isEmpty()); // Error: filteredArr.isEmpty is not a function</code>
  We can use it in more advanced keys to strip extended functionality from resulting values if not needed. 
Or, maybe, to extend it even further.

Unfortunately, <code>Rabbit</code> objects can’t be created. 
What’s wrong? Fix it.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>class Animal {
  constructor(name) {
    this.name = name;
  }
}
class Rabbit extends Animal {
  constructor(name) {
    this.name = name;
    this.created = Date.now();
  }
}
let rabbit = new Rabbit(&quot;White Rabbit&quot;); // Error: this is not defined
alert(rabbit.name);</code>
  <button type="button">solution</button>

That’s because the child constructor must call <code>super()</code>.

Here’s the corrected code:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>class Animal {
  constructor(name) {
    this.name = name;
  }
}
class Rabbit extends Animal {
  constructor(name) {
    super(name);
    this.created = Date.now();
  }
}
let rabbit = new Rabbit(&quot;White Rabbit&quot;); // ok now
alert(rabbit.name); // White Rabbit</code>
  <button type="button" title="close"></button>

<h3><a href="#extended-clock" name="extended-clock">Extended clock</a></h3><a href="/task/clock-class-extended" target="_blank"></a>

importance: 5

We’ve got a <code>Clock</code> class. 
As of now, it prints the time every second.

Create a new class <code>ExtendedClock</code> that inherits from <code>Clock</code> and adds the parameter <code>precision</code> – the number of <code>ms</code> between “ticks”. 
Should be <code>1000</code> (1 second) by default.

<li>Your code should be in the file <code>extended-clock.js</code></li><li>Don’t modify the original <code>clock.js</code>. 
Extend it.</li>

<a href="http://plnkr.co/edit/XZ1YztfCGf5lLKQ56tAO?p=preview" target="_blank" data-plunk-id="XZ1YztfCGf5lLKQ56tAO">Open the sandbox for the task.</a>
<button type="button">solution</button>

<a href="http://plnkr.co/edit/LSBcWONytYD9aqo7tjO1?p=preview" target="_blank" data-plunk-id="LSBcWONytYD9aqo7tjO1">Open the solution in the sandbox.</a>
<button type="button" title="close"></button>

<h3><a href="#class-extends-object" name="class-extends-object">Class extends Object?</a></h3><a href="/task/class-extend-object" target="_blank"></a>

importance: 5

As we know, all objects normally inherit from <code>Object.prototype</code> and get access to “generic” object methods like <code>hasOwnProperty</code> etc.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>class Rabbit {
  constructor(name) {
    this.name = name;
  }
}
let rabbit = new Rabbit(&quot;Rab&quot;);
// hasOwnProperty method is from Object.prototype
// rabbit.__proto__ === Object.prototype
alert( rabbit.hasOwnProperty('name') ); // true</code>
  But if we spell it out explicitly like <code>&quot;class Rabbit extends Object&quot;</code>, then the result would be different from a simple <code>&quot;class Rabbit&quot;</code>?

What’s the difference?

Here’s an example of such code (it doesn’t work – why? fix it?):

    <code>class Rabbit extends Object {
  constructor(name) {
    this.name = name;
  }
}
let rabbit = new Rabbit(&quot;Rab&quot;);
alert( rabbit.hasOwnProperty('name') ); // true</code>
  <button type="button">solution</button>

First, let’s see why the latter code doesn’t work.

The reason becomes obvious if we try to run it. 
An inheriting class constructor must call <code>super()</code>. 
Otherwise <code>&quot;this&quot;</code> won’t be “defined”.

So here’s the fix:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>class Rabbit extends Object {
  constructor(name) {
    super(); // need to call the parent constructor when inheriting
    this.name = name;
  }
}
let rabbit = new Rabbit(&quot;Rab&quot;);
alert( rabbit.hasOwnProperty('name') ); // true</code>
  But that’s not all yet.

Even after the fix, there’s still important difference in <code>&quot;class Rabbit extends Object&quot;</code> versus <code>class Rabbit</code>.

As we know, the “extends” syntax sets up two prototypes:

<li>Between <code>&quot;prototype&quot;</code> of the constructor functions (for methods).</li><li>Between the constructor functions itself (for static methods).</li>

In our case, for <code>class Rabbit extends Object</code> it means:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>class Rabbit extends Object {}
alert( Rabbit.prototype.__proto__ === Object.prototype ); // (1) true
alert( Rabbit.__proto__ === Object ); // (2) true</code>
  So <code>Rabbit</code> now provides access to static methods of <code>Object</code> via <code>Rabbit</code>, like this:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>class Rabbit extends Object {}
// normally we call Object.getOwnPropertyNames
alert ( Rabbit.getOwnPropertyNames({a: 1, b: 2})); // a,b</code>
  But if we don’t have <code>extends Object</code>, then <code>Rabbit.__proto__</code> is not set to <code>Object</code>.

Here’s the demo:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>class Rabbit {}
alert( Rabbit.prototype.__proto__ === Object.prototype ); // (1) true
alert( Rabbit.__proto__ === Object ); // (2) false (!)
alert( Rabbit.__proto__ === Function.prototype ); // as any function by default
// error, no such function in Rabbit
alert ( Rabbit.getOwnPropertyNames({a: 1, b: 2})); // Error</code>
  So <code>Rabbit</code> doesn’t provide access to static methods of <code>Object</code> in that case.

By the way, <code>Function.prototype</code> has “generic” function methods, like <code>call</code>, <code>bind</code> etc. 
They are ultimately available in both cases, because for the built-in <code>Object</code> constructor, <code>Object.__proto__ === Function.prototype</code>.

Here’s the picture:

<img src="https://javascript.info/task/class-extend-object/rabbit-extends-object.png">
So, to put it short, there are two differences:

<table>
<thead>
<tr>
<th>class Rabbit</th>
<th>class Rabbit extends Object</th>
</tr>
</thead>
<tbody>
<tr>
<td>–</td>
<td>needs to call <code>super()</code> in constructor</td>
</tr>
<tr>
<td><code>Rabbit.__proto__ === Function.prototype</code></td>
<td><code>Rabbit.__proto__ === Object</code></td>
</tr>
</tbody>
</table>
<button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/class" data-tooltip="Classes">Previous lesson</a><a href="/instanceof" data-tooltip="Class checking: &quot;instanceof&quot;">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Fclass-inheritance"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Fclass-inheritance"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Fclass-inheritance"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Fclass-inheritance"></a>

The <code>instanceof</code> operator allows to check whether an object belongs to a certain class. 
It also takes inheritance into account.

Such a check may be necessary in many cases, here we’ll use it for building a <em>polymorphic</em> function, the one that treats arguments differently depending on their type.

<h2>The instanceof operator</h2>
The syntax is:

    <code>obj instanceof Class</code>
  It returns <code>true</code> if <code>obj</code> belongs to the <code>Class</code> (or a class inheriting from it).

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>class Rabbit {}
let rabbit = new Rabbit();
// is it an object of Rabbit class?
alert( rabbit instanceof Rabbit ); // true</code>
  It also works with constructor functions:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// instead of class
function Rabbit() {}
alert( new Rabbit() instanceof Rabbit ); // true</code>
  …And with built-in classes like <code>Array</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let arr = [1, 2, 3];
alert( arr instanceof Array ); // true
alert( arr instanceof Object ); // true</code>
  Please note that <code>arr</code> also belongs to the <code>Object</code> class. 
That’s because <code>Array</code> prototypally inherits from <code>Object</code>.

The <code>instanceof</code> operator examines the prototype chain for the check, and is also fine-tunable using the static method <code>Symbol.hasInstance</code>.

The algorithm of <code>obj instanceof Class</code> works roughly as follows:

<li>If there’s a static method <code>Symbol.hasInstance</code>, then use it. 
Like this:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// assume anything that canEat is an animal
class Animal {
  static [Symbol.hasInstance](obj) {
    if (obj.canEat) return true;
  }
}
let obj = { canEat: true };
alert(obj instanceof Animal); // true: Animal[Symbol.hasInstance](obj) is called</code>
  </li><li>Most classes do not have <code>Symbol.hasInstance</code>. 
In that case, check if <code>Class.prototype</code> equals to one of prototypes in the <code>obj</code> prototype chain.

In other words, compare:

    <code>obj.__proto__ === Class.prototype
obj.__proto__.__proto__ === Class.prototype
obj.__proto__.__proto__.__proto__ === Class.prototype
...</code>
  In the example above <code>Rabbit.prototype === rabbit.__proto__</code>, so that gives the answer immediately.

In the case of an inheritance, <code>rabbit</code> is an instance of the parent class as well:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>class Animal {}
class Rabbit extends Animal {}
let rabbit = new Rabbit();
alert(rabbit instanceof Animal); // true
// rabbit.__proto__ === Rabbit.prototype
// rabbit.__proto__.__proto__ === Animal.prototype (match!)</code>
  </li>

Here’s the illustration of what <code>rabbit instanceof Animal</code> compares with <code>Animal.prototype</code>:

<img src="https://javascript.info/article/instanceof/instanceof.png">
By the way, there’s also a method <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/object/isPrototypeOf">objA.isPrototypeOf(objB)</a>, that returns <code>true</code> if <code>objA</code> is somewhere in the chain of prototypes for <code>objB</code>. 
So the test of <code>obj instanceof Class</code> can be rephrased as <code>Class.prototype.isPrototypeOf(obj)</code>.

That’s funny, but the <code>Class</code> constructor itself does not participate in the check! Only the chain of prototypes and <code>Class.prototype</code> matters.

That can lead to interesting consequences when <code>prototype</code> is changed.

Like here:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function Rabbit() {}
let rabbit = new Rabbit();
// changed the prototype
Rabbit.prototype = {};
// ...not a rabbit any more!
alert( rabbit instanceof Rabbit ); // false</code>
  That’s one of the reasons to avoid changing <code>prototype</code>. 
Just to keep safe.

<h2>Bonus: Object toString for the type</h2>
We already know that plain objects are converted to string as <code>[object Object]</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let obj = {};
alert(obj); // [object Object]
alert(obj.toString()); // the same</code>
  That’s their implementation of <code>toString</code>. 
But there’s a hidden feature that makes <code>toString</code> actually much more powerful than that. 
We can use it as an extended <code>typeof</code> and an alternative for <code>instanceof</code>.

Sounds strange? Indeed. 
Let’s demystify.

By <a href="https://tc39.github.io/ecma262/#sec-object.prototype.tostring">specification</a>, the built-in <code>toString</code> can be extracted from the object and executed in the context of any other value. 
And its result depends on that value.

<li>For a number, it will be <code>[object Number]</code></li><li>For a boolean, it will be <code>[object Boolean]</code></li><li>For <code>null</code>: <code>[object Null]</code></li><li>For <code>undefined</code>: <code>[object Undefined]</code></li><li>For arrays: <code>[object Array]</code></li><li>…etc (customizable).</li>

Let’s demonstrate:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// copy toString method into a variable for convenience
let objectToString = Object.prototype.toString;
// what type is this?
let arr = [];
alert( objectToString.call(arr) ); // [object Array]</code>
  Here we used <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/function/call">call</a> as described in the chapter <a href="/call-apply-decorators">Decorators and forwarding, call/apply</a> to execute the function <code>objectToString</code> in the context <code>this=arr</code>.

Internally, the <code>toString</code> algorithm examines <code>this</code> and returns the corresponding result. 
More examples:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let s = Object.prototype.toString;
alert( s.call(123) ); // [object Number]
alert( s.call(null) ); // [object Null]
alert( s.call(alert) ); // [object Function]</code>
  <h3><a name="symbol-tostringtag" href="#symbol-tostringtag">Symbol.toStringTag</a></h3>
The behavior of Object <code>toString</code> can be customized using a special object property <code>Symbol.toStringTag</code>.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let user = {
  [Symbol.toStringTag]: &quot;User&quot;
};
alert( {}.toString.call(user) ); // [object User]</code>
  For most environment-specific objects, there is such a property. 
Here are few browser specific examples:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// toStringTag for the envinronment-specific object and class:
alert( window[Symbol.toStringTag]); // window
alert( XMLHttpRequest.prototype[Symbol.toStringTag] ); // XMLHttpRequest
alert( {}.toString.call(window) ); // [object Window]
alert( {}.toString.call(new XMLHttpRequest()) ); // [object XMLHttpRequest]</code>
  As you can see, the result is exactly <code>Symbol.toStringTag</code> (if exists), wrapped into <code>[object ...]</code>.

At the end we have “typeof on steroids” that not only works for primitive data types, but also for built-in objects and even can be customized.

It can be used instead of <code>instanceof</code> for built-in objects when we want to get the type as a string rather than just to check.

<h4><a name="summary" href="#summary">Summary</a4</h2>
Let’s recap the type-checking methods that we know:

<table>
<thead>
<tr>
<th></th>
<th>works for</th>
<th>returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>typeof</code></td>
<td>primitives</td>
<td>string</td>
</tr>
<tr>
<td><code>{}.toString</code></td>
<td>primitives, built-in objects, objects with <code>Symbol.toStringTag</code></td>
<td>string</td>
</tr>
<tr>
<td><code>instanceof</code></td>
<td>objects</td>
<td>true/false</td>
</tr>
</tbody>
</table>

As we can see, <code>{}.toString</code> is technically a “more advanced” <code>typeof</code>.

And <code>instanceof</code> operator really shines when we are working with a class hierarchy and want to check for the class taking into account inheritance.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function A() {}
function B() {}
A.prototype = B.prototype = {};
let a = new A();
alert( a instanceof B ); // true</code>
  <button type="button">solution</button>

Yeah, looks strange indeed.

But <code>instanceof</code> does not care about the function, but rather about its <code>prototype</code>, that it matches against the prototype chain.

And here <code>a.__proto__ == B.prototype</code>, so <code>instanceof</code> returns <code>true</code>.

So, by the logic of <code>instanceof</code>, the <code>prototype</code> actually defines the type, not the constructor function.

<button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/class-inheritance" data-tooltip="Class inheritance, super">Previous lesson</a><a href="/mixins" data-tooltip="Mixins">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Finstanceof"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Finstanceof"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Finstanceof"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Finstanceof"></a>

In JavaScript we can only inherit from a single object. 
There can be only one <code>[[Prototype]]</code> for an object. 
And a class may extend only one other class.

But sometimes that feels limiting. 
For instance, I have a class <code>StreetSweeper</code> and a class <code>Bicycle</code>, and want to make a <code>StreetSweepingBicycle</code>.

Or, talking about programming, we have a class <code>Renderer</code> that implements templating and a class <code>EventEmitter</code> that implements event handling, and want to merge these functionalities together with a class <code>Page</code>, to make a page that can use templates and emit events.

There’s a concept that can help here, called “mixins”.

As defined in Wikipedia, a <a href="https://en.wikipedia.org/wiki/Mixin">mixin</a> is a class that contains methods for use by other classes without having to be the parent class of those other classes.

In other words, a <em>mixin</em> provides methods that implement a certain behavior, but we do not use it alone, we use it to add the behavior to other classes.

<h2>A mixin example</h2>
The simplest way to make a mixin in JavaScript is to make an object with useful methods, so that we can easily merge them into a prototype of any class.

For instance here the mixin <code>sayHiMixin</code> is used to add some “speech” for <code>User</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// mixin
let sayHiMixin = {
  sayHi() {
    alert(`Hello ${this.name}`);
  },
  sayBye() {
    alert(`Bye ${this.name}`);
  }
};
// usage:
class User {
  constructor(name) {
    this.name = name;
  }
}
// copy the methods
Object.assign(User.prototype, sayHiMixin);
// now User can say hi
new User(&quot;Dude&quot;).sayHi(); // Hello Dude!</code>
  There’s no inheritance, but a simple method copying. 
So <code>User</code> may extend some other class and also include the mixin to “mix-in” the additional methods, like this:

    <code>class User extends Person {
  // ...
}
Object.assign(User.prototype, sayHiMixin);</code>
  Mixins can make use of inheritance inside themselves.

For instance, here <code>sayHiMixin</code> inherits from <code>sayMixin</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let sayMixin = {
  say(phrase) {
    alert(phrase);
  }
};
let sayHiMixin = {
  __proto__: sayMixin, // (or we could use Object.create to set the prototype here)
  sayHi() {
    // call parent method
    super.say(`Hello ${this.name}`);
  },
  sayBye() {
    super.say(`Bye ${this.name}`);
  }
};
class User {
  constructor(name) {
    this.name = name;
  }
}
// copy the methods
Object.assign(User.prototype, sayHiMixin);
// now User can say hi
new User(&quot;Dude&quot;).sayHi(); // Hello Dude!</code>
  Please note that the call to the parent method <code>super.say()</code> from <code>sayHiMixin</code> looks for the method in the prototype of that mixin, not the class.

<img src="https://javascript.info/article/mixins/mixin-inheritance.png">
That’s because methods from <code>sayHiMixin</code> have <code>[[HomeObject]]</code> set to it. 
So <code>super</code> actually means <code>sayHiMixin.__proto__</code>, not <code>User.__proto__</code>.

<h2>EventMixin</h2>
Now let’s make a mixin for real life.

The important feature of many objects is working with events.

That is: an object should have a method to “generate an event” when something important happens to it, and other objects should be able to “listen” to such events.

An event must have a name and, optionally, bundle some additional data.

For instance, an object <code>user</code> can generate an event <code>&quot;login&quot;</code> when the visitor logs in. 
And another object <code>calendar</code> may want to receive such events to load the calendar for the logged-in person.

Or, a <code>menu</code> can generate the event <code>&quot;select&quot;</code> when a menu item is selected, and other objects may want to get that information and react on that event.

Events is a way to “share information” with anyone who wants it. 
They can be useful in any class, so let’s make a mixin for them:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let eventMixin = {
  /**
   * Subscribe to event, usage:
   *  menu.on('select', function(item) { ... 
}
  */
  on(eventName, handler) {
    if (!this._eventHandlers) this._eventHandlers = {};
    if (!this._eventHandlers[eventName]) {
this._eventHandlers[eventName] = [];
    }
    this._eventHandlers[eventName].push(handler);
  },
  /**
   * Cancel the subscription, usage:
   *  menu.off('select', handler)
   */
  off(eventName, handler) {
    let handlers = this._eventHandlers &amp;&amp; this._eventHandlers[eventName];
    if (!handlers) return;
    for (let i = 0; i &lt; handlers.length; i++) {
if (handlers[i] === handler) {
  handlers.splice(i--, 1);
}
    }
  },
  /**
   * Generate the event and attach the data to it
   *  this.trigger('select', data1, data2);
   */
  trigger(eventName, ...args) {
    if (!this._eventHandlers || !this._eventHandlers[eventName]) {
return; // no handlers for that event name
    }
    // call the handlers
    this._eventHandlers[eventName].forEach(handler =&gt; handler.apply(this, args));
  }
};</code>
  There are 3 methods here:

<li><code>.on(eventName, handler)</code> – assigns function <code>handler</code> to run when the event with that name happens. 
The handlers are stored in the <code>_eventHandlers</code> property.</li><li><code>.off(eventName, handler)</code> – removes the function from the handlers list.</li><li><code>.trigger(eventName, ...args)</code> – generates the event: all assigned handlers are called and <code>args</code> are passed as arguments to them.</li>

Usage:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>// Make a class
class Menu {
  choose(value) {
    this.trigger(&quot;select&quot;, value);
  }
}
// Add the mixin
Object.assign(Menu.prototype, eventMixin);
let menu = new Menu();
// call the handler on selection:
menu.on(&quot;select&quot;, value =&gt; alert(`Value selected: ${value}`));
// triggers the event =&gt; shows Value selected: 123
menu.choose(&quot;123&quot;); // value selected</code>
  Now if we have the code interested to react on user selection, we can bind it with <code>menu.on(...)</code>.

And the <code>eventMixin</code> can add such behavior to as many classes as we’d like, without interfering with the inheritance chain.

<h4><a name="summary" href="#summary">Summary</a4</h2>
<em>Mixin</em> – is a generic object-oriented programming term: a class that contains methods for other classes.

Some other languages like e.g. 
python allow to create mixins using multiple inheritance. 
JavaScript does not support multiple inheritance, but mixins can be implemented by copying them into the prototype.

We can use mixins as a way to augment a class by multiple behaviors, like event-handling as we have seen above.

Mixins may become a point of conflict if they occasionally overwrite native class methods. 
So generally one should think well about the naming for a mixin, to minimize such possibility.

No matter how great we are at programming, sometimes our scripts have errors. 
They may occur because of our mistakes, an unexpected user input, an erroneous server response and for a thousand of other reasons.

Usually, a script “dies” (immediately stops) in case of an error, printing it to console.

But there’s a syntax construct <code>try..catch</code> that allows to “catch” errors and, instead of dying, do something more reasonable.

<h2>The “try…catch” syntax</h2>
The <code>try..catch</code> construct has two main blocks: <code>try</code>, and then <code>catch</code>:

    <code>try {
  // code...
} catch (err) {
  // error handling
}</code>
  It works like this:

<li>First, the code in <code>try {...}</code> is executed.</li><li>If there were no errors, then <code>catch(err)</code> is ignored: the execution reaches the end of <code>try</code> and then jumps over <code>catch</code>.</li><li>If an error occurs, then <code>try</code> execution is stopped, and the control flows to the beginning of <code>catch(err)</code>. 
The <code>err</code> variable (can use any name for it) contains an error object with details about what’s happened.</li>

<img src="https://javascript.info/article/try-catch/try-catch-flow.png">
So, an error inside the <code>try {…}</code> block does not kill the script: we have a chance to handle it in <code>catch</code>.

Let’s see more examples.

<li>An errorless example: shows <code>alert</code> <code>(1)</code> and <code>(2)</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>try {
  alert('Start of try runs');  // (1) &lt;--
  // ...no errors here
  alert('End of try runs');   // (2) &lt;--
} catch(err) {
  alert('Catch is ignored, because there are no errors'); // (3)
}
alert(&quot;...Then the execution continues&quot;);</code>
  </li><li>An example with an error: shows <code>(1)</code> and <code>(3)</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>try {
  alert('Start of try runs');  // (1) &lt;--
  lalala; // error, variable is not defined!
  alert('End of try (never reached)');  // (2)
} catch(err) {
  alert(`Error has occured!`); // (3) &lt;--
}
alert(&quot;...Then the execution continues&quot;);</code>
  </li>

<code>try..catch</code> only works for runtime errors
For <code>try..catch</code> to work, the code must be runnable. 
In other words, it should be valid JavaScript.

It won’t work if the code is syntactically wrong, for instance it has unmatched curly braces:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>try {
  {{{{{{{{{{{{
} catch(e) {
  alert(&quot;The engine can't understand this code, it's invalid&quot;);
}</code>
  The JavaScript engine first reads the code, and then runs it. 
The errors that occur on the reading phrase are called “parse-time” errors and are unrecoverable (from inside that code). 
That’s because the engine can’t understand the code.

So, <code>try..catch</code> can only handle errors that occur in the valid code. 
Such errors are called “runtime errors” or, sometimes, “exceptions”.

<code>try..catch</code> works synchronously
If an exception happens in “scheduled” code, like in <code>setTimeout</code>, then <code>try..catch</code> won’t catch it:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>try {
  setTimeout(function() {
    noSuchVariable; // script will die here
  }, 1000);
} catch (e) {
  alert( &quot;won't work&quot; );
}</code>
  That’s because <code>try..catch</code> actually wraps the <code>setTimeout</code> call that schedules the function. 
But the function itself is executed later, when the engine has already left the <code>try..catch</code> construct.

To catch an exception inside a scheduled function, <code>try..catch</code> must be inside that function:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>setTimeout(function() {
  try {
    noSuchVariable; // try..catch handles the error!
  } catch (e) {
    alert( &quot;error is caught here!&quot; );
  }
}, 1000);</code>
  
<h2>Error object</h2>
When an error occurs, JavaScript generates an object containing the details about it. 
The object is then passed as an argument to <code>catch</code>:

    <code>try {
  // ...
} catch(err) { // &lt;-- the &quot;error object&quot;, could use another word instead of err
  // ...
}</code>
  For all built-in errors, the error object inside <code>catch</code> block has two main properties:

<dl>
<dt><code>name</code></dt>
<dd>Error name. 
For an undefined variable that’s <code>&quot;ReferenceError&quot;</code>.</dd>
<dt><code>message</code></dt>
<dd>Textual message about error details.</dd>
</dl>

There are other non-standard properties available in most environments. 
One of most widely used and supported is:

<dl>
<dt><code>stack</code></dt>
<dd>Current call stack: a string with information about the sequence of nested calls that led to the error. 
Used for debugging purposes.</dd>
</dl>

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>try {
  lalala; // error, variable is not defined!
} catch(err) {
  alert(err.name); // ReferenceError
  alert(err.message); // lalala is not defined
  alert(err.stack); // ReferenceError: lalala is not defined at ...
  // Can also show an error as a whole
  // The error is converted to string as &quot;name: message&quot;
  alert(err); // ReferenceError: lalala is not defined
}</code>
  <h2>Using “try…catch”</h2>
Let’s explore a real-life use case of <code>try..catch</code>.

As we already know, JavaScript supports the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse">JSON.parse(str)</a> method to read JSON-encoded values.

Usually it’s used to decode data received over the network, from the server or another source.

We receive it and call <code>JSON.parse</code>, like this:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let json = '{&quot;name&quot;:&quot;John&quot;, &quot;age&quot;: 30}'; // data from the server
let user = JSON.parse(json); // convert the text representation to JS object
// now user is an object with properties from the string
alert( user.name ); // John
alert( user.age );  // 30</code>
  You can find more detailed information about JSON in the <a href="/json">JSON methods, toJSON</a> chapter.

<strong>If <code>json</code> is malformed, <code>JSON.parse</code> generates an error, so the script “dies”.</strong>

Should we be satisfied with that? Of course, not!

This way, if something’s wrong with the data, the visitor will never know that (unless he opens developer console). 
And people really don’t like when something “just dies” without any error message.

Let’s use <code>try..catch</code> to handle the error:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let json = &quot;{ bad json }&quot;;
try {
  let user = JSON.parse(json); // &lt;-- when an error occurs...
  alert( user.name ); // doesn't work
} catch (e) {
  // ...the execution jumps here
  alert( &quot;Our apologies, the data has errors, we'll try to request it one more time.&quot; );
  alert( e.name );
  alert( e.message );
}</code>
  Here we use the <code>catch</code> block only to show the message, but we can do much more: send a new network request, suggest an alternative to the visitor, send information about the error to a logging facility, … . 
All much better than just dying.

<h2>Throwing our own errors</h2>
What if <code>json</code> is syntactically correct, but doesn’t have a required <code>name</code> property?

Like this:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let json = '{ &quot;age&quot;: 30 }'; // incomplete data
try {
  let user = JSON.parse(json); // &lt;-- no errors
  alert( user.name ); // no name!
} catch (e) {
  alert( &quot;doesn't execute&quot; );
}</code>
  Here <code>JSON.parse</code> runs normally, but the absence of <code>name</code> is actually an error for us.

To unify error handling, we’ll use the <code>throw</code> operator.

<h3><a name="throw-operator" href="#throw-operator">“Throw” operator</a></h3>
The <code>throw</code> operator generates an error.

The syntax is:

    <code>throw &lt;error object&gt;</code>
  Technically, we can use anything as an error object. 
That may be even a primitive, like a number or a string, but it’s better to use objects, preferrably with <code>name</code> and <code>message</code> properties (to stay somewhat compatible with built-in errors).

JavaScript has many built-in constructors for standard errors: <code>Error</code>, <code>SyntaxError</code>, <code>ReferenceError</code>, <code>TypeError</code> and others. 
We can use them to create error objects as well.

Their syntax is:

    <code>let error = new Error(message);
// or
let error = new SyntaxError(message);
let error = new ReferenceError(message);
// ...</code>
  For built-in errors (not for any objects, just for errors), the <code>name</code> property is exactly the name of the constructor. 
And <code>message</code> is taken from the argument.

For instance:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let error = new Error(&quot;Things happen o_O&quot;);
alert(error.name); // Error
alert(error.message); // Things happen o_O</code>
  Let’s see what kind of error <code>JSON.parse</code> generates:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>try {
  JSON.parse(&quot;{ bad json o_O }&quot;);
} catch(e) {
  alert(e.name); // SyntaxError
  alert(e.message); // Unexpected token o in JSON at position 0
}</code>
  As we can see, that’s a <code>SyntaxError</code>.

And in our case, the absence of <code>name</code> could be treated as a syntax error also, assuming that users must have a <code>name</code>.

So let’s throw it:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let json = '{ &quot;age&quot;: 30 }'; // incomplete data
try {
  let user = JSON.parse(json); // &lt;-- no errors
  if (!user.name) {
    throw new SyntaxError(&quot;Incomplete data: no name&quot;); // (*)
  }
  alert( user.name );
} catch(e) {
  alert( &quot;JSON Error: &quot; + e.message ); // JSON Error: Incomplete data: no name
}</code>
  In the line <code>(*)</code>, the <code>throw</code> operator generates a <code>SyntaxError</code> with the given <code>message</code>, the same way as JavaScript would generate it itself. 
The execution of <code>try</code> immediately stops and the control flow jumps into <code>catch</code>.

Now <code>catch</code> became a single place for all error handling: both for <code>JSON.parse</code> and other cases.

<h2>Rethrowing</h2>
In the example above we use <code>try..catch</code> to handle incorrect data. 
But is it possible that <em>another unexpected error</em> occurs within the <code>try {...}</code> block? Like a variable is undefined or something else, not just that “incorrect data” thing.

Like this:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let json = '{ &quot;age&quot;: 30 }'; // incomplete data
try {
  user = JSON.parse(json); // &lt;-- forgot to put &quot;let&quot; before user
  // ...
} catch(err) {
  alert(&quot;JSON Error: &quot; + err); // JSON Error: ReferenceError: user is not defined
  // (no JSON Error actually)
}</code>
  Of course, everything’s possible! Programmers do make mistakes. 
Even in open-source utilities used by millions for decades – suddenly a crazy bug may be discovered that leads to terrible hacks (like it happened with the <code>ssh</code> tool).

In our case, <code>try..catch</code> is meant to catch “incorrect data” errors. 
But by its nature, <code>catch</code> gets <em>all</em> errors from <code>try</code>. 
Here it gets an unexpected error, but still shows the same <code>&quot;JSON Error&quot;</code> message. 
That’s wrong and also makes the code more difficult to debug.

Fortunately, we can find out which error we get, for instance from its <code>name</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>try {
  user = { /*...*/ };
} catch(e) {
  alert(e.name); // &quot;ReferenceError&quot; for accessing an undefined variable
}</code>
  The rule is simple:

<strong>Catch should only process errors that it knows and “rethrow” all others.</strong>

The “rethrowing” technique can be explained in more detail as:

<li>Catch gets all errors.</li><li>In <code>catch(err) {...}</code> block we analyze the error object <code>err</code>.</li><li>If we don’t know how to handle it, then we do <code>throw err</code>.</li>

In the code below, we use rethrowing so that <code>catch</code> only handles <code>SyntaxError</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let json = '{ &quot;age&quot;: 30 }'; // incomplete data
try {
  let user = JSON.parse(json);
  if (!user.name) {
    throw new SyntaxError(&quot;Incomplete data: no name&quot;);
  }
  blabla(); // unexpected error
  alert( user.name );
} catch(e) {
  if (e.name == &quot;SyntaxError&quot;) {
    alert( &quot;JSON Error: &quot; + e.message );
  } else {
    throw e; // rethrow (*)
  }
}</code>
  The error throwing on line <code>(*)</code> from inside <code>catch</code> block “falls out” of <code>try..catch</code> and can be either caught by an outer <code>try..catch</code> construct (if it exists), or it kills the script.

So the <code>catch</code> block actually handles only errors that it knows how to deal with and “skips” all others.

The example below demonstrates how such errors can be caught by one more level of <code>try..catch</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function readData() {
  let json = '{ &quot;age&quot;: 30 }';
  try {
    // ...
    blabla(); // error!
  } catch (e) {
    // ...
    if (e.name != 'SyntaxError') {
throw e; // rethrow (don't know how to deal with it)
    }
  }
}
try {
  readData();
} catch (e) {
  alert( &quot;External catch got: &quot; + e ); // caught it!
}</code>
  Here <code>readData</code> only knows how to handle <code>SyntaxError</code>, while the outer <code>try..catch</code> knows how to handle everything.

<h2>try…catch…finally</h2>
Wait, that’s not all.

The <code>try..catch</code> construct may have one more code clause: <code>finally</code>.

If it exists, it runs in all cases:

<li>after <code>try</code>, if there were no errors,</li><li>after <code>catch</code>, if there were errors.</li>

The extended syntax looks like this:

    <code>try {
   ... 
try to execute the code ...
} catch(e) {
   ... 
handle errors ...
} finally {
   ... 
execute always ...
}</code>
  Try running this code:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>try {
  alert( 'try' );
  if (confirm('Make an error?')) BAD_CODE();
} catch (e) {
  alert( 'catch' );
} finally {
  alert( 'finally' );
}</code>
  The code has two ways of execution:

<li>If you answer “Yes” to “Make an error?”, then <code>try -&gt; catch -&gt; finally</code>.</li><li>If you say “No”, then <code>try -&gt; finally</code>.</li>

The <code>finally</code> clause is often used when we start doing something before <code>try..catch</code> and want to finalize it in any case of outcome.

For instance, we want to measure the time that a Fibonacci numbers function <code>fib(n)</code> takes. 
Naturally, we can start measuring before it runs and finish afterwards. 
But what if there’s an error during the function call? In particular, the implementation of <code>fib(n)</code> in the code below returns an error for negative or non-integer numbers.

The <code>finally</code> clause is a great place to finish the measurements no matter what.

Here <code>finally</code> guarantees that the time will be measured correctly in both situations – in case of a successful execution of <code>fib</code> and in case of an error in it:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>let num = +prompt(&quot;Enter a positive integer number?&quot;, 35)
let diff, result;
function fib(n) {
  if (n &lt; 0 || Math.trunc(n) != n) {
    throw new Error(&quot;Must not be negative, and also an integer.&quot;);
  }
  return n &lt;= 1 ? n : fib(n - 1) + fib(n - 2);
}
let start = Date.now();
try {
  result = fib(num);
} catch (e) {
  result = 0;
} finally {
  diff = Date.now() - start;
}
alert(result || &quot;error occured&quot;);
alert( `execution took ${diff}ms` );</code>
  You can check by running the code with entering <code>35</code> into <code>prompt</code> – it executes normally, <code>finally</code> after <code>try</code>. 
And then enter <code>-1</code> – there will be an immediate error, an the execution will take <code>0ms</code>. 
Both measurements are done correctly.

In other words, there may be two ways to exit a function: either a <code>return</code> or <code>throw</code>. 
The <code>finally</code> clause handles them both.

Variables are local inside <code>try..catch..finally</code>
Please note that <code>result</code> and <code>diff</code> variables in the code above are declared <em>before</em> <code>try..catch</code>.

Otherwise, if <code>let</code> were made inside the <code>{...}</code> block, it would only be visible inside of it.

<code>finally</code> and <code>return</code>
The <code>finally</code> clause works for <em>any</em> exit from <code>try..catch</code>. 
That includes an explicit <code>return</code>.

In the example below, there’s a <code>return</code> in <code>try</code>. 
In this case, <code>finally</code> is executed just before the control returns to the outer code.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function func() {
  try {
    return 1;
  } catch (e) {
    /* ... 
*/
  } finally {
    alert( 'finally' );
  }
}
alert( func() ); // first works alert from finally, and then this one</code>
  

<code>try..finally</code>
The <code>try..finally</code> construct, without <code>catch</code> clause, is also useful. 
We apply it when we don’t want to handle errors right here, but want to be sure that processes that we started are finalized.

    <code>function func() {
  // start doing something that needs completion (like measurements)
  try {
    // ...
  } finally {
    // complete that thing even if all dies
  }
}</code>
  In the code above, an error inside <code>try</code> always falls out, because there’s no <code>catch</code>. 
But <code>finally</code> works before the execution flow jumps outside.

<h2>Global catch</h2>

Environment-specific
The information from this section is not a part of the core JavaScript.

Let’s imagine we’ve got a fatal error outside of <code>try..catch</code>, and the script died. 
Like a programming error or something else terrible.

Is there a way to react on such occurrences? We may want to log the error, show something to the user (normally he doesn’t see error messages) etc.

There is none in the specification, but environments usually provide it, because it’s really useful. 
For instance, Node.JS has <a href="https://nodejs.org/api/process.html#process_event_uncaughtexception">process.on(‘uncaughtException’)</a> for that. 
And in the browser we can assign a function to special <a href="https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onerror">window.onerror</a> property. 
It will run in case of an uncaught error.

The syntax:

    <code>window.onerror = function(message, url, line, col, error) {
  // ...
};</code>
  <dl>
<dt><code>message</code></dt>
<dd>Error message.</dd>
<dt><code>url</code></dt>
<dd>URL of the script where error happened.</dd>
<dt><code>line</code>, <code>col</code></dt>
<dd>Line and column numbers where error happened.</dd>
<dt><code>error</code></dt>
<dd>Error object.</dd>
</dl>

For instance:

    

      <a href="#" title="show" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>&lt;script&gt;
  window.onerror = function(message, url, line, col, error) {
    alert(`${message}\n At ${line}:${col} of ${url}`);
  };
  function readData() {
    badFunc(); // Whoops, something went wrong!
  }
  readData();
&lt;/script&gt;</code>
  The role of the global handler <code>window.onerror</code> is usually not to recover the script execution – that’s probably impossible in case of programming errors, but to send the error message to developers.

There are also web-services that provide error-logging for such cases, like <a href="https://errorception.com">https://errorception.com</a> or <a href="http://www.muscula.com">http://www.muscula.com</a>.

They work like this:

<li>We register at the service and get a piece of JS (or a script URL) from them to insert on pages.</li><li>That JS script has a custom <code>window.onerror</code> function.</li><li>When an error occurs, it sends a network request about it to the service.</li><li>We can log in to the service web interface and see errors.</li>

<h4><a name="summary" href="#summary">Summary</a4</h2>
The <code>try..catch</code> construct allows to handle runtime errors. 
It literally allows to try running the code and catch errors that may occur in it.

The syntax is:

    <code>try {
  // run this code
} catch(err) {
  // if an error happened, then jump here
  // err is the error object
} finally {
  // do in any case after try/catch
}</code>
  There may be no <code>catch</code> section or no <code>finally</code>, so <code>try..catch</code> and <code>try..finally</code> are also valid.

Error objects have following properties:

<li><code>message</code> – the human-readable error message.</li><li><code>name</code> – the string with error name (error constructor name).</li><li><code>stack</code> (non-standard) – the stack at the moment of error creation.</li>

We can also generate our own errors using the <code>throw</code> operator. 
Technically, the argument of <code>throw</code> can be anything, but usually it’s an error object inheriting from the built-in <code>Error</code> class. 
More on extending errors in the next chapter.

Rethrowing is a basic pattern of error handling: a <code>catch</code> block usually expects and knows how to handle the particular error type, so it should rethrow errors it doesn’t know.

Even if we don’t have <code>try..catch</code>, most environments allow to setup a “global” error handler to catch errors that “fall out”. 
In-browser that’s <code>window.onerror</code>.

<li>The first one uses <code>finally</code> to execute the code after <code>try..catch</code>:

    <code>try {
  work work
} catch (e) {
  handle errors
} finally {
  cleanup the working space
}</code>
  </li><li>The second fragment puts the cleaning right after <code>try..catch</code>:

    <code>try {
  work work
} catch (e) {
  handle errors
}
cleanup the working space</code>
  </li>

We definitely need the cleanup after the work has started, doesn’t matter if there was an error or not.

Is there an advantage here in using <code>finally</code> or both code fragments are equal? If there is such an advantage, then give an example when it matters.

<button type="button">solution</button>

The difference becomes obvious when we look at the code inside a function.

The behavior is different if there’s a “jump out” of <code>try..catch</code>.

For instance, when there’s a <code>return</code> inside <code>try..catch</code>. 
The <code>finally</code> clause works in case of <em>any</em> exit from <code>try..catch</code>, even via the <code>return</code> statement: right after <code>try..catch</code> is done, but before the calling code gets the control.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function f() {
  try {
    alert('start');
    return &quot;result&quot;;
  } catch (e) {
    /// ...
  } finally {
    alert('cleanup!');
  }
}
f(); // cleanup!</code>
  …Or when there’s a <code>throw</code>, like here:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>function f() {
  try {
    alert('start');
    throw new Error(&quot;an error&quot;);
  } catch (e) {
    // ...
    if(&quot;can't handle the error&quot;) {
throw e;
    }
  } finally {
    alert('cleanup!')
  }
}
f(); // cleanup!</code>
  It’s <code>finally</code> that guarantees the cleanup here. 
If we just put the code at the end of <code>f</code>, it wouldn’t run.

<button type="button" title="close"></button><!--if lang == 'en'--><!--  include /blocks/banner-bottom.en-->

<a href="/error-handling" data-tooltip="Error handling">Previous lesson</a><a href="/custom-errors" data-tooltip="Custom errors, extending Error">Next lesson</a>

Share<a href="https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Ftry-catch"></a><a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Ftry-catch"></a><a href="https://plus.google.com/share?url=https%3A%2F%2Fjavascript.info%2Ftry-catch"></a><a href="https://vkontakte.ru/share.php?url=https%3A%2F%2Fjavascript.info%2Ftry-catch"></a>

When we develop something, we often need our own error classes to reflect specific things that may go wrong in our tasks. 
For errors in network operations we may need <code>HttpError</code>, for database operations <code>DbError</code>, for searching operations <code>NotFoundError</code> and so on.

Our errors should support basic error properties like <code>message</code>, <code>name</code> and, preferably, <code>stack</code>. 
But they also may have other properties of their own, e.g. 
<code>HttpError</code> objects may have <code>statusCode</code> property with a value like <code>404</code> or <code>403</code> or <code>500</code>.

JavaScript allows to use <code>throw</code> with any argument, so technically our custom error classes don’t need to inherit from <code>Error</code>. 
But if we inherit, then it becomes possible to use <code>obj instanceof Error</code> to identify error objects. 
So it’s better to inherit from it.

As we build our application, our own errors naturally form a hierarchy, for instance <code>HttpTimeoutError</code> may inherit from <code>HttpError</code>, and so on.

<h2>Extending Error</h2>
As an example, let’s consider a function <code>readUser(json)</code> that should read JSON with user data.

Here’s an example of how a valid <code>json</code> may look:

    <code>let json = `{ &quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30 }`;</code>
  Internally, we’ll use <code>JSON.parse</code>. 
If it receives malformed <code>json</code>, then it throws <code>SyntaxError</code>.

But even if <code>json</code> is syntactically correct, that doesn’t mean that it’s a valid user, right? It may miss the necessary data. 
For instance, if may not have <code>name</code> and <code>age</code> properties that are essential for our users.

Our function <code>readUser(json)</code> will not only read JSON, but check (“validate”) the data. 
If there are no required fields, or the format is wrong, then that’s an error. 
And that’s not a <code>SyntaxError</code>, because the data is syntactically correct, but another kind of error. 
We’ll call it <code>ValidationError</code> and create a class for it. 
An error of that kind should also carry the information about the offending field.

Our <code>ValidationError</code> class should inherit from the built-in <code>Error</code> class.

That class is built-in, but we should have its approximate code before our eyes, to understand what we’re extending.

So here you are:

    <code>// The &quot;pseudocode&quot; for the built-in Error class defined by JavaScript itself
class Error {
  constructor(message) {
    this.message = message;
    this.name = &quot;Error&quot;; // (different names for different built-in error classes)
    this.stack = &lt;nested calls&gt;; // non-standard, but most environments support it
  }
}</code>
  Now let’s go on and inherit <code>ValidationError</code> from it:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>class ValidationError extends Error {
  constructor(message) {
    super(message); // (1)
    this.name = &quot;ValidationError&quot;; // (2)
  }
}
function test() {
  throw new ValidationError(&quot;Whoops!&quot;);
}
try {
  test();
} catch(err) {
  alert(err.message); // Whoops!
  alert(err.name); // ValidationError
  alert(err.stack); // a list of nested calls with line numbers for each
}</code>
  Please take a look at the constructor:

<li>In the line <code>(1)</code> we call the parent constructor. 
JavaScript requires us to call <code>super</code> in the child constructor, so that’s obligatory. 
The parent constructor sets the <code>message</code> property.</li><li>The parent constructor also sets the <code>name</code> property to <code>&quot;Error&quot;</code>, so in the line <code>(2)</code> we reset it to the right value.</li>

Let’s try to use it in <code>readUser(json)</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = &quot;ValidationError&quot;;
  }
}
// Usage
function readUser(json) {
  let user = JSON.parse(json);
  if (!user.age) {
    throw new ValidationError(&quot;No field: age&quot;);
  }
  if (!user.name) {
    throw new ValidationError(&quot;No field: name&quot;);
  }
  return user;
}
// Working example with try..catch
try {
  let user = readUser('{ &quot;age&quot;: 25 }');
} catch (err) {
  if (err instanceof ValidationError) {
    alert(&quot;Invalid data: &quot; + err.message); // Invalid data: No field: name
  } else if (err instanceof SyntaxError) { // (*)
    alert(&quot;JSON Syntax Error: &quot; + err.message);
  } else {
    throw err; // unknown error, rethrow it (**)
  }
}</code>
  The <code>try..catch</code> block in the code above handles both our <code>ValidationError</code> and the built-in <code>SyntaxError</code> from <code>JSON.parse</code>.

Please take a look at how we use <code>instanceof</code> to check for the specific error type in the line <code>(*)</code>.

We could also look at <code>err.name</code>, like this:

    <code>// ...
// instead of (err instanceof SyntaxError)
} else if (err.name == &quot;SyntaxError&quot;) { // (*)
// ...</code>
  The <code>instanceof</code> version is much better, because in the future we are going to extend <code>ValidationError</code>, make subtypes of it, like <code>PropertyRequiredError</code>. 
And <code>instanceof</code> check will continue to work for new inheriting classes. 
So that’s future-proof.

Also it’s important that if <code>catch</code> meets an unknown error, then it rethrows it in the line <code>(**)</code>. 
The <code>catch</code>  only knows how to handle validation and syntax errors, other kinds (due to a typo in the code or such) should fall through.

<h2>Further inheritance</h2>
The <code>ValidationError</code> class is very generic. 
Many things may go wrong. 
The property may be absent or it may be in a wrong format (like a string value for <code>age</code>). 
Let’s make a more concrete class <code>PropertyRequiredError</code>, exactly for absent properties. 
It will carry additional information about the property that’s missing.

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = &quot;ValidationError&quot;;
  }
}
class PropertyRequiredError extends ValidationError {
  constructor(property) {
    super(&quot;No property: &quot; + property);
    this.name = &quot;PropertyRequiredError&quot;;
    this.property = property;
  }
}
// Usage
function readUser(json) {
  let user = JSON.parse(json);
  if (!user.age) {
    throw new PropertyRequiredError(&quot;age&quot;);
  }
  if (!user.name) {
    throw new PropertyRequiredError(&quot;name&quot;);
  }
  return user;
}
// Working example with try..catch
try {
  let user = readUser('{ &quot;age&quot;: 25 }');
} catch (err) {
  if (err instanceof ValidationError) {
    alert(&quot;Invalid data: &quot; + err.message); // Invalid data: No property: name
    alert(err.name); // PropertyRequiredError
    alert(err.property); // name
  } else if (err instanceof SyntaxError) {
    alert(&quot;JSON Syntax Error: &quot; + err.message);
  } else {
    throw err; // unknown error, rethrow it
  }
}</code>
  The new class <code>PropertyRequiredError</code> is easy to use: we only need to pass the property name: <code>new PropertyRequiredError(property)</code>. 
The human-readable <code>message</code> is generated by the constructor.

Please note that <code>this.name</code> in <code>PropertyRequiredError</code> constructor is again assigned manually. 
That may become a bit tedius – to assign <code>this.name = &lt;class name&gt;</code> when creating each custom error. 
But there’s a way out. 
We can make our own “basic error” class that removes this burden from our shoulders by using <code>this.constructor.name</code> for <code>this.name</code> in the constructor. 
And then inherit from it.

Let’s call it <code>MyError</code>.

Here’s the code with <code>MyError</code> and other custom error classes, simplified:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>class MyError extends Error {
  constructor(message) {
    super(message);
    this.name = this.constructor.name;
  }
}
class ValidationError extends MyError { }
class PropertyRequiredError extends ValidationError {
  constructor(property) {
    super(&quot;No property: &quot; + property);
    this.property = property;
  }
}
// name is correct
alert( new PropertyRequiredError(&quot;field&quot;).name ); // PropertyRequiredError</code>
  Now custom errors are much shorter, especially <code>ValidationError</code>, as we got rid of the <code>&quot;this.name = ...&quot;</code> line in the constructor.

<h2>Wrapping exceptions</h2>
The purpose of the function <code>readUser</code> in the code above is “to read the user data”, right? There may occur different kinds of errors in the process. 
Right now we have <code>SyntaxError</code> and <code>ValidationError</code>, but in the future <code>readUser</code> function may grow: the new code will probably generate other kinds of errors.

The code which calls <code>readUser</code> should handle these errors. 
Right now it uses multiple <code>if</code> in the <code>catch</code> block to check for different error types and rethrow the unknown ones. 
But if <code>readUser</code> function generates several kinds of errors – then we should ask ourselves: do we really want to check for all error types one-by-one in every code that calls <code>readUser</code>?

Often the answer is “No”: the outer code wants to be “one level above all that”. 
It wants to have some kind of “data reading error”. 
Why exactly it happened – is often irrelevant (the error message describes it). 
Or, even better if there is a way to get error details, but only if we need to.

So let’s make a new class <code>ReadError</code> to represent such errors. 
If an error occurs inside <code>readUser</code>, we’ll catch it there and generate <code>ReadError</code>. 
We’ll also keep the reference to the original error in its <code>cause</code> property. 
Then the outer code will only have to check for <code>ReadError</code>.

Here’s the code that defines <code>ReadError</code> and demonstrates its use in <code>readUser</code> and <code>try..catch</code>:

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>class ReadError extends Error {
  constructor(message, cause) {
    super(message);
    this.cause = cause;
    this.name = 'ReadError';
  }
}
class ValidationError extends Error { /*...*/ }
class PropertyRequiredError extends ValidationError { /* ... 
*/ }
function validateUser(user) {
  if (!user.age) {
    throw new PropertyRequiredError(&quot;age&quot;);
  }
  if (!user.name) {
    throw new PropertyRequiredError(&quot;name&quot;);
  }
}
function readUser(json) {
  let user;
  try {
    user = JSON.parse(json);
  } catch (err) {
    if (err instanceof SyntaxError) {
throw new ReadError(&quot;Syntax Error&quot;, err);
    } else {
throw err;
    }
  }
  try {
    validateUser(user);
  } catch (err) {
    if (err instanceof ValidationError) {
throw new ReadError(&quot;Validation Error&quot;, err);
    } else {
throw err;
    }
  }
}
try {
  readUser('{bad json}');
} catch (e) {
  if (e instanceof ReadError) {
    alert(e);
    // Original error: SyntaxError: Unexpected token b in JSON at position 1
    alert(&quot;Original error: &quot; + e.cause);
  } else {
    throw e;
  }
}</code>
  In the code above, <code>readUser</code> works exactly as described – catches syntax and validation errors and throws <code>ReadError</code> errors instead (unknown errors are rethrown as usual).

So the outer code checks <code>instanceof ReadError</code> and that’s it. 
No need to list possible all error types.

The approach is called “wrapping exceptions”, because we take “low level exceptions” and “wrap” them into <code>ReadError</code> that is more abstract and more convenient to use for the calling code. 
It is widely used in object-oriented programming.

<h4><a name="summary" href="#summary">Summary</a></h4><li>We can inherit from <code>Error</code> and other built-in error classes normally, just need to take care of <code>name</code> property and don’t forget to call <code>super</code>.</li><li>Most of the time, we should use <code>instanceof</code> to check for particular errors. 
It also works with inheritance. 
But sometimes we have an error object coming from the 3rd-party library and there’s no easy way to get the class. 
Then <code>name</code> property can be used for such checks.</li><li>Wrapping exceptions is a widespread technique when a function handles low-level exceptions and makes a higher-level object to report about the errors. 
Low-level exceptions sometimes become properties of that object like <code>err.cause</code> in the examples above, but that’s not strictly required.</li>

It should support <code>message</code>, <code>name</code> and <code>stack</code> properties.

Usage example:

    <code>let err = new FormatError(&quot;formatting error&quot;);
alert( err.message ); // formatting error
alert( err.name ); // FormatError
alert( err.stack ); // stack
alert( err instanceof FormatError ); // true
alert( err instanceof SyntaxError ); // true (because inherits from SyntaxError)</code>
  <button type="button">solution</button>

    

      <a href="#" title="run" data-action="run"></a>
  

      <a href="#" title="open in sandbox" target="_blank" data-action="edit"></a>
  

    <code>class FormatError extends SyntaxError {
  constructor(message) {
    super(message);
    this.name = &quot;FormatError&quot;;
  }
}
let err = new FormatError(&quot;formatting error&quot;);
alert( err.message ); // formatting error
alert( err.name ); // FormatError
alert( err.stack ); // stack
alert( err instanceof SyntaxError ); // true</code>
  
<script type='text/javascript' src='readbook.js'></script>
<script>
var lazyLoadInstance = new LazyLoad({
    elements_selector: ".lazy"
    // ... more custom settings?
});
</script>


</body>
</html>
