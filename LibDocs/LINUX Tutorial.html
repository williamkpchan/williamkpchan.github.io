<base target="_blank"><html><head><title>UNIX / LINUX Tutorial</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src="https://williamkpchan.github.io/lazyload.min.js"></script>
<script src='https://williamkpchan.github.io/mainscript.js'></script>
<script src="https://williamkpchan.github.io/commonfunctions.js"></script>
<script>
  var showTopicNumber = false;
  var topicEnd = "<br>";
  var bookid = "UNIX / LINUX Tutorial"
  var markerName = "h2"
</script>
<style>
body{width:80%;margin-left: 10%; font-size:24px;}
h1, h2 {color: gold;}
strong {color: orange;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px;}
</style></head><body onkeypress="chkKey()"><center>
<h1>UNIX / LINUX Tutorial</h1>
<a href="#mustWatch" class="red goldbs" target="_self">Must Watch!</a><br><br>
<div id="toc"></div></center><br><br>
<div id="mustWatch"><center><span class="red">MustWatch</span></center><br></div>
<pre><br><br>


<h2><span class="orange">UNIX / LINUX Tutorial</span></h2>

Unix is a computer Operating System which is capable of handling activities from multiple users at the same time. 
The development of Unix started around 1969 at AT&amp;T Bell Labs by Ken Thompson and Dennis Ritchie. 
This tutorial gives a very good understanding on Unix.

This tutorial has been prepared for the beginners to help them understand the basics to advanced concepts covering Unix commands, Unix shell scripting and various utilities.

We assume you have adequate exposure to Operating Systems and their functionalities. 
A basic understanding on various computer concepts will also help you in understanding the various exercises given in this tutorial.
<h2><span class="orange">Execute Unix Shell Programs</span></h2>
If you are willing to learn the Unix/Linux basic commands and Shell script but you do not have a setup for the same, then do not worry — The <a href="https://www.tutorialspoint.com/codingground.htm">CodingGround</a> is available on a highend dedicated server giving you real programming experience with the comfort of singleclick execution. 
Yes! It is absolutely free and online.

<h2><span class="orange">Unix / Linux - Getting Started</span></h2>
<h2>&emsp;What is Unix ?</h2>
The Unix operating system is a set of programs that act as a link between the computer and the user.
The computer programs that allocate the system resources and coordinate all the details of the computer's internals is called the <b>operating system</b> or the <b>kernel</b>.
Users communicate with the kernel through a program known as the <b>shell</b>. 
The shell is a command line interpreter; it translates commands entered by the user and converts them into a language that is understood by the kernel.
Unix was originally developed in 1969 by a group of AT&amp;T employees Ken Thompson, Dennis Ritchie, Douglas McIlroy, and Joe Ossanna at Bell Labs.
There are various Unix variants available in the market. 
Solaris Unix, AIX, HP Unix and BSD are a few examples. 
Linux is also a flavor of Unix which is freely available.
Several people can use a Unix computer at the same time; hence Unix is called a multiuser system.
A user can also run multiple programs at the same time; hence Unix is a multitasking environment.

<h2>&emsp;Unix Architecture</h2>
Here is a basic block diagram of a Unix system -
<img src="https://www.tutorialspoint.com/unix/images/unix_architecture.jpg" alt="Unix Architecture">The main concept that unites all the versions of Unix is the following four basics -
<b>Kernel</b> - The kernel is the heart of the operating system. 
It interacts with the hardware and most of the tasks like memory management, task scheduling and file management.
<b>Shell</b> - The shell is the utility that processes your requests. 
When you type in a command at your terminal, the shell interprets the command and calls the program that you want. 
The shell uses standard syntax for all commands. 
C Shell, Bourne Shell and Korn Shell are the most famous shells which are available with most of the Unix variants.
<b>Commands and Utilities</b> - There are various commands and utilities which you can make use of in your day to day activities. 
<b>cp</b>, <b>mv</b>, <b>cat</b> and <b>grep</b>, etc. 
are few examples of commands and utilities. 
There are over 250 standard commands plus numerous others provided through 3<sup>rd</sup> party software. 
All the commands come along with various options.
<b>Files and Directories</b> - All the data of Unix is organized into files. 
All files are then organized into directories. 
These directories are further organized into a tree-like structure called the <b>filesystem</b>.

<h3>System Bootup</h3>
If you have a computer which has the Unix operating system installed in it, then you simply need to turn on the system to make it live.
As soon as you turn on the system, it starts booting up and finally it prompts you to log into the system, which is an activity to log into the system and use it for your day-to-day activities.
<h3>Login Unix</h3>
When you first connect to a Unix system, you usually see a prompt such as the following -
login:

<h3>To log in</h3>
Have your userid (user identification) and password ready. 
Contact your system administrator if you don't have these yet.
Type your userid at the login prompt, then press <b>ENTER</b>. 
Your userid is <b>case-sensitive</b>, so be sure you type it exactly as your system administrator has instructed.
Type your password at the password prompt, then press <b>ENTER</b>. 
Your password is also case-sensitive.
If you provide the correct userid and password, then you will be allowed to enter into the system. 
Read the information and messages that comes up on the screen, which is as follows.

login : amrood
amrood's password:
Last login: Sun Jun 14 09:32:32 2009 from 62.61.164.73
$

You will be provided with a command prompt (sometime called the <b>$</b> prompt ) where you type all your commands. 
For example, to check calendar, you need to type the <b>cal</b> command as follows -
$ cal
     June 2009
Su Mo Tu We Th Fr Sa
    1  2  3  4  5  6
 7  8  9 10 11 12 13
14 15 16 17 18 19 20
21 22 23 24 25 26 27
28 29 30
$

<h3>Change Password</h3>
All Unix systems require passwords to help ensure that your files and data remain your own and that the system itself is secure from hackers and crackers. 
Following are the steps to change your password -
<b>Step 1</b> - To start, type password at the command prompt as shown below.
<b>Step 2</b> - Enter your old password, the one you're currently using.
<b>Step 3</b> - Type in your new password. 
Always keep your password complex enough so that nobody can guess it. 
But make sure, you remember it.
<b>Step 4</b> - You must verify the password by typing it again.

$ passwd
Changing password for amrood
(current) Unix password:******
New UNIX password:*******
Retype new UNIX password:*******
passwd: all authentication tokens updated  successfully
$

<b>Note</b> - We have added asterisk (*) here just to show the location where you need to enter the current and new passwords otherwise at your system. 
It does not show you any character when you type.
<h3>Listing Directories and Files</h3>
All data in Unix is organized into files. 
All files are organized into directories. 
These directories are organized into a tree-like structure called the filesystem.
You can use the <b>ls</b> command to list out all the files or directories available in a directory. 
Following is the example of using <b>ls</b> command with <b>-l</b> option.

$ ls -l
total 19621
drwxrwxr-x  2 amrood amrood      4096 Dec 25 09:59 uml
-rw-rw-r--  1 amrood amrood      5341 Dec 25 08:38 uml.jpg
drwxr-xr-x  2 amrood amrood      4096 Feb 15  2006 univ
drwxr-xr-x  2 root   root        4096 Dec  9  2007 urlspedia
-rw-r--r--  1 root   root      276480 Dec  9  2007 urlspedia.tar
drwxr-xr-x  8 root   root        4096 Nov 25  2007 usr
-rwxr-xr-x  1 root   root        3192 Nov 25  2007 webthumb.php
-rw-rw-r--  1 amrood amrood     20480 Nov 25  2007 webthumb.tar
-rw-rw-r--  1 amrood amrood      5654 Aug  9  2007 yourfile.mid
-rw-rw-r--  1 amrood amrood    166255 Aug  9  2007 yourfile.swf
$

Here entries starting with <b>d.....</b> represent directories. 
For example, uml, univ and urlspedia are directories and rest of the entries are files.
<h3>Who Are You?</h3>
While you're logged into the system, you might be willing to know : <b>Who am I</b>?
The easiest way to find out "who you are" is to enter the <b>whoami</b> command -
$ whoami
 amrood
$

Try it on your system. 
This command lists the account name associated with the current login. 
You can try <b>who am i</b> command as well to get information about yourself.
<h3>Who is Logged in?</h3>
Sometime you might be interested to know who is logged in to the computer at the same time.
There are three commands available to get you this information, based on how much you wish to know about the other users: <b>users</b>, <b>who</b>, and <b>w</b>.

$ users
 amrood bablu qadir
$ who
amrood ttyp0 Oct 8 14:10 (limbo)
bablu  ttyp2 Oct 4 09:08 (calliope)
qadir  ttyp4 Oct 8 12:09 (dent)
$

Try the <b>w</b> command on your system to check the output. 
This lists down information associated with the users logged in the system.
<h3>Logging Out</h3>
When you finish your session, you need to log out of the system. 
This is to ensure that nobody else accesses your files.
<b>To log out</b>
Just type the <b>logout</b> command at the command prompt, and the system will clean up everything and break the connection.

<h3>System Shutdown</h3>
The most consistent way to shut down a Unix system properly via the command line is to use one of the following commands -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Command &amp; Description</th></tr>
<tr><td>1</td><td><b>halt</b>
Brings the system down immediately</td></tr>
<tr><td>2</td><td><b>init 0</b>
Powers off the system using predefined scripts to synchronize and clean up the system prior to shutting down</td></tr>
<tr><td>3</td><td><b>init 6</b>
Reboots the system by shutting it down completely and then restarting it</td></tr>
<tr><td>4</td><td><b>poweroff</b>
Shuts down the system by powering off</td></tr>
<tr><td>5</td><td><b>reboot</b>
Reboots the system</td></tr>
<tr><td>6</td><td><b>shutdown</b>
Shuts down the system</td></tr>
</table>
You typically need to be the super user or root (the most privileged account on a Unix system) to shut down the system. 
However, on some standalone or personally-owned Unix boxes, an administrative user and sometimes regular users can do so.

<h2><span class="orange">Unix / Linux - File Management</span></h2>
In this chapter, we will discuss in detail about file management in Unix. 
All data in Unix is organized into files. 
All files are organized into directories. 
These directories are organized into a tree-like structure called the filesystem.
When you work with Unix, one way or another, you spend most of your time working with files. 
This tutorial will help you understand how to create and remove files, copy and rename them, create links to them, etc.
In Unix, there are three basic types of files -
<b>Ordinary Files</b> - An ordinary file is a file on the system that contains data, text, or program instructions. 
In this tutorial, you look at working with ordinary files.
<b>Directories</b> - Directories store both special and ordinary files. 
For users familiar with Windows or Mac OS, Unix directories are equivalent to folders.
<b>Special Files</b> - Some special files provide access to hardware such as hard drives, CD-ROM drives, modems, and Ethernet adapters. 
Other special files are similar to aliases or shortcuts and enable you to access a single file using different names.

<h2>&emsp;Listing Files</h2>
To list the files and directories stored in the current directory, use the following command -
$ls

Here is the sample output of the above command -
$ls
bin        hosts  lib     res.03
ch07       hw1    pub     test_results
ch07.bak   hw2    res.01  users
docs       hw3    res.02  work

The command <b>ls</b> supports the <b>-l</b> option which would help you to get more information about the listed files -
$ls -l
total 1962188
drwxrwxr-x  2 amrood amrood      4096 Dec 25 09:59 uml
-rw-rw-r--  1 amrood amrood      5341 Dec 25 08:38 uml.jpg
drwxr-xr-x  2 amrood amrood      4096 Feb 15  2006 univ
drwxr-xr-x  2 root   root        4096 Dec  9  2007 urlspedia
-rw-r--r--  1 root   root      276480 Dec  9  2007 urlspedia.tar
drwxr-xr-x  8 root   root        4096 Nov 25  2007 usr
drwxr-xr-x  2    200    300      4096 Nov 25  2007 webthumb-1.01
-rwxr-xr-x  1 root   root        3192 Nov 25  2007 webthumb.php
-rw-rw-r--  1 amrood amrood     20480 Nov 25  2007 webthumb.tar
-rw-rw-r--  1 amrood amrood      5654 Aug  9  2007 yourfile.mid
-rw-rw-r--  1 amrood amrood    166255 Aug  9  2007 yourfile.swf
drwxr-xr-x 11 amrood amrood      4096 May 29  2007 zlib-1.2.3
$

Here is the information about all the listed columns -
<b>First Column</b> - Represents the file type and the permission given on the file. 
Below is the description of all type of files.
<b>Second Column</b> - Represents the number of memory blocks taken by the file or directory.
<b>Third Column</b> - Represents the owner of the file. 
This is the Unix user who created this file.
<b>Fourth Column</b> - Represents the group of the owner. 
Every Unix user will have an associated group.
<b>Fifth Column</b> - Represents the file size in bytes.
<b>Sixth Column</b> - Represents the date and the time when this file was created or modified for the last time.
<b>Seventh Column</b> - Represents the file or the directory name.

In the <b>ls -l</b> listing example, every file line begins with a <b>d</b>, <b>-</b>, or <b>l</b>. 
These characters indicate the type of the file that's listed.
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Prefix &amp; Description</th></tr>
<tr><td>1</td><td><b>-</b>
Regular file, such as an ASCII text file, binary executable, or hard link.</td></tr>
<tr><td>2</td><td><b>b</b>
Block special file. 
Block input/output device file such as a physical hard drive.</td></tr>
<tr><td>3</td><td><b>c</b>
Character special file. 
Raw input/output device file such as a physical hard drive.</td></tr>
<tr><td>4</td><td><b>d</b>
Directory file that contains a listing of other files and directories.</td></tr>
<tr><td>5</td><td><b>l</b>
Symbolic link file. 
Links on any regular file.</td></tr>
<tr><td>6</td><td><b>p</b>
Named pipe. 
A mechanism for interprocess communications.</td></tr>
<tr><td>7</td><td><b>s</b>
Socket used for interprocess communication.</td></tr>
</table>
<h2>&emsp;Metacharacters</h2>
Metacharacters have a special meaning in Unix. 
For example, <b>*</b> and <b>?</b> are metacharacters. 
We use <b>*</b> to match 0 or more characters, a question mark (<b>?</b>) matches with a single character.
For Example -
$ls ch*.doc

Displays all the files, the names of which start with <b>ch</b> and end with <b>.doc</b> -
ch01-1.doc   ch010.doc  ch02.doc    ch03-2.doc 
ch04-1.doc   ch040.doc  ch05.doc    ch06-2.doc
ch01-2.doc ch02-1.doc c

Here, <b>*</b> works as meta character which matches with any character. 
If you want to display all the files ending with just <b>.doc</b>, then you can use the following command -
$ls *.doc

<h2>&emsp;Hidden Files</h2>
An invisible file is one, the first character of which is the dot or the period character (.). 
Unix programs (including the shell) use most of these files to store configuration information.
Some common examples of the hidden files include the files -
<b>.profile</b> - The Bourne shell ( sh) initialization script
<b>.kshrc</b> - The Korn shell ( ksh) initialization script
<b>.cshrc</b> - The C shell ( csh) initialization script
<b>.rhosts</b> - The remote shell configuration file

To list the invisible files, specify the <b>-a</b> option to <b>ls</b> -
$ ls -a
. 
        .profile       docs     lib     test_results
.. 
       .rhosts        hosts    pub     users
.emacs    bin            hw1      res.01  work
.exrc     ch07           hw2      res.02
.kshrc    ch07.bak       hw3      res.03
$

<b>Single dot (.)</b> - This represents the current directory.
<b>Double dot (..)</b> - This represents the parent directory.

<h2>&emsp;Creating Files</h2>
You can use the <b>vi</b> editor to create ordinary files on any Unix system. 
You simply need to give the following command -
$ vi filename

The above command will open a file with the given filename. 
Now, press the key <b>i</b> to come into the edit mode. 
Once you are in the edit mode, you can start writing your content in the file as in the following program -
This is unix file....I created it for the first time.....
I'm going to save this content in this file.

Once you are done with the program, follow these steps -
Press the key <b>esc</b> to come out of the edit mode.
Press two keys <b>Shift &amp;plus; ZZ</b> together to come out of the file completely.

You will now have a file created with <b>filename</b> in the current directory.

$ vi filename
$

<h2>&emsp;Editing Files</h2>
You can edit an existing file using the <b>vi</b> editor. 
We will discuss in short how to open an existing file -
$ vi filename

Once the file is opened, you can come in the edit mode by pressing the key <b>i</b> and then you can proceed by editing the file. 
If you want to move here and there inside a file, then first you need to come out of the edit mode by pressing the key <b>Esc</b>. 
After this, you can use the following keys to move inside a file -
<b>l</b> key to move to the right side.
<b>h</b> key to move to the left side.
<b>k</b> key to move upside in the file.
<b>j</b> key to move downside in the file.

So using the above keys, you can position your cursor wherever you want to edit. 
Once you are positioned, then you can use the <b>i</b> key to come in the edit mode. 
Once you are done with the editing in your file, press <b>Esc</b> and finally two keys <b>Shift &amp;plus; ZZ</b> together to come out of the file completely.
<h2>&emsp;Display Content of a File</h2>
You can use the <b>cat</b> command to see the content of a file. 
Following is a simple example to see the content of the above created file -
$ cat filename
This is unix file....I created it for the first time.....
I'm going to save this content in this file.
$

You can display the line numbers by using the <b>-b</b> option along with the <b>cat</b> command as follows -
$ cat -b filename
1   This is unix file....I created it for the first time.....
2   I'm going to save this content in this file.
$

<h2>&emsp;Counting Words in a File</h2>
You can use the <b>wc</b> command to get a count of the total number of lines, words, and characters contained in a file. 
Following is a simple example to see the information about the file created above -
$ wc filename
2  19 103 filename
$

Here is the detail of all the four columns -
<b>First Column</b> - Represents the total number of lines in the file.
<b>Second Column</b> - Represents the total number of words in the file.
<b>Third Column</b> - Represents the total number of bytes in the file. 
This is the actual size of the file.
<b>Fourth Column</b> - Represents the file name.

You can give multiple files and get information about those files at a time. 
Following is simple syntax -
$ wc filename1 filename2 filename3

<h2>&emsp;Copying Files</h2>
To make a copy of a file use the <b>cp</b> command. 
The basic syntax of the command is -
$ cp source_file destination_file

Following is the example to create a copy of the existing file <b>filename</b>.

$ cp filename copyfile
$

You will now find one more file <b>copyfile</b> in your current directory. 
This file will exactly be the same as the original file <b>filename</b>.
<h2>&emsp;Renaming Files</h2>
To change the name of a file, use the <b>mv</b> command. 
Following is the basic syntax -
$ mv old_file new_file

The following program will rename the existing file <b>filename</b> to <b>newfile</b>.

$ mv filename newfile
$

The <b>mv</b> command will move the existing file completely into the new file. 
In this case, you will find only <b>newfile</b> in your current directory.
<h2>&emsp;Deleting Files</h2>
To delete an existing file, use the <b>rm</b> command. 
Following is the basic syntax -
$ rm filename

<b>Caution</b> - A file may contain useful information. 
It is always recommended to be careful while using this <b>Delete</b> command. 
It is better to use the <b>-i</b> option along with <b>rm</b> command.
Following is the example which shows how to completely remove the existing file <b>filename</b>.

$ rm filename
$

You can remove multiple files at a time with the command given below -
$ rm filename1 filename2 filename3
$

<h2>&emsp;Standard Unix Streams</h2>
Under normal circumstances, every Unix program has three streams (files) opened for it when it starts up -
<b>stdin</b> - This is referred to as the <i>standard input</i> and the associated file descriptor is 0. 
This is also represented as STDIN. 
The Unix program will read the default input from STDIN.
<b>stdout</b> - This is referred to as the <i>standard output</i> and the associated file descriptor is 1. 
This is also represented as STDOUT. 
The Unix program will write the default output at STDOUT
<b>stderr</b> - This is referred to as the <i>standard error</i> and the associated file descriptor is 2. 
This is also represented as STDERR. 
The Unix program will write all the error messages at STDERR.

<h2><span class="orange">Unix / Linux - Directory Management</span></h2>
In this chapter, we will discuss in detail about directory management in Unix.
A directory is a file the solo job of which is to store the file names and the related information. 
All the files, whether ordinary, special, or directory, are contained in directories.
Unix uses a hierarchical structure for organizing files and directories. 
This structure is often referred to as a directory tree. 
The tree has a single root node, the slash character (<b>/</b>), and all other directories are contained below it.
<h2>&emsp;Home Directory</h2>
The directory in which you find yourself when you first login is called your home directory.
You will be doing much of your work in your home directory and subdirectories that you'll be creating to organize your files.
You can go in your home directory anytime using the following command -
$cd ~
$

Here <b>~</b> indicates the home directory. 
Suppose you have to go in any other user's home directory, use the following command -
$cd ~username
$

To go in your last directory, you can use the following command -
$cd -
$

<h2>&emsp;Absolute/Relative Pathnames</h2>
Directories are arranged in a hierarchy with root (/) at the top. 
The position of any file within the hierarchy is described by its pathname.
Elements of a pathname are separated by a /. 
A pathname is absolute, if it is described in relation to root, thus absolute pathnames always begin with a /.
Following are some examples of absolute filenames.

/etc/passwd
/users/sjones/chem/notes
/dev/rdsk/Os3

A pathname can also be relative to your current working directory. 
Relative pathnames never begin with /. 
Relative to user amrood's home directory, some pathnames might look like this -
chem/notes
personal/res

To determine where you are within the filesystem hierarchy at any time, enter the command <b>pwd</b> to print the current working directory -
$pwd
/user0/home/amrood
$

<h2>&emsp;Listing Directories</h2>
To list the files in a directory, you can use the following syntax -
$ls dirname

Following is the example to list all the files contained in <b>/usr/local</b> directory -
$ls /usr/local
X11       bin          gimp       jikes       sbin
ace       doc          include    lib         share
atalk     etc          info       man         ami

<h2>&emsp;Creating Directories</h2>
We will now understand how to create directories. 
Directories are created by the following command -
$mkdir dirname

Here, directory is the absolute or relative pathname of the directory you want to create. 
For example, the command -
$mkdir mydir
$

Creates the directory <b>mydir</b> in the current directory. 
Here is another example -
$mkdir /tmp/test-dir
$

This command creates the directory <b>test-dir</b> in the <b>/tmp</b> directory. 
The <b>mkdir</b> command produces no output if it successfully creates the requested directory.
If you give more than one directory on the command line, <b>mkdir</b> creates each of the directories. 
For example, -
$mkdir docs pub
$

Creates the directories docs and pub under the current directory.
<h2>&emsp;Creating Parent Directories</h2>
We will now understand how to create parent directories. 
Sometimes when you want to create a directory, its parent directory or directories might not exist. 
In this case, <b>mkdir</b> issues an error message as follows -
$mkdir /tmp/amrood/test
mkdir: Failed to make directory "/tmp/amrood/test"; 
No such file or directory
$

In such cases, you can specify the <b>-p</b> option to the <b>mkdir</b> command. 
It creates all the necessary directories for you. 
For example -
$mkdir -p /tmp/amrood/test
$

The above command creates all the required parent directories.
<h2>&emsp;Removing Directories</h2>
Directories can be deleted using the <b>rmdir</b> command as follows -
$rmdir dirname
$

<b>Note</b> - To remove a directory, make sure it is empty which means there should not be any file or sub-directory inside this directory.
You can remove multiple directories at a time as follows -
$rmdir dirname1 dirname2 dirname3
$

The above command removes the directories dirname1, dirname2, and dirname3, if they are empty. 
The <b>rmdir</b> command produces no output if it is successful.
<h2>&emsp;Changing Directories</h2>
You can use the <b>cd</b> command to do more than just change to a home directory. 
You can use it to change to any directory by specifying a valid absolute or relative path. 
The syntax is as given below -
$cd dirname
$

Here, <b>dirname</b> is the name of the directory that you want to change to. 
For example, the command -
$cd /usr/local/bin
$

Changes to the directory <b>/usr/local/bin</b>. 
From this directory, you can <b>cd</b> to the directory <b>/usr/home/amrood</b> using the following relative path -
$cd ../../home/amrood
$

<h2>&emsp;Renaming Directories</h2>
The <b>mv (move)</b> command can also be used to rename a directory. 
The syntax is as follows -
$mv olddir newdir
$

You can rename a directory <b>mydir</b> to <b>yourdir</b> as follows -
$mv mydir yourdir
$

<h2>&emsp;The directories .(dot) and ..(dot dot)</h2>
The <b>filename .</b> (dot) represents the current working directory; and the <b>filename ..</b> (dot dot) represents the directory one level above the current working directory, often referred to as the parent directory.
If we enter the command to show a listing of the current working directories/files and use the <b>-a option</b> to list all the files and the <b>-l option</b> to provide the long listing, we will receive the following result.

$ls -la
drwxrwxr-x    4    teacher   class   2048  Jul 16 17.56 .
drwxr-xr-x    60   root              1536  Jul 13 14:18 ..
----------    1    teacher   class   4210  May 1 08:27 .profile
-rwxr-xr-x    1    teacher   class   1948  May 12 13:42 memo
$

<h2><span class="orange">Unix / Linux - File Permission / Access Modes</span></h2>
In this chapter, we will discuss in detail about file permission and access modes in Unix. 
File ownership is an important component of Unix that provides a secure method for storing files. 
Every file in Unix has the following attributes -
<b>Owner permissions</b> - The owner's permissions determine what actions the owner of the file can perform on the file.
<b>Group permissions</b> - The group's permissions determine what actions a user, who is a member of the group that a file belongs to, can perform on the file.
<b>Other (world) permissions</b> - The permissions for others indicate what action all other users can perform on the file.

<h2>&emsp;The Permission Indicators</h2>
While using <b>ls -l</b> command, it displays various information related to file permission as follows -
$ls -l /home/amrood
-rwxr-xr--  1 amrood   users 1024  Nov 2 00:10  myfile
drwxr-xr--- 1 amrood   users 1024  Nov 2 00:10  mydir

Here, the first column represents different access modes, i.e., the permission associated with a file or a directory.
The permissions are broken into groups of threes, and each position in the group denotes a specific permission, in this order: read (r), write (w), execute (x) -
The first three characters (2-4) represent the permissions for the file's owner. 
For example, <b>-rwxr-xr--</b> represents that the owner has read (r), write (w) and execute (x) permission.
The second group of three characters (5-7) consists of the permissions for the group to which the file belongs. 
For example, <b>-rwxr-xr--</b> represents that the group has read (r) and execute (x) permission, but no write permission.
The last group of three characters (8-10) represents the permissions for everyone else. 
For example, <b>-rwxr-xr--</b> represents that there is <b>read (r)</b> only permission.

<h2>&emsp;File Access Modes</h2>
The permissions of a file are the first line of defense in the security of a Unix system. 
The basic building blocks of Unix permissions are the <b>read</b>, <b>write</b>, and <b>execute</b> permissions, which have been described below -
<h3>Read</h3>
Grants the capability to read, i.e., view the contents of the file.
<h3>Write</h3>
Grants the capability to modify, or remove the content of the file.
<h3>Execute</h3>
User with execute permissions can run a file as a program.
<h2>&emsp;Directory Access Modes</h2>
Directory access modes are listed and organized in the same manner as any other file. 
There are a few differences that need to be mentioned -
<h3>Read</h3>
Access to a directory means that the user can read the contents. 
The user can look at the <b>filenames</b> inside the directory.
<h3>Write</h3>
Access means that the user can add or delete files from the directory.
<h3>Execute</h3>
Executing a directory doesn't really make sense, so think of this as a traverse permission.
A user must have <b>execute</b> access to the <b>bin</b> directory in order to execute the <b>ls</b> or the <b>cd</b> command.
<h2>&emsp;Changing Permissions</h2>
To change the file or the directory permissions, you use the <b>chmod</b> (change mode) command. 
There are two ways to use chmod — the symbolic mode and the absolute mode.
<h3>Using chmod in Symbolic Mode</h3>
The easiest way for a beginner to modify file or directory permissions is to use the symbolic mode. 
With symbolic permissions you can add, delete, or specify the permission set you want by using the operators in the following table.
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Chmod operator &amp; Description</th></tr>
<tr><td>1</td><td><b>+</b>
Adds the designated permission(s) to a file or directory.</td></tr>
<tr><td>2</td><td><b>-</b>
Removes the designated permission(s) from a file or directory.</td></tr>
<tr><td>3</td><td><b>=</b>
Sets the designated permission(s).</td></tr>
</table>
Here's an example using <b>testfile</b>. 
Running <b>ls -1</b> on the testfile shows that the file's permissions are as follows -
$ls -l testfile
-rwxrwxr--  1 amrood   users 1024  Nov 2 00:10  testfile

Then each example <b>chmod</b> command from the preceding table is run on the testfile, followed by <b>ls –l</b>, so you can see the permission changes -
$chmod o+wx testfile
$ls -l testfile
-rwxrwxrwx  1 amrood   users 1024  Nov 2 00:10  testfile
$chmod u-x testfile
$ls -l testfile
-rw-rwxrwx  1 amrood   users 1024  Nov 2 00:10  testfile
$chmod g = rx testfile
$ls -l testfile
-rw-r-xrwx  1 amrood   users 1024  Nov 2 00:10  testfile

Here's how you can combine these commands on a single line -
$chmod o+wx,u-x,g = rx testfile
$ls -l testfile
-rw-r-xrwx  1 amrood   users 1024  Nov 2 00:10  testfile

<h2>&emsp;Using chmod with Absolute Permissions</h2>
The second way to modify permissions with the chmod command is to use a number to specify each set of permissions for the file.
Each permission is assigned a value, as the following table shows, and the total of each set of permissions provides a number for that set.
<table class="table table-bordered">
<tr><th>Number</th><th>Octal Permission Representation</th>
<th style="text-align:center;width:15%">Ref</th></tr>
<tr><td><b>0</b></td><td>No permission</td><td>---</td></tr>
<tr><td><b>1</b></td><td>Execute permission</td><td>--x</td></tr>
<tr><td><b>2</b></td><td>Write permission</td><td>-w-</td></tr>
<tr><td><b>3</b></td><td>Execute and write permission: 1 (execute) + 2 (write) = 3</td><td>-wx</td></tr>
<tr><td><b>4</b></td><td>Read permission</td><td>r--</td></tr>
<tr><td><b>5</b></td><td>Read and execute permission: 4 (read) &amp;plus; 1 (execute) = 5 </td><td>r-x</td></tr>
<tr><td><b>6</b></td><td>Read and write permission: 4 (read) &amp;plus; 2 (write) = 6</td><td>rw-</td></tr>
<tr><td><b>7</b></td><td>All permissions: 4 (read) &amp;plus; 2 (write) &amp;plus; 1 (execute) = 7</td><td>rwx</td></tr>
</table>
Here's an example using the testfile. 
Running <b>ls -1</b> on the testfile shows that the file's permissions are as follows -
$ls -l testfile
-rwxrwxr--  1 amrood   users 1024  Nov 2 00:10  testfile

Then each example <b>chmod</b> command from the preceding table is run on the testfile, followed by <b>ls –l</b>, so you can see the permission changes -
$ chmod 755 testfile
$ls -l testfile
-rwxr-xr-x  1 amrood   users 1024  Nov 2 00:10  testfile
$chmod 743 testfile
$ls -l testfile
-rwxr---wx  1 amrood   users 1024  Nov 2 00:10  testfile
$chmod 043 testfile
$ls -l testfile
----r---wx  1 amrood   users 1024  Nov 2 00:10  testfile

<h2>&emsp;Changing Owners and Groups</h2>
While creating an account on Unix, it assigns a <b>owner ID</b> and a <b>group ID</b> to each user. 
All the permissions mentioned above are also assigned based on the Owner and the Groups.
Two commands are available to change the owner and the group of files -
<b>chown</b> - The <b>chown</b> command stands for <b>"change owner"</b> and is used to change the owner of a file.
<b>chgrp</b> - The <b>chgrp</b> command stands for <b>"change group"</b> and is used to change the group of a file.

<h2>&emsp;Changing Ownership</h2>
The <b>chown</b> command changes the ownership of a file. 
The basic syntax is as follows -
$ chown user filelist

The value of the user can be either the <b>name of a user</b> on the system or the <b>user id (uid)</b> of a user on the system.
The following example will help you understand the concept -
$ chown amrood testfile
$

Changes the owner of the given file to the user <b>amrood</b>.
<b>NOTE</b> - The super user, root, has the unrestricted capability to change the ownership of any file but normal users can change the ownership of only those files that they own.
<h2>&emsp;Changing Group Ownership</h2>
The <b>chgrp</b> command changes the group ownership of a file. 
The basic syntax is as follows -
$ chgrp group filelist

The value of group can be the <b>name of a group</b> on the system or <b>the group ID (GID)</b> of a group on the system.
Following example helps you understand the concept -
$ chgrp special testfile
$

Changes the group of the given file to <b>special</b> group.
<h2>&emsp;SUID and SGID File Permission</h2>
Often when a command is executed, it will have to be executed with special privileges in order to accomplish its task.
As an example, when you change your password with the <b>passwd</b> command, your new password is stored in the file <b>/etc/shadow</b>.
As a regular user, you do not have <b>read</b> or <b>write</b> access to this file for security reasons, but when you change your password, you need to have the write permission to this file. 
This means that the <b>passwd</b> program has to give you additional permissions so that you can write to the file <b>/etc/shadow</b>.
Additional permissions are given to programs via a mechanism known as the <b>Set User ID (SUID)</b> and <b>Set Group ID (SGID)</b> bits.
When you execute a program that has the SUID bit enabled, you inherit the permissions of that program's owner. 
Programs that do not have the SUID bit set are run with the permissions of the user who started the program.
This is the case with SGID as well. 
Normally, programs execute with your group permissions, but instead your group will be changed just for this program to the group owner of the program.
The SUID and SGID bits will appear as the letter <b>"s"</b> if the permission is available. 
The SUID <b>"s"</b> bit will be located in the permission bits where the owners’ <b>execute</b> permission normally resides.
For example, the command -
$ ls -l /usr/bin/passwd
-r-sr-xr-x  1   root   bin  19031 Feb 7 13:47  /usr/bin/passwd*
$

Shows that the SUID bit is set and that the command is owned by the root. 
A capital letter <b>S</b> in the execute position instead of a lowercase <b>s</b> indicates that the execute bit is not set.
If the sticky bit is enabled on the directory, files can only be removed if you are one of the following users -
The owner of the sticky directory
The owner of the file being removed
The super user, root

To set the SUID and SGID bits for any directory try the following command -
$ chmod ug+s dirname
$ ls -l
drwsr-sr-x 2 root root  4096 Jun 19 06:45 dirname
$

<h2><span class="orange">Unix / Linux - Environment</span></h2>
In this chapter, we will discuss in detail about the Unix environment. 
An important Unix concept is the <b>environment</b>, which is defined by environment variables. 
Some are set by the system, others by you, yet others by the shell, or any program that loads another program.
A variable is a character string to which we assign a value. 
The value assigned could be a number, text, filename, device, or any other type of data.
For example, first we set a variable TEST and then we access its value using the <b>echo</b> command -
$TEST="Unix Programming"
$echo $TEST

It produces the following result.

Unix Programming

Note that the environment variables are set without using the <b>$</b> sign but while accessing them we use the $ sign as prefix. 
These variables retain their values until we come out of the shell.
When you log in to the system, the shell undergoes a phase called <b>initialization</b> to set up the environment. 
This is usually a two-step process that involves the shell reading the following files -
/etc/profile
profile

The process is as follows -
The shell checks to see whether the file <b>/etc/profile</b> exists.
If it exists, the shell reads it. 
Otherwise, this file is skipped. 
No error message is displayed.
The shell checks to see whether the file <b>.profile</b> exists in your home directory. 
Your home directory is the directory that you start out in after you log in.
If it exists, the shell reads it; otherwise, the shell skips it. 
No error message is displayed.

As soon as both of these files have been read, the shell displays a prompt -
$

This is the prompt where you can enter commands in order to have them executed.
<b>Note</b> - The shell initialization process detailed here applies to all <b>Bourne</b> type shells, but some additional files are used by <b>bash</b> and <b>ksh</b>.
<h2>&emsp;The .profile File</h2>
The file <b>/etc/profile</b> is maintained by the system administrator of your Unix machine and contains shell initialization information required by all users on a system.
The file <b>.profile</b> is under your control. 
You can add as much shell customization information as you want to this file. 
The minimum set of information that you need to configure includes -
The type of terminal you are using.
A list of directories in which to locate the commands.
A list of variables affecting the look and feel of your terminal.

You can check your <b>.profile</b> available in your home directory. 
Open it using the vi editor and check all the variables set for your environment.
<h2>&emsp;Setting the Terminal Type</h2>
Usually, the type of terminal you are using is automatically configured by either the <b>login</b> or <b>getty</b> programs. 
Sometimes, the auto configuration process guesses your terminal incorrectly.
If your terminal is set incorrectly, the output of the commands might look strange, or you might not be able to interact with the shell properly.
To make sure that this is not the case, most users set their terminal to the lowest common denominator in the following way -
$TERM=vt100
$

<h2>&emsp;Setting the PATH</h2>
When you type any command on the command prompt, the shell has to locate the command before it can be executed.
The PATH variable specifies the locations in which the shell should look for commands. 
Usually the Path variable is set as follows -
$PATH=/bin:/usr/bin
$

Here, each of the individual entries separated by the colon character <b>(:)</b> are directories. 
If you request the shell to execute a command and it cannot find it in any of the directories given in the PATH variable, a message similar to the following appears -
$hello
hello: not found
$

There are variables like PS1 and PS2 which are discussed in the next section.
<h2>&emsp;PS1 and PS2 Variables</h2>
The characters that the shell displays as your command prompt are stored in the variable PS1. 
You can change this variable to be anything you want. 
As soon as you change it, it'll be used by the shell from that point on.
For example, if you issued the command -
$PS1='=&gt;'
=&gt;
=&gt;
=&gt;

Your prompt will become =&gt;. 
To set the value of <b>PS1</b> so that it shows the working directory, issue the command -
=&gt;PS1="[\u@\h \w]\$"
[root@ip-72-167-112-17 /var/www/tutorialspoint/unix]$
[root@ip-72-167-112-17 /var/www/tutorialspoint/unix]$

The result of this command is that the prompt displays the user's username, the machine's name (hostname), and the working directory.
There are quite a few <b>escape sequences</b> that can be used as value arguments for PS1; try to limit yourself to the most critical so that the prompt does not overwhelm you with information.
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Escape Sequence &amp; Description</th></tr>
<tr><td>1</td><td><b>\t</b>
Current time, expressed as HH:MM:SS</td></tr>
<tr><td>2</td><td><b>\d</b>
Current date, expressed as Weekday Month Date</td></tr>
<tr><td>3</td><td><b>\n</b>
Newline</td></tr>
<tr><td>4</td><td><b>\s</b>
Current shell environment</td></tr>
<tr><td>5</td><td><b>\W</b>
Working directory</td></tr>
<tr><td>6</td><td><b>\w</b>
Full path of the working directory</td></tr>
<tr><td>7</td><td><b>\u</b>
Current user’s username</td></tr>
<tr><td>8</td><td><b>\h</b>
Hostname of the current machine</td></tr>
<tr><td>9</td><td><b>\#</b>
Command number of the current command. 
Increases when a new command is entered</td></tr>
<tr><td>10</td><td><b>\$</b>
If the effective UID is 0 (that is, if you are logged in as root), end the prompt with the # character; otherwise, use the $ sign</td></tr>
</table>
You can make the change yourself every time you log in, or you can have the change made automatically in PS1 by adding it to your <b>.profile</b> file.
When you issue a command that is incomplete, the shell will display a secondary prompt and wait for you to complete the command and hit <b>Enter</b> again.
The default secondary prompt is <b>&gt;</b> (the greater than sign), but can be changed by re-defining the <b>PS2</b> shell variable -
Following is the example which uses the default secondary prompt -
$ echo "this is a
&gt; test"
this is a
test
$

The example given below re-defines PS2 with a customized prompt -
$ PS2="secondary prompt-&gt;"
$ echo "this is a
secondary prompt-&gt;test"
this is a
test
$

<h2>&emsp;Environment Variables</h2>
Following is the partial list of important environment variables. 
These variables are set and accessed as mentioned below -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Variable &amp; Description</th></tr>
<tr><td>1</td><td><b>DISPLAY</b>
Contains the identifier for the display that <b>X11</b> programs should use by default.</td></tr>
<tr><td>2</td><td><b>HOME</b>
Indicates the home directory of the current user: the default argument for the cd <b>built-in</b> command.</td></tr>
<tr><td>3</td><td><b>IFS</b>
Indicates the <b>Internal Field Separator</b> that is used by the parser for word splitting after expansion.</td></tr>
<tr><td>4</td><td><b>LANG</b>
LANG expands to the default system locale; LC_ALL can be used to override this. 
For example, if its value is <b>pt_BR</b>, then the language is set to (Brazilian) Portuguese and the locale to Brazil.</td></tr>
<tr><td>5</td><td><b>LD_LIBRARY_PATH</b>
A Unix system with a dynamic linker, contains a colonseparated list of directories that the dynamic linker should search for shared objects when building a process image after exec, before searching in any other directories.</td></tr>
<tr><td>6</td><td><b>PATH</b>
Indicates the search path for commands. 
It is a colon-separated list of directories in which the shell looks for commands.</td></tr>
<tr><td>7</td><td><b>PWD</b>
Indicates the current working directory as set by the cd command.</td></tr>
<tr><td>8</td><td><b>RANDOM</b>
Generates a random integer between 0 and 32,767 each time it is referenced.</td></tr>
<tr><td>9</td><td><b>SHLVL</b>
Increments by one each time an instance of bash is started. 
This variable is useful for determining whether the built-in exit command ends the current session.</td></tr>
<tr><td>10</td><td><b>TERM</b>
Refers to the display type.</td></tr>
<tr><td>11</td><td><b>TZ</b>
Refers to Time zone. 
It can take values like GMT, AST, etc.</td></tr>
<tr><td>12</td><td><b>UID</b>
Expands to the numeric user ID of the current user, initialized at the shell startup.</td></tr>
</table>
Following is the sample example showing few environment variables -
$ echo $HOME
/root
]$ echo $DISPLAY
$ echo $TERM
xterm
$ echo $PATH
/usr/local/bin:/bin:/usr/bin:/home/amrood/bin:/usr/local/bin
$

<h2><span class="orange">Unix / Linux Basic Utilities - Printing, Email</span></h2>
In this chapter, we will discuss in detail about Printing and Email as the basic utilities of Unix. 
So far, we have tried to understand the Unix OS and the nature of its basic commands. 
In this chapter, we will learn some important Unix utilities that can be used in our day-to-day life.
<h2>&emsp;Printing Files</h2>
Before you print a file on a Unix system, you may want to reformat it to adjust the margins, highlight some words, and so on. 
Most files can also be printed without reformatting, but the raw printout may not be that appealing.
Many versions of Unix include two powerful text formatters, <b>nroff</b> and <b>troff</b>.
 
<h3>The pr Command</h3>
The <b>pr</b> command does minor formatting of files on the terminal screen or for a printer. 
For example, if you have a long list of names in a file, you can format it onscreen into two or more columns.
Following is the syntax for the <b>pr</b> command -
pr option(s) filename(s)

The <b>pr</b> changes the format of the file only on the screen or on the printed copy; it doesn't modify the original file. 
Following table lists some <b>pr</b> options -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Option &amp; Description</th></tr>
<tr><td>1</td><td><b>-k</b>
Produces <b>k</b> columns of output</td></tr>
<tr><td>2</td><td><b>-d</b>
Double-spaces the output (not on all <b>pr</b> versions)</td></tr>
<tr><td>3</td><td><b>-h "header"</b>
Takes the next item as a report header</td></tr>
<tr><td>4</td><td><b>-t</b>
Eliminates the printing of header and the top/bottom margins</td></tr>
<tr><td>5</td><td><b>-l PAGE_LENGTH</b>
Sets the page length to PAGE_LENGTH (66) lines. 
The default number of lines of text is 56</td></tr>
<tr><td>6</td><td><b>-o MARGIN</b>
Offsets each line with MARGIN (zero) spaces</td></tr>
<tr><td>7</td><td><b>-w PAGE_WIDTH</b>
Sets the page width to PAGE_WIDTH (72) characters for multiple text-column output only</td></tr>
</table>
Before using <b>pr</b>, here are the contents of a sample file named food.

$cat food
Sweet Tooth
Bangkok Wok
Mandalay
Afghani Cuisine
Isle of Java
Big Apple Deli
Sushi and Sashimi
Tio Pepe's Peppers
........
$

Let's use the <b>pr</b> command to make a two-column report with the header <i>Restaurants</i> -
$pr -2 -h "Restaurants" food
Nov  7  9:58 1997  Restaurants   Page 1
Sweet Tooth              Isle of Java
Bangkok Wok              Big Apple Deli
Mandalay                 Sushi and Sashimi
Afghani Cuisine          Tio Pepe's Peppers
........
$

<h3>The lp and lpr Commands</h3>
The command <b>lp</b> or <b>lpr</b> prints a file onto paper as opposed to the screen display. 
Once you are ready with formatting using the <b>pr</b> command, you can use any of these commands to print your file on the printer connected to your computer.
Your system administrator has probably set up a default printer at your site. 
To print a file named <b>food</b> on the default printer, use the <b>lp</b> or <b>lpr</b> command, as in the following example -
$lp food
request id is laserp-525  (1 file)
$

The <b>lp</b> command shows an ID that you can use to cancel the print job or check its status.
If you are using the <b>lp</b> command, you can use the -n<b>Num</b> option to print Num number of copies. 
Along with the command <b>lpr</b>, you can use -<b>Num</b> for the same.
If there are multiple printers connected with the shared network, then you can choose a printer using -d<b>printer</b> option along with lp command and for the same purpose you can use -P<b>printer</b> option along with lpr command. 
Here printer is the printer name.

<h3>The lpstat and lpq Commands</h3>
The <b>lpstat</b> command shows what's in the printer queue: request IDs, owners, file sizes, when the jobs were sent for printing, and the status of the requests.
Use <b>lpstat -o</b> if you want to see all output requests other than just your own. 
Requests are shown in the order they'll be printed -
$lpstat -o
laserp-573  john  128865  Nov 7  11:27  on laserp
laserp-574  grace  82744  Nov 7  11:28
laserp-575  john   23347  Nov 7  11:35
$

The <b>lpq</b> gives slightly different information than <b>lpstat -o</b> -
$lpq
laserp is ready and printing
Rank   Owner      Job  Files                  Total Size
active john       573  report.ps              128865 bytes
1st    grace      574  ch03.ps ch04.ps        82744 bytes
2nd    john       575  standard input         23347 bytes
$

Here the first line displays the printer status. 
If the printer is disabled or running out of paper, you may see different messages on this first line.
<h3>The cancel and lprm Commands</h3>
The <b>cancel</b> command terminates a printing request from the <b>lp command</b>. 
The <b>lprm</b> command terminates all <b>lpr requests</b>. 
You can specify either the ID of the request (displayed by lp or lpq) or the name of the printer.

$cancel laserp-575
request "laserp-575" cancelled
$

To cancel whatever request is currently printing, regardless of its ID, simply enter cancel and the printer name -
$cancel laserp
request "laserp-573" cancelled
$

The <b>lprm</b> command will cancel the active job if it belongs to you. 
Otherwise, you can give job numbers as arguments, or use a <b>dash (-)</b> to remove all of your jobs -
$lprm 575
dfA575diamond dequeued
cfA575diamond dequeued
$

The <b>lprm</b> command tells you the actual filenames removed from the printer queue.
<h2>&emsp;Sending Email</h2>
You use the Unix mail command to send and receive mail. 
Here is the syntax to send an email -
$mail [-s subject] [-c cc-addr] [-b bcc-addr] to-addr

Here are important options related to mail command -s
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Option &amp; Description</th></tr>
<tr><td>1</td><td><b>-s</b>
Specifies subject on the command line.</td></tr>
<tr><td>2</td><td><b>-c</b>
Sends carbon copies to the list of users. 
List should be a commaseparated list of names.</td></tr>
<tr><td>3</td><td><b>-b</b>
Sends blind carbon copies to list. 
List should be a commaseparated list of names.</td></tr>
</table>
Following is an example to send a test message to admin@yahoo.com.

$mail -s "Test Message" admin@yahoo.com 

You are then expected to type in your message, followed by <b>"control-D"</b> at the beginning of a line. 
To stop, simply type dot <b>(.)</b> as follows -
Hi,
This is a test
.
Cc: 

You can send a complete file using a <b>redirect &lt; operator</b> as follows -
$mail -s "Report 05/06/07" admin@yahoo.com &lt; demo.txt 

To check incoming email at your Unix system, you simply type email as follows -
$mail
no email

<h2><span class="orange">Unix / Linux - Pipes and Filters</span></h2>
In this chapter, we will discuss in detail about pipes and filters in Unix. 
You can connect two commands together so that the output from one program becomes the input of the next program. 
Two or more commands connected in this way form a pipe.
To make a pipe, put a vertical bar (<b>&amp;verbar;</b>) on the command line between two commands.
When a program takes its input from another program, it performs some operation on that input, and writes the result to the standard output. 
It is referred to as a <b><i>filter</i></b>.
<h2>&emsp;The grep Command</h2>
The grep command searches a file or files for lines that have a certain pattern. 
The syntax is -
$grep pattern file(s)

The name <b>"grep"</b> comes from the ed (a Unix line editor) command <b>g/re/p</b> which means “globally search for a regular expression and print all lines containing it”.
A regular expression is either some plain text (a word, for example) and/or special characters used for pattern matching.
The simplest use of grep is to look for a pattern consisting of a single word. 
It can be used in a pipe so that only those lines of the input files containing a given string are sent to the standard output. 
If you don't give grep a filename to read, it reads its standard input; that's the way all filter programs work -
$ls -l | grep "Aug"
-rw-rw-rw-   1 john  doc     11008 Aug  6 14:10 ch02
-rw-rw-rw-   1 john  doc      8515 Aug  6 15:30 ch07
-rw-rw-r--   1 john  doc      2488 Aug 15 10:51 intro
-rw-rw-r--   1 carol doc      1605 Aug 23 07:35 macros
$

There are various options which you can use along with the <b>grep</b> command -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Option &amp; Description</th></tr>
<tr><td>1</td><td><b>-v</b>
Prints all lines that do not match pattern.</td></tr>
<tr><td>2</td><td><b>-n</b>
Prints the matched line and its line number.</td></tr>
<tr><td>3</td><td><b>-l</b>
Prints only the names of files with matching lines (letter "l")</td></tr>
<tr><td>4</td><td><b>-c</b>
Prints only the count of matching lines.</td></tr>
<tr><td>5</td><td><b>-i</b>
Matches either upper or lowercase.</td></tr>
</table>
Let us now use a regular expression that tells grep to find lines with <b>"carol"</b>, followed by zero or other characters abbreviated in a regular expression as ".*"), then followed by "Aug".-
Here, we are using the <b><i>-i</i></b> option to have case insensitive search -
$ls -l | grep -i "carol.*aug"
-rw-rw-r--   1 carol doc      1605 Aug 23 07:35 macros
$

<h2>&emsp;The sort Command</h2>
The <b>sort</b> command arranges lines of text alphabetically or numerically. 
The following example sorts the lines in the food file -
$sort food
Afghani Cuisine
Bangkok Wok
Big Apple Deli
Isle of Java
Mandalay
Sushi and Sashimi
Sweet Tooth
Tio Pepe's Peppers
$

The <b>sort</b> command arranges lines of text alphabetically by default. 
There are many options that control the sorting -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Description</th></tr>
<tr><td>1</td><td><b>-n</b>
Sorts numerically (example: 10 will sort after 2), ignores blanks and tabs.</td></tr>
<tr><td>2</td><td><b>-r</b>
Reverses the order of sort.</td></tr>
<tr><td>3</td><td><b>-f</b>
Sorts upper and lowercase together.</td></tr>
<tr><td>4</td><td><b>&amp;plus;x</b>
Ignores first <b>x</b> fields when sorting.</td></tr>
</table>
More than two commands may be linked up into a pipe. 
Taking a previous pipe example using <b>grep</b>, we can further sort the files modified in August by the order of size.
The following pipe consists of the commands <b>ls</b>, <b>grep</b>, and <b>sort</b> -
$ls -l | grep "Aug" | sort +4n
-rw-rw-r--  1 carol doc      1605 Aug 23 07:35 macros
-rw-rw-r--  1 john  doc      2488 Aug 15 10:51 intro
-rw-rw-rw-  1 john  doc      8515 Aug  6 15:30 ch07
-rw-rw-rw-  1 john  doc     11008 Aug  6 14:10 ch02
$

This pipe sorts all files in your directory modified in August by the order of size, and prints them on the terminal screen. 
The sort option &amp;plus;4n skips four fields (fields are separated by blanks) then sorts the lines in numeric order.
<h2>&emsp;The pg and more Commands</h2>
A long output can normally be zipped by you on the screen, but if you run text through more or use the <b>pg</b> command as a filter; the display stops once the screen is full of text.
Let's assume that you have a long directory listing. 
To make it easier to read the sorted listing, pipe the output through <b>more</b> as follows -
$ls -l | grep "Aug" | sort +4n | more
-rw-rw-r--  1 carol doc      1605 Aug 23 07:35 macros
-rw-rw-r--  1 john  doc      2488 Aug 15 10:51 intro
-rw-rw-rw-  1 john  doc      8515 Aug  6 15:30 ch07
-rw-rw-r--  1 john  doc     14827 Aug  9 12:40 ch03
.
.
.
-rw-rw-rw-  1 john  doc     16867 Aug  6 15:56 ch05
--More--(74%)

The screen will fill up once the screen is full of text consisting of lines sorted by the order of the file size. 
At the bottom of the screen is the <b>more</b> prompt, where you can type a command to move through the sorted text.
Once you're done with this screen, you can use any of the commands listed in the discussion of the more program.

<h2><span class="orange">Unix / Linux - Processes Management</span></h2>
In this chapter, we will discuss in detail about process management in Unix. 
When you execute a program on your Unix system, the system creates a special environment for that program. 
This environment contains everything needed for the system to run the program as if no other program were running on the system.
Whenever you issue a command in Unix, it creates, or starts, a new process. 
When you tried out the <b>ls</b> command to list the directory contents, you started a process. 
A process, in simple terms, is an instance of a running program.
The operating system tracks processes through a five-digit ID number known as the <b>pid</b> or the <b>process ID</b>. 
Each process in the system has a unique <b>pid</b>.
Pids eventually repeat because all the possible numbers are used up and the next pid rolls or starts over. 
At any point of time, no two processes with the same pid exist in the system because it is the pid that Unix uses to track each process.
<h2>&emsp;Starting a Process</h2>
When you start a process (run a command), there are two ways you can run it -
Foreground Processes
Background Processes

<h3>Foreground Processes</h3>
By default, every process that you start runs in the foreground. 
It gets its input from the keyboard and sends its output to the screen.
You can see this happen with the <b>ls</b> command. 
If you wish to list all the files in your current directory, you can use the following command -
$ls ch*.doc

This would display all the files, the names of which start with <b>ch</b> and end with <b>.doc</b> -
ch01-1.doc   ch010.doc  ch02.doc    ch03-2.doc 
ch04-1.doc   ch040.doc  ch05.doc    ch06-2.doc
ch01-2.doc   ch02-1.doc

The process runs in the foreground, the output is directed to my screen, and if the <b>ls</b> command wants any input (which it does not), it waits for it from the keyboard.
While a program is running in the foreground and is time-consuming, no other commands can be run (start any other processes) because the prompt would not be available until the program finishes processing and comes out.
<h3>Background Processes</h3>
A background process runs without being connected to your keyboard. 
If the background process requires any keyboard input, it waits.
The advantage of running a process in the background is that you can run other commands; you do not have to wait until it completes to start another!
The simplest way to start a background process is to add an ampersand (<b>&amp;</b>) at the end of the command.

$ls ch*.doc &amp;

This displays all those files the names of which start with <b>ch</b> and end with <b>.doc</b> -
ch01-1.doc   ch010.doc  ch02.doc    ch03-2.doc 
ch04-1.doc   ch040.doc  ch05.doc    ch06-2.doc
ch01-2.doc   ch02-1.doc

Here, if the <b>ls</b> command wants any input (which it does not), it goes into a stop state until we move it into the foreground and give it the data from the keyboard.
That first line contains information about the background process - the job number and the process ID. 
You need to know the job number to manipulate it between the background and the foreground.
Press the Enter key and you will see the following -
[1]   +   Done                 ls ch*.doc &amp;
$

The first line tells you that the <b>ls</b> command background process finishes successfully. 
The second is a prompt for another command.
<h2>&emsp;Listing Running Processes</h2>
It is easy to see your own processes by running the <b>ps</b> (process status) command as follows -
$ps
PID       TTY      TIME        CMD
18358     ttyp3    00:00:00    sh
18361     ttyp3    00:01:31    abiword
18789     ttyp3    00:00:00    ps

One of the most commonly used flags for ps is the <b>-f</b> ( f for full) option, which provides more information as shown in the following example -
$ps -f
UID      PID  PPID C STIME    TTY   TIME CMD
amrood   6738 3662 0 10:23:03 pts/6 0:00 first_one
amrood   6739 3662 0 10:22:54 pts/6 0:00 second_one
amrood   3662 3657 0 08:10:53 pts/6 0:00 -ksh
amrood   6892 3662 4 10:51:50 pts/6 0:00 ps -f

Here is the description of all the fields displayed by <b>ps -f</b> command -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Column &amp; Description</th></tr>
<tr><td>1</td><td><b>UID</b>
User ID that this process belongs to (the person running it)</td></tr>
<tr><td>2</td><td><b>PID</b>
Process ID</td></tr>
<tr><td>3</td><td><b>PPID</b>
Parent process ID (the ID of the process that started it)</td></tr>
<tr><td>4</td><td><b>C</b>
CPU utilization of process</td></tr>
<tr><td>5</td><td><b>STIME</b>
Process start time</td></tr>
<tr><td>6</td><td><b>TTY</b>
Terminal type associated with the process</td></tr>
<tr><td>7</td><td><b>TIME</b>
CPU time taken by the process</td></tr>
<tr><td>8</td><td><b>CMD</b>
The command that started this process</td></tr>
</table>
There are other options which can be used along with <b>ps</b> command -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Option &amp; Description</th></tr>
<tr><td>1</td><td><b>-a</b>
Shows information about all users</td></tr>
<tr><td>2</td><td><b>-x</b>
Shows information about processes without terminals</td></tr>
<tr><td>3</td><td><b>-u</b>
Shows additional information like -f option</td></tr>
<tr><td>4</td><td><b>-e</b>
Displays extended information</td></tr>
</table>
<h2>&emsp;Stopping Processes</h2>
Ending a process can be done in several different ways. 
Often, from a console-based command, sending a CTRL &amp;plus; C keystroke (the default interrupt character) will exit the command. 
This works when the process is running in the foreground mode.
If a process is running in the background, you should get its Job ID using the <b>ps</b> command. 
After that, you can use the <b>kill</b> command to kill the process as follows -
$ps -f
UID      PID  PPID C STIME    TTY   TIME CMD
amrood   6738 3662 0 10:23:03 pts/6 0:00 first_one
amrood   6739 3662 0 10:22:54 pts/6 0:00 second_one
amrood   3662 3657 0 08:10:53 pts/6 0:00 -ksh
amrood   6892 3662 4 10:51:50 pts/6 0:00 ps -f
$kill 6738
Terminated

Here, the <b>kill</b> command terminates the <b>first_one</b> process. 
If a process ignores a regular kill command, you can use <b>kill -9</b> followed by the process ID as follows -
$kill -9 6738
Terminated

<h2>&emsp;Parent and Child Processes</h2>
Each unix process has two ID numbers assigned to it: The Process ID (pid) and the Parent process ID (ppid). 
Each user process in the system has a parent process.
Most of the commands that you run have the shell as their parent. 
Check the <b>ps -f</b> example where this command listed both the process ID and the parent process ID.
<h2>&emsp;Zombie and Orphan Processes</h2>
Normally, when a child process is killed, the parent process is updated via a <b>SIGCHLD</b> signal. 
Then the parent can do some other task or restart a new child as needed. 
However, sometimes the parent process is killed before its child is killed. 
In this case, the "parent of all processes," the <b>init</b> process, becomes the new PPID (parent process ID). 
In some cases, these processes are called orphan processes.
When a process is killed, a <b>ps</b> listing may still show the process with a <b>Z</b> state. 
This is a zombie or defunct process. 
The process is dead and not being used. 
These processes are different from the orphan processes. 
They have completed execution but still find an entry in the process table.
<h2>&emsp;Daemon Processes</h2>
Daemons are system-related background processes that often run with the permissions of root and services requests from other processes.
A daemon has no controlling terminal. 
It cannot open <b>/dev/tty</b>. 
If you do a <b>"ps -ef"</b> and look at the <b>tty</b> field, all daemons will have a <b>?</b> for the <b>tty</b>.
To be precise, a daemon is a process that runs in the background, usually waiting for something to happen that it is capable of working with. 
For example, a printer daemon waiting for print commands.
If you have a program that calls for lengthy processing, then it’s worth to make it a daemon and run it in the background.
<h2>&emsp;The top Command</h2>
The <b>top</b> command is a very useful tool for quickly showing processes sorted by various criteria.
It is an interactive diagnostic tool that updates frequently and shows information about physical and virtual memory, CPU usage, load averages, and your busy processes.
Here is the simple syntax to run top command and to see the statistics of CPU utilization by different processes -
$top

<h2>&emsp;Job ID Versus Process ID</h2>
Background and suspended processes are usually manipulated via <b>job number (job ID)</b>. 
This number is different from the process ID and is used because it is shorter.
In addition, a job can consist of multiple processes running in a series or at the same time, in parallel. 
Using the job ID is easier than tracking individual processes.

<h2><span class="orange">Unix / Linux - Network Communication Utilities</span></h2>
In this chapter, we will discuss in detail about network communication utilities in Unix. 
When you work in a distributed environment, you need to communicate with remote users and you also need to access remote Unix machines.
There are several Unix utilities that help users compute in a networked, distributed environment. 
This chapter lists a few of them.
<h2>&emsp;The ping Utility</h2>
The <b>ping</b> command sends an echo request to a host available on the network. 
Using this command, you can check if your remote host is responding well or not.
The ping command is useful for the following -
Tracking and isolating hardware and software problems.
Determining the status of the network and various foreign hosts.
Testing, measuring, and managing networks.

<h3>Syntax</h3>
Following is the simple syntax to use the ftp command -
$ping hostname or ip-address

The above command starts printing a response after every second. 
To come out of the command, you can terminate it by pressing <b>CNTRL &amp;plus; C</b> keys.
<h3>Example</h3>
Following is an example to check the availability of a host available on the network -
$ping google.com
PING google.com (74.125.67.100) 56(84) bytes of data.
64 bytes from 74.125.67.100: icmp_seq = 1 ttl = 54 time = 39.4 ms
64 bytes from 74.125.67.100: icmp_seq = 2 ttl = 54 time = 39.9 ms
64 bytes from 74.125.67.100: icmp_seq = 3 ttl = 54 time = 39.3 ms
64 bytes from 74.125.67.100: icmp_seq = 4 ttl = 54 time = 39.1 ms
64 bytes from 74.125.67.100: icmp_seq = 5 ttl = 54 time = 38.8 ms
--- google.com ping statistics ---
22 packets transmitted, 22 received, 0% packet loss, time 21017ms
rtt min/avg/max/mdev = 38.867/39.334/39.900/0.396 ms
$

If a host does not exist, you will receive the following output -
$ping giiiiiigle.com
ping: unknown host giiiiigle.com
$

<h2>&emsp;The ftp Utility</h2>
Here, <b>ftp</b> stands for <b>F</b>ile <b>T</b>ransfer <b>P</b>rotocol. 
This utility helps you upload and download your file from one computer to another computer.
The ftp utility has its own set of Unix-like commands. 
These commands help you perform tasks such as -
Connect and login to a remote host.
Navigate directories.
List directory contents.
Put and get files.
Transfer files as <b>ascii</b>, <b>ebcdic</b> or <b>binary</b>.

<h3>Syntax</h3>
Following is the simple syntax to use the ftp command -
$ftp hostname or ip-address

The above command would prompt you for the login ID and the password. 
Once you are authenticated, you can access the home directory of the login account and you would be able to perform various commands.
The following tables lists out a few important commands -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Command &amp; Description</th></tr>
<tr><td>1</td><td><b>put filename</b>
Uploads filename from the local machine to the remote machine.</td></tr>
<tr><td>2</td><td><b>get filename</b>
Downloads filename from the remote machine to the local machine.</td></tr>
<tr><td>3</td><td><b>mput file list</b>
Uploads more than one file from the local machine to the remote machine.</td></tr>
<tr><td>4</td><td><b>mget file list</b>
Downloads more than one file from the remote machine to the local machine.</td></tr>
<tr><td>5</td><td><b>prompt off</b>
Turns the prompt off. 
By default, you will receive a prompt to upload or download files using <b>mput</b> or <b>mget</b> commands.</td></tr>
<tr><td>6</td><td><b>prompt on</b>
Turns the prompt on.</td></tr>
<tr><td>7</td><td><b>dir</b>
Lists all the files available in the current directory of the remote machine.</td></tr>
<tr><td>8</td><td><b>cd dirname</b>
Changes directory to dirname on the remote machine.</td></tr>
<tr><td>9</td><td><b>lcd dirname</b>
Changes directory to dirname on the local machine.</td></tr>
<tr><td>10</td><td><b>quit</b>
Helps logout from the current login.</td></tr>
</table>
It should be noted that all the files would be downloaded or uploaded to or from the current directories. 
If you want to upload your files in a particular directory, you need to first change to that directory and then upload the required files.
<h3>Example</h3>
Following is the example to show the working of a few commands -
$ftp amrood.com
Connected to amrood.com.
220 amrood.com FTP server (Ver 4.9 Thu Sep 2 20:35:07 CDT 2009)
Name (amrood.com:amrood): amrood
331 Password required for amrood.
Password:
230 User amrood logged in.
ftp&gt; dir
200 PORT command successful.
150 Opening data connection for /bin/ls.
total 1464
drwxr-sr-x   3 amrood   group       1024 Mar 11 20:04 Mail
drwxr-sr-x   2 amrood   group       1536 Mar  3 18:07 Misc
drwxr-sr-x   5 amrood   group        512 Dec  7 10:59 OldStuff
drwxr-sr-x   2 amrood   group       1024 Mar 11 15:24 bin
drwxr-sr-x   5 amrood   group       3072 Mar 13 16:10 mpl
-rw-r--r--   1 amrood   group     209671 Mar 15 10:57 myfile.out
drwxr-sr-x   3 amrood   group        512 Jan  5 13:32 public
drwxr-sr-x   3 amrood   group        512 Feb 10 10:17 pvm3
226 Transfer complete.
ftp&gt; cd mpl
250 CWD command successful.
ftp&gt; dir
200 PORT command successful.
150 Opening data connection for /bin/ls.
total 7320
-rw-r--r--   1 amrood   group       1630 Aug  8 1994  dboard.f
-rw-r-----   1 amrood   group       4340 Jul 17 1994  vttest.c
-rwxr-xr-x   1 amrood   group     525574 Feb 15 11:52 wave_shift
-rw-r--r--   1 amrood   group       1648 Aug  5 1994  wide.list
-rwxr-xr-x   1 amrood   group       4019 Feb 14 16:26 fix.c
226 Transfer complete.
ftp&gt; get wave_shift
200 PORT command successful.
150 Opening data connection for wave_shift (525574 bytes).
226 Transfer complete.
528454 bytes received in 1.296 seconds (398.1 Kbytes/s)
ftp&gt; quit
221 Goodbye.
$

<h2>&emsp;The telnet Utility</h2>
There are times when we are required to connect to a remote Unix machine and work on that machine remotely. 
<b>Telnet</b> is a utility that allows a computer user at one site to make a connection, login and then conduct work on a computer at another site.
Once you login using Telnet, you can perform all the activities on your remotely connected machine. 
The following is an example of Telnet session -
C:&gt;telnet amrood.com
Trying...
Connected to amrood.com.
Escape character is '^]'.
login: amrood
amrood's Password: 
*****************************************************
*                                                   *
*                                                   *
*    WELCOME TO AMROOD.COM                          *
*                                                   *
*                                                   *
*****************************************************
Last unsuccessful login: Fri Mar  3 12:01:09 IST 2009
Last login: Wed Mar  8 18:33:27 IST 2009 on pts/10
   {  do your work }
$ logout
Connection closed.
C:&gt;

<h2>&emsp;The finger Utility</h2>
The <b>finger</b> command displays information about users on a given host. 
The host can be either local or remote.
Finger may be disabled on other systems for security reasons.
Following is the simple syntax to use the finger command -
Check all the logged-in users on the local machine -
$ finger
Login     Name       Tty      Idle  Login Time   Office
amrood               pts/0          Jun 25 08:03 (62.61.164.115)

Get information about a specific user available on the local machine -
$ finger amrood
Login: amrood                           Name: (null)
Directory: /home/amrood                 Shell: /bin/bash
On since Thu Jun 25 08:03 (MST) on pts/0 from 62.61.164.115
No mail.
No Plan.

Check all the logged-in users on the remote machine -
$ finger @avtar.com
Login     Name       Tty      Idle  Login Time   Office
amrood               pts/0          Jun 25 08:03 (62.61.164.115)

Get the information about a specific user available on the remote machine -
$ finger amrood@avtar.com
Login: amrood                           Name: (null)
Directory: /home/amrood                 Shell: /bin/bash
On since Thu Jun 25 08:03 (MST) on pts/0 from 62.61.164.115
No mail.
No Plan.

<h2><span class="orange">Unix/Linux - The vi Editor Tutorial</span></h2>
In this chapter, we will understand how the vi Editor works in Unix. 
There are many ways to edit files in Unix. 
Editing files using the screen-oriented text editor <b>vi</b> is one of the best ways. 
This editor enables you to edit lines in context with other lines in the file.
An improved version of the vi editor which is called the <b>VIM</b> has also been made available now. 
Here, VIM stands for <b>Vi IM</b>proved.
vi is generally considered the de facto standard in Unix editors because -
It's usually available on all the flavors of Unix system.
Its implementations are very similar across the board.
It requires very few resources.
It is more user-friendly than other editors such as the <b>ed</b> or the <b>ex</b>.

You can use the <b>vi</b> editor to edit an existing file or to create a new file from scratch. 
You can also use this editor to just read a text file.
<h2>&emsp;Starting the vi Editor</h2>
The following table lists out the basic commands to use the vi editor -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Command &amp; Description</th></tr>
<tr><td>1</td><td><b>vi filename</b>
Creates a new file if it already does not exist, otherwise opens an existing file.</td></tr>
<tr><td>2</td><td><b>vi -R filename</b>
Opens an existing file in the read-only mode.</td></tr>
<tr><td>3</td><td><b>view filename</b>
Opens an existing file in the read-only mode.</td></tr>
</table>
Following is an example to create a new file <b>testfile</b> if it already does not exist in the current working directory -
$vi testfile

The above command will generate the following output -
|
~
~
~
~
~
~
~
~
~
~
~
~
"testfile" [New File]    

You will notice a <b>tilde</b> (~) on each line following the cursor. 
A tilde represents an unused line. 
If a line does not begin with a tilde and appears to be blank, there is a space, tab, newline, or some other non-viewable character present.
You now have one open file to start working on. 
Before proceeding further, let us understand a few important concepts.
<h2>&emsp;Operation Modes</h2>
While working with the vi editor, we usually come across the following two modes -
<b>Command mode</b> - This mode enables you to perform administrative tasks such as saving the files, executing the commands, moving the cursor, cutting (yanking) and pasting the lines or words, as well as finding and replacing. 
In this mode, whatever you type is interpreted as a command.
<b>Insert mode</b> - This mode enables you to insert text into the file. 
Everything that's typed in this mode is interpreted as input and placed in the file.

vi always starts in the <b>command mode</b>. 
To enter text, you must be in the insert mode for which simply type <b>i</b>. 
To come out of the insert mode, press the <b>Esc</b> key, which will take you back to the command mode.
<b>Hint</b> - If you are not sure which mode you are in, press the Esc key twice; this will take you to the command mode. 
You open a file using the vi editor. 
Start by typing some characters and then come to the command mode to understand the difference.
<h2>&emsp;Getting Out of vi</h2>
The command to quit out of vi is <b>:q</b>. 
Once in the command mode, type colon, and 'q', followed by return. 
If your file has been modified in any way, the editor will warn you of this, and not let you quit. 
To ignore this message, the command to quit out of vi without saving is <b>:q!</b>. 
This lets you exit vi without saving any of the changes.
The command to save the contents of the editor is <b>:w</b>. 
You can combine the above command with the quit command, or use <b>:wq</b> and return.
The easiest way to <b>save your changes and exit vi</b> is with the ZZ command. 
When you are in the command mode, type <b>ZZ</b>. 
The <b>ZZ</b> command works the same way as the <b>:wq</b> command.
If you want to specify/state any particular name for the file, you can do so by specifying it after the <b>:w</b>. 
For example, if you wanted to save the file you were working on as another filename called <b>filename2</b>, you would type <b>:w filename2</b> and return.
<h2>&emsp;Moving within a File</h2>
To move around within a file without affecting your text, you must be in the command mode (press Esc twice). 
The following table lists out a few commands you can use to move around one character at a time -
<table class="table table-bordered">
<tr><th style="text-align:center">Sr.No.</th>
<th style="text-align:center">Command &amp; Description</th></tr>
<tr><td>1</td><td><b>k</b>
Moves the cursor up one line</td></tr>
<tr><td>2</td><td><b>j</b>
Moves the cursor down one line</td></tr>
<tr><td>3</td><td><b>h</b>
Moves the cursor to the left one character position</td></tr>
<tr><td>4</td><td><b>l</b>
Moves the cursor to the right one character position</td></tr>
</table>
The following points need to be considered to move within a file -
vi is case-sensitive. 
You need to pay attention to capitalization when using the commands.
Most commands in vi can be prefaced by the number of times you want the action to occur. 
For example, <b>2j</b> moves the cursor two lines down the cursor location.

There are many other ways to move within a file in vi. 
Remember that you must be in the command mode (<b>press Esc twice</b>). 
The following table lists out a few commands to move around the file -
<section class="toggle"><label>Given below is the list of commands to move around the file.</label>
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Command &amp; Description</th></tr>
<tr><td>1</td><td><b>0 or &amp;verbar;</b>
Positions the cursor at the beginning of a line</td></tr>
<tr><td>2</td><td><b>$</b>
Positions the cursor at the end of a line</td></tr>
<tr><td>3</td><td><b>w</b>
Positions the cursor to the next word</td></tr>
<tr><td>4</td><td><b>b</b>
Positions the cursor to the previous word</td></tr>
<tr><td>5</td><td><b>(</b>
Positions the cursor to the beginning of the current sentence</td></tr>
<tr><td>6</td><td><b>)</b>
Positions the cursor to the  beginning of the next sentence</td></tr>
<tr><td>7</td><td><b>E</b>
Moves to the end of the blank delimited word</td></tr>
<tr><td>8</td><td><b>{</b>
Moves a paragraph back</td></tr>
<tr><td>9</td><td><b>}</b>
Moves a paragraph forward</td></tr>
<tr><td>10</td><td><b>[[</b>
Moves a section back</td></tr>
<tr><td>11</td><td><b>]]</b>
Moves a section forward</td></tr>
<tr><td>12</td><td><b>n|</b>
Moves to the column <b>n</b> in the current line</td></tr>
<tr><td>13</td><td><b>1G</b>
Moves to the first line of the file</td></tr>
<tr><td>14</td><td><b>G</b>
Moves to the last line of the file</td></tr>
<tr><td>15</td><td><b>nG</b>
Moves to the <b>n<sup>th</sup></b> line of the file</td></tr>
<tr><td>16</td><td><b>:n</b>
Moves to the <b>n<sup>th</sup></b> line of the file</td></tr>
<tr><td>17</td><td><b>fc</b>
Moves forward to <b>c</b></td></tr>
<tr><td>18</td><td><b>Fc</b>
Moves back to <b>c</b></td></tr>
<tr><td>19</td><td><b>H</b>
Moves to the top of the screen</td></tr>
<tr><td>20</td><td><b>nH</b>
Moves to the <b>n<sup>th</sup></b> line from the top of the screen</td></tr>
<tr><td>21</td><td><b>M</b>
Moves to the middle of the screen</td></tr>
<tr><td>22</td><td><b>L</b>
Move to the bottom of the screen</td></tr>
<tr><td>23</td><td><b>nL</b>
Moves to the <b>n<sup>th</sup></b> line from the bottom of the screen</td></tr>
<tr><td>24</td><td><b>:x</b>
Colon followed by a number would position the cursor on the line number represented by <b>x</b></td></tr>
</table>
</section><h2>&emsp;Control Commands</h2>
The following commands can be used with the Control Key to performs functions as given in the table below -
<section class="toggle"><label>Given below is the list of control commands.</label>
<table class="table table-bordered">
<tr><th style="text-align:center;width:5%">Sr.No.</th><th>Command &amp; Description</th></tr>
<tr><td>1</td><td><b>CTRL&amp;plus;d</b>
Moves forward 1/2 screen</td></tr>
<tr><td>2</td><td><b>CTRL&amp;plus;f</b>
Moves forward one full screen</td></tr>
<tr><td>3</td><td><b>CTRL&amp;plus;u</b>
Moves backward 1/2 screen</td></tr>
<tr><td>4</td><td><b>CTRL&amp;plus;b</b>
Moves backward one full screen</td></tr>
<tr><td>5</td><td><b>CTRL&amp;plus;e</b>
Moves the screen up one line</td></tr>
<tr><td>6</td><td><b>CTRL&amp;plus;y</b>
Moves the screen down one line</td></tr>
<tr><td>7</td><td><b>CTRL&amp;plus;u</b>
Moves the screen up 1/2 page</td></tr>
<tr><td>8</td><td><b>CTRL&amp;plus;d</b>
Moves the screen down 1/2 page</td></tr>
<tr><td>9</td><td><b>CTRL&amp;plus;b</b>
Moves the screen up one page</td></tr>
<tr><td>10</td><td><b>CTRL&amp;plus;f</b>
Moves the screen down one page</td></tr>
<tr><td>11</td><td><b>CTRL&amp;plus;I</b>
Redraws the screen</td></tr>
</table>
</section><h2>&emsp;Editing Files</h2>
To edit the file, you need to be in the insert mode. 
There are many ways to enter the insert mode from the command mode -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Command &amp; Description</th></tr>
<tr><td>1</td><td><b>i</b>
Inserts text before the current cursor location</td></tr>
<tr><td>2</td><td><b>I</b>
Inserts text at the beginning of the current line</td></tr>
<tr><td>3</td><td><b>a</b>
Inserts text after the current cursor location</td></tr>
<tr><td>4</td><td><b>A</b>
Inserts text at the end of the current line</td></tr>
<tr><td>5</td><td><b>o</b>
Creates a new line for text entry below the cursor location</td></tr>
<tr><td>6</td><td><b>O</b>
Creates a new line for text entry above the cursor location</td></tr>
</table>
<h2>&emsp;Deleting Characters</h2>
Here is a list of important commands, which can be used to delete characters and lines in an open file -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Command &amp; Description</th></tr>
<tr><td>1</td><td><b>x</b>
Deletes the character under the cursor location</td></tr>
<tr><td>2</td><td><b>X</b>
Deletes the character before the cursor location</td></tr>
<tr><td>3</td><td><b>dw</b>
Deletes from the current cursor location to the next word</td></tr>
<tr><td>4</td><td><b>d^</b>
Deletes from the current cursor position to the beginning of the line</td></tr>
<tr><td>5</td><td><b>d$</b>
Deletes from the current cursor position to the end of the line</td></tr>
<tr><td>6</td><td><b>D</b>
Deletes from the cursor position to the end of the current line</td></tr>
<tr><td>7</td><td><b>dd</b>
Deletes the line the cursor is on</td></tr>
</table>
As mentioned above, most commands in vi can be prefaced by the number of times you want the action to occur. 
For example, <b>2x</b> deletes two characters under the cursor location and <b>2dd</b> deletes two lines the cursor is on.
It is recommended that the commands are practiced before we proceed further.
<h2>&emsp;Change Commands</h2>
You also have the capability to change characters, words, or lines in vi without deleting them. 
Here are the relevant commands -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Command &amp; Description</th></tr>
<tr><td>1</td><td><b>cc</b>
Removes the contents of the line, leaving you in insert mode.</td></tr>
<tr><td>2</td><td><b>cw</b>
Changes the word the cursor is on from the cursor to the lowercase <b>w</b> end of the word.</td></tr>
<tr><td>3</td><td><b>r</b>
Replaces the character under the cursor. 
vi returns to the command mode after the replacement is entered.</td></tr>
<tr><td>4</td><td><b>R</b>
Overwrites multiple characters beginning with the character currently under the cursor. 
You must use <b>Esc</b> to stop the overwriting.</td></tr>
<tr><td>5</td><td><b>s</b>
Replaces the current character with the character you type. 
Afterward, you are left in the insert mode.</td></tr>
<tr><td>6</td><td><b>S</b>
Deletes the line the cursor is on and replaces it with the new text. 
After the new text is entered, vi remains in the insert mode.</td></tr>
</table>
<h2>&emsp;Copy and Paste Commands</h2>
You can copy lines or words from one place and then you can paste them at another place using the following commands -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Command &amp; Description</th></tr>
<tr><td>1</td><td><b>yy</b>
Copies the current line.</td></tr>
<tr><td>2</td><td><b>yw</b>
Copies the current word from the character the lowercase w cursor is on, until the end of the word.</td></tr>
<tr><td>3</td><td><b>p</b>
Puts the copied text after the cursor.</td></tr>
<tr><td>4</td><td><b>P</b>
Puts the yanked text before the cursor.</td></tr>
</table>
<h2>&emsp;Advanced Commands</h2>
There are some advanced commands that simplify day-to-day editing and allow for more efficient use of vi -
<section class="toggle"><label>Given below is the list advanced commands.</label>
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Command &amp; Description</th></tr>
<tr><td>1</td><td><b>J</b>
Joins the current line with the next one. 
A count of j commands join many lines.</td></tr>
<tr><td>2</td><td><b>&lt;&lt;</b>
Shifts the current line to the left by one shift width.</td></tr>
<tr><td>3</td><td><b>&gt;&gt;</b>
Shifts the current line to the right by one shift width.</td></tr>
<tr><td>4</td><td><b>~</b>
Switches the case of the character under the cursor.</td></tr>
<tr><td>5</td><td><b>^G</b>
Press Ctrl and G keys at the same time to show the current filename and the status.</td></tr>
<tr><td>6</td><td><b>U</b>
Restores the current line to the state it was in before the cursor entered the line.</td></tr>
<tr><td>7</td><td><b>u</b>
This helps undo the last change that was done in the file. 
Typing 'u' again will re-do the change.</td></tr>
<tr><td>8</td><td><b>J</b>
Joins the current line with the next one. 
A count joins that many lines.</td></tr>
<tr><td>9</td><td><b>:f</b>
Displays the current position in the file in % and the file name, the total number of file.</td></tr>
<tr><td>10</td><td><b>:f filename</b>
Renames the current file to filename.</td></tr>
<tr><td>11</td><td><b>:w filename</b>
Writes to file filename.</td></tr>
<tr><td>12</td><td><b>:e filename</b>
Opens another file with filename.</td></tr>
<tr><td>13</td><td><b>:cd dirname</b>
Changes the current working directory to dirname.</td></tr>
<tr><td>14</td><td><b>:e #</b>
Toggles between two open files.</td></tr>
<tr><td>15</td><td><b>:n</b>
In case you open multiple files using vi, use <b>:n</b> to go to the next file in the series.</td></tr>
<tr><td>16</td><td><b>:p</b>
In case you open multiple files using vi, use <b>:p</b> to go to the previous file in the series.</td></tr>
<tr><td>17</td><td><b>:N</b>
In case you open multiple files using vi, use <b>:N</b> to go to the previous file in the series.</td></tr>
<tr><td>18</td><td><b>:r file</b>
Reads file and inserts it after the current line.</td></tr>
<tr><td>19</td><td><b>:nr file</b>
Reads file and inserts it after the line <b>n</b>.</td></tr>
</table>
</section><h2>&emsp;Word and Character Searching</h2>
The vi editor has two kinds of searches: <b>string</b> and <b>character</b>. 
For a string search, the <b>/</b> and <b>?</b> commands are used. 
When you start these commands, the command just typed will be shown on the last line of the screen, where you type the particular string to look for.
These two commands differ only in the direction where the search takes place -
The <b>/</b> command searches forwards (downwards) in the file.
The <b>?</b> command searches backwards (upwards) in the file.

The <b>n</b> and <b>N</b> commands repeat the previous search command in the same or the opposite direction, respectively. 
Some characters have special meanings. 
These characters must be preceded by a backslash (<b>\</b>) to be included as part of the search expression.
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Character &amp;Description</th></tr>
<tr><td>1</td><td><b>^</b>
Searches at the beginning of the line (Use at the beginning of a search expression).</td></tr>
<tr><td>2</td><td><b>.</b>
Matches a single character.</td></tr>
<tr><td>3</td><td><b>*</b>
Matches zero or more of the previous character.</td></tr>
<tr><td>4</td><td><b>$</b>
End of the line (Use at the end of the search expression).</td></tr>
<tr><td>5</td><td><b>[</b>
Starts a set of matching or non-matching expressions.</td></tr>
<tr><td>6</td><td><b>&lt;</b>
This is put in an expression escaped with the backslash to find the ending or the beginning of a word.</td></tr>
<tr><td>7</td><td><b>&gt;</b>
This helps see the '<b>&lt;</b>' character description above.</td></tr>
</table>
The character search searches within one line to find a character entered after the command. 
The <b>f</b> and <b>F</b> commands search for a character on the current line only. 
<b>f</b> searches forwards and <b>F</b> searches backwards and the cursor moves to the position of the found character.
The <b>t</b> and <b>T</b> commands search for a character on the current line only, but for <b>t</b>, the cursor moves to the position before the character, and <b>T</b> searches the line backwards to the position after the character.
<h2>&emsp;Set Commands</h2>
You can change the look and feel of your vi screen using the following <b>:set</b> commands. 
Once you are in the command mode, type <b>:set</b> followed by any of the following commands.
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Command &amp; Description</th></tr>
<tr><td>1</td><td><b>:set ic</b>
Ignores the case when searching</td></tr>
<tr><td>2</td><td><b>:set ai</b>
Sets autoindent</td></tr>
<tr><td>3</td><td><b>:set noai</b>
Unsets autoindent</td></tr>
<tr><td>4</td><td><b>:set nu</b>
Displays lines with line numbers on the left side</td></tr>
<tr><td>5</td><td><b>:set sw</b>
Sets the width of a software tabstop. 
For example, you would set a shift width of 4 with this command — <b>:set sw = 4</b></td></tr>
<tr><td>6</td><td><b>:set ws</b>
If <i>wrapscan</i> is set, and the word is not found at the bottom of the file, it will try searching for it at the beginning</td></tr>
<tr><td>7</td><td><b>:set wm</b>
If this option has a value greater than zero, the editor will automatically "word wrap". 
For example, to set the wrap margin to two characters, you would type this: <b>:set wm = 2</b></td></tr>
<tr><td>8</td><td><b>:set ro</b>
Changes file type to "read only"</td></tr>
<tr><td>9</td><td><b>:set term</b>
Prints terminal type</td></tr>
<tr><td>10</td><td><b>:set bf</b>
Discards control characters from input</td></tr>
</table>
<h2>&emsp;Running Commands</h2>
The vi has the capability to run commands from within the editor. 
To run a command, you only need to go to the command mode and type <b>:!</b> command.
For example, if you want to check whether a file exists before you try to save your file with that filename, you can type <b>:! ls</b> and you will see the output of <b>ls</b> on the screen.
You can press any key (or the command's escape sequence) to return to your vi session.
<h2>&emsp;Replacing Text</h2>
The substitution command (<b>:s/</b>) enables you to quickly replace words or groups of words within your files. 
Following is the syntax to replace text -
:s/search/replace/g

The <b>g</b> stands for globally. 
The result of this command is that all occurrences on the cursor's line are changed.
<h2>&emsp;Important Points to Note</h2>
The following points will add to your success with vi -
You must be in command mode to use the commands. 
(Press Esc twice at any time to ensure that you are in command mode.)
You must be careful with the commands. 
These are case-sensitive.
You must be in insert mode to enter text.

<h2><span class="orange">Shell Scripting Tutorial</span></h2>
A shell script is a computer program designed to be run by the Unix/Linux shell which could be one of the following:
The Bourne Shell
The C Shell
The Korn Shell
The GNU Bourne-Again Shell

 A shell is a command-line interpreter and typical operations performed by shell scripts include file manipulation, program execution, and printing text.
<h2>&emsp;Extended Shell Scripts</h2>
Shell scripts have several required constructs that tell the shell environment what to do and when to do it. 
Of course, most scripts are more complex than the above one.
The shell is, after all, a real programming language, complete with variables, control structures, and so forth. 
No matter how complicated a script gets, it is still just a list of commands executed sequentially.
The following script uses the <b>read</b> command which takes the input from the keyboard and assigns it as the value of the variable PERSON and finally prints it on STDOUT.

#!/bin/sh
# Author : Zara Ali
# Copyright (c) Tutorialspoint.com
# Script follows here:
echo "What is your name?"
read PERSON
echo "Hello, $PERSON"

Here is a sample run of the script -
$./test.sh
What is your name?
Zara Ali
Hello, Zara Ali
$

Subsequent part of this tutorial will cover Unix/Linux Shell Scripting in detail.

<h2><span class="orange">Unix / Linux - What is Shells?</span></h2>
A <b>Shell</b> provides you with an interface to the Unix system. 
It gathers input from you and executes programs based on that input. 
When a program finishes executing, it displays that program's output.
Shell is an environment in which we can run our commands, programs, and shell scripts. 
There are different flavors of a shell, just as there are different flavors of operating systems. 
Each flavor of shell has its own set of recognized commands and functions.
<h2>&emsp;Shell Prompt</h2>
The prompt, <b>$</b>, which is called the <b>command prompt</b>, is issued by the shell. 
While the prompt is displayed, you can type a command.
Shell reads your input after you press <b>Enter</b>. 
It determines the command you want executed by looking at the first word of your input. 
A word is an unbroken set of characters. 
Spaces and tabs separate words.
Following is a simple example of the <b>date</b> command, which displays the current date and time -
$date
Thu Jun 25 08:30:19 MST 2009

You can customize your command prompt using the environment variable PS1 explained in the Environment tutorial.
<h2>&emsp;Shell Types</h2>
In Unix, there are two major types of shells -
<b>Bourne shell</b> - If you are using a Bourne-type shell, the <b>$</b> character is the default prompt.
<b>C shell</b> - If you are using a C-type shell, the % character is the default prompt.

The Bourne Shell has the following subcategories -
Bourne shell (sh)
Korn shell (ksh)
Bourne Again shell (bash)
POSIX shell (sh)

The different C-type shells follow -
C shell (csh)
TENEX/TOPS C shell (tcsh)

The original Unix shell was written in the mid-1970s by Stephen R. 
Bourne while he was at the AT&amp;T Bell Labs in New Jersey.
Bourne shell was the first shell to appear on Unix systems, thus it is referred to as "the shell".
Bourne shell is usually installed as <b>/bin/sh</b> on most versions of Unix. 
For this reason, it is the shell of choice for writing scripts that can be used on different versions of Unix.
In this chapter, we are going to cover most of the Shell concepts that are based on the Borne Shell.
<h2>&emsp;Shell Scripts</h2>
The basic concept of a shell script is a list of commands, which are listed in the order of execution. 
A good shell script will have comments, preceded by <b>#</b> sign, describing the steps.
There are conditional tests, such as value A is greater than value B, loops allowing us to go through massive amounts of data, files to read and store data, and variables to read and store data, and the script may include functions.
We are going to write many scripts in the next sections. 
It would be a simple text file in which we would put all our commands and several other required constructs that tell the shell environment what to do and when to do it.
Shell scripts and functions are both interpreted. 
This means they are not compiled.
<h2>&emsp;Example Script</h2>
Assume we create a <b>test.sh</b> script. 
Note all the scripts would have the <b>.sh</b> extension. 
Before you add anything else to your script, you need to alert the system that a shell script is being started. 
This is done using the <b>shebang</b> construct. 
For example -
#!/bin/sh

This tells the system that the commands that follow are to be executed by the Bourne shell. 
<i>It's called a shebang because the <b>#</b> symbol is called a hash, and the ! symbol is called a bang</i>.
To create a script containing these commands, you put the shebang line first and then add the commands -
#!/bin/bash
pwd
ls

<h2>&emsp;Shell Comments</h2>
You can put your comments in your script as follows -
#!/bin/bash
# Author : Zara Ali
# Copyright (c) Tutorialspoint.com
# Script follows here:
pwd
ls

Save the above content and make the script executable -
$chmod +x test.sh

The shell script is now ready to be executed -
$./test.sh

Upon execution, you will receive the following result -
/home/amrood
index.htm  unix-basic_utilities.htm  unix-directories.htm  
test.sh    unix-communication.htm    unix-environment.htm

<b>Note</b> - To execute a program available in the current directory, use <b>./program_name</b>
<h2>&emsp;Extended Shell Scripts</h2>
Shell scripts have several required constructs that tell the shell environment what to do and when to do it. 
Of course, most scripts are more complex than the above one.
The shell is, after all, a real programming language, complete with variables, control structures, and so forth. 
No matter how complicated a script gets, it is still just a list of commands executed sequentially.
The following script uses the <b>read</b> command which takes the input from the keyboard and assigns it as the value of the variable PERSON and finally prints it on STDOUT.

#!/bin/sh
# Author : Zara Ali
# Copyright (c) Tutorialspoint.com
# Script follows here:
echo "What is your name?"
read PERSON
echo "Hello, $PERSON"

Here is a sample run of the script -
$./test.sh
What is your name?
Zara Ali
Hello, Zara Ali
$

<h2><span class="orange">Unix / Linux - Using Shell Variables</span></h2>
In this chapter, we will learn how to use Shell variables in Unix. 
A variable is a character string to which we assign a value. 
The value assigned could be a number, text, filename, device, or any other type of data.
A variable is nothing more than a pointer to the actual data. 
The shell enables you to create, assign, and delete variables.
<h2>&emsp;Variable Names</h2>
The name of a variable can contain only letters (a to z or A to Z), numbers ( 0 to 9) or the underscore character ( _).
By convention, Unix shell variables will have their names in UPPERCASE.
The following examples are valid variable names -
_ALI
TOKEN_A
VAR_1
VAR_2

Following are the examples of invalid variable names -
2_VAR
-VARIABLE
VAR1-VAR2
VAR_A!

The reason you cannot use other characters such as <b>!</b>, <b>*</b>, or <b>-</b> is that these characters have a special meaning for the shell.
<h2>&emsp;Defining Variables</h2>
Variables are defined as follows -
variable_name=variable_value

For example -
NAME="Zara Ali"

The above example defines the variable NAME and assigns the value "Zara Ali" to it. 
Variables of this type are called <b>scalar variables</b>. 
A scalar variable can hold only one value at a time.
Shell enables you to store any value you want in a variable. 
For example -
VAR1="Zara Ali"
VAR2=100

<h2>&emsp;Accessing Values</h2>
To access the value stored in a variable, prefix its name with the dollar sign (<b>$</b>) -
For example, the following script will access the value of defined variable NAME and print it on STDOUT -
<a href="http://tpcg.io/AP7zgT" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

#!/bin/sh
NAME="Zara Ali"
echo $NAME

The above script will produce the following value -
Zara Ali

<h2>&emsp;Read-only Variables</h2>
Shell provides a way to mark variables as read-only by using the read-only command. 
After a variable is marked read-only, its value cannot be changed.
For example, the following script generates an error while trying to change the value of NAME -
<a href="http://tpcg.io/tawT1C" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

#!/bin/sh
NAME="Zara Ali"
readonly NAME
NAME="Qadiri"

The above script will generate the following result -
/bin/sh: NAME: This variable is read only.

<h2>&emsp;Unsetting Variables</h2>
Unsetting or deleting a variable directs the shell to remove the variable from the list of variables that it tracks. 
Once you unset a variable, you cannot access the stored value in the variable.
Following is the syntax to unset a defined variable using the <b>unset</b> command -
unset variable_name

The above command unsets the value of a defined variable. 
Here is a simple example that demonstrates how the command works -
#!/bin/sh
NAME="Zara Ali"
unset NAME
echo $NAME

The above example does not print anything. 
You cannot use the unset command to <b>unset</b> variables that are marked <b>readonly</b>.
<h2>&emsp;Variable Types</h2>
When a shell is running, three main types of variables are present -
<b>Local Variables</b> - A local variable is a variable that is present within the current instance of the shell. 
It is not available to programs that are started by the shell. 
They are set at the command prompt.
<b>Environment Variables</b> - An environment variable is available to any child process of the shell. 
Some programs need environment variables in order to function correctly. 
Usually, a shell script defines only those environment variables that are needed by the programs that it runs.
<b>Shell Variables</b> - A shell variable is a special variable that is set by the shell and is required by the shell in order to function correctly. 
Some of these variables are environment variables whereas others are local variables.

<h2><span class="orange">Unix / Linux - Special Variables</span></h2>
In this chapter, we will discuss in detail about special variable in Unix. 
In one of our previous chapters, we understood how to be careful when we use certain nonalphanumeric characters in variable names. 
This is because those characters are used in the names of special Unix variables. 
These variables are reserved for specific functions.
For example, the <b>$</b> character represents the process ID number, or PID, of the current shell -
$echo $$

The above command writes the PID of the current shell -
29949

The following table shows a number of special variables that you can use in your shell scripts -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Variable &amp; Description</th></tr>
<tr><td>1</td><td><b>$0</b>
The filename of the current script.</td></tr>
<tr><td>2</td><td><b>$n</b>
These variables correspond to the arguments with which a script was invoked. 
Here <b>n</b> is a positive decimal number corresponding to the position of an argument (the first argument is $1, the second argument is $2, and so on).</td></tr>
<tr><td>3</td><td><b>$#</b>
The number of arguments supplied to a script.</td></tr>
<tr><td>4</td><td><b>$*</b>
All the arguments are double quoted. 
If a script receives two arguments, $* is equivalent to $1 $2.</td></tr>
<tr><td>5</td><td><b>$@</b>
All the arguments are individually double quoted. 
If a script receives two arguments, $@ is equivalent to $1 $2.</td></tr>
<tr><td>6</td><td><b>$?</b>
The exit status of the last command executed.</td></tr>
<tr><td>7</td><td><b>$$</b>
The process number of the current shell. 
For shell scripts, this is the process ID under which they are executing.</td></tr>
<tr><td>8</td><td><b>$!</b>
The process number of the last background command.</td></tr>
</table>
<h2>&emsp;Command-Line Arguments</h2>
The command-line arguments $1, $2, $3, ...$9 are positional parameters, with $0 pointing to the actual command, program, shell script, or function and $1, $2, $3, ...$9 as the arguments to the command.
Following script uses various special variables related to the command line -
#!/bin/sh
echo "File Name: $0"
echo "First Parameter : $1"
echo "Second Parameter : $2"
echo "Quoted Values: $@"
echo "Quoted Values: $*"
echo "Total Number of Parameters : $#"

Here is a sample run for the above script -
$./test.sh Zara Ali
File Name : ./test.sh
First Parameter : Zara
Second Parameter : Ali
Quoted Values: Zara Ali
Quoted Values: Zara Ali
Total Number of Parameters : 2

<h2>&emsp;Special Parameters $* and $@</h2>
There are special parameters that allow accessing all the command-line arguments at once. 
<b>$*</b> and <b>$@</b> both will act the same unless they are enclosed in double quotes, <b>""</b>.
Both the parameters specify the command-line arguments. 
However, the "$*" special parameter takes the entire list as one argument with spaces between and the "$@" special parameter takes the entire list and separates it into separate arguments.
We can write the shell script as shown below to process an unknown number of commandline arguments with either the $* or $@ special parameters -
#!/bin/sh
for TOKEN in $*
do
   echo $TOKEN
done

Here is a sample run for the above script -
$./test.sh Zara Ali 10 Years Old
Zara
Ali
10
Years
Old

<b>Note</b> - Here <b>do...done</b> is a kind of loop that will be covered in a subsequent tutorial.
<h2>&emsp;Exit Status</h2>
The <b>$?</b> variable represents the exit status of the previous command.
Exit status is a numerical value returned by every command upon its completion. 
As a rule, most commands return an exit status of 0 if they were successful, and 1 if they were unsuccessful.
Some commands return additional exit statuses for particular reasons. 
For example, some commands differentiate between kinds of errors and will return various exit values depending on the specific type of failure.
Following is the example of successful command -
$./test.sh Zara Ali
File Name : ./test.sh
First Parameter : Zara
Second Parameter : Ali
Quoted Values: Zara Ali
Quoted Values: Zara Ali
Total Number of Parameters : 2
$echo $?
0
$

<h2><span class="orange">Unix / Linux - Using Shell Arrays</span></h2>
In this chapter, we will discuss how to use shell arrays in Unix. 
A shell variable is capable enough to hold a single value. 
These variables are called scalar variables.
Shell supports a different type of variable called an <b>array variable</b>. 
This can hold multiple values at the same time. 
Arrays provide a method of grouping a set of variables. 
Instead of creating a new name for each variable that is required, you can use a single array variable that stores all the other variables.
All the naming rules discussed for Shell Variables would be applicable while naming arrays.
<h2>&emsp;Defining Array Values</h2>
The difference between an array variable and a scalar variable can be explained as follows.
Suppose you are trying to represent the names of various students as a set of variables. 
Each of the individual variables is a scalar variable as follows -
NAME01="Zara"
NAME02="Qadir"
NAME03="Mahnaz"
NAME04="Ayan"
NAME05="Daisy"

We can use a single array to store all the above mentioned names. 
Following is the simplest method of creating an array variable. 
This helps assign a value to one of its indices.

array_name[index]=value

Here <i>array_name</i> is the name of the array, <i>index</i> is the index of the item in the array that you want to set, and value is the value you want to set for that item.
As an example, the following commands -
NAME[0]="Zara"
NAME[1]="Qadir"
NAME[2]="Mahnaz"
NAME[3]="Ayan"
NAME[4]="Daisy"

If you are using the <b>ksh</b> shell, here is the syntax of array initialization -
set -A array_name value1 value2 ... 
valuen

If you are using the <b>bash</b> shell, here is the syntax of array initialization -
array_name=(value1 ... 
valuen)

<h2>&emsp;Accessing Array Values</h2>
After you have set any array variable, you access it as follows -
${array_name[index]}

Here <i>array_name</i> is the name of the array, and <i>index</i> is the index of the value to be accessed. 
Following is an example to understand the concept -
<a href="http://tpcg.io/AMsECl" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

#!/bin/sh
NAME[0]="Zara"
NAME[1]="Qadir"
NAME[2]="Mahnaz"
NAME[3]="Ayan"
NAME[4]="Daisy"
echo "First Index: ${NAME[0]}"
echo "Second Index: ${NAME[1]}"

The above example will generate the following result -
$./test.sh
First Index: Zara
Second Index: Qadir

You can access all the items in an array in one of the following ways -
${array_name[*]}
${array_name[@]}

Here <b>array_name</b> is the name of the array you are interested in. 
Following example will help you understand the concept -
<a href="http://tpcg.io/r8Dol0" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

#!/bin/sh
NAME[0]="Zara"
NAME[1]="Qadir"
NAME[2]="Mahnaz"
NAME[3]="Ayan"
NAME[4]="Daisy"
echo "First Method: ${NAME[*]}"
echo "Second Method: ${NAME[@]}"

The above example will generate the following result -
$./test.sh
First Method: Zara Qadir Mahnaz Ayan Daisy
Second Method: Zara Qadir Mahnaz Ayan Daisy

<h2><span class="orange">Unix / Linux - Shell Basic Operators</span></h2>
There are various operators supported by each shell. 
We will discuss in detail about Bourne shell (default shell) in this chapter.
We will now discuss the following operators -
Arithmetic Operators
Relational Operators
Boolean Operators
String Operators
File Test Operators

Bourne shell didn't originally have any mechanism to perform simple arithmetic operations but it uses external programs, either <b>awk</b> or <b>expr</b>.
The following example shows how to add two numbers -
<a href="http://tpcg.io/zURE2C" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

#!/bin/sh
val=`expr 2 + 2`
echo "Total value : $val"

The above script will generate the following result -
Total value : 4

The following points need to be considered while adding -
There must be spaces between operators and expressions. 
For example, 2&amp;plus;2 is not correct; it should be written as 2 &amp;plus; 2.
The complete expression should be enclosed between <b>‘ ‘</b>, called the backtick.

<h2>&emsp;Arithmetic Operators</h2>
The following arithmetic operators are supported by Bourne Shell.
Assume variable <b>a</b> holds 10 and variable <b>b</b> holds 20 then -
<a href="/unix/unix-arithmetic-operators.htm">Show Examples</a>
<table class="table table-bordered">
<tr><th style="text-align:center;width:23%">Operator</th>
<th style="text-align:center;width:50%">Description</th>
<th style="text-align:center;width:40%">Example</th></tr>
<tr><td>&amp;plus; (Addition)</td><td>Adds values on either side of the operator</td><td>`expr $a &amp;plus; $b` will give 30</td></tr>
<tr><td>- (Subtraction)</td><td>Subtracts right hand operand from left hand operand</td><td>`expr $a - $b` will give -10</td></tr>
<tr><td>* (Multiplication)</td><td>Multiplies values on either side of the operator</td><td>`expr $a \* $b` will give 200</td></tr>
<tr><td>/ (Division)</td><td>Divides left hand operand by right hand operand</td><td>`expr $b / $a` will give 2</td></tr>
<tr><td>% (Modulus)</td><td>Divides left hand operand by right hand operand and returns remainder</td><td>`expr $b % $a` will give 0</td></tr>
<tr><td>= (Assignment)</td>
<td style="vertical-align:middle;">Assigns right operand in left operand</td><td>a = $b would assign value of b into a</td></tr>
<tr><td>== (Equality)</td><td>Compares two numbers, if both are same then returns true.</td><td>[ $a == $b ] would return false.</td></tr>
<tr><td>!= (Not Equality)</td><td>Compares two numbers, if both are different then returns true.</td><td>[ $a != $b ] would return true.</td></tr>
</table>
It is very important to understand that all the conditional expressions should be inside square braces with spaces around them, for example <b>[ $a == $b ]</b> is correct whereas, <b>[$a==$b]</b> is incorrect.
All the arithmetical calculations are done using long integers.
<h2>&emsp;Relational Operators</h2>
Bourne Shell supports the following relational operators that are specific to numeric values. 
These operators do not work for string values unless their value is numeric.
For example, following operators will work to check a relation between 10 and 20 as well as in between "10" and "20" but not in between "ten" and "twenty".
Assume variable <b>a</b> holds 10 and variable <b>b</b> holds 20 then -
<a href="/unix/unix-relational-operators.htm">Show Examples</a>
<table class="table table-bordered">
<tr><th>Operator</th><th>Description</th>
<th style="text-align:center;width:25%">Example</th></tr>
<tr><td><b>-eq</b></td><td>Checks if the value of two operands are equal or not; if yes, then the condition becomes true.</td><td>[ $a -eq $b ] is not true.</td></tr>
<tr><td><b>-ne</b></td><td>Checks if the value of two operands are equal or not; if values are not equal, then the condition becomes true.</td>
<td style="vertical-align:middle;">[ $a -ne $b ] is true.</td></tr>
<tr><td><b>-gt</b></td><td>Checks if the value of left operand is greater than the value of right operand; if yes, then the condition becomes true.</td>
<td style="vertical-align:middle;">[ $a -gt $b ] is not true.</td></tr>
<tr><td><b>-lt</b></td><td>Checks if the value of left operand is less than the value of right operand; if yes, then the condition becomes true.</td>
<td style="vertical-align:middle;">[ $a -lt $b ] is true.</td></tr>
<tr><td><b>-ge</b></td><td>Checks if the value of left operand is greater than or equal to the value of right operand; if yes, then the condition becomes true.</td>
<td style="vertical-align:middle;">[ $a -ge $b ] is not true.</td></tr>
<tr><td><b>-le</b></td><td>Checks if the value of left operand is less than or equal to the value of right operand; if yes, then the condition becomes true.</td>
<td style="vertical-align:middle;">[ $a -le $b ] is true.</td></tr>
</table>
It is very important to understand that all the conditional expressions should be placed inside square braces with spaces around them. 
For example, <b>[ $a &lt;= $b ]</b> is correct whereas, <b>[$a &lt;= $b]</b> is incorrect.
<h2>&emsp;Boolean Operators</h2>
The following Boolean operators are supported by the Bourne Shell. 

Assume variable <b>a</b> holds 10 and variable <b>b</b> holds 20 then -
<a href="/unix/unix-boolean-operators.htm">Show Examples</a>
<table class="table table-bordered">
<tr><th>Operator</th><th>Description</th>
<th style="text-align:center;width:25%">Example</th></tr>
<tr><td><b>!</b></td><td>This is logical negation. 
This inverts a true condition into false and vice versa.</td>
<td style="vertical-align:middle;">[ ! false  ] is true.</td></tr>
<tr><td><b>-o</b></td><td>This is logical <b>OR</b>. 
If one of the operands is true, then the condition becomes true.</td><td>[  $a -lt 20  -o $b -gt 100 ] is true.</td></tr>
<tr><td><b>-a</b></td><td>This is logical <b>AND</b>. 
If both the operands are true, then the condition becomes true otherwise false.</td>
<td style="vertical-align:middle;">[  $a -lt 20  -a $b -gt 100 ] is false. 
</td></tr>
</table>
<h2>&emsp;String Operators</h2>
The following string operators are supported by Bourne Shell.
Assume variable <b>a</b> holds "abc" and variable <b>b</b> holds "efg" then -
<a href="/unix/unix-string-operators.htm">Show Examples</a>
<table class="table table-bordered">
<tr><th>Operator</th><th>Description</th>
<th style="text-align:center;width:30%">Example</th></tr>
<tr><td><b>=</b></td><td>Checks if the value of two operands are equal or not; if yes, then the condition becomes true.</td><td>[ $a = $b ] is not true.</td></tr>
<tr><td><b>!=</b></td><td>Checks if the value of two operands are equal or not; if values are not equal then the condition becomes true.</td><td>[ $a != $b ] is true.</td></tr>
<tr><td><b>-z</b></td><td>Checks if the given string operand size is zero; if it is zero length, then it returns true.</td><td>[ -z $a ] is not true.</td></tr>
<tr><td><b>-n</b></td><td>Checks if the given string operand size is non-zero; if it is nonzero length, then it returns true.</td><td>[ -n $a ] is not false.</td></tr>
<tr><td><b>str</b></td><td>Checks if <b>str</b> is not the empty string; if it is empty, then it returns false.</td><td>[ $a ] is not false.</td></tr>
</table>
<h2>&emsp;File Test Operators</h2>
We have a few operators that can be used to test various properties associated with a Unix file.
Assume a variable <b>file</b> holds an existing file name "test" the size of which is 100 bytes and has <b>read</b>, <b>write</b> and <b>execute</b> permission on -
<a href="/unix/unix-file-operators.htm">Show Examples</a>
<table class="table table-bordered">
<tr><th>Operator</th><th>Description</th>
<th style="text-align:center;width:29%">Example</th></tr>
<tr><td><b>-b file</b></td><td>Checks if file is a block special file; if yes, then the condition becomes true.</td><td>[ -b $file ] is  false.</td></tr>
<tr><td><b>-c file</b></td><td>Checks if file is a character special file; if yes, then the condition becomes true.</td><td>[ -c $file ] is  false.</td></tr>
<tr><td><b>-d file</b></td><td>Checks if file is a directory; if yes, then the condition becomes true.</td><td>[ -d $file ] is not true.</td></tr>
<tr><td><b>-f file</b></td><td>Checks if file is an ordinary file as opposed to a directory or special file; if yes, then the condition becomes true.</td><td>[ -f $file ] is  true.</td></tr>
<tr><td><b>-g file</b></td><td>Checks if file has its set group ID (SGID) bit set; if yes, then the condition becomes true.</td><td>[ -g $file ] is  false.</td></tr>
<tr><td><b>-k file</b></td><td>Checks if file has its sticky bit set; if yes, then the condition becomes true.</td><td>[ -k $file ] is  false.</td></tr>
<tr><td><b>-p file</b></td><td>Checks if file is a named pipe; if yes, then the condition becomes true.</td><td>[ -p $file ] is  false.</td></tr>
<tr><td><b>-t file</b></td><td>Checks if file descriptor is open and associated with a terminal; if yes, then the condition becomes true.</td><td>[ -t $file ] is  false.</td></tr>
<tr><td><b>-u file</b></td><td>Checks if file has its Set User ID (SUID) bit set; if yes, then the condition becomes true.</td><td>[ -u $file ] is  false.</td></tr>
<tr><td><b>-r file</b></td><td>Checks if file is readable; if yes, then the condition becomes true.</td><td>[ -r $file ] is  true.</td></tr>
<tr><td><b>-w file</b></td><td>Checks if file is writable; if yes, then the condition becomes true.</td><td>[ -w $file ] is  true.</td></tr>
<tr><td><b>-x file</b></td><td>Checks if file is executable; if yes, then the condition becomes true.</td><td>[ -x $file ] is  true.</td></tr>
<tr><td><b>-s file</b></td><td>Checks if file has size greater than 0; if yes, then condition becomes true.</td><td>[ -s $file ] is true.</td></tr>
<tr><td><b>-e file</b></td><td>Checks if file exists; is true even if file is a directory but exists.</td><td>[ -e $file ] is true.</td></tr>
</table>
<h2>&emsp;C Shell Operators</h2>
Following link will give you a brief idea on C Shell Operators -
<a href="/unix/unix-c-shell-operators.htm">C Shell Operators</a>
<h2>&emsp;Korn Shell Operators</h2>
Following link helps you understand Korn Shell Operators -
<a href="/unix/unix-korn-shell-operators.htm">Korn Shell Operators</a>

<h2><span class="orange">Unix / Linux - Shell Decision Making</span></h2>
In this chapter, we will understand shell decision-making in Unix. 
While writing a shell script, there may be a situation when you need to adopt one path out of the given two paths. 
So you need to make use of conditional statements that allow your program to make correct decisions and perform the right actions.
Unix Shell supports conditional statements which are used to perform different actions based on different conditions. 
We will now understand two decision-making statements here -
The <b>if...else</b> statement
The <b>case...esac</b> statement

<h2>&emsp;The if...else statements</h2>
If else statements are useful decision-making statements which can be used to select an option from a given set of options.
Unix Shell supports following forms of <b>if…else</b> statement -
<a href="/unix/if-fi-statement.htm">if...fi statement</a>
<a href="/unix/if-else-statement.htm">if...else...fi statement</a>
<a href="/unix/if-elif-statement.htm">if...elif...else...fi statement</a>

Most of the if statements check relations using relational operators discussed in the previous chapter.
<h2>&emsp;The case...esac Statement</h2>
You can use multiple <b>if...elif</b> statements to perform a multiway branch. 
However, this is not always the best solution, especially when all of the branches depend on the value of a single variable.
Unix Shell supports <b>case...esac</b> statement which handles exactly this situation, and it does so more efficiently than repeated <b>if...elif</b> statements.
There is only one form of <b>case...esac</b> statement which has been described in detail here -
<a href="/unix/case-esac-statement.htm">case...esac statement</a>

The <b>case...esac</b> statement in the Unix shell is very similar to the <b>switch...case</b> statement we have in other programming languages like <b>C</b> or <b>C++</b> and <b>PERL</b>, etc.

<h2><span class="orange">Unix / Linux - Shell Loop Types</span></h2>
In this chapter, we will discuss shell loops in Unix. 
A loop is a powerful programming tool that enables you to execute a set of commands repeatedly. 
In this chapter, we will examine the following types of loops available to shell programmers -
<a href="/unix/while-loop.htm">The while loop</a>
<a href="/unix/for-loop.htm">The for loop</a>
<a href="/unix/until-loop.htm">The until loop</a>
<a href="/unix/select-loop.htm">The select loop</a>

You will use different loops based on the situation. 
For example, the <b>while</b> loop executes the given commands until the given condition remains true; the <b>until</b> loop executes until a given condition becomes true.
Once you have good programming practice you will gain the expertise and thereby, start using appropriate loop based on the situation. 
Here, <b>while</b> and <b>for</b> loops are available in most of the other programming languages like <b>C</b>, <b>C++</b> and <b>PERL</b>, etc.
<h2>&emsp;Nesting Loops</h2>
All the loops support nesting concept which means you can put one loop inside another similar one or different loops. 
This nesting can go up to unlimited number of times based on your requirement.
Here is an example of nesting <b>while</b> loop. 
The other loops can be nested based on the programming requirement in a similar way -
<h2>&emsp;Nesting while Loops</h2>
It is possible to use a while loop as part of the body of another while loop.
<h3>Syntax</h3>

while command1 ; # this is loop1, the outer loop
do
   Statement(s) to be executed if command1 is true
   while command2 ; # this is loop2, the inner loop
   do
      Statement(s) to be executed if command2 is true
   done
   Statement(s) to be executed if command1 is true
done

<h3>Example</h3>
Here is a simple example of loop nesting. 
Let's add another countdown loop inside the loop that you used to count to nine -
#!/bin/sh
a=0
while [ "$a" -lt 10 ]    # this is loop1
do
   b="$a"
   while [ "$b" -ge 0 ]  # this is loop2
   do
      echo -n "$b "
      b=`expr $b - 1`
   done
   echo
   a=`expr $a + 1`
done

This will produce the following result. 
It is important to note how <b>echo -n</b> works here. 
Here <b>-n</b> option lets echo avoid printing a new line character.

0
1 0
2 1 0
3 2 1 0
4 3 2 1 0
5 4 3 2 1 0
6 5 4 3 2 1 0
7 6 5 4 3 2 1 0
8 7 6 5 4 3 2 1 0
9 8 7 6 5 4 3 2 1 0

<h2><span class="orange">Unix / Linux - Shell Loop Control</span></h2>
In this chapter, we will discuss shell loop control in Unix. 
So far you have looked at creating loops and working with loops to accomplish different tasks. 
Sometimes you need to stop a loop or skip iterations of the loop.
In this chapter, we will learn following two statements that are used to control shell loops-
The <b>break</b> statement
The <b>continue</b> statement

<h2>&emsp;The infinite Loop</h2>
All the loops have a limited life and they come out once the condition is false or true depending on the loop.
A loop may continue forever if the required condition is not met. 
A loop that executes forever without terminating executes for an infinite number of times. 
For this reason, such loops are called infinite loops.
<h3>Example</h3>
Here is a simple example that uses the <b>while</b> loop to display the numbers zero to nine -
#!/bin/sh
a=10
until [ $a -lt 10 ]
do
   echo $a
   a=`expr $a + 1`
done

This loop continues forever because <b>a</b> is always <b>greater than</b> or <b>equal to 10</b> and it is never less than 10.
<h2>&emsp;The break Statement</h2>
The <b>break</b> statement is used to terminate the execution of the entire loop, after completing the execution of all of the lines of code up to the break statement. 
It then steps down to the code following the end of the loop.
<h3>Syntax</h3>
The following <b>break</b> statement is used to come out of a loop -
break

The break command can also be used to exit from a nested loop using this format -
break n

Here <b>n</b> specifies the <b>n<sup>th</sup></b> enclosing loop to the exit from.
<h3>Example</h3>
Here is a simple example which shows that loop terminates as soon as <b>a</b> becomes 5 -
#!/bin/sh
a=0
while [ $a -lt 10 ]
do
   echo $a
   if [ $a -eq 5 ]
   then
      break
   fi
   a=`expr $a + 1`
done

Upon execution, you will receive the following result -
0
1
2
3
4
5

Here is a simple example of nested for loop. 
This script breaks out of both loops if <b>var1 equals 2</b> and <b>var2 equals 0</b> -
<a href="http://tpcg.io/NcYiyO" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

#!/bin/sh
for var1 in 1 2 3
do
   for var2 in 0 5
   do
      if [ $var1 -eq 2 -a $var2 -eq 0 ]
      then
         break 2
      else
         echo "$var1 $var2"
      fi
   done
done

Upon execution, you will receive the following result. 
In the inner loop, you have a break command with the argument 2. 
This indicates that if a condition is met you should break out of outer loop and ultimately from the inner loop as well.

1 0
1 5

<h2>&emsp;The continue statement</h2>
The <b>continue</b> statement is similar to the <b>break</b> command, except that it causes the current iteration of the loop to exit, rather than the entire loop.
This statement is useful when an error has occurred but you want to try to execute the next iteration of the loop.
<h3>Syntax</h3>

continue

Like with the break statement, an integer argument can be given to the continue command to skip commands from nested loops.

continue n

Here <b>n</b> specifies the <b>n<sup>th</sup></b> enclosing loop to continue from.
<h3>Example</h3>
The following loop makes use of the <b>continue</b> statement which returns from the continue statement and starts processing the next statement -
<a href="http://tpcg.io/SN4DzV" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

#!/bin/sh
NUMS="1 2 3 4 5 6 7"
for NUM in $NUMS
do
   Q=`expr $NUM % 2`
   if [ $Q -eq 0 ]
   then
      echo "Number is an even number!!"
      continue
   fi
   echo "Found odd number"
done

Upon execution, you will receive the following result -
Found odd number
Number is an even number!!
Found odd number
Number is an even number!!
Found odd number
Number is an even number!!
Found odd number

<h2><span class="orange">Unix / Linux - Shell Substitution</span></h2>
<h2>&emsp;What is Substitution?</h2>
The shell performs substitution when it encounters an expression that contains one or more special characters.
<h3>Example</h3>
Here, the printing value of the variable is substituted by its value. 
Same time, <b>"\n"</b> is substituted by a new line -
<a href="http://tpcg.io/OFDBZ1" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

#!/bin/sh
a=10
echo -e "Value of a is $a \n"

You will receive the following result. 
Here the <b>-e</b> option enables the interpretation of backslash escapes.

Value of a is 10

Following is the result without <b>-e</b> option -
Value of a is 10\n

The following escape sequences which can be used in echo command -
<table class="table table-bordered">
<tr><th style="text-align:center;width:7%">Sr.No.</th><th>Escape &amp; Description</th></tr>
<tr><td>1</td><td><b>\\</b>
backslash</td></tr>
<tr><td>2</td><td><b>\a</b>
alert (BEL)</td></tr>
<tr><td>3</td><td><b>\b</b>
backspace</td></tr>
<tr><td>4</td><td><b>\c </b>
suppress trailing newline</td></tr>
<tr><td>5</td><td><b>\f </b>
form feed</td></tr>
<tr><td>6</td><td><b>\n</b>
new line</td></tr>
<tr><td>7</td><td><b>\r</b>
carriage return</td></tr>
<tr><td>8</td><td><b>\t </b>
horizontal tab</td></tr>
<tr><td>9</td><td><b>\v </b>
vertical tab</td></tr>
</table>
You can use the <b>-E</b> option to disable the interpretation of the backslash escapes (default).
You can use the <b>-n</b> option to disable the insertion of a new line.
<h2>&emsp;Command Substitution</h2>
Command substitution is the mechanism by which the shell performs a given set of commands and then substitutes their output in the place of the commands.
<h3>Syntax</h3>
The command substitution is performed when a command is given as -
`command`

When performing the command substitution make sure that you use the backquote, not the single quote character.
<h3>Example</h3>
Command substitution is generally used to assign the output of a command to a variable. 
Each of the following examples demonstrates the command substitution -
<a href="http://tpcg.io/YVfKUs" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

#!/bin/sh
DATE=`date`
echo "Date is $DATE"
USERS=`who | wc -l`
echo "Logged in user are $USERS"
UP=`date ; uptime`
echo "Uptime is $UP"

Upon execution, you will receive the following result -
Date is Thu Jul  2 03:59:57 MST 2009
Logged in user are 1
Uptime is Thu Jul  2 03:59:57 MST 2009
03:59:57 up 20 days, 14:03,  1 user,  load avg: 0.13, 0.07, 0.15

<h2>&emsp;Variable Substitution</h2>
Variable substitution enables the shell programmer to manipulate the value of a variable based on its state.
Here is the following table for all the possible substitutions -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Form &amp; Description</th></tr>
<tr><td>1</td><td><b>${var}</b>
Substitute the value of <i>var</i>.</td></tr>
<tr><td>2</td><td><b>${var:-word}</b>
If <i>var</i> is null or unset, <i>word</i> is substituted for <b>var</b>. 
The value of <i>var</i> does not change.</td></tr>
<tr><td>3</td><td><b>${var:=word}</b>
If <i>var</i> is null or unset, <i>var</i> is set to the value of <b>word</b>.</td></tr>
<tr><td>4</td><td><b>${var:?message}</b>
If <i>var</i> is null or unset, <i>message</i> is printed to standard error. 
This checks that variables are set correctly.</td></tr>
<tr><td>5</td><td><b>${var:&amp;plus;word}</b>
If <i>var</i> is set, <i>word</i> is substituted for var. 
The value of <i>var</i> does not change.</td></tr>
</table>
<h3>Example</h3>
Following is the example to show various states of the above substitution -
<a href="http://tpcg.io/5XMYM6" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

#!/bin/sh
echo ${var:-"Variable is not set"}
echo "1 - Value of var is ${var}"
echo ${var:="Variable is not set"}
echo "2 - Value of var is ${var}"
unset var
echo ${var:+"This is default value"}
echo "3 - Value of var is $var"
var="Prefix"
echo ${var:+"This is default value"}
echo "4 - Value of var is $var"
echo ${var:?"Print this message"}
echo "5 - Value of var is ${var}"

Upon execution, you will receive the following result -
Variable is not set
1 - Value of var is
Variable is not set
2 - Value of var is Variable is not set
3 - Value of var is
This is default value
4 - Value of var is Prefix
Prefix
5 - Value of var is Prefix

<h2><span class="orange">Unix / Linux - Shell Quoting Mechanisms</span></h2>
In this chapter, we will discuss in detail about the Shell quoting mechanisms. 
We will start by discussing the metacharacters.
<h2>&emsp;The Metacharacters</h2>
Unix Shell provides various metacharacters which have special meaning while using them in any Shell Script and causes termination of a word unless quoted.
For example, <b>?</b> matches with a single character while listing files in a directory and an <b>*</b> matches more than one character. 
Here is a list of most of the shell special characters (also called metacharacters) -
* ? [ ] ' " \ $ ; &amp; ( ) | ^ &lt; &gt; new-line space tab

A character may be quoted (i.e., made to stand for itself) by preceding it with a <b>\</b>.
<h3>Example</h3>
Following example shows how to print a <b>*</b> or a <b>?</b> -
<a href="http://tpcg.io/Zys0js" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

#!/bin/sh
echo Hello; Word

Upon execution, you will receive the following result -
Hello
./test.sh: line 2: Word: command not found
shell returned 127

Let us now try using a quoted character -
<a href="http://tpcg.io/NMnaJv" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

#!/bin/sh
echo Hello\; Word

Upon execution, you will receive the following result -
Hello; Word

The <b>$</b> sign is one of the metacharacters, so it must be quoted to avoid special handling by the shell -
<a href="http://tpcg.io/RdOwAg" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

#!/bin/sh
echo "I have \$1200"

Upon execution, you will receive the following result -
I have $1200

The following table lists the four forms of quoting -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Quoting &amp; Description</th></tr>
<tr><td>1</td><td><b>Single quote</b>
All special characters between these quotes lose their special meaning.</td></tr>
<tr><td>2</td><td><b>Double quote</b>
Most special characters between these quotes lose their special meaning with these exceptions -
$
`
\$
\'
\"
\\
</td></tr>
<tr><td>3</td><td><b>Backslash</b>
Any character immediately following the backslash loses its special meaning.</td></tr>
<tr><td>4</td><td><b>Back quote</b>
Anything in between back quotes would be treated as a command and would be executed.</td></tr>
</table>
<h2>&emsp;The Single Quotes</h2>
Consider an echo command that contains many special shell characters -
echo &lt;-$1500.**&gt;; (update?) [y|n]

Putting a backslash in front of each special character is tedious and makes the line difficult to read -
echo \&lt;-\$1500.\*\*\&gt;\; \(update\?\) \[y\|n\]

There is an easy way to quote a large group of characters. 
Put a single quote (') at the beginning and at the end of the string -
echo '&lt;-$1500.**&gt;; (update?) [y|n]'

Characters within single quotes are quoted just as if a backslash is in front of each character. 
With this, the echo command displays in a proper way.
If a single quote appears within a string to be output, you should not put the whole string within single quotes instead you should precede that using a backslash (\) as follows -
echo 'It\'s Shell Programming

<h2>&emsp;The Double Quotes</h2>
Try to execute the following shell script. 
This shell script makes use of single quote -
<a href="http://tpcg.io/U3IE2i" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

VAR=ZARA
echo '$VAR owes &lt;-$1500.**&gt;; [ as of (`date +%m/%d`) ]'

Upon execution, you will receive the following result -
$VAR owes &lt;-$1500.**&gt;; [ as of (`date +%m/%d`) ]

This is not what had to be displayed. 
It is obvious that single quotes prevent variable substitution. 
If you want to substitute variable values and to make inverted commas work as expected, then you would need to put your commands in double quotes as follows -
<a href="http://tpcg.io/5DzVN3" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

VAR=ZARA
echo "$VAR owes &lt;-\$1500.**&gt;; [ as of (`date +%m/%d`) ]"

Upon execution, you will receive the following result -
ZARA owes &lt;-$1500.**&gt;; [ as of (07/02) ]

Double quotes take away the special meaning of all characters except the following -
<b>$</b> for parameter substitution
Backquotes for command substitution
<b>\$</b> to enable literal dollar signs
<b>\`</b> to enable literal backquotes
<b>\"</b> to enable embedded double quotes
<b>\\</b> to enable embedded backslashes
All other <b>\</b> characters are literal (not special)

Characters within single quotes are quoted just as if a backslash is in front of each character. 
This helps the echo command display properly.
If a single quote appears within a string to be output, you should not put the whole string within single quotes instead you should precede that using a backslash (\) as follows -
echo 'It\'s Shell Programming'

<h2>&emsp;The Backquotes</h2>
Putting any Shell command in between <b>backquotes</b> executes the command.
<h3>Syntax</h3>
Here is the simple syntax to put any Shell <b>command</b> in between backquotes -
var=`command`

<h3>Example</h3>
The <b>date</b> command is executed in the following example and the produced result is stored in DATA variable.

<a href="http://tpcg.io/90knhD" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

DATE=`date`
echo "Current Date: $DATE"

Upon execution, you will receive the following result -
Current Date: Thu Jul  2 05:28:45 MST 2009

<h2><span class="orange">Unix / Linux - Shell Input/Output Redirections</span></h2>
In this chapter, we will discuss in detail about the Shell input/output redirections. 
Most Unix system commands take input from your terminal and send the resulting output back to your terminal. 
A command normally reads its input from the standard input, which happens to be your terminal by default. 
Similarly, a command normally writes its output to standard output, which is again your terminal by default.
<h2>&emsp;Output Redirection</h2>
The output from a command normally intended for standard output can be easily diverted to a file instead. 
This capability is known as output redirection.
If the notation &gt; file is appended to any command that normally writes its output to standard output, the output of that command will be written to file instead of your terminal.
Check the following <b>who</b> command which redirects the complete output of the command in the users file.

$ who &gt; users

Notice that no output appears at the terminal. 
This is because the output has been redirected from the default standard output device (the terminal) into the specified file. 
You can check the users file for the complete content -
$ cat users
oko         tty01   Sep 12 07:30
ai          tty15   Sep 12 13:32
ruth        tty21   Sep 12 10:10
pat         tty24   Sep 12 13:07
steve       tty25   Sep 12 13:03
$

If a command has its output redirected to a file and the file already contains some data, that data will be lost. 
Consider the following example -
$ echo line 1 &gt; users
$ cat users
line 1
$

You can use &gt;&gt; operator to append the output in an existing file as follows -
$ echo line 2 &gt;&gt; users
$ cat users
line 1
line 2
$

<h2>&emsp;Input Redirection</h2>
Just as the output of a command can be redirected to a file, so can the input of a command be redirected from a file. 
As the <b>greater-than character &gt;</b> is used for output redirection, the <b>less-than character &lt;</b> is used to redirect the input of a command.
The commands that normally take their input from the standard input can have their input redirected from a file in this manner. 
For example, to count the number of lines in the file <i>users</i> generated above, you can execute the command as follows -
$ wc -l users
2 users
$

Upon execution, you will receive the following output. 
You can count the number of lines in the file by redirecting the standard input of the <b>wc</b> command from the file <i>users</i> -
$ wc -l &lt; users
2
$

Note that there is a difference in the output produced by the two forms of the wc command. 
In the first case, the name of the file users is listed with the line count; in the second case, it is not.
In the first case, wc knows that it is reading its input from the file users. 
In the second case, it only knows that it is reading its input from standard input so it does not display file name.
<h2>&emsp;Here Document</h2>
A <b>here document</b> is used to redirect input into an interactive shell script or program.
We can run an interactive program within a shell script without user action by supplying the required input for the interactive program, or interactive shell script.
The general form for a <b>here</b> document is -
command &lt;&lt; delimiter
document
delimiter

Here the shell interprets the <b>&lt;&lt;</b> operator as an instruction to read input until it finds a line containing the specified delimiter. 
All the input lines up to the line containing the delimiter are then fed into the standard input of the command.
The delimiter tells the shell that the <b>here</b> document has completed. 
Without it, the shell continues to read the input forever. 
The delimiter must be a single word that does not contain spaces or tabs.
Following is the input to the command <b>wc -l</b> to count the total number of lines -
$wc -l &lt;&lt; EOF
   This is a simple lookup program 
for good (and bad) restaurants
in Cape Town.
EOF
3
$

You can use the <b>here document</b> to print multiple lines using your script as follows -
<a href="http://tpcg.io/o3GfEg" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

#!/bin/sh
cat &lt;&lt; EOF
This is a simple lookup program 
for good (and bad) restaurants
in Cape Town.
EOF

Upon execution, you will receive the following result -
This is a simple lookup program
for good (and bad) restaurants
in Cape Town.

The following script runs a session with the <b>vi</b> text editor and saves the input in the file <b>test.txt</b>.

#!/bin/sh
filename=test.txt
vi $filename &lt;&lt;EndOfCommands
i
This file was created automatically from
a shell script
^[
ZZ
EndOfCommands

If you run this script with vim acting as vi, then you will likely see output like the following -
$ sh test.sh
Vim: Warning: Input is not from a terminal
$

After running the script, you should see the following added to the file <b>test.txt</b> -
$ cat test.txt
This file was created automatically from
a shell script
$

<h2>&emsp;Discard the output</h2>
Sometimes you will need to execute a command, but you don't want the output displayed on the screen. 
In such cases, you can discard the output by redirecting it to the file <b>/dev/null</b> -
$ command &gt; /dev/null

Here command is the name of the command you want to execute. 
The file <b>/dev/null</b> is a special file that automatically discards all its input.
To discard both output of a command and its error output, use standard redirection to redirect <b>STDERR</b> to <b>STDOUT</b> -
$ command &gt; /dev/null 2&gt;&amp;1

Here <b>2</b> represents <b>STDERR</b> and <b>1</b> represents <b>STDOUT</b>. 
You can display a message on to STDERR by redirecting STDOUT into STDERR as follows -
$ echo message 1&gt;&amp;2

<h2>&emsp;Redirection Commands</h2>
Following is a complete list of commands which you can use for redirection -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Command &amp; Description</th></tr>
<tr><td>1</td><td><b>pgm &gt; file</b>
Output of pgm is redirected to file</td></tr>
<tr><td>2</td><td><b>pgm &lt; file</b>
Program pgm reads its input from file</td></tr>
<tr><td>3</td><td><b>pgm &gt;&gt; file</b>
Output of pgm is appended to file</td></tr>
<tr><td>4</td><td><b>n &gt; file</b>
Output from stream with descriptor <b>n</b> redirected to file</td></tr>
<tr><td>5</td><td><b>n &gt;&gt; file</b>
Output from stream with descriptor <b>n</b> appended to file</td></tr>
<tr><td>6</td><td><b>n &gt;&amp; m</b>
Merges output from stream <b>n</b> with stream <b>m</b></td></tr>
<tr><td>7</td><td><b>n &lt;&amp; m</b>
Merges input from stream <b>n</b> with stream <b>m</b></td></tr>
<tr><td>8</td><td><b>&lt;&lt; tag</b>
Standard input comes from here through next tag at the start of line</td></tr>
<tr><td>9</td><td><b>&amp;verbar;</b>
Takes output from one program, or process, and sends it to another</td></tr>
</table>
Note that the file descriptor <b>0</b> is normally standard input (STDIN), <b>1</b> is standard output (STDOUT), and <b>2</b> is standard error output (STDERR).

<h2><span class="orange">Unix / Linux - Shell Functions</span></h2>
In this chapter, we will discuss in detail about the shell functions. 
Functions enable you to break down the overall functionality of a script into smaller, logical subsections, which can then be called upon to perform their individual tasks when needed.
Using functions to perform repetitive tasks is an excellent way to create <b>code reuse</b>. 
This is an important part of modern object-oriented programming principles.
Shell functions are similar to subroutines, procedures, and functions in other programming languages.
<h2>&emsp;Creating Functions</h2>
To declare a function, simply use the following syntax -
function_name () { 
   list of commands
}

The name of your function is <b>function_name</b>, and that's what you will use to call it from elsewhere in your scripts. 
The function name must be followed by parentheses, followed by a list of commands enclosed within braces.
<h3>Example</h3>
Following example shows the use of function -
<a href="http://tpcg.io/o9dmTt" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

#!/bin/sh
# Define your function here
Hello () {
   echo "Hello World"
}
# Invoke your function
Hello

Upon execution, you will receive the following output -
$./test.sh
Hello World

<h2>&emsp;Pass Parameters to a Function</h2>
You can define a function that will accept parameters while calling the function. 
These parameters would be represented by <b>$1</b>, <b>$2</b> and so on.
Following is an example where we pass two parameters <i>Zara</i> and <i>Ali</i> and then we capture and print these parameters in the function.

<a href="http://tpcg.io/FOOm8P" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

#!/bin/sh
# Define your function here
Hello () {
   echo "Hello World $1 $2"
}
# Invoke your function
Hello Zara Ali

Upon execution, you will receive the following result -
$./test.sh
Hello World Zara Ali

<h2>&emsp;Returning Values from Functions</h2>
If you execute an <b>exit</b> command from inside a function, its effect is not only to terminate execution of the function but also of the shell program that called the function.
If you instead want to just terminate execution of the function, then there is way to come out of a defined function.
Based on the situation you can return any value from your function using the <b>return</b> command whose syntax is as follows -
return code

Here <b>code</b> can be anything you choose here, but obviously you should choose something that is meaningful or useful in the context of your script as a whole.
<h3>Example</h3>
Following function returns a value 10 -
<a href="http://tpcg.io/lVaJwM" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

#!/bin/sh
# Define your function here
Hello () {
   echo "Hello World $1 $2"
   return 10
}
# Invoke your function
Hello Zara Ali
# Capture value returnd by last command
ret=$?
echo "Return value is $ret"

Upon execution, you will receive the following result -
$./test.sh
Hello World Zara Ali
Return value is 10

<h2>&emsp;Nested Functions</h2>
One of the more interesting features of functions is that they can call themselves and also other functions. 
A function that calls itself is known as a <b><i>recursive function</i></b>.
Following example demonstrates nesting of two functions -
<a href="http://tpcg.io/ooh900" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

#!/bin/sh
# Calling one function from another
number_one () {
   echo "This is the first function speaking..."
   number_two
}
number_two () {
   echo "This is now the second function speaking..."
}
# Calling function one.
number_one

Upon execution, you will receive the following result -
This is the first function speaking...
This is now the second function speaking...

<h2>&emsp;Function Call from Prompt</h2>
You can put definitions for commonly used functions inside your <b><i>.profile</i></b>. 
These definitions will be available whenever you log in and you can use them at the command prompt.
Alternatively, you can group the definitions in a file, say <b><i>test.sh</i></b>, and then execute the file in the current shell by typing -
$. 
test.sh

This has the effect of causing functions defined inside <b><i>test.sh</i></b> to be read and defined to the current shell as follows -
$ number_one
This is the first function speaking...
This is now the second function speaking...
$

To remove the definition of a function from the shell, use the unset command with the <b>.f</b> option. 
This command is also used to remove the definition of a variable to the shell.

$ unset -f function_name

<h2><span class="orange">Unix / Linux - Shell Manpage Help</span></h2>
All the Unix commands come with a number of optional and mandatory options. 
It is very common to forget the complete syntax of these commands.
 
Because no one can possibly remember every Unix command and all its options, we have online help available to mitigate this right from when Unix was at its development stage.
Unix's version of <b>Help files</b> are called <b>man pages</b>. 
If there is a command name and you are not sure how to use it, then Man Pages help you out with every step.
<h3>Syntax</h3>
Here is the simple command that helps you get the detail of any Unix command while working with the system -
$man command

<h3>Example</h3>
Suppose there is a command that requires you to get help; assume that you want to know about <b>pwd</b> then you simply need to use the following command -
$man pwd

The above command helps you with the complete information about the <b>pwd</b> command. 
Try it yourself at your command prompt to get more detail.
You can get complete detail on <b>man</b> command itself using the following command -
$man man

<h2>&emsp;Man Page Sections</h2>
Man pages are generally divided into sections, which generally vary by the man page author's preference. 
Following table lists some common sections -
 
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Section &amp; Description</th></tr>
<tr><td>1</td><td><b>NAME</b>
Name of the command</td></tr>
<tr><td>2</td><td><b>SYNOPSIS</b>
General usage parameters of the command</td></tr>
<tr><td>3</td><td><b>DESCRIPTION</b>
Describes what the command does</td></tr>
<tr><td>4</td><td><b>OPTIONS</b>
Describes all the arguments or options to the command</td></tr>
<tr><td>5</td><td><b>SEE ALSO</b>
Lists other commands that are directly related to the command in the man page or closely resemble its functionality</td></tr>
<tr><td>6</td><td><b>BUGS</b>
Explains any known issues or bugs that exist with the command or its output</td></tr>
<tr><td>7</td><td><b>EXAMPLES</b>
Common usage examples that give the reader an idea of how the command can be used</td></tr>
<tr><td>8</td><td><b>AUTHORS</b>
The author of the man page/command</td></tr>
</table>
To sum it up, man pages are a vital resource and the first avenue of research when you need information about commands or files in a Unix system.
<h2>&emsp;Useful Shell Commands</h2>
The following link gives you a list of the most important and very frequently used Unix Shell commands.
If you do not know how to use any command, then use man page to get complete detail about the command.
Here is the list of <a href="/unix/unix-useful-commands.htm">Unix Shell - Useful Commands</a>

<h2><span class="orange">Unix / Linux - Regular Expressions with SED</span></h2>
In this chapter, we will discuss in detail about regular expressions with SED in Unix.
A regular expression is a string that can be used to describe several sequences of characters. 
Regular expressions are used by several different Unix commands, including <b>ed</b>, <b>sed</b>, <b>awk</b>, <b>grep</b>, and to a more limited extent, <b>vi</b>.
Here <b>SED</b> stands for <b>s</b>tream <b>ed</b>itor. 
This stream-oriented editor was created exclusively for executing scripts. 
Thus, all the input you feed into it passes through and goes to STDOUT and it does not change the input file.
<h2>&emsp;Invoking sed</h2>
Before we start, let us ensure we have a local copy of <b>/etc/passwd</b> text file to work with <b>sed</b>.
As mentioned previously, sed can be invoked by sending data through a pipe to it as follows -
$ cat /etc/passwd | sed
Usage: sed [OPTION]... 
{script-other-script} [input-file]...
  -n, --quiet, --silent
                 suppress automatic printing of pattern space
  -e script, --expression = script
...............................

The <b>cat</b> command dumps the contents of <b>/etc/passwd</b> to <b>sed</b> through the pipe into sed's pattern space. 
The pattern space is the internal work buffer that sed uses for its operations.
<h2>&emsp;The sed General Syntax</h2>
Following is the general syntax for sed -
/pattern/action

Here, <b>pattern</b> is a regular expression, and <b>action</b> is one of the commands given in the following table. 
If <b>pattern</b> is omitted, <b>action</b> is performed for every line as we have seen above.
The slash character (/) that surrounds the pattern are required because they are used as delimiters.
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Range &amp; Description</th></tr>
<tr><td>1</td><td><b>p</b>
Prints the line</td></tr>
<tr><td>2</td><td><b>d</b>
Deletes the line</td></tr>
<tr><td>3</td><td><b>s/pattern1/pattern2/</b>
Substitutes the first occurrence of pattern1 with pattern2</td></tr>
</table>
<h2>&emsp;Deleting All Lines with sed</h2>
We will now understand how to delete all lines with sed. 
Invoke sed again; but the sed is now supposed to use the <b>editing command delete line</b>, denoted by the single letter <b>d</b> -
$ cat /etc/passwd | sed 'd'
$

Instead of invoking sed by sending a file to it through a pipe, the sed can be instructed to read the data from a file, as in the following example.
The following command does exactly the same as in the previous example, without the cat command -
$ sed -e 'd' /etc/passwd
$

<h2>&emsp;The sed Addresses</h2>
The sed also supports addresses. 
Addresses are either particular locations in a file or a range where a particular editing command should be applied. 
When the sed encounters no addresses, it performs its operations on every line in the file.
The following command adds a basic address to the sed command you've been using -
$ cat /etc/passwd | sed '1d' |more
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/bin/sh
man:x:6:12:man:/var/cache/man:/bin/sh
mail:x:8:8:mail:/var/mail:/bin/sh
news:x:9:9:news:/var/spool/news:/bin/sh
backup:x:34:34:backup:/var/backups:/bin/sh
$

Notice that the number 1 is added before the <b>delete edit</b> command. 
This instructs the sed to perform the editing command on the first line of the file. 
In this example, the sed will delete the first line of <b>/etc/password</b> and print the rest of the file.
<h2>&emsp;The sed Address Ranges</h2>
We will now understand how to work with <b>the sed address ranges</b>. 
So what if you want to remove more than one line from a file? You can specify an address range with sed as follows -
$ cat /etc/passwd | sed '1, 5d' |more
games:x:5:60:games:/usr/games:/bin/sh
man:x:6:12:man:/var/cache/man:/bin/sh
mail:x:8:8:mail:/var/mail:/bin/sh
news:x:9:9:news:/var/spool/news:/bin/sh
backup:x:34:34:backup:/var/backups:/bin/sh
$

The above command will be applied on all the lines starting from 1 through 5. 
This deletes the first five lines.
Try out the following address ranges -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Range &amp; Description</th></tr>
<tr><td>1</td><td><b>'4,10d'</b>
Lines starting from the 4<sup>th</sup> till the 10<sup>th</sup> are deleted</td></tr>
<tr><td>2</td><td><b>'10,4d'</b>
Only 10<sup>th</sup> line is deleted, because the sed does not work in reverse direction</td></tr>
<tr><td>3</td><td><b>'4,&amp;plus;5d'</b>
This matches line 4 in the file, deletes that line, continues to delete the next five lines, and then ceases its deletion and prints the rest</td></tr>
<tr><td>4</td><td><b>'2,5!d'</b>
This deletes everything except starting from 2<sup>nd</sup> till 5<sup>th</sup> line</td></tr>
<tr><td>5</td><td><b>'1~3d'</b>
This deletes the first line, steps over the next three lines, and then deletes the fourth line. 
Sed continues to apply this pattern until the end of the file.</td></tr>
<tr><td>6</td><td><b>'2~2d'</b>
This tells sed to delete the second line, step over the next line, delete the next line, and repeat until the end of the file is reached</td></tr>
<tr><td>7</td><td><b>'4,10p'</b>
Lines starting from 4<sup>th</sup> till 10<sup>th</sup> are printed</td></tr>
<tr><td>8</td><td><b>'4,d'</b>
This generates the syntax error</td></tr>
<tr><td>9</td><td><b>',10d'</b>
This would also generate syntax error</td></tr>
</table>
<b>Note</b> - While using the <b>p</b> action, you should use the <b>-n</b> option to avoid repetition of line printing. 
Check the difference in between the following two commands -
$ cat /etc/passwd | sed -n '1,3p'
Check the above command without -n as follows -
$ cat /etc/passwd | sed '1,3p'

<h2>&emsp;The Substitution Command</h2>
The substitution command, denoted by <b>s</b>, will substitute any string that you specify with any other string that you specify.
To substitute one string with another, the sed needs to have the information on where the first string ends and the substitution string begins. 
For this, we proceed with bookending the two strings with the forward slash (<b>/</b>) character.
The following command substitutes the first occurrence on a line of the string <b>root</b> with the string <b>amrood</b>.

$ cat /etc/passwd | sed 's/root/amrood/'
amrood:x:0:0:root user:/root:/bin/sh
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
..........................

It is very important to note that sed substitutes only the first occurrence on a line. 
If the string root occurs more than once on a line only the first match will be replaced.
For the sed to perform a global substitution, add the letter <b>g</b> to the end of the command as follows -
$ cat /etc/passwd | sed 's/root/amrood/g'
amrood:x:0:0:amrood user:/amrood:/bin/sh
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
...........................

<h2>&emsp;Substitution Flags</h2>
There are a number of other useful flags that can be passed in addition to the <b>g</b> flag, and you can specify more than one at a time.
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Flag &amp; Description</th></tr>
<tr><td>1</td><td><b>g</b>
Replaces all matches, not just the first match</td></tr>
<tr><td>2</td><td><b>NUMBER</b>
Replaces only NUMBER<sup>th</sup> match</td></tr>
<tr><td>3</td><td><b>p</b>
If substitution was made, then prints the pattern space</td></tr>
<tr><td>4</td><td><b>w FILENAME</b>
If substitution was made, then writes result to FILENAME</td></tr>
<tr><td>5</td><td><b>I or i</b>
Matches in a case-insensitive manner</td></tr>
<tr><td>6</td><td><b>M or m</b>
In addition to the normal behavior of the special regular expression characters ^ and $, this flag causes ^ to match the empty string after a newline and $ to match the empty string before a newline</td></tr>
</table>
<h2>&emsp;Using an Alternative String Separator</h2>
Suppose you have to do a substitution on a string that includes the forward slash character. 
In this case, you can specify a different separator by providing the designated character after the <b>s</b>.

$ cat /etc/passwd | sed 's:/root:/amrood:g'
amrood:x:0:0:amrood user:/amrood:/bin/sh
daemon:x:1:1:daemon:/usr/sbin:/bin/sh

In the above example, we have used <b>:</b> as the <b>delimiter</b> instead of slash / because we were trying to search <b>/root</b> instead of the simple root.
<h2>&emsp;Replacing with Empty Space</h2>
Use an empty substitution string to delete the root string from the <b>/etc/passwd</b> file entirely -
$ cat /etc/passwd | sed 's/root//g'
:x:0:0::/:/bin/sh
daemon:x:1:1:daemon:/usr/sbin:/bin/sh

<h2>&emsp;Address Substitution</h2>
If you want to substitute the string <b>sh</b> with the string <b>quiet</b> only on line 10, you can specify it as follows -
$ cat /etc/passwd | sed '10s/sh/quiet/g'
root:x:0:0:root user:/root:/bin/sh
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/bin/sh
man:x:6:12:man:/var/cache/man:/bin/sh
mail:x:8:8:mail:/var/mail:/bin/sh
news:x:9:9:news:/var/spool/news:/bin/sh
backup:x:34:34:backup:/var/backups:/bin/quiet

Similarly, to do an address range substitution, you could do something like the following -
$ cat /etc/passwd | sed '1,5s/sh/quiet/g'
root:x:0:0:root user:/root:/bin/quiet
daemon:x:1:1:daemon:/usr/sbin:/bin/quiet
bin:x:2:2:bin:/bin:/bin/quiet
sys:x:3:3:sys:/dev:/bin/quiet
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/bin/sh
man:x:6:12:man:/var/cache/man:/bin/sh
mail:x:8:8:mail:/var/mail:/bin/sh
news:x:9:9:news:/var/spool/news:/bin/sh
backup:x:34:34:backup:/var/backups:/bin/sh

As you can see from the output, the first five lines had the string <b>sh</b> changed to <b>quiet</b>, but the rest of the lines were left untouched.
<h2>&emsp;The Matching Command</h2>
You would use the <b>p</b> option along with the <b>-n</b> option to print all the matching lines as follows -
$ cat testing | sed -n '/root/p'
root:x:0:0:root user:/root:/bin/sh
[root@ip-72-167-112-17 amrood]# vi testing
root:x:0:0:root user:/root:/bin/sh
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/bin/sh
man:x:6:12:man:/var/cache/man:/bin/sh
mail:x:8:8:mail:/var/mail:/bin/sh
news:x:9:9:news:/var/spool/news:/bin/sh
backup:x:34:34:backup:/var/backups:/bin/sh

<h2>&emsp;Using Regular Expression</h2>
While matching patterns, you can use the regular expression which provides more flexibility.
Check the following example which matches all the lines starting with <i>daemon</i> and then deletes them -
$ cat testing | sed '/^daemon/d'
root:x:0:0:root user:/root:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/bin/sh
man:x:6:12:man:/var/cache/man:/bin/sh
mail:x:8:8:mail:/var/mail:/bin/sh
news:x:9:9:news:/var/spool/news:/bin/sh
backup:x:34:34:backup:/var/backups:/bin/sh

Following is the example which deletes all the lines ending with <b>sh</b> -
$ cat testing | sed '/sh$/d'
sync:x:4:65534:sync:/bin:/bin/sync

The following table lists four special characters that are very useful in regular expressions.
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Character &amp; Description</th></tr>
<tr><td>1</td><td><b>^</b>
Matches the beginning of lines</td></tr>
<tr><td>2</td><td><b>$</b>
Matches the end of lines</td></tr>
<tr><td>3</td><td><b>.</b>
Matches any single character</td></tr>
<tr><td>4</td><td><b>*</b>
Matches zero or more occurrences of the previous character</td></tr>
<tr><td>5</td><td><b>[chars]</b>
Matches any one of the characters given in chars, where chars is a sequence of characters. 
You can use the - character to indicate a range of characters.</td></tr>
</table>
<h2>&emsp;Matching Characters</h2>
Look at a few more expressions to demonstrate the use of <b>metacharacters</b>. 
For example, the following pattern -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Expression &amp; Description</th></tr>
<tr><td>1</td><td><b>/a.c/</b>
Matches lines that contain strings such as <b>a&amp;plus;c</b>, <b>a-c</b>, <b>abc</b>, <b>match</b>, and <b>a3c</b></td></tr>
<tr><td>2</td><td><b>/a*c/</b>
Matches the same strings along with strings such as <b>ace</b>, <b>yacc</b>, and <b>arctic</b></td></tr>
<tr><td>3</td><td><b>/[tT]he/</b>
Matches the string <b>The</b> and <b>the</b></td></tr>
<tr><td>4</td><td><b>/^$/</b>
Matches blank lines</td></tr>
<tr><td>5</td><td><b>/^.*$/</b>
Matches an entire line whatever it is</td></tr>
<tr><td>6</td><td><b>/ */</b>
Matches one or more spaces</td></tr>
<tr><td>7</td><td><b>/^$/</b>
Matches <b>blank</b> lines</td></tr>
</table>
Following table shows some frequently used sets of characters -
<table class="table table-bordered">
<tr><th style="text-align:center;width:8%">Sr.No.</th><th>Set &amp; Description</th></tr>
<tr><td>1</td><td><b>[a-z]</b>
Matches a single lowercase letter</td></tr>
<tr><td>2</td><td><b>[A-Z]</b>
Matches a single uppercase letter</td></tr>
<tr><td>3</td><td><b>[a-zA-Z]</b>
Matches a single letter</td></tr>
<tr><td>4</td><td><b>[0-9]</b>
Matches a single number</td></tr>
<tr><td>5</td><td><b>[a-zA-Z0-9]</b>
Matches a single letter or number</td></tr>
</table>
<h2>&emsp;Character Class Keywords</h2>
Some special keywords are commonly available to <b>regexps</b>, especially GNU utilities that employ <b>regexps</b>. 
These are very useful for sed regular expressions as they simplify things and enhance readability.
For example, the characters <b>a through z</b> and the characters <b>A through Z</b>, constitute one such class of characters that has the keyword <b>[[:alpha:]]</b>
Using the alphabet character class keyword, this command prints only those lines in the <b>/etc/syslog.conf</b> file that start with a letter of the alphabet -
$ cat /etc/syslog.conf | sed -n '/^[[:alpha:]]/p'
authpriv.*                         /var/log/secure
mail.*                             -/var/log/maillog
cron.*                             /var/log/cron
uucp,news.crit                     /var/log/spooler
local7.*                           /var/log/boot.log

The following table is a complete list of the available character class keywords in GNU sed.
<table class="table table-bordered">
<tr><th style="text-align:center;width:8%">Sr.No.</th><th>Character Class &amp; Description</th></tr>
<tr><td>1</td><td><b>[[:alnum:]]</b>
Alphanumeric [a-z A-Z 0-9]</td></tr>
<tr><td>2</td><td><b>[[:alpha:]]</b>
Alphabetic [a-z A-Z]</td></tr>
<tr><td>3</td><td><b>[[:blank:]]</b>
Blank characters (spaces or tabs)</td></tr>
<tr><td>4</td><td><b>[[:cntrl:]]</b>
Control characters</td></tr>
<tr><td>5</td><td><b>[[:digit:]]</b>
Numbers [0-9]</td></tr>
<tr><td>6</td><td><b>[[:graph:]]</b>
Any visible characters (excludes whitespace)</td></tr>
<tr><td>7</td><td><b>[[:lower:]]</b>
Lowercase letters [a-z]</td></tr>
<tr><td>8</td><td><b>[[:print:]]</b>
Printable characters (non-control characters)</td></tr>
<tr><td>9</td><td><b>[[:punct:]]</b>
Punctuation characters</td></tr>
<tr><td>10</td><td><b>[[:space:]]</b>
Whitespace</td></tr>
<tr><td>11</td><td><b>[[:upper:]]</b>
Uppercase letters [A-Z]</td></tr>
<tr><td>12</td><td><b>[[:xdigit:]]</b>
Hex digits [0-9 a-f A-F]</td></tr>
</table>
<h2>&emsp;Aampersand Referencing</h2>
The <b>sed metacharacter &amp;</b> represents the contents of the pattern that was matched. 
For instance, say you have a file called <b>phone.txt</b> full of phone numbers, such as the following -
5555551212
5555551213
5555551214
6665551215
6665551216
7775551217

You want to make the <b>area code</b> (the first three digits) surrounded by parentheses for easier reading. 
To do this, you can use the ampersand replacement character -
$ sed -e 's/^[[:digit:]][[:digit:]][[:digit:]]/(&amp;)/g' phone.txt
(555)5551212
(555)5551213
(555)5551214
(666)5551215
(666)5551216
(777)5551217

Here in the pattern part you are matching the first 3 digits and then using <b>&amp;</b> you are replacing those 3 digits with the surrounding <b>parentheses</b>.
<h2>&emsp;Using Multiple sed Commands</h2>
You can use multiple sed commands in a single sed command as follows -
$ sed -e 'command1' -e 'command2' ... 
-e 'commandN' files

Here <b>command1</b> through <b>commandN</b> are sed commands of the type discussed previously. 
These commands are applied to each of the lines in the list of files given by files.
Using the same mechanism, we can write the above phone number example as follows -
$ sed -e 's/^[[:digit:]]\{3\}/(&amp;)/g'  \ 
   -e 's/)[[:digit:]]\{3\}/&amp;-/g' phone.txt 
(555)555-1212 
(555)555-1213 
(555)555-1214 
(666)555-1215 
(666)555-1216 
(777)555-1217

<b>Note</b> - In the above example, instead of repeating the character class keyword <b>[[:digit:]]</b> three times, we replaced it with <b>\{3\}</b>, which means the preceding regular expression is matched three times. 
We have also used <b>\</b> to give line break and this has to be removed before the command is run.
<h2>&emsp;Back References</h2>
The <b>ampersand metacharacter</b> is useful, but even more useful is the ability to define specific regions in regular expressions. 
These special regions can be used as reference in your replacement strings. 
By defining specific parts of a regular expression, you can then refer back to those parts with a special reference character.
To do <b>back references</b>, you have to first define a region and then refer back to that region. 
To define a region, you insert <b>backslashed parentheses</b> around each region of interest. 
The first region that you surround with backslashes is then referenced by <b>\1</b>, the second region by <b>\2</b>, and so on.
Assuming <b>phone.txt</b> has the following text -
(555)555-1212
(555)555-1213
(555)555-1214
(666)555-1215
(666)555-1216
(777)555-1217

Try the following command -
$ cat phone.txt | sed 's/\(.*)\)\(.*-\)\(.*$\)/Area \ 
   code: \1 Second: \2 Third: \3/' 
Area code: (555) Second: 555- Third: 1212 
Area code: (555) Second: 555- Third: 1213 
Area code: (555) Second: 555- Third: 1214 
Area code: (666) Second: 555- Third: 1215 
Area code: (666) Second: 555- Third: 1216 
Area code: (777) Second: 555- Third: 1217

<b>Note</b> - In the above example, each regular expression inside the parenthesis would be back referenced by <b>\1</b>, <b>\2</b> and so on. 
We have used <b>\</b> to give line break here. 
This should be removed before running the command.

<h2><span class="orange">Unix / Linux - File System Basics</span></h2>
A file system is a logical collection of files on a partition or disk. 
A partition is a container for information and can span an entire hard drive if desired.
Your hard drive can have various partitions which usually contain only one file system, such as one file system housing the <b>/file system</b> or another containing the <b>/home file system</b>.
One file system per partition allows for the logical maintenance and management of differing file systems.
Everything in Unix is considered to be a file, including physical devices such as DVD-ROMs, USB devices, and floppy drives.
<h2>&emsp;Directory Structure</h2>
Unix uses a hierarchical file system structure, much like an upside-down tree, with root (/) at the base of the file system and all other directories spreading from there.
A Unix filesystem is a collection of files and directories that has the following properties -
It has a root directory (<b>/</b>) that contains other files and directories.
Each file or directory is uniquely identified by its name, the directory in which it resides, and a unique identifier, typically called an <b>inode</b>.
By convention, the root directory has an <b>inode</b> number of <b>2</b> and the <b>lost&amp;plus;found</b> directory has an <b>inode</b> number of <b>3</b>. 
Inode numbers <b>0</b> and <b>1</b> are not used. 
File inode numbers can be seen by specifying the <b>-i option</b> to <b>ls command</b>.
It is self-contained. 
There are no dependencies between one filesystem and another.

The directories have specific purposes and generally hold the same types of information for easily locating files. 
Following are the directories that exist on the major versions of Unix -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Directory &amp; Description</th></tr>
<tr><td>1</td><td><b>/</b>
This is the root directory which should contain only the directories needed at the top level of the file structure</td></tr>
<tr><td>2</td><td><b>/bin</b>
This is where the executable files are located. 
These files are available to all users</td></tr>
<tr><td>3</td><td><b>/dev</b>
These are device drivers</td></tr>
<tr><td>4</td><td><b>/etc</b>
Supervisor directory commands, configuration files, disk configuration files, valid user lists, groups, ethernet, hosts, where to send critical messages</td></tr>
<tr><td>5</td><td><b>/lib</b>
Contains shared library files and sometimes other kernel-related files</td></tr>
<tr><td>6</td><td><b>/boot</b>
Contains files for booting the system</td></tr>
<tr><td>7</td><td><b>/home</b>
Contains the home directory for users and other accounts</td></tr>
<tr><td>8</td><td><b>/mnt</b>
Used to mount other temporary file systems, such as <b>cdrom</b> and <b>floppy</b> for the <b>CD-ROM</b> drive and <b>floppy diskette drive</b>, respectively</td></tr>
<tr><td>9</td><td><b>/proc</b>
Contains all processes marked as a file by <b>process number</b> or other information that is dynamic to the system</td></tr>
<tr><td>10</td><td><b>/tmp</b>
Holds temporary files used between system boots</td></tr>
<tr><td>11</td><td><b>/usr</b>
Used for miscellaneous purposes, and can be used by many users. 
Includes administrative commands, shared files, library files, and others</td></tr>
<tr><td>12</td><td><b>/var</b>
Typically contains variable-length files such as log and print files and any other type of file that may contain a variable amount of data</td></tr>
<tr><td>13</td><td><b>/sbin</b>
Contains binary (executable) files, usually for system administration. 
For example, <b><i>fdisk</i></b> and <b><i>ifconfig</i></b> utlities</td></tr>
<tr><td>14</td><td><b>/kernel</b>
Contains kernel files</td></tr>
</table>
<h2>&emsp;Navigating the File System</h2>
Now that you understand the basics of the file system, you can begin navigating to the files you need. 
The following commands are used to navigate the system -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Command &amp; Description</th></tr>
<tr><td>1</td><td><b>cat filename</b>
Displays a filename</td></tr>
<tr><td>2</td><td><b>cd dirname</b>
Moves you to the identified directory</td></tr>
<tr><td>3</td><td><b>cp file1 file2</b>
Copies one file/directory to the specified location</td></tr>
<tr><td>4</td><td><b>file filename</b>
Identifies the file type (binary, text, etc)</td></tr>
<tr><td>5</td><td><b>find filename dir</b>
Finds a file/directory</td></tr>
<tr><td>6</td><td><b>head filename</b>
Shows the beginning of a file</td></tr>
<tr><td>7</td><td><b>less filename</b>
Browses through a file from the end or the beginning</td></tr>
<tr><td>8</td><td><b>ls dirname</b>
Shows the contents of the directory specified</td></tr>
<tr><td>9</td><td><b>mkdir dirname</b>
Creates the specified directory</td></tr>
<tr><td>10</td><td><b>more filename</b>
Browses through a file from the beginning to the end</td></tr>
<tr><td>11</td><td><b>mv file1 file2</b>
Moves the location of, or renames a file/directory</td></tr>
<tr><td>12</td><td><b>pwd</b>
Shows the current directory the user is in</td></tr>
<tr><td>13</td><td><b>rm filename</b>
Removes a file</td></tr>
<tr><td>14</td><td><b>rmdir dirname</b>
Removes a directory</td></tr>
<tr><td>15</td><td><b>tail filename</b>
Shows the end of a file</td></tr>
<tr><td>16</td><td><b>touch filename</b>
Creates a blank file or modifies an existing file or its attributes</td></tr>
<tr><td>17</td><td><b>whereis filename</b>
Shows the location of a file</td></tr>
<tr><td>18</td><td><b>which filename</b>
Shows the location of a file if it is in your PATH</td></tr>
</table>
You can use <a href="/unix/unix-manpage-help.htm">Manpage Help</a> to check complete syntax for each command mentioned here.
<h2>&emsp;The df Command</h2>
The first way to manage your partition space is with the <b>df (disk free)</b> command. 
The command <b>df -k (disk free)</b> displays the <b>disk space usage in kilobytes</b>, as shown below -
$df -k
Filesystem      1K-blocks      Used   Available Use% Mounted on
/dev/vzfs        10485760   7836644     2649116  75% /
/devices                0         0           0   0% /devices
$

Some of the directories, such as <b>/devices</b>, shows 0 in the kbytes, used, and avail columns as well as 0% for capacity. 
These are special (or virtual) file systems, and although they reside on the disk under /, by themselves they do not consume disk space.
The <b>df -k</b> output is generally the same on all Unix systems. 
Here's what it usually includes -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Column &amp; Description</th></tr>
<tr><td>1</td><td><b>Filesystem</b>
The physical file system name</td></tr>
<tr><td>2</td><td><b>kbytes</b>
Total kilobytes of space available on the storage medium</td></tr>
<tr><td>3</td><td><b>used</b>
Total kilobytes of space used (by files)</td></tr>
<tr><td>4</td><td><b>avail</b>
Total kilobytes available for use</td></tr>
<tr><td>5</td><td><b>capacity</b>
Percentage of total space used by files</td></tr>
<tr><td>6</td><td><b>Mounted on</b>
What the file system is mounted on</td></tr>
</table>
You can use the <b>-h (human readable) option</b> to display the output in a format that shows the size in easier-to-understand notation.
<h2>&emsp;The du Command</h2>
The <b>du (disk usage) command</b> enables you to specify directories to show disk space usage on a particular directory.
This command is helpful if you want to determine how much space a particular directory is taking. 
The following command displays number of blocks consumed by each directory. 
A single block may take either 512 Bytes or 1 Kilo Byte depending on your system.

$du /etc
10     /etc/cron.d
126    /etc/default
6      /etc/dfs
...
$

The <b>-h</b> option makes the output easier to comprehend -
$du -h /etc
5k    /etc/cron.d
63k   /etc/default
3k    /etc/dfs
...
$

<h2>&emsp;Mounting the File System</h2>
A file system must be mounted in order to be usable by the system. 
To see what is currently mounted (available for use) on your system, use the following command -
$ mount
/dev/vzfs on / type reiserfs (rw,usrquota,grpquota)
proc on /proc type proc (rw,nodiratime)
devpts on /dev/pts type devpts (rw)
$

The <b>/mnt</b> directory, by the Unix convention, is where temporary mounts (such as CDROM drives, remote network drives, and floppy drives) are located. 
If you need to mount a file system, you can use the mount command with the following syntax -
mount -t file_system_type device_to_mount directory_to_mount_to

For example, if you want to mount a <b>CD-ROM</b> to the directory <b>/mnt/cdrom</b>, you can type -
$ mount -t iso9660 /dev/cdrom /mnt/cdrom

This assumes that your CD-ROM device is called <b>/dev/cdrom</b> and that you want to mount it to <b>/mnt/cdrom</b>. 
Refer to the mount man page for more specific information or type mount <b>-h</b> at the command line for help information.
After mounting, you can use the cd command to navigate the newly available file system through the mount point you just made.
<h2>&emsp;Unmounting the File System</h2>
To unmount (remove) the file system from your system, use the <b>umount</b> command by identifying the mount point or device.
For example, <b>to unmount cdrom</b>, use the following command -
$ umount /dev/cdrom

The <b>mount command</b> enables you to access your file systems, but on most modern Unix systems, the <b>automount function</b> makes this process invisible to the user and requires no intervention.
<h2>&emsp;User and Group Quotas</h2>
The user and group quotas provide the mechanisms by which the amount of space used by a single user or all users within a specific group can be limited to a value defined by the administrator.
Quotas operate around two limits that allow the user to take some action if the amount of space or number of disk blocks start to exceed the administrator defined limits -
<b>Soft Limit</b> - If the user exceeds the limit defined, there is a grace period that allows the user to free up some space.
<b>Hard Limit</b> - When the hard limit is reached, regardless of the grace period, no further files or blocks can be allocated.

There are a number of commands to administer quotas -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Command &amp; Description</th></tr>
<tr><td>1</td><td><b>quota</b>
Displays disk usage and limits for a user of group</td></tr>
<tr><td>2</td><td><b>edquota</b>
This is a quota editor. 
Users or Groups quota can be edited using this command</td></tr>
<tr><td>3</td><td><b>quotacheck</b>
Scans a filesystem for disk usage, creates, checks and repairs quota files</td></tr>
<tr><td>4</td><td><b>setquota</b>
This is a command line quota editor</td></tr>
<tr><td>5</td><td><b>quotaon</b>
This announces to the system that disk quotas should be enabled on one or more filesystems</td></tr>
<tr><td>6</td><td><b>quotaoff</b>
This announces to the system that disk quotas should be disabled for one or more filesystems</td></tr>
<tr><td>7</td><td><b>repquota</b>
This prints a summary of the disc usage and quotas for the specified file systems</td></tr>
</table>
You can use <a href="/unix/unix-manpage-help.htm">Manpage Help</a> to check complete syntax for each command mentioned here.

<h2><span class="orange">Unix / Linux - User Administration</span></h2>
In this chapter, we will discuss in detail about user administration in Unix.
There are three types of accounts on a Unix system -
<h3>Root account</h3>
This is also called <b>superuser</b> and would have complete and unfettered control of the system. 
A superuser can run any commands without any restriction. 
This user should be assumed as a system administrator.
<h3>System accounts</h3>
System accounts are those needed for the operation of system-specific components for example mail accounts and the <b>sshd</b> accounts. 
These accounts are usually needed for some specific function on your system, and any modifications to them could adversely affect the system.
<h3>User accounts</h3>
User accounts provide interactive access to the system for users and groups of users. 
General users are typically assigned to these accounts and usually have limited access to critical system files and directories.
Unix supports a concept of <i>Group Account</i> which logically groups a number of accounts. 
Every account would be a part of another group account. 
A Unix group plays important role in handling file permissions and process management.
<h2>&emsp;Managing Users and Groups</h2>
There are four main user administration files -
<b>/etc/passwd</b> - Keeps the user account and password information. 
This file holds the majority of information about accounts on the Unix system.
<b>/etc/shadow</b> - Holds the encrypted password of the corresponding account. 
Not all the systems support this file.
<b>/etc/group</b> - This file contains the group information for each account.
<b>/etc/gshadow</b> - This file contains secure group account information.

Check all the above files using the <b>cat</b> command.
The following table lists out commands that are available on majority of Unix systems to create and manage accounts and groups -
<table class="table table-bordered">
<tr><th style="text-align:center;width:8%">Sr.No.</th><th>Command &amp; Description</th></tr>
<tr><td>1</td><td><b>useradd</b>
Adds accounts to the system</td></tr>
<tr><td>2</td><td><b>usermod</b>
Modifies account attributes</td></tr>
<tr><td>3</td><td><b>userdel</b>
Deletes accounts from the system</td></tr>
<tr><td>4</td><td><b>groupadd</b>
Adds groups to the system</td></tr>
<tr><td>5</td><td><b>groupmod</b>
Modifies group attributes</td></tr>
<tr><td>6</td><td><b>groupdel</b>
Removes groups from the system</td></tr>
</table>
You can use <a href="/unix/unix-manpage-help.htm">Manpage Help</a> to check complete syntax for each command mentioned here.
<h2>&emsp;Create a Group</h2>
We will now understand how to create a group. 
For this, we need to create groups before creating any account otherwise, we can make use of the existing groups in our system. 
We have all the groups listed in <b><i>/etc/groups</i></b> file.
All the default groups are system account specific groups and it is not recommended to use them for ordinary accounts. 
So, following is the syntax to create a new group account -
 groupadd [-g gid [-o]] [-r] [-f] groupname

The following table lists out the parameters -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Option &amp; Description</th></tr>
<tr><td>1</td><td><b>-g GID</b>
The numerical value of the group's ID</td></tr>
<tr><td>2</td><td><b>-o</b>
This option permits to add group with non-unique GID</td></tr>
<tr><td>3</td><td><b>-r</b>
This flag instructs <b>groupadd</b> to add a system account</td></tr>
<tr><td>4</td><td><b>-f </b>
This option causes to just exit with success status, if the specified group already exists. 
With -g, if the specified GID already exists, other (unique) GID is chosen</td></tr>
<tr><td>5</td><td><b>groupname</b>
Actual group name to be created</td></tr>
</table>
If you do not specify any parameter, then the system makes use of the default values.
Following example creates a <i>developers</i> group with default values, which is very much acceptable for most of the administrators.

$ groupadd developers

<h2>&emsp;Modify a Group</h2>
To modify a group, use the <b>groupmod</b> syntax -
$ groupmod -n new_modified_group_name old_group_name

To change the developers_2 group name to developer, type -
$ groupmod -n developer developer_2

Here is how you will change the financial GID to 545 -
$ groupmod -g 545 developer

<h2>&emsp;Delete a Group</h2>
We will now understand how to delete a group. 
To delete an existing group, all you need is the <b>groupdel command</b> and the <b>group name</b>. 
To delete the financial group, the command is -
$ groupdel developer

This removes only the group, not the files associated with that group. 
The files are still accessible by their owners.
<h2>&emsp;Create an Account</h2>
Let us see how to create a new account on your Unix system. 
Following is the syntax to create a user's account -
useradd -d homedir -g groupname -m -s shell -u userid accountname

The following table lists out the parameters -
<table class="table table-bordered">
<tr><th style="text-align:center;width:8%">Sr.No.</th><th>Option &amp; Description</th></tr>
<tr><td>1</td><td><b>-d homedir</b>
Specifies home directory for the account</td></tr>
<tr><td>2</td><td><b>-g groupname</b>
Specifies a group account for this account</td></tr>
<tr><td>3</td><td><b>-m</b>
Creates the home directory if it doesn't exist</td></tr>
<tr><td>4</td><td><b>-s shell</b>
Specifies the default shell for this account</td></tr>
<tr><td>5</td><td><b>-u userid</b>
You can specify a user id for this account</td></tr>
<tr><td>6</td><td><b>accountname</b>
Actual account name to be created</td></tr>
</table>
If you do not specify any parameter, then the system makes use of the default values. 
The <b>useradd</b> command modifies the <b>/etc/passwd</b>, <b>/etc/shadow</b>, and <b>/etc/group</b> files and creates a home directory.
Following is the example that creates an account <b><i>mcmohd</i></b>, setting its home directory to <b><i>/home/mcmohd</i></b> and the group as <b><i>developers</i></b>. 
This user would have Korn Shell assigned to it.

$ useradd -d /home/mcmohd -g developers -s /bin/ksh mcmohd

Before issuing the above command, make sure you already have the <i>developers</i> group created using the <b><i>groupadd</i></b> command.
Once an account is created you can set its password using the <b>passwd</b> command as follows -
$ passwd mcmohd20
Changing password for user mcmohd20.
New UNIX password:
Retype new UNIX password:
passwd: all authentication tokens updated successfully.

When you type <b><i>passwd accountname</i></b>, it gives you an option to change the password, provided you are a superuser. 
Otherwise, you can change just your password using the same command but without specifying your account name.
<h2>&emsp;Modify an Account</h2>
The <b>usermod</b> command enables you to make changes to an existing account from the command line. 
It uses the same arguments as the <b>useradd</b> command, plus the -l argument, which allows you to change the account name.
For example, to change the account name <b><i>mcmohd</i></b> to <b><i>mcmohd20</i></b> and to change home directory accordingly, you will need to issue the following command -
$ usermod -d /home/mcmohd20 -m -l mcmohd mcmohd20

<h2>&emsp;Delete an Account</h2>
The <b>userdel</b> command can be used to delete an existing user. 
This is a very dangerous command if not used with caution.
There is only one argument or option available for the command <b>.r</b>, for removing the account's home directory and mail file.
For example, to remove account <i>mcmohd20</i>, issue the following command -
$ userdel -r mcmohd20

If you want to keep the home directory for backup purposes, omit the <b>-r</b> option. 
You can remove the home directory as needed at a later time.

<h2><span class="orange">Unix / Linux - System Performance</span></h2>
In this chapter, we will discuss in detail about the system performance in Unix.
We will introduce you to a few free tools that are available to monitor and manage performance on Unix systems. 
These tools also provide guidelines on how to diagnose and fix performance problems in the Unix environment.
Unix has following major resource types that need to be monitored and tuned -
<b>CPU</b>
<b>Memory</b>
<b>Disk space</b>
<b>Communications lines</b>
<b>I/O Time</b>
<b>Network Time</b>
<b>Applications programs</b>

<h2>&emsp;Performance Components</h2>
The following table lists out five major components which take up the system time -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Component &amp; Description</th></tr>
<tr><td>1</td><td><b>User State CPU</b>
The actual amount of time the CPU spends running the users’ program in the user state. 
It includes the time spent executing library calls, but does not include the time spent in the kernel on its behalf</td></tr>
<tr><td>2</td><td><b>System State CPU </b>
This is the amount of time the CPU spends in the system state on behalf of this program. 
All <b>I/O routines</b> require kernel services. 
The programmer can affect this value by blocking I/O transfers</td></tr>
<tr><td>3</td><td><b>I/O Time and Network Time </b>
This is the amount of time spent moving data and servicing I/O requests</td></tr>
<tr><td>4</td><td><b>Virtual Memory Performance </b>
This includes context switching and swapping</td></tr>
<tr><td>5</td><td><b>Application Program</b>
Time spent running other programs - when the system is not servicing this application because another application currently has the CPU</td></tr>
</table>
<h2>&emsp;Performance Tools</h2>
Unix provides following important tools to measure and fine tune Unix system performance -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Command &amp; Description</th></tr>
<tr><td>1</td><td><b>nice/renice</b>
Runs a program with modified scheduling priority</td></tr>
<tr><td>2</td><td><b>netstat</b>
Prints network connections, routing tables, interface statistics, masquerade connections, and multicast memberships</td></tr>
<tr><td>3</td><td><b>time</b>
Helps time a simple command or give resource usage</td></tr>
<tr><td>4</td><td><b>uptime</b>
This is System Load Average</td></tr>
<tr><td>5</td><td><b>ps</b>
Reports a snapshot of the current processes</td></tr>
<tr><td>6</td><td><b>vmstat</b>
Reports virtual memory statistics</td></tr>
<tr><td>7</td><td><b>gprof</b>
Displays call graph profile data</td></tr>
<tr><td>8</td><td><b>prof</b>
Facilitates Process Profiling</td></tr>
<tr><td>9</td><td><b>top</b>
Displays system tasks</td></tr>
</table>
You can use <a href="/unix/unix-manpage-help.htm">Manpage Help</a> to check complete syntax for each command mentioned here.

<h2><span class="orange">Unix / Linux - System Logging</span></h2>
In this chapter, we will discuss in detail about system logging in Unix.
Unix systems have a very flexible and powerful logging system, which enables you to record almost anything you can imagine and then manipulate the logs to retrieve the information you require.
Many versions of Unix provide a general-purpose logging facility called <b>syslog</b>. 
Individual programs that need to have information logged, send the information to syslog.
Unix <i>syslog</i> is a host-configurable, uniform system logging facility. 
The system uses a centralized system logging process that runs the program <b>/etc/syslogd</b> or <b>/etc/syslog</b>.
The operation of the system logger is quite straightforward. 
Programs send their log entries to <i>syslogd</i>, which consults the configuration file <b>/etc/syslogd.conf</b> or <b>/etc/syslog</b> and, when a match is found, writes the log message to the desired log file.
There are four basic syslog terms that you should understand -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Term &amp; Description</th></tr>
<tr><td>1</td><td><b>Facility</b>
The identifier used to describe the application or process that submitted the log message. 
For example, mail, kernel, and ftp.</td></tr>
<tr><td>2</td><td><b>Priority</b>
An indicator of the importance of the message. 
Levels are defined within syslog as guidelines, from debugging information to critical events.</td></tr>
<tr><td>3</td><td><b>Selector</b>
A combination of one or more facilities and levels. 
When an incoming event matches a selector, an action is performed.</td></tr>
<tr><td>4</td><td><b>Action</b>
What happens to an incoming message that matches a selector — Actions can write the message to a log file, echo the message to a console or other device, write the message to a logged in user, or send the message along to another syslog server.</td></tr>
</table>
<h2>&emsp;Syslog Facilities</h2>
We will now understand about the syslog facilities. 
Here are the available facilities for the selector. 
Not all facilities are present on all versions of Unix.
<table class="table table-bordered">
<tr><th>Facility</th><th>Description</th></tr>
<tr><td>1</td><td><b>auth</b>
Activity related to requesting name and password (getty, su, login)</td></tr>
<tr><td>2</td><td><b>authpriv</b>
Same as auth but logged to a file that can only be read by selected users</td></tr>
<tr><td>3</td><td><b>console</b>
Used to capture messages that are generally directed to the system console</td></tr>
<tr><td>4</td><td><b>cron</b>
Messages from the cron system scheduler</td></tr>
<tr><td>5</td><td><b>daemon</b>
System daemon catch-all</td></tr>
<tr><td>6</td><td><b>ftp</b>
Messages relating to the ftp daemon</td></tr>
<tr><td>7</td><td><b>kern</b>
Kernel messages</td></tr>
<tr><td>8</td><td><b>local0.local7</b>
Local facilities defined per site</td></tr>
<tr><td>9</td><td><b>lpr</b>
Messages from the line printing system</td></tr>
<tr><td>10</td><td><b>mail</b>
Messages relating to the mail system</td></tr>
<tr><td>11</td><td><b>mark</b>
Pseudo-event used to generate timestamps in log files</td></tr>
<tr><td>12</td><td><b>news</b>
Messages relating to network news protocol (nntp)</td></tr>
<tr><td>13</td><td><b>ntp</b>
Messages relating to network time protocol</td></tr>
<tr><td>14</td><td><b>user</b>
Regular user processes</td></tr>
<tr><td>15</td><td><b>uucp</b>
UUCP subsystem</td></tr>
</table>
<h2>&emsp;Syslog Priorities</h2>
The syslog priorities are summarized in the following table -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Priority &amp; Description</th></tr>
<tr><td>1</td><td><b>emerg</b>
Emergency condition, such as an imminent system crash, usually broadcast to all users</td></tr>
<tr><td>2</td><td><b>alert</b>
Condition that should be corrected immediately, such as a corrupted system database</td></tr>
<tr><td>3</td><td><b>crit</b>
Critical condition, such as a hardware error</td></tr>
<tr><td>4</td><td><b>err</b>
Ordinary error</td></tr>
<tr><td>5</td><td><b>Warning</b>
Warning</td></tr>
<tr><td>6</td><td><b>notice</b>
Condition that is not an error, but possibly should be handled in a special way</td></tr>
<tr><td>7</td><td><b>info</b>
Informational message</td></tr>
<tr><td>8</td><td><b>debug</b>
Messages that are used when debugging programs</td></tr>
<tr><td>9</td><td><b>none</b>
Pseudo level used to specify not to log messages</td></tr>
</table>
The combination of facilities and levels enables you to be discerning about what is logged and where that information goes.
As each program sends its messages dutifully to the system logger, the logger makes decisions on what to keep track of and what to discard based on the levels defined in the selector.
When you specify a level, the system will keep track of everything at that level and higher.
<h2>&emsp;The /etc/syslog.conf file</h2>
The <b>/etc/syslog.conf</b> file controls where messages are logged. 
A typical <b>syslog.conf</b> file might look like this -
*.err;kern.debug;auth.notice /dev/console
daemon,auth.notice           /var/log/messages
lpr.info                     /var/log/lpr.log
mail.*                       /var/log/mail.log
ftp.*                        /var/log/ftp.log
auth.*                       @prep.ai.mit.edu
auth.*                       root,amrood
netinfo.err                  /var/log/netinfo.log
install.*                    /var/log/install.log
*.emerg                      *
*.alert                      |program_name
mark.*                       /dev/console

Each line of the file contains two parts -
A <b>message selector</b> that specifies which kind of messages to log. 
For example, all error messages or all debugging messages from the kernel.
An <b>action field</b> that says what should be done with the message. 
For example, put it in a file or send the message to a user's terminal.

Following are the notable points for the above configuration -
Message selectors have two parts: <b>a facility</b> and <b>a priority</b>. 
For example, <i>kern.debug</i> selects all debug messages (the priority) generated by the kernel (the facility).
Message selector <i>kern.debug</i> selects all priorities that are greater than debug.
An asterisk in place of either the facility or the priority indicates "all". 
For example, <b>*.debug</b> means all debug messages, while <b>kern.*</b> means all messages generated by the kernel.
You can also use commas to specify multiple facilities. 
Two or more selectors can be grouped together by using a semicolon.

<h2>&emsp;Logging Actions</h2>
The action field specifies one of five actions -
Log message to a file or a device. 
For example, <b>/var/log/lpr.log</b> or <b>/dev/console</b>.
Send a message to a user. 
You can specify multiple usernames by separating them with commas; for example, root, amrood.
Send a message to all users. 
In this case, the action field consists of an asterisk; for example, *.
Pipe the message to a program. 
In this case, the program is specified after the Unix pipe symbol (|).
Send the message to the syslog on another host. 
In this case, the action field consists of a hostname, preceded by an at sign; for example, @tutorialspoint.com.

<h2>&emsp;The logger Command</h2>
Unix provides the <b>logger</b> command, which is an extremely useful command to deal with system logging. 
The <b>logger</b> command sends logging messages to the syslogd daemon, and consequently provokes system logging.
This means we can check from the command line at any time the <b>syslogd</b> daemon and its configuration. 
The logger command provides a method for adding one-line entries to the system log file from the command line.
The format of the command is -
logger [-i] [-f file] [-p priority] [-t tag] [message]...

Here is the detail of the parameters -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Option &amp; Description</th></tr>
<tr><td>1</td><td><b>-f filename</b>
Uses the contents of file filename as the message to log.</td></tr>
<tr><td>2</td><td><b>-i</b>
Logs the process ID of the logger process with each line.</td></tr>
<tr><td>3</td><td><b>-p priority</b>
Enters the message with the specified priority (specified selector entry); the message priority can be specified numerically, or as a facility.priority pair. 
The default priority is user.notice.</td></tr>
<tr><td>4</td><td><b>-t tag</b>
Marks each line added to the log with the specified tag.</td></tr>
<tr><td>5</td><td><b>message</b>
The string arguments whose contents are concatenated together in the specified order, separated by the space.</td></tr>
</table>
You can use <a href="/unix/unix-manpage-help.htm">Manpage Help</a> to check complete syntax for this command.
<h2>&emsp;Log Rotation</h2>
Log files have the propensity to grow very fast and consume large amounts of disk space. 
To enable log rotations, most distributions use tools such as <b><i>newsyslog</i></b> or <b><i>logrotate</i></b>.
These tools should be called on a frequent time interval using the <b>cron daemon</b>. 
Check the man pages for <i>newsyslog</i> or <i>logrotate</i> for more details.
<h2>&emsp;Important Log Locations</h2>
All the system applications create their log files in <b><i>/var/log</i></b> and its sub-directories. 
Here are few important applications and their corresponding log directories -
<table class="table table-bordered">
<tr><th>Application</th><th>Directory</th></tr>
<tr><td>httpd</td><td>/var/log/httpd</td></tr>
<tr><td>samba</td><td>/var/log/samba</td></tr>
<tr><td>cron</td><td>/var/log/</td></tr>
<tr><td>mail</td><td>/var/log/</td></tr>
<tr><td>mysql</td><td>/var/log/</td></tr>
</table>


<h2><span class="orange">Unix / Linux - Signals and Traps</span></h2>
In this chapter, we will discuss in detail about Signals and Traps in Unix.
Signals are software interrupts sent to a program to indicate that an important event has occurred. 
The events can vary from user requests to illegal memory access errors. 
Some signals, such as the interrupt signal, indicate that a user has asked the program to do something that is not in the usual flow of control.
The following table lists out common signals you might encounter and want to use in your programs -
<table class="table table-bordered">
<tr><th style="text-align:center;vertical-align:middle;width:20%">Signal Name</th>
<th style="text-align:center;width:10%">Signal Number</th>
<th style="text-align:center;vertical-align:middle;width:70%">Description</th></tr>
<tr><td style="text-align:center;vertical-align:middle;">SIGHUP</td>
<td style="text-align:center;vertical-align:middle;">1</td><td>Hang up detected on controlling terminal or death of controlling process</td></tr>
<tr><td>SIGINT</td><td>2</td><td>Issued if the user sends an interrupt signal (Ctrl + C)</td></tr>
<tr><td>SIGQUIT</td><td>3</td><td>Issued if the user sends a quit signal (Ctrl + D)</td></tr>
<tr><td style="text-align:center;vertical-align:middle;">SIGFPE</td>
<td style="text-align:center;vertical-align:middle;">8</td><td>Issued if an illegal mathematical operation is attempted</td></tr>
<tr><td style="text-align:center;vertical-align:middle;">SIGKILL</td>
<td style="text-align:center;vertical-align:middle;">9</td><td>If a process gets this signal it must quit immediately and will not perform any clean-up operations</td></tr>
<tr><td>SIGALRM</td><td>14</td><td>Alarm clock signal (used for timers)</td></tr>
<tr><td>SIGTERM</td><td>15</td><td>Software termination signal (sent by kill by default)</td></tr>
</table>
<h2>&emsp;List of Signals</h2>
There is an easy way to list down all the signals supported by your system. 
Just issue the <b>kill -l</b> command and it would display all the supported signals -
$ kill -l
 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL
 5) SIGTRAP      6) SIGABRT      7) SIGBUS       8) SIGFPE
 9) SIGKILL     10) SIGUSR1     11) SIGSEGV     12) SIGUSR2
13) SIGPIPE     14) SIGALRM     15) SIGTERM     16) SIGSTKFLT
17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU
25) SIGXFSZ     26) SIGVTALRM   27) SIGPROF     28) SIGWINCH
29) SIGIO       30) SIGPWR      31) SIGSYS      34) SIGRTMIN
35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3  38) SIGRTMIN+4
39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12
47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14
51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10
55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7  58) SIGRTMAX-6
59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX

The actual list of signals varies between Solaris, HP-UX, and Linux.
<h2>&emsp;Default Actions</h2>
Every signal has a default action associated with it. 
The default action for a signal is the action that a script or program performs when it receives a signal.
Some of the possible default actions are -
Terminate the process.
Ignore the signal.
Dump core. 
This creates a file called <b>core</b> containing the memory image of the process when it received the signal.
Stop the process.
Continue a stopped process.

<h2>&emsp;Sending Signals</h2>
There are several methods of delivering signals to a program or script. 
One of the most common is for a user to type <b>CONTROL-C</b> or the <b>INTERRUPT key</b> while a script is executing.
When you press the <b><i>Ctrl+C</i></b> key, a <b>SIGINT</b> is sent to the script and as per defined default action script terminates.
The other common method for delivering signals is to use the <b>kill command</b>, the syntax of which is as follows -
$ kill -signal pid

Here <b>signal</b> is either the number or name of the signal to deliver and <b>pid</b> is the process ID that the signal should be sent to. 
For Example -
$ kill -1 1001

The above command sends the HUP or hang-up signal to the program that is running with <b>process ID 1001</b>. 
To send a kill signal to the same process, use the following command -
$ kill -9 1001

This kills the process running with <b>process ID 1001</b>.
<h2>&emsp;Trapping Signals</h2>
When you press the <i>Ctrl+C</i> or Break key at your terminal during execution of a shell program, normally that program is immediately terminated, and your command prompt returns. 
This may not always be desirable. 
For instance, you may end up leaving a bunch of temporary files that won't get cleaned up.
Trapping these signals is quite easy, and the trap command has the following syntax -
$ trap commands signals

Here <i>command</i> can be any valid Unix command, or even a user-defined function, and signal can be a list of any number of signals you want to trap.
There are two common uses for trap in shell scripts -
Clean up temporary files
Ignore signals

<h2>&emsp;Cleaning Up Temporary Files</h2>
As an example of the trap command, the following shows how you can remove some files and then exit if someone tries to abort the program from the terminal -
$ trap "rm -f $WORKDIR/work1$$ $WORKDIR/dataout$$; exit" 2

From the point in the shell program that this trap is executed, the two files <b><i>work1$$</i></b> and <b><i>dataout$$</i></b> will be automatically removed if signal number 2 is received by the program.
Hence, if the user interrupts the execution of the program after this trap is executed, you can be assured that these two files will be cleaned up. 
The <b>exit</b> command that follows the <b>rm</b> is necessary because without it, the execution would continue in the program at the point that it left off when the signal was received.
Signal number 1 is generated for <b>hangup</b>. 
Either someone intentionally hangs up the line or the line gets accidentally disconnected.
You can modify the preceding trap to also remove the two specified files in this case by adding signal number 1 to the list of signals -
$ trap "rm $WORKDIR/work1$$ $WORKDIR/dataout$$; exit" 1 2

Now these files will be removed if the line gets hung up or if the <i>Ctrl+C</i> key gets pressed.
The commands specified to trap must be enclosed in quotes, if they contain more than one command. 
Also note that the shell scans the command line at the time that the trap command gets executed and also when one of the listed signals is received.
Thus, in the preceding example, the value of <b>WORKDIR</b> and <b>$$</b> will be substituted at the time that the trap command is executed. 
If you wanted this substitution to occur at the time that either signal 1 or 2 was received, you can put the commands inside single quotes -
$ trap 'rm $WORKDIR/work1$$ $WORKDIR/dataout$$; exit' 1 2

<h2>&emsp;Ignoring Signals</h2>
If the command listed for trap is null, the specified signal will be ignored when received. 
For example, the command -
$ trap '' 2

This specifies that the interrupt signal is to be ignored. 
You might want to ignore certain signals when performing an operation that you don't want to be interrupted. 
You can specify multiple signals to be ignored as follows -
$ trap '' 1 2 3 15

Note that the first argument must be specified for a signal to be ignored and is not equivalent to writing the following, which has a separate meaning of its own -
$ trap  2

If you ignore a signal, all subshells also ignore that signal. 
However, if you specify an action to be taken on the receipt of a signal, all subshells will still take the default action on receipt of that signal.
<h2>&emsp;Resetting Traps</h2>
After you've changed the default action to be taken on receipt of a signal, you can change it back again with the trap if you simply omit the first argument; so -
$ trap 1 2

This resets the action to be taken on the receipt of signals 1 or 2 back to the default.

<h2><span class="orange">Unix / Linux Questions and Answers</span></h2>
<b>Unix Questions and Answers</b> has been designed with a special intention of helping students and professionals preparing for various <b>Certification Exams</b> and <b>Job Interviews</b>. 
This section provides a useful collection of sample Interview Questions and  Multiple Choice Questions (MCQs) and their answers with appropriate explanations.
<img src="https://www.tutorialspoint.com/images/questions_and_answers.png" alt="Questions and Answers"><table class="table table-bordered">
<tr><th>Sr.No.</th><th>Question/Answers Type</th></tr>
<tr><td>1</td><td><a href="/unix/unix_interview_questions.htm" title="Unix Interview Questions">Unix Interview Questions</a>
This section provides a huge collection of Unix Interview Questions with their answers hidden in a box to challenge you to have a go at them before discovering the correct answer.</td></tr>
<tr><td>2</td><td><a href="/unix/unix_online_quiz.htm" title="Unix Online Quiz">Unix Online Quiz</a>
This section provides a great collection of Unix Multiple Choice Questions (MCQs) on a single page along with their correct answers and explanation. 
If you select the right option, it turns green; else red.</td></tr>
<tr><td>3</td><td><a href="/unix/unix_online_test.htm" title="Unix Online Test">Unix Online Test</a>
If you are preparing to appear for a Java and Unix Framework related certification exam, then this section is a must for you. 
This section simulates a real online test along with a given timer which challenges you to complete the test within a given time-frame. 
Finally you can check your overall test score and how you fared among millions of other candidates who attended this online test.</td></tr>
<tr><td>4</td><td><a href="/unix/unix_mock_test.htm" title="Unix Mock Test">Unix Mock Test</a>
This section provides various mock tests that you can download at your local machine and solve offline. 
Every mock test is supplied with a mock test key to let you verify the final score and grade yourself.</td></tr>
</table>


<h2><span class="orange">Unix / Linux - Useful Commands</span></h2>
This quick guide lists commands, including a syntax and a brief description. 
For more detail, use -
$man command

<h2>&emsp;Files and Directories</h2>
These commands allow you to create directories and handle files.
<section class="toggle"><label>Given below is the list of commands in Files and Directories.</label>
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Command &amp; Description</th></tr>
<tr><td>1</td><td><b>cat</b>
Displays File Contents</td></tr>
<tr><td>2</td><td><b>cd</b>
Changes Directory to dirname</td></tr>
<tr><td>3</td><td><b>chgrp</b>
Changes file group</td></tr>
<tr><td>4</td><td><b>chmod</b>
Changes permissions</td></tr>
<tr><td>5</td><td><b>cp</b>
Copies source file into destination</td></tr>
<tr><td>6</td><td><b>file</b>
Determines file type</td></tr>
<tr><td>7</td><td><b>find</b>
Finds files</td></tr>
<tr><td>8</td><td><b>grep</b>
Searches files for regular expressions</td></tr>
<tr><td>9</td><td><b>head</b>
Displays first few lines of a file</td></tr>
<tr><td>10</td><td><b>ln</b>
Creates softlink on oldname</td></tr>
<tr><td>11</td><td><b>ls</b>
Displays information about file type</td></tr>
<tr><td>12</td><td><b>mkdir</b>
Creates a new directory dirname</td></tr>
<tr><td>13</td><td><b>more</b>
Displays data in paginated form</td></tr>
<tr><td>14</td><td><b>mv</b>
Moves (Renames) an oldname to newname</td></tr>
<tr><td>15</td><td><b>pwd</b>
Prints current working directory</td></tr>
<tr><td>16</td><td><b>rm</b>
Removes (Deletes) filename</td></tr>
<tr><td>17</td><td><b>rmdir</b>
Deletes an existing directory provided it is empty</td></tr>
<tr><td>18</td><td><b>tail</b>
Prints last few lines in a file</td></tr>
<tr><td>19</td><td><b>touch</b>
Updates access and modification time of a file</td></tr>
</table>
</section><h2>&emsp;Manipulating data</h2>
The contents of files can be compared and altered with the following commands.
<section class="toggle"><label>Given below is the list of commands in Manipulating data.</label>
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Command &amp; Description</th></tr>
<tr><td>1</td><td><b>awk</b>
Pattern scanning and processing language</td></tr>
<tr><td>2</td><td><b>cmp</b>
Compares the contents of two files</td></tr>
<tr><td>3</td><td><b>comm</b>
Compares sorted data</td></tr>
<tr><td>4</td><td><b>cut</b>
Cuts out selected fields of each line of a file</td></tr>
<tr><td>5</td><td><b>diff</b>
Differential file comparator</td></tr>
<tr><td>6</td><td><b>expand</b>
Expands tabs to spaces</td></tr>
<tr><td>7</td><td><b>join</b>
Joins files on some common field</td></tr>
<tr><td>8</td><td><b>perl</b>
Data manipulation language</td></tr>
<tr><td>9</td><td><b>sed</b>
Stream text editor</td></tr>
<tr><td>10</td><td><b>sort</b>
Sorts file data</td></tr>
<tr><td>11</td><td><b>split</b>
Splits file into smaller files</td></tr>
<tr><td>12</td><td><b>tr</b>
Translates characters</td></tr>
<tr><td>13</td><td><b>uniq</b>
Reports repeated lines in a file</td></tr>
<tr><td>14</td><td><b>wc</b>
Counts words, lines, and characters</td></tr>
<tr><td>15</td><td><b>vi</b>
Opens vi text editor</td></tr>
<tr><td>16</td><td><b>vim</b>
Opens vim text editor</td></tr>
<tr><td>17</td><td><b>fmt</b>
Simple text formatter</td></tr>
<tr><td>18</td><td><b>spell</b>
Checks text for spelling error</td></tr>
<tr><td>19</td><td><b>ispell</b>
Checks text for spelling error</td></tr>
<tr><td>20</td><td><b>emacs</b>
GNU project Emacs</td></tr>
<tr><td>21</td><td><b>ex, edit</b>
Line editor</td></tr>
<tr><td>22</td><td><b>emacs</b>
GNU project Emacs</td></tr>
</table>
</section><h2>&emsp;Compressed Files</h2>
Files may be compressed to save space. 
Compressed files can be created and examined.
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Command &amp; Description</th></tr>
<tr><td>1</td><td><b>compress</b>
Compresses files</td></tr>
<tr><td>2</td><td><b>gunzip</b>
Helps uncompress gzipped files</td></tr>
<tr><td>3</td><td><b>gzip</b>
GNU alternative compression method</td></tr>
<tr><td>4</td><td><b>uncompress</b>
Helps uncompress files</td></tr>
<tr><td>5</td><td><b>unzip</b>
List, test and extract compressed files in a ZIP archive</td></tr>
<tr><td>6</td><td><b>zcat</b>
Cat a compressed file</td></tr>
<tr><td>7</td><td><b>zcmp</b>
Compares compressed files</td></tr>
<tr><td>8</td><td><b>zdiff</b>
Compares compressed files</td></tr>
<tr><td>9</td><td><b>zmore</b>
File perusal filter for crt viewing of compressed text</td></tr>
</table>
<h2>&emsp;Getting Information</h2>
Various Unix manuals and documentation are available on-line. 
The following Shell commands give information -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Command &amp; Description</th></tr>
<tr><td>1</td><td><b>apropos</b>
Locates commands by keyword lookup</td></tr>
<tr><td>2</td><td><b>info</b>
Displays command information pages online</td></tr>
<tr><td>2</td><td><b>man</b>
Displays manual pages online</td></tr>
<tr><td>3</td><td><b>whatis</b>
Searches the whatis database for complete words</td></tr>
<tr><td>4</td><td><b>yelp</b>
GNOME help viewer</td></tr>
</table>
<h2>&emsp;Network Communication</h2>
These following commands are used to send and receive files from a local Unix hosts to the remote host around the world.
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Command &amp; Description</th></tr>
<tr><td>1</td><td><b>ftp</b>
File transfer program</td></tr>
<tr><td>2</td><td><b>rcp</b>
Remote file copy</td></tr>
<tr><td>3</td><td><b>rlogin</b>
Remote login to a Unix host</td></tr>
<tr><td>4</td><td><b>rsh</b>
Remote shell</td></tr>
<tr><td>5</td><td><b>tftp</b>
Trivial file transfer program</td></tr>
<tr><td>6</td><td><b>telnet</b>
Makes terminal connection to another host</td></tr>
<tr><td>7</td><td><b>ssh</b>
Secures shell terminal or command connection</td></tr>
<tr><td>8</td><td><b>scp</b>
Secures shell remote file copy</td></tr>
<tr><td>9</td><td><b>sftp</b>
Secures shell file transfer program</td></tr>
</table>
Some of these commands may be restricted at your computer for security reasons.
<h2>&emsp;Messages between Users</h2>
The Unix systems support on-screen messages to other users and world-wide electronic mail -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Command &amp; Description</th></tr>
<tr><td>1</td><td><b>evolution</b>
GUI mail handling tool on Linux</td></tr>
<tr><td>2</td><td><b>mail</b>
Simple send or read mail program</td></tr>
<tr><td>3</td><td><b>mesg</b>
Permits or denies messages</td></tr>
<tr><td>4</td><td><b>parcel</b>
Sends files to another user</td></tr>
<tr><td>5</td><td><b>pine</b>
Vdu-based mail utility</td></tr>
<tr><td>6</td><td><b>talk</b>
Talks to another user</td></tr>
<tr><td>7</td><td><b>write</b>
Writes message to another user</td></tr>
</table>
<h2>&emsp;Programming Utilities</h2>
The following programming tools and languages are available based on what you have installed on your Unix.
<section class="toggle"><label>Given below is the list of tools and languages in Programming Utilities.</label>
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Command &amp; Description</th></tr>
<tr><td>1</td><td><b>dbx</b>
Sun debugger</td></tr>
<tr><td>2</td><td><b>gdb</b>
GNU debugger</td></tr>
<tr><td>3</td><td><b>make</b>
Maintains program groups and compile programs</td></tr>
<tr><td>4</td><td><b>nm</b>
Prints program's name list</td></tr>
<tr><td>5</td><td><b>size</b>
Prints program's sizes</td></tr>
<tr><td>6</td><td><b>strip</b>
Removes symbol table and relocation bits</td></tr>
<tr><td>7</td><td><b>cb</b>
C program beautifier</td></tr>
<tr><td>8</td><td><b>cc</b>
ANSI C compiler for Suns SPARC systems</td></tr>
<tr><td>9</td><td><b>ctrace</b>
C program debugger</td></tr>
<tr><td>10</td><td><b>gcc</b>
GNU ANSI C Compiler</td></tr>
<tr><td>11</td><td><b>indent</b>
Indent and format C program source</td></tr>
<tr><td>12</td><td><b>bc</b>
Interactive arithmetic language processor</td></tr>
<tr><td>13</td><td><b>gcl</b>
GNU Common Lisp</td></tr>
<tr><td>14</td><td><b>perl</b>
General purpose language</td></tr>
<tr><td>15</td><td><b>php</b>
Web page embedded language</td></tr>
<tr><td>16</td><td><b>py</b>
Python language interpreter</td></tr>
<tr><td>17</td><td><b>asp</b>
Web page embedded language</td></tr>
<tr><td>18</td><td><b>CC</b>
C++ compiler for Suns SPARC systems</td></tr>
<tr><td>19</td><td><b>g++</b>
GNU C++ Compiler</td></tr>
<tr><td>20</td><td><b>javac</b>
JAVA compiler</td></tr>
<tr><td>21</td><td><b>appletvieweir</b>
JAVA applet viewer</td></tr>
<tr><td>22</td><td><b>netbeans</b>
Java integrated development environment on Linux</td></tr>
<tr><td>23</td><td><b>sqlplus</b>
Runs the Oracle SQL interpreter</td></tr>
<tr><td>24</td><td><b>sqlldr</b>
Runs the Oracle SQL data loader</td></tr>
<tr><td>25</td><td><b>mysql</b>
Runs the mysql SQL interpreter</td></tr>
</table>
</section><h2>&emsp;Misc Commands</h2>
These commands list or alter information about the system -
<section class="toggle"><label>Given below is the list of Misc Commands in Unix.</label>
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Command &amp; Description</th></tr>
<tr><td>1</td><td><b>chfn</b>
Changes your finger information</td></tr>
<tr><td>2</td><td><b>chgrp</b>
Changes the group ownership of a file</td></tr>
<tr><td>3</td><td><b>chown</b>
Changes owner</td></tr>
<tr><td>4</td><td><b>date</b>
Prints the date</td></tr>
<tr><td>5</td><td><b>determin</b>
Automatically finds terminal type</td></tr>
<tr><td>6</td><td><b>du</b>
Prints amount of disk usage</td></tr>
<tr><td>7</td><td><b>echo</b>
Echo arguments to the standard options</td></tr>
<tr><td>8</td><td><b>exit</b>
Quits the system</td></tr>
<tr><td>9</td><td><b>finger</b>
Prints information about logged-in users</td></tr>
<tr><td>10</td><td><b>groupadd</b>
Creates a user group</td></tr>
<tr><td>11</td><td><b>groups</b>
Show group memberships</td></tr>
<tr><td>12</td><td><b>homequota</b>
Shows quota and file usage</td></tr>
<tr><td>13</td><td><b>iostat</b>
Reports I/O statistics</td></tr>
<tr><td>14</td><td><b>kill</b>
Sends a signal to a process</td></tr>
<tr><td>15</td><td><b>last</b>
Shows last logins of users</td></tr>
<tr><td>16</td><td><b>logout</b>
Logs off Unix</td></tr>
<tr><td>17</td><td><b>lun</b>
Lists user names or login ID</td></tr>
<tr><td>18</td><td><b>netstat</b>
Shows network status</td></tr>
<tr><td>19</td><td><b>passwd</b>
Changes user password</td></tr>
<tr><td>20</td><td><b>passwd</b>
Changes your login password</td></tr>
<tr><td>21</td><td><b>printenv</b>
Displays value of a shell variable</td></tr>
<tr><td>22</td><td><b>ps</b>
Displays the status of current processes</td></tr>
<tr><td>23</td><td><b>ps</b>
Prints process status statistics</td></tr>
<tr><td>24</td><td><b>quota -v</b>
Displays disk usage and limits</td></tr>
<tr><td>25</td><td><b>reset</b>
Resets terminal mode</td></tr>
<tr><td>26</td><td><b>script</b>
Keeps script of terminal session</td></tr>
<tr><td>27</td><td><b>script</b>
Saves the output of a command or process</td></tr>
<tr><td>28</td><td><b>setenv</b>
Sets environment variables</td></tr>
<tr><td>30</td><td><b>stty</b>
Sets terminal options</td></tr>
<tr><td>31</td><td><b>time</b>
Helps time a command</td></tr>
<tr><td>32</td><td><b>top</b>
Displays all system processes</td></tr>
<tr><td>33</td><td><b>tset</b>
Sets terminal mode</td></tr>
<tr><td>34</td><td><b>tty</b>
Prints current terminal name</td></tr>
<tr><td>35</td><td><b>umask</b>
Show the permissions that are given to view files by default</td></tr>
<tr><td>36</td><td><b>uname</b>
Displays name of the current system</td></tr>
<tr><td>37</td><td><b>uptime</b>
Gets the system up time</td></tr>
<tr><td>38</td><td><b>useradd</b>
Creates a user account</td></tr>
<tr><td>39</td><td><b>users</b>
Prints names of logged in users</td></tr>
<tr><td>40</td><td><b>vmstat</b>
Reports virtual memory statistics</td></tr>
<tr><td>41</td><td><b>w</b>
Shows what logged in users are doing</td></tr>
<tr><td>42</td><td><b>who</b>
Lists logged in users</td></tr>
</table>
</section>


<h2><span class="orange">Unix / Linux - Quick Guide</span></h2>
<h2><span class="orange">Unix - Getting Started</span></h2>
<h2>&emsp;What is Unix ?</h2>
The Unix operating system is a set of programs that act as a link between the computer and the user.
The computer programs that allocate the system resources and coordinate all the details of the computer's internals is called the <b>operating system</b> or the <b>kernel</b>.
Users communicate with the kernel through a program known as the <b>shell</b>. 
The shell is a command line interpreter; it translates commands entered by the user and converts them into a language that is understood by the kernel.
Unix was originally developed in 1969 by a group of AT&amp;T employees Ken Thompson, Dennis Ritchie, Douglas McIlroy, and Joe Ossanna at Bell Labs.
There are various Unix variants available in the market. 
Solaris Unix, AIX, HP Unix and BSD are a few examples. 
Linux is also a flavor of Unix which is freely available.
Several people can use a Unix computer at the same time; hence Unix is called a multiuser system.
A user can also run multiple programs at the same time; hence Unix is a multitasking environment.

<h2>&emsp;Unix Architecture</h2>
Here is a basic block diagram of a Unix system -
<img src="https://www.tutorialspoint.com/unix/images/unix_architecture.jpg" alt="Unix Architecture">The main concept that unites all the versions of Unix is the following four basics -
<b>Kernel</b> - The kernel is the heart of the operating system. 
It interacts with the hardware and most of the tasks like memory management, task scheduling and file management.
<b>Shell</b> - The shell is the utility that processes your requests. 
When you type in a command at your terminal, the shell interprets the command and calls the program that you want. 
The shell uses standard syntax for all commands. 
C Shell, Bourne Shell and Korn Shell are the most famous shells which are available with most of the Unix variants.
<b>Commands and Utilities</b> - There are various commands and utilities which you can make use of in your day to day activities. 
<b>cp</b>, <b>mv</b>, <b>cat</b> and <b>grep</b>, etc. 
are few examples of commands and utilities. 
There are over 250 standard commands plus numerous others provided through 3<sup>rd</sup> party software. 
All the commands come along with various options.
<b>Files and Directories</b> - All the data of Unix is organized into files. 
All files are then organized into directories. 
These directories are further organized into a tree-like structure called the <b>filesystem</b>.

<h3>System Bootup</h3>
If you have a computer which has the Unix operating system installed in it, then you simply need to turn on the system to make it live.
As soon as you turn on the system, it starts booting up and finally it prompts you to log into the system, which is an activity to log into the system and use it for your day-to-day activities.
<h3>Login Unix</h3>
When you first connect to a Unix system, you usually see a prompt such as the following -
login:

<h3>To log in</h3>
Have your userid (user identification) and password ready. 
Contact your system administrator if you don't have these yet.
Type your userid at the login prompt, then press <b>ENTER</b>. 
Your userid is <b>case-sensitive</b>, so be sure you type it exactly as your system administrator has instructed.
Type your password at the password prompt, then press <b>ENTER</b>. 
Your password is also case-sensitive.
If you provide the correct userid and password, then you will be allowed to enter into the system. 
Read the information and messages that comes up on the screen, which is as follows.

login : amrood
amrood's password:
Last login: Sun Jun 14 09:32:32 2009 from 62.61.164.73
$

You will be provided with a command prompt (sometime called the <b>$</b> prompt ) where you type all your commands. 
For example, to check calendar, you need to type the <b>cal</b> command as follows -
$ cal
     June 2009
Su Mo Tu We Th Fr Sa
    1  2  3  4  5  6
 7  8  9 10 11 12 13
14 15 16 17 18 19 20
21 22 23 24 25 26 27
28 29 30
$

<h3>Change Password</h3>
All Unix systems require passwords to help ensure that your files and data remain your own and that the system itself is secure from hackers and crackers. 
Following are the steps to change your password -
<b>Step 1</b> - To start, type password at the command prompt as shown below.
<b>Step 2</b> - Enter your old password, the one you're currently using.
<b>Step 3</b> - Type in your new password. 
Always keep your password complex enough so that nobody can guess it. 
But make sure, you remember it.
<b>Step 4</b> - You must verify the password by typing it again.

$ passwd
Changing password for amrood
(current) Unix password:******
New UNIX password:*******
Retype new UNIX password:*******
passwd: all authentication tokens updated  successfully
$

<b>Note</b> - We have added asterisk (*) here just to show the location where you need to enter the current and new passwords otherwise at your system. 
It does not show you any character when you type.
<h3>Listing Directories and Files</h3>
All data in Unix is organized into files. 
All files are organized into directories. 
These directories are organized into a tree-like structure called the filesystem.
You can use the <b>ls</b> command to list out all the files or directories available in a directory. 
Following is the example of using <b>ls</b> command with <b>-l</b> option.

$ ls -l
total 19621
drwxrwxr-x  2 amrood amrood      4096 Dec 25 09:59 uml
-rw-rw-r--  1 amrood amrood      5341 Dec 25 08:38 uml.jpg
drwxr-xr-x  2 amrood amrood      4096 Feb 15  2006 univ
drwxr-xr-x  2 root   root        4096 Dec  9  2007 urlspedia
-rw-r--r--  1 root   root      276480 Dec  9  2007 urlspedia.tar
drwxr-xr-x  8 root   root        4096 Nov 25  2007 usr
-rwxr-xr-x  1 root   root        3192 Nov 25  2007 webthumb.php
-rw-rw-r--  1 amrood amrood     20480 Nov 25  2007 webthumb.tar
-rw-rw-r--  1 amrood amrood      5654 Aug  9  2007 yourfile.mid
-rw-rw-r--  1 amrood amrood    166255 Aug  9  2007 yourfile.swf
$

Here entries starting with <b>d.....</b> represent directories. 
For example, uml, univ and urlspedia are directories and rest of the entries are files.
<h3>Who Are You?</h3>
While you're logged into the system, you might be willing to know : <b>Who am I</b>?
The easiest way to find out "who you are" is to enter the <b>whoami</b> command -
$ whoami
 amrood
$

Try it on your system. 
This command lists the account name associated with the current login. 
You can try <b>who am i</b> command as well to get information about yourself.
<h3>Who is Logged in?</h3>
Sometime you might be interested to know who is logged in to the computer at the same time.
There are three commands available to get you this information, based on how much you wish to know about the other users: <b>users</b>, <b>who</b>, and <b>w</b>.

$ users
 amrood bablu qadir
$ who
amrood ttyp0 Oct 8 14:10 (limbo)
bablu  ttyp2 Oct 4 09:08 (calliope)
qadir  ttyp4 Oct 8 12:09 (dent)
$

Try the <b>w</b> command on your system to check the output. 
This lists down information associated with the users logged in the system.
<h3>Logging Out</h3>
When you finish your session, you need to log out of the system. 
This is to ensure that nobody else accesses your files.
<b>To log out</b>
Just type the <b>logout</b> command at the command prompt, and the system will clean up everything and break the connection.

<h3>System Shutdown</h3>
The most consistent way to shut down a Unix system properly via the command line is to use one of the following commands -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Command &amp; Description</th></tr>
<tr><td>1</td><td><b>halt</b>
Brings the system down immediately</td></tr>
<tr><td>2</td><td><b>init 0</b>
Powers off the system using predefined scripts to synchronize and clean up the system prior to shutting down</td></tr>
<tr><td>3</td><td><b>init 6</b>
Reboots the system by shutting it down completely and then restarting it</td></tr>
<tr><td>4</td><td><b>poweroff</b>
Shuts down the system by powering off</td></tr>
<tr><td>5</td><td><b>reboot</b>
Reboots the system</td></tr>
<tr><td>6</td><td><b>shutdown</b>
Shuts down the system</td></tr>
</table>
You typically need to be the super user or root (the most privileged account on a Unix system) to shut down the system. 
However, on some standalone or personally-owned Unix boxes, an administrative user and sometimes regular users can do so.
<h2><span class="orange">Unix - File Management</span></h2>
In this chapter, we will discuss in detail about file management in Unix. 
All data in Unix is organized into files. 
All files are organized into directories. 
These directories are organized into a tree-like structure called the filesystem.
When you work with Unix, one way or another, you spend most of your time working with files. 
This tutorial will help you understand how to create and remove files, copy and rename them, create links to them, etc.
In Unix, there are three basic types of files -
<b>Ordinary Files</b> - An ordinary file is a file on the system that contains data, text, or program instructions. 
In this tutorial, you look at working with ordinary files.
<b>Directories</b> - Directories store both special and ordinary files. 
For users familiar with Windows or Mac OS, Unix directories are equivalent to folders.
<b>Special Files</b> - Some special files provide access to hardware such as hard drives, CD-ROM drives, modems, and Ethernet adapters. 
Other special files are similar to aliases or shortcuts and enable you to access a single file using different names.

<h2>&emsp;Listing Files</h2>
To list the files and directories stored in the current directory, use the following command -
$ls

Here is the sample output of the above command -
$ls
bin        hosts  lib     res.03
ch07       hw1    pub     test_results
ch07.bak   hw2    res.01  users
docs       hw3    res.02  work

The command <b>ls</b> supports the <b>-l</b> option which would help you to get more information about the listed files -
$ls -l
total 1962188
drwxrwxr-x  2 amrood amrood      4096 Dec 25 09:59 uml
-rw-rw-r--  1 amrood amrood      5341 Dec 25 08:38 uml.jpg
drwxr-xr-x  2 amrood amrood      4096 Feb 15  2006 univ
drwxr-xr-x  2 root   root        4096 Dec  9  2007 urlspedia
-rw-r--r--  1 root   root      276480 Dec  9  2007 urlspedia.tar
drwxr-xr-x  8 root   root        4096 Nov 25  2007 usr
drwxr-xr-x  2    200    300      4096 Nov 25  2007 webthumb-1.01
-rwxr-xr-x  1 root   root        3192 Nov 25  2007 webthumb.php
-rw-rw-r--  1 amrood amrood     20480 Nov 25  2007 webthumb.tar
-rw-rw-r--  1 amrood amrood      5654 Aug  9  2007 yourfile.mid
-rw-rw-r--  1 amrood amrood    166255 Aug  9  2007 yourfile.swf
drwxr-xr-x 11 amrood amrood      4096 May 29  2007 zlib-1.2.3
$

Here is the information about all the listed columns -
<b>First Column</b> - Represents the file type and the permission given on the file. 
Below is the description of all type of files.
<b>Second Column</b> - Represents the number of memory blocks taken by the file or directory.
<b>Third Column</b> - Represents the owner of the file. 
This is the Unix user who created this file.
<b>Fourth Column</b> - Represents the group of the owner. 
Every Unix user will have an associated group.
<b>Fifth Column</b> - Represents the file size in bytes.
<b>Sixth Column</b> - Represents the date and the time when this file was created or modified for the last time.
<b>Seventh Column</b> - Represents the file or the directory name.

In the <b>ls -l</b> listing example, every file line begins with a <b>d</b>, <b>-</b>, or <b>l</b>. 
These characters indicate the type of the file that's listed.
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Prefix &amp; Description</th></tr>
<tr><td>1</td><td><b>-</b>
Regular file, such as an ASCII text file, binary executable, or hard link.</td></tr>
<tr><td>2</td><td><b>b</b>
Block special file. 
Block input/output device file such as a physical hard drive.</td></tr>
<tr><td>3</td><td><b>c</b>
Character special file. 
Raw input/output device file such as a physical hard drive.</td></tr>
<tr><td>4</td><td><b>d</b>
Directory file that contains a listing of other files and directories.</td></tr>
<tr><td>5</td><td><b>l</b>
Symbolic link file. 
Links on any regular file.</td></tr>
<tr><td>6</td><td><b>p</b>
Named pipe. 
A mechanism for interprocess communications.</td></tr>
<tr><td>7</td><td><b>s</b>
Socket used for interprocess communication.</td></tr>
</table>
<h2>&emsp;Metacharacters</h2>
Metacharacters have a special meaning in Unix. 
For example, <b>*</b> and <b>?</b> are metacharacters. 
We use <b>*</b> to match 0 or more characters, a question mark (<b>?</b>) matches with a single character.
For Example -
$ls ch*.doc

Displays all the files, the names of which start with <b>ch</b> and end with <b>.doc</b> -
ch01-1.doc   ch010.doc  ch02.doc    ch03-2.doc 
ch04-1.doc   ch040.doc  ch05.doc    ch06-2.doc
ch01-2.doc ch02-1.doc c

Here, <b>*</b> works as meta character which matches with any character. 
If you want to display all the files ending with just <b>.doc</b>, then you can use the following command -
$ls *.doc

<h2>&emsp;Hidden Files</h2>
An invisible file is one, the first character of which is the dot or the period character (.). 
Unix programs (including the shell) use most of these files to store configuration information.
Some common examples of the hidden files include the files -
<b>.profile</b> - The Bourne shell ( sh) initialization script
<b>.kshrc</b> - The Korn shell ( ksh) initialization script
<b>.cshrc</b> - The C shell ( csh) initialization script
<b>.rhosts</b> - The remote shell configuration file

To list the invisible files, specify the <b>-a</b> option to <b>ls</b> -
$ ls -a
. 
        .profile       docs     lib     test_results
.. 
       .rhosts        hosts    pub     users
.emacs    bin            hw1      res.01  work
.exrc     ch07           hw2      res.02
.kshrc    ch07.bak       hw3      res.03
$

<b>Single dot (.)</b> - This represents the current directory.
<b>Double dot (..)</b> - This represents the parent directory.

<h2>&emsp;Creating Files</h2>
You can use the <b>vi</b> editor to create ordinary files on any Unix system. 
You simply need to give the following command -
$ vi filename

The above command will open a file with the given filename. 
Now, press the key <b>i</b> to come into the edit mode. 
Once you are in the edit mode, you can start writing your content in the file as in the following program -
This is unix file....I created it for the first time.....
I'm going to save this content in this file.

Once you are done with the program, follow these steps -
Press the key <b>esc</b> to come out of the edit mode.
Press two keys <b>Shift &amp;plus; ZZ</b> together to come out of the file completely.

You will now have a file created with <b>filename</b> in the current directory.

$ vi filename
$

<h2>&emsp;Editing Files</h2>
You can edit an existing file using the <b>vi</b> editor. 
We will discuss in short how to open an existing file -
$ vi filename

Once the file is opened, you can come in the edit mode by pressing the key <b>i</b> and then you can proceed by editing the file. 
If you want to move here and there inside a file, then first you need to come out of the edit mode by pressing the key <b>Esc</b>. 
After this, you can use the following keys to move inside a file -
<b>l</b> key to move to the right side.
<b>h</b> key to move to the left side.
<b>k</b> key to move upside in the file.
<b>j</b> key to move downside in the file.

So using the above keys, you can position your cursor wherever you want to edit. 
Once you are positioned, then you can use the <b>i</b> key to come in the edit mode. 
Once you are done with the editing in your file, press <b>Esc</b> and finally two keys <b>Shift &amp;plus; ZZ</b> together to come out of the file completely.
<h2>&emsp;Display Content of a File</h2>
You can use the <b>cat</b> command to see the content of a file. 
Following is a simple example to see the content of the above created file -
$ cat filename
This is unix file....I created it for the first time.....
I'm going to save this content in this file.
$

You can display the line numbers by using the <b>-b</b> option along with the <b>cat</b> command as follows -
$ cat -b filename
1   This is unix file....I created it for the first time.....
2   I'm going to save this content in this file.
$

<h2>&emsp;Counting Words in a File</h2>
You can use the <b>wc</b> command to get a count of the total number of lines, words, and characters contained in a file. 
Following is a simple example to see the information about the file created above -
$ wc filename
2  19 103 filename
$

Here is the detail of all the four columns -
<b>First Column</b> - Represents the total number of lines in the file.
<b>Second Column</b> - Represents the total number of words in the file.
<b>Third Column</b> - Represents the total number of bytes in the file. 
This is the actual size of the file.
<b>Fourth Column</b> - Represents the file name.

You can give multiple files and get information about those files at a time. 
Following is simple syntax -
$ wc filename1 filename2 filename3

<h2>&emsp;Copying Files</h2>
To make a copy of a file use the <b>cp</b> command. 
The basic syntax of the command is -
$ cp source_file destination_file

Following is the example to create a copy of the existing file <b>filename</b>.

$ cp filename copyfile
$

You will now find one more file <b>copyfile</b> in your current directory. 
This file will exactly be the same as the original file <b>filename</b>.
<h2>&emsp;Renaming Files</h2>
To change the name of a file, use the <b>mv</b> command. 
Following is the basic syntax -
$ mv old_file new_file

The following program will rename the existing file <b>filename</b> to <b>newfile</b>.

$ mv filename newfile
$

The <b>mv</b> command will move the existing file completely into the new file. 
In this case, you will find only <b>newfile</b> in your current directory.
<h2>&emsp;Deleting Files</h2>
To delete an existing file, use the <b>rm</b> command. 
Following is the basic syntax -
$ rm filename

<b>Caution</b> - A file may contain useful information. 
It is always recommended to be careful while using this <b>Delete</b> command. 
It is better to use the <b>-i</b> option along with <b>rm</b> command.
Following is the example which shows how to completely remove the existing file <b>filename</b>.

$ rm filename
$

You can remove multiple files at a time with the command given below -
$ rm filename1 filename2 filename3
$

<h2>&emsp;Standard Unix Streams</h2>
Under normal circumstances, every Unix program has three streams (files) opened for it when it starts up -
<b>stdin</b> - This is referred to as the <i>standard input</i> and the associated file descriptor is 0. 
This is also represented as STDIN. 
The Unix program will read the default input from STDIN.
<b>stdout</b> - This is referred to as the <i>standard output</i> and the associated file descriptor is 1. 
This is also represented as STDOUT. 
The Unix program will write the default output at STDOUT
<b>stderr</b> - This is referred to as the <i>standard error</i> and the associated file descriptor is 2. 
This is also represented as STDERR. 
The Unix program will write all the error messages at STDERR.

<h2><span class="orange">Unix - Directory Management</span></h2>
In this chapter, we will discuss in detail about directory management in Unix.
A directory is a file the solo job of which is to store the file names and the related information. 
All the files, whether ordinary, special, or directory, are contained in directories.
Unix uses a hierarchical structure for organizing files and directories. 
This structure is often referred to as a directory tree. 
The tree has a single root node, the slash character (<b>/</b>), and all other directories are contained below it.
<h2>&emsp;Home Directory</h2>
The directory in which you find yourself when you first login is called your home directory.
You will be doing much of your work in your home directory and subdirectories that you'll be creating to organize your files.
You can go in your home directory anytime using the following command -
$cd ~
$

Here <b>~</b> indicates the home directory. 
Suppose you have to go in any other user's home directory, use the following command -
$cd ~username
$

To go in your last directory, you can use the following command -
$cd -
$

<h2>&emsp;Absolute/Relative Pathnames</h2>
Directories are arranged in a hierarchy with root (/) at the top. 
The position of any file within the hierarchy is described by its pathname.
Elements of a pathname are separated by a /. 
A pathname is absolute, if it is described in relation to root, thus absolute pathnames always begin with a /.
Following are some examples of absolute filenames.

/etc/passwd
/users/sjones/chem/notes
/dev/rdsk/Os3

A pathname can also be relative to your current working directory. 
Relative pathnames never begin with /. 
Relative to user amrood's home directory, some pathnames might look like this -
chem/notes
personal/res

To determine where you are within the filesystem hierarchy at any time, enter the command <b>pwd</b> to print the current working directory -
$pwd
/user0/home/amrood
$

<h2>&emsp;Listing Directories</h2>
To list the files in a directory, you can use the following syntax -
$ls dirname

Following is the example to list all the files contained in <b>/usr/local</b> directory -
$ls /usr/local
X11       bin          gimp       jikes       sbin
ace       doc          include    lib         share
atalk     etc          info       man         ami

<h2>&emsp;Creating Directories</h2>
We will now understand how to create directories. 
Directories are created by the following command -
$mkdir dirname

Here, directory is the absolute or relative pathname of the directory you want to create. 
For example, the command -
$mkdir mydir
$

Creates the directory <b>mydir</b> in the current directory. 
Here is another example -
$mkdir /tmp/test-dir
$

This command creates the directory <b>test-dir</b> in the <b>/tmp</b> directory. 
The <b>mkdir</b> command produces no output if it successfully creates the requested directory.
If you give more than one directory on the command line, <b>mkdir</b> creates each of the directories. 
For example, -
$mkdir docs pub
$

Creates the directories docs and pub under the current directory.
<h2>&emsp;Creating Parent Directories</h2>
We will now understand how to create parent directories. 
Sometimes when you want to create a directory, its parent directory or directories might not exist. 
In this case, <b>mkdir</b> issues an error message as follows -
$mkdir /tmp/amrood/test
mkdir: Failed to make directory "/tmp/amrood/test"; 
No such file or directory
$

In such cases, you can specify the <b>-p</b> option to the <b>mkdir</b> command. 
It creates all the necessary directories for you. 
For example -
$mkdir -p /tmp/amrood/test
$

The above command creates all the required parent directories.
<h2>&emsp;Removing Directories</h2>
Directories can be deleted using the <b>rmdir</b> command as follows -
$rmdir dirname
$

<b>Note</b> - To remove a directory, make sure it is empty which means there should not be any file or sub-directory inside this directory.
You can remove multiple directories at a time as follows -
$rmdir dirname1 dirname2 dirname3
$

The above command removes the directories dirname1, dirname2, and dirname3, if they are empty. 
The <b>rmdir</b> command produces no output if it is successful.
<h2>&emsp;Changing Directories</h2>
You can use the <b>cd</b> command to do more than just change to a home directory. 
You can use it to change to any directory by specifying a valid absolute or relative path. 
The syntax is as given below -
$cd dirname
$

Here, <b>dirname</b> is the name of the directory that you want to change to. 
For example, the command -
$cd /usr/local/bin
$

Changes to the directory <b>/usr/local/bin</b>. 
From this directory, you can <b>cd</b> to the directory <b>/usr/home/amrood</b> using the following relative path -
$cd ../../home/amrood
$

<h2>&emsp;Renaming Directories</h2>
The <b>mv (move)</b> command can also be used to rename a directory. 
The syntax is as follows -
$mv olddir newdir
$

You can rename a directory <b>mydir</b> to <b>yourdir</b> as follows -
$mv mydir yourdir
$

<h2>&emsp;The directories .(dot) and ..(dot dot)</h2>
The <b>filename .</b> (dot) represents the current working directory; and the <b>filename ..</b> (dot dot) represents the directory one level above the current working directory, often referred to as the parent directory.
If we enter the command to show a listing of the current working directories/files and use the <b>-a option</b> to list all the files and the <b>-l option</b> to provide the long listing, we will receive the following result.

$ls -la
drwxrwxr-x    4    teacher   class   2048  Jul 16 17.56 .
drwxr-xr-x    60   root              1536  Jul 13 14:18 ..
----------    1    teacher   class   4210  May 1 08:27 .profile
-rwxr-xr-x    1    teacher   class   1948  May 12 13:42 memo
$

<h2><span class="orange">Unix - File Permission / Access Modes</span></h2>
In this chapter, we will discuss in detail about file permission and access modes in Unix. 
File ownership is an important component of Unix that provides a secure method for storing files. 
Every file in Unix has the following attributes -
<b>Owner permissions</b> - The owner's permissions determine what actions the owner of the file can perform on the file.
<b>Group permissions</b> - The group's permissions determine what actions a user, who is a member of the group that a file belongs to, can perform on the file.
<b>Other (world) permissions</b> - The permissions for others indicate what action all other users can perform on the file.

<h2>&emsp;The Permission Indicators</h2>
While using <b>ls -l</b> command, it displays various information related to file permission as follows -
$ls -l /home/amrood
-rwxr-xr--  1 amrood   users 1024  Nov 2 00:10  myfile
drwxr-xr--- 1 amrood   users 1024  Nov 2 00:10  mydir

Here, the first column represents different access modes, i.e., the permission associated with a file or a directory.
The permissions are broken into groups of threes, and each position in the group denotes a specific permission, in this order: read (r), write (w), execute (x) -
The first three characters (2-4) represent the permissions for the file's owner. 
For example, <b>-rwxr-xr--</b> represents that the owner has read (r), write (w) and execute (x) permission.
The second group of three characters (5-7) consists of the permissions for the group to which the file belongs. 
For example, <b>-rwxr-xr--</b> represents that the group has read (r) and execute (x) permission, but no write permission.
The last group of three characters (8-10) represents the permissions for everyone else. 
For example, <b>-rwxr-xr--</b> represents that there is <b>read (r)</b> only permission.

<h2>&emsp;File Access Modes</h2>
The permissions of a file are the first line of defense in the security of a Unix system. 
The basic building blocks of Unix permissions are the <b>read</b>, <b>write</b>, and <b>execute</b> permissions, which have been described below -
<h3>Read</h3>
Grants the capability to read, i.e., view the contents of the file.
<h3>Write</h3>
Grants the capability to modify, or remove the content of the file.
<h3>Execute</h3>
User with execute permissions can run a file as a program.
<h2>&emsp;Directory Access Modes</h2>
Directory access modes are listed and organized in the same manner as any other file. 
There are a few differences that need to be mentioned -
<h3>Read</h3>
Access to a directory means that the user can read the contents. 
The user can look at the <b>filenames</b> inside the directory.
<h3>Write</h3>
Access means that the user can add or delete files from the directory.
<h3>Execute</h3>
Executing a directory doesn't really make sense, so think of this as a traverse permission.
A user must have <b>execute</b> access to the <b>bin</b> directory in order to execute the <b>ls</b> or the <b>cd</b> command.
<h2>&emsp;Changing Permissions</h2>
To change the file or the directory permissions, you use the <b>chmod</b> (change mode) command. 
There are two ways to use chmod — the symbolic mode and the absolute mode.
<h3>Using chmod in Symbolic Mode</h3>
The easiest way for a beginner to modify file or directory permissions is to use the symbolic mode. 
With symbolic permissions you can add, delete, or specify the permission set you want by using the operators in the following table.
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Chmod operator &amp; Description</th></tr>
<tr><td>1</td><td><b>+</b>
Adds the designated permission(s) to a file or directory.</td></tr>
<tr><td>2</td><td><b>-</b>
Removes the designated permission(s) from a file or directory.</td></tr>
<tr><td>3</td><td><b>=</b>
Sets the designated permission(s).</td></tr>
</table>
Here's an example using <b>testfile</b>. 
Running <b>ls -1</b> on the testfile shows that the file's permissions are as follows -
$ls -l testfile
-rwxrwxr--  1 amrood   users 1024  Nov 2 00:10  testfile

Then each example <b>chmod</b> command from the preceding table is run on the testfile, followed by <b>ls –l</b>, so you can see the permission changes -
$chmod o+wx testfile
$ls -l testfile
-rwxrwxrwx  1 amrood   users 1024  Nov 2 00:10  testfile
$chmod u-x testfile
$ls -l testfile
-rw-rwxrwx  1 amrood   users 1024  Nov 2 00:10  testfile
$chmod g = rx testfile
$ls -l testfile
-rw-r-xrwx  1 amrood   users 1024  Nov 2 00:10  testfile

Here's how you can combine these commands on a single line -
$chmod o+wx,u-x,g = rx testfile
$ls -l testfile
-rw-r-xrwx  1 amrood   users 1024  Nov 2 00:10  testfile

<h2>&emsp;Using chmod with Absolute Permissions</h2>
The second way to modify permissions with the chmod command is to use a number to specify each set of permissions for the file.
Each permission is assigned a value, as the following table shows, and the total of each set of permissions provides a number for that set.
<table class="table table-bordered">
<tr><th>Number</th><th>Octal Permission Representation</th>
<th style="text-align:center;width:15%">Ref</th></tr>
<tr><td><b>0</b></td><td>No permission</td><td>---</td></tr>
<tr><td><b>1</b></td><td>Execute permission</td><td>--x</td></tr>
<tr><td><b>2</b></td><td>Write permission</td><td>-w-</td></tr>
<tr><td><b>3</b></td><td>Execute and write permission: 1 (execute) + 2 (write) = 3</td><td>-wx</td></tr>
<tr><td><b>4</b></td><td>Read permission</td><td>r--</td></tr>
<tr><td><b>5</b></td><td>Read and execute permission: 4 (read) &amp;plus; 1 (execute) = 5 </td><td>r-x</td></tr>
<tr><td><b>6</b></td><td>Read and write permission: 4 (read) &amp;plus; 2 (write) = 6</td><td>rw-</td></tr>
<tr><td><b>7</b></td><td>All permissions: 4 (read) &amp;plus; 2 (write) &amp;plus; 1 (execute) = 7</td><td>rwx</td></tr>
</table>
Here's an example using the testfile. 
Running <b>ls -1</b> on the testfile shows that the file's permissions are as follows -
$ls -l testfile
-rwxrwxr--  1 amrood   users 1024  Nov 2 00:10  testfile

Then each example <b>chmod</b> command from the preceding table is run on the testfile, followed by <b>ls –l</b>, so you can see the permission changes -
$ chmod 755 testfile
$ls -l testfile
-rwxr-xr-x  1 amrood   users 1024  Nov 2 00:10  testfile
$chmod 743 testfile
$ls -l testfile
-rwxr---wx  1 amrood   users 1024  Nov 2 00:10  testfile
$chmod 043 testfile
$ls -l testfile
----r---wx  1 amrood   users 1024  Nov 2 00:10  testfile

<h2>&emsp;Changing Owners and Groups</h2>
While creating an account on Unix, it assigns a <b>owner ID</b> and a <b>group ID</b> to each user. 
All the permissions mentioned above are also assigned based on the Owner and the Groups.
Two commands are available to change the owner and the group of files -
<b>chown</b> - The <b>chown</b> command stands for <b>"change owner"</b> and is used to change the owner of a file.
<b>chgrp</b> - The <b>chgrp</b> command stands for <b>"change group"</b> and is used to change the group of a file.

<h2>&emsp;Changing Ownership</h2>
The <b>chown</b> command changes the ownership of a file. 
The basic syntax is as follows -
$ chown user filelist

The value of the user can be either the <b>name of a user</b> on the system or the <b>user id (uid)</b> of a user on the system.
The following example will help you understand the concept -
$ chown amrood testfile
$

Changes the owner of the given file to the user <b>amrood</b>.
<b>NOTE</b> - The super user, root, has the unrestricted capability to change the ownership of any file but normal users can change the ownership of only those files that they own.
<h2>&emsp;Changing Group Ownership</h2>
The <b>chgrp</b> command changes the group ownership of a file. 
The basic syntax is as follows -
$ chgrp group filelist

The value of group can be the <b>name of a group</b> on the system or <b>the group ID (GID)</b> of a group on the system.
Following example helps you understand the concept -
$ chgrp special testfile
$

Changes the group of the given file to <b>special</b> group.
<h2>&emsp;SUID and SGID File Permission</h2>
Often when a command is executed, it will have to be executed with special privileges in order to accomplish its task.
As an example, when you change your password with the <b>passwd</b> command, your new password is stored in the file <b>/etc/shadow</b>.
As a regular user, you do not have <b>read</b> or <b>write</b> access to this file for security reasons, but when you change your password, you need to have the write permission to this file. 
This means that the <b>passwd</b> program has to give you additional permissions so that you can write to the file <b>/etc/shadow</b>.
Additional permissions are given to programs via a mechanism known as the <b>Set User ID (SUID)</b> and <b>Set Group ID (SGID)</b> bits.
When you execute a program that has the SUID bit enabled, you inherit the permissions of that program's owner. 
Programs that do not have the SUID bit set are run with the permissions of the user who started the program.
This is the case with SGID as well. 
Normally, programs execute with your group permissions, but instead your group will be changed just for this program to the group owner of the program.
The SUID and SGID bits will appear as the letter <b>"s"</b> if the permission is available. 
The SUID <b>"s"</b> bit will be located in the permission bits where the owners’ <b>execute</b> permission normally resides.
For example, the command -
$ ls -l /usr/bin/passwd
-r-sr-xr-x  1   root   bin  19031 Feb 7 13:47  /usr/bin/passwd*
$

Shows that the SUID bit is set and that the command is owned by the root. 
A capital letter <b>S</b> in the execute position instead of a lowercase <b>s</b> indicates that the execute bit is not set.
If the sticky bit is enabled on the directory, files can only be removed if you are one of the following users -
The owner of the sticky directory
The owner of the file being removed
The super user, root

To set the SUID and SGID bits for any directory try the following command -
$ chmod ug+s dirname
$ ls -l
drwsr-sr-x 2 root root  4096 Jun 19 06:45 dirname
$

<h2><span class="orange">Unix - Environment</span></h2>
In this chapter, we will discuss in detail about the Unix environment. 
An important Unix concept is the <b>environment</b>, which is defined by environment variables. 
Some are set by the system, others by you, yet others by the shell, or any program that loads another program.
A variable is a character string to which we assign a value. 
The value assigned could be a number, text, filename, device, or any other type of data.
For example, first we set a variable TEST and then we access its value using the <b>echo</b> command -
$TEST="Unix Programming"
$echo $TEST

It produces the following result.

Unix Programming

Note that the environment variables are set without using the <b>$</b> sign but while accessing them we use the $ sign as prefix. 
These variables retain their values until we come out of the shell.
When you log in to the system, the shell undergoes a phase called <b>initialization</b> to set up the environment. 
This is usually a two-step process that involves the shell reading the following files -
/etc/profile
profile

The process is as follows -
The shell checks to see whether the file <b>/etc/profile</b> exists.
If it exists, the shell reads it. 
Otherwise, this file is skipped. 
No error message is displayed.
The shell checks to see whether the file <b>.profile</b> exists in your home directory. 
Your home directory is the directory that you start out in after you log in.
If it exists, the shell reads it; otherwise, the shell skips it. 
No error message is displayed.

As soon as both of these files have been read, the shell displays a prompt -
$

This is the prompt where you can enter commands in order to have them executed.
<b>Note</b> - The shell initialization process detailed here applies to all <b>Bourne</b> type shells, but some additional files are used by <b>bash</b> and <b>ksh</b>.
<h2>&emsp;The .profile File</h2>
The file <b>/etc/profile</b> is maintained by the system administrator of your Unix machine and contains shell initialization information required by all users on a system.
The file <b>.profile</b> is under your control. 
You can add as much shell customization information as you want to this file. 
The minimum set of information that you need to configure includes -
The type of terminal you are using.
A list of directories in which to locate the commands.
A list of variables affecting the look and feel of your terminal.

You can check your <b>.profile</b> available in your home directory. 
Open it using the vi editor and check all the variables set for your environment.
<h2>&emsp;Setting the Terminal Type</h2>
Usually, the type of terminal you are using is automatically configured by either the <b>login</b> or <b>getty</b> programs. 
Sometimes, the auto configuration process guesses your terminal incorrectly.
If your terminal is set incorrectly, the output of the commands might look strange, or you might not be able to interact with the shell properly.
To make sure that this is not the case, most users set their terminal to the lowest common denominator in the following way -
$TERM=vt100
$

<h2>&emsp;Setting the PATH</h2>
When you type any command on the command prompt, the shell has to locate the command before it can be executed.
The PATH variable specifies the locations in which the shell should look for commands. 
Usually the Path variable is set as follows -
$PATH=/bin:/usr/bin
$

Here, each of the individual entries separated by the colon character <b>(:)</b> are directories. 
If you request the shell to execute a command and it cannot find it in any of the directories given in the PATH variable, a message similar to the following appears -
$hello
hello: not found
$

There are variables like PS1 and PS2 which are discussed in the next section.
<h2>&emsp;PS1 and PS2 Variables</h2>
The characters that the shell displays as your command prompt are stored in the variable PS1. 
You can change this variable to be anything you want. 
As soon as you change it, it'll be used by the shell from that point on.
For example, if you issued the command -
$PS1='=&gt;'
=&gt;
=&gt;
=&gt;

Your prompt will become =&gt;. 
To set the value of <b>PS1</b> so that it shows the working directory, issue the command -
=&gt;PS1="[\u@\h \w]\$"
[root@ip-72-167-112-17 /var/www/tutorialspoint/unix]$
[root@ip-72-167-112-17 /var/www/tutorialspoint/unix]$

The result of this command is that the prompt displays the user's username, the machine's name (hostname), and the working directory.
There are quite a few <b>escape sequences</b> that can be used as value arguments for PS1; try to limit yourself to the most critical so that the prompt does not overwhelm you with information.
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Escape Sequence &amp; Description</th></tr>
<tr><td>1</td><td><b>\t</b>
Current time, expressed as HH:MM:SS</td></tr>
<tr><td>2</td><td><b>\d</b>
Current date, expressed as Weekday Month Date</td></tr>
<tr><td>3</td><td><b>\n</b>
Newline</td></tr>
<tr><td>4</td><td><b>\s</b>
Current shell environment</td></tr>
<tr><td>5</td><td><b>\W</b>
Working directory</td></tr>
<tr><td>6</td><td><b>\w</b>
Full path of the working directory</td></tr>
<tr><td>7</td><td><b>\u</b>
Current user’s username</td></tr>
<tr><td>8</td><td><b>\h</b>
Hostname of the current machine</td></tr>
<tr><td>9</td><td><b>\#</b>
Command number of the current command. 
Increases when a new command is entered</td></tr>
<tr><td>10</td><td><b>\$</b>
If the effective UID is 0 (that is, if you are logged in as root), end the prompt with the # character; otherwise, use the $ sign</td></tr>
</table>
You can make the change yourself every time you log in, or you can have the change made automatically in PS1 by adding it to your <b>.profile</b> file.
When you issue a command that is incomplete, the shell will display a secondary prompt and wait for you to complete the command and hit <b>Enter</b> again.
The default secondary prompt is <b>&gt;</b> (the greater than sign), but can be changed by re-defining the <b>PS2</b> shell variable -
Following is the example which uses the default secondary prompt -
$ echo "this is a
&gt; test"
this is a
test
$

The example given below re-defines PS2 with a customized prompt -
$ PS2="secondary prompt-&gt;"
$ echo "this is a
secondary prompt-&gt;test"
this is a
test
$

<h2>&emsp;Environment Variables</h2>
Following is the partial list of important environment variables. 
These variables are set and accessed as mentioned below -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Variable &amp; Description</th></tr>
<tr><td>1</td><td><b>DISPLAY</b>
Contains the identifier for the display that <b>X11</b> programs should use by default.</td></tr>
<tr><td>2</td><td><b>HOME</b>
Indicates the home directory of the current user: the default argument for the cd <b>built-in</b> command.</td></tr>
<tr><td>3</td><td><b>IFS</b>
Indicates the <b>Internal Field Separator</b> that is used by the parser for word splitting after expansion.</td></tr>
<tr><td>4</td><td><b>LANG</b>
LANG expands to the default system locale; LC_ALL can be used to override this. 
For example, if its value is <b>pt_BR</b>, then the language is set to (Brazilian) Portuguese and the locale to Brazil.</td></tr>
<tr><td>5</td><td><b>LD_LIBRARY_PATH</b>
A Unix system with a dynamic linker, contains a colonseparated list of directories that the dynamic linker should search for shared objects when building a process image after exec, before searching in any other directories.</td></tr>
<tr><td>6</td><td><b>PATH</b>
Indicates the search path for commands. 
It is a colon-separated list of directories in which the shell looks for commands.</td></tr>
<tr><td>7</td><td><b>PWD</b>
Indicates the current working directory as set by the cd command.</td></tr>
<tr><td>8</td><td><b>RANDOM</b>
Generates a random integer between 0 and 32,767 each time it is referenced.</td></tr>
<tr><td>9</td><td><b>SHLVL</b>
Increments by one each time an instance of bash is started. 
This variable is useful for determining whether the built-in exit command ends the current session.</td></tr>
<tr><td>10</td><td><b>TERM</b>
Refers to the display type.</td></tr>
<tr><td>11</td><td><b>TZ</b>
Refers to Time zone. 
It can take values like GMT, AST, etc.</td></tr>
<tr><td>12</td><td><b>UID</b>
Expands to the numeric user ID of the current user, initialized at the shell startup.</td></tr>
</table>
Following is the sample example showing few environment variables -
$ echo $HOME
/root
]$ echo $DISPLAY
$ echo $TERM
xterm
$ echo $PATH
/usr/local/bin:/bin:/usr/bin:/home/amrood/bin:/usr/local/bin
$

<h2><span class="orange">Unix Basic Utilities - Printing, Email</span></h2>
In this chapter, we will discuss in detail about Printing and Email as the basic utilities of Unix. 
So far, we have tried to understand the Unix OS and the nature of its basic commands. 
In this chapter, we will learn some important Unix utilities that can be used in our day-to-day life.
<h2>&emsp;Printing Files</h2>
Before you print a file on a Unix system, you may want to reformat it to adjust the margins, highlight some words, and so on. 
Most files can also be printed without reformatting, but the raw printout may not be that appealing.
Many versions of Unix include two powerful text formatters, <b>nroff</b> and <b>troff</b>.
 
<h3>The pr Command</h3>
The <b>pr</b> command does minor formatting of files on the terminal screen or for a printer. 
For example, if you have a long list of names in a file, you can format it onscreen into two or more columns.
Following is the syntax for the <b>pr</b> command -
pr option(s) filename(s)

The <b>pr</b> changes the format of the file only on the screen or on the printed copy; it doesn't modify the original file. 
Following table lists some <b>pr</b> options -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Option &amp; Description</th></tr>
<tr><td>1</td><td><b>-k</b>
Produces <b>k</b> columns of output</td></tr>
<tr><td>2</td><td><b>-d</b>
Double-spaces the output (not on all <b>pr</b> versions)</td></tr>
<tr><td>3</td><td><b>-h "header"</b>
Takes the next item as a report header</td></tr>
<tr><td>4</td><td><b>-t</b>
Eliminates the printing of header and the top/bottom margins</td></tr>
<tr><td>5</td><td><b>-l PAGE_LENGTH</b>
Sets the page length to PAGE_LENGTH (66) lines. 
The default number of lines of text is 56</td></tr>
<tr><td>6</td><td><b>-o MARGIN</b>
Offsets each line with MARGIN (zero) spaces</td></tr>
<tr><td>7</td><td><b>-w PAGE_WIDTH</b>
Sets the page width to PAGE_WIDTH (72) characters for multiple text-column output only</td></tr>
</table>
Before using <b>pr</b>, here are the contents of a sample file named food.

$cat food
Sweet Tooth
Bangkok Wok
Mandalay
Afghani Cuisine
Isle of Java
Big Apple Deli
Sushi and Sashimi
Tio Pepe's Peppers
........
$

Let's use the <b>pr</b> command to make a two-column report with the header <i>Restaurants</i> -
$pr -2 -h "Restaurants" food
Nov  7  9:58 1997  Restaurants   Page 1
Sweet Tooth              Isle of Java
Bangkok Wok              Big Apple Deli
Mandalay                 Sushi and Sashimi
Afghani Cuisine          Tio Pepe's Peppers
........
$

<h3>The lp and lpr Commands</h3>
The command <b>lp</b> or <b>lpr</b> prints a file onto paper as opposed to the screen display. 
Once you are ready with formatting using the <b>pr</b> command, you can use any of these commands to print your file on the printer connected to your computer.
Your system administrator has probably set up a default printer at your site. 
To print a file named <b>food</b> on the default printer, use the <b>lp</b> or <b>lpr</b> command, as in the following example -
$lp food
request id is laserp-525  (1 file)
$

The <b>lp</b> command shows an ID that you can use to cancel the print job or check its status.
If you are using the <b>lp</b> command, you can use the -n<b>Num</b> option to print Num number of copies. 
Along with the command <b>lpr</b>, you can use -<b>Num</b> for the same.
If there are multiple printers connected with the shared network, then you can choose a printer using -d<b>printer</b> option along with lp command and for the same purpose you can use -P<b>printer</b> option along with lpr command. 
Here printer is the printer name.

<h3>The lpstat and lpq Commands</h3>
The <b>lpstat</b> command shows what's in the printer queue: request IDs, owners, file sizes, when the jobs were sent for printing, and the status of the requests.
Use <b>lpstat -o</b> if you want to see all output requests other than just your own. 
Requests are shown in the order they'll be printed -
$lpstat -o
laserp-573  john  128865  Nov 7  11:27  on laserp
laserp-574  grace  82744  Nov 7  11:28
laserp-575  john   23347  Nov 7  11:35
$

The <b>lpq</b> gives slightly different information than <b>lpstat -o</b> -
$lpq
laserp is ready and printing
Rank   Owner      Job  Files                  Total Size
active john       573  report.ps              128865 bytes
1st    grace      574  ch03.ps ch04.ps        82744 bytes
2nd    john       575  standard input         23347 bytes
$

Here the first line displays the printer status. 
If the printer is disabled or running out of paper, you may see different messages on this first line.
<h3>The cancel and lprm Commands</h3>
The <b>cancel</b> command terminates a printing request from the <b>lp command</b>. 
The <b>lprm</b> command terminates all <b>lpr requests</b>. 
You can specify either the ID of the request (displayed by lp or lpq) or the name of the printer.

$cancel laserp-575
request "laserp-575" cancelled
$

To cancel whatever request is currently printing, regardless of its ID, simply enter cancel and the printer name -
$cancel laserp
request "laserp-573" cancelled
$

The <b>lprm</b> command will cancel the active job if it belongs to you. 
Otherwise, you can give job numbers as arguments, or use a <b>dash (-)</b> to remove all of your jobs -
$lprm 575
dfA575diamond dequeued
cfA575diamond dequeued
$

The <b>lprm</b> command tells you the actual filenames removed from the printer queue.
<h2>&emsp;Sending Email</h2>
You use the Unix mail command to send and receive mail. 
Here is the syntax to send an email -
$mail [-s subject] [-c cc-addr] [-b bcc-addr] to-addr

Here are important options related to mail command -s
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Option &amp; Description</th></tr>
<tr><td>1</td><td><b>-s</b>
Specifies subject on the command line.</td></tr>
<tr><td>2</td><td><b>-c</b>
Sends carbon copies to the list of users. 
List should be a commaseparated list of names.</td></tr>
<tr><td>3</td><td><b>-b</b>
Sends blind carbon copies to list. 
List should be a commaseparated list of names.</td></tr>
</table>
Following is an example to send a test message to admin@yahoo.com.

$mail -s "Test Message" admin@yahoo.com 

You are then expected to type in your message, followed by <b>"control-D"</b> at the beginning of a line. 
To stop, simply type dot <b>(.)</b> as follows -
Hi,
This is a test
.
Cc: 

You can send a complete file using a <b>redirect &lt; operator</b> as follows -
$mail -s "Report 05/06/07" admin@yahoo.com &lt; demo.txt 

To check incoming email at your Unix system, you simply type email as follows -
$mail
no email

<h2><span class="orange">Unix - Pipes and Filters</span></h2>
In this chapter, we will discuss in detail about pipes and filters in Unix. 
You can connect two commands together so that the output from one program becomes the input of the next program. 
Two or more commands connected in this way form a pipe.
To make a pipe, put a vertical bar (<b>&amp;verbar;</b>) on the command line between two commands.
When a program takes its input from another program, it performs some operation on that input, and writes the result to the standard output. 
It is referred to as a <b><i>filter</i></b>.
<h2>&emsp;The grep Command</h2>
The grep command searches a file or files for lines that have a certain pattern. 
The syntax is -
$grep pattern file(s)

The name <b>"grep"</b> comes from the ed (a Unix line editor) command <b>g/re/p</b> which means “globally search for a regular expression and print all lines containing it”.
A regular expression is either some plain text (a word, for example) and/or special characters used for pattern matching.
The simplest use of grep is to look for a pattern consisting of a single word. 
It can be used in a pipe so that only those lines of the input files containing a given string are sent to the standard output. 
If you don't give grep a filename to read, it reads its standard input; that's the way all filter programs work -
$ls -l | grep "Aug"
-rw-rw-rw-   1 john  doc     11008 Aug  6 14:10 ch02
-rw-rw-rw-   1 john  doc      8515 Aug  6 15:30 ch07
-rw-rw-r--   1 john  doc      2488 Aug 15 10:51 intro
-rw-rw-r--   1 carol doc      1605 Aug 23 07:35 macros
$

There are various options which you can use along with the <b>grep</b> command -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Option &amp; Description</th></tr>
<tr><td>1</td><td><b>-v</b>
Prints all lines that do not match pattern.</td></tr>
<tr><td>2</td><td><b>-n</b>
Prints the matched line and its line number.</td></tr>
<tr><td>3</td><td><b>-l</b>
Prints only the names of files with matching lines (letter "l")</td></tr>
<tr><td>4</td><td><b>-c</b>
Prints only the count of matching lines.</td></tr>
<tr><td>5</td><td><b>-i</b>
Matches either upper or lowercase.</td></tr>
</table>
Let us now use a regular expression that tells grep to find lines with <b>"carol"</b>, followed by zero or other characters abbreviated in a regular expression as ".*"), then followed by "Aug".-
Here, we are using the <b><i>-i</i></b> option to have case insensitive search -
$ls -l | grep -i "carol.*aug"
-rw-rw-r--   1 carol doc      1605 Aug 23 07:35 macros
$

<h2>&emsp;The sort Command</h2>
The <b>sort</b> command arranges lines of text alphabetically or numerically. 
The following example sorts the lines in the food file -
$sort food
Afghani Cuisine
Bangkok Wok
Big Apple Deli
Isle of Java
Mandalay
Sushi and Sashimi
Sweet Tooth
Tio Pepe's Peppers
$

The <b>sort</b> command arranges lines of text alphabetically by default. 
There are many options that control the sorting -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Description</th></tr>
<tr><td>1</td><td><b>-n</b>
Sorts numerically (example: 10 will sort after 2), ignores blanks and tabs.</td></tr>
<tr><td>2</td><td><b>-r</b>
Reverses the order of sort.</td></tr>
<tr><td>3</td><td><b>-f</b>
Sorts upper and lowercase together.</td></tr>
<tr><td>4</td><td><b>&amp;plus;x</b>
Ignores first <b>x</b> fields when sorting.</td></tr>
</table>
More than two commands may be linked up into a pipe. 
Taking a previous pipe example using <b>grep</b>, we can further sort the files modified in August by the order of size.
The following pipe consists of the commands <b>ls</b>, <b>grep</b>, and <b>sort</b> -
$ls -l | grep "Aug" | sort +4n
-rw-rw-r--  1 carol doc      1605 Aug 23 07:35 macros
-rw-rw-r--  1 john  doc      2488 Aug 15 10:51 intro
-rw-rw-rw-  1 john  doc      8515 Aug  6 15:30 ch07
-rw-rw-rw-  1 john  doc     11008 Aug  6 14:10 ch02
$

This pipe sorts all files in your directory modified in August by the order of size, and prints them on the terminal screen. 
The sort option &amp;plus;4n skips four fields (fields are separated by blanks) then sorts the lines in numeric order.
<h2>&emsp;The pg and more Commands</h2>
A long output can normally be zipped by you on the screen, but if you run text through more or use the <b>pg</b> command as a filter; the display stops once the screen is full of text.
Let's assume that you have a long directory listing. 
To make it easier to read the sorted listing, pipe the output through <b>more</b> as follows -
$ls -l | grep "Aug" | sort +4n | more
-rw-rw-r--  1 carol doc      1605 Aug 23 07:35 macros
-rw-rw-r--  1 john  doc      2488 Aug 15 10:51 intro
-rw-rw-rw-  1 john  doc      8515 Aug  6 15:30 ch07
-rw-rw-r--  1 john  doc     14827 Aug  9 12:40 ch03
.
.
.
-rw-rw-rw-  1 john  doc     16867 Aug  6 15:56 ch05
--More--(74%)

The screen will fill up once the screen is full of text consisting of lines sorted by the order of the file size. 
At the bottom of the screen is the <b>more</b> prompt, where you can type a command to move through the sorted text.
Once you're done with this screen, you can use any of the commands listed in the discussion of the more program.
<h2><span class="orange">Unix - Processes Management</span></h2>
In this chapter, we will discuss in detail about process management in Unix. 
When you execute a program on your Unix system, the system creates a special environment for that program. 
This environment contains everything needed for the system to run the program as if no other program were running on the system.
Whenever you issue a command in Unix, it creates, or starts, a new process. 
When you tried out the <b>ls</b> command to list the directory contents, you started a process. 
A process, in simple terms, is an instance of a running program.
The operating system tracks processes through a five-digit ID number known as the <b>pid</b> or the <b>process ID</b>. 
Each process in the system has a unique <b>pid</b>.
Pids eventually repeat because all the possible numbers are used up and the next pid rolls or starts over. 
At any point of time, no two processes with the same pid exist in the system because it is the pid that Unix uses to track each process.
<h2>&emsp;Starting a Process</h2>
When you start a process (run a command), there are two ways you can run it -
Foreground Processes
Background Processes

<h3>Foreground Processes</h3>
By default, every process that you start runs in the foreground. 
It gets its input from the keyboard and sends its output to the screen.
You can see this happen with the <b>ls</b> command. 
If you wish to list all the files in your current directory, you can use the following command -
$ls ch*.doc

This would display all the files, the names of which start with <b>ch</b> and end with <b>.doc</b> -
ch01-1.doc   ch010.doc  ch02.doc    ch03-2.doc 
ch04-1.doc   ch040.doc  ch05.doc    ch06-2.doc
ch01-2.doc   ch02-1.doc

The process runs in the foreground, the output is directed to my screen, and if the <b>ls</b> command wants any input (which it does not), it waits for it from the keyboard.
While a program is running in the foreground and is time-consuming, no other commands can be run (start any other processes) because the prompt would not be available until the program finishes processing and comes out.
<h3>Background Processes</h3>
A background process runs without being connected to your keyboard. 
If the background process requires any keyboard input, it waits.
The advantage of running a process in the background is that you can run other commands; you do not have to wait until it completes to start another!
The simplest way to start a background process is to add an ampersand (<b>&amp;</b>) at the end of the command.

$ls ch*.doc &amp;

This displays all those files the names of which start with <b>ch</b> and end with <b>.doc</b> -
ch01-1.doc   ch010.doc  ch02.doc    ch03-2.doc 
ch04-1.doc   ch040.doc  ch05.doc    ch06-2.doc
ch01-2.doc   ch02-1.doc

Here, if the <b>ls</b> command wants any input (which it does not), it goes into a stop state until we move it into the foreground and give it the data from the keyboard.
That first line contains information about the background process - the job number and the process ID. 
You need to know the job number to manipulate it between the background and the foreground.
Press the Enter key and you will see the following -
[1]   +   Done                 ls ch*.doc &amp;
$

The first line tells you that the <b>ls</b> command background process finishes successfully. 
The second is a prompt for another command.
<h2>&emsp;Listing Running Processes</h2>
It is easy to see your own processes by running the <b>ps</b> (process status) command as follows -
$ps
PID       TTY      TIME        CMD
18358     ttyp3    00:00:00    sh
18361     ttyp3    00:01:31    abiword
18789     ttyp3    00:00:00    ps

One of the most commonly used flags for ps is the <b>-f</b> ( f for full) option, which provides more information as shown in the following example -
$ps -f
UID      PID  PPID C STIME    TTY   TIME CMD
amrood   6738 3662 0 10:23:03 pts/6 0:00 first_one
amrood   6739 3662 0 10:22:54 pts/6 0:00 second_one
amrood   3662 3657 0 08:10:53 pts/6 0:00 -ksh
amrood   6892 3662 4 10:51:50 pts/6 0:00 ps -f

Here is the description of all the fields displayed by <b>ps -f</b> command -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Column &amp; Description</th></tr>
<tr><td>1</td><td><b>UID</b>
User ID that this process belongs to (the person running it)</td></tr>
<tr><td>2</td><td><b>PID</b>
Process ID</td></tr>
<tr><td>3</td><td><b>PPID</b>
Parent process ID (the ID of the process that started it)</td></tr>
<tr><td>4</td><td><b>C</b>
CPU utilization of process</td></tr>
<tr><td>5</td><td><b>STIME</b>
Process start time</td></tr>
<tr><td>6</td><td><b>TTY</b>
Terminal type associated with the process</td></tr>
<tr><td>7</td><td><b>TIME</b>
CPU time taken by the process</td></tr>
<tr><td>8</td><td><b>CMD</b>
The command that started this process</td></tr>
</table>
There are other options which can be used along with <b>ps</b> command -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Option &amp; Description</th></tr>
<tr><td>1</td><td><b>-a</b>
Shows information about all users</td></tr>
<tr><td>2</td><td><b>-x</b>
Shows information about processes without terminals</td></tr>
<tr><td>3</td><td><b>-u</b>
Shows additional information like -f option</td></tr>
<tr><td>4</td><td><b>-e</b>
Displays extended information</td></tr>
</table>
<h2>&emsp;Stopping Processes</h2>
Ending a process can be done in several different ways. 
Often, from a console-based command, sending a CTRL &amp;plus; C keystroke (the default interrupt character) will exit the command. 
This works when the process is running in the foreground mode.
If a process is running in the background, you should get its Job ID using the <b>ps</b> command. 
After that, you can use the <b>kill</b> command to kill the process as follows -
$ps -f
UID      PID  PPID C STIME    TTY   TIME CMD
amrood   6738 3662 0 10:23:03 pts/6 0:00 first_one
amrood   6739 3662 0 10:22:54 pts/6 0:00 second_one
amrood   3662 3657 0 08:10:53 pts/6 0:00 -ksh
amrood   6892 3662 4 10:51:50 pts/6 0:00 ps -f
$kill 6738
Terminated

Here, the <b>kill</b> command terminates the <b>first_one</b> process. 
If a process ignores a regular kill command, you can use <b>kill -9</b> followed by the process ID as follows -
$kill -9 6738
Terminated

<h2>&emsp;Parent and Child Processes</h2>
Each unix process has two ID numbers assigned to it: The Process ID (pid) and the Parent process ID (ppid). 
Each user process in the system has a parent process.
Most of the commands that you run have the shell as their parent. 
Check the <b>ps -f</b> example where this command listed both the process ID and the parent process ID.
<h2>&emsp;Zombie and Orphan Processes</h2>
Normally, when a child process is killed, the parent process is updated via a <b>SIGCHLD</b> signal. 
Then the parent can do some other task or restart a new child as needed. 
However, sometimes the parent process is killed before its child is killed. 
In this case, the "parent of all processes," the <b>init</b> process, becomes the new PPID (parent process ID). 
In some cases, these processes are called orphan processes.
When a process is killed, a <b>ps</b> listing may still show the process with a <b>Z</b> state. 
This is a zombie or defunct process. 
The process is dead and not being used. 
These processes are different from the orphan processes. 
They have completed execution but still find an entry in the process table.
<h2>&emsp;Daemon Processes</h2>
Daemons are system-related background processes that often run with the permissions of root and services requests from other processes.
A daemon has no controlling terminal. 
It cannot open <b>/dev/tty</b>. 
If you do a <b>"ps -ef"</b> and look at the <b>tty</b> field, all daemons will have a <b>?</b> for the <b>tty</b>.
To be precise, a daemon is a process that runs in the background, usually waiting for something to happen that it is capable of working with. 
For example, a printer daemon waiting for print commands.
If you have a program that calls for lengthy processing, then it’s worth to make it a daemon and run it in the background.
<h2>&emsp;The top Command</h2>
The <b>top</b> command is a very useful tool for quickly showing processes sorted by various criteria.
It is an interactive diagnostic tool that updates frequently and shows information about physical and virtual memory, CPU usage, load averages, and your busy processes.
Here is the simple syntax to run top command and to see the statistics of CPU utilization by different processes -
$top

<h2>&emsp;Job ID Versus Process ID</h2>
Background and suspended processes are usually manipulated via <b>job number (job ID)</b>. 
This number is different from the process ID and is used because it is shorter.
In addition, a job can consist of multiple processes running in a series or at the same time, in parallel. 
Using the job ID is easier than tracking individual processes.
<h2><span class="orange">Unix - Network Communication Utilities</span></h2>
In this chapter, we will discuss in detail about network communication utilities in Unix. 
When you work in a distributed environment, you need to communicate with remote users and you also need to access remote Unix machines.
There are several Unix utilities that help users compute in a networked, distributed environment. 
This chapter lists a few of them.
<h2>&emsp;The ping Utility</h2>
The <b>ping</b> command sends an echo request to a host available on the network. 
Using this command, you can check if your remote host is responding well or not.
The ping command is useful for the following -
Tracking and isolating hardware and software problems.
Determining the status of the network and various foreign hosts.
Testing, measuring, and managing networks.

<h3>Syntax</h3>
Following is the simple syntax to use the ftp command -
$ping hostname or ip-address

The above command starts printing a response after every second. 
To come out of the command, you can terminate it by pressing <b>CNTRL &amp;plus; C</b> keys.
<h3>Example</h3>
Following is an example to check the availability of a host available on the network -
$ping google.com
PING google.com (74.125.67.100) 56(84) bytes of data.
64 bytes from 74.125.67.100: icmp_seq = 1 ttl = 54 time = 39.4 ms
64 bytes from 74.125.67.100: icmp_seq = 2 ttl = 54 time = 39.9 ms
64 bytes from 74.125.67.100: icmp_seq = 3 ttl = 54 time = 39.3 ms
64 bytes from 74.125.67.100: icmp_seq = 4 ttl = 54 time = 39.1 ms
64 bytes from 74.125.67.100: icmp_seq = 5 ttl = 54 time = 38.8 ms
--- google.com ping statistics ---
22 packets transmitted, 22 received, 0% packet loss, time 21017ms
rtt min/avg/max/mdev = 38.867/39.334/39.900/0.396 ms
$

If a host does not exist, you will receive the following output -
$ping giiiiiigle.com
ping: unknown host giiiiigle.com
$

<h2>&emsp;The ftp Utility</h2>
Here, <b>ftp</b> stands for <b>F</b>ile <b>T</b>ransfer <b>P</b>rotocol. 
This utility helps you upload and download your file from one computer to another computer.
The ftp utility has its own set of Unix-like commands. 
These commands help you perform tasks such as -
Connect and login to a remote host.
Navigate directories.
List directory contents.
Put and get files.
Transfer files as <b>ascii</b>, <b>ebcdic</b> or <b>binary</b>.

<h3>Syntax</h3>
Following is the simple syntax to use the ftp command -
$ftp hostname or ip-address

The above command would prompt you for the login ID and the password. 
Once you are authenticated, you can access the home directory of the login account and you would be able to perform various commands.
The following tables lists out a few important commands -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Command &amp; Description</th></tr>
<tr><td>1</td><td><b>put filename</b>
Uploads filename from the local machine to the remote machine.</td></tr>
<tr><td>2</td><td><b>get filename</b>
Downloads filename from the remote machine to the local machine.</td></tr>
<tr><td>3</td><td><b>mput file list</b>
Uploads more than one file from the local machine to the remote machine.</td></tr>
<tr><td>4</td><td><b>mget file list</b>
Downloads more than one file from the remote machine to the local machine.</td></tr>
<tr><td>5</td><td><b>prompt off</b>
Turns the prompt off. 
By default, you will receive a prompt to upload or download files using <b>mput</b> or <b>mget</b> commands.</td></tr>
<tr><td>6</td><td><b>prompt on</b>
Turns the prompt on.</td></tr>
<tr><td>7</td><td><b>dir</b>
Lists all the files available in the current directory of the remote machine.</td></tr>
<tr><td>8</td><td><b>cd dirname</b>
Changes directory to dirname on the remote machine.</td></tr>
<tr><td>9</td><td><b>lcd dirname</b>
Changes directory to dirname on the local machine.</td></tr>
<tr><td>10</td><td><b>quit</b>
Helps logout from the current login.</td></tr>
</table>
It should be noted that all the files would be downloaded or uploaded to or from the current directories. 
If you want to upload your files in a particular directory, you need to first change to that directory and then upload the required files.
<h3>Example</h3>
Following is the example to show the working of a few commands -
$ftp amrood.com
Connected to amrood.com.
220 amrood.com FTP server (Ver 4.9 Thu Sep 2 20:35:07 CDT 2009)
Name (amrood.com:amrood): amrood
331 Password required for amrood.
Password:
230 User amrood logged in.
ftp&gt; dir
200 PORT command successful.
150 Opening data connection for /bin/ls.
total 1464
drwxr-sr-x   3 amrood   group       1024 Mar 11 20:04 Mail
drwxr-sr-x   2 amrood   group       1536 Mar  3 18:07 Misc
drwxr-sr-x   5 amrood   group        512 Dec  7 10:59 OldStuff
drwxr-sr-x   2 amrood   group       1024 Mar 11 15:24 bin
drwxr-sr-x   5 amrood   group       3072 Mar 13 16:10 mpl
-rw-r--r--   1 amrood   group     209671 Mar 15 10:57 myfile.out
drwxr-sr-x   3 amrood   group        512 Jan  5 13:32 public
drwxr-sr-x   3 amrood   group        512 Feb 10 10:17 pvm3
226 Transfer complete.
ftp&gt; cd mpl
250 CWD command successful.
ftp&gt; dir
200 PORT command successful.
150 Opening data connection for /bin/ls.
total 7320
-rw-r--r--   1 amrood   group       1630 Aug  8 1994  dboard.f
-rw-r-----   1 amrood   group       4340 Jul 17 1994  vttest.c
-rwxr-xr-x   1 amrood   group     525574 Feb 15 11:52 wave_shift
-rw-r--r--   1 amrood   group       1648 Aug  5 1994  wide.list
-rwxr-xr-x   1 amrood   group       4019 Feb 14 16:26 fix.c
226 Transfer complete.
ftp&gt; get wave_shift
200 PORT command successful.
150 Opening data connection for wave_shift (525574 bytes).
226 Transfer complete.
528454 bytes received in 1.296 seconds (398.1 Kbytes/s)
ftp&gt; quit
221 Goodbye.
$

<h2>&emsp;The telnet Utility</h2>
There are times when we are required to connect to a remote Unix machine and work on that machine remotely. 
<b>Telnet</b> is a utility that allows a computer user at one site to make a connection, login and then conduct work on a computer at another site.
Once you login using Telnet, you can perform all the activities on your remotely connected machine. 
The following is an example of Telnet session -
C:&gt;telnet amrood.com
Trying...
Connected to amrood.com.
Escape character is '^]'.
login: amrood
amrood's Password: 
*****************************************************
*                                                   *
*                                                   *
*    WELCOME TO AMROOD.COM                          *
*                                                   *
*                                                   *
*****************************************************
Last unsuccessful login: Fri Mar  3 12:01:09 IST 2009
Last login: Wed Mar  8 18:33:27 IST 2009 on pts/10
   {  do your work }
$ logout
Connection closed.
C:&gt;

<h2>&emsp;The finger Utility</h2>
The <b>finger</b> command displays information about users on a given host. 
The host can be either local or remote.
Finger may be disabled on other systems for security reasons.
Following is the simple syntax to use the finger command -
Check all the logged-in users on the local machine -
$ finger
Login     Name       Tty      Idle  Login Time   Office
amrood               pts/0          Jun 25 08:03 (62.61.164.115)

Get information about a specific user available on the local machine -
$ finger amrood
Login: amrood                           Name: (null)
Directory: /home/amrood                 Shell: /bin/bash
On since Thu Jun 25 08:03 (MST) on pts/0 from 62.61.164.115
No mail.
No Plan.

Check all the logged-in users on the remote machine -
$ finger @avtar.com
Login     Name       Tty      Idle  Login Time   Office
amrood               pts/0          Jun 25 08:03 (62.61.164.115)

Get the information about a specific user available on the remote machine -
$ finger amrood@avtar.com
Login: amrood                           Name: (null)
Directory: /home/amrood                 Shell: /bin/bash
On since Thu Jun 25 08:03 (MST) on pts/0 from 62.61.164.115
No mail.
No Plan.

<h2><span class="orange">Unix - The vi Editor Tutorial</span></h2>
In this chapter, we will understand how the vi Editor works in Unix. 
There are many ways to edit files in Unix. 
Editing files using the screen-oriented text editor <b>vi</b> is one of the best ways. 
This editor enables you to edit lines in context with other lines in the file.
An improved version of the vi editor which is called the <b>VIM</b> has also been made available now. 
Here, VIM stands for <b>Vi IM</b>proved.
vi is generally considered the de facto standard in Unix editors because -
It's usually available on all the flavors of Unix system.
Its implementations are very similar across the board.
It requires very few resources.
It is more user-friendly than other editors such as the <b>ed</b> or the <b>ex</b>.

You can use the <b>vi</b> editor to edit an existing file or to create a new file from scratch. 
You can also use this editor to just read a text file.
<h2>&emsp;Starting the vi Editor</h2>
The following table lists out the basic commands to use the vi editor -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Command &amp; Description</th></tr>
<tr><td>1</td><td><b>vi filename</b>
Creates a new file if it already does not exist, otherwise opens an existing file.</td></tr>
<tr><td>2</td><td><b>vi -R filename</b>
Opens an existing file in the read-only mode.</td></tr>
<tr><td>3</td><td><b>view filename</b>
Opens an existing file in the read-only mode.</td></tr>
</table>
Following is an example to create a new file <b>testfile</b> if it already does not exist in the current working directory -
$vi testfile

The above command will generate the following output -
|
~
~
~
~
~
~
~
~
~
~
~
~
"testfile" [New File]    

You will notice a <b>tilde</b> (~) on each line following the cursor. 
A tilde represents an unused line. 
If a line does not begin with a tilde and appears to be blank, there is a space, tab, newline, or some other non-viewable character present.
You now have one open file to start working on. 
Before proceeding further, let us understand a few important concepts.
<h2>&emsp;Operation Modes</h2>
While working with the vi editor, we usually come across the following two modes -
<b>Command mode</b> - This mode enables you to perform administrative tasks such as saving the files, executing the commands, moving the cursor, cutting (yanking) and pasting the lines or words, as well as finding and replacing. 
In this mode, whatever you type is interpreted as a command.
<b>Insert mode</b> - This mode enables you to insert text into the file. 
Everything that's typed in this mode is interpreted as input and placed in the file.

vi always starts in the <b>command mode</b>. 
To enter text, you must be in the insert mode for which simply type <b>i</b>. 
To come out of the insert mode, press the <b>Esc</b> key, which will take you back to the command mode.
<b>Hint</b> - If you are not sure which mode you are in, press the Esc key twice; this will take you to the command mode. 
You open a file using the vi editor. 
Start by typing some characters and then come to the command mode to understand the difference.
<h2>&emsp;Getting Out of vi</h2>
The command to quit out of vi is <b>:q</b>. 
Once in the command mode, type colon, and 'q', followed by return. 
If your file has been modified in any way, the editor will warn you of this, and not let you quit. 
To ignore this message, the command to quit out of vi without saving is <b>:q!</b>. 
This lets you exit vi without saving any of the changes.
The command to save the contents of the editor is <b>:w</b>. 
You can combine the above command with the quit command, or use <b>:wq</b> and return.
The easiest way to <b>save your changes and exit vi</b> is with the ZZ command. 
When you are in the command mode, type <b>ZZ</b>. 
The <b>ZZ</b> command works the same way as the <b>:wq</b> command.
If you want to specify/state any particular name for the file, you can do so by specifying it after the <b>:w</b>. 
For example, if you wanted to save the file you were working on as another filename called <b>filename2</b>, you would type <b>:w filename2</b> and return.
<h2>&emsp;Moving within a File</h2>
To move around within a file without affecting your text, you must be in the command mode (press Esc twice). 
The following table lists out a few commands you can use to move around one character at a time -
<table class="table table-bordered">
<tr><th style="text-align:center;%">Sr.No.</th>
<th style="text-align:center;%">Command &amp; Description</th></tr>
<tr><td>1</td><td><b>k</b>
Moves the cursor up one line</td></tr>
<tr><td>2</td><td><b>j</b>
Moves the cursor down one line</td></tr>
<tr><td>3</td><td><b>h</b>
Moves the cursor to the left one character position</td></tr>
<tr><td>4</td><td><b>l</b>
Moves the cursor to the right one character position</td></tr>
</table>
The following points need to be considered to move within a file -
vi is case-sensitive. 
You need to pay attention to capitalization when using the commands.
Most commands in vi can be prefaced by the number of times you want the action to occur. 
For example, <b>2j</b> moves the cursor two lines down the cursor location.

There are many other ways to move within a file in vi. 
Remember that you must be in the command mode (<b>press Esc twice</b>). 
The following table lists out a few commands to move around the file -
<section class="toggle"><label>Given below is the list of commands to move around the file.</label>
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Command &amp; Description</th></tr>
<tr><td>1</td><td><b>0 or &amp;verbar;</b>
Positions the cursor at the beginning of a line</td></tr>
<tr><td>2</td><td><b>$</b>
Positions the cursor at the end of a line</td></tr>
<tr><td>3</td><td><b>w</b>
Positions the cursor to the next word</td></tr>
<tr><td>4</td><td><b>b</b>
Positions the cursor to the previous word</td></tr>
<tr><td>5</td><td><b>(</b>
Positions the cursor to the beginning of the current sentence</td></tr>
<tr><td>6</td><td><b>)</b>
Positions the cursor to the  beginning of the next sentence</td></tr>
<tr><td>7</td><td><b>E</b>
Moves to the end of the blank delimited word</td></tr>
<tr><td>8</td><td><b>{</b>
Moves a paragraph back</td></tr>
<tr><td>9</td><td><b>}</b>
Moves a paragraph forward</td></tr>
<tr><td>10</td><td><b>[[</b>
Moves a section back</td></tr>
<tr><td>11</td><td><b>]]</b>
Moves a section forward</td></tr>
<tr><td>12</td><td><b>n|</b>
Moves to the column <b>n</b> in the current line</td></tr>
<tr><td>13</td><td><b>1G</b>
Moves to the first line of the file</td></tr>
<tr><td>14</td><td><b>G</b>
Moves to the last line of the file</td></tr>
<tr><td>15</td><td><b>nG</b>
Moves to the <b>n<sup>th</sup></b> line of the file</td></tr>
<tr><td>16</td><td><b>:n</b>
Moves to the <b>n<sup>th</sup></b> line of the file</td></tr>
<tr><td>17</td><td><b>fc</b>
Moves forward to <b>c</b></td></tr>
<tr><td>18</td><td><b>Fc</b>
Moves back to <b>c</b></td></tr>
<tr><td>19</td><td><b>H</b>
Moves to the top of the screen</td></tr>
<tr><td>20</td><td><b>nH</b>
Moves to the <b>n<sup>th</sup></b> line from the top of the screen</td></tr>
<tr><td>21</td><td><b>M</b>
Moves to the middle of the screen</td></tr>
<tr><td>22</td><td><b>L</b>
Move to the bottom of the screen</td></tr>
<tr><td>23</td><td><b>nL</b>
Moves to the <b>n<sup>th</sup></b> line from the bottom of the screen</td></tr>
<tr><td>24</td><td><b>:x</b>
Colon followed by a number would position the cursor on the line number represented by <b>x</b></td></tr>
</table>
</section><h2>&emsp;Control Commands</h2>
The following commands can be used with the Control Key to performs functions as given in the table below -
<section class="toggle"><label>Given below is the list of control commands.</label>
<table class="table table-bordered">
<tr><th style="text-align:center;width:5%">Sr.No.</th><th>Command &amp; Description</th></tr>
<tr><td>1</td><td><b>CTRL&amp;plus;d</b>
Moves forward 1/2 screen</td></tr>
<tr><td>2</td><td><b>CTRL&amp;plus;f</b>
Moves forward one full screen</td></tr>
<tr><td>3</td><td><b>CTRL&amp;plus;u</b>
Moves backward 1/2 screen</td></tr>
<tr><td>4</td><td><b>CTRL&amp;plus;b</b>
Moves backward one full screen</td></tr>
<tr><td>5</td><td><b>CTRL&amp;plus;e</b>
Moves the screen up one line</td></tr>
<tr><td>6</td><td><b>CTRL&amp;plus;y</b>
Moves the screen down one line</td></tr>
<tr><td>7</td><td><b>CTRL&amp;plus;u</b>
Moves the screen up 1/2 page</td></tr>
<tr><td>8</td><td><b>CTRL&amp;plus;d</b>
Moves the screen down 1/2 page</td></tr>
<tr><td>9</td><td><b>CTRL&amp;plus;b</b>
Moves the screen up one page</td></tr>
<tr><td>10</td><td><b>CTRL&amp;plus;f</b>
Moves the screen down one page</td></tr>
<tr><td>11</td><td><b>CTRL&amp;plus;I</b>
Redraws the screen</td></tr>
</table>
</section><h2>&emsp;Editing Files</h2>
To edit the file, you need to be in the insert mode. 
There are many ways to enter the insert mode from the command mode -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Command &amp; Description</th></tr>
<tr><td>1</td><td><b>i</b>
Inserts text before the current cursor location</td></tr>
<tr><td>2</td><td><b>I</b>
Inserts text at the beginning of the current line</td></tr>
<tr><td>3</td><td><b>a</b>
Inserts text after the current cursor location</td></tr>
<tr><td>4</td><td><b>A</b>
Inserts text at the end of the current line</td></tr>
<tr><td>5</td><td><b>o</b>
Creates a new line for text entry below the cursor location</td></tr>
<tr><td>6</td><td><b>O</b>
Creates a new line for text entry above the cursor location</td></tr>
</table>
<h2>&emsp;Deleting Characters</h2>
Here is a list of important commands, which can be used to delete characters and lines in an open file -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Command &amp; Description</th></tr>
<tr><td>1</td><td><b>x</b>
Deletes the character under the cursor location</td></tr>
<tr><td>2</td><td><b>X</b>
Deletes the character before the cursor location</td></tr>
<tr><td>3</td><td><b>dw</b>
Deletes from the current cursor location to the next word</td></tr>
<tr><td>4</td><td><b>d^</b>
Deletes from the current cursor position to the beginning of the line</td></tr>
<tr><td>5</td><td><b>d$</b>
Deletes from the current cursor position to the end of the line</td></tr>
<tr><td>6</td><td><b>D</b>
Deletes from the cursor position to the end of the current line</td></tr>
<tr><td>7</td><td><b>dd</b>
Deletes the line the cursor is on</td></tr>
</table>
As mentioned above, most commands in vi can be prefaced by the number of times you want the action to occur. 
For example, <b>2x</b> deletes two characters under the cursor location and <b>2dd</b> deletes two lines the cursor is on.
It is recommended that the commands are practiced before we proceed further.
<h2>&emsp;Change Commands</h2>
You also have the capability to change characters, words, or lines in vi without deleting them. 
Here are the relevant commands -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Command &amp; Description</th></tr>
<tr><td>1</td><td><b>cc</b>
Removes the contents of the line, leaving you in insert mode.</td></tr>
<tr><td>2</td><td><b>cw</b>
Changes the word the cursor is on from the cursor to the lowercase <b>w</b> end of the word.</td></tr>
<tr><td>3</td><td><b>r</b>
Replaces the character under the cursor. 
vi returns to the command mode after the replacement is entered.</td></tr>
<tr><td>4</td><td><b>R</b>
Overwrites multiple characters beginning with the character currently under the cursor. 
You must use <b>Esc</b> to stop the overwriting.</td></tr>
<tr><td>5</td><td><b>s</b>
Replaces the current character with the character you type. 
Afterward, you are left in the insert mode.</td></tr>
<tr><td>6</td><td><b>S</b>
Deletes the line the cursor is on and replaces it with the new text. 
After the new text is entered, vi remains in the insert mode.</td></tr>
</table>
<h2>&emsp;Copy and Paste Commands</h2>
You can copy lines or words from one place and then you can paste them at another place using the following commands -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Command &amp; Description</th></tr>
<tr><td>1</td><td><b>yy</b>
Copies the current line.</td></tr>
<tr><td>2</td><td><b>yw</b>
Copies the current word from the character the lowercase w cursor is on, until the end of the word.</td></tr>
<tr><td>3</td><td><b>p</b>
Puts the copied text after the cursor.</td></tr>
<tr><td>4</td><td><b>P</b>
Puts the yanked text before the cursor.</td></tr>
</table>
<h2>&emsp;Advanced Commands</h2>
There are some advanced commands that simplify day-to-day editing and allow for more efficient use of vi -
<section class="toggle"><label>Given below is the list advanced commands.</label>
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Command &amp; Description</th></tr>
<tr><td>1</td><td><b>J</b>
Joins the current line with the next one. 
A count of j commands join many lines.</td></tr>
<tr><td>2</td><td><b>&lt;&lt;</b>
Shifts the current line to the left by one shift width.</td></tr>
<tr><td>3</td><td><b>&gt;&gt;</b>
Shifts the current line to the right by one shift width.</td></tr>
<tr><td>4</td><td><b>~</b>
Switches the case of the character under the cursor.</td></tr>
<tr><td>5</td><td><b>^G</b>
Press Ctrl and G keys at the same time to show the current filename and the status.</td></tr>
<tr><td>6</td><td><b>U</b>
Restores the current line to the state it was in before the cursor entered the line.</td></tr>
<tr><td>7</td><td><b>u</b>
This helps undo the last change that was done in the file. 
Typing 'u' again will re-do the change.</td></tr>
<tr><td>8</td><td><b>J</b>
Joins the current line with the next one. 
A count joins that many lines.</td></tr>
<tr><td>9</td><td><b>:f</b>
Displays the current position in the file in % and the file name, the total number of file.</td></tr>
<tr><td>10</td><td><b>:f filename</b>
Renames the current file to filename.</td></tr>
<tr><td>11</td><td><b>:w filename</b>
Writes to file filename.</td></tr>
<tr><td>12</td><td><b>:e filename</b>
Opens another file with filename.</td></tr>
<tr><td>13</td><td><b>:cd dirname</b>
Changes the current working directory to dirname.</td></tr>
<tr><td>14</td><td><b>:e #</b>
Toggles between two open files.</td></tr>
<tr><td>15</td><td><b>:n</b>
In case you open multiple files using vi, use <b>:n</b> to go to the next file in the series.</td></tr>
<tr><td>16</td><td><b>:p</b>
In case you open multiple files using vi, use <b>:p</b> to go to the previous file in the series.</td></tr>
<tr><td>17</td><td><b>:N</b>
In case you open multiple files using vi, use <b>:N</b> to go to the previous file in the series.</td></tr>
<tr><td>18</td><td><b>:r file</b>
Reads file and inserts it after the current line.</td></tr>
<tr><td>19</td><td><b>:nr file</b>
Reads file and inserts it after the line <b>n</b>.</td></tr>
</table>
</section><h2>&emsp;Word and Character Searching</h2>
The vi editor has two kinds of searches: <b>string</b> and <b>character</b>. 
For a string search, the <b>/</b> and <b>?</b> commands are used. 
When you start these commands, the command just typed will be shown on the last line of the screen, where you type the particular string to look for.
These two commands differ only in the direction where the search takes place -
The <b>/</b> command searches forwards (downwards) in the file.
The <b>?</b> command searches backwards (upwards) in the file.

The <b>n</b> and <b>N</b> commands repeat the previous search command in the same or the opposite direction, respectively. 
Some characters have special meanings. 
These characters must be preceded by a backslash (<b>\</b>) to be included as part of the search expression.
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Character &amp;Description</th></tr>
<tr><td>1</td><td><b>^</b>
Searches at the beginning of the line (Use at the beginning of a search expression).</td></tr>
<tr><td>2</td><td><b>.</b>
Matches a single character.</td></tr>
<tr><td>3</td><td><b>*</b>
Matches zero or more of the previous character.</td></tr>
<tr><td>4</td><td><b>$</b>
End of the line (Use at the end of the search expression).</td></tr>
<tr><td>5</td><td><b>[</b>
Starts a set of matching or non-matching expressions.</td></tr>
<tr><td>6</td><td><b>&lt;</b>
This is put in an expression escaped with the backslash to find the ending or the beginning of a word.</td></tr>
<tr><td>7</td><td><b>&gt;</b>
This helps see the '<b>&lt;</b>' character description above.</td></tr>
</table>
The character search searches within one line to find a character entered after the command. 
The <b>f</b> and <b>F</b> commands search for a character on the current line only. 
<b>f</b> searches forwards and <b>F</b> searches backwards and the cursor moves to the position of the found character.
The <b>t</b> and <b>T</b> commands search for a character on the current line only, but for <b>t</b>, the cursor moves to the position before the character, and <b>T</b> searches the line backwards to the position after the character.
<h2>&emsp;Set Commands</h2>
You can change the look and feel of your vi screen using the following <b>:set</b> commands. 
Once you are in the command mode, type <b>:set</b> followed by any of the following commands.
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Command &amp; Description</th></tr>
<tr><td>1</td><td><b>:set ic</b>
Ignores the case when searching</td></tr>
<tr><td>2</td><td><b>:set ai</b>
Sets autoindent</td></tr>
<tr><td>3</td><td><b>:set noai</b>
Unsets autoindent</td></tr>
<tr><td>4</td><td><b>:set nu</b>
Displays lines with line numbers on the left side</td></tr>
<tr><td>5</td><td><b>:set sw</b>
Sets the width of a software tabstop. 
For example, you would set a shift width of 4 with this command — <b>:set sw = 4</b></td></tr>
<tr><td>6</td><td><b>:set ws</b>
If <i>wrapscan</i> is set, and the word is not found at the bottom of the file, it will try searching for it at the beginning</td></tr>
<tr><td>7</td><td><b>:set wm</b>
If this option has a value greater than zero, the editor will automatically "word wrap". 
For example, to set the wrap margin to two characters, you would type this: <b>:set wm = 2</b></td></tr>
<tr><td>8</td><td><b>:set ro</b>
Changes file type to "read only"</td></tr>
<tr><td>9</td><td><b>:set term</b>
Prints terminal type</td></tr>
<tr><td>10</td><td><b>:set bf</b>
Discards control characters from input</td></tr>
</table>
<h2>&emsp;Running Commands</h2>
The vi has the capability to run commands from within the editor. 
To run a command, you only need to go to the command mode and type <b>:!</b> command.
For example, if you want to check whether a file exists before you try to save your file with that filename, you can type <b>:! ls</b> and you will see the output of <b>ls</b> on the screen.
You can press any key (or the command's escape sequence) to return to your vi session.
<h2>&emsp;Replacing Text</h2>
The substitution command (<b>:s/</b>) enables you to quickly replace words or groups of words within your files. 
Following is the syntax to replace text -
:s/search/replace/g

The <b>g</b> stands for globally. 
The result of this command is that all occurrences on the cursor's line are changed.
<h2>&emsp;Important Points to Note</h2>
The following points will add to your success with vi -
You must be in command mode to use the commands. 
(Press Esc twice at any time to ensure that you are in command mode.)
You must be careful with the commands. 
These are case-sensitive.
You must be in insert mode to enter text.

<h2><span class="orange">Unix - What is Shells?</span></h2>
A <b>Shell</b> provides you with an interface to the Unix system. 
It gathers input from you and executes programs based on that input. 
When a program finishes executing, it displays that program's output.
Shell is an environment in which we can run our commands, programs, and shell scripts. 
There are different flavors of a shell, just as there are different flavors of operating systems. 
Each flavor of shell has its own set of recognized commands and functions.
<h2>&emsp;Shell Prompt</h2>
The prompt, <b>$</b>, which is called the <b>command prompt</b>, is issued by the shell. 
While the prompt is displayed, you can type a command.
Shell reads your input after you press <b>Enter</b>. 
It determines the command you want executed by looking at the first word of your input. 
A word is an unbroken set of characters. 
Spaces and tabs separate words.
Following is a simple example of the <b>date</b> command, which displays the current date and time -
$date
Thu Jun 25 08:30:19 MST 2009

You can customize your command prompt using the environment variable PS1 explained in the Environment tutorial.
<h2>&emsp;Shell Types</h2>
In Unix, there are two major types of shells -
<b>Bourne shell</b> - If you are using a Bourne-type shell, the <b>$</b> character is the default prompt.
<b>C shell</b> - If you are using a C-type shell, the % character is the default prompt.

The Bourne Shell has the following subcategories -
Bourne shell (sh)
Korn shell (ksh)
Bourne Again shell (bash)
POSIX shell (sh)

The different C-type shells follow -
C shell (csh)
TENEX/TOPS C shell (tcsh)

The original Unix shell was written in the mid-1970s by Stephen R. 
Bourne while he was at the AT&amp;T Bell Labs in New Jersey.
Bourne shell was the first shell to appear on Unix systems, thus it is referred to as "the shell".
Bourne shell is usually installed as <b>/bin/sh</b> on most versions of Unix. 
For this reason, it is the shell of choice for writing scripts that can be used on different versions of Unix.
In this chapter, we are going to cover most of the Shell concepts that are based on the Borne Shell.
<h2>&emsp;Shell Scripts</h2>
The basic concept of a shell script is a list of commands, which are listed in the order of execution. 
A good shell script will have comments, preceded by <b>#</b> sign, describing the steps.
There are conditional tests, such as value A is greater than value B, loops allowing us to go through massive amounts of data, files to read and store data, and variables to read and store data, and the script may include functions.
We are going to write many scripts in the next sections. 
It would be a simple text file in which we would put all our commands and several other required constructs that tell the shell environment what to do and when to do it.
Shell scripts and functions are both interpreted. 
This means they are not compiled.
<h2>&emsp;Example Script</h2>
Assume we create a <b>test.sh</b> script. 
Note all the scripts would have the <b>.sh</b> extension. 
Before you add anything else to your script, you need to alert the system that a shell script is being started. 
This is done using the <b>shebang</b> construct. 
For example -
#!/bin/sh

This tells the system that the commands that follow are to be executed by the Bourne shell. 
<i>It's called a shebang because the <b>#</b> symbol is called a hash, and the ! symbol is called a bang</i>.
To create a script containing these commands, you put the shebang line first and then add the commands -
#!/bin/bash
pwd
ls

<h2>&emsp;Shell Comments</h2>
You can put your comments in your script as follows -
#!/bin/bash
# Author : Zara Ali
# Copyright (c) Tutorialspoint.com
# Script follows here:
pwd
ls

Save the above content and make the script executable -
$chmod +x test.sh

The shell script is now ready to be executed -
$./test.sh

Upon execution, you will receive the following result -
/home/amrood
index.htm  unix-basic_utilities.htm  unix-directories.htm  
test.sh    unix-communication.htm    unix-environment.htm

<b>Note</b> - To execute a program available in the current directory, use <b>./program_name</b>
<h2>&emsp;Extended Shell Scripts</h2>
Shell scripts have several required constructs that tell the shell environment what to do and when to do it. 
Of course, most scripts are more complex than the above one.
The shell is, after all, a real programming language, complete with variables, control structures, and so forth. 
No matter how complicated a script gets, it is still just a list of commands executed sequentially.
The following script uses the <b>read</b> command which takes the input from the keyboard and assigns it as the value of the variable PERSON and finally prints it on STDOUT.

#!/bin/sh
# Author : Zara Ali
# Copyright (c) Tutorialspoint.com
# Script follows here:
echo "What is your name?"
read PERSON
echo "Hello, $PERSON"

Here is a sample run of the script -
$./test.sh
What is your name?
Zara Ali
Hello, Zara Ali
$

<h2><span class="orange">Unix - Using Shell Variables</span></h2>
In this chapter, we will learn how to use Shell variables in Unix. 
A variable is a character string to which we assign a value. 
The value assigned could be a number, text, filename, device, or any other type of data.
A variable is nothing more than a pointer to the actual data. 
The shell enables you to create, assign, and delete variables.
<h2>&emsp;Variable Names</h2>
The name of a variable can contain only letters (a to z or A to Z), numbers ( 0 to 9) or the underscore character ( _).
By convention, Unix shell variables will have their names in UPPERCASE.
The following examples are valid variable names -
_ALI
TOKEN_A
VAR_1
VAR_2

Following are the examples of invalid variable names -
2_VAR
-VARIABLE
VAR1-VAR2
VAR_A!

The reason you cannot use other characters such as <b>!</b>, <b>*</b>, or <b>-</b> is that these characters have a special meaning for the shell.
<h2>&emsp;Defining Variables</h2>
Variables are defined as follows -
variable_name=variable_value

For example -
NAME="Zara Ali"

The above example defines the variable NAME and assigns the value "Zara Ali" to it. 
Variables of this type are called <b>scalar variables</b>. 
A scalar variable can hold only one value at a time.
Shell enables you to store any value you want in a variable. 
For example -
VAR1="Zara Ali"
VAR2=100

<h2>&emsp;Accessing Values</h2>
To access the value stored in a variable, prefix its name with the dollar sign (<b>$</b>) -
For example, the following script will access the value of defined variable NAME and print it on STDOUT -
<a href="http://tpcg.io/AP7zgT" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

#!/bin/sh
NAME="Zara Ali"
echo $NAME

The above script will produce the following value -
Zara Ali

<h2>&emsp;Read-only Variables</h2>
Shell provides a way to mark variables as read-only by using the read-only command. 
After a variable is marked read-only, its value cannot be changed.
For example, the following script generates an error while trying to change the value of NAME -
<a href="http://tpcg.io/tawT1C" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

#!/bin/sh
NAME="Zara Ali"
readonly NAME
NAME="Qadiri"

The above script will generate the following result -
/bin/sh: NAME: This variable is read only.

<h2>&emsp;Unsetting Variables</h2>
Unsetting or deleting a variable directs the shell to remove the variable from the list of variables that it tracks. 
Once you unset a variable, you cannot access the stored value in the variable.
Following is the syntax to unset a defined variable using the <b>unset</b> command -
unset variable_name

The above command unsets the value of a defined variable. 
Here is a simple example that demonstrates how the command works -
#!/bin/sh
NAME="Zara Ali"
unset NAME
echo $NAME

The above example does not print anything. 
You cannot use the unset command to <b>unset</b> variables that are marked <b>readonly</b>.
<h2>&emsp;Variable Types</h2>
When a shell is running, three main types of variables are present -
<b>Local Variables</b> - A local variable is a variable that is present within the current instance of the shell. 
It is not available to programs that are started by the shell. 
They are set at the command prompt.
<b>Environment Variables</b> - An environment variable is available to any child process of the shell. 
Some programs need environment variables in order to function correctly. 
Usually, a shell script defines only those environment variables that are needed by the programs that it runs.
<b>Shell Variables</b> - A shell variable is a special variable that is set by the shell and is required by the shell in order to function correctly. 
Some of these variables are environment variables whereas others are local variables.

<h2><span class="orange">Unix - Special Variables</span></h2>
In this chapter, we will discuss in detail about special variable in Unix. 
In one of our previous chapters, we understood how to be careful when we use certain nonalphanumeric characters in variable names. 
This is because those characters are used in the names of special Unix variables. 
These variables are reserved for specific functions.
For example, the <b>$</b> character represents the process ID number, or PID, of the current shell -
$echo $$

The above command writes the PID of the current shell -
29949

The following table shows a number of special variables that you can use in your shell scripts -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Variable &amp; Description</th></tr>
<tr><td>1</td><td><b>$0</b>
The filename of the current script.</td></tr>
<tr><td>2</td><td><b>$n</b>
These variables correspond to the arguments with which a script was invoked. 
Here <b>n</b> is a positive decimal number corresponding to the position of an argument (the first argument is $1, the second argument is $2, and so on).</td></tr>
<tr><td>3</td><td><b>$#</b>
The number of arguments supplied to a script.</td></tr>
<tr><td>4</td><td><b>$*</b>
All the arguments are double quoted. 
If a script receives two arguments, $* is equivalent to $1 $2.</td></tr>
<tr><td>5</td><td><b>$@</b>
All the arguments are individually double quoted. 
If a script receives two arguments, $@ is equivalent to $1 $2.</td></tr>
<tr><td>6</td><td><b>$?</b>
The exit status of the last command executed.</td></tr>
<tr><td>7</td><td><b>$$</b>
The process number of the current shell. 
For shell scripts, this is the process ID under which they are executing.</td></tr>
<tr><td>8</td><td><b>$!</b>
The process number of the last background command.</td></tr>
</table>
<h2>&emsp;Command-Line Arguments</h2>
The command-line arguments $1, $2, $3, ...$9 are positional parameters, with $0 pointing to the actual command, program, shell script, or function and $1, $2, $3, ...$9 as the arguments to the command.
Following script uses various special variables related to the command line -
#!/bin/sh
echo "File Name: $0"
echo "First Parameter : $1"
echo "Second Parameter : $2"
echo "Quoted Values: $@"
echo "Quoted Values: $*"
echo "Total Number of Parameters : $#"

Here is a sample run for the above script -
$./test.sh Zara Ali
File Name : ./test.sh
First Parameter : Zara
Second Parameter : Ali
Quoted Values: Zara Ali
Quoted Values: Zara Ali
Total Number of Parameters : 2

<h2>&emsp;Special Parameters $* and $@</h2>
There are special parameters that allow accessing all the command-line arguments at once. 
<b>$*</b> and <b>$@</b> both will act the same unless they are enclosed in double quotes, <b>""</b>.
Both the parameters specify the command-line arguments. 
However, the "$*" special parameter takes the entire list as one argument with spaces between and the "$@" special parameter takes the entire list and separates it into separate arguments.
We can write the shell script as shown below to process an unknown number of commandline arguments with either the $* or $@ special parameters -
#!/bin/sh
for TOKEN in $*
do
   echo $TOKEN
done

Here is a sample run for the above script -
$./test.sh Zara Ali 10 Years Old
Zara
Ali
10
Years
Old

<b>Note</b> - Here <b>do...done</b> is a kind of loop that will be covered in a subsequent tutorial.
<h2>&emsp;Exit Status</h2>
The <b>$?</b> variable represents the exit status of the previous command.
Exit status is a numerical value returned by every command upon its completion. 
As a rule, most commands return an exit status of 0 if they were successful, and 1 if they were unsuccessful.
Some commands return additional exit statuses for particular reasons. 
For example, some commands differentiate between kinds of errors and will return various exit values depending on the specific type of failure.
Following is the example of successful command -
$./test.sh Zara Ali
File Name : ./test.sh
First Parameter : Zara
Second Parameter : Ali
Quoted Values: Zara Ali
Quoted Values: Zara Ali
Total Number of Parameters : 2
$echo $?
0
$

<h2><span class="orange">Unix - Using Shell Arrays</span></h2>
In this chapter, we will discuss how to use shell arrays in Unix. 
A shell variable is capable enough to hold a single value. 
These variables are called scalar variables.
Shell supports a different type of variable called an <b>array variable</b>. 
This can hold multiple values at the same time. 
Arrays provide a method of grouping a set of variables. 
Instead of creating a new name for each variable that is required, you can use a single array variable that stores all the other variables.
All the naming rules discussed for Shell Variables would be applicable while naming arrays.
<h2>&emsp;Defining Array Values</h2>
The difference between an array variable and a scalar variable can be explained as follows.
Suppose you are trying to represent the names of various students as a set of variables. 
Each of the individual variables is a scalar variable as follows -
NAME01="Zara"
NAME02="Qadir"
NAME03="Mahnaz"
NAME04="Ayan"
NAME05="Daisy"

We can use a single array to store all the above mentioned names. 
Following is the simplest method of creating an array variable. 
This helps assign a value to one of its indices.

array_name[index]=value

Here <i>array_name</i> is the name of the array, <i>index</i> is the index of the item in the array that you want to set, and value is the value you want to set for that item.
As an example, the following commands -
NAME[0]="Zara"
NAME[1]="Qadir"
NAME[2]="Mahnaz"
NAME[3]="Ayan"
NAME[4]="Daisy"

If you are using the <b>ksh</b> shell, here is the syntax of array initialization -
set -A array_name value1 value2 ... 
valuen

If you are using the <b>bash</b> shell, here is the syntax of array initialization -
array_name=(value1 ... 
valuen)

<h2>&emsp;Accessing Array Values</h2>
After you have set any array variable, you access it as follows -
${array_name[index]}

Here <i>array_name</i> is the name of the array, and <i>index</i> is the index of the value to be accessed. 
Following is an example to understand the concept -
<a href="http://tpcg.io/AMsECl" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

#!/bin/sh
NAME[0]="Zara"
NAME[1]="Qadir"
NAME[2]="Mahnaz"
NAME[3]="Ayan"
NAME[4]="Daisy"
echo "First Index: ${NAME[0]}"
echo "Second Index: ${NAME[1]}"

The above example will generate the following result -
$./test.sh
First Index: Zara
Second Index: Qadir

You can access all the items in an array in one of the following ways -
${array_name[*]}
${array_name[@]}

Here <b>array_name</b> is the name of the array you are interested in. 
Following example will help you understand the concept -
<a href="http://tpcg.io/r8Dol0" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

#!/bin/sh
NAME[0]="Zara"
NAME[1]="Qadir"
NAME[2]="Mahnaz"
NAME[3]="Ayan"
NAME[4]="Daisy"
echo "First Method: ${NAME[*]}"
echo "Second Method: ${NAME[@]}"

The above example will generate the following result -
$./test.sh
First Method: Zara Qadir Mahnaz Ayan Daisy
Second Method: Zara Qadir Mahnaz Ayan Daisy

<h2><span class="orange">Unix - Shell Basic Operators</span></h2>
There are various operators supported by each shell. 
We will discuss in detail about Bourne shell (default shell) in this chapter.
We will now discuss the following operators -
Arithmetic Operators
Relational Operators
Boolean Operators
String Operators
File Test Operators

Bourne shell didn't originally have any mechanism to perform simple arithmetic operations but it uses external programs, either <b>awk</b> or <b>expr</b>.
The following example shows how to add two numbers -
<a href="http://tpcg.io/zURE2C" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

#!/bin/sh
val=`expr 2 + 2`
echo "Total value : $val"

The above script will generate the following result -
Total value : 4

The following points need to be considered while adding -
There must be spaces between operators and expressions. 
For example, 2&amp;plus;2 is not correct; it should be written as 2 &amp;plus; 2.
The complete expression should be enclosed between <b>‘ ‘</b>, called the backtick.

<h2>&emsp;Arithmetic Operators</h2>
The following arithmetic operators are supported by Bourne Shell.
Assume variable <b>a</b> holds 10 and variable <b>b</b> holds 20 then -
<a href="/unix/unix-arithmetic-operators.htm">Show Examples</a>
<table class="table table-bordered">
<tr><th style="text-align:center;width:23%">Operator</th>
<th style="text-align:center;width:50%">Description</th>
<th style="text-align:center;width:40%">Example</th></tr>
<tr><td>&amp;plus; (Addition)</td><td>Adds values on either side of the operator</td><td>`expr $a &amp;plus; $b` will give 30</td></tr>
<tr><td>- (Subtraction)</td><td>Subtracts right hand operand from left hand operand</td><td>`expr $a - $b` will give -10</td></tr>
<tr><td>* (Multiplication)</td><td>Multiplies values on either side of the operator</td><td>`expr $a \* $b` will give 200</td></tr>
<tr><td>/ (Division)</td><td>Divides left hand operand by right hand operand</td><td>`expr $b / $a` will give 2</td></tr>
<tr><td>% (Modulus)</td><td>Divides left hand operand by right hand operand and returns remainder</td><td>`expr $b % $a` will give 0</td></tr>
<tr><td>= (Assignment)</td>
<td style="vertical-align:middle;">Assigns right operand in left operand</td><td>a = $b would assign value of b into a</td></tr>
<tr><td>== (Equality)</td><td>Compares two numbers, if both are same then returns true.</td><td>[ $a == $b ] would return false.</td></tr>
<tr><td>!= (Not Equality)</td><td>Compares two numbers, if both are different then returns true.</td><td>[ $a != $b ] would return true.</td></tr>
</table>
It is very important to understand that all the conditional expressions should be inside square braces with spaces around them, for example <b>[ $a == $b ]</b> is correct whereas, <b>[$a==$b]</b> is incorrect.
All the arithmetical calculations are done using long integers.
<h2>&emsp;Relational Operators</h2>
Bourne Shell supports the following relational operators that are specific to numeric values. 
These operators do not work for string values unless their value is numeric.
For example, following operators will work to check a relation between 10 and 20 as well as in between "10" and "20" but not in between "ten" and "twenty".
Assume variable <b>a</b> holds 10 and variable <b>b</b> holds 20 then -
<a href="/unix/unix-relational-operators.htm">Show Examples</a>
<table class="table table-bordered">
<tr><th>Operator</th><th>Description</th>
<th style="text-align:center;width:25%">Example</th></tr>
<tr><td><b>-eq</b></td><td>Checks if the value of two operands are equal or not; if yes, then the condition becomes true.</td><td>[ $a -eq $b ] is not true.</td></tr>
<tr><td><b>-ne</b></td><td>Checks if the value of two operands are equal or not; if values are not equal, then the condition becomes true.</td>
<td style="vertical-align:middle;">[ $a -ne $b ] is true.</td></tr>
<tr><td><b>-gt</b></td><td>Checks if the value of left operand is greater than the value of right operand; if yes, then the condition becomes true.</td>
<td style="vertical-align:middle;">[ $a -gt $b ] is not true.</td></tr>
<tr><td><b>-lt</b></td><td>Checks if the value of left operand is less than the value of right operand; if yes, then the condition becomes true.</td>
<td style="vertical-align:middle;">[ $a -lt $b ] is true.</td></tr>
<tr><td><b>-ge</b></td><td>Checks if the value of left operand is greater than or equal to the value of right operand; if yes, then the condition becomes true.</td>
<td style="vertical-align:middle;">[ $a -ge $b ] is not true.</td></tr>
<tr><td><b>-le</b></td><td>Checks if the value of left operand is less than or equal to the value of right operand; if yes, then the condition becomes true.</td>
<td style="vertical-align:middle;">[ $a -le $b ] is true.</td></tr>
</table>
It is very important to understand that all the conditional expressions should be placed inside square braces with spaces around them. 
For example, <b>[ $a &lt;= $b ]</b> is correct whereas, <b>[$a &lt;= $b]</b> is incorrect.
<h2>&emsp;Boolean Operators</h2>
The following Boolean operators are supported by the Bourne Shell. 

Assume variable <b>a</b> holds 10 and variable <b>b</b> holds 20 then -
<a href="/unix/unix-boolean-operators.htm">Show Examples</a>
<table class="table table-bordered">
<tr><th>Operator</th><th>Description</th>
<th style="text-align:center;width:25%">Example</th></tr>
<tr><td><b>!</b></td><td>This is logical negation. 
This inverts a true condition into false and vice versa.</td>
<td style="vertical-align:middle;">[ ! false  ] is true.</td></tr>
<tr><td><b>-o</b></td><td>This is logical <b>OR</b>. 
If one of the operands is true, then the condition becomes true.</td><td>[  $a -lt 20  -o $b -gt 100 ] is true.</td></tr>
<tr><td><b>-a</b></td><td>This is logical <b>AND</b>. 
If both the operands are true, then the condition becomes true otherwise false.</td>
<td style="vertical-align:middle;">[  $a -lt 20  -a $b -gt 100 ] is false. 
</td></tr>
</table>
<h2>&emsp;String Operators</h2>
The following string operators are supported by Bourne Shell.
Assume variable <b>a</b> holds "abc" and variable <b>b</b> holds "efg" then -
<a href="/unix/unix-string-operators.htm">Show Examples</a>
<table class="table table-bordered">
<tr><th>Operator</th><th>Description</th>
<th style="text-align:center;width:30%">Example</th></tr>
<tr><td><b>=</b></td><td>Checks if the value of two operands are equal or not; if yes, then the condition becomes true.</td><td>[ $a = $b ] is not true.</td></tr>
<tr><td><b>!=</b></td><td>Checks if the value of two operands are equal or not; if values are not equal then the condition becomes true.</td><td>[ $a != $b ] is true.</td></tr>
<tr><td><b>-z</b></td><td>Checks if the given string operand size is zero; if it is zero length, then it returns true.</td><td>[ -z $a ] is not true.</td></tr>
<tr><td><b>-n</b></td><td>Checks if the given string operand size is non-zero; if it is nonzero length, then it returns true.</td><td>[ -n $a ] is not false.</td></tr>
<tr><td><b>str</b></td><td>Checks if <b>str</b> is not the empty string; if it is empty, then it returns false.</td><td>[ $a ] is not false.</td></tr>
</table>
<h2>&emsp;File Test Operators</h2>
We have a few operators that can be used to test various properties associated with a Unix file.
Assume a variable <b>file</b> holds an existing file name "test" the size of which is 100 bytes and has <b>read</b>, <b>write</b> and <b>execute</b> permission on -
<a href="/unix/unix-file-operators.htm">Show Examples</a>
<table class="table table-bordered">
<tr><th>Operator</th><th>Description</th>
<th style="text-align:center;width:29%">Example</th></tr>
<tr><td><b>-b file</b></td><td>Checks if file is a block special file; if yes, then the condition becomes true.</td><td>[ -b $file ] is  false.</td></tr>
<tr><td><b>-c file</b></td><td>Checks if file is a character special file; if yes, then the condition becomes true.</td><td>[ -c $file ] is  false.</td></tr>
<tr><td><b>-d file</b></td><td>Checks if file is a directory; if yes, then the condition becomes true.</td><td>[ -d $file ] is not true.</td></tr>
<tr><td><b>-f file</b></td><td>Checks if file is an ordinary file as opposed to a directory or special file; if yes, then the condition becomes true.</td><td>[ -f $file ] is  true.</td></tr>
<tr><td><b>-g file</b></td><td>Checks if file has its set group ID (SGID) bit set; if yes, then the condition becomes true.</td><td>[ -g $file ] is  false.</td></tr>
<tr><td><b>-k file</b></td><td>Checks if file has its sticky bit set; if yes, then the condition becomes true.</td><td>[ -k $file ] is  false.</td></tr>
<tr><td><b>-p file</b></td><td>Checks if file is a named pipe; if yes, then the condition becomes true.</td><td>[ -p $file ] is  false.</td></tr>
<tr><td><b>-t file</b></td><td>Checks if file descriptor is open and associated with a terminal; if yes, then the condition becomes true.</td><td>[ -t $file ] is  false.</td></tr>
<tr><td><b>-u file</b></td><td>Checks if file has its Set User ID (SUID) bit set; if yes, then the condition becomes true.</td><td>[ -u $file ] is  false.</td></tr>
<tr><td><b>-r file</b></td><td>Checks if file is readable; if yes, then the condition becomes true.</td><td>[ -r $file ] is  true.</td></tr>
<tr><td><b>-w file</b></td><td>Checks if file is writable; if yes, then the condition becomes true.</td><td>[ -w $file ] is  true.</td></tr>
<tr><td><b>-x file</b></td><td>Checks if file is executable; if yes, then the condition becomes true.</td><td>[ -x $file ] is  true.</td></tr>
<tr><td><b>-s file</b></td><td>Checks if file has size greater than 0; if yes, then condition becomes true.</td><td>[ -s $file ] is true.</td></tr>
<tr><td><b>-e file</b></td><td>Checks if file exists; is true even if file is a directory but exists.</td><td>[ -e $file ] is true.</td></tr>
</table>
<h2>&emsp;C Shell Operators</h2>
Following link will give you a brief idea on C Shell Operators -
<a href="/unix/unix-c-shell-operators.htm">C Shell Operators</a>
<h2>&emsp;Korn Shell Operators</h2>
Following link helps you understand Korn Shell Operators -
<a href="/unix/unix-korn-shell-operators.htm">Korn Shell Operators</a>
<h2><span class="orange">Unix - Shell Decision Making</span></h2>
In this chapter, we will understand shell decision-making in Unix. 
While writing a shell script, there may be a situation when you need to adopt one path out of the given two paths. 
So you need to make use of conditional statements that allow your program to make correct decisions and perform the right actions.
Unix Shell supports conditional statements which are used to perform different actions based on different conditions. 
We will now understand two decision-making statements here -
The <b>if...else</b> statement
The <b>case...esac</b> statement

<h2>&emsp;The if...else statements</h2>
If else statements are useful decision-making statements which can be used to select an option from a given set of options.
Unix Shell supports following forms of <b>if…else</b> statement -
<a href="/unix/if-fi-statement.htm">if...fi statement</a>
<a href="/unix/if-else-statement.htm">if...else...fi statement</a>
<a href="/unix/if-elif-statement.htm">if...elif...else...fi statement</a>

Most of the if statements check relations using relational operators discussed in the previous chapter.
<h2>&emsp;The case...esac Statement</h2>
You can use multiple <b>if...elif</b> statements to perform a multiway branch. 
However, this is not always the best solution, especially when all of the branches depend on the value of a single variable.
Unix Shell supports <b>case...esac</b> statement which handles exactly this situation, and it does so more efficiently than repeated <b>if...elif</b> statements.
There is only one form of <b>case...esac</b> statement which has been described in detail here -
<a href="/unix/case-esac-statement.htm">case...esac statement</a>

The <b>case...esac</b> statement in the Unix shell is very similar to the <b>switch...case</b> statement we have in other programming languages like <b>C</b> or <b>C++</b> and <b>PERL</b>, etc.
<h2><span class="orange">Unix - Shell Loop Types</span></h2>
In this chapter, we will discuss shell loops in Unix. 
A loop is a powerful programming tool that enables you to execute a set of commands repeatedly. 
In this chapter, we will examine the following types of loops available to shell programmers -
<a href="/unix/while-loop.htm">The while loop</a>
<a href="/unix/for-loop.htm">The for loop</a>
<a href="/unix/until-loop.htm">The until loop</a>
<a href="/unix/select-loop.htm">The select loop</a>

You will use different loops based on the situation. 
For example, the <b>while</b> loop executes the given commands until the given condition remains true; the <b>until</b> loop executes until a given condition becomes true.
Once you have good programming practice you will gain the expertise and thereby, start using appropriate loop based on the situation. 
Here, <b>while</b> and <b>for</b> loops are available in most of the other programming languages like <b>C</b>, <b>C++</b> and <b>PERL</b>, etc.
<h2>&emsp;Nesting Loops</h2>
All the loops support nesting concept which means you can put one loop inside another similar one or different loops. 
This nesting can go up to unlimited number of times based on your requirement.
Here is an example of nesting <b>while</b> loop. 
The other loops can be nested based on the programming requirement in a similar way -
<h2>&emsp;Nesting while Loops</h2>
It is possible to use a while loop as part of the body of another while loop.
<h3>Syntax</h3>

while command1 ; # this is loop1, the outer loop
do
   Statement(s) to be executed if command1 is true
   while command2 ; # this is loop2, the inner loop
   do
      Statement(s) to be executed if command2 is true
   done
   Statement(s) to be executed if command1 is true
done

<h3>Example</h3>
Here is a simple example of loop nesting. 
Let's add another countdown loop inside the loop that you used to count to nine -
#!/bin/sh
a=0
while [ "$a" -lt 10 ]    # this is loop1
do
   b="$a"
   while [ "$b" -ge 0 ]  # this is loop2
   do
      echo -n "$b "
      b=`expr $b - 1`
   done
   echo
   a=`expr $a + 1`
done

This will produce the following result. 
It is important to note how <b>echo -n</b> works here. 
Here <b>-n</b> option lets echo avoid printing a new line character.

0
1 0
2 1 0
3 2 1 0
4 3 2 1 0
5 4 3 2 1 0
6 5 4 3 2 1 0
7 6 5 4 3 2 1 0
8 7 6 5 4 3 2 1 0
9 8 7 6 5 4 3 2 1 0

<h2><span class="orange">Unix - Shell Loop Control</span></h2>
In this chapter, we will discuss shell loop control in Unix. 
So far you have looked at creating loops and working with loops to accomplish different tasks. 
Sometimes you need to stop a loop or skip iterations of the loop.
In this chapter, we will learn following two statements that are used to control shell loops-
The <b>break</b> statement
The <b>continue</b> statement

<h2>&emsp;The infinite Loop</h2>
All the loops have a limited life and they come out once the condition is false or true depending on the loop.
A loop may continue forever if the required condition is not met. 
A loop that executes forever without terminating executes for an infinite number of times. 
For this reason, such loops are called infinite loops.
<h3>Example</h3>
Here is a simple example that uses the <b>while</b> loop to display the numbers zero to nine -
#!/bin/sh
a=10
until [ $a -lt 10 ]
do
   echo $a
   a=`expr $a + 1`
done

This loop continues forever because <b>a</b> is always <b>greater than</b> or <b>equal to 10</b> and it is never less than 10.
<h2>&emsp;The break Statement</h2>
The <b>break</b> statement is used to terminate the execution of the entire loop, after completing the execution of all of the lines of code up to the break statement. 
It then steps down to the code following the end of the loop.
<h3>Syntax</h3>
The following <b>break</b> statement is used to come out of a loop -
break

The break command can also be used to exit from a nested loop using this format -
break n

Here <b>n</b> specifies the <b>n<sup>th</sup></b> enclosing loop to the exit from.
<h3>Example</h3>
Here is a simple example which shows that loop terminates as soon as <b>a</b> becomes 5 -
#!/bin/sh
a=0
while [ $a -lt 10 ]
do
   echo $a
   if [ $a -eq 5 ]
   then
      break
   fi
   a=`expr $a + 1`
done

Upon execution, you will receive the following result -
0
1
2
3
4
5

Here is a simple example of nested for loop. 
This script breaks out of both loops if <b>var1 equals 2</b> and <b>var2 equals 0</b> -
<a href="http://tpcg.io/NcYiyO" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

#!/bin/sh
for var1 in 1 2 3
do
   for var2 in 0 5
   do
      if [ $var1 -eq 2 -a $var2 -eq 0 ]
      then
         break 2
      else
         echo "$var1 $var2"
      fi
   done
done

Upon execution, you will receive the following result. 
In the inner loop, you have a break command with the argument 2. 
This indicates that if a condition is met you should break out of outer loop and ultimately from the inner loop as well.

1 0
1 5

<h2>&emsp;The continue statement</h2>
The <b>continue</b> statement is similar to the <b>break</b> command, except that it causes the current iteration of the loop to exit, rather than the entire loop.
This statement is useful when an error has occurred but you want to try to execute the next iteration of the loop.
<h3>Syntax</h3>

continue

Like with the break statement, an integer argument can be given to the continue command to skip commands from nested loops.

continue n

Here <b>n</b> specifies the <b>n<sup>th</sup></b> enclosing loop to continue from.
<h3>Example</h3>
The following loop makes use of the <b>continue</b> statement which returns from the continue statement and starts processing the next statement -
<a href="http://tpcg.io/SN4DzV" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

#!/bin/sh
NUMS="1 2 3 4 5 6 7"
for NUM in $NUMS
do
   Q=`expr $NUM % 2`
   if [ $Q -eq 0 ]
   then
      echo "Number is an even number!!"
      continue
   fi
   echo "Found odd number"
done

Upon execution, you will receive the following result -
Found odd number
Number is an even number!!
Found odd number
Number is an even number!!
Found odd number
Number is an even number!!
Found odd number

<h2><span class="orange">Unix - Shell Substitution</span></h2>
<h2>&emsp;What is Substitution?</h2>
The shell performs substitution when it encounters an expression that contains one or more special characters.
<h3>Example</h3>
Here, the printing value of the variable is substituted by its value. 
Same time, <b>"\n"</b> is substituted by a new line -
<a href="http://tpcg.io/OFDBZ1" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

#!/bin/sh
a=10
echo -e "Value of a is $a \n"

You will receive the following result. 
Here the <b>-e</b> option enables the interpretation of backslash escapes.

Value of a is 10

Following is the result without <b>-e</b> option -
Value of a is 10\n

Here are following escape sequences which can be used in echo command -
<table class="table table-bordered">
<tr><th style="text-align:center;width:7%">Sr.No.</th><th>Escape &amp; Description</th></tr>
<tr><td>1</td><td><b>\\</b>
backslash</td></tr>
<tr><td>2</td><td><b>\a</b>
alert (BEL)</td></tr>
<tr><td>3</td><td><b>\b</b>
backspace</td></tr>
<tr><td>4</td><td><b>\c </b>
suppress trailing newline</td></tr>
<tr><td>5</td><td><b>\f </b>
form feed</td></tr>
<tr><td>6</td><td><b>\n</b>
new line</td></tr>
<tr><td>7</td><td><b>\r</b>
carriage return</td></tr>
<tr><td>8</td><td><b>\t </b>
horizontal tab</td></tr>
<tr><td>9</td><td><b>\v </b>
vertical tab</td></tr>
</table>
You can use the <b>-E</b> option to disable the interpretation of the backslash escapes (default).
You can use the <b>-n</b> option to disable the insertion of a new line.
<h2>&emsp;Command Substitution</h2>
Command substitution is the mechanism by which the shell performs a given set of commands and then substitutes their output in the place of the commands.
<h3>Syntax</h3>
The command substitution is performed when a command is given as -
`command`

When performing the command substitution make sure that you use the backquote, not the single quote character.
<h3>Example</h3>
Command substitution is generally used to assign the output of a command to a variable. 
Each of the following examples demonstrates the command substitution -
<a href="http://tpcg.io/YVfKUs" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

#!/bin/sh
DATE=`date`
echo "Date is $DATE"
USERS=`who | wc -l`
echo "Logged in user are $USERS"
UP=`date ; uptime`
echo "Uptime is $UP"

Upon execution, you will receive the following result -
Date is Thu Jul  2 03:59:57 MST 2009
Logged in user are 1
Uptime is Thu Jul  2 03:59:57 MST 2009
03:59:57 up 20 days, 14:03,  1 user,  load avg: 0.13, 0.07, 0.15

<h2>&emsp;Variable Substitution</h2>
Variable substitution enables the shell programmer to manipulate the value of a variable based on its state.
Here is the following table for all the possible substitutions -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Form &amp; Description</th></tr>
<tr><td>1</td><td><b>${var}</b>
Substitute the value of <i>var</i>.</td></tr>
<tr><td>2</td><td><b>${var:-word}</b>
If <i>var</i> is null or unset, <i>word</i> is substituted for <b>var</b>. 
The value of <i>var</i> does not change.</td></tr>
<tr><td>3</td><td><b>${var:=word}</b>
If <i>var</i> is null or unset, <i>var</i> is set to the value of <b>word</b>.</td></tr>
<tr><td>4</td><td><b>${var:?message}</b>
If <i>var</i> is null or unset, <i>message</i> is printed to standard error. 
This checks that variables are set correctly.</td></tr>
<tr><td>5</td><td><b>${var:&amp;plus;word}</b>
If <i>var</i> is set, <i>word</i> is substituted for var. 
The value of <i>var</i> does not change.</td></tr>
</table>
<h3>Example</h3>
Following is the example to show various states of the above substitution -
<a href="http://tpcg.io/5XMYM6" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

#!/bin/sh
echo ${var:-"Variable is not set"}
echo "1 - Value of var is ${var}"
echo ${var:="Variable is not set"}
echo "2 - Value of var is ${var}"
unset var
echo ${var:+"This is default value"}
echo "3 - Value of var is $var"
var="Prefix"
echo ${var:+"This is default value"}
echo "4 - Value of var is $var"
echo ${var:?"Print this message"}
echo "5 - Value of var is ${var}"

Upon execution, you will receive the following result -
Variable is not set
1 - Value of var is
Variable is not set
2 - Value of var is Variable is not set
3 - Value of var is
This is default value
4 - Value of var is Prefix
Prefix
5 - Value of var is Prefix

<h2><span class="orange">Unix - Shell Quoting Mechanisms</span></h2>
In this chapter, we will discuss in detail about the Shell quoting mechanisms. 
We will start by discussing the metacharacters.
<h2>&emsp;The Metacharacters</h2>
Unix Shell provides various metacharacters which have special meaning while using them in any Shell Script and causes termination of a word unless quoted.
For example, <b>?</b> matches with a single character while listing files in a directory and an <b>*</b> matches more than one character. 
Here is a list of most of the shell special characters (also called metacharacters) -
* ? [ ] ' " \ $ ; &amp; ( ) | ^ &lt; &gt; new-line space tab

A character may be quoted (i.e., made to stand for itself) by preceding it with a <b>\</b>.
<h3>Example</h3>
Following example shows how to print a <b>*</b> or a <b>?</b> -
<a href="http://tpcg.io/Zys0js" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

#!/bin/sh
echo Hello; Word

Upon execution, you will receive the following result -
Hello
./test.sh: line 2: Word: command not found
shell returned 127

Let us now try using a quoted character -
<a href="http://tpcg.io/NMnaJv" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

#!/bin/sh
echo Hello\; Word

Upon execution, you will receive the following result -
Hello; Word

The <b>$</b> sign is one of the metacharacters, so it must be quoted to avoid special handling by the shell -
<a href="http://tpcg.io/RdOwAg" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

#!/bin/sh
echo "I have \$1200"

Upon execution, you will receive the following result -
I have $1200

The following table lists the four forms of quoting -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Quoting &amp; Description</th></tr>
<tr><td>1</td><td><b>Single quote</b>
All special characters between these quotes lose their special meaning.</td></tr>
<tr><td>2</td><td><b>Double quote</b>
Most special characters between these quotes lose their special meaning with these exceptions -
$
`
\$
\'
\"
\\
</td></tr>
<tr><td>3</td><td><b>Backslash</b>
Any character immediately following the backslash loses its special meaning.</td></tr>
<tr><td>4</td><td><b>Back quote</b>
Anything in between back quotes would be treated as a command and would be executed.</td></tr>
</table>
<h2>&emsp;The Single Quotes</h2>
Consider an echo command that contains many special shell characters -
echo &lt;-$1500.**&gt;; (update?) [y|n]

Putting a backslash in front of each special character is tedious and makes the line difficult to read -
echo \&lt;-\$1500.\*\*\&gt;\; \(update\?\) \[y\|n\]

There is an easy way to quote a large group of characters. 
Put a single quote (') at the beginning and at the end of the string -
echo '&lt;-$1500.**&gt;; (update?) [y|n]'

Characters within single quotes are quoted just as if a backslash is in front of each character. 
With this, the echo command displays in a proper way.
If a single quote appears within a string to be output, you should not put the whole string within single quotes instead you should precede that using a backslash (\) as follows -
echo 'It\'s Shell Programming

<h2>&emsp;The Double Quotes</h2>
Try to execute the following shell script. 
This shell script makes use of single quote -
<a href="http://tpcg.io/U3IE2i" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

VAR=ZARA
echo '$VAR owes &lt;-$1500.**&gt;; [ as of (`date +%m/%d`) ]'

Upon execution, you will receive the following result -
$VAR owes &lt;-$1500.**&gt;; [ as of (`date +%m/%d`) ]

This is not what had to be displayed. 
It is obvious that single quotes prevent variable substitution. 
If you want to substitute variable values and to make inverted commas work as expected, then you would need to put your commands in double quotes as follows -
<a href="http://tpcg.io/5DzVN3" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

VAR=ZARA
echo "$VAR owes &lt;-\$1500.**&gt;; [ as of (`date +%m/%d`) ]"

Upon execution, you will receive the following result -
ZARA owes &lt;-$1500.**&gt;; [ as of (07/02) ]

Double quotes take away the special meaning of all characters except the following -
<b>$</b> for parameter substitution
Backquotes for command substitution
<b>\$</b> to enable literal dollar signs
<b>\`</b> to enable literal backquotes
<b>\"</b> to enable embedded double quotes
<b>\\</b> to enable embedded backslashes
All other <b>\</b> characters are literal (not special)

Characters within single quotes are quoted just as if a backslash is in front of each character. 
This helps the echo command display properly.
If a single quote appears within a string to be output, you should not put the whole string within single quotes instead you should precede that using a backslash (\) as follows -
echo 'It\'s Shell Programming'

<h2>&emsp;The Backquotes</h2>
Putting any Shell command in between <b>backquotes</b> executes the command.
<h3>Syntax</h3>
Here is the simple syntax to put any Shell <b>command</b> in between backquotes -
var=`command`

<h3>Example</h3>
The <b>date</b> command is executed in the following example and the produced result is stored in DATA variable.

<a href="http://tpcg.io/90knhD" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

DATE=`date`
echo "Current Date: $DATE"

Upon execution, you will receive the following result -
Current Date: Thu Jul  2 05:28:45 MST 2009

<h2><span class="orange">Unix - Shell Input/Output Redirections</span></h2>
In this chapter, we will discuss in detail about the Shell input/output redirections. 
Most Unix system commands take input from your terminal and send the resulting output back to your terminal. 
A command normally reads its input from the standard input, which happens to be your terminal by default. 
Similarly, a command normally writes its output to standard output, which is again your terminal by default.
<h2>&emsp;Output Redirection</h2>
The output from a command normally intended for standard output can be easily diverted to a file instead. 
This capability is known as output redirection.
If the notation &gt; file is appended to any command that normally writes its output to standard output, the output of that command will be written to file instead of your terminal.
Check the following <b>who</b> command which redirects the complete output of the command in the users file.

$ who &gt; users

Notice that no output appears at the terminal. 
This is because the output has been redirected from the default standard output device (the terminal) into the specified file. 
You can check the users file for the complete content -
$ cat users
oko         tty01   Sep 12 07:30
ai          tty15   Sep 12 13:32
ruth        tty21   Sep 12 10:10
pat         tty24   Sep 12 13:07
steve       tty25   Sep 12 13:03
$

If a command has its output redirected to a file and the file already contains some data, that data will be lost. 
Consider the following example -
$ echo line 1 &gt; users
$ cat users
line 1
$

You can use &gt;&gt; operator to append the output in an existing file as follows -
$ echo line 2 &gt;&gt; users
$ cat users
line 1
line 2
$

<h2>&emsp;Input Redirection</h2>
Just as the output of a command can be redirected to a file, so can the input of a command be redirected from a file. 
As the <b>greater-than character &gt;</b> is used for output redirection, the <b>less-than character &lt;</b> is used to redirect the input of a command.
The commands that normally take their input from the standard input can have their input redirected from a file in this manner. 
For example, to count the number of lines in the file <i>users</i> generated above, you can execute the command as follows -
$ wc -l users
2 users
$

Upon execution, you will receive the following output. 
You can count the number of lines in the file by redirecting the standard input of the <b>wc</b> command from the file <i>users</i> -
$ wc -l &lt; users
2
$

Note that there is a difference in the output produced by the two forms of the wc command. 
In the first case, the name of the file users is listed with the line count; in the second case, it is not.
In the first case, wc knows that it is reading its input from the file users. 
In the second case, it only knows that it is reading its input from standard input so it does not display file name.
<h2>&emsp;Here Document</h2>
A <b>here document</b> is used to redirect input into an interactive shell script or program.
We can run an interactive program within a shell script without user action by supplying the required input for the interactive program, or interactive shell script.
The general form for a <b>here</b> document is -
command &lt;&lt; delimiter
document
delimiter

Here the shell interprets the <b>&lt;&lt;</b> operator as an instruction to read input until it finds a line containing the specified delimiter. 
All the input lines up to the line containing the delimiter are then fed into the standard input of the command.
The delimiter tells the shell that the <b>here</b> document has completed. 
Without it, the shell continues to read the input forever. 
The delimiter must be a single word that does not contain spaces or tabs.
Following is the input to the command <b>wc -l</b> to count the total number of lines -
$wc -l &lt;&lt; EOF
   This is a simple lookup program 
for good (and bad) restaurants
in Cape Town.
EOF
3
$

You can use the <b>here document</b> to print multiple lines using your script as follows -
<a href="http://tpcg.io/o3GfEg" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

#!/bin/sh
cat &lt;&lt; EOF
This is a simple lookup program 
for good (and bad) restaurants
in Cape Town.
EOF

Upon execution, you will receive the following result -
This is a simple lookup program
for good (and bad) restaurants
in Cape Town.

The following script runs a session with the <b>vi</b> text editor and saves the input in the file <b>test.txt</b>.

#!/bin/sh
filename=test.txt
vi $filename &lt;&lt;EndOfCommands
i
This file was created automatically from
a shell script
^[
ZZ
EndOfCommands

If you run this script with vim acting as vi, then you will likely see output like the following -
$ sh test.sh
Vim: Warning: Input is not from a terminal
$

After running the script, you should see the following added to the file <b>test.txt</b> -
$ cat test.txt
This file was created automatically from
a shell script
$

<h2>&emsp;Discard the output</h2>
Sometimes you will need to execute a command, but you don't want the output displayed on the screen. 
In such cases, you can discard the output by redirecting it to the file <b>/dev/null</b> -
$ command &gt; /dev/null

Here command is the name of the command you want to execute. 
The file <b>/dev/null</b> is a special file that automatically discards all its input.
To discard both output of a command and its error output, use standard redirection to redirect <b>STDERR</b> to <b>STDOUT</b> -
$ command &gt; /dev/null 2&gt;&amp;1

Here <b>2</b> represents <b>STDERR</b> and <b>1</b> represents <b>STDOUT</b>. 
You can display a message on to STDERR by redirecting STDOUT into STDERR as follows -
$ echo message 1&gt;&amp;2

<h2>&emsp;Redirection Commands</h2>
Following is a complete list of commands which you can use for redirection -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Command &amp; Description</th></tr>
<tr><td>1</td><td><b>pgm &gt; file</b>
Output of pgm is redirected to file</td></tr>
<tr><td>2</td><td><b>pgm &lt; file</b>
Program pgm reads its input from file</td></tr>
<tr><td>3</td><td><b>pgm &gt;&gt; file</b>
Output of pgm is appended to file</td></tr>
<tr><td>4</td><td><b>n &gt; file</b>
Output from stream with descriptor <b>n</b> redirected to file</td></tr>
<tr><td>5</td><td><b>n &gt;&gt; file</b>
Output from stream with descriptor <b>n</b> appended to file</td></tr>
<tr><td>6</td><td><b>n &gt;&amp; m</b>
Merges output from stream <b>n</b> with stream <b>m</b></td></tr>
<tr><td>7</td><td><b>n &lt;&amp; m</b>
Merges input from stream <b>n</b> with stream <b>m</b></td></tr>
<tr><td>8</td><td><b>&lt;&lt; tag</b>
Standard input comes from here through next tag at the start of line</td></tr>
<tr><td>9</td><td><b>&amp;verbar;</b>
Takes output from one program, or process, and sends it to another</td></tr>
</table>
Note that the file descriptor <b>0</b> is normally standard input (STDIN), <b>1</b> is standard output (STDOUT), and <b>2</b> is standard error output (STDERR).
<h2><span class="orange">Unix - Shell Functions</span></h2>
In this chapter, we will discuss in detail about the shell functions. 
Functions enable you to break down the overall functionality of a script into smaller, logical subsections, which can then be called upon to perform their individual tasks when needed.
Using functions to perform repetitive tasks is an excellent way to create <b>code reuse</b>. 
This is an important part of modern object-oriented programming principles.
Shell functions are similar to subroutines, procedures, and functions in other programming languages.
<h2>&emsp;Creating Functions</h2>
To declare a function, simply use the following syntax -
function_name () { 
   list of commands
}

The name of your function is <b>function_name</b>, and that's what you will use to call it from elsewhere in your scripts. 
The function name must be followed by parentheses, followed by a list of commands enclosed within braces.
<h3>Example</h3>
Following example shows the use of function -
<a href="http://tpcg.io/o9dmTt" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

#!/bin/sh
# Define your function here
Hello () {
   echo "Hello World"
}
# Invoke your function
Hello

Upon execution, you will receive the following output -
$./test.sh
Hello World

<h2>&emsp;Pass Parameters to a Function</h2>
You can define a function that will accept parameters while calling the function. 
These parameters would be represented by <b>$1</b>, <b>$2</b> and so on.
Following is an example where we pass two parameters <i>Zara</i> and <i>Ali</i> and then we capture and print these parameters in the function.

<a href="http://tpcg.io/FOOm8P" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

#!/bin/sh
# Define your function here
Hello () {
   echo "Hello World $1 $2"
}
# Invoke your function
Hello Zara Ali

Upon execution, you will receive the following result -
$./test.sh
Hello World Zara Ali

<h2>&emsp;Returning Values from Functions</h2>
If you execute an <b>exit</b> command from inside a function, its effect is not only to terminate execution of the function but also of the shell program that called the function.
If you instead want to just terminate execution of the function, then there is way to come out of a defined function.
Based on the situation you can return any value from your function using the <b>return</b> command whose syntax is as follows -
return code

Here <b>code</b> can be anything you choose here, but obviously you should choose something that is meaningful or useful in the context of your script as a whole.
<h3>Example</h3>
Following function returns a value 10 -
<a href="http://tpcg.io/lVaJwM" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

#!/bin/sh
# Define your function here
Hello () {
   echo "Hello World $1 $2"
   return 10
}
# Invoke your function
Hello Zara Ali
# Capture value returnd by last command
ret=$?
echo "Return value is $ret"

Upon execution, you will receive the following result -
$./test.sh
Hello World Zara Ali
Return value is 10

<h2>&emsp;Nested Functions</h2>
One of the more interesting features of functions is that they can call themselves and also other functions. 
A function that calls itself is known as a <b><i>recursive function</i></b>.
Following example demonstrates nesting of two functions -
<a href="http://tpcg.io/ooh900" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>

#!/bin/sh
# Calling one function from another
number_one () {
   echo "This is the first function speaking..."
   number_two
}
number_two () {
   echo "This is now the second function speaking..."
}
# Calling function one.
number_one

Upon execution, you will receive the following result -
This is the first function speaking...
This is now the second function speaking...

<h2>&emsp;Function Call from Prompt</h2>
You can put definitions for commonly used functions inside your <b><i>.profile</i></b>. 
These definitions will be available whenever you log in and you can use them at the command prompt.
Alternatively, you can group the definitions in a file, say <b><i>test.sh</i></b>, and then execute the file in the current shell by typing -
$. 
test.sh

This has the effect of causing functions defined inside <b><i>test.sh</i></b> to be read and defined to the current shell as follows -
$ number_one
This is the first function speaking...
This is now the second function speaking...
$

To remove the definition of a function from the shell, use the unset command with the <b>.f</b> option. 
This command is also used to remove the definition of a variable to the shell.

$ unset -f function_name

<h2><span class="orange">Unix - Shell Manpage Help</span></h2>
All the Unix commands come with a number of optional and mandatory options. 
It is very common to forget the complete syntax of these commands.
 
Because no one can possibly remember every Unix command and all its options, we have online help available to mitigate this right from when Unix was at its development stage.
Unix's version of <b>Help files</b> are called <b>man pages</b>. 
If there is a command name and you are not sure how to use it, then Man Pages help you out with every step.
<h3>Syntax</h3>
Here is the simple command that helps you get the detail of any Unix command while working with the system -
$man command

<h3>Example</h3>
Suppose there is a command that requires you to get help; assume that you want to know about <b>pwd</b> then you simply need to use the following command -
$man pwd

The above command helps you with the complete information about the <b>pwd</b> command. 
Try it yourself at your command prompt to get more detail.
You can get complete detail on <b>man</b> command itself using the following command -
$man man

<h2>&emsp;Man Page Sections</h2>
Man pages are generally divided into sections, which generally vary by the man page author's preference. 
Following table lists some common sections -
 
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Section &amp; Description</th></tr>
<tr><td>1</td><td><b>NAME</b>
Name of the command</td></tr>
<tr><td>2</td><td><b>SYNOPSIS</b>
General usage parameters of the command</td></tr>
<tr><td>3</td><td><b>DESCRIPTION</b>
Describes what the command does</td></tr>
<tr><td>4</td><td><b>OPTIONS</b>
Describes all the arguments or options to the command</td></tr>
<tr><td>5</td><td><b>SEE ALSO</b>
Lists other commands that are directly related to the command in the man page or closely resemble its functionality</td></tr>
<tr><td>6</td><td><b>BUGS</b>
Explains any known issues or bugs that exist with the command or its output</td></tr>
<tr><td>7</td><td><b>EXAMPLES</b>
Common usage examples that give the reader an idea of how the command can be used</td></tr>
<tr><td>8</td><td><b>AUTHORS</b>
The author of the man page/command</td></tr>
</table>
To sum it up, man pages are a vital resource and the first avenue of research when you need information about commands or files in a Unix system.
<h2>&emsp;Useful Shell Commands</h2>
The following link gives you a list of the most important and very frequently used Unix Shell commands.
If you do not know how to use any command, then use man page to get complete detail about the command.
Here is the list of <a href="/unix/unix-useful-commands.htm">Unix Shell - Useful Commands</a>
<h2><span class="orange">Unix - Regular Expressions with SED</span></h2>
In this chapter, we will discuss in detail about regular expressions with SED in Unix.
A regular expression is a string that can be used to describe several sequences of characters. 
Regular expressions are used by several different Unix commands, including <b>ed</b>, <b>sed</b>, <b>awk</b>, <b>grep</b>, and to a more limited extent, <b>vi</b>.
Here <b>SED</b> stands for <b>s</b>tream <b>ed</b>itor. 
This stream-oriented editor was created exclusively for executing scripts. 
Thus, all the input you feed into it passes through and goes to STDOUT and it does not change the input file.
<h2>&emsp;Invoking sed</h2>
Before we start, let us ensure we have a local copy of <b>/etc/passwd</b> text file to work with <b>sed</b>.
As mentioned previously, sed can be invoked by sending data through a pipe to it as follows -
$ cat /etc/passwd | sed
Usage: sed [OPTION]... 
{script-other-script} [input-file]...
  -n, --quiet, --silent
                 suppress automatic printing of pattern space
  -e script, --expression = script
...............................

The <b>cat</b> command dumps the contents of <b>/etc/passwd</b> to <b>sed</b> through the pipe into sed's pattern space. 
The pattern space is the internal work buffer that sed uses for its operations.
<h2>&emsp;The sed General Syntax</h2>
Following is the general syntax for sed -
/pattern/action

Here, <b>pattern</b> is a regular expression, and <b>action</b> is one of the commands given in the following table. 
If <b>pattern</b> is omitted, <b>action</b> is performed for every line as we have seen above.
The slash character (/) that surrounds the pattern are required because they are used as delimiters.
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Range &amp; Description</th></tr>
<tr><td>1</td><td><b>p</b>
Prints the line</td></tr>
<tr><td>2</td><td><b>d</b>
Deletes the line</td></tr>
<tr><td>3</td><td><b>s/pattern1/pattern2/</b>
Substitutes the first occurrence of pattern1 with pattern2</td></tr>
</table>
<h2>&emsp;Deleting All Lines with sed</h2>
We will now understand how to delete all lines with sed. 
Invoke sed again; but the sed is now supposed to use the <b>editing command delete line</b>, denoted by the single letter <b>d</b> -
$ cat /etc/passwd | sed 'd'
$

Instead of invoking sed by sending a file to it through a pipe, the sed can be instructed to read the data from a file, as in the following example.
The following command does exactly the same as in the previous example, without the cat command -
$ sed -e 'd' /etc/passwd
$

<h2>&emsp;The sed Addresses</h2>
The sed also supports addresses. 
Addresses are either particular locations in a file or a range where a particular editing command should be applied. 
When the sed encounters no addresses, it performs its operations on every line in the file.
The following command adds a basic address to the sed command you've been using -
$ cat /etc/passwd | sed '1d' |more
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/bin/sh
man:x:6:12:man:/var/cache/man:/bin/sh
mail:x:8:8:mail:/var/mail:/bin/sh
news:x:9:9:news:/var/spool/news:/bin/sh
backup:x:34:34:backup:/var/backups:/bin/sh
$

Notice that the number 1 is added before the <b>delete edit</b> command. 
This instructs the sed to perform the editing command on the first line of the file. 
In this example, the sed will delete the first line of <b>/etc/password</b> and print the rest of the file.
<h2>&emsp;The sed Address Ranges</h2>
We will now understand how to work with <b>the sed address ranges</b>. 
So what if you want to remove more than one line from a file? You can specify an address range with sed as follows -
$ cat /etc/passwd | sed '1, 5d' |more
games:x:5:60:games:/usr/games:/bin/sh
man:x:6:12:man:/var/cache/man:/bin/sh
mail:x:8:8:mail:/var/mail:/bin/sh
news:x:9:9:news:/var/spool/news:/bin/sh
backup:x:34:34:backup:/var/backups:/bin/sh
$

The above command will be applied on all the lines starting from 1 through 5. 
This deletes the first five lines.
Try out the following address ranges -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Range &amp; Description</th></tr>
<tr><td>1</td><td><b>'4,10d'</b>
Lines starting from the 4<sup>th</sup> till the 10<sup>th</sup> are deleted</td></tr>
<tr><td>2</td><td><b>'10,4d'</b>
Only 10<sup>th</sup> line is deleted, because the sed does not work in reverse direction</td></tr>
<tr><td>3</td><td><b>'4,&amp;plus;5d'</b>
This matches line 4 in the file, deletes that line, continues to delete the next five lines, and then ceases its deletion and prints the rest</td></tr>
<tr><td>4</td><td><b>'2,5!d'</b>
This deletes everything except starting from 2<sup>nd</sup> till 5<sup>th</sup> line</td></tr>
<tr><td>5</td><td><b>'1~3d'</b>
This deletes the first line, steps over the next three lines, and then deletes the fourth line. 
Sed continues to apply this pattern until the end of the file.</td></tr>
<tr><td>6</td><td><b>'2~2d'</b>
This tells sed to delete the second line, step over the next line, delete the next line, and repeat until the end of the file is reached</td></tr>
<tr><td>7</td><td><b>'4,10p'</b>
Lines starting from 4<sup>th</sup> till 10<sup>th</sup> are printed</td></tr>
<tr><td>8</td><td><b>'4,d'</b>
This generates the syntax error</td></tr>
<tr><td>9</td><td><b>',10d'</b>
This would also generate syntax error</td></tr>
</table>
<b>Note</b> - While using the <b>p</b> action, you should use the <b>-n</b> option to avoid repetition of line printing. 
Check the difference in between the following two commands -
$ cat /etc/passwd | sed -n '1,3p'
Check the above command without -n as follows -
$ cat /etc/passwd | sed '1,3p'

<h2>&emsp;The Substitution Command</h2>
The substitution command, denoted by <b>s</b>, will substitute any string that you specify with any other string that you specify.
To substitute one string with another, the sed needs to have the information on where the first string ends and the substitution string begins. 
For this, we proceed with bookending the two strings with the forward slash (<b>/</b>) character.
The following command substitutes the first occurrence on a line of the string <b>root</b> with the string <b>amrood</b>.

$ cat /etc/passwd | sed 's/root/amrood/'
amrood:x:0:0:root user:/root:/bin/sh
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
..........................

It is very important to note that sed substitutes only the first occurrence on a line. 
If the string root occurs more than once on a line only the first match will be replaced.
For the sed to perform a global substitution, add the letter <b>g</b> to the end of the command as follows -
$ cat /etc/passwd | sed 's/root/amrood/g'
amrood:x:0:0:amrood user:/amrood:/bin/sh
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
...........................

<h2>&emsp;Substitution Flags</h2>
There are a number of other useful flags that can be passed in addition to the <b>g</b> flag, and you can specify more than one at a time.
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Flag &amp; Description</th></tr>
<tr><td>1</td><td><b>g</b>
Replaces all matches, not just the first match</td></tr>
<tr><td>2</td><td><b>NUMBER</b>
Replaces only NUMBER<sup>th</sup> match</td></tr>
<tr><td>3</td><td><b>p</b>
If substitution was made, then prints the pattern space</td></tr>
<tr><td>4</td><td><b>w FILENAME</b>
If substitution was made, then writes result to FILENAME</td></tr>
<tr><td>5</td><td><b>I or i</b>
Matches in a case-insensitive manner</td></tr>
<tr><td>6</td><td><b>M or m</b>
In addition to the normal behavior of the special regular expression characters ^ and $, this flag causes ^ to match the empty string after a newline and $ to match the empty string before a newline</td></tr>
</table>
<h2>&emsp;Using an Alternative String Separator</h2>
Suppose you have to do a substitution on a string that includes the forward slash character. 
In this case, you can specify a different separator by providing the designated character after the <b>s</b>.

$ cat /etc/passwd | sed 's:/root:/amrood:g'
amrood:x:0:0:amrood user:/amrood:/bin/sh
daemon:x:1:1:daemon:/usr/sbin:/bin/sh

In the above example, we have used <b>:</b> as the <b>delimiter</b> instead of slash / because we were trying to search <b>/root</b> instead of the simple root.
<h2>&emsp;Replacing with Empty Space</h2>
Use an empty substitution string to delete the root string from the <b>/etc/passwd</b> file entirely -
$ cat /etc/passwd | sed 's/root//g'
:x:0:0::/:/bin/sh
daemon:x:1:1:daemon:/usr/sbin:/bin/sh

<h2>&emsp;Address Substitution</h2>
If you want to substitute the string <b>sh</b> with the string <b>quiet</b> only on line 10, you can specify it as follows -
$ cat /etc/passwd | sed '10s/sh/quiet/g'
root:x:0:0:root user:/root:/bin/sh
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/bin/sh
man:x:6:12:man:/var/cache/man:/bin/sh
mail:x:8:8:mail:/var/mail:/bin/sh
news:x:9:9:news:/var/spool/news:/bin/sh
backup:x:34:34:backup:/var/backups:/bin/quiet

Similarly, to do an address range substitution, you could do something like the following -
$ cat /etc/passwd | sed '1,5s/sh/quiet/g'
root:x:0:0:root user:/root:/bin/quiet
daemon:x:1:1:daemon:/usr/sbin:/bin/quiet
bin:x:2:2:bin:/bin:/bin/quiet
sys:x:3:3:sys:/dev:/bin/quiet
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/bin/sh
man:x:6:12:man:/var/cache/man:/bin/sh
mail:x:8:8:mail:/var/mail:/bin/sh
news:x:9:9:news:/var/spool/news:/bin/sh
backup:x:34:34:backup:/var/backups:/bin/sh

As you can see from the output, the first five lines had the string <b>sh</b> changed to <b>quiet</b>, but the rest of the lines were left untouched.
<h2>&emsp;The Matching Command</h2>
You would use the <b>p</b> option along with the <b>-n</b> option to print all the matching lines as follows -
$ cat testing | sed -n '/root/p'
root:x:0:0:root user:/root:/bin/sh
[root@ip-72-167-112-17 amrood]# vi testing
root:x:0:0:root user:/root:/bin/sh
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/bin/sh
man:x:6:12:man:/var/cache/man:/bin/sh
mail:x:8:8:mail:/var/mail:/bin/sh
news:x:9:9:news:/var/spool/news:/bin/sh
backup:x:34:34:backup:/var/backups:/bin/sh

<h2>&emsp;Using Regular Expression</h2>
While matching patterns, you can use the regular expression which provides more flexibility.
Check the following example which matches all the lines starting with <i>daemon</i> and then deletes them -
$ cat testing | sed '/^daemon/d'
root:x:0:0:root user:/root:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/bin/sh
man:x:6:12:man:/var/cache/man:/bin/sh
mail:x:8:8:mail:/var/mail:/bin/sh
news:x:9:9:news:/var/spool/news:/bin/sh
backup:x:34:34:backup:/var/backups:/bin/sh

Following is the example which deletes all the lines ending with <b>sh</b> -
$ cat testing | sed '/sh$/d'
sync:x:4:65534:sync:/bin:/bin/sync

The following table lists four special characters that are very useful in regular expressions.
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Character &amp; Description</th></tr>
<tr><td>1</td><td><b>^</b>
Matches the beginning of lines</td></tr>
<tr><td>2</td><td><b>$</b>
Matches the end of lines</td></tr>
<tr><td>3</td><td><b>.</b>
Matches any single character</td></tr>
<tr><td>4</td><td><b>*</b>
Matches zero or more occurrences of the previous character</td></tr>
<tr><td>5</td><td><b>[chars]</b>
Matches any one of the characters given in chars, where chars is a sequence of characters. 
You can use the - character to indicate a range of characters.</td></tr>
</table>
<h2>&emsp;Matching Characters</h2>
Look at a few more expressions to demonstrate the use of <b>metacharacters</b>. 
For example, the following pattern -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Expression &amp; Description</th></tr>
<tr><td>1</td><td><b>/a.c/</b>
Matches lines that contain strings such as <b>a&amp;plus;c</b>, <b>a-c</b>, <b>abc</b>, <b>match</b>, and <b>a3c</b></td></tr>
<tr><td>2</td><td><b>/a*c/</b>
Matches the same strings along with strings such as <b>ace</b>, <b>yacc</b>, and <b>arctic</b></td></tr>
<tr><td>3</td><td><b>/[tT]he/</b>
Matches the string <b>The</b> and <b>the</b></td></tr>
<tr><td>4</td><td><b>/^$/</b>
Matches blank lines</td></tr>
<tr><td>5</td><td><b>/^.*$/</b>
Matches an entire line whatever it is</td></tr>
<tr><td>6</td><td><b>/ */</b>
Matches one or more spaces</td></tr>
<tr><td>7</td><td><b>/^$/</b>
Matches <b>blank</b> lines</td></tr>
</table>
Following table shows some frequently used sets of characters -
<table class="table table-bordered">
<tr><th style="text-align:center;width:8%">Sr.No.</th><th>Set &amp; Description</th></tr>
<tr><td>1</td><td><b>[a-z]</b>
Matches a single lowercase letter</td></tr>
<tr><td>2</td><td><b>[A-Z]</b>
Matches a single uppercase letter</td></tr>
<tr><td>3</td><td><b>[a-zA-Z]</b>
Matches a single letter</td></tr>
<tr><td>4</td><td><b>[0-9]</b>
Matches a single number</td></tr>
<tr><td>5</td><td><b>[a-zA-Z0-9]</b>
Matches a single letter or number</td></tr>
</table>
<h2>&emsp;Character Class Keywords</h2>
Some special keywords are commonly available to <b>regexps</b>, especially GNU utilities that employ <b>regexps</b>. 
These are very useful for sed regular expressions as they simplify things and enhance readability.
For example, the characters <b>a through z</b> and the characters <b>A through Z</b>, constitute one such class of characters that has the keyword <b>[[:alpha:]]</b>
Using the alphabet character class keyword, this command prints only those lines in the <b>/etc/syslog.conf</b> file that start with a letter of the alphabet -
$ cat /etc/syslog.conf | sed -n '/^[[:alpha:]]/p'
authpriv.*                         /var/log/secure
mail.*                             -/var/log/maillog
cron.*                             /var/log/cron
uucp,news.crit                     /var/log/spooler
local7.*                           /var/log/boot.log

The following table is a complete list of the available character class keywords in GNU sed.
<table class="table table-bordered">
<tr><th style="text-align:center;width:8%">Sr.No.</th><th>Character Class &amp; Description</th></tr>
<tr><td>1</td><td><b>[[:alnum:]]</b>
Alphanumeric [a-z A-Z 0-9]</td></tr>
<tr><td>2</td><td><b>[[:alpha:]]</b>
Alphabetic [a-z A-Z]</td></tr>
<tr><td>3</td><td><b>[[:blank:]]</b>
Blank characters (spaces or tabs)</td></tr>
<tr><td>4</td><td><b>[[:cntrl:]]</b>
Control characters</td></tr>
<tr><td>5</td><td><b>[[:digit:]]</b>
Numbers [0-9]</td></tr>
<tr><td>6</td><td><b>[[:graph:]]</b>
Any visible characters (excludes whitespace)</td></tr>
<tr><td>7</td><td><b>[[:lower:]]</b>
Lowercase letters [a-z]</td></tr>
<tr><td>8</td><td><b>[[:print:]]</b>
Printable characters (non-control characters)</td></tr>
<tr><td>9</td><td><b>[[:punct:]]</b>
Punctuation characters</td></tr>
<tr><td>10</td><td><b>[[:space:]]</b>
Whitespace</td></tr>
<tr><td>11</td><td><b>[[:upper:]]</b>
Uppercase letters [A-Z]</td></tr>
<tr><td>12</td><td><b>[[:xdigit:]]</b>
Hex digits [0-9 a-f A-F]</td></tr>
</table>
<h2>&emsp;Aampersand Referencing</h2>
The <b>sed metacharacter &amp;</b> represents the contents of the pattern that was matched. 
For instance, say you have a file called <b>phone.txt</b> full of phone numbers, such as the following -
5555551212
5555551213
5555551214
6665551215
6665551216
7775551217

You want to make the <b>area code</b> (the first three digits) surrounded by parentheses for easier reading. 
To do this, you can use the ampersand replacement character -
$ sed -e 's/^[[:digit:]][[:digit:]][[:digit:]]/(&amp;)/g' phone.txt
(555)5551212
(555)5551213
(555)5551214
(666)5551215
(666)5551216
(777)5551217

Here in the pattern part you are matching the first 3 digits and then using <b>&amp;</b> you are replacing those 3 digits with the surrounding <b>parentheses</b>.
<h2>&emsp;Using Multiple sed Commands</h2>
You can use multiple sed commands in a single sed command as follows -
$ sed -e 'command1' -e 'command2' ... 
-e 'commandN' files

Here <b>command1</b> through <b>commandN</b> are sed commands of the type discussed previously. 
These commands are applied to each of the lines in the list of files given by files.
Using the same mechanism, we can write the above phone number example as follows -
$ sed -e 's/^[[:digit:]]\{3\}/(&amp;)/g'  \ 
   -e 's/)[[:digit:]]\{3\}/&amp;-/g' phone.txt 
(555)555-1212 
(555)555-1213 
(555)555-1214 
(666)555-1215 
(666)555-1216 
(777)555-1217

<b>Note</b> - In the above example, instead of repeating the character class keyword <b>[[:digit:]]</b> three times, we replaced it with <b>\{3\}</b>, which means the preceding regular expression is matched three times. 
We have also used <b>\</b> to give line break and this has to be removed before the command is run.
<h2>&emsp;Back References</h2>
The <b>ampersand metacharacter</b> is useful, but even more useful is the ability to define specific regions in regular expressions. 
These special regions can be used as reference in your replacement strings. 
By defining specific parts of a regular expression, you can then refer back to those parts with a special reference character.
To do <b>back references</b>, you have to first define a region and then refer back to that region. 
To define a region, you insert <b>backslashed parentheses</b> around each region of interest. 
The first region that you surround with backslashes is then referenced by <b>\1</b>, the second region by <b>\2</b>, and so on.
Assuming <b>phone.txt</b> has the following text -
(555)555-1212
(555)555-1213
(555)555-1214
(666)555-1215
(666)555-1216
(777)555-1217

Try the following command -
$ cat phone.txt | sed 's/\(.*)\)\(.*-\)\(.*$\)/Area \ 
   code: \1 Second: \2 Third: \3/' 
Area code: (555) Second: 555- Third: 1212 
Area code: (555) Second: 555- Third: 1213 
Area code: (555) Second: 555- Third: 1214 
Area code: (666) Second: 555- Third: 1215 
Area code: (666) Second: 555- Third: 1216 
Area code: (777) Second: 555- Third: 1217

<b>Note</b> - In the above example, each regular expression inside the parenthesis would be back referenced by <b>\1</b>, <b>\2</b> and so on. 
We have used <b>\</b> to give line break here. 
This should be removed before running the command.
<h2><span class="orange">Unix - File System Basics</span></h2>
A file system is a logical collection of files on a partition or disk. 
A partition is a container for information and can span an entire hard drive if desired.
Your hard drive can have various partitions which usually contain only one file system, such as one file system housing the <b>/file system</b> or another containing the <b>/home file system</b>.
One file system per partition allows for the logical maintenance and management of differing file systems.
Everything in Unix is considered to be a file, including physical devices such as DVD-ROMs, USB devices, and floppy drives.
<h2>&emsp;Directory Structure</h2>
Unix uses a hierarchical file system structure, much like an upside-down tree, with root (/) at the base of the file system and all other directories spreading from there.
A Unix filesystem is a collection of files and directories that has the following properties -
It has a root directory (<b>/</b>) that contains other files and directories.
Each file or directory is uniquely identified by its name, the directory in which it resides, and a unique identifier, typically called an <b>inode</b>.
By convention, the root directory has an <b>inode</b> number of <b>2</b> and the <b>lost&amp;plus;found</b> directory has an <b>inode</b> number of <b>3</b>. 
Inode numbers <b>0</b> and <b>1</b> are not used. 
File inode numbers can be seen by specifying the <b>-i option</b> to <b>ls command</b>.
It is self-contained. 
There are no dependencies between one filesystem and another.

The directories have specific purposes and generally hold the same types of information for easily locating files. 
Following are the directories that exist on the major versions of Unix -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Directory &amp; Description</th></tr>
<tr><td>1</td><td><b>/</b>
This is the root directory which should contain only the directories needed at the top level of the file structure</td></tr>
<tr><td>2</td><td><b>/bin</b>
This is where the executable files are located. 
These files are available to all users</td></tr>
<tr><td>3</td><td><b>/dev</b>
These are device drivers</td></tr>
<tr><td>4</td><td><b>/etc</b>
Supervisor directory commands, configuration files, disk configuration files, valid user lists, groups, ethernet, hosts, where to send critical messages</td></tr>
<tr><td>5</td><td><b>/lib</b>
Contains shared library files and sometimes other kernel-related files</td></tr>
<tr><td>6</td><td><b>/boot</b>
Contains files for booting the system</td></tr>
<tr><td>7</td><td><b>/home</b>
Contains the home directory for users and other accounts</td></tr>
<tr><td>8</td><td><b>/mnt</b>
Used to mount other temporary file systems, such as <b>cdrom</b> and <b>floppy</b> for the <b>CD-ROM</b> drive and <b>floppy diskette drive</b>, respectively</td></tr>
<tr><td>9</td><td><b>/proc</b>
Contains all processes marked as a file by <b>process number</b> or other information that is dynamic to the system</td></tr>
<tr><td>10</td><td><b>/tmp</b>
Holds temporary files used between system boots</td></tr>
<tr><td>11</td><td><b>/usr</b>
Used for miscellaneous purposes, and can be used by many users. 
Includes administrative commands, shared files, library files, and others</td></tr>
<tr><td>12</td><td><b>/var</b>
Typically contains variable-length files such as log and print files and any other type of file that may contain a variable amount of data</td></tr>
<tr><td>13</td><td><b>/sbin</b>
Contains binary (executable) files, usually for system administration. 
For example, <b><i>fdisk</i></b> and <b><i>ifconfig</i></b> utlities</td></tr>
<tr><td>14</td><td><b>/kernel</b>
Contains kernel files</td></tr>
</table>
<h2>&emsp;Navigating the File System</h2>
Now that you understand the basics of the file system, you can begin navigating to the files you need. 
The following commands are used to navigate the system -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Command &amp; Description</th></tr>
<tr><td>1</td><td><b>cat filename</b>
Displays a filename</td></tr>
<tr><td>2</td><td><b>cd dirname</b>
Moves you to the identified directory</td></tr>
<tr><td>3</td><td><b>cp file1 file2</b>
Copies one file/directory to the specified location</td></tr>
<tr><td>4</td><td><b>file filename</b>
Identifies the file type (binary, text, etc)</td></tr>
<tr><td>5</td><td><b>find filename dir</b>
Finds a file/directory</td></tr>
<tr><td>6</td><td><b>head filename</b>
Shows the beginning of a file</td></tr>
<tr><td>7</td><td><b>less filename</b>
Browses through a file from the end or the beginning</td></tr>
<tr><td>8</td><td><b>ls dirname</b>
Shows the contents of the directory specified</td></tr>
<tr><td>9</td><td><b>mkdir dirname</b>
Creates the specified directory</td></tr>
<tr><td>10</td><td><b>more filename</b>
Browses through a file from the beginning to the end</td></tr>
<tr><td>11</td><td><b>mv file1 file2</b>
Moves the location of, or renames a file/directory</td></tr>
<tr><td>12</td><td><b>pwd</b>
Shows the current directory the user is in</td></tr>
<tr><td>13</td><td><b>rm filename</b>
Removes a file</td></tr>
<tr><td>14</td><td><b>rmdir dirname</b>
Removes a directory</td></tr>
<tr><td>15</td><td><b>tail filename</b>
Shows the end of a file</td></tr>
<tr><td>16</td><td><b>touch filename</b>
Creates a blank file or modifies an existing file or its attributes</td></tr>
<tr><td>17</td><td><b>whereis filename</b>
Shows the location of a file</td></tr>
<tr><td>18</td><td><b>which filename</b>
Shows the location of a file if it is in your PATH</td></tr>
</table>
You can use <a href="/unix/unix-manpage-help.htm">Manpage Help</a> to check complete syntax for each command mentioned here.
<h2>&emsp;The df Command</h2>
The first way to manage your partition space is with the <b>df (disk free)</b> command. 
The command <b>df -k (disk free)</b> displays the <b>disk space usage in kilobytes</b>, as shown below -
$df -k
Filesystem      1K-blocks      Used   Available Use% Mounted on
/dev/vzfs        10485760   7836644     2649116  75% /
/devices                0         0           0   0% /devices
$

Some of the directories, such as <b>/devices</b>, shows 0 in the kbytes, used, and avail columns as well as 0% for capacity. 
These are special (or virtual) file systems, and although they reside on the disk under /, by themselves they do not consume disk space.
The <b>df -k</b> output is generally the same on all Unix systems. 
Here's what it usually includes -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Column &amp; Description</th></tr>
<tr><td>1</td><td><b>Filesystem</b>
The physical file system name</td></tr>
<tr><td>2</td><td><b>kbytes</b>
Total kilobytes of space available on the storage medium</td></tr>
<tr><td>3</td><td><b>used</b>
Total kilobytes of space used (by files)</td></tr>
<tr><td>4</td><td><b>avail</b>
Total kilobytes available for use</td></tr>
<tr><td>5</td><td><b>capacity</b>
Percentage of total space used by files</td></tr>
<tr><td>6</td><td><b>Mounted on</b>
What the file system is mounted on</td></tr>
</table>
You can use the <b>-h (human readable) option</b> to display the output in a format that shows the size in easier-to-understand notation.
<h2>&emsp;The du Command</h2>
The <b>du (disk usage) command</b> enables you to specify directories to show disk space usage on a particular directory.
This command is helpful if you want to determine how much space a particular directory is taking. 
The following command displays number of blocks consumed by each directory. 
A single block may take either 512 Bytes or 1 Kilo Byte depending on your system.

$du /etc
10     /etc/cron.d
126    /etc/default
6      /etc/dfs
...
$

The <b>-h</b> option makes the output easier to comprehend -
$du -h /etc
5k    /etc/cron.d
63k   /etc/default
3k    /etc/dfs
...
$

<h2>&emsp;Mounting the File System</h2>
A file system must be mounted in order to be usable by the system. 
To see what is currently mounted (available for use) on your system, use the following command -
$ mount
/dev/vzfs on / type reiserfs (rw,usrquota,grpquota)
proc on /proc type proc (rw,nodiratime)
devpts on /dev/pts type devpts (rw)
$

The <b>/mnt</b> directory, by the Unix convention, is where temporary mounts (such as CDROM drives, remote network drives, and floppy drives) are located. 
If you need to mount a file system, you can use the mount command with the following syntax -
mount -t file_system_type device_to_mount directory_to_mount_to

For example, if you want to mount a <b>CD-ROM</b> to the directory <b>/mnt/cdrom</b>, you can type -
$ mount -t iso9660 /dev/cdrom /mnt/cdrom

This assumes that your CD-ROM device is called <b>/dev/cdrom</b> and that you want to mount it to <b>/mnt/cdrom</b>. 
Refer to the mount man page for more specific information or type mount <b>-h</b> at the command line for help information.
After mounting, you can use the cd command to navigate the newly available file system through the mount point you just made.
<h2>&emsp;Unmounting the File System</h2>
To unmount (remove) the file system from your system, use the <b>umount</b> command by identifying the mount point or device.
For example, <b>to unmount cdrom</b>, use the following command -
$ umount /dev/cdrom

The <b>mount command</b> enables you to access your file systems, but on most modern Unix systems, the <b>automount function</b> makes this process invisible to the user and requires no intervention.
<h2>&emsp;User and Group Quotas</h2>
The user and group quotas provide the mechanisms by which the amount of space used by a single user or all users within a specific group can be limited to a value defined by the administrator.
Quotas operate around two limits that allow the user to take some action if the amount of space or number of disk blocks start to exceed the administrator defined limits -
<b>Soft Limit</b> - If the user exceeds the limit defined, there is a grace period that allows the user to free up some space.
<b>Hard Limit</b> - When the hard limit is reached, regardless of the grace period, no further files or blocks can be allocated.

There are a number of commands to administer quotas -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Command &amp; Description</th></tr>
<tr><td>1</td><td><b>quota</b>
Displays disk usage and limits for a user of group</td></tr>
<tr><td>2</td><td><b>edquota</b>
This is a quota editor. 
Users or Groups quota can be edited using this command</td></tr>
<tr><td>3</td><td><b>quotacheck</b>
Scans a filesystem for disk usage, creates, checks and repairs quota files</td></tr>
<tr><td>4</td><td><b>setquota</b>
This is a command line quota editor</td></tr>
<tr><td>5</td><td><b>quotaon</b>
This announces to the system that disk quotas should be enabled on one or more filesystems</td></tr>
<tr><td>6</td><td><b>quotaoff</b>
This announces to the system that disk quotas should be disabled for one or more filesystems</td></tr>
<tr><td>7</td><td><b>repquota</b>
This prints a summary of the disc usage and quotas for the specified file systems</td></tr>
</table>
You can use <a href="/unix/unix-manpage-help.htm">Manpage Help</a> to check complete syntax for each command mentioned here.
<h2><span class="orange">Unix - User Administration</span></h2>
In this chapter, we will discuss in detail about user administration in Unix.
There are three types of accounts on a Unix system -
<h3>Root account</h3>
This is also called <b>superuser</b> and would have complete and unfettered control of the system. 
A superuser can run any commands without any restriction. 
This user should be assumed as a system administrator.
<h3>System accounts</h3>
System accounts are those needed for the operation of system-specific components for example mail accounts and the <b>sshd</b> accounts. 
These accounts are usually needed for some specific function on your system, and any modifications to them could adversely affect the system.
<h3>User accounts</h3>
User accounts provide interactive access to the system for users and groups of users. 
General users are typically assigned to these accounts and usually have limited access to critical system files and directories.
Unix supports a concept of <i>Group Account</i> which logically groups a number of accounts. 
Every account would be a part of another group account. 
A Unix group plays important role in handling file permissions and process management.
<h2>&emsp;Managing Users and Groups</h2>
There are four main user administration files -
<b>/etc/passwd</b> - Keeps the user account and password information. 
This file holds the majority of information about accounts on the Unix system.
<b>/etc/shadow</b> - Holds the encrypted password of the corresponding account. 
Not all the systems support this file.
<b>/etc/group</b> - This file contains the group information for each account.
<b>/etc/gshadow</b> - This file contains secure group account information.

Check all the above files using the <b>cat</b> command.
The following table lists out commands that are available on majority of Unix systems to create and manage accounts and groups -
<table class="table table-bordered">
<tr><th style="text-align:center;width:8%">Sr.No.</th><th>Command &amp; Description</th></tr>
<tr><td>1</td><td><b>useradd</b>
Adds accounts to the system</td></tr>
<tr><td>2</td><td><b>usermod</b>
Modifies account attributes</td></tr>
<tr><td>3</td><td><b>userdel</b>
Deletes accounts from the system</td></tr>
<tr><td>4</td><td><b>groupadd</b>
Adds groups to the system</td></tr>
<tr><td>5</td><td><b>groupmod</b>
Modifies group attributes</td></tr>
<tr><td>6</td><td><b>groupdel</b>
Removes groups from the system</td></tr>
</table>
You can use <a href="/unix/unix-manpage-help.htm">Manpage Help</a> to check complete syntax for each command mentioned here.
<h2>&emsp;Create a Group</h2>
We will now understand how to create a group. 
For this, we need to create groups before creating any account otherwise, we can make use of the existing groups in our system. 
We have all the groups listed in <b><i>/etc/groups</i></b> file.
All the default groups are system account specific groups and it is not recommended to use them for ordinary accounts. 
So, following is the syntax to create a new group account -
 groupadd [-g gid [-o]] [-r] [-f] groupname

The following table lists out the parameters -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Option &amp; Description</th></tr>
<tr><td>1</td><td><b>-g GID</b>
The numerical value of the group's ID</td></tr>
<tr><td>2</td><td><b>-o</b>
This option permits to add group with non-unique GID</td></tr>
<tr><td>3</td><td><b>-r</b>
This flag instructs <b>groupadd</b> to add a system account</td></tr>
<tr><td>4</td><td><b>-f </b>
This option causes to just exit with success status, if the specified group already exists. 
With -g, if the specified GID already exists, other (unique) GID is chosen</td></tr>
<tr><td>5</td><td><b>groupname</b>
Actual group name to be created</td></tr>
</table>
If you do not specify any parameter, then the system makes use of the default values.
Following example creates a <i>developers</i> group with default values, which is very much acceptable for most of the administrators.

$ groupadd developers

<h2>&emsp;Modify a Group</h2>
To modify a group, use the <b>groupmod</b> syntax -
$ groupmod -n new_modified_group_name old_group_name

To change the developers_2 group name to developer, type -
$ groupmod -n developer developer_2

Here is how you will change the financial GID to 545 -
$ groupmod -g 545 developer

<h2>&emsp;Delete a Group</h2>
We will now understand how to delete a group. 
To delete an existing group, all you need is the <b>groupdel command</b> and the <b>group name</b>. 
To delete the financial group, the command is -
$ groupdel developer

This removes only the group, not the files associated with that group. 
The files are still accessible by their owners.
<h2>&emsp;Create an Account</h2>
Let us see how to create a new account on your Unix system. 
Following is the syntax to create a user's account -
useradd -d homedir -g groupname -m -s shell -u userid accountname

The following table lists out the parameters -
<table class="table table-bordered">
<tr><th style="text-align:center;width:8%">Sr.No.</th><th>Option &amp; Description</th></tr>
<tr><td>1</td><td><b>-d homedir</b>
Specifies home directory for the account</td></tr>
<tr><td>2</td><td><b>-g groupname</b>
Specifies a group account for this account</td></tr>
<tr><td>3</td><td><b>-m</b>
Creates the home directory if it doesn't exist</td></tr>
<tr><td>4</td><td><b>-s shell</b>
Specifies the default shell for this account</td></tr>
<tr><td>5</td><td><b>-u userid</b>
You can specify a user id for this account</td></tr>
<tr><td>6</td><td><b>accountname</b>
Actual account name to be created</td></tr>
</table>
If you do not specify any parameter, then the system makes use of the default values. 
The <b>useradd</b> command modifies the <b>/etc/passwd</b>, <b>/etc/shadow</b>, and <b>/etc/group</b> files and creates a home directory.
Following is the example that creates an account <b><i>mcmohd</i></b>, setting its home directory to <b><i>/home/mcmohd</i></b> and the group as <b><i>developers</i></b>. 
This user would have Korn Shell assigned to it.

$ useradd -d /home/mcmohd -g developers -s /bin/ksh mcmohd

Before issuing the above command, make sure you already have the <i>developers</i> group created using the <b><i>groupadd</i></b> command.
Once an account is created you can set its password using the <b>passwd</b> command as follows -
$ passwd mcmohd20
Changing password for user mcmohd20.
New UNIX password:
Retype new UNIX password:
passwd: all authentication tokens updated successfully.

When you type <b><i>passwd accountname</i></b>, it gives you an option to change the password, provided you are a superuser. 
Otherwise, you can change just your password using the same command but without specifying your account name.
<h2>&emsp;Modify an Account</h2>
The <b>usermod</b> command enables you to make changes to an existing account from the command line. 
It uses the same arguments as the <b>useradd</b> command, plus the -l argument, which allows you to change the account name.
For example, to change the account name <b><i>mcmohd</i></b> to <b><i>mcmohd20</i></b> and to change home directory accordingly, you will need to issue the following command -
$ usermod -d /home/mcmohd20 -m -l mcmohd mcmohd20

<h2>&emsp;Delete an Account</h2>
The <b>userdel</b> command can be used to delete an existing user. 
This is a very dangerous command if not used with caution.
There is only one argument or option available for the command <b>.r</b>, for removing the account's home directory and mail file.
For example, to remove account <i>mcmohd20</i>, issue the following command -
$ userdel -r mcmohd20

If you want to keep the home directory for backup purposes, omit the <b>-r</b> option. 
You can remove the home directory as needed at a later time.
<h2><span class="orange">Unix - System Performance</span></h2>
In this chapter, we will discuss in detail about the system performance in Unix.
We will introduce you to a few free tools that are available to monitor and manage performance on Unix systems. 
These tools also provide guidelines on how to diagnose and fix performance problems in the Unix environment.
Unix has following major resource types that need to be monitored and tuned -
<b>CPU</b>
<b>Memory</b>
<b>Disk space</b>
<b>Communications lines</b>
<b>I/O Time</b>
<b>Network Time</b>
<b>Applications programs</b>

<h2>&emsp;Performance Components</h2>
The following table lists out five major components which take up the system time -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Component &amp; Description</th></tr>
<tr><td>1</td><td><b>User State CPU</b>
The actual amount of time the CPU spends running the users’ program in the user state. 
It includes the time spent executing library calls, but does not include the time spent in the kernel on its behalf</td></tr>
<tr><td>2</td><td><b>System State CPU </b>
This is the amount of time the CPU spends in the system state on behalf of this program. 
All <b>I/O routines</b> require kernel services. 
The programmer can affect this value by blocking I/O transfers</td></tr>
<tr><td>3</td><td><b>I/O Time and Network Time </b>
This is the amount of time spent moving data and servicing I/O requests</td></tr>
<tr><td>4</td><td><b>Virtual Memory Performance </b>
This includes context switching and swapping</td></tr>
<tr><td>5</td><td><b>Application Program</b>
Time spent running other programs - when the system is not servicing this application because another application currently has the CPU</td></tr>
</table>
<h2>&emsp;Performance Tools</h2>
Unix provides following important tools to measure and fine tune Unix system performance -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Command &amp; Description</th></tr>
<tr><td>1</td><td><b>nice/renice</b>
Runs a program with modified scheduling priority</td></tr>
<tr><td>2</td><td><b>netstat</b>
Prints network connections, routing tables, interface statistics, masquerade connections, and multicast memberships</td></tr>
<tr><td>3</td><td><b>time</b>
Helps time a simple command or give resource usage</td></tr>
<tr><td>4</td><td><b>uptime</b>
This is System Load Average</td></tr>
<tr><td>5</td><td><b>ps</b>
Reports a snapshot of the current processes</td></tr>
<tr><td>6</td><td><b>vmstat</b>
Reports virtual memory statistics</td></tr>
<tr><td>7</td><td><b>gprof</b>
Displays call graph profile data</td></tr>
<tr><td>8</td><td><b>prof</b>
Facilitates Process Profiling</td></tr>
<tr><td>9</td><td><b>top</b>
Displays system tasks</td></tr>
</table>
You can use <a href="/unix/unix-manpage-help.htm">Manpage Help</a> to check complete syntax for each command mentioned here.
<h2><span class="orange">Unix - System Logging</span></h2>
In this chapter, we will discuss in detail about system logging in Unix.
Unix systems have a very flexible and powerful logging system, which enables you to record almost anything you can imagine and then manipulate the logs to retrieve the information you require.
Many versions of Unix provide a general-purpose logging facility called <b>syslog</b>. 
Individual programs that need to have information logged, send the information to syslog.
Unix <i>syslog</i> is a host-configurable, uniform system logging facility. 
The system uses a centralized system logging process that runs the program <b>/etc/syslogd</b> or <b>/etc/syslog</b>.
The operation of the system logger is quite straightforward. 
Programs send their log entries to <i>syslogd</i>, which consults the configuration file <b>/etc/syslogd.conf</b> or <b>/etc/syslog</b> and, when a match is found, writes the log message to the desired log file.
There are four basic syslog terms that you should understand -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Term &amp; Description</th></tr>
<tr><td>1</td><td><b>Facility</b>
The identifier used to describe the application or process that submitted the log message. 
For example, mail, kernel, and ftp.</td></tr>
<tr><td>2</td><td><b>Priority</b>
An indicator of the importance of the message. 
Levels are defined within syslog as guidelines, from debugging information to critical events.</td></tr>
<tr><td>3</td><td><b>Selector</b>
A combination of one or more facilities and levels. 
When an incoming event matches a selector, an action is performed.</td></tr>
<tr><td>4</td><td><b>Action</b>
What happens to an incoming message that matches a selector — Actions can write the message to a log file, echo the message to a console or other device, write the message to a logged in user, or send the message along to another syslog server.</td></tr>
</table>
<h2>&emsp;Syslog Facilities</h2>
We will now understand about the syslog facilities. 
Here are the available facilities for the selector. 
Not all facilities are present on all versions of Unix.
<table class="table table-bordered">
<tr><th>Facility</th><th>Description</th></tr>
<tr><td>1</td><td><b>auth</b>
Activity related to requesting name and password (getty, su, login)</td></tr>
<tr><td>2</td><td><b>authpriv</b>
Same as auth but logged to a file that can only be read by selected users</td></tr>
<tr><td>3</td><td><b>console</b>
Used to capture messages that are generally directed to the system console</td></tr>
<tr><td>4</td><td><b>cron</b>
Messages from the cron system scheduler</td></tr>
<tr><td>5</td><td><b>daemon</b>
System daemon catch-all</td></tr>
<tr><td>6</td><td><b>ftp</b>
Messages relating to the ftp daemon</td></tr>
<tr><td>7</td><td><b>kern</b>
Kernel messages</td></tr>
<tr><td>8</td><td><b>local0.local7</b>
Local facilities defined per site</td></tr>
<tr><td>9</td><td><b>lpr</b>
Messages from the line printing system</td></tr>
<tr><td>10</td><td><b>mail</b>
Messages relating to the mail system</td></tr>
<tr><td>11</td><td><b>mark</b>
Pseudo-event used to generate timestamps in log files</td></tr>
<tr><td>12</td><td><b>news</b>
Messages relating to network news protocol (nntp)</td></tr>
<tr><td>13</td><td><b>ntp</b>
Messages relating to network time protocol</td></tr>
<tr><td>14</td><td><b>user</b>
Regular user processes</td></tr>
<tr><td>15</td><td><b>uucp</b>
UUCP subsystem</td></tr>
</table>
<h2>&emsp;Syslog Priorities</h2>
The syslog priorities are summarized in the following table -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Priority &amp; Description</th></tr>
<tr><td>1</td><td><b>emerg</b>
Emergency condition, such as an imminent system crash, usually broadcast to all users</td></tr>
<tr><td>2</td><td><b>alert</b>
Condition that should be corrected immediately, such as a corrupted system database</td></tr>
<tr><td>3</td><td><b>crit</b>
Critical condition, such as a hardware error</td></tr>
<tr><td>4</td><td><b>err</b>
Ordinary error</td></tr>
<tr><td>5</td><td><b>Warning</b>
Warning</td></tr>
<tr><td>6</td><td><b>notice</b>
Condition that is not an error, but possibly should be handled in a special way</td></tr>
<tr><td>7</td><td><b>info</b>
Informational message</td></tr>
<tr><td>8</td><td><b>debug</b>
Messages that are used when debugging programs</td></tr>
<tr><td>9</td><td><b>none</b>
Pseudo level used to specify not to log messages</td></tr>
</table>
The combination of facilities and levels enables you to be discerning about what is logged and where that information goes.
As each program sends its messages dutifully to the system logger, the logger makes decisions on what to keep track of and what to discard based on the levels defined in the selector.
When you specify a level, the system will keep track of everything at that level and higher.
<h2>&emsp;The /etc/syslog.conf file</h2>
The <b>/etc/syslog.conf</b> file controls where messages are logged. 
A typical <b>syslog.conf</b> file might look like this -
*.err;kern.debug;auth.notice /dev/console
daemon,auth.notice           /var/log/messages
lpr.info                     /var/log/lpr.log
mail.*                       /var/log/mail.log
ftp.*                        /var/log/ftp.log
auth.*                       @prep.ai.mit.edu
auth.*                       root,amrood
netinfo.err                  /var/log/netinfo.log
install.*                    /var/log/install.log
*.emerg                      *
*.alert                      |program_name
mark.*                       /dev/console

Each line of the file contains two parts -
A <b>message selector</b> that specifies which kind of messages to log. 
For example, all error messages or all debugging messages from the kernel.
An <b>action field</b> that says what should be done with the message. 
For example, put it in a file or send the message to a user's terminal.

Following are the notable points for the above configuration -
Message selectors have two parts: <b>a facility</b> and <b>a priority</b>. 
For example, <i>kern.debug</i> selects all debug messages (the priority) generated by the kernel (the facility).
Message selector <i>kern.debug</i> selects all priorities that are greater than debug.
An asterisk in place of either the facility or the priority indicates "all". 
For example, <b>*.debug</b> means all debug messages, while <b>kern.*</b> means all messages generated by the kernel.
You can also use commas to specify multiple facilities. 
Two or more selectors can be grouped together by using a semicolon.

<h2>&emsp;Logging Actions</h2>
The action field specifies one of five actions -
Log message to a file or a device. 
For example, <b>/var/log/lpr.log</b> or <b>/dev/console</b>.
Send a message to a user. 
You can specify multiple usernames by separating them with commas; for example, root, amrood.
Send a message to all users. 
In this case, the action field consists of an asterisk; for example, *.
Pipe the message to a program. 
In this case, the program is specified after the Unix pipe symbol (|).
Send the message to the syslog on another host. 
In this case, the action field consists of a hostname, preceded by an at sign; for example, @tutorialspoint.com.

<h2>&emsp;The logger Command</h2>
Unix provides the <b>logger</b> command, which is an extremely useful command to deal with system logging. 
The <b>logger</b> command sends logging messages to the syslogd daemon, and consequently provokes system logging.
This means we can check from the command line at any time the <b>syslogd</b> daemon and its configuration. 
The logger command provides a method for adding one-line entries to the system log file from the command line.
The format of the command is -
logger [-i] [-f file] [-p priority] [-t tag] [message]...

Here is the detail of the parameters -
<table class="table table-bordered">
<tr><th>Sr.No.</th><th>Option &amp; Description</th></tr>
<tr><td>1</td><td><b>-f filename</b>
Uses the contents of file filename as the message to log.</td></tr>
<tr><td>2</td><td><b>-i</b>
Logs the process ID of the logger process with each line.</td></tr>
<tr><td>3</td><td><b>-p priority</b>
Enters the message with the specified priority (specified selector entry); the message priority can be specified numerically, or as a facility.priority pair. 
The default priority is user.notice.</td></tr>
<tr><td>4</td><td><b>-t tag</b>
Marks each line added to the log with the specified tag.</td></tr>
<tr><td>5</td><td><b>message</b>
The string arguments whose contents are concatenated together in the specified order, separated by the space.</td></tr>
</table>
You can use <a href="/unix/unix-manpage-help.htm">Manpage Help</a> to check complete syntax for this command.
<h2>&emsp;Log Rotation</h2>
Log files have the propensity to grow very fast and consume large amounts of disk space. 
To enable log rotations, most distributions use tools such as <b><i>newsyslog</i></b> or <b><i>logrotate</i></b>.
These tools should be called on a frequent time interval using the <b>cron daemon</b>. 
Check the man pages for <i>newsyslog</i> or <i>logrotate</i> for more details.
<h2>&emsp;Important Log Locations</h2>
All the system applications create their log files in <b><i>/var/log</i></b> and its sub-directories. 
Here are few important applications and their corresponding log directories -
<table class="table table-bordered">
<tr><th>Application</th><th>Directory</th></tr>
<tr><td>httpd</td><td>/var/log/httpd</td></tr>
<tr><td>samba</td><td>/var/log/samba</td></tr>
<tr><td>cron</td><td>/var/log/</td></tr>
<tr><td>mail</td><td>/var/log/</td></tr>
<tr><td>mysql</td><td>/var/log/</td></tr>
</table>
<h2><span class="orange">Unix - Signals and Traps</span></h2>
In this chapter, we will discuss in detail about Signals and Traps in Unix.
Signals are software interrupts sent to a program to indicate that an important event has occurred. 
The events can vary from user requests to illegal memory access errors. 
Some signals, such as the interrupt signal, indicate that a user has asked the program to do something that is not in the usual flow of control.
The following table lists out common signals you might encounter and want to use in your programs -
<table class="table table-bordered">
<tr><th style="text-align:center;vertical-align:middle;width:20%">Signal Name</th>
<th style="text-align:center;width:10%">Signal Number</th>
<th style="text-align:center;vertical-align:middle;width:70%">Description</th></tr>
<tr><td style="text-align:center;vertical-align:middle;">SIGHUP</td>
<td style="text-align:center;vertical-align:middle;">1</td><td>Hang up detected on controlling terminal or death of controlling process</td></tr>
<tr><td>SIGINT</td><td>2</td><td>Issued if the user sends an interrupt signal (Ctrl + C)</td></tr>
<tr><td>SIGQUIT</td><td>3</td><td>Issued if the user sends a quit signal (Ctrl + D)</td></tr>
<tr><td style="text-align:center;vertical-align:middle;">SIGFPE</td>
<td style="text-align:center;vertical-align:middle;">8</td><td>Issued if an illegal mathematical operation is attempted</td></tr>
<tr><td style="text-align:center;vertical-align:middle;">SIGKILL</td>
<td style="text-align:center;vertical-align:middle;">9</td><td>If a process gets this signal it must quit immediately and will not perform any clean-up operations</td></tr>
<tr><td>SIGALRM</td><td>14</td><td>Alarm clock signal (used for timers)</td></tr>
<tr><td>SIGTERM</td><td>15</td><td>Software termination signal (sent by kill by default)</td></tr>
</table>
<h2>&emsp;List of Signals</h2>
There is an easy way to list down all the signals supported by your system. 
Just issue the <b>kill -l</b> command and it would display all the supported signals -
$ kill -l
 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL
 5) SIGTRAP      6) SIGABRT      7) SIGBUS       8) SIGFPE
 9) SIGKILL     10) SIGUSR1     11) SIGSEGV     12) SIGUSR2
13) SIGPIPE     14) SIGALRM     15) SIGTERM     16) SIGSTKFLT
17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU
25) SIGXFSZ     26) SIGVTALRM   27) SIGPROF     28) SIGWINCH
29) SIGIO       30) SIGPWR      31) SIGSYS      34) SIGRTMIN
35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3  38) SIGRTMIN+4
39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12
47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14
51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10
55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7  58) SIGRTMAX-6
59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX

The actual list of signals varies between Solaris, HP-UX, and Linux.
<h2>&emsp;Default Actions</h2>
Every signal has a default action associated with it. 
The default action for a signal is the action that a script or program performs when it receives a signal.
Some of the possible default actions are -
Terminate the process.
Ignore the signal.
Dump core. 
This creates a file called <b>core</b> containing the memory image of the process when it received the signal.
Stop the process.
Continue a stopped process.

<h2>&emsp;Sending Signals</h2>
There are several methods of delivering signals to a program or script. 
One of the most common is for a user to type <b>CONTROL-C</b> or the <b>INTERRUPT key</b> while a script is executing.
When you press the <b><i>Ctrl+C</i></b> key, a <b>SIGINT</b> is sent to the script and as per defined default action script terminates.
The other common method for delivering signals is to use the <b>kill command</b>, the syntax of which is as follows -
$ kill -signal pid

Here <b>signal</b> is either the number or name of the signal to deliver and <b>pid</b> is the process ID that the signal should be sent to. 
For Example -
$ kill -1 1001

The above command sends the HUP or hang-up signal to the program that is running with <b>process ID 1001</b>. 
To send a kill signal to the same process, use the following command -
$ kill -9 1001

This kills the process running with <b>process ID 1001</b>.
<h2>&emsp;Trapping Signals</h2>
When you press the <i>Ctrl+C</i> or Break key at your terminal during execution of a shell program, normally that program is immediately terminated, and your command prompt returns. 
This may not always be desirable. 
For instance, you may end up leaving a bunch of temporary files that won't get cleaned up.
Trapping these signals is quite easy, and the trap command has the following syntax -
$ trap commands signals

Here <i>command</i> can be any valid Unix command, or even a user-defined function, and signal can be a list of any number of signals you want to trap.
There are two common uses for trap in shell scripts -
Clean up temporary files
Ignore signals

<h2>&emsp;Cleaning Up Temporary Files</h2>
As an example of the trap command, the following shows how you can remove some files and then exit if someone tries to abort the program from the terminal -
$ trap "rm -f $WORKDIR/work1$$ $WORKDIR/dataout$$; exit" 2

From the point in the shell program that this trap is executed, the two files <b><i>work1$$</i></b> and <b><i>dataout$$</i></b> will be automatically removed if signal number 2 is received by the program.
Hence, if the user interrupts the execution of the program after this trap is executed, you can be assured that these two files will be cleaned up. 
The <b>exit</b> command that follows the <b>rm</b> is necessary because without it, the execution would continue in the program at the point that it left off when the signal was received.
Signal number 1 is generated for <b>hangup</b>. 
Either someone intentionally hangs up the line or the line gets accidentally disconnected.
You can modify the preceding trap to also remove the two specified files in this case by adding signal number 1 to the list of signals -
$ trap "rm $WORKDIR/work1$$ $WORKDIR/dataout$$; exit" 1 2

Now these files will be removed if the line gets hung up or if the <i>Ctrl+C</i> key gets pressed.
The commands specified to trap must be enclosed in quotes, if they contain more than one command. 
Also note that the shell scans the command line at the time that the trap command gets executed and also when one of the listed signals is received.
Thus, in the preceding example, the value of <b>WORKDIR</b> and <b>$$</b> will be substituted at the time that the trap command is executed. 
If you wanted this substitution to occur at the time that either signal 1 or 2 was received, you can put the commands inside single quotes -
$ trap 'rm $WORKDIR/work1$$ $WORKDIR/dataout$$; exit' 1 2

<h2>&emsp;Ignoring Signals</h2>
If the command listed for trap is null, the specified signal will be ignored when received. 
For example, the command -
$ trap '' 2

This specifies that the interrupt signal is to be ignored. 
You might want to ignore certain signals when performing an operation that you don't want to be interrupted. 
You can specify multiple signals to be ignored as follows -
$ trap '' 1 2 3 15

Note that the first argument must be specified for a signal to be ignored and is not equivalent to writing the following, which has a separate meaning of its own -
$ trap  2

If you ignore a signal, all subshells also ignore that signal. 
However, if you specify an action to be taken on the receipt of a signal, all subshells will still take the default action on receipt of that signal.
<h2>&emsp;Resetting Traps</h2>
After you've changed the default action to be taken on receipt of a signal, you can change it back again with the trap if you simply omit the first argument; so -
$ trap 1 2

This resets the action to be taken on the receipt of signals 1 or 2 back to the default.

<h2><span class="orange">Unix / Linux - Shell Builtin Mathematical Functions</span></h2>
The most of the part of this tutorial covered Bourne Shell but this page list down all the mathematical builti-in functions available in <b>Korn</b> Shell.
The Korn shell provides access to the standard set of mathematical functions. 
They are
called using C function call syntax.
<table class="table table-bordered">
<tr><th style="text-align:center;width:8%">Sr.No.</th><th>Function &amp; Description</th></tr>
<tr><td>1</td><td><b>abs</b>
Absolute value</td></tr>
<tr><td>2</td><td><b>log</b>
Natural logarithm</td></tr>
<tr><td>3</td><td><b>acos</b>
Arc cosine</td></tr>
<tr><td>4</td><td><b>sin</b>
Sine</td></tr>
<tr><td>5</td><td><b>asin</b>
Arc sine</td></tr>
<tr><td>6</td><td><b>sinh</b>
Hyperbolic sine</td></tr>
<tr><td>7</td><td><b>cos</b>
Cosine</td></tr>
<tr><td>8</td><td><b>sqrt</b>
Square root</td></tr>
<tr><td>9</td><td><b>cosh</b>
Hyperbolic cosine</td></tr>
<tr><td>10</td><td><b>tan</b>
Tangent</td></tr>
<tr><td>11</td><td><b>exp</b>
Exponential function</td></tr>
<tr><td>12</td><td><b>tanh</b>
Hyperbolic tangent</td></tr>
<tr><td>13</td><td><b>int</b>
Integer part of floating-point number</td></tr>
</table>

<script src='https://williamkpchan.github.io/LibDocs/readbook.js'></script>
</pre></body></html>
