<base target="_blank"><html><head><title>Learn how to use IndexedDB</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src="https://williamkpchan.github.io/lazyload.min.js"></script>
<script src='https://williamkpchan.github.io/mainscript.js'></script>
<script src="https://williamkpchan.github.io/commonfunctions.js"></script>
<script>
  var showTopicNumber = true;
  var bookid = "Learn how to use IndexedDB"
  var markerName = "h2, h3"
</script>
<style>
body{width:80%;margin-left: 10%; font-size:24px;}
h1, h2 {color: gold;}
strong {color: orange;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px;}
</style></head><body onkeypress="chkKey()"><center>
<h1></h1>
<h1>Learn how to use IndexedDB</h1>
<div id="toc"></div></center>
<pre>
<br><br>

IndexedDB is an <span class="red">API</span> for storing data in user's browser.
One can also use cookies and local storage but they don't provide database like usability the way IndexedDB do.

The data stored in IndexedDB is <span class="red">persistence</span>.

It provides rich query abilities and is available both in online and offline mode.

It can be used to store large amount of data.

<span class="red">>Note: IndexedDB is currently a Candidate Recommendation and is only available in modern desktop web browsers.</span>
IndexedDB stores data in form of objects along with an index key.

Everything that happens in IndexedDB happens through <span class="red">transactions</span>.

The objects are grouped into <span class="red">object stores</span>.

The IndexedDB <span class="red">contains object stores</span> and these object stores <span class="red">contain objects along with a unique keyPath</span>.</span>
<img src="http://dartdoc.takyam.com/docs/tutorials/indexeddb/images/generaldatabase.png">
<h2>IndexedDB vs LocalStorage, Cookies</h2>
Although both were developed to provide <span class="red">client side data storage</span> but both have different approaches and should be chosen according to the needs.

<span class="green">localStorage</span> stores data in key-value pair but unlike IndexedDB, they are not stored in form of objects.

Instead, it stores only string key-value pairs.

A simple trick to store objects in localstorage is to use <span class="redword">JSON.stringify()</span>, similarly to store it back to object form after reading you will need to do <span class="redword">JSON.parse()</span>.

<span class="orange">// our array
var movies = ["Reservoir Dogs", "Pulp Fiction", "Jackie Brown", 
"Kill Bill", "Death Proof", "Inglourious Basterds"];
</span>
// storing our array as a string
<span class="red">localStorage.setItem("thisfilename", JSON.stringify(movies));</span>

// retrieving our data and converting it back into an array
<span class="red">var retrievedData = localStorage.getItem("thisfilename");</span>
var movies2 = JSON.parse(retrievedData);

//making sure it still is an array
alert(movies2.length);

But it will not be a good solution when storing large number of complex objects.

Moreover, <span class="green">localstorage was designed for smaller data and provides synchronous API.</span>
<span class="green">IndexedDB</span> is great for handling large amount of data and comes with asynchronous API.

<span class="green">It uses indexes to store data and transactions to perform operations.</span>

It even supports simple data types.

IndexedDB may seem better than localstorage,but its API is complex to use and currently only latest desktop browsers are supported.


For basic storage you may continue to use local storage but if you are going to store large amount of data, IndexedDB will be a better suited option as it will also allow you to perform <span class="orange">complex search queries</span>.
<h4>IndexedDB vs Web SQL</h4>
<blockquote class="red">Beware.
This specification is no longer in active maintenance and the Web Applications Working Group does not intend to maintain it further.</blockquote>

<h4>IndexedDB vs Cookies</h4>
Cookies may sound tasty but they are not.

Cookies are sent and received with every http request resulting in additional traffic.

e.g.
if you have 10KB of cookies and made 10 request, then total 100KB of data will be transferred.

Also, cookies are only strings and hence need to be parsed.

Also, the space of storing  cookies is limited and many users block their cookies.

Hence cookies can be only good for storing very small non-crucial data.
<h2>How to use IndexedDB</h2>
To understand IndexedDB, I have created a basic web app that stores the roll numbers and names of students in IndexedDB.

It provides basic add, remove, access and update option.
<a href="https://github.com/SuyashMShepHertz/indexedDB_sample">https://github.com/SuyashMShepHertz/indexedDB_sample</a>
<h2>Opening a Database</h2>
<span class="red">Firstly you need to make sure, that your browser supports IndexedDB.</span>

As mentioned earlier, it is still a candidate recommendation and hence not supported in all browsers.
<span class="green">
indexedDB = indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;

if(!indexedDB)
{
  console.log("Your Browser does not support IndexedDB");
}
</span>
Once, we know IndexedDB is supported, we have to open a database.

<span class="green">You can not simply open a database, rather IndexedDB requires you to create a request to open a database.</span>
<span class="green">
 var request = indexedDB.open("testDB", 2);
</span>
here first parameter is the name of database and second parameter is version of database.

The version allows you to represent your DB's current schema i.e the object stores stored in it and their structures.

If you upgrade your database you will only need to create/delete few object stores rather than creating/deleting all the object stores.
When you will increase the version of your database, <span class="green">onupgradeneeded event</span> will be triggered.

Along with onupgradeneeded, there are success, error and blocked events.
<code>
<span class="green">
var db;</span>
<span class="red">request.onerror</span> = function(event){
 console.log("Error opening DB", event);
}
<span class="red">request.onupgradeneeded</span> = function(event){
 console.log("Upgrading");
 db = event.target.result;
 var objectStore = <span class="red">db.createObjectStore</span>("students", { keyPath : "rollNo" });
};
<span class="red">request.onsuccess</span>  = function(event){
 console.log("Success opening DB");
 db = event.target.result;
}
</code>
onupgradeneeded event will be called whenever the webpage is hit for the first time on user's web browser or if there is an upgrade in version of database.

Hence, you will have to create your object stores only in onupgradeneeded event.

If there is no upgrade in version and the page has been opened previously, you will get onsuccess event.

onerror event occurs if there is some error.

onblocked event occurs if previous connection was never closed.
In above code snippet, we are creating a Object Store named “students” with index key “roll no”.
<h2>Adding Object to ObjectStore</h2>
To add data in our DB, we first need to <span class="green">create a transaction with read write permission</span> on our object store.

To perform any action on object store we need to create a transaction.

Following it, access our object store and add the data to it.
<span class="green">
var transaction = <span class="red">db.transaction(["students"],"readwrite");</span></span>
<span class="red">transaction.oncomplete</span> = function(event) {
    console.log("Success");
};

<span class="red">transaction.onerror</span> = function(event) {
    console.log("Error");
};  
var objectStore = <span class="red">transaction.objectStore</span>("students");

<span class="red">objectStore.add({rollNo: rollNo, name: name})</span>;

<strong>Removing Object from ObjectStore</strong>
Deletion is similar to addition, you need to create transaction and call delete function with the key of the object to be removed.
<span class="green">
db.transaction(["students"],"readwrite").objectStore("students").<span class="red">delete(rollNo)</span>;
</span>
I have mixed up statements to make it more easier but they perform the same.
<h2>Accessing an object with the key</h2>
Use the get() function passing the key of the object to be retrieved.
<code>
<span class="green">
var request = db.transaction(["students"],"readwrite").objectStore("students").<span class="red">get(rollNo)</span>;
request.onsuccess = function(event){
    console.log("Name : "+request.result.name);    
};
</span></code>
<strong>Updating an Object</strong>
To update an object, first get that object and then after making changes put back it to object store.
<span class="green">
var transaction = db.transaction(["students"],"readwrite");
var objectStore = transaction.objectStore("students");
var request = objectStore.get(rollNo);
request.onsuccess = function(event){
    console.log("Updating : "+request.result.name + " to " + name);
    request.result.name = name;<
    <span class="red">objectStore.put(request.result)</span>;
};
</span>
The full source code of above sample web page is <a href="https://github.com/SuyashMShepHertz/indexedDB_sample/blob/master/index.html" title="sample app" target="_blank">here</a>.

If you have any questions or need any further assistance, please feel free to write us at <a href="mailto:support@shephertz.com">support@shephertz.com</a>.


Please check out the demo before we start the tutorial.
a href="http://www.onlywebpro.com/demo/jquery/indexeddb.html" target="_blank" class="demo_btn">View Demo</a>

<h2>Get Started Example</h2>
Since we know that the IndexedDB API is still evolve, so we need to include the following prefixes of implementation. 
Besides, for best practice, we should always provide fallback content for unsupported browsers.
<code>
//prefixes of implementation that we want to test
indexedDB = indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;

//prefixes of window.IDB objects
window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction;
window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange

if (!indexedDB) {
window.alert("Your browser doesn't support a stable version of IndexedDB.")
}
</code>
<h2>Opening an IndexedDB Database</h2>
Before we create the database, the very first thing to do is to prepare some data for the database. 
Let say we have some customer information as shown below:
<code>
const customerData = [
 { id: "00-01", name: "Bill", age: 35, email: "bill@company.com" },
 { id: "00-02", name: "Donna", age: 32, email: "donna@home.org" }
];

</code>
2 data enetries, each entry consists of the information of ID, name, age and email of the customer.
Before we can insert the data into the database, we need to open our database using the <strong>open()</strong> method as shown below:
<code>
var db;
var request = indexedDB.open("newDatabase", 1);
  request.onerror = function(event) { console.log("error: "); };
  request.onsuccess = function(event) {
    db = request.result;
    console.log("success: "+ db);
  };
  request.onupgradeneeded = function(event) {}
</code>
As you can see we have opened a database with the name &#8220;<strong>newDatabase</strong>&#8221; and the version of the database. 
 All IndexedDB databases are stored in the same origin with the web application / website. 
Example, if myblog.com might has a database named &#8220;newDatabase&#8221; and mybusiness.com also might has a totally distinct database named &#8220;newDatabase&#8221;.
The open() method has accepts <strong>2 parameters</strong>, the first is the name ofthe database. 
It will checks whether the database named &#8220;newDatabase&#8221; is already exist or not, if it is exist, then it will open the database, else it will create a new one. 
The second paramter of open() method is the version of the database, which allows you to update the schema of the database.
<h4>Onsuccess handler</h4>
If everything succeeds, then a success event &#8220;<strong>onsuccess</strong>&#8221; is fired with request as its target and we have save the request&#8217;s result for later use by assigning it to <strong>db </strong>variable.
<h4>Onerror handler</h4>
If the process of opening database fail, then an error event &#8220;<strong>onerror</strong>&#8221; is fired.
<h4>Onupgradeneeded handler</h4>
If you want to update the database, or to create, delete or modify the database, then you have to implement the onupgradeneeded handler or which will be called as part of a <strong>versionchange </strong>transaction that allows you to make any changes on the database. 
Please bear in mind that, the &#8220;<strong>onupgradeneeded</strong>&#8221; handler is the only place for you to alter the structure of database.
<h2>Structuring the Database</h2>
Again, IndexedDB is <strong>NOT </strong>same as a Relational Database. 
IndexedDB uses object stores to store data rather than tables. 
Whenever a value is stored in an object store, it is associated with a key. 
The interesting of IndexedDB is it allows us to create indices on any object store. 
An index lets us to access the values stored in object store using the value of a property of the stored object. 
This may sound confusing now, but you may know it better after go through the entire lesson.
The following code illustrates how we create the object store and insert the pre-prepared data into it:
<code>
request.onupgradeneeded = function(event) {
 var db = event.target.result;
 var objectStore = db.createObjectStore("customers", {keyPath: "id"});
 for (var i in customerData) {
objectStore.add(customerData[i]); 
 }
}
</code>
We create an object store using <strong>createObjectStore()</strong> method. 
This method accepts 2 parameters: &ndash; name of the store and a parameter object. 
In this case, we have named the object store as &#8220;customers&#8221; and defined a keyPath that is the property that makes an individual object in the store unique. 
In this example, we have use the &#8220;id&#8221; as keyPath, which is unique value in the object store, and you must make sure that the &#8220;id&#8221; property must be present in every objects in the object store.
Once the object store is created, we can start adding the data into it using <strong>for </strong>loop.
<h2>Manually Adding Data</h2>
You may probably want to manually add extra data into the database, then here is how you should write the function:
<code>
function add() {
 var request = db.transaction(["customers"], "readwrite")
.objectStore("customers")
.add({ id: "00-03", name: "Kenny", age: 19, email: "kenny@planet.org" });
    
 request.onsuccess = function(event) {
  alert("Kenny has been added to your database.");
 };
 
 request.onerror = function(event) {
alert("Unable to add data\r\nKenny is aready exist in your database! ");  
 }
 
}
</code>
We have just manually added a new data named with &#8220;Kenny&#8221; to the object store &#8220;customer&#8221; using <strong>add()</strong> method.
Before we can do anything (read, write, modify) to our database, we have to start use a <strong>transaction</strong>. 
The transaction() method is used to specify which object stores you want the transaction to span. 
The transaction() mthod accepts 3 parameters (second and third are optional): &ndash; First is the list of object store you want to deal with, second is whether you want to read only or read and write to the object, third is the versionchange.
The transaction method let you have the object store that you specified and insert, modify or delete the data that you need. 
In this case, we insert the data using <strong>add()</strong> method.
<h2>Retrieving Data</h2>
Let&#8217;s retrieve the data from the database. 
We can retrieve the data using <strong>get()</strong> method.
<code>
function read() {
 var transaction = db.transaction(["customers"]);
 var objectStore = transaction.objectStore("customers");
 var request = objectStore.get("00-03");
 request.onerror = function(event) {
alert("Unable to retrieve daa from database!");
 };
 request.onsuccess = function(event) {
// Do something with the request.result!
if(request.result) {
  alert("Name: " + request.result.name + ", Age: " + request.result.age + ", Email: " + request.result.email);
} else {
alert("Kenny couldn't be found in your database!");  
}
 };
}
</code>
We use <strong>get()</strong> method to retrieve the data we need from object store. 
Since we already set the id of object as keyPath earlier, so the get() method will look up the object that has the same id value. 
This will return us the object named &#8220;Kenny&#8221;which is the object that we manually added in the previous function.
<h4>Retrieving All Data</h4>
If you want get all data instead of one from object store, then you may need to use a <strong>cursor</strong>. 
Here is another function that using cursor to retrieve all data from object store: 
<code>
function readAll() {
 var objectStore = db.transaction("customers").objectStore("customers");

 objectStore.openCursor().onsuccess = function(event) {
var cursor = event.target.result;
if (cursor) {
alert("Name for id " + cursor.key + " is " + cursor.value.name + ", Age: " + cursor.value.age + ", Email: " + cursor.value.email);
cursor.continue();
}
else {
alert("No more entries!");
}
 };  
}
</code>
As you can see, we implement the <strong>openCursor()</strong> method to accomplish the goal. 
The openCursor() is used to iterate over multiple records in a database. 
It can accepts several parameters, such as limit the range items, the direction that we want to iterate and etc. 
In this case, we leave it no parameters.
The cursor object itself is the result of the request. 
We have implement the <strong>continue()</strong> function to continues with the next iteration in the loop. 
When the loop reached end, then we will get the alert with content &#8220;No more entries!&#8221;.
<h2>Removing Data</h2>
Removing data from object store is very similar to other functions that we have just learnt. 
Here is how the code looks like:
<code>
function remove() {

 var request = db.transaction(["customers"], "readwrite")
.objectStore("customers")
.delete("00-03");
 request.onsuccess = function(event) {
alert("Kenny's entry has been removed from your database.");
 };
}
</code>
If you want to remove data from object store, then you may need to use <strong>delete()</strong> method. 
You have to pass the keyPath of the object that you want to remove as paramter to the delete() method. 
In this case, we remove the object with named &#8220;Kenny&#8221; which we added via add function just now.
<h2>The HTML</h2>
We have just wrote all the functions, and now is the time to display the data using the onclick event that binded to HTML button.
<code>
&lt;!DOCTYPE html&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
&lt;title&gt;IndexedDb Demo | onlyWebPro.com&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;button onclick="read()"&gt;Read single data from indexedDb&lt;/button&gt;
&lt;button onclick="readAll()"&gt;Read all data from indexedDb&lt;/button&gt;
&lt;button onclick="add()"&gt;Add data to indexedDb&lt;/button&gt;
&lt;button onclick="remove()"&gt;Delete data from indexedDb&lt;/button&gt;
&lt;/body&gt;
&lt;/html&gt;
</code>
We have prepared 4 HTML buttons. 
Each of the button is used to trigger the Javascript function that we wrote earlier in this article. 
Save your document and view it in supported browser. 
Have fun! 🙂
<h2>The Final Code</h2>
<code>
&lt;!DOCTYPE html&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
&lt;title&gt;IndexedDb Demo | onlyWebPro.com&lt;/title&gt;
&lt;script type="text/javascript"&gt;
//prefixes of implementation that we want to test
indexedDB = indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;

//prefixes of window.IDB objects
window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction;
window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange

if (!indexedDB) {
window.alert("Your browser doesn't support a stable version of IndexedDB.")
}

const customerData = [
 { id: "00-01", name: "Bill", age: 35, email: "bill@company.com" },
 { id: "00-02", name: "Donna", age: 32, email: "donna@home.org" }
];


var db;
var request = indexedDB.open("newDatabase", 1);
  request.onerror = function(event) { console.log("error: "); };
  request.onsuccess = function(event) {
    db = request.result;
    console.log("success: "+ db);
  };
  request.onupgradeneeded = function(event) {
    var db = event.target.result;
    var objectStore = db.createObjectStore("customers", {keyPath: "id"});
    for (var i in customerData) { objectStore.add(customerData[i]); }
  }

function read() {
  var transaction = db.transaction(["customers"]);
  var objectStore = transaction.objectStore("customers");
  var request = objectStore.get("00-03");
  request.onerror = function(event) {
    alert("Unable to retrieve daa from database!");
  };
  request.onsuccess = function(event) {
    // Do something with the request.result!
    if(request.result) {
      alert("Name: " + request.result.name + ", Age: " + request.result.age + ", Email: " + request.result.email);
    } else {
      alert("Kenny couldn't be found in your database!");  
    }
  };
}

function readAll() {
  var objectStore = db.transaction("customers").objectStore("customers");
  objectStore.openCursor().onsuccess = function(event) {
    var cursor = event.target.result;
    if (cursor) {
      alert("Name for id " + cursor.key + " is " + cursor.value.name + ", Age: " + cursor.value.age + ", Email: " + cursor.value.email);
      cursor.continue();
    } else {
      alert("No more entries!");
    }
  };  
}

function add() {
  var request = db.transaction(["customers"], "readwrite")
    .objectStore("customers")
    .add({
          id: "00-03", name: "Kenny", age: 19,
          email: "kenny@planet.org" });
  request.onsuccess = function(event) {
    alert("Kenny has been added to your database.");
  };
 
  request.onerror = function(event) {
    alert("Unable to add data\r\nKenny aready exist! ");  
  }
}

function remove() {
  var request = db.transaction(["customers"], "readwrite")
    .objectStore("customers").delete("00-03");
  request.onsuccess = function(event) {
    alert("Kenny's entry has been removed from your database.");
  };
}

&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;button onclick="read()"&gt;Read single data from indexedDb&lt;/button&gt;
&lt;button onclick="readAll()"&gt;Read all data from indexedDb&lt;/button&gt;
&lt;button onclick="add()"&gt;Add data to indexedDb&lt;/button&gt;
&lt;button onclick="remove()"&gt;Delete data from indexedDb&lt;/button&gt;
&lt;/body&gt;
&lt;/html&gt;
</code>
a href="http://www.onlywebpro.com/demo/jquery/indexeddb.html" target="_blank" class="demo_btn">View Demo</a>
<h2>Conclusion</h2>
The HTML5 IndexedDB API is very useful and powerful. 
You can leverage it to create rich, online and offline HTML5 application. 
In addition, with IndexedDB API, you can cache data to make traditional web applications especially mobile web applications load faster and more responsive without need to retrieve data from the web server each time. 





<a href="https://blog.teamtreehouse.com/create-your-own-to-do-app-with-html5-and-indexeddb">Create Your Own To-Do App with HTML5 and IndexedDB</a>


<h2><span class="orange">IndexedDB Introduction</span></h2>
We are using Jake Archibald's <a href="https://github.com/jakearchibald/indexeddb-promised">IndexedDB Promised</a> library, which is very similar to the IndexedDB API, but uses promises rather than events. 
This simplifies the API while maintaining its structure, so anything you learn using this library can be applied to the IndexedDB API directly.
<h2>Checking for IndexedDB support</h2>
Because IndexedDB isn't supported by all browsers, we need to check that the  <a href="http://caniuse.com/#search=indexeddb">user's browser supports it</a> before using it. 
The easiest way is to check the window object:

<code>if (!('indexedDB' in window)) {
  console.log('This browser doesn\'t support IndexedDB');
  return;
}
</code>

We simply place this function at the beginning of our scripts and we're ready to use IndexedDB.

<h2>Opening a database</h2>

With IndexedDB you can create multiple databases with any names you choose. 
In general, there is just one database per app. 
To open a database, we use:

<code>idb.open(name, version, upgradeCallback)
</code>

This method returns a promise that resolves to a database object. 
When using <code>idb.open</code>, you provide a name, version number, and an optional callback to set up the database.

Here is an example of <code>idb.open</code> in context:

<code>(function() {
  'use strict';

  //check for support
  if (!('indexedDB' in window)) {
    console.log('This browser doesn\'t support IndexedDB');
    return;
  }

  var dbPromise = idb.open('test-db1', 1);

})();
</code>

We place our check for IndexedDB support at the top of the anonymous function. 
This exits out of the function if the browser doesn't support IndexedDB. 
We call <code>idb.open</code> to open a database named "test-db1". 
We have left out the optional callback function in this first example to keep things simple.

<h2>Working with object stores</h2>

<h3> . - Creating object stores</h3>

A database typically contains one or more object stores. 
Object stores can be thought of as similar to tables in SQL databases and should contain objects of the same "type" (not JavaScript data type). 
For example, for a site persisting user profiles and notes, we can imagine a "people" object store containing "person" objects, and a "notes" object store. 
A well structured IndexedDB database should have one object store for each type of data you need to persist.

To ensure database integrity, object stores can only be created and removed in the callback function in <code>idb.open</code>. 
The callback receives an instance of UpgradeDB, a special object in the IDB Promised library that is used to create object stores. 
Call the  <a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBDatabase/createObjectStore">createObjectStore</a> method on UpgradeDB to create the object store:

<code>upgradeDb.createObjectStore('storeName', options);
</code>

This method takes the name of the object store as well as a parameter object that lets us define various configuration properties for the object store.

Below is an example of the <code>createObjectStore</code> method:

<code>(function() {
  'use strict';

  //check for support
  if (!('indexedDB' in window)) {
    console.log('This browser doesn\'t support IndexedDB');
    return;
  }

  var dbPromise = idb.open('test-db2', 1, function(upgradeDb) {
    console.log('making a new object store');
    if (!upgradeDb.objectStoreNames.contains('firstOS')) {
      upgradeDb.createObjectStore('firstOS');
    }
  });

})();
</code>

Again, we first check the browser for IndexedDB support. 
This time we include the callback function in <code>idb.open</code> in order to create the object store. 
The browser throws an error if we try to create an object store that already exists in the database so we wrap the <code>createObjectStore</code> method in an <code>if</code> statement that checks if the object store exists. 
Inside the <code>if</code> block we call <code>createObjectStore</code> on the UpgradeDB object to create an object store named "firstOS".

<h3> . - Defining primary keys</h3>

When you define object stores, you can define how data is uniquely identified in the store using the primary key. 
You can define a primary key by either defining a key path, or by using a key generator.

A  <em>key path</em>  is a property that always exists and contains a unique value. 
For example, in the case of a "people" object store we could choose the email address as the key path.

<code>upgradeDb.createObjectStore('people', {keyPath: 'email'});
</code>

This example creates an object store called "people" and assigns the "email" property as the primary key.

You could also use a key generator, such as <code>autoIncrement</code>. 
The key generator creates a unique value for every object added to the object store. 
By default, if we don't specify a key, IndexedDB creates a key and stores it separately from the data.

<code>upgradeDb.createObjectStore('notes', {autoIncrement:true});
</code>

This example creates an object store called "notes" and sets the primary key to be assigned automatically as an auto incrementing number.

<code>upgradeDb.createObjectStore('logs', {keyPath: 'id', autoIncrement:true});
</code>

This example is similar to the previous example, but this time the auto incrementing value is assigned to a property called "id".

Choosing which method to use to define the key depends on your data. 
If your data has a property that is always unique, you can make it the keypath to enforce this uniqueness. 
Otherwise, using an auto incrementing value makes sense.

Let's look at an example:

<code>function() {
  'use strict';

  //check for support
  if (!('indexedDB' in window)) {
    console.log('This browser doesn\'t support IndexedDB');
    return;
  }

  var dbPromise = idb.open('test-db3', 1, function(upgradeDb) {
    if (!upgradeDb.objectStoreNames.contains('people')) {
      upgradeDb.createObjectStore('people', {keyPath: 'email'});
    }
    if (!upgradeDb.objectStoreNames.contains('notes')) {
      upgradeDb.createObjectStore('notes', {autoIncrement: true});
    }
    if (!upgradeDb.objectStoreNames.contains('logs')) {
      upgradeDb.createObjectStore('logs', {keyPath: 'id', autoIncrement: true});
    }
  });
})();
</code>

This code creates three object stores demonstrating the various ways of defining primary keys in object stores.

<h3> . - Defining indexes</h3>

Indexes are a kind of object store used to retrieve data from the reference object store by a specified property. 
An index lives inside the reference object store and contains the same data, but uses the specified property as its key path instead of the reference store's primary key. 
Indexes must be made when you create your object stores and can also be used to define a unique constraint on your data.

To create an index, call the  <a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/createIndex">createIndex</a> method on an object store instance:

<code>objectStore.createIndex('indexName', 'property', options);
</code>

This method creates and returns an index object. 
<code>createIndex</code> takes the name of the new index as the first argument, and the second argument refers to the property on the data you want to index. 
The final argument lets you define two options that determine how the index operates:  <em>unique</em>  and  <em>multiEntry</em> . 
If  <em>unique</em>  is set to true, the index does not allow duplicate values for a single key. 
 <em>multiEntry</em>  determines how <code>createIndex</code> behaves when the indexed property is an array. 
If it's set to true, <code>createIndex</code> adds an entry in the index for each array element. 
Otherwise, it adds a single entry containing the array.

Here is an example:

<code>(function() {
  'use strict';

  //check for support
  if (!('indexedDB' in window)) {
    console.log('This browser doesn\'t support IndexedDB');
    return;
  }

  var dbPromise = idb.open('test-db4', 1, function(upgradeDb) {
    if (!upgradeDb.objectStoreNames.contains('people')) {
      var peopleOS = upgradeDb.createObjectStore('people', {keyPath: 'email'});
      peopleOS.createIndex('gender', 'gender', {unique: false});
      peopleOS.createIndex('ssn', 'ssn', {unique: true});
    }
    if (!upgradeDb.objectStoreNames.contains('notes')) {
      var notesOS = upgradeDb.createObjectStore('notes', {autoIncrement: true});
      notesOS.createIndex('title', 'title', {unique: false});
    }
    if (!upgradeDb.objectStoreNames.contains('logs')) {
      var logsOS = upgradeDb.createObjectStore('logs', {keyPath: 'id',
        autoIncrement: true});
    }
  });
})();
</code>

In this example, the "people" and "notes" object stores have indexes. 
To create the indexes, we first assign the result of <code>createObjectStore</code> (which is an object store object) to a variable so we can call <code>createIndex</code> on it.

<aside><strong>Note:</strong> Indexes are updated every time you write data to the reference object store. 
More indexes mean more work for IndexedDB.</aside>

<h2>Working with data</h2>

In this section, we describe how to create, read, update, and delete data. 
These operations are all asynchronous, using promises where the IndexedDB API uses requests. 
This simplifies the API. 
Instead of listening for events triggered by the request, we can simply call <code>.then</code> on the database object returned from <code>idb.open</code> to start interactions with the database.

All data operations in IndexedDB are carried out inside a transaction. 
Each operation has this form:

Get database object
Open transaction on database
Open object store on transaction
Perform operation on object store

A transaction can be thought of as a safe wrapper around an operation or group of operations. 
If one of the actions within a transaction fail, all of the actions are rolled back. 
Transactions are specific to one or more object stores, which we define when we open the transaction. 
They can be read-only or read and write. 
This signifies whether the operations inside the transaction read the data or make a change to the database.

<h3> . - Creating data</h3>

To create data, call the  <a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/add">add</a> method on the object store and pass in the data you want to add. 
Add has an optional second argument that lets you define the primary key for the individual object on creation, but it should only be used if you have not specified the key path in <code>createObjectStore</code>. 
Here is a simple example:

<code>someObjectStore.add(data, optionalKey);
</code>

The data parameter can be data of any type: a string, number, object, array, and so forth. 
The only restriction is if the object store has a defined keypath, the data must contain this property and the value must be unique. 
The add method returns a promise that resolves once the object has been added to the store.

Add occurs within a transaction, so even if the promise resolves successfully it doesn't necessarily mean the operation worked. 
Remember, if one of the actions in the transaction fails, all of the operations in the transaction are rolled back. 
To be sure that the add operation was carried out, we need to check if the whole transaction has completed using the <code>transaction.complete</code> method. 
<code>transaction.complete</code> is a promise that resolves when the transaction completes and rejects if the transaction errors. 
Note that this method doesn't actually close the transaction. 
The transaction completes on its own. 
We must perform this check for all "write" operations, because it is our only way of knowing that the changes to the database have actually been carried out.

Let's look at an example of the <code>add</code> method:

<code>dbPromise.then(function(db) {
  var tx = db.transaction('store', 'readwrite');
  var store = tx.objectStore('store');
  var item = {
    name: 'sandwich',
    price: 4.99,
    description: 'A very tasty sandwich',
    created: new Date().getTime()
  };
  store.add(item);
  return tx.complete;
}).then(function() {
  console.log('added item to the store os!');
});
</code>

First, we get the database object. 
We call <code>.then</code> on <code>dbPromise</code>, which resolves to the database object, and pass this object to the callback function in <code>.then</code>. 
Because <code>dbPromise</code> (<code>idb.open</code>) is a promise, we can safely assume that when <code>.then</code> executes, the database is open and all object stores and indexes are ready for use.

The next step is to open a transaction by calling the <code>transaction</code> method on the database object. 
This method takes a list of object stores, which defines the scope of the transaction (if it is a single store name, we can pass it directly instead of passing an array of names, as we did in our example where we only want the "store" object store). 
The transaction method also has an optional second argument for the mode, which can be <code>readonly</code> or <code>readwrite</code>. 
This option is read-only by default.

We can then open the "store" object store on this transaction and assign it to the <code>store</code> variable. 
Now when we call <code>store.add</code>, the add operation occurs within the transaction. 
Finally, we return <code>tx.complete</code> and log a success message once the transaction has completed.

<h3> . - Reading data</h3>

To read data, call the  <a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/get"><code>get</code></a> method on the object store. 
The <code>get</code> method takes the primary key of the object you want to retrieve from the store. 
Here is a basic example:

<code>someObjectStore.get(primaryKey);
</code>

As with <code>add</code>, the <code>get</code> method returns a promise and must happen within a transaction.

Let's look at an example of the <code>get</code> method:

<code>dbPromise.then(function(db) {
  var tx = db.transaction('store', 'readonly');
  var store = tx.objectStore('store');
  return store.get('sandwich');
}).then(function(val) {
  console.dir(val);
});
</code>

Once again, we start the operation by getting the database object and creating a transaction. 
Note that this time it is a read-only transaction because we are not writing anything to the database inside the transaction (that is, using <code>put</code>, <code>add</code>, or <code>delete</code>). 
We then open the object store on the transaction and assign the resulting object store object to the <code>store</code> variable. 
Finally, we return the result of <code>store.get</code> and log this object to the console.

<aside><strong>Note:</strong> If you try to get an object that doesn't exist, the success handler still executes, but the result is <code>undefined</code>.</aside>
<h3> . - Updating data</h3>

To update data, call the  <a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/put"><code>put</code></a> method on the object store. 
The <code>put</code> method is very similar to the <code>add</code> method and can be used instead of <code>add</code> to create data in the object store. 
Like <code>add</code>, <code>put</code> takes the data and an optional primary key:

<code>someObjectStore.put(data, optionalKey);
</code>

Again, this method returns a promise and occurs inside a transaction. 
As with <code>add</code>, we need to be careful to check <code>transaction.complete</code> if we want to be sure that the operation was actually carried out.

Here is an example using the <code>put</code> method:

<code>dbPromise.then(function(db) {
  var tx = db.transaction('store', 'readwrite');
  var store = tx.objectStore('store');
  var item = {
    name: 'sandwich',
    price: 99.99,
    description: 'A very tasty, but quite expensive, sandwich',
    created: new Date().getTime()
  };
  store.put(item);
  return tx.complete;
}).then(function() {
  console.log('item updated!');
});
</code>

To update an existing item in the object store, use the <code>put</code> method on an object containing the same primary key value as the object in the store. 
We are assuming the keyPath for the store object store is the "name" property and we are updating the price and description of our "sandwich" object. 
The database interaction has the same structure as the create and read operations: get the database object, create a transaction, open an object store on the transaction, perform the operation on the object store.

<h3> . - Deleting data</h3>

To delete data, call the  <a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/delete"><code>delete</code></a> method on the object store.

<code>someObjectStore.delete(primaryKey);
</code>

Once again, this method returns a promise and must be wrapped in a transaction. 
Here is a simple example:

<code>dbPromise.then(function(db) {
  var tx = db.transaction('store', 'readwrite');
  var store = tx.objectStore('store');
  store.delete(key);
  return tx.complete;
}).then(function() {
  console.log('Item deleted');
});
</code>

The structure of the database interaction is the same as for the other operations. 
Note that we again check that the whole transaction has completed by returning the <code>tx.complete</code> method to be sure that the delete was carried out.

<h2>Getting all the data</h2>

So far we have only retrieved objects from the store one at a time. 
We can also retrieve all of the data (or subset) from an object store or index using either the <code>getAll</code> method or using cursors.

<h3> . - Using the getAll method</h3>

The simplest way to retrieve all of the data is to call the <code>getAll</code> method on the object store or index, like this:

<code>someObjectStore.getAll(optionalConstraint);
</code>

This method returns all the objects in the object store matching the specified key or key range, or all objects in the store if no parameter is given. 
As with all other database operations, this operation happens inside a transaction. 
Here is a short example:

<code>dbPromise.then(function(db) {
  var tx = db.transaction('store', 'readonly');
  var store = tx.objectStore('store');
  return store.getAll();
}).then(function(items) {
  console.log('Items by name:', items);
});
</code>

Here we are calling <code>getAll</code> on the "store" object store. 
This returns all of the objects in the store ordered by the primary key.

<h3> . - Using cursors</h3>

Another way to retrieve all of the data is to use a cursor. 
A cursor selects each object in an object store or index one by one, letting you do something with the data as it is selected. 
Cursors, like the other database operations, work within transactions.

We create the cursor by calling the  <a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/openCursor">openCursor</a> method on the object store, like this:

<code>someObjectStore.openCursor(optionalKeyRange, optionalDirection);
</code>

This method returns a promise that resolves with a cursor object representing the first object in the object store or <code>undefined</code> if there is no object. 
To move on to the next object in the object store, we call <code>cursor.continue</code>. 
This returns a promise that resolves with the next object, or <code>undefined</code> if there are no more objects. 
We put this inside a loop to move through all of the entries in the store one by one. 
The optional key range in the <code>openCursor</code> method limits the iteration to a subset of the objects in the store. 
The direction option can be <code>next</code> or <code>prev</code>, specifying forward or backward traversal through the data.

The next example uses a cursor to iterate through all the items in the "store" object store and log them to the console:

<code>dbPromise.then(function(db) {
  var tx = db.transaction('store', 'readonly');
  var store = tx.objectStore('store');
  return store.openCursor();
}).then(function logItems(cursor) {
  if (!cursor) {
    return;
  }
  console.log('Cursored at:', cursor.key);
  for (var field in cursor.value) {
    console.log(cursor.value[field]);
  }
  return cursor.continue().then(logItems);
}).then(function() {
  console.log('Done cursoring');
});
</code>

As usual, we start by getting the database object, creating a transaction, and opening an object store. 
We call the <code>openCursor</code> method on the object store and pass the cursor object to the callback function in <code>.then</code>. 
This time we name the callback function "logItems" so we can call it from inside the function and make a loop. 
The line <code>if (!cursor) {return;}</code> breaks the loop if the promise returned by <code>store.openCursor()</code> resolves with <code>undefined</code>, or if the promise returned by <code>cursor.continue()</code>resolves with <code>undefined</code> (indicating that there are no more objects).

The cursor object contains a <code>key</code> property that represents the primary key for the item. 
It also contains a <code>value</code> property that represents the data. 
At the end of <code>logItems</code>, we return <code>cursor.continue().then(logItems)</code>. 
The <code>cursor.continue</code> method returns a promise that resolves to a cursor object representing the next item in the store or <code>undefined</code> if there are no more objects. 
This result is passed to the callback function in <code>.then,</code> which we have chosen to be <code>logItems,</code>so that the function loops. 
Consequently, <code>logItems</code> continues to call itself until no objects remain.

<h3> . - Working with ranges and indexes</h3>

We can get all the data in a couple of different ways, but what if we want only a subset of the data based on a particular property? This is where indexes come in. 
Indexes let us fetch the data in an object store by a property other than the primary key. 
We can create an index on any property (which becomes the keypath for the index), specify a range on that property, and get the data within the range using the <code>getAll</code> method or a cursor.

We define the range using the <code>IDBKeyRange</code> object. 
This object has four methods that are used to define the limits of the range: <code>upperBound</code>, <code>lowerBound</code>, <code>bound</code> (which means both), and <code>only</code>. 
As expected, the <code>upperBound</code> and <code>lowerBound</code> methods specify the upper and lower limits of the range.

<code>IDBKeyRange.lowerBound(indexKey);
</code>

Or

<code>IDBKeyRange.upperBound(indexKey);
</code>

They each take one argument which is be the index's keypath value of the item you want to specify as the upper or lower limit.

The <code>bound</code> method is used to specify both an upper and lower limit, and takes the lower limit as the first argument:

<code>IDBKeyRange.bound(lowerIndexKey, upperIndexKey);
</code>

The range for these functions is inclusive by default, but can be specified as exclusive by passing <code>true</code> as the second argument (or the third and fourth in the case of <code>bound</code>, for the lower and upper limits respectively). 
An inclusive range includes the data at the limits of the range. 
An exclusive range does not.

Let's look at an example. 
For this demo, we have created an index on the "price" property in the "store" object store. 
We have also added a small form with two inputs for the upper and lower limits of the range. 
Imagine we are passing in the lower and upper bounds to the function as floating point numbers representing prices:

<code>function searchItems(lower, upper) {
  if (lower === ' && upper === ') {return;}

  var range;
  if (lower !== ' && upper !== ') {
    range = IDBKeyRange.bound(lower, upper);
  } else if (lower === ') {
    range = IDBKeyRange.upperBound(upper);
  } else {
    range = IDBKeyRange.lowerBound(lower);
  }

  dbPromise.then(function(db) {
    var tx = db.transaction(['store'], 'readonly');
    var store = tx.objectStore('store');
    var index = store.index('price');
    return index.openCursor(range);
  }).then(function showRange(cursor) {
    if (!cursor) {return;}
    console.log('Cursored at:', cursor.key);
    for (var field in cursor.value) {
      console.log(cursor.value[field]);
    }
    return cursor.continue().then(showRange);
  }).then(function() {
    console.log('Done cursoring');
  });
}
</code>

The code first gets the values for the limits and checks if the limits exist. 
The next block of code decides which method to use to limit the range based on the values. 
In the database interaction, we open the object store on the transaction as usual, then we open the "price" index on the object store. 
The "price" index allows us to search for the items by price. 
We open a cursor on the index and pass in the range. 
The cursor now returns a promise representing the first object in the range, or <code>undefined</code> if there is no data within the range. 
<code>cursor.continue</code> returns a cursor a object representing the next object and so on through the loop until we reach the end of the range.

<h2>Using database versioning</h2>

When we call <code>idb.open</code>, we can specify the database version number in the second parameter. 
If this version number is greater than the version of the existing database, the upgrade callback executes, allowing us to add object stores and indexes to the database.

<aside><strong>Note:</strong> The browser throws an error if we try to create object stores or indexes that already exist in the database. 
We can wrap the calls to <code>createObjectStore</code> in <code>if</code> statements checking if the object store already exists using <code>upgradeDb.objectStoreNames.contains('objectStoreName')</code>. 
We can also use a <code>switch</code> statement on the <code>oldVersion</code> property as in the next example.</aside>

The UpgradeDB object has a special <code>oldVersion</code> property, which indicates the version number of the database existing in the browser. 
We can pass this version number into a <code>switch</code> statement to execute blocks of code inside the upgrade callback based on the existing database version number. 
Let's look at an example:

<code>var dbPromise = idb.open('test-db7', 2, function(upgradeDb) {
  switch (upgradeDb.oldVersion) {
    case 0:
      upgradeDb.createObjectStore('store', {keyPath: 'name'});
    case 1:
      var peopleStore = upgradeDb.transaction.objectStore('store');
      peopleStore.createIndex('price', 'price');
  }
});
</code>

In the example we have set the newest version of the database at 2. 
When this code first executes, since the database doesn't yet exist in the browser, <code>upgradeDb.oldVersion</code> is 0 and the <code>switch</code> statement starts at <code>case 0</code>. 
In our example, this results in a "store" object store being added to the database. 
Usually, in switch statements, there is a break after each case, but we are deliberately not doing that here. 
This way, if the existing database is a few versions behind (or if it doesn't exist), the code continues through the rest of the case blocks until it has executed all the latest changes. 
So in our example, the browser continues executing through <code>case 1</code>, creating a "price" index on the "store" object store. 
Once this has finished executing, the database in the browser is at version 2 and contains a "store" object store with a "price" index.

Let's say we now want to create a "description" index on the "store" object store. 
We need to update the version number and add a case, like this:

<code>var dbPromise = idb.open('test-db7', 3, function(upgradeDb) {
  switch (upgradeDb.oldVersion) {
    case 0:
      upgradeDb.createObjectStore('store', {keyPath: 'name'});
    case 1:
      var storeOS = upgradeDb.transaction.objectStore('store');
      storeOS.createIndex('price', 'price');
    case 2:
      var storeOS = upgradeDb.transaction.objectStore('store');
      storeOS.createIndex('description', 'description');
  }
});
</code>

Assuming the database we created in the previous example still exists in the browser, when this executes <code>upgradeDb.oldVersion</code> is 2. 
<code>case 0</code> and <code>case 1</code> are skipped and the browser executes the code in <code>case 2</code>, which creates a "description" index. 
Once all this has finished, the browser has a database at version 3 containing a "store" object store with "price" and "description" indexes.

<h2>Further reading</h2>

<h3> . - IndexedDB Documentation</h3>

<a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB">Using IndexedDB</a> - MDN
<a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Basic_Concepts_Behind_IndexedDB">Basic Concepts Behind indexedDB</a> - MDN
<a href="https://www.w3.org/TR/IndexedDB/">Indexed Database API</a> - W3C

<h3> . - Data storage limits</h3>

<a href="http://www.html5rocks.com/en/tutorials/offline/quota-research/">Working with quota on mobile browsers</a>
<a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Browser_storage_limits_and_eviction_criteria">Browser storage limits and eviction criteria</a>

<h2>Appendix</h2>

<h3> . - Comparison of IndexedDB API and IndexedDB Promised library</h3>

The IndexedDB Promised library sits on top of the IndexedDB API, translating its requests into promises. 
The overall structure is the same between the library and the API and, in general, the actual syntax for the database operations is the same and they will act the same way. 
But there are a few differences because of the differences between requests and promises, which we will cover here.

All database interactions in the IndexedDB API are requests and have associated <code>onsuccess</code> and <code>onerror</code> event handlers. 
These are similar to the <code>.then</code> and <code>.catch</code> promise functions. 
The <code>indexedDB.open</code> method in the raw API also gets a special event handler, <code>onupgradeneeded</code>, which is used to create the object stores and indexes. 
This is equivalent to the upgrade callback in <code>idb.open</code> in the Promised library. 
In fact, if you look through the Promised library, you will find the upgrade callback is just a convenient wrapper for the <code>onupgradeneeded</code> event handler.

Let's look at an example of the IndexedDB API. 
In this example we will open a database, add an object store, and add one item to the object store:

<code>var db;

var openRequest = indexedDB.open('test_db', 1);

openRequest.onupgradeneeded = function(e) {
  var db = e.target.result;
  console.log('running onupgradeneeded');
  if (!db.objectStoreNames.contains('store')) {
    var storeOS = db.createObjectStore('store',
      {keyPath: 'name'});
  }
};
openRequest.onsuccess = function(e) {
  console.log('running onsuccess');
  db = e.target.result;
  addItem();
};
openRequest.onerror = function(e) {
  console.log('onerror!');
  console.dir(e);
};

function addItem() {
  var transaction = db.transaction(['store'], 'readwrite');
  var store = transaction.objectStore('store');
  var item = {
    name: 'banana',
    price: '$2.99',
    description: 'It is a purple banana!',
    created: new Date().getTime()
  };

 var request = store.add(item);

 request.onerror = function(e) {
    console.log('Error', e.target.error.name);
  };
  request.onsuccess = function(e) {
    console.log('Woot! Did it');
  };
}
</code>

This code does something very similar to previous examples in this tutorial except that it doesn't use the Promised library. 
We can see that the structure of the database interaction hasn't changed. 
Object stores are created on the database object in the upgrade event handler, and items are added to the object store in the same transaction sequence we've seen before. 
The difference is that this is done with requests and event handlers rather than promises and promise chains.

Here is a short reference of the differences between the IndexedDB API and the IndexedDB Promised library.

<table markdown="1">
<tr><td></td>
<td>IndexedDB Promised</td>
<td>IndexedDB API</td></tr>
<tr><td>Open database</td>
<td><code>idb.open(name, version, upgradeCallback)</code></td>
<td><code>indexedDB.open(name, version)</code></td></tr>
<tr><td>Upgrade database</td>
<td>Inside upgradeCallback</td>
<td><code>request.onupgradeneeded</code></td></tr>
<tr><td>Success</td>
<td><code>.then</code></td>
<td><code>request.onsuccess</code></td></tr>
<tr><td>Error</td>
<td><code>.catch</code></td>
<td><code>request.onerror</code></td></tr></table>


<h2><span class="orange">IndexedDB Starter Tutorial</span></h2>
Characteristics of IndexedDB are as follows:
<strong>(1) It's stored in key-value pairs.</strong>
IndexedDB uses an object store to hold data internally. 
All types of data can be stored in directly, including JavaScript objects. 
In the object store, the data is stored in the form of "key-value pairs". 
Each data record has its own corresponding primary key, and the primary key is unique and can't be repeated, otherwise an error will be thrown.

<strong>(2) Asynchronous.</strong>
It won't lock the browser when you are operating IndexedDB, and users can still perform other operations, which is in contrast to LocalStorage (as it's synchronous). 
Asynchronous design is to prevent the reading and writing of large amounts of data, which will slow down the performance of web pages.

<strong>(3) Support transaction.</strong>
IndexedDB supports transactions, which means that as long as one of a series of the steps fails, the entire transaction will be canceled, and the database is rolled back to the state before the transaction occurred. 
So there is no case where only a part of the data is rewritten.

<strong>(4) Homologous restriction.</strong> IndexedDB is subject to homology restriction, and each database corresponds to the domain name that created it. 
The web page can only access the database which is under its own domain name, but not a cross-domain database.

<strong>(5) Large storage space.</strong>
IndexedDB has a much larger storage space than LocalStorage. 
Generally it's more than 250MB, or even no upper limit.

<strong>(6) Support binary storage.</strong>
IndexedDB can store not only strings, but also binary data (ArrayBuffer objects and Blob objects).

<h3> . - 2. Basic concepts</h3>

IndexedDB is a more complex API, and there are many concepts. 
It abstracts different entities into individual object interfaces. 
To learning the API is to learn its various object interfaces.

Database: <code>IDBDatabase</code> object
Object store: <code>IDBObjectStore</code> object
Index: <code>IDBIndex</code> object
Transaction: <code>IDBTransaction</code> object
Operation request: <code>IDBRequest</code> object
Pointer: <code>IDBCursor</code> object
Primary key collection: <code>IDBKeyRange</code> object

Here are some of the main concepts.
<strong>Database -> Object store -> Data recording</strong>

<strong>(1) Database</strong>

A database is a collection of related data. 
Each domain name (strictly speaking, protocol + domain name + port) can create any number of databases.

The IndexedDB database has the concept of a version. 
only one version of the database can exist at the same time. 
If you want to modify the database structure (add or delete tables, indexes or primary keys), you can only do this by upgrading the database version.

<strong>(2) Object store</strong>

Each database contains several object stores. 
It is similar to the table in the relational database.

<strong>(3) Data recording</strong>

Object store holds data record. 
Each record is similar to the row of a relational database, but with only the primary key and the data body. 
The primary key is used to establish the default index, which must be different, otherwise an error will be thrown. 
The primary key can be an attribute in the data record, and it also can be specified as an incremental integer number.

<code>{ id: 1, text: 'foo' }</code>

In the above object, the <code>id</code> attribute can be treated as a primary key.

The data body can be any data type and is not limited to objects.

<strong>(4) Index</strong>

In order to speed up the retrieval of data, you can build indexes for different attributes inside the object store.

<strong>(5) Transaction</strong>

It should be done through transaction when you need to read, write or delete data records. 
It provides three events, which are <code>error</code>, <code>abort </code>and <code>complete </code>on the transaction objects to listen for the result of the operation.

<h3> . - 3. Operation process</h3>

IndexedDB database are generally performed by the following process. 
This section only gives a simple code example for quick start-up. 
For more detailed API for each object, see <a href="https://wangdoc.com/javascript/bom/indexeddb.html#indexeddb-%E5%AF%B9%E8%B1%A1" target="_blank">here</a>.

<h3> . - 3.1 Open the database</h3>

The first step to use IndexedDB is to open the database, which is to use <code>indexedDB.open()</code> method.

<code>var request = indexedDB.open(databaseName, version);</code>

The method takes two arguments, and the first argument which represents the name of the database is a string. 
If the specified database doesn't exist, a new database will be created. 
The second argument is an integer representing the version of the database. 
If omitted, when opening an existing database, the default is the current version; when creating a new database, the default is 1.

The <code>indexedDB.open()</code> method returns an IDBRequest object. 
The object handles the operation result for opening the database through three events <code>error</code>, <code>success</code>, <code>upgradeneeded</code>.

<strong>(1) error event</strong>

The <code>error</code> event indicates that it failed to open the database.

<code>request.onerror = function (event) {
  console.log('The database is opened failed');
};</code>

<strong>(2) success event</strong>

The <code>success</code> event indicates that the database was opened successfully.

<code>var db;

request.onsuccess = function (event) {
  db = request.result;
  console.log('The database is opened successfully');
};</code>

At this point, the database object is obtained by the <code>result</code> attribute of the <code>request</code> object.

<strong>(3) upgradeneeded event</strong>

If the specified version number is greater than the actual version number of the database, a database upgrade event <code>upgradeneeded</code> occurs.

<code>var db;

request.onupgradeneeded = function (event) {
  db = event.target.result;
}</code>

At this point, the database instance is obtained through the <code>target.result</code> attribute of the event object.

<h3> . - 3.2 Creating a new database</h3>

<u>Creating a new database is the same as opening a database. 
If the specified database doesn't exist, it will create a new one.</u>
The difference is that the subsequent operations are mainly done in the listener of the <code>upgradeneeded</code> event. The reason why the event is triggered is that the version comes from scratch.

Usually, after creating a new database, the first thing is to create a new object store (create a new table).

<code>request.onupgradeneeded = function(event) {
  db = event.target.result;
  var objectStore = db.createObjectStore('person', { keyPath: 'id' });
}</code>

In the above code, after the database is created successfully, a new table called <code>person</code> is added, and the primary key is <code>id</code>.

A better way to do this is to first determine whether the table exists, and if it doesn't exist, create a new one then.

<code>request.onupgradeneeded = function (event) {
  db = event.target.result;
  var objectStore;
  if (!db.objectStoreNames.contains('person')) {
    objectStore = db.createObjectStore('person', { keyPath: 'id' });
  }
}</code>

The primary key is the index attribute which is built by default. 
For example, the data record is <code>{ id: 1, name: 'Jam' }</code>, so the <code>id</code> attribute can be used as the primary key. 
The property of the objects in the next layer can also be specified as the primary key. 
For example, the <code>foo.bar</code> of the<code>{ foo: { bar: 'baz' } }</code> can also be specified as the primary key.

If there is no suitable attribute in the data record as a primary key, then you can make IndexedDB generated a primary key automatically.

<code>var objectStore = db.createObjectStore(
  'person',
  { autoIncrement: true }
);</code>

In the above code, the specified primary key is an increasing integer.

After creating a new object store, the next step is to create a new index.

<code>request.onupgradeneeded = function(event) {
  db = event.target.result;
  var objectStore = db.createObjectStore('person', { keyPath: 'id' });
  objectStore.createIndex('name', 'name', { unique: false });
  objectStore.createIndex('email', 'email', { unique: true });
}</code>

In the above code, the three parameters of <code>IDBObject.createIndex()</code> are the index name, the attribute of the index and the configuration object (indicating whether the attribute contains duplicate values).

<h3> . - 3.3 Add data</h3>

Adding data refers to writing data records to an object store. 
It needs to be done through the transaction.

<code>function add() {
  var request = db.transaction(['person'], 'readwrite')
    .objectStore('person')
    .add({ id: 1, name: 'Jam', age: 24, email: 'jam@example.com' });

  request.onsuccess = function (event) {
    console.log('The data has been written successfully');
  };

  request.onerror = function (event) {
    console.log('The data has been written failed');
  }
}

add();</code>

In the above code, you need to create a new transaction in order to write data. 
The table name and operating mode ("Read Only" or "Read and Write") must be specified when creating. 
After the new transaction is created, you can use <code>IDBTransaction.objectStore(name)</code> method to obtain the IDBObjectStore object, and then use <code>add()</code>method on the table object to write a record to the table.

The operation of writing is asynchronous, and it can be known whether it was written successfully by listening to the <code>success</code> and <code>error</code> events on the connection object.

<h3> . - 3.4 Read data</h3>

Reading data is also done through transactions.

<code>function read() {
   var transaction = db.transaction(['person']);
   var objectStore = transaction.objectStore('person');
   var request = objectStore.get(1);

   request.onerror = function(event) {
     console.log('Transaction failed');
   };

   request.onsuccess = function( event) {
      if (request.result) {
        console.log('Name: ' + request.result.name);
        console.log('Age: ' + request.result.age);
        console.log('Email: ' + request.result.email);
      } else {
        console.log('No data record');
      }
   };
}

read();</code>

In the above code, the <code>objectStore.get()</code> method is used to read data, and the parameter is the value of the primary key.

<h3> . - 3.5 Traverse data</h3>

To traverse all the records of the data table, you should use the pointer object IDBCursor.

<code>function readAll() {
  var objectStore = db.transaction('person').objectStore('person');

   objectStore.openCursor().onsuccess = function (event) {
     var cursor = event.target.result;

     if (cursor) {
       console.log('Id: ' + cursor.key);
       console.log('Name: ' + cursor.value.name);
       console.log('Age: ' + cursor.value.age);
       console.log('Email: ' + cursor.value.email);
       cursor.continue();
    } else {
      console.log('No more data');
    }
  };
}

readAll();</code>

In the above code, the <code>openCursor()</code> method of the new pointer object is an asynchronous operation, so you need to listen to the <code>success</code> event.

<h3> . - 3.6 Update data</h3>

The <code>IDBObject.put()</code> method is used to update data.

<code>function update() {
  var request = db.transaction(['person'], 'readwrite')
    .objectStore('person')
    .put({ id: 1, name: 'Jim', age: 35, email: 'Jim@example.com' });

  request.onsuccess = function (event) {
    console.log('The data has been updated successfully');
  };

  request.onerror = function (event) {
    console.log('The data has been updated failed');
  }
}

update();</code>

In the above code, the <code>put()</code> method updates the record of which the primary key is <code>1</code> automatically.

<h3> . - 3.7 Delete data</h3>

The <code>IDBObjectStore.delete()</code> method is used to delete records.

<code>function remove() {
  var request = db.transaction(['person'], 'readwrite')
    .objectStore('person')
    .delete(1);

  request.onsuccess = function (event) {
    console.log('The data has been deleted successfully');
  };
}

remove();</code>

<h3> . - 3.8 Index</h3>

The role of an index is to allow you to search for any field, that is, get data record from any field. 
If you haven't built an index, you can only search for the primary key by default ( take values from the primary key).

Assume that you have built an index for the <code>name</code> field when creating a new table.

<code>objectStore.createIndex('name', 'name', { unique: false });</code>

Now, you can find the corresponding data record from the <code>name</code>.

<code>var transaction = db.transaction(['person'], 'readonly');
var store = transaction.objectStore('person');
var index = store.index('name');
var request = index.get('Jim');

request.onsuccess = function (e) {
  var result = e.target.result;
  if (result) {
    // ...
  } else {
    // ...
  }
}</code>


<script type='text/javascript' src='readbook.js'></script>

