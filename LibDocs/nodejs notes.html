<base target="_blank"><html><head><title>nodejs notes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@13.0.1/dist/lazyload.min.js"></script>
<script type='text/javascript' src='../mainscript.js'></script>
<script>
  var showTopicNumber = true;
</script>
<style>
body{width:80%;margin-left: 10%; font-size:22px;}
strong, h1, h2 {color: gold;}
strong {color: orange;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px;}
</style></head><body onkeypress="chkKey()"><center>
<h1>nodejs notes</h1>
<div id="toc"></div></center>
<pre>
<br>
<br>
<h2>nodejs tutorials</h2>
<a href="nodejs.html">&diams;nodejs</a>
<a href="Node入门.html">&diams;Node入门</a>
<a href="NodejsSQL.html" class="gold embossts">&diams;NodejsSQL</a>
<a class="goldword" href="http://www.tutorialspoint.com/nodejs/">Node.js Tutorial</a>
<a href="http://www.tutorialspoint.com/nodejs_terminal_online.php">Online Node Terminal</a>

<a href="Node命令行程序.html"><u class="redb">&diams;Node命令行程序</u></a>

<a href="nodejsList.html"><u class="redb">&diams;nodejsList</u></a>
<a href="https://medium.com/@kieranmaher13/nodejs-in-three-ish-minutes-4c4401b43b2c"><span class="redinsha">nodejs in 3 minutes</span></a>
<a href="http://www.youtube.com/watch?v=U8XF6AFGqlc">Node.js Tutorial For Absolute Beginners</a>
<a href="Getting Started with Node.js.html"><b class="redword">&diams;Getting Started with Node.js</b></a>

<a href="https://packagecontrol.io/packages/Nodejs"><span class="whiteOnblacksha">Sublime Text Nodejs</span></a>

<a href="nodejs_mongodb.html"><span class="orangeb">&diams;nodejs_mongodb</span></a>
Usage
node [options] [V8 options] [script.js | -e "script" | - ] [arguments]
node [options] [V8 options] [script.js | -e "script" | -] [--] [arguments]
node inspect [script.js | -e "script" | <host>:<port>] …
node --v8-options

Next, create a new source file in the projects folder and call it hello-world.js.

Open hello-world.js and paste in the following content:

const http = require('http');
const hostname = '127.0.0.1';
const port = 3000;
const server = http.createServer((req, res) => {
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/plain');
  res.end('Hello, World!\n');
});

server.listen(port, hostname, () => {
  console.log(`Server running at http://${hostname}:${port}/`);
});

Save the file, go back to the terminal window, and enter the following command:

$ node hello-world.js

Now, open any preferred web browser and visit http://127.0.0.1:3000.

<h2><span class="orange">XMLHttpRequest</span></h2>
Example Using the XMLHttpRequest Object
function loadXMLDoc() {
  var xhttp = new XMLHttpRequest();
  xhttp.onreadystatechange = function() {
    if (this.readyState == 4 && this.status == 200) {
      document.getElementById("demo").innerHTML =
      this.responseText;
    }
  };
  xhttp.open("GET", "xmlhttp_info.txt", true);
  xhttp.send();
}

XMLHttpRequest is a built-in browser object that allows to make HTTP requests in JavaScript.

Despite of having the word “XML” in its name, it can operate on any data, not only in XML format. 
We can upload/download files, track progress and much more.

Right now, there’s another, more modern method <code>fetch</code>, that somewhat deprecates <code>XMLHttpRequest</code>.
<b>A Fetch API Example</b>
let file = "fetch_info.txt"
fetch (file)
.then(x => x.text())
.then(y => document.getElementById("demo").innerHTML = y);

Since Fetch is based on async and await, the example above might be easier to understand like this:

getText("fetch_info.txt");
async function getText(file) {
  let x = await fetch(file);
  let y = await x.text();
  document.getElementById("demo").innerHTML = y;
}
In modern web-development <code>XMLHttpRequest</code> is used for three reasons:
Historical reasons: we need to support existing scripts with <code>XMLHttpRequest</code>.
We need to support old browsers, and don’t want polyfills (e.g. to keep scripts tiny).
We need something that <code>fetch</code> can’t do yet, e.g. to track upload progress.

Does that sound familiar? If yes, then all right, go on with <code>XMLHttpRequest</code>. 
Otherwise, please head on to <a href="/fetch">Fetch</a>.

<h2>The basics</h2>XMLHttpRequest has two modes of operation: synchronous and asynchronous.

Let’s see the asynchronous first, as it’s used in the majority of cases.

To do the request, we need 3 steps:

Create <code>XMLHttpRequest</code>:

<code>let xhr = new XMLHttpRequest();</code>

The constructor has no arguments.

Initialize it, usually right after <code>new XMLHttpRequest</code>:

<code>xhr.open(method, URL, [async, user, password])</code>

This method specifies the main parameters of the request:

<code>method</code> – HTTP-method. 
Usually <code>"GET"</code> or <code>"POST"</code>.
<code>URL</code> – the URL to request, a string, can be <a href="/url">URL</a> object.
<code>async</code> – if explicitly set to <code>false</code>, then the request is synchronous, we’ll cover that a bit later.
<code>user</code>, <code>password</code> – login and password for basic HTTP auth (if required).

Please note that <code>open</code> call, contrary to its name, does not open the connection. 
It only configures the request, but the network activity only starts with the call of <code>send</code>.

Send it out.

<code>xhr.send([body])</code>

This method opens the connection and sends the request to server. 
The optional <code>body</code> parameter contains the request body.

Some request methods like <code>GET</code> do not have a body. 
And some of them like <code>POST</code> use <code>body</code> to send the data to the server. 
We’ll see examples of that later.

Listen to <code>xhr</code> events for response.

These three events are the most widely used:

<code>load</code> – when the request is complete (even if HTTP status is like 400 or 500), and the response is fully downloaded.
<code>error</code> – when the request couldn’t be made, e.g. network down or invalid URL.
<code>progress</code> – triggers periodically while the response is being downloaded, reports how much has been downloaded.

<code>xhr.onload = function() {
  alert(`Loaded: ${xhr.status} ${xhr.response}`);
};

xhr.onerror = function() {
  // only triggers if the request couldn't be made at all
  alert(`Network Error`);
};

xhr.onprogress = function(event) {
  // triggers periodically
 // event.loaded - how many bytes downloaded
 // event.lengthComputable = true if the server sent Content-Length header
 // event.total - total number of bytes (if lengthComputable)
 alert(`Received ${event.loaded} of ${event.total}`);
};</code>

Here’s a full example. 
The code below loads the URL at <code>/article/xmlhttprequest/example/load</code> from the server and prints the progress:

<code>// 1. Create a new XMLHttpRequest object
let xhr = new XMLHttpRequest();

// 2. Configure it: GET-request for the URL /article/.../load
xhr.open('GET', '/article/xmlhttprequest/example/load');

// 3. Send the request over the network
xhr.send();

// 4. This will be called after the response is received
xhr.onload = function() {
  if (xhr.status != 200) {
    // analyze HTTP status of the response
    alert(`Error ${xhr.status}: ${xhr.statusText}`); // e.g. 404: Not Found
  } else { // show the result
    alert(`Done, got ${xhr.response.length} bytes`); // response is the server response
  }
};

xhr.onprogress = function(event) {
  if (event.lengthComputable) {
    alert(`Received ${event.loaded} of ${event.total} bytes`);
  } else {
    alert(`Received ${event.loaded} bytes`); // no Content-Length
  }
};

xhr.onerror = function() {
  alert("Request failed");
};</code>

Once the server has responded, we can receive the result in the following <code>xhr</code> properties:

<dt><code>status</code></dt>
<dd>HTTP status code (a number): <code>200</code>, <code>404</code>, <code>403</code> and so on, can be <code>0</code> in case of a non-HTTP failure.</dd>
<dt><code>statusText</code></dt>
<dd>HTTP status message (a string): usually <code>OK</code> for <code>200</code>, <code>Not Found</code> for <code>404</code>, <code>Forbidden</code> for <code>403</code> and so on.</dd>
<dt><code>response</code> (old scripts may use <code>responseText</code>)</dt>
<dd>The server response body.</dd>

We can also specify a timeout using the corresponding property:

<code>xhr.timeout = 10000; // timeout in ms, 10 seconds</code>

If the request does not succeed within the given time, it gets canceled and <code>timeout</code> event triggers.

URL search parameters
To add parameters to URL, like <code>?name=value</code>, and ensure the proper encoding, we can use <a href="/url">URL</a> object:

<code>let url = new URL('https://google.com/search');
url.searchParams.set('q', 'test me!');

// the parameter 'q' is encoded
xhr.open('GET', url); // https://google.com/search?q=test+me%21</code>

<h2>Response Type</h2>We can use <code>xhr.responseType</code> property to set the response format:

<code>"</code> (default) – get as string,
<code>"text"</code> – get as string,
<code>"arraybuffer"</code> – get as <code>ArrayBuffer</code> (for binary data, see chapter <a href="/arraybuffer-binary-arrays">ArrayBuffer, binary arrays</a>),
<code>"blob"</code> – get as <code>Blob</code> (for binary data, see chapter <a href="/blob">Blob</a>),
<code>"document"</code> – get as XML document (can use XPath and other XML methods) or HTML document (based on the MIME type of the received data),
<code>"json"</code> – get as JSON (parsed automatically).

For example, let’s get the response as JSON:
<code>let xhr = new XMLHttpRequest();

xhr.open('GET', '/article/xmlhttprequest/example/json');
xhr.responseType = 'json';
xhr.send();
// the response is {"message": "Hello, world!"}
xhr.onload = function() {
  let responseObj = xhr.response;
  alert(responseObj.message); // Hello, world!
};</code>

Please note:
In the old scripts you may also find <code>xhr.responseText</code> and even <code>xhr.responseXML</code> properties.

They exist for historical reasons, to get either a string or XML document. 
Nowadays, we should set the format in <code>xhr.responseType</code> and get <code>xhr.response</code> as demonstrated above.

<h2>Ready states</h2><code>XMLHttpRequest</code> changes between states as it progresses. 
The current state is accessible as  <code>xhr.readyState</code>.

All states, as in <a href="https://xhr.spec.whatwg.org/#states">the specification</a>:

<code>UNSENT = 0; // initial state
OPENED = 1; // open called
HEADERS_RECEIVED = 2; // response headers received
LOADING = 3; // response is loading (a data packet is received)
DONE = 4; // request complete</code>

An <code>XMLHttpRequest</code> object travels them in the order <code>0</code> → <code>1</code> → <code>2</code> → <code>3</code> → … → <code>3</code> → <code>4</code>. 
State <code>3</code> repeats every time a data packet is received over the network.

We can track them using <code>readystatechange</code> event:

<code>xhr.onreadystatechange = function() {
  if (xhr.readyState == 3) {
    // loading
  }
  if (xhr.readyState == 4) {
    // request finished
  }
};</code>

You can find <code>readystatechange</code> listeners in really old code, it’s there for historical reasons, as there was a time when there were no <code>load</code> and other events. 
Nowadays, <code>load/error/progress</code> handlers deprecate it.

<h2>Aborting request</h2>We can terminate the request at any time. 
The call to <code>xhr.abort()</code> does that:

<code>xhr.abort(); // terminate the request</code>

That triggers <code>abort</code> event, and <code>xhr.status</code> becomes <code>0</code>.

<h2>Synchronous requests</h2>If in the <code>open</code> method the third parameter <code>async</code> is set to <code>false</code>, the request is made synchronously.

In other words, JavaScript execution pauses at <code>send()</code> and resumes when the response is received. 
Somewhat like <code>alert</code> or <code>prompt</code> commands.

Here’s the rewritten example, the 3rd parameter of <code>open</code> is <code>false</code>:

<code>let xhr = new XMLHttpRequest();

xhr.open('GET', '/article/xmlhttprequest/hello.txt', false);

try {
xhr.send();
if (xhr.status != 200) {
alert(`Error ${xhr.status}: ${xhr.statusText}`);
} else {
alert(xhr.response);
}
} catch(err) { // instead of onerror
alert("Request failed");
}</code>

It might look good, but synchronous calls are used rarely, because they block in-page JavaScript till the loading is complete. 
In some browsers it becomes impossible to scroll. 
If a synchronous call takes too much time, the browser may suggest to close the “hanging” webpage.

Many advanced capabilities of <code>XMLHttpRequest</code>, like requesting from another domain or specifying a timeout, are unavailable for synchronous requests. 
Also, as you can see, no progress indication.

Because of all that, synchronous requests are used very sparingly, almost never. 
We won’t talk about them any more.

<h2>HTTP-headers</h2><code>XMLHttpRequest</code> allows both to send custom headers and read headers from the response.

There are 3 methods for HTTP-headers:

<dl>
<dt><code>setRequestHeader(name, value)</code></dt>
<dd>
Sets the request header with the given <code>name</code> and <code>value</code>.

For instance:

<code>xhr.setRequestHeader('Content-Type', 'application/json');</code>

Headers limitations
Several headers are managed exclusively by the browser, e.g. <code>Referer</code> and <code>Host</code>.
The full list is <a href="https://xhr.spec.whatwg.org/#the-setrequestheader()-method">in the specification</a>.

<code>XMLHttpRequest</code> is not allowed to change them, for the sake of user safety and correctness of the request.

Can’t remove a header
Another peculiarity of <code>XMLHttpRequest</code> is that one can’t undo <code>setRequestHeader</code>.

Once the header is set, it’s set. 
Additional calls add information to the header, don’t overwrite it.

For instance:

<code>xhr.setRequestHeader('X-Auth', '123');
xhr.setRequestHeader('X-Auth', '456');

// the header will be:
// X-Auth: 123, 456</code>

</dd>
<dt><code>getResponseHeader(name)</code></dt>
<dd>
Gets the response header with the given <code>name</code> (except <code>Set-Cookie</code> and <code>Set-Cookie2</code>).

For instance:

<code>xhr.getResponseHeader('Content-Type')</code>

</dd>
<dt><code>getAllResponseHeaders()</code></dt>
<dd>
Returns all response headers, except <code>Set-Cookie</code> and <code>Set-Cookie2</code>.

Headers are returned as a single line, e.g.:

<code>Cache-Control: max-age=31536000
Content-Length: 4260
Content-Type: image/png
Date: Sat, 08 Sep 2012 16:53:16 GMT</code>

The line break between headers is always <code>"\r\n"</code> (doesn’t depend on OS), so we can easily split it into individual headers. 
The separator between the name and the value is always a colon followed by a space <code>": "</code>. 
That’s fixed in the specification.

So, if we want to get an object with name/value pairs, we need to throw in a bit JS.

Like this (assuming that if two headers have the same name, then the latter one overwrites the former one):

<code>let headers = xhr
.getAllResponseHeaders()
.split('\r\n')
.reduce((result, current) =&gt; {
let [name, value] = current.split(': ');
result[name] = value;
return result;
}, {});

// headers['Content-Type'] = 'image/png'</code>

</dd>
</dl>
<h2>POST, FormData</h2>To make a POST request, we can use the built-in <a href="https://developer.mozilla.org/en-US/docs/Web/API/FormData">FormData</a> object.

The syntax:

<code>let formData = new FormData([form]); // creates an object, optionally fill from &lt;form&gt;
formData.append(name, value); // appends a field</code>

We create it, optionally fill from a form, <code>append</code> more fields if needed, and then:

<code>xhr.open('POST', ...)</code> – use <code>POST</code> method.
<code>xhr.send(formData)</code> to submit the form to the server.

For instance:





<code>&lt;form name="person"&gt;
&lt;input name="name" value="John"&gt;
&lt;input name="surname" value="Smith"&gt;
&lt;/form&gt;

&lt;script&gt;
// pre-fill FormData from the form
let formData = new FormData(document.forms.person);

// add one more field
formData.append("middle", "Lee");

// send it out
let xhr = new XMLHttpRequest();
xhr.open("POST", "/article/xmlhttprequest/post/user");
xhr.send(formData);

xhr.onload = () =&gt; alert(xhr.response);
&lt;/script&gt;</code>

The form is sent with <code>multipart/form-data</code> encoding.

Or, if we like JSON more, then <code>JSON.stringify</code> and send as a string.

Just don’t forget to set the header <code>Content-Type: application/json</code>, many server-side frameworks automatically decode JSON with it:

<code>let xhr = new XMLHttpRequest();

let json = JSON.stringify({
name: "John",
surname: "Smith"
});

xhr.open("POST", '/submit')
xhr.setRequestHeader('Content-type', 'application/json; charset=utf-8');

xhr.send(json);</code>

The <code>.send(body)</code> method is pretty omnivore. 
It can send almost any <code>body</code>, including <code>Blob</code> and <code>BufferSource</code> objects.

<h2>Upload progress</h2>The <code>progress</code> event triggers only on the downloading stage.

That is: if we <code>POST</code> something, <code>XMLHttpRequest</code> first uploads our data (the request body), then downloads the response.

If we’re uploading something big, then we’re surely more interested in tracking the upload progress. 
But <code>xhr.onprogress</code> doesn’t help here.

There’s another object, without methods, exclusively to track upload events: <code>xhr.upload</code>.

It generates events, similar to <code>xhr</code>, but <code>xhr.upload</code> triggers them solely on uploading:

<code>loadstart</code> – upload started.
<code>progress</code> – triggers periodically during the upload.
<code>abort</code> – upload aborted.
<code>error</code> – non-HTTP error.
<code>load</code> – upload finished successfully.
<code>timeout</code> – upload timed out (if <code>timeout</code> property is set).
<code>loadend</code> – upload finished with either success or error.

Example of handlers:

<code>xhr.upload.onprogress = function(event) {
alert(`Uploaded ${event.loaded} of ${event.total} bytes`);
};

xhr.upload.onload = function() {
alert(`Upload finished successfully.`);
};

xhr.upload.onerror = function() {
alert(`Error during the upload: ${xhr.status}`);
};</code>

Here’s a real-life example: file upload with progress indication:





<code>&lt;input type="file" onchange="upload(this.files[0])"&gt;

&lt;script&gt;
function upload(file) {
let xhr = new XMLHttpRequest();

// track upload progress
xhr.upload.onprogress = function(event) {
console.log(`Uploaded ${event.loaded} of ${event.total}`);
};

// track completion: both successful or not
xhr.onloadend = function() {
if (xhr.status == 200) {
console.log("success");
} else {
console.log("error " + this.status);
}
};

xhr.open("POST", "/article/xmlhttprequest/post/upload");
xhr.send(file);
}
&lt;/script&gt;</code>

<h2>Cross-origin requests</h2><code>XMLHttpRequest</code> can make cross-origin requests, using the same CORS policy as <a href="/fetch-crossorigin">fetch</a>.

Just like <code>fetch</code>, it doesn’t send cookies and HTTP-authorization to another origin by default. 
To enable them, set <code>xhr.withCredentials</code> to <code>true</code>:

<code>let xhr = new XMLHttpRequest();
xhr.withCredentials = true;

xhr.open('POST', 'http://anywhere.com/request');
...</code>

See the chapter <a href="/fetch-crossorigin">Fetch: Cross-Origin Requests</a> for details about cross-origin headers.

<h2>Summary</h2>Typical code of the GET-request with <code>XMLHttpRequest</code>:

<code>let xhr = new XMLHttpRequest();

xhr.open('GET', '/my/url');

xhr.send();

xhr.onload = function() {
if (xhr.status != 200) { // HTTP error?
// handle error
alert( 'Error: ' + xhr.status);
return;
}

// get the response from xhr.response
};

xhr.onprogress = function(event) {
// report progress
alert(`Loaded ${event.loaded} of ${event.total}`);
};

xhr.onerror = function() {
// handle non-HTTP error (e.g. network down)
};</code>

There are actually more events, the <a href="https://xhr.spec.whatwg.org/#events">modern specification</a> lists them (in the lifecycle order):

<code>loadstart</code> – the request has started.
<code>progress</code> – a data packet of the response has arrived, the whole response body at the moment is in <code>response</code>.
<code>abort</code> – the request was canceled by the call <code>xhr.abort()</code>.
<code>error</code> – connection error has occurred, e.g. wrong domain name. 
Doesn’t happen for HTTP-errors like 404.
<code>load</code> – the request has finished successfully.
<code>timeout</code> – the request was canceled due to timeout (only happens if it was set).
<code>loadend</code> – triggers after <code>load</code>, <code>error</code>, <code>timeout</code> or <code>abort</code>.

The <code>error</code>, <code>abort</code>, <code>timeout</code>, and <code>load</code> events are mutually exclusive. 
Only one of them may happen.

The most used events are load completion (<code>load</code>), load failure (<code>error</code>), or we can use a single <code>loadend</code> handler and check the properties of the request object <code>xhr</code> to see what happened.

We’ve already seen another event: <code>readystatechange</code>. 
Historically, it appeared long ago, before the specification settled. 
Nowadays, there’s no need to use it, we can replace it with newer events, but it can often be found in older scripts.

If we need to track uploading specifically, then we should listen to same events on <code>xhr.upload</code> object.

<h2><span class="orange">Chat with WebSockets, Server and Client both in NodeJs</span></h2>
Usually when somebody thinks chat, they think WebSockets. 
Normally there are tutorials how you make a server in NodeJs for example and a client in HTML. 
But in this case the client will also be a NodeJs app. 
It will display messages from the server and listen to users input with NodeJs <code>readline</code>.

<img src="https://miro.medium.com/max/8802/0*9F8GQk7R1EZQagSO">
<h2>Extra</h2>
There will be no persistence here. 
A client wil<span>l</span> see only messages that server sends him from the point he connects to it. 
Also whenever a client is connected, the server will generate a random color and a random name, and the client will use that. 
It’s not necessary, it’s just a few extra stuff.

Utils — this file contains the generate random color and generate random name. 
You can check the contents of that file in full on Github. 
Link at the end of story.
<h2>Server</h2>
<code>myClient</code> is just a class called Client (not the actual client we are gonna define that connects to the server). 
It contains 2 fields, name &amp; color.

<code>handleReceviedMsg</code> accepts the message that was send to server, and returns that it’s JSON stringified.

For WebSockets we are using the ws package. 
And chalk is used to make the console log a little colourful.

First we create the WebSocketServer, running on port 8080, with option for client tracking. 
This tracking enables that the WebSocket server has clients property.

When the server detects a connection, we create a client instance. 
It’s just a placeholder for name and color. 
Then we send the init or welcome message to the client, with that information.

Whenever a new message is received, we will send that message to every client back. 
Even to the one who has send it. 
So they know that the message was received and transmitted.
<h2>Client</h2>
The client connects to the WebSocket server. 
On initial or welcome message, the server will return the name and the color. 
The client will use that to display message in color with the help of chalk.

For client input we use nodes readline. 
Readline listents on the line event. 
This event is triggered whenever the client presses the Enter key. 
On that event we capture the text that was inputed and together with the clients name and color we send that to the server.

Everything else should be pretty much self explanatory.

On open is when we have a connection established. 
On close is when the connection gets terminated. 
On message is whenever server send us a message.

<img src="https://miro.medium.com/max/972/1*cjeTJvXhzR1xiAgA3f-YmQ.png">
client.js

<img src="https://miro.medium.com/max/932/1*H7WqjR0xG_fjBWE99b9ZHQ.png">
server.js

Whole structure and code: <a href="https://github.com/zprima/wschat" rel="noopener nofollow">https://github.com/zprima/wschat</a>

<h2><span class="orange">Creating a chat with Node.js</span></h2>
https://itnext.io/creating-a-chat-with-node-js-from-the-scratch-707896d64593
<h2>About Socket.IO</h2>
This Node.js module brings a way to connect directly from the client browser to the application server. 
The library works through events, that is, the server or client will trigger events so that there are responses from one of the parties

In a way, let’s use two very basic methods, which are <code>emit</code> and <code>on</code>. 
One serves to make the emission of the event and the other to receive the response of it. 
Each side of the application will therefore have the Socket.IO library added.

In addition to allowing the direct exchange of messages between two devices, Socket.IO also allows the broadcast of messages, sending an event to all other connected users. 
The broadcast can be both from client and server.

When the user accesses the page, a socket is created with the server and it is through this socket that the exchange of messages between a client and a server takes place. 
This, in turn, can either issue an event to a single Socket or to all the sockets connected to it, what we call a message broadcast.

<h2>The project</h2>
Let’s create now a directory called <code>\ChatJs</code> and, inside of it, we will create a file called app.js, which will be the main file of our server. 
As a first part we will create a fairly simple server that will only present a successful message on the browser screen

Creating a single application.
var app = require('http').createServer(response);
app.listen(3000);
console.log("App running…");
function response(req, res) {
 res.writeHead(200);
 res.end("Hi, your server is working!");
}

The script creates an HTTP server (which will be listening on port 3000) which has as main method to be requested the <code>response()</code> function, which, in turn, has two parameters: <code>req</code> (request) and <code>res</code> (response). 
Into the function, we define a success code (200) and end it with a string warning that the server is ok.

Soon after, just run the following command, which will run our application at the prompt:
node app.js

Note that when you run this code at the prompt, the terminal presents the content of the <code>console.log</code> function warning that the application is running. 
However, it will not print any other lines, indicating that our application is currently running.

At this point, we have only our Node.js server running. 
If you access the browser at <a href="http://localhost:3000/">http://localhost:3000/</a> you’ll see the message we passed in the <code>end</code> method

Next, we will make our server present an HTML response that will be the main page of our chat. 
For this, we will have to load the <code>FileSystem</code> module, since we will navigate the project directory and open a file. 
So, let’s change our <code>app.js</code> just like we see at <strong>Listing 4</strong>. 
Before making the changes, go to the prompt and press <code>Ctrl + C</code> (or <code>command + C</code>) to stop our application on the server.

<strong>Listing 4.</strong> Introducing an HTML page.
var app = require('http').createServer(response);
var fs = require('fs');
app.listen(3000);
console.log("App running…");
function response(req, res) {
 fs.readFile(__dirname + '/index.html',
 function (err, data) {
 if (err) {
   res.writeHead(500);
   return res.end('Failed to load file index.html');
 } res.writeHead(200);
   res.end(data);
 });
}

After these changes we will again execute the command <code>node app.js</code> and, when accessing again the address <a href="http://localhost:3000/">http://localhost:3000/</a>, you’ll come across the message “<em>Error loading the index.html file”</em>, just because we don’t have an index.html file inside our project yet.

It is also important to remember that the server we created so far does not differentiate the path, ie you can put anything after <a href="http://localhost:3000/">http://localhost:3000/</a> and it will always respond in the same way because we have not implemented how it’d treat these paths. 
Soon, you can very well call up addresses like <a href="http://localhost:3000/chat">http://localhost:3000/chat</a>, <a href="http://localhost:3000/error">http://localhost:3000/error</a>, <a href="http://localhost:3000/potato">http://localhost:3000/potato</a>, etc.

Let’s create a simple interface for our chat. 
Create an <code>index.html</code> file inside the project root directory. 
In this file enter a code equal to that shown in <strong>Listing 5</strong>.

<strong>Listing 5.</strong> Chat HTML code.
&lt;!DOCTYPE html>
&lt;html>
&lt;head>
 &lt;title>ChatJS&lt;/title>
 &lt;link rel="stylesheet" type="text/css" href="/css/style.css" />
&lt;/head>
&lt;body>
 &lt;div id="history">&lt;/div>
 &lt;form id="chat">
 &lt;input type="text" id="msg_text" name="msg_text" />
 &lt;input type="submit" value="Send!" /> 
 &lt;/form>
&lt;/body>
&lt;/html>

Our index, for now, will only deals with a div called <code>history</code> that is where all the messages exchanged in the chat will be arranged. 
Then, we have soon after a form with a text box and the button of message sending. 
A very simple chat structure so far.

However, if you now try to access the address <a href="http://localhost:3000/">http://localhost:3000/</a> you will receive the same error message. 
This is because we do not restart our server application, then we go to the prompt again, press <code>Ctrl + C</code> and then reexecute the app.

As you may have noticed, we already left a link tag in the <code>&lt;head></code> of our application to load our CSS. 
Within the directory of our project create another directory called <code>css</code> and, inside it, the <code>style.css</code> file with the same content as shown in <strong>Listing 6</strong>.

<strong>Listing 6.</strong> style.css file.
html, body, input { font-family: Georgia, Tahoma, Arial, sans-serif; margin: 0; padding: 0;}
body { background: #302F31; padding: 10px;}

form { margin: 15px 0;}
form input[type='text'] { border: 2px solid #eb5424; border-radius: 5px; padding: 5px; width: 75%;}
form input[type='submit'] { background: #eb5424; border: none; border-radius: 5px; color: #FFF; cursor: pointer; font-weight: bold; padding: 7px 5px; width: 19%;}

#history { background: #FFF; border: 2px solid #eb5424; height: 550px;}


If we restart the application, the style is not yet applied to the index page. 
The reason is that our app.js only deals with a request path so far. 
To solve this we will change our app.js file so that it loads the files that are passed in the request URL, instead of placing each of the URLs manually. 
Let’s take a closer look at the changes listed in <strong>Listing 7</strong>.

<strong>Listing 7.</strong> Path changes in app.js.
var app = require('http').createServer(response);
var fs = require('fs');
app.listen(3000);
console.log("App running...");
function response(req, res) {
    var file = "";
    if (req.url == "/") {
        file = __dirname + '/index.html';
    } else {
        file = __dirname + req.url;
    }
    fs.readFile(file, function(err, data) {
        if (err) {
            res.writeHead(404);
            return res.end('Page or file not found');
        }
        res.writeHead(200);
        res.end(data);
    });
}

After restarting the app

<h2>Sending messages</h2>
We will now work on the messaging mechanism. 
Our application will work by communicating with the Node.js server through the client-side library of Socket.IO while jQuery takes place in the interaction with the page.

For this, we will change the app.js file as shown in <strong>Listing 8</strong>, and include a line of a command at the beginning of the file stating that we are including Socket.IO in the application.

<strong>Listing 8.</strong> Including Socket.IO module.
var app = require('http').createServer(response);
var fs = require('fs');
var io = require('socket.io')(app);
…

In order to use the <code>require</code> function in a module we need first to install it for our application. 
So, stop the application and run the following command to get this done:
npm install socket.io

Once finished, go to your index.html page and add the code snippet shown in <strong>Listing 9</strong>, at the end of the file.

<strong>Listing 9.</strong> Message sending event.
…
 &lt;script type="text/javascript" src="<a href="https://code.jquery.com/jquery-3.3.1.min.js">https://code.jquery.com/jquery-3.3.1.min.js</a>">&lt;/script>
 &lt;script type="text/javascript" src="/socket.io/socket.io.js">&lt;/script>
 &lt;script type="text/javascript">
 var socket = io.connect();
 $("form#chat").submit(function(e) {
   e.preventDefault();
 
   socket.emit("send message", $(this).find("#msg_text").val(), function() {
     $("form#chat #msg_text").val(");
   });
 });
 &lt;/script>
&lt;/body>
&lt;/html>

We are declaring a <code>socket</code> variable that refers to the Socket.IO library, which will be responsible for all socket functionalities. 
Next, we declare a <code>submit</code> event of our form in jQuery and pass a <code>preventDefault</code> so that the form does not proceed to its <code>action</code>, since we are the ones who are going to take care of the form response.

Note that the <code>emit</code> method of the library is invoked, in which we pass as parameters three things: the event name (this will be useful on the server), the data we are sending (in this case we are only sending the contents of the <code>message</code> field) and finally the <code>callback</code>, a function that will be executed once the event is issued. 
The latter, in particular, will only serve to clear the message field, so the user does not have to delete the message after sending it.

If we now test our application the message sending will not work, not even the callback to clear the message field, because we have not yet put the functionality of what the server have to do as soon as it receives this event. 
To do this, edit the app.js file and put the code shown in <strong>Listing 11</strong> at the end of it.

<strong>Listing 11.</strong> Receiving messages from the client.
io.on("connection", function(socket) {
    socket.on("send message", function(sent_msg, callback) {
        sent_msg = "[ " + getCurrentDate() + " ]: " + sent_msg;
        io.sockets.emit("update messages", sent_msg);
        callback();
    });
});
function getCurrentDate() {
    var currentDate = new Date();
    var day = (currentDate.getDate() < 10 ? '0' : '') + currentDate.getDate();
    var month = ((currentDate.getMonth() + 1) < 10 ? '0' : '') + (currentDate.getMonth() + 1);
    var year = currentDate.getFullYear();
    var hour = (currentDate.getHours() < 10 ? '0' : '') + currentDate.getHours();
    var minute = (currentDate.getMinutes() < 10 ? '0' : '') + currentDate.getMinutes();
    var second = (currentDate.getSeconds() < 10 ? '0' : '') + currentDate.getSeconds();
    return year + "-" + month + "-" + day + " " + hour + ":" + minute + ":" + second;
}

We’ve created a method that will work in response to the client’s connection to the server. 
When the client accesses the page it triggers this method on the server and when this socket receives a <code>send message</code> we trigger a method that has as parameters the sent data (the <code>message</code> field) and the callback that we created on the client side.

Within this method we put the second part of the functionality: the module will send to the sockets connected to the server (all users) the <code>update messages</code> event and will also pass which new message was sent, with a specific datetime format. 
To provide the date and time we create a separate function because we will still use this method a few more times throughout the development. 
Right away, we call the callback that we created on the client side, which is the method for clearing the fields.

Finally, also edit the index.html file and create the method that will update the messages for the users. 
The idea is quite simple: let’s give an <code>append</code> in the <code>history</code> div (the changes are in <strong>Listing 12</strong>). 
The following lines should be entered shortly after submitting the form.

<strong>Listing 12.</strong> Updating message history.
socket.on("update messages", function(msg){
var final_message = $("&lt;p />").text(msg);
   $("#history").append(final_message);
});

Basically, the conversation between the server and the client is the same on both sides, that is, the two have an <code>emit</code> and <code>on</code> functions for issuing and receiving events, respectively.

So, restart and access the application in two tabs and just send a message to see the power of Socket.IO in action. 
The application should display the message

<h2>Conclusion</h2>
With this very simple project and a few dependencies, we managed to create, in some lines of code, a very functional application.

Notwithstanding, the power of Socket.IO extends to more solutions that previously relied on back-end pages. 
Now, the inbound/outbound server response time can rely on the WebSocket protocol for a more agile information exchange, enabling systems that track monitoring results or even setting real-time pricing for users.

You can find the full source code <a href="https://github.com/diogosouza/ChatJS">here</a>.

<h2><span class="orange">Communication</span></h2>
<a href="Complete Guide To Node Client-Server Communication.html"><span class="orangeb">&diams;Complete Guide To Node Client-Server Communication</span></a>

<a href="https://stackoverflow.com/questions/11115508/in-node-js-how-do-i-communicate-with-client-side-javascript">node js communicate with client side javascript</a>
<a href="https://flaviocopes.com/node-websockets/">Using WebSockets with Node.js</a>

The easiest way is to set up <a href="http://expressjs.com/" class="whitebut ">Express</a> and have your client side code communicate via Ajax (for example, using jQuery).

(function() {
  var app, express;
  express = require("express");
  app = express.createServer();

  app.configure(function() {
    app.use(express.bodyParser());
    return app.use(app.router);
  });

  app.configure("development", function() {
    return app.use(express.errorHandler({
      dumpExceptions: true,
      showStack: true
    }));
  });

  app.post("/locations", function(request, response) {
    var latitude, longitude;
    latitude = request.body.latitude;
    longitude = request.body.longitude;
    return response.json({}, 200);
  });
  app.listen(80);
}).call(this);

On the client side, call it like this:

var latitude = 0, longitude = 0; // Set from form
$.post({
  url: "http://localhost/locations",
  data: {latitude: latitude, longitude: longitude},
  success: function (data) {
    console.log("Success");
  },
  dataType: "json"
});

Note this code is simply an example; you'll have to work out the error handling, etc.

Another way is by making an HTTP request, just like any other server side program in a web application.

With the XMLHttpRequest object, or by generating a <form> and then submitting it, or a variety of other methods.

<h2>Create a new WebSockets connection</h2>
<code>const url = &#39;wss://myserver.com/something&#39;
const connection = new WebSocket(url)
</code>

<code>connection</code> is a <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket">WebSocket</a> object.

When the connection is successfully established, the <code>open</code> event is fired.

Listen for it by assigning a callback function to the <code>onopen</code> property of the <code>connection</code> object:

<code>connection.onopen = () =&gt; {
  //...
}
</code>

If there's any error, the <code>onerror</code> function callback is fired:

<code>connection.onerror = error =&gt; {
  console.log(`WebSocket error: ${error}`)
}
</code>

<h2>Sending data to the server using WebSockets</h2>

Once the connection is open, you can send data to the server.

You can do so conveniently inside the <code>onopen</code> callback function:

<code>connection.onopen = () =&gt; {
  connection.send(&#39;hey&#39;)
}
</code>

<h2>Receiving data from the server using WebSockets</h2>

Listen with a callback function on <code>onmessage</code>, which is called when the <code>message</code> event is received:

<code>connection.onmessage = e =&gt; {
  console.log(e.data)
}
</code>

<h2>Implement a WebSockets server in Node.js</h2>

<a href="https://github.com/websockets/ws">ws</a> is a popular WebSockets library for <a href="/nodejs/">Node.js</a>.

We'll use it to build a WebSockets server. It can also be used to implement a client, and use WebSockets to communicate between two backend services.

Easily install it using

<code>yarn init
yarn add ws</code>

The code you need to write is very little:

<code>const WebSocket = require(&#39;ws&#39;)

const wss = new WebSocket.Server({ port: 8080 })

wss.on(&#39;connection&#39;, ws =&gt; {
  ws.on(&#39;message&#39;, message =&gt; {
    console.log(`Received message =&gt; ${message}`)
  })
  ws.send(&#39;ho!&#39;)
})
</code>

This code creates a new server on port 8080 (the default port for WebSockets), and adds a callback function when a connection is established, sending <code>ho!</code> to the client, and logging the messages it receives.

<h2>See a live example on Glitch</h2>

Here is a live example of a WebSockets server: <a href="https://glitch.com/edit/#!/flavio-websockets-server-example">https://glitch.com/edit/#!/flavio-websockets-server-example</a>

Here is a WebSockets client that interacts with the server: <a href="https://glitch.com/edit/#!/flavio-websockets-client-example">https://glitch.com/edit/#!/flavio-websockets-client-example</a>

<h2>Node.js Generate html</h2>
<a href="https://stackoverflow.com/questions/21617468/node-js-generate-html">Node.js Generate html</a>

The most basic way is:

var http = require('http');

http.createServer(function (req, res) {
  var html = buildHtml(req);

  res.writeHead(200, {
    'Content-Type': 'text/html',
    'Content-Length': html.length,
    'Expires': new Date().toUTCString()
  });
  res.end(html);
}).listen(8080);

function buildHtml(req) {
  var header = '';
  var body = '';

  // concatenate header string
  // concatenate body string

  return '&lt;!DOCTYPE html&gt;'
       + '&lt;html&gt;&lt;head&gt;' + header + '&lt;/head&gt;&lt;body&gt;' + body + '&lt;/body&gt;&lt;/html&gt;';
};
And access this HTML with http://localhost:8080 from your browser.

<a href="https://www.npmjs.com/package/create-html">create-html</a>

<h2>nodejs server</h2>
<pre>
var http = require('http');

http.createServer(function (req, res) {
    res.writeHead(200, {'Content-Type': 'text/html'});
    res.end('Hello World!');
}).listen(8080);

<h2>Web Scraping nodejs server</h2>
<a href="http://stackoverflow.com/questions/6084360/using-node-js-as-a-simple-web-server">Using node.js as a simple web server</a>
Simplest Node.js server is just:
$ npm install http-server -g

Now you can run a server via the following commands:
$ cd MyApp
$ http-server

If you're using NPM 5.2.0 or newer, you can use http-server without installing it with npx. 
This isn't recommended for use in production but is a great way to quickly get a server running on localhost.

$ npx http-server

Or, you can try this, which opens your web browser and enables CORS requests:
$ http-server -o --cors

For more options, check out the documentation for http-server on GitHub, or run:
$ http-server --help

Lots of other nice features and brain-dead-simple deployment to NodeJitsu.

Feature Forks

Of course, you can easily top up the features with your own fork. 
You might find it's already been done in one of the existing 800+ forks of this project:

https://github.com/nodeapps/http-server/network

Light Server: An Auto Refreshing Alternative

A nice alternative to http-server is light-server. 
It supports file watching and auto-refreshing and many other features.

$ npm install -g light-server 
$ light-server

Add to your directory context menu in Windows Explorer

 reg.exe add HKCR\Directory\shell\LightServer\command /ve /t REG_EXPAND_SZ /f /d "\"C:\nodejs\light-server.cmd\" \"-o\" \"-s\" \"%V\""

Simple JSON REST server

If you need to create a simple REST server for a prototype project then json-server might be what you're looking for.

Auto Refreshing Editors

Most web page editors and IDE tools now include a web server that will watch your source files and auto refresh your web page when they change.
I use Live Server with Visual Studio Code.
The open source text editor Brackets also includes a NodeJS static web server. 
Just open any HTML file in Brackets, press "Live Preview" and it starts a static server and opens your browser at the page. 
The browser will **auto refresh whenever you edit and save the HTML file. 
This especially useful when testing adaptive web sites. 
Open your HTML page on multiple browsers/window sizes/devices. 
Save your HTML page and instantly see if your adaptive stuff is working as they all auto refresh.

PhoneGap Developers

If you're coding a hybrid mobile app, you may be interested to know that the PhoneGap team took this auto refresh concept on board with their new PhoneGap App. 
This is a generic mobile app that can load the HTML5 files from a server during development. 
This is a very slick trick since now you can skip the slow compile/deploy steps in your development cycle for hybrid mobile apps if you're changing JS/CSS/HTML files — which is what you're doing most of the time. 
They also provide the static NodeJS web server (run phonegap serve) that detects file changes.

PhoneGap + Sencha Touch Developers

I've now extensively adapted the PhoneGap static server & PhoneGap Developer App for Sencha Touch & jQuery Mobile developers. 
Check it out at Sencha Touch Live. 
Supports --qr QR Codes and --localtunnel that proxies your static server from your desktop computer to a URL outside your firewall! Tons of uses. 
Massive speedup for hybrid mobile devs.

Cordova + Ionic Framework Developers

Local server and auto refresh features are baked into the ionic tool. 
Just run ionic serve from your app folder. 
Even better ... 
ionic serve --lab to view auto-refreshing side by side views of both iOS and Android.

<a href="http://hackprogramming.com/web-scraping-in-node-js-with-multiple-examples/">Web Scraping In Node Js With Multiple Examples</a>
<a href="https://scotch.io/tutorials/scraping-the-web-with-node-js">Scraping the Web With Node.js</a>
<a href="https://codeburst.io/an-introduction-to-web-scraping-with-node-js-1045b55c63f7">An Introduction to Web Scraping with Node JS</a>

<h3>What will we need?</h3>
For this project we’ll be using <a href="https://nodejs.org/en/">Node.js</a>. 

We’ll also be using two open-sourced <a href="https://www.npmjs.com/"><strong>npm</strong></a><strong> </strong>modules to make today’s task a little easier:
<a href="https://github.com/request/request-promise"><strong>request-promise </strong></a>— Request is a simple HTTP client that allows us to make quick and easy HTTP calls.
<a href="https://github.com/cheeriojs/cheerio"><strong>cheerio</strong></a> — jQuery for Node.js. 
Cheerio makes it easy to select, edit, and view DOM elements.

<h3>Project Setup.</h3>Create a new project folder. 
Within that folder create an <code>index.js</code> file. 
We’ll need to install and require our dependencies. 
Open up your command line, and install and save:<strong> request, request-promise, and cheerio</strong>
npm install --save request request-promise cheerio
Then require them in our <code>index.js</code> file:
const rp = require(&#x27;request-promise&#x27;);
const cheerio = require(&#x27;cheerio&#x27;);
<h3>Setting up the Request</h3><code>request-promise</code> accepts an object as input, and returns a promise. 
The <code>options</code> object needs to do two things:
Pass in the url we want to scrape.
Tell Cheerio to load the returned HTML so that we can use it.

Here’s what that looks like:
const options = {
  uri: `<a href="https://www.google.com/search?num=10&amp;q=${search}`">https://www.yourURLhere.com`</a>,
  transform: function (body) { return cheerio.load(body); }
};
The <code>uri</code> key is simply the website we want to scrape.
The <code>transform</code> key tells <code>request-promise</code> to take the returned body and load it into Cheerio before returning it to us.
Awesome. 
We’ve successfully set up our HTTP request options! Here’s what your code should look like so far:
const rp = require(&#x27;request-promise&#x27;);
const cheerio = require(&#x27;cheerio&#x27;);const options = {
  uri: `<a href="https://www.google.com/search?num=10&amp;q=${search}`">https://www.yourURLhere.com`</a>,
  transform: function (body) { return cheerio.load(body); }
};
<h3>Make the Request</h3>Now that the options are taken care of, we can actually make our request. 
The boilerplate in the documentation for that looks like this:
rp(<strong>OPTIONS</strong>)
    .then(function (data) {
        // <strong>REQUEST SUCCEEDED:</strong> <strong>DO SOMETHING</strong>
    })
    .catch(function (err) {
        // <strong>REQUEST FAILED: ERROR OF SOME KIND</strong>
    });
We pass in our <code>options</code> object to <code>request-promise</code>, then wait to see if our request succeeds or fails. 
Either way, we do something with the returned data.
Knowing what the documentation says to do, lets create our own version:
rp(options)
  .then(($) =&gt; {
    console.log($);
  })
  .catch((err) =&gt; {
    console.log(err);
  });
The code is pretty similar. 
The big difference is I’ve used arrow functions. 
I’ve also logged out the returned data from our HTTP request. 
We’re going to test to make sure everything is working so far.
Replace the placeholder <code>uri</code> with the website you want to scrape. 
Then, open up your console and type:
<strong>node index.js</strong>// LOGS THE FOLLOWING:
{ [Function: initialize]
  fn:
   initialize {
     constructor: [Circular],
     _originalRoot:
      { type: &#x27;root&#x27;,
        name: &#x27;root&#x27;,
        namespace: &#x27;<a href="http://www.w3.org/1999/xhtml&#x27;">http://www.w3.org/1999/xhtml&#x27;</a>,
        attribs: {},
        ...
If you don’t see an error, then everything is working so far — and you just made your first scrape!

Here is the full code of our boilerplate:
const rp = require('request-promise');
const cheerio = require('cheerio');
const options = {
  uri: `https://www.google.com`,
  transform: function (body) { return cheerio.load(body); }
};

rp(options)
  .then(($) => {
    console.log($);
  })
  .catch((err) => {
    console.log(err);
  });

Boilerplate web scraping code

<h3>Using the Data</h3>What good is our web scraper if it doesn’t actually return any useful data? This is where the fun begins.
There are numerous things you can do with Cheerio to extract the data that you want. 
First and foremost, Cheerio’s selector implementation is nearly identical to jQuery’s. 
So if you know jQuery, this will be a breeze. 
If not, don’t worry, I’ll show you.
<h2>Selectors</h2>The selector method allows you to traverse and select elements in the document. 
You can get data and set data using a selector. 
Imagine we have the following HTML in the website we want to scrape:
<strong>&lt;ul id=&quot;cities&quot;&gt;
  &lt;li class=&quot;large&quot;&gt;New York&lt;/li&gt;
  &lt;li id=&quot;medium&quot;&gt;Portland&lt;/li&gt;
  &lt;li class=&quot;small&quot;&gt;Salem&lt;/li&gt;
&lt;/ul&gt;</strong>
We can select id’s using (<code>#</code>), classes using (<code>.</code>), and elements by their tag names, ex: <code>div</code>.
$(&#x27;.large&#x27;).text()
// New York$(&#x27;#medium&#x27;).text()
// Portland$(&#x27;li[class=small]&#x27;).html()
// &lt;li class=&quot;small&quot;&gt;Salem&lt;/li&gt;
<h2>Looping</h2>Just like jQuery, we can also iterate through multiple elements with the <code>each()</code> function. 
Using the same HTML code as above, we can return the inner text of each <code>li</code> with the following code:
$(&#x27;li&#x27;).each(function(i, elem) {
  cities[i] = $(this).text();
});// New York Portland Salem
<h2>Finding</h2>Imagine we have two lists on our web site:
<strong>&lt;ul id=&quot;cities&quot;&gt;
  &lt;li class=&quot;large&quot;&gt;New York&lt;/li&gt;
  &lt;li id=&quot;c-medium&quot;&gt;Portland&lt;/li&gt;
  &lt;li class=&quot;small&quot;&gt;Salem&lt;/li&gt;
&lt;/ul&gt;
&lt;ul id=&quot;towns&quot;&gt;
  &lt;li class=&quot;large&quot;&gt;Bend&lt;/li&gt;
  &lt;li id=&quot;t-medium&quot;&gt;Hood River&lt;/li&gt;
  &lt;li class=&quot;small&quot;&gt;Madras&lt;/li&gt;
&lt;/ul&gt;</strong>
We can select each list using their respective ID’s, then find the <em>small </em>city/town within each list:
$(&#x27;#cities&#x27;).find(&#x27;.small&#x27;).text()
// Salem$(&#x27;#towns&#x27;).find(&#x27;.small&#x27;).text()
// Madras
<blockquote>Finding will search all descendant DOM elements, not just immediate children as shown in this example.
</blockquote><h2>Children</h2>Children is similar to find. 
The difference is that children <strong>only </strong>searches for immediate children of the selected element.
$(&#x27;#cities&#x27;).children(&#x27;#c-medium&#x27;).text();
// Portland
<h2>Text &amp; HTML</h2>Up until this point, all of my examples have included the <code>.text()</code> function. 
Hopefully you’ve been able to figure out that this function is what gets the text of the selected element. 
You can also use <code>.html()</code> to return the html of the given element:
$(&#x27;.large&#x27;)<strong>.text()</strong>
// Bend$(&#x27;.large&#x27;)<strong>.html()</strong>
// &lt;li class=&quot;large&quot;&gt;Bend&lt;/li&gt;
<h2>Additional Methods</h2>There are more methods than I can count, and the documentation for all of them is available <a href="https://github.com/cheeriojs/cheerio"><strong>here</strong></a>.
<h3>Chrome Developer Tools</h3>Don’t forget, the Chrome Developer Tools are your friend. 
In Google Chrome, you can easily find element, class, and ID names using: <strong>CTRL + SHIFT + C</strong>
<div role="button" tabindex="0"><img alt="Image for post" src="https://miro.medium.com/max/60/1*HNgMR7H87W7I0p3JvekDIQ.png?q=20" width="928" height="286"/><img alt="Image for post" width="928" height="286"/><noscript><img alt="Image for post" src="https://miro.medium.com/max/1856/1*HNgMR7H87W7I0p3JvekDIQ.png" width="928" height="286" srcSet="https://miro.medium.com/max/552/1*HNgMR7H87W7I0p3JvekDIQ.png 276w, https://miro.medium.com/max/1104/1*HNgMR7H87W7I0p3JvekDIQ.png 552w, https://miro.medium.com/max/1280/1*HNgMR7H87W7I0p3JvekDIQ.png 640w, https://miro.medium.com/max/1400/1*HNgMR7H87W7I0p3JvekDIQ.png 700w" sizes="700px"/></noscript>
Finding class names with chrome dev tools
As you seen in the above image, I’m able to hover over an element on the page and the element name and class name of the selected element are shown in real-time!
<h3>Limitations</h3>As Jaye Speaks points out:
<blockquote>MOST websites modify the DOM using JavaScript. 
Unfortunately Cheerio doesn’t resolve parsing a modified DOM. 
Dynamically generated content from procedures leveraging AJAX, client-side logic, and other async procedures are not available to Cheerio.
</blockquote>Remember this is an introduction to basic scraping. 
In order to get started you’ll need to find a static website with minimal DOM manipulation.

<a href="https://www.freecodecamp.org/news/the-ultimate-guide-to-web-scraping-with-node-js-daa2027dcd3/">The Ultimate Guide to Web Scraping with Node.js</a>
<a href="https://stackabuse.com/web-scraping-with-node-js/">Web Scraping with Node.js</a>
<a href="https://levelup.gitconnected.com/web-scraping-with-node-js-c93dcf76fe2b">Web Scraping with Node.js</a>
<a href="https://medium.com/@paul_irish/debugging-node-js-nightlies-with-chrome-devtools-7c4a1b95ae27">Debugging Node.js with Chrome DevTools</a>
<a href="https://medium.com/the-node-js-collection/debugging-node-js-with-google-chrome-4965b5f910f4">Debugging Node.js with Google Chrome</a>
<a href="https://www.google.com/search?q=chrome+node.js&oq=chrome+node.js&aqs=chrome..69i57.5657j0j7&sourceid=chrome&ie=UTF-8">chrome node.js</a>

<h2>Run Node.JS from page</h2>
<a href="https://stackoverflow.com/questions/29433718/run-node-js-from-page-javascript-button">Run Node.JS from page javascript button</a>
<a href="https://www.tutorialsteacher.com/nodejs/expressjs-web-application">Express.js Web Application</a>

<h2>Node.JS Examples</h2>
<a href="https://www.tutorialkart.com/nodejs/node-js-examples/" class="red bordwhite2 borRad10 limebs">Node.js Examples</a>

<h2>read a file</h2>
// include file system module
var fs = require('fs');
 
// read file sample.html
fs.readFile('sample.html',
    // callback function that is called when reading file is done
    function(err, data) { 
        if (err) throw err;
        // data is a buffer containing file content
        console.log(data.toString('utf8'))
});

</pre>
<br>
<h2>real time chat application in Node.js</h2>
<a href="real time chat application in Node.js.html"><span class="goldb">real time chat application in Node.js</span></a> 


<h2>TOP Node.JS Examples</h2>
https://bytescout.com/blog/node-js-code-examples.html
<strong>What is Node.js</strong> exactly, and what is Node.js used for? These are the essential questions we will answer here. 
Essentially, Node.js enables developers to build server apps in JavaScript. 
Projects in Node.js today commonly include:

Web Application framework
Messaging middleware
Servers for online gaming
REST APIs and Backend
Static file server

Node.js app development is wildly popular. 
Projects built with Node.js plus a combination of front-end developer tools are faster than similar PHP apps because of efficient <em>Async </em>functionality supported by Node. 
Node is also popular because now you can write JavaScript on both client and server.

<strong>This article covers the following aspects:</strong>

Building Node.js Skills
Under the Hood
First Node.js App
Build Your Own Node.js Module
Adding MySQL to Advanced Node.js Apps
Data Connection &#8211; Node JS Examples
Adding AngularJS Components
Best Practices for Fresh Ideas in Node.js

<strong>In this advanced intro to Node.js, we will explore the latest methods on how to create a Node.js module</strong>, and lead up to a method to create a simple Node.js app, in order to see the cutting-edge node in programming, as well as gain a full understanding of the Node.js app framework. 
These are apps we can build with Node.js and actually run simultaneously.

<h3>Building Node.js Skills</h3>

The best Node.js tutorials and MOOC online courses explain methods with <strong>well-documented code samples and snippets on how to learn Node.js</strong> <strong>properly</strong>. 
Extensive online education programs teach you all about <a href="https://nodejs.org/en/" target="_blank" rel="noopener noreferrer">Node.js</a> and include topics such as writing node modules and how to create a node module. 
MOOCs cover more in-depth topics ranging from simple Node.js applications to how to create a node server. 
Node.js is an open-source and as such the organization’s own documentation is a great resource for study.

Node’s API reference <a href="https://nodejs.org/en/docs/" target="_blank" rel="noopener noreferrer">documentation</a> contains details on functions and objects used to build Node.js programs. 
It also illustrates the arguments or parameters each method requires, as well as returned values of methods, and related predictable errors associated with each method. 
Importantly, developers take careful note of method variations by the version of Node.js as documented &#8211; the latest version is 9.10.1. 
Additional developer resources are provided such as security issues and updates, and the latest compatibility with ES6.

<h3>Under the Hood</h3>

<strong>Node uses Google Chrome’s runtime engine to translate JavaScript code to native machine code</strong> which runs on the server environment. 
Node.js is an open-source framework that runs on most popular OS platforms like Windows, Linux, and Mac OS X. 
Express.js, is the standard web application framework for use with Node.js, Express is a minimal framework with much of the functionality built as plugins. 
A typical app will use Express for the backend, MongoDB database, and <a href="https://bytescout.com/blog/angularjs-for-coding-spas.html" target="_blank" rel="noopener noreferrer">AngularJS</a> frontend (called MEAN stack). 
 The standard “Hello world” in Node is:

var http = require('http');
http.createServer(function (req, res) {
    res.writeHead(200, {'Content-Type': 'text/plain'});
    res.end('Hello Node.js World!');
}).listen(8080);

<h3>First Node.js App</h3>

In order to follow our Node JS examples, be sure to <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener noreferrer">download</a> and install the latest Node.js and update Node.js dependencies. 
The standard Node.js documentation includes complete details on how to install Node.js, and naturally, you will want to use the latest Node.js version. 
Trawling Google for tips will produce hits like, “node latest version.” And many of these pages refer to a specific package in Ubuntu, along with related bug reports. 
Making the distinction between beta and <em>node latest stable version</em> is important to developers who wish to experiment with the newest features.

<strong>Node.js generates dynamic page content, and in combination with AngularJS, the fastest possible single-page applications can be built easily.</strong> Node JS examples include creating and deleting server files, as well as open, read, and write ops to server databases. 
Node is event-driven with events including HTTP requests. 
Node files include tasks to be executed when triggered by these events. 
With that background, let’s get started setting up a real Node.js application.

Use the command npm init to initialize a new npm-project. 
This command creates a new package.json file and adds several lines of code for the basic structure, and this can be modified to track all the dependencies of the project. 
In order to test that your Node setup is correct, let’s run a quick test. 
Copy the “Hello Node World!” code above to a text file and name it, “test.js” to start. 
Now open a command-line interface (CLI) and enter the command npm init. 
You can now run your hello world in the CLI by typing: node test.js at the command prompt. 
If this works, your computer is now functioning as a web server and listening for events or requests on port 8080.

<h2>Build Your Own Node.js Module</h2>

The require (&#8216;http&#8217;) module is a built-in Node module that invokes the functionality of the HTTP library to create a local server. 
<strong>To add your own Node.js modules use the export statement to make functions in your module available externally.</strong> Create a new text file to contain the functions in your module called, “modules.js” and add this function to return today’s date and time:

exports.CurrentDateTime = function () {
    var d = new Date();
    return d;
};

<strong>Next, you can add the require(&#8216;./modules&#8217;)</strong>; as below to include the modules file. 
And by the way, Express framework can be included with a similar syntax as const express = require(&#8216;express&#8217;); to expose all its methods. 
Now you can reference the methods of your function in this way:

var http = require('http');
var dateTime = require('./modules');

http.createServer(function (req, res) {
    res.writeHead(200, {'Content-Type': 'text/html'});
    res.write("Current date and time: " + dateTime.CurrentDateTime());
    res.end();
}).listen(8080);

<strong>As mentioned, the HTTP module exposed with createServer() creates an HTTP server</strong> and listens to the server port 8080, and then responds to client requests. 
A function passed to the http.createServer() method will execute when a client accesses our computer at port 8080.

<h2>Adding MySQL to Advanced Node.js Apps</h2>

Today’s most popular combination of developer tools includes Express.js as a Node backend framework along with <strong>MySQL database and  AngularJS frontend</strong> functionality. 
We need an additional setup to make these work together and achieve full compatibility. 
Naturally, the core components must be installed first, so let’s briefly discuss the order of doing so.

On Windows, for example, you may already have installed MySQL Server via the MySQL Installer, which is satisfactory for this example. 
And MySQL X Protocol plugin may already be enabled &#8211; if not enable it now by re-configuring the <strong>MySQL Server</strong>. 
Enabling the X Plugin exposes the use of MySQL as a document store. 
Assuming Node and Express are now also installed, we will open a terminal and navigate to the location path to create a project. 
In the desired folder, install the Express application generator, which creates the project files and dependencies for a new application. 
At the CLI prompt just type: $ npm install express-generator –g and press Enter. 
We want to use HTML instead of the native Jade interpreter of Express so just enter this command for the setup: $ express MySQL pname &#8211;ejs and hit Enter (name is the actual name of your MySQL DB. 
You can now verify the new server is operating with the new app framework by entering: $ npm start and opening a browser to <strong><em>http://localhost:3000</em></strong>

<strong>The next step is to connect Node.js to MySQL. 
Enter this command:</strong>

$ npm install mysql-connector-nodejs at the CLI prompt and hit Enter to do so. 
Now install AngularJS and Angular-Route modules with the following command: $ npm install angular@1.5.8 angular-route@1.5.8 and hit Enter.

With everything installed, we can begin coding the web application. 
First, we will add a JSON file to the data folder with some data. 
Call it freshideas.json for this project. 
Add some data in a consistent format to ref later. 
A Node programming example (JSON file record) might include:

{
"title_": "Node.js: Testing Improvements",
"link_": "http://mynodejs.com/freshideas/",
"intro_": "Using Node.js with MySQL",
"pub_": "Thu Sep 29 2016",
},

Now we will update the app to create a schema plus a collection to upload the initial data. 
Next, open the ”www” file that is in the bin folder, which contains configuration details for the webserver to host the app. 
Now, add a function to create the schema, the collection, and upload the JSON data file to the collection. 
<strong>Add this code to the end of the “www” file:</strong>

function configuredbDataBase(callback) {
mysql.getSession({
    host: 'localhost',
    port: '33080',
    dbUser: 'root',
    dbPassword: ''pwd_
  }).then(function (session) {
    var schema = session.getSchema('mysqlPname');
    schema.existsInDatabase().then(function (exists) {
      if (!exists) {
        session.createSchema('mysqlPname').then(function (Pnamechema) {
        Promise.all([
        newSchema.createCollection('Pname').then(function (PnameColl) {
           PnameColl.add(initialData).execute().then(function (PnameAdded) {
                  var rowsAffected = PnameAdded.getAffectedItemsCount();
                  if (rowsAffected1 &lt;= 0) {
                    console.log('No Pname Added');
                  }
                  else {
                    console.log(rowsAffected1 + 'Pname Added');
                  }
                }).catch(function (err) {
                  console.log(err.message);
                  console.log(err.stack);
                });
              }).catch(function (err) {
                console.log(err.message);
                console.log(err.stack);
              })
          ]).then(function () {
            session.close();
            callback(Done: Collection initialized');
          });
        }).catch(function (err) {
          console.log(err.message);
          console.log(err.stack);
        });
      }
      else {
        session.close();
        callback('Database Already Configured');
      }
    });

  }).catch(function (err) {
    console.log(err.message);
    console.log(err.stack);
  });
}

function configureDataBase(callback) {
  mysql.getSession({
    host: 'localhost',
    port: '33080',
    dbUser: 'root',
    dbPassword: ''
  }).then(function (session) {
    var schema = session.getSchema('mysqlPname');

    schema.existsInDatabase().then(function (exists) {
      if (!exists) {
        session.createSchema('mysqlPname').then(function (newSchema) {
          Promise.all([
               newSchema.createCollection('Pname').then(function (PnameColl) {
                PnameColl.add(initialData).execute().then(function (PnameAdded) {
                  var rowsAffected1 = PnameAdded.getAffectedItemsCount();
                  if (rowsAffected1 &lt;= 0) {
                    console.log('No Pname Added');
                  }
                  else {
                    console.log(rowsAffected1 + ' Pname Added');
                  }
                }).catch(function (err) {
                  console.log(err.message);
                  console.log(err.stack);
                });
                }
      else {
        session.close();
        callback('Database Configured');
      }
    });
  }).catch(function (err) {
    console.log(err.message);
    console.log(err.stack);
  });
}

<strong>The above snippet illustrates how to configure the config for initialization and connecting the MySQL DB to the app</strong>, assigning the xdevapi module to the MySQL variable. 
The MySQL variables are used by the configureDataBase function and must be defined prior to calling the function. 
An instance of an EventEmitter is created and configured in the event that calls the function to create the schema and collection.

<h2>Data Connection &#8211; Node JS Examples</h2>

In this model, we will add a new file called Pname.js as consistent with the code to configure the MySQL. 
The new module will contain the methods used over the collections. 
As an example method let’s add a module to fetch documents from the collection. 
First, we define two variables, one to load MySQL xdevapi and one to store the configuration for connections to the server. 
Here is the basic code, which you can expand to <strong>suit your app:</strong>

var mysql_ = require('@mysql/xdevapi'); 
var config_ = {
    host: 'localhost',
    port: '33080',
    userid: 'root',
    password: '', pwd_
    schema: 'mysqlPname',
    collection: 'Pname'
};

Finally, we will add the method to get the export object of this module and then call <strong>getSession method</strong> to create a server connection. 
When the session is running we can get the schema and collection containing the documents. 
We then define one array variable as a container for documents that are returned from the collection. 
Executing the <em>find </em>method without a filter will return <em>all the documents</em>. 
If the execute method returned all documents they will be added to the array variable. 
As such, we have a Node.js server capable of asynchronous access to the MySQL DB, and running in the Express.js context.

<h2>Adding AngularJS Components</h2>

To add components <strong>using the Angular framework</strong> to display the docs from Pname, we will create a folder in the public Javascripts path with the defined name, and this folder will contain the template to add new docs as well. 
Begin by adding the new-comment.module.js component to the folder with the following code:

angular.module('newDoc', ['ngRoute']);
module('newDoc').
component('newDoc', {
templateUrl: '/javascripts/Doc/new-comment.template.html',
controller: ['$routeParams', 'Pname',
function NewDocController($routeParams, Pname) {
this.postIdl_ = $routeParams._Id;
this.addComment = function () {
if (!this.postIdl_ || (!this.comment || this.comment === ")) { return; }
Pname.addComment({ id: this.postId, Doc: this.Doc });
};
this.cancelAddComment = function () {
this.Doc= '', this.postIdl_ = '';
Pname.cancelAddDoc();
};
}
]
});

Here is an excellent view of the powerful capability to enable Angular as a frontend for a Node.js server. 
The demo shows how to build a full-stack JavaScript app using all the <strong>platforms including Node.js examples with MySQL</strong>, via the framework Express, and AngularJS as frontend.

<h3>Best Practices for Fresh Ideas in Node.js</h3>

Node.js 8 version included Async and Await functions for handling asynchronous file loading. 
<strong>This accelerated Node.js potential beyond PHP for many applications.</strong> It is essential to master these ES6 level functions to optimize your coding skills. 
Node.js 8.5 introduced support for ES modules with import() and export(). 
Further, Node.js 8.8 offered HTTP/2 without a flag. 
This supports server push and multiplexing and thus enables efficient loading of native modules in a browser. 
Note that Express support is in progress &#8211; HTTP/2 is experimental in the scope of Node.js with libraries now in development. 
Beyond the borders of Node.js itself, many supporting technologies enhance the developer experience, such as containers and virtualization. 
Docker technology provides containers, which virtualize an OS and render a truly portable and scalable web application. 

<h2>Node.js tutorial</h2>
Node.js is the runtime and <a href="https://www.npmjs.com/" class="external-link" target="_blank">npm</a> is the Package Manager for Node.js modules.
To run a Node.js application, you will need to install the Node.js runtime on your machine.
The Node Package Manager is included in the Node.js distribution. 
You'll need to open a new terminal (command prompt) for the <code>node</code> and <code>npm</code> command-line tools to be on your PATH.
<blockquote>
<strong>Tip:</strong> To test that you've got Node.js correctly installed on your computer, open a new terminal and type <code>node --help</code> and you should see the usage documentation.
</blockquote>
<h3>Hello World</h3>
Let's get started by creating the simplest Node.js application, &quot;Hello World&quot;.
Create an empty folder called &quot;hello&quot;, navigate into and open VS Code:
<code>mkdir hello
cd hello
code .</code>

<blockquote>
<strong>Tip:</strong> You can open files or folders directly from the command line. 
 The period '.' refers to the current folder, therefore VS Code will start and open the <code>Hello</code> folder.
</blockquote>
From the File Explorer toolbar, press the New File button:
and name the file <code>app.js</code>:
Create a simple string variable in <code>app.js</code> and send the contents of the string to the console:
<code>var msg = 'Hello World';
console.log(msg);</code>

save the file.
<h3>Running Hello World</h3>
It's simple to run <code>app.js</code> with Node.js. 
From a terminal, just type:
<code>node app.js</code>

You should see &quot;Hello World&quot; output to the terminal and then Node.js returns.
<h3>Integrated Terminal</h3>
VS Code has an <a href="/docs/editor/integrated-terminal">integrated terminal</a> which you can use to run shell commands. 
You can run Node.js directly from there and avoid switching out of VS Code while running command-line tools.
<strong>View</strong> &gt; <strong>Terminal</strong> (⌃` (Windows, Linux Ctrl+`) with the backtick character) will open the integrated terminal and you can run <code>node app.js</code> there:

<h3>Debugging Hello World</h3>
VS Code ships with a debugger for Node.js applications. 
Let's try debugging our simple Hello World application.
To set a breakpoint in <code>app.js</code>, put the editor cursor on the first line and press F9 or click in the editor left gutter next to the line numbers. 
A red circle will appear in the gutter.
<img class="lazy" data-src="https://code.visualstudio.com/assets/docs/nodejs/nodejs/app-js-breakpoint-set.png" alt="app.js breakpoint set">
To start debugging, select the Run View in the Activity Bar:
<img class="lazy" data-src="https://code.visualstudio.com/assets/docs/nodejs/nodejs/debugicon.png" alt="Run icon">
You can now click Debug toolbar green arrow or press F5 to launch and debug &quot;Hello World&quot;. 
Your breakpoint will be hit and you can view and step through the simple application. 
 Notice that VS Code displays a different colored Status Bar to indicate it is in Debug mode and the DEBUG CONSOLE is displayed.
<img class="lazy" data-src="https://code.visualstudio.com/assets/docs/nodejs/nodejs/hello-world-debugging.png" alt="hello world debugging">
Now that you've seen VS Code in action with &quot;Hello World&quot;, the next section shows using VS Code with a full-stack Node.js web app.
<blockquote>
<strong>Note:</strong> We're done with the &quot;Hello World&quot; example so navigate out of that folder before you create an Express app. 
You can delete the &quot;Hello&quot; folder if you wish as it is not required for the rest of the walkthrough.
</blockquote>
<h2>An Express application</h2>
<a href="https://expressjs.com/" class="external-link" target="_blank">Express</a> is a very popular application framework for building and running Node.js applications. 
You can scaffold (create) a new Express application using the Express Generator tool. 
The Express Generator is shipped as an npm module and installed by using the npm command-line tool <code>npm</code>.
<blockquote>
<strong>Tip:</strong> To test that you've got <code>npm</code> correctly installed on your computer, type <code>npm --help</code> from a terminal and you should see the usage documentation.
</blockquote>
Install the Express Generator by running the following from a terminal:
<code>npm install -g express-generator</code>

The <code>-g</code> switch installs the Express Generator globally on your machine so you can run it from anywhere.
We can now scaffold a new Express application called <code>myExpressApp</code> by running:
<code>express myExpressApp --view pug</code>

This creates a new folder called <code>myExpressApp</code> with the contents of your application. 
The <code>--view pug</code> parameters tell the generator to use the <a href="https://pugjs.org/api/getting-started.html" class="external-link" target="_blank">pug</a> template engine.
To install all of the application's dependencies (again shipped as npm modules), go to the new folder and execute <code>npm install</code>:
<code>cd myExpressApp
npm install</code>

At this point, we should test that our application runs. 
The generated Express application has a <code>package.json</code> file which includes a <code>start</code> script to run <code>node ./bin/www</code>. 
 This will start the Node.js application running.
From a terminal in the Express application folder, run:
<code>npm start</code>

<blockquote>
<strong>Tip:</strong> You can enable an explorer for the npm scripts in your workspace using the <code>npm.enableScriptExplorer</code> setting.
</blockquote>
The Node.js web server will start and you can browse to <a href="http://localhost:3000" class="external-link" target="_blank">http://localhost:3000</a> to see the running application.
<img class="lazy" data-src="https://code.visualstudio.com/assets/docs/nodejs/nodejs/express.png" alt="Your first Node Express App">
<h3>Great code editing</h3>
Close the browser and from a terminal in the <code>myExpressApp</code> folder, stop the Node.js server by pressing CTRL+C.
Now launch VS Code:
<code>code .</code>

<blockquote>
<strong>Note:</strong> If you've been using the VS Code integrated terminal to install the Express generator and scaffold the app, you can open the <code>myExpressApp</code> folder from your running VS Code instance with the <strong>File</strong> &gt; <strong>Open Folder</strong> command.
</blockquote>
The <a href="https://nodejs.org/api/" class="external-link" target="_blank">Node.js</a> and <a href="https://expressjs.com/api.html" class="external-link" target="_blank">Express</a> documentation does a great job explaining how to build rich applications using the platform and framework. 
Visual Studio Code will make you more productive in developing these types of applications by providing great code editing and navigation experiences.
Open the file <code>app.js</code> and hover over the Node.js global object <code>__dirname</code>. 
Notice how VS Code understands that <code>__dirname</code> is a string. 
Even more interesting, you can get full IntelliSense against the Node.js framework. 
For example, you can require <code>http</code> and get full IntelliSense against the <code>http</code> class as you type in Visual Studio Code.
<img class="lazy" data-src="https://code.visualstudio.com/assets/docs/nodejs/nodejs/intellisense.png" alt="http IntelliSense">
VS Code uses TypeScript type declaration (typings) files (for example <code>node.d.ts</code>) to provide metadata to VS Code about the JavaScript based frameworks you are consuming in your application. 
Type declaration files are written in TypeScript so they can express the data types of parameters and functions, allowing VS Code to provide a rich IntelliSense experience. 
Thanks to a feature called <code>Automatic Type Acquisition</code>, you do not have to worry about downloading these type declaration files, VS Code will install them automatically for you.
You can also write code that references modules in other files. 
For example, in <code>app.js</code> we require the <code>./routes/index</code> module, which exports an <code>Express.Router</code> class. 
If you bring up IntelliSense on <code>index</code>, you can see the shape of the <code>Router</code> class.
<img class="lazy" data-src="https://code.visualstudio.com/assets/docs/nodejs/nodejs/moduleintellisense.png" alt="Express.Router IntelliSense">
<h3>Debug your Express app</h3>
You will need to create a debugger configuration file <code>launch.json</code> for your Express application. 
Click on the Run icon in the <strong>Activity Bar</strong> and then the Configure gear icon at the top of the Run view to create a default <code>launch.json</code> file. 
 Select the <strong>Node.js</strong> environment by ensuring that the <code>type</code> property in <code>configurations</code> is set to <code>&quot;node&quot;</code>. 
 When the file is first created, VS Code will look in <code>package.json</code> for a <code>start</code> script and will use that value as the <code>program</code> (which in this case is <code>&quot;${workspaceFolder}\\bin\\www</code>) for the <strong>Launch Program</strong> configuration.
<code>{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "node",
      "request": "launch",
      "name": "Launch Program",
      "program": "${workspaceFolder}\\bin\\www"
    }
  ]
}</code>

Save the new file and make sure <strong>Launch Program</strong> is selected in the configuration drop-down at the top of the Run view. 
Open <code>app.js</code> and set a breakpoint near the top of the file where the Express app object is created by clicking in the gutter to the left of the line number. 
Press F5 to start debugging the application. 
VS Code will start the server in a new terminal and hit the breakpoint we set. 
From there you can inspect variables, create watches, and step through your code.

<img class="lazy" data-src="https://code.visualstudio.com/assets/docs/nodejs/nodejs/debugsession.png" alt="Debug session">
<h3>Deploy your application</h3>
If you'd like to learn how to deploy your web application, check out the <a href="/docs/azure/deployment">Deploying Applications to Azure</a> tutorials where we show how to run your website in Azure.

<h2>simple http proxy</h2>
<a href="https://stackoverflow.com/questions/20351637/how-to-create-a-simple-http-proxy-in-node-js" class="whitebut ">create a simple http proxy in node.js</a>

<h2>websockets to communicate between client and node.js server</h2>

https://medium.com/@joekarlsson/complete-guide-to-node-client-server-communication-b156440c029

This is a demo shows a demo of a client connecting to a websocket server and sharing data.

<span class="brown">Here is the server.js of a websocket.</span>

'use strict';
const WebSocketServer = require('ws').Server
const wss = new WebSocketServer({ port: 8081 });
wss.on('connection', ((ws) =&gt; {
  ws.on('message', (message) =&gt; {
    console.log(`received: ${message}`);
  });
  ws.on('end', () =&gt; {
  console.log('Connection ended...');
});
ws.send('Hello Client');
}));

<span class="brown">Here is the client.js of a websocket.</span>

console.log('open: ');
var ws = new WebSocket("ws://127.0.0.1:8081");
ws.onopen = function (event) {
  console.log('Connection is open ...');
  ws.send("Hello Server");
};
ws.onerror = function (err) {
  console.log('err: ', err);
}
ws.onmessage = function (event) {
  console.log(event.data);
  document.body.innerHTML += event.data + '&lt;br&gt;';
};
ws.onclose = function() {
  console.log("Connection is closed...");
}

https://stackoverflow.com/questions/52407025/client-server-communication-in-node-js

I would use websockets for this.
Once you've set up the connection you can initiate messages from either side.
The WS npm package makes this pretty easy.

<span class="brown">Server example (using the ws npm package):</span>

    const WebSocket = require('ws');

    // Set up server
    const wss = new WebSocket.Server({ port: 8080 });

    // Wire up some logic for the connection event (when a client connects) 
    wss.on('connection', function connection(ws) {

      // Wire up logic for the message event (when a client sends something)
      ws.on('message', function incoming(message) {
        console.log('received: %s', message);
      });

      // Send a message
      ws.send('Hello client!');
    });

<span class="brown">Client example</span> (no need for any package here, it's built into most browsers) :

// Create WebSocket connection.
const socket = new WebSocket('ws://localhost:8080');

// Connection opened
socket.addEventListener('open', function (event) {
    socket.send('Hello Server!');
});

// Listen for messages
socket.addEventListener('message', function (event) {
    console.log('Message from server ', event.data);
});

There are alternatives if you can't use websockets, such as polling (where the client periodically calls the server to see if theres a message), and long-polling (where the server holds a http request open for an artificially long period of time until a message is ready).

<h2>send data to USB device in node.js</h2>
<a href="https://www.npmjs.com/package/usb#interfaceinterface" class="whitebut ">USB Library for Node.JS</a>

Installation
Libusb is included as a submodule. 

npm install usb

Windows
Use Zadig to install the WinUSB driver for your USB device. 
Otherwise you will get LIBUSB_ERROR_NOT_SUPPORTED when attempting to open devices.

var usb = require('usb')
usb
Top-level object.

usb.getDeviceList()
Return a list of Device objects for the USB devices attached to the system.

usb.findByIds(vid, pid)
Convenience method to get the first device with the specified VID and PID, or undefined if no such device is present.

usb.LIBUSB_*
Constant properties from libusb

usb.setDebugLevel(level : int)
Set the libusb debug level (between 0 and 4)

Device
Represents a USB device.

.busNumber
Integer USB device number

.deviceAddress
Integer USB device address

.portNumbers
Array containing the USB device port numbers, or undefined if not supported on this platform.

<h2>Scrape a site with Node and Cheerio in 5 minutes</h2>
https://www.twilio.com/blog/web-scraping-and-parsing-html-with-node-js-and-cheerio

<a href="https://www.scrapingbee.com/blog/web-scraping-javascript/" class="whitebut redts gold bluebs dimbrownback">Web Scraping with Javascript and NodeJS</a>

Website scraping is a common problem with a common toolset. 
Two approaches dominate the web today:

Automate a browser to navigate a site programmatically, using tools like <a href="https://github.com/GoogleChrome/puppeteer" rel="noopener nofollow">Puppeteer</a> or <a href="https://www.seleniumhq.org/" rel="noopener nofollow">Selenium</a>.

Make an HTTP request to a website, retrieving data on the page using tools like <a href="https://github.com/cheeriojs/cheerio" rel="noopener nofollow">Cheerio</a> or <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/" rel="noopener nofollow">BeautifulSoup</a>.

The first approach — driving a real browser programmatically — is typical for projects where you’re running automated website tests, or capturing screenshots of your site.

The second approach has limitations. 
For example, Cheerio “<a href="https://github.com/cheeriojs/cheerio#cheerio-is-not-a-web-browser" rel="noopener nofollow">is not a browser</a>” and “does <em>not</em> produce a visual rendering, apply CSS, load external resources, or execute JavaScript”. 
<strong>But this approach is simple, and often sufficient, especially when you’re learning how scraping works.</strong>
<h3>Using Got to retrieve data to use with Cheerio</h3>
First let's write some code to grab the HTML from the web page, and look at how we can start parsing through it. 
The following code will send a <code>GET</code> request to the web page we want, and will create a Cheerio object with the HTML from that page. 
We'll name it <code>$</code> following the infamous jQuery convention:

<code>const fs = require('fs');
const cheerio = require('cheerio');
const got = require('got');

const vgmUrl= 'https://www.vgmusic.com/music/console/nintendo/nes';

got(vgmUrl).then(response => {
  const $ = cheerio.load(response.body);
  console.log($('title')[0].text());
  console.log($('h1').text());  // print the text

}).catch(err => {
  console.log(err);
});
</code>

With this <code>$</code> object, you can navigate through the HTML and retrieve <a href="https://api.jquery.com/Types/#Element">DOM elements</a> for the data you want, <a href="https://api.jquery.com/jQuery/">in the same way that you can with jQuery</a>. 
For example, <code>$('title')</code> will get you an array of objects corresponding to every <code>&lt;title></code> tag on the page. 
There's typically only one <code>title</code> element, so this will be an array with one object. 
If you run this code with the command <code>node index.js</code>, it will log the structure of this object to the console.

<h3>Getting familiar with Cheerio</h3>
When you have an object corresponding to an element in the HTML you're parsing through, you can do things like navigate through its children, parent and sibling elements. 
The child of this <code>&lt;title></code> element is the text within the tags. 
So <code>console.log($('title')[0].children[0].data);</code> will log the title of the web page.

If you want to get more specific in your query, <a href="https://api.jquery.com/category/selectors/">there are a variety of selectors</a> you can use to parse through the HTML. 
Two of the most common ones are to search for elements by <a href="https://api.jquery.com/class-selector/">class</a> or <a href="https://api.jquery.com/id-selector/">ID</a>. 
If you wanted to get a div with the ID of &quot;menu&quot; you would run <code>$('#menu')</code> and if you wanted all of the columns in the table of VGM MIDIs with the &quot;header&quot; class, you'd do <code>$('td.header')</code>

What we want on this page are the hyperlinks to all of the MIDI files we need to download. 
We can start by getting every link on the page using <code>$('a')</code>. 
Add the following to your code in <code>index.js</code>:

<code>got(vgmUrl).then(response => {
  const $ = cheerio.load(response.body);

  $('a').each((i, link) => {
    const href = link.attribs.href;
    console.log(href);
  });
}).catch(err => {
  console.log(err);
});
</code>

This code logs the URL of every link on the page. 
Notice that we're able to look through all elements from a given selector using the <code>.each()</code> function. 
Iterating through every link on the page is great, but we're going to need to get a little more specific than that if we want to download all of the MIDI files.

<h3>Filtering through HTML elements with Cheerio</h3>
Before writing more code to parse the content that we want, let’s first take a look at the HTML that’s rendered by the browser. 
Every web page is different, and sometimes getting the right data out of them requires a bit of creativity, pattern recognition, and experimentation.

<img src="https://twilio-cms-prod.s3.amazonaws.com/images/RqLbgi-q_vRQy0ai0TmWqdjoJjaN9k-OpSrNj2drs46QnP.width-500.png">

Our goal is to download a bunch of MIDI files, but there are a lot of duplicate tracks on this webpage, as well as remixes of songs. 
We only want one of each song, and because our ultimate goal is to use this data to train a neural network to generate accurate Nintendo music, we won't want to train it on user-created remixes.

When you're writing code to parse through a web page, it's usually helpful to use the developer tools available to you in most modern browsers. 
If you right-click on the element you're interested in, you can inspect the HTML behind that element to get more insight.

<img src="https://twilio-cms-prod.s3.amazonaws.com/images/eTCvZko6rcZKTGL3cwARnulCWGmKGP4Rpi1dK-XQbmmAgl.width-500.png">

With Cheerio, you can write filter functions to fine-tune which data you want from your selectors. 
These functions loop through all elements for a given selector and return true or false based on whether they should be included in the set or not.

If you looked through the data that was logged in the previous step, you might have noticed that there are quite a few links on the page that have no <code>href</code> attribute, and therefore lead nowhere. 
We can be sure those are not the MIDIs we are looking for, so let's write a short function to filter those out as well as making sure that elements which do contain a <code>href</code> element lead to a <code>.mid</code> file:

    <code>const isMidi = (i, link) => {
  // Return false if there is no href attribute.
  if(typeof link.attribs.href === 'undefined') { return false }

  return link.attribs.href.includes('.mid');
};
</code>

Now we have the problem of not wanting to download duplicates or user generated remixes. 
For this we can use regular expressions to make sure we are only getting links whose text has no parentheses, as only the duplicates and remixes contain parentheses:

    <code>const noParens = (i, link) => {
  // Regular expression to determine if the text has parentheses.
  const parensRegex = /^((?!\().)*$/;
  return parensRegex.test(link.children[0].data);
};
</code>

Try adding these to your code in <code>index.js</code>:

    <code>got(vgmUrl).then(response => {
  const $ = cheerio.load(response.body);

  $('a').filter(isMidi).filter(noParens).each((i, link) => {
    const href = link.attribs.href;
    console.log(href);
  });
});
</code>

Run this code again and it should only be printing <code>.mid</code> files.

<h3>Downloading the MIDI files we want from the webpage</h3>
Now that we have working code to iterate through every MIDI file that we want, we have to write code to download all of them.

In the callback function for looping through all of the MIDI links, add this code to stream the MIDI download into a local file, complete with error checking:

    <code>  $('a').filter(isMidi).filter(noParens).each((i, link) => {
    const fileName = link.attribs.href;

    got.stream(`${vgmUrl}/${fileName}`)
      .on('error', err => { console.log(err); console.log(`Error on ${vgmUrl}/${fileName}`) })
      .pipe(fs.createWriteStream(`MIDIs/${fileName}`))
      .on('error', err => { console.log(err); console.log(`Error on ${vgmUrl}/${fileName}`) })
      .on('finish', () => console.log(`Finished ${fileName}`));
  });
</code>

Run this code from a directory where you want to save all of the MIDI files, and watch your terminal screen display all 2230 MIDI files that you downloaded (at the time of writing this). 
With that, we should be finished scraping all of the MIDI files we need.
<h3>Worked Sample</h3>
const fs = require('fs');
const cheerio = require('cheerio');
const got = require('got');

const theAddr= "https://williamkpchan.github.io/LibDocs/GoNotes.html"

got(theAddr).then(response => {
  const $ = cheerio.load(response.body);

  $('h2').each(function(i) {
     console.log($(this).text())  // extract text content
     console.log(String($(this))) // cvt object to string

  });
}).catch(err => {
  console.log(err);
});

<h3>sample</h3>
const cheerio = require('cheerio');
const $ = cheerio.load('&lt;h2 class="title">Hello world&lt;/h2>');

$('h2.title').text('Hello there!');
$('h2').addClass('welcome');

$.html();
//=> &lt;html>&lt;head>&lt;/head>&lt;body>&lt;h2 class="title welcome">Hello there!&lt;/h2>&lt;/body>&lt;/html>

<h2>Copy to clipboard</h2>
const clipboardy = require('clipboardy');

// Copy
clipboardy.writeSync('🦄');

// Paste
clipboardy.readSync();
//🦄

<h2>Debugging</h2>
<a href="https://nodejs.org/en/docs/guides/debugging-getting-started/" class="whitebut ">Nodejs Debugging Guide</a>

<h2>await is only valid in async function</h2>
await can only be called in a function marked as async. 

(async function(){
    var body = await httpGet('link');
    $.response.setBody(body);
})()

Basically when you use one asynchronous operation, you need to make the entire flow asynchronous as well.
So the async keyword kindof uses ES6 generator function 
and makes it return a promise.

<h2>Promises</h2>
Promises simplify deferred and asynchronous computations. A promise represents an operation that hasn't completed yet.

<h2>chalk colors</h2>
<a href="https://github.com/chalk/chalk" class="whitebut ">chalk colors</a>
Example: chalk.red.bold.underline('Hello', 'world');

Colors: black, red, green, yellow, blue, magenta, cyan, white, blackBright (alias: gray, grey), redBright, greenBright, yellowBright, blueBright, magentaBright, cyanBright, whiteBright

Background colors: bgBlack, bgRed, bgGreen, bgYellow, bgBlue, bgMagenta, bgCyan, bgWhite, bgBlackBright (alias: bgGray, bgGrey), bgRedBright, bgGreenBright, bgYellowBright, bgBlueBright, bgMagentaBright, bgCyanBright, bgWhiteBright

Modifiers:
reset - Resets the current color chain.
bold - Make text bold.
dim - Emitting only a small amount of light.
italic - Make text italic. (Not widely supported)
underline - Make text underline. (Not widely supported)
inverse- Inverse background and foreground colors.
hidden - Prints the text, but makes it invisible.
strikethrough - Puts a horizontal line through the center of the text. (Not widely supported)
visible- Prints the text only when Chalk has a color level > 0. Can be useful for things that are purely cosmetic.

<h2>Node.js MySQL Tutorial About CRUD Application</h2>
<a href="https://www.edureka.co/blog/node-js-mysql-tutorial/" class="whitebut ">Node.js MySQL Tutorial About CRUD Application</a>

<h2>Serving static files in Express</h2>
https://expressjs.com/en/starter/static-files.html
To serve static files such as images, CSS files, and JavaScript files, use the express.static built-in middleware function in Express.

The function signature is:

express.static(root, [options])
The root argument specifies the root directory from which to serve static assets.

For example:
app.use(express.static('public'))
Now, you can load the files that are in the public directory:

http://localhost:3000/images/kitten.jpg
http://localhost:3000/css/style.css
http://localhost:3000/js/app.js
http://localhost:3000/images/bg.png
http://localhost:3000/hello.html

Express looks up the files relative to the static directory, so the name of the static directory is not part of the URL.

To use multiple static assets directories, call the express.static middleware function multiple times:

app.use(express.static('public'))
app.use(express.static('files'))

Express looks up the files in the order in which you set the static directories with the express.static middleware function.

NOTE: For best results, use a reverse proxy cache to improve performance of serving static assets.

To create a virtual path prefix (where the path does not actually exist in the file system) for files that are served by the express.static function, specify a mount path for the static directory, as shown below:

app.use('/static', express.static('public'))
Now, you can load the files that are in the public directory from the /static path prefix.

http://localhost:3000/static/images/kitten.jpg
http://localhost:3000/static/css/style.css
http://localhost:3000/static/js/app.js
http://localhost:3000/static/images/bg.png
http://localhost:3000/static/hello.html

However, the path that you provide to the express.static function is relative to the directory from where you launch your node process. If you run the express app from another directory, it’s safer to use the absolute path of the directory that you want to serve:

app.use('/static', express.static(path.join(__dirname, 'public')))

<h2>express dynamic content</h2>
<a href="Node.js dynamic content.html" class="whitebut ">Node.js dynamic content</a>









<br><br>
<script type='text/javascript' src='readbook.js'></script>
<script>
var lazyLoadInstance = new LazyLoad({ elements_selector: ".lazy" });
</script>
</body>
</html>
