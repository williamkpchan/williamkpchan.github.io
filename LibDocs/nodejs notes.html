<base target="_blank"><html><head><title>nodejs notes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@13.0.1/dist/lazyload.min.js"></script>
<script type='text/javascript' src='../mainscript.js'></script>
<script>
  var showTopicNumber = true;
</script>
<style>
body{width:80%;margin-left: 10%; font-size:22px;}
strong, h1, h2 {color: gold;}
strong {color: orange;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px;}
</style></head><body onkeypress="chkKey()"><center>
<h1>nodejs notes</h1>
<div id="toc"></div></center>
<pre>
<br>
<br>
<h2>nodejs tutorials</h2>
<a href="nodejs.html">&diams;nodejs</a>
<a href="Node入门.html">&diams;Node入门</a>
<a href="NodejsSQL.html" class="gold embossts">&diams;NodejsSQL</a>
<a class="goldword" href="http://www.tutorialspoint.com/nodejs/">Node.js Tutorial</a>
<a href="http://www.tutorialspoint.com/nodejs_terminal_online.php">Online Node Terminal</a>

<a href="Node命令行程序.html"><u class="redb">&diams;Node命令行程序</u></a>

<a href="nodejsList.html"><u class="redb">&diams;nodejsList</u></a>
<a href="https://medium.com/@kieranmaher13/nodejs-in-three-ish-minutes-4c4401b43b2c"><span class="redinsha">nodejs in 3 minutes</span></a>
<a href="http://www.youtube.com/watch?v=U8XF6AFGqlc">Node.js Tutorial For Absolute Beginners</a>
<a href="Getting Started with Node.js.html"><b class="redword">&diams;Getting Started with Node.js</b></a>

<a href="https://packagecontrol.io/packages/Nodejs"><span class="whiteOnblacksha">Sublime Text Nodejs</span></a>

<a href="nodejs_mongodb.html"><span class="orangeb">&diams;nodejs_mongodb</span></a>
Usage
node [options] [V8 options] [script.js | -e "script" | - ] [arguments]
node [options] [V8 options] [script.js | -e "script" | -] [--] [arguments]
node inspect [script.js | -e "script" | <host>:<port>] …
node --v8-options

Next, create a new source file in the projects folder and call it hello-world.js.

Open hello-world.js and paste in the following content:

const http = require('http');
const hostname = '127.0.0.1';
const port = 3000;
const server = http.createServer((req, res) => {
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/plain');
  res.end('Hello, World!\n');
});

server.listen(port, hostname, () => {
  console.log(`Server running at http://${hostname}:${port}/`);
});

Save the file, go back to the terminal window, and enter the following command:

$ node hello-world.js

Now, open any preferred web browser and visit http://127.0.0.1:3000.



<h2>Communication</h2>
<a href="Complete Guide To Node Client-Server Communication.html"><span class="orangeb">&diams;Complete Guide To Node Client-Server Communication</span></a>

<a href="https://stackoverflow.com/questions/11115508/in-node-js-how-do-i-communicate-with-client-side-javascript">node js communicate with client side javascript</a>
<a href="https://flaviocopes.com/node-websockets/">Using WebSockets with Node.js</a>

The easiest way is to set up <a href="http://expressjs.com/" class="whitebut ">Express</a> and have your client side code communicate via Ajax (for example, using jQuery).

(function() {
  var app, express;
  express = require("express");
  app = express.createServer();

  app.configure(function() {
    app.use(express.bodyParser());
    return app.use(app.router);
  });

  app.configure("development", function() {
    return app.use(express.errorHandler({
      dumpExceptions: true,
      showStack: true
    }));
  });

  app.post("/locations", function(request, response) {
    var latitude, longitude;
    latitude = request.body.latitude;
    longitude = request.body.longitude;
    return response.json({}, 200);
  });
  app.listen(80);
}).call(this);

On the client side, call it like this:

var latitude = 0, longitude = 0; // Set from form
$.post({
  url: "http://localhost/locations",
  data: {latitude: latitude, longitude: longitude},
  success: function (data) {
    console.log("Success");
  },
  dataType: "json"
});

Note this code is simply an example; you'll have to work out the error handling, etc.

Another way is by making an HTTP request, just like any other server side program in a web application.

With the XMLHttpRequest object, or by generating a <form> and then submitting it, or a variety of other methods.

<h2>Create a new WebSockets connection</h2>
<code>const url = &#39;wss://myserver.com/something&#39;
const connection = new WebSocket(url)
</code>

<code>connection</code> is a <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket">WebSocket</a> object.

When the connection is successfully established, the <code>open</code> event is fired.

Listen for it by assigning a callback function to the <code>onopen</code> property of the <code>connection</code> object:

<code>connection.onopen = () =&gt; {
  //...
}
</code>

If there's any error, the <code>onerror</code> function callback is fired:

<code>connection.onerror = error =&gt; {
  console.log(`WebSocket error: ${error}`)
}
</code>

<h2>Sending data to the server using WebSockets</h2>

Once the connection is open, you can send data to the server.

You can do so conveniently inside the <code>onopen</code> callback function:

<code>connection.onopen = () =&gt; {
  connection.send(&#39;hey&#39;)
}
</code>

<h2>Receiving data from the server using WebSockets</h2>

Listen with a callback function on <code>onmessage</code>, which is called when the <code>message</code> event is received:

<code>connection.onmessage = e =&gt; {
  console.log(e.data)
}
</code>

<h2>Implement a WebSockets server in Node.js</h2>

<a href="https://github.com/websockets/ws">ws</a> is a popular WebSockets library for <a href="/nodejs/">Node.js</a>.

We'll use it to build a WebSockets server. It can also be used to implement a client, and use WebSockets to communicate between two backend services.

Easily install it using

<code>yarn init
yarn add ws</code>

The code you need to write is very little:

<code>const WebSocket = require(&#39;ws&#39;)

const wss = new WebSocket.Server({ port: 8080 })

wss.on(&#39;connection&#39;, ws =&gt; {
  ws.on(&#39;message&#39;, message =&gt; {
    console.log(`Received message =&gt; ${message}`)
  })
  ws.send(&#39;ho!&#39;)
})
</code>

This code creates a new server on port 8080 (the default port for WebSockets), and adds a callback function when a connection is established, sending <code>ho!</code> to the client, and logging the messages it receives.

<h2>See a live example on Glitch</h2>

Here is a live example of a WebSockets server: <a href="https://glitch.com/edit/#!/flavio-websockets-server-example">https://glitch.com/edit/#!/flavio-websockets-server-example</a>

Here is a WebSockets client that interacts with the server: <a href="https://glitch.com/edit/#!/flavio-websockets-client-example">https://glitch.com/edit/#!/flavio-websockets-client-example</a>

<h2>Node.js Generate html</h2>
<a href="https://stackoverflow.com/questions/21617468/node-js-generate-html">Node.js Generate html</a>

The most basic way is:

var http = require('http');

http.createServer(function (req, res) {
  var html = buildHtml(req);

  res.writeHead(200, {
    'Content-Type': 'text/html',
    'Content-Length': html.length,
    'Expires': new Date().toUTCString()
  });
  res.end(html);
}).listen(8080);

function buildHtml(req) {
  var header = '';
  var body = '';

  // concatenate header string
  // concatenate body string

  return '&lt;!DOCTYPE html&gt;'
       + '&lt;html&gt;&lt;head&gt;' + header + '&lt;/head&gt;&lt;body&gt;' + body + '&lt;/body&gt;&lt;/html&gt;';
};
And access this HTML with http://localhost:8080 from your browser.

<a href="https://www.npmjs.com/package/create-html">create-html</a>

<h2>nodejs server</h2>
<pre>
var http = require('http');

http.createServer(function (req, res) {
    res.writeHead(200, {'Content-Type': 'text/html'});
    res.end('Hello World!');
}).listen(8080);

<h2>Web Scraping nodejs server</h2>
<a href="http://stackoverflow.com/questions/6084360/using-node-js-as-a-simple-web-server">Using node.js as a simple web server</a>
Simplest Node.js server is just:
$ npm install http-server -g

Now you can run a server via the following commands:
$ cd MyApp
$ http-server

If you're using NPM 5.2.0 or newer, you can use http-server without installing it with npx. 
This isn't recommended for use in production but is a great way to quickly get a server running on localhost.

$ npx http-server

Or, you can try this, which opens your web browser and enables CORS requests:
$ http-server -o --cors

For more options, check out the documentation for http-server on GitHub, or run:
$ http-server --help

Lots of other nice features and brain-dead-simple deployment to NodeJitsu.

Feature Forks

Of course, you can easily top up the features with your own fork. 
You might find it's already been done in one of the existing 800+ forks of this project:

https://github.com/nodeapps/http-server/network

Light Server: An Auto Refreshing Alternative

A nice alternative to http-server is light-server. 
It supports file watching and auto-refreshing and many other features.

$ npm install -g light-server 
$ light-server

Add to your directory context menu in Windows Explorer

 reg.exe add HKCR\Directory\shell\LightServer\command /ve /t REG_EXPAND_SZ /f /d "\"C:\nodejs\light-server.cmd\" \"-o\" \"-s\" \"%V\""

Simple JSON REST server

If you need to create a simple REST server for a prototype project then json-server might be what you're looking for.

Auto Refreshing Editors

Most web page editors and IDE tools now include a web server that will watch your source files and auto refresh your web page when they change.
I use Live Server with Visual Studio Code.
The open source text editor Brackets also includes a NodeJS static web server. 
Just open any HTML file in Brackets, press "Live Preview" and it starts a static server and opens your browser at the page. 
The browser will **auto refresh whenever you edit and save the HTML file. 
This especially useful when testing adaptive web sites. 
Open your HTML page on multiple browsers/window sizes/devices. 
Save your HTML page and instantly see if your adaptive stuff is working as they all auto refresh.

PhoneGap Developers

If you're coding a hybrid mobile app, you may be interested to know that the PhoneGap team took this auto refresh concept on board with their new PhoneGap App. 
This is a generic mobile app that can load the HTML5 files from a server during development. 
This is a very slick trick since now you can skip the slow compile/deploy steps in your development cycle for hybrid mobile apps if you're changing JS/CSS/HTML files — which is what you're doing most of the time. 
They also provide the static NodeJS web server (run phonegap serve) that detects file changes.

PhoneGap + Sencha Touch Developers

I've now extensively adapted the PhoneGap static server & PhoneGap Developer App for Sencha Touch & jQuery Mobile developers. 
Check it out at Sencha Touch Live. 
Supports --qr QR Codes and --localtunnel that proxies your static server from your desktop computer to a URL outside your firewall! Tons of uses. 
Massive speedup for hybrid mobile devs.

Cordova + Ionic Framework Developers

Local server and auto refresh features are baked into the ionic tool. 
Just run ionic serve from your app folder. 
Even better ... 
ionic serve --lab to view auto-refreshing side by side views of both iOS and Android.

<a href="http://hackprogramming.com/web-scraping-in-node-js-with-multiple-examples/">Web Scraping In Node Js With Multiple Examples</a>
<a href="https://scotch.io/tutorials/scraping-the-web-with-node-js">Scraping the Web With Node.js</a>
<a href="https://codeburst.io/an-introduction-to-web-scraping-with-node-js-1045b55c63f7">An Introduction to Web Scraping with Node JS</a>

<h3>What will we need?</h3>
For this project we’ll be using <a href="https://nodejs.org/en/">Node.js</a>. 

We’ll also be using two open-sourced <a href="https://www.npmjs.com/"><strong>npm</strong></a><strong> </strong>modules to make today’s task a little easier:
<a href="https://github.com/request/request-promise"><strong>request-promise </strong></a>— Request is a simple HTTP client that allows us to make quick and easy HTTP calls.
<a href="https://github.com/cheeriojs/cheerio"><strong>cheerio</strong></a> — jQuery for Node.js. 
Cheerio makes it easy to select, edit, and view DOM elements.

<h3>Project Setup.</h3>Create a new project folder. 
Within that folder create an <code>index.js</code> file. 
We’ll need to install and require our dependencies. 
Open up your command line, and install and save:<strong> request, request-promise, and cheerio</strong>
npm install --save request request-promise cheerio
Then require them in our <code>index.js</code> file:
const rp = require(&#x27;request-promise&#x27;);
const cheerio = require(&#x27;cheerio&#x27;);
<h3>Setting up the Request</h3><code>request-promise</code> accepts an object as input, and returns a promise. 
The <code>options</code> object needs to do two things:
Pass in the url we want to scrape.
Tell Cheerio to load the returned HTML so that we can use it.

Here’s what that looks like:
const options = {
  uri: `<a href="https://www.google.com/search?num=10&amp;q=${search}`">https://www.yourURLhere.com`</a>,
  transform: function (body) { return cheerio.load(body); }
};
The <code>uri</code> key is simply the website we want to scrape.
The <code>transform</code> key tells <code>request-promise</code> to take the returned body and load it into Cheerio before returning it to us.
Awesome. 
We’ve successfully set up our HTTP request options! Here’s what your code should look like so far:
const rp = require(&#x27;request-promise&#x27;);
const cheerio = require(&#x27;cheerio&#x27;);const options = {
  uri: `<a href="https://www.google.com/search?num=10&amp;q=${search}`">https://www.yourURLhere.com`</a>,
  transform: function (body) { return cheerio.load(body); }
};
<h3>Make the Request</h3>Now that the options are taken care of, we can actually make our request. 
The boilerplate in the documentation for that looks like this:
rp(<strong>OPTIONS</strong>)
    .then(function (data) {
        // <strong>REQUEST SUCCEEDED:</strong> <strong>DO SOMETHING</strong>
    })
    .catch(function (err) {
        // <strong>REQUEST FAILED: ERROR OF SOME KIND</strong>
    });
We pass in our <code>options</code> object to <code>request-promise</code>, then wait to see if our request succeeds or fails. 
Either way, we do something with the returned data.
Knowing what the documentation says to do, lets create our own version:
rp(options)
  .then(($) =&gt; {
    console.log($);
  })
  .catch((err) =&gt; {
    console.log(err);
  });
The code is pretty similar. 
The big difference is I’ve used arrow functions. 
I’ve also logged out the returned data from our HTTP request. 
We’re going to test to make sure everything is working so far.
Replace the placeholder <code>uri</code> with the website you want to scrape. 
Then, open up your console and type:
<strong>node index.js</strong>// LOGS THE FOLLOWING:
{ [Function: initialize]
  fn:
   initialize {
     constructor: [Circular],
     _originalRoot:
      { type: &#x27;root&#x27;,
        name: &#x27;root&#x27;,
        namespace: &#x27;<a href="http://www.w3.org/1999/xhtml&#x27;">http://www.w3.org/1999/xhtml&#x27;</a>,
        attribs: {},
        ...
If you don’t see an error, then everything is working so far — and you just made your first scrape!

Here is the full code of our boilerplate:
const rp = require('request-promise');
const cheerio = require('cheerio');
const options = {
  uri: `https://www.google.com`,
  transform: function (body) { return cheerio.load(body); }
};

rp(options)
  .then(($) => {
    console.log($);
  })
  .catch((err) => {
    console.log(err);
  });

Boilerplate web scraping code

<h3>Using the Data</h3>What good is our web scraper if it doesn’t actually return any useful data? This is where the fun begins.
There are numerous things you can do with Cheerio to extract the data that you want. 
First and foremost, Cheerio’s selector implementation is nearly identical to jQuery’s. 
So if you know jQuery, this will be a breeze. 
If not, don’t worry, I’ll show you.
<h2>Selectors</h2>The selector method allows you to traverse and select elements in the document. 
You can get data and set data using a selector. 
Imagine we have the following HTML in the website we want to scrape:
<strong>&lt;ul id=&quot;cities&quot;&gt;
  &lt;li class=&quot;large&quot;&gt;New York&lt;/li&gt;
  &lt;li id=&quot;medium&quot;&gt;Portland&lt;/li&gt;
  &lt;li class=&quot;small&quot;&gt;Salem&lt;/li&gt;
&lt;/ul&gt;</strong>
We can select id’s using (<code>#</code>), classes using (<code>.</code>), and elements by their tag names, ex: <code>div</code>.
$(&#x27;.large&#x27;).text()
// New York$(&#x27;#medium&#x27;).text()
// Portland$(&#x27;li[class=small]&#x27;).html()
// &lt;li class=&quot;small&quot;&gt;Salem&lt;/li&gt;
<h2>Looping</h2>Just like jQuery, we can also iterate through multiple elements with the <code>each()</code> function. 
Using the same HTML code as above, we can return the inner text of each <code>li</code> with the following code:
$(&#x27;li&#x27;).each(function(i, elem) {
  cities[i] = $(this).text();
});// New York Portland Salem
<h2>Finding</h2>Imagine we have two lists on our web site:
<strong>&lt;ul id=&quot;cities&quot;&gt;
  &lt;li class=&quot;large&quot;&gt;New York&lt;/li&gt;
  &lt;li id=&quot;c-medium&quot;&gt;Portland&lt;/li&gt;
  &lt;li class=&quot;small&quot;&gt;Salem&lt;/li&gt;
&lt;/ul&gt;
&lt;ul id=&quot;towns&quot;&gt;
  &lt;li class=&quot;large&quot;&gt;Bend&lt;/li&gt;
  &lt;li id=&quot;t-medium&quot;&gt;Hood River&lt;/li&gt;
  &lt;li class=&quot;small&quot;&gt;Madras&lt;/li&gt;
&lt;/ul&gt;</strong>
We can select each list using their respective ID’s, then find the <em>small </em>city/town within each list:
$(&#x27;#cities&#x27;).find(&#x27;.small&#x27;).text()
// Salem$(&#x27;#towns&#x27;).find(&#x27;.small&#x27;).text()
// Madras
<blockquote>Finding will search all descendant DOM elements, not just immediate children as shown in this example.
</blockquote><h2>Children</h2>Children is similar to find. 
The difference is that children <strong>only </strong>searches for immediate children of the selected element.
$(&#x27;#cities&#x27;).children(&#x27;#c-medium&#x27;).text();
// Portland
<h2>Text &amp; HTML</h2>Up until this point, all of my examples have included the <code>.text()</code> function. 
Hopefully you’ve been able to figure out that this function is what gets the text of the selected element. 
You can also use <code>.html()</code> to return the html of the given element:
$(&#x27;.large&#x27;)<strong>.text()</strong>
// Bend$(&#x27;.large&#x27;)<strong>.html()</strong>
// &lt;li class=&quot;large&quot;&gt;Bend&lt;/li&gt;
<h2>Additional Methods</h2>There are more methods than I can count, and the documentation for all of them is available <a href="https://github.com/cheeriojs/cheerio"><strong>here</strong></a>.
<h3>Chrome Developer Tools</h3>Don’t forget, the Chrome Developer Tools are your friend. 
In Google Chrome, you can easily find element, class, and ID names using: <strong>CTRL + SHIFT + C</strong>
<div role="button" tabindex="0"><img alt="Image for post" src="https://miro.medium.com/max/60/1*HNgMR7H87W7I0p3JvekDIQ.png?q=20" width="928" height="286"/><img alt="Image for post" width="928" height="286"/><noscript><img alt="Image for post" src="https://miro.medium.com/max/1856/1*HNgMR7H87W7I0p3JvekDIQ.png" width="928" height="286" srcSet="https://miro.medium.com/max/552/1*HNgMR7H87W7I0p3JvekDIQ.png 276w, https://miro.medium.com/max/1104/1*HNgMR7H87W7I0p3JvekDIQ.png 552w, https://miro.medium.com/max/1280/1*HNgMR7H87W7I0p3JvekDIQ.png 640w, https://miro.medium.com/max/1400/1*HNgMR7H87W7I0p3JvekDIQ.png 700w" sizes="700px"/></noscript>
Finding class names with chrome dev tools
As you seen in the above image, I’m able to hover over an element on the page and the element name and class name of the selected element are shown in real-time!
<h3>Limitations</h3>As Jaye Speaks points out:
<blockquote>MOST websites modify the DOM using JavaScript. 
Unfortunately Cheerio doesn’t resolve parsing a modified DOM. 
Dynamically generated content from procedures leveraging AJAX, client-side logic, and other async procedures are not available to Cheerio.
</blockquote>Remember this is an introduction to basic scraping. 
In order to get started you’ll need to find a static website with minimal DOM manipulation.

<a href="https://www.freecodecamp.org/news/the-ultimate-guide-to-web-scraping-with-node-js-daa2027dcd3/">The Ultimate Guide to Web Scraping with Node.js</a>
<a href="https://stackabuse.com/web-scraping-with-node-js/">Web Scraping with Node.js</a>
<a href="https://levelup.gitconnected.com/web-scraping-with-node-js-c93dcf76fe2b">Web Scraping with Node.js</a>
<a href="https://medium.com/@paul_irish/debugging-node-js-nightlies-with-chrome-devtools-7c4a1b95ae27">Debugging Node.js with Chrome DevTools</a>
<a href="https://medium.com/the-node-js-collection/debugging-node-js-with-google-chrome-4965b5f910f4">Debugging Node.js with Google Chrome</a>
<a href="https://www.google.com/search?q=chrome+node.js&oq=chrome+node.js&aqs=chrome..69i57.5657j0j7&sourceid=chrome&ie=UTF-8">chrome node.js</a>

<h2>Run Node.JS from page</h2>
<a href="https://stackoverflow.com/questions/29433718/run-node-js-from-page-javascript-button">Run Node.JS from page javascript button</a>
<a href="https://www.tutorialsteacher.com/nodejs/expressjs-web-application">Express.js Web Application</a>

<h2>Node.JS Examples</h2>
<a href="https://www.tutorialkart.com/nodejs/node-js-examples/" class="red bordwhite2 borRad10 limebs">Node.js Examples</a>

<h2>read a file</h2>
// include file system module
var fs = require('fs');
 
// read file sample.html
fs.readFile('sample.html',
    // callback function that is called when reading file is done
    function(err, data) { 
        if (err) throw err;
        // data is a buffer containing file content
        console.log(data.toString('utf8'))
});

</pre>
<br>
<h2>real time chat application in Node.js</h2>
<a href="real time chat application in Node.js.html"><span class="goldb">real time chat application in Node.js</span></a> 


<h2>TOP Node.JS Examples</h2>
https://bytescout.com/blog/node-js-code-examples.html
<strong>What is Node.js</strong> exactly, and what is Node.js used for? These are the essential questions we will answer here. 
Essentially, Node.js enables developers to build server apps in JavaScript. 
Projects in Node.js today commonly include:

Web Application framework
Messaging middleware
Servers for online gaming
REST APIs and Backend
Static file server

Node.js app development is wildly popular. 
Projects built with Node.js plus a combination of front-end developer tools are faster than similar PHP apps because of efficient <em>Async </em>functionality supported by Node. 
Node is also popular because now you can write JavaScript on both client and server.

<strong>This article covers the following aspects:</strong>

Building Node.js Skills
Under the Hood
First Node.js App
Build Your Own Node.js Module
Adding MySQL to Advanced Node.js Apps
Data Connection &#8211; Node JS Examples
Adding AngularJS Components
Best Practices for Fresh Ideas in Node.js

<strong>In this advanced intro to Node.js, we will explore the latest methods on how to create a Node.js module</strong>, and lead up to a method to create a simple Node.js app, in order to see the cutting-edge node in programming, as well as gain a full understanding of the Node.js app framework. 
These are apps we can build with Node.js and actually run simultaneously.

<h3>Building Node.js Skills</h3>

The best Node.js tutorials and MOOC online courses explain methods with <strong>well-documented code samples and snippets on how to learn Node.js</strong> <strong>properly</strong>. 
Extensive online education programs teach you all about <a href="https://nodejs.org/en/" target="_blank" rel="noopener noreferrer">Node.js</a> and include topics such as writing node modules and how to create a node module. 
MOOCs cover more in-depth topics ranging from simple Node.js applications to how to create a node server. 
Node.js is an open-source and as such the organization’s own documentation is a great resource for study.

Node’s API reference <a href="https://nodejs.org/en/docs/" target="_blank" rel="noopener noreferrer">documentation</a> contains details on functions and objects used to build Node.js programs. 
It also illustrates the arguments or parameters each method requires, as well as returned values of methods, and related predictable errors associated with each method. 
Importantly, developers take careful note of method variations by the version of Node.js as documented &#8211; the latest version is 9.10.1. 
Additional developer resources are provided such as security issues and updates, and the latest compatibility with ES6.

<h3>Under the Hood</h3>

<strong>Node uses Google Chrome’s runtime engine to translate JavaScript code to native machine code</strong> which runs on the server environment. 
Node.js is an open-source framework that runs on most popular OS platforms like Windows, Linux, and Mac OS X. 
Express.js, is the standard web application framework for use with Node.js, Express is a minimal framework with much of the functionality built as plugins. 
A typical app will use Express for the backend, MongoDB database, and <a href="https://bytescout.com/blog/angularjs-for-coding-spas.html" target="_blank" rel="noopener noreferrer">AngularJS</a> frontend (called MEAN stack). 
 The standard “Hello world” in Node is:

var http = require('http');
http.createServer(function (req, res) {
    res.writeHead(200, {'Content-Type': 'text/plain'});
    res.end('Hello Node.js World!');
}).listen(8080);

<h3>First Node.js App</h3>

In order to follow our Node JS examples, be sure to <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener noreferrer">download</a> and install the latest Node.js and update Node.js dependencies. 
The standard Node.js documentation includes complete details on how to install Node.js, and naturally, you will want to use the latest Node.js version. 
Trawling Google for tips will produce hits like, “node latest version.” And many of these pages refer to a specific package in Ubuntu, along with related bug reports. 
Making the distinction between beta and <em>node latest stable version</em> is important to developers who wish to experiment with the newest features.

<strong>Node.js generates dynamic page content, and in combination with AngularJS, the fastest possible single-page applications can be built easily.</strong> Node JS examples include creating and deleting server files, as well as open, read, and write ops to server databases. 
Node is event-driven with events including HTTP requests. 
Node files include tasks to be executed when triggered by these events. 
With that background, let’s get started setting up a real Node.js application.

Use the command npm init to initialize a new npm-project. 
This command creates a new package.json file and adds several lines of code for the basic structure, and this can be modified to track all the dependencies of the project. 
In order to test that your Node setup is correct, let’s run a quick test. 
Copy the “Hello Node World!” code above to a text file and name it, “test.js” to start. 
Now open a command-line interface (CLI) and enter the command npm init. 
You can now run your hello world in the CLI by typing: node test.js at the command prompt. 
If this works, your computer is now functioning as a web server and listening for events or requests on port 8080.

<h2>Build Your Own Node.js Module</h2>

The require (&#8216;http&#8217;) module is a built-in Node module that invokes the functionality of the HTTP library to create a local server. 
<strong>To add your own Node.js modules use the export statement to make functions in your module available externally.</strong> Create a new text file to contain the functions in your module called, “modules.js” and add this function to return today’s date and time:

exports.CurrentDateTime = function () {
    var d = new Date();
    return d;
};

<strong>Next, you can add the require(&#8216;./modules&#8217;)</strong>; as below to include the modules file. 
And by the way, Express framework can be included with a similar syntax as const express = require(&#8216;express&#8217;); to expose all its methods. 
Now you can reference the methods of your function in this way:

var http = require('http');
var dateTime = require('./modules');

http.createServer(function (req, res) {
    res.writeHead(200, {'Content-Type': 'text/html'});
    res.write("Current date and time: " + dateTime.CurrentDateTime());
    res.end();
}).listen(8080);

<strong>As mentioned, the HTTP module exposed with createServer() creates an HTTP server</strong> and listens to the server port 8080, and then responds to client requests. 
A function passed to the http.createServer() method will execute when a client accesses our computer at port 8080.

<h2>Adding MySQL to Advanced Node.js Apps</h2>

Today’s most popular combination of developer tools includes Express.js as a Node backend framework along with <strong>MySQL database and  AngularJS frontend</strong> functionality. 
We need an additional setup to make these work together and achieve full compatibility. 
Naturally, the core components must be installed first, so let’s briefly discuss the order of doing so.

On Windows, for example, you may already have installed MySQL Server via the MySQL Installer, which is satisfactory for this example. 
And MySQL X Protocol plugin may already be enabled &#8211; if not enable it now by re-configuring the <strong>MySQL Server</strong>. 
Enabling the X Plugin exposes the use of MySQL as a document store. 
Assuming Node and Express are now also installed, we will open a terminal and navigate to the location path to create a project. 
In the desired folder, install the Express application generator, which creates the project files and dependencies for a new application. 
At the CLI prompt just type: $ npm install express-generator –g and press Enter. 
We want to use HTML instead of the native Jade interpreter of Express so just enter this command for the setup: $ express MySQL pname &#8211;ejs and hit Enter (name is the actual name of your MySQL DB. 
You can now verify the new server is operating with the new app framework by entering: $ npm start and opening a browser to <strong><em>http://localhost:3000</em></strong>

<strong>The next step is to connect Node.js to MySQL. 
Enter this command:</strong>

$ npm install mysql-connector-nodejs at the CLI prompt and hit Enter to do so. 
Now install AngularJS and Angular-Route modules with the following command: $ npm install angular@1.5.8 angular-route@1.5.8 and hit Enter.

With everything installed, we can begin coding the web application. 
First, we will add a JSON file to the data folder with some data. 
Call it freshideas.json for this project. 
Add some data in a consistent format to ref later. 
A Node programming example (JSON file record) might include:

{
"title_": "Node.js: Testing Improvements",
"link_": "http://mynodejs.com/freshideas/",
"intro_": "Using Node.js with MySQL",
"pub_": "Thu Sep 29 2016",
},

Now we will update the app to create a schema plus a collection to upload the initial data. 
Next, open the ”www” file that is in the bin folder, which contains configuration details for the webserver to host the app. 
Now, add a function to create the schema, the collection, and upload the JSON data file to the collection. 
<strong>Add this code to the end of the “www” file:</strong>

function configuredbDataBase(callback) {
mysql.getSession({
    host: 'localhost',
    port: '33080',
    dbUser: 'root',
    dbPassword: ''pwd_
  }).then(function (session) {
    var schema = session.getSchema('mysqlPname');
    schema.existsInDatabase().then(function (exists) {
      if (!exists) {
        session.createSchema('mysqlPname').then(function (Pnamechema) {
        Promise.all([
        newSchema.createCollection('Pname').then(function (PnameColl) {
           PnameColl.add(initialData).execute().then(function (PnameAdded) {
                  var rowsAffected = PnameAdded.getAffectedItemsCount();
                  if (rowsAffected1 &lt;= 0) {
                    console.log('No Pname Added');
                  }
                  else {
                    console.log(rowsAffected1 + 'Pname Added');
                  }
                }).catch(function (err) {
                  console.log(err.message);
                  console.log(err.stack);
                });
              }).catch(function (err) {
                console.log(err.message);
                console.log(err.stack);
              })
          ]).then(function () {
            session.close();
            callback(Done: Collection initialized');
          });
        }).catch(function (err) {
          console.log(err.message);
          console.log(err.stack);
        });
      }
      else {
        session.close();
        callback('Database Already Configured');
      }
    });

  }).catch(function (err) {
    console.log(err.message);
    console.log(err.stack);
  });
}

function configureDataBase(callback) {
  mysql.getSession({
    host: 'localhost',
    port: '33080',
    dbUser: 'root',
    dbPassword: ''
  }).then(function (session) {
    var schema = session.getSchema('mysqlPname');

    schema.existsInDatabase().then(function (exists) {
      if (!exists) {
        session.createSchema('mysqlPname').then(function (newSchema) {
          Promise.all([
               newSchema.createCollection('Pname').then(function (PnameColl) {
                PnameColl.add(initialData).execute().then(function (PnameAdded) {
                  var rowsAffected1 = PnameAdded.getAffectedItemsCount();
                  if (rowsAffected1 &lt;= 0) {
                    console.log('No Pname Added');
                  }
                  else {
                    console.log(rowsAffected1 + ' Pname Added');
                  }
                }).catch(function (err) {
                  console.log(err.message);
                  console.log(err.stack);
                });
                }
      else {
        session.close();
        callback('Database Configured');
      }
    });
  }).catch(function (err) {
    console.log(err.message);
    console.log(err.stack);
  });
}

<strong>The above snippet illustrates how to configure the config for initialization and connecting the MySQL DB to the app</strong>, assigning the xdevapi module to the MySQL variable. 
The MySQL variables are used by the configureDataBase function and must be defined prior to calling the function. 
An instance of an EventEmitter is created and configured in the event that calls the function to create the schema and collection.

<h2>Data Connection &#8211; Node JS Examples</h2>

In this model, we will add a new file called Pname.js as consistent with the code to configure the MySQL. 
The new module will contain the methods used over the collections. 
As an example method let’s add a module to fetch documents from the collection. 
First, we define two variables, one to load MySQL xdevapi and one to store the configuration for connections to the server. 
Here is the basic code, which you can expand to <strong>suit your app:</strong>

var mysql_ = require('@mysql/xdevapi'); 
var config_ = {
    host: 'localhost',
    port: '33080',
    userid: 'root',
    password: '', pwd_
    schema: 'mysqlPname',
    collection: 'Pname'
};

Finally, we will add the method to get the export object of this module and then call <strong>getSession method</strong> to create a server connection. 
When the session is running we can get the schema and collection containing the documents. 
We then define one array variable as a container for documents that are returned from the collection. 
Executing the <em>find </em>method without a filter will return <em>all the documents</em>. 
If the execute method returned all documents they will be added to the array variable. 
As such, we have a Node.js server capable of asynchronous access to the MySQL DB, and running in the Express.js context.

<h2>Adding AngularJS Components</h2>

To add components <strong>using the Angular framework</strong> to display the docs from Pname, we will create a folder in the public Javascripts path with the defined name, and this folder will contain the template to add new docs as well. 
Begin by adding the new-comment.module.js component to the folder with the following code:

angular.module('newDoc', ['ngRoute']);
module('newDoc').
component('newDoc', {
templateUrl: '/javascripts/Doc/new-comment.template.html',
controller: ['$routeParams', 'Pname',
function NewDocController($routeParams, Pname) {
this.postIdl_ = $routeParams._Id;
this.addComment = function () {
if (!this.postIdl_ || (!this.comment || this.comment === ")) { return; }
Pname.addComment({ id: this.postId, Doc: this.Doc });
};
this.cancelAddComment = function () {
this.Doc= '', this.postIdl_ = '';
Pname.cancelAddDoc();
};
}
]
});

Here is an excellent view of the powerful capability to enable Angular as a frontend for a Node.js server. 
The demo shows how to build a full-stack JavaScript app using all the <strong>platforms including Node.js examples with MySQL</strong>, via the framework Express, and AngularJS as frontend.

<h3>Best Practices for Fresh Ideas in Node.js</h3>

Node.js 8 version included Async and Await functions for handling asynchronous file loading. 
<strong>This accelerated Node.js potential beyond PHP for many applications.</strong> It is essential to master these ES6 level functions to optimize your coding skills. 
Node.js 8.5 introduced support for ES modules with import() and export(). 
Further, Node.js 8.8 offered HTTP/2 without a flag. 
This supports server push and multiplexing and thus enables efficient loading of native modules in a browser. 
Note that Express support is in progress &#8211; HTTP/2 is experimental in the scope of Node.js with libraries now in development. 
Beyond the borders of Node.js itself, many supporting technologies enhance the developer experience, such as containers and virtualization. 
Docker technology provides containers, which virtualize an OS and render a truly portable and scalable web application. 

<h2>Node.js tutorial</h2>
Node.js is the runtime and <a href="https://www.npmjs.com/" class="external-link" target="_blank">npm</a> is the Package Manager for Node.js modules.
To run a Node.js application, you will need to install the Node.js runtime on your machine.
The Node Package Manager is included in the Node.js distribution. 
You'll need to open a new terminal (command prompt) for the <code>node</code> and <code>npm</code> command-line tools to be on your PATH.
<blockquote>
<strong>Tip:</strong> To test that you've got Node.js correctly installed on your computer, open a new terminal and type <code>node --help</code> and you should see the usage documentation.
</blockquote>
<h3>Hello World</h3>
Let's get started by creating the simplest Node.js application, &quot;Hello World&quot;.
Create an empty folder called &quot;hello&quot;, navigate into and open VS Code:
<code>mkdir hello
cd hello
code .</code>

<blockquote>
<strong>Tip:</strong> You can open files or folders directly from the command line. 
 The period '.' refers to the current folder, therefore VS Code will start and open the <code>Hello</code> folder.
</blockquote>
From the File Explorer toolbar, press the New File button:
and name the file <code>app.js</code>:
Create a simple string variable in <code>app.js</code> and send the contents of the string to the console:
<code>var msg = 'Hello World';
console.log(msg);</code>

save the file.
<h3>Running Hello World</h3>
It's simple to run <code>app.js</code> with Node.js. 
From a terminal, just type:
<code>node app.js</code>

You should see &quot;Hello World&quot; output to the terminal and then Node.js returns.
<h3>Integrated Terminal</h3>
VS Code has an <a href="/docs/editor/integrated-terminal">integrated terminal</a> which you can use to run shell commands. 
You can run Node.js directly from there and avoid switching out of VS Code while running command-line tools.
<strong>View</strong> &gt; <strong>Terminal</strong> (⌃` (Windows, Linux Ctrl+`) with the backtick character) will open the integrated terminal and you can run <code>node app.js</code> there:

<h3>Debugging Hello World</h3>
VS Code ships with a debugger for Node.js applications. 
Let's try debugging our simple Hello World application.
To set a breakpoint in <code>app.js</code>, put the editor cursor on the first line and press F9 or click in the editor left gutter next to the line numbers. 
A red circle will appear in the gutter.
<img class="lazy" data-src="https://code.visualstudio.com/assets/docs/nodejs/nodejs/app-js-breakpoint-set.png" alt="app.js breakpoint set">
To start debugging, select the Run View in the Activity Bar:
<img class="lazy" data-src="https://code.visualstudio.com/assets/docs/nodejs/nodejs/debugicon.png" alt="Run icon">
You can now click Debug toolbar green arrow or press F5 to launch and debug &quot;Hello World&quot;. 
Your breakpoint will be hit and you can view and step through the simple application. 
 Notice that VS Code displays a different colored Status Bar to indicate it is in Debug mode and the DEBUG CONSOLE is displayed.
<img class="lazy" data-src="https://code.visualstudio.com/assets/docs/nodejs/nodejs/hello-world-debugging.png" alt="hello world debugging">
Now that you've seen VS Code in action with &quot;Hello World&quot;, the next section shows using VS Code with a full-stack Node.js web app.
<blockquote>
<strong>Note:</strong> We're done with the &quot;Hello World&quot; example so navigate out of that folder before you create an Express app. 
You can delete the &quot;Hello&quot; folder if you wish as it is not required for the rest of the walkthrough.
</blockquote>
<h2>An Express application</h2>
<a href="https://expressjs.com/" class="external-link" target="_blank">Express</a> is a very popular application framework for building and running Node.js applications. 
You can scaffold (create) a new Express application using the Express Generator tool. 
The Express Generator is shipped as an npm module and installed by using the npm command-line tool <code>npm</code>.
<blockquote>
<strong>Tip:</strong> To test that you've got <code>npm</code> correctly installed on your computer, type <code>npm --help</code> from a terminal and you should see the usage documentation.
</blockquote>
Install the Express Generator by running the following from a terminal:
<code>npm install -g express-generator</code>

The <code>-g</code> switch installs the Express Generator globally on your machine so you can run it from anywhere.
We can now scaffold a new Express application called <code>myExpressApp</code> by running:
<code>express myExpressApp --view pug</code>

This creates a new folder called <code>myExpressApp</code> with the contents of your application. 
The <code>--view pug</code> parameters tell the generator to use the <a href="https://pugjs.org/api/getting-started.html" class="external-link" target="_blank">pug</a> template engine.
To install all of the application's dependencies (again shipped as npm modules), go to the new folder and execute <code>npm install</code>:
<code>cd myExpressApp
npm install</code>

At this point, we should test that our application runs. 
The generated Express application has a <code>package.json</code> file which includes a <code>start</code> script to run <code>node ./bin/www</code>. 
 This will start the Node.js application running.
From a terminal in the Express application folder, run:
<code>npm start</code>

<blockquote>
<strong>Tip:</strong> You can enable an explorer for the npm scripts in your workspace using the <code>npm.enableScriptExplorer</code> setting.
</blockquote>
The Node.js web server will start and you can browse to <a href="http://localhost:3000" class="external-link" target="_blank">http://localhost:3000</a> to see the running application.
<img class="lazy" data-src="https://code.visualstudio.com/assets/docs/nodejs/nodejs/express.png" alt="Your first Node Express App">
<h3>Great code editing</h3>
Close the browser and from a terminal in the <code>myExpressApp</code> folder, stop the Node.js server by pressing CTRL+C.
Now launch VS Code:
<code>code .</code>

<blockquote>
<strong>Note:</strong> If you've been using the VS Code integrated terminal to install the Express generator and scaffold the app, you can open the <code>myExpressApp</code> folder from your running VS Code instance with the <strong>File</strong> &gt; <strong>Open Folder</strong> command.
</blockquote>
The <a href="https://nodejs.org/api/" class="external-link" target="_blank">Node.js</a> and <a href="https://expressjs.com/api.html" class="external-link" target="_blank">Express</a> documentation does a great job explaining how to build rich applications using the platform and framework. 
Visual Studio Code will make you more productive in developing these types of applications by providing great code editing and navigation experiences.
Open the file <code>app.js</code> and hover over the Node.js global object <code>__dirname</code>. 
Notice how VS Code understands that <code>__dirname</code> is a string. 
Even more interesting, you can get full IntelliSense against the Node.js framework. 
For example, you can require <code>http</code> and get full IntelliSense against the <code>http</code> class as you type in Visual Studio Code.
<img class="lazy" data-src="https://code.visualstudio.com/assets/docs/nodejs/nodejs/intellisense.png" alt="http IntelliSense">
VS Code uses TypeScript type declaration (typings) files (for example <code>node.d.ts</code>) to provide metadata to VS Code about the JavaScript based frameworks you are consuming in your application. 
Type declaration files are written in TypeScript so they can express the data types of parameters and functions, allowing VS Code to provide a rich IntelliSense experience. 
Thanks to a feature called <code>Automatic Type Acquisition</code>, you do not have to worry about downloading these type declaration files, VS Code will install them automatically for you.
You can also write code that references modules in other files. 
For example, in <code>app.js</code> we require the <code>./routes/index</code> module, which exports an <code>Express.Router</code> class. 
If you bring up IntelliSense on <code>index</code>, you can see the shape of the <code>Router</code> class.
<img class="lazy" data-src="https://code.visualstudio.com/assets/docs/nodejs/nodejs/moduleintellisense.png" alt="Express.Router IntelliSense">
<h3>Debug your Express app</h3>
You will need to create a debugger configuration file <code>launch.json</code> for your Express application. 
Click on the Run icon in the <strong>Activity Bar</strong> and then the Configure gear icon at the top of the Run view to create a default <code>launch.json</code> file. 
 Select the <strong>Node.js</strong> environment by ensuring that the <code>type</code> property in <code>configurations</code> is set to <code>&quot;node&quot;</code>. 
 When the file is first created, VS Code will look in <code>package.json</code> for a <code>start</code> script and will use that value as the <code>program</code> (which in this case is <code>&quot;${workspaceFolder}\\bin\\www</code>) for the <strong>Launch Program</strong> configuration.
<code>{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "node",
      "request": "launch",
      "name": "Launch Program",
      "program": "${workspaceFolder}\\bin\\www"
    }
  ]
}</code>

Save the new file and make sure <strong>Launch Program</strong> is selected in the configuration drop-down at the top of the Run view. 
Open <code>app.js</code> and set a breakpoint near the top of the file where the Express app object is created by clicking in the gutter to the left of the line number. 
Press F5 to start debugging the application. 
VS Code will start the server in a new terminal and hit the breakpoint we set. 
From there you can inspect variables, create watches, and step through your code.

<img class="lazy" data-src="https://code.visualstudio.com/assets/docs/nodejs/nodejs/debugsession.png" alt="Debug session">
<h3>Deploy your application</h3>
If you'd like to learn how to deploy your web application, check out the <a href="/docs/azure/deployment">Deploying Applications to Azure</a> tutorials where we show how to run your website in Azure.

<h2>simple http proxy</h2>
<a href="https://stackoverflow.com/questions/20351637/how-to-create-a-simple-http-proxy-in-node-js" class="whitebut ">create a simple http proxy in node.js</a>

<h2>websockets to communicate between client and node.js server</h2>

https://medium.com/@joekarlsson/complete-guide-to-node-client-server-communication-b156440c029

This is a demo shows a demo of a client connecting to a websocket server and sharing data.

<span class="brown">Here is the server.js of a websocket.</span>

'use strict';
const WebSocketServer = require('ws').Server
const wss = new WebSocketServer({ port: 8081 });
wss.on('connection', ((ws) =&gt; {
  ws.on('message', (message) =&gt; {
    console.log(`received: ${message}`);
  });
  ws.on('end', () =&gt; {
  console.log('Connection ended...');
});
ws.send('Hello Client');
}));

<span class="brown">Here is the client.js of a websocket.</span>

console.log('open: ');
var ws = new WebSocket("ws://127.0.0.1:8081");
ws.onopen = function (event) {
  console.log('Connection is open ...');
  ws.send("Hello Server");
};
ws.onerror = function (err) {
  console.log('err: ', err);
}
ws.onmessage = function (event) {
  console.log(event.data);
  document.body.innerHTML += event.data + '&lt;br&gt;';
};
ws.onclose = function() {
  console.log("Connection is closed...");
}

https://stackoverflow.com/questions/52407025/client-server-communication-in-node-js

I would use websockets for this.
Once you've set up the connection you can initiate messages from either side.
The WS npm package makes this pretty easy.

<span class="brown">Server example (using the ws npm package):</span>

    const WebSocket = require('ws');

    // Set up server
    const wss = new WebSocket.Server({ port: 8080 });

    // Wire up some logic for the connection event (when a client connects) 
    wss.on('connection', function connection(ws) {

      // Wire up logic for the message event (when a client sends something)
      ws.on('message', function incoming(message) {
        console.log('received: %s', message);
      });

      // Send a message
      ws.send('Hello client!');
    });

<span class="brown">Client example</span> (no need for any package here, it's built into most browsers) :

// Create WebSocket connection.
const socket = new WebSocket('ws://localhost:8080');

// Connection opened
socket.addEventListener('open', function (event) {
    socket.send('Hello Server!');
});

// Listen for messages
socket.addEventListener('message', function (event) {
    console.log('Message from server ', event.data);
});

There are alternatives if you can't use websockets, such as polling (where the client periodically calls the server to see if theres a message), and long-polling (where the server holds a http request open for an artificially long period of time until a message is ready).

<h2>send data to USB device in node.js</h2>
<a href="https://www.npmjs.com/package/usb#interfaceinterface" class="whitebut ">USB Library for Node.JS</a>

Installation
Libusb is included as a submodule. 

npm install usb

Windows
Use Zadig to install the WinUSB driver for your USB device. 
Otherwise you will get LIBUSB_ERROR_NOT_SUPPORTED when attempting to open devices.

var usb = require('usb')
usb
Top-level object.

usb.getDeviceList()
Return a list of Device objects for the USB devices attached to the system.

usb.findByIds(vid, pid)
Convenience method to get the first device with the specified VID and PID, or undefined if no such device is present.

usb.LIBUSB_*
Constant properties from libusb

usb.setDebugLevel(level : int)
Set the libusb debug level (between 0 and 4)

Device
Represents a USB device.

.busNumber
Integer USB device number

.deviceAddress
Integer USB device address

.portNumbers
Array containing the USB device port numbers, or undefined if not supported on this platform.

<h2>Scrape a site with Node and Cheerio in 5 minutes</h2>
https://www.twilio.com/blog/web-scraping-and-parsing-html-with-node-js-and-cheerio

Website scraping is a common problem with a common toolset. 
Two approaches dominate the web today:

Automate a browser to navigate a site programmatically, using tools like <a href="https://github.com/GoogleChrome/puppeteer" rel="noopener nofollow">Puppeteer</a> or <a href="https://www.seleniumhq.org/" rel="noopener nofollow">Selenium</a>.

Make an HTTP request to a website, retrieving data on the page using tools like <a href="https://github.com/cheeriojs/cheerio" rel="noopener nofollow">Cheerio</a> or <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/" rel="noopener nofollow">BeautifulSoup</a>.

The first approach — driving a real browser programmatically — is typical for projects where you’re running automated website tests, or capturing screenshots of your site.

The second approach has limitations. 
For example, Cheerio “<a href="https://github.com/cheeriojs/cheerio#cheerio-is-not-a-web-browser" rel="noopener nofollow">is not a browser</a>” and “does <em>not</em> produce a visual rendering, apply CSS, load external resources, or execute JavaScript”. 
<strong>But this approach is simple, and often sufficient, especially when you’re learning how scraping works.</strong>
<h3>Using Got to retrieve data to use with Cheerio</h3>
First let's write some code to grab the HTML from the web page, and look at how we can start parsing through it. 
The following code will send a <code>GET</code> request to the web page we want, and will create a Cheerio object with the HTML from that page. 
We'll name it <code>$</code> following the infamous jQuery convention:

<code>const fs = require('fs');
const cheerio = require('cheerio');
const got = require('got');

const vgmUrl= 'https://www.vgmusic.com/music/console/nintendo/nes';

got(vgmUrl).then(response => {
  const $ = cheerio.load(response.body);
  console.log($('title')[0].text());
  console.log($('h1').text());  // print the text

}).catch(err => {
  console.log(err);
});
</code>

With this <code>$</code> object, you can navigate through the HTML and retrieve <a href="https://api.jquery.com/Types/#Element">DOM elements</a> for the data you want, <a href="https://api.jquery.com/jQuery/">in the same way that you can with jQuery</a>. 
For example, <code>$('title')</code> will get you an array of objects corresponding to every <code>&lt;title></code> tag on the page. 
There's typically only one <code>title</code> element, so this will be an array with one object. 
If you run this code with the command <code>node index.js</code>, it will log the structure of this object to the console.

<h3>Getting familiar with Cheerio</h3>
When you have an object corresponding to an element in the HTML you're parsing through, you can do things like navigate through its children, parent and sibling elements. 
The child of this <code>&lt;title></code> element is the text within the tags. 
So <code>console.log($('title')[0].children[0].data);</code> will log the title of the web page.

If you want to get more specific in your query, <a href="https://api.jquery.com/category/selectors/">there are a variety of selectors</a> you can use to parse through the HTML. 
Two of the most common ones are to search for elements by <a href="https://api.jquery.com/class-selector/">class</a> or <a href="https://api.jquery.com/id-selector/">ID</a>. 
If you wanted to get a div with the ID of &quot;menu&quot; you would run <code>$('#menu')</code> and if you wanted all of the columns in the table of VGM MIDIs with the &quot;header&quot; class, you'd do <code>$('td.header')</code>

What we want on this page are the hyperlinks to all of the MIDI files we need to download. 
We can start by getting every link on the page using <code>$('a')</code>. 
Add the following to your code in <code>index.js</code>:

<code>got(vgmUrl).then(response => {
  const $ = cheerio.load(response.body);

  $('a').each((i, link) => {
    const href = link.attribs.href;
    console.log(href);
  });
}).catch(err => {
  console.log(err);
});
</code>

This code logs the URL of every link on the page. 
Notice that we're able to look through all elements from a given selector using the <code>.each()</code> function. 
Iterating through every link on the page is great, but we're going to need to get a little more specific than that if we want to download all of the MIDI files.

<h3>Filtering through HTML elements with Cheerio</h3>
Before writing more code to parse the content that we want, let’s first take a look at the HTML that’s rendered by the browser. 
Every web page is different, and sometimes getting the right data out of them requires a bit of creativity, pattern recognition, and experimentation.

<img src="https://twilio-cms-prod.s3.amazonaws.com/images/RqLbgi-q_vRQy0ai0TmWqdjoJjaN9k-OpSrNj2drs46QnP.width-500.png">

Our goal is to download a bunch of MIDI files, but there are a lot of duplicate tracks on this webpage, as well as remixes of songs. 
We only want one of each song, and because our ultimate goal is to use this data to train a neural network to generate accurate Nintendo music, we won't want to train it on user-created remixes.

When you're writing code to parse through a web page, it's usually helpful to use the developer tools available to you in most modern browsers. 
If you right-click on the element you're interested in, you can inspect the HTML behind that element to get more insight.

<img src="https://twilio-cms-prod.s3.amazonaws.com/images/eTCvZko6rcZKTGL3cwARnulCWGmKGP4Rpi1dK-XQbmmAgl.width-500.png">

With Cheerio, you can write filter functions to fine-tune which data you want from your selectors. 
These functions loop through all elements for a given selector and return true or false based on whether they should be included in the set or not.

If you looked through the data that was logged in the previous step, you might have noticed that there are quite a few links on the page that have no <code>href</code> attribute, and therefore lead nowhere. 
We can be sure those are not the MIDIs we are looking for, so let's write a short function to filter those out as well as making sure that elements which do contain a <code>href</code> element lead to a <code>.mid</code> file:

    <code>const isMidi = (i, link) => {
  // Return false if there is no href attribute.
  if(typeof link.attribs.href === 'undefined') { return false }

  return link.attribs.href.includes('.mid');
};
</code>

Now we have the problem of not wanting to download duplicates or user generated remixes. 
For this we can use regular expressions to make sure we are only getting links whose text has no parentheses, as only the duplicates and remixes contain parentheses:

    <code>const noParens = (i, link) => {
  // Regular expression to determine if the text has parentheses.
  const parensRegex = /^((?!\().)*$/;
  return parensRegex.test(link.children[0].data);
};
</code>

Try adding these to your code in <code>index.js</code>:

    <code>got(vgmUrl).then(response => {
  const $ = cheerio.load(response.body);

  $('a').filter(isMidi).filter(noParens).each((i, link) => {
    const href = link.attribs.href;
    console.log(href);
  });
});
</code>

Run this code again and it should only be printing <code>.mid</code> files.

<h3>Downloading the MIDI files we want from the webpage</h3>
Now that we have working code to iterate through every MIDI file that we want, we have to write code to download all of them.

In the callback function for looping through all of the MIDI links, add this code to stream the MIDI download into a local file, complete with error checking:

    <code>  $('a').filter(isMidi).filter(noParens).each((i, link) => {
    const fileName = link.attribs.href;

    got.stream(`${vgmUrl}/${fileName}`)
      .on('error', err => { console.log(err); console.log(`Error on ${vgmUrl}/${fileName}`) })
      .pipe(fs.createWriteStream(`MIDIs/${fileName}`))
      .on('error', err => { console.log(err); console.log(`Error on ${vgmUrl}/${fileName}`) })
      .on('finish', () => console.log(`Finished ${fileName}`));
  });
</code>

Run this code from a directory where you want to save all of the MIDI files, and watch your terminal screen display all 2230 MIDI files that you downloaded (at the time of writing this). 
With that, we should be finished scraping all of the MIDI files we need.
<h3>Worked Sample</h3>
const fs = require('fs');
const cheerio = require('cheerio');
const got = require('got');

const theAddr= "https://williamkpchan.github.io/LibDocs/GoNotes.html"

got(theAddr).then(response => {
  const $ = cheerio.load(response.body);

  $('h2').each(function(i) {
     console.log($(this).text())  // extract text content
     console.log(String($(this))) // cvt object to string

  });
}).catch(err => {
  console.log(err);
});

<h3>sample</h3>
const cheerio = require('cheerio');
const $ = cheerio.load('&lt;h2 class="title">Hello world&lt;/h2>');

$('h2.title').text('Hello there!');
$('h2').addClass('welcome');

$.html();
//=> &lt;html>&lt;head>&lt;/head>&lt;body>&lt;h2 class="title welcome">Hello there!&lt;/h2>&lt;/body>&lt;/html>

<h2>Copy to clipboard</h2>
const clipboardy = require('clipboardy');

// Copy
clipboardy.writeSync('🦄');

// Paste
clipboardy.readSync();
//🦄

<h2>Debugging</h2>
<a href="https://nodejs.org/en/docs/guides/debugging-getting-started/" class="whitebut ">Nodejs Debugging Guide</a>

<h2>await is only valid in async function</h2>
await can only be called in a function marked as async. 

(async function(){
    var body = await httpGet('link');
    $.response.setBody(body);
})()

Basically when you use one asynchronous operation, you need to make the entire flow asynchronous as well.
So the async keyword kindof uses ES6 generator function 
and makes it return a promise.

<h2>Promises</h2>
Promises simplify deferred and asynchronous computations. A promise represents an operation that hasn't completed yet.

<h2>chalk colors</h2>
<a href="https://github.com/chalk/chalk" class="whitebut ">chalk colors</a>
Example: chalk.red.bold.underline('Hello', 'world');

Colors: black, red, green, yellow, blue, magenta, cyan, white, blackBright (alias: gray, grey), redBright, greenBright, yellowBright, blueBright, magentaBright, cyanBright, whiteBright

Background colors: bgBlack, bgRed, bgGreen, bgYellow, bgBlue, bgMagenta, bgCyan, bgWhite, bgBlackBright (alias: bgGray, bgGrey), bgRedBright, bgGreenBright, bgYellowBright, bgBlueBright, bgMagentaBright, bgCyanBright, bgWhiteBright

Modifiers:
reset - Resets the current color chain.
bold - Make text bold.
dim - Emitting only a small amount of light.
italic - Make text italic. (Not widely supported)
underline - Make text underline. (Not widely supported)
inverse- Inverse background and foreground colors.
hidden - Prints the text, but makes it invisible.
strikethrough - Puts a horizontal line through the center of the text. (Not widely supported)
visible- Prints the text only when Chalk has a color level > 0. Can be useful for things that are purely cosmetic.










<br><br>
<script type='text/javascript' src='readbook.js'></script>
<script>
var lazyLoadInstance = new LazyLoad({ elements_selector: ".lazy" });
</script>
</body>
</html>
