// List of JavaScript tips
var tipsList = ['<code>abs</code>(<em>x</em>)<br><br><p>Return the absolute value of a number.  The argument may be an integer or a floating point number.  If the argument is a complex number, its magnitude is returned.</p>', 
'<code>all</code>(<em>iterable</em>)<br><br><p>Return <code class="docutils literal"><span class="pre">True</span></code> if all elements of the <em>iterable</em> are true (or if the iterable is empty).  ', 
'<code>any</code>(<em>iterable</em>)<br><br><p>Return <code class="docutils literal"><span class="pre">True</span></code> if any element of the <em>iterable</em> is true.  If the iterable is empty, return <code class="docutils literal"><span class="pre">False</span></code>.', 
'<code>ascii</code>(<em>object</em>)<br><br><p>As <a href="#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a>, return a string containing a printable representation of an object, but escape the non-ASCII characters in the string returned by <a href="#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a> using <code class="docutils literal"><span class="pre">\\x</span></code>, <code class="docutils literal"><span class="pre">\\u</span></code> or <code class="docutils literal"><span class="pre">\\U</span></code> escapes.  This generates a string similar to that returned by <a href="#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a> in Python 2.</p>', 
'<code>bin</code>(<em>x</em>)<br><br><blockquote><div><p>Convert an integer number to a binary string prefixed with “0b”. The result is a valid Python expression. If <em>x</em> is not a Python <a href="#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a> object, it has to define an <a href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal"><span class="pre">__index__()</span></code></a> method that returns an integer.', 
'<code>bool</code>(<span class="optional">[</span><em>x</em><span class="optional">]</span>)<br><br><p>Return a Boolean value, i.e. one of <code class="docutils literal"><span class="pre">True</span></code> or <code class="docutils literal"><span class="pre">False</span></code>.  <em>x</em> is converted using the standard <a href="stdtypes.html#truth"><span class="std std-ref">truth testing procedure</span></a>.  If <em>x</em> is false or omitted, this returns <code class="docutils literal"><span class="pre">False</span></code>; otherwise it returns <code class="docutils literal"><span class="pre">True</span></code>.  The <a href="#bool" title="bool"><code class="xref py py-class docutils literal"><span class="pre">bool</span></code></a> class is a subclass of <a href="#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a> (see <a href="stdtypes.html#typesnumeric"><span class="std std-ref">Numeric Types — int, float, complex</span></a>). It cannot be subclassed further.  Its only instances are <code class="docutils literal"><span class="pre">False</span></code> and <code class="docutils literal"><span class="pre">True</span></code> (see <a href="stdtypes.html#bltin-boolean-values"><span class="std std-ref">Boolean Values</span></a>).</p>', 
'<code>bytearray</code>(<span class="optional">[</span><em>source</em><span class="optional">[</span>, <em>encoding</em><span class="optional">[</span>, <em>errors</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span>)<br><br><p>Return a new array of bytes.  The <a href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> class is a mutable sequence of integers in the range 0 &lt;= x &lt; 256.  It has most of the usual methods of mutable sequences, described in <a href="stdtypes.html#typesseq-mutable"><span class="std std-ref">Mutable Sequence Types</span></a>, as well as most methods that the <a href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> type has, see <a href="stdtypes.html#bytes-methods"><span class="std std-ref">Bytes and Bytearray Operations</span></a>.</p>', 
'<code>bytes</code>(<span class="optional">[</span><em>source</em><span class="optional">[</span>, <em>encoding</em><span class="optional">[</span>, <em>errors</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span>)<br><br><p>Return a new “bytes” object, which is an immutable sequence of integers in the range <code class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">256</span></code>.  <a href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> is an immutable version of <a href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> – it has the same non-mutating methods and the same indexing and slicing behavior.</p>', 
'<code>callable</code>(<em>object</em>)<br><br><p>Return <a href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a> if the <em>object</em> argument appears callable, <a href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> if not.  If this returns true, it is still possible that a call fails, but if it is false, calling <em>object</em> will never succeed.', 
'<code>chr</code>(<em>i</em>)<br><br><p>Return the string representing a character whose Unicode code point is the integer <em>i</em>.  For example, <code class="docutils literal"><span class="pre">chr(97)</span></code> returns the string <code class="docutils literal"><span class="pre">"a"</span></code>, while <code class="docutils literal"><span class="pre">chr(8364)</span></code> returns the string <code class="docutils literal"><span class="pre">"€"</span></code>. This is the inverse of <a href="#ord" title="ord"><code class="xref py py-func docutils literal"><span class="pre">ord()</span></code></a>.</p>', 
'<code>classmethod</code><br><br><p>Transform a method into a class method.</p> <p>A class method receives the class as implicit first argument, just like an instance method receives the instance.', 
'<code>compile</code>(<em>source</em>, <em>filename</em>, <em>mode</em>, <em>flags=0</em>, <em>dont_inherit=False</em>, <em>optimize=-1</em>)<br><br><p>Compile the <em>source</em> into a code or AST object.  Code objects can be executed by <a href="#exec" title="exec"><code class="xref py py-func docutils literal"><span class="pre">exec()</span></code></a> or <a href="#eval" title="eval"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a>.  <em>source</em> can either be a normal string, a byte string, or an AST object.  Refer to the <a href="ast.html#module-ast" title="ast: Abstract Syntax Tree classes and manipulation."><code class="xref py py-mod docutils literal"><span class="pre">ast</span></code></a> module documentation for information on how to work with AST objects.</p>', 
'<code>complex</code>(<span class="optional">[</span><em>real</em><span class="optional">[</span>, <em>imag</em><span class="optional">]</span><span class="optional">]</span>)<br><br><p>Return a complex number with the value <em>real</em> + <em>imag</em>*1j or convert a string or number to a complex number.  If the first parameter is a string, it will be interpreted as a complex number and the function must be called without a second parameter.  The second parameter can never be a string. Each argument may be any numeric type (including complex).  If <em>imag</em> is omitted, it defaults to zero and the constructor serves as a numeric conversion like <a href="#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a> and <a href="#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>.  If both arguments are omitted, returns <code class="docutils literal"><span class="pre">0j</span></code>.</p>', 
'<code>delattr</code>(<em>object</em>, <em>name</em>)<br><br><p>This is a relative of <a href="#setattr" title="setattr"><code class="xref py py-func docutils literal"><span class="pre">setattr()</span></code></a>.  The arguments are an object and a string.  The string must be the name of one of the object’s attributes.  The function deletes the named attribute, provided the object allows it.  For example, <code class="docutils literal"><span class="pre">delattr(x,</span> <span class="pre">"foobar")</span></code> is equivalent to <code class="docutils literal"><span class="pre">del</span> <span class="pre">x.foobar</span></code>.</p>', 
'<code>dict</code>(<em>iterable</em>, <em>**kwarg</em>)<br><br><p>Create a new dictionary.  The <a href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> object is the dictionary class.', 
'<code>dir</code>(<span class="optional">[</span><em>object</em><span class="optional">]</span>)<br><br><p>Without arguments, return the list of names in the current local scope.  With an argument, attempt to return a list of valid attributes for that object.</p>', 
'<code>divmod</code>(<em>a</em>, <em>b</em>)<br><br><p>Take two (non complex) numbers as arguments and return a pair of numbers consisting of their quotient and remainder when using integer division.  With mixed operand types, the rules for binary arithmetic operators apply.  For integers, the result is the same as <code class="docutils literal"><span class="pre">(a</span> <span class="pre">//</span> <span class="pre">b,</span> <span class="pre">a</span> <span class="pre">%</span> <span class="pre">b)</span></code>. For floating point numbers the result is <code class="docutils literal"><span class="pre">(q,</span> <span class="pre">a</span> <span class="pre">%</span> <span class="pre">b)</span></code>, where <em>q</em> is usually <code class="docutils literal"><span class="pre">math.floor(a</span> <span class="pre">/</span>', 
'<code>enumerate</code>(<em>iterable</em>, <em>start=0</em>)<br><br><p>Return an enumerate object. <em>iterable</em> must be a sequence, an <a href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a>, or some other object which supports iteration.', 
'<code>eval</code>(<em>expression</em>, <em>globals=None</em>, <em>locals=None</em>)<br><br><p>The arguments are a string and optional globals and locals.  If provided, <em>globals</em> must be a dictionary.  If provided, <em>locals</em> can be any mapping object.</p>', 
'<code>exec</code>(<em>object</em><span class="optional">[</span>, <em>globals</em><span class="optional">[</span>, <em>locals</em><span class="optional">]</span><span class="optional">]</span>)<br><br><p>This function supports dynamic execution of Python code. <em>object</em> must be either a string or a code object.  If it is a string, the string is parsed as a suite of Python statements which is then executed (unless a syntax error occurs). <a class="footnote-reference" href="#id2" id="id1">[1]</a> If it is a code object, it is simply executed.  In all cases, the code that’s executed is expected to be valid as file input (see the section “File input” in the Reference Manual). Be aware that the <a href="../reference/simple_stmts.html#return"><code class="xref std std-keyword docutils literal"><span class="pre">return</span></code></a> and <a href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> statements may not be used outside of function definitions even within the context of code passed to the <a href="#exec" title="exec"><code class="xref py py-func docutils literal"><span class="pre">exec()</span></code></a> function. The return value is <code class="docutils literal"><span class="pre">None</span></code>.</p>', 
'<code>filter</code>(<em>function</em>, <em>iterable</em>)<br><br><p>Construct an iterator from those elements of <em>iterable</em> for which <em>function</em> returns true.  <em>iterable</em> may be either a sequence, a container which supports iteration, or an iterator.  If <em>function</em> is <code class="docutils literal"><span class="pre">None</span></code>, the identity function is assumed, that is, all elements of <em>iterable</em> that are false are removed.</p>', 
'<code>float</code>(<span class="optional">[</span><em>x</em><span class="optional">]</span>)<br><br><p id="index-3">Return a floating point number constructed from a number or string <em>x</em>.</p>', 
'<code>format</code>(<em>value</em><span class="optional">[</span>, <em>format_spec</em><span class="optional">]</span>)<br><br><p>Convert a <em>value</em> to a “formatted” representation, as controlled by <em>format_spec</em>.  The interpretation of <em>format_spec</em> will depend on the type of the <em>value</em> argument, however there is a standard formatting syntax that is used by most built-in types: <a href="string.html#formatspec"><span class="std std-ref">Format Specification Mini-Language</span></a>.</p>', 
'<code>frozenset</code>(<span class="optional">[</span><em>iterable</em><span class="optional">]</span>)<br><br><p>Return a new <a href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> object, optionally with elements taken from <em>iterable</em>.  <code class="docutils literal"><span class="pre">frozenset</span></code> is a built-in class.  See <a href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> and <a href="stdtypes.html#types-set"><span class="std std-ref">Set Types — set, frozenset</span></a> for documentation about this class.</p>', 
'<code>getattr</code>(<em>object</em>, <em>name</em><span class="optional">[</span>, <em>default</em><span class="optional">]</span>)<br><br><p>Return the value of the named attribute of <em>object</em>.  <em>name</em> must be a string. If the string is the name of one of the object’s attributes, the result is the value of that attribute.  For example, <code class="docutils literal"><span class="pre">getattr(x,</span> <span class="pre">"foobar")</span></code> is equivalent to <code class="docutils literal"><span class="pre">x.foobar</span></code>.  If the named attribute does not exist, <em>default</em> is returned if provided, otherwise <a href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a> is raised.</p>', 
'<code>globals</code>()<br><br><p>Return a dictionary representing the current global symbol table. This is always the dictionary of the current module (inside a function or method, this is the module where it is defined, not the module from which it is called).</p>', 
'<code>hasattr</code>(<em>object</em>, <em>name</em>)<br><br><p>The arguments are an object and a string.  The result is <code class="docutils literal"><span class="pre">True</span></code> if the string is the name of one of the object’s attributes, <code class="docutils literal"><span class="pre">False</span></code> if not. (This is implemented by calling <code class="docutils literal"><span class="pre">getattr(object,</span> <span class="pre">name)</span></code> and seeing whether it raises an <a href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a> or not.)</p>', 
'<code>hash</code>(<em>object</em>)<br><br><blockquote> <div>Return the hash value of the object (if it has one).  Hash values are integers.  They are used to quickly compare dictionary keys during a dictionary lookup.  Numeric values that compare equal have the same hash value (even if they are of different types, as is the case for 1 and 1.0).</div></blockquote>', 
'<code>help</code>(<span class="optional">[</span><em>object</em><span class="optional">]</span>)<br><br><p>Invoke the built-in help system.  (This function is intended for interactive use.)  If no argument is given, the interactive help system starts on the interpreter console.  If the argument is a string, then the string is looked up as the name of a module, function, class, method, keyword, or documentation topic, and a help page is printed on the console.  If the argument is any other kind of object, a help page on the object is generated.</p>', 
'<code>hex</code>(<em>x</em>)<br><br><p>Convert an integer number to a lowercase hexadecimal string prefixed with “0x”. If x is not a Python <a href="#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a> object, it has to define an __index__() method that returns an integer. ', 
'<code>id</code>(<em>object</em>)<br><br><p>Return the “identity” of an object.  This is an integer which is guaranteed to be unique and constant for this object during its lifetime.', 
'<code>input</code>(<span class="optional">[</span><em>prompt</em><span class="optional">]</span>)<br><br><p>If the <em>prompt</em> argument is present, it is written to standard output without a trailing newline.  The function then reads a line from input, converts it to a string (stripping a trailing newline), and returns that.  When EOF is read, <a href="exceptions.html#EOFError" title="EOFError"><code class="xref py py-exc docutils literal"><span class="pre">EOFError</span></code></a> is raised. ', 
'<code>int</code>(<em>x</em>, <em>base=10</em>)<br><br><p>Return an integer object constructed from a number or string <em>x</em>, or return', 
'<code>isinstance</code>(<em>object</em>, <em>classinfo</em>)<br><br><p>Return true if the <em>object</em> argument is an instance of the <em>classinfo</em> argument, or of a (direct, indirect or <a href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">virtual</span></a>) subclass thereof.  If <em>object</em> is not an object of the given type, the function always returns false.', 
'<code>issubclass</code>(<em>class</em>, <em>classinfo</em>)<br><br><p>Return true if <em>class</em> is a subclass (direct, indirect or <a href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">virtual</span></a>) of <em>classinfo</em>.  A class is considered a subclass of itself. <em>classinfo</em> may be a tuple of class objects, in which case every entry in <em>classinfo</em> will be checked. In any other case, a <a href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> exception is raised.</p>', 
'<code>iter</code>(<em>object</em><span class="optional">[</span>, <em>sentinel</em><span class="optional">]</span>)<br><br><p>Return an <a href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a> object.  The first argument is interpreted very differently depending on the presence of the second argument. Without a second argument, <em>object</em> must be a collection object which supports the iteration protocol (the <a href="../reference/datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></code></a> method), or it must support the sequence protocol (the <a href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> method with integer arguments starting at <code class="docutils literal"><span class="pre">0</span></code>).  If it does not support either of those protocols, <a href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> is raised. If the second argument, <em>sentinel</em>, is given, then <em>object</em> must be a callable object.  The iterator created in this case will call <em>object</em> with no arguments for each call to its <a href="stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal"><span class="pre">__next__()</span></code></a> method; if the value returned is equal to <em>sentinel</em>, <a href="exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> will be raised, otherwise the value will be returned.</p>', 
'<code>len</code>(<em>s</em>)<br><br><p>Return the length (the number of items) of an object.  The argument may be a sequence (such as a string, bytes, tuple, list, or range) or a collection (such as a dictionary, set, or frozen set).</p>', 
'<code>list</code>(<span class="optional">[</span><em>iterable</em><span class="optional">]</span>)<br><br><p>Rather than being a function, <a href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a> is actually a mutable sequence type, as documented in <a href="stdtypes.html#typesseq-list"><span class="std std-ref">Lists</span></a> and <a href="stdtypes.html#typesseq"><span class="std std-ref">Sequence Types — list, tuple, range</span></a>.</p>', 
'<code>locals</code>()<br><br><p>Update and return a dictionary representing the current local symbol table. Free variables are returned by <a href="#locals" title="locals"><code class="xref py py-func docutils literal"><span class="pre">locals()</span></code></a> when it is called in function blocks, but not in class blocks.</p>', 
'<code>map</code>(<em>function</em>, <em>iterable</em>, <em>...</em>)<br><br><p>Return an iterator that applies <em>function</em> to every item of <em>iterable</em>, yielding the results.  If additional <em>iterable</em> arguments are passed, <em>function</em> must take that many arguments and is applied to the items from all iterables in parallel.  With multiple iterables, the iterator stops when the shortest iterable is exhausted.  For cases where the function inputs are already arranged into argument tuples, see <a href="itertools.html#itertools.starmap" title="itertools.starmap"><code class="xref py py-func docutils literal"><span class="pre">itertools.starmap()</span></code></a>.</p>', 
'<code>max</code>(<em>iterable</em>, <em>*</em><span class="optional">[</span>, <em>key</em>, <em>default</em><span class="optional">]</span>)</dt>', 
'<code>max</code>(<em>arg1</em>, <em>arg2</em>, <em>*args</em><span class="optional">[</span>, <em>key</em><span class="optional">]</span>)<br><br><p>Return the largest item in an iterable or the largest of two or more arguments.</p>', 
'<code>memoryview</code>(<em>obj</em>)<br><br><p>Return a “memory view” object created from the given argument.  ', 
'<code>min</code>(<em>iterable</em>, <em>*</em><span class="optional">[</span>, <em>key</em>, <em>default</em><span class="optional">]</span>)</dt>', 
'<code>min</code>(<em>arg1</em>, <em>arg2</em>, <em>*args</em><span class="optional">[</span>, <em>key</em><span class="optional">]</span>)<br><br><p>Return the smallest item in an iterable or the smallest of two or more The smallest item in the iterable is returned.  If two or more positional arguments are provided, the smallest of the positional arguments is <p>If multiple items are minimal, the function returns the first one such as <code class="docutils literal"><span class="pre">sorted(iterable,</span> <span class="pre">key=keyfunc)[0]</span></code> and <code class="docutils literal"><span class="pre">heapq.nsmallest(1,</span> <span class="pre">iterable,</span> <span class="pre">key=keyfunc)</span></code>.</p>', 
'<code>next</code>(<em>iterator</em><span class="optional">[</span>, <em>default</em><span class="optional">]</span>)<br><br><p>Retrieve the next item from the <em>iterator</em> by calling its <a href="stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal"><span class="pre">__next__()</span></code></a> method.  If <em>default</em> is given, it is returned if the iterator is exhausted, otherwise <a href="exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> is raised.</p>', 
'<code>object</code><br><br><p>Return a new featureless object.  <a href="#object" title="object"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a> is a base for all classes. It has the methods that are common to all instances of Python classes.  This function does not accept any arguments.</p>', 
'<code>oct</code>(<em>x</em>)<br><br><p>Convert an integer number to an octal string prefixed with “0o”.  The result is a valid Python expression. If <em>x</em> is not a Python <a href="#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a> object, it has to define an <a href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal"><span class="pre">__index__()</span></code></a> method that returns an integer.', 
'<code>open</code>(<em>file</em>, <em>mode="r"</em>, <em>buffering=-1</em>, <em>encoding=None</em>, <em>errors=None</em>, <em>newline=None</em>, <em>closefd=True</em>, <em>opener=None</em>)<br><br><p>Open <em>file</em> and return a corresponding <a href="../glossary.html#term-file-object"><span class="xref std std-term">file object</span></a>.  If the file cannot be opened, an <a href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a> is raised.</p>', 
'<code>ord</code>(<em>c</em>)<br><br><p>Given a string representing one Unicode character, return an integer representing the Unicode code point of that character. ', 
'<code>pow</code>(<em>x</em>, <em>y</em><span class="optional">[</span>, <em>z</em><span class="optional">]</span>)<br><br><p>Return <em>x</em> to the power <em>y</em>; if <em>z</em> is present, return <em>x</em> to the power <em>y</em>, modulo <em>z</em> (computed more efficiently than <code class="docutils literal"><span class="pre">pow(x,</span> <span class="pre">y)</span> <span class="pre">%</span> <span class="pre">z</span></code>). The two-argument form <code class="docutils literal"><span class="pre">pow(x,</span> <span class="pre">y)</span></code> is equivalent to using the power operator: <code class="docutils literal"><span class="pre">x**y</span></code>.</p>', 
'<code>print</code>(<em>*objects</em>, <em>sep=" "</em>, <em>end="\\n"</em>, <em>file=sys.stdout</em>, <em>flush=False</em>)<br><br><p>Print <em>objects</em> to the text stream <em>file</em>, separated by <em>sep</em> and followed by <em>end</em>.  <em>sep</em>, <em>end</em>, <em>file</em> and <em>flush</em>, if present, must be given as keyword <p>All non-keyword arguments are converted to strings like <a href="stdtypes.html#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a> does and written to the stream, separated by <em>sep</em> and followed by <em>end</em>.  Both <em>sep</em> and <em>end</em> must be strings; they can also be <code class="docutils literal"><span class="pre">None</span></code>, which means to use the default values.  If no <em>objects</em> are given, <a href="#print" title="print"><code class="xref py py-func docutils literal"><span class="pre">print()</span></code></a> will just write <em>end</em>.</p>', 
'<code>property</code>(<em>fget=None</em>, <em>fset=None</em>, <em>fdel=None</em>, <em>doc=None</em>)<br><br><p>Return a property attribute.</p>', 
'<code>range</code>(<em>start</em>, <em>stop</em><span class="optional">[</span>, <em>step</em><span class="optional">]</span>)<br><br><p>Rather than being a function, <a href="stdtypes.html#range" title="range"><code class="xref py py-class docutils literal"><span class="pre">range</span></code></a> is actually an immutable sequence type, as documented in <a href="stdtypes.html#typesseq-range"><span class="std std-ref">Ranges</span></a> and <a href="stdtypes.html#typesseq"><span class="std std-ref">Sequence Types — list, tuple, range</span></a>.</p>', 
'<code>repr</code>(<em>object</em>)<br><br><p>Return a string containing a printable representation of an object.  For many types, this function makes an attempt to return a string that would yield an object with the same value when passed to <a href="#eval" title="eval"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a>, otherwise the representation is a string enclosed in angle brackets that contains the name of the type of the object together with additional information often including the name and address of the object.  A class can control what this function returns for its instances by defining a <a href="../reference/datamodel.html#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal"><span class="pre">__repr__()</span></code></a> method.</p>', 
'<code>reversed</code>(<em>seq</em>)<br><br><p>Return a reverse <a href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a>.  <em>seq</em> must be an object which has a <a href="../reference/datamodel.html#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal"><span class="pre">__reversed__()</span></code></a> method or supports the sequence protocol (the <a href="../reference/datamodel.html#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal"><span class="pre">__len__()</span></code></a> method and the <a href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> method with integer arguments starting at <code class="docutils literal"><span class="pre">0</span></code>).</p>', 
'<code>round</code>(<em>number</em><span class="optional">[</span>, <em>ndigits</em><span class="optional">]</span>)<br><br><p>Return <em>number</em> rounded to <em>ndigits</em> precision after the decimal point.  If <em>ndigits</em> is omitted or is <code class="docutils literal"><span class="pre">None</span></code>, it returns the nearest integer to its input.</p>', 
'<code>set</code>(<span class="optional">[</span><em>iterable</em><span class="optional">]</span>)<br><br><p>Return a new <a href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> object, optionally with elements taken from <em>iterable</em>.  <code class="docutils literal"><span class="pre">set</span></code> is a built-in class.  See <a href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> and <p>For other containers see the built-in <a href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a>, <a href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a>, <dt id="setattr"> <code>setattr</code>(<em>object</em>, <em>name</em>, <em>value</em>)<br><br><p>This is the counterpart of <a href="#getattr" title="getattr"><code class="xref py py-func docutils literal"><span class="pre">getattr()</span></code></a>.  The arguments are an object, a string and an arbitrary value.  The string may name an existing attribute or a new attribute.  The function assigns the value to the attribute, provided the object allows it.  For example, <code class="docutils literal"><span class="pre">setattr(x,</span> <span class="pre">"foobar",</span> <span class="pre">123)</span></code> is equivalent to <code class="docutils literal"><span class="pre">x.foobar</span> <span class="pre">=</span> <span class="pre">123</span></code>.</p>', 
'<code>slice</code>(<em>start</em>, <em>stop</em><span class="optional">[</span>, <em>step</em><span class="optional">]</span>)<br><br><p id="index-9">Return a <a href="../glossary.html#term-slice"><span class="xref std std-term">slice</span></a> object representing the set of indices specified by', 
'<code>sorted</code>(<em>iterable</em>, <em>*</em>, <em>key=None</em>, <em>reverse=False</em>)<br><br><p>Return a new sorted list from the items in <em>iterable</em>.</p>', 
'<code>staticmethod</code><br><br><p>Transform a method into a static method.</p>', 
'<code>str</code>(<em>object=b""</em>, <em>encoding="utf-8"</em>, <em>errors="strict"</em>)<br><br><p>Return a <a href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> version of <em>object</em>.  See <a href="stdtypes.html#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a>', 
'<code>sum</code>(<em>iterable</em><span class="optional">[</span>, <em>start</em><span class="optional">]</span>)<br><br><p>Sums <em>start</em> and the items of an <em>iterable</em> from left to right and returns the total.  <em>start</em> defaults to <code class="docutils literal"><span class="pre">0</span></code>. The <em>iterable</em>’s items are normally numbers, and the start value is not allowed to be a string.</p>', 
'<code>super</code>(<span class="optional">[</span><em>type</em><span class="optional">[</span>, <em>object-or-type</em><span class="optional">]</span><span class="optional">]</span>)<br><br><p>Return a proxy object that delegates method calls to a parent or sibling class of <em>type</em>.  This is useful for accessing inherited methods that have been overridden in a class. The search order is same as that used by <a href="#getattr" title="getattr"><code class="xref py py-func docutils literal"><span class="pre">getattr()</span></code></a> except that the <em>type</em> itself is skipped.</p>', 
'<code>tuple</code>(<span class="optional">[</span><em>iterable</em><span class="optional">]</span>)<br><br><p>Rather than being a function, <a href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a> is actually an immutable sequence type, as documented in <a href="stdtypes.html#typesseq-tuple"><span class="std std-ref">Tuples</span></a> and <a href="stdtypes.html#typesseq"><span class="std std-ref">Sequence Types — list, tuple, range</span></a>.</p>', 
'<code>type</code>(<em>name</em>, <em>bases</em>, <em>dict</em>)<br><br><p id="index-11">With one argument, return the type of an <em>object</em>.  The return value is a type object and generally the same object as returned by <a href="stdtypes.html#instance.__class__" title="instance.__class__"><code class="xref py py-attr docutils literal"><span class="pre">object.__class__</span></code></a>.</p>', 
'<code>vars</code>(<span class="optional">[</span><em>object</em><span class="optional">]</span>)<br><br><p>Return the <a href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a> attribute for a module, class, instance, or any other object with a <a href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a> attribute.</p>', 
'<code>zip</code>(<em>*iterables</em>)<br><br><p>Make an iterator that aggregates elements from each of the iterables.</p>', 
'<code>__import__</code>(<em>name</em>, <em>globals=None</em>, <em>locals=None</em>, <em>fromlist=()</em>, <em>level=0</em>)'
];

// Tip Limit counter
var tipLimit = tipsList.length;

function shuffle(array) {
    var i = tipsList.length,
        j = 0,
        temp;
    while (i--) {
        j = Math.floor(Math.random() * i);
        // swap randomly chosen element with current element
        temp = tipsList[i];
        tipsList[i] = tipsList[j];
        tipsList[j] = temp;
    }
    return tipsList;
}

var ranNums = shuffle(Array.from(Array(tipsList.length).keys()));

function generateTip(tipsNum) {
  var tip = ranNums[tipsNum];
  var tipElement = document.querySelector('.js-tip');
  tipElement.innerHTML = tip;
  var tipLimitCount = document.querySelector('.tip-limit-count');
  tipLimitCount.innerHTML = tipLimit;
  document.querySelector('.tip-button').focus();

}

function onTipButtonClick() {
  var tipButton = document.querySelector('.tip-button');
  tipButton.addEventListener('click', function() {
    tipLimit = tipLimit - 1;
    if (tipLimit >= 0) {
	generateTip(tipLimit);

      if (tipLimit === 0) {
        tipButton.innerHTML = 'See you in another tab!';
        tipButton.classList.add('disabled');
      }
    }
  });
}

// Get the first tip shown
generateTip(tipLimit - 1);

onTipButtonClick();