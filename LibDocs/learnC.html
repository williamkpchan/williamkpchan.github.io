<html>
<head>
<title>Learn C</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script type='text/javascript' src='../mainscript.js'></script>

<script>
$(document).ready(function(){
    $('h1, h2, h3, h4, h5, .goldword, strong,  div.title').click(function(){
    parent.history.back();
    return false;
    });
});

function chkKey() {
var testkey = getChar(event);
if(testkey == 'e'){window.scrollTo(0,document.body.scrollHeight);}
if(testkey == "l"){divtoc = document.getElementById("toc");$('body,html').animate({scrollTop:(divtoc.clientHeight + divtoc.offsetTop-600)}, 1); }
if(testkey == 't'){window.location = '#toc';}
if(testkey == 'T'){window.scrollTo(0,0);}
}
function getChar(event){if (event.which!=0 && event.charCode!=0) {return String.fromCharCode(event.which)}
 else {return null}}

</script>
<style>
body{width:80%;margin-left: 10%; font-size:22px;}
strong, h1, h2 {color: gold;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px;}
</style>
</head>
<body onkeypress="chkKey()">
<center>
<h1>Learn C</h1>
<div id="toc"></div></center>
<pre>

<br>
<br>

<h2>Our first program</h2>
Every C program uses libraries, which give the ability to execute necessary functions. 
For example, the most basic function called <code>printf</code>, which prints to the screen, is defined in the <code>stdio.h</code> header file. 
To add the ability to run the <code>printf</code> command to our program, we must add the following include directive to our first line of the code:

<code>#include &lt;stdio.h&gt;</code>
The second part of the code is the actual code which we are going to write. 
The first code which will run will always reside in the <code>main</code> function. 

<code>int main() {
  ... our code goes here
}</code>
The <code>int</code> keyword indicates that the function <code>main</code> will return an integer - a simple number. 
The number which will be returned by the function indicates whether the program that we wrote worked correctly. 
If we want to say that our code was run successfully, we will return the number 0. 
A number greater than 0 will mean that the program that we wrote failed.

For this tutorial, we will return 0 to indicate that our program was successful:

<code>return 0;</code>
Notice that every line in C must end with a semicolon, so that the compiler knows that a new line has started.

Last but not least, we will need to call the function <code>printf</code> to print our sentence.


<h2>Variables and Types</h2>

<h3>Data types</h3>
C has several types of variables, but there are a few basic types:
Integers - whole numbers which can be either positive or negative. 
Defined using <code>char, int, short, long</code> or <code>long long</code>.

Unsigned integers - whole numbers which can only be positive. 
Defined using <code>unsigned char, unsigned int, unsigned short, unsigned long</code> or <code>unsigned long long</code>.

Floating point numbers - real numbers (numbers with fractions). 
Defined using <code>float</code> and <code>double</code>.

Structures - will be explained later, in the Structures section.
The different types of variables define their bounds. 
A <code>char</code> can range only from -128 to 127, whereas a <code>long</code> can range from -2,147,483,648 to 2,147,483,647 (<code>long</code> and other numeric data types may have another range on different computers, for example - from –9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 on 64-bit computer).

Note that C does <em>not</em> have a boolean type. 
Usually, it is defined using the following notation:

<code>#define BOOL char
#define FALSE 0
#define TRUE 1</code>
C uses arrays of characters to define strings, and will be explained in the Strings section.

<h3>Defining variables</h3>
For numbers, we will usually use the type <code>int</code>, which an integer in the size of a "word" the default number size of the machine which your program is compiled on. 
On most computers today, it is a 32-bit number, which means the number can range from -2,147,483,648 to 2,147,483,647.

To define the variables <code>foo</code> and <code>bar</code>, we need to use the following syntax:

<code>int foo;
int bar = 1;</code>
The variable <code>foo</code> can be used, but since we did not initialize it, we don't know what's in it. 
The variable <code>bar</code> contains the number 1.

Now, we can do some math. 
Assuming <code>a, b, c, d</code>, and <code>e</code> are variables, we can simply use plus, minus and multiplication operators in the following notation, and assign a new value to <code>a</code>:

<code>int a = 0, b = 1, c = 2, d = 3, e = 4;
a = b - c + d * e;
printf("%d", a); /* will print 1-2+3*4 = 11 */</code>
<h3>Exercise</h3>
In the next exercise, you will need to create a program which prints out the sum of the numbers <code>a, b</code>, and <code>c</code>.

<h2>Arrays</h2>

Arrays are special variables which can hold more than one value under the same variable name, organised with an index. 
Arrays are defined using a very straightforward syntax:

<code>/* defines an array of 10 integers */
int numbers[10];</code>
Accessing a number from the array is done using the same syntax. 
Notice that arrays in C are zero-based, which means that if we defined an array of size 10, then the array cells 0 through 9 (inclusive) are defined. 
<code>numbers[10]</code> is not an actual value.

<code>int numbers[10];

/* populate the array */
numbers[0] = 10;
numbers[1] = 20;
numbers[2] = 30;
numbers[3] = 40;
numbers[4] = 50;
numbers[5] = 60;
numbers[6] = 70;

/* print the 7th number from the array, which has an index of 6 */
printf("The 7th number in the array is %d", numbers[6]);</code>
Arrays can only have one type of variable, because they are implemented as a sequence of values in the computer's memory.
Because of that, accessing a specific array cell is very efficient.

<h3>Exercise</h3>

The code below does not compile, because the <code>grades</code> variable is missing. 
One of the grades is missing. 
Can you define it so the grade average will be 85?


<h2>Multidimensional Arrays</h2>

In the previous tutorials on <a href="https://www.learn-c.org/en/Arrays">Arrays</a>, we covered, well, arrays and how they work. 
The arrays we looked at were all one-dimensional, but C can create and use multi-dimensional arrays. 
Here is the general form of a multidimensional array declaration:

<code>type name[size1][size2]...[sizeN];</code>
For example, here's a basic one for you to look at -

<code>int foo[1][2][3];</code>
or maybe this one -

<code>char vowels[1][5] = {
    {'a', 'e', 'i', 'o', 'u'}
};</code>
<h3>Two-dimensional Arrays</h3>
The simplest form of multidimensional array is the two-dimensional array. 
A two-dimensional array is pretty much a list of one-dimensional arrays. 
To declare a two-dimensional integer array of size [ x ][ y ], you would write something like this −

<code>type arrayName [x][y];</code>
Where <strong>type</strong> can be any C data type (int, char, long, long long, double, etc.) and <strong>arrayName</strong> will be a valid C identifier, or variable. 
A two-dimensional array can be considered as a table which will have [ x ] number of rows and [ y ] number of columns. 
A two-dimensional array a, which contains three rows and four columns can be shown and thought about like this −

<img alt="Table 1A" src="https://www.tutorialspoint.com/cprogramming/images/two_dimensional_arrays.jpg" />

In this sense, every element in the array a is identified by an element name in the form <strong>a[i][j]</strong>, where 'a' is the name of the array, and 'i' and 'j' are the indexes that uniquely identify, or show, each element in 'a'.

And honestly, you really don't have to put in a [ x ] value really, because if you did something like this -

<code>char vowels[][5] = {
    {'A', 'E', 'I', 'O', 'U'},
    {'a', 'e', 'i', 'o', 'u'}
};</code>
the compiler would already know that there are two "dimensions" you could say, but, you need need <strong>NEED</strong> a [ y ] value!! The compiler may be smart, but it <em>will not know</em> how many integers, characters, floats, whatever you're using you have in the dimensions. 
Keep that in mind.

<h3>Initializing Two-Dimensional Arrays</h3>
Multidimensional arrays may be used by specifying bracketed[] values for each row. 
Below is an array with 3 rows and each row has 4 columns. 
To make it easier, you can forget the 3 and keep it blank, it'll still work.

<code>int a[3][4] = {  
   {0, 1, 2, 3} ,   /*  initializers for row indexed by 0 */
   {4, 5, 6, 7} ,   /*  initializers for row indexed by 1 */
   {8, 9, 10, 11}   /*  initializers for row indexed by 2 */
};</code>
The inside braces, which indicates the wanted row, are optional. 
The following initialization is the same to the previous example −

<code>int a[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};</code>
<h3>Accessing Two-Dimensional Array Elements</h3>
An element in a two-dimensional array is accessed by using the subscripts, i.e., row index and column index of the array. 
For example −

<code>int val = a[2][3];</code>
The above statement will take the 4th element from the 3rd row of the array.

<h3>Exercise</h3>
Let us try to find out the average marks of a group of five students for two subjects, Mathematics and Physics. 
To do this, we use a two-dimensional array called <code>grades</code>. 
The marks corresponding to Mathematics would be stored in the first row (<code>grades[0]</code>), whereas those corresponding to Physics would be stored in the second row (<code>grades[1]</code>). 
Complete the following steps so that you can execute this program.
Declare grades as a two-dimensional array of integers

Complete the for loops by specifying their terminating conditions

Compute the average marks obtained in each subject


<h2>Conditions</h2>

<h3>Decision Making</h3>
In life, we all have to make decisions. 
In order to make a decision we weigh out our options and so do our programs.

Here is the general form of the decision making structures found in C.

<code>int target = 10;
if (target == 10) {
    printf("Target is equal to 10");
}</code>
<h3>The <code>if</code> statement</h3>
The <code>if</code> statement allows us to check if an expression is <code>true</code> or <code>false</code>, and execute different code according to the result.

To evaluate whether two variables are equal, the <code>==</code> operator is used, just like in the first example.

Inequality operators can also be used to evaluate expressions. 
For example:

<code>int foo = 1;
int bar = 2;

if (foo &lt; bar) {
    printf("foo is smaller than bar.");
}

if (foo &gt; bar) {
    printf("foo is greater than bar.");
}</code>
We can use the <code>else</code> keyword to exectue code when our expression evaluates to <code>false</code>.

<code>int foo = 1;
int bar = 2;

if (foo &lt; bar) {
    printf("foo is smaller than bar.");
} else {
    printf("foo is greater than bar.");
}</code>
Sometimes we will have more than two outcomes to choose from. 
In these cases, we can "chain" multiple <code>if</code> <code>else</code> statements together.

<code>int foo = 1;
int bar = 2;

if (foo &lt; bar) {
    printf("foo is smaller than bar.");
} else if (foo == bar) {
    printf("foo is equal to bar.");
} else {
    printf("foo is greater than bar.");
}</code>
You can also nest <code>if</code> <code>else</code> statements if you like.

<code>int peanuts_eaten = 22;
int peanuts_in_jar = 100;
int max_peanut_limit = 50;

if (peanuts_in_jar &gt; 80) {
    if (peanuts_eaten &lt; max_peanut_limit) {
        printf("Take as many peanuts as you want!\n");
    }
} else {
    if (peanuts_eaten &gt; peanuts_in_jar) {
        printf("You can't have anymore peanuts!\n");
    }
    else {
        printf("Alright, just one more peanut.\n");
    }
}</code>
Two or more expressions can be evaluated together using logical operators to check if two expressions evaluate to <code>true</code> together, or at least one of them. 
To check if two expressions both evaluate to <code>true</code>, use the AND operator <code>&amp;&amp;</code>. 
To check if at least one of the expressions evaluate to <code>true</code>, use the OR operator <code>||</code>.

<code>int foo = 1;
int bar = 2;
int moo = 3;

if (foo &lt; bar &amp;&amp; moo &gt; bar) {
    printf("foo is smaller than bar AND moo is larger than bar.");
}

if (foo &lt; bar || moo &gt; bar) {
    printf("foo is smaller than bar OR moo is larger than bar.");
}</code>
The NOT operator <code>!</code> can also be used likewise:

<code>int target = 9;
if (target != 10) {
    printf("Target is not equal to 10");
}</code>
<h3>Exercise</h3>
In this exercise, you must construct an <code>if</code> statement inside the <code>guessNumber</code> function statement that checks if the number <code>guess</code> is equal to 555. 
If that is the case, the function must print out using <code>printf</code> "Correct. 
You guessed it!". 
If <code>guess</code> is less than 555, the function must print out using <code>printf</code> "Your guess is too low." If <code>guess</code> is greater than 555, the function must print out using <code>printf</code> "Your guess is too high."

<h2>Strings</h2>

<h3>Defining strings</h3>
Strings in C are actually arrays of characters. 
Although using pointers in C is an advanced subject, fully explained later on, we will use pointers to a character array to define simple strings, in the following manner:

<code>char * name = "John Smith";</code>
This method creates a string which we can only use for reading.
If we wish to define a string which can be manipulated, we will need to define it as a local character array:

<code>char name[] = "John Smith";</code>
This notation is different because it allocates an array variable so we can manipulate it. 
The empty brackets notation <code>[]</code> tells the compiler to calculate the size of the array automatically. 
This is in fact the same as allocating it explicitly, adding one to the length of the string:

<code>char name[] = "John Smith";
/* is the same as */
char name[11] = "John Smith";</code>
The reason that we need to add one, although the string <code>John Smith</code> is exactly 10 characters long, is for the string termination:
a special character (equal to 0) which indicates the end of the string. 
The end of the string is marked because the program does not know the length of the string - only the compiler knows it according to the code.

<h3>String formatting with printf</h3>
We can use the <code>printf</code> command to format a string together with other strings, in the following manner:

<code>char * name = "John Smith";
int age = 27;

/* prints out 'John Smith is 27 years old.' */
printf("%s is %d years old.\n", name, age);</code>
Notice that when printing strings, we must add a newline (<code>\n</code>) character so that our next <code>printf</code> statement will print in a new line.

<h3>String Length</h3>
The function 'strlen' returns the length of the string which has to be passed as an argument:

<code>char * name = "Nikhil";
printf("%d\n",strlen(name));</code>
<h3>String comparison</h3>
The function <code>strncmp</code> compares between two strings, returning the number 0 if they are equal, or a different number if they are different.
The arguments are the two strings to be compared, and the maximum comparison length. 
There is also an unsafe version of this function called <code>strcmp</code>, but it is not recommended to use it. 
For example:

<code>char * name = "John";

if (strncmp(name, "John", 4) == 0) {
    printf("Hello, John!\n");
} else {
    printf("You are not John. 
Go away.\n");
}</code>
<h3>String Concatenation</h3>
The function 'strncat' appends first n characters of src string to the destination string where n is min(n,length(src));
The arguments passed are destination string, source string, and n - maximum number of characters to be appended. 
For Example:

<code>char dest[20]="Hello";
char src[20]="World";
strncat(dest,src,3);
printf("%s\n",dest);
strncat(dest,src,20);
printf("%s\n",dest);</code>
<h3>Exercise</h3>
Define the string <code>first_name</code> with the value <code>John</code> using the pointer notation, and define the string <code>last_name</code> with the value <code>Doe</code>
using the local array notation.

<h2>For loops</h2>

For loops in C are straightforward. 
They supply the ability to create a loop - a code block that runs multiple times.
For loops require an iterator variable, usually notated as <code>i</code>.

For loops give the following functionality:
Initialize the iterator variable using an initial value

Check if the iterator has reached its final value

Increases the iterator
For example, if we wish to iterate on a block for 10 times, we write:

<code>int i;
for (i = 0; i &lt; 10; i++) {
    printf("%d\n", i);
}</code>
This block will print the numbers 0 through 9 (10 numbers in total).

For loops can iterate on array values. 
For example, if we would want to sum all the values of an array, we would use the iterator <code>i</code> as the array index:

<code>int array[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
int sum = 0;
int i;

for (i = 0; i &lt; 10; i++) {
    sum += array[i];
}

/* sum now contains a[0] + a[1] + ... 
+ a[9] */
printf("Sum of the array is %d\n", sum);</code>
<h3>Exercise</h3>
Calculate the factorial (multiplication of all items <code>array[0]</code> to <code>array[9]</code>, inclusive), of the variable <code>array</code>.

<h2>While loops</h2>

While loops are similar to for loops, but have less functionality. 
A while loop continues executing the while block as long as the condition in the while remains true. 
For example, the following code will execute exactly ten times:

<code>int n = 0;
while (n &lt; 10) {
    n++;
}</code>
While loops can also execute infinitely if a condition is given which always evaluates as true (non-zero):

<code>while (1) {
   /* do something */
}</code>
<h3>Loop directives</h3>
There are two important loop directives that are used in conjunction with all loop types in C - the <code>break</code> and <code>continue</code> directives.

The <code>break</code> directive halts a loop after ten loops, even though the while loop never finishes:

<code>int n = 0;
while (1) {
    n++;
    if (n == 10) {
        break;
    }
}</code>
In the following code, the <code>continue</code> directive causes the <code>printf</code> command to be skipped, so that only even numbers are printed out:

<code>int n = 0;
while (n &lt; 10) {
    n++;

    /* check that n is odd */
    if (n % 2 == 1) {
        /* go back to the start of the while block */
        continue;
    }

    /* we reach this code only if n is even */
    printf("The number %d is even.\n", n);
}</code>
<h3>Exercise</h3>
The <code>array</code> variable consists of a sequence of ten numbers. 
Inside the while loop, you must write two <code>if</code> conditions,
which change the flow of the loop in the following manner (without changing the <code>printf</code> command):
If the current number which is about to printed is less than 5, don't print it.

If the current number which is about to printed is greater than 10, don't print it and stop the loop.
Notice that if you do not advance the iterator variable <code>i</code> and use the <code>continue</code> derivative, you will get stuck in an infinite loop.

<h2>Functions</h2>

C functions are simple, but because of how C works, the power of functions is a bit limited.
Functions receive either a fixed or variable amount of arguments.

Functions can only return one value, or return no value.
In C, arguments are copied by value to functions, which means that we cannot change the arguments to affect their value outside of the function. 
To do that, we must use pointers, which are taught later on.

Functions are defined using the following syntax:

<code>int foo(int bar) {
    /* do something */
    return bar * 2;
}

int main() {
    foo(1);
}</code>
The function <code>foo</code> we defined receives one argument, which is <code>bar</code>. 
The function receives an integer, multiplies it by two, and returns the result. 
To execute the function <code>foo</code> with 1 as the argument <code>bar</code>, we use the following syntax:

<code>foo(1);</code>
In C, functions must be first defined before they are used in the code. 
They can be either declared first and then implemented later on using a header file or in the beginning of the C file, or they can be implemented in the order they are used (less preferable).

The correct way to use functions is as follows:

<code>/* function declaration */
int foo(int bar);

int main() {
    /* calling foo from main */
    printf("The value of foo is %d", foo(1));
}

int foo(int bar) {
    return bar + 1;
}</code>
We can also create functions that do not return a value by using the keyword <code>void</code>:

<code>void moo() {
    /* do something and don't return a value */
}

int main() {
    moo();
}</code>
<h3>Exercise</h3>
Write a function called <code>print_big</code> which receives one argument (an integer) and prints the line <code>x is big</code> if the argument given to the function is a number bigger than 10. 

<strong>Important</strong>: Don't forget to add a newline character <code>\n</code> at the end of the printf string.


<h2>Static</h2>

<code>static</code> is a keyword in the C programming language. 
It can be used with variables and functions.

<h3>What is a static variable?</h3>
By default, variables are local to the scope in which they are defined. 
Variables can be declared as static to increase their scope up to file containing them. 
As a result, these variables can be accessed anywhere inside a file.

Consider the following scenario – we want to count the runners participating in a race:

<code>#include&lt;stdio.h&gt;
int runner() {
    int count = 0;
    count++;
    return count;
}

int main()
{
    printf("%d ", runner());
    printf("%d ", runner());
    return 0;
}</code>
We will see that <code>count</code> is not updated because it is removed from memory as soon as the function completes. 
If <code>static</code> is used, however:

<code>#include&lt;stdio.h&gt;
int runner()
{
    static int count = 0;
    count++;
    return count;
}

int main()
{
    printf("%d ", runner());
    printf("%d ", runner());
    return 0;
}</code>
<h3>What is a static function?</h3>
By default, functions are global in C. 
If we declare a function with <code>static</code>, the scope of that function is reduced to the file containing it.

The syntax looks like this:

<code>static void fun(void) {
   printf("I am a static function.");
}</code>
<h3>Static vs Global?</h3>
While static variables have scope over the file containing them making them accessible only inside a given file, global variables can be accessed outside the file too.

<h3>Exercise</h3>
In this exercise, try to find the sum of some numbers by using the static keyword. 
Do not pass any variable representing the running total to the <code>sum()</code> function.

<h2>Pointers</h2>

Pointers are also variables and play a very important role in C programming language. 
They are used for several reasons, such as:
Strings

Dynamic memory allocation

Sending function arguments by reference 

Building complicated data structures

Pointing to functions

Building special data structures (i.e. 
Tree, Tries, etc...)
And many more.

<h3>What is a pointer?</h3>
A pointer is essentially a simple integer variable which holds a <strong>memory address</strong> that points to a value, instead of holding the actual value itself. 
The computer's memory is a sequential store of data, and a pointer points to a specific part of the memory. 
Our program can use pointers in such a way that the pointers point to a large amount of memory - depending on how much we decide to read from that point on.

<h3>Strings as pointers</h3>
We've already discussed strings, but now we can dive in a bit deeper and understand what strings in C really are (which are called C-Strings to differentiate them from other strings when mixed with C++) 

The following line:

<code>char * name = "John";</code>
does three things:

<ol>
It allocates a local (stack) variable called <code>name</code>, which is a pointer to a single character. 
It causes the string "John" to appear somewhere in the program memory (after it is compiled and executed, of course). 
It initializes the <code>name</code> argument to point to where the <code>J</code> character resides at (which is followed by the rest of the string in the memory).

</ol>
If we try to access the <code>name</code> variable as an array, it will work, and will return the ordinal value of the character <code>J</code>, since the <code>name</code> variable actually points exactly to the beginning of the string.

Since we know that the memory is sequential, we can assume that if we move ahead in the memory to the next character, we'll receive the next letter in the string, until we reach the end of the string, marked with a null terminator (the character with the ordinal value of 0, noted as <code>\0</code>).

<h3>Dereferencing</h3>
Dereferencing is the act of referring to where the pointer points, instead of the memory address. 
We are already using dereferencing in arrays - but we just didn't know it yet. 
The brackets operator - <code>[0]</code> for example, accesses the first item of the array. 
And since arrays are actually pointers, accessing the first item in the array is the same as dereferencing a pointer. 
Dereferencing a pointer is done using the asterisk operator <code>*</code>.

If we want to create an array that will point to a different variable in our stack, we can write the following code:

<code>/* define a local variable a */
int a = 1;

/* define a pointer variable, and point it to a using the &amp; operator */
int * pointer_to_a = &amp;a;

printf("The value a is %d\n", a);
printf("The value of a is also %d\n", *pointer_to_a);</code>
Notice that we used the <code>&amp;</code> operator to point at the variable <code>a</code>, which we have just created.

We then referred to it using the dereferencing operator. 
We can also change the contents of the dereferenced variable:

<code>int a = 1;
int * pointer_to_a = &amp;a;

/* let's change the variable a */
a += 1;

/* we just changed the variable again! */
*pointer_to_a += 1;

/* will print out 3 */
printf("The value of a is now %d\n", a);</code>
<h3>Exercise</h3>
Create a pointer to the local variable <code>n</code> called <code>pointer_to_n</code>, and use it to increase the value of <code>n</code> by one.

<h2>Structures</h2>

C structures are special, large variables which contain several named variables inside. 
Structures are the basic foundation for objects and classes in C. 
Structures are used for:
Serialization of data

Passing multiple arguments in and out of functions through a single argument

Data structures such as linked lists, binary trees, and more
The most basic example of structures are <strong>points</strong>, which are a single entity that contains two variables - <code>x</code> and <code>y</code>. 
Let's define a point:

<code>struct point {
    int x;
    int y;
};</code>
Now, let's define a new point, and use it. 
Assume the function <code>draw</code> receives a point and draws it on a screen. 
Without structs, using it would require two arguments - each for every coordinate:

<code>/* draws a point at 10, 5 */
int x = 10;
int y = 5;
draw(x, y);</code>
Using structs, we can pass a point argument:

<code>/* draws a point at 10, 5 */
struct point p;
p.x = 10;
p.y = 5;
draw(p);</code>
To access the point's variables, we use the dot <code>.</code> operator. 
<h3>Typedefs</h3>
Typedefs allow us to define types with a different name - which can come in handy when dealing with structs and pointers. 
In this case, we'd want to get rid of the long definition of a point structure. 
We can use the following syntax to remove the <code>struct</code> keyword from each time we want to define a new point:

<code>typedef struct {
    int x;
    int y;
} point;</code>
This will allow us to define a new point like this:

<code>point p;</code>
Structures can also hold pointers - which allows them to hold strings, or pointers to other structures as well - which is their real power. 
For example, we can define a vehicle structure in the following manner:

<code>typedef struct {
    char * brand;
    int model;
} vehicle;</code>
Since brand is a char pointer, the vehicle type can contain a string (which, in this case, indicates the brand of the vehicle).

<code>vehicle mycar;
mycar.brand = "Ford";
mycar.model = 2007;</code>
<h3>Exercise</h3>
Define a new data structure, named "person", which contains a string (pointer to char) called <code>name</code>, and an integer called <code>age</code>.
Next Tutorial <i class="fas fa-angle-double-right"></i>
</a>


<h2>Function arguments by reference</h2>

Function arguments are passed by value, which means they are copied in and out of functions. 
But what if we copied pointers to values instead of the values themselves? This will enable us to give functions control over variables and structures of the parent functions, and not just a copy of them. 
Let's say we want to write a function which increments a number by one, called <code>addone</code>. 
This will not work:

<code>void addone(int n) {
    n++;
}

int n;
printf("Before: %d\n", n);
addone(n);
printf("After: %d\n", n);</code>
However, this will work:

<code>void addone(int * n) {
    (*n)++;
}

int n;
printf("Before: %d\n", n);
addone(&amp;n);
printf("After: %d\n", n);</code>
The difference is that the second version of <code>addone</code> receives a pointer to the variable <code>n</code> as an argument, and then it can manipulate it, because it knows where it is in the memory.

Notice that when calling the <code>addone</code> function, we <strong>must</strong> pass a reference to the variable <code>n</code>, and not the variable itself - this is done so that the function knows the address of the variable, and won't just receive a copy of the variable itself.

<h3>Pointers to structures</h3>
Let's say we want to create a function which moves a point forward in both <code>x</code> and <code>y</code> directions, called <code>move</code>. 
Instead of sending two pointers, we can now send only one pointer to the function of the point structure:

<code>void move(point * p) {
    (*p).x++;
    (*p).y++;
}</code>
However, if we wish to dereference a structure and access one of it's internal members, we have a shorthand syntax for that, because this operation is widely used in data structures. 
We can rewrite this function using the following syntax:

<code>void move(point * p) {
    p-&gt;x++;
    p-&gt;y++;
}</code>
<h3>Exercise</h3>
Write a function called <code>birthday</code>, which adds one to the <code>age</code> of a <code>person</code>.

<h2>Dynamic allocation</h2>

Dynamic allocation of memory is a very important subject in C. 
It allows building complex data structures such as linked lists. 
Allocating memory dynamically helps us to store data without initially knowing the size of the data in the time we wrote the program.

To allocate a chunk of memory dynamically, we have to have a pointer ready to store the location of the newly allocated memory. 
We can access memory that was allocated to us using that same pointer, and we can use that pointer to free the memory again, once we have finished using it.

Let's assume we want to dynamically allocate a person structure. 
The person is defined like this:

<code>typedef struct {
    char * name;
    int age;
} person;</code>
To allocate a new person in the <code>myperson</code> argument, we use the following syntax:

<code>person * myperson = (person *) malloc(sizeof(person));</code>
This tells the compiler that we want to dynamically allocate just enough to hold a person struct in memory, and then return a pointer to the newly allocated data.

Note that <code>sizeof</code> is not an actual function, because the compiler interprets it and translates it to the actual memory size of the person struct.

To access the person's members, we can use the <code>-&gt;</code> notation:

<code>myperson-&gt;name = "John";
myperson-&gt;age = 27;</code>
After we are done using the dynamically allocated struct, we can release it using <code>free</code>:

<code>free(myperson);</code>
Note that the free does not delete the <code>myperson</code> variable itself, it simply releases the data that it points to. 
The <code>myperson</code> variable will still point to somewhere in the memory - but after calling <code>myperson</code> we are not allowed to access that area anymore. 
We must not use that pointer again until we allocate new data using it.

<h3>Exercise</h3>
Use <code>malloc</code> to dynamically allocate a point structure.
Next Tutorial <i class="fas fa-angle-double-right"></i>
</a>


<h2>Arrays and Pointers</h2>

In a previous tutorial on <a href='/en/Pointers'>Pointers</a>, you learned that a pointer to a given data type can store the address of any variable of that particular data type. 
For example, in the following code, the pointer variable <code>pc</code> stores the address of the character variable <code>c</code>.

<code>char c = 'A';
char *pc = &amp;c;</code>
Here, <code>c</code> is a scalar variable that can store only a single value. 
However, you are already familiar with arrays that can hold multiple values of the same data type in a contiguously allocated memory block. 
So, you might wonder, can we have pointers to arrays too? Indeed, we can.

Let us start with an example code and look at its output. 
We will discuss its behavior subsequently.

<code>char vowels[] = {'A', 'E', 'I', 'O', 'U'};
char *pvowels = &amp;vowels;
int i;

// Print the addresses for (i = 0; i &lt; 5; i++) {
    printf("&amp;vowels[%d]: %u, pvowels + %d: %u, vowels + %d: %u\n", i, &amp;vowels[i], i, pvowels + i, i, vowels + i);
}

// Print the values for (i = 0; i &lt; 5; i++) {
    printf("vowels[%d]: %c, *(pvowels + %d): %c, *(vowels + %d): %c\n", i, vowels[i], i, *(pvowels + i), i, *(vowels + i));
}</code>
A typical output of the above code is shown below.

<blockquote>
&amp;vowels[0]: 4287605531, pvowels + 0: 4287605531, vowels + 0: 4287605531

&amp;vowels[1]: 4287605532, pvowels + 1: 4287605532, vowels + 1: 4287605532

&amp;vowels[2]: 4287605533, pvowels + 2: 4287605533, vowels + 2: 4287605533

&amp;vowels[3]: 4287605534, pvowels + 3: 4287605534, vowels + 3: 4287605534

&amp;vowels[4]: 4287605535, pvowels + 4: 4287605535, vowels + 4: 4287605535

vowels[0]: A, *(pvowels + 0): A, *(vowels + 0): A

vowels[1]: E, *(pvowels + 1): E, *(vowels + 1): E

vowels[2]: I, *(pvowels + 2): I, *(vowels + 2): I

vowels[3]: O, *(pvowels + 3): O, *(vowels + 3): O

vowels[4]: U, *(pvowels + 4): U, *(vowels + 4): U

</blockquote>
As you rightly guessed, <code>&amp;vowels[i]</code> gives the memory location of the <em>i</em>th element of the array <code>vowels</code>. 
Moreover, since this is a character array, each element occupies one byte so that the consecutive memory addresses are separated by a single byte. 
We also created a pointer, <code>pvowels</code>, and assigned the address of the array <code>vowels</code> to it. 
<code>pvowels + i</code> is a valid operation; although in general, this may not always be meaningful (explored further in <a href='/en/Pointer_Arithmetics'>Pointer Arithmetics</a> ). 
In particular, the output shown above indicates that <code>&amp;vowels[i]</code> and <code>pvowels + i</code> are equivalent. 
Feel free to alter the data types of the array and pointer variables to test this out.

If you look carefully at the previous code, you will notice that we also used another apparently surprising notation: <code>vowels + i</code>. 
Moreover, <code>pvowels + i</code> and <code>vowels + i</code> returns the same thing &mdash; address of the <em>i</em>th element of the array <code>vowels</code>. 
On the other hand, <code>*(pvowels + i)</code> and <code>*(vowels + i)</code> both return the <em>i</em>th element of the array <code>vowels</code>. 
Why is that so?

This is because the name of an array itself is a (constant) pointer to the first element of the array. 
In other words, the notations <code>vowels, &amp;vowels[0]</code>, and <code>vowels + 0</code> all point to the same location.

<h2>Dynamic Memory Allocation for Arrays</h2>
By now we know that we can traverse an array using pointers. 
Moreover, we also know that we can dynamically allocate (contiguous) memory using blocks pointers. 
These two aspects can be combined to dynamically allocate memory for an array. 
This is illustrated in the following code.

<code>// Allocate memory to store five characters int n = 5;
char *pvowels = (char *) malloc(n * sizeof(char));
int i;

pvowels[0] = 'A';
pvowels[1] = 'E';
*(pvowels + 2) = 'I';
pvowels[3] = 'O';
*(pvowels + 4) = 'U';

for (i = 0; i &lt; n; i++) {
    printf("%c ", pvowels[i]);
}

printf("\n");

free(pvowels);</code>
In the above code, we allocated five contiguous bytes of memory to store five characters. 
Subsequently, we used array notations to traverse the blocks of memory as if <code>pvowels</code> is an array. 
However, remember that <code>pvowels</code> actually is a pointer. 
Pointers and arrays, in general, are not the same thing.

So when is this useful? Remember that while declaring an array, the number of elements that it would contain must be known beforehand. 
Therefore, in some scenarios it might happen that the space allocated for an array is either too less than the desired space or too much more. 
However, by using dynamic memory allocation, one can allocate just as much memory as required by a program. 
Moreover, unused memory can be freed as soon as it is no longer required by invoking the <code>free()</code> function. 
On the down side, with dynamic memory allocation, one must responsibly call <code>free()</code> wherever relevant. 
Otherwise, memory leaks would occur.

We conclude this tutorial by looking at dynamic memory allocation for a two-dimensional array. 
This can be generalized to <em>n</em>-dimensions in a similar way. 
Unlike one-dimensional arrays, where we used a pointer, in this case we require a pointer to a pointer, as shown below.

<code>int nrows = 2;
int ncols = 5;
int i, j;

// Allocate memory for nrows pointers char **pvowels = (char **) malloc(nrows * sizeof(char *));

// For each row, allocate memory for ncols elements pvowels[0] = (char *) malloc(ncols * sizeof(char));
pvowels[1] = (char *) malloc(ncols * sizeof(char));

pvowels[0][0] = 'A';
pvowels[0][1] = 'E';
pvowels[0][2] = 'I';
pvowels[0][3] = 'O';
pvowels[0][4] = 'U';

pvowels[1][0] = 'a';
pvowels[1][1] = 'e';
pvowels[1][2] = 'i';
pvowels[1][3] = 'o';
pvowels[1][4] = 'u';

for (i = 0; i &lt; nrows; i++) {
    for(j = 0; j &lt; ncols; j++) {
        printf("%c ", pvowels[i][j]);
    }

    printf("\n");
}

// Free individual rows free(pvowels[0]);
free(pvowels[1]);

// Free the top-level pointer free(pvowels);</code>
<h3>Exercise</h3>
The first seven rows of <a href="http://mathworld.wolfram.com/PascalsTriangle.html">Pascal's triangle</a> are shown below. 
Note that row <em>i</em> contains <em>i</em> elements. 
Therefore, to store the numbers from the first three rows, one would require 1 + 2 + 3 = 6 memory slots.

<blockquote>
1

1 1

1 2 1

1 3 3 1

1 4 6 4 1

1 5 10 10 5 1

1 6 15 20 15 6 1

</blockquote>
Complete the skeleton code given below to store the numbers from the first three rows of Pascal's triangle in a two-dimensional &quot;array&quot; using dynamic memory allocation. 
Note that you must allocate exactly six memory slots to store those six numbers. 
No extra memory should be allocated. 
At the end of your program, free all the memory blocks used in this program.

<h2>Recursion</h2>

Recursion occurs when a function contains within it a call to itself. 
Recursion can result in very neat, elegant code that is intuitive to follow. 
It can also result in a very large amount of memory being used if the recursion gets too deep.

Common examples of where recursion is used :
Walking recursive data structures such as linked lists, binary trees, etc.

Exploring possible scenarios in games such as chess
Recursion always consists of two main parts. 
A terminating case that indicates when the recursion will finish and a call to itself that must make progress towards the terminating case.

For example, this function will perform multiplication by recursively adding :

<code>#include &lt;stdio.h&gt;

unsigned int multiply(unsigned int x, unsigned int y)
{
    if (x == 1)
    {
        /* Terminating case */
        return y;
    }
    else if (x &gt; 1)
    {
        /* Recursive step */
        return y + multiply(x-1, y);
    }

    /* Catch scenario when x is zero */
    return 0;
}

int main() {
    printf("3 times 5 is %d", multiply(3, 5));
    return 0;
}</code>
<h3>Exercise</h3>
Define a new function called <code>factorial()</code> that will compute the factorial by recursive multiplication (5! = 5 x 4 x 3 x 2 x 1).

<h2>Linked lists</h2>

<h3>Introduction</h3>
Linked lists are the best and simplest example of a dynamic data structure that uses pointers for its implementation.
However, understanding pointers is crucial to understanding how linked lists work, so if you've skipped the pointers tutorial, you should go back and redo it. 
You must also be familiar with dynamic memory allocation and structures.

Essentially, linked lists function as an array that can grow and shrink as needed, from any point in the array.

Linked lists have a few advantages over arrays:

<ol>
Items can be added or removed from the middle of the list

There is no need to define an initial size

</ol>
However, linked lists also have a few disadvantages:

<ol>
There is no "random" access - it is impossible to reach the nth item in the array without first iterating over all items up until that item. 
This means we have to start from the beginning of the list and count how many times we advance in the list until we get to the desired item.

Dynamic memory allocation and pointers are required, which complicates the code and increases the risk of memory leaks and segment faults.

Linked lists have a much larger overhead over arrays, since linked list items are dynamically allocated (which is less efficient in memory usage) and each item in the list also must store an additional pointer.

</ol>
<h3>What is a linked list?</h3>
A linked list is a set of dynamically allocated nodes, arranged in such a way that each node contains one value and one pointer. 
The pointer always points to the next member of the list. 
If the pointer is NULL, then it is the last node in the list.

A linked list is held using a local pointer variable which points to the first item of the list. 
If that pointer is also NULL, then the list is considered to be empty.

<code>    ------------------------------              ------------------------------
    |              |             |            \ |              |             |
    |     DATA     |     NEXT    |--------------|     DATA     |     NEXT    |
    |              |             |            / |              |             |
    ------------------------------              ------------------------------</code>
Let's define a linked list node:

<code>typedef struct node {
    int val;
    struct node * next;
} node_t;</code>
Notice that we are defining the struct in a recursive manner, which is possible in C. 
Let's name our node type <code>node_t</code>.

Now we can use the nodes. 
Let's create a local variable which points to the first item of the list (called <code>head</code>).

<code>node_t * head = NULL;
head = (node_t *) malloc(sizeof(node_t));
if (head == NULL) {
    return 1;
}

head-&gt;val = 1;
head-&gt;next = NULL;</code>
We've just created the first variable in the list. 
We must set the value, and the next item to be empty, if we want to finish populating the list. 
Notice that we should always check if malloc returned a NULL value or not.

To add a variable to the end of the list, we can just continue advancing to the next pointer:

<code>node_t * head = NULL;
head = (node_t *) malloc(sizeof(node_t));
head-&gt;val = 1;
head-&gt;next = (node_t *) malloc(sizeof(node_t));
head-&gt;next-&gt;val = 2;
head-&gt;next-&gt;next = NULL;</code>
This can go on and on, but what we should actually do is advance to the last item of the list, until the <code>next</code> variable will be <code>NULL</code>.

<h3>Iterating over a list</h3>
Let's build a function that prints out all the items of a list. 
To do this, we need to use a <code>current</code> pointer that will keep track of the node we are currently printing. 
After printing the value of the node, we set the <code>current</code>
pointer to the next node, and print again, until we've reached the end of the list (the next node is NULL).

<code>void print_list(node_t * head) {
    node_t * current = head;

    while (current != NULL) {
        printf("%d\n", current-&gt;val);
        current = current-&gt;next;
    }
}</code>
<h3>Adding an item to the end of the list</h3>
To iterate over all the members of the linked list, we use a pointer called <code>current</code>. 
We set it to start from the head and then in each step, we advance the pointer to the next item in the list, until we reach the last item.

<code>void push(node_t * head, int val) {
    node_t * current = head;
    while (current-&gt;next != NULL) {
        current = current-&gt;next;
    }

    /* now we can add a new variable */
    current-&gt;next = (node_t *) malloc(sizeof(node_t));
    current-&gt;next-&gt;val = val;
    current-&gt;next-&gt;next = NULL;
}</code>
The best use cases for linked lists are stacks and queues, which we will now implement:

<h3>Adding an item to the beginning of the list (pushing to the list)</h3>
To add to the beginning of the list, we will need to do the following:

<ol>
Create a new item and set its value

Link the new item to point to the head of the list

Set the head of the list to be our new item

</ol>
This will effectively create a new head to the list with a new value, and keep the rest of the list linked to it.

Since we use a function to do this operation, we want to be able to modify the head variable. 
To do this, we must pass a pointer to the pointer variable (a double pointer) so we will be able to modify the pointer itself.

<code>void push(node_t ** head, int val) {
    node_t * new_node;
    new_node = (node_t *) malloc(sizeof(node_t));

    new_node-&gt;val = val;
    new_node-&gt;next = *head;
    *head = new_node;
}</code>
<h3>Removing the first item (popping from the list)</h3>
To pop a variable, we will need to reverse this action:

<ol>
Take the next item that the head points to and save it

Free the head item

Set the head to be the next item that we've stored on the side

</ol>
Here is the code:

<code>int pop(node_t ** head) {
    int retval = -1;
    node_t * next_node = NULL;

    if (*head == NULL) {
        return -1;
    }

    next_node = (*head)-&gt;next;
    retval = (*head)-&gt;val;
    free(*head);
    *head = next_node;

    return retval;
}</code>
<h3>Removing the last item of the list</h3>
Removing the last item from a list is very similar to adding it to the end of the list, but with one big exception -
since we have to change one item before the last item, we actually have to look two items ahead and see if the next item is the last one in the list:

<code>int remove_last(node_t * head) {
    int retval = 0;
    /* if there is only one item in the list, remove it */
    if (head-&gt;next == NULL) {
        retval = head-&gt;val;
        free(head);
        return retval;
    }

    /* get to the second to last node in the list */
    node_t * current = head;
    while (current-&gt;next-&gt;next != NULL) {
        current = current-&gt;next;
    }

    /* now current points to the second to last item of the list, so let's remove current-&gt;next */
    retval = current-&gt;next-&gt;val;
    free(current-&gt;next);
    current-&gt;next = NULL;
    return retval;

}</code>
<h3>Removing a specific item</h3>
To remove a specific item from the list, either by its index from the beginning of the list or by its value, we will need to go over all the items, continuously looking ahead to find out if we've reached the node before the item we wish to remove. 
This is because we need to change the location to where the previous node points to as well.

Here is the algorithm:

<ol>
Iterate to the node before the node we wish to delete

Save the node we wish to delete in a temporary pointer

Set the previous node's next pointer to point to the node after the node we wish to delete

Delete the node using the temporary pointer

</ol>
There are a few edge cases we need to take care of, so make sure you understand the code.

<code>int remove_by_index(node_t ** head, int n) {
    int i = 0;
    int retval = -1;
    node_t * current = *head;
    node_t * temp_node = NULL;

    if (n == 0) {
        return pop(head);
    }

    for (i = 0; i &lt; n-1; i++) {
        if (current-&gt;next == NULL) {
            return -1;
        }
        current = current-&gt;next;
    }

    temp_node = current-&gt;next;
    retval = temp_node-&gt;val;
    current-&gt;next = temp_node-&gt;next;
    free(temp_node);

    return retval;

}</code>
<h3>Exercise</h3>
You must implement the function <code>remove_by_value</code> which receives a double pointer to the head and removes the first item in the list which has the value <code>val</code>.

<h2>Binary trees</h2>

<h3>Introduction</h3>
A Binary Tree is a type of data structure in which each node has at most two children (left child and right child). 
Binary trees are used to implement binary search trees and binary heaps, and are used for efficient searching and sorting. 
A binary tree is a special case of a K-ary tree, where k is 2. 
Common operations for binary trees include insertion, deletion, and traversal. 
The difficulty of performing these operations varies if the tree is balanced and also whether the nodes are leaf nodes or branch nodes. 
For <strong>balanced trees</strong> the depth of the left and right subtrees of every node differ by 1 or less. 
This allows for a predictable <strong>depth</strong> also known as <strong>height</strong>. 
This is the measure of a node from root to leaf, where root is 0 and sebsequent nodes are (1,2..n). 
This can be expressed by the integer part of log<sub>2</sub>(n) where n is the number of nodes in the tree.

<code>        g                  s                  9
       / \                / \                / \
      b   m              f   u              5   13
     / \                    / \                /  \
    c   d                  t   y              11  15</code>
The operations performed on trees requires searching in one of two main ways: Depth First Search and Breadth-first search. 
<strong>Depth-first search (DFS)</strong> is an algorithm for traversing or searching tree or graph data structures. 
One starts at the root and explores as far as possible along each branch before backtracking. 
There are three types of depth first search traversal: <strong>pre-order</strong> visit, left, right, <strong>in-order</strong> left, visit, right, <strong>post-order</strong> left, right, visit. 
<strong>Breadth-first search (BFS)</strong> is an algorithm for traversing or searching tree or graph structures. 
In level-order, where we visit every node on a level before going to a lower level.<br>

<h3>Exercise</h3>
Below is an implementation of a binary tree that has insertion and printing capabilities. 
This tree is ordered but not balanced. 
This example maintains its ordering at insertion time.

Change the print routine to depth-first search <strong>pre-order</strong>.

<h2>Unions</h2>

C Unions are essentially the same as C Structures, except that instead of containing multiple variables each with their own memory a Union allows for multiple names to the same variable. 
These names can treat the memory as different types (and the size of the union will be the size of the largest type, + any padding the compiler might decide to give it)

So if you wanted to be able to read a variable's memory in different ways, for example read an integer one byte at a time, you could have something like this:

<code>union intParts {
  int theInt;
  char bytes[sizeof(int)];
};</code>
Allowing you to look at each byte individually without casting a pointer and using pointer arithmetic:

<code>union intParts parts;
parts.theInt = 5968145; // arbitrary number &gt; 255 (1 byte)

printf("The int is %i\nThe bytes are [%i, %i, %i, %i]\n",
parts.theInt, parts.bytes[0], parts.bytes[1], parts.bytes[2], parts.bytes[3]);

// vs

int theInt = parts.theInt;
printf("The int is %i\nThe bytes are [%i, %i, %i, %i]\n",
theInt, *((char*)&amp;theInt+0), *((char*)&amp;theInt+1), *((char*)&amp;theInt+2), *((char*)&amp;theInt+3));

// or with array syntax which can be a tiny bit nicer sometimes

printf("The int is %i\nThe bytes are [%i, %i, %i, %i]\n",
    theInt, ((char*)&amp;theInt)[0], ((char*)&amp;theInt)[1], ((char*)&amp;theInt)[2], ((char*)&amp;theInt)[3]);</code>
Combining this with a structure allows you to create a "tagged" union which can be used to store multiple different types, one at a time.

For example, you might have a "number" struct, but you don't want to use something like this:

<code>struct operator {
    int intNum;
    float floatNum;
    int type;
    double doubleNum;
};</code>
Because your program has a lot of them and it takes a bit too much memory for all of the variables, so you could use this:

<code>struct operator {
    int type;
    union {
      int intNum;
      float floatNum;
      double doubleNum;
    } types;
};</code>
Like this the size of the struct is just the size of the int <code>type</code> + the size of the largest type in the union (the double). 
Not a huge gain, only 8 or 16 bytes, but the concept can be applied to similar structs.

use:

<code>operator op;
op.type = 0; // int, probably better as an enum or macro constant op.types.intNum = 352;</code>
Also, if you don't give the union a name then it's members are accessed directly from the struct:

<code>struct operator {
    int type;
    union {
        int intNum;
        float floatNum;
        double doubleNum;
    }; // no name!
};

operator op;
op.type = 0; // int
// intNum is part of the union, but since it's not named you access it directly off the struct itself op.intNum = 352;</code>
Another, perhaps more useful feature, is when you always have multiple variables of the same type, and you want to be able to use both names (for readability) and indexes (for ease of iteration), in that case you can do something like this:

<code>union Coins {
    struct {
        int quarter;
        int dime;
        int nickel;
        int penny;
    }; // anonymous struct acts the same way as an anonymous union, members are on the outer container
    int coins[4];
};</code>
In that example you can see that there is a struct which contains the four (common) coins in the United States.

since the union makes the variables share the same memory the coins array matches with each int in the struct (in order):

<code>union Coins change;
for(int i = 0; i &lt; sizeof(change) / sizeof(int); ++i)
{
    scanf("%i", change.coins + i); // BAD code! input is always suspect!
}
printf("There are %i quarters, %i dimes, %i nickels, and %i pennies\n",
    change.quarter, change.dime, change.nickel, change.penny);</code>
<h3>Exercise</h3>
Create a union that stores an array of 21 characters and 6 ints (6 since 21 / 4 == 5, but 5 * 4 == 20 so you need 1 more for the purpose of this exercise), you will set the integers to 6 given values and then print out the character array both as a series of chars and as a string.

<h2>Pointer Arithmetics</h2>

You previously learned what is a pointer and how to manipulate pointers. 
In this tutorial you will be learning the arithmetic operations on pointers.
There are multiple arithmetic operations that can be applied on C pointers: ++, --, -, +

<h3>Incrementing a Pointer with (++)</h3>
Just like any variable the ++ operation increases the value of that variable. 
In our case here the variable is a pointer hence when we increase its value we are increasing the address in the memory that pointer points to.
Let's combine this operation with an array in our example:

<code>#include &lt;stdio.h&gt;

int main()
{
    int intarray[5] = {10,20,30,40,50};

    int i;
    for(i = 0; i &lt; 5; i++)
        printf("intarray[%d] has value %d - and address @ %x\n", i, intarray[i], &amp;intarray[i]);

    int *intpointer = &amp;intarray[3]; //point to the 4th element in the array
    printf("address: %x - has value %d\n", intpointer, *intpointer); //print the address of the 4th element

    intpointer++; //now increase the pointer's address so it points to the 5th elemnt in the array
    printf("address: %x - has value %d\n", intpointer, *intpointer); //print the address of the 5th element

    return 0;
}</code>
<h3>Decreasing a Pointer with (--)</h3>
Just like in our previous example we increased the pointer's pointed-to address by one using the ++ operator, we can decrease the address pointed-to by one using the decrement operator (--).

<code>#include &lt;stdio.h&gt;

int main()
{
    int intarray[5] = {10,20,30,40,50};

    int i;
    for(i = 0; i &lt; 5; i++)
        printf("intarray[%d] has value %d - and address @ %x\n", i, intarray[i], &amp;intarray[i]);

    int *intpointer = &amp;intarray[4]; //point to the 5th element in the array
    printf("address: %x - has value %d\n", intpointer, *intpointer); //print the address of the 5th element

    intpointer--; //now decrease the point's address so it points to the 4th element in the array
    printf("address: %x - has value %d\n", intpointer, *intpointer); //print the address of the 4th element

    return 0;
}</code>
<h3>Adding Pointers with (+)</h3>
We previously increased a pointer's pointed-to address by one. 
We can also increase it by an integer value such:

<code>#include &lt;stdio.h&gt;

int main()
{
    int intarray[5] = {10,20,30,40,50};

    int i;
    for(i = 0; i &lt; 5; i++)
        printf("intarray[%d] has value: %d - and address @ %x\n", i, intarray[i], &amp;intarray[i]);

    int *intpointer = &amp;intarray[1]; //point to the 2nd element in the array
    printf("address: %x - has value %d\n", intpointer, *intpointer); //print the address of the 2nd element

    intpointer += 2; //now shift by two the point's address so it points to the 4th element in the array
    printf("address: %x - has value %d\n", intpointer, *intpointer); //print the addres of the 4th element

    return 0;
}</code>
Note how in the output the address shifted by 8 steps in the memory. 
You might be wondering why?
The answer is simple: Because our pointer is an int-pointer and the size of an int variable is 4 bytes the memory is shift-able by 4 blocks.
In our code we shifted by 2 (added +2) to the initial address so that makes them 2 x 4 byte = 8.

<h3>Subtracting Pointers with (-)</h3>
Similarly we can subtract:

<code>#include &lt;stdio.h&gt;

int main()
{
    int intarray[5] = {10,20,30,40,50};

    int i;
    for(i = 0; i &lt; 5; i++)
        printf("intarray[%d] has value: %d - and address @ %x\n", i, intarray[i], &amp;intarray[i]);

    int *intpointer = &amp;intarray[4]; //point to the 5th element in the array
    printf("address: %x - has value %d\n", intpointer, *intpointer); //print the address of the 5th element

    intpointer -= 2; //now shift by two the point's address so it points to the 3rd element in the array
    printf("address: %x - has value %d\n", intpointer, *intpointer); //print the address of the 3rd element

    return 0;
}</code>
again the address is shifted by blocks of 4bytes (in case of int).

<h3>Other Operations</h3>
There are more operations such as comparison &gt;, &lt;, ==. 
The idea is very similar of comparing variables, but in this case we are comparing memory address.

<h3>Exercise</h3>
Copy last three addresses of intarray into parray which is an array of pointers to an int.

<h2>Function Pointers</h2>

Remember pointers? We used them to point to an array of chars then make a string out of them.
Then things got more interesting when we learned how to control these pointers.
Now it is time to do something even more interesting with pointers, using them to point to and call functions.

<h3>Why point to a function?</h3>
The first question that may come to your mind is why would we use pointers to call a function when we can simply call a function by its name: <code>function();</code> - that's a great question! Now imagine the <code>sort</code> function where you need to sort an array. 
Sometimes you want to order array elements in an ascending order or descending order. 
How would you choose? Function pointers!

<h3>Function Pointer Syntax</h3>
<code>void (*pf)(int);</code>
I agree with you. 
This definitely is very complicated, or so you may think. 
Let's re-read that code and try to understand it point by point. 
Read it inside-out. 
<code>*pf</code> is the pointer to a function. 
<code>void</code> is the return type of that function, and finally <code>int</code> is the argument type of that function. 
Got it? Good.

Let's insert pointers into the function pointer and try to read it again:

<code>char* (*pf)(int*)</code>
Again:
1. 
<code>*pf</code> is the function pointer.
2. 
<code>char*</code> is the return type of that function.
3. 
<code>int*</code> is the type of the argument.

Ok enough with theory. 
Let's get our hands dirty with some real code.
See this example:

<code>#include &lt;stdio.h&gt;
void someFunction(int arg)
{
    printf("This is someFunction being called and arg is: %d\n", arg);
    printf("Whoops leaving the function now!\n");
}

main()
{
    void (*pf)(int);
    pf = &amp;someFunction;
    printf("We're about to call someFunction() using a pointer!\n");
    (pf)(5);
    printf("Wow that was cool. 
Back to main now!\n\n");
}</code>
Remember <code>sort()</code> we talked about earlier? We can do the same with it.
Instead of ordering a set in an ascending way we can do the opposite using our own comparison function as follows:

<code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt; //for qsort()

int compare(const void* left, const void* right)
{
    return (*(int*)right - *(int*)left);
    // go back to ref if this seems complicated: http://www.cplusplus.com/reference/cstdlib/qsort/
}
main()
{
    int (*cmp) (const void* , const void*);
    cmp = &amp;compare;

    int iarray[] = {1,2,3,4,5,6,7,8,9};
    qsort(iarray, sizeof(iarray)/sizeof(*iarray), sizeof(*iarray), cmp);

    int c = 0;
    while (c &lt; sizeof(iarray)/sizeof(*iarray))
    {
        printf("%d \t", iarray[c]);
        c++;
    }
}</code>
Let's remember again. 
Why do we use function pointers?
1. 
To allow programmers to use libraries for different usages -&gt; "Flexibility"

<h3>Exercise</h3>
Complete the array of pointers to functions and call each function using its pointer from the array. 
Array of pointers to functions? Yes you can do that!

<h3>Tutorial</h3>
Bit masking is simply the process of storing data truly as bits, as opposed to storing it as chars/ints/floats. 
It is incredibly useful for storing certain types of data compactly and efficiently.

The idea for bit masking is based on boolean logic. 
For those not familiar, boolean logic is the manipulation of 'true' (1) and 'false' (0) through logical operations (that take 0s and 1s as their argument). 
We are concerned with the following operations:
NOT a - the final value is the opposite of the input value (1 -&gt; 0, 0 -&gt; 1)

a AND b - if both values are 1, the final value is 1, otherwise the final value is 0

a OR b - if either value is 1, the final value is 1, otherwise the final value is 0

a XOR b - if one value is 1 and the other value is 0, the final value is 1, otherwise the final value is 0
In computing, one of these true/false values is a <em>bit</em>. 
Primitives in C (<code>int, float</code>, etc) are made up of some number of bits, where that number is a multiple of 8. 
For example, an <code>int</code> may be at least 16 bits in size, where a <code>char</code> may be 8 bits. 
8 bits is typically referred to as a <em>byte</em>. 
C guarantees that certain primitives are <a href="https://en.wikipedia.org/wiki/C_data_types#Basic_types">at least some number</a> of bytes in size. 
The introduction of <code>stdint.h</code> in C11 allows the programmer to specify integer types that are exactly some number of bytes, which is extremely useful when using masks.

Bit masks are often used when setting flags. 
Flags are values that can be in two states, such as 'on/off' and 'moving/stationary'.

<h3>Setting bit n</h3>
Setting bit <code>n</code> is as simple as ORing the value of the storage variable with the value <code>2^n</code>.

<code>storage |= 1 &lt;&lt; n;</code>

As an example, here is the setting of bit 3 where <code>storage</code> is a char (8 bits):

<code>01000010
OR
00001000
==
01001010</code>

The <code>2^n</code> logic places the '1' value at the proper bit in the mask itself, allowing access to that same bit in the storage variable.

<h3>Clearing bit n</h3>
Clearing bit <code>n</code> is the result of ANDing the value of the storage variable with the inverse (NOT) of the value <code>2^n</code>:

<code>storage &amp;= ~(1 &lt;&lt; n);</code>

Here's the example again:

<code>01001010
AND
11110111
==
01000010</code>

<h3>Flipping bit n</h3>
Flipping bit <code>n</code> is the result of XORing the value of the storage variable with <code>2^n</code>:

<code>storage ^= 1 &lt;&lt; n;</code>

<code>01000010 01001010
XOR XOR
00001000 00001000
== ==
01001010 01000010</code>

<h3>Checking bit n</h3>
Checking a bit is ANDing the value of <code>2^n</code> with the bit storage:

<code>bit = storage &amp; (1 &lt;&lt; n);</code>

<code>01000010 01001010
AND AND
00001000 00001000
== ==
00000000 00001000</code>

<h3>Exercise</h3>
Use bit masks to manipulate some flags.

<h3>Tutorial Code</h3>
<code>#include &lt;assert.h&gt;

/* Finish initializing the flags */

const short FLAG_ON          = 1 &lt;&lt; 0; // 1  (0x01)
const short FLAG_MOVEMENT    = 1 &lt;&lt; 1; // 2  (0x02)
const short FLAG_TRANSPARENT = 1 &lt;&lt; 2; // 4  (0x04)
const short FLAG_ALIVE       = ;
const short FLAG_BROKEN      = ;
const short FLAG_EDIBLE      = 1 &lt;&lt; 5; // 32 (0x20)

int main() {
  short attributes = 0;

  /* Set the attributes ON, TRANSPARENT, and BROKEN */

  assert(attributes == FLAG_ON | FLAG_TRANSPARENT | FLAG_BROKEN);

  /* Modify (set/clear/toggle) so the only attributes are ON and ALIVE */

  assert(attributes == FLAG_ON | FLAG_ALIVE);

  /* Check if the ALIVE flag is set */
  assert(/* ??? */);

  /* Check if the BROKEN flag is not set */
  assert(/* ??? */);

  /* Modify so only the EDIBLE attribute is set */

  assert(attributes == FLAG_EDIBLE);
}</code>
<h2>Excepted Output</h2>
<h3>Solution</h3>
<code>#include &lt;assert.h&gt;

/* Finish initializing the flags */

const short FLAG_ON          = 1 &lt;&lt; 0; // 1  (0x01)
const short FLAG_MOVEMENT    = 1 &lt;&lt; 1; // 2  (0x02)
const short FLAG_TRANSPARENT = 1 &lt;&lt; 2; // 4  (0x04)
const short FLAG_ALIVE       = 1 &lt;&lt; 3; // 8  (0x08)
const short FLAG_BROKEN      = 1 &lt;&lt; 4; // 16 (0x10)
const short FLAG_EDIBLE      = 1 &lt;&lt; 5; // 32 (0x20)

int main() {
  short attributes = 0;

  /* Set the attributes ON, TRANSPARENT, and BROKEN */
  storage |= FLAG_ON;
  storage |= FLAG_TRANSPARENT;
  storage |= FLAG_BROKEN;
  // possible solution(s):
  // storage |= FLAG_ON &amp; FLAG_TRANSPARENT &amp; FLAG_BROKEN;
  // storage = FLAG_ON &amp; FLAG_TRANSPARENT &amp; FLAG_BROKEN;

  assert(attributes == FLAG_ON | FLAG_TRANSPARENT | FLAG_BROKEN);

  /* Modify (set/clear/toggle) so the only attributes are ON and ALIVE */
  storage &amp;= ~FLAG_TRANSPARENT;
  // possible: storage ^= FLAG_TRANSPARENT;
  storage ^= FLAG_BROKEN;
  // possible: storage &amp;= ~FLAG_BROKEN;
  storage |= FLAG_ALIVE;

  assert(attributes == FLAG_ON | FLAG_ALIVE);

  /* Check if the ALIVE flag is set */
  assert(attributes &amp; FLAG_ALIVE);

  /* Check if the BROKEN flag is not set */
  assert(!(attributes &amp; FLAG_BROKEN));

  /* Modify so only the EDIBLE attribute is set */
  storage = FLAG_EDIBLE;

  assert(attributes == FLAG_EDIBLE);
}</code>
<br>
<br>
<br>
<br>

<script>
	var toc = $('#toc');
	$('h2').each(function(i) {
		var topic = $(this), topicNumber = i + 1;
		toc.append(topicNumber +' <a href="#topic-'+topicNumber+'" target="_self">'+topic.html()+'</a><br>');
		topic.attr('id', 'topic-' + topicNumber);
	});
</script>
</pre></body></html>