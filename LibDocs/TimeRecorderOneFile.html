<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<style>
@viewport{width:extend-to-zoom;zoom:1.0;}
@-ms-viewport{width:extend-to-zoom;zoom:1.0;}
html{min-height:100%;position:relative;}
body{font-family:sans-serif;font-size:1em;overflow-x:hidden;color:#999;height:100%;line-height:34px;margin-top:75px;background-color:#406040;}
div#main-body-container{background-color:white;padding:2px;padding-bottom:5px;padding-top:0;text-align:left;}
h1{margin-top:0;}
h1,h2,h3,h4{font-family:sans-serif;font-weight:100;line-height:100%;font-size:2.25em;}
h2{font-size:1.75em;}
h3{font-size:1.25em;}
a:link{font-weight:bold;font-style:italic;}
pre.code,code{padding:5px;background-color:#eee;overflow:auto;background-image:linear-gradient(-45deg, rgba(255,255,255,0.5), transparent);padding:15px;line-height: 20px !important;}
pre.code span{color:#0b0;}
pre.code span span{color:#c00;}
span.inline-code-highlight{padding:3px;background-color:#eee;font-family:Monospace;}
#breadcrumb{font-style:italic;margin:2px;font-size:80%;position:relative;margin-top:20px;}
#breadcrumb a,#logo a{text-decoration:none;}
ol li{margin-top:20px;}
ol#implementation li code{margin-top:5px;}
ol.compact li{margin-top:0;}
td.description{background-color:#eee;padding:3px;border:1px solid #ddd;}
td.chart{text-align:center;}
.example_boxout{background-color:#eee;padding:3px;border:1px solid #aaa;}
ol#colors li{margin:0;}
div.list-item{width:220px;display:inline-block;}
div.list-item.label{width:170px;}
legend{background-color:#efefef;border:1px solid #75736e;}
div.warning{background-color:#ffa;padding:10px;margin-top:5px;border-radius:15px;opacity:1;box-shadow:2px 2px 2px #ccc;}
div#title div#image{float:left;margin-right:15px;}
div#title div#text{padding-top:5px;margin-left:70px;}
div.warning p{text-align:center;margin-top:5px;margin-bottom:5px;font-weight:bold;}
div.description{border:1px dashed gray;background-color:#eee;font-size:75%;padding:3px;}
div#social{display:inline;display:inline-block;}
div.testimonial{font-size:80%;padding:6px;}
span.javascript-comment{color:#090;}
ul{list-style:none;}
.documentation_header{border:1px solid #aaa;background-color:#eee;font-style:italic;padding:5px;-moz-border-radius:10px;-webkit-border-radius:10px;border-radius:10px;}
span#byline{position:relative;top:-15px;}
p#copyright{text-align:center;font-size:70%;color:black;}
p#copyright a:hover{font-weight:bold;}
#text-only-link{position:absolute;right:100px;top:5px;z-index:2;font-size:70%;font-weight:bold;color:#aaf;background-color:rgba(255,255,255,0.75);padding:5px;}
p#summary{background-color:rgba(240,240,240,0.75);padding:15px;}
div#notify_container{background-color:#cfc;padding:15px;margin-top:15px;margin-bottom:15px;}
input#notify_email{padding:5px;font-size:18pt;width:80%;}
input#notify_submit{float:none;}
div#donation-block{text-align:center;min-height:100px;}
div#donation-block div{display:inline-block;padding-left:5px;padding-right:5px;}
table.api-properties{border-collapse:collapse;width:100%;}
table.api-properties th{background-color:black;color:white;padding:0;}
table.api-properties th,table.api-properties td{border:1px solid #ccc;padding:0 5px 0 5px;}
table.api-properties tr:nth-child(odd){background-color:rgba(160, 215, 245, 0.35);}
table.api-properties td:nth-child(1){font-weight:bold;font-style:italic;}
table.api-properties td:nth-child(3){font-style:italic;}
footer div#footer {box-shadow:0 -3px 5px #666;position:absolute;left:-2%;width:104%;background-color:black;color:white;}
footer div#footer p{position:absolute;right:50px;}
footer div#footer ul{list-style-type:none;!list-style-image:none;margin-right:30px;height: 150px;}
footer div#footer ul li:nth-child(1){list-style-image: none; position: relative; left: -10px;}
footer div#footer a{font-size:90%;color:#ddd;text-decoration:none;font-style:normal;font-weight:normal;}
footer div#footer a:hover{color:#fff;}
div#front-page-header{background-color:black;position:relative;top:-20px;left:-10px;padding:30px;padding-top:10px;color:white;width:100%;overflow:hidden;}
div#front-page-header p{font-size:120%;}
div#front-page-header ul{font-size:100%;list-style-image:none;list-style-type:none;z-index:2;position:relative;width:500px;padding:15px;background-image:linear-gradient(90deg,rgba(64,64,64,0.65),rgba(64,64,64,0.55),rgba(64,64,64,0));}
div#front-page-header ul li{margin:10px;}
div#front-page-header>img{position:absolute;right:0;width:100%;height:100%;z-index:0;}
div#front-page-header-images{margin-right:20px;float:right;position:relative;}
div#front-page-header-images-left,div#front-page-header-images-middle,div#front-page-header-images-right,div#front-page-header-images-col4{position:relative;float:right;margin-right:20px;width:150px;z-index:3;}
div#front-page-header-images-left img,div#front-page-header-images-middle img,div#front-page-header-images-right img,div#front-page-header-images-col4 img{box-shadow:3px 3px 15px #aaa;transition:transform .25s ease-out,opacity .25s;opacity: 0.75;margin-top:30px;}
div#front-page-header-images-left img:hover,div#front-page-header-images-middle img:hover,div#front-page-header-images-right img:hover,div#front-page-header-images-col4 img:hover{transform:scale(1.1);opacity:1;}
div#front-page-header span.download-button{display:inline-block;padding:10px;font-size: 125%;border-radius:15px;color:white;z-index:1;position:relative;margin:-10px 10px 10px 10px;background-color:green;}
div#front-page-header span.javascript-charts{display:inline-block;padding:10px;font-size: 125%;border-radius:15px;color:white;z-index:1;position:relative;margin:-10px 10px 10px 10px;background-color:rgb(128,128,255);}
div#front-page-header a{text-decoration:none}
div#javascript-charts-boxout {background-color: #590678;background-image: linear-gradient(90deg, #590678, #806);color: white;position:relative;left: -10px;width: 100%;padding: 15px;}
div#javascript-charts-images-container{text-align: center;}
div#javascript-charts-images-container div.javascript-charts-box{background-color:#fff;width: 250px;margin: 25px;display: inline-block;box-shadow: 0 5px 15px #aaa;transition: transform .25s ease-out;white-space: nowrap;overflow: hidden;text-overflow: ellipsis;min-height: 150px;}
div#javascript-charts-images-container div.javascript-charts-box:hover{transform: scale(1.1);}
div#javascript-charts-images-container div.javascript-charts-box img{width: 250px;}
div#javascript-charts-images-container a{display:inline-block;color:black;font-weight:normal;font-style:normal;}
div#data-import-methods div{float:left;width:25%;min-width:200px;display:inline-block;box-sizing:border-box;padding-right:15px;}
div#data-import-methods img{float:left;margin-right: 15px;transform:scale(1);}
div#data-import-methods small{color:gray;}
div.javascript-charts-menubar{text-align:left;margin-bottom: 15px;}
div.javascript-charts-menubar b{display:inline-block;width: 130px;}
div.javascript-charts-menubar a{background-color: #eee;padding-left: 5px;padding-right: 5px;text-decoration:none;box-shadow: 2px 2px 3px #ccc;}
div.javascript-charts-menubar a:hover{background-color: #fee;}
ul#list-of-features{width:100%!important;max-width:500px!important;line-height: 25px;}
ul#list-of-features li a{color:#aaf;}
div#boxout-container{text-align:center;display:flex;}
div#boxout-container div.image-container{min-width:200px;text-align:left;margin:5px;border:1px solid #ddd;padding:15px;border-radius:5px;flex-grow:1;}
div#footer-image-icons{text-align:center;}
div#footer-image-icons div.footer-container{display:inline-block;text-align:center;width:20%;}
div#footer-image-icons a div.footer-container b{font-size:smaller;}
div#footer-image-icons a div.footer-container img{transition:transform .25s ease-out;}
div#footer-image-icons a div.footer-container img:hover{transform:scale(1.1);}
.dropdown-menu-smallscreen-image{position: relative!important; padding-right: 10px!important;top:3px!important;left:0!important;}
ul#dropdown-menu-smallscreen li a{color:white;text-decoration:none;font-style:normal;}
img#navigation-top-bar-hamburger{display:none;}
div#navigation-top-bar{position:absolute;top:0;left:0;z-index:1000;width:100%;}
div#navigation-top-bar-image{background-color:black;z-index:5;overflow:hidden;box-shadow:0 3px 5px #bbb;padding:0;height:55px;}
div#navigation-top-bar-links a{color:white;text-decoration:none;font-style:normal;font-family:Segoe UI Light,sans-serif;text-align:center;font-size:.8em;width:9%;display:inline-block;}
div#navigation-top-bar-links a span{display:inline-block;lmargin:0;border-bottom:3px solid #999;}
div#navigation-top-bar-links a span::after{display:block;position:relative;top:3px;content:'';border-bottom:solid 3px #ddd;transform:scaleX(0);transition:transform .25s ease-in-out;}
div#navigation-top-bar-links a span:hover::after{transform:scaleX(1);}
img#navigation-top-bar-hamburger{position:absolute;top:0;right:15px;z-index:5;background-image:url(/images/navigation-icons/small/icons-combined.png);background-position: -146px -125px;cursor:pointer;}
img#navigation-top-bar-logo{float:left;margin-top:2px;}
#front-page-free-for{width:90%;margin-left:5%}
#front-page-free-for span{font-size: 250%; font-family: Segoe UI Light,Arial,sans-serif}
#download-page-poster-image-container{display:inline-block;z-index:-1;opacity:.2;float:right;position:relative;width:670px;height:300px}
#download-page-poster-image-container img{position:absolute;top:0;left:0}
#download-page-poster-image-container div{position:absolute;top:0;left:0;width:100%;height:100%;background-image:linear-gradient(90deg,white,rgba(255,255,255,0),rgba(255,255,255,0),rgba(255,255,255,0),rgba(255,255,255,0),rgba(255,255,255,0))}
img#facebook-share{background:url(/images/sprite.png) -429px -82px;position:absolute;top:5px;left:calc(63% + 290px);transition:transform .5s ease-out}
img#twitter-share{background:url(/images/sprite.png) -432px -48px;position:absolute;top:8px;left:calc(63% + 315px);transition:transform .5s ease-out}
img#facebook-share:hover{transform:scale(1.25)}
img#twitter-share:hover{transform:scale(1.25)}
body {
 margin: auto;
 width: 80%;
 font-size: 24px;
 background-color: #000000;
 color: #20C030;
}
a { text-decoration: none; 
	color: #28B8B8; }
a:visited {	color: #389898; }
A:hover {	color: yellow; }
A:focus {	color: red; }
code { color: gray;  background-color: #001010}
pre { color: gray;  background-color: #001010;  font-size: 16px; }
button, input, select {color: gray; background-color: #001010;  font-size: 18px; }
.redword { color: red; text-shadow: 1px 1px 2px black, -1px -1px 1px white;}
.greyword { color: grey;}
</style>

<script>
// var alarmSound = new Audio('./mp3/stringVibrate.mp3');
// toneBeep.mp3
var theCode = 'HSI';
var stkCode, stkName, stkTime, stkPrice, stkMaxprice, stkMinprice, stkVol, mytimer;
var timerValue = 10;
var stkChangeArr = [];
var toFixedLen = 2;
var stkCode, stkName, stkTime, stkPrice, stkMaxprice, stkMinprice, stkChange, stkVol;
var theString ="";
function dispTime() {
	document.getElementById("dateAndTime").innerHTML = showTime();
}

function checkTime() {
	var d = new Date(); // current time
	var hours = d.getHours();
	var mins = d.getMinutes();
	var day = d.getDay();
	return day >= 1
		&& day <= 5
		&& (
			(hours >= 10  || hours === 9 && mins >= 30) && (hours < 12)
			|| (hours >= 13) && (hours < 16)
			);
}

function setTimer() {
	document.getElementById("msg").innerHTML = "<br><br>";
	clearInterval(mytimer);
	mytimer = setInterval(function(){ alarm(); }, timerValue* 1000);

}

function alarm() {
	dispTime();
	if(checkTime()){
		$.get("http://qt.gtimg.cn/r=2&q=r_hk" + theCode, function(data, status){process(data);})

//    setTimeout(window.onload, 2000); // 2000 millisec, this is to replace setInterval
	}
}
function process(data) {
	extractData(data);
	reportStatus()
}

function extractData(data) {
	theString = data;
	var arr = theString.split("=");
	theString = arr[1];
	var arr = theString.split("~");
	stkCode = arr[2];
	stkName = arr[1];
	stkTime = arr[30];

	stkPrice = Number(arr[3]).toFixed(toFixedLen);
	stkMaxprice = Number(arr[33]).toFixed(toFixedLen);
	stkMinprice = Number(arr[34]).toFixed(toFixedLen);
	stkChange = Number(arr[31]).toFixed(toFixedLen);

	stkVol = (Number(arr[37])/10000).toFixed(0);
}

function reportStatus() {
	stkpriceDataArr.push(Number(stkPrice));
	stkChangeArr.push(stkChange);
	finalString = showTime() + " " + "<span class='greyword'>" + stkCode + "</span>" + "&emsp;" + stkName + "&emsp;" + stkTime + "&emsp;" + "<span class='redword'>"  + stkPrice + "</span>" + "&emsp;" + stkChange  + "&emsp;" + calstkChangechg() +  "&emsp;" + stkMaxprice + "&emsp;" + stkMinprice + "&emsp;" + stkVol + "<br>" ;
	
	$("#msg").prepend(finalString);

//	RGraph.reset(document.getElementById('cvs'));

	RGraph.clear(document.getElementById("cvs", 'white'));
	theMax = Math.max(...stkpriceDataArr);
	theMin = Math.min(...stkpriceDataArr);

	drawchart();
//	alarmSound.play();
}

function chkKey() {
  var testkey = getChar(event);
//  if(testkey == 'c'){getKeyword();}
}

function getChar(event) {
  if (event.which!=0 && event.charCode!=0) {
    return String.fromCharCode(event.which)   // the rest
  } else {
    return null // special key
  }
}

function showTime() {
	var d = new Date();
	var secs=d.getSeconds();
	var mins=d.getMinutes();
	var hr=d.getHours();
	var timemsg = FormatNumberLength(hr) + ":" + FormatNumberLength(mins) + ":" + FormatNumberLength(secs)
	return(timemsg)
}

function FormatNumberLength(num) {
    var r = "" + num;
    while (r.length < 2) {
	r = "0" + r;
    }
    return r;
}
function calstkChangechg() {
	if (stkpriceDataArr.length>1){
		stkChangechgval = stkChangeArr.slice(-1) - stkChangeArr.slice(-2)[0];
		return stkChangechgval.toFixed(toFixedLen);
	} else {
		return 0;
	}
}
</script>

</head>

<body onkeypress="chkKey()">
<h3>Time Recorder 10 sec &emsp; <span id="dateAndTime""><script>dispTime();</script></span></h3>

<canvas id="cvs" width="1000" height="500">[No canvas support]</canvas>
<div id="msg"></div>

<script>
    RGraph = window.RGraph || {isRGraph: true};

// Module pattern
(function (win, doc, undefined)
{
    var RG  = RGraph,
        ua  = navigator.userAgent,
        ma  = Math;
    /**
    * Initialise the various objects
    */
    RG.Highlight      = {};
    RG.Registry       = {};
    RG.Registry.store = [];
    RG.Registry.store['chart.event.handlers']       = [];
    RG.Registry.store['__rgraph_event_listeners__'] = []; // Used in the new system for tooltips
    RG.Background     = {};
    RG.background     = {};
    RG.objects        = [];
    RG.Resizing       = {};
    RG.events         = [];
    RG.cursor         = [];
    RG.Effects        = RG.Effects || {};
    RG.cache          = [];

    RG.ObjectRegistry                    = {};
    RG.ObjectRegistry.objects            = {};
    RG.ObjectRegistry.objects.byUID      = [];
    RG.ObjectRegistry.objects.byCanvasID = [];
    RG.OR                                = RG.ObjectRegistry;
    
    /**
    * Some "constants". The ua variable is navigator.userAgent (definedabove)
    */
    RG.PI       = ma.PI;
    RG.HALFPI   = RG.PI / 2;
    RG.TWOPI    = RG.PI * 2;

    RG.ISFF     = ua.indexOf('Firefox') != -1;
    RG.ISOPERA  = ua.indexOf('Opera') != -1;
    RG.ISCHROME = ua.indexOf('Chrome') != -1;
    RG.ISSAFARI = ua.indexOf('Safari') != -1 && !RG.ISCHROME;
    RG.ISWEBKIT = ua.indexOf('WebKit') != -1;

    RG.ISIE   = ua.indexOf('Trident') > 0 || navigator.userAgent.indexOf('MSIE') > 0;
    RG.ISIE6  = ua.indexOf('MSIE 6') > 0;
    RG.ISIE7  = ua.indexOf('MSIE 7') > 0;
    RG.ISIE8  = ua.indexOf('MSIE 8') > 0;
    RG.ISIE9  = ua.indexOf('MSIE 9') > 0;
    RG.ISIE10 = ua.indexOf('MSIE 10') > 0;
    RG.ISOLD  = RGraph.ISIE6 || RGraph.ISIE7 || RGraph.ISIE8; // MUST be here
    
    RG.ISIE11UP = ua.indexOf('MSIE') == -1 && ua.indexOf('Trident') > 0;
    RG.ISIE10UP = RG.ISIE10 || RG.ISIE11UP;
    RG.ISIE9UP  = RG.ISIE9 || RG.ISIE10UP;
    
    /**
    * Returns five values which are used as a nice scale
    * 
    * @param  max int    The maximum value of the graph
    * @param  obj object The graph object
    * @return     array   An appropriate scale
    */
    RG.getScale = function (max, obj)
    {
        /**
        * Special case for 0
        */
        if (max == 0) {
            return ['0.2', '0.4', '0.6', '0.8', '1.0'];
        }

        var original_max = max;

        /**
        * Manually do decimals
        */
        if (max <= 1) {
            if (max > 0.5) {
                return [0.2,0.4,0.6,0.8, Number(1).toFixed(1)];

            } else if (max >= 0.1) {
                return obj.Get('chart.scale.round') ? [0.2,0.4,0.6,0.8,1] : [0.1,0.2,0.3,0.4,0.5];

            } else {

                var tmp = max;
                var exp = 0;

                while (tmp < 1.01) {
                    exp += 1;
                    tmp *= 10;
                }

                var ret = ['2e-' + exp, '4e-' + exp, '6e-' + exp, '8e-' + exp, '10e-' + exp];


                if (max <= ('5e-' + exp)) {
                    ret = ['1e-' + exp, '2e-' + exp, '3e-' + exp, '4e-' + exp, '5e-' + exp];
                }

                return ret;
            }
        }

        // Take off any decimals
        if (String(max).indexOf('.') > 0) {
            max = String(max).replace(/\.\d+$/, '');
        }

        var interval = ma.pow(10, Number(String(Number(max)).length - 1));
        var topValue = interval;

        while (topValue < max) {
            topValue += (interval / 2);
        }

        // Handles cases where the max is (for example) 50.5
        if (Number(original_max) > Number(topValue)) {
            topValue += (interval / 2);
        }

        // Custom if the max is greater than 5 and less than 10
        if (max < 10) {
            topValue = (Number(original_max) <= 5 ? 5 : 10);
        }
        
        /**
        * Added 02/11/2010 to create "nicer" scales
        */
        if (obj && typeof(obj.Get('chart.scale.round')) == 'boolean' && obj.Get('chart.scale.round')) {
            topValue = 10 * interval;
        }

        return [topValue * 0.2, topValue * 0.4, topValue * 0.6, topValue * 0.8, topValue];
    };
    
    /**
    * Returns an appropriate scale. The return value is actualy an object consisting of:
    *  scale.max
    *  scale.min
    *  scale.scale
    * 
    * @param  obj object  The graph object
    * @param  prop object An object consisting of configuration properties
    * @return     object  An object containg scale information
    */
    RG.getScale2 = function (obj, opt)
    {
        var ca           = obj.canvas,
            co           = obj.context,
            prop         = obj.properties,
            numlabels    = typeof opt['ylabels.count'] == 'number' ? opt['ylabels.count'] : 5,
            units_pre    = typeof opt['units.pre'] == 'string' ? opt['units.pre'] : '',
            units_post   = typeof opt['units.post'] == 'string' ? opt['units.post'] : '',
            max          = Number(opt['max']),
            min          = typeof opt['min'] == 'number' ? opt['min'] : 0,
            strict       = opt['strict'],
            decimals     = Number(opt['scale.decimals']), // Sometimes the default is null
            point        = opt['scale.point'], // Default is a string in all chart libraries so no need to cast it
            thousand     = opt['scale.thousand'], // Default is a string in all chart libraries so no need to cast it
            original_max = max,
            round        = opt['scale.round'],
            scale        = {max:1,labels:[],values:[]}
                    /**
        * Special case for 0
        * 
        * ** Must be first **
        */
        if (!max) {

            var max   = 1;

            for (var i=0; i<numlabels; ++i) {

                var label = ((((max - min) / numlabels) + min) * (i + 1)).toFixed(decimals);

                scale.labels.push(units_pre + label + units_post);
                scale.values.push(parseFloat(label))
            }

        /**
        * Manually do decimals
        */
        } else if (max <= 1 && !strict) {

            var arr = [
                1,0.5,
                0.10,0.05,
                0.010,0.005,
                0.0010,0.0005,
                0.00010,0.00005,
                0.000010,0.000005,
                0.0000010,0.0000005,
                0.00000010,0.00000005,
                0.000000010,0.000000005,
                0.0000000010,0.0000000005,
                0.00000000010,0.00000000005,
                0.000000000010,0.000000000005,
                0.0000000000010,0.0000000000005
            ], vals = [];
                        for (var i=0; i<arr.length; ++i) {
                if (max > arr[i]) {
                    i--;
                    break;
                }
            }


            scale.max = arr[i]
            scale.labels = [];
            scale.values = [];
        
            for (var j=0; j<numlabels; ++j) {
                
                var value = ((((arr[i] - min) / numlabels) * (j + 1)) + min).toFixed(decimals);

                scale.values.push(value);
                scale.labels.push(RG.numberFormat(obj, value, units_pre, units_post));
            }
            
        } else if (!strict) {

            /**
            * Now comes the scale handling for integer values
            */

            // This accomodates decimals by rounding the max up to the next integer
            max = ma.ceil(max);

            var interval = ma.pow(10, ma.max(1, Number(String(Number(max) - Number(min)).length - 1)) );

            var topValue = interval;

            while (topValue < max) {
                topValue += (interval / 2);
            }

            // Handles cases where the max is (for example) 50.5
            if (Number(original_max) > Number(topValue)) {
                topValue += (interval / 2);
            }

            // Custom if the max is greater than 5 and less than 10
            if (max <= 10) {
                topValue = (Number(original_max) <= 5 ? 5 : 10);
            }
    
    
            // Added 02/11/2010 to create "nicer" scales
            if (obj && typeof(round) == 'boolean' && round) {
                topValue = 10 * interval;
            }

            scale.max = topValue;

            // Now generate the scale. Temporarily set the objects chart.scale.decimal and chart.scale.point to those
            //that we've been given as the number_format functuion looks at those instead of using argumrnts.
            var tmp_point    = prop['chart.scale.point'];
            var tmp_thousand = prop['chart.scale.thousand'];

            obj.Set('chart.scale.thousand', thousand);
            obj.Set('chart.scale.point', point);


            for (var i=0; i<numlabels; ++i) {
                scale.labels.push( RG.number_format(obj, ((((i+1) / numlabels) * (topValue - min)) + min).toFixed(decimals), units_pre, units_post) );
                scale.values.push(((((i+1) / numlabels) * (topValue - min)) + min).toFixed(decimals));
            }

            obj.Set('chart.scale.thousand', tmp_thousand);
            obj.Set('chart.scale.point', tmp_point);
        
        } else if (typeof(max) == 'number' && strict) {

            /**
            * ymax is set and also strict
            */
            for (var i=0; i<numlabels; ++i) {
                scale.labels.push(RG.numberFormat(
                    obj,
                    ((((i+1) / numlabels) * (max - min)) + min).toFixed(decimals),
                    units_pre,
                    units_post
                ));

                scale.values.push(
                    ((((i+1) / numlabels) * (max - min)) + min).toFixed(decimals)
                );
            }
            
            // ???
            scale.max = max;
        }

        
        scale.units_pre  = units_pre;
        scale.units_post = units_post;
        scale.point      = point;
        scale.decimals   = decimals;
        scale.thousand   = thousand;
        scale.numlabels  = numlabels;
        scale.round      = Boolean(round);
        scale.min        = min;

        //
        // Convert all of the scale values to numbers
        //
        for (var i=0; i<scale.values.length; ++i) {
            scale.values[i] = parseFloat(scale.values[i]);
        }

        return scale;
    };
    
    //
    // Converts an the truthy values to falsey values and vice-versa
    //
    RG.arrayInvert = function (arr)
    {
        for (var i=0,len=arr.length; i<len; ++i) {
            arr[i] = !arr[i];
        }

        return arr;
    };
    
    //
    // An array_trim function that removes the empty elements off
    //both ends
    //
    RG.arrayTrim = function (arr)
    {
        var out = [], content = false;

        // Trim the start
        for (var i=0; i<arr.length; i++) {
        
            if (arr[i]) {
                content = true;
            }
        
            if (content) {
                out.push(arr[i]);
            }
        }
        
        // Reverse the array and trim the start again
        out = RG.arrayReverse(out);

        var out2 = [], content = false ;
        for (var i=0; i<out.length; i++) {
        
            if (out[i]) {
                content = true;
            }
        
            if (content) {
                out2.push(out[i]);
            }
        }
        
        // Now reverse the array and return it
        out2 = RG.arrayReverse(out2);

        return out2;
    };
    
    /**
    * Makes a clone of an object
    * 
    * @param obj val The object to clone
    */
    RG.arrayClone =
    RG.array_clone = function (obj)
    {
        if(obj === null || typeof obj !== 'object') {
            return obj;
        }

        var temp = [];

        for (var i=0,len=obj.length;i<len; ++i) {

            if (typeof obj[i]  === 'number') {
                temp[i] = (function (arg) {return Number(arg);})(obj[i]);
            
            } else if (typeof obj[i]  === 'string') {
                temp[i] = (function (arg) {return String(arg);})(obj[i]);
            
            } else if (typeof obj[i] === 'function') {
                temp[i] = obj[i];
            
            } else {
                temp[i] = RG.arrayClone(obj[i]);
            }
        }

        return temp;
    };
    
    /**
    * Returns the maximum numeric value which is in an array. This function IS NOT
    * recursive
    * 
    * @param  array arr The array (can also be a number, in which case it's returned as-is)
    * @param  int       Whether to ignore signs (ie negative/positive)
    * @return int       The maximum value in the array
    */
    RG.arrayMax =
    RG.array_max = function (arr)
    {
        var max = null,
            ma  = Math
        
        if (typeof arr === 'number') {
            return arr;
        }
        
        if (RG.isNull(arr)) {
            return 0;
        }

        for (var i=0,len=arr.length; i<len; ++i) {
            if (typeof arr[i] === 'number' && !isNaN(arr[i])) {

                var val = arguments[1] ? ma.abs(arr[i]) : arr[i];
                
                if (typeof max === 'number') {
                    max = ma.max(max, val);
                } else {
                    max = val;
                }
            }
        }

        return max;
    };
    
    /**
    * Returns the minimum numeric value which is in an array
    * 
    * @param  array arr The array (can also be a number, in which case it's returned as-is)
    * @param  int       Whether to ignore signs (ie negative/positive)
    * @return int       The minimum value in the array
    */
    RG.arrayMin = function (arr)
    {
        var max = null,
            min = null,
            ma  = Math;
        
        if (typeof arr === 'number') {
            return arr;
        }
        
        if (RG.isNull(arr)) {
            return 0;
        }

        for (var i=0,len=arr.length; i<len; ++i) {
            if (typeof arr[i] === 'number') {

                var val = arguments[1] ? ma.abs(arr[i]) : arr[i];
                
                if (typeof min === 'number') {
                    min = ma.min(min, val);
                } else {
                    min = val;
                }
            }
        }

        return min;
    };
    
    /**
    * Returns the maximum value which is in an array
    * 
    * @param  array arr The array
    * @param  int   len The length to pad the array to
    * @param  mixed     The value to use to pad the array (optional)
    */
    RG.arrayPad =
    RG.array_pad = function (arr, len)
    {
        if (arr.length < len) {
            var val = arguments[2] ? arguments[2] : null;
            
            for (var i=arr.length; i<len; i+=1) {
                arr[i] = val;
            }
        }
        
        return arr;
    };
    

    /**
    * An array sum function
    * 
    * @param  array arr The  array to calculate the total of
    * @return int       The summed total of the arrays elements
    */
    RG.arraySum =
    RG.array_sum = function (arr)
    {
        // Allow integers
        if (typeof arr === 'number') {
            return arr;
        }
        
        // Account for null
        if (RG.isNull(arr)) {
            return 0;
        }

        var i, sum, len = arr.length;

        for(i=0,sum=0;i<len;sum+=(arr[i++]||0));

        return sum;
    };
    
    /**
    * Takes any number of arguments and adds them to one big linear array
    * which is then returned
    * 
    * @param ... mixed The data to linearise. You can strings, booleans, numbers or arrays
    */
    RG.arrayLinearize =
    RG.array_linearize = function ()
    {
        var arr  = [],
            args = arguments

        for (var i=0,len=args.length; i<len; ++i) {

            if (typeof args[i] === 'object' && args[i]) {
                for (var j=0,len2=args[i].length; j<len2; ++j) {
                    var sub = RG.array_linearize(args[i][j]);
                    
                    for (var k=0,len3=sub.length; k<len3; ++k) {
                        arr.push(sub[k]);
                    }
                }
            } else {
                arr.push(args[i]);
            }
        }

        return arr;
    };
    
    /**
    * Takes one off the front of the given array and returns the new array.
    * 
    * @param array arr The array from which to take one off the front of array 
    * 
    * @return array The new array
    */
    RG.arrayShift =
    RG.array_shift = function(arr)
    {
        var ret = [];
        
        for(var i=1,len=arr.length; i<len; ++i) {
            ret.push(arr[i]);
        }
        
        return ret;
    };
    
    /**
    * Reverses the order of an array
    * 
    * @param array arr The array to reverse
    */
    RG.arrayReverse =
    RG.array_reverse = function (arr)
    {
        if (!arr) {
            return;
        }

        var newarr=[];

        for(var i=arr.length - 1; i>=0; i-=1) {
            newarr.push(arr[i]);
        }
        
        return newarr;
    };
    
    /**
    * Returns the absolute value of a number. You can also pass in an
    * array and it will run the abs() function on each element. It
    * operates recursively so sub-arrays are also traversed.
    * 
    * @param array arr The number or array to work on
    */
    RG.abs = function (value)
    {
        if (typeof value === 'string') {
            value = parseFloat(value) || 0;
        }

        if (typeof value === 'number') {
            return ma.abs(value);
        }

        if (typeof value === 'object') {
            for (i in value) {
                if (   typeof i === 'string'
                    || typeof i === 'number'
                    || typeof i === 'object') {

                    value[i] = RG.abs(value[i]);
                }
            }
            
            return value;
        }
        
        return 0;
    };
    
    /**
    * Clears the canvas by setting the width. You can specify a colour if you wish.
    * 
    * @param object canvas The canvas to clear
    * @param mixed         Usually a color string to use to clear the canvas
    *                      with - could also be a gradient object
    */
    RG.clear =
    RG.Clear = function (ca)
    {
        var obj   = ca.__object__,
            co    = ca.getContext('2d'),
            color = arguments[1] || (obj && obj.get('clearto'))

        if (!ca) {
            return;
        }
        
        RG.fireCustomEvent(obj, 'onbeforeclear');

        /**
        * Set the CSS display: to none for DOM text
        */
        if (RG.text2.domNodeCache && RG.text2.domNodeCache[ca.id]) {
            for (var i in RG.text2.domNodeCache[ca.id]) {
                
                var el = RG.text2.domNodeCache[ca.id][i];
    
                if (el && el.style) {
                    el.style.display = 'none';
                }
            }
        }

        /**
        * Can now clear the canvas back to fully transparent
        */
        if (   !color
            || (color && color === 'rgba(0,0,0,0)' || color === 'transparent')
            ) {

            co.clearRect(-100,-100,ca.width + 200, ca.height + 200);

            // Reset the globalCompositeOperation
            co.globalCompositeOperation = 'source-over';

        } else if (color) {

            RG.path2(co, 'fs % fr -100 -100 % %',
                color,
                ca.width + 200,
                ca.height + 200
            );
        
        } else {
            RG.path2(co, 'fs % fr -100 -100 % %',
                obj.get('clearto'),
                ca.width + 200,
                ca.height + 200
            );
        }
        
        //if (RG.ClearAnnotations) {
            //RG.ClearAnnotations(ca.id);
        //}
        
        /**
        * This removes any background image that may be present
        */
        if (RG.Registry.Get('chart.background.image.' + ca.id)) {
            var img = RG.Registry.Get('chart.background.image.' + ca.id);
            img.style.position = 'absolute';
            img.style.left     = '-10000px';
            img.style.top      = '-10000px';
        }
        
        /**
        * This hides the tooltip that is showing IF it has the same canvas ID as
        * that which is being cleared
        */
        if (RG.Registry.Get('chart.tooltip') && obj && !obj.get('chart.tooltips.nohideonclear')) {
            RG.HideTooltip(ca);
            //RG.Redraw();
        }
                //
        // Hide all DOM text by positioning it outside the canvas
        //
        //for (i in RG.cache) {
        //    if (typeof i === 'string' && i.indexOf('-text-') > 0) {
        //        RG.cache[i].style.left = '-100px';
        //        RG.cache[i].style.top  = '-100px';
        //    }
        //}

        /**
        * Set the cursor to default
        */
        ca.style.cursor = 'default';

        RG.FireCustomEvent(obj, 'onclear');
    };
    
    /**
    * Draws the title of the graph
    * 
    * @param object  canvas The canvas object
    * @param string  text   The title to write
    * @param integer gutter The size of the gutter
    * @param integer        The center X point (optional - if not given it will be generated from the canvas width)
    * @param integer        Size of the text. If not given it will be 14
    * @param object         An optional object which has canvas and context properties to use instead of those on
    *                       the obj argument (so as to enable caching)
    */
    RG.drawTitle =
    RG.DrawTitle = function (obj, text, gutterTop)
    {
        var ca = canvas  = obj.canvas,
            co = context = obj.context,
            prop         = obj.properties
            gutterLeft   = prop['chart.gutter.left'],
            gutterRight  = prop['chart.gutter.right'],
            gutterTop    = gutterTop,
            gutterBottom = prop['chart.gutter.bottom'],
            size         = arguments[4] ? arguments[4] : 12,
            bold         = prop['chart.title.bold'],
            italic       = prop['chart.title.italic'],
            centerx      = (arguments[3] ? arguments[3] : ((ca.width - gutterLeft - gutterRight) / 2) + gutterLeft),
            keypos       = prop['chart.key.position'],
            vpos         = prop['chart.title.vpos'],
            hpos         = prop['chart.title.hpos'],
            bgcolor      = prop['chart.title.background'],
            x            = prop['chart.title.x'],
            y            = prop['chart.title.y'],
            halign       = 'center',
            valign       = 'center'

        // Account for 3D effect by faking the key position
        if (obj.type == 'bar' && prop['chart.variant'] == '3d') {
            keypos = 'gutter';
        }

        co.beginPath();
        co.fillStyle = prop['chart.text.color'] ? prop['chart.text.color'] : 'black';
        

        /**
        * Vertically center the text if the key is not present
        */
        if (keypos && keypos != 'gutter') {
            var valign = 'center';

        } else if (!keypos) {
            var valign = 'center';

       } else {
            var valign = 'bottom';
        }
        

        // if chart.title.vpos is a number, use that
        if (typeof prop['chart.title.vpos'] === 'number') {
            vpos = prop['chart.title.vpos'] * gutterTop;

            if (prop['chart.xaxispos'] === 'top') {
                vpos = prop['chart.title.vpos'] * gutterBottom + gutterTop + (ca.height - gutterTop - gutterBottom);
            }

        } else {
            vpos = gutterTop - size - 5;

            if (prop['chart.xaxispos'] === 'top') {
                vpos = ca.height  - gutterBottom + size + 5;
            }
        }
        
        // if chart.title.hpos is a number, use that. It's multiplied with the (entire) canvas width
        if (typeof hpos === 'number') {
            centerx = hpos * ca.width;
        }

        /**
        * Now the chart.title.x and chart.title.y settings override (is set) the above
        */
        if (typeof x === 'number') centerx = x;
        if (typeof y === 'number') vpos    = y;
        
        /**
        * Horizontal alignment can now (Jan 2013) be specified
        */
        if (typeof prop['chart.title.halign'] === 'string') {
            halign = prop['chart.title.halign'];
        }
        
        /**
        * Vertical alignment can now (Jan 2013) be specified
        */
        if (typeof prop['chart.title.valign'] === 'string') {
            valign = prop['chart.title.valign'];
        }
        
        
        // Set the colour
        if (typeof prop['chart.title.color'] !== null) {
            var oldColor = co.fillStyle
            var newColor = prop['chart.title.color'];
            co.fillStyle = newColor ? newColor : 'black';
        }
        
        /**
        * Default font is Arial
        */
        var font = prop['chart.text.font'];
        
        /**
        * Override the default font with chart.title.font
        */
        if (typeof prop['chart.title.font'] === 'string') {
            font = prop['chart.title.font'];
        }
        
        /**
        * Draw the title
        */

        var ret = RG.text2(obj, {
            font:font,
            size:size,
            x:centerx,
            y:vpos,
            text:text,
            valign:valign,
            halign:halign,
            bounding:bgcolor != null,
            'bounding.fill':bgcolor,
            'bold':bold,
            italic: italic,
            tag:'title',
            marker: false
        });

        // Reset the fill colour
        co.fillStyle = oldColor;
    };
    
    /**
    * Gets the mouse X/Y coordinates relative to the canvas
    * 
    * @param object e The event object. As such this method should be used in an event listener.
    */
    RG.getMouseXY = function(e)
    {
        // This is necessary foe IE9
        if (!e.target) {
            return;
        }

        var el      = e.target;
        var ca      = el;
        var caStyle = ca.style;
        var offsetX = 0;
        var offsetY = 0;
        var x;
        var y;
        var borderLeft  = parseInt(caStyle.borderLeftWidth) || 0;
        var borderTop   = parseInt(caStyle.borderTopWidth) || 0;
        var paddingLeft = parseInt(caStyle.paddingLeft) || 0
        var paddingTop  = parseInt(caStyle.paddingTop) || 0
        var additionalX = borderLeft + paddingLeft;
        var additionalY = borderTop + paddingTop;


        if (typeof e.offsetX === 'number' && typeof e.offsetY === 'number') {
        	

            if (!RG.ISIE && !RG.ISOPERA) {
                x = e.offsetX - borderLeft - paddingLeft;
                y = e.offsetY - borderTop - paddingTop;
            
            } else if (RG.ISIE) {
                x = e.      offsetX - paddingLeft;
                y = e.offsetY - paddingTop;
            
            } else {
                x = e.offsetX;
                y = e.offsetY;
            }   

        } else {

            if (typeof el.offsetParent !== 'undefined') {
                do {
                    offsetX += el.offsetLeft;
                    offsetY += el.offsetTop;
                } while ((el = el.offsetParent));
            }

            x = e.pageX - offsetX - additionalX;
            y = e.pageY - offsetY - additionalY;

            x -= (2 * (parseInt(document.body.style.borderLeftWidth) || 0));
            y -= (2 * (parseInt(document.body.style.borderTopWidth) || 0));

            //x += (parseInt(caStyle.borderLeftWidth) || 0);
            //y += (parseInt(caStyle.borderTopWidth) || 0);
        }

        // We return a javascript array with x and y defined
        return [x, y];
    };
    
    /**
    * This function returns a two element array of the canvas x/y position in
    * relation to the page
    * 
    * @param object canvas
    */
    RG.getCanvasXY = function (canvas)
    {
        var x  = 0;
        var y  = 0;
        var el = canvas; // !!!

        do {

            x += el.offsetLeft;
            y += el.offsetTop;
            
            // ACCOUNT FOR TABLES IN wEBkIT
            if (el.tagName.toLowerCase() == 'table' && (RG.ISCHROME || RG.ISSAFARI)) {
                x += parseInt(el.border) || 0;
                y += parseInt(el.border) || 0;
            }

            el = el.offsetParent;

        } while (el && el.tagName.toLowerCase() != 'body');


        var paddingLeft = canvas.style.paddingLeft ? parseInt(canvas.style.paddingLeft) : 0;
        var paddingTop  = canvas.style.paddingTop ? parseInt(canvas.style.paddingTop) : 0;
        var borderLeft  = canvas.style.borderLeftWidth ? parseInt(canvas.style.borderLeftWidth) : 0;
        var borderTop   = canvas.style.borderTopWidth  ? parseInt(canvas.style.borderTopWidth) : 0;

        if (navigator.userAgent.indexOf('Firefox') > 0) {
            x += parseInt(document.body.style.borderLeftWidth) || 0;
            y += parseInt(document.body.style.borderTopWidth) || 0;
        }

        return [x + paddingLeft + borderLeft, y + paddingTop + borderTop];
    };
    
    /**
    * This function determines whther a canvas is fixed (CSS positioning) or not. If not it returns
    * false. If it is then the element that is fixed is returned (it may be a parent of the canvas).
    * 
    * @return Either false or the fixed positioned element
    */
    RG.isFixed = function (canvas)
    {
        var obj = canvas;
        var i = 0;

        while (obj && obj.tagName.toLowerCase() != 'body' && i < 99) {

            if (obj.style.position == 'fixed') {
                return obj;
            }
            
            obj = obj.offsetParent;
        }

        return false;
    };
    
    /**
    * Registers a graph object (used when the canvas is redrawn)
    * 
    * @param object obj The object to be registered
    */
    RG.register =
    RG.Register = function (obj)
    {
        // Checking this property ensures the object is only registered once
        if (!obj.Get('chart.noregister')) {
            // As of 21st/1/2012 the object registry is now used
            RGraph.ObjectRegistry.Add(obj);
            obj.Set('chart.noregister', true);
        }
    };
    
    /**
    * Causes all registered objects to be redrawn
    * 
    * @param string An optional color to use to clear the canvas
    */
    RG.redraw =
    RG.Redraw = function ()
    {
        var objectRegistry = RGraph.ObjectRegistry.objects.byCanvasID;

        // Get all of the canvas tags on the page
        var tags = document.getElementsByTagName('canvas');

        for (var i=0,len=tags.length; i<len; ++i) {
            if (tags[i].__object__ && tags[i].__object__.isRGraph) {
                
                // Only clear the canvas if it's not Trace'ing - this applies to the Line/Scatter Trace effects
                if (!tags[i].noclear) {
                    RGraph.clear(tags[i], arguments[0] ? arguments[0] : null);
                }
            }
        }

        // Go through the object registry and redraw *all* of the canvas'es that have been registered
        for (var i=0,len=objectRegistry.length; i<len; ++i) {
            if (objectRegistry[i]) {
                var id = objectRegistry[i][0];
                objectRegistry[i][1].Draw();
            }
        }
    };
    
    /**
    * Causes all registered objects ON THE GIVEN CANVAS to be redrawn
    * 
    * @param canvas object The canvas object to redraw
    * @param        bool   Optional boolean which defaults to true and determines whether to clear the canvas
    */
    RG.redrawCanvas =
    RG.RedrawCanvas = function (ca)
    {
        var objects = RG.ObjectRegistry.getObjectsByCanvasID(ca.id);

        /**
        * First clear the canvas
        */
        if (!arguments[1] || (typeof arguments[1] === 'boolean' && !arguments[1] == false) ) {
            var color = arguments[2] || ca.__object__.get('clearto') || 'transparent';
            RG.clear(ca, color);
        }

        /**
        * Now redraw all the charts associated with that canvas
        */
        for (var i=0,len=objects.length; i<len; ++i) {
            if (objects[i]) {
                if (objects[i] && objects[i].isRGraph) { // Is it an RGraph object ??
                    objects[i].Draw();
                }
            }
        }
    };
    
    /**
    * This function draws the background for the bar chart, line chart and scatter chart.
    * 
    * @param  object obj The graph object
    */
    RG.Background.draw =
    RG.background.draw =
    RG.background.Draw = function (obj)
    {
        var ca   = obj.canvas,
            co   = obj.context,
            prop = obj.properties,
            height       = 0,
            gutterLeft   = obj.gutterLeft,
            gutterRight  = obj.gutterRight,
            gutterTop    = obj.gutterTop,
            gutterBottom = obj.gutterBottom,
            variant      = prop['chart.variant']
                

            co.fillStyle = prop['chart.text.color'];
            
            // If it's a bar and 3D variant, translate
            if (variant == '3d') {
                co.save();
                co.translate(prop['chart.variant.threed.offsetx'], -1 * prop['chart.variant.threed.offsety']);
            }
    
            // X axis title
            if (typeof prop['chart.title.xaxis'] === 'string' && prop['chart.title.xaxis'].length) {
            
                var size = prop['chart.text.size'] + 2;
                var font = prop['chart.text.font'];
                var bold = prop['chart.title.xaxis.bold'];
    
                if (typeof(prop['chart.title.xaxis.size']) == 'number') {
                    size = prop['chart.title.xaxis.size'];
                }
    
                if (typeof(prop['chart.title.xaxis.font']) == 'string') {
                    font = prop['chart.title.xaxis.font'];
                }
                
                var hpos = ((ca.width - gutterLeft - gutterRight) / 2) + gutterLeft;
                var vpos = ca.height - gutterBottom + 25;
                
                if (typeof prop['chart.title.xaxis.pos'] === 'number') {
                    vpos = ca.height - (gutterBottom * prop['chart.title.xaxis.pos']);
                }
    
    
    
    
                // Specifically specified X/Y positions
                if (typeof prop['chart.title.xaxis.x'] === 'number') {
                    hpos = prop['chart.title.xaxis.x'];
                }
    
                if (typeof prop['chart.title.xaxis.y'] === 'number') {
                    vpos = prop['chart.title.xaxis.y'];
                }
    
    
    
                RG.text2(prop['chart.text.accessible'] ? obj.context : co,  {
					font:font,
					size:size,
					x:hpos,
					y:vpos,
					text:prop['chart.title.xaxis'],
					halign:'center',
					valign:'center',
					bold:bold,
                    color: prop['chart.title.xaxis.color'] || 'black',
					tag: 'title xaxis'
				});
            }
    
            // Y axis title
            if (typeof(prop['chart.title.yaxis']) == 'string' && prop['chart.title.yaxis'].length) {
    
                var size  = prop['chart.text.size'] + 2;
                var font  = prop['chart.text.font'];
                var angle = 270;
                var bold  = prop['chart.title.yaxis.bold'];
                var color = prop['chart.title.yaxis.color'];
    
                if (typeof(prop['chart.title.yaxis.pos']) == 'number') {
                    var yaxis_title_pos = prop['chart.title.yaxis.pos'] * gutterLeft;
                } else {
                    var yaxis_title_pos = ((gutterLeft - 25) / gutterLeft) * gutterLeft;
                }
    
                if (typeof prop['chart.title.yaxis.size'] === 'number') {
                    size = prop['chart.title.yaxis.size'];
                }
    
                if (typeof prop['chart.title.yaxis.font'] === 'string') {
                    font = prop['chart.title.yaxis.font'];
                }
    
                if (   prop['chart.title.yaxis.align'] == 'right'
                    || prop['chart.title.yaxis.position'] == 'right'
                    || (obj.type === 'hbar' && prop['chart.yaxispos'] === 'right' && typeof prop['chart.title.yaxis.align'] === 'undefined' && typeof prop['chart.title.yaxis.position'] === 'undefined')
                   ) {
    
                    angle = 90;
                    yaxis_title_pos = prop['chart.title.yaxis.pos'] ? (ca.width - gutterRight) + (prop['chart.title.yaxis.pos'] * gutterRight) :
                                                                       ca.width - gutterRight + prop['chart.text.size'] + 5;
                } else {
                    yaxis_title_pos = yaxis_title_pos;
                }
                
                var y = ((ca.height - gutterTop - gutterBottom) / 2) + gutterTop;
                
                // Specifically specified X/Y positions
                if (typeof prop['chart.title.yaxis.x'] === 'number') {
                    yaxis_title_pos = prop['chart.title.yaxis.x'];
                }
    
                if (typeof prop['chart.title.yaxis.y'] === 'number') {
                    y = prop['chart.title.yaxis.y'];
                }

                co.fillStyle = color;
                RG.text2(prop['chart.text.accessible'] ? obj.context : co,  {
					'font':font,
					'size':size,
					'x':yaxis_title_pos,
					'y':y,
					'valign':'center',
					'halign':'center',
					'angle':angle,
					'bold':bold,
					'text':prop['chart.title.yaxis'],
					'tag':'title yaxis',
                    accessible: false
				});
            }
    
            /**
            * If the background color is spec ified - draw that. It's a rectangle that fills the
            * entire area within the gutters
            */
            var bgcolor = prop['chart.background.color'];
            if (bgcolor) {
                co.fillStyle = bgcolor;
                co.fillRect(gutterLeft + 0.5, gutterTop + 0.5, ca.width - gutterLeft - gutterRight, ca.height - gutterTop - gutterBottom);
            }
            



            /**
            * Draw horizontal background bars
            */
            var numbars   = (prop['chart.ylabels.count'] || 5);
            var barHeight = (ca.height - gutterBottom - gutterTop) / numbars;

            co.beginPath();
                co.fillStyle   = prop['chart.background.barcolor1'];
                co.strokeStyle = co.fillStyle;
                height = (ca.height - gutterBottom);

                for (var i=0; i<numbars; i+=2) {
                    co.rect(gutterLeft,
                        (i * barHeight) + gutterTop,
                        ca.width - gutterLeft - gutterRight,
                        barHeight
                    );
                }
            co.fill();
                        co.beginPath();
                co.fillStyle   = prop['chart.background.barcolor2'];
                co.strokeStyle = co.fillStyle;
        
                for (var i=1; i<numbars; i+=2) {
                    co.rect(
                        gutterLeft,
                        (i * barHeight) + gutterTop,
                        ca.width - gutterLeft - gutterRight,
                        barHeight
                    );
                }
            
            co.fill();
            
            // Close any errantly open path
            co.beginPath();
            
            //
            // The background grid is cached
            //
            var func = function (obj, cacheCanvas, cacheContext)
            {
                // Draw the background grid
                if (prop['chart.background.grid']) {
                
                    prop['chart.background.grid.autofit.numhlines'] += 0.0001;
    
                    // If autofit is specified, use the .numhlines and .numvlines along with the width to work
                    // out the hsize and vsize
                    if (prop['chart.background.grid.autofit']) {
    
                        /**
                        * Align the grid to the tickmarks
                        */
                        if (prop['chart.background.grid.autofit.align']) {
    
                            // Align the horizontal lines
                            if (obj.type === 'hbar') {
                                obj.set('chart.background.grid.autofit.numhlines', obj.data.length);
                            }
    
                            // Align the vertical lines for the line
                            if (obj.type === 'line') {
                                if (typeof prop['chart.background.grid.autofit.numvlines'] === 'number') {
                                    // Nada
                                } else if (prop['chart.labels'] && prop['chart.labels'].length) {
                                    obj.Set('chart.background.grid.autofit.numvlines', prop['chart.labels'].length - 1);
                                } else {
                                    obj.Set('chart.background.grid.autofit.numvlines', obj.data[0].length - 1);
                                }
                            } else if (obj.type === 'waterfall') {
                                obj.set(
                                    'backgroundGridAutofitNumvlines',
                                    obj.data.length + (prop['chart.total'] ? 1 : 0)
                                );

                            // Align the vertical lines for the bar, Scatter
                            } else if ( (
                                obj.type === 'bar' ||
                                obj.type === 'scatter'
                                )
                                
                                && (
                                       (prop['chart.labels'] && prop['chart.labels'].length)
                                    || obj.type === 'bar'
                                   )
                            ) {
    
                                var len = (prop['chart.labels'] && prop['chart.labels'].length) || obj.data.length;
    
    
                                obj.set({
                                    backgroundGridAutofitNumvlines: len
                                });
    
                            // Gantt
                            } else if (obj.type === 'gantt') {
    
                                if (typeof obj.get('chart.background.grid.autofit.numvlines') === 'number') {
                                    // Nothing to do here
                                } else {
                                    obj.set('chart.background.grid.autofit.numvlines', prop['chart.xmax']);
                                }
    
                                obj.set('chart.background.grid.autofit.numhlines', obj.data.length);
                            
                            // HBar
                            } else if (obj.type === 'hbar' && RG.isNull(prop['chart.background.grid.autofit.numhlines']) ) {
                                obj.set('chart.background.grid.autofit.numhlines', obj.data.length);
                            }
                        }
    
                        var vsize = ((cacheCanvas.width - gutterLeft - gutterRight)) / prop['chart.background.grid.autofit.numvlines'];
                        var hsize = (cacheCanvas.height - gutterTop - gutterBottom) / prop['chart.background.grid.autofit.numhlines'];
    
                        obj.Set('chart.background.grid.vsize', vsize);
                        obj.Set('chart.background.grid.hsize', hsize);
                    }
    
                    co.beginPath();
                    cacheContext.lineWidth   = prop['chart.background.grid.width'] ? prop['chart.background.grid.width'] : 1;
                    cacheContext.strokeStyle = prop['chart.background.grid.color'];

                    // Dashed background grid
                    if (prop['chart.background.grid.dashed'] && typeof cacheContext.setLineDash == 'function') {
                        cacheContext.setLineDash([3,5]);
                    }
                    
                    // Dotted background grid
                    if (prop['chart.background.grid.dotted'] && typeof cacheContext.setLineDash == 'function') {
                        cacheContext.setLineDash([1,3]);
                    }
                    
                    co.beginPath();
        
        
                    // Draw the horizontal lines
                    if (prop['chart.background.grid.hlines']) {
                        height = (cacheCanvas.height - gutterBottom)
                        var hsize = prop['chart.background.grid.hsize'];
                        for (y=gutterTop; y<=height; y+=hsize) {
                            cacheContext.moveTo(gutterLeft, ma.round(y));
                            cacheContext.lineTo(ca.width - gutterRight, ma.round(y));
                        }
                    }
        
                    if (prop['chart.background.grid.vlines']) {
                        // Draw the vertical lines
                        var width = (cacheCanvas.width - gutterRight);
                        var vsize = prop['chart.background.grid.vsize'];

                        for (x=gutterLeft; ma.round(x)<=width; x+=vsize) {
                            cacheContext.moveTo(ma.round(x), gutterTop);
                            cacheContext.lineTo(ma.round(x), ca.height - gutterBottom);
                        }
                    }
        
                    if (prop['chart.background.grid.border']) {
                        // Make sure a rectangle, the same colour as the grid goes around the graph
                        cacheContext.strokeStyle = prop['chart.background.grid.color'];
                        cacheContext.strokeRect(ma.round(gutterLeft), ma.round(gutterTop), ca.width - gutterLeft - gutterRight, ca.height - gutterTop - gutterBottom);
                    }
                }
    
                cacheContext.stroke();
    
    
    
                // Ensure the grids drawn before continuing
                cacheContext.beginPath();
                cacheContext.closePath();
            }
            
            // Now a cached draw in newer browsers
            RG.cachedDraw(obj, obj.uid + '_background', func);
            
            // If it's a bar and 3D variant, translate
            if (variant == '3d') {
                co.restore();
            }

            // Reset the line dash
            if (typeof co.setLineDash == 'function') {
                co.setLineDash([1,0]);
            }
    
            co.stroke();
                    // Draw the title if one is set
        if ( typeof(obj.properties['chart.title']) == 'string') {

            var prop = obj.properties;

            RG.drawTitle(
                obj,
                prop['chart.title'],
                obj.gutterTop,
                null,
                prop['chart.title.size'] ? prop['chart.title.size'] : prop['chart.text.size'] + 2,
                obj
            );
        }
    };
    
    /**
    * Formats a number with thousand seperators so it's easier to read
    * 
    * @param  integer obj The chart object
    * @param  integer num The number to format
    * @param  string      The (optional) string to prepend to the string
    * @param  string      The (optional) string to append to the string
    * @return string      The formatted number
    */
    RG.numberFormat =
    RG.number_format = function (obj, num)
    {
        var ca   = obj.canvas;
        var co   = obj.context;
        var prop = obj.properties;

        var i;
        var prepend = arguments[2] ? String(arguments[2]) : '';
        var append  = arguments[3] ? String(arguments[3]) : '';
        var output  = '';
        var decimal = '';
        var decimal_seperator  = typeof prop['chart.scale.point'] == 'string' ? prop['chart.scale.point'] : '.';
        var thousand_seperator = typeof prop['chart.scale.thousand'] == 'string' ? prop['chart.scale.thousand'] : ',';
        RegExp.$1   = '';
        var i,j;

        if (typeof prop['chart.scale.formatter'] === 'function') {
            return prop['chart.scale.formatter'](obj, num);
        }

        // Ignore the preformatted version of "1e-2"
        if (String(num).indexOf('e') > 0) {
            return String(prepend + String(num) + append);
        }

        // We need then number as a string
        num = String(num);
        
        // Take off the decimal part - we re-append it later
        if (num.indexOf('.') > 0) {
            var tmp = num;
            num     = num.replace(/\.(.*)/, ''); // The front part of the number
            decimal = tmp.replace(/(.*)\.(.*)/, '$2'); // The decimal part of the number
        }

        // Thousand seperator
        //var seperator = arguments[1] ? String(arguments[1]) : ',';
        var seperator = thousand_seperator;
        
        /**
        * Work backwards adding the thousand seperators
        */
        var foundPoint;
        for (i=(num.length - 1),j=0; i>=0; j++,i--) {
            var character = num.charAt(i);
            
            if ( j % 3 == 0 && j != 0) {
                output += seperator;
            }
            
            /**
            * Build the output
            */
            output += character;
        }
        
        /**
        * Now need to reverse the string
        */
        var rev = output;
        output = '';
        for (i=(rev.length - 1); i>=0; i--) {
            output += rev.charAt(i);
        }

        // Tidy up
        //output = output.replace(/^-,/, '-');
        if (output.indexOf('-' + prop['chart.scale.thousand']) == 0) {
            output = '-' + output.substr(('-' + prop['chart.scale.thousand']).length);
        }

        // Reappend the decimal
        if (decimal.length) {
            output =  output + decimal_seperator + decimal;
            decimal = '';
            RegExp.$1 = '';
        }

        // Minor bugette
        if (output.charAt(0) == '-') {
            output = output.replace(/-/, '');
            prepend = '-' + prepend;
        }

        return prepend + output + append;
    };
    
    /**
    * Draws horizontal coloured bars on something like the bar, line or scatter
    */
    RG.drawBars =
    RG.DrawBars = function (obj)
    {
        var prop  = obj.properties;
        var co    = obj.context;
        var ca    = obj.canvas;
        var hbars = prop['chart.background.hbars'];

        if (hbars === null) {
            return;
        }

        /**
        * Draws a horizontal bar
        */
        co.beginPath();

        for (i=0,len=hbars.length; i<len; ++i) {
        
            var start  = hbars[i][0];
            var length = hbars[i][1];
            var color  = hbars[i][2];
            

            // Perform some bounds checking
            if(RG.is_null(start))start = obj.scale2.max
            if (start > obj.scale2.max) start = obj.scale2.max;
            if (RG.is_null(length)) length = obj.scale2.max - start;
            if (start + length > obj.scale2.max) length = obj.scale2.max - start;
            if (start + length < (-1 * obj.scale2.max) ) length = (-1 * obj.scale2.max) - start;

            if (prop['chart.xaxispos'] == 'center' && start == obj.scale2.max && length < (obj.scale2.max * -2)) {
                length = obj.scale2.max * -2;
            }


            /**
            * Draw the bar
            */
            var x = prop['chart.gutter.left'];
            var y = obj.getYCoord(start);
            var w = ca.width - prop['chart.gutter.left'] - prop['chart.gutter.right'];
            var h = obj.getYCoord(start + length) - y;

            // Accommodate Opera :-/
            if (RG.ISOPERA != -1 && prop['chart.xaxispos'] == 'center' && h < 0) {
                h *= -1;
                y = y - h;
            }

            /**
            * Account for X axis at the top
            */
            if (prop['chart.xaxispos'] == 'top') {
                y  = ca.height - y;
                h *= -1;
            }

            co.fillStyle = color;
            co.fillRect(x, y, w, h);
        }
/*


            


            // If the X axis is at the bottom, and a negative max is given, warn the user
            if (obj.Get('chart.xaxispos') == 'bottom' && (hbars[i][0] < 0 || (hbars[i][1] + hbars[i][1] < 0)) ) {
                alert('[' + obj.type.toUpperCase() + ' (ID: ' + obj.id + ') BACKGROUND HBARS] You have a negative value in one of your background hbars values, whilst the X axis is in the center');
            }

            var ystart = (obj.grapharea - (((hbars[i][0] - obj.scale2.min) / (obj.scale2.max - obj.scale2.min)) * obj.grapharea));
            //var height = (Math.min(hbars[i][1], obj.max - hbars[i][0]) / (obj.scale2.max - obj.scale2.min)) * obj.grapharea;
            var height = obj.getYCoord(hbars[i][0]) - obj.getYCoord(hbars[i][1]);

            // Account for the X axis being in the center
            if (obj.Get('chart.xaxispos') == 'center') {
                ystart /= 2;
                //height /= 2;
            }
            
            ystart += obj.Get('chart.gutter.top')

            var x = obj.Get('chart.gutter.left');
            var y = ystart - height;
            var w = obj.canvas.width - obj.Get('chart.gutter.left') - obj.Get('chart.gutter.right');
            var h = height;

            // Accommodate Opera :-/
            if (navigator.userAgent.indexOf('Opera') != -1 && obj.Get('chart.xaxispos') == 'center' && h < 0) {
                h *= -1;
                y = y - h;
            }
            
            /**
            * Account for X axis at the top
            */
            //if (obj.Get('chart.xaxispos') == 'top') {
            //    y  = obj.canvas.height - y;
            //    h *= -1;
            //}

            //obj.context.fillStyle = hbars[i][2];
            //obj.context.fillRect(x, y, w, h);
        //}
    };
    
    /**
    * Draws in-graph labels.
    * 
    * @param object obj The graph object
    */
    RG.drawInGraphLabels =
    RG.DrawInGraphLabels = function (obj)
    {
        var ca      = obj.canvas,
            co      = obj.context,
            prop    = obj.properties,
            labels  = prop['chart.labels.ingraph'],
            labels_processed = [];

        // Defaults
        var fgcolor   = 'black',
            bgcolor   = 'white',
            direction = 1;

        if (!labels) {
            return;
        }

        /**
        * Preprocess the labels array. Numbers are expanded
        */
        for (var i=0,len=labels.length; i<len; i+=1) {
            if (typeof labels[i] === 'number') {
                for (var j=0; j<labels[i]; ++j) {
                    labels_processed.push(null);
                }
            } else if (typeof labels[i] === 'string' || typeof labels[i] === 'object') {
                labels_processed.push(labels[i]);
            
            } else {
                labels_processed.push('');
            }
        }
        

        /**
        * Turn off any shadow
        */
        RG.noShadow(obj);
        

        if (labels_processed && labels_processed.length > 0) {

            for (var i=0,len=labels_processed.length; i<len; i+=1) {
                if (labels_processed[i]) {
                    var coords = obj.coords[i];
                    
                    if (coords && coords.length > 0) {
                        var x      = (obj.type == 'bar' ? coords[0] + (coords[2] / 2) : coords[0]);
                        var y      = (obj.type == 'bar' ? coords[1] + (coords[3] / 2) : coords[1]);
                        var length = typeof labels_processed[i][4] === 'number' ? labels_processed[i][4] : 25;
    
                        co.beginPath();
                        co.fillStyle   = 'black';
                        co.strokeStyle = 'black';
                        
    
                        if (obj.type === 'bar') {
                        
                            /**
                            * X axis at the top
                            */
                            if (obj.Get('chart.xaxispos') == 'top') {
                                length *= -1;
                            }
    
                            if (prop['chart.variant'] == 'dot') {
                                co.moveTo(ma.round(x), obj.coords[i][1] - 5);
                                co.lineTo(ma.round(x), obj.coords[i][1] - 5 - length);
                                
                                var text_x = ma.round(x);
                                var text_y = obj.coords[i][1] - 5 - length;
                            
                            } else if (prop['chart.variant'] == 'arrow') {
                                co.moveTo(ma.round(x), obj.coords[i][1] - 5);
                                co.lineTo(ma.round(x), obj.coords[i][1] - 5 - length);
                                
                                var text_x = ma.round(x);
                                var text_y = obj.coords[i][1] - 5 - length;
                            
                            } else {
    
                                co.arc(ma.round(x), y, 2.5, 0, 6.28, 0);
                                co.moveTo(ma.round(x), y);
                                co.lineTo(ma.round(x), y - length);

                                var text_x = ma.round(x);
                                var text_y = y - length;
                            }

                            co.stroke();
                            co.fill();
                            
    
                        } else {

                            if (
                                typeof labels_processed[i] == 'object' &&
                                typeof labels_processed[i][3] == 'number' &&
                                labels_processed[i][3] == -1
                               ) {

                                // Draw an up arrow
                                drawUpArrow(x, y)
                                var valign = 'top';
                                
                                var text_x = x;
                                var text_y = y + 5 + length;
                            
                            } else {

                                var text_x = x;
                                var text_y = y - 5 - length;

                                if (text_y < 5 && (typeof labels_processed[i] === 'string' || typeof labels_processed[i][3] === 'undefined')) {
                                    text_y = y + 5 + length;
                                    var valign = 'top';
                                }

                                if (valign === 'top') {
                                    /// Draw an down arrow
                                    drawUpArrow(x, y);
                                } else {
                                    /// Draw an up arrow
                                    drawDownArrow(x, y);
                                }
                            }
                        
                            co.fill();
                        }

                        co.beginPath();
                            
                            // Foreground color
                            co.fillStyle = (typeof labels_processed[i] === 'object' && typeof labels_processed[i][1] === 'string') ? labels_processed[i][1] : 'black';

                            RG.text2(obj,{
                                font:            prop['chart.text.font'],
                                size:            prop['chart.text.size'],
                                x:               text_x,
                                y:               text_y + (obj.properties['chart.text.accessible'] ? 2 : 0),
                                text:            (typeof labels_processed[i] === 'object' && typeof labels_processed[i][0] === 'string') ? labels_processed[i][0] : labels_processed[i],
                                valign:          valign || 'bottom',
                                halign:          'center',
                                bounding:        true,
                                'bounding.fill': (typeof labels_processed[i] === 'object' && typeof labels_processed[i][2] === 'string') ? labels_processed[i][2] : 'white',
                                tag:             'labels ingraph'
                            });
                        co.fill();
                    }
                    
                    // Draws a down arrow
                    function drawUpArrow (x, y)
                    {
                        co.moveTo(ma.round(x), y + 5);
                        co.lineTo(ma.round(x), y + 5 + length);
                        
                        co.stroke();
                        co.beginPath();                                
                        
                        // This draws the arrow
                        co.moveTo(ma.round(x), y + 5);
                        co.lineTo(ma.round(x) - 3, y + 10);
                        co.lineTo(ma.round(x) + 3, y + 10);
                        co.closePath();
                    }
                    
                    // Draw an up arrow
                    function drawDownArrow (x, y)
                    {
                        co.moveTo(ma.round(x), y - 5);
                        co.lineTo(ma.round(x), y - 5 - length);
                        
                        co.stroke();
                        co.beginPath();
                        
                        // This draws the arrow
                        co.moveTo(ma.round(x), y - 5);
                        co.lineTo(ma.round(x) - 3, y - 10);
                        co.lineTo(ma.round(x) + 3, y - 10);
                        co.closePath();
                    }
                    
                    valign = undefined;
                }
            }
        }
    };
    
    /**
    * This function "fills in" key missing properties that various implementations lack
    * 
    * @param object e The event object
    */
    RG.fixEventObject =
    RG.FixEventObject = function (e)
    {
        if (RG.ISOLD) {
            var e = event;

            e.pageX  = (event.clientX + doc.body.scrollLeft);
            e.pageY  = (event.clientY + doc.body.scrollTop);
            e.target = event.srcElement;
            
            if (!doc.body.scrollTop && doc.documentElement.scrollTop) {
                e.pageX += parseInt(doc.documentElement.scrollLeft);
                e.pageY += parseInt(doc.documentElement.scrollTop);
            }
        }

        
        // Any browser that doesn't implement stopPropagation() (MSIE)
        if (!e.stopPropagation) {
            e.stopPropagation = function () {window.event.cancelBubble = true;}
        }
        
        return e;
    };
    
    /**
    * Thisz function hides the crosshairs coordinates
    */
    RG.hideCrosshairCoords =
    RG.HideCrosshairCoords = function ()
    {
        var div = RG.Registry.Get('chart.coordinates.coords.div');

        if (   div
            && div.style.opacity == 1
            && div.__object__.Get('chart.crosshairs.coords.fadeout')
           ) {
            
            var style = RG.Registry.Get('chart.coordinates.coords.div').style;

            setTimeout(function() {style.opacity = 0.9;}, 25);
            setTimeout(function() {style.opacity = 0.8;}, 50);
            setTimeout(function() {style.opacity = 0.7;}, 75);
            setTimeout(function() {style.opacity = 0.6;}, 100);
            setTimeout(function() {style.opacity = 0.5;}, 125);
            setTimeout(function() {style.opacity = 0.4;}, 150);
            setTimeout(function() {style.opacity = 0.3;}, 175);
            setTimeout(function() {style.opacity = 0.2;}, 200);
            setTimeout(function() {style.opacity = 0.1;}, 225);
            setTimeout(function() {style.opacity = 0;}, 250);
            setTimeout(function() {style.display = 'none';}, 275);
        }
    };
    
    /**
    * Draws the3D axes/background
    * 
    * @param object obj The chart object
    */
    RG.draw3DAxes =
    RG.Draw3DAxes = function (obj)
    {
        var prop = obj.properties,
            co   = obj.context,
            ca   = obj.canvas;

        var gutterLeft    = obj.gutterLeft,
            gutterRight   = obj.gutterRight,
            gutterTop     = obj.gutterTop,
            gutterBottom  = obj.gutterBottom,
            xaxispos      = prop['chart.xaxispos'],
            graphArea     = ca.height - gutterTop - gutterBottom,
            halfGraphArea = graphArea / 2,
            offsetx       = prop['chart.variant.threed.offsetx'],
            offsety       = prop['chart.variant.threed.offsety'],
            xaxis         = prop['chart.variant.threed.xaxis'],
            yaxis         = prop['chart.variant.threed.yaxis']
        

        //
        // Draw the 3D Y axis
        //
        if (yaxis) {
            RG.draw3DYAxis(obj);
        }
        
        
        
        // X axis
        if (xaxis) {
            if (xaxispos === 'center') {
                RG.path2(
                    co,
                    'b m % % l % % l % % l % % c s #aaa f #ddd',
                    gutterLeft,gutterTop + halfGraphArea,
                    gutterLeft + offsetx,gutterTop + halfGraphArea - offsety,
                    ca.width - gutterRight + offsetx,gutterTop + halfGraphArea - offsety,
                    ca.width - gutterRight,gutterTop + halfGraphArea
                );

            } else {
            
                if (obj.type === 'hbar') {
                    var xaxisYCoord = obj.canvas.height - obj.properties['chart.gutter.bottom'];
                } else {
                    var xaxisYCoord = obj.getYCoord(0);
                }

                RG.path2(
                    co,
                    'm % % l % % l % % l % % c s #aaa f #ddd',
                    gutterLeft,xaxisYCoord,
                    gutterLeft + offsetx,xaxisYCoord - offsety,
                    ca.width - gutterRight + offsetx,xaxisYCoord - offsety,
                    ca.width - gutterRight,xaxisYCoord
                );
            }
        }
    };
    
    /**
    * Draws the3D Y axis/background
    * 
    * @param object obj The chart object
    */
    RG.draw3DYAxis = function (obj)
    {
        var prop = obj.properties,
            co   = obj.context,
            ca   = obj.canvas;

        var gutterLeft    = obj.gutterLeft,
            gutterRight   = obj.gutterRight,
            gutterTop     = obj.gutterTop,
            gutterBottom  = obj.gutterBottom,
            xaxispos      = prop['chart.xaxispos'],
            graphArea     = ca.height - gutterTop - gutterBottom,
            halfGraphArea = graphArea / 2,
            offsetx       = prop['chart.variant.threed.offsetx'],
            offsety       = prop['chart.variant.threed.offsety']

        
        
        // Y axis
        // Commented out the if condition because of drawing oddities
        //if (!prop['chart.noaxes'] && !prop['chart.noyaxis']) {

            if ( (obj.type === 'hbar' || obj.type === 'bar') && prop['chart.yaxispos'] === 'center') {
                var x = ((ca.width - gutterLeft - gutterRight) / 2) + gutterLeft;
            } else if ((obj.type === 'hbar' || obj.type === 'bar') && prop['chart.yaxispos'] === 'right') {
                var x = ca.width - gutterRight;
            } else {
                var x = gutterLeft;
            }

            RG.path2(
                co,
                'b m % % l % % l % % l % % s #aaa f #ddd',
                x,gutterTop,
                x + offsetx,gutterTop - offsety,
                x + offsetx,ca.height - gutterBottom - offsety,
                x,ca.height - gutterBottom
            );
        //}
    };
    
    /**
    * Draws a rectangle with curvy corners
    * 
    * @param co object The context
    * @param x number The X coordinate (top left of the square)
    * @param y number The Y coordinate (top left of the square)
    * @param w number The width of the rectangle
    * @param h number The height of the rectangle
    * @param   number The radius of the curved corners
    * @param   boolean Whether the top left corner is curvy
    * @param   boolean Whether the top right corner is curvy
    * @param   boolean Whether the bottom right corner is curvy
    * @param   boolean Whether the bottom left corner is curvy
    */
    RG.strokedCurvyRect = function (co, x, y, w, h)
    {
        // The corner radius
        var r = arguments[5] ? arguments[5] : 3;

        // The corners
        var corner_tl = (arguments[6] || arguments[6] == null) ? true : false;
        var corner_tr = (arguments[7] || arguments[7] == null) ? true : false;
        var corner_br = (arguments[8] || arguments[8] == null) ? true : false;
        var corner_bl = (arguments[9] || arguments[9] == null) ? true : false;

        co.beginPath();

            // Top left side
            co.moveTo(x + (corner_tl ? r : 0), y);
            co.lineTo(x + w - (corner_tr ? r : 0), y);
            
            // Top right corner
            if (corner_tr) {
                co.arc(x + w - r, y + r, r, RG.PI + RG.HALFPI, RG.TWOPI, false);
            }

            // Top right side
            co.lineTo(x + w, y + h - (corner_br ? r : 0) );

            // Bottom right corner
            if (corner_br) {
                co.arc(x + w - r, y - r + h, r, RG.TWOPI, RG.HALFPI, false);
            }

            // Bottom right side
            co.lineTo(x + (corner_bl ? r : 0), y + h);

            // Bottom left corner
            if (corner_bl) {
                co.arc(x + r, y - r + h, r, RG.HALFPI, RG.PI, false);
            }

            // Bottom left side
            co.lineTo(x, y + (corner_tl ? r : 0) );

            // Top left corner
            if (corner_tl) {
                co.arc(x + r, y + r, r, RG.PI, RG.PI + RG.HALFPI, false);
            }

        co.stroke();
    };
    
    /**
    * Draws a filled rectangle with curvy corners
    * 
    * @param context object The context
    * @param x       number The X coordinate (top left of the square)
    * @param y       number The Y coordinate (top left of the square)
    * @param w       number The width of the rectangle
    * @param h       number The height of the rectangle
    * @param         number The radius of the curved corners
    * @param         boolean Whether the top left corner is curvy
    * @param         boolean Whether the top right corner is curvy
    * @param         boolean Whether the bottom right corner is curvy
    * @param         boolean Whether the bottom left corner is curvy
    */
    RG.filledCurvyRect = function (co, x, y, w, h)
    {
        // The corner radius
        var r = arguments[5] ? arguments[5] : 3;

        // The corners
        var corner_tl = (arguments[6] || arguments[6] == null) ? true : false;
        var corner_tr = (arguments[7] || arguments[7] == null) ? true : false;
        var corner_br = (arguments[8] || arguments[8] == null) ? true : false;
        var corner_bl = (arguments[9] || arguments[9] == null) ? true : false;

        co.beginPath();

            // First draw the corners

            // Top left corner
            if (corner_tl) {
                co.moveTo(x + r, y + r);
                co.arc(x + r, y + r, r, RG.PI, RG.PI + RG.HALFPI, false);
            } else {
                co.fillRect(x, y, r, r);
            }

            // Top right corner
            if (corner_tr) {
                co.moveTo(x + w - r, y + r);
                co.arc(x + w - r, y + r, r, RG.PI + RG.HALFPI, 0, false);
            } else {
                co.moveTo(x + w - r, y);
                co.fillRect(x + w - r, y, r, r);
            }


            // Bottom right corner
            if (corner_br) {
                co.moveTo(x + w - r, y + h - r);
                co.arc(x + w - r, y - r + h, r, 0, RG.HALFPI, false);
            } else {
                co.moveTo(x + w - r, y + h - r);
                co.fillRect(x + w - r, y + h - r, r, r);
            }

            // Bottom left corner
            if (corner_bl) {
                co.moveTo(x + r, y + h - r);
                co.arc(x + r, y - r + h, r, RG.HALFPI, RG.PI, false);
            } else {
                co.moveTo(x, y + h - r);
                co.fillRect(x, y + h - r, r, r);
            }

            // Now fill it in
            co.fillRect(x + r, y, w - r - r, h);
            co.fillRect(x, y + r, r + 1, h - r - r);
            co.fillRect(x + w - r - 1, y + r, r + 1, h - r - r);

        co.fill();
    };
    
    /**
    * Hides the zoomed canvas
    */
    RG.hideZoomedCanvas =
    RG.HideZoomedCanvas = function ()
    {
        var interval = 10;
        var frames   = 15;

        if (typeof RG.zoom_image === 'object') {
            var obj  = RG.zoom_image.obj;
            var prop = obj.properties;
        } else {
            return;
        }

        if (prop['chart.zoom.fade.out']) {
            for (var i=frames,j=1; i>=0; --i, ++j) {
                if (typeof RG.zoom_image === 'object') {
                    setTimeout("RGraph.zoom_image.style.opacity = " + String(i / 10), j * interval);
                }
            }

            if (typeof RG.zoom_background === 'object') {
                setTimeout("RGraph.zoom_background.style.opacity = " + String(i / frames), j * interval);
            }
        }

        if (typeof RG.zoom_image === 'object') {
            setTimeout("RGraph.zoom_image.style.display = 'none'", prop['chart.zoom.fade.out'] ? (frames * interval) + 10 : 0);
        }

        if (typeof RG.zoom_background === 'object') {
            setTimeout("RGraph.zoom_background.style.display = 'none'", prop['chart.zoom.fade.out'] ? (frames * interval) + 10 : 0);
        }
    };
    
    /**
    * Adds an event handler
    * 
    * @param object obj   The graph object
    * @param string event The name of the event, eg ontooltip
    * @param object func  The callback function
    */
    RG.addCustomEventListener =
    RG.AddCustomEventListener = function (obj, name, func)
    {
        // Initialise the events array if necessary
        if (typeof RG.events[obj.uid] === 'undefined') {
            RG.events[obj.uid] = [];
        }
        
        // Prepend "on" if necessary
        if (name.substr(0, 2) !== 'on') {
            name = 'on' + name;
        }

        RG.events[obj.uid].push([obj, name, func]);

        return RG.events[obj.uid].length - 1;
    };
    
    /**
    * Used to fire one of the RGraph custom events
    * 
    * @param object obj   The graph object that fires the event
    * @param string event The name of the event to fire
    */
    RG.fireCustomEvent =
    RG.FireCustomEvent = function (obj, name)
    {
        if (obj && obj.isRGraph) {
        
            // This allows the eventsMouseout property to work
            // (for some reason...)
            if (name.match(/(on)?mouseout/) && typeof obj.properties['chart.events.mouseout'] === 'function') {
                (obj.properties['chart.events.mouseout'])(obj);
            }
        
            // DOM1 style of adding custom events
            if (obj[name]) {
                (obj[name])(obj);
            }
            
            var uid = obj.uid;

            if (   typeof uid === 'string'
                && typeof RG.events === 'object'
                && typeof RG.events[uid] === 'object'
                && RG.events[uid].length > 0) {

                for(var j=0; j<RG.events[uid].length; ++j) {
                    if (RG.events[uid][j] && RG.events[uid][j][1] === name) {
                        RG.events[uid][j][2](obj);
                    }
                }
            }
        }
    };
    
    /**
    * Clears all the custom event listeners that have been registered
    * 
    * @param    string Limits the clearing to this object ID
    */
    RGraph.removeAllCustomEventListeners =
    RGraph.RemoveAllCustomEventListeners = function ()
    {
        var id = arguments[0];

        if (id && RG.events[id]) {
            RG.events[id] = [];
        } else {
            RG.events = [];
        }
    };
    
    /**
    * Clears a particular custom event listener
    * 
    * @param object obj The graph object
    * @param number i   This is the index that is return by .AddCustomEventListener()
    */
    RG.removeCustomEventListener =
    RG.RemoveCustomEventListener = function (obj, i)
    {
        if (   typeof RG.events === 'object'
            && typeof RG.events[obj.id] === 'object'
            && typeof RG.events[obj.id][i] === 'object') {
            
            RG.events[obj.id][i] = null;
        }
    };
    
    /**
    * This draws the background
    * 
    * @param object obj The graph object
    */
    RG.drawBackgroundImage =
    RG.DrawBackgroundImage = function (obj)
    {
        var prop = obj.properties;
        var ca   = obj.canvas;
        var co   = obj.context;

        if (typeof prop['chart.background.image'] === 'string') {
            if (typeof ca.__rgraph_background_image__ === 'undefined') {
                var img = new Image();
                img.__object__  = obj;
                img.__canvas__  = ca;
                img.__context__ = co;
                img.src         = obj.Get('chart.background.image');
                
                ca.__rgraph_background_image__ = img;
            } else {
                img = ca.__rgraph_background_image__;
            }

            // When the image has loaded - redraw the canvas
            img.onload = function ()
            {
                obj.__rgraph_background_image_loaded__ = true;
                RG.clear(ca);
                RG.redrawCanvas(ca);
            }
                
            var gutterLeft   = obj.gutterLeft;
            var gutterRight  = obj.gutterRight;
            var gutterTop    = obj.gutterTop;
            var gutterBottom = obj.gutterBottom;
            var stretch      = prop['chart.background.image.stretch'];
            var align        = prop['chart.background.image.align'];
    
            // Handle chart.background.image.align
            if (typeof align === 'string') {
                if (align.indexOf('right') != -1) {
                    var x = ca.width - (prop['chart.background.image.w'] || img.width) - gutterRight;
                } else {
                    var x = gutterLeft;
                }
    
                if (align.indexOf('bottom') != -1) {
                    var y = ca.height - (prop['chart.background.image.h'] || img.height) - gutterBottom;
                } else {
                    var y = gutterTop;
                }
            } else {
                var x = gutterLeft || 25;
                var y = gutterTop || 25;
            }

            // X/Y coords take precedence over the align
            var x = typeof prop['chart.background.image.x'] === 'number' ? prop['chart.background.image.x'] : x;
            var y = typeof prop['chart.background.image.y'] === 'number' ? prop['chart.background.image.y'] : y;
            var w = stretch ? ca.width - gutterLeft - gutterRight : img.width;
            var h = stretch ? ca.height - gutterTop - gutterBottom : img.height;
            
            /**
            * You can now specify the width and height of the image
            */
            if (typeof prop['chart.background.image.w'] === 'number') w  = prop['chart.background.image.w'];
            if (typeof prop['chart.background.image.h'] === 'number') h = prop['chart.background.image.h'];

            var oldAlpha = co.globalAlpha;
                co.globalAlpha = prop['chart.background.image.alpha'];
                co.drawImage(img,x,y,w, h);
            co.globalAlpha = oldAlpha;
        }
    };
    
    /**
    * This function determines wshether an object has tooltips or not
    * 
    * @param object obj The chart object
    */
    RG.hasTooltips = function (obj)
    {
        var prop = obj.properties;

        if (typeof prop['chart.tooltips'] == 'object' && prop['chart.tooltips']) {
            for (var i=0,len=prop['chart.tooltips'].length; i<len; ++i) {
                if (!RG.is_null(obj.Get('chart.tooltips')[i])) {
                    return true;
                }
            }
        } else if (typeof prop['chart.tooltips'] === 'function') {
            return true;
        }
        
        return false;
    };
    
    /**
    * This function creates a (G)UID which can be used to identify objects.
    * 
    * @return string (g)uid The (G)UID
    */
    RG.createUID =
    RG.CreateUID = function ()
    {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c)
        {
            var r = ma.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
            return v.toString(16);
        });
    };
        /**
    * This is the new object registry, used to facilitate multiple objects per canvas.
    * 
    * @param object obj The object to register
    */
    RG.OR.add =
    RG.OR.Add = function (obj)
    {
        var uid = obj.uid;
        var id  = obj.canvas.id;

        /**
        * Index the objects by UID
        */
        RG.ObjectRegistry.objects.byUID.push([uid, obj]);
        
        /**
        * Index the objects by the canvas that they're drawn on
        */
        RG.ObjectRegistry.objects.byCanvasID.push([id, obj]);
    };
    
    /**
    * Remove an object from the object registry
    * 
    * @param object obj The object to remove.
    */
    RG.OR.remove =
    RG.OR.Remove = function (obj)
    {
        var id  = obj.id;
        var uid = obj.uid;

        for (var i=0; i<RG.ObjectRegistry.objects.byUID.length; ++i) {
            if (RG.ObjectRegistry.objects.byUID[i] && RG.ObjectRegistry.objects.byUID[i][1].uid == uid) {
                RG.ObjectRegistry.objects.byUID[i] = null;
            }
        }


        for (var i=0; i<RG.ObjectRegistry.objects.byCanvasID.length; ++i) {
            if (   RG.ObjectRegistry.objects.byCanvasID[i]
                && RG.ObjectRegistry.objects.byCanvasID[i][1]
                && RG.ObjectRegistry.objects.byCanvasID[i][1].uid == uid) {
                
                RG.ObjectRegistry.objects.byCanvasID[i] = null;
            }
        }
    };
    
    /**
    * Removes all objects from the ObjectRegistry. If either the ID of a canvas is supplied,
    * or the canvas itself, then only objects pertaining to that canvas are cleared.
    * 
    * @param mixed   Either a canvas object (as returned by document.getElementById()
    *                or the ID of a canvas (ie a string)
    */
    RG.OR.clear =
    RG.OR.Clear = function ()
    {
        // If an ID is supplied restrict the learing to that
        if (arguments[0]) {
            var id      = (typeof arguments[0] === 'object' ? arguments[0].id : arguments[0]);
            var objects = RG.ObjectRegistry.getObjectsByCanvasID(id);

            for (var i=0,len=objects.length; i<len; ++i) {
                RG.ObjectRegistry.remove(objects[i]);
            }

        } else {

            RG.ObjectRegistry.objects            = {};
            RG.ObjectRegistry.objects.byUID      = [];
            RG.ObjectRegistry.objects.byCanvasID = [];
        }
    };
    
    /**
    * Lists all objects in the ObjectRegistry
    * 
    * @param boolean ret Whether to return the list or alert() it
    */
    RG.OR.list =
    RG.OR.List = function ()
    {
        var list = [];

        for (var i=0,len=RG.ObjectRegistry.objects.byUID.length; i<len; ++i) {
            if (RG.ObjectRegistry.objects.byUID[i]) {
                list.push(RG.ObjectRegistry.objects.byUID[i][1].type);
            }
        }
        
        if (arguments[0]) {
            return list;
        } else {
            $p(list);
        }
    };
    
    /**
    * Clears the ObjectRegistry of objects that are of a certain given type
    * 
    * @param type string The type to clear
    */
    RG.OR.clearByType =
    RG.OR.ClearByType = function (type)
    {
        var objects = RG.ObjectRegistry.objects.byUID;

        for (var i=0,len=objects.length; i<len; ++i) {
            if (objects[i]) {
                var uid = objects[i][0];
                var obj = objects[i][1];
                
                if (obj && obj.type == type) {
                    RG.ObjectRegistry.remove(obj);
                }
            }
        }
    };
    
    /**
    * This function provides an easy way to go through all of the objects that are held in the
    * Registry
    * 
    * @param func function This function is run for every object. Its passed the object as an argument
    * @param string type Optionally, you can pass a type of object to look for
    */
    RG.OR.iterate =
    RG.OR.Iterate = function (func)
    {
        var objects = RGraph.ObjectRegistry.objects.byUID;

        for (var i=0,len=objects.length; i<len; ++i) {
        
            if (typeof arguments[1] === 'string') {
                
                var types = arguments[1].split(/,/);

                for (var j=0,len2=types.length; j<len2; ++j) {
                    if (types[j] == objects[i][1].type) {
                        func(objects[i][1]);
                    }
                }
            } else {
                func(objects[i][1]);
            }
        }
    };
    
    /**
    * Retrieves all objects for a given canvas id
    * 
    * @patarm id string The canvas ID to get objects for.
    */
    RG.OR.getObjectsByCanvasID = function (id)
    {
        var store = RG.ObjectRegistry.objects.byCanvasID;
        var ret = [];

        // Loop through all of the objects and return the appropriate ones
        for (var i=0,len=store.length; i<len; ++i) {
            if (store[i] && store[i][0] == id ) {
                ret.push(store[i][1]);
            }
        }

        return ret;
    };
    
    /**
    * Retrieves the relevant object based on the X/Y position.
    * 
    * @param  object e The event object
    * @return object   The applicable (if any) object
    */
    RG.OR.firstbyxy =
    RG.OR.getFirstObjectByXY =
    RG.OR.getObjectByXY = function (e)
    {
        var canvas  = e.target;
        var ret     = null;
        var objects = RG.ObjectRegistry.getObjectsByCanvasID(canvas.id);

        for (var i=(objects.length - 1); i>=0; --i) {

            var obj = objects[i].getObjectByXY(e);

            if (obj) {
                return obj;
            }
        }
    };
    

    /**
    * Retrieves the relevant objects based on the X/Y position.
    * NOTE This function returns an array of objects
    * 
    * @param  object e The event object
    * @return          An array of pertinent objects. Note the there may be only one object
    */
    RG.OR.getObjectsByXY = function (e)
    {
        var canvas  = e.target,
            ret     = [],
            objects = RG.ObjectRegistry.getObjectsByCanvasID(canvas.id);

        // Retrieve objects "front to back"
        for (var i=(objects.length - 1); i>=0; --i) {

            var obj = objects[i].getObjectByXY(e);

            if (obj) {
                ret.push(obj);
            }
        }
        
        return ret;
    };
    

    /**
    * Retrieves the object with the corresponding UID
    * 
    * @param string uid The UID to get the relevant object for
    */
    RG.OR.get =
    RG.OR.getObjectByUID = function (uid)
    {
        var objects = RG.ObjectRegistry.objects.byUID;

        for (var i=0,len=objects.length; i<len; ++i) {
            if (objects[i] && objects[i][1].uid == uid) {
                return objects[i][1];
            }
        }
    };
    
    /**
    * Brings a chart to the front of the ObjectRegistry by
    * removing it and then readding it at the end and then
    * redrawing the canvas
    * 
    * @param object  obj    The object to bring to the front
    * @param boolean redraw Whether to redraw the canvas after the 
    *                       object has been moved
    */
    RG.OR.bringToFront = function (obj)
    {
        var redraw = typeof arguments[1] === 'undefined' ? true : arguments[1];

        RG.ObjectRegistry.remove(obj);
        RG.ObjectRegistry.add(obj);
        
        if (redraw) {
            RG.redrawCanvas(obj.canvas);
        }
    };
    
    /**
    * Retrieves the objects that are the given type
    * 
    * @param  mixed canvas  The canvas to check. It can either be the canvas object itself or just the ID
    * @param  string type   The type to look for
    * @return array         An array of one or more objects
    */
    RG.OR.type =
    RG.OR.getObjectsByType = function (type)
    {
        var objects = RG.ObjectRegistry.objects.byUID;
        var ret     = [];

        for (var i=0,len=objects.length; i<len; ++i) {

            if (objects[i] && objects[i][1] && objects[i][1].type && objects[i][1].type && objects[i][1].type == type) {
                ret.push(objects[i][1]);
            }
        }

        return ret;
    };
    
    /**
    * Retrieves the FIRST object that matches the given type
    *
    * @param  string type   The type of object to look for
    * @return object        The FIRST object that matches the given type
    */
    RG.OR.first =
    RG.OR.getFirstObjectByType = function (type)
    {
        var objects = RG.ObjectRegistry.objects.byUID;
    
        for (var i=0,len=objects.length; i<len; ++i) {
            if (objects[i] && objects[i][1] && objects[i][1].type == type) {
                return objects[i][1];
            }
        }
        
        return null;
    };
    
    /**
    * This takes centerx, centery, x and y coordinates and returns the
    * appropriate angle relative to the canvas angle system. Remember
    * that the canvas angle system starts at the EAST axis
    * 
    * @param  number cx  The centerx coordinate
    * @param  number cy  The centery coordinate
    * @param  number x   The X coordinate (eg the mouseX if coming from a click)
    * @param  number y   The Y coordinate (eg the mouseY if coming from a click)
    * @return number     The relevant angle (measured in in RADIANS)
    */
    RG.getAngleByXY = function (cx, cy, x, y)
    {
        var angle = ma.atan((y - cy) / (x - cx));
            angle = ma.abs(angle)

        if (x >= cx && y >= cy) {
            angle += RG.TWOPI;

        } else if (x >= cx && y < cy) {
            angle = (RG.HALFPI - angle) + (RG.PI + RG.HALFPI);

        } else if (x < cx && y < cy) {
            angle += RG.PI;

        } else {
            angle = RG.PI - angle;
        }

        /**
        * Upper and lower limit checking
        */
        if (angle > RG.TWOPI) {
            angle -= RG.TWOPI;
        }

        return angle;
    };
    
    /**
    * This function returns the distance between two points. In effect the
    * radius of an imaginary circle that is centered on x1 and y1. The name
    * of this function is derived from the word "Hypoteneuse", which in
    * trigonmetry is the longest side of a triangle
    * 
    * @param number x1 The original X coordinate
    * @param number y1 The original Y coordinate
    * @param number x2 The target X coordinate
    * @param number y2 The target Y  coordinate
    */
    RG.getHypLength = function (x1, y1, x2, y2)
    {
        var ret = ma.sqrt(((x2 - x1) * (x2 - x1)) + ((y2 - y1) * (y2 - y1)));

        return ret;
    };
    
    /**
    * This function gets the end point (X/Y coordinates) of a given radius.
    * You pass it the center X/Y and the radius and this function will return
    * the endpoint X/Y coordinates.
    * 
    * @param number cx The center X coord
    * @param number cy The center Y coord
    * @param number r  The lrngth of the radius
    */
    RG.getRadiusEndPoint = function (cx, cy, angle, radius)
    {
        var x = cx + (ma.cos(angle) * radius);
        var y = cy + (ma.sin(angle) * radius);
        
        return [x, y];
    };
    
    /**
    * This installs all of the event listeners
    * 
    * @param object obj The chart object
    */
    RG.installEventListeners =
    RG.InstallEventListeners = function (obj)
    {
        var prop = obj.properties;

        /**
        * Don't attempt to install event listeners for older versions of MSIE
        */
        if (RG.ISOLD) {
            return;
        }

        /**
        * If this function exists, then the dynamic file has been included.
        */
        if (RG.installCanvasClickListener) {

            RG.installWindowMousedownListener(obj);
            RG.installWindowMouseupListener(obj);
            RG.installCanvasMousemoveListener(obj);
            RG.installCanvasMouseupListener(obj);
            RG.installCanvasMousedownListener(obj);
            RG.installCanvasClickListener(obj);
        
        } else if (   RG.hasTooltips(obj)
                   || prop['chart.adjustable']
                   || prop['chart.annotatable']
                   || prop['chart.contextmenu']
                   || prop['chart.resizable']
                   || prop['chart.key.interactive']
                   || prop['chart.events.click']
                   || prop['chart.events.mousemove']
                   || typeof obj.onclick === 'function'
                   || typeof obj.onmousemove === 'function'
                  ) {

            alert('[RGRAPH] You appear to have used dynamic features but not included the file: RGraph.common.dynamic.js');
        }
    };
    
    /**
    * Loosly mimicks the PHP function print_r();
    */
    RG.pr = function (obj)
    {
        var indent = (arguments[2] ? arguments[2] : '    ');
        var str    = '';

        var counter = typeof arguments[3] == 'number' ? arguments[3] : 0;
        
        if (counter >= 5) {
            return '';
        }
        
        switch (typeof obj) {
            
            case 'string':    str += obj + ' (' + (typeof obj) + ', ' + obj.length + ')'; break;
            case 'number':    str += obj + ' (' + (typeof obj) + ')'; break;
            case 'boolean':   str += obj + ' (' + (typeof obj) + ')'; break;
            case 'function':  str += 'function () {}'; break;
            case 'undefined': str += 'undefined'; break;
            case 'null':      str += 'null'; break;
            
            case 'object':
                // In case of null
                if (RGraph.is_null(obj)) {
                    str += indent + 'null\n';
                } else {
                    str += indent + 'Object {' + '\n'
                    for (j in obj) {
                        str += indent + '    ' + j + ' => ' + RGraph.pr(obj[j], true, indent + '    ', counter + 1) + '\n';
                    }
                    str += indent + '}';
                }
                break;
            
            
            default:
                str += 'Unknown type: ' + typeof obj + '';
                break;
        }


        /**
        * Finished, now either return if we're in a recursed call, or alert()
        * if we're not.
        */
        if (!arguments[1]) {
            alert(str);
        }
        
        return str;
    };
    
    /**
    * Produces a dashed line
    * 
    * @param object co The 2D context
    * @param number x1 The start X coordinate
    * @param number y1 The start Y coordinate
    * @param number x2 The end X coordinate
    * @param number y2 The end Y coordinate
    */
    RG.dashedLine =
    RG.DashedLine = function(co, x1, y1, x2, y2)
    {
        /**
        * This is the size of the dashes
        */
        var size = 5;

        /**
        * The optional fifth argument can be the size of the dashes
        */
        if (typeof arguments[5] === 'number') {
            size = arguments[5];
        }

        var dx  = x2 - x1;
        var dy  = y2 - y1;
        var num = ma.floor(ma.sqrt((dx * dx) + (dy * dy)) / size);

        var xLen = dx / num;
        var yLen = dy / num;

        var count = 0;

        do {
            (count % 2 == 0 && count > 0) ? co.lineTo(x1, y1) : co.moveTo(x1, y1);

            x1 += xLen;
            y1 += yLen;
        } while(count++ <= num);
    };
    
    /**
    * Makes an AJAX call. It calls the given callback (a function) when ready
    * 
    * @param string   url      The URL to retrieve
    * @param function callback A function that is called when the response is ready,
    *                          there's an example below called "myCallback".
    */
    RG.AJAX = function (url, callback)
    {
        // Mozilla, Safari, ...
        if (window.XMLHttpRequest) {
            var httpRequest = new XMLHttpRequest();

        // MSIE
        } else if (window.ActiveXObject) {
            var httpRequest = new ActiveXObject("Microsoft.XMLHTTP");
        }

        httpRequest.onreadystatechange = function ()
        {
            if (this.readyState == 4 && this.status == 200) {
                this.__user_callback__ = callback;

                this.__user_callback__(this.responseText);
            }
        }

        httpRequest.open('GET', url, true);
        httpRequest.send();
    };
    
    /**
    * Makes an AJAX POST request. It calls the given callback (a function) when ready
    * 
    * @param string   url      The URL to retrieve
    * @param object   data     The POST data
    * @param function callback A function that is called when the response is ready, there's an example below
    *                          called "myCallback".
    */
    RG.AJAX.POST = function (url, data, callback)
    {
        // Used when building the POST string
        var crumbs = [];
        


        // Mozilla, Safari, ...
        if (window.XMLHttpRequest) {
            var httpRequest = new XMLHttpRequest();

        // MSIE
        } else if (window.ActiveXObject) {
            var httpRequest = new ActiveXObject("Microsoft.XMLHTTP");
        }
        

        httpRequest.onreadystatechange = function ()
        {
            if (this.readyState == 4 && this.status == 200) {
                this.__user_callback__ = callback;
                this.__user_callback__(this.responseText);
            }
        }

        httpRequest.open('POST', url, true);
        httpRequest.setRequestHeader("Content-type","application/x-www-form-urlencoded");
        
        for (i in data) {
            if (typeof i == 'string') {
                crumbs.push(i + '=' + encodeURIComponent(data[i]));
            }
        }

        httpRequest.send(crumbs.join('&'));
    };
    
    /**
    * Uses the above function but calls the call back passing a number as its argument
    * 
    * @param url string The URL to fetch
    * @param callback function Your callback function (which is passed the number as an argument)
    */
    RG.AJAX.getNumber = function (url, callback)
    {
        RG.AJAX(url, function ()
        {
            var num = parseFloat(this.responseText);

            callback(num);
        });
    };
    
    /**
    * Uses the above function but calls the call back passing a string as its argument
    * 
    * @param url string The URL to fetch
    * @param callback function Your callback function (which is passed the string as an argument)
    */
    RG.AJAX.getString = function (url, callback)
    {
        RG.AJAX(url, function ()
        {
            var str = String(this.responseText);

            callback(str);
        });
    };
    
    /**
    * Uses the above function but calls the call back passing JSON (ie a JavaScript object ) as its argument
    * 
    * @param url string The URL to fetch
    * @param callback function Your callback function (which is passed the JSON object as an argument)
    */
    RG.AJAX.getJSON = function (url, callback)
    {
        RG.AJAX(url, function ()
        {
            var json = eval('(' + this.responseText + ')');

            callback(json);
        });
    };
    
    /**
    * Uses the above RGraph.AJAX function but calls the call back passing an array as its argument.
    * Useful if you're retrieving CSV data
    * 
    * @param url string The URL to fetch
    * @param callback function Your callback function (which is passed the CSV/array as an argument)
    */
    RG.AJAX.getCSV = function (url, callback)
    {
        var seperator = arguments[2] ? arguments[2] : ',';

        RG.AJAX(url, function ()
        {
            var regexp = new RegExp(seperator);
            var arr = this.responseText.split(regexp);
            
            // Convert the strings to numbers
            for (var i=0,len=arr.length;i<len;++i) {
                arr[i] = parseFloat(arr[i]);
            }

            callback(arr);
        });
    };
    
    /**
    * Rotates the canvas
    * 
    * @param object canvas The canvas to rotate
    * @param  int   x      The X coordinate about which to rotate the canvas
    * @param  int   y      The Y coordinate about which to rotate the canvas
    * @param  int   angle  The angle(in RADIANS) to rotate the canvas by
    */
    RG.rotateCanvas =
    RG.RotateCanvas = function (ca, x, y, angle)
    {
        var co = ca.getContext('2d');

        co.translate(x, y);
        co.rotate(angle);
        co.translate(0 - x, 0 - y);    
    };
    
    /**
    * Measures text by creating a DIV in the document and adding the relevant text to it.
    * Then checking the .offsetWidth and .offsetHeight.
    * 
    * @param  string text   The text to measure
    * @param  bool   bold   Whether the text is bold or not
    * @param  string font   The font to use
    * @param  size   number The size of the text (in pts)
    * @return array         A two element array of the width and height of the text
    */
    RG.measureText =
    RG.MeasureText = function (text, bold, font, size)
    {
        // Add the sizes to the cache as adding DOM elements is costly and causes slow downs
        if (typeof RG.measuretext_cache === 'undefined') {
            RG.measuretext_cache = [];
        }

        var str = text + ':' + bold + ':' + font + ':' + size;
        if (typeof RG.measuretext_cache == 'object' && RG.measuretext_cache[str]) {
            return RG.measuretext_cache[str];
        }
        
        if (!RG.measuretext_cache['text-div']) {
            var div = document.createElement('DIV');
                div.style.position = 'absolute';
                div.style.top = '-100px';
                div.style.left = '-100px';
            document.body.appendChild(div);
            
            // Now store the newly created DIV
            RG.measuretext_cache['text-div'] = div;

        } else if (RG.measuretext_cache['text-div']) {
            var div = RG.measuretext_cache['text-div'];
        }

        div.innerHTML        = text.replace(/\r\n/g, '<br />');
        div.style.fontFamily = font;
        div.style.fontWeight = bold ? 'bold' : 'normal';
        div.style.fontSize   = (size || 12) + 'pt';
        
        var size = [div.offsetWidth, div.offsetHeight];

        //document.body.removeChild(div);
        RG.measuretext_cache[str] = size;
        
        return size;
    };
    
    /* New text function. Accepts two arguments:
    *  o obj - The chart object
    *  o opt - An object/hash/map of properties. This can consist of:
    *          x                The X coordinate (REQUIRED)
    *          y                The Y coordinate (REQUIRED)
    *          text             The text to show (REQUIRED)
    *          font             The font to use
    *          size             The size of the text (in pt)
    *          italic           Whether the text should be italic or not
    *          bold             Whether the text shouldd be bold or not
    *          marker           Whether to show a marker that indicates the X/Y coordinates
    *          valign           The vertical alignment
    *          halign           The horizontal alignment
    *          bounding         Whether to draw a bounding box for the text
    *          boundingStroke   The strokeStyle of the bounding box
    *          boundingFill     The fillStyle of the bounding box
    *          accessible       If false this will cause the text to be
    *                           rendered as native canvas text. DOM text otherwise
    */
    RG.text2 =
    RG.Text2 = function (obj, opt)
    {
        /**
        * Use DOM nodes to get better quality text. This option is BETA quality
        * code and most likely and will not work if you use 3D or if you use
        * your own transformations.
        */
        function domtext ()
        {
            /**
            * Check the font property to see if it contains the italic keyword,
            * and if it does then take it out and set the italic property
            */
            if (String(opt.size).toLowerCase().indexOf('italic') !== -1) {
                opt.size = opt.size.replace(/ *italic +/, '');
                opt.italic = true;
            }
                        // Used for caching the DOM node
            var cacheKey = ma.abs(parseInt(opt.x)) + '_' + ma.abs(parseInt(opt.y)) + '_' + String(opt.text).replace(/[^a-zA-Z0-9]+/g, '_') + '_' + obj.canvas.id;
                        // Wrap the canvas in a DIV
            if (!ca.rgraph_domtext_wrapper) {

                var wrapper = document.createElement('div');
                    wrapper.id        = ca.id + '_rgraph_domtext_wrapper';
                    wrapper.className = 'rgraph_domtext_wrapper';

                    // The wrapper can be configured to hide or show the
                    // overflow with the textAccessibleOverflow option
                    wrapper.style.overflow = obj.properties['chart.text.accessible.overflow'] != false && obj.properties['chart.text.accessible.overflow'] != 'hidden' ? 'visible' : 'hidden';
                    
                    wrapper.style.width    = ca.offsetWidth + 'px';
                    wrapper.style.height   = ca.offsetHeight + 'px';

                    wrapper.style.cssFloat = ca.style.cssFloat;
                    wrapper.style.display  = ca.style.display || 'inline-block';
                    wrapper.style.position = ca.style.position || 'relative';
                    wrapper.style.left     = ca.style.left;
                    wrapper.style.top      = ca.style.top;
                    wrapper.style.width    = ca.width + 'px';
                    wrapper.style.height   = ca.height + 'px';

                    ca.style.position      = 'absolute';
                    ca.style.left          = 0;
                    ca.style.top           = 0;
                    ca.style.display       = 'inline';
                    ca.style.cssFloat      = 'none';

                    
                    if ((obj.type === 'bar' || obj.type === 'bipolar' || obj.type === 'hbar') && obj.properties['chart.variant'] === '3d') {
                        wrapper.style.transform = 'skewY(5.7deg)';
                    }

                ca.parentNode.insertBefore(wrapper, ca);
                
                // Remove the canvas from the DOM and put it in the wrapper
                ca.parentNode.removeChild(ca);
                wrapper.appendChild(ca);
                
                ca.rgraph_domtext_wrapper = wrapper;
                
                // TODO Add a subwrapper here

            } else {
                wrapper = ca.rgraph_domtext_wrapper;
            }
                        var defaults = {
                size: 12,
                font: 'Arial',
                italic: 'normal',
                bold: 'normal',
                valign: 'bottom',
                halign: 'left',
                marker: true,
                color: co.fillStyle,
                bounding: {
                    enabled: false,
                    fill: 'rgba(255,255,255,0.7)',
                    stroke: '#666'
                }
            }
            
            
            // Transform \n to the string [[RETURN]] which is then replaced
            // further down
            opt.text = String(opt.text).replace(/\r?\n/g, '[[RETURN]]');


            // Create the node cache array that nodes
            // already created are stored in
            if (typeof RG.text2.domNodeCache === 'undefined') {
                RG.text2.domNodeCache = new Array();
            }
            
            if (typeof RG.text2.domNodeCache[obj.id] === 'undefined') {
                RG.text2.domNodeCache[obj.id] = new Array();
            }

            // Create the dimension cache array that node
            // dimensions are stored in
            if (typeof RG.text2.domNodeDimensionCache === 'undefined') {
                RG.text2.domNodeDimensionCache = new Array();
            }
            
            if (typeof RG.text2.domNodeDimensionCache[obj.id] === 'undefined') {
                RG.text2.domNodeDimensionCache[obj.id] = new Array();
            }
                        // Create the DOM node
            if (!RG.text2.domNodeCache[obj.id] || !RG.text2.domNodeCache[obj.id][cacheKey]) {

                var span = document.createElement('span');
                    span.style.position      = 'absolute';
                    span.style.display       = 'inline';
                    
                    span.style.left       = (opt.x * (parseInt(ca.offsetWidth) / parseInt(ca.width))) + 'px';
                    span.style.top        = (opt.y * (parseInt(ca.offsetHeight) / parseInt(ca.height)))  + 'px';
                    span.style.color      = opt.color || defaults.color;
                    span.style.fontFamily = opt.font || defaults.font;
                    span.style.fontWeight = opt.bold ? 'bold' : defaults.bold;
                    span.style.fontStyle  = opt.italic ? 'italic' : defaults.italic;
                    span.style.fontSize   = (opt.size || defaults.size) + 'pt';
                    span.style.whiteSpace = 'nowrap';
                    span.tag              = opt.tag;


                    // CSS angled text. This should be conasidered BETA quality code at the moment,
                    // but it seems to be OK. You may need to use the labelsOffsety when using this
                    // option.
                    if (typeof opt.angle === 'number' && opt.angle !== 0) {
                    
                        var coords = RG.measureText(
                            opt.text,
                            opt.bold,
                            opt.font,
                            opt.size
                        );
                    
                        //span.style.left = parseFloat(span.style.left) - coords[0] + 'px';
                        span.style.transformOrigin = '100% 50%';
                        span.style.transform       = 'rotate(' + opt.angle + 'deg)';
                    }
                    
                    // Shadow
                    span.style.textShadow = '{1}px {2}px {3}px {4}'.format(
                        co.shadowOffsetX,
                        co.shadowOffsetY,
                        co.shadowBlur,
                        co.shadowColor
                    );


                    if (opt.bounding) {
                        span.style.border          = '1px solid ' + (opt['bounding.stroke'] || defaults.bounding.stroke);
                        span.style.backgroundColor = opt['bounding.fill'] || defaults.bounding.fill;
                    }
                    // Pointer events
                    if ((typeof obj.properties['chart.text.accessible.pointerevents'] === 'undefined' ||
                        obj.properties['chart.text.accessible.pointerevents']) &&
                        obj.properties['chart.text.accessible.pointerevents'] !== 'none') {
                        
                        span.style.pointerEvents =  'auto';
                    } else {
                        span.style.pointerEvents =  'none';
                    }

                    span.style.padding = opt.bounding ? '2px' : null;
                    span.__text__      = opt.text
                    span.innerHTML     = opt.text.replace('&', '&amp;')
                                                 .replace('<', '&lt;')
                                                 .replace('>', '&gt;');
                    
                    // Now replace the string [[RETURN]] with a <br />
                    span.innerHTML = span.innerHTML.replace(/\[\[RETURN\]\]/g, '<br />');

                wrapper.appendChild(span);

                // Alignment defaults
                opt.halign = opt.halign || 'left';
                opt.valign = opt.valign || 'bottom';
                
                // Horizontal alignment
                if (opt.halign === 'right') {
                    span.style.left      = parseFloat(span.style.left) - span.offsetWidth + 'px';
                    span.style.textAlign = 'right';
                } else if (opt.halign === 'center') {
                    span.style.left      = parseFloat(span.style.left) - (span.offsetWidth  / 2) + 'px';
                    span.style.textAlign = 'center';
                }
                
                // Vertical alignment
                if (opt.valign === 'top') {
                    // Nothing to do here
                } else if (opt.valign === 'center') {
                    span.style.top = parseFloat(span.style.top) - (span.offsetHeight / 2) + 'px';
                } else {
                    span.style.top = parseFloat(span.style.top) - span.offsetHeight + 'px';
                }
                        
                
                var offsetWidth  = parseFloat(span.offsetWidth),
                    offsetHeight = parseFloat(span.offsetHeight),
                    top          = parseFloat(span.style.top),
                    left         = parseFloat(span.style.left);

                RG.text2.domNodeCache[obj.id][cacheKey] = span;
                RG.text2.domNodeDimensionCache[obj.id][cacheKey] = {
                      left: left,
                       top: top,
                     width: offsetWidth,
                    height: offsetHeight
                };
                span.id = cacheKey;


            
            } else {
                span = RG.text2.domNodeCache[obj.id][cacheKey];
                span.style.display = 'inline';
                
                var offsetWidth  = RG.text2.domNodeDimensionCache[obj.id][cacheKey].width,
                    offsetHeight = RG.text2.domNodeDimensionCache[obj.id][cacheKey].height,
                    top          = RG.text2.domNodeDimensionCache[obj.id][cacheKey].top,
                    left         = RG.text2.domNodeDimensionCache[obj.id][cacheKey].left;
            }


            

            
            
            // If requested, draw a marker to indicate the coords
            if (opt.marker) {
                RG.path2(context, 'b m % % l % % m % % l % % s',
                    opt.x - 5, opt.y,
                    opt.x + 5, opt.y,
                    opt.x, opt.y - 5,
                    opt.x, opt.y + 5
                );
            }
            
            /**
            * If its a drawing API text object then allow
            * for events and tooltips
            */
            if (obj.type === 'drawing.text') {

                // Mousemove
                if (obj.properties['chart.events.mousemove']) {
                    span.addEventListener('mousemove', function (e) {(obj.properties['chart.events.mousemove'])(e, obj);}, false);
                }
                
                // Click
                if (obj.properties['chart.events.click']) {
                    span.addEventListener('click', function (e) {(obj.properties['chart.events.click'])(e, obj);}, false);
                }
                
                // Tooltips
                if (obj.properties['chart.tooltips']) {
                    span.addEventListener(
                        obj.properties['chart.tooltips.event'].indexOf('mousemove') !== -1 ? 'mousemove' : 'click',
                        function (e)
                        {
                            if (   !RG.Registry.get('chart.tooltip')
                                || RG.Registry.get('chart.tooltip').__index__ !== 0
                                || RG.Registry.get('chart.tooltip').__object__.uid != obj.uid
                               ) {
                               
                                RG.hideTooltip();
                                RG.redraw();
                                RG.tooltip(obj, obj.properties['chart.tooltips'][0], opt.x, opt.y, 0, e);
                            }
                        },
                        false
                    );
                }
            }

            // Build the return value
            var ret    = {};
            ret.x      = left;
            ret.y      = top;
            ret.width  = offsetWidth;
            ret.height = offsetHeight;
            ret.object = obj;
            ret.text   = opt.text;
            ret.tag    = opt.tag;

            
            // The reset() function clears the domNodeCache
            ////
            // @param object OPTIONAL You can pass in the canvas to limit the
            //                        clearing to that canvas.
            RG.text2.domNodeCache.reset = function ()
            {

                // Limit the clearing to a single canvas tag
                if (arguments[0]) {
                    
                    if (typeof arguments[0] === 'string') {
                        var ca = document.getElementById(arguments[0])
                    } else {
                        var ca = arguments[0];
                    }

                    var nodes = RG.text2.domNodeCache[ca.id];
                
                    for (j in nodes) {
                        
                        var node = RG.text2.domNodeCache[ca.id][j];
                        
                        if (node && node.parentNode) {
                            node.parentNode.removeChild(node);
                        }
                    }
                    
                    RG.text2.domNodeCache[ca.id]          = [];
                    RG.text2.domNodeDimensionCache[ca.id] = [];

                // Clear all DOM text from all tags
                } else {
                    for (i in RG.text2.domNodeCache) {
                        for (j in RG.text2.domNodeCache[i]) {
                            if (RG.text2.domNodeCache[i][j] && RG.text2.domNodeCache[i][j].parentNode) {
                                RG.text2.domNodeCache[i][j].parentNode.removeChild(RG.text2.domNodeCache[i][j]);
                            }
                        }
                    }

                    RG.text2.domNodeCache          = [];
                    RG.text2.domNodeDimensionCache = [];
                }
            };
            
            //
            // Helps you get hold of the SPAN tag nodes that hold the text on the chart
            //
            RG.text2.find = function (opt)
            {
                var span, nodes = [];
                var id = typeof opt.id === 'string' ? opt.id : opt.object.id;

                for (i in RG.text2.domNodeCache[id]) {
                
                    span = RG.text2.domNodeCache[id][i];

                    // A full tag is given
                    if (typeof opt.tag === 'string' && opt.tag === span.tag) {
                        nodes.push(span);
                        continue;
                    }
                                        // A regex is given as the tag
                    if (typeof opt.tag === 'object' && opt.tag.constructor.toString().indexOf('RegExp')) {

                        var regexp = new RegExp(opt.tag);

                        if (regexp.test(span.tag)) {
                            nodes.push(span);
                            continue;
                        }
                    }
                                        // A full text is given
                    if (typeof opt.text === 'string' && opt.text === span.__text__) {
                        nodes.push(span);
                        continue;
                    }
                                        // Regex for the text is given
                    // A regex is given as the tag
                    if (typeof opt.text === 'object' && opt.text.constructor.toString().indexOf('RegExp')) {

                        var regexp = new RegExp(opt.text);

                        if (regexp.test(span.__text__)) {
                            nodes.push(span);
                            
                        continue;
                        }
                    }
                }

                return nodes;
            };
            
            //
            // Add the SPAN tag to the return value
            //
            ret.node = span;


            /**
            * Save and then return the details of the text (but oly
            * if it's an RGraph object that was given)
            */
            if (obj && obj.isRGraph && obj.coordsText) {
                obj.coordsText.push(ret);
            }


            return ret;
        }
        
        /**
        * An RGraph object can be given, or a string or the 2D rendering context
        * The coords are placed on the obj.coordsText variable ONLY if it's an RGraph object. The function
        * still returns the cooords though in all cases.
        */
        if (obj && obj.isRGraph) {
            var obj = obj;
            var co  = obj.context;
            var ca  = obj.canvas;
        } else if (typeof obj == 'string') {
            var ca  = document.getElementById(obj);
            var co  = ca.getContext('2d');
            var obj = ca.__object__;
        } else if (typeof obj.getContext === 'function') {
            var ca = obj;
            var co = ca.getContext('2d');
            var obj = ca.__object__;
        } else if (obj.toString().indexOf('CanvasRenderingContext2D') != -1 || RGraph.ISIE8 && obj.moveTo) {
            var co  = obj;
            var ca  = obj.canvas;
            var obj = ca.__object__;

        // IE7/8
        } else if (RG.ISOLD && obj.fillText) {
            var co  = obj;
            var ca  = obj.canvas;
            var obj = ca.__object__;
        }


        /**
        * Changed the name of boundingFill/boundingStroke - this allows you to still use those names
        */

        if (typeof opt.boundingFill === 'string')   opt['bounding.fill']   = opt.boundingFill;
        if (typeof opt.boundingStroke === 'string') opt['bounding.stroke'] = opt.boundingStroke;
        


        if (obj && obj.properties['chart.text.accessible'] && opt.accessible !== false) {
            return domtext();
        }
        
        var x              = opt.x,
            y              = opt.y,
            originalX      = x,
            originalY      = y,
            text           = opt.text,
            text_multiline = typeof text === 'string' ? text.split(/\r?\n/g) : '',
            numlines       = text_multiline.length,
            font           = opt.font ? opt.font : 'Arial',
            size           = opt.size ? opt.size : 10,
            size_pixels    = size * 1.5,
            bold           = opt.bold,
            italic         = opt.italic,
            halign         = opt.halign ? opt.halign : 'left',
            valign         = opt.valign ? opt.valign : 'bottom',
            tag            = typeof opt.tag == 'string' && opt.tag.length > 0 ? opt.tag : '',
            marker         = opt.marker,
            angle          = opt.angle || 0
                    
        
        
        
        
        





        var bounding                = opt.bounding,
            bounding_stroke         = opt['bounding.stroke'] ? opt['bounding.stroke'] : 'black',
            bounding_fill           = opt['bounding.fill'] ? opt['bounding.fill'] : 'rgba(255,255,255,0.7)',
            bounding_shadow         = opt['bounding.shadow'],
            bounding_shadow_color   = opt['bounding.shadow.color'] || '#ccc',
            bounding_shadow_blur    = opt['bounding.shadow.blur'] || 3,
            bounding_shadow_offsetx = opt['bounding.shadow.offsetx'] || 3,
            bounding_shadow_offsety = opt['bounding.shadow.offsety'] || 3,
            bounding_linewidth      = opt['bounding.linewidth'] || 1;
                    /**
        * Initialize the return value to an empty object
        */
        var ret = {};
        
        //
        // Color
        //
        if (typeof opt.color === 'string') {
            var orig_fillstyle = co.fillStyle;
            co.fillStyle = opt.color;
        }
                /**
        * The text arg must be a string or a number
        */
        if (typeof text == 'number') {
            text = String(text);
        }

        if (typeof text !== 'string') {
            return;
        }
        
        
        
        /**
        * This facilitates vertical text
        */
        if (angle != 0) {
            co.save();
            co.translate(x, y);
            co.rotate((ma.PI / 180) * angle)
            x = 0;
            y = 0;
        }


        
        /**
        * Set the font
        */
        co.font = (opt.italic ? 'italic ' : '') + (opt.bold ? 'bold ' : '') + size + 'pt ' + font;
                /**
        * Measure the width/height. This must be done AFTER the font has been set
        */
        var width=0;
        for (var i=0; i<numlines; ++i) {
            width = ma.max(width, co.measureText(text_multiline[i]).width);
        }
        var height = size_pixels * numlines;
        
        /**
        * Accommodate old MSIE 7/8
        */
        //if (document.all && RGraph.ISOLD) {
            //y += 2;
        //}
                /**
        * If marker is specified draw a marker at the X/Y coordinates
        */
        if (opt.marker) {
            var marker_size = 10;
            var strokestyle = co.strokeStyle;
            co.beginPath();
                co.strokeStyle = 'red';
                co.moveTo(x, y - marker_size);
                co.lineTo(x, y + marker_size);
                co.moveTo(x - marker_size, y);
                co.lineTo(x + marker_size, y);
            co.stroke();
            co.strokeStyle = strokestyle;
        }
                /**
        * Set the horizontal alignment
        */
        if (halign == 'center') {
            co.textAlign = 'center';
            var boundingX = x - 2 - (width / 2);
        } else if (halign == 'right') {
            co.textAlign = 'right';
            var boundingX = x - 2 - width;
        } else {
            co.textAlign = 'left';
            var boundingX = x - 2;
        }


        /**
        * Set the vertical alignment
        */
        if (valign == 'center') {
            
            co.textBaseline = 'middle';
            // Move the text slightly
            y -= 1;
            
            y -= ((numlines - 1) / 2) * size_pixels;
            var boundingY = y - (size_pixels / 2) - 2;
        
        } else if (valign == 'top') {
            co.textBaseline = 'top';

            var boundingY = y - 2;

        } else {

            co.textBaseline = 'bottom';
            
            // Move the Y coord if multiline text
            if (numlines > 1) {
                y -= ((numlines - 1) * size_pixels);
            }

            var boundingY = y - size_pixels - 2;
        }
        
        var boundingW = width + 4;
        var boundingH = height + 4;
                /**
        * Draw a bounding box if required
        */
        if (bounding) {

            var pre_bounding_linewidth     = co.lineWidth;
            var pre_bounding_strokestyle   = co.strokeStyle;
            var pre_bounding_fillstyle     = co.fillStyle;
            var pre_bounding_shadowcolor   = co.shadowColor;
            var pre_bounding_shadowblur    = co.shadowBlur;
            var pre_bounding_shadowoffsetx = co.shadowOffsetX;
            var pre_bounding_shadowoffsety = co.shadowOffsetY;

            co.lineWidth   = bounding_linewidth;
            co.strokeStyle = bounding_stroke;
            co.fillStyle   = bounding_fill;

            if (bounding_shadow) {
                co.shadowColor   = bounding_shadow_color;
                co.shadowBlur    = bounding_shadow_blur;
                co.shadowOffsetX = bounding_shadow_offsetx;
                co.shadowOffsetY = bounding_shadow_offsety;
            }

            //obj.context.strokeRect(boundingX, boundingY, width + 6, (size_pixels * numlines) + 4);
            //obj.context.fillRect(boundingX, boundingY, width + 6, (size_pixels * numlines) + 4);
            co.strokeRect(boundingX, boundingY, boundingW, boundingH);
            co.fillRect(boundingX, boundingY, boundingW, boundingH);

            // Reset the linewidth,colors and shadow to it's original setting
            co.lineWidth     = pre_bounding_linewidth;
            co.strokeStyle   = pre_bounding_strokestyle;
            co.fillStyle     = pre_bounding_fillstyle;
            co.shadowColor   = pre_bounding_shadowcolor
            co.shadowBlur    = pre_bounding_shadowblur
            co.shadowOffsetX = pre_bounding_shadowoffsetx
            co.shadowOffsetY = pre_bounding_shadowoffsety
        }

        
        
        /**
        * Draw the text
        */
        if (numlines > 1) {
            for (var i=0; i<numlines; ++i) {
                co.fillText(text_multiline[i], x, y + (size_pixels * i));
            }
        } else {
            co.fillText(text, x + 0.5, y + 0.5);
        }
        
        
        
        /**
        * If the text is at 90 degrees restore() the canvas - getting rid of the rotation
        * and the translate that we did
        */
        if (angle != 0) {
            if (angle == 90) {
                if (halign == 'left') {
                    if (valign == 'bottom') {boundingX = originalX - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}
                    if (valign == 'center') {boundingX = originalX - (height / 2) - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}
                    if (valign == 'top')    {boundingX = originalX - height - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}
                
                } else if (halign == 'center') {
                    if (valign == 'bottom') {boundingX = originalX - 2; boundingY = originalY - (width / 2) - 2; boundingW = height + 4; boundingH = width + 4;}
                    if (valign == 'center') {boundingX = originalX - (height / 2) -  2; boundingY = originalY - (width / 2) - 2; boundingW = height + 4; boundingH = width + 4;}
                    if (valign == 'top')    {boundingX = originalX - height -  2; boundingY = originalY - (width / 2) - 2; boundingW = height + 4; boundingH = width + 4;}
                
                } else if (halign == 'right') {
                    if (valign == 'bottom') {boundingX = originalX - 2; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}
                    if (valign == 'center') {boundingX = originalX - (height / 2) - 2; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}
                    if (valign == 'top')    {boundingX = originalX - height - 2; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}
                }

            } else if (angle == 180) {

                if (halign == 'left') {
                    if (valign == 'bottom') {boundingX = originalX - width - 2; boundingY = originalY - 2; boundingW = width + 4; boundingH = height + 4;}
                    if (valign == 'center') {boundingX = originalX - width - 2; boundingY = originalY - (height / 2) - 2; boundingW = width + 4; boundingH = height + 4;}
                    if (valign == 'top')    {boundingX = originalX - width - 2; boundingY = originalY - height - 2; boundingW = width + 4; boundingH = height + 4;}
                
                } else if (halign == 'center') {
                    if (valign == 'bottom') {boundingX = originalX - (width / 2) - 2; boundingY = originalY - 2; boundingW = width + 4; boundingH = height + 4;}
                    if (valign == 'center') {boundingX = originalX - (width / 2) - 2; boundingY = originalY - (height / 2) - 2; boundingW = width + 4; boundingH = height + 4;}
                    if (valign == 'top')    {boundingX = originalX - (width / 2) - 2; boundingY = originalY - height - 2; boundingW = width + 4; boundingH = height + 4;}
                
                } else if (halign == 'right') {
                    if (valign == 'bottom') {boundingX = originalX - 2; boundingY = originalY - 2; boundingW = width + 4; boundingH = height + 4;}
                    if (valign == 'center') {boundingX = originalX - 2; boundingY = originalY - (height / 2) - 2; boundingW = width + 4; boundingH = height + 4;}
                    if (valign == 'top')    {boundingX = originalX - 2; boundingY = originalY - height - 2; boundingW = width + 4; boundingH = height + 4;}
                }
            
            } else if (angle == 270) {

                if (halign == 'left') {
                    if (valign == 'bottom') {boundingX = originalX - height - 2; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}
                    if (valign == 'center') {boundingX = originalX - (height / 2) - 4; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}
                    if (valign == 'top')    {boundingX = originalX - 2; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}
                
                } else if (halign == 'center') {
                    if (valign == 'bottom') {boundingX = originalX - height - 2; boundingY = originalY - (width/2) - 2; boundingW = height + 4; boundingH = width + 4;}
                    if (valign == 'center') {boundingX = originalX - (height/2) - 4; boundingY = originalY - (width/2) - 2; boundingW = height + 4; boundingH = width + 4;}
                    if (valign == 'top')    {boundingX = originalX - 2; boundingY = originalY - (width/2) - 2; boundingW = height + 4; boundingH = width + 4;}
                
                } else if (halign == 'right') {
                    if (valign == 'bottom') {boundingX = originalX - height - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}
                    if (valign == 'center') {boundingX = originalX - (height/2) - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}
                    if (valign == 'top')    {boundingX = originalX - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}
                }
            }

            co.restore();
        }
        
        /**
        * Reset the text alignment so that text rendered after this text function is not affected
        */
        co.textBaseline = 'alphabetic';
        co.textAlign    = 'left';
        

        /**
        * Fill the ret variable with details of the text
        */
        ret.x      = boundingX;
        ret.y      = boundingY;
        ret.width  = boundingW;
        ret.height = boundingH
        ret.object = obj;
        ret.text   = text;
        ret.tag    = tag;
                /**
        * Save and then return the details of the text (but oly
        * if it's an RGraph object that was given)
        */
        if (obj && obj.isRGraph && obj.coordsText) {
            obj.coordsText.push(ret);
        }
        
        //
        // Restore the original fillstyle
        //
        if (typeof orig_fillstyle === 'string') {
            co.fillStyle = orig_fillstyle;
        }

        return ret;
    };
    
    /**
    * Takes a sequential index abd returns the group/index variation of it. Eg if you have a
    * sequential index from a grouped bar chart this function can be used to convert that into
    * an appropriate group/index combination
    * 
    * @param nindex number The sequential index
    * @param data   array  The original data (which is grouped)
    * @return              The group/index information
    */
    RG.sequentialIndexToGrouped = function (index, data)
    {
        var group         = 0;
        var grouped_index = 0;

        while (--index >= 0) {

            if (RG.is_null(data[group])) {
                group++;
                grouped_index = 0;
                continue;
            }

            // Allow for numbers as well as arrays in the dataset
            if (typeof data[group] == 'number') {
                group++
                grouped_index = 0;
                continue;
            }
            

            grouped_index++;
            
            if (grouped_index >= data[group].length) {
                group++;
                grouped_index = 0;
            }
        }
        
        return [group, grouped_index];
    };
    
    /**
    * This function highlights a rectangle
    * 
    * @param object obj    The chart object
    * @param number shape  The coordinates of the rect to highlight
    */
    RG.Highlight.rect =
    RG.Highlight.Rect = function (obj, shape)
    {
        var ca   = obj.canvas;
        var co   = obj.context;
        var prop = obj.properties;

        if (prop['chart.tooltips.highlight']) {
            
        
            // Safari seems to need this
            co.lineWidth = 1;


            /**
            * Draw a rectangle on the canvas to highlight the appropriate area
            */
            co.beginPath();

                co.strokeStyle = prop['chart.highlight.stroke'];
                co.fillStyle   = prop['chart.highlight.fill'];
    
                co.rect(shape['x'],shape['y'],shape['width'],shape['height']);
                //co.fillRect(shape['x'],shape['y'],shape['width'],shape['height']);
            co.stroke();
            co.fill();
        }
    };
    
    /**
    * This function highlights a point
    * 
    * @param object obj    The chart object
    * @param number shape  The coordinates of the rect to highlight
    */
    RG.Highlight.point =
    RG.Highlight.Point = function (obj, shape)
    {
        var prop = obj.properties;
        var ca   = obj.canvas;
        var co   = obj.context;

        if (prop['chart.tooltips.highlight']) {
    
            /**
            * Draw a rectangle on the canvas to highlight the appropriate area
            */
            co.beginPath();
                co.strokeStyle = prop['chart.highlight.stroke'];
                co.fillStyle   = prop['chart.highlight.fill'];
                var radius   = prop['chart.highlight.point.radius'] || 2;
                co.arc(shape['x'],shape['y'],radius, 0, RG.TWOPI, 0);
            co.stroke();
            co.fill();
        }
    };
    
    /**
    * This is the same as Date.parse - though a little more flexible.
    * 
    * @param string str The date string to parse
    * @return Returns the same thing as Date.parse
    */
    RG.parseDate = function (str)
    {

        str = RG.trim(str);

        // Allow for: now (just the word "now")
        if (str === 'now') {
            str = (new Date()).toString();
        }


        // Allow for: 22-11-2013
        // Allow for: 22/11/2013
        // Allow for: 22-11-2013 12:09:09
        // Allow for: 22/11/2013 12:09:09
        if (str.match(/^(\d\d)(?:-|\/)(\d\d)(?:-|\/)(\d\d\d\d)(.*)$/)) {
            str = '{1}/{2}/{3}{4}'.format(
                RegExp.$3,
                RegExp.$2,
                RegExp.$1,
                RegExp.$4
            );
        }

        // Allow for: 2013-11-22 12:12:12 or  2013/11/22 12:12:12
        if (str.match(/^(\d\d\d\d)(-|\/)(\d\d)(-|\/)(\d\d)( |T)(\d\d):(\d\d):(\d\d)$/)) {
            str = RegExp.$1 + '-' + RegExp.$3 + '-' + RegExp.$5 + 'T' + RegExp.$7 + ':' + RegExp.$8 + ':' + RegExp.$9;
        }

        // Allow for: 2013-11-22
        if (str.match(/^\d\d\d\d-\d\d-\d\d$/)) {
            str = str.replace(/-/g, '/');
        }


        // Allow for: 12:09:44 (time only using todays date)
        if (str.match(/^\d\d:\d\d:\d\d$/)) {
        
            var dateObj  = new Date();
            var date     = dateObj.getDate();
            var month    = dateObj.getMonth() + 1;
            var year     = dateObj.getFullYear();
            
            // Pad the date/month with a zero if it's not two characters
            if (String(month).length === 1) month = '0' + month;
            if (String(date).length === 1) date = '0' + date;

            str = (year + '/' + month + '/' + date) + ' ' + str;
        }

        return Date.parse(str);
    };
    
    /**
    * Reset all of the color values to their original values
    * 
    * @param object
    */
    RG.resetColorsToOriginalValues = function (obj)
    {
        if (obj.original_colors) {
            // Reset the colors to their original values
            for (var j in obj.original_colors) {
                if (typeof j === 'string' && j.substr(0,6) === 'chart.') {
                    obj.properties[j] = RG.arrayClone(obj.original_colors[j]);
                }
            }
        }
                /**
        * If the function is present on the object to reset specific colors - use that
        */
        if (typeof obj.resetColorsToOriginalValues === 'function') {
            obj.resetColorsToOriginalValues();
        }
                // Reset the colorsParsed flag so that they're parsed for gradients again
        obj.colorsParsed = false;
    };
    
    /**
    * Creates a Linear gradient
    * 
    * @param object obj The chart object
    * @param number x1 The start X coordinate
    * @param number x2 The end X coordinate
    * @param number y1 The start Y coordinate
    * @param number y2 The end Y coordinate
    * @param string color1 The start color
    * @param string color2 The end color
    */
    RG.linearGradient =
    RG.LinearGradient = function (obj, x1, y1, x2, y2, color1, color2)
    {
        var gradient = obj.context.createLinearGradient(x1, y1, x2, y2);
        var numColors=arguments.length-5;
        
        for (var i=5; i<arguments.length; ++i) {
            
            var color = arguments[i];
            var stop = (i - 5) / (numColors - 1);
            
            gradient.addColorStop(stop, color);
        }
        
        return gradient;
    };
        
    /**
    * Creates a Radial gradient
    * 
    * @param object obj The chart object
    * @param number x1 The start X coordinate
    * @param number x2 The end X coordinate
    * @param number y1 The start Y coordinate
    * @param number y2 The end Y coordinate
    * @param string color1 The start color
    * @param string color2 The end color
    */
    RG.radialGradient =
    RG.RadialGradient = function(obj, x1, y1, r1, x2, y2, r2, color1, color2)
    {
        var gradient  = obj.context.createRadialGradient(x1, y1, r1, x2, y2, r2);
        var numColors = arguments.length-7;
        
        for(var i=7; i<arguments.length; ++i) {
            
            var color = arguments[i];
            var stop  = (i-7) / (numColors-1);
            
            gradient.addColorStop(stop, color);
        }
        
        return gradient;
    };
    
    /**
    * Adds an event listener to RGraphs internal array so that RGraph can track them.
    * This DOESN'T add the event listener to the canvas/window.
    * 
    * 5/1/14 TODO Used in the tooltips file, but is it necessary any more?
    */
    RG.addEventListener =
    RG.AddEventListener = function (id, e, func)
    {
        var type = arguments[3] ? arguments[3] : 'unknown';
        
        RG.Registry.get('chart.event.handlers').push([id,e,func,type]);
    };
    
    /**
    * Clears event listeners that have been installed by RGraph
    * 
    * @param string id The ID of the canvas to clear event listeners for - or 'window' to clear
    *                  the event listeners attached to the window
    */
    RG.clearEventListeners =
    RG.ClearEventListeners = function(id)
    {
        if (id && id == 'window') {
        
            window.removeEventListener('mousedown', window.__rgraph_mousedown_event_listener_installed__, false);
            window.removeEventListener('mouseup', window.__rgraph_mouseup_event_listener_installed__, false);
        
        } else {
            
            var canvas = document.getElementById(id);
            
            canvas.removeEventListener('mouseup', canvas.__rgraph_mouseup_event_listener_installed__, false);
            canvas.removeEventListener('mousemove', canvas.__rgraph_mousemove_event_listener_installed__, false);
            canvas.removeEventListener('mousedown', canvas.__rgraph_mousedown_event_listener_installed__, false);
            canvas.removeEventListener('click', canvas.__rgraph_click_event_listener_installed__, false);
        }
    };
    
    /**
    * Hides the annotating palette. It's here because it can be called
    * from code other than the annotating code.
    */
    RG.hidePalette =
    RG.HidePalette = function ()
    {
        var div = RG.Registry.get('palette');
        
        if(typeof div == 'object' && div) {
            
            div.style.visibility = 'hidden';
            div.style.display = 'none';
            
            RG.Registry.set('palette', null);
        }
    };
    
    /**
    * Generates a random number between the minimum and maximum
    * 
    * @param number min The minimum value
    * @param number max The maximum value
    * @param number     OPTIONAL Number of decimal places
    */
    RG.random = function (min, max)
    {
        var dp = arguments[2] ? arguments[2] : 0;
        var r  = ma.random();
        
        return Number((((max - min) * r) + min).toFixed(dp));
    };
    
    /**
    * 
    */
    RG.arrayRand =
    RG.arrayRandom =
    RG.random.array = function (num, min, max)
    {
        for(var i=0,arr=[]; i<num; i+=1) {
            arr.push(RG.random(min,max, arguments[3]));
        }
        
        return arr;
    };
    
    /**
    * Turns off shadow by setting blur to zero, the offsets to zero and the color to transparent black.
    * 
    * @param object obj The chart object
    */
    RG.noShadow =
    RG.NoShadow = function (obj)
    {
        var co = obj.context;

        co.shadowColor   = 'rgba(0,0,0,0)';
        co.shadowBlur    = 0;
        co.shadowOffsetX = 0;
        co.shadowOffsetY = 0;
    };
    
    /**
    * Sets the various shadow properties
    * 
    * @param object obj     The chart object
    * @param string color   The color of the shadow
    * @param number offsetx The offsetX value for the shadow
    * @param number offsety The offsetY value for the shadow
    * @param number blur    The blurring value for the shadow
    */
    RG.setShadow =
    RG.SetShadow = function (obj, color, offsetx, offsety, blur)
    {
        var co = obj.context;

        co.shadowColor   = color;
        co.shadowOffsetX = offsetx;
        co.shadowOffsetY = offsety;
        co.shadowBlur    = blur;

    };
    
    /**
    * Sets an object in the RGraph registry
    * 
    * @param string name The name of the value to set
    */
    RG.Registry.set =
    RG.Registry.Set = function (name, value)
    {
        // Convert uppercase letters to dot+lower case letter
        name = name.replace(/([A-Z])/g, function (str)
        {
            return '.' + String(RegExp.$1).toLowerCase();
        });
        
        // Ensure there is the chart. prefix
        if (name.substr(0,6) !== 'chart.') {
            name = 'chart.' + name;
        }

        RG.Registry.store[name] = value;
        
        return value;
    };
    
    /**
    * Gets an object from the RGraph registry
    * 
    * @param string name The name of the value to fetch
    */
    RG.Registry.get =
    RG.Registry.Get = function (name)
    {
        // Convert uppercase letters to dot+lower case letter
        name = name.replace(/([A-Z])/g, function (str)
        {
            return '.' + String(RegExp.$1).toLowerCase();
        });
        
        // Ensure there is the chart. prefix
        if (name.substr(0,6) !== 'chart.') {
            name = 'chart.' + name;
        }


        return RG.Registry.store[name];
    };
    
    /**
    * Converts the given number of degrees to radians. Angles in canvas are measured in radians
    * 
    * @param number deg The value to convert
    */
    RG.degrees2Radians = function (deg)
    {
        return deg * (RG.PI / 180);
    };
    
    /**
    * Generates logs for... log charts
    * 
    * @param number n    The number to generate the log for
    * @param number base The base to use
    */
    RG.log = function (n,base)
    {
        return ma.log(n) / (base ? ma.log(base) : 1);
    };
    
    /**
    * Determines if the given object is an array or not
    * 
    * @param mixed obj The variable to test
    */
    RG.isArray =
    RG.is_array = function (obj)
    {
        if (obj && obj.constructor) {
            var pos = obj.constructor.toString().indexOf('Array');
        } else {
            return false;
        }

        return obj != null &&
               typeof pos === 'number' &&
               pos > 0 &&
               pos < 20;
    };
    
    /**
    * Removes white-space from the start aqnd end of a string
    * 
    * @param string str The string to trim
    */
    RG.trim = function (str)
    {
        return RG.ltrim(RG.rtrim(str));
    };
    
    /**
    * Trims the white-space from the start of a string
    * 
    * @param string str The string to trim
    */
    RG.ltrim = function (str)
    {
        return str.replace(/^(\s|\0)+/, '');
    };
    
    /**
    * Trims the white-space off of the end of a string
    * 
    * @param string str The string to trim
    */
    RG.rtrim = function (str)
    {
        return str.replace(/(\s|\0)+$/, '');
    };
        /**
    * Returns true/false as to whether the given variable is null or not
    * 
    * @param mixed arg The argument to check
    */
    RG.isNull =
    RG.is_null = function (arg)
    {
        // must BE DOUBLE EQUALS - NOT TRIPLE
        if (arg == null || typeof arg === 'object' && !arg) {
            return true;
        }
        
        return false;
    };
    
    /**
    * This function facilitates a very limited way of making your charts
    * whilst letting the rest of page continue - using  the setTimeout function
    * 
    * @param function func The function to run that creates the chart
    */
    RG.async =
    RG.Async = function (func)
    {
        return setTimeout(func, arguments[1] ? arguments[1] : 1);
    };
    
    /**
    * Resets (more than just clears) the canvas and clears any pertinent objects
    * from the ObjectRegistry
    * 
    * @param object ca The canvas object (as returned by document.getElementById() ).
    */
    RG.reset =
    RG.Reset = function (ca)
    {
        ca.width = ca.width;
        
        RG.ObjectRegistry.clear(ca);
        
        ca.__rgraph_aa_translated__ = false;

        if (RG.text2.domNodeCache && RG.text2.domNodeCache.reset) {
            RG.text2.domNodeCache.reset(ca);
        }

        // Create the node and dimension caches if they don't already exist
        if (!RG.text2.domNodeCache)          { RG.text2.domNodeCache          = []; }
        if (!RG.text2.domNodeDimensionCache) { RG.text2.domNodeDimensionCache = []; }

        // Create/reset the specific canvas arrays in the caches
        RG.text2.domNodeCache[ca.id]          = [];
        RG.text2.domNodeDimensionCache[ca.id] = [];
    };
    

    /**
    * Put the attribution on the canvas IF textAccessible is enabled.
    * By default it adds the attribution in the bottom right corner.
    * 
    * @param object obj The chart object
    */
    RG.att = 
    RG.attribution = function (obj)
    {
        var ca        = obj.canvas,
            co        = obj.context,
            prop      = obj.properties;

        if (!ca || !co) {
            return;
        }

        // Needs to be a new var... statement here
        var width     = ca.width,
            height    = ca.height,
            wrapper   = document.getElementById('cvs').__object__.canvas.parentNode,
            text      = prop['chart.attribution.text'] || 'Free Charts with RGraph.net',
            x         = prop['chart.attribution.x'],           // null
            y         = prop['chart.attribution.y'],           // null
            bold      = prop['chart.attribution.bold'],   // false
            italic    = prop['chart.attribution.italic'], // true
            font      = prop['chart.attribution.font'] || 'sans-serif', // sans-serif
            size      = prop['chart.attribution.size'] || 8, // 8
            underline = prop['chart.attribution.underline'] ? 'underline' : 'none', // false
            color     = typeof prop['chart.attribution.color'] === 'string' ? prop['chart.attribution.color'] : '',
            href      = typeof prop['chart.attribution.href'] === 'string' ? prop['chart.attribution.href'] : 'http://www.rgraph.net/canvas/index.html';

        if (wrapper.attribution_node) {
            return;
        }

        
        // Take some measurements
        var measurements = RG.measureText(text, bold, font, size);

        // Create the link
        var a                      = document.createElement('A');
            a.href                 = href;
            a.innerHTML            = text;
            a.target               = '_blank';
            a.style.position       = 'absolute';
            a.style.left           = typeof x === 'number' ? x : wrapper.offsetWidth - measurements[0] - 5 + 'px';
            a.style.top            = typeof y === 'number' ? y : wrapper.offsetHeight - measurements[1] + 'px';
            a.style.fontSize       = size + 'pt';
            a.style.fontStyle      = typeof italic === 'boolean'  ? (italic ? 'italic' : '') : 'italic',
            a.style.fontWeight     = bold ? 'bold' : '',
            a.style.textDecoration = underline;
            a.style.fontFamily     = font;
            a.style.color          = color;
        wrapper.appendChild(a);
        
        wrapper.attribution_node = a;
    };
    

    /**
    * This function is due to be removed.
    * 
    * @param string id The ID of what can be either the canvas tag or a DIV tag
    */
    RG.getCanvasTag = function (id)
    {
        id = typeof id === 'object' ? id.id : id;
        var canvas = doc.getElementById(id);

        return [id, canvas];
    };
    
    /**
    * A wrapper function that encapsulate requestAnimationFrame
    * 
    * @param function func The animation function
    */
    RG.Effects.updateCanvas =
    RG.Effects.UpdateCanvas = function (func)
    {
        win.requestAnimationFrame =    win.requestAnimationFrame
                                    || win.webkitRequestAnimationFrame
                                    || win.msRequestAnimationFrame
                                    || win.mozRequestAnimationFrame
                                    || (function (func){setTimeout(func, 16.666);});
        
        win.requestAnimationFrame(func);
    };
    
    /**
    * This function returns an easing multiplier for effects so they eas out towards the
    * end of the effect.
    * 
    * @param number frames The total number of frames
    * @param number frame  The frame number
    */
    RG.Effects.getEasingMultiplier = function (frames, frame)
    {
        return ma.pow(ma.sin((frame / frames) * RG.HALFPI), 3);
    };
    
    /**
    * This function converts an array of strings to an array of numbers. Its used by the meter/gauge
    * style charts so that if you want you can pass in a string. It supports various formats:
    * 
    * '45.2'
    * '-45.2'
    * ['45.2']
    * ['-45.2']
    * '45.2,45.2,45.2' // A CSV style string
    * 
    * @param number frames The string or array to parse
    */
    RG.stringsToNumbers = function (str)
    {
        // An optional seperator to use intead of a comma
        var sep = arguments[1] || ',';
        
        
        // If it's already a number just return it
        if (typeof str === 'number') {
            return str;
        }
        

        if (typeof str === 'string') {
            if (str.indexOf(sep) != -1) {
                str = str.split(sep);
            } else {
                str = parseFloat(str);
            }
        }
        

        if (typeof str === 'object' && !RG.isNull(str)) {
            for (var i=0,len=str.length; i<len; i+=1) {
                str[i] = parseFloat(str[i]);
            }
        }

        return str;
    };
    
    /**
    * Drawing cache function. This function creates an off-screen canvas and draws [wwhatever] to it
    * and then subsequent calls use that  instead of repeatedly drawing the same thing.
    * 
    * @param object   obj  The graph object
    * @param string   id   An ID string used to identify the relevant entry in the cache
    * @param function func The drawing function. This will be called to do the draw.
    */
    RG.cachedDraw = function (obj, id, func)
    {
        //If the cache entry exists - just copy it across to the main canvas
        if (!RG.cache[id]) {

            RG.cache[id] = {};

            RG.cache[id].object = obj;
            RG.cache[id].canvas = document.createElement('canvas');

            RG.cache[id].canvas.setAttribute('width', obj.canvas.width);
            RG.cache[id].canvas.setAttribute('height', obj.canvas.height);
            RG.cache[id].canvas.setAttribute('id', 'background_cached_canvas' + obj.canvas.id);

            RG.cache[id].canvas.__object__ = obj;
            RG.cache[id].context = RG.cache[id].canvas.getContext('2d');
            
            // Antialiasing on the cache canvas
            RG.cache[id].context.translate(0.5,0.5);

            // Call the function
            func(obj, RG.cache[id].canvas, RG.cache[id].context);
        }

        // Now copy the contents of the cached canvas over to the main one.
        // The coordinates are -0.5 because of the anti-aliasing effect in
        // use on the main canvas
        obj.context.drawImage(RG.cache[id].canvas,-0.5,-0.5);
    };
    
    /**
    * The function that runs through the supplied configuration and
    * converts it to the RGraph stylee.
    * 
    * @param object conf The config
    * @param object      The settings for the object
    */
    RG.parseObjectStyleConfig = function (obj, config)
    {
        /**
        * The recursion function
        */
        var recurse = function (obj, config, name, settings)
        {
            var i;
    
            for (key in config) {

                // Allow for functions in the configuration. Run them immediately
                if (key.match(/^exec[0-9]*$/)) {
                    (config[key])(obj, settings);
                    continue;
                }

                var isObject = false; // Default value
                var isArray  = false; // Default value
                var value    = config[key];

                // Change caps to dots. Eg textSize => text.size
                while(key.match(/([A-Z])/)) {
                    key = key.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());
                }

                if (!RG.isNull(value) && value.constructor) {
                    isObject = value.constructor.toString().indexOf('Object') > 0;
                    isArray  = value.constructor.toString().indexOf('Array') > 0;
                }

                if (isObject && !isArray) {
                    recurse(obj, config[key], name + '.' + key, settings);
                
                } else if (key === 'self') {
                    settings[name] = value;

                } else {
                    settings[name + '.' + key] = value;
                }
            }

            return settings;
        };
        
        /**
        * Go through the settings that we've been given
        */
        var settings = recurse(obj, config, 'chart', {});

        /**
        * Go through the settings and set them on the object
        */
        for (key in settings) {
            if (typeof key === 'string') {
                obj.set(key, settings[key]);
            }
        }
    };
    
    /**
    * This function is a short-cut for the canvas path syntax (which can be rather
    * verbose). You can read a description of it (which details all of the
    * various options) on the RGraph blog (www.rgraph.net/blog). The function is
    * added to the CanvasRenderingContext2D object so it becomes a context function.
    * 
    * So you can use it like these examples show:
    * 
    * 1. RG.path2(context, 'b r 0 0 50 50 f red');
    * 2. RG.path2(context, 'b a 50 50 50 0 3.14 false f red');
    * 3. RG.path2(context, 'b m 5 100 bc 5 0 100 0 100 100 s red');
    * 4. RG.path2(context, 'b m 5 100 at 50 0 95 100 50 s red');
    * 5. RG.path2(context, 'sa b r 0 0 50 50 c b r 5 5 590 240 f red rs');
    * 6. RG.path2(context, 'ld [2,6] ldo 4 b r 5 5 590 240 f red');
    * 7. RG.path2(context, 'ga 0.25 b r 5 5 590 240 f red');
    * 
    * @param   array p  The path details
    */
    RG.path2 = function (co, p)
    {
        // Save this functions arguments
        var args = arguments;

        
        // If the path was a string - split it then collapse quoted bits together
        if (typeof p === 'string') {
            p = splitstring(p);
        }

        // Store the last path on the RGraph object
        RG.path2.last = RG.arrayClone(p);

        // Go through the path information.
        for (var i=0,len=p.length; i<len; i+=1) {

            switch (p[i]) {
                case 'b':co.beginPath();break;
                case 'c':co.closePath();break;
                case 'm':co.moveTo(parseFloat(p[i+1]),parseFloat(p[i+2]));i+=2;break;
                case 'l':co.lineTo(parseFloat(p[i+1]),parseFloat(p[i+2]));i+=2;break;
                case 's':if(p[i+1])co.strokeStyle=p[i+1];co.stroke();i++;break;
                case 'f':if(p[i+1]){co.fillStyle=p[i+1];}co.fill();i++;break;
                case 'qc':co.quadraticCurveTo(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]));i+=4;break;
                case 'bc':co.bezierCurveTo(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]),parseFloat(p[i+5]),parseFloat(p[i+6]));i+=6;break;
                case 'r':co.rect(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]));i+=4;break;
                case 'a':co.arc(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]),parseFloat(p[i+5]),p[i+6]==='true'||p[i+6]===true||p[i+6]===1||p[i+6]==='1'?true:false);i+=6;break;
                case 'at':co.arcTo(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]),parseFloat(p[i+5]));i+=5;break;
                case 'lw':co.lineWidth=parseFloat(p[i+1]);i++;break;
                case 'e':co.ellipse(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]),parseFloat(p[i+5]),parseFloat(p[i+6]),parseFloat(p[i+7]),p[i+8] === 'true' ? true : false);i+=8;break;
                case 'lj':co.lineJoin=p[i+1];i++;break;
                case 'lc':co.lineCap=p[i+1];i++;break;
                case 'sc':co.shadowColor=p[i+1];i++;break;
                case 'sb':co.shadowBlur=parseFloat(p[i+1]);i++;break;
                case 'sx':co.shadowOffsetX=parseFloat(p[i+1]);i++;break;
                case 'sy':co.shadowOffsetY=parseFloat(p[i+1]);i++;break;
                case 'fs':co.fillStyle=p[i+1];i++;break;
                case 'ss':co.strokeStyle=p[i+1];i++;break;
                case 'fr':co.fillRect(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]));i+=4;break;
                case 'sr':co.strokeRect(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]));i+=4;break;
                case 'cl':co.clip();break;
                case 'sa':co.save();break;
                case 'rs':co.restore();break;
                case 'tr':co.translate(parseFloat(p[i+1]),parseFloat(p[i+2]));i+=2;break;
                case 'sl':co.scale(parseFloat(p[i+1]), parseFloat(p[i+2]));i+=2;break;
                case 'ro':co.rotate(parseFloat(p[i+1]));i++;break;
                case 'tf':co.transform(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]),parseFloat(p[i+5]),parseFloat(p[i+6]));i+=6;break;
                case 'stf':co.setTransform(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]),parseFloat(p[i+5]),parseFloat(p[i+6]));i+=6;break;
                case 'cr':co.clearRect(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]));i+=4;break;
                case 'ld':var parts = p[i+1];co.setLineDash(parts);i+=1;break;
                case 'ldo':co.lineDashOffset=p[i+1];i++;break;
                case 'fo':co.font=p[i+1];i++;break;
                case 'ft':co.fillText(p[i+1], parseFloat(p[i+2]), parseFloat(p[i+3]));i+=3;break;
                case 'st':co.strokeText(p[i+1], parseFloat(p[i+2]), parseFloat(p[i+3]));i+=3;break;
                case 'ta':co.textAlign=p[i+1];i++;break;
                case 'tbl':co.textBaseline=p[i+1];i++;break;
                case 'ga':co.globalAlpha=parseFloat(p[i+1]);i++;break;
                case 'gco':co.globalCompositeOperation=p[i+1];i++;break;
                case 'fu':(p[i+1])(co.canvas.__object__);i++;break;
                
                // Empty option - ignore it
                case '':break;
                
                // Unknown option
                default: alert('[ERROR] Unknown option: ' + p[i]);
            }
        }
        
        function splitstring (p)
        {
            var ret = [], buffer = '', inquote = false, quote = '', substitutionIndex = 2;

            for (var i=0; i<p.length; i+=1) {
                
                var chr = p[i],
                    isWS = chr.match(/ /);

                if (isWS) {
                    if (!inquote) {
                    
                        // Get rid of any enclosing quotes
                        if (buffer[0] === '"' || buffer[0] === "'") {
                            buffer = buffer.substr(1, buffer.length - 2);
                        }


                        // String substitution
                        if (buffer.trim() === '%' && typeof args[substitutionIndex] !== 'undefined') {
                            buffer = args[substitutionIndex++];
                        }

                        ret.push(buffer);
                        buffer = '';
                    } else {
                        buffer += chr;
                    }
                } else {
                    if (chr === "'" || chr === '"') {
                        inquote = !inquote;
                    }

                    buffer += chr;
                }
            }

            // Do the last bit (including substitution)
            if (buffer.trim() === '%' && args[substitutionIndex]) {
                buffer = args[substitutionIndex++];
            }

            ret.push(buffer);

            return ret;
        }
    };
    
    //
    // Wraps the canvas in a DIV to allow DOM text to be used
    //
    // NOT USED ANY MORE
    //
    RG.wrap = function () {};
    
// End module pattern
})(window, document);

    /**
    * Uses the alert() function to show the structure of the given variable
    * 
    * @param mixed v The variable to print/alert the structure of
    */
    window.$p = function (v)
    {
        RGraph.pr(arguments[0], arguments[1], arguments[3]);
    };
    
    /**
    * A shorthand for the default alert() function
    */
    window.$a = function (v)
    {
        alert(v);
    };
    
    /**
    * Short-hand for console.log
    * 
    * @param mixed v The variable to log to the console
    */
    window.$cl = function (v)
    {
        return console.log(v);
    };
    
    /**
    * A basic string formatting function. Use it like this:
    * 
    * var str = '{0} {1} {2}'.format('a', 'b', 'c');
    * 
    * Outputs: a b c
    */
    if (!String.prototype.format) {
      String.prototype.format = function()
      {
        var args = arguments;

        return this.replace(/{(\d+)}/g, function(str, idx)
        {
          return typeof args[idx - 1] !== 'undefined' ? args[idx - 1] : str;
        });
      };
    }


    RGraph = window.RGraph || {isRGraph: true};

    RGraph.CSV = function (url, func)
    {
        var RG  = RGraph,
            ua  = navigator.userAgent,
            ma  = Math;

        /**
        * Some default values
        */
        this.url       = url;
        this.ready     = func;
        this.data      = null;
        this.numrows   = null;
        this.numcols   = null;
        this.seperator = arguments[2] || ',';
        this.endofline = arguments[3] || /\r?\n/;
        this.uid       = RGraph.createUID();

        /**
        * A Custom split function
        * 
        * @param string str  The CSV string to split
        * @param mixed  char The character to split on - or it can also be an object like this:
        *                    {
        *                        preserve: false, // Whether to preserve whitespace
        *                        char: ','        // The character to split on
        *                    }
        */
        this.splitCSV = function (str, split)
        {
            // Defaults
            var arr            = [];
            var field          = '';
            var inDoubleQuotes = false;
            var inSingleQuotes = false;
            var preserve       = (typeof split === 'object' && split.preserve) ? true : false;
            
            // The character to split the CSV string on
            if (typeof split === 'object') {
                if (typeof split.char === 'string') {
                    split = split.char;
                } else {
                    split = ',';
                }
            } // If not an object just leave the char as it's supplied
                        for (var i=0,len=str.length; i<len; i+=1) {
                
                char = str.charAt(i);
                
                if ( (char === '"') && !inDoubleQuotes) {
                    inDoubleQuotes = true;
                    continue;
                
                } else if ( (char === '"') && inDoubleQuotes) {
                    inDoubleQuotes = false;
                    continue;
                }
                if ( (char === "'") && !inSingleQuotes) {
                    inSingleQuotes = true;
                    continue;
                
                } else if ( (char === "'") && inSingleQuotes) {
                    inSingleQuotes = false;
                    continue;
    
                } else if (char === split && !inDoubleQuotes && !inSingleQuotes) {
// TODO look ahead in order to allow for multi-character seperators
                    arr.push(field);
                    field = '';
                    continue;
    
                } else {
                    field = field + char;
                }
            }
            
            // Add the last field
            arr.push(field);
            
            // Now trim each value if necessary
            if (!preserve) {
                for (i=0,len=arr.length; i<len; i+=1) {
                    arr[i] = arr[i].trim();
                }
            }
    
            return arr;
        };

        /**
        * This function splits the CSV data into an array so that it can be useful.
        */
        this.fetch = function ()
        {
            var sep = this.seperator,
                eol = this.endofline,
                obj = this;

            if (this.url.substring(0,3) === 'id:' || this.url.substring(0,4) === 'str:') {

                // Get rid of any surrounding whitespace
                if (this.url.substring(0,3) === 'id:') {
                    var data = document.getElementById(this.url.substring(3)).innerHTML.trim();
                
                } else if (this.url.substring(0,4) === 'str:') {
                    var data = this.url.substring(4).trim();
                }

                // Store the CSV data on the CSV object (ie - this object)
                obj.data = data.split(eol);

                // Store the number of rows
                obj.numrows = obj.data.length;

                for (var i=0,len=obj.data.length; i<len; i+=1) {


                    /**
                    * Split the individual line
                    */
                    //var row = obj.data[i].split(sep);
                    var row = obj.splitCSV(obj.data[i], {preserve: false, char: sep});


                    if (!obj.numcols) {
                        obj.numcols = row.length;
                    }

                    /**
                    * If the cell is purely made up of numbers - convert it
                    */
                    for (var j=0; j<row.length; j+=1) {
                        if ((/^\-?[0-9.]+$/).test(row[j])) {
                            row[j] = parseFloat(row[j]);
                        }
                            
                        // Assign the split-up-row back to the data array
                        obj.data[i] = row;
                    }
                }
                
                // Call the ready function straight away
                obj.ready(obj);

            } else {

                RGraph.AJAX.getString(this.url, function (data)
                {
                    data = data.replace(/(\r?\n)+$/, '');

                    /**
                    * Split the lines in the CSV
                    */
                    obj.data = data.split(eol);

                    /**
                    * Store the number of rows
                    */
                    obj.numrows = obj.data.length;
                                        /**
                    * Loop thru each lines in the CSV file
                    */
                    for (var i=0,len=obj.data.length; i<len; i+=1) {
                        /**
                        * Use the new split function to split each row NOT preserving whitespace
                        */
                        //var row = obj.data[i].split(sep);
                        var row = obj.splitCSV(obj.data[i], {preserve: false, char: sep});

                        if (!obj.numcols) {
                            obj.numcols = row.length;
                        }

                        /**
                        * If the cell is purely made up of numbers - convert it
                        */
                        for (var j=0; j<row.length; j+=1) {
                            if ((/^\-?[0-9.]+$/).test(row[j])) {
                                row[j] = parseFloat(row[j]);
                            }

                            // Assign the split-up-row back to the data array
                            obj.data[i] = row;
                        }
                    }

                    // Call the ready function straight away
                    obj.ready(obj);
                });
            }
        };

        /**
        * Returns a row of the CSV file
        * 
        * @param number index The index of the row to fetch
        * @param        start OPTIONAL If desired you can specify a column to start at (which starts at 0 by default)
        */
        this.getRow = function (index)
        {
            var row   = [];
            var start = arguments[1] || 0;

            for (var i=start; i<this.numcols; i+=1) {
                row.push(this.data[index][i]);
            }
            
            return row;
        };

        /**
        * Returns a column of the CSV file
        * 
        * @param number index The index of the column to fetch
        * @param        start OPTIONAL If desired you can specify a row to start at (which starts at 0 by default)
        */
        this.getCol =
        this.getColumn = function (index)
        {
            var col   = [];
            var start = arguments[1] || 0;

            for (var i=start; i<this.numrows; i+=1) {
                col.push(this.data[i][index]);
            }
            
            return col;
        };


        // Fetch the CSV file
        this.fetch();
    };


    RGraph = window.RGraph || {isRGraph: true};

    /**
    * The line chart constructor
    * 
    * @param object canvas The cxanvas object
    * @param array  ...    The lines to plot
    */
    RGraph.Line = function (conf)
    {
        /**
        * Allow for object config style
        */
        if (   typeof conf === 'object'
            && typeof conf.data === 'object'
            && typeof conf.id === 'string') {

            var id                        = conf.id;
            var canvas                    = document.getElementById(id);
            var data                      = conf.data;
            var parseConfObjectForOptions = true; // Set this so the config is parsed (at the end of the constructor)
        
        } else {
        
            var id     = conf;
            var canvas = document.getElementById(id);
            var data   = arguments[1];
        }
        
        this.id                 = id;
        this.canvas             = canvas;
        this.context            = this.canvas.getContext('2d');
        this.canvas.__object__  = this;
        this.type               = 'line';
        this.max                = 0;
        this.coords             = [];
        this.coords2            = [];
        this.coords.key         = [];
        this.coordsText         = [];
        this.coordsSpline       = [];
        this.coordsAxes         = {xaxis: [], yaxis: []};
        this.hasnegativevalues  = false;
        this.isRGraph           = true;
        this.uid                = RGraph.CreateUID();
        this.canvas.uid         = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();
        this.colorsParsed       = false;
        this.original_colors    = [];
        this.firstDraw          = true; // After the first draw this will be false


        /**
        * Compatibility with older browsers
        */
        //RGraph.OldBrowserCompat(this.context);


        // Various config type stuff
        this.properties =
        {
            'chart.background.barcolor1':   'rgba(0,0,0,0)',
            'chart.background.barcolor2':   'rgba(0,0,0,0)',
            'chart.background.grid':        1,
            'chart.background.grid.width':  1,
            'chart.background.grid.hsize':  25,
            'chart.background.grid.vsize':  25,
            'chart.background.grid.color':  '#ddd',
            'chart.background.grid.vlines': true,
            'chart.background.grid.hlines': true,
            'chart.background.grid.border': true,
            'chart.background.grid.autofit':           true,
            'chart.background.grid.autofit.align':     true,
            'chart.background.grid.autofit.numhlines': 5,
            'chart.background.grid.autofit.numvlines': null,
            'chart.background.grid.dashed': false,
            'chart.background.grid.dotted': false,
            'chart.background.hbars':       null,
            'chart.background.image':       null,
            'chart.background.image.stretch': true,
            'chart.background.image.x':     null,
            'chart.background.image.y':     null,
            'chart.background.image.w':     null,
            'chart.background.image.h':     null,
            'chart.background.image.align': null,
            'chart.background.color':       null,
            'chart.labels':                 null,
            'chart.labels.bold':            false,
            'chart.labels.color':           null,
            'chart.labels.ingraph':         null,
            'chart.labels.above':            false, // Working
            'chart.labels.above.size':       8, // Working
            'chart.labels.above.decimals':   null, // Working
            'chart.labels.above.color':      null,
            'chart.labels.above.background': 'white',
            'chart.labels.above.font':       null,
            'chart.labels.above.border':     true,
            'chart.labels.above.offsety':     5,
            'chart.labels.above.units.pre':  '',
            'chart.labels.above.units.post': '',
            'chart.labels.above.specific':   null,
            'chart.labels.offsetx':         0,
            'chart.labels.offsety':         0,
            'chart.xtickgap':               20,
            'chart.smallxticks':            3,
            'chart.largexticks':            5,
            'chart.ytickgap':               20,
            'chart.smallyticks':            3,
            'chart.largeyticks':            5,
            'chart.numyticks':              10,
            'chart.linewidth':              2.01,
            'chart.colors':                 ['red', '#0f0', '#00f', '#f0f', '#ff0', '#0ff','green','pink','blue','black'],
            'chart.hmargin':                0,
            'chart.tickmarks.dot.stroke':   'white',
            'chart.tickmarks.dot.fill':     null,
            'chart.tickmarks.dot.linewidth': 3,
            'chart.tickmarks':              'endcircle',
            'chart.tickmarks.linewidth':    null,
            'chart.tickmarks.image':        null,
            'chart.tickmarks.image.halign': 'center',
            'chart.tickmarks.image.valign': 'center',
            'chart.tickmarks.image.offsetx':0,
            'chart.tickmarks.image.offsety':0,
            'chart.ticksize':               3,
            'chart.gutter.left':            25,
            'chart.gutter.right':           25,
            'chart.gutter.top':             25,
            'chart.gutter.bottom':          30,
            'chart.tickdirection':          -1,
            'chart.yaxispoints':            5,
            'chart.fillstyle':              null,
            'chart.xaxispos':               'bottom',
            'chart.xaxispos.value':         0,
            'chart.yaxispos':               'left',
            'chart.xticks':                 null,
            'chart.text.size':              12,
            'chart.text.angle':             0,
            'chart.text.color':             'black',
            'chart.text.font':              'Arial, Verdana, sans-serif',
            'chart.text.accessible':               true,
            'chart.text.accessible.overflow':      'visible',
            'chart.text.accessible.pointerevents': false,
            'chart.ymin':                   0,
            'chart.ymax':                   null,
            'chart.title':                  '',
            'chart.title.background':       null,
            'chart.title.hpos':             null,
            'chart.title.vpos':             null,
            'chart.title.bold':             true,
            'chart.title.font':             null,
            'chart.title.xaxis':            '',
            'chart.title.xaxis.bold':       true,
            'chart.title.xaxis.size':       null,
            'chart.title.xaxis.font':       null,
            'chart.title.xaxis.color':      null,
            'chart.title.yaxis':            '',
            'chart.title.yaxis.bold':       true,
            'chart.title.yaxis.size':       null,
            'chart.title.yaxis.font':       null,
            'chart.title.yaxis.color':      null,
            'chart.title.xaxis.pos':        null,
            'chart.title.yaxis.pos':        null,
            'chart.title.yaxis.x':          null,
            'chart.title.yaxis.y':          null,
            'chart.title.xaxis.x':          null,
            'chart.title.xaxis.y':          null,
            'chart.title.x':                null,
            'chart.title.y':                null,
            'chart.title.halign':           null,
            'chart.title.valign':           null,
            'chart.shadow':                 true,
            'chart.shadow.offsetx':         2,
            'chart.shadow.offsety':         2,
            'chart.shadow.blur':            3,
            'chart.shadow.color':           'rgba(128,128,128,0.5)',
            'chart.tooltips':               null,
            'chart.tooltips.hotspot.xonly': false,
            'chart.tooltips.hotspot.size':  5,
            'chart.tooltips.effect':        'fade',
            'chart.tooltips.css.class':     'RGraph_tooltip',
            'chart.tooltips.event':         'onmousemove',
            'chart.tooltips.highlight':     true,
            'chart.tooltips.coords.page':   false,
            'chart.highlight.style':        null,
            'chart.highlight.stroke':       'gray',
            'chart.highlight.fill':         'white',
            'chart.stepped':                false,
            'chart.key':                    null,
            'chart.key.background':         'white',
            'chart.key.position':           'graph',
            'chart.key.halign':             null,
            'chart.key.shadow':             false,
            'chart.key.shadow.color':       '#666',
            'chart.key.shadow.blur':        3,
            'chart.key.shadow.offsetx':     2,
            'chart.key.shadow.offsety':     2,
            'chart.key.position.gutter.boxed': false,
            'chart.key.position.x':         null,
            'chart.key.position.y':         null,
            'chart.key.color.shape':        'square',
            'chart.key.rounded':            true,
            'chart.key.linewidth':          1,
            'chart.key.colors':             null,
            'chart.key.interactive':        false,
            'chart.key.interactive.highlight.chart.stroke': 'rgba(255,0,0,0.3)',
            'chart.key.interactive.highlight.label': 'rgba(255,0,0,0.2)',
            'chart.key.text.color':         'black',
            'chart.contextmenu':            null,
            'chart.ylabels':                true,
            'chart.ylabels.count':          5,
            'chart.ylabels.inside':         false,
            'chart.ylabels.offsetx':        0,
            'chart.ylabels.offsety':        0,
            'chart.scale.invert':           false,
            'chart.xlabels.inside':         false,
            'chart.xlabels.inside.color':   'rgba(255,255,255,0.5)',
            'chart.noaxes':                 false,
            'chart.noyaxis':                false,
            'chart.noxaxis':                false,
            'chart.noendxtick':             false,
            'chart.noendytick':             false,
            'chart.units.post':             '',
            'chart.units.pre':              '',
            'chart.scale.zerostart':        true,
            'chart.scale.decimals':         null,
            'chart.scale.point':            '.',
            'chart.scale.thousand':         ',',
            'chart.crosshairs':             false,
            'chart.crosshairs.color':       '#333',
            'chart.crosshairs.hline':       true,
            'chart.crosshairs.vline':       true,
            'chart.annotatable':            false,
            'chart.annotate.color':         'black',
            'chart.axesontop':              false,
            'chart.filled':                 false,
            'chart.filled.range':           false,
            'chart.filled.range.threshold': null,
            'chart.filled.range.threshold.colors': ['red', 'green'],
            'chart.filled.accumulative':    true,
            'chart.variant':                null,
            'chart.axis.color':             'black',
            'chart.axis.linewidth':         1,
            'chart.numxticks':              (data && typeof(data[0]) == 'number' ? data.length - 1 : (typeof data[0] === 'object' && data[0] && typeof data[0][0] === 'number' ? data[0].length - 1 : 20)),
            'chart.numyticks':              10,
            'chart.zoom.factor':            1.5,
            'chart.zoom.fade.in':           true,
            'chart.zoom.fade.out':          true,
            'chart.zoom.hdir':              'right',
            'chart.zoom.vdir':              'down',
            'chart.zoom.frames':            25,
            'chart.zoom.delay':             16.666,
            'chart.zoom.shadow':            true,
            'chart.zoom.background':        true,
            'chart.zoom.action':            'zoom',
            'chart.backdrop':               false,
            'chart.backdrop.size':          30,
            'chart.backdrop.alpha':         0.2,
            'chart.resizable':              false,
            'chart.resize.handle.adjust':   [0,0],
            'chart.resize.handle.background': null,
            'chart.adjustable':             false,
            'chart.adjustable.only':        null,
            'chart.noredraw':               false,
            'chart.outofbounds':            false,
            'chart.outofbounds.clip':       false,
            'chart.chromefix':              true,
            'chart.animation.factor':       1,
            'chart.animation.unfold.x':     false,
            'chart.animation.unfold.y':     true,
            'chart.animation.unfold.initial': 2,
            'chart.animation.trace.clip':     1,
            'chart.curvy':                    false,
            'chart.line.visible':             [],
            'chart.events.click':             null,
            'chart.events.mousemove':         null,
            'chart.errorbars':              false,
            'chart.errorbars.color':        'black',
            'chart.errorbars.capped':        true,
            'chart.errorbars.capped.width':   12,
            'chart.errorbars.linewidth':     1,
            'chart.combinedchart.effect':     null,
            'chart.combinedchart.effect.options':  null,
            'chart.combinedchart.effect.callback': null,
            'chart.clearto':   'rgba(0,0,0,0)',
            'chart.dotted':     false,
            'chart.dashed':     false
        }

        /**
        * Change null arguments to empty arrays
        */
        for (var i=1; i<arguments.length; ++i) {
            if (typeof(arguments[i]) == 'null' || !arguments[i]) {
                arguments[i] = [];
            }
        }


        /**
        * Store the original data. This also allows for giving arguments as one big array.
        */
        this.original_data = [];

        // This allows for the new object based configuration style
        if (typeof conf === 'object' && conf.data) {
            if (typeof conf.data[0] === 'number' || RGraph.isNull(conf.data[0])) {

                this.original_data[0] = RGraph.arrayClone(conf.data);

            //} else if (typeof conf.data[0] === 'object' && !RGraph.isNull(conf.data[0])) {
            } else {

                for (var i=0; i<conf.data.length; ++i) {
                    this.original_data[i] = RGraph.arrayClone(conf.data[i]);
                }
            }

        // Allow for the older configuration style
        } else {
            for (var i=1; i<arguments.length; ++i) {
                
                if (   arguments[1]
                    && typeof(arguments[1]) == 'object'
                    && arguments[1][0]
                    && typeof(arguments[1][0]) == 'object'
                    && arguments[1][0].length) {
    
                    var tmp = [];
    
                    for (var i=0; i<arguments[1].length; ++i) {
                        tmp[i] = RGraph.array_clone(arguments[1][i]);
                    }
    
                    for (var j=0; j<tmp.length; ++j) {
                        this.original_data[j] = RGraph.array_clone(tmp[j]);
                    }
    
                } else {
                    this.original_data[i - 1] = RGraph.array_clone(arguments[i]);
                }
            }
        }


        // Check for support
        if (!this.canvas) {
            alert('[LINE] Fatal error: no canvas support');
            return;
        }
        
        // Convert strings to numbers
        for (var i=0; i<this.original_data.length; ++i) {
            for (var j=0; j<this.original_data[i].length; ++j) {
                if (typeof this.original_data[i][j] === 'string') {
                    this.original_data[i][j] = parseFloat(this.original_data[i][j]);
                }
            }
        }

        
        /**
        * Store the data here as one big array
        */
        this.data_arr = RGraph.arrayLinearize(this.original_data);

        for (var i=0; i<this.data_arr.length; ++i) {
            this['$' + i] = {};
        }


        /**
        * Translate half a pixel for antialiasing purposes - but only if it hasn't beeen
        * done already
        */
        if (!this.canvas.__rgraph_aa_translated__) {
            this.context.translate(0.5,0.5);
            
            this.canvas.__rgraph_aa_translated__ = true;
        }
        
        // Short variable names
        var RG   = RGraph,
            ca   = this.canvas,
            co   = ca.getContext('2d'),
            prop = this.properties,
            pa2  = RG.path2,
            win  = window,
            doc  = document,
            ma   = Math
        
        
        
        /**
        * "Decorate" the object with the generic effects if the effects library has been included
        */
        if (RG.Effects && typeof RG.Effects.decorate === 'function') {
            RG.Effects.decorate(this);
        }
        
            
        /**
        * An all encompassing accessor
        * 
        * @param string name The name of the property
        * @param mixed value The value of the property
        */
        this.set =
        this.Set = function (name)
        {
            var value = typeof arguments[1] === 'undefined' ? null : arguments[1];

            /**
            * the number of arguments is only one and it's an
            * object - parse it for configuration data and return.
            */
            if (arguments.length === 1 && typeof name === 'object') {
                RG.parseObjectStyleConfig(this, name);
                return this;
            }
            
    
            /**
            * This should be done first - prepend the propertyy name with "chart." if necessary
            */
            if (name.substr(0,6) != 'chart.') {
                name = 'chart.' + name;
            }
            
            // Convert uppercase letters to dot+lower case letter
            while(name.match(/([A-Z])/)) {
                name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());
            }
                        // Consolidate the tooltips
            if (name == 'chart.tooltips' && typeof value == 'object' && value) {
    
                var tooltips = [];
    
                for (var i=1; i<arguments.length; i++) {
                    if (typeof(arguments[i]) == 'object' && arguments[i][0]) {
                        for (var j=0; j<arguments[i].length; j++) {
                            tooltips.push(arguments[i][j]);
                        }
    
                    } else if (typeof(arguments[i]) == 'function') {
                        tooltips = arguments[i];
    
                    } else {
                        tooltips.push(arguments[i]);
                    }
                }
    
                // Because "value" is used further down at the end of this function, set it to the expanded array os tooltips
                value = tooltips;
            }
    
            
            /**
            * If (buggy) Chrome and the linewidth is 1, change it to 1.01
            */
            if (name == 'chart.linewidth' && navigator.userAgent.match(/Chrome/)) {
                if (value == 1) {
                    value = 1.01;
                
                } else if (RGraph.is_array(value)) {
                    for (var i=0; i<value.length; ++i) {
                        if (typeof(value[i]) == 'number' && value[i] == 1) {
                            value[i] = 1.01;
                        }
                    }
                }
            }
    
    
            /**
            * Check for xaxispos
            */
            if (name == 'chart.xaxispos' ) {
                if (value != 'bottom' && value != 'center' && value != 'top') {
                    alert('[LINE] (' + this.id + ') chart.xaxispos should be top, center or bottom. Tried to set it to: ' + value + ' Changing it to center');
                    value = 'center';
                }
            }
    
    
            /**
            * chart.xticks is now called chart.numxticks
            */
            if (name == 'chart.xticks') {
                name = 'chart.numxticks';
            }
    
    
            /**
            * Change the new chart.spline option to chart.curvy
            */
            if (name == 'chart.spline') {
                name = 'chart.curvy';
            }
    
    
            /**
            * Chnge chart.ylabels.invert to chart.scale.invert
            */
            if (name == 'chart.ylabels.invert') {
                name = 'chart.scale.invert';
            }
            

    
    
            this.properties[name] = value;
    
            return this;
        };
        
        /**
        * An all encompassing accessor
        * 
        * @param string name The name of the property
        */
        this.get =
        this.Get = function (name)
        {
            /**
            * This should be done first - prepend the property name with "chart." if necessary
            */
            if (name.substr(0,6) != 'chart.') {
                name = 'chart.' + name;
            }

            // Convert uppercase letters to dot+lower case letter
            while(name.match(/([A-Z])/)) {
                name = name.replace(/([A-Z])/, '.' + RegExp.$1.toLowerCase());
            }
            
            /**
            * If requested property is chart.spline - change it to chart.curvy
            */
            if (name == 'chart.spline') {
                name = 'chart.curvy';
            }
    
            return prop[name];
        };
        
        /**
        * The function you call to draw the line chart
        * 
        * @param bool An optional bool used internally to ditinguish whether the
        *             line chart is being called by the bar chart
        * 
        * Draw()
        *  |
        *  +--Draw()
        *  |  |
        *  |  +-DrawLine()
        *  |
        *  +-RedrawLine()
        *     |
        *     +-DrawCurvyLine()
        *        |
        *        +-DrawSpline()
        */
        this.draw =
        this.Draw = function ()
        {
            // MUST be the first thing done!
            if (typeof(prop['chart.background.image']) == 'string') {
                RG.DrawBackgroundImage(this);
            }
    
    
            /**
            * Fire the onbeforedraw event
            */
            RG.FireCustomEvent(this, 'onbeforedraw');
            


            /**
            * Parse the colors. This allows for simple gradient syntax
            */
            if (!this.colorsParsed) {
    
                this.parseColors();
    
                // Don't want to do this again
                this.colorsParsed = true;
            }
    
    
    
            /**
            * This is new in May 2011 and facilitates indiviual gutter settings,
            * eg chart.gutter.left
            */
            this.gutterLeft   = prop['chart.gutter.left'];
            this.gutterRight  = prop['chart.gutter.right'];
            this.gutterTop    = prop['chart.gutter.top'];
            this.gutterBottom = prop['chart.gutter.bottom'];
    
    
            /**
            * Check for Chrome 6 and shadow
            * 
            * TODO Remove once it's been fixed (for a while)
            * 07/03/2014 - Removed
            * 29/10/2011 - Looks like it's been fixed as long the linewidth is at least 1.01
            * SEARCH TAGS: CHROME FIX SHADOW BUG
            */
            //if (   prop['chart.shadow']
            //    && RG.ISCHROME
            //    && prop['chart.linewidth'] <= 1
            //    && prop['chart.chromefix']
            //    && prop['chart.shadow.blur'] > 0) {
            //        alert('[RGRAPH WARNING] Chrome has a shadow bug, meaning you should increase the linewidth to at least 1.01');
            //}
    
    
            // Reset the data back to that which was initially supplied
            this.data = RG.array_clone(this.original_data);

    
            // Reset the max value
            this.max = 0;
    
            /**
            * Reverse the datasets so that the data and the labels tally
            *  COMMENTED OUT 15TH AUGUST 2011
            */
            //this.data = RG.array_reverse(this.data);

            if (prop['chart.filled'] && !prop['chart.filled.range'] && this.data.length > 1 && prop['chart.filled.accumulative']) {
    
                var accumulation = [];

                for (var set=0; set<this.data.length; ++set) {
                    for (var point=0; point<this.data[set].length; ++point) {
                        this.data[set][point] = Number(accumulation[point] ? accumulation[point] : 0) + this.data[set][point];
                        accumulation[point] = this.data[set][point];
                    }
                }
            }
    
            /**
            * Get the maximum Y scale value
            */
            if (prop['chart.ymax']) {
                
                this.max = prop['chart.ymax'];
                this.min = prop['chart.ymin'] ? prop['chart.ymin'] : 0;
    
                this.scale2 = RG.getScale2(this, {
                    'max':this.max,
                    'min':prop['chart.ymin'],
                    'strict':true,
                    'scale.thousand':prop['chart.scale.thousand'],
                    'scale.point':prop['chart.scale.point'],
                    'scale.decimals':prop['chart.scale.decimals'],
                    'ylabels.count':prop['chart.ylabels.count'],
                    'scale.round':prop['chart.scale.round'],
                    'units.pre': prop['chart.units.pre'],
                    'units.post': prop['chart.units.post']
                });

                this.max   = this.scale2.max ? this.scale2.max : 0;
    
                // Check for negative values
                if (!prop['chart.outofbounds']) {
                    for (dataset=0; dataset<this.data.length; ++dataset) {
                        if (RGraph.isArray(this.data[dataset])) {
                            for (var datapoint=0; datapoint<this.data[dataset].length; datapoint++) {
                                // Check for negative values
                                this.hasnegativevalues = (this.data[dataset][datapoint] < 0) || this.hasnegativevalues;
                            }
                        }
                    }
                }
    
            } else {

                this.min = prop['chart.ymin'] ? prop['chart.ymin'] : 0;
    
                // Work out the max Y value
                for (dataset=0; dataset<this.data.length; ++dataset) {
                    for (var datapoint=0; datapoint<this.data[dataset].length; datapoint++) {
        
                        this.max = Math.max(this.max, this.data[dataset][datapoint] ? Math.abs(parseFloat(this.data[dataset][datapoint])) : 0);
        
                        // Check for negative values
                        if (!prop['chart.outofbounds']) {
                            this.hasnegativevalues = (this.data[dataset][datapoint] < 0) || this.hasnegativevalues;
                        }
                    }
                }

                this.scale2 = RG.getScale2(this, {
                    'max':this.max,
                    'min':prop['chart.ymin'],
                    'scale.thousand':prop['chart.scale.thousand'],
                    'scale.point':prop['chart.scale.point'],
                    'scale.decimals':prop['chart.scale.decimals'],
                    'ylabels.count':prop['chart.ylabels.count'],
                    'scale.round':prop['chart.scale.round'],
                    'units.pre': prop['chart.units.pre'],
                    'units.post': prop['chart.units.post']
                });
    
                this.max   = this.scale2.max ? this.scale2.max : 0;
            }
    
            /**
            * Setup the context menu if required
            */
            if (prop['chart.contextmenu']) {
                RG.ShowContext(this);
            }

            /**
            * Reset the coords arrays otherwise it will keep growing
            */
            this.coords     = [];
            this.coordsText = [];

            /**
            * Work out a few things. They need to be here because they depend on things you can change before you
            * call Draw() but after you instantiate the object
            */
            this.grapharea      = ca.height - this.gutterTop - this.gutterBottom;
            this.halfgrapharea  = this.grapharea / 2;
            this.halfTextHeight = prop['chart.text.size'] / 2;
    
            // Check the combination of the X axis position and if there any negative values
            //
            // 25th Feb 2016 - Removed entirely as this is another way to do
            // offset axes
            //if (prop['chart.xaxispos'] == 'bottom' && this.hasnegativevalues && !RG.ISOPERA) {
            //    alert('[LINE] You have negative values and the X axis is at the bottom. This is not good...');
            //}
    
            if (prop['chart.variant'] == '3d') {
                RG.Draw3DAxes(this);
            }
            
            // Progressively Draw the chart
            RG.background.Draw(this);


            /**
            * Draw any horizontal bars that have been defined
            */
            if (prop['chart.background.hbars'] && prop['chart.background.hbars'].length > 0) {
                RG.DrawBars(this);
            }

            if (prop['chart.axesontop'] == false) {
                this.DrawAxes();
            }

            //if (typeof(shadowColor) == 'object') {
            //    shadowColor = RG.array_reverse(RG.array_clone(prop['chart.shadow.color']]);
            //}
    
            /**
            * This facilitates the new Trace2 effect
            */
    
            co.save()
            co.beginPath();
            co.rect(0, 0, ca.width * prop['chart.animation.trace.clip'], ca.height);
            co.clip();
    
                for (var i=0, j=0, len=this.data.length; i<len; i++, j++) {
        
                    co.beginPath();
        
                    /**
                    * Turn on the shadow if required
                    */
                    if (!prop['chart.filled']) {
                        this.SetShadow(i);
                    }
        
                    /**
                    * Draw the line
                    */
        
                    if (prop['chart.fillstyle']) {
                        if (typeof(prop['chart.fillstyle']) == 'object' && prop['chart.fillstyle'][j]) {
                           var fill = prop['chart.fillstyle'][j];
                        
                        } else if (typeof(prop['chart.fillstyle']) == 'object' && prop['chart.fillstyle'].toString().indexOf('Gradient') > 0) {
                           var fill = prop['chart.fillstyle'];
                        
                        } else if (typeof(prop['chart.fillstyle']) == 'string') {
                            var fill = prop['chart.fillstyle'];
            
                        }
                    } else if (prop['chart.filled']) {
                        var fill = prop['chart.colors'][j];
        
                    } else {
                        var fill = null;
                    }

                    /**
                    * Figure out the tickmark to use
                    */
                    if (prop['chart.tickmarks'] && typeof(prop['chart.tickmarks']) == 'object') {
                        var tickmarks = prop['chart.tickmarks'][i];
                    } else if (prop['chart.tickmarks'] && typeof(prop['chart.tickmarks']) == 'string') {
                        var tickmarks = prop['chart.tickmarks'];
                    } else if (prop['chart.tickmarks'] && typeof(prop['chart.tickmarks']) == 'function') {
                        var tickmarks = prop['chart.tickmarks'];
                    } else {
                        var tickmarks = null;
                    }

                    //
                    // Draw the line, accounting for the outofboundsClip option
                    //
                    if (prop['chart.outofbounds.clip']) {
                        pa2(
                            co,
                            'sa b r % % % % cl b',
                            0,
                            this.gutterTop,
                            ca.width,
                            ca.height - this.gutterTop - this.gutterBottom
                        );
                    }

                        this.drawLine(
                            this.data[i],
                            prop['chart.colors'][j],
                            fill,
                            this.getLineWidth(j),
                            tickmarks,
                            i
                        );
                    if (prop['chart.outofbounds.clip']) {
                        co.restore();
                    }
            
                    co.stroke();

/**
* Draw errorbars
* 
* ** This is now done in the redrawLine function **
*/
                }
        
            /**
            * If the line is filled re-stroke the lines
            */
            if (prop['chart.outofbounds.clip']) {
                pa2(
                    co,
                    'sa b r % % % % cl b',
                    0,
                    this.gutterTop,
                    ca.width,
                    ca.height - this.gutterTop - this.gutterBottom
                );
            }


            if (prop['chart.filled'] && prop['chart.filled.accumulative'] && !prop['chart.curvy']) {
                

                for (var i=0; i<this.coords2.length; ++i) {
        
                    co.beginPath();
                    co.lineWidth = this.GetLineWidth(i);
                    co.strokeStyle = !this.hidden(i) ? prop['chart.colors'][i] : 'rgba(0,0,0,0)';
        
                    for (var j=0,len=this.coords2[i].length; j<len; ++j) {
        
                        if (j == 0 || this.coords2[i][j][1] == null || (this.coords2[i][j - 1] && this.coords2[i][j - 1][1] == null)) {
                            co.moveTo(this.coords2[i][j][0], this.coords2[i][j][1]);
                        } else {
                            if (prop['chart.stepped']) {
                                co.lineTo(this.coords2[i][j][0], this.coords2[i][j - 1][1]);
                            }
                            co.lineTo(this.coords2[i][j][0], this.coords2[i][j][1]);
                        }
                    }
                    
                    co.stroke();
                    // No fill!
                }

                //Redraw the tickmarks
                if (prop['chart.tickmarks']) {
        
                    co.beginPath();
        
                    co.fillStyle = 'white';
                    
                    for (var i=0,len=this.coords2.length; i<len; ++i) {
        
                        co.beginPath();
                        co.strokeStyle = prop['chart.colors'][i];
    
                        for (var j=0; j<this.coords2[i].length; ++j) {
                            if (typeof(this.coords2[i][j]) == 'object' && typeof(this.coords2[i][j][0]) == 'number' && typeof(this.coords2[i][j][1]) == 'number') {
                                
                                var tickmarks = typeof(prop['chart.tickmarks']) == 'object' ? prop['chart.tickmarks'][i] : prop['chart.tickmarks'];
        
                                this.DrawTick(
                                    this.coords2[i],
                                    this.coords2[i][j][0],
                                    this.coords2[i][j][1],
                                    co.strokeStyle,
                                    false,
                                    j == 0 ? 0 : this.coords2[i][j - 1][0],
                                    j == 0 ? 0 : this.coords2[i][j - 1][1],
                                    tickmarks,
                                    j,
                                    i
                                );
                            }
                        }
                    }
        
                    co.stroke();
                    co.fill();
                }

            } else if (prop['chart.filled'] && prop['chart.filled.accumulative'] && prop['chart.curvy']) {

                // Restroke the curvy filled accumulative lines

                for (var i=0; i<this.coordsSpline.length; i+=1) {
                    co.beginPath();
                    co.strokeStyle = prop['chart.colors'][i];
                    co.lineWidth = this.GetLineWidth(i);

                    for (var j=0,len=this.coordsSpline[i].length; j<len; j+=1) {
                        
                        var point = this.coordsSpline[i][j];
                        
                        j == 0 ? co.moveTo(point[0], point[1]) : co.lineTo(point[0], point[1]);
                    }

                   co.stroke();
                }
                
                for (var i=0,len=this.coords2.length; i<len; i+=1) {
                    for (var j=0,len2=this.coords2[i].length; j<len2; ++j) {
                        if (typeof(this.coords2[i][j]) == 'object' && typeof(this.coords2[i][j][0]) == 'number' && typeof(this.coords2[i][j][1]) == 'number') {
                            
                            var tickmarks = typeof prop['chart.tickmarks'] == 'object' && !RGraph.is_null(prop['chart.tickmarks']) ? prop['chart.tickmarks'][i] : prop['chart.tickmarks'];
                            co.strokeStyle = prop['chart.colors'][i];
                            this.DrawTick(
                                this.coords2[i],
                                this.coords2[i][j][0],
                                this.coords2[i][j][1],
                                prop['chart.colors'][i],
                                false,
                                j == 0 ? 0 : this.coords2[i][j - 1][0],
                                j == 0 ? 0 : this.coords2[i][j - 1][1],
                                tickmarks,
                                j,
                                i
                            );
                        }
                    }
                }
                            }


        if (prop['chart.outofbounds.clip']) {
            co.restore();
        }
        co.restore();
    
        // ???
        co.beginPath();
    
    
    
    
            /**
            * If the axes have been requested to be on top, do that
            */
            if (prop['chart.axesontop']) {
                this.DrawAxes();
            }
    
            /**
            * Draw the labels
            */
            this.DrawLabels();
            
            /**
            * Draw the range if necessary
            */
            this.DrawRange();

            // Draw a key if necessary
            if (prop['chart.key'] && prop['chart.key'].length && RG.DrawKey) {
                RG.DrawKey(this, prop['chart.key'], prop['chart.colors']);
            }
    
            /**
            * Draw " above" labels if enabled
            */
            if (prop['chart.labels.above']) {
                this.drawAboveLabels();
            }
    
            /**
            * Draw the "in graph" labels
            */
            RG.DrawInGraphLabels(this);

            /**
            * Redraw the lines if a filled range is on the cards
            */
            if (prop['chart.filled'] && prop['chart.filled.range'] && this.data.length == 2) {
    
                co.beginPath();
                var len        = this.coords.length / 2;
                co.lineWidth   = prop['chart.linewidth'];
                co.strokeStyle = this.hidden(0) ? 'rgba(0,0,0,0)' : prop['chart.colors'][0];
    
                for (var i=0; i<len; ++i) {
    
                    if (!RG.isNull(this.coords[i][1])) {
                        if (i == 0) {
                            co.moveTo(this.coords[i][0], this.coords[i][1]);
                        } else {
                            co.lineTo(this.coords[i][0], this.coords[i][1]);
                        }
                    }
                }
                
                co.stroke();
    
    
                co.beginPath();
                
                if (prop['chart.colors'][1]) {
                    co.strokeStyle = this.hidden(1) ? 'rgba(0,0,0,0)' : prop['chart.colors'][1];
                }
                
                for (var i=this.coords.length - 1; i>=len; --i) {
                    if (!RG.is_null(this.coords[i][1])) {
                        if (i == (this.coords.length - 1)) {
                            co.moveTo(this.coords[i][0], this.coords[i][1]);
                        } else {
                            co.lineTo(this.coords[i][0], this.coords[i][1]);
                        }
                    }
                }
    
                co.stroke();
    
    
            } else if (prop['chart.filled'] && prop['chart.filled.range']) {
                alert('[LINE] You must have only two sets of data for a filled range chart');
            }

            /**
            * This function enables resizing
            */
            if (prop['chart.resizable']) {
                RG.AllowResizing(this);
            }
    
    
            /**
            * This installs the event listeners
            */
            RG.InstallEventListeners(this);
            
            

    
    

            /**
            * Fire the onfirstdraw event
            */
            if (this.firstDraw) {
                this.firstDraw = false;
                RG.fireCustomEvent(this, 'onfirstdraw');
                this.firstDrawFunc();
            }
            
            /**
            * Fire the RGraph ondraw event
            */
            RG.FireCustomEvent(this, 'ondraw');
            
            return this;
        };
        
        
        
        /**
        * Used in chaining. Runs a function there and then - not waiting for
        * the events to fire (eg the onbeforedraw event)
        * 
        * @param function func The function to execute
        */
        this.exec = function (func)
        {
            func(this);
            
            return this;
        };
        
        /**
        * Draws the axes
        */
        this.drawAxes =
        this.DrawAxes = function ()
        {
            // Don't draw the axes?
            if (prop['chart.noaxes']) {
                return;
            }
    
            // Turn any shadow off
            RG.noShadow(this);
    
            co.lineWidth   = prop['chart.axis.linewidth'] + 0.001;
            co.lineCap     = 'square';
            co.lineJoin    = 'miter';
            co.strokeStyle = prop['chart.axis.color'];
            coords         = {
                xaxis: {},
                yaxis: {}
            };

            co.beginPath();

            // Draw the X axis
            if (prop['chart.noxaxis'] == false) {

                if (prop['chart.xaxispos'] == 'center') {
                    coords.xaxis = [
                        this.gutterLeft,
                        ma.round((this.grapharea / 2) + this.gutterTop),
                        ca.width - this.gutterRight,
                        ma.round((this.grapharea / 2) + this.gutterTop)
                    ];
                } else if (prop['chart.xaxispos'] === 'top') {
                    coords.xaxis = [
                        this.gutterLeft,
                        this.gutterTop,
                        ca.width - this.gutterRight,
                        this.gutterTop
                    ];
                } else {

                    var y = ma.round(this.getYCoord(prop['chart.ymin'] != 0 ? prop['chart.ymin'] : 0));
                    
                    if (prop['chart.scale.invert'] && prop['chart.ymin'] === 0) {
                        y = this.getYCoord(this.scale2.max);
                    } else if (prop['chart.scale.invert'] || prop['chart.ymin'] < 0) {
                        y = this.getYCoord(0);
                    }

                    coords.xaxis = [
                        this.gutterLeft,
                        y,
                        ca.width - this.gutterRight,
                        y
                    ];
                }
                
                co.moveTo(coords.xaxis[0], coords.xaxis[1]);
                co.lineTo(coords.xaxis[2], coords.xaxis[3]);

                // Save the coords so that they can
                // be referenced at a later time
                this.coordsAxes = coords;
            }
            

            // Draw the Y axis
            if (prop['chart.noyaxis'] == false) {
                if (prop['chart.yaxispos'] == 'left') {
                    co.moveTo(this.gutterLeft, this.gutterTop);
                    co.lineTo(this.gutterLeft, ca.height - this.gutterBottom);
                } else {
                    co.moveTo(ca.width - this.gutterRight, this.gutterTop);
                    co.lineTo(ca.width - this.gutterRight, ca.height - this.gutterBottom);
                }
            }

            /**
            * Draw the X tickmarks
            */
            if (prop['chart.noxaxis'] == false && prop['chart.numxticks'] > 0) {

                var xTickInterval = (ca.width - this.gutterLeft - this.gutterRight) / prop['chart.numxticks'];
    
                
                if (!xTickInterval || xTickInterval <= 0) {
                    xTickInterval = (ca.width - this.gutterLeft - this.gutterRight) / (prop['chart.labels'] && prop['chart.labels'].length ? prop['chart.labels'].length - 1 : 10);
                }

                for (x=this.gutterLeft + (prop['chart.yaxispos'] == 'left' ? xTickInterval : 0); x<=(ca.width - this.gutterRight + 1 ); x+=xTickInterval) {
    
                    if (prop['chart.yaxispos'] == 'right' && x >= (ca.width - this.gutterRight - 1) ) {
                        break;
                    }

                    // If the last tick is not desired...
                    if (prop['chart.noendxtick']) {
                        if (prop['chart.yaxispos'] == 'left' && x >= (ca.width - this.gutterRight - 1)) {
                            break;
                        } else if (prop['chart.yaxispos'] == 'right' && x == this.gutterLeft) {
                            continue;
                        }
                    }
    
                    var yStart = prop['chart.xaxispos'] === 'center' ? (this.gutterTop + (this.grapharea / 2)) - 3 : ca.height - this.gutterBottom;
                    var yEnd   = prop['chart.xaxispos'] === 'center' ? yStart + 6 : ca.height - this.gutterBottom - (x % 60 == 0 ? prop['chart.largexticks'] * prop['chart.tickdirection'] : prop['chart.smallxticks'] * prop['chart.tickdirection']);


                    // Draw the tick
                    if (prop['chart.ymin'] >= 0 && prop['chart.xaxispos'] === 'bottom') {
                        var yStart = this.getYCoord(prop['chart.ymin']) - (prop['chart.ymin'] >= 0 ? 0 : 3),
                            yEnd   = this.getYCoord(prop['chart.ymin']) + 3;

                        if (prop['chart.scale.invert']) {
                            yStart = ca.height - prop['chart.gutter.bottom'];
                            yEnd   = yStart + 3;
                        }

                    } else if (prop['chart.xaxispos'] == 'center') {
                        var yStart = Math.round((this.gutterTop + (this.grapharea / 2))) - 3,
                            yEnd = yStart + 6;
                    
                    } else if (prop['chart.xaxispos'] == 'bottom') {

                        var yStart = this.getYCoord(0) - (prop['chart.ymin'] !== 0 ? 3 : 0),
                            yEnd   = this.getYCoord(0) - (x % 60 == 0 ? prop['chart.largexticks'] * prop['chart.tickdirection'] : prop['chart.smallxticks'] * prop['chart.tickdirection']);
                        yEnd += 0;
                                            
                    } else if (prop['chart.xaxispos'] == 'top') {

                        yStart = this.gutterTop - 3;
                        yEnd   = this.gutterTop;
                    }


                    co.moveTo(ma.round(x), yStart);
                    co.lineTo(ma.round(x), yEnd);
                }
    
            // Draw an extra tickmark if there is no X axis, but there IS a Y axis
            // OR if there is an offset X axis
            } else if (prop['chart.noyaxis'] == false && prop['chart.numyticks'] > 0) {

                if (!prop['chart.noendytick']) {
                    if (prop['chart.yaxispos'] == 'left') {
                        co.moveTo(this.gutterLeft, Math.round(ca.height - this.gutterBottom));
                        co.lineTo(this.gutterLeft - prop['chart.smallyticks'], Math.round(ca.height - this.gutterBottom));
                    } else {
                        co.moveTo(ca.width - this.gutterRight, Math.round(ca.height - this.gutterBottom));
                        co.lineTo(ca.width - this.gutterRight + prop['chart.smallyticks'], Math.round(ca.height - this.gutterBottom));
                    }
                }
            }
    
            /**
            * Draw the Y tickmarks
            */
            var numyticks = prop['chart.numyticks'];

            if (prop['chart.noyaxis'] == false && numyticks > 0) {
                
                var counter    = 0,
                    adjustment = 0;
        
                if (prop['chart.yaxispos'] == 'right') {
                    adjustment = (ca.width - this.gutterLeft - this.gutterRight);
                }
                
                // X axis at the center
                if (prop['chart.xaxispos'] == 'center') {
                    var interval = (this.grapharea / numyticks);
                    var lineto = (prop['chart.yaxispos'] == 'left' ? this.gutterLeft : ca.width - this.gutterRight + prop['chart.smallyticks']);
        
                    // Draw the upper halves Y tick marks
                    for (y=this.gutterTop; y<(this.grapharea / 2) + this.gutterTop; y+=interval) {
                        if (y < (this.grapharea / 2) + this.gutterTop) {
                            co.moveTo((prop['chart.yaxispos'] == 'left' ? this.gutterLeft - prop['chart.smallyticks'] : ca.width - this.gutterRight), Math.round(y));
                            co.lineTo(lineto, Math.round(y));
                        }
                    }
    
                    // Draw the lower halves Y tick marks
                    for (y=this.gutterTop + (this.halfgrapharea) + interval; y <= this.grapharea + this.gutterTop; y+=interval) {
                        co.moveTo((prop['chart.yaxispos'] == 'left' ? this.gutterLeft - prop['chart.smallyticks'] : ca.width - this.gutterRight), Math.round(y));
                        co.lineTo(lineto, Math.round(y));
                    }
                
                // X axis at the top
                } else if (prop['chart.xaxispos'] == 'top') {
                    var interval = (this.grapharea / numyticks);
                    var lineto = (prop['chart.yaxispos'] == 'left' ? this.gutterLeft : ca.width - this.gutterRight + prop['chart.smallyticks']);
    
                    // Draw the Y tick marks
                    for (y=this.gutterTop + interval; y <= this.grapharea + this.gutterBottom; y+=interval) {
                        co.moveTo((prop['chart.yaxispos'] == 'left' ? this.gutterLeft - prop['chart.smallyticks'] : ca.width - this.gutterRight), Math.round(y));
                        co.lineTo(lineto, Math.round(y));
                    }

                    
                    // If there's no X axis draw an extra tick
                    if (prop['chart.noxaxis'] && prop['chart.noendytick'] == false) {
                        co.moveTo((prop['chart.yaxispos'] == 'left' ? this.gutterLeft - prop['chart.smallyticks'] : ca.width - this.gutterRight), this.gutterTop);
                        co.lineTo(lineto, this.gutterTop);
                    }
                
                // X axis at the bottom
                } else {

                    var lineto = (prop['chart.yaxispos'] == 'left' ? this.gutterLeft - prop['chart.smallyticks'] : ca.width - this.gutterRight + prop['chart.smallyticks']);

                    for (y=this.gutterTop;
                         y<(ca.height - this.gutterBottom) && counter < numyticks;
                         y+=( (ca.height - this.gutterTop - this.gutterBottom) / numyticks)
                        ) {

                        // This check is so that there's no tickmark at
                        // the same position as the X axis
                        if (ma.round(y) !== ma.round(this.coordsAxes.xaxis[1])) {
                            co.moveTo(this.gutterLeft + adjustment, ma.round(y));
                            co.lineTo(lineto, ma.round(y));
                        }
                    
                        var counter = counter + 1;
                    }
                    
                    // Draw an extra Y tick if there's an offsetX axis
                    if (prop['chart.ymin'] < 0) {

                        co.moveTo(
                            (prop['chart.yaxispos'] == 'left' ? this.gutterLeft : ca.width - this.gutterRight),
                            ma.round(y)
                        );

                        co.lineTo(
                            lineto,
                            ma.round(y)
                        );
                    }
                }
    
            // Draw an extra X tickmark
            } else if (prop['chart.noxaxis'] == false && prop['chart.numxticks'] > 0) {
    
                if (prop['chart.yaxispos'] == 'left') {
                    co.moveTo(this.gutterLeft, prop['chart.xaxispos'] == 'top' ? this.gutterTop : ca.height - this.gutterBottom);
                    co.lineTo(this.gutterLeft, prop['chart.xaxispos'] == 'top' ? this.gutterTop - prop['chart.smallxticks'] : ca.height - this.gutterBottom + prop['chart.smallxticks']);
               } else {
                    co.moveTo(ca.width - this.gutterRight, ca.height - this.gutterBottom);
                    co.lineTo(ca.width - this.gutterRight, ca.height - this.gutterBottom + prop['chart.smallxticks']);
                }
            }
    
            co.stroke();

            /**
            * This is here so that setting the color after this function doesn't
            * change the color of the axes
            */
            co.beginPath();
        };
        
        /**
        * Draw the text labels for the axes
        */
        this.drawLabels =
        this.DrawLabels = function ()
        {
            co.strokeStyle = 'black';
            co.fillStyle   = prop['chart.text.color'];
            co.lineWidth   = 1;
            
            // Turn off any shadow
            RG.NoShadow(this);
    
            // This needs to be here
            var font      = prop['chart.text.font'];
            var text_size = prop['chart.text.size'];
            var decimals  = prop['chart.scale.decimals'];
            var context   = co;
            var canvas    = ca;
            var ymin      = prop['chart.ymin'];
    
            // Draw the Y axis labels
            if (prop['chart.ylabels'] && prop['chart.ylabels.specific'] == null) {
    
                var units_pre  = prop['chart.units.pre'];
                var units_post = prop['chart.units.post'];
                var xpos       = prop['chart.yaxispos'] == 'left' ? this.gutterLeft - 5 : ca.width - this.gutterRight + 5;
                var align      = prop['chart.yaxispos'] == 'left' ? 'right' : 'left';
                var numYLabels = this.scale2.labels.length;
                var bounding   = false;
                var bgcolor    = prop['chart.ylabels.inside'] ? prop['chart.ylabels.inside.color'] : null;
                var offsetx    = prop['chart.ylabels.offsetx'];
                var offsety    = prop['chart.ylabels.offsety'];
    
                
                /**
                * If the Y labels are inside the Y axis, invert the alignment
                */
                if (prop['chart.ylabels.inside'] == true && align == 'left') {
                    xpos -= 10;
                    align = 'right';
                    bounding = true;
                    
    
                } else if (prop['chart.ylabels.inside'] == true && align == 'right') {
                    xpos += 10;
                    align = 'left';
                    bounding = true;
                }
    
    
    
    
                /**
                * X axis in the center
                */
                if (prop['chart.xaxispos'] == 'center') {
                    
                    var half = this.grapharea / 2;
    
                    /**
                    * Draw the top half 
                    */
                    for (var i=0; i<this.scale2.labels.length; ++i) {
                        RG.text2(this, {
                            'font': font,
                            'size': text_size,
                            'x': xpos + offsetx,
                            'y': this.gutterTop + half - (((i+1)/numYLabels) * half) + offsety,
                            'valign': 'center',
                            'halign':align,
                            'bounding': bounding,
                            'boundingFill': bgcolor,
                            'text': this.scale2.labels[i],
                            'tag': 'scale'
                        });
                    }
                    
                    /**
                    * Draw the bottom half
                    */
                    for (var i=0; i<this.scale2.labels.length; ++i) {
                        RG.text2(this, {
                            'font': font,
                            'size': text_size,
                            'x': xpos + offsetx,
                            'y': this.gutterTop + half + (((i+1)/numYLabels) * half) + offsety,
                            'valign': 'center',
                            'halign':align,
                            'bounding': bounding,
                            'boundingFill': bgcolor,
                            'text': '-' + this.scale2.labels[i],
                            'tag': 'scale'
                        });
                    }
    
                    // No X axis - so draw 0
                    if (prop['chart.noxaxis'] == true || ymin != 0 || prop['chart.scale.zerostart']) {
                        RG.text2(this,{
                            'font':font,
                            'size':text_size,
                            'x':xpos + offsetx,
                            'y':this.gutterTop + half + offsety,
                            'text':prop['chart.units.pre'] + ymin.toFixed(ymin === 0 ? 0 : decimals) + prop['chart.units.post'],
                            'bounding':bounding,
                            'boundingFill':bgcolor,
                            'valign':'center',
                            'halign':align,
                            'tag': 'scale'
                        });
                    }
    
    
    
                /**
                * X axis at the top
                */
                } else if (prop['chart.xaxispos'] == 'top') {
                
                    var half = this.grapharea / 2;
    
                    if (prop['chart.scale.invert']) {
    
                        for (var i=0; i<this.scale2.labels.length; ++i) {
    
                            RG.text2(this, {
                                'font': font,
                                'size': text_size,
                                'x': xpos + offsetx,
                                'y': this.gutterTop + ((i/this.scale2.labels.length) * this.grapharea) + offsety,
                                'valign': 'center',
                                'halign':align,
                                'bounding': bounding,
                                'boundingFill': bgcolor,
                                'text': '-' + this.scale2.labels[this.scale2.labels.length - (i+1)],
                                'tag': 'scale'
                            });
                        }
                    } else {
                        for (var i=0; i<this.scale2.labels.length; ++i) {
                            RG.text2(this, {
                                'font': font,
                                'size': text_size,
                                'x': xpos + offsetx,
                                'y': this.gutterTop + (((i+1)/numYLabels) * this.grapharea) + offsety,
                                'valign': 'center',
                                'halign':align,
                                'bounding': bounding,
                                'boundingFill': bgcolor,
                                'text': '-' + this.scale2.labels[i],
                                'tag': 'scale'
                            });
                        }
                    }

                    // Draw the lower limit if chart.ymin is specified
                    if ((prop['chart.ymin'] != 0 || prop['chart.noxaxis']) || prop['chart.scale.invert'] || prop['chart.scale.zerostart']) {
                        RG.text2(this, {
                            'font':font,
                            'size':text_size,
                            'x':xpos + offsetx,
                            'y': prop['chart.scale.invert'] ? ca.height - this.gutterBottom + offsety : this.gutterTop + offsety,
                            'text': (prop['chart.ymin'] != 0 ? '-' : '') + RG.numberFormat(this, prop['chart.ymin'].toFixed(ymin === 0 ? 0 : decimals), units_pre, units_post),
                            'valign':'center',
                            'halign': align,
                            'bounding':bounding,
                            'boundingFill':bgcolor,
                            'tag': 'scale'
                        });
                    }
    
    
    
    
    
    
                /**
                * X axis labels at the bottom
                */
                } else {
    
                    if (prop['chart.scale.invert']) {

                        // Draw the minimum value
                        RG.text2(this, {
                            'font': font,
                            'size': text_size,
                            'x': xpos + offsetx,
                            'y': this.gutterTop + offsety,
                            'valign': 'center',
                            'halign':align,
                            'bounding': bounding,
                            'boundingFill': bgcolor,
                            'text': RG.numberFormat(this, this.min.toFixed(prop['chart.ymin'] === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post),
                            'tag': 'scale'
                        });

                        for (var i=0,len=this.scale2.labels.length; i<len; ++i) {
                            RG.Text2(this, {
                                'font': font,
                                'size': text_size,
                                'x': xpos + offsetx,
                                'y': this.gutterTop + (((i+1)/this.scale2.labels.length) * this.grapharea) + offsety,
                                'valign': 'center',
                                'halign':align,
                                'bounding': bounding,
                                'boundingFill': bgcolor,
                                'text': this.scale2.labels[i],
                                'tag': 'scale'
                            });
                        }

                    } else {
                        for (var i=0,len=this.scale2.labels.length; i<len; ++i) {
                            RG.text2(this, {
                                'font': font,
                                'size': text_size,
                                'x': xpos + offsetx,
                                'y': this.gutterTop + ((i/this.scale2.labels.length) * this.grapharea) + offsety,
                                'valign': 'center',
                                'halign':align,
                                'bounding': bounding,
                                'boundingFill': bgcolor,
                                'text': this.scale2.labels[this.scale2.labels.length - (i + 1)],
                                'tag': 'scale'
                            });
                        }
                    }

                    // Draw the lower limit if chart.ymin is specified
                    if ( (prop['chart.ymin']!= 0 && !prop['chart.scale.invert'] || prop['chart.scale.zerostart'])
                        || prop['chart.noxaxis']
                        ) {

                        RG.text2(this, {
                            'font':font,
                            'size':text_size,
                            'x':xpos + offsetx,
                            'y':prop['chart.scale.invert'] ? this.gutterTop + offsety : ca.height - this.gutterBottom + offsety,
                            'text':RG.numberFormat(this, prop['chart.ymin'].toFixed(prop['chart.ymin'] === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post),
                            'valign':'center',
                            'halign':align,
                            'bounding':bounding,
                            'boundingFill':bgcolor,
                            'tag': 'scale'
                        });

                    }
                }

    
    
    
    

    
                // No X axis - so draw 0 - but not if the X axis is in the center
                if (   prop['chart.noxaxis'] == true
                    && prop['chart.ymin'] == null
                    && prop['chart.xaxispos'] != 'center'
                    && prop['chart.noendytick'] == false
                   ) {

                    RG.text2(this, {
                        'font':font,
                        'size':text_size,
                        'x':xpos + offsetx,
                        'y':prop['chart.xaxispos'] == 'top' ? this.gutterTop + offsety : (ca.height - this.gutterBottom),'text': prop['chart.units.pre'] + Number(0).toFixed(prop['chart.scale.decimals']) + prop['chart.units.post'] + offsety,
                        'valign':'center',
                        'halign':align,
                        'bounding':bounding,
                        'boundingFill':bgcolor,
                        'tag':'scale'
                    });
                }

            } else if (prop['chart.ylabels'] && typeof(prop['chart.ylabels.specific']) == 'object') {
    
                // A few things
                var gap      = this.grapharea / prop['chart.ylabels.specific'].length;
                var halign   = prop['chart.yaxispos'] == 'left' ? 'right' : 'left';
                var bounding = false;
                var bgcolor  = null;
                var ymin     = prop['chart.ymin'] != null && prop['chart.ymin'];
    
                // Figure out the X coord based on the position of the axis
                if (prop['chart.yaxispos'] == 'left') {
                    var x = this.gutterLeft - 5;
                    
                    if (prop['chart.ylabels.inside']) {
                        x += 10;
                        halign   = 'left';
                        bounding = true;
                        bgcolor  = 'rgba(255,255,255,0.5)';
                    }
    
                } else if (prop['chart.yaxispos'] == 'right') {
                    var x = ca.width - this.gutterRight + 5;
                    
                    if (prop['chart.ylabels.inside']) {
                        x -= 10;
                        halign = 'right';
                        bounding = true;
                        bgcolor  = 'rgba(255,255,255,0.5)';
                    }
                }
    
                var offsetx = prop['chart.ylabels.offsetx'];
                var offsety = prop['chart.ylabels.offsety'];
                
                // Draw the labels
                if (prop['chart.xaxispos'] == 'center') {
                

                
                    // Draw the top halfs labels
                    for (var i=0; i<prop['chart.ylabels.specific'].length; ++i) {
                        
                        var y = this.gutterTop + (this.grapharea / (((prop['chart.ylabels.specific'].length - 1)) * 2) * i);
                        
                        if (ymin && ymin > 0) {
                            var y  = ((this.grapharea / 2) / (prop['chart.ylabels.specific'].length - (ymin ? 1 : 0)) ) * i;
                                y += this.gutterTop;
                        }

                        RG.text2(this, {
                            'font':font,
                            'size':text_size,
                            'x':x + offsetx,
                            'y':y + offsety,
                            'text':String(prop['chart.ylabels.specific'][i]),
                            'valign': 'center',
                            'halign':halign,
                            'bounding':bounding,
                            'boundingFill':bgcolor,
                            'tag': 'ylabels.specific'
                        });
                    }
                    
                    // Now reverse the labels and draw the bottom half
                    var reversed_labels = RG.array_reverse(prop['chart.ylabels.specific']);
                
                    // Draw the bottom halfs labels
                    for (var i=0; i<reversed_labels.length; ++i) {
                        
                        var y = (this.grapharea / 2) + this.gutterTop + ((this.grapharea / ((reversed_labels.length - 1) * 2) ) * i);
    
                        RG.text2(this, {
                            'font':font,
                            'size':text_size,
                            'x':x + offsetx,
                            'y':y + offsety,
                            'text':i == 0 ? '' : String(reversed_labels[i]),
                            'valign': 'center',
                            'halign':halign,
                            'bounding':bounding,
                            'boundingFill':bgcolor,
                            'tag': 'ylabels.specific'
                        });
                    }
                
                } else if (prop['chart.xaxispos'] == 'top') {
    
                    // Reverse the labels and draw
                    var reversed_labels = RG.array_reverse(prop['chart.ylabels.specific']);
                
                    // Draw the bottom halfs labels
                    for (var i=0; i<reversed_labels.length; ++i) {
                        
                        var y = (this.grapharea / (reversed_labels.length - 1)) * i;
                            y = y + this.gutterTop;
    
                        RG.Text2(this, {
                            'font':font,
                            'size':text_size,
                            'x':x + offsetx,
                            'y':y + offsety,
                            'text':String(reversed_labels[i]),
                            'valign': 'center',
                            'halign':halign,
                            'bounding':bounding,
                            'boundingFill':bgcolor,
                            'tag': 'ylabels.specific'
                        });
                    }
    
                } else {
                    for (var i=0; i<prop['chart.ylabels.specific'].length; ++i) {
                        var y = this.gutterTop + ((this.grapharea / (prop['chart.ylabels.specific'].length - 1)) * i);
                        RG.text2(this, {
                            'font':font,
                            'size':text_size,
                            'x':x + offsetx,
                            'y':y + offsety,
                            'text':String(prop['chart.ylabels.specific'][i]),
                            'valign':'center',
                            'halign':halign,
                            'bounding':bounding,
                            'boundingFill':bgcolor,
                            'tag': 'ylabels.specific'
                        });
                    }
                }
            }
    
            // Draw the X axis labels
            if (prop['chart.labels'] && prop['chart.labels'].length > 0) {

                var yOffset  = 5,
                    bordered = false,
                    bgcolor  = null

                co.fillStyle = prop['chart.labels.color'] || prop['chart.text.color'];

                /**
                * Text angle
                */
                var angle  = 0,
                    valign = 'top',
                    halign = 'center',
                    bold   = prop['chart.labels.bold']
    
                if (prop['chart.xlabels.inside']) {
                    yOffset  = -5;
                    bordered = true;
                    bgcolor  = prop['chart.xlabels.inside.color'];
                    valign   = 'bottom';
                }
                
                if (prop['chart.xaxispos'] == 'top') {
                    valign = 'bottom';
                    yOffset += 2;
                }
    
                if (typeof(prop['chart.text.angle']) == 'number' && prop['chart.text.angle'] > 0) {
                    angle   = -1 * prop['chart.text.angle'];
                    valign  = 'center';
                    halign  = 'right';
                    yOffset = 10;
                    
                    if (prop['chart.xaxispos'] == 'top') {
                        yOffset = 10;
                    }
                }
    
                var numLabels = prop['chart.labels'].length,
                    offsetx   = prop['chart.labels.offsetx'],
                    offsety   = prop['chart.labels.offsety'];
    
                for (i=0; i<numLabels; ++i) {
    
                    // Changed 8th Nov 2010 to be not reliant on the coords
                    //if (this.properties['chart.labels'][i] && this.coords && this.coords[i] && this.coords[i][0]) {
                    if (prop['chart.labels'][i]) {
    
                        var labelX = ((ca.width - this.gutterLeft - this.gutterRight - (2 * prop['chart.hmargin'])) / (numLabels - 1) ) * i;
                            labelX += this.gutterLeft + prop['chart.hmargin'];

                        /**
                        * Account for an unrelated number of labels
                        */

                        if (this.data.length === 0 || !this.data[0] || prop['chart.labels'].length != this.data[0].length) {
                            labelX = this.gutterLeft + prop['chart.hmargin'] + ((ca.width - this.gutterLeft - this.gutterRight - (2 * prop['chart.hmargin'])) * (i / (prop['chart.labels'].length - 1)));
                        }
                        
                        // This accounts for there only being one point on the chart
                        if (!labelX) {
                            labelX = this.gutterLeft + prop['chart.hmargin'];
                        }
    
                        if (prop['chart.xaxispos'] == 'top' && prop['chart.text.angle'] > 0) {
                            halign = 'left';
                        }
                        
                        if (prop['chart.text.angle'] != 0) {
                            halign = 'right';
                        }
    
                        RG.Text2(this, {
                            'font':font,
                            'size':text_size,
                            'bold': bold,
                            'x':labelX + offsetx,
                            'y':(prop['chart.xaxispos'] == 'top') ? this.gutterTop - yOffset - (prop['chart.xlabels.inside'] ? -22 : 0) + offsety : (ca.height - this.gutterBottom) + yOffset + offsety,
                            'text':String(prop['chart.labels'][i]),
                            'valign':valign,
                            'halign':halign,
                            'bounding':bordered,
                            'boundingFill':bgcolor,
                            'angle':angle,
                            'tag': 'labels'
                        });
                    }
                }
    
            }
    
            co.stroke();
            co.fill();
        }
    
    
    
        /**
        * Draws the line
        */
        this.drawLine =
        this.DrawLine = function (lineData, color, fill, linewidth, tickmarks, index)
        {
            // This facilitates the Rise animation (the Y value only)
            if (prop['chart.animation.unfold.y'] && prop['chart.animation.factor'] != 1) {
                for (var i=0; i<lineData.length; ++i) {
                    lineData[i] *= prop['chart.animation.factor'];
                }
            }

            var penUp = false;
            var yPos  = null;
            var xPos  = 0;
            co.lineWidth = 1;
            var lineCoords = [];
            
            /**
            * Get the previous line data
            */
            if (index > 0) {
                var prevLineCoords = this.coords2[index - 1];
            }


            // Work out the X interval
            var xInterval = (ca.width - (2 * prop['chart.hmargin']) - this.gutterLeft - this.gutterRight) / (lineData.length - 1);
    
            // Loop thru each value given, plotting the line
            // (FORMERLY FIRST)
            for (i=0,len=lineData.length; i<len; i+=1) {

                var data_point = lineData[i];
    
                /**
                * Get the yPos for the given data point
                */
                var yPos = this.getYCoord(data_point);


                // Null data points, and a special case for this bug:http://dev.rgraph.net/tests/ymin.html
                if (   lineData[i] == null
                    || (prop['chart.xaxispos'] == 'bottom' && lineData[i] < this.min && !prop['chart.outofbounds'])
                    ||  (prop['chart.xaxispos'] == 'center' && lineData[i] < (-1 * this.max) && !prop['chart.outofbounds'])
                    || (((lineData[i] < this.min && prop['chart.xaxispos'] !== 'center') || lineData[i] > this.max) && !prop['chart.outofbounds'])) {
    
                    yPos = null;
                }

                // Not always very noticeable, but it does have an effect
                // with thick lines
                co.lineCap  = 'round';
                co.lineJoin = 'round';
    
                // Plot the line if we're at least on the second iteration
                if (i > 0) {
                    xPos = xPos + xInterval;
                } else {
                    xPos = prop['chart.hmargin'] + this.gutterLeft;
                }
                
                if (prop['chart.animation.unfold.x']) {
                    xPos *= prop['chart.animation.factor'];
                    
                    if (xPos < prop['chart.gutter.left']) {
                        xPos = prop['chart.gutter.left'];
                    }
                }
    
                /**
                * Add the coords to an array
                */
                this.coords.push([xPos, yPos]);
                lineCoords.push([xPos, yPos]);
            }

            co.stroke();

            // Store the coords in another format, indexed by line number
            this.coords2[index] = lineCoords;

            /**
            * For IE only: Draw the shadow ourselves as ExCanvas doesn't produce shadows
            */
            if (RG.ISOLD && prop['chart.shadow']) {
                this.DrawIEShadow(lineCoords, co.shadowColor);
            }
                        /**
            * Now draw the actual line [FORMERLY SECOND]
            */
            co.beginPath();
            // Transparent now as of 11/19/2011
            co.strokeStyle = 'rgba(0,0,0,0)';
            //co.strokeStyle = fill;
            if (fill) {
                co.fillStyle   = fill;
            }

            var isStepped = prop['chart.stepped'];
            var isFilled  = prop['chart.filled'];
            
            if (prop['chart.xaxispos'] == 'top') {
                var xAxisPos = this.gutterTop;
            } else if (prop['chart.xaxispos'] == 'center') {
                var xAxisPos = this.gutterTop + (this.grapharea / 2);
            } else if (prop['chart.xaxispos'] == 'bottom') {
                var xAxisPos = this.getYCoord(prop['chart.ymin'])

            }
            
            for (var i=0,len=lineCoords.length; i<len; i+=1) {
    
                xPos = lineCoords[i][0];
                yPos = lineCoords[i][1];
                var set = index;
    
                var prevY     = (lineCoords[i - 1] ? lineCoords[i - 1][1] : null);
                var isLast    = (i + 1) == lineCoords.length;
    
                /**
                * This nullifys values which are out-of-range
                */
                if (!prop['chart.outofbounds'] && (prevY < this.gutterTop || prevY > (ca.height - this.gutterBottom) ) ) {
                    penUp = true;
                }
    
                if (i == 0 || penUp || !yPos || !prevY || prevY < this.gutterTop) {

                    if (prop['chart.filled'] && !prop['chart.filled.range']) {
    
                        if (!prop['chart.outofbounds'] || prevY === null || yPos === null) {
                            co.moveTo(xPos + 1, xAxisPos);
                        }

                        // This facilitates the X axis being at the top
                        // NOTE: Also done below
                        if (prop['chart.xaxispos'] == 'top') {
                            co.moveTo(xPos + 1, xAxisPos);
                        }
                        
                        if (isStepped && i > 0) {
                            co.lineTo(xPos, lineCoords[i - 1][1]);
                        }
    
                        co.lineTo(xPos, yPos);
    
                    } else {
    
                        if (RG.ISOLD && yPos == null) {
                            // Nada
                        } else {
                            co.moveTo(xPos + 1, yPos);
                        }
                    }
    
                    if (yPos == null) {
                        penUp = true;
    
                    } else {
                        penUp = false;
                    }
    
                } else {
    
                    // Draw the stepped part of stepped lines
                    if (isStepped) {
                        co.lineTo(xPos, lineCoords[i - 1][1]);
                    }
    
                    if ((yPos >= this.gutterTop && yPos <= (ca.height - this.gutterBottom)) || prop['chart.outofbounds'] ) {
    
                        if (isLast && prop['chart.filled'] && !prop['chart.filled.range'] && prop['chart.yaxispos'] == 'right') {
                            xPos -= 1;
                        }
    
    
                        // Added 8th September 2009
                        if (!isStepped || !isLast) {
                            co.lineTo(xPos, yPos);
                            
                            if (isFilled && lineCoords[i+1] && lineCoords[i+1][1] == null) {
                                co.lineTo(xPos, xAxisPos);
                            }
                        
                        // Added August 2010
                        } else if (isStepped && isLast) {
                            co.lineTo(xPos,yPos);
                        }
    
    
                        penUp = false;
                    } else {
                        penUp = true;
                    }
                }
            }

            /**
            * Draw a line to the X axis if the chart is filled
            */
            if (prop['chart.filled'] && !prop['chart.filled.range'] && !prop['chart.curvy']) {

                // Is this needed ??
                var fillStyle = prop['chart.fillstyle'];

                /**
                * Draw the bottom edge of the filled bit using either the X axis or the prevlinedata,
                * depending on the index of the line. The first line uses the X axis, and subsequent
                * lines use the prevLineCoords array
                */
                if (index > 0 && prop['chart.filled.accumulative']) {
                    
                    co.lineTo(xPos, prevLineCoords ? prevLineCoords[i - 1][1] : (ca.height - this.gutterBottom - 1 + (prop['chart.xaxispos'] == 'center' ? (ca.height - this.gutterTop - this.gutterBottom) / 2 : 0)));

                    for (var k=(i - 1); k>=0; --k) {
                        co.lineTo(k == 0 ? prevLineCoords[k][0] + 1: prevLineCoords[k][0], prevLineCoords[k][1]);
                    }
                } else {

                    // Draw a line down to the X axis
                    if (prop['chart.xaxispos'] == 'top') {
                        co.lineTo(xPos, prop['chart.gutter.top'] +  1);
                        co.lineTo(lineCoords[0][0],prop['chart.gutter.top'] + 1);
                    } else if (typeof(lineCoords[i - 1][1]) == 'number') {

                        // var yPosition = prop['chart.xaxispos'] == 'center' ? ((ca.height - this.gutterTop - this.gutterBottom) / 2) + this.gutterTop : this.getYCoord(0);//ca.height - this.gutterBottom;
                        var yPosition = this.getYCoord(0);

                        co.lineTo(xPos,yPosition);
                        co.lineTo(lineCoords[0][0],yPosition);
                    }
                }
    
                co.fillStyle = !this.hidden(index) ? fill : 'rgba(0,0,0,0)';

                co.fill();
                co.beginPath();

            }
    
            /**
            * FIXME this may need removing when Chrome is fixed
            * SEARCH TAGS: CHROME SHADOW BUG
            */
            //if (false && RGraph.ISCHROME && prop['chart.shadow'] && prop['chart.chromefix'] && prop['chart.shadow.blur'] > 0) {
            //
            //    for (var i=lineCoords.length - 1; i>=0; --i) {
            //        if (
            //               typeof(lineCoords[i][1]) != 'number'
            //            || (typeof(lineCoords[i+1]) == 'object' && typeof(lineCoords[i+1][1]) != 'number')
            //           ) {
            //            co.moveTo(lineCoords[i][0],lineCoords[i][1]);
            //        } else {
            //            co.lineTo(lineCoords[i][0],lineCoords[i][1]);
            //        }
            //    }
            //}
    
            co.stroke();
    
    
            if (prop['chart.backdrop']) {
                this.DrawBackdrop(lineCoords, color);
            }
    
    
    
    
            /**
            * TODO CLIP TRACE
            * By using the clip() method the Trace animation can be updated.
            * NOTE: Needs to be done for the filled part as well
            */
            co.save();
                co.beginPath();
                co.rect(0,0,ca.width * prop['chart.animation.trace.clip'],ca.height);
                co.clip();
                

                //
                // Draw errorbars
                //
                if (typeof prop['chart.errorbars'] !== 'null') {
                    this.drawErrorbars();
                }
                
                // Now redraw the lines with the correct line width
                this.SetShadow(index);
                this.redrawLine(lineCoords, color, linewidth, index);
                co.stroke();
                RG.NoShadow(this);
                


    
            // Draw the tickmarks
                for (var i=0; i<lineCoords.length; ++i) {
        
                    i = Number(i);
                    
                    /**
                    * Set the color
                    */
                    co.strokeStyle = color;
                    
        
                    if (isStepped && i == (lineCoords.length - 1)) {
                        co.beginPath();
                        //continue;
                    }
        
                    if (
                        (
                            tickmarks != 'endcircle'
                         && tickmarks != 'endsquare'
                         && tickmarks != 'filledendsquare'
                         && tickmarks != 'endtick'
                         && tickmarks != 'endtriangle'
                         && tickmarks != 'arrow'
                         && tickmarks != 'filledarrow'
                        )
                        || (i == 0 && tickmarks != 'arrow' && tickmarks != 'filledarrow')
                        || i == (lineCoords.length - 1)
                       ) {
        
                        var prevX = (i <= 0 ? null : lineCoords[i - 1][0]);
                        var prevY = (i <= 0 ? null : lineCoords[i - 1][1]);

                        this.DrawTick(
                            lineData,
                            lineCoords[i][0],
                            lineCoords[i][1],
                            color,
                            false,
                            prevX,
                            prevY,
                            tickmarks,
                            i,
                            index
                        );
        
                        // Draws tickmarks on the stepped bits of stepped charts. Takend out 14th July 2010
                        //
                        //if (this.properties['chart.stepped'] && lineCoords[i + 1] && this.properties['chart.tickmarks'] != 'endsquare' && this.properties['chart.tickmarks'] != 'endcircle' && this.properties['chart.tickmarks'] != 'endtick') {
                        //    this.DrawTick(lineCoords[i + 1][0], lineCoords[i][1], color);
                        //}
                    }
                }
            
            co.restore();
    
            // Draw something off canvas to skirt an annoying bug
            co.beginPath();
            co.arc(ca.width + 50000, ca.height + 50000, 2, 0, 6.38, 1);
        };
        
        /**
        * This functions draws a tick mark on the line
        */
        this.drawTick =
        this.DrawTick = function (lineData, xPos, yPos, color, isShadow, prevX, prevY, tickmarks, index, dataset)
        {
            // Various conditions mean no tick
            if (this.hidden(dataset)) {
                return;
            } else if (RG.is_null(yPos)) {
                return false;
            } else if ((yPos > (ca.height - this.gutterBottom)) && !prop['chart.outofbounds']) {
                return;
             } else if ((yPos < this.gutterTop) && !prop['chart.outofbounds']) {
                return;
            }

            co.beginPath();
    
            var offset   = 0;
    
            // Reset the stroke and lineWidth back to the same as what they were when the line was drawm
            // UPDATE 28th July 2011 - the line width is now set to 1
            co.lineWidth   = prop['chart.tickmarks.linewidth'] ? prop['chart.tickmarks.linewidth'] : prop['chart.linewidth'];
            co.strokeStyle = isShadow ? prop['chart.shadow.color'] : co.strokeStyle;
            co.fillStyle   = isShadow ? prop['chart.shadow.color'] : co.strokeStyle;
    
            // Cicular tick marks
            if (   tickmarks == 'circle'
                || tickmarks == 'filledcircle'
                || tickmarks == 'endcircle') {
    
                if (tickmarks == 'circle'|| tickmarks == 'filledcircle' || (tickmarks == 'endcircle' && (index == 0 || index == (lineData.length - 1)))) {
                    co.beginPath();
                    co.arc(xPos + offset, yPos + offset, prop['chart.ticksize'], 0, 360 / (180 / RG.PI), false);

                    if (tickmarks == 'filledcircle') {
                        co.fillStyle = isShadow ? prop['chart.shadow.color'] : co.strokeStyle;
                    } else {
                        co.fillStyle = isShadow ? prop['chart.shadow.color'] : 'white';
                    }
    
                    co.stroke();
                    co.fill();
                }
    
            // Halfheight "Line" style tick marks
            } else if (tickmarks == 'halftick') {
                co.beginPath();
                co.moveTo(Math.round(xPos), yPos);
                co.lineTo(Math.round(xPos), yPos + prop['chart.ticksize']);
    
                co.stroke();
            
            // Tick style tickmarks
            } else if (tickmarks == 'tick') {
                co.beginPath();
                co.moveTo(Math.round(xPos), yPos -  prop['chart.ticksize']);
                co.lineTo(Math.round(xPos), yPos + prop['chart.ticksize']);
    
                co.stroke();
            
            // Endtick style tickmarks
            } else if (tickmarks == 'endtick' && (index == 0 || index == (lineData.length - 1))) {
                co.beginPath();
                co.moveTo(Math.round(xPos), yPos -  prop['chart.ticksize']);
                co.lineTo(Math.round(xPos), yPos + prop['chart.ticksize']);
    
                co.stroke();
            
            // "Cross" style tick marks
            } else if (tickmarks == 'cross') {
                co.beginPath();
                    
                    var ticksize = prop['chart.ticksize'];
                    
                    co.moveTo(xPos - ticksize, yPos - ticksize);
                    co.lineTo(xPos + ticksize, yPos + ticksize);
                    co.moveTo(xPos + ticksize, yPos - ticksize);
                    co.lineTo(xPos - ticksize, yPos + ticksize);
                co.stroke();
    
    
            // Triangle style tick marks
            } else if (tickmarks == 'triangle' || tickmarks == 'filledtriangle' || (tickmarks == 'endtriangle' && (index == 0 || index == (lineData.length - 1)))) {
                co.beginPath();
                    
                    if (tickmarks == 'filledtriangle') {
                        co.fillStyle = isShadow ? prop['chart.shadow.color'] : co.strokeStyle;
                    } else {
                        co.fillStyle = 'white';
                    }
    
                    co.moveTo(ma.round(xPos - prop['chart.ticksize']), yPos + prop['chart.ticksize']);
                    co.lineTo(ma.round(xPos), yPos - prop['chart.ticksize']);
                    co.lineTo(ma.round(xPos + prop['chart.ticksize']), yPos + prop['chart.ticksize']);
                co.closePath();
                
                co.stroke();
                co.fill();
    
    
            // 
            // A white bordered circle
            //
            } else if (tickmarks == 'borderedcircle' || tickmarks == 'dot') {
                    
                    co.lineWidth   = prop['chart.tickmarks.dot.linewidth'] || 0.00000001;

                    pa2(co, [
                        'b',
                        'a',xPos, yPos, prop['chart.ticksize'], 0, 360 / (180 / RG.PI), false,
                        'c',
                        'f',prop['chart.tickmarks.dot.fill'] || color,
                        's',prop['chart.tickmarks.dot.stroke'] || color
                    ]);
            
            } else if (   tickmarks == 'square'
                       || tickmarks == 'filledsquare'
                       || (tickmarks == 'endsquare' && (index == 0 || index == (lineData.length - 1)))
                       || (tickmarks == 'filledendsquare' && (index == 0 || index == (lineData.length - 1))) ) {
    
                co.fillStyle   = 'white';
                co.strokeStyle = co.strokeStyle;
    
                co.beginPath();
                co.rect(Math.round(xPos - prop['chart.ticksize']), Math.round(yPos - prop['chart.ticksize']), prop['chart.ticksize'] * 2, prop['chart.ticksize'] * 2);
    
                // Fillrect
                if (tickmarks == 'filledsquare' || tickmarks == 'filledendsquare') {
                    co.fillStyle = isShadow ? prop['chart.shadow.color'] : co.strokeStyle;
                    co.rect(Math.round(xPos - prop['chart.ticksize']), Math.round(yPos - prop['chart.ticksize']), prop['chart.ticksize'] * 2, prop['chart.ticksize'] * 2);
    
                } else if (tickmarks == 'square' || tickmarks == 'endsquare') {
                    co.fillStyle = isShadow ? prop['chart.shadow.color'] : 'white';
                    co.rect(Math.round((xPos - prop['chart.ticksize']) + 1), Math.round((yPos - prop['chart.ticksize']) + 1), (prop['chart.ticksize'] * 2) - 2, (prop['chart.ticksize'] * 2) - 2);
                }
    
                co.stroke();
                co.fill();
    
            /**
            * FILLED arrowhead
            */
            } else if (tickmarks == 'filledarrow') {
            
                var x = Math.abs(xPos - prevX);
                var y = Math.abs(yPos - prevY);
    
                if (yPos < prevY) {
                    var a = Math.atan(x / y) + 1.57;
                } else {
                    var a = Math.atan(y / x) + 3.14;
                }
    
                co.beginPath();
                    co.moveTo(Math.round(xPos), Math.round(yPos));
                    co.arc(Math.round(xPos), Math.round(yPos), 7, a - 0.5, a + 0.5, false);
                co.closePath();
    
                co.stroke();
                co.fill();
    
            /**
            * Arrow head, NOT filled
            */
            } else if (tickmarks == 'arrow') {
            
                var orig_linewidth = co.lineWidth;
    
                var x = Math.abs(xPos - prevX);
                var y = Math.abs(yPos - prevY);
                
                co.lineWidth;
    
                if (yPos < prevY) {
                    var a = Math.atan(x / y) + 1.57;
                } else {
                    var a = Math.atan(y / x) + 3.14;
                }
    
                co.beginPath();
                    co.moveTo(Math.round(xPos), Math.round(yPos));
                    co.arc(Math.round(xPos), Math.round(yPos), 7, a - 0.5 - (doc.all ? 0.1 : 0.01), a - 0.4, false);
    
                    co.moveTo(Math.round(xPos), Math.round(yPos));
                    co.arc(Math.round(xPos), Math.round(yPos), 7, a + 0.5 + (doc.all ? 0.1 : 0.01), a + 0.5, true);
                co.stroke();
                co.fill();

                // Revert to original lineWidth
                co.lineWidth = orig_linewidth;
                


            /**
            * Image based tickmark
            */
            // lineData, xPos, yPos, color, isShadow, prevX, prevY, tickmarks, index
            } else if (
                       typeof tickmarks === 'string' &&
                           (
                            tickmarks.substr(0, 6) === 'image:'  ||
                            tickmarks.substr(0, 5) === 'data:'   ||
                            tickmarks.substr(0, 1) === '/'       ||
                            tickmarks.substr(0, 3) === '../'     ||
                            tickmarks.substr(0, 7) === 'images/'
                           )
                      ) {

                var img = new Image();
                
                if (tickmarks.substr(0, 6) === 'image:') {
                    img.src = tickmarks.substr(6);
                } else {
                    img.src = tickmarks;
                }


                img.onload = function ()
                {
                    if (prop['chart.tickmarks.image.halign'] === 'center') xPos -= (this.width / 2);
                    if (prop['chart.tickmarks.image.halign'] === 'right')  xPos -= this.width;
                    
                    if (prop['chart.tickmarks.image.valign'] === 'center') yPos -= (this.height / 2);
                    if (prop['chart.tickmarks.image.valign'] === 'bottom') yPos -= this.height;
                    
                    xPos += prop['chart.tickmarks.image.offsetx'];
                    yPos += prop['chart.tickmarks.image.offsety'];

                    co.drawImage(this, xPos, yPos);
                };
                



            /**
            * Custom tick drawing function
            */
            } else if (typeof(tickmarks) == 'function') {
                tickmarks(this, lineData, lineData[index], index, xPos, yPos, color, prevX, prevY);
            }
        };
        
        /**
        * Draws a filled range if necessary
        */
        this.drawRange =
        this.DrawRange = function ()
        {
            /**
            * Fill the range if necessary
            */
            if (prop['chart.filled.range'] && prop['chart.filled']) {
            
                if (RG.isNull(prop['chart.filled.range.threshold'])) {
                    prop['chart.filled.range.threshold']        = this.ymin
                    prop['chart.filled.range.threshold.colors'] = [prop['chart.fillstyle'], prop['chart.fillstyle']]
                }
    
                for (var idx=0; idx<2; ++idx) {
    
                    var threshold_colors = prop['chart.filled.range.threshold.colors'];
                    var y = this.getYCoord(prop['chart.filled.range.threshold'])
                    
                    co.save();
                        if (idx == 0) {
                            co.beginPath();
                            co.rect(0,0,ca.width,y);
                            co.clip();
                        
                        } else {
    
                            co.beginPath();
                            co.rect(0,y,ca.width, ca.height);
                            co.clip();
                        }
    
                        co.beginPath();
                            co.fillStyle = (idx == 1 ? prop['chart.filled.range.threshold.colors'][1] : prop['chart.filled.range.threshold.colors'][0]);
                        
                            //co.strokeStyle = prop['chart.fillstyle']; // Strokestyle not used now (10th October 2012)
                            
                            co.lineWidth = !this.hidden(idx) ? 1 : 0;
                            var len = (this.coords.length / 2);
                
                            
                            
                            for (var i=0; i<len; ++i) {
                                if (!RG.is_null(this.coords[i][1])) {
                                    if (i == 0) {
                                        co.moveTo(this.coords[i][0], this.coords[i][1])
                                    } else {
                                        co.lineTo(this.coords[i][0], this.coords[i][1])
                                    }
                                }
                            }
    
    
                            for (var i=this.coords.length - 1; i>=len; --i) {
                                if (RG.is_null(this.coords[i][1])) {
                                    co.moveTo(this.coords[i][0], this.coords[i][1])
                                } else {
                                    co.lineTo(this.coords[i][0], this.coords[i][1])
                                }
                                //co.lineTo(this.coords[i][0], this.coords[i][1])
                            }
    
    
    
                        // Taken out - 10th Oct 2012
                        //co.stroke();
            
                        co.fill();
                    co.restore();
                }
            }
        };
        
        /**
        * Redraws the line with the correct line width etc
        * 
        * @param array coords The coordinates of the line
        */
        this.redrawLine =
        this.RedrawLine = function (coords, color, linewidth, index)
        {
            if (prop['chart.noredraw'] || prop['chart.filled.range']) {
                return;
            }
    

            
            co.strokeStyle = (typeof(color) == 'object' && color && color.toString().indexOf('CanvasGradient') == -1 ? color[0] : color);
            co.lineWidth = linewidth;


            // Added this on 1/1/17 to facilitate dotted and dashed lines
            if (prop['chart.dashed']) {
                co.setLineDash([2,6])
            } else if (prop['chart.dotted']) {
                co.setLineDash([1,5])
            }
                        if (this.hidden(index)) {
                co.strokeStyle = 'rgba(0,0,0,0)';
            }
            

            if (!RG.ISOLD && (prop['chart.curvy'] || prop['chart.spline'])) {
                this.DrawCurvyLine(coords, this.hidden(index) ? 'rgba(0,0,0,0)' : color, linewidth, index);
                return;
            }
            

            co.beginPath();
    
            var len    = coords.length;
            var width  = ca.width
            var height = ca.height;
            var penUp  = false;
    
            for (var i=0; i<len; ++i) {
    
                var xPos   = coords[i][0];
                var yPos   = coords[i][1];
    
                if (i > 0) {
                    var prevX = coords[i - 1][0];
                    var prevY = coords[i - 1][1];
                }
    
    
                if ((
                       (i == 0 && coords[i])
                    || (yPos < this.gutterTop)
                    || (prevY < this.gutterTop)
                    || (yPos > (height - this.gutterBottom))
                    || (i > 0 && prevX > (width - this.gutterRight))
                    || (i > 0 && prevY > (height - this.gutterBottom))
                    || prevY == null
                    || penUp == true
                   ) && (!prop['chart.outofbounds'] || yPos == null || prevY == null) ) {

                    if (RG.ISOLD && yPos == null) {
                        // ...?
                    } else {
                        co.moveTo(coords[i][0], coords[i][1]);
                    }
    
                    penUp = false;
    
                } else {
    
                    if (prop['chart.stepped'] && i > 0) {
                        co.lineTo(coords[i][0], coords[i - 1][1]);
                    }
                    
                    // Don't draw the last bit of a stepped chart. Now DO
                    //if (!this.properties['chart.stepped'] || i < (coords.length - 1)) {
                    co.lineTo(coords[i][0], coords[i][1]);
                    //}
                    penUp = false;
                }
            }
    
            /**
            * If two colors are specified instead of one, go over the up bits
            */
            if (prop['chart.colors.alternate'] && typeof(color) == 'object' && color[0] && color[1]) {
                for (var i=1; i<len; ++i) {
    
                    var prevX = coords[i - 1][0];
                    var prevY = coords[i - 1][1];
                    
                    if (prevY != null && coords[i][1] != null) {
                        co.beginPath();
                            co.strokeStyle = color[coords[i][1] < prevY ? 0 : 1];
                            co.lineWidth = prop['chart.linewidth'];
                            co.moveTo(prevX, prevY);
                            co.lineTo(coords[i][0], coords[i][1]);
                        co.stroke();
                    }
                }
            }
            


            if (prop['chart.dashed'] || prop['chart.dotted']) {
                co.setLineDash([1,0]);
            }
        };
        
        /**
        * This function is used by MSIE only to manually draw the shadow
        * 
        * @param array coords The coords for the line
        */
        this.drawIEShadow =
        this.DrawIEShadow = function (coords, color)
        {
            var offsetx = prop['chart.shadow.offsetx'];
            var offsety = prop['chart.shadow.offsety'];
            
            co.lineWidth   = prop['chart.linewidth'];
            co.strokeStyle = color;

            co.beginPath();
                for (var i=0; i<coords.length; ++i) {
                
                    var isNull     = RG.isNull(coords[i][1]);
                    var prevIsNull = RG.isNull(coords[i-1]) || RG.isNull(coords[i-1][1]);

                    if (i == 0 || isNull || prevIsNull) {
                        if (!isNull) {
                            co.moveTo(coords[i][0] + offsetx, coords[i][1] + offsety);
                        }
                    } else {
                        co.lineTo(coords[i][0] + offsetx, coords[i][1] + offsety);
                    }
                }
            co.stroke();
        };
        
        /**
        * Draw the backdrop
        */
        this.drawBackdrop =
        this.DrawBackdrop = function (coords, color)
        {
            //var ca   = this.canvas;
            //var co   = this.context;
            //var prop = this.properties;
    
            var size = prop['chart.backdrop.size'];
            co.lineWidth = size;
            co.globalAlpha = prop['chart.backdrop.alpha'];
            co.strokeStyle = color;
            var yCoords = [];
    
            co.beginPath();
                if (prop['chart.curvy'] && !RG.ISOLD) {
                    
                    // The DrawSpline function only takes the Y coords so extract them from the coords that have
                    // (which are X/Y pairs)
                    for (var i=0; i<coords.length; ++i) {
                        yCoords.push(coords[i][1])
                    }

                    this.DrawSpline(co, yCoords, color, null);
    
                } else {
                    co.moveTo(coords[0][0], coords[0][1]);
                    for (var j=1; j<coords.length; ++j) {
                        co.lineTo(coords[j][0], coords[j][1]);
                    }
                }
            co.stroke();
        
            // Reset the alpha value
            co.globalAlpha = 1;
            RG.NoShadow(this);
        };
        
        /**
        * Returns the linewidth
        */
        this.getLineWidth =
        this.GetLineWidth = function (i)
        {
            var linewidth = prop['chart.linewidth'];

            if (typeof(linewidth) == 'number') {
                return linewidth;
            
            } else if (typeof(linewidth) == 'object') {
                if (linewidth[i]) {
                    return linewidth[i];
                } else {
                    return linewidth[0];
                }
    
                alert('[LINE] Error! chart.linewidth should be a single number or an array of one or more numbers');
            }
        };
        
        /**
        * The getPoint() method - used to get the point the mouse is currently over, if any
        * 
        * @param object e The event object
        * @param object   OPTIONAL You can pass in the bar object instead of the
        *                          function getting it from the canvas
        */
        this.getShape =
        this.getPoint = function (e)
        {
            var obj     = this,
                mouseXY = RG.getMouseXY(e),
                mouseX  = mouseXY[0],
                mouseY  = mouseXY[1];
            
            // This facilitates you being able to pass in the bar object as a parameter instead of
            // the function getting it from the object
            if (arguments[1]) {
                obj = arguments[1];
            }
    
            for (var i=0; i<obj.coords.length; ++i) {
            
                var x = obj.coords[i][0],
                    y = obj.coords[i][1];
    
                // Do this if the hotspot is triggered by the X coord AND the Y coord
                if (   mouseX <= (x + prop['chart.tooltips.hotspot.size'])
                    && mouseX >= (x - prop['chart.tooltips.hotspot.size'])
                    && mouseY <= (y + prop['chart.tooltips.hotspot.size'])
                    && mouseY >= (y - prop['chart.tooltips.hotspot.size'])
                   ) {
    
                        if (RG.parseTooltipText) {
                            var tooltip = RG.parseTooltipText(prop['chart.tooltips'], i);
                        }
    
                        // Work out the dataset
                        var dataset = 0,
                            idx     = i;

                        while ((idx + 1) > this.data[dataset].length) {
                            idx -= this.data[dataset].length;
                            dataset++;
                        }

                        // Don't return points for hidden datasets
                        // Added 10/08/17
                        // Fixed 22/09/17 Thanks to zsolt - this should be a continue
                        // not a return.
                        if (this.hidden(dataset)) {
                            continue;
                        }

                        return {
                            0: obj, object: obj,
                            1: x,   x: x,
                            2: y,   y: y,
                            3: i,   index: i,
                                    tooltip: tooltip,
                                    dataset: dataset,
                                    index_adjusted: idx
                        };
    
                } else if (    prop['chart.tooltips.hotspot.xonly'] == true
                            && mouseX <= (x + prop['chart.tooltips.hotspot.size'])
                            && mouseX >= (x - prop['chart.tooltips.hotspot.size'])) {
    
                            var tooltip = RG.parseTooltipText(prop['chart.tooltips'], i);
    
                            return {
                                0: obj, object: obj,
                                1: x,   x: x,
                                2: y,   y: y,
                                3: i,   index: i,
                                        tooltip: tooltip
                            };
                }
            }
        };
        
        /**
        * Draws the above line labels
        */
        this.drawAboveLabels =
        this.DrawAboveLabels = function ()
        {
            var size       = prop['chart.labels.above.size'],
                font       = prop['chart.labels.above.font'] || prop['chart.text.font'],
                units_pre  = prop['chart.labels.above.units.pre'],
                units_post = prop['chart.labels.above.units.post'],
                decimals   = prop['chart.labels.above.decimals'],
                color      = prop['chart.labels.above.color'] || prop['chart.text.color'],
                bgcolor    = prop['chart.labels.above.background'] || 'white',
                border     = ((
                       typeof prop['chart.labels.above.border'] === 'boolean'
                    || typeof prop['chart.labels.above.border'] === 'number'
                ) ? prop['chart.labels.above.border'] : true),
                offsety = prop['chart.labels.above.offsety'] + size,
                specific = prop['chart.labels.above.specific'];

            // Use this to 'reset' the drawing state
            co.beginPath();
    
            // Don't need to check that chart.labels.above is enabled here, it's been done already
            for (var i=0, len=this.coords.length; i<len; i+=1) {

                var coords = this.coords[i];

                RG.text2(this, {
                    color:color,
                    'font':font,
                    'size':size,
                    'x':coords[0],
                    'y':coords[1] - offsety,
                    'text':(specific && specific[i]) ? specific[i] : (specific ? null : RG.numberFormat(this, typeof decimals === 'number' ? this.data_arr[i].toFixed(decimals) : this.data_arr[i], units_pre, units_post)),
                    'valign':'center',
                    'halign':'center',
                    'bounding':true,
                    'boundingFill':bgcolor,
                    'boundingStroke':border ? 'black' : 'rgba(0,0,0,0)',
                    'tag':'labels.above'
                });
            }
        };
        
        /**
        * Draw a curvy line.
        */
        this.drawCurvyLine =
        this.DrawCurvyLine = function (coords, color, linewidth, index)
        {
            var yCoords = [];
    
            for (var i=0; i<coords.length; ++i) {
                yCoords.push(coords[i][1]);
            }
            
            if (prop['chart.filled']) {
                co.beginPath();
                    
                    // First, work out the xaxispos
                    //if (prop['chart.xaxispos'] === 'center') {
                    //    var xaxisY = ((ca.height - this.gutterTop - this.gutterBottom) / 2) + this.gutterTop;
                    //} else {
                        var xaxisY = this.getYCoord(prop['chart.ymin']);
                    //}


                    co.moveTo(coords[0][0],xaxisY);
                    this.drawSpline(co, yCoords, color, index);

                    if (prop['chart.filled.accumulative'] && index > 0) {
                        for (var i=(this.coordsSpline[index - 1].length - 1); i>=0; i-=1) {
                            co.lineTo(this.coordsSpline[index - 1][i][0], this.coordsSpline[index - 1][i][1]);
                        }
                    } else {
                        co.lineTo(coords[coords.length - 1][0],xaxisY);
                    }
                co.fill();
            }

            co.beginPath();    
            this.DrawSpline(co, yCoords, color, index);
            co.stroke();
        };
        
        /**
        * When you click on the chart, this method can return the Y value at that point. It works for any point on the
        * chart (that is inside the gutters) - not just points on the Line.
        * 
        * @param object e The event object
        */
        this.getValue = function (arg)
        {
            if (arg.length == 2) {
                var mouseX = arg[0];
                var mouseY = arg[1];
            } else {
                var mouseCoords = RG.getMouseXY(arg);
                var mouseX      = mouseCoords[0];
                var mouseY      = mouseCoords[1];
            }
    
            var obj = this;
            var xaxispos = prop['chart.xaxispos'];
    
            if (mouseY < prop['chart.gutter.top']) {
                return xaxispos == 'bottom' || xaxispos == 'center' ? this.max : this.min;
            } else if (mouseY > (ca.height - prop['chart.gutter.bottom'])) {
                return xaxispos == 'bottom' ? this.min : this.max;
            }
            
            if (prop['chart.xaxispos'] == 'center') {
                var value = (( (obj.grapharea / 2) - (mouseY - prop['chart.gutter.top'])) / obj.grapharea) * (obj.max - obj.min);
                value *= 2;
                value > 0 ? value += this.min : value -= this.min;
                return value;
            } else if (prop['chart.xaxispos'] == 'top') {
                var value = ((obj.grapharea - (mouseY - prop['chart.gutter.top'])) / obj.grapharea) * (obj.max - obj.min);
                value = Math.abs(obj.max - value) * -1;
                return value;
            } else {
                var value = ((obj.grapharea - (mouseY - prop['chart.gutter.top'])) / obj.grapharea) * (obj.max - obj.min)
                value += obj.min;
                return value;
            }
        };
        
        /**
        * Each object type has its own Highlight() function which highlights the appropriate shape
        * 
        * @param object shape The shape to highlight
        */
        this.highlight =
        this.Highlight = function (shape)
        {
            if (prop['chart.tooltips.highlight']) {
                
                if (typeof prop['chart.highlight.style'] === 'function') {
                    (prop['chart.highlight.style'])(shape);
                
                } else if (prop['chart.highlight.style'] === 'halo') {
                    
                    var obj   = shape.object,
                        color = prop['chart.colors'][shape.dataset];

                    // Clear a space in white first for the tickmark
                    RG.path2(obj.context, 'b a % % 13 0 6.2830 false f rgba(255,255,255,0.75)',
                        shape.x,
                        shape.y
                    );
                    
                    RG.path2(obj.context, 'ga 0.15 b a % % 13 0 6.2830 false f % ga 1',
                        shape.x,
                        shape.y,
                        color
                    );
            
                    RG.path2(obj.context, 'b a % % 7 0 6.2830 false f white',
                        shape.x,
                        shape.y
                    );
                    
                    RG.path2(obj.context, 'b a % % 5 0 6.2830 false f %',
                        shape.x,
                        shape.y,
                        color
                    );
                
                } else {
                    RG.Highlight.Point(this, shape);
                }
            }
        };
        
        /**
        * The getObjectByXY() worker method. Don't call this call:
        * 
        * RG.ObjectRegistry.getObjectByXY(e)
        * 
        * @param object e The event object
        */
        this.getObjectByXY = function (e)
        {
            //var ca      = this.canvas;
            //var prop    = this.properties;
            var mouseXY = RG.getMouseXY(e);
    
            // The 5 is so that the cursor doesn't have to be over the graphArea to trigger the hotspot
            if (
                   (mouseXY[0] > prop['chart.gutter.left'] - 5)
                && mouseXY[0] < (ca.width - prop['chart.gutter.right'] + 5)
                && mouseXY[1] > (prop['chart.gutter.top'] - 5)
                && mouseXY[1] < (ca.height - prop['chart.gutter.bottom'] + 5)
                ) {
    
                return this;
            }
        };
        
        /**
        * This method handles the adjusting calculation for when the mouse is moved
        * 
        * @param object e The event object
        */
        this.adjusting_mousemove =
        this.Adjusting_mousemove = function (e)
        {
            /**
            * Handle adjusting for the Bar
            */
            if (prop['chart.adjustable'] && RG.Registry.Get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {
    
                // Rounding the value to the given number of decimals make the chart step
                var value   = Number(this.getValue(e));//.toFixed(this.properties['chart.scale.decimals']);
                var shape   = RG.Registry.Get('chart.adjusting.shape');
    
                if (shape) {
    
                    RG.Registry.Set('chart.adjusting.shape', shape);
    
                    this.original_data[shape['dataset']][shape['index_adjusted']] = Number(value);
    
                    RG.redrawCanvas(e.target);
                    
                    RG.fireCustomEvent(this, 'onadjust');
                }
            }
        };
        
        /**
        * This function can be used when the canvas is clicked on (or similar - depending on the event)
        * to retrieve the relevant Y coordinate for a particular value.
        * 
        * @param int value The value to get the Y coordinate for
        */
        this.getYCoord = function (value)
        {    
            if (typeof(value) != 'number') {
                return null;
            }
    
            var y;
            var xaxispos = prop['chart.xaxispos'];
    
            // Higher than max
            // Commented out on March 7th 2013 because the tan curve was not showing correctly
            //if (value > this.max) {
            //    value = this.max;
            //}
    
            if (xaxispos == 'top') {
            
                // Account for negative numbers
                //if (value < 0) {
                //    value = Math.abs(value);
                //}
    
                y = ((value - this.min) / (this.max - this.min)) * this.grapharea;
    
                // Inverted Y labels
                if (prop['chart.scale.invert']) {
                    y = this.grapharea - y;
                }
    
                y = y + this.gutterTop
    
            } else if (xaxispos == 'center') {
    
                y = ((value - this.min) / (this.max - this.min)) * (this.grapharea / 2);
                y = (this.grapharea / 2) - y;
                y += this.gutterTop;
    
            } else {
    
                if ((value < this.min || value > this.max) && prop['chart.outofbounds'] == false) {
                    return null;
                }
    
                y = ((value - this.min) / (this.max - this.min)) * this.grapharea;
    
    
                
                // Inverted Y labels
                if (prop['chart.scale.invert']) {
                    y = this.grapharea - y;
                }
                
                y = ca.height - this.gutterBottom - y;
            }

            return y;
        };
        
        /**
        * This function positions a tooltip when it is displayed
        * 
        * @param obj object    The chart object
        * @param int x         The X coordinate specified for the tooltip
        * @param int y         The Y coordinate specified for the tooltip
        * @param objec tooltip The tooltips DIV element
        *
        this.positionTooltip = function (obj, x, y, tooltip, idx)
        {

            var coordX     = obj.coords[tooltip.__index__][0];
            var coordY     = obj.coords[tooltip.__index__][1];
            var canvasXY   = RG.getCanvasXY(obj.canvas);
            var gutterLeft = prop['chart.gutter.left'];
            var gutterTop  = prop['chart.gutter.top'];
            var width      = tooltip.offsetWidth;
            var height     = tooltip.offsetHeight;
            var mouseXY    = RG.getMouseXY(window.event);
    
            // Set the top position
            tooltip.style.left = 0;
            tooltip.style.top  = window.event.pageY - height - 20 + 'px';
            
            // By default any overflow is hidden
            tooltip.style.overflow = '';
            
            // Reposition the tooltip if at the edges:
            
            // LEFT edge
            if (canvasXY[0] + mouseXY[0] - (width / 2) < 0) {
                tooltip.style.left = canvasXY[0] + mouseXY[0]  - (width * 0.1) + 'px';
    
            // RIGHT edge
            } else if (canvasXY[0] + mouseXY[0]  + (width / 2) > doc.body.offsetWidth) {
                tooltip.style.left = canvasXY[0] + mouseXY[0]  - (width * 0.9) + 'px';
    
            // Default positioning - CENTERED
            } else {
                tooltip.style.left = canvasXY[0] + mouseXY[0]  - (width / 2) + 'px';
            }
        };*/
        
        /**
        * This function draws a curvy line
        * 
        * @param object context The  2D context
        * @param array  coords  The coordinates
        */
        this.drawSpline =
        this.DrawSpline = function (context, coords, color, index)
        {
            this.coordsSpline[index] = [];
            var xCoords     = [];
            var gutterLeft  = prop['chart.gutter.left'];
            var gutterRight = prop['chart.gutter.right'];
            var hmargin     = prop['chart.hmargin'];
            var interval    = (ca.width - (gutterLeft + gutterRight) - (2 * hmargin)) / (coords.length - 1);
    
            co.strokeStyle = color;

            /**
            * The drawSpline function takes an array of JUST Y coords - not X/Y coords. So the line coords need converting
            * if we've been given X/Y pairs
            */
            for (var i=0,len=coords.length; i<len;i+=1) {
                if (typeof coords[i] == 'object' && coords[i] && coords[i].length == 2) {
                    coords[i] = Number(coords[i][1]);
                }
            }
            
            /**
            * Get the Points array in the format we want - first value should be null along with the lst value
            */
            var P = [coords[0]];
            for (var i=0; i<coords.length; ++i) {
                P.push(coords[i]);
            }
            P.push(coords[coords.length - 1] + (coords[coords.length - 1] - coords[coords.length - 2]));
    
            for (var j=1; j<P.length-2; ++j) {
                for (var t=0; t<10; ++t) {
                    
                    var yCoord = Spline( t/10, P[j-1], P[j], P[j+1], P[j+2] );
    
                    xCoords.push(((j-1) * interval) + (t * (interval / 10)) + gutterLeft + hmargin);

                    co.lineTo(xCoords[xCoords.length - 1], yCoord);

                    
                    if (typeof index == 'number') {
                        this.coordsSpline[index].push([xCoords[xCoords.length - 1], yCoord]);
                    }
                }
            }
            

            // Draw the last section
            co.lineTo(((j-1) * interval) + gutterLeft + hmargin, P[j]);
            if (typeof index == 'number') {
                this.coordsSpline[index].push([((j-1) * interval) + gutterLeft + hmargin, P[j]]);
            }
            

    
            function Spline (t, P0, P1, P2, P3)
            {
                return 0.5 * ((2 * P1) +
                             ((0-P0) + P2) * t +
                             ((2*P0 - (5*P1) + (4*P2) - P3) * (t*t) +
                             ((0-P0) + (3*P1)- (3*P2) + P3) * (t*t*t)));
            }
        };
        
        /**
        * This allows for easy specification of gradients
        */
        this.parseColors = function ()
        {
            // Save the original colors so that they can be restored when the canvas is reset
            if (this.original_colors.length === 0) {
                this.original_colors['chart.colors']                = RGraph.array_clone(prop['chart.colors']);
                this.original_colors['chart.fillstyle']             = RGraph.array_clone(prop['chart.fillstyle']);
                this.original_colors['chart.key.colors']            = RGraph.array_clone(prop['chart.key.colors']);
                this.original_colors['chart.background.barcolor1']  = prop['chart.background.barcolor1'];
                this.original_colors['chart.background.barcolor2']  = prop['chart.background.barcolor2'];
                this.original_colors['chart.background.grid.color'] = prop['chart.background.grid.color'];
                this.original_colors['chart.background.color']      = prop['chart.background.color'];
                this.original_colors['chart.text.color']            = prop['chart.text.color'];
                this.original_colors['chart.crosshairs.color']      = prop['chart.crosshairs.color'];
                this.original_colors['chart.annotate.color']        = prop['chart.annotate.color'];
                this.original_colors['chart.title.color']           = prop['chart.title.color'];
                this.original_colors['chart.title.yaxis.color']     = prop['chart.title.yaxis.color'];
                this.original_colors['chart.key.background']        = prop['chart.key.background'];
                this.original_colors['chart.axis.color']            = prop['chart.axis.color'];
                this.original_colors['chart.highlight.fill']        = prop['chart.highlight.fill'];
            }
            
            
            
            for (var i=0; i<prop['chart.colors'].length; ++i) {
                if (typeof(prop['chart.colors'][i]) == 'object' && prop['chart.colors'][i][0] && prop['chart.colors'][i][1]) {
                    prop['chart.colors'][i][0] = this.parseSingleColorForGradient(prop['chart.colors'][i][0]);
                    prop['chart.colors'][i][1] = this.parseSingleColorForGradient(prop['chart.colors'][i][1]);
                } else {
                    prop['chart.colors'][i] = this.parseSingleColorForGradient(prop['chart.colors'][i]);
                }
            }
            
            /**
            * Fillstyle
            */
            if (prop['chart.fillstyle']) {
                if (typeof(prop['chart.fillstyle']) == 'string') {
                    prop['chart.fillstyle'] = this.parseSingleColorForGradient(prop['chart.fillstyle'], 'vertical');
                } else {
                    for (var i=0; i<prop['chart.fillstyle'].length; ++i) {
                        prop['chart.fillstyle'][i] = this.parseSingleColorForGradient(prop['chart.fillstyle'][i], 'vertical');
                    }
                }
            }
            
            /**
            * Key colors
            */
            if (!RG.is_null(prop['chart.key.colors'])) {
                for (var i=0; i<prop['chart.key.colors'].length; ++i) {
                    prop['chart.key.colors'][i] = this.parseSingleColorForGradient(prop['chart.key.colors'][i]);
                }
            }
    
            /**
            * Parse various properties for colors
            */
            var properties = [
                'chart.background.barcolor1',
                'chart.background.barcolor2',
                'chart.background.grid.color',
                'chart.background.color',
                'chart.text.color',
                'chart.crosshairs.color',
                'chart.annotate.color',
                'chart.title.color',
                'chart.title.yaxis.color',
                'chart.key.background',
                'chart.axis.color',
                'chart.highlight.fill'
            ];
    
            for (var i=0; i<properties.length; ++i) {
                prop[properties[i]] = this.parseSingleColorForGradient(prop[properties[i]]);
            }
        };
        
        /**
        * Use this function to reset the object to the post-constructor state. Eg reset colors if
        * need be etc
        */
        this.reset = function ()
        {
        };
        
        /**
        * This parses a single color value
        */
        this.parseSingleColorForGradient = function (color)
        {            
            if (!color || typeof(color) != 'string') {
                return color;
            }

            /**
            * Horizontal or vertical gradient
            */
            var dir = typeof(arguments[1]) == 'string' ? arguments[1] : 'vertical';
    
            if (typeof color === 'string' && color.match(/^gradient\((.*)\)$/i)) {
    
                var parts = RegExp.$1.split(':');
    
                // Create the gradient
                if (dir == 'horizontal') {
                    var grad = co.createLinearGradient(0,0,ca.width,0);
                } else {
                    var grad = co.createLinearGradient(0,ca.height - prop['chart.gutter.bottom'],0,prop['chart.gutter.top']);
                }
    
                var diff = 1 / (parts.length - 1);
    
                grad.addColorStop(0, RG.trim(parts[0]));
    
                for (var j=1; j<parts.length; ++j) {
                    grad.addColorStop(
                        j * diff,
                        RG.trim(parts[j])
                    );
                }
            }
    
            return grad ? grad : color;
        };
        
        /**
        * Sets the appropriate shadow
        */
        this.setShadow =
        this.SetShadow = function (i)
        {
            //var ca   = this.canvas;
            //var co   = this.context;
            //var prop = this.properties;
    
            if (prop['chart.shadow']) {
                /**
                * Handle the appropriate shadow color. This now facilitates an array of differing
                * shadow colors
                */
                var shadowColor = prop['chart.shadow.color'];
        
                /**
                * Accommodate an array of shadow colors as well as a single string
                */
                if (typeof(shadowColor) == 'object' && shadowColor[i - 1]) {
                    co.shadowColor = shadowColor[i];
    
                } else if (typeof(shadowColor) == 'object') {
                    co.shadowColor = shadowColor[0];
    
                } else if (typeof(shadowColor) == 'string') {
                    co.shadowColor = shadowColor;
                }
        
                co.shadowBlur    = prop['chart.shadow.blur'];
                co.shadowOffsetX = prop['chart.shadow.offsetx'];
                co.shadowOffsetY = prop['chart.shadow.offsety'];
            }
        };
        
        /**
        * This function handles highlighting an entire data-series for the interactive
        * key
        * 
        * @param int index The index of the data series to be highlighted
        */
        this.interactiveKeyHighlight = function (index)
        {
            var coords = this.coords2[index];

            if (coords) {

                var pre_linewidth = co.lineWidth;
                var pre_linecap   = co.lineCap;
                
                co.lineWidth   = prop['chart.linewidth'] + 10;
                co.lineCap     = 'round';
                co.strokeStyle = prop['chart.key.interactive.highlight.chart.stroke'];

                
                co.beginPath();
                if (prop['chart.curvy']) {
                    this.DrawSpline(co, coords, prop['chart.key.interactive.highlight.chart'], null);
                } else {
                    for (var i=0,len=coords.length; i<len; i+=1) {
                        if (   i == 0
                            || RG.is_null(coords[i][1])
                            || (typeof coords[i - 1][1] != undefined && RG.is_null(coords[i - 1][1]))) {
                            co.moveTo(coords[i][0], coords[i][1]);
                        } else {
                            co.lineTo(coords[i][0], coords[i][1]);
                        }
                    }
                }
                co.stroke();
                
                // Reset the lineCap and lineWidth
                co.lineWidth = pre_linewidth;
                co.lineCap = pre_linecap;
            }
        };
        
        /**
        * Using a function to add events makes it easier to facilitate method chaining
        * 
        * @param string   type The type of even to add
        * @param function func 
        */
        this.on = function (type, func)
        {
            if (type.substr(0,2) !== 'on') {
                type = 'on' + type;
            }


            if (typeof this[type] !== 'function') {
                this[type] = func;
            } else {
                RG.addCustomEventListener(this, type, func);
            }
    
            return this;
        };
        
        /**
        * This function runs once only
        * (put at the end of the file (before any effects))
        */
        this.firstDrawFunc = function ()
        {
        };
        
        //
        // Draws error-bars for the Bar and Line charts
        //
        this.drawErrorbars = function ()
        {
            // Save the state of the canvas so that it can be restored at the end
            co.save();

                RG.noShadow(this);

                var coords = this.coords,
                         x = 0,
                 errorbars = prop['chart.errorbars'],
                    length = 0;

                // If not capped set the width of the cap to zero
                if (!prop['chart.errorbars.capped']) {
                    prop['chart.errorbars.capped.width'] = 0.001;
                    halfwidth = 0.0005;
                }

                // Set the linewidth
                co.lineWidth = prop['chart.errorbars.linewidth'];
    
    
    
    
                for (var i=0; i<coords.length; ++i) {
                
                    var halfwidth = prop['chart.errorbars.capped.width'] / 2 || 5,
                            color = prop['chart.errorbars.color'] || 'black';

                    // Set the perbar linewidth if the fourth option in the array
                    // is specified
                    if (errorbars[i] && typeof errorbars[i][3] === 'number') {
                        co.lineWidth = errorbars[i][3];
                    } else if (typeof prop['chart.errorbars.linewidth'] === 'number') {
                        co.lineWidth = prop['chart.errorbars.linewidth'];
                    } else {
                        co.lineWidth = 1;
                    }

    
    
                    // Calulate the pixel size
                    if (typeof errorbars === 'number' || typeof errorbars[i] === 'number') {

                        if (typeof errorbars === 'number') {
                            var positiveLength = this.getYCoord(this.min) - this.getYCoord(this.min + errorbars),
                                negativeLength = positiveLength;
                        } else {
                            var positiveLength = this.getYCoord(this.min) - this.getYCoord(this.min + errorbars[i]),
                                negativeLength = positiveLength;
                        }

                        if (positiveLength || negativeLength) {

                            pa2(
                                co,
                                'lj miter lc square b m % % l % % m % % l % % l % % m % % l % % s %',
                                coords[i][0] - halfwidth,
                                coords[i][1] + negativeLength,
                                coords[i][0] + halfwidth,
                                coords[i][1] + negativeLength,
                                coords[i][0],
                                coords[i][1] + negativeLength,
                                coords[i][0],
                                coords[i][1] - positiveLength,
                                coords[i][0] - halfwidth,
                                coords[i][1] - positiveLength,
                                coords[i][0],
                                coords[i][1] - positiveLength,
                                coords[i][0] + halfwidth,
                                coords[i][1] - positiveLength,
                                color
                            );

                            pa2(
                                co,
                                'lj miter lc square b m % % l % % s %',
                                coords[i][0] - halfwidth,
                                coords[i][1] + negativeLength,
                                coords[i][0] + halfwidth,
                                coords[i][1] + negativeLength,
                                color
                            );
                        }
                                            } else if (typeof errorbars[i] === 'object' && !RG.isNull(errorbars[i])) {

                        var positiveLength = this.getYCoord(this.min) - this.getYCoord(this.min + errorbars[i][0]),
                            negativeLength = this.getYCoord(this.min) - this.getYCoord(this.min + errorbars[i][1]);


                        // Color
                        if (typeof errorbars[i][2] === 'string') {
                            color = errorbars[i][2];
                        }

                        // Cap width
                        halfwidth = typeof errorbars[i][4] === 'number' ? errorbars[i][4] / 2 : halfwidth;
    
    
                        // Set the linewidth
                        if (typeof errorbars[i] === 'object' && typeof errorbars[i][3] === 'number') {
                            co.lineWidth = errorbars[i][3];
                        } else if (typeof prop['chart.errorbars.linewidth'] === 'number') {
                            co.lineWidth = prop['chart.errorbars.linewidth'];
                        } else {
                            co.lineWidth = 1;
                        }


                        if (!RG.isNull(errorbars[i][0])) {

                            pa2(
                                co,
                                'lc square b  m % % l % % l % % m % % l % % s %',
                                coords[i][0],
                                coords[i][1],
                                coords[i][0],
                                coords[i][1] - positiveLength,
                                coords[i][0] - halfwidth,
                                ma.round(coords[i][1] - positiveLength),
                                coords[i][0],
                                ma.round(coords[i][1] - positiveLength),
                                coords[i][0] + halfwidth,
                                ma.round(coords[i][1] - positiveLength),
                                color
                            );
                        }
    
                        if (typeof errorbars[i][1] === 'number') {

                            var negativeLength = ma.abs(this.getYCoord(errorbars[i][1]) - this.getYCoord(0));
    
                            pa2(
                                co,
                                'b m % % l % % l % % m % % l % % s %',
                                coords[i][0],
                                coords[i][1],
                                coords[i][0],
                                coords[i][1] + negativeLength,
                                coords[i][0] - halfwidth,
                                ma.round(coords[i][1] + negativeLength),
                                coords[i][0],
                                ma.round(coords[i][1] + negativeLength),
                                coords[i][0] + halfwidth,
                                ma.round(coords[i][1] + negativeLength),
                                color
                            );
                        }
                    }
                }

            co.restore();
        };
        
        /**
        * Hides a line by setting the appropriate flag so that the .visible(index)
        * function returns the relevant result.
        * 
        * @param int index The index of the line to hide
        */
        this.hide = function ()
        {
            // Hide a single line
            if (typeof arguments[0] === 'number') {
                prop['chart.line.visible'][arguments[0]] = false;
            
            // Hide multiple lines
            } else if (typeof arguments[0] === 'object') {
                for (var i=0; i<arguments[0].length; ++i) {
                    prop['chart.line.visible'][arguments[0][i]] = false;
                }
                
            // Hide all lines
            } else {
                for (var i=0; i<this.original_data.length; ++i) {
                    prop['chart.line.visible'][i] = false;
                }
            }
            
            RG.redraw();
            
            // Facilitate chaining
            return this;
        };
        
        /**
        * Shows a line by setting the appropriate flag so that the .visible(index)
        * function returns the relevant result.
        * 
        * @param int index The index of the line to show
        */
        this.show = function ()
        {
            // Show a single line
            if (typeof arguments[0] === 'number') {
                prop['chart.line.visible'][arguments[0]] = true;
            
            // Show multiple lines
            } else if (typeof arguments[0] === 'object') {
                for (var i=0; i<arguments[0].length; ++i) {
                    prop['chart.line.visible'][arguments[0][i]] = true;
                }

            // Show all lines
            } else {
                for (var i=0; i<this.original_data.length; ++i) {
                    prop['chart.line.visible'][i] = true;
                }
            }
            
            RG.redraw();            
            
            // Facilitate chaining
            return this;
        };
        
        /**
        * Returns true/false as to wether a line is hidden or not
        * 
        * @param int index The index of the line to hide
        */
        this.hidden = function (index)
        {
            return !prop['chart.line.visible'][index];
        };
                /**
        * Unfold
        * 
        * This effect gradually increases the X/Y coordinatesfrom 0
        * 
        * @param object obj The chart object
        */
        this.unfold = function ()
        {
            var obj                        = this;
            var opt                        = arguments[0] ? arguments[0] : {};
            var frames                     = opt.frames ? opt.frames : 30;
            var frame                      = 0;
            var callback                   = arguments[1] ? arguments[1] : function () {};
            var initial                    = prop['chart.animation.unfold.initial'];
            
            prop['chart.animation.factor'] = prop['chart.animation.unfold.initial'];

            function iterator ()
            {
                prop['chart.animation.factor'] = ((1 - initial) * (frame / frames)) + initial;
    
                RG.clear(obj.canvas);
                RG.redrawCanvas(obj.canvas);
    
                if (frame < frames) {
                    frame++;
                    RG.Effects.updateCanvas(iterator);
                } else {
                    callback(obj);
                }
            }


            iterator();

            return this;
        };
        
        /**
        * Trace2
        * 
        * This is a new version of the Trace effect which no longer requires jQuery and is more compatible
        * with other effects (eg Expand). This new effect is considerably simpler and less code.
        * 
        * @param object     Options for the effect. Currently only "frames" is available.
        * @param int        A function that is called when the ffect is complete
        */
        this.trace  =
        this.trace2 = function ()
        {
            var obj       = this;
            var callback  = arguments[2];
            var opt       = arguments[0] || {};
            var frames    = opt.frames || 30;
            var frame     = 0;
            var callback = arguments[1] || function () {};

            obj.Set('animation.trace.clip', 0);
    
            function iterator ()
            {
                RG.clear(obj.canvas);

                RG.redrawCanvas(obj.canvas);

                if (frame++ < frames) {
                    obj.Set('animation.trace.clip', frame / frames);
                    RG.Effects.updateCanvas(iterator);
                } else {
                    callback(obj);
                }
            }
            
            iterator();
            
            return this;
        };
        
        /**
        * FoldToCenter
        * 
        * Line chart  FoldTocenter
        * 
        * @param object   OPTIONAL An object map of options
        * @param function OPTIONAL A callback to run when the effect is complete
        */
        this.foldtocenter =
        this.foldToCenter = function ()
        {
            var obj      = this;
            var opt      = arguments[0] || {};
            var frames   = opt.frames || 30;
            var frame    = 0;
            var callback = arguments[1] || function () {};
            var center_value = obj.scale2.max / 2;

            obj.Set('chart.ymax', obj.scale2.max);
            
            var original_data = RG.array_clone(obj.original_data);
            
            function iterator ()
            {
                for (var i=0,len=obj.data.length; i<len; ++i) {
                    if (obj.data[i].length) {
                        for (var j=0,len2=obj.data[i].length; j<len2; ++j) {
                            
                            var dataset = obj.original_data[i];

                            if (dataset[j] > center_value) {
                                dataset[j] = original_data[i][j] - ((original_data[i][j] - center_value) * (frame / frames));
                            } else {
                                dataset[j] = original_data[i][j] + (((center_value - original_data[i][j]) / frames) * frame);
                            }
                        }
                    }
                }
                
                RG.clear(obj.canvas);
                RG.redrawCanvas(obj.canvas)
    
                if (frame++ < frames) {
                    RG.Effects.updateCanvas(iterator);
                } else {
                    callback(obj);
                }
            }
                        iterator();
                        return this;
        };
        
        /**
        * UnfoldFromCenterTrace effect
        * 
        * @param object   An object containing options
        * @param function A callback function
        */
        this.unfoldFromCenterTrace =
        this.unfoldFromCenterTrace2 = function ()
        {
            var obj      = this,
                opt      = arguments[0] || {},
                frames   = opt.frames || 30,
                frame    = 0,
                data     = RG.arrayClone(obj.original_data),
                callback = arguments[1] || function () {};
                            // Draw the chart once to get the scale values
            obj.canvas.style.visibility = 'hidden';
            obj.draw();
            var max = obj.scale2.max;
            RG.clear(obj.canvas);
            obj.canvas.style.visibility = 'visible';
            
            /**
            * When the Trace function finishes it calls this function
            */
            var unfoldCallback = function ()
            {
                obj.original_data = data;
                obj.unfoldFromCenter({frames: frames / 2}, callback);
            };
                        /**
            * Determine the mid-point
            */
            var half = obj.Get('chart.xaxispos') == 'center' ? obj.min : ((obj.max - obj.min) / 2) + obj.min;
            obj.Set('chart.ymax', obj.max);
    
            for (var i=0,len=obj.original_data.length; i<len; ++i) {
                for (var j=0; j<obj.original_data[i].length; ++j) {
                    obj.original_data[i][j] = (obj.Get('chart.filled') && obj.Get('chart.filled.accumulative') && i > 0) ? 0 : half;
                }
            }

            RG.clear(obj.canvas);
            obj.trace2({frames: frames / 2}, unfoldCallback);
            
            return obj;
        };
        
        /**
        * UnfoldFromCenter
        * 
        * Line chart  unfold from center
        * 
        * @param object An option map of properties. Only frames is supported: {frames: 30}
        * @param function An optional callback
        */
        this.unfoldFromCenter = function ()
        {
            var obj           = this;
            var opt           = arguments[0] || {};
            var frames        = opt.frames || 30;
            var frame         = 0;
            var callback      = arguments[1] || function () {};
            
            // Draw the chart once to get the scale values
            obj.canvas.style.visibility = 'hidden';
            obj.Draw();
            var max = obj.scale2.max;
            RG.clear(obj.canvas);
            obj.canvas.style.visibility = 'visible';

            var center_value  = obj.Get('chart.xaxispos') === 'center' ? prop['chart.ymin'] : ((obj.max - obj.min) / 2) + obj.min;
            var original_data = RG.array_clone(obj.original_data);
            var steps         = null;
            
            obj.Set('chart.ymax', max);

            if (!steps) {
            
                steps = [];
            
                for (var dataset=0,len=original_data.length; dataset<len; ++dataset) {
    
                    steps[dataset] = []
    
                    for (var i=0,len2=original_data[dataset].length; i<len2; ++i) {
                        if (prop['chart.filled'] && prop['chart.filled.accumulative'] && dataset > 0) {
                            steps[dataset][i] = original_data[dataset][i] / frames;
                            obj.original_data[dataset][i] = center_value;
                        } else {
                            steps[dataset][i] = (original_data[dataset][i] - center_value) / frames;
                            obj.original_data[dataset][i] = center_value;
                        }
                    }
                }
            }

            function unfoldFromCenter ()
            {
                for (var dataset=0; dataset<original_data.length; ++dataset) {
                    for (var i=0; i<original_data[dataset].length; ++i) {
                        obj.original_data[dataset][i] += steps[dataset][i];
                    }
                }

                RG.clear(obj.canvas);
                RG.redrawCanvas(obj.canvas);
    
                if (--frames > 0) {
                    RG.Effects.updateCanvas(unfoldFromCenter);
                } else {
                    obj.original_data = RG.array_clone(original_data);
                    RG.clear(obj.canvas);
                    RG.redrawCanvas(obj.canvas);

                    callback(obj);
                }
            }
            
            unfoldFromCenter();
            
            return this;
        };
        
        
        
        

        RG.att(ca);
                //
        // Determines whether a point is adjustable or not.
        //
        // @param object A shape object
        //
        this.isAdjustable = function (shape)
        {
            if (RG.isNull(prop['chart.adjustable.only'])) {
                return true;
            }

            if (RG.isArray(prop['chart.adjustable.only']) && prop['chart.adjustable.only'][shape.index]) {
                return true;
            }

            return false;
        };
        
        /**
        * Register the object so it is redrawn when necessary
        */
        RG.Register(this);
        
        /**
        * This is the 'end' of the constructor so if the first argument
        * contains configuration data - handle that.
        */
        if (parseConfObjectForOptions) {
            RG.parseObjectStyleConfig(this, conf.options);
        }

        /**
        * Allow all lines to start off as visible
        */
        for (var i=0; i<this.original_data.length; ++i) {
            prop['chart.line.visible'][i] = true;
        }
    };


	stkpriceDataArr = [];
	function drawchart() {
	    var line = new RGraph.Line({
		id: 'cvs',
		data: stkpriceDataArr,
		options: {
			title: '',
			titleColor: 'grey',
			titleSize: 25,
//			titleVpos: 0.5,
			spline: true,
			textAccessible: true,
			hmargin: 5,
			gutterBottom: 35,
//			adjustable: true,
			linewidth: 0.5,
			ylabels: true,
			shadow: false,
			colors: ['blue'],
			tickmarks: 'triangle',
			ticksize: 2,
			textSize: 10,
			ymax: theMax,
			ymin: theMin,

			backgroundGrid: true,
			backgroundGridColor:  '#242',
				backgroundGridVlines: false,
				backgroundGridHlines: true,
				backgroundGridBorder: true,
//				backgroundGridAutofitNumhlines: 7,

				axisColor: '#392',
//			labels: ['1','2','3','4','5','6','7','8','9','10','11','12','13','14','15'],
			textColor: 'grey',
		}
	    }).draw()
	};
alarm();
setTimer();
</script>

</body>
</html>
