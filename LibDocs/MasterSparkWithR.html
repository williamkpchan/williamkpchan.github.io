<base target="_blank"><html><head><title>Master Spark With R</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src="https://williamkpchan.github.io/lazyload.min.js"></script>
<script type='text/javascript' src='https://williamkpchan.github.io/mainscript.js'></script>
<script src="D:/Dropbox/Public/commonfunctions.js"></script>
<script src="https://d3js.org/d3.v4.min.js"></script>

<script>
  var showTopicNumber = true;
  var bookid = "Master Spark With R"
  var markerName = "h2"
</script>
<style>
body{width:80%;margin-left: 10%; font-size:22px;}
h1, h2 {color: gold;}
strong {color: orange;}
pre{width:100%;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px; background-color:#044;}
</style></head><body onkeypress="chkKey()"><center>
<h1>Master Spark With R</h1>
<a href="#mustWatch" class="red goldbs" target="_self">Must Watch!</a>
<br><br>
<div id="toc"></div></center>
<br><br>
<div id="mustWatch"><center><span class="red">MustWatch</span></center><br>
</div>
<pre>
<br>
<br>
<h2><span class="orange">Chapter 1 Introduction</span></h2>

With information growing at exponential rates, it’s no surprise that historians are referring to this period of history as the Information Age. 
The increasing speed at which data is being collected has created new opportunities and is certainly poised to create even more. 
This chapter presents the tools that have been used to solve large-scale data challenges. 
First, it introduces Apache Spark as a leading tool that is democratizing our ability to process large datasets. 
With this as a backdrop, we introduce the R computing language, which was specifically designed to simplify data analysis. 
Finally, this leads us to introduce <code>sparklyr</code>, a project merging R and Spark into a powerful tool that is easily accessible to all.
Chapter 2 presents the prerequisites, tools, and steps you need to perform to get Spark and R working on your personal computer. 
You will learn how to install and initialize Spark, get introduced to common operations, and get your very first data processing and modeling task done. 
It is the goal of that chapter to help anyone grasp the concepts and tools required to start tackling large-scale data challenges which, until recently, were accessible to just a few organizations.
You then move into learning how to analyze large-scale data, followed by building models capable of predicting trends and discover information hidden in vast amounts of information. 
At which point, you will have the tools required to perform data analysis and modeling at scale. 
Subsequent chapters help you move away from your local computer into computing clusters required to solve many real world problems. 
The last chapters present additional topics, like real-time data processing and graph analysis, which you will need to truly master the art of analyzing data at any scale. 
The last chapter of this book provides you with tools and inspiration to consider contributing back to the Spark and R communities.
We hope that this is a journey you will enjoy, that will help you to solve problems in your professional career, and to nudge the world into making better decisions that can benefit us all.

<h2>1.1 Overview</h2>
Search engines were unable to store all of the web page information required to support web searches in a single computer. 
This meant that they had to split information into several files and store them across many machines. 
This approach became known as the <em>Google File System</em>, and was presented in a research paper published in 2003 by Google.

<h2>1.2 Hadoop</h2>
One year later, Google published a new paper describing how to perform operations across the Google File System, an approach that came to be known as <em>MapReduce</em>. 
As you would expect, there are two operations in MapReduce: map and reduce. 
The <em>map operation</em> provides an arbitrary way to transform each file into a new file, whereas the <em>reduce operation</em> combines two files. 
Both operations require custom computer code, but the MapReduce framework takes care of automatically executing them across many computers at once. 
These two operations are sufficient to process all the data available on the web, while also providing enough flexibility to extract meaningful information from it.
For example, as illustrated in Figure 1.2, we can use MapReduce to count words in two different text files stored in different machines. 
The map operation splits each word in the original file and outputs a new word-counting file with a mapping of words and counts. 
The reduce operation can be defined to take two word-counting files and combine them by aggregating the totals for each word; this last file will contain a list of word counts across all the original files.

<img src="https://therinspark.com/the-r-in-spark_files/figure-html/intro-mapreduce-example-1.png" height="320pt" />

FIGURE 1.2: MapReduce example counting words across files

Counting words is often the most basic MapReduce example, but we can also use MapReduce for much more sophisticated and interesting applications. 
For instance, we can use it to rank web pages in Google’s <em>PageRank</em> algorithm, which assigns ranks to web pages based on the count of hyperlinks linking to a web page and the rank of the page linking to it.
After these papers were released by Google, a team at Yahoo worked on implementing the Google File System and MapReduce as a single open source project. 
This project was released in 2006 as <em>Hadoop</em>, with the Google File System implemented as the <em>Hadoop Distributed File System</em> (HDFS). 
The Hadoop project made distributed file-based computing accessible to a wider range of users and organizations, making MapReduce useful beyond web data processing.
Although Hadoop provided support to perform MapReduce operations over a distributed file system, it still required MapReduce operations to be written with code every time a data analysis was run. 
To improve upon this tedious process, the <em>Hive</em> project, released in 2008 by Facebook, brought <em>Structured Query Language</em> (SQL) support to Hadoop. 
This meant that data analysis could now be performed at large scale without the need to write code for each MapReduce operation; instead, one could write generic data analysis statements in SQL, which are much easier to understand and write.

<h2>1.3 Spark</h2>
In 2009, <em>Apache Spark</em> began as a research project at UC Berkeley’s AMPLab to improve on MapReduce. 
Specifically, Spark provided a richer set of verbs beyond MapReduce to facilitate optimizing code running in multiple machines. 
Spark also loaded data in-memory, making operations much faster than Hadoop’s on-disk storage. 
One of the earliest results showed that running <em>logistic regression</em>, a data modeling technique that we will introduce in Chapter 4, allowed Spark to run 10 times faster than Hadoop by making use of in-memory datasets.. 
A chart similar to Figure 1.3 was presented in the original research publication.

<img src="https://therinspark.com/images/intro-hadoop-spark-logistic-regression-resized.png" />

FIGURE 1.3: Logistic regression performance in Hadoop and Spark

Even though Spark is well known for its in-memory performance, it was designed to be a general execution engine that works both in-memory and on-disk. 
For instance, Spark has set sorting, for which data was not loaded in-memory; rather, Spark made improvements in network serialization, network shuffling, and efficient use of the CPU’s cache to dramatically enhance performance. 
If you needed to sort large amounts of data, there was no other system in the world faster than Spark.
To give you a sense of how much faster and efficient Spark is, it takes 72 minutes and 2,100 computers to sort 100 terabytes of data using Hadoop, but only 23 minutes and 206 computers using Spark. 
In addition, Spark holds the cloud sorting record, which makes it the most cost-effective solution for sorting large-datasets in the cloud.
<table>
<thead>
<tr><th></th><th>Hadoop Record</th><th>Spark Record</th></tr>
</thead>
<tbody>
<tr><td>Data Size</td><td>102.5 TB</td><td>100 TB</td></tr>
<tr><td>Elapsed Time</td><td>72 mins</td><td>23 mins</td></tr>
<tr><td>Nodes</td><td>2100</td><td>206</td></tr>
<tr><td>Cores</td><td>50400</td><td>6592</td></tr>
<tr><td>Disk</td><td>3150 GB/s</td><td>618 GB/s</td></tr>
<tr><td>Network</td><td>10Gbps</td><td>10Gbps</td></tr>
<tr><td>Sort rate</td><td>1.42 TB/min</td><td>4.27 TB/min</td></tr>
<tr><td>Sort rate / node</td><td>0.67 GB/min</td><td>20.7 GB/min</td></tr>
</tbody>
</table>
Spark is also easier to use than Hadoop; for instance, the word-counting MapReduce example takes about 50 lines of code in Hadoop, but it takes only 2 lines of code in Spark. 
As you can see, Spark is much faster, more efficient, and easier to use than Hadoop.
In 2010, Spark was released as an open source project and then donated to the Apache Software Foundation in 2013. 
Spark is licensed under Apache 2.0, which allows you to freely use, modify, and distribute it. 
Spark then reached more than 1,000 contributors, making it one of the most active projects in the Apache Software Foundation.
This gives an overview of how Spark came to be, which we can now use to formally introduce Apache Spark as defined on the project’s website:

To help us understand this definition of Apache Spark, we break it down as follows:

<dt>Unified</dt>
Spark supports many libraries, cluster technologies, and storage systems.

<dt>Analytics</dt>
Analytics is the discovery and interpretation of data to produce and communicate information.

<dt>Engine</dt>
Spark is expected to be efficient and generic.

<dt>Large-Scale</dt>
You can interpret large-scale as <em>cluster</em>-scale, a set of connected computers working together.

Spark is described as an <em>engine</em> because it’s generic and efficient. 
It’s generic because it optimizes and executes generic code; that is, there are no restrictions as to what type of code you can write in Spark. 
It is efficient, because, as we mentioned earlier, Spark much faster than other technologies by making efficient use of memory, network, and CPUs to speed data processing algorithms in computing clusters.
This makes Spark ideal in many <em>analytics</em> projects like ranking movies at Netflix, aligning protein sequences, or analyzing high-energy physics at CERN.
As a <em>unified</em> platform, Spark is expected to support many cluster technologies and multiple data sources, which you learn about in Chapter 6 and Chapter 8, respectively. 
It is also expected to support many different libraries like Spark SQL, MLlib, GraphX, and Spark Streaming; libraries that you can use for analysis, modeling, graph processing, and real-time data processing, respectively. 
In summary, Spark is a platform providing access to clusters, data sources, and libraries for large-scale computing, as illustrated in Figure 1.4.

<img src="https://therinspark.com/the-r-in-spark_files/figure-html/intro-spark-unified-1.png" height="240pt" />

FIGURE 1.4: Spark as a unified analytics engine for large-scale data processing

Describing Spark as <em>large scale</em> implies that a good use case for Spark is tackling problems that can be solved with multiple machines. 
For instance, when data does not fit on a single disk drive or into memory, Spark is a good candidate to consider. 
However, you can also consider it for problems that might not be large scale, but for which using multiple computers could speed up computation. 
For instance, CPU-intensive models and scientific simulations also benefit from running in Spark.
Therefore, Spark is good at tackling large-scale data-processing problems, usually known as <em>big data</em> (datasets that are more voluminous and complex than traditional ones) but it is also good at tackling large-scale computation problems, known as <em>big compute</em> (tools and approaches using a large amount of CPU and memory resources in a coordinated way). 
Big data often requires big compute, but big compute does not necessarily require big data.
Big data and big compute problems are usually easy to spot—if the data does not fit into a single machine, you might have a big data problem; if the data fits into a single machine but processing it takes days, weeks, or even months to compute, you might have a big compute problem.
However, there is also a third problem space for which neither data nor compute is necessarily large scale and yet there are significant benefits to using cluster computing frameworks like Spark. 
For this third problem space, there are a few use cases:

<dt>Velocity</dt>
Suppose that you have a dataset of 10 GB and a process that takes 30 minutes to run over this data—this is neither big compute nor big data by any means. 
However, if you happen to be researching ways to improve the accuracy of your models, reducing the runtime down to three minutes is a significant improvement, which can lead to meaningful advances and productivity gains by increasing the velocity at which you can analyze data. 
Alternatively, you might need to process data faster—for stock trading, for instance. 
Whereas three minutes could seem fast enough, it can be far too slow for real-time data processing, for which you might need to process data in a few seconds—or even a few milliseconds.

<dt>Variety</dt>
You could also have an efficient process to collect data from many sources into a single location, usually a database; this process could be already running efficiently and close to real time. 
Such processes are known as <em>Extract, Transform, Load</em> (ETL); data is extracted from multiple sources, transformed to the required format, and loaded into a single data store. 
Although this has worked for years, the trade-off from this approach is that adding a new data source is expensive. 
Because the system is centralized and tightly controlled, making changes could cause the entire process to halt; therefore, adding new data source usually takes too long to be implemented. 
Instead, you can store all data in its natural format and process it as needed using cluster computing, an architecture known as a <em>data lake</em>. 
In addition, storing data in its raw format allows you to process a variety of new file formats like images, audio, and video without having to figure out how to fit them into conventional structured storage systems.

<dt>Veracity</dt>
When using many data sources, you might find the data quality varies greatly between them, which requires special analysis methods to improve their accuracy. 
For instance, suppose that you have a table of cities with values like San Francisco, Seattle, and Boston. 
What happens when data contains a misspelled entry like “Bston”? In a relational database, this invalid entry might be dropped. 
However, dropping values is not necessarily the best approach in all cases; you might want to correct this field by making use of geocodes, cross-referencing data sources, or attempting a best-effort match. 
Therefore, understanding and improving the veracity of the original data source can lead to more accurate results.

If we include “volume” as a synonym for big data, you get the mnemonic people refer to as the four Vs of big data; others have expanded this to five or even 10 Vs of big data. 
Mnemonics aside, cluster computing is being used today in more innovative ways, and is not uncommon to see organizations experimenting with new workflows and a variety of tasks that were traditionally uncommon for cluster computing. 
Much of the hype attributed to big data falls into this space where, strictly speaking, you’re not handling big data, but there are still benefits from using tools designed for big data and big compute.
Our hope is that this book will help you to understand the opportunities and limitations of cluster computing and, specifically, the opportunities and limitations of using Apache Spark with R.

<h2>1.4 R</h2>
The R computing language has its origins in the S language, which was created at Bell Laboratories. 
Rick Becker explained in useR 2016 that at that time in Bell Labs, computing was done by calling subroutines written in the Fortran language, which, apparently, were not pleasant to deal with. 
The S computing language was designed as an interface language to solve particular problems without having to worry about other languages, such as Fortran. 
The creator of S, John Chambers, shows in Figure 1.5 how S was designed to provide an interface that simplifies data processing; his co-creator presented this during <em>useR! 2016</em> as the original diagram that inspired the creation of S.

<img src="https://therinspark.com/images/intro-s-algorithm-interface-resized.png" />

FIGURE 1.5: Interface language diagram by John Chambers (Rick Becker useR 2016)

R is a modern and free implementation of S. 
Specifically, according to the R Project for Statistical Computing:
While working with data, we believe there are two strong arguments for using R:

<dt>R Language</dt>
R was designed by statisticians for statisticians, meaning that this is one of the few successful languages designed for nonprogrammers, so learning R will probably feel more natural. 
Additionally, because the R language was designed to be an interface to other tools and languages, R allows you to focus more on understanding data and less on the particulars of computer science and engineering.

<dt>R Community</dt>
The R community provides a rich package archive provided by the Comprehensive R Archive Network (CRAN), which allows you to install ready-to-use packages to perform many tasks—most notably high-quality data manipulation, visualization, and statistical models, many of which are available only in R. 
In addition, the R community is a welcoming and active group of talented individuals motivated to help you succeed. 
Many packages provided by the R community make R, by far, the best option for statistical computing. 
Some of the most downloaded R packages include: <code>dplyr</code> to manipulate data, <code>cluster</code> to analyze clusters, and <code>ggplot2</code> to visualize data. 
Figure 1.6 quantifies the growth of the R community by plotting daily downloads of R packages in CRAN.

<img src="https://therinspark.com/images/intro-daily-cran-downloads-resized.png" />

FIGURE 1.6: Daily downloads of CRAN packages

Aside from statistics, R is also used in many other fields. 
The following areas are particularly relevant to this book:

<dt>Data Science</dt>
Data science is based on knowledge and practices from statistics and computer science that turn raw data into understanding by using data analysis and modeling techniques. 
Statistical methods provide a solid foundation to understand the world and perform predictions, while the automation provided by computing methods allows us to simplify statistical analysis and make it much more accessible. 
Some have advocated that statistics should be renamed data science; however, data science goes beyond statistics by also incorporating advances in computing. 
This book presents analysis and modeling techniques common in statistics but applied to large datasets, which requires incorporating advances in distributed computing.

<dt>Machine Learning</dt>
Machine learning uses practices from statistics and computer science; however, it is heavily focused on automation and prediction. 
For instance, Arthur Samuel coined the term <em>machine learning</em> while automating a computer program to play checkers. 
Although we could perform data science on particular games, writing a program to play checkers requires us to automate the entire process. 
Therefore, this falls in the realm of machine learning, not data science. 
Machine learning makes it possible for many users to take advantage of statistical methods without being aware of using them. 
One of the first important applications of machine learning was to filter spam emails. 
In this case, it’s just not feasible to perform data analysis and modeling over each email account; therefore, machine learning automates the entire process of finding spam and filtering it out without having to involve users at all. 
This book presents the methods to transition data science workflows into fully automated machine learning methods—for instance, by providing support to build and export Spark pipelines that can be easily reused in automated environments.

<dt>Deep Learning</dt>
Deep learning builds on knowledge of statistics, data science, and machine learning to define models loosely inspired by biological nervous systems. 
Deep learning models evolved from neural network models after the vanishing-gradient problem was resolved by training one layer at a time, and have proven useful in image and speech recognition tasks. 
For instance, in voice assistants like Siri, Alexa, Cortana, or Google Assistant, the model performing the audio-to-text conversion is most likely based on deep learning models. 
Although Graphic Processing Units (GPUs) have been successfully used to train deep learning models, some datasets cannot be processed in a single GPU. 
It is also the case that deep learning models require huge amounts of data, which needs to be preprocessed across many machines before it can be fed into a single GPU for training. 
This book doesn’t make any direct references to deep learning models; however, you can use the methods we present in this book to prepare data for deep learning and, in the years to come, using deep learning with large-scale computing will become a common practice. 
In fact, recent versions of Spark have already introduced execution models optimized for training deep learning in Spark.

When working in any of the previous fields, you will be faced with increasingly large datasets or increasingly complex computations that are slow to execute or at times even impossible to process in a single computer. 
However, it is important to understand that Spark does not need to be the answer to all our computations problems; instead, when faced with computing challenges in R, using the following techniques can be as effective:

<dt>Sampling</dt>
A first approach to try is to reduce the amount of data being handled, through sampling. 
However, we must sample the data properly by applying sound statistical principles. 
For instance, selecting the top results is not sufficient in sorted datasets; with simple random sampling, there might be underrepresented groups, which we could overcome with stratified sampling, which in turn adds complexity to properly select categories. 
It’s beyond the scope of this book to teach how to properly perform statistical sampling, but many resources are available on this topic.

<dt>Profiling</dt>
You can try to understand why a computation is slow and make the necessary improvements. 
A profiler is a tool capable of inspecting code execution to help identify bottlenecks. 
In R, the R profiler, the <code>profvis</code> R package, and RStudio profiler feature allow you to easily to retrieve and visualize a profile; however, it’s not always trivial to optimize.

<dt>Scaling Up</dt>
Speeding up computation is usually possible by buying faster or more capable hardware (say, increasing your machine memory, upgrading your hard drive, or procuring a machine with many more CPUs); this approach is known as <em>scaling up</em>. 
However, there are usually hard limits as to how much a single computer can scale up, and even with significant CPUs, you need to find frameworks that parallelize computation efficiently.

<dt>Scaling Out</dt>
Finally, we can consider spreading computation and storage across multiple machines. 
This approach provides the highest degree of scalability because you can potentially use an arbitrary number of machines to perform a computation. 
This approach is commonly known as <em>scaling out</em>. 
However, spreading computation effectively across many machines is a complex endeavor, especially without using specialized tools and frameworks like Apache Spark.

This last point brings us closer to the purpose of this book, which is to bring the power of distributed computing systems provided by Apache Spark to solve meaningful computation problems in data science and related fields, using R.

<h2>1.5 sparklyr</h2>
When you think of the computation power that Spark provides and the ease of use of the R language, it is natural to want them to work together, seamlessly. 
This is also what the R community expected: an R package that would provide an interface to Spark that was easy to use, compatible with other R packages, and available in CRAN. 
With this goal, we started developing <code>sparklyr</code>. 
The first version, <code>sparklyr 0.4</code>, was released during the <em>useR! 2016</em> conference. 
This first version included support for <code>dplyr</code>, <code>DBI</code>, modeling with <code>MLlib</code>, and an extensible API that enabled extensions like H2O’s <code>rsparkling</code> package. 
Since then, many new features and improvements have been made available through <code>sparklyr</code> <code>0.5</code>, <code>0.6</code>, <code>0.7</code>, <code>0.8</code>, <code>0.9</code> and <code>1.0</code>.
Officially, <code>sparklyr</code> is an R interface for Apache Spark. 
It’s available in CRAN and works like any other CRAN package, meaning that it’s agnostic to Spark versions, it’s easy to install, it serves the R community, it embraces other packages and practices from the R community, and so on. 
It’s hosted in GitHub and licensed under Apache 2.0, which allows you to clone, modify, and contribute back to this project.
When thinking of who should use <code>sparklyr</code>, the following roles come to mind:

<dt>New Users</dt>
For new users, it is our belief that <code>sparklyr</code> provides the easiest way to get started with Spark. 
Our hope is that the early chapters of this book will get you up and running with ease and set you up for long-term success.

<dt>Data Scientists</dt>
For data scientists who already use and love R, <code>sparklyr</code> integrates with many other R practices and packages like <code>dplyr</code>, <code>magrittr</code>, <code>broom</code>, <code>DBI</code>, <code>tibble</code>, <code>rlang</code>, and many others, which will make you feel at home while working with Spark. 
For those new to R and Spark, the combination of high-level workflows available in <code>sparklyr</code> and low-level extensibility mechanisms make it a productive environment to match the needs and skills of every data scientist.

<dt>Expert Users</dt>
For those users who are already immersed in Spark and can write code natively in Scala, consider making your Spark libraries available as an R package to the R community, a diverse and skilled community that can put your contributions to good use while moving open science forward.

We wrote this book to describe and teach the exciting overlap between Apache Spark and R. 
<code>sparklyr</code> is the R package that brings together these communities, expectations, future directions, packages, and package extensions. 
We believe that there is an opportunity to use this book to bridge the R and Spark communities: to present to the R community why Spark is exciting, and to the Spark community what makes R great. 
Both communities are solving very similar problems with a set of different skills and backgrounds; therefore, it is our hope that <code>sparklyr</code> can be a fertile ground for innovation, a welcoming place for newcomers, a productive environment for experienced data scientists, and an open community where cluster computing, data science, and machine learning can come together.

<h2>1.6 Recap</h2>
This chapter presented Spark as a modern and powerful computing platform, R as an easy-to-use computing language with solid foundations in statistical methods, and <code>sparklyr</code> as a project bridging both technologies and communities. 
In a world in which the total amount of information is growing exponentially, learning how to analyze data at scale will help you to tackle the problems and opportunities humanity is facing today. 
However, before we start analyzing data, Chapter 2 will equip you with the tools you will need throughout the rest of this book. 
Be sure to follow each step carefully and take the time to install the recommended tools, which we hope will become familiar resources that you use and love.

<h2><span class="orange">Chapter 2 Getting Started</span></h2>
After reading Chapter 1, you should now be familiar with the kinds of problems that Spark can help you solve. 
And it should be clear that Spark solves problems by making use of multiple computers when data does not fit in a single machine or when computation is too slow. 
If you are newer to R, it should also be clear that combining Spark with data science tools like <code>ggplot2</code> for visualization and <code>dplyr</code> to perform data transformations brings a promising landscape for doing data science at scale. 
We also hope you are excited to become proficient in large-scale computing.
In this chapter, we take a tour of the tools you’ll need to become proficient in Spark. 
We encourage you to walk through the code in this chapter because it will force you to go through the motions of analyzing, modeling, reading, and writing data. 
In other words, you will need to do some wax-on, wax-off, repeat before you get fully immersed in the world of Spark.
In Chapter 3 we dive into analysis followed by modeling, which presents examples using a single-cluster machine: your personal computer. 
Subsequent chapters introduce cluster computing and the concepts and techniques that you’ll need to successfully run code across multiple machines.

<h2>2.1 Overview</h2>
From R, getting started with Spark using <code>sparklyr</code> and a local cluster is as easy as installing and loading the <code>sparklyr</code> package followed by installing Spark using <code>sparklyr</code> however, we assume you are starting with a brand new computer running Windows, macOS, or Linux, so we’ll walk you through the prerequisites before connecting to a local Spark cluster.
Although this chapter is designed to help you get ready to use Spark on your personal computer, it’s also likely that some readers will already have a Spark cluster available or might prefer to get started with an online Spark cluster. 
For instance, Databricks hosts a free community edition of Spark that you can easily access from your web browser. 
If you end up choosing this path, skip to Prerequisites, but make sure you consult the proper resources for your existing or online Spark cluster.
Either way, after you are done with the prerequisites, you will first learn how to connect to Spark. 
We then present the most important tools and operations that you’ll use throughout the rest of this book. 
Less emphasis is placed on teaching concepts or how to use them—we can’t possibly explain modeling or streaming in a single chapter. 
However, going through this chapter should give you a brief glimpse of what to expect and give you the confidence that you have the tools correctly configured to tackle more challenging problems later on.
The tools you’ll use are mostly divided into R code and the Spark web interface. 
All Spark operations are run from R; however, monitoring execution of distributed operations is performed from Spark’s web interface, which you can load from any web browser. 
We then disconnect from this local cluster, which is easy to forget to do but highly recommended while working with local clusters—and in shared Spark clusters as well!
We close this chapter by walking you through some of the features that make using Spark with RStudio easier; more specifically, we present the RStudio extensions that <code>sparklyr</code> implements. 
However, if you are inclined to use Jupyter Notebooks or if your cluster is already equipped with a different R user interface, rest assured that you can use Spark with R through plain R code. 
Let’s move along and get your prerequisites properly configured.

<h2>2.2 Prerequisites</h2>
R can run in many platforms and environments; therefore, whether you use Windows, Mac, or Linux, the first step is to install R from r-project.org; detailed instructions are provided in Installing R.
Most people use programming languages with tools to make them more productive; for R, RStudio is such a tool. 
Strictly speaking, RStudio is an <em>integrated development environment</em> (IDE), which also happens to support many platforms and environments. 
We strongly recommend you install RStudio if you haven’t done so already; see details in Using RStudio.
<strong>Tip:</strong> When using Windows, we recommend avoiding directories with spaces in their path. 
If running <code>getwd()</code> from R returns a path with spaces, consider switching to a path with no spaces using <code>setwd("path")</code> or by creating an RStudio project in a path with no spaces.
Additionally, because Spark is built in the Scala programming language, which is run by the Java Virtual Machine (JVM), you also need to install Java 8 on your system. 
It is likely that your system already has Java installed, but you should still check the version and update or downgrade as described in Installing Java. 
You can use the following R command to check which version is installed on your system:
<code>system("java -version")</code>
<code>java version "1.8.0_201"
Java(TM) SE Runtime Environment (build 1.8.0_201-b09)
Java HotSpot(TM) 64-Bit Server VM (build 25.201-b09, mixed mode)</code>
You can also use the <code>JAVA_HOME</code> environment variable to point to a specific Java version by running <code>Sys.setenv(JAVA_HOME = "path-to-java-8")</code>; either way, before moving on to installing <code>sparklyr</code>, make sure that Java 8 is the version available for R.

<h3>2.2.1 Installing sparklyr</h3>
As with many other R packages, you can install <code>sparklyr</code> from CRAN as follows:
<code>install.packages("sparklyr")</code>
The examples in this book assume you are using the latest version of <code>sparklyr</code>. 
You can verify your version is as new as the one we are using by running the following:
<code>packageVersion("sparklyr")</code>
<code>[1] ‘1.0.2’</code>

<h3>2.2.2 Installing Spark</h3>
Start by loading <code>sparklyr</code>:
<code>library(sparklyr)</code>
This makes all <code>sparklyr</code> functions available in R, which is really helpful; otherwise, you would need to run each <code>sparklyr</code> command prefixed with <code>sparklyr::</code>.
You can easily install Spark by running <code>spark_install()</code>. 
This downloads, installs, and configures the latest version of Spark locally on your computer; however, because we’ve written this book with Spark 2.3, you should also install this version to make sure that you can follow all the examples provided without any surprises:
<code>spark_install("2.3")</code>
You can display all of the versions of Spark that are available for installation by running the following:
<code>spark_available_versions()</code>
<code>##   spark
## 1   1.6
## 2   2.0
## 3   2.1
## 4   2.2
## 5   2.3
## 6   2.4</code>
You can install a specific version by using the Spark version and, optionally, by also specifying the Hadoop version. 
For instance, to install Spark 1.6.3, you would run:
<code>spark_install(version = "1.6")</code>
You can also check which versions are installed by running this command:
<code>spark_installed_versions()</code>
<code>  spark hadoop                              dir
7 2.3.1    2.7 /spark/spark-2.3.1-bin-hadoop2.7</code>
The path where Spark is installed is known as Spark’s <em>home</em>, which is defined in R code and system configuration settings with the <code>SPARK_HOME</code> identifier. 
When you are using a local Spark cluster installed with <code>sparklyr</code>, this path is already known and no additional configuration needs to take place.
Finally, to uninstall a specific version of Spark you can run <code>spark_uninstall()</code> by specifying the Spark and Hadoop versions, like so:
<code>spark_uninstall(version = "1.6.3", hadoop = "2.6")</code>
<strong>Note:</strong> The default installation paths are <code>~/spark</code> for macOS and Linux, and <code>%LOCALAPPDATA%/spark</code> for Windows. 
To customize the installation path, you can run <code>options(spark.install.dir = "installation-path")</code> before <code>spark_install()</code> and <code>spark_connect()</code>.

<h2>2.3 Connecting</h2>
It’s important to mention that, so far, we’ve installed only a local Spark cluster. 
A local cluster is really helpful to get started, test code, and troubleshoot with ease. 
Later chapters explain where to find, install, and connect to real Spark clusters with many machines, but for the first few chapters, we focus on using local clusters.
To connect to this local cluster, simply run the following:
<code>library(sparklyr)
sc &lt;- spark_connect(master = "local", version = "2.3")</code>
<strong>Note:</strong> If you are using your own or online Spark cluster, make sure that you connect as specified by your cluster administrator or the online documentation. 
If you need some pointers, you can take a quick look at Chapter 7, which explains in detail how to connect to any Spark cluster.
The <code>master</code> parameter identifies which is the “main” machine from the Spark cluster; this machine is often called the <em>driver node</em>. 
While working with real clusters using many machines, you’ll find that most machines will be worker machines and one will be the master. 
Since we have only a local cluster with just one machine, we will default to using <code>"local"</code> for now.
After a connection is established, <code>spark_connect()</code> retrieves an active Spark connection, which most code usually names <code>sc</code>; you will then make use of <code>sc</code> to execute Spark commands.
If the connection fails, Chapter 7 contains a troubleshooting section that can help you to resolve your connection issue.

<h2>2.4 Using Spark</h2>
Now that you are connected, we can run a few simple commands. 
For instance, let’s start by copying the <code>mtcars</code> dataset into Apache Spark by using <code>copy_to()</code>:
<code>cars &lt;- copy_to(sc, mtcars)</code>
The data was copied into Spark, but we can access it from R using the <code>cars</code> reference. 
To print its contents, we can simply type <code>*cars*</code>:
<code>cars</code>
<code># Source: spark&lt;mtcars> [?? x 11]
     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
   &lt;dbl> &lt;dbl> &lt;dbl> &lt;dbl> &lt;dbl> &lt;dbl> &lt;dbl> &lt;dbl> &lt;dbl> &lt;dbl> &lt;dbl>
 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4
 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4
 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1
 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1
 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2
 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1
 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4
 8  24.4     4  147. 
   62  3.69  3.19  20       1     0     4     2
 9  22.8     4  141. 
   95  3.92  3.15  22.9     1     0     4     2
10  19.2     6  168. 
  123  3.92  3.44  18.3     1     0     4     4
# … with more rows</code>
Congrats! You have successfully connected and loaded your first dataset into Spark.
Let’s explain what’s going on in <code>copy_to()</code>. 
The first parameter, <code>sc</code>, gives the function a reference to the active Spark connection that was created earlier with <code>spark_connect()</code>. 
The second parameter specifies a dataset to load into Spark. 
Now, <code>copy_to()</code> returns a reference to the dataset in Spark, which R automatically prints. 
Whenever a Spark dataset is printed, Spark <em>collects</em> some of the records and displays them for you. 
In this particular case, that dataset contains only a few rows describing automobile models and some of their specifications like horsepower and expected miles per gallon.

<h3>2.4.1 Web Interface</h3>
Most of the Spark commands are executed from the R console; however, monitoring and analyzing execution is done through Spark’s web interface, shown in Figure 2.1. 
This interface is a web application provided by Spark that you can access by running:
<code>spark_web(sc)</code>

<img src="https://therinspark.com/images/starting-spark-web-resized.png" />

FIGURE 2.1: The Apache Spark web interface

Printing the <code>cars</code> dataset collected a few records to be displayed in the R console. 
You can see in the Spark web interface that a job was started to collect this information back from Spark. 
You can also select the Storage tab to see the <code>mtcars</code> dataset cached in memory in Spark, as shown in Figure 2.2.

<img src="https://therinspark.com/images/starting-spark-web-storage.png" />

FIGURE 2.2: The Storage tab on the Apache Spark web interface

Notice that this dataset is fully loaded into memory, as indicated by the Fraction Cached column, which shows 100%; thus, you can see exactly how much memory this dataset is using through the Size in Memory column.
The Executors tab, shown in Figure 2.3, provides a view of your cluster resources. 
For local connections, you will find only one executor active with only 2 GB of memory allocated to Spark, and 384 MB available for computation. 
In Chapter 9 you will learn how to request more compute instances and resources, and how memory is allocated.

<img src="https://therinspark.com/images/starting-spark-web-executors-resized.png" />

FIGURE 2.3: The Executors tab on the Apache Spark web interface

The last tab to explore is the Environment tab, shown in Figure 2.4; this tab lists all of the settings for this Spark application, which we look at in Chapter 9. 
As you will learn, most settings don’t need to be configured explicitly, but to properly run them at scale, you need to become familiar with some of them, eventually.

<img src="https://therinspark.com/images/starting-spark-web-environment-resized.png" />

FIGURE 2.4: The Environment tab on the Apache Spark web interface

Next, you will make use of a small subset of the practices that we cover in depth in Chapter 3.

<h3>2.4.2 Analysis</h3>
When using Spark from R to analyze data, you can use SQL (Structured Query Language) or <code>dplyr</code> (a grammar of data manipulation). 
You can use SQL through the <code>DBI</code> package; for instance, to count how many records are available in our <code>cars</code> dataset, we can run the following:
<code>library(DBI)
dbGetQuery(sc, "SELECT count(*) FROM mtcars")</code>
<code>  count(1)
1       32</code>
When using <code>dplyr</code>, you write less code, and it’s often much easier to write than SQL. 
This is precisely why we won’t make use of SQL in this book; however, if you are proficient in SQL, this is a viable option for you. 
For instance, counting records in <code>dplyr</code> is more compact and easier to understand:
<code>library(dplyr)
count(cars)</code>
<code># Source: spark&lt;?> [?? x 1]
      n
  &lt;dbl>
1    32</code>
In general, we usually start by analyzing data in Spark with <code>dplyr</code>, followed by sampling rows and selecting a subset of the available columns. 
The last step is to collect data from Spark to perform further data processing in R, like data visualization. 
Let’s perform a very simple data analysis example by selecting, sampling, and plotting the <code>cars</code> dataset in Spark:
<code>select(cars, hp, mpg) %>%
  sample_n(100) %>%
  collect() %>%
  plot()</code>

<img src="https://therinspark.com/images/starting-cars-hp-vs-mpg-resized.png" />

FIGURE 2.5: Horsepower versus miles per gallon

The plot in Figure 2.5, shows that as we increase the horsepower in a vehicle, its fuel efficiency measured in miles per gallon decreases. 
Although this is insightful, it’s difficult to predict numerically how increased horsepower would affect fuel efficiency. 
Modeling can help us overcome this.

<h3>2.4.3 Modeling</h3>
Although data analysis can take you quite far toward understanding data, building a mathematical model that describes and generalizes the dataset is quite powerful. 
In Chapter 1 you learned that the fields of machine learning and data science make use of mathematical models to perform predictions and find additional insights.
For instance, we can use a linear model to approximate the relationship between fuel efficiency and horsepower:
<code>model &lt;- ml_linear_regression(cars, mpg ~ hp)
model</code>
<code>Formula: mpg ~ hp

Coefficients:
(Intercept)          hp 
30.09886054 -0.06822828</code>
Now we can use this model to predict values that are not in the original dataset. 
For instance, we can add entries for cars with horsepower beyond 250 and also visualize the predicted values, as shown in Figure 2.6.
<code>model %>%
  ml_predict(copy_to(sc, data.frame(hp = 250 + 10 * 1:10))) %>%
  transmute(hp = hp, mpg = prediction) %>%
  full_join(select(cars, hp, mpg)) %>%
  collect() %>%
  plot()</code>

<img src="https://therinspark.com/images/starting-cars-hp-vs-mpg-prediction-resized.png" />

FIGURE 2.6: Horsepower versus miles per gallon with predictions

Even though the previous example lacks many of the appropriate techniques that you should use while modeling, it’s also a simple example to briefly introduce the modeling capabilities of Spark. 
We introduce all of the Spark models, techniques, and best practices in Chapter 4.

<h3>2.4.4 Data</h3>
For simplicity, we copied the <code>mtcars</code> dataset into Spark; however, data is usually not copied into Spark. 
Instead, data is read from existing data sources in a variety of formats, like plain text, CSV, JSON, Java Database Connectivity (JDBC), and many more, which we examine in detail in Chapter 8. 
For instance, we can export our <code>cars</code> dataset as a CSV file:
<code>spark_write_csv(cars, "cars.csv")</code>
In practice, we would read an existing dataset from a distributed storage system like HDFS, but we can also read back from the local file system:
<code>cars &lt;- spark_read_csv(sc, "cars.csv")</code>

<h3>2.4.5 Extensions</h3>
In the same way that R is known for its vibrant community of package authors, at a smaller scale, many extensions for Spark and R have been written and are available to you. 
Chapter 10 introduces many interesting ones to perform advanced modeling, graph analysis, preprocessing of datasets for deep learning, and more.
For instance, the <code>sparkly.nested</code> extension is an R package that extends <code>sparklyr</code> to help you manage values that contain nested information. 
A common use case involves JSON files that contain nested lists that require preprocessing before you can do meaningful data analysis. 
To use this extension, we first need to install it as follows:
<code>install.packages("sparklyr.nested")</code>
Then, we can use the <code>sparklyr.nested</code> extension to group all of the horsepower data points over the number of cylinders:
<code>sparklyr.nested::sdf_nest(cars, hp) %>%
  group_by(cyl) %>%
  summarise(data = collect_list(data))</code>
<code># Source: spark&lt;?> [?? x 2]
    cyl data       
  &lt;int> &lt;list>     
1     6 &lt;list [7]> 
2     4 &lt;list [11]>
3     8 &lt;list [14]></code>
Even though nesting data makes it more difficult to read, it is a requirement when you are dealing with nested data formats like JSON using the <code>spark_read_json()</code> and <code>spark_write_json()</code> functions.

<h3>2.4.6 Distributed R</h3>
For those few cases when a particular functionality is not available in Spark and no extension has been developed, you can consider distributing your own R code across the Spark cluster. 
This is a powerful tool, but it comes with additional complexity, so you should only use it as a last resort.
Suppose that we need to round all of the values across all the columns in our dataset. 
One approach would be running custom R code, making use of R’s <code>round()</code> function:
<code>cars %>% spark_apply(~round(.x))</code>
<code># Source: spark&lt;?> [?? x 11]
     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
   &lt;dbl> &lt;dbl> &lt;dbl> &lt;dbl> &lt;dbl> &lt;dbl> &lt;dbl> &lt;dbl> &lt;dbl> &lt;dbl> &lt;dbl>
 1    21     6   160   110     4     3    16     0     1     4     4
 2    21     6   160   110     4     3    17     0     1     4     4
 3    23     4   108    93     4     2    19     1     1     4     1
 4    21     6   258   110     3     3    19     1     0     3     1
 5    19     8   360   175     3     3    17     0     0     3     2
 6    18     6   225   105     3     3    20     1     0     3     1
 7    14     8   360   245     3     4    16     0     0     3     4
 8    24     4   147    62     4     3    20     1     0     4     2
 9    23     4   141    95     4     3    23     1     0     4     2
10    19     6   168   123     4     3    18     1     0     4     4
# … with more rows</code>
If you are a proficient R user, it can be quite tempting to use <code>spark_apply()</code> for everything, but please, don’t! <code>spark_apply()</code> was designed for advanced use cases where Spark falls short. 
You will learn how to do proper data analysis and modeling without having to distribute custom R code across your cluster.

<h3>2.4.7 Streaming</h3>
While processing large static datasets is the most typical use case for Spark, processing dynamic datasets in real time is also possible and, for some applications, a requirement. 
You can think of a streaming dataset as a static data source with new data arriving continuously, like stock market quotes. 
Streaming data is usually read from Kafka (an open source stream-processing software platform) or from distributed storage that receives new data continuously.
To try out streaming, let’s first create an <em>input/</em> folder with some data that we will use as the input for this stream:
<code>dir.create("input")
write.csv(mtcars, "input/cars_1.csv", row.names = F)</code>
Then, we define a stream that processes incoming data from the <em>input/</em> folder, performs a custom transformation in R, and pushes the output into an <em>output/</em> folder:
<code>stream &lt;- stream_read_csv(sc, "input/") %>%
    select(mpg, cyl, disp) %>%
    stream_write_csv("output/")</code>
As soon as the stream of real-time data starts, the <em>input/</em> folder is processed and turned into a set of new files under the <em>output/</em> folder containing the new transformed files. 
Since the input contained only one file, the output folder will also contain a single file resulting from applying the custom <code>spark_apply()</code> transformation.
<code>dir("output", pattern = ".csv")</code>
<code>[1] "part-00000-eece04d8-7cfa-4231-b61e-f1aef8edeb97-c000.csv"</code>
Up to this point, this resembles static data processing; however, we can keep adding files to the <em>input/</em> location, and Spark will parallelize and process data automatically. 
Let’s add one more file and validate that it’s automatically processed:
<code># Write more data into the stream source
write.csv(mtcars, "input/cars_2.csv", row.names = F)</code>
Wait a few seconds and validate that the data is processed by the Spark stream:
<code># Check the contents of the stream destination
dir("output", pattern = ".csv")</code>
<code>[1] "part-00000-2d8e5c07-a2eb-449d-a535-8a19c671477d-c000.csv"
[2] "part-00000-eece04d8-7cfa-4231-b61e-f1aef8edeb97-c000.csv"</code>
You should then stop the stream:
<code>stream_stop(stream)</code>
You can use <code>dplyr</code>, SQL, Spark models, or distributed R to analyze streams in real time. 
In Chapter 12 we properly introduce you to all the interesting transformations you can perform to analyze real-time data.

<h3>2.4.8 Logs</h3>
Logging is definitely less interesting than real-time data processing; however, it’s a tool you should be or become familiar with. 
A <em>log</em> is just a text file to which Spark appends information relevant to the execution of tasks in the cluster. 
For local clusters, we can retrieve all the recent logs by running the following:
<code>spark_log(sc)</code>
<code>18/10/09 19:41:46 INFO Executor: Finished task 0.0 in stage 5.0 (TID 5)...
18/10/09 19:41:46 INFO TaskSetManager: Finished task 0.0 in stage 5.0...
18/10/09 19:41:46 INFO TaskSchedulerImpl: Removed TaskSet 5.0, whose...
18/10/09 19:41:46 INFO DAGScheduler: ResultStage 5 (collect at utils...
18/10/09 19:41:46 INFO DAGScheduler: Job 3 finished: collect at utils...</code>
Or, we can retrieve specific log entries containing, say, <code>sparklyr</code>, by using the <code>filter</code> parameter, as follows:
<code>spark_log(sc, filter = "sparklyr")</code>
<code>## 18/10/09 18:53:23 INFO SparkContext: Submitted application: sparklyr
## 18/10/09 18:53:23 INFO SparkContext: Added JAR...
## 18/10/09 18:53:27 INFO Executor: Fetching spark://localhost:52930/...
## 18/10/09 18:53:27 INFO Utils: Fetching spark://localhost:52930/...
## 18/10/09 18:53:27 INFO Executor: Adding file:/private/var/folders/...</code>
Most of the time, you won’t need to worry about Spark logs, except in cases for which you need to troubleshoot a failed computation; in those cases, logs are an invaluable resource to be aware of. 
Now you know.

<h2>2.5 Disconnecting</h2>
For local clusters (really, any cluster), after you are done processing data, you should disconnect by running the following:
<code>spark_disconnect(sc)</code>
This terminates the connection to the cluster as well as the cluster tasks. 
If multiple Spark connections are active, or if the connection instance <code>sc</code> is no longer available, you can also disconnect all your Spark connections by running this command:
<code>spark_disconnect_all()</code>
Notice that exiting R, or RStudio, or restarting your R session, also causes the Spark connection to terminate, which in turn terminates the Spark cluster and cached data that is not explicitly saved.

<h2>2.6 Using RStudio</h2>
Since it’s very common to use RStudio with R, <code>sparklyr</code> provides RStudio extensions to help simplify your workflows and increase your productivity while using Spark in RStudio. 
If you are not familiar with RStudio, take a quick look at Using RStudio. 
Otherwise, there are a couple extensions worth highlighting.
First, instead of starting a new connection using <code>spark_connect()</code> from RStudio’s R console, you can use the New Connection action from the Connections tab and then select the Spark connection, which opens the dialog shown in Figure 2.7. 
You can then customize the versions and connect to Spark, which will simply generate the right <code>spark_connect()</code> command and execute this in the R console for you.

<img src="https://therinspark.com/images/starting-rstudio-new-spark-connection-resized.png" />

FIGURE 2.7: RStudio New Spark Connection dialog

After you’re connected to Spark, RStudio displays your available datasets in the Connections tab, as shown in Figure 2.8. 
This is a useful way to track your existing datasets and provides an easy way to explore each of them.

<img src="https://therinspark.com/images/starting-rstudio-connections-pane.png" />

FIGURE 2.8: The RStudio Connections tab

Additionally, an active connection provides the following custom actions:

<dt>Spark</dt>
Opens the Spark web interface; a shortcut to <code>spark_web(sc)</code>.

<dt>Log</dt>
Opens the Spark web logs; a shortcut to <code>spark_log(sc)</code>.

<dt>SQL</dt>
Opens a new SQL query. 
For more information about <code>DBI</code> and SQL support, see Chapter 3.

<dt>Help</dt>
Opens the reference documentation in a new web browser window.

<dt>Disconnect</dt>
Disconnects from Spark; a shortcut to <code>spark_disconnect(sc)</code>.

The rest of this book will use plain R code. 
It is up to you whether to execute this code in the R console, RStudio, Jupyter Notebooks, or any other tool that supports executing R code, since the examples provided in this book execute in any R environment.

<h2>2.7 Resources</h2>
While we’ve put significant effort into simplifying the onboarding process, there are many additional resources that can help you to troubleshoot particular issues while getting started and, in general, introduce you to the broader Spark and R communities to help you get specific answers, discuss topics, and connect with many users actively using Spark with R:

<dt>Documentation</dt>
The documentation site hosted in RStudio’s Spark website should be your first stop to learn more about Spark when using R. 
The documentation is kept up to date with examples, reference functions, and many more relevant resources.

<dt>Blog</dt>
To keep up to date with major <code>sparklyr</code> announcements, you can follow the RStudio blog.

<dt>Community</dt>
For general <code>sparklyr</code> questions, you can post in the RStudio Community tagged as <code>sparklyr</code>.

<dt>Stack Overflow</dt>
For general Spark questions, Stack Overflow is a great resource; there are also many topics specifically about <code>sparklyr</code>.

<dt>Github</dt>
If you believe something needs to be fixed, open a GitHub issue or send us a pull request.

<dt>Gitter</dt>
For urgent issues or to keep in touch, you can chat with us in Gitter.

<h2>2.8 Recap</h2>
In this chapter you learned about the prerequisites required to work with Spark. 
You saw how to connect to Spark using <code>spark_connect()</code>; install a local cluster using <code>spark_install()</code>; load a simple dataset, launch the web interface, and display logs using <code>spark_web(sc)</code> and <code>spark_log(sc)</code>, respectively; and disconnect from RStudio using <code>spark_disconnect()</code>. 
We close by presenting the RStudio extensions that <code>sparklyr</code> provides.
At this point, we hope that you feel ready to tackle actual data analysis and modeling problems in Spark and R, which will be introduced over the next two chapters. 
Chapter 3 will present data analysis as the process of inspecting, cleaning, and transforming data with the goal of discovering useful information. 
Modeling, the subject of Chapter 4, can be considered part of data analysis; however, it deserves its own chapter to truly describe and take advantage of the modeling functionality available in Spark.

<h2><span class="orange">Chapter 3 Analysis</span></h2>
Previous chapters focused on introducing Spark with R, getting you up to speed and encouraging you to try basic data analysis workflows. 
However, they have not properly introduced what data analysis means, especially with Spark. 
They presented the tools you will need throughout this book—tools that will help you spend more time learning and less time troubleshooting.
This chapter introduces tools and concepts to perform data analysis in Spark from R. 
Spoiler alert: these are the same tools you use with plain R! This is not a mere coincidence; rather, we want data scientists to live in a world where technology is hidden from them, where you can use the R packages you know and love, and they “just work” in Spark! Now, we are not quite there yet, but we are also not that far. 
Therefore, in this chapter you learn widely used R packages and practices to perform data analysis—<code>dplyr</code>, <code>ggplot2</code>, formulas, <code>rmarkdown</code>, and so on—which also happen to work in Spark.
Chapter 4 will focus on creating statistical models to predict, estimate, and describe datasets, but first, let’s get started with analysis!

<h2>3.1 Overview</h2>
In a data analysis project, the main goal is to understand what the data is trying to “tell us”, hoping that it provides an answer to a specific question. 
Most data analysis projects follow a set of steps, as shown in Figure 3.1.
As the diagram illustrates, we first <em>import</em> data into our analysis stem, where we <em>wrangle</em> it by trying different data transformations, such as aggregations. 
We then <em>visualize</em> the data to help us perceive relationships and trends. 
To gain deeper insight, we can fit one or multiple statistical <em>models</em> against sample data. 
This will help us find out whether the patterns hold true when new data is applied to them. 
Lastly, the results are communicated publicly or privately to colleagues and stakeholders.

<img src="https://therinspark.com/the-r-in-spark_files/figure-html/analysis-steps-1.png" height="220pt" />

FIGURE 3.1: The general steps of a data analysis

When working with not-large-scale datasets—as in datasets that fit in memory—we can perform all those steps from R, without using Spark. 
However, when data does not fit in memory or computation is simply too slow, we can slightly modify this approach by incorporating Spark. 
But how?
For data analysis, the ideal approach is to let Spark do what it’s good at. 
Spark is a(((“parallel execution”))) parallel computation engine that works at a large scale and provides a SQL engine and modeling libraries. 
You can use these to perform most of the same operations R performs. 
Such operations include data selection, transformation, and modeling. 
Additionally, Spark includes tools for performing specialized computational work like graph analysis, stream processing, and many others. 
For now, we will skip those non-rectangular datasets and present them in later chapters.
You can perform data <em>import</em>, <em>wrangling</em>, and <em>modeling</em> within Spark. 
You can also partly do <em>visualization</em> with Spark, which we cover later in this chapter. 
The idea is to use R to tell Spark what data operations to run, and then only bring the results into R. 
As illustrated in Figure 3.2, the ideal method <em>pushes compute</em> to the Spark cluster and then <em>collects results</em> into R.

<img src="https://therinspark.com/the-r-in-spark_files/figure-html/analysis-approach-1.png" height="220pt" />

FIGURE 3.2: Spark computes while R collects results

The <code>sparklyr</code> package aids in using the “push compute, collect results” principle. 
Most of its functions are wrappers on top of Spark API calls. 
This allows us to take advantage of Spark’s analysis components, instead of R’s. 
For example, when you need to fit a linear regression model, instead of using R’s familiar <code>lm()</code> function, you would use Spark’s <code>ml_linear_regression()</code> function. 
This R function then calls Spark to create this model. 
Figure 3.3 depicts this specific example.

<img src="https://therinspark.com/the-r-in-spark_files/figure-html/analysis-scala-1.png" height="140pt" />

FIGURE 3.3: R functions call Spark functionality

For more common data manipulation tasks, <code>sparklyr</code> provides a backend for <code>dplyr</code>. 
This means you can use <code>dplyr</code> verbs with which you’re already familiar in R, and then <code>sparklyr</code> and <code>dplyr</code> will translate those actions into Spark SQL statements, which are generally more compact and easier to read than SQL statements (see Figure 3.4). 
So, if you are already familiar with R and <code>dplyr</code>, there is nothing new to learn. 
This might feel a bit anticlimactic—indeed, it is—but it’s also great since you can focus that energy on learning other skills required to do large-scale computing.

<img src="https://therinspark.com/the-r-in-spark_files/figure-html/analysis-sql-1.png" height="140pt" />

FIGURE 3.4: dplyr writes SQL in Spark

To practice as you learn, the rest of this chapter’s code uses a single exercise that runs in the <em>local</em> Spark master. 
This way, you can replicate the code on your personal computer. 
Make sure <code>sparklyr</code> is already working, which should be the case if you completed Chapter 2.
This chapter will make use of packages that you might not have installed. 
So, first, make sure the following packages are installed by running these commands:
<code>install.packages("ggplot2")
install.packages("corrr")
install.packages("dbplot")
install.packages("rmarkdown")</code>
First, load the <code>sparklyr</code> and <code>dplyr</code> packages and then open a new <em>local</em> connection.
<code>library(sparklyr)
library(dplyr)

sc &lt;- spark_connect(master = "local", version = "2.3")</code>
The environment is ready to be used, so our next task is to import data that we can later analyze.

<h2>3.2 Import</h2>
When using Spark with R, you need to approach importing data differently. 
Usually, importing means that R will read files and load them into memory; when you are using Spark, the data is imported into Spark, not R. 
In Figure 3.5, notice how the data source is connected to Spark instead of being connected to R.

<img src="https://therinspark.com/the-r-in-spark_files/figure-html/analysis-access-1.png" height="160pt" />

FIGURE 3.5: Import data to Spark not R

<strong>Note:</strong> When you’re performing analysis over large-scale datasets, the vast majority of the necessary data will already be available in your Spark cluster (which is usually made available to users via Hive tables or by accessing the file system directly). 
Chapter 8 will cover this extensively.
Rather than importing all data into Spark, you can request Spark to access the data source without importing it—this is a decision you should make based on speed and performance. 
Importing all of the data into the Spark session incurs a one-time up-front cost, since Spark needs to wait for the data to be loaded before analyzing it. 
If the data is not imported, you usually incur a cost with every Spark operation since Spark needs to retrieve a subset from the cluster’s storage, which is usually disk drives that happen to be much slower than reading from Spark’s memory. 
More on this topic will be covered in Chapter 9.
Let’s prime the session with some data by importing <code>mtcars</code> into Spark using <code>copy_to()</code>; you can also import data from distributed files in many different file formats, which we look at in Chapter 8.
<code>cars &lt;- copy_to(sc, mtcars)</code>
<strong>Note:</strong> When using real clusters, you should use <code>copy_to()</code> to transfer only small tables from R; large data transfers should be performed with specialized data transfer tools.
The data is now accessible to Spark and you can now apply transformations with ease; the next section covers how to wrangle data by running transformations inside Spark, using <code>dplyr</code>.

<h2>3.3 Wrangle</h2>
Data wrangling uses transformations to understand the data. 
It is often referred to as the process of transforming data from one “raw” data form into another format with the intent of making it more appropriate for data analysis.
Malformed or missing values and columns with multiple attributes are common data problems you might need to fix, since they prevent you from understanding your dataset. 
For example, a “name” field contains the last and first name of a customer. 
There are two attributes (first and last name) in a single column. 
To be usable, we need to <em>transform</em> the “name” field, by <em>changing</em> it into “first_name” and “last_name” fields.
After the data is cleaned, you still need to understand the basics about its content. 
Other transformations such as aggregations can help with this task. 
For example, the result of requesting the average balance of all customers will return a single row and column. 
The value will be the average of all customers. 
That information will give us context when we see individual, or grouped, customer balances.
The main goal is to write the data transformations using R syntax as much as possible. 
This saves us from the cognitive cost of having to switch between multiple computer technologies to accomplish a single task. 
In this case, it is better to take advantage of <code>dplyr</code> instead of writing Spark SQL statements for data exploration.
In the R environment, <code>cars</code> can be treated as if it were a local DataFrame, so you can use <code>dplyr</code> verbs. 
For instance, we can find out the mean of all columns by using <code>summarise_all()</code>:
<code>summarize_all(cars, mean)</code>
<code># Source: spark&lt;?> [?? x 11]
    mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
  &lt;dbl> &lt;dbl> &lt;dbl> &lt;dbl> &lt;dbl> &lt;dbl> &lt;dbl> &lt;dbl> &lt;dbl> &lt;dbl> &lt;dbl>
1  20.1  6.19  231. 
 147. 
 3.60  3.22  17.8 0.438 0.406  3.69  2.81</code>
While this code is exactly the same as the code you would run when using <code>dplyr</code> without Spark, a lot is happening under the hood. 
The data is <em>not</em> being imported into R; instead, <code>dplyr</code> converts this task into SQL statements that are then sent to Spark. 
The <code>show_query()</code> command makes it possible to peer into the SQL statement that <code>sparklyr</code> and <code>dplyr</code> created and sent to Spark. 
We can also use this time to introduce the pipe operator (<code>%>%</code>), a custom operator from the <code>magrittr</code> package that pipes a computation into the first argument of the next function, making your data analysis much easier to read:
<code>summarize_all(cars, mean) %>%
  show_query()</code>
<code>&lt;SQL>
SELECT AVG(`mpg`) AS `mpg`, AVG(`cyl`) AS `cyl`, AVG(`disp`) AS `disp`,
       AVG(`hp`) AS `hp`, AVG(`drat`) AS `drat`, AVG(`wt`) AS `wt`,
       AVG(`qsec`) AS `qsec`, AVG(`vs`) AS `vs`, AVG(`am`) AS `am`,
       AVG(`gear`) AS `gear`, AVG(`carb`) AS `carb`
FROM `mtcars`</code>
As is evident, <code>dplyr</code> is much more concise than SQL, but rest assured, you will not need to see or understand SQL when using <code>dplyr</code>. 
Your focus can remain on obtaining insights from the data, as opposed to figuring out how to express a given set of transformations in SQL. 
Here is another example that groups the <code>cars</code> dataset by <code>transmission</code> type:
<code>cars %>%
  mutate(transmission = ifelse(am == 0, "automatic", "manual")) %>%
  group_by(transmission) %>%
  summarise_all(mean)</code>
<code># Source: spark&lt;?> [?? x 12]
  transmission   mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
  &lt;chr>        &lt;dbl> &lt;dbl> &lt;dbl> &lt;dbl> &lt;dbl> &lt;dbl> &lt;dbl> &lt;dbl> &lt;dbl> &lt;dbl> &lt;dbl>
1 automatic     17.1  6.95  290. 
 160. 
 3.29  3.77  18.2 0.368     0  3.21  2.74
2 manmual       24.4  5.08  144. 
 127. 
 4.05  2.41  17.4 0.538     1  4.38  2.92</code>
Most of the data transformation operations made available by <code>dplyr</code> to work with local DataFrames are also available to use with a Spark connection. 
This means that you can focus on learning <code>dplyr</code> first and then reuse that skill when working with Spark. 
Chapter 5 from the book <em>R for Data Science</em> by Hadley Wickham and Garrett Grolemund (O’Reilly) is a great resource to learn <code>dplyr</code> in depth. 
If proficiency with <code>dplyr</code> is not an issue for you, we recommend that you take some time to experiment with different <code>dplyr</code> functions against the <code>cars</code> table.
Sometimes, we might need to perform an operation not yet available through <code>dplyr</code> and <code>sparklyr</code>. 
Instead of downloading the data into R, there is usually a Hive function within Spark to accomplish what we need. 
The next section covers this scenario.

<h3>3.3.1 Built-in Functions</h3>
Spark SQL is based on Hive’s SQL conventions and functions, and it is possible to call all these functions using <code>dplyr</code> as well. 
This means that we can use any Spark SQL functions to accomplish operations that might not be available via <code>dplyr</code>. 
We can access the functions by calling them as if they were R functions. 
Instead of failing, <code>dplyr</code> passes functions it does not recognize as is to the query engine. 
This gives us a lot of flexibility on the functions we can use.
For instance, the <code>percentile()</code> function returns the exact percentile of a column in a group. 
The function expects a column name, and either a single percentile value or an array of percentile values. 
We can use this Spark SQL function from <code>dplyr</code>, as follows:
<code>summarise(cars, mpg_percentile = percentile(mpg, 0.25))</code>
<code># Source: spark&lt;?> [?? x 1]
  mpg_percentile
           &lt;dbl>
1           15.4</code>
There is no <code>percentile()</code> function in R, so <code>dplyr</code> passes that portion of the code as-is to the resulting SQL query:
<code>summarise(cars, mpg_percentile = percentile(mpg, 0.25)) %>%
  show_query()</code>
<code>&lt;SQL>
SELECT percentile(`mpg`, 0.25) AS `mpg_percentile`
FROM `mtcars_remote`</code>
To pass multiple values to <code>percentile()</code>, we can call another Hive function called <code>array()</code>. 
In this case, <code>array()</code> would work similarly to R’s <code>list()</code> function. 
We can pass multiple values separated by commas. 
The output from Spark is an array variable, which is imported into R as a list variable column:
<code>summarise(cars, mpg_percentile = percentile(mpg, array(0.25, 0.5, 0.75)))</code>
<code># Source: spark&lt;?> [?? x 1]
  mpg_percentile
  &lt;list>        
1 &lt;list [3]>   </code>
You can use the <code>explode()</code> function to separate Spark’s array value results into their own record. 
To do this, use <code>explode()</code> within a <code>mutate()</code> command, and pass the variable containing the results of the percentile operation:
<code>summarise(cars, mpg_percentile = percentile(mpg, array(0.25, 0.5, 0.75))) %>%
  mutate(mpg_percentile = explode(mpg_percentile))</code>
<code># Source: spark&lt;?> [?? x 1]
  mpg_percentile
           &lt;dbl>
1           15.4
2           19.2
3           22.8</code>
We have included a comprehensive list of all the Hive functions in the section Hive Functions. 
Glance over them to get a sense of the wide range of operations that you can accomplish with them.

<h3>3.3.2 Correlations</h3>
A very common exploration technique is to calculate and visualize correlations, which we often calculate to find out what kind of statistical relationship exists between paired sets of variables. 
Spark provides functions to calculate correlations across the entire dataset and returns the results to R as a DataFrame object:
<code>ml_corr(cars)</code>
<code># A tibble: 11 x 11
      mpg    cyl   disp     hp    drat     wt    qsec
    &lt;dbl>  &lt;dbl>  &lt;dbl>  &lt;dbl>   &lt;dbl>  &lt;dbl>   &lt;dbl>
 1  1     -0.852 -0.848 -0.776  0.681  -0.868  0.419 
 2 -0.852  1      0.902  0.832 -0.700   0.782 -0.591 
 3 -0.848  0.902  1      0.791 -0.710   0.888 -0.434 
 4 -0.776  0.832  0.791  1     -0.449   0.659 -0.708 
 5  0.681 -0.700 -0.710 -0.449  1      -0.712  0.0912
 6 -0.868  0.782  0.888  0.659 -0.712   1     -0.175 
 7  0.419 -0.591 -0.434 -0.708  0.0912 -0.175  1     
 8  0.664 -0.811 -0.710 -0.723  0.440  -0.555  0.745 
 9  0.600 -0.523 -0.591 -0.243  0.713  -0.692 -0.230 
10  0.480 -0.493 -0.556 -0.126  0.700  -0.583 -0.213 
11 -0.551  0.527  0.395  0.750 -0.0908  0.428 -0.656 
# ... 
with 4 more variables: vs &lt;dbl>, am &lt;dbl>,
#   gear &lt;dbl>, carb &lt;dbl></code>
The <code>corrr</code> R package specializes in correlations. 
It contains friendly functions to prepare and visualize the results. 
Included inside the package is a backend for Spark, so when a Spark object is used in <code>corrr</code>, the actual computation also happens in Spark. 
In the background, the <code>correlate()</code> function runs <code>sparklyr::ml_corr()</code>, so there is no need to collect any data into R prior to running the command:
<code>library(corrr)
correlate(cars, use = "pairwise.complete.obs", method = "pearson") </code>
<code># A tibble: 11 x 12
   rowname     mpg     cyl    disp      hp     drat      wt
   &lt;chr>     &lt;dbl>   &lt;dbl>   &lt;dbl>   &lt;dbl>    &lt;dbl>   &lt;dbl>
 1 mpg      NA      -0.852  -0.848  -0.776   0.681   -0.868
 2 cyl      -0.852  NA       0.902   0.832  -0.700    0.782
 3 disp     -0.848   0.902  NA       0.791  -0.710    0.888
 4 hp       -0.776   0.832   0.791  NA      -0.449    0.659
 5 drat      0.681  -0.700  -0.710  -0.449  NA       -0.712
 6 wt       -0.868   0.782   0.888   0.659  -0.712   NA    
 7 qsec      0.419  -0.591  -0.434  -0.708   0.0912  -0.175
 8 vs        0.664  -0.811  -0.710  -0.723   0.440   -0.555
 9 am        0.600  -0.523  -0.591  -0.243   0.713   -0.692
10 gear      0.480  -0.493  -0.556  -0.126   0.700   -0.583
11 carb     -0.551   0.527   0.395   0.750  -0.0908   0.428
# ... 
with 5 more variables: qsec &lt;dbl>, vs &lt;dbl>,
#   am &lt;dbl>, gear &lt;dbl>, carb &lt;dbl></code>
We can pipe the results to other <code>corrr</code> functions. 
For example, the <code>shave()</code> function turns all of the duplicated results into <code>NAs</code>. 
Again, while this feels like standard R code using existing R packages, Spark is being used under the hood to perform the correlation.
Additionally, as shown in Figure 3.6, the results can be easily visualized using the <code>rplot()</code> function, as shown here:
<code>correlate(cars, use = "pairwise.complete.obs", method = "pearson") %>%
  shave() %>%
  rplot()</code>

<img src="https://therinspark.com/images/analysis-corrr-rplot-resized.png" height="400pt" />

FIGURE 3.6: Using rplot() to visualize correlations

It is much easier to see which relationships are positive or negative: positive relationships are in gray, and negative relationships are black. 
The size of the circle indicates how significant their relationship is. 
The power of visualizing data is in how much easier it makes it for us to understand results. 
The next section expands on this step of the process.

<h2>3.4 Visualize</h2>
Visualizations are a vital tool to help us find patterns in the data. 
It is easier for us to identify outliers in a dataset of 1,000 observations when plotted in a graph, as opposed to reading them from a list.
R is great at data visualizations. 
Its capabilities for creating plots are extended by the many R packages that focus on this analysis step. 
Unfortunately, the vast majority of R functions that create plots depend on the data already being in local memory within R, so they fail when using a remote table within Spark.
It is possible to create visualizations in R from data sources that exist in Spark. 
To understand how to do this, let’s first break down how computer programs build plots. 
To begin, a program takes the raw data and performs some sort of transformation. 
The transformed data is then mapped to a set of coordinates. 
Finally, the mapped values are drawn in a plot. 
Figure 3.7 summarizes each of the steps.

<img src="https://therinspark.com/the-r-in-spark_files/figure-html/analysis-plot-1.png" height="80pt" />

FIGURE 3.7: Stages of an R plot

In essence, the approach for visualizing is the same as in wrangling: push the computation to Spark, and then collect the results in R for plotting. 
As illustrated in Figure 3.8, the heavy lifting of preparing the data, such as aggregating the data by groups or bins, can be done within Spark, and then the much smaller dataset can be collected into R. 
Inside R, the plot becomes a more basic operation. 
For example, for a histogram, the bins are calculated in Spark, and then plotted in R using a simple column plot, as opposed to a histogram plot, because there is no need for R to recalculate the bins.

<img src="https://therinspark.com/the-r-in-spark_files/figure-html/analysis-spark-plot-1.png" height="150pt" />

FIGURE 3.8: Plotting with Spark and R

Let’s apply this conceptual model when using <code>ggplot2</code>.

<h3>3.4.1 Using ggplot2</h3>
To create a bar plot using <code>ggplot2</code>, we simply call a function:
<code>library(ggplot2)</code>
<code>## Warning: package &#39;ggplot2&#39; was built under R version 3.5.2</code>
<code>ggplot(aes(as.factor(cyl), mpg), data = mtcars) + geom_col()</code>

<img src="https://therinspark.com/the-r-in-spark_files/figure-html/analysis-ggplot2-simple-1.png" height="400pt" />

FIGURE 3.9: Plotting inside R

In this case, the <code>mtcars</code> raw data was <em>automatically</em> transformed into three discrete aggregated numbers. 
Next, each result was mapped into an <code>x</code> and <code>y</code> plane. 
Then the plot was drawn. 
As R users, all of the stages of building the plot are conveniently abstracted for us.
In Spark, there are a couple of key steps when codifying the “push compute, collect results” approach. 
First, ensure that the transformation operations happen within Spark. 
In the example that follows, <code>group_by()</code> and <code>summarise()</code> will run inside Spark. 
The second is to bring the results back into R after the data has been transformed. 
Be sure to transform and then collect, in that order; if <code>collect()</code> is run first, R will try to ingest the entire dataset from Spark. 
Depending on the size of the data, collecting all of the data will slow down or can even bring down your system.
<code>car_group &lt;- cars %>%
  group_by(cyl) %>%
  summarise(mpg = sum(mpg, na.rm = TRUE)) %>%
  collect() %>%
  print()</code>
<code># A tibble: 3 x 2
    cyl   mpg
  &lt;dbl> &lt;dbl>
1     6  138.
2     4  293.
3     8  211.</code>
In this example, now that the data has been preaggregated and collected into R, only three records are passed to the plotting function:
<code>ggplot(aes(as.factor(cyl), mpg), data = car_group) + 
  geom_col(fill = "#999999") + coord_flip()</code>
Figure 3.10 shows the resulting plot.

<img src="https://therinspark.com/images/analysis-visualizations-1.png" />

FIGURE 3.10: Plot with aggregation in Spark

Any other <code>ggplot2</code> visualization can be made to work using this approach; however, this is beyond the scope of the book. 
Instead, we recommend that you read <em>R Graphics Cookbook</em>, by Winston Chang (O’Reilly) to learn additional visualization techniques applicable to Spark. 
Now, to ease this transformation step before visualizing, the <code>dbplot</code> package provides a few ready-to-use visualizations that automate aggregation in Spark.

<h3>3.4.2 Using dbplot</h3>
The <code>dbplot</code> package provides helper functions for plotting with remote data. 
The R code <code>dbplot</code> that’s used to transform the data is written so that it can be translated into Spark. 
It then uses those results to create a graph using the <code>ggplot2</code> package where data transformation and plotting are both triggered by a single function.
The <code>dbplot_histogram()</code> function makes Spark calculate the bins and the count per bin and outputs a <code>ggplot</code> object, which we can further refine by adding more steps to the plot object. 
<code>dbplot_histogram()</code> also accepts a <code>binwidth</code> argument to control the range used to compute the bins:
<code>library(dbplot)

cars %>%
dbplot_histogram(mpg, binwidth = 3) +
labs(title = "MPG Distribution",
     subtitle = "Histogram over miles per gallon")</code>
Figure 3.11 presents the resulting plot.

<img src="https://therinspark.com/images/analysis-visualizations-histogram-resized.png" />

FIGURE 3.11: Histogram created by dbplot

Histograms provide a great way to analyze a single variable. 
To analyze two variables, a scatter or raster plot is commonly used.
Scatter plots are used to compare the relationship between two continuous variables. 
For example, a scatter plot will display the relationship between the weight of a car and its gas consumption. 
The plot in Figure 3.12 shows that the higher the weight, the higher the gas consumption because the dots clump together into almost a line that goes from the upper left toward the lower right. 
Here’s the code to generate the plot:
<code>ggplot(aes(mpg, wt), data = mtcars) + 
  geom_point()</code>

<img src="https://therinspark.com/images/analysis-point-resized.png" />

FIGURE 3.12: Scatter plot example in Spark

However, for scatter plots, no amount of “pushing the computation” to Spark will help with this problem because the data must be plotted in individual dots.
The best alternative is to find a plot type that represents the x/y relationship and concentration in a way that it is easy to perceive and to “physically” plot. 
The <em>raster</em> plot might be the best answer. 
A raster plot returns a grid of x/y positions and the results of a given aggregation, usually represented by the color of the square.
You can use <code>dbplot_raster()</code> to create a scatter-like plot in Spark, while only retrieving (collecting) a small subset of the remote dataset:
<code>dbplot_raster(cars, mpg, wt, resolution = 16)</code>

<img src="https://therinspark.com/images/analysis-visualizations-raster-resized.png" />

FIGURE 3.13: A raster plot using Spark

As shown in 3.13, the resulting plot returns a grid no bigger than 5 x 5. 
This limits the number of records that need to be collected into R to 25.
<strong>Tip:</strong> You can also use <code>dbplot</code> to retrieve the raw data and visualize by other means; to retrieve the aggregates, but not the plots, use <code>db_compute_bins()</code>, <code>db_compute_count()</code>, <code>db_compute_raster()</code>, and <code>db_compute_boxplot()</code>.
While visualizations are indispensable, you can complement data analysis using statistical models to gain even deeper insights into our data. 
The next section describes how we can prepare data for modeling with Spark.

<h2>3.5 Model</h2>
The next two chapters focus entirely on modeling, so rather than introducing modeling in too much detail in this chapter, we want to cover how to interact with models while doing data analysis.
First, an analysis project goes through many transformations and models to find the answer. 
That’s why the first data analysis diagram we introduced in Figure 3.2, illustrates a cycle of: visualizing, wrangling, and modeling—we know you don’t end with modeling, not in R, nor when using Spark.
Therefore, the ideal data analysis language enables you to quickly adjust over each wrangle-visualize-model iteration. 
Fortunately, this is the case when using Spark and R.
To illustrate how easy it is to iterate over wrangling and modeling in Spark, consider the following example. 
We will start by performing a linear regression against all features and predict miles per gallon:
<code>cars %>% 
  ml_linear_regression(mpg ~ .) %>%
  summary()</code>
<code>Deviance Residuals:
    Min      1Q  Median      3Q     Max 
-3.4506 -1.6044 -0.1196  1.2193  4.6271 

Coefficients:
(Intercept)         cyl        disp          hp        drat          wt  
12.30337416 -0.11144048  0.01333524 -0.02148212  0.78711097 -3.71530393
      qsec          vs          am        gear        carb 
0.82104075  0.31776281  2.52022689  0.65541302 -0.19941925 

R-Squared: 0.869
Root Mean Squared Error: 2.147</code>
At this point, it is very easy to experiment with different features, we can simply change the R formula from <code>mpg ~ .</code> to, say, <code>mpg ~ hp + cyl</code> to only use horsepower and cylinders as features:
<code>cars %>% 
  ml_linear_regression(mpg ~ hp + cyl) %>%
  summary()</code>
<code>Deviance Residuals:
    Min      1Q  Median      3Q     Max 
-4.4948 -2.4901 -0.1828  1.9777  7.2934 

Coefficients:
(Intercept)          hp         cyl 
 36.9083305  -0.0191217  -2.2646936 

R-Squared: 0.7407
Root Mean Squared Error: 3.021</code>
Additionally, it is also very easy to iterate with other kinds of models. 
The following one replaces the linear model with a generalized linear model:
<code>cars %>% 
  ml_generalized_linear_regression(mpg ~ hp + cyl) %>%
  summary()</code>
<code>Deviance Residuals:
    Min      1Q  Median      3Q     Max 
-4.4948 -2.4901 -0.1828  1.9777  7.2934 

Coefficients:
(Intercept)          hp         cyl 
 36.9083305  -0.0191217  -2.2646936 

(Dispersion parameter for gaussian family taken to be 10.06809)

   Null  deviance: 1126.05 on 31 degress of freedom
Residual deviance: 291.975 on 29 degrees of freedom
AIC: 169.56</code>
Usually, before fitting a model you would need to use multiple <code>dplyr</code> transformations to get it ready to be consumed by a model. 
To make sure the model can be fitted as efficiently as possible, you should cache your dataset before fitting it, as described next.

<h3>3.5.1 Caching</h3>
The examples in this chapter are built using a very small dataset. 
In real-life scenarios, large amounts of data are used for models. 
If the data needs to be transformed first, the volume of the data could exact a heavy toll on the Spark session. 
Before fitting the models, it is a good idea to save the results of all the transformations in a new table loaded in Spark memory.
The <code>compute()</code> command can take the end of a <code>dplyr</code> command and save the results to Spark memory:
<code>cached_cars &lt;- cars %>% 
  mutate(cyl = paste0("cyl_", cyl)) %>%
  compute("cached_cars")</code>
<code>cached_cars %>%
  ml_linear_regression(mpg ~ .) %>%
  summary()</code>
<code>Deviance Residuals:
     Min       1Q   Median       3Q      Max 
-3.47339 -1.37936 -0.06554  1.05105  4.39057 

Coefficients:
(Intercept) cyl_cyl_8.0 cyl_cyl_4.0        disp          hp        drat
16.15953652  3.29774653  1.66030673  0.01391241 -0.04612835  0.02635025
          wt        qsec          vs          am       gear        carb 
 -3.80624757  0.64695710  1.74738689  2.61726546 0.76402917  0.50935118  

R-Squared: 0.8816
Root Mean Squared Error: 2.041</code>
As more insights are gained from the data, more questions might be raised. 
That is why we expect to iterate through the data wrangle, visualize, and model cycle multiple times. 
Each iteration should provide incremental insights into what the data is “telling us”. 
There will be a point when we reach a satisfactory level of understanding. 
It is at this point that we will be ready to share the results of the analysis. 
This is the topic of the next section.

<h2>3.6 Communicate</h2>
It is important to clearly communicate the analysis results—as important as the analysis work itself! The public, colleagues, or stakeholders need to understand what you found out and how.
To communicate effectively, we need to use artifacts such as reports and presentations; these are common output formats that we can create in R, using <em>R Markdown</em>.
R Markdown documents allow you to weave narrative text and code together. 
The variety of output formats provides a very compelling reason to learn and use R Markdown. 
There are many available output formats like HTML, PDF, PowerPoint, Word, web slides, websites, books, and so on.
Most of these outputs are available in the core R packages of R Markdown: <code>knitr</code> and <code>rmarkdown</code>. 
You can extend R Markdown with other R packages. 
For example, this book was written using R Markdown thanks to an extension provided by the <code>bookdown</code> package. 
The best resource to delve deeper into R Markdown is the official book.
In R Markdown, one singular artifact could potentially be rendered in different formats. 
For example, you could render the same report in HTML or as a PDF file by changing a setting within the report itself. 
Conversely, multiple types of artifacts could be rendered as the same output. 
For example, a presentation deck and a report could be rendered in HTML.
Creating a new R Markdown report that uses Spark as a computer engine is easy. 
At the top, R Markdown expects a YAML header. 
The first and last lines are three consecutive dashes (<code>---</code>). 
The content in between the dashes varies depending on the type of document. 
The only required field in the YAML header is the <code>output</code> value. 
R Markdown needs to know what kind of output it needs to render your report into. 
This YAML header is called <em>frontmatter</em>. 
Following the frontmatter are sections of code, called <em>code chunks</em>. 
These code chunks can be interlaced with the narratives. 
There is nothing particularly interesting to note when using Spark with R Markdown; it is just business as usual.
Since an R Markdown document is self-contained and meant to be reproducible, before rendering documents, we should first disconnect from Spark to free resources:
<code>spark_disconnect(sc)</code>
The following example shows how easy it is to create a fully reproducible report that uses Spark to process large-scale datasets. 
The narrative, code, and, most important, the output of the code is recorded in the resulting HTML file. 
You can copy and paste the following code in a file. 
Save the file with a <em>.Rmd</em> extension, and choose whatever name you would like:
<code>---
title: "mtcars analysis"
output:
  html_document: 
    fig_width: 6 
    fig_height: 3
---
```{r, setup, include = FALSE}
library(sparklyr)
library(dplyr)

sc &lt;- spark_connect(master = "local", version = "2.3")
cars &lt;- copy_to(sc, mtcars)
```

## Visualize
Aggregate data in Spark, visualize in R.
```{r  fig.align=&#39;center&#39;, warning=FALSE}
library(ggplot2)
cars %>%
  group_by(cyl) %>% summarise(mpg = mean(mpg)) %>%
  ggplot(aes(cyl, mpg)) + geom_bar(stat="identity")
```

## Model
The selected model was a simple linear regression that 
uses the weight as the predictor of MPG

```{r}
cars %>%
  ml_linear_regression(wt ~ mpg) %>%
  summary()
```
```{r, include = FALSE}
spark_disconnect(sc)
```</code>
To(((“commands”, “render()”))) knit this report, save the file with a <em>.Rmd</em> extension such as <em>report.Rmd</em>, and run <code>render()</code> from R. 
The output should look like that shown in Figure 3.14.
<code>rmarkdown::render("report.Rmd")</code>

<img src="https://therinspark.com/images/analysis-rmarkdown-resized.png" />

FIGURE 3.14: R Markdown HTML output

You can now easily share this report, and viewers of won’t need Spark or R to read and consume its contents; it’s just a self-contained HTML file, trivial to open in any browser.
It is also common to distill insights of a report into many other output formats. 
Switching is quite easy: in the top frontmatter, change the <code>output</code> option to <code>powerpoint_presentation</code>, <code>pdf_document</code>, <code>word_document</code>, or the like. 
Or you can even produce multiple output formats from the same report:
<code>---
title: "mtcars analysis"
output:
  word_document: default
  pdf_document: default
  powerpoint_presentation: default
---</code>
The result will be a PowerPoint presentation, a Word document, and a PDF. 
All of the same information that was displayed in the original HTML report is computed in Spark and rendered in R. 
You’ll likely need to edit the PowerPoint template or the output of the code chunks.
This minimal example shows how easy it is to go from one format to another. 
Of course, it will take some more editing on the R user’s side to make sure the slides contain only the pertinent information. 
The main point is that it does not require that you learn a different markup or code conventions to switch from one artifact to another.

<h2>3.7 Recap</h2>
This chapter presented a solid introduction to data analysis with R and Spark. 
Many of the techniques presented looked quite similar to using just R and no Spark, which, while anticlimactic, is the right design to help users already familiar with R to easily transition to Spark. 
For users unfamiliar with R, this chapter also served as a very brief introduction to some of the most popular (and useful!) packages available in R.
It should now be quite obvious that, together, R and Spark are a powerful combination—a large-scale computing platform, along with an incredibly robust ecosystem of R packages, makes for an ideal analysis platform.
While doing analysis in Spark with R, remember to push computation to Spark and focus on collecting results in R. 
This paradigm should set up a successful approach to data manipulation, visualization and communication through sharing your results in a variety of outputs.
Chapter 4 will dive deeper into how to build statistical models in Spark using a much more interesting dataset (what’s more interesting than dating datasets?). 
You will also learn many more techniques that we did not even mention in the brief modeling section from this chapter.

<h2><span class="orange">Chapter 4 Modeling</span></h2>
In Chapter 3 you learned how to scale up data analysis to large datasets using Spark. 
In this chapter, we detail the steps required to build prediction models in Spark. 
We explore <code>MLlib</code>, the component of Spark that allows you to write high-level code to perform predictive modeling on distributed data, and use data wrangling in the context of feature engineering and exploratory data analysis.
We will start this chapter by introducing modeling in the context of Spark and the dataset you will use throughout the chapter. 
We then demonstrate a supervised learning workflow that includes exploratory data analysis, feature engineering, and model building. 
Then we move on to an unsupervised topic modeling example using unstructured text data. 
Keep in mind that our goal is to show various techniques of executing data science tasks on large data rather than conducting a rigorous and coherent analysis. 
There are also many other models available in Spark that won’t be covered in this chapter, but by the end of the chapter, you will have the right tools to experiment with additional ones on your own.
While predicting datasets manually is often a reasonable approach (by “manually,” we mean someone imports a dataset into Spark and uses the fitted model to enrich or predict values), it does beg the question, could we automate this process into systems that anyone can use? For instance, how can we build a system that automatically identifies an email as spam without having to manually analyze each email account? Chapter 5 presents the tools to automate data analysis and modeling with pipelines, but to get there, we need to first understand how to train models “by hand”.

<h2>4.1 Overview</h2>
The R interface to Spark provides modeling algorithms that should be familiar to R users, and we’ll go into detail in the chapter. 
For instance, we’ve already used <code>ml_linear_regression(cars, mpg ~ .)</code>, but we could run <code>ml_logistic_regression(cars, am ~ .)</code> just as easily.
Take a moment to look at the long list of <code>MLlib</code> functions included in the appendix of this book; a quick glance at this list shows that Spark supports Decision Trees, Gradient-Boosted Trees, Accelerated Failure Time Survival Regression, Isotonic Regression, <em>K</em>-Means Clustering, Gaussian Mixture Clustering, and more.
As you can see, Spark provides a wide range of algorithms and feature transformers, and here we touch on a representative portion of the functionality. 
A complete treatment of predictive modeling concepts is beyond the scope of this book, so we recommend complementing this discussion with <em>R for Data Science</em> by Hadley Wickham and Garrett Grolemund G (O’Reilly) and Feature Engineering and Selection: A Practical Approach for Predictive Models, from which we adopted (sometimes verbatim) some of the examples and visualizations in this chapter.
This chapter focuses on predictive modeling, since Spark aims to enable machine learning as opposed to statistical inference. 
Machine learning is often more concerned about forecasting the future rather than inferring the process by which our data is generated, which is then used to create automated systems. 
Machine learning can be categorized into <em>supervised learning</em> (predictive modeling) and <em>unsupervised learning</em>. 
In supervised learning, we try to learn a function that will map from X to Y, from a dataset of (x, y) examples. 
In unsupervised learning, we just have X and not the Y labels, so instead we try to learn something about the structure of X. 
Some practical use cases for supervised learning include forecasting tomorrow’s weather, determining whether a credit card transaction is fraudulent, and coming up with a quote for your car insurance policy. 
With unsupervised learning, examples include automated grouping of photos of individuals, segmenting customers based on their purchase history, and clustering of documents.
The ML interface in <code>sparklyr</code> has been designed to minimize the cognitive effort for moving from a local, in-memory, native-R workflow to the cluster, and back. 
While the Spark ecosystem is very rich, there is still a tremendous number of packages from CRAN, with some implementing functionality that you might require for a project. 
Also, you might want to leverage your skills and experience working in R to maintain productivity. 
What we learned in Chapter 3 also applies here—it is important to keep track of where you are performing computations and move between the cluster and your R session as appropriate.
The examples in this chapter utilize the <code>OkCupid</code> dataset. 
The dataset consists of user profile data from an online dating site and contains a diverse set of features, including biographical characteristics such as gender and profession, as well as free text fields related to personal interests. 
There are about 60,000 profiles in the dataset, which fits comfortably into memory on a modern laptop and wouldn’t be considered “big data”, so you can easily follow along running Spark in local mode.
You can download this dataset as follows:
<code>download.file(
  "https://github.com/r-spark/okcupid/raw/master/profiles.csv.zip",
  "okcupid.zip")

unzip("okcupid.zip", exdir = "data")
unlink("okcupid.zip")</code>
We don’t recommend sampling this dataset since the model won’t be nearly as rich; however, if you have limited hardware resources, you are welcome to sample it as follows:
<code>profiles &lt;- read.csv("data/profiles.csv")
write.csv(dplyr::sample_n(profiles, 10^3),
          "data/profiles.csv", row.names = FALSE)</code>
<strong>Note:</strong> The examples in this chapter utilize small datasets so that you can easily follow along in local mode. 
In practice, if your dataset fits comfortably in memory on your local machine, you might be better off using an efficient, nondistributed implementation of the modeling algorithm. 
For example, you might want to use the <code>ranger</code> package instead of <code>ml_random_forest_classifier()</code>.
In addition, to follow along, you will need to install a few additional packages:
<code>install.packages("ggmosaic")
install.packages("forcats")
install.packages("FactoMineR")</code>
To motivate the examples, we consider the following problem:
Next up, we explore this dataset.

<h2>4.2 Exploratory Data Analysis</h2>
Exploratory data analysis (EDA), in the context of predictive modeling, is the exercise of looking at excerpts and summaries of the data. 
The specific goals of the EDA stage are informed by the business problem, but here are some common objectives:
<ul>
<li>Check for data quality; confirm meaning and prevalence of missing values and reconcile statistics against existing controls.</li>
<li>Understand univariate relationships between variables.</li>
<li>Perform an initial assessment on what variables to include and what transformations need to be done on them.</li>
</ul>
To begin, we connect to Spark, load libraries, and read in the data:
<code>library(sparklyr)
library(ggplot2)
library(dbplot)
library(dplyr)

sc &lt;- spark_connect(master = "local", version = "2.3")

okc &lt;- spark_read_csv(
  sc, 
  "data/profiles.csv", 
  escape = "\", 
  memory = FALSE,
  options = list(multiline = TRUE)
) %>%
  mutate(
    height = as.numeric(height),
    income = ifelse(income == "-1", NA, as.numeric(income))
  ) %>%
  mutate(sex = ifelse(is.na(sex), "missing", sex)) %>%
  mutate(drinks = ifelse(is.na(drinks), "missing", drinks)) %>%
  mutate(drugs = ifelse(is.na(drugs), "missing", drugs)) %>%
  mutate(job = ifelse(is.na(job), "missing", job))</code>
We specify <code>escape = "\""</code> and <code>options = list(multiline = TRUE)</code> here to accommodate embedded quote characters and newlines in the essay fields. 
We also convert the <code>height</code> and <code>income</code> columns to numeric types and recode missing values in the string columns. 
Note that it might very well take a few tries of specifying different parameters to get the initial data ingest correct, and sometimes you might need to revisit this step after you learn more about the data during modeling.
We can now take a quick look at our data by using <code>glimpse()</code>:
<code>glimpse(okc)</code>
<code>Observations: ??
Variables: 31
Database: spark_connection
$ age         &lt;int> 22, 35, 38, 23, 29, 29, 32, 31, 24, 37, 35…
$ body_type   &lt;chr> "a little extra", "average", "thin", "thin…
$ diet        &lt;chr> "strictly anything", "mostly other", "anyt…
$ drinks      &lt;chr> "socially", "often", "socially", "socially…
$ drugs       &lt;chr> "never", "sometimes", "missing", "missing"…
$ education   &lt;chr> "working on college/university", "working …
$ essay0      &lt;chr> "about me:&lt;br />\n&lt;br />\ni would love to …
$ essay1      &lt;chr> "currently working as an international age…
$ essay2      &lt;chr> "making people laugh.&lt;br />\nranting about…
$ essay3      &lt;chr> "the way i look. 
i am a six foot half asia…
$ essay4      &lt;chr> "books:&lt;br />\nabsurdistan, the republic, …
$ essay5      &lt;chr> "food.&lt;br />\nwater.&lt;br />\ncell phone.&lt;br…
$ essay6      &lt;chr> "duality and humorous things", "missing", …
$ essay7      &lt;chr> "trying to find someone to hang out with. 
…
$ essay8      &lt;chr> "i am new to california and looking for so…
$ essay9      &lt;chr> "you want to be swept off your feet!&lt;br />…
$ ethnicity   &lt;chr> "asian, white", "white", "missing", "white…
$ height      &lt;dbl> 75, 70, 68, 71, 66, 67, 65, 65, 67, 65, 70…
$ income      &lt;dbl> NaN, 80000, NaN, 20000, NaN, NaN, NaN, NaN…
$ job         &lt;chr> "transportation", "hospitality / travel", …
$ last_online &lt;chr> "2012-06-28-20-30", "2012-06-29-21-41", "2…
$ location    &lt;chr> "south san francisco, california", "oaklan…
$ offspring   &lt;chr> "doesn&amp;rsquo;t have kids, but might want t…
$ orientation &lt;chr> "straight", "straight", "straight", "strai…
$ pets        &lt;chr> "likes dogs and likes cats", "likes dogs a…
$ religion    &lt;chr> "agnosticism and very serious about it", "…
$ sex         &lt;chr> "m", "m", "m", "m", "m", "m", "f", "f", "f…
$ sign        &lt;chr> "gemini", "cancer", "pisces but it doesn&amp;r…
$ smokes      &lt;chr> "sometimes", "no", "no", "no", "no", "no",…
$ speaks      &lt;chr> "english", "english (fluently), spanish (p…
$ status      &lt;chr> "single", "single", "available", "single",…</code>
Now, we add our response variable as a column in the dataset and look at its distribution:
<code>okc &lt;- okc %>%
  mutate(
    not_working = ifelse(job %in% c("student", "unemployed", "retired"), 1 , 0)
  )

okc %>% 
  group_by(not_working) %>% 
  tally()</code>
<code># Source: spark&lt;?> [?? x 2]
  not_working     n
        &lt;dbl> &lt;dbl>
1           0 54541
2           1  5405</code>
Before we proceed further, let’s perform an initial split of our data into a training set and a testing set and put away the latter. 
In practice, this is a crucial step because we would like to have a holdout set that we set aside at the end of the modeling process to evaluate model performance. 
If we were to include the entire dataset during EDA, information from the testing set could “leak” into the visualizations and summary statistics and bias our model-building process even though the data is not used directly in a learning algorithm. 
This would undermine the credibility of our performance metrics. 
We can easily split the data by using the <code>sdf_random_split()</code> function:
<code>data_splits &lt;- sdf_random_split(okc, training = 0.8, testing = 0.2, seed = 42)
okc_train &lt;- data_splits$training
okc_test &lt;- data_splits$testing</code>
We can quickly look at the distribution of our response variable:
<code>okc_train %>%
  group_by(not_working) %>%
  tally() %>%
  mutate(frac = n / sum(n))</code>
<code># Source: spark&lt;?> [?? x 3]
  not_working     n   frac
        &lt;dbl> &lt;dbl>  &lt;dbl>
1           0 43785 0.910 
2           1  4317 0.0897</code>
Using the <code>sdf_describe()</code> function, we can obtain numerical summaries of specific columns:
<code>sdf_describe(okc_train, cols = c("age", "income"))</code>
<code># Source: spark&lt;?> [?? x 3]
  summary age                income            
  &lt;chr>   &lt;chr>              &lt;chr>             
1 count   48102              9193              
2 mean    32.336534863415245 104968.99815076689
3 stddev  9.43908920033797   202235.2291773537 
4 min     18                 20000.0           
5 max     110                1000000.0   </code>
Like we saw in Chapter 3, we can also utilize the <code>dbplot</code> package to plot distributions of these variables. 
In Figure 4.1 we show a histogram of the distribution of the <code>age</code> variable, which is the result of the following code:
<code>dbplot_histogram(okc_train, age)</code>

<img src="https://therinspark.com/images/modeling-okc-histogram-age-resized.png" />

FIGURE 4.1: Distribution of age

A common EDA exercise is to look at the relationships between the response and the individual predictors. 
Often, you might have prior business knowledge of what these relationships should be, so this can serve as a data quality check. 
Also, unexpected trends can inform variable interactions that you might want to include in the model. 
As an example, we can explore the <code>religion</code> variable:
<code>prop_data &lt;- okc_train %>%
  mutate(religion = regexp_extract(religion, "^\\\\w+", 0)) %>% 
  group_by(religion, not_working) %>%
  tally() %>%
  group_by(religion) %>%
  summarize(
    count = sum(n),
    prop = sum(not_working * n) / sum(n)
  ) %>%
  mutate(se = sqrt(prop * (1 - prop) / count)) %>%
  collect()

prop_data</code>
<code># A tibble: 10 x 4
   religion     count   prop      se
   &lt;chr>        &lt;dbl>  &lt;dbl>   &lt;dbl>
 1 judaism       2520 0.0794 0.00539
 2 atheism       5624 0.118  0.00436
 3 christianity  4671 0.120  0.00480
 4 hinduism       358 0.101  0.0159 
 5 islam          115 0.191  0.0367 
 6 agnosticism   7078 0.0958 0.00346
 7 other         6240 0.0841 0.00346
 8 missing      16152 0.0719 0.002  
 9 buddhism      1575 0.0851 0.007  
10 catholicism   3769 0.0886 0.00458</code>
Note that <code>prop_data</code> is a small DataFrame that has been collected into memory in our R session, we can take advantage of <code>ggplot2</code> to create an informative visualization (see Figure 4.2):
<code>prop_data %>%
  ggplot(aes(x = religion, y = prop)) + geom_point(size = 2) +
  geom_errorbar(aes(ymin = prop - 1.96 * se, ymax = prop + 1.96 * se),
                width = .1) +
  geom_hline(yintercept = sum(prop_data$prop * prop_data$count) /
                              sum(prop_data$count))</code>

<img src="https://therinspark.com/images/modeling-okc-prop-resized.png" />

FIGURE 4.2: Proportion of individuals not currently employed, by religion

Next, we take a look at the relationship between a couple of predictors: alcohol use and drug use. 
We would expect there to be some correlation between them. 
You can compute a contingency table via <code>sdf_crosstab()</code>:
<code>contingency_tbl &lt;- okc_train %>% 
  sdf_crosstab("drinks", "drugs") %>%
  collect()

contingency_tbl</code>
<code># A tibble: 7 x 5
  drinks_drugs missing never often sometimes
  &lt;chr>          &lt;dbl> &lt;dbl> &lt;dbl>     &lt;dbl>
1 very often        54   144    44       137
2 socially        8221 21066   126      4106
3 not at all       146  2371    15       109
4 desperately       72    89    23        74
5 often           1049  1718    69      1271
6 missing         1121  1226    10        59
7 rarely           613  3689    35       445</code>
We can visualize this contingency table using a mosaic plot (see Figure 4.3):
<code>library(ggmosaic)
library(forcats)
library(tidyr)

contingency_tbl %>%
  rename(drinks = drinks_drugs) %>%
  gather("drugs", "count", missing:sometimes) %>%
  mutate(
    drinks = as_factor(drinks) %>% 
      fct_relevel("missing", "not at all", "rarely", "socially", 
                  "very often", "desperately"),
    drugs = as_factor(drugs) %>%
      fct_relevel("missing", "never", "sometimes", "often")
  ) %>%
  ggplot() +
  geom_mosaic(aes(x = product(drinks, drugs), fill = drinks, 
                  weight = count))</code>

<img src="https://therinspark.com/images/modeling-okc-mosaic-resized.png" />

FIGURE 4.3: Mosaic plot of drug and alcohol use

To further explore the relationship between these two variables, we can perform correspondence analysis using the <code>FactoMineR</code> package. 
This technique enables us to summarize the relationship between the high-dimensional factor levels by mapping each level to a point on the plane. 
We first obtain the mapping using <code>FactoMineR::CA()</code> as follows:
<code>dd_obj &lt;- contingency_tbl %>% 
  tibble::column_to_rownames(var = "drinks_drugs") %>%
  FactoMineR::CA(graph = FALSE)</code>
We can then plot the results using <code>ggplot</code>, which you can see in Figure 4.4:
<code>dd_drugs &lt;-
  dd_obj$row$coord %>%
  as.data.frame() %>%
  mutate(
    label = gsub("_", " ", rownames(dd_obj$row$coord)),
    Variable = "Drugs"
  )

dd_drinks &lt;-
  dd_obj$col$coord %>%
  as.data.frame() %>%
  mutate(
    label = gsub("_", " ", rownames(dd_obj$col$coord)),
    Variable = "Alcohol"
  )
  
ca_coord &lt;- rbind(dd_drugs, dd_drinks)
  
ggplot(ca_coord, aes(x = `Dim 1`, y = `Dim 2`, 
                     col = Variable)) +
  geom_vline(xintercept = 0) +
  geom_hline(yintercept = 0) +
  geom_text(aes(label = label)) +
  coord_equal()</code>

<img src="https://therinspark.com/images/modeling-okc-correspondence-analysis-resized.png" />

FIGURE 4.4: Correspondence analysis principal coordinates for drug and alcohol use

In Figure 4.4, we see that the correspondence analysis procedure has transformed the factors into variables called <em>principal coordinates</em>, which correspond to the axes in the plot and represent how much information in the contingency table they contain. 
We can, for example, interpret the proximity of “drinking often” and “using drugs very often” as indicating association.
This concludes our discussion on EDA. 
Let’s proceed to feature engineering.

<h2>4.3 Feature Engineering</h2>
The feature engineering exercise comprises transforming the data to increase the performance of the model. 
This can include things like centering and scaling numerical values and performing string manipulation to extract meaningful variables. 
It also often includes variable selection—the process of selecting which predictors are used in the model.
In Figure 4.1 we see that the <code>age</code> variable has a range from 18 to over 60. 
Some algorithms, especially neural networks, train faster if we normalize our inputs so that they are of the same magnitude. 
Let’s now normalize the <code>age</code> variable by removing the mean and scaling to unit variance, beginning by calculating its mean and standard deviation:
<code>scale_values &lt;- okc_train %>%
  summarize(
    mean_age = mean(age),
    sd_age = sd(age)
  ) %>%
  collect()

scale_values</code>
<code># A tibble: 1 x 2
  mean_age sd_age
     &lt;dbl>  &lt;dbl>
1     32.3   9.44</code>
We can then use these to transform the dataset:
<code>okc_train &lt;- okc_train %>%
  mutate(scaled_age = (age - !!scale_values$mean_age) /
           !!scale_values$sd_age)</code>
<code>dbplot_histogram(okc_train, scaled_age)</code>
In Figure 4.5, we see that the scaled age variable has values that are closer to zero. 
We now move on to discussing other types of transformations, but during your feature engineering workflow you might want to perform the normalization for all numeric variables that you want to include in the model.

<img src="https://therinspark.com/images/modeling-okc-histogram-scaled-age-resized.png" />

FIGURE 4.5: Distribution of scaled age

Since some of the profile features are multiple-select—in other words, a person can choose to associate multiple options for a variable—we need to process them before we can build meaningful models. 
If we take a look at the ethnicity column, for example, we see that there are many different combinations:
<code>okc_train %>%
  group_by(ethnicity) %>%
  tally()</code>
<code># Source: spark&lt;?> [?? x 2]
   ethnicity                                     n
   &lt;chr>                                     &lt;dbl>
 1 hispanic / latin, white                    1051
 2 black, pacific islander, hispanic / latin     2
 3 asian, black, pacific islander                5
 4 black, native american, white                91
 5 middle eastern, white, other                 34
 6 asian, other                                 78
 7 asian, black, white                          12
 8 asian, hispanic / latin, white, other         7
 9 middle eastern, pacific islander              1
10 indian, hispanic / latin                      5
# … with more rows</code>
One way to proceed would be to treat each combination of races as a separate level, but that would lead to a very large number of levels, which becomes problematic in many algorithms. 
To better encode this information, we can create dummy variables for each race, as follows:
<code>ethnicities &lt;- c("asian", "middle eastern", "black", "native american", "indian", 
                 "pacific islander", "hispanic / latin", "white", "other")
ethnicity_vars &lt;- ethnicities %>% 
  purrr::map(~ expr(ifelse(like(ethnicity, !!.x), 1, 0))) %>%
  purrr::set_names(paste0("ethnicity_", gsub("\\s|/", ", ethnicities)))
okc_train &lt;- mutate(okc_train, !!!ethnicity_vars)
okc_train %>% 
  select(starts_with("ethnicity_")) %>%
  glimpse()</code>
<code>Observations: ??
Variables: 9
Database: spark_connection
$ ethnicity_asian           &lt;dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…
$ ethnicity_middleeastern   &lt;dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…
$ ethnicity_black           &lt;dbl> 0, 1, 0, 0, 0, 0, 0, 0, 0, 0…
$ ethnicity_nativeamerican  &lt;dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…
$ ethnicity_indian          &lt;dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…
$ ethnicity_pacificislander &lt;dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…
$ ethnicity_hispaniclatin   &lt;dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…
$ ethnicity_white           &lt;dbl> 1, 0, 1, 0, 1, 1, 1, 0, 1, 0…
$ ethnicity_other           &lt;dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…</code>
For the free text fields, a straightforward way to extract features is counting the total number of characters. 
We will store the train dataset in Spark’s memory with <code>compute()</code> to speed up computation.
<code>okc_train &lt;- okc_train %>%
  mutate(
    essay_length = char_length(paste(!!!syms(paste0("essay", 0:9))))
  ) %>% compute()</code>
<code>dbplot_histogram(okc_train, essay_length, bins = 100)</code>
We can see the distribution of the <code>essay_length</code> variable in Figure 4.6.

<img src="https://therinspark.com/images/modeling-okc-histogram-essay-length-resized.png" />

FIGURE 4.6: Distribution of essay length

We use this dataset in Chapter 5, so let’s save it first as a Parquet file—an efficient file format ideal for numeric data:
<code>spark_write_parquet(okc_train, "data/okc-train.parquet")</code>
Now that we have a few more features to work with, we can begin running some unsupervised learning algorithms.

<h2>4.4 Supervised Learning</h2>
Once we have a good grasp on our dataset, we can start building some models. 
Before we do so, however, we need to come up with a plan to tune and validate the “candidate” models—in modeling projects, we often try different types of models and ways to fit them to see which ones perform the best. 
Since we are dealing with a binary classification problem, the metrics we can use include accuracy, precision, sensitivity, and area under the receiver operating characteristic curve (ROC AUC), among others. 
The metric you optimize depends on your specific business problem, but for this exercise, we will focus on the ROC AUC.
It is important that we don’t peek at the testing holdout set until the very end, because any information we obtain could influence our modeling decisions, which would in turn make our estimates of model performance less credible. 
For tuning and validation, we perform 10-fold cross-validation, which is a standard approach for model tuning. 
The scheme works as follows: we first divide our dataset into 10 approximately equal-sized subsets. 
We take the 2nd to 10th sets together as the training set for an algorithm and validate the resulting model on the 1st set. 
Next, we reserve the 2nd set as the validation set and train the algorithm on the 1st and 3rd to 10th sets. 
In total, we train 10 models and average the performance. 
If time and resources allow, you can also perform this procedure multiple times with different random partitions of the data. 
In our case, we will demonstrate how to perform the cross-validation once. 
Hereinafter, we refer to the training set associated with each split as the <em>analysis</em> data, and the validation set as <em>assessment</em> data.
Using the <code>sdf_random_split()</code> function, we can create a list of subsets from our <code>okc_train</code> table:
<code>vfolds &lt;- sdf_random_split(
  okc_train,
  weights = purrr::set_names(rep(0.1, 10), paste0("fold", 1:10)),
  seed = 42
)</code>
We then create our first analysis/assessment split as follows:
<code>analysis_set &lt;- do.call(rbind, vfolds[2:10])
assessment_set &lt;- vfolds[[1]]</code>
One item we need to carefully treat here is the scaling of variables. 
We need to make sure that we do not leak any information from the assessment set to the analysis set, so we calculate the mean and standard deviation on the analysis set only and apply the same transformation to both sets. 
Here is how we would handle this for the <code>age</code> variable:
<code>make_scale_age &lt;- function(analysis_data) {
  scale_values &lt;- analysis_data %>%
    summarize(
      mean_age = mean(age),
      sd_age = sd(age)
    ) %>%
    collect()

  function(data) {
    data %>%
      mutate(scaled_age = (age - !!scale_values$mean_age) / !!scale_values$sd_age)
  }
}

scale_age &lt;- make_scale_age(analysis_set)
train_set &lt;- scale_age(analysis_set)
validation_set &lt;- scale_age(assessment_set)</code>
For brevity, here we show only how to transform the <code>age</code> variable. 
In practice, however, you would want to normalize each one of your continuous predictors, such as the <code>essay_length</code> variable we derived in the previous section.
Logistic regression is often a reasonable starting point for binary classification problems, so let’s give it a try. 
Suppose also that our domain knowledge provides us with an initial set of predictors. 
We can then fit a model by using the <code>Formula</code> interface:
<code>lr &lt;- ml_logistic_regression(
  analysis_set, not_working ~ scaled_age + sex + drinks + drugs + essay_length
)
lr</code>
<code>Formula: not_working ~ scaled_age + sex + drinks + drugs + essay_length

Coefficients:
      (Intercept)        scaled_age             sex_m   drinks_socially 
    -2.823517e+00     -1.309498e+00     -1.918137e-01      2.235833e-01 
    drinks_rarely      drinks_often drinks_not at all    drinks_missing 
     6.732361e-01      7.572970e-02      8.214072e-01     -4.456326e-01 
drinks_very often       drugs_never     drugs_missing   drugs_sometimes 
     8.032052e-02     -1.712702e-01     -3.995422e-01     -7.483491e-02 
     essay_length 
     3.664964e-05 </code>
To obtain a summary of performance metrics on the assessment set, we can use the <code>ml_evaluate()</code> function:
<code>validation_summary &lt;- ml_evaluate(lr, assessment_set)</code>
You can print <code>validation_summary</code> to see the available metrics:
<code>validation_summary</code>
<code>BinaryLogisticRegressionSummaryImpl 
 Access the following via `$` or `ml_summary()`. 

 - features_col() 
 - label_col() 
 - predictions() 
 - probability_col() 
 - area_under_roc() 
 - f_measure_by_threshold() 
 - pr() 
 - precision_by_threshold() 
 - recall_by_threshold() 
 - roc() 
 - prediction_col() 
 - accuracy() 
 - f_measure_by_label() 
 - false_positive_rate_by_label() 
 - labels() 
 - precision_by_label() 
 - recall_by_label() 
 - true_positive_rate_by_label() 
 - weighted_f_measure() 
 - weighted_false_positive_rate() 
 - weighted_precision() 
 - weighted_recall() 
 - weighted_true_positive_rate() </code>
We can plot the ROC curve by collecting the output of <code>validation_summary$roc()</code> and using <code>ggplot2</code>:
<code>roc &lt;- validation_summary$roc() %>%
  collect()

ggplot(roc, aes(x = FPR, y = TPR)) +
  geom_line() + geom_abline(lty = "dashed")</code>
Figure 4.7 shows the results of the plot.

<img src="https://therinspark.com/images/modeling-okc-roc1-resized.png" />

FIGURE 4.7: ROC curve for the logistic regression model

The ROC curve plots the true positive rate (sensitivity) against the false positive rate (1–specificity) for varying values of the classification threshold. 
In practice, the business problem helps to determine where on the curve one sets the threshold for classification. 
The AUC is a summary measure for determining the quality of a model, and we can compute it by calling the <code>area_under_roc()</code> function.
<code>validation_summary$area_under_roc()</code>
<code>[1] 0.7872754</code>
<strong>Note:</strong> Spark provides evaluation methods for only generalized linear models (including linear models and logistic regression). 
For other algorithms, you can use the evaluator functions (e.g., <code>ml_binary_classification_evaluator()</code> on the prediction DataFrame) or compute your own metrics.
Now, we can easily repeat the logic we already have and apply it to each analysis/assessment split:
<code>cv_results &lt;- purrr::map_df(1:10, function(v) {
  analysis_set &lt;- do.call(rbind, vfolds[setdiff(1:10, v)]) %>% compute()
  assessment_set &lt;- vfolds[[v]]
  
  scale_age &lt;- make_scale_age(analysis_set)
  train_set &lt;- scale_age(analysis_set)
  validation_set &lt;- scale_age(assessment_set)
  
  model &lt;- ml_logistic_regression(
    analysis_set, not_working ~ scaled_age + sex + drinks + drugs + essay_length
  )
  s &lt;- ml_evaluate(model, assessment_set)
  roc_df &lt;- s$roc() %>% 
    collect()
  auc &lt;- s$area_under_roc()
  
  tibble(
    Resample = paste0("Fold", stringr::str_pad(v, width = 2, pad = "0")),
    roc_df = list(roc_df),
    auc = auc
  )
})</code>
This gives us 10 ROC curves:
<code>unnest(cv_results, roc_df) %>%
  ggplot(aes(x = FPR, y = TPR, color = Resample)) +
  geom_line() + geom_abline(lty = "dashed")</code>
Figure 4.8 shows the results of the plot.

<img src="https://therinspark.com/images/modeling-okc-roc2-resized.png" />

FIGURE 4.8: Cross-validated ROC curves for the logistic regression model

And we can obtain the average AUC metric:
<code>mean(cv_results$auc)</code>
<code>[1] 0.7715102</code>

<h3>4.4.1 Generalized Linear Regression</h3>
If you are interested in generalized linear model (GLM) diagnostics,you can also fit a logistic regression via the generalized linear regression interface by specifying <code>family = "binomial"</code>. 
Because the result is a regression model, the <code>ml_predict()</code> method does not give class probabilities. 
However, it includes confidence intervals for coefficient estimates:
<code>glr &lt;- ml_generalized_linear_regression(
  analysis_set, 
  not_working ~ scaled_age + sex + drinks + drugs, 
  family = "binomial"
)

tidy_glr &lt;- tidy(glr)</code>
We can extract the coefficient estimates into a tidy DataFrame, which we can then process further—for example, to create a coefficient plot, which you can see in Figure 4.9.
<code>tidy_glr %>%
  ggplot(aes(x = term, y = estimate)) +
  geom_point() +
  geom_errorbar(
    aes(ymin = estimate - 1.96 * std.error, 
       ymax = estimate + 1.96 * std.error, width = .1)
  ) +
  coord_flip() +
  geom_hline(yintercept = 0, linetype = "dashed")</code>

<img src="https://therinspark.com/images/modeling-okc-glr-coefs-resized.png" />

FIGURE 4.9: Coefficient estimates with 95% confidence intervals

<strong>Note:</strong> Both <code>ml_logistic_regression()</code> and <code>ml_linear_regression()</code> support elastic net regularization through the <code>reg_param</code> and <code>elastic_net_param</code> parameters. 
<code>reg_param</code> corresponds to \(\lambda\), whereas <code>elastic_net_param</code> corresponds to \(\alpha\). 
<code>ml_generalized_linear_regression()</code> supports only <code>reg_param</code>.

<h3>4.4.2 Other Models</h3>
Spark supports many of the standard modeling algorithms and it’s easy to apply these models and hyperparameters (values that control the model-fitting process) for your particular problem. 
You can find a list of supported ML-related functions in the appendix. 
The interfaces to access these functionalities are largely identical, so it is easy to experiment with them. 
For example, to fit a neural network model we can run the following:
<code>nn &lt;- ml_multilayer_perceptron_classifier(
  analysis_set,
  not_working ~ scaled_age + sex + drinks + drugs + essay_length, 
  layers = c(12, 64, 64, 2)
)</code>
This gives us a feedforward neural network model with two hidden layers of 64 nodes each. 
Note that you have to specify the correct values for the input and output layers in the <code>layers</code> argument. 
We can obtain predictions on a validation set using <code>ml_predict()</code>:
<code>predictions &lt;- ml_predict(nn, assessment_set)</code>
Then, we can compute the AUC via <code>ml_binary_classification_evaluator()</code>:
<code>ml_binary_classification_evaluator(predictions)</code>
<code>[1] 0.7812709</code>
Up until now, we have not looked into the unstructured text in the essay fields apart from doing simple character counts. 
In the next section, we explore the textual data in more depth.

<h2>4.5 Unsupervised Learning</h2>
Along with speech, images, and videos, textual data is one of the components of the big data explosion. 
Prior to modern text-mining techniques and the computational resources to support them, companies had little use for freeform text fields. 
Today, text is considered a rich source of insights that can be found anywhere from physician’s notes to customer complaints. 
In this section, we show some basic text analysis capabilities of <code>sparklyr</code>. 
If you would like more background on text-mining techniques, we recommend reading <em>Text Mining with R</em> by David Robinson and Julie Silge (O’Reilly).
In this section, we show how to perform a basic topic-modeling task on the essay data in the <code>OKCupid</code> dataset. 
Our plan is to concatenate the essay fields (of which there are 10) of each profile and regard each profile as a document, then attempt to discover <em>topics</em> (we define these soon) using Latent Dirichlet Allocation (LDA).

<h3>4.5.1 Data Preparation</h3>
As always, before analyzing a dataset (or a subset of one), we want to take a quick look at it to orient ourselves. 
In this case, we are interested in the freeform text that the users entered into their dating profiles.
<code>essay_cols &lt;- paste0("essay", 0:9)
essays &lt;- okc %>%
  select(!!essay_cols)
essays %>% 
  glimpse()</code>
<code>Observations: ??
Variables: 10
Database: spark_connection
$ essay0 &lt;chr> "about me:&lt;br />\n&lt;br />\ni would love to think that…
$ essay1 &lt;chr> "currently working as an international agent for a f…
$ essay2 &lt;chr> "making people laugh.&lt;br />\nranting about a good sa…
$ essay3 &lt;chr> "the way i look. 
i am a six foot half asian, half ca…
$ essay4 &lt;chr> "books:&lt;br />\nabsurdistan, the republic, of mice an…
$ essay5 &lt;chr> "food.&lt;br />\nwater.&lt;br />\ncell phone.&lt;br />\nshelt…
$ essay6 &lt;chr> "duality and humorous things", "missing", "missing",…
$ essay7 &lt;chr> "trying to find someone to hang out with. 
i am down …
$ essay8 &lt;chr> "i am new to california and looking for someone to w…
$ essay9 &lt;chr> "you want to be swept off your feet!&lt;br />\nyou are …</code>
Just from this output, we see the following:
<ul>
<li>The text contains HTML tags</li>
<li>The text contains the newline (<code>\n</code>) character</li>
<li>There are missing values in the data</li>
</ul>
The HTML tags and special characters pollute the data since they are not directly input by the user and do not provide interesting information. 
Similarly, since we have encoded missing character fields with the <em>missing</em> string, we need to remove it. 
(Note that by doing this we are also removing instances of the word “missing” written by the users, but the information lost from this removal is likely to be small.)
As you analyze your own text data, you will quickly come across and become familiar with the peculiarities of the specific dataset. 
As with tabular numerical data, preprocessing text data is an iterative process, and after a few tries we have the following transformations:
<code>essays &lt;- essays %>%
  # Replace `missing` with empty string.
  mutate_all(list(~ ifelse(. 
== "missing", ", .))) %>%
  # Concatenate the columns.
  mutate(essay = paste(!!!syms(essay_cols))) %>%
  # Remove miscellaneous characters and HTML tags
  mutate(words = regexp_replace(essay, "\\n|&amp;nbsp;|&lt;[^>]*>|[^A-Za-z|&#39;]", " "))</code>
Note here we are using <code>regex_replace()</code>, which is a Spark SQL function. 
Next, we discuss LDA and how to apply it to our cleaned dataset.

<h3>4.5.2 Topic Modeling</h3>
LDA is a type of topic model for identifying abstract “topics” in a set of documents. 
It is an unsupervised algorithm in that we do not provide any labels, or topics, for the input documents. 
LDA posits that each document is a mixture of topics, and each topic is a mixture of words. 
During training, it attempts to estimate both of these simultaneously. 
A typical use case for topic models involves categorizing many documents, for which the large number of documents renders manual approaches infeasible. 
The application domains range from GitHub issues to legal documents.
After we have a reasonably clean dataset following the workflow in the previous section, we can fit an LDA model with <code>ml_lda()</code>:
<code>stop_words &lt;- ml_default_stop_words(sc) %>%
  c(
    "like", "love", "good", "music", "friends", "people", "life",
    "time", "things", "food", "really", "also", "movies"
  )

lda_model &lt;-  ml_lda(essays, ~ words, k = 6, max_iter = 1, min_token_length = 4, 
                     stop_words = stop_words, min_df = 5)</code>
We are also including a <code>stop_words</code> vector, consisting of commonly used English words and common words in our dataset, that instructs the algorithm to ignore them. 
After the model is fit, we can use the <code>tidy()</code> function to extract the associated betas, which are the per-topic-per-word probabilities, from the model.
<code>betas &lt;- tidy(lda_model)
betas</code>
<code># A tibble: 256,992 x 3
   topic term      beta
   &lt;int> &lt;chr>    &lt;dbl>
 1     0 know      303.
 2     0 work      250.
 3     0 want      367.
 4     0 books     211.
 5     0 family    213.
 6     0 think     291.
 7     0 going     160.
 8     0 anything  292.
 9     0 enjoy     145.
10     0 much      272.
# … with 256,982 more rows</code>
We can then visualize this output by looking at word probabilities by topic. 
In Figure 4.10 and Figure 4.11, we show the results at 1 iteration and 100 iterations. 
The code that generates Figure 4.10 follows; to generate Figure 4.11, you would need to set <code>max_iter = 100</code> when running <code>ml_lda()</code>, but beware that this can take a really long time in a single machine—this is the kind of big-compute problem that a proper Spark cluster would be able to easily tackle.
<code>betas %>%
  group_by(topic) %>%
  top_n(10, beta) %>%
  ungroup() %>%
  arrange(topic, -beta) %>%
  mutate(term = reorder(term, beta)) %>%
  ggplot(aes(term, beta, fill = factor(topic))) +
    geom_col(show.legend = FALSE) +
    facet_wrap(~ topic, scales = "free") +
    coord_flip()</code>

<img src="https://therinspark.com/images/modeling-okc-betas-topics-1-resized.png" />

FIGURE 4.10: The most common terms per topic in the first iteration

At 100 iterations, we can see “topics” starting to emerge. 
This could be interesting information in its own right if you were digging into a large collection of documents with which you aren’t familiar. 
The learned topics can also serve as features in a downstream supervised learning task; for example, we could consider using the topic number as a predictor in our model to predict employment status in our predictive modeling example.

<img src="https://therinspark.com/images/modeling-okc-betas-topics-100-resized.png" />

FIGURE 4.11: The most common terms per topic after 100 iterations

Finally, to conclude this chapter you should disconnect from Spark. 
Chapter 5 also makes use of the <code>OKCupid</code> dataset, but we provide instructions to reload it from scratch:
<code>spark_disconnect(sc)</code>

<h2>4.6 Recap</h2>
In this chapter, we covered the basics of building predictive models in Spark with R by presenting the topics of EDA, feature engineering, and building supervised models, in which we explored using logistic regression and neural networks—just to pick a few from dozens of models available in Spark through <code>MLlib</code>.
We then explored how to use unsupervised learning to process raw text, in which you created a topic model that automatically grouped the profiles into six categories. 
We demonstrated that building the topic model can take a significant amount of time using a single machine, which is a nearly perfect segue to introduce full-sized computing clusters! But hold that thought: we first need to consider how to automate data science workflows.
As we mentioned when introducing this chapter, emphasis was placed on predictive modeling. 
Spark can help with data science at scale, but it can also assist in productionizing data science workflows into automated processes, known by many as machine learning. 
Chapter 5 presents the tools we will need to take our predictive models, and even our entire training workflows, into automated environments that can run continuously or be exported and consumed in web applications, mobile applications, and more.

<h2><span class="orange">Chapter 5 Pipelines</span></h2>
In Chapter 4, you learned how to build predictive models using the high-level functions Spark provides and well-known R packages that work well together with Spark. 
You learned about supervised methods first and finished the chapter with an unsupervised method over raw text.
In this chapter, we dive into Spark Pipelines, which is the engine that powers the features we demonstrated in Chapter 5. 
So, for instance, when you invoke an <code>MLlib</code> function via the formula interface in R—for example, <code>ml_logistic_regression(cars, am ~ .)</code>—a <em>pipeline</em> is constructed for you under the hood. 
Therefore, Pipelines(((“pipelines”, “purpose of”))) also allow you to make use of advanced data processing and modeling workflows. 
In addition, a pipeline also facilitates collaboration across data science and engineering teams by allowing you to <em>deploy</em> pipelines into production systems, web applications, mobile applications, and so on.
This chapter also happens to be the last chapter that encourages using your local computer as a Spark cluster. 
You are just one chapter away from getting properly introduced to cluster computing and beginning to perform data science or machine learning that can scale to the most demanding computation problems.

<h2>5.1 Overview</h2>
The building blocks of pipelines are objects called <em>transformers</em> and <em>estimators</em>, which are collectively referred to as <em>pipeline stages</em>. 
A <em>transformer</em> can be used to apply transformations to a DataFrame and return another DataFrame; the resulting DataFrame often comprises the original DataFrame with new columns appended to it. 
An <em>estimator</em>, on the other hand, can be used to create a transformer giving some training data. 
Consider the following example to illustrate this relationship: a “center and scale” estimator can learn the mean and standard deviation of some data and store the statistics in a resulting transformer object; this transformer can then be used to normalize the data that it was trained on and also any new, yet unseen, data.
Here is an example of how to define an estimator:
<code>library(sparklyr)
library(dplyr)

sc &lt;- spark_connect(master = "local", version = "2.3")

scaler &lt;- ft_standard_scaler(
  sc,
  input_col = "features",
  output_col = "features_scaled",
  with_mean = TRUE)

scaler</code>
<code>StandardScaler (Estimator)
&lt;standard_scaler_7f6d46f452a1> 
 (Parameters -- Column Names)
  input_col: features
  output_col: features_scaled
 (Parameters)
  with_mean: TRUE
  with_std: TRUE</code>
We can now create some data (for which we know the mean and standard deviation) and then fit our scaling model to it using the <code>ml_fit()</code> function:
<code>df &lt;- copy_to(sc, data.frame(value = rnorm(100000))) %>% 
  ft_vector_assembler(input_cols = "value", output_col = "features")

scaler_model &lt;- ml_fit(scaler, df)
scaler_model</code>
<code>StandardScalerModel (Transformer)
&lt;standard_scaler_7f6d46f452a1> 
 (Parameters -- Column Names)
  input_col: features
  output_col: features_scaled
 (Transformer Info)
  mean:  num 0.00421 
  std:  num 0.999 </code>
<strong>Note:</strong> In Spark ML, many algorithms and feature transformers require that the input be a vector column. 
The function <code>ft_vector_assembler()</code> performs this task. 
You can also use the function to initialize a transformer to be used in a pipeline.
We see that the mean and standard deviation are very close to 0 and 1, respectively, which is what we expect. 
We then can use the transformer to <em>transform</em> a DataFrame, using the <code>ml_transform()</code> function:
<code>scaler_model %>% 
  ml_transform(df) %>%
  glimpse()</code>
<code>Observations: ??
Variables: 3
Database: spark_connection
$ value           &lt;dbl> 0.75373300, -0.84207731, 0.59365113, -…
$ features        &lt;list> [0.753733, -0.8420773, 0.5936511, -0.…
$ features_scaled &lt;list> [0.7502211, -0.8470762, 0.58999, -0.4…</code>
Now that you’ve seen basic examples of estimators and transformers, we can move on to pipelines.

<h2>5.2 Creation</h2>
A <em>pipeline</em> is simply a sequence of transformers and estimators, and a <em>pipeline model</em> is a pipeline that has been trained on data so all of its components have been converted to transformers.
There are a couple of ways to construct a pipeline in <code>sparklyr</code>, both of which use the <code>ml_pipeline()</code> function.
We can initialize an empty pipeline with <code>ml_pipeline(sc)</code> and append stages to it:
<code>ml_pipeline(sc) %>% 
  ft_standard_scaler(
    input_col = "features",
    output_col = "features_scaled", 
    with_mean = TRUE)</code>
<code>Pipeline (Estimator) with 1 stage
&lt;pipeline_7f6d6a6a38ee> 
  Stages 
  |--1 StandardScaler (Estimator)
  |    &lt;standard_scaler_7f6d63bfc7d6> 
  |     (Parameters -- Column Names)
  |      input_col: features
  |      output_col: features_scaled
  |     (Parameters)
  |      with_mean: TRUE
  |      with_std: TRUE</code>
Alternatively, we can pass stages directly to <code>ml_pipeline()</code>:
<code>pipeline &lt;- ml_pipeline(scaler)</code>
We fit a pipeline as we would fit an estimator:
<code>pipeline_model &lt;- ml_fit(pipeline, df)
pipeline_model</code>
<code>PipelineModel (Transformer) with 1 stage
&lt;pipeline_7f6d64df6e45> 
  Stages 
  |--1 StandardScalerModel (Transformer)
  |    &lt;standard_scaler_7f6d46f452a1> 
  |     (Parameters -- Column Names)
  |      input_col: features
  |      output_col: features_scaled
  |     (Transformer Info)
  |      mean:  num 0.00421 
  |      std:  num 0.999 </code>
<code>pipeline </code>
<strong>Note:</strong> As a result of the design of Spark ML, pipelines are always estimator objects, even if they comprise only transformers. 
This means that if you have a pipeline with only transformers, you still need to call <code>ml_fit()</code> on it to obtain a transformer. 
The “fitting” procedure in this case wouldn’t actually modify any of the transformers.

<h2>5.3 Use Cases</h2>
Now that you have an understanding of the rudimentary concepts for ML Pipelines, let’s apply them to the predictive modeling problem from the previous chapter in which we are trying to predict whether people are currently employed by looking at their profiles. 
Our starting point is the <code>okc_train</code> DataFrame with the relevant columns.
<code>okc_train &lt;- spark_read_parquet(sc, "data/okc-train.parquet")

okc_train &lt;- okc_train %>% 
  select(not_working, age, sex, drinks, drugs, essay1:essay9, essay_length)</code>
We first exhibit the pipeline, which includes feature engineering and modeling steps, and then walk through it:
<code>pipeline &lt;- ml_pipeline(sc) %>%
  ft_string_indexer(input_col = "sex", output_col = "sex_indexed") %>%
  ft_string_indexer(input_col = "drinks", output_col = "drinks_indexed") %>%
  ft_string_indexer(input_col = "drugs", output_col = "drugs_indexed") %>%
  ft_one_hot_encoder_estimator(
    input_cols = c("sex_indexed", "drinks_indexed", "drugs_indexed"),
    output_cols = c("sex_encoded", "drinks_encoded", "drugs_encoded")
  ) %>%
  ft_vector_assembler(
    input_cols = c("age", "sex_encoded", "drinks_encoded", 
                   "drugs_encoded", "essay_length"), 
    output_col = "features"
  ) %>%
  ft_standard_scaler(input_col = "features", output_col = "features_scaled", 
                     with_mean = TRUE) %>%
  ml_logistic_regression(features_col = "features_scaled", 
                         label_col = "not_working")</code>
The first three stages index the <code>sex</code>, <code>drinks</code>, and <code>drugs</code> columns, which are characters, into numeric indices via <code>ft_string_indexer()</code>. 
This is necessary for the <code>ft_one_hot_encoder_estimator()</code> that comes next, which requires numeric column inputs. 
When all of our predictor variables are of numeric type (recall that <code>age</code> is numeric already), we can create our features vector using <code>ft_vector_assembler()</code>, which concatenates all of its inputs together into one column of vectors. 
We can then use <code>ft_standard_scaler()</code> to normalize all elements of the features column (including the one-hot-encoded 0/1 values of the categorical variables), and finally apply a logistic regression via <code>ml_logistic_regression()</code>.
During prototyping, you might want to execute these transformations <em>eagerly</em> on a small subset of the data, by passing the DataFrame to the <code>ft_</code> and <code>ml_</code> functions, and inspecting the transformed DataFrame. 
The immediate feedback allows for rapid iteration of ideas; when you have arrived at the desired processing steps, you can roll them up into a pipeline. 
For example, you can do the following:
<code>okc_train %>%
  ft_string_indexer("sex", "sex_indexed") %>% 
  select(sex_indexed)</code>
<code># Source: spark&lt;?> [?? x 1]
   sex_indexed
         &lt;dbl>
 1           0
 2           0
 3           1
 4           0
 5           1
 6           0
 7           0
 8           1
 9           1
10           0
# … with more rows</code>
After you have found the appropriate transformations for your dataset, you can replace the DataFrame input with <code>ml_pipeline(sc)</code>, and the result will be a pipeline that you can apply to any DataFrame with the appropriate schema. 
In the next section, we’ll see how pipelines can make it easier for us to test different model specifications.

<h3>5.3.1 Hyperparameter Tuning</h3>
Going back to the pipeline we have created earlier, we can use <code>ml_cross_validator()</code> to perform the cross-validation workflow we demonstrated in the previous chapter and easily test different hyperparameter combinations. 
In this example, we test whether centering the variables improves predictions together with various regularization values for the logistic regression. 
We define the cross-validator as follows:
<code>cv &lt;- ml_cross_validator(
  sc,
  estimator = pipeline,
  estimator_param_maps = list(
    standard_scaler = list(with_mean = c(TRUE, FALSE)),
    logistic_regression = list(
      elastic_net_param = c(0.25, 0.75),
      reg_param = c(1e-2, 1e-3)
    )
  ),
  evaluator = ml_binary_classification_evaluator(sc, label_col = "not_working"),
  num_folds = 10)</code>
The <code>estimator</code> argument is simply the estimator that we want to tune, and in this case it is the <code>pipeline</code> that we defined. 
We provide the hyperparameter values we are interested in via the <code>estimator_param_maps</code> parameter, which takes a nested named list. 
The names at the first level correspond to UIDs, which are unique identifiers associated with each pipeline stage object, of the stages we want to tune (if a partial UID is provided, <code>sparklyr</code> will attempt to match it to a pipeline stage), and the names at the second level correspond to parameters of each stage. 
In the preceding snippet, we are specifying that we want to test the following:

<dt>Standard scaler</dt>
The values <code>TRUE</code> and <code>FALSE</code> for <code>with_mean</code>, which denotes whether predictor values are centered.

<dt>Logistic regression</dt>
The values <code>0.25</code> and <code>0.75</code> for \(\alpha\), and the values <code>1e-2</code> and <code>1e-3</code> for \(\lambda\).

We expect this to give rise to \(2 \times 2 \times 2 = 8\) hyperparameter combinations, which we can confirm by printing the <code>cv</code> object:
<code>cv</code>
<code>CrossValidator (Estimator)
&lt;cross_validator_d5676ac6f5> 
 (Parameters -- Tuning)
  estimator: Pipeline
             &lt;pipeline_d563b0cba31> 
  evaluator: BinaryClassificationEvaluator
             &lt;binary_classification_evaluator_d561d90b53d> 
    with metric areaUnderROC 
  num_folds: 10 
  [Tuned over 8 hyperparameter sets]</code>
As with any other estimator, we can fit the cross-validator by using <code>ml_fit()</code>
<code>cv_model &lt;- ml_fit(cv, okc_train)</code>
and then inspect the results:
<code>ml_validation_metrics(cv_model) %>%
  arrange(-areaUnderROC)</code>
<code>  areaUnderROC elastic_net_param_1 reg_param_1 with_mean_2
1    0.7722700                0.75       0.001        TRUE
2    0.7718431                0.75       0.010       FALSE
3    0.7718350                0.75       0.010        TRUE
4    0.7717677                0.25       0.001        TRUE
5    0.7716070                0.25       0.010        TRUE
6    0.7715972                0.25       0.010       FALSE
7    0.7713816                0.75       0.001       FALSE
8    0.7703913                0.25       0.001       FALSE</code>
Now that we have seen the pipelines API in action, let’s talk more formally about how they behave in various contexts.

<h2>5.4 Operating Modes</h2>
By now, you have likely noticed that the pipeline stage functions, such as <code>ft_string_indexer()</code> and <code>ml_logistic_regression()</code>, return different types of objects depending on the first argument passed to them. 
Table 5.1 presents the full pattern.
<table>
<caption>TABLE 5.1: Operating modes in machine learning functions.</caption>
<thead>
<tr><th align="left">First.argument</th><th align="left">Returns</th><th align="left">Example</th></tr>
</thead>
<tbody>
<tr><td align="left">Spark connection</td><td align="left">Estimator or transformer object</td><td align="left">ft_string_indexer(sc)</td></tr>
<tr><td align="left">Pipeline</td><td align="left">Pipeline</td><td align="left">ml_pipeline(sc) %>% ft_string_indexer()</td></tr>
<tr><td align="left">Data frame, without formula</td><td align="left">Data frame</td><td align="left">ft_string_indexer(iris, “Species”, “indexed”)</td></tr>
<tr><td align="left">Data frame, with formula</td><td align="left">sparklyr ML model object</td><td align="left">ml_logistic_regression(iris, Species ~ .)</td></tr>
</tbody>
</table>
These functions are implemented using S3, which is the most popular object-oriented programming paradigm provided by R. 
For our purposes, it suffices to know that the behavior of an <code>ml_</code> or <code>ft_</code> function is dictated by the class of the first argument provided. 
This allows us to provide a wide range of features without introducing additional function names. 
We now can summarize the behavior of these functions:
<ul>
<li>If a Spark connection is provided, the function returns a transformer or estimator object, which can be utilized directly using <code>ml_fit()</code> or <code>ml_transform()</code> or be included in a pipeline.</li>
<li>If a pipeline is provided, the function returns a pipeline object with the stage appended to it.</li>
<li>If a DataFrame is provided to a feature transformer function (those with prefix <code>ft_</code>), or an ML algorithm without also providing a formula, the function instantiates the pipeline stage object, fits it to the data if necessary (if the stage is an estimator), and then transforms the DataFrame returning a DataFrame.</li>
<li>If a DataFrame and a formula are provided to an ML algorithm that supports the formula interface, <code>sparklyr</code> builds a pipeline model under the hood and returns an ML model object that contains additional metadata information.</li>
</ul>
The formula interface approach is what we studied in Chapter 5, and this is what we recommend users new to Spark start with, since its syntax is similar to existing R modeling packages and abstracts away some Spark ML peculiarities. 
However, to take advantage of the full power of Spark ML and leverage pipelines for workflow organization and interoperability, it is worthwhile to learn the ML Pipelines API.
With the basics of pipelines down, we are now ready to discuss the collaboration and model deployment aspects hinted at in the introduction of this chapter.

<h2>5.5 Interoperability</h2>
One of the most powerful aspects of pipelines is that they can be serialized to disk and are fully interoperable with the other Spark APIs such as Python and Scala. 
This means that you can easily share them among users of Spark working in different languages, which might include other data scientists, data engineers, and deployment engineers. 
To save a pipeline model, call <code>ml_save()</code> and provide a path:
<code>model_dir &lt;- file.path("spark_model")
ml_save(cv_model$best_model, model_dir, overwrite = TRUE)</code>
<code>Model successfully saved.</code>
Let’s take a look at the directory to which we just wrote:
<code>list.dirs(model_dir,full.names = FALSE) %>%
  head(10)</code>
<code> [1] "                                             
 [2] "metadata"                                     
 [3] "stages"                                       
 [4] "stages/0_string_indexer_5b42c72817b"          
 [5] "stages/0_string_indexer_5b42c72817b/data"     
 [6] "stages/0_string_indexer_5b42c72817b/metadata" 
 [7] "stages/1_string_indexer_5b423192b89f"         
 [8] "stages/1_string_indexer_5b423192b89f/data"    
 [9] "stages/1_string_indexer_5b423192b89f/metadata"
[10] "stages/2_string_indexer_5b421796e826"    </code>
We can dive into a couple of the files to see what type of data was saved:
<code>spark_read_json(sc, file.path(
  file.path(dir(file.path(model_dir, "stages"),
                pattern = "1_string_indexer.*",
                full.names = TRUE), "metadata")
)) %>% 
  glimpse()</code>
<code>Observations: ??
Variables: 5
Database: spark_connection
$ class        &lt;chr> "org.apache.spark.ml.feature.StringIndexerModel"
$ paramMap     &lt;list> [["error", "drinks", "drinks_indexed", "frequencyDesc"]]
$ sparkVersion &lt;chr> "2.3.2"
$ timestamp    &lt;dbl> 1.561763e+12
$ uid          &lt;chr> "string_indexer_ce05afa9899"</code>
<code>spark_read_parquet(sc, file.path(
  file.path(dir(file.path(model_dir, "stages"),
                pattern = "6_logistic_regression.*",
                full.names = TRUE), "data")
))</code>
<code># Source: spark&lt;data> [?? x 5]
  numClasses numFeatures interceptVector coefficientMatr… isMultinomial
       &lt;int>       &lt;int> &lt;list>          &lt;list>           &lt;lgl>        
1          2          12 &lt;dbl [1]>       &lt;-1.27950828662… FALSE        </code>
We see that quite a bit of information has been exported, from the SQL statement in the <code>dplyr</code> transformer to the fitted coefficient estimates of the logistic regression. 
We can then (in a new Spark session) reconstruct the model by using <code>ml_load()</code>:
<code>model_reload &lt;- ml_load(sc, model_dir)</code>
Let’s see if we can retrieve the logistic regression stage from this pipeline model:
<code>ml_stage(model_reload, "logistic_regression")</code>
<code>LogisticRegressionModel (Transformer)
&lt;logistic_regression_5b423b539d0f> 
 (Parameters -- Column Names)
  features_col: features_scaled
  label_col: not_working
  prediction_col: prediction
  probability_col: probability
  raw_prediction_col: rawPrediction
 (Transformer Info)
  coefficient_matrix:  num [1, 1:12] -1.2795 -0.0915 0 0.126 -0.0324 ... 

  coefficients:  num [1:12] -1.2795 -0.0915 0 0.126 -0.0324 ... 

  intercept:  num -2.79 
  intercept_vector:  num -2.79 
  num_classes:  int 2 
  num_features:  int 12 
  threshold:  num 0.5 
  thresholds:  num [1:2] 0.5 0.5 </code>
Note that the exported JSON and parquet files are agnostic of the API that exported them. 
This means that in a multilingual machine learning engineering team, you can pick up a data preprocessing pipeline from a data engineer working in Python, build a prediction model on top of it, and then hand off the final pipeline to a deployment engineering working in Scala. 
In the next section, we discuss deployment of models in more detail.
<strong>Note:</strong> When <code>ml_save()</code> is called for <code>sparklyr</code> ML models (created using the formula interface), the associated pipeline model is saved, but any <code>sparklyr</code>-specific metadata, such as index labels, is not. 
In other words, saving a <code>sparklyr</code> <code>ml_model</code> object and then loading it will yield a pipeline model object, as if you created it via the ML Pipelines API. 
This behavior is required to use pipelines with other programming languages.
Before we move on to discuss how to run pipelines in production, make sure you disconnect from Spark:
<code>spark_disconnect(sc)</code>
That way, we can start from a brand new environment, which is also expected when you are deploying pipelines to production.

<h2>5.6 Deployment</h2>
What we have just demonstrated bears emphasizing: by collaborating within the framework of ML Pipelines, we reduce friction among different personas in a data science team. 
In particular, we cut down on the time from modeling to deployment.
In many cases, a data science project does not end with just a slide deck with insights and recommendations. 
Instead, the business problem at hand might require scoring new data points on a schedule or on-demand in real time. 
For example, a bank might want to evaluate its mortgage portfolio risk nightly or provide instant decisions on credit card applications. 
This process of taking a model and turning it into a service that others can consume is usually referred to as <em>deployment</em> or <em>productionization</em>. 
Historically, there was a large gap between the analyst who built the model and the engineer who deployed it: the former might work in R and develop extensive documentation on the scoring mechanism, so that the latter can reimplement the model in C++ or Java. 
This practice, which might easily take months in some organizations, is less prevalent today, but is almost always unnecessary in Spark ML workflows.
The aforementioned nightly portfolio risk and credit application scoring examples represent two modes of ML deployment known as <em>batch</em> and <em>real time</em>. 
Loosely, batch processing implies processing many records at the same time, and that execution time is not important as long it is reasonable (often on the scale of minutes to hours). 
On the other hand, real-time processing implies scoring one or a few records at a time, but the latency is crucial (on the scale of &lt;1 second). 
Let’s turn now to see how we can take our <code>OKCupid</code> pipeline model to “production”.

<h3>5.6.1 Batch Scoring</h3>
For both scoring methods, batch and real time, we will expose our model as web services, in the form of an API over the Hypertext Transfer Protocol (HTTP). 
This is the primary medium over which software communicates. 
By providing an API, other services or end users can utilize our model without any knowledge of R or Spark. 
The <code>plumber</code> R package enables us to do this very easily by annotating our prediction function.
You will need make sure that <code>plumber</code>, <code>callr</code>, and the <code>httr</code> package are installed by running the following:
<code>install.packages(c("plumber", "callr", "httr"))</code>
The <code>callr</code> package provides support to run R code in separate R sessions; it is not strictly required, but we will use it to start a web service in the background. 
The <code>httr</code> package allows us to use web APIs from R.
In the batch scoring use case, we simply initiate a Spark connection and load the saved model. 
Save the following script as <em>plumber/spark-plumber.R</em>:
<code>library(sparklyr)
sc &lt;- spark_connect(master = "local", version = "2.3")

spark_model &lt;- ml_load(sc, "spark_model")

#* @post /predict
score_spark &lt;- function(age, sex, drinks, drugs, essay_length) {
  new_data &lt;- data.frame(
    age = age,
    sex = sex,
    drinks = drinks,
    drugs = drugs,
    essay_length = essay_length,
    stringsAsFactors = FALSE
  )
  new_data_tbl &lt;- copy_to(sc, new_data, overwrite = TRUE)
  
  ml_transform(spark_model, new_data_tbl) %>%
    dplyr::pull(prediction)
}</code>
We can then initialize the service by executing the following:
<code>service &lt;- callr::r_bg(function() {
  p &lt;- plumber::plumb("plumber/spark-plumber.R")
  p$run(port = 8000)
})</code>
This starts the web service locally, and then we can query the service with new data to be scored; however, you might need to wait a few seconds for the Spark service to initialize:
<code>httr::content(httr::POST(
  "http://127.0.0.1:8000/predict",
  body = &#39;{"age": 42, "sex": "m", "drinks": "not at all", 
           "drugs": "never", "essay_length": 99}&#39;
))</code>
<code>[[1]]
[1] 0</code>
This reply tell us that this particular profile is likely to not be unemployed, that is, employed. 
We can now terminate the <code>plumber</code> service by stopping the <code>callr</code> service:
<code>service$interrupt()</code>
If we were to time this operation (e.g., with <code>system.time()</code>), we see that the latency is on the order of hundreds of milliseconds, which might be appropriate for batch applications but is insufficient for real time. 
The main bottleneck is the serialization of the R DataFrame to a Spark DataFrame and back. 
Also, it requires an active Spark session, which is a heavy runtime requirement. 
To ameliorate these issues, we discuss next a deployment method more suitable for real-time deployment.

<h3>5.6.2 Real-Time Scoring</h3>
For real-time production, we want to keep dependencies as light as possible so we can target more platforms for deployment. 
We now show how we can use the <code>mleap</code> package, which provides an interface to the MLeap library, to serialize and serve Spark ML models. 
MLeap is open source (Apache License 2.0) and supports a wide range of, though not all, Spark ML transformers. 
At runtime, the only prerequisites for the environment are the Java Virtual Machine (JVM) and the MLeap runtime library. 
This avoids both the Spark binaries and expensive overhead in converting data to and from Spark DataFrames.
Since <code>mleap</code> is a <code>sparklyr</code> extension and an R package, first we need to install it from CRAN:
<code>install.packages("mleap")</code>
It then must be loaded when <code>spark_connect()</code> is called; so let’s restart your R session, establish a new Spark connection, and load the pipeline model that we previously saved:
<code>library(sparklyr)
library(mleap)</code>
<code>sc &lt;- spark_connect(master = "local", version = "2.3")</code>
<code>spark_model &lt;- ml_load(sc, "spark_model")</code>
The way we save a model to MLeap bundle format is very similar to saving a model using the Spark ML Pipelines API; the only additional argument is <code>sample_input</code>, which is a Spark DataFrame with schema that we expect new data to be scored to have:
<code>sample_input &lt;- data.frame(
  sex = "m",
  drinks = "not at all",
  drugs = "never",
  essay_length = 99,
  age = 25,
  stringsAsFactors = FALSE
)

sample_input_tbl &lt;- copy_to(sc, sample_input)

ml_write_bundle(spark_model, sample_input_tbl, "mleap_model.zip", overwrite = TRUE)</code>
We can now deploy the artifact we just created, <em>mleap_model.zip</em>, in any device that runs Java and has the open source MLeap runtime dependencies, without needing Spark or R! In fact, we can go ahead and disconnect from Spark already:
<code>spark_disconnect(sc)</code>
Before we use this MLeap model, make sure the runtime dependencies are installed:
<code>mleap::install_maven()
mleap::install_mleap()</code>
To test this model, we can create a new plumber API to expose it. 
The script <em>plumber/mleap-plumber.R</em> is very similar to the previous example:
<code>library(mleap)

mleap_model &lt;- mleap_load_bundle("mleap_model.zip")

#* @post /predict
score_spark &lt;- function(age, sex, drinks, drugs, essay_length) {
  new_data &lt;- data.frame(
    age = as.double(age),
    sex = sex,
    drinks = drinks,
    drugs = drugs,
    essay_length = as.double(essay_length),
    stringsAsFactors = FALSE
  )
  mleap_transform(mleap_model, new_data)$prediction
}</code>
And the way we launch the service is exactly the same:
<code>service &lt;- callr::r_bg(function() {
  p &lt;- plumber::plumb("plumber/mleap-plumber.R")
  p$run(port = 8000)
})</code>
We can run the exact same code we did previously to test unemployment predictions in this new service:
<code>httr::POST(
  "http://127.0.0.1:8000/predict",
  body = &#39;{"age": 42, "sex": "m", "drinks": "not at all", 
           "drugs": "never", "essay_length": 99}&#39;
) %>%
  httr::content()</code>
<code>[[1]]
[1] 0</code>
If we were to time this operation, we would see that the service now returns predictions in tens of milliseconds.
Let’s stop this service and then wrap up this chapter:
<code>service$interrupt()</code>

<h2>5.7 Recap</h2>
In this chapter, we discussed Spark Pipelines, which is the engine behind the modeling functions introduced in Chapter 4. 
You learned how to tidy up your predictive modeling workflows by organizing data processing and modeling algorithms into pipelines. 
You learned that pipelines also facilitate collaboration among members of a multilingual data science and engineering team by sharing a language-agnostic serialization format—you can export a Spark pipeline from R and let others reload your pipeline into Spark using Python or Scala, which allows them to collaborate without changing their language of choice.
You also learned how to deploy pipelines using <code>mleap</code>, a Java runtime that provides another path to productionize Spark models—you can export a pipeline and integrate it to Java-enabled environments without requiring the target environment to support Spark or R.
You probably noticed that some algorithms, especially the unsupervised learning kind, were slow, even for the <code>OKCupid</code> dataset, which can be loaded into memory. 
If we had access to a proper Spark cluster, we could spend more time modeling and less time waiting! Not only that, but we could use cluster resources to run broader hyperparameter-tuning jobs and process large datasets. 
To get there, Chapter 6 presents what exactly a computing cluster is and explains the various options you can consider, like building your own or using cloud clusters on demand.

<h2><span class="orange">Chapter 6 Clusters</span></h2>
Previous chapters focused on using Spark over a single computing instance, your personal computer. 
In this chapter, we introduce techniques to run Spark over multiple computing instances, also known as a <em>computing</em> cluster. 
This chapter and subsequent ones will introduce and make use of concepts applicable to computing clusters; however, it’s not required to use a computing cluster to follow along, so you can still use your personal computer. 
It’s worth mentioning that while previous chapters focused on single computing instances, you can also use all the data analysis and modeling techniques we presented in a computing cluster without changing any code.
If you already have a Spark cluster in your organization, you could consider skipping to Chapter 7, which teaches you how to connect to an existing cluster. 
Otherwise, if you don’t have a cluster or are considering improvements to your existing infrastructure, this chapter introduces the cluster trends, managers, and providers available today.

<h2>6.1 Overview</h2>
There are three major trends in cluster computing worth discussing: <em>on-premises</em>, <em>cloud</em> computing, and <em>Kubernetes</em>. 
Framing these trends over time will help us understand how they came to be, what they are, and what their future might be. 
To illustrate this, Figure 6.1 plots these trends over time using data from Google trends.
For on-premises clusters, you or someone in your organization purchased physical computers that were intended to be used for cluster computing. 
The computers in this cluster are made of <em>off-the-shelf</em> hardware, meaning that someone placed an order to purchase computers usually found on store shelves, or <em>high-performance</em> hardware, meaning that a computing vendor provided highly customized computing hardware, which also comes optimized for high-performance network connectivity, power consumption, and so on.

<img src="https://therinspark.com/images/clusters-trends-resized.png" />

FIGURE 6.1: Google trends for on-premises (mainframe), cloud computing, and Kubernetes

When purchasing hundreds or thousands of computing instances, it doesn’t make sense to keep them in the usual computing case that we are all familiar with; instead, it makes sense to stack them as efficiently as possible on top of one another to minimize the space the use. 
This group of efficiently stacked computing instances is known as a <em>rack</em>. 
After a cluster grows to thousands of computers, you will also need to host hundreds of racks of computing devices; at this scale, you would also need significant physical space to host those racks.
A building that provides racks of computing instances is usually known as a <em>datacenter</em>. 
At the scale of a datacenter, you would also need to find ways to make the building more efficient, especially the cooling system, power supplies, network connectivity, and so on. 
Since this is time-consuming, a few organizations have come together to open source their infrastructure under the Open Compute Project initiative, which provides a set of datacenter blueprints free for anyone to use.
There is nothing preventing you from building our own datacenter, and, in fact, many organizations have followed this path. 
For instance, Amazon started as an online bookstore, but over the years it grew to sell much more than just books. 
Along with its online store growth, its datacenters also grew in size. 
In 2002, Amazon considered renting servers in their datacenters to the public, and two years later, Amazon Web Services (AWS) launched as a way to let anyone rent servers in the company’s datacenters on demand, meaning that you did not need to purchase, configure, maintain, or tear down your own clusters; rather, you could rent them directly from AWS.
This on-demand compute model is what we know today as <em>cloud computing</em>. 
In the cloud, the cluster you use is not owned by you, and it’s not in your physical building; instead it’s a datacenter owned and managed by someone else. 
Today, there are many cloud providers in this space, including AWS, Databricks, Google, Microsoft, Qubole, and many others. 
Most cloud computing platforms provide a user interface through either a web application or command line to request and manage resources.
While the benefits of processing data in the <em>cloud</em> were obvious for many years, picking a cloud provider had the unintended side effect of locking in organizations with one particular provider, making it hard to switch between providers or back to on-premises clusters. 
<em>Kubernetes</em>, announced by Google in 2014, is an open source system for managing containerized applications across multiple hosts. 
In practice, it makes it easier to deploy across multiple cloud providers and on-premises as well.
In summary, we have seen a transition from on-premises to cloud computing and, more recently, Kubernetes. 
These technologies are often loosely described as the <em>private cloud</em>, the <em>public cloud</em>, and as one of the orchestration services that can enable a <em>hybrid cloud</em>, respectively. 
This chapter walks you through each cluster computing trend in the context of Spark and R.

<h2>6.2 On-Premise</h2>
As mentioned in the overview section, on-premises clusters represent a set of computing instances procured and managed by staff members from your organization. 
These clusters can be highly customized and controlled; however, they can also incur higher initial expenses and maintenance costs.
When using on-premises Spark clusters, there are two concepts you should consider:

<dt>Cluster manager</dt>
In a similar way as to how an operating system (like Windows or macOS) allows you to run multiple applications in the same computer, a cluster manager allows multiple applications to be run in the same cluster. 
You need to choose one yourself when working with on-premises clusters.

<dt>Spark distribution</dt>
While you can install Spark from the Apache Spark site, many organizations partner with companies that can provide support and enhancements to Apache Spark, which we often refer to as Spark <em>distributions</em>.

<h3>6.2.1 Managers</h3>
To run Spark within a computing cluster, you will need to run software capable of initializing Spark over each physical machine and register all the available computing nodes. 
This software is known as a cluster manager. 
The available cluster managers in Spark are <em>Spark Standalone</em>, <em>YARN</em>, <em>Mesos</em>, and <em>Kubernetes</em>.
<strong>Note:</strong> In distributed systems and clusters literature, we often refer to each physical machine as a <em>compute instance</em>, <em>compute node</em>, <em>instance</em>, or <em>node</em>.

<h4>6.2.1.1 Standalone</h4>
In <em>Spark Standalone</em>, Spark uses itself as its own cluster manager, which allows you to use Spark without installing additional software in your cluster. 
This can be useful if you are planning to use your cluster to run only Spark applications; if this cluster is not dedicated to Spark, a generic cluster manager like YARN, Mesos, or Kubernetes would be more suitable. 
The Spark Standalone documentation contains detailed information on configuring, launching, monitoring, and enabling high availability, as illustrated in Figure 6.2.
However, since Spark Standalone is contained within a Spark installation, by completing Chapter 2, you have now a Spark installation available that you can use to initialize a local Spark Standalone cluster on your own machine. 
In practice, you would want to start the worker nodes on different machines, but for simplicity, we present the code to start a standalone cluster on a single machine.
First, retrieve the <code>SPARK_HOME</code> directory by running <em><code>spark_home_dir()</code></em>, and then start the master node and a worker node as follows:
<code># Retrieve the Spark installation directory
spark_home &lt;- spark_home_dir()

# Build paths and classes
spark_path &lt;- file.path(spark_home, "bin", "spark-class")

# Start cluster manager master node
system2(spark_path, "org.apache.spark.deploy.master.Master", wait = FALSE)</code>

<img src="https://therinspark.com/images/clusters-spark-standalone-resized.png" />

FIGURE 6.2: Spark Standalone website

The previous command initializes the master node. 
You can access the master node interface at <em>localhost:8080</em>, as captured in Figure 6.3. 
Note that the Spark master URL is specified as <em>spark://address:port</em>; you will need this URL to initialize worker nodes.
We then can initialize a single worker using the master URL; however, you could use a similar approach to initialize multiple workers by running the code multiple times and, potentially, across different machines:
<code># Start worker node, find master URL at http://localhost:8080/
system2(spark_path, c("org.apache.spark.deploy.worker.Worker",
                      "spark://address:port"), wait = FALSE)</code>

<img src="https://therinspark.com/images/clusters-spark-standalone-web-ui-resized.png" />

FIGURE 6.3: The Spark Standalone web interface

There is one worker register in Spark Standalone. 
Click the link to this worker node to view details for this particular worker, like available memory and cores, as shown in Figure 6.4.

<img src="https://therinspark.com/images/clusters-spark-standalone-web-ui-worker.png" />

FIGURE 6.4: Spark Standalone worker web interface

After you are done performing computations in this cluster, you will need to stop the master and worker nodes. 
You can use the <code>jps</code> command to identify the process numbers to terminate. 
In the following example, <code>15330</code> and <code>15353</code> are the processes that you can terminate to finalize this cluster. 
To terminate a process, you can use <code>system("Taskkill /PID ##### /F")</code> in Windows, or <code>system("kill -9 #####")</code> in macOS and Linux.
<code>system("jps")</code>
<code>15330 Master
15365 Jps
15353 Worker
1689 QuorumPeerMain</code>
You can follow a similar approach to configure a cluster by running the initialization code over each machine in the cluster.
While it’s possible to initialize a simple standalone cluster, configuring a proper Spark Standalone cluster that can recover from computer restarts and failures, and supports multiple users, permissions, and so on, is usually a much longer process that falls beyond the scope of this book. 
The following sections present several alternatives that can be much easier to manage on-premises or through cloud services. 
We will start by introducing YARN.

<h4>6.2.1.2 Yarn</h4>
Hadoop YARN, or simply YARN, as it is commonly called, is the resource manager of the Hadoop project. 
It was originally developed in the Hadoop project but was refactored into its own project in Hadoop 2. 
As we mentioned in Chapter 1, Spark was built to speed up computation over Hadoop, and therefore it’s very common to find Spark installed on Hadoop clusters.
One advantage of YARN is that it is likely to be already installed in many existing clusters that support Hadoop; this means that you can easily use Spark with many existing Hadoop clusters without requesting any major changes to the existing cluster infrastructure. 
It is also very common to find Spark deployed in YARN clusters since many started out as Hadoop clusters and were eventually upgraded to also support Spark.
You can submit YARN applications in two modes: <em>yarn-client</em> and <em>yarn-cluster</em>. 
In yarn-cluster mode the driver is running remotely (potentially), while in yarn-client mode, the driver is running locally. 
Both modes are supported, and we explain them further in Chapter 7.
YARN provides a resource management user interface useful to access logs, monitor available resources, terminate applications, and more. 
After you connect to Spark from R, you will be able to manage the running application in YARN, as shown in Figure 6.5.
Since YARN is the cluster manager from the Hadoop project, you can find YARN’s documentation at hadoop.apache.org. 
You can also reference the “Running Spark on YARN” guide at spark.apache.org.

<img src="https://therinspark.com/images/clusters-yarn-resource-manager-resized.png" />

FIGURE 6.5: YARN’s Resource Manager running a sparklyr application

<h4>6.2.1.3 Mesos</h4>
Apache Mesos is an open source project to manage computer clusters. 
Mesos began as a research project in the UC Berkeley RAD Lab. 
It makes use of Linux Cgroups to provide isolation for CPU, memory, I/O, and file system access.
Mesos, like YARN, supports executing many cluster frameworks, including Spark. 
However, one advantage particular to Mesos is that it allows cluster frameworks like Spark to implement custom task schedulers. 
A scheduler is the component that coordinates in a cluster which applications are allocated execution time and which resources are assigned to them. 
Spark uses a coarse-grained scheduler, which schedules resources for the duration of the application; however, other frameworks might use Mesos’ fine-grained scheduler, which can increase the overall efficiency in the cluster by scheduling tasks in shorter intervals, allowing them to share resources between them.
Mesos provides a web interface to manage your running applications, resources, and so on. 
After connecting to Spark from R, your application will be registered like any other application running in Mesos. 
Figure 6.6 shows a successful connection to Spark from R.
Mesos is an Apache project with its documentation available at mesos.apache.org. 
The <em>Running Spark on Mesos</em> guide is also a great resource if you choose to use Mesos as your cluster manager.

<img src="https://therinspark.com/images/clusters-mesos-webui.png" />

FIGURE 6.6: Mesos web interface running Spark and R

<h3>6.2.2 Distributions</h3>
You can use a cluster manager in on-premises clusters, as described in the previous section; however, many organizations—including, but not limited to, Apache Spark—choose to partner with companies providing additional management software, services, and resources to help manage applications in their cluster. 
Some of the on-premises cluster providers include <em>Cloudera</em>, <em>Hortonworks</em>, and <em>MapR</em>, which we briefly introduce next.
<em>Cloudera</em>, Inc., is a US-based software company that provides Apache Hadoop and Apache Spark–based software, support and services, and training to business customers. 
Cloudera’s hybrid open source Apache Hadoop distribution, Cloudera Distribution Including Apache Hadoop (CDH), targets enterprise-class deployments of that technology. 
Cloudera donates more than 50% of its engineering output to the various Apache-licensed open source projects (Apache Hive, Apache Avro, Apache HBase, and so on) that combine to form the Apache Hadoop platform. 
Cloudera is also a sponsor of the Apache Software Foundation.
Cloudera clusters make use of <em>parcels</em>, which are binary distributions containing program files and metadata. 
Spark happens to be installed as a parcel in Cloudera. 
It’s beyond the scope of this book to present how to configure Cloudera clusters, but resources and documentation can be found under cloudera.com, and “Introducing sparklyr, an R Interface for Apache Spark” on the Cloudera blog.
Cloudera provides the Cloudera Manager web interface to manage resources, services, parcels, diagnostics, and more. 
Figure 6.7 shows a Spark parcel running in Cloudera Manager, which you can later use to connect from R.

<img src="https://therinspark.com/images/clusters-cloudera-manager-resized.png" />

FIGURE 6.7: Cloudera Manager running Spark parcel

<code>sparklyr</code> is certified with Cloudera, meaning that Cloudera’s support is aware of <code>sparklyr</code> and can be effective helping organizations that are using Spark and R. 
Table 6.1 summarizes the versions currently certified.
<table>
<caption>TABLE 6.1: Versions of sparklyr certified with Cloudera</caption>
<thead>
<tr><th align="left">Cloudera.Version</th><th align="left">Product</th><th align="right">Version</th><th align="left">Components</th><th align="left">Kerberos</th></tr>
</thead>
<tbody>
<tr><td align="left">CDH5.9</td><td align="left">sparklyr</td><td align="right">0.5</td><td align="left">HDFS, Spark</td><td align="left">Yes</td></tr>
<tr><td align="left">CDH5.9</td><td align="left">sparklyr</td><td align="right">0.6</td><td align="left">HDFS, Spark</td><td align="left">Yes</td></tr>
<tr><td align="left">CDH5.9</td><td align="left">sparklyr</td><td align="right">0.7</td><td align="left">HDFS, Spark</td><td align="left">Yes</td></tr>
</tbody>
</table>
<em>Hortonworks</em> is a big data software company based in Santa Clara, California. 
The company develops, supports, and provides expertise on an expansive set of entirely open source software designed to manage data and processing for everything from Internet of Things (IoT) to advanced analytics and machine learning. 
Hortonworks believes that it is a data management company bridging the cloud and the datacenter.
Hortonworks partnered with Microsoft to improve support in Microsoft Windows for Hadoop and Spark, which used to be a differentiation point from Cloudera; however, comparing Hortonworks and Cloudera is less relevant today since the companies merged in January 2019. 
Despite the merger, support for the Cloudera and Hortonworks Spark distributions are still available. 
Additional resources to configure Spark under Hortonworks are available at hortonworks.com.
<em>MapR</em> is a business software company headquartered in Santa Clara, California. 
MapR provides access to a variety of data sources from a single computer cluster, including big data workloads such as Apache Hadoop and Apache Spark, a distributed file system, a multimodel database management system, and event stream processing, combining analytics in real time with operational applications. 
Its technology runs on both commodity hardware and public cloud computing services.

<h2>6.3 Cloud</h2>
If you have neither an on-premises cluster nor spare machines to reuse, starting with a cloud cluster can be quite convenient since it will allow you to access a proper cluster in a matter of minutes. 
This section briefly mentions some of the major cloud infrastructure providers and gives you resources to help you get started if you choose to use a cloud provider.
In cloud services, the compute instances are billed for as long the Spark cluster runs; your billing starts when the cluster launches, and it stops when the cluster stops. 
This cost needs to be multiplied by the number of instances reserved for your cluster. 
So, for instance, if a cloud provider charges $1.00 per compute instance per hour, and you start a three-node cluster that you use for one hour and 10 minutes, it is likely that you’ll receive a bill for $1.00 x 2 hours x 3 nodes = $6.00. 
Some cloud providers charge per minute, but at least you can rely on all of them charging per compute hour.
Be aware that, while computing costs can be quite low for small clusters, accidentally leaving a cluster running can cause significant billing expenses. 
Therefore, it’s worth taking the extra time to check twice that your cluster is terminated when you no longer need it. 
It’s also a good practice to monitor costs daily while using clusters to make sure your expectations match the daily bill.
From past experience, you should also plan to request compute resources in advance while dealing with large-scale projects; various cloud providers will not allow you to start a cluster with hundreds of machines before requesting them explicitly through a support request. 
While this can be cumbersome, it’s also a way to help you control costs in your organization.
Since the cluster size is flexible, it is a good practice to start with small clusters and scale compute resources as needed. 
Even if you know in advance that a cluster of significant size will be required, starting small provides an opportunity to troubleshoot issues at a lower cost since it’s unlikely that your data analysis will run at scale flawlessly on the first try. 
As a rule of thumb, grow the instances exponentially; if you need to run a computation over an eight-node cluster, start with one node and an eighth of the entire dataset, then two nodes with a fourth, then four nodes with half of the dataset, and then, finally, eight nodes and the entire dataset. 
As you become more experienced, you’ll develop a good sense of how to troubleshoot issues, and of the size of the required cluster, and you’ll be able to skip intermediate steps, but for starters, this is a good practice to follow.
You can also use a cloud provider to acquire bare computing resources and then install the on-premises distributions presented in the previous section yourself; for instance, you can run the Cloudera distribution on Amazon Elastic Compute Cloud (Amazon EC2). 
This model would avoid procuring colocated hardware, but it still allows you to closely manage and customize your cluster. 
This book presents an overview of only the fully managed Spark services available by cloud providers; however, you can usually find with ease instructions online on how to install on-premises distributions in the cloud.
Some of the major providers of cloud computing infrastructure are Amazon, Databricks, Google, IBM, and Microsoft and Qubole. 
The subsections that follow briefly introduce each one.

<h3>6.3.1 Amazon</h3>
Amazon provides cloud services through AWS; more specifically, it provides an on-demand Spark cluster through Amazon EMR.
Detailed instructions on using R with Amazon EMR were published under Amazon’s Big Data blog in a post called “Running sparklyr on Amazon EMR”. 
This post introduced the launch of <code>sparklyr</code> and instructions to configure Amazon EMR clusters with <code>sparklyr</code>. 
For instance, it suggests you can use the Amazon Command Line Interface to launch a cluster with three nodes, as follows:
<code>aws emr create-cluster --applications Name=Hadoop Name=Spark Name=Hive \
  --release-label emr-5.8.0 --service-role EMR_DefaultRole --instance-groups \
  InstanceGroupType=MASTER,InstanceCount=1,InstanceType=m3.2xlarge \
  InstanceGroupType=CORE,InstanceCount=2,InstanceType=m3.2xlarge \ 
  --bootstrap-action Path=s3://aws-bigdata-blog/artifacts/aws-blog-emr-\
rstudio-sparklyr/rstudio_sparklyr_emr5.sh,Args=["--user-pw", "&lt;password>", \
  "--rstudio", "--arrow"] --ec2-attributes InstanceProfile=EMR_EC2_DefaultRole</code>
You can then see the cluster launching and then eventually running under the AWS portal, as illustrated in Figure 6.8.
You then can navigate to the Master Public DNS and find RStudio under port 8787—for example, <code>ec2-12-34-567-890.us-west-1.compute.amazonaws.com:8787</code>—and then log in with user <code>hadoop</code> and password <code>password</code>.

<img src="https://therinspark.com/images/clusters-amazon-emr-launching-resized.png" />

FIGURE 6.8: Launching an Amazon EMR cluster

It is also possible to launch the Amazon EMR cluster using the web interface; the same introductory post contains additional details and walkthroughs specifically designed for Amazon EMR.
Remember to turn off your cluster to avoid unnecessary charges and use appropriate security restrictions when starting Amazon EMR clusters for sensitive data analysis.
Regarding cost, you can find the most up-to-date information at https://amzn.to/2YRGb5r[Amazon EMR Pricing]. 
Table 6.2 presents some of the instance types available in the <code>us-west-1</code> region (as of this writing); this is meant to provide a glimpse of the resources and costs associated with cloud processing. 
Notice that the “EMR price is in addition to the Amazon EC2 price (the price for the underlying servers)”.
<table>
<caption>TABLE 6.2: Amazon EMR pricing information</caption>
<thead>
<tr><th align="left">Instance</th><th align="right">CPUs</th><th align="left">Memory</th><th align="left">Storage</th><th align="left">EC2.Cost</th><th align="left">EMR.Cost</th></tr>
</thead>
<tbody>
<tr><td align="left">c1.medium</td><td align="right">2</td><td align="left">1.7GB</td><td align="left">350GB</td><td align="left">$0.148 USD/hr</td><td align="left">$0.030 USD/hr</td></tr>
<tr><td align="left">m3.2xlarge</td><td align="right">8</td><td align="left">30GB</td><td align="left">160GB</td><td align="left">$0.616 USD/hr</td><td align="left">$0.140 USD/hr</td></tr>
<tr><td align="left">i2.8xlarge</td><td align="right">32</td><td align="left">244GB</td><td align="left">6400GB</td><td align="left">$7.502 USD/hr</td><td align="left">$0.270 USD/hr</td></tr>
</tbody>
</table>
<strong>Note:</strong> We are presenting only a subset of the available compute instances for Amazon and subsequent cloud providers as of 2019; however, note that hardware (CPU speed, hard drive speed, etc.) varies between vendors and locations; therefore, you can’t use these hardware tables as an accurate price comparison. 
Accurate comparison would require running your particular workloads and considering other aspects beyond compute instance cost.

<h3>6.3.2 Databricks</h3>
Databricks is a company founded by the creators of Apache Spark, whose aim is to help clients with cloud-based big data processing using Spark. 
Databricks grew out of the AMPLab project at the University of California, Berkeley.
Databricks provides enterprise-level cluster computing plans as well as a free/community tier to explore functionality and become familiar with their environment.
After a cluster is launched, you can use R and <code>sparklyr</code> from Databricks notebooks following the steps provided in Chapter 2 or by installing RStudio on Databricks. 
Figure 6.9 shows a Databricks notebook using Spark through <code>sparkylyr</code>.

<img src="https://therinspark.com/images/clusters-databricks-sparklyr.png" />

FIGURE 6.9: Databricks community notebook running sparklyr

Additional resources are available under the Databricks Engineering Blog post “Using sparklyr in Databricks” and the Databricks documentation for <code>sparklyr</code>.
You can find the latest pricing
information at <em>databricks.com/product/pricing</em>. 
Table 6.3 lists the available plans as of this writing.
<table>
<caption>TABLE 6.3: Databricks procong information.</caption>
<thead>
<tr><th align="left">Plan</th><th align="left">Basic</th><th align="left">Data.Engineering</th><th align="left">Data.Analytics</th></tr>
</thead>
<tbody>
<tr><td align="left">AWS Standard</td><td align="left">$0.07 USD/DBU</td><td align="left">$0.20 USD/DBU</td><td align="left">$0.40 USD/DBU</td></tr>
<tr><td align="left">Azure Standard</td><td align="left"></td><td align="left">$0.20 USD/DBU</td><td align="left">$0.40 USD/DBU</td></tr>
<tr><td align="left">Azure Premium</td><td align="left"></td><td align="left">$0.35 USD/DBU</td><td align="left">$0.55 USD/DBU</td></tr>
</tbody>
</table>
Notice that pricing is based on cost of DBU per hour. 
From Databricks, “a Databricks Unit (DBU) is a unit of Apache Spark processing capability per hour. 
For a varied set of instances, DBUs are a more transparent way to view usage instead of the node-hour”.

<h3>6.3.3 Google</h3>
Google provides Google Cloud Dataproc as a cloud-based managed Spark and Hadoop service offered on Google Cloud Platform (GCP). 
Dataproc utilizes many GCP technologies, such as Google Compute Engine and Google Cloud Storage, to offer fully managed clusters running popular data processing frameworks such as Apache Hadoop and Apache Spark.
You can easily create a cluster from the Google Cloud console or the Google Cloud command-line interface (CLI) as illustrated in Figure 6.10.

<img src="https://therinspark.com/images/clusters-dataproc-launching-resized.png" />

FIGURE 6.10: Launching a Dataproc cluster

After you’ve created your cluster, ports can be forwarded to allow you to access this cluster from your machine—for instance, by launching Chrome to make use of this proxy and securely connect to the Dataproc cluster. 
Configuring this connection looks as follows:
<code>gcloud compute ssh sparklyr-m --project=&lt;project> --zone=&lt;region> -- -D 1080 \
  -N "&lt;path to chrome>" --proxy-server="socks5://localhost:1080" \
  --user-data-dir="/tmp/sparklyr-m" http://sparklyr-m:8088</code>
There are various tutorials available (cloud.google.com/dataproc/docs/tutorials), including a comprehensive tutorial to configure RStudio and <code>sparklyr</code>.
You can find the latest pricing information at <em>cloud.google.com/dataproc/pricing</em>. 
In Table 6.4 notice that the cost is split between compute engine and a dataproc premium.
<table>
<caption>TABLE 6.4: Databricks procong information.</caption>
<thead>
<tr><th align="left">Instance</th><th align="right">CPUs</th><th align="left">Memory</th><th align="left">Compute.Engine</th><th align="left">Dataproc.Premium</th></tr>
</thead>
<tbody>
<tr><td align="left">n1-standard-1</td><td align="right">1</td><td align="left">3.75GB</td><td align="left">$0.0475 USD/hr</td><td align="left">$0.010 USD/hr</td></tr>
<tr><td align="left">n1-standard-8</td><td align="right">8</td><td align="left">30GB</td><td align="left">$0.3800 USD/hr</td><td align="left">$0.080 USD/hr</td></tr>
<tr><td align="left">n1-standard-64</td><td align="right">64</td><td align="left">244GB</td><td align="left">$3.0400 USD/hr</td><td align="left">$0.640 USD/hr</td></tr>
</tbody>
</table>

<h3>6.3.4 IBM</h3>
IBM cloud computing is a set of cloud computing services for business. 
IBM cloud includes Infrastructure as a Service (IaaS), Software as a Service (SaaS), and Platform as a Service (PaaS) offered through public, private, and hybrid cloud delivery models, in addition to the components that make up those clouds.
From within IBM Cloud, open Watson Studio and create a Data Science project, add a Spark cluster under the project settings, and then, on the Launch IDE menu, start RStudio. 
Please note that, as of this writing, the provided version of <code>sparklyr</code> was not the latest version available in CRAN, since <code>sparklyr</code> was modified to run under the IBM Cloud. 
In any case, follow IBM’s documentation as an authoritative reference to run R and Spark on the IBM Cloud and particularly on how to upgrade <code>sparklyr</code> appropriately. 
Figure 6.11 captures IBM’s Cloud portal launching a Spark cluster.

<img src="https://therinspark.com/images/clusters-ibm-sparklyr-resized.png" />

FIGURE 6.11: IBM Watson Studio launching Spark with R support

The most up-to-date pricing information is available at <em>ibm.com/cloud/pricing</em>. 
In Table 6.5, compute cost was normalized using 31 days from the per-month costs.
<table>
<caption>TABLE 6.5: IBM Cloud pricing information</caption>
<thead>
<tr><th align="left">Instance</th><th align="right">CPUs</th><th align="left">Memory</th><th align="left">Storage</th><th align="left">Cost</th></tr>
</thead>
<tbody>
<tr><td align="left">C1.1x1x25</td><td align="right">1</td><td align="left">1GB</td><td align="left">25GB</td><td align="left">$0.033 USD/hr</td></tr>
<tr><td align="left">C1.4x4x25</td><td align="right">4</td><td align="left">4GB</td><td align="left">25GB</td><td align="left">$0.133 USD/hr</td></tr>
<tr><td align="left">C1.32x32x25</td><td align="right">32</td><td align="left">25GB</td><td align="left">25GB</td><td align="left">$0.962 USD/hr</td></tr>
</tbody>
</table>

<h3>6.3.5 Microsoft</h3>
Microsoft Azure is a cloud computing service created by Microsoft for building, testing, deploying, and managing applications and services through a global network of Microsoft-managed datacenters. 
It provides SaaS, PaaS, and IaaS and supports many different programming languages, tools, and frameworks, including both Microsoft-specific and third-party software and systems.
From the Azure portal, the Azure HDInsight service provides support for on-demand Spark clusters. 
You can easily create HDInsight cluster with support for Spark and RStudio by selecting the ML Services cluster type. 
Note that the provided version of <code>sparklyr</code> might not be the latest version available in CRAN since the default package repository seems to be initialized using a Microsoft R Application Network (MRAN) snapshot, not directly from CRAN. 
Figure 6.12 shows the Azure portal launching a Spark cluster with support for R.

<img src="https://therinspark.com/images/clusters-azure-mlservices-resized.png" />

FIGURE 6.12: Creating an Azure HDInsight Spark cluster

Up-to-date pricing for HDInsight is available at <em>azure.microsoft.com/en-us/pricing/details/hdinsight</em>; Table 6.6 lists the pricing as of this writing.
<table>
<caption>TABLE 6.6: Azure HDInsight pricing information</caption>
<thead>
<tr><th align="left">Instance</th><th align="right">CPUs</th><th align="left">Memory</th><th align="left">Total.Cost</th></tr>
</thead>
<tbody>
<tr><td align="left">D1 v2</td><td align="right">1</td><td align="left">3.5 GB</td><td align="left">$0.074/hour</td></tr>
<tr><td align="left">D4 v2</td><td align="right">8</td><td align="left">28 GB</td><td align="left">$0.59/hour</td></tr>
<tr><td align="left">G5</td><td align="right">64</td><td align="left">448 GB</td><td align="left">$9.298/hour</td></tr>
</tbody>
</table>

<h3>6.3.6 Qubole</h3>
Qubole was founded in 2013 with a mission to close the data accessibility gap. 
Qubole delivers a self-service platform for big data analytics built on Amazon, Microsoft, Google, and Oracle Clouds. 
In Qubole, you can launch Spark clusters, which you can then use from Qubole notebooks or RStudio Server. 
Figure 6.13 shows a Qubole cluster initialized with RStudio and <code>sparklyr</code>.

<img src="https://therinspark.com/images/clusters-qubole-sparklyr.png" />

FIGURE 6.13: A Qubole cluster initialized with RStudio and sparklyr

You can find the latest pricing information at Qubole's pricing page. 
Table 6.7 lists the price for Qubole’s current plan, as of this writing. 
Notice that pricing is based on cost of QCU/hr, which stands for “Qubole Compute Unit per hour,” and the Enterprise Edition requires an annual contract.
<table>
<caption>TABLE 6.7: Qubole pricing information</caption>
<thead>
<tr><th align="left">Test.Drive</th><th align="left">Full.Featured.Trial</th><th align="left">Enterprise.Edition</th></tr>
</thead>
<tbody>
<tr><td align="left">$0 USD</td><td align="left">$0 USD</td><td align="left">$0.14 USD/QCU</td></tr>
</tbody>
</table>

<h2>6.4 Kubernetes</h2>
Kubernetes is an open source container orchestration system for automating deployment, scaling, and management of containerized applications that was originally designed by Google and is now maintained by the Cloud Native Computing Foundation (CNCF). 
Kubernetes was originally based on Docker, while, like Mesos, it’s also based on Linux Cgroups.
Kubernetes can execute many cluster applications and frameworks that you can highly customize by using container images with specific resources and libraries. 
This allows a single Kubernetes cluster to be used for many different purposes beyond data analysis, which in turn helps organizations manage their compute resources with ease. 
One trade-off from using custom images is that they add further configuration overhead but make Kubernetes clusters extremely flexible. 
Nevertheless, this flexibility has proven to be instrumental to easily administer cluster resources in many organizations and, as pointed out in Overview, Kubernetes is becoming a very popular cluster framework.
Kubernetes is supported across all major cloud providers. 
They all provide extensive documentation as to how to launch, manage, and tear down Kubernetes clusters; Figure 6.14 shows the GCP console while creating a Kubernetes cluster. 
You can deploy Spark over any Kubernetes cluster, and you can use R to connect, analyze, model, and more.

<img src="https://therinspark.com/images/clusters-kubernetes-google-console-resized.png" />

FIGURE 6.14: Creating a Kubernetes cluster for Spark and R using Google Cloud

You can learn more at kubernetes.io, and read the <em>Running Spark on Kubernetes</em> guide from spark.apache.org.
Strictly speaking, Kubernetes is a cluster technology, not a specific cluster architecture. 
However, Kubernetes represents a larger trend often referred to as a <em>hybrid cloud</em>. 
A hybrid cloud is a computing environment that makes use of on-premises and public cloud services with orchestration between the various platforms. 
It’s still too early to precisely categorize the leading technologies that will form a hybrid approach to cluster computing; although, as previously mentioned, Kubernetes is the leading one, many more are likely to form to complement or even replace existing technologies.

<h2>6.5 Tools</h2>
While using only R and Spark can be sufficient for some clusters, it is common to install complementary tools in your cluster to improve monitoring, SQL analysis, workflow coordination, and more, with applications like Ganglia, Hue, and Oozie, respectively. 
This section is not meant to cover all tools; rather, it mentions the ones that are commonly used.

<h3>6.5.1 RStudio</h3>
From reading Chapter 1, you are aware that RStudio is a well-known and free desktop development environment for R; therefore, it is likely that you are following the examples in this book using RStudio Desktop. 
However, you might not be aware that you can run RStudio as a web service within a Spark cluster. 
This version of RStudio is known as <em>RStudio Server</em>. 
You can see RStudio Server running in Figure 6.15. 
In the same way that the Spark UI runs in the cluster, you can install RStudio Server within the cluster. 
Then you can connect to RStudio Server and use RStudio in exactly the same way you use RStudio Desktop but with the ability to run code against the Spark cluster. 
As you can see in Figure 6.15, RStudio Server looks and feels just like RStudio Desktop, but adds support to run commands efficiently by being located within the cluster.

<img src="https://therinspark.com/images/clusters-rstudio-server-resized.png" />

FIGURE 6.15: RStudio Server Pro running inside Apache Spark

If you’re familiar with R, Shiny Server is a very popular tool for building interactive web applications from R. 
We recommended that you install Shiny directly in your Spark cluster.
RStudio Server and Shiny Server are a free and open source; however, RStudio also provides professional products like RStudio Server, RStudio Server Pro, Shiny Server Pro, and RStudio Connect, which you can install within the cluster to support additional R workflows. 
While <code>sparklyr</code> does not require any additional tools, they provide significant productivity gains worth considering. 
You can learn more about them at <em>rstudio.com/products/</em>.

<h3>6.5.2 Jupyter</h3>
Project Jupyter exists to develop open source software, open standards, and services for interactive computing across dozens of programming languages. 
A Jupyter notebook provides support for various programming languages, including R. 
You can use <code>sparklyr</code> with Jupyter notebooks using the R Kernel. 
Figure 6.16 shows <code>sparklyr</code> running within a local Jupyter notebook.

<img src="https://therinspark.com/images/clusters-jupyter-resized.png" />

FIGURE 6.16: Jupyter notebook running sparklyr

<h3>6.5.3 Livy</h3>
Apache Livy is an incubation project in Apache providing support to use Spark clusters remotely through a web interface. 
It is ideal to connect directly into the Spark cluster; however, there are times where connecting directly to the cluster is not feasible. 
When facing those constraints, you can consider installing Livy in the cluster and secure it properly to enable remote use over web protocols. 
Be aware, though, that there is a significant performance overhead from using Livy in <code>sparklyr</code>.
To help test Livy locally, <code>sparklyr</code> provides support to list, install, start, and stop a local Livy instance by executing <code>livy_available_versions()</code>:
<code>##    livy
## 1 0.2.0
## 2 0.3.0
## 3 0.4.0
## 4 0.5.0</code>
This lists the versions that you can install; we recommend installing the latest version and verifying it as follows:
<code># Install default Livy version
livy_install()

# List installed Livy services
livy_installed_versions()

# Start the Livy service
livy_service_start()</code>
You then can navigate to the local Livy session at http://localhost:8998. 
Chapter 7 will detail how to connect through Livy. 
After you’re connected, you can navigate to the Livy web application, as shown in Figure 6.17.

<img src="https://therinspark.com/images/clusters-livy-local.png" />

FIGURE 6.17: Apache Livy running as a local service

Make sure you also stop the Livy service when working with local Livy instances (for proper Livy services running in a cluster, you won’t have to):
<code># Stops the Livy service
livy_service_stop()</code>

<h2>6.6 Recap</h2>
This chapter explained the history and trade-offs of on-premises and cloud computing and presented Kubernetes as a promising framework to provide flexibility across on-premises or multiple cloud providers. 
It also introduced cluster managers (Spark Standalone, YARN, Mesos, and Kubernetes) as the software needed to run Spark as a cluster application. 
This chapter briefly mentioned on-premises cluster providers like Cloudera, Hortonworks, and MapR, as well as the major Spark cloud providers: Amazon, Databricks, IBM, Google, Microsoft, and Qubole.
While this chapter provided a solid foundation to understand current cluster computing trends, tools, and service providers useful to perform data science at scale, it did not provide a comprehensive framework to help you decide which cluster technologies to choose. 
Instead, use this chapter as an overview and a starting point to seek out additional resources to help you find the cluster stack that best fits your organization needs.
Chapter 7 will focus on understanding how to connect to existing clusters; therefore, it assumes a Spark cluster like those we presented in this chapter is already available to you.

<h2><span class="orange">Chapter 7 Connections</span></h2>
Chapter 6 presented the major cluster computing trends, cluster managers, distributions, and cloud service providers to help you choose the Spark cluster that best suits your needs. 
In contrast, this chapter presents the internal components of a Spark cluster and how to connect to a particular Spark cluster.
When reading this chapter, don’t try to execute every line of code; this would be quite hard since you would need to prepare different Spark environments. 
Instead, if you already have a Spark cluster or if the previous chapter gets you motivated enough to sign up for an on-demand cluster, now is the time to learn how to connect to it. 
This chapter helps you connect to your cluster, which you should have already chosen by now. 
Without a cluster, we recommend that you learn the concepts and come back to execute code later on.
In addition, this chapter provides various troubleshooting connection techniques. 
While we hope you won’t need to use them, this chapter prepares you to use them as effective techniques to resolve connectivity issues.
While this chapter might feel a bit dry—connecting and troubleshooting connections is definitely not the most exciting part of large-scale computing—it introduces the components of a Spark cluster and how they interact, often known as the <em>architecture</em> of Apache Spark. 
This chapter, along with Chapters 8 and
9, will provide a detailed view of how Spark works, which will help you move toward becoming an intermediate Spark user who can truly understand the exciting world of distributed computing using Apache Spark.

<h2>7.1 Overview</h2>
The overall connection architecture for a Spark cluster is composed of three types of compute instances: the <em>driver node</em>, the <em>worker nodes</em>, and the <em>cluster manager</em>. 
A cluster manager is a service that allows Spark to be executed in the cluster; this was detailed in Clusters - Managers. 
The worker nodes (also referred to as <em>executors</em>) execute compute tasks over partitioned data and communicate intermediate results to other workers or back to the driver node. 
The driver node is tasked with delegating work to the worker nodes, but also with aggregating their results and controlling computation flow. 
For the most part, aggregation happens in the worker nodes; however, even after the nodes aggregate data, it is often the case that the driver node would need to collect the worker’s results. 
Therefore, the driver node usually has at least, but often much more, compute resources (memory, CPUs, local storage, etc.) as the worker node.
Strictly speaking, the driver node and worker nodes are just names assigned to machines with particular roles, while the actual computation in the driver node is performed by the <em>Spark context</em>. 
The Spark context is the main entry point for Spark functionality since it’s tasked with scheduling tasks, managing storage, tracking execution status, specifying access configuration settings, canceling jobs, and so on. 
In the worker nodes, the actual computation is performed under a <em>spark executor</em>, which is a Spark component tasked with executing subtasks against a specific data partition.
Figure 7.1 illustrates this concept, where the driver node orchestrates a worker’s work through the cluster manager.

<img src="https://therinspark.com/the-r-in-spark_files/figure-html/connections-architecture-1.png" height="280pt" />

FIGURE 7.1: Apache Spark connection architecture

If you already have a Spark cluster in your organization, you should request the connection information to this cluster from your cluster administrator, read their usage policies carefully, and follow their advice. 
Since a cluster can be shared among many users, you want to ensure that you request only the compute resources you need. 
We cover how to request resources in Chapter 9. 
Your system administrator will specify whether it’s an <em>on-premises</em> or <em>cloud</em> cluster, the cluster manager being used, supported <em>connections</em>, and supported <em>tools</em>. 
You can use this information to jump directly to Standalone, YARN, Mesos, Livy, or Kubernetes based on which is appropriate for your situation.
<strong>Note:</strong> After you’ve used <code>spark_connect()</code> to connect, you can use all the techniques described in previous chapters using the <code>sc</code> connection; for instance, you can do data analysis or modeling with the same code previous chapters presented.

<h3>7.1.1 Edge Nodes</h3>
Computing clusters are configured to enable high bandwidth and fast network connectivity between nodes. 
To optimize network connectivity, the nodes in the cluster are configured to trust one another and to disable security features. 
This improves performance but requires you to close all external network communication, making the entire cluster secure as a whole except for a few cluster machines that are carefully configured to accept connections from outside the cluster; conceptually, these machines are located in the “edge” of the cluster and are known as <em>edge nodes</em>.
Therefore, before connecting to Apache Spark, it is likely that you will first need to connect to an edge node in your cluster. 
There are two methods to connect:

<dt>Terminal</dt>
Using a computer terminal application, you can use a Secure Shell to establish a remote connection into the cluster; after you connect into the cluster, you can launch R and then use <code>sparklyr</code>. 
However, a terminal can be cumbersome for some tasks, like exploratory data analysis, so it’s often used only while configuring the cluster or troubleshooting issues.

<dt>Web Browser</dt>
While using <code>sparklyr</code> from a terminal is possible, it is usually more productive to install a <em>web server</em> in an edge node that provides access to run R with <code>sparklyr</code> from a web browser. 
Most likely, you will want to consider using RStudio or Jupyter rather than connecting from the terminal.

Figure 7.2 explains these concepts visually. 
The left block is usually your web browser, and the right block is the edge node. 
Client and edge nodes communicate over HTTP when using a web browser or Secure Shell (SSH) when using the terminal.

<img src="https://therinspark.com/the-r-in-spark_files/figure-html/connections-spark-edge-1.png" height="240pt" />

FIGURE 7.2: Connecting to Spark’s edge node

<h3>7.1.2 Spark Home</h3>
After you connect to an edge node, the next step is to determine where Spark is installed, a location known as the <code>SPARK_HOME</code>. 
In most cases, your cluster administrator will have already set the <code>SPARK_HOME</code> environment variable to the correct installation path. 
If not, you will need to get the correct <em>SPARK_HOME</em> path. 
You must specify the <code>SPARK_HOME</code> path as an environment variable or explicitly when running <code>spark_connect()</code> using the <code>spark_home</code> parameter.
If your cluster provider or cluster administrator already provided <code>SPARK_HOME</code> for you, the following code should return a path instead of an empty string:
<code>Sys.getenv("SPARK_HOME")</code>
If this code returns an empty string, this would mean that the <code>SPARK_HOME</code> environment variable is not set in your cluster, so you will need to specify <code>SPARK_HOME</code> while using <code>spark_connect()</code>, as follows:
<code>sc &lt;- spark_connect(master = "&lt;master>", spark_home = "local/path/to/spark")</code>
In this example, <code>master</code> is set to the correct cluster manager master for Spark Standalone, YARN, Mesos, Kubernetes, or Livy.

<h2>7.2 Local</h2>
When you connect to Spark in local mode, Spark starts a single process that runs most of the cluster components like the Spark context and a single executor. 
This is ideal to learn Spark, work offline, troubleshoot issues, or test code before you run it over a large compute cluster. 
Figure 7.3 depicts a local connection to Spark.

<img src="https://therinspark.com/the-r-in-spark_files/figure-html/connections-local-diagram-1.png" height="260pt" />

FIGURE 7.3: Local connection diagram

Notice that there is neither a cluster manager nor worker process since, in local mode, everything runs inside the driver application. 
It’s also worth noting that <code>sparklyr</code> starts the Spark context through <code>spark-submit</code>, a script available in every Spark installation to enable users to submit custom applications to Spark. 
If you’re curious, &lt;&lt;contributing>> explains the internal processes that take place in <code>sparklyr</code> to submit this application and connect properly from R.
To perform this local connection, we can use the following familiar code from previous chapters:
<code># Connect to local Spark instance
sc &lt;- spark_connect(master = "local")</code>

<h2>7.3 Standalone</h2>
Connecting to a Spark Standalone cluster requires the location of the cluster manager’s master instance, which you can find in the cluster manager web interface as described in the Clusters - Standalone section. 
You can find this location by looking for a URL starting with <code>spark://</code>.
A connection in standalone mode starts from <code>sparklyr</code>, which launches <code>spark-submit</code>, which then submits the <code>sparklyr</code> application and creates the Spark Context, which requests executors from the Spark Standalone instance running under the given <code>master</code> address.
Figure 7.4 illustrates this process, which is quite similar to the overall connection architecture from Figure 7.1 but with additional details that are particular to standalone clusters and <code>sparklyr</code>.

<img src="https://therinspark.com/the-r-in-spark_files/figure-html/connections-standalone-diagram-1.png" height="280pt" />

FIGURE 7.4: Spark Standalone connection diagram

To connect, use <code>master = "spark://hostname:port"</code> in <code>spark_connect()</code> as follows:
<code>sc &lt;- spark_connect(master = "spark://hostname:port")</code>

<h2>7.4 Yarn</h2>
Hadoop YARN is the cluster manager from the Hadoop project. 
It’s the most common cluster manager that you are likely to find in clusters, which started out as Hadoop clusters; with Cloudera, Hortonworks, and MapR distributions as when using Amazon EMR. 
YARN supports two connection modes: YARN client and YARN cluster. 
However, YARN client mode is much more common than YARN cluster since it’s more efficient and easier to set up.

<h3>7.4.1 Yarn Client</h3>
When you connect in YARN client mode, the driver instance runs R, <code>sparklyr</code>, and the Spark context, which requests worker nodes from YARN to run Spark executors, as shown in Figure 7.5.

<img src="https://therinspark.com/the-r-in-spark_files/figure-html/connections-yarn-client-diagram-1.png" height="280pt" />

FIGURE 7.5: YARN client connection diagram

To connect, you simply run with <code>master = "yarn"</code>, as follows:
<code>sc &lt;- spark_connect(master = "yarn")</code>
Behind the scenes, when you’re running YARN in client mode, the cluster manager will do what you would expect a cluster manager would do: it allocates resources from the cluster and assigns them to your Spark application, which the Spark context will manage for you. 
The important piece to notice in Figure 7.5 is that the Spark context resides in the same machine where you run R code; this is different when you’re running YARN in cluster mode.

<h3>7.4.2 Yarn Cluster</h3>
The main difference between running YARN in cluster mode and running YARN in client mode is that, in cluster mode, the driver node is not required to be the node where R and <code>sparklyr</code> were launched; instead, the driver node remains the designated driver node, which is usually a different node than the edge node where R is running. 
It can be helpful to consider using cluster mode when the edge node has too many concurrent users, when it is lacking computing resources, or when tools (like RStudio or Jupyter) need to be managed independently of other cluster resources.
Figure 7.6 shows how the different components become decoupled when running in cluster mode. 
Notice there is still a line connecting the client with the cluster manager since, first of all, resources still need to be allocated from the cluster manager; however, after they’re allocated, the client communicates directly with the driver node, which communicates with the worker nodes. 
From Figure 7.6, you might think that cluster mode looks much more complicated than client mode—this would be a correct assessment; therefore, if possible, it’s best to avoid cluster mode due to its additional configuration overhead.

<img src="https://therinspark.com/the-r-in-spark_files/figure-html/connections-yarn-cluster-diagram-1.png" height="280pt" />

FIGURE 7.6: YARN cluster connection diagram

To connect in YARN cluster mode, simply run the following:
<code>sc &lt;- spark_connect(master = "yarn-cluster")</code>
Cluster mode assumes that the node running <code>spark_connect()</code> is properly configured, meaning that <code>yarn-site.xml</code> exists and the <code>YARN_CONF_DIR</code> environment variable is properly set. 
When using Hadoop as a file system, you will also need the <code>HADOOP_CONF_DIR</code> environment variable properly configured. 
In addition, you would need to ensure proper network connectivity between the client and the driver node—not just by having both machines reachable, but also by making sure that they have sufficient bandwidth between them. 
This configuration is usually provided by your system administrator and is not something that you would need to manually configure.

<h2>7.5 Livy</h2>
As opposed to other connection methods that require using an edge node in the cluster, Livy provides a <em>web API</em> that makes the Spark cluster accessible from outside the cluster and does not require a Spark installation in the client. 
After it’s connected through the web API, the <em>Livy Service</em> starts the Spark context by requesting resources from the cluster manager and distributing work as usual. 
Figure 7.7 illustrates a Livy connection; notice that the client connects remotely to the driver through a web API.

<img src="https://therinspark.com/the-r-in-spark_files/figure-html/connections-livy-diagram-1.png" height="280pt" />

FIGURE 7.7: Livy connection diagram

Connecting through Livy requires the URL to the Livy service, which should be similar to <code>https://hostname:port/livy</code>. 
Since remote connections are allowed, connections usually require, at the very least, basic authentication:
<code>sc &lt;- spark_connect(
  master = "https://hostname:port/livy",
  method = "livy", config = livy_config(
    spark_version = "2.4.0",
    username = "&lt;username>",
    password = "&lt;password>"
  ))</code>
To try out Livy on your local machine, you can install and run a Livy service as described under the Clusters - Livy section and then connect as follows:
<code>sc &lt;- spark_connect(
  master = "http://localhost:8998",
  method = "livy",
  version = "2.4.0")</code>
After you’re connected through Livy, you can make use of any <code>sparklyr</code> feature; however, Livy is not suitable for exploratory data analysis, since executing commands has a significant performance cost. 
That said, while running long-running computations, this overhead could be considered irrelevant. 
In general, you should prefer to avoid using Livy and work directly within an edge node in the cluster; when this is not feasible, using Livy could be a reasonable approach.
<strong>Note:</strong> Specifying the Spark version through the <code>spark_version</code> parameter is optional; however, when the version is specified, performance is significantly improved by deploying precompiled Java binaries compatible with the given version. 
Therefore, it is a best practice to specify the Spark version when connecting to Spark using Livy.

<h2>7.6 Mesos</h2>
Similar to YARN, Mesos supports client mode and a cluster mode; however, <code>sparklyr</code> currently supports only client mode under Mesos. 
Therefore, the diagram shown in Figure 7.8 is equivalent to YARN client’s diagram with only the cluster manager changed from YARN to Mesos.

<img src="https://therinspark.com/the-r-in-spark_files/figure-html/connections-mesos-diagram-1.png" height="280pt" />

FIGURE 7.8: Mesos connection diagram

Connecting requires the address to the Mesos master node, usually in the form of <code>mesos://host:port</code> or <code>mesos://zk://host1:2181,host2:2181,host3:2181/mesos</code> for Mesos using ZooKeeper:
<code>sc &lt;- spark_connect(master = "mesos://host:port")</code>
The <code>MESOS_NATIVE_JAVA_LIBRARY</code> environment variable needs to be set by your system administrator or manually set when you are running Mesos on your local machine. 
For instance, in macOS, you can install and initialize Mesos from a terminal, followed by manually setting the <code>mesos</code> library and connecting with <code>spark_connect()</code>:
<code>brew install mesos
/usr/local/Cellar/mesos/1.6.1/sbin/mesos-master --registry=in_memory
  --ip=127.0.0.1 MESOS_WORK_DIR=. 
/usr/local/Cellar/mesos/1.6.1/sbin/mesos-slave
  --master=127.0.0.1:5050</code>
<code>Sys.setenv(MESOS_NATIVE_JAVA_LIBRARY = 
             "/usr/local/Cellar/mesos/1.6.1/lib/libmesos.dylib")

sc &lt;- spark_connect(master = "mesos://localhost:5050",
                    spark_home = spark_home_dir())</code>

<h2>7.7 Kubernetes</h2>
Kubernetes clusters do not support client modes like Mesos or YARN; instead, the connection model is similar to YARN cluster, where the driver node is assigned by Kubernetes, as illustrated in Figure 7.9.

<img src="https://therinspark.com/the-r-in-spark_files/figure-html/connections-kubernetes-diagram-1.png" height="280pt" />

FIGURE 7.9: Kubernetes connection diagram

To use Kubernetes, you will need to prepare a virtual machine with Spark installed and properly configured; however, it is beyond the scope of this book to present how to create one. 
Once created, connecting to Kubernetes works as follows:
<code>library(sparklyr)
sc &lt;- spark_connect(config = spark_config_kubernetes(
  "k8s://https://&lt;apiserver-host>:&lt;apiserver-port>",
  account = "default",
  image = "docker.io/owner/repo:version",
  version = "2.3.1"))</code>
If your computer is already configured to use a Kubernetes cluster, you can use the following command to find the <code>apiserver-host</code> and <code>apiserver-port</code>:
<code>system2("kubectl", "cluster-info")</code>

<h2>7.8 Cloud</h2>
When you are working with cloud providers, there are a few connection differences. 
For instance, connecting from Databricks requires the following connection method:
<code>sc &lt;- spark_connect(method = "databricks")</code>
Since Amazon EMR makes use of YARN, you can connect using <code>master = "yarn"</code>:
<code>sc &lt;- spark_connect(master = "yarn")</code>
Connecting to Spark when using IBM’s Watson Studio requires you to retrieve a configuration object through a <code>load_spark_kernels()</code> function that IBM provides:
<code>kernels &lt;- load_spark_kernels()
sc &lt;- spark_connect(config = kernels[2])</code>
In Microsoft Azure HDInsights and when using ML Services (R Server), a Spark connection is initialized as follows:
<code>library(RevoScaleR)
cc &lt;- rxSparkConnect(reset = TRUE, interop = "sparklyr")
sc &lt;- rxGetSparklyrConnection(cc)</code>
Connecting from Qubole requires using the <code>qubole</code> connection method:
<code>sc &lt;- spark_connect(method = "qubole")</code>
Refer to your cloud provider’s documentation and support channels if you need help.

<h2>7.9 Batches</h2>
Most of the time, you use <code>sparklyr</code> interactively; that is, you explicitly connect with <code>spark_connect()</code> and then execute commands to analyze and model large-scale data. 
However, you can also automate processes by scheduling Spark jobs that use <code>sparklyr</code>. 
Spark does not provide tools to schedule data-processing tasks; instead, you would use other workflow management tools. 
This can be useful to transform data, prepare a model and score data overnight, or to make use of Spark by other systems.
As an example, you can create a file named <code>batch.R</code> with the following contents:
<code>library(sparklyr)

sc &lt;- spark_connect(master = "local")

sdf_len(sc, 10) %>% spark_write_csv("batch.csv")

spark_disconnect(sc)</code>
You can then submit this application to Spark in batch mode using <code>spark_submit()</code>, the <code>master</code> parameter should be set to the appropriately.
<code>spark_submit(master = "local", "batch.R")</code>
You can also invoke <code>spark-submit</code> from the shell directly through the following:
<code>/spark-home-path/spark-submit
  --class sparklyr.Shell &#39;/spark-jars-path/sparklyr-2.3-2.11.jar&#39;
  8880 12345 --batch /path/to/batch.R</code>
The last parameters represent the port number <code>8880</code> and the session number <code>12345</code>, which you can set to any unique numeric identifier. 
You can use the following R code to get the correct paths:
<code># Retrieve spark-home-path
spark_home_dir()

# Retrieve spark-jars-path
system.file("java", package = "sparklyr")</code>
You can customize your script by passing additional command-line arguments to <code>spark-submit</code> and then read them back in R using <code>commandArgs()</code>.

<h2>7.10 Tools</h2>
When connecting to a Spark cluster using tools like Jupyter and RStudio, you can run the same connection parameters presented in this chapter. 
However, since many cloud providers make use of a web proxy to secure Spark’s web interface, to use <code>spark_web()</code> or the RStudio Connections pane extension, you need to properly configure the <code>sparklyr.web.spark</code> setting, which you would then pass to <code>spark_config()</code> through the <code>config</code> parameter.
For instance, when using Amazon EMR, you can configure <code>sparklyr.web.spark</code> and <code>sparklyr.web.yarn</code> by dynamically retrieving the YARN application and building the EMR proxy URL:
<code>domain &lt;- "http://ec2-12-345-678-9.us-west-2.compute.amazonaws.com"
config &lt;- spark_config()
config$sparklyr.web.spark &lt;- ~paste0(
  domain, ":20888/proxy/", invoke(spark_context(sc), "applicationId"))
config$sparklyr.web.yarn &lt;- paste0(domain, ":8088")

sc &lt;- spark_connect(master = "yarn", config = config)</code>

<h2>7.11 Multiple</h2>
It is common to connect once, and only once, to Spark. 
However, you can also open multiple connections to Spark by connecting to different clusters or by specifying the <code>app_name</code> parameter. 
This can be helpful to compare Spark versions or validate your analysis before submitting to the cluster. 
The following example opens connections to Spark 1.6.3, 2.3.0 and Spark Standalone:
<code># Connect to local Spark 1.6.3
sc_16 &lt;- spark_connect(master = "local", version = "1.6")

# Connect to local Spark 2.3.0
sc_23 &lt;- spark_connect(master = "local", version = "2.3", appName = "Spark23")

# Connect to local Spark Standalone
sc_standalone &lt;- spark_connect(master = "spark://host:port")</code>
Finally, you can disconnect from each connection:
<code>spark_disconnect(sc_1_6_3)
spark_disconnect(sc_2_3_0)
spark_disconnect(sc_standalone)</code>
Alternatively, you can disconnect from all connections at once:
<code>spark_disconnect_all()</code>

<h2>7.12 Troubleshooting</h2>
Last but not least, we introduce the following troubleshooting techniques: <em>Logging</em>, <em>Spark Submit</em>, and <em>Windows</em>. 
When in doubt about where to begin, start with the Windows section when using Windows systems, followed by Logging and finally Spark Submit. 
These techniques are useful when running <code>spark_connect()</code> fails with an error message.

<h3>7.12.1 Logging</h3>
The first technique to troubleshoot connections is to print Spark logs directly to the console to help you spot additional error messages:
<code>sc &lt;- spark_connect(master = "local", log = "console")</code>
In addition, you can enable verbose logging by setting the <code>sparklyr.verbose</code> option to <code>TRUE</code> when connecting:
<code>sc &lt;- spark_connect(master = "local", log = "console",
                    config = list(sparklyr.verbose = TRUE))</code>

<h3>7.12.2 Spark Submit</h3>
You can diagnose whether a connection issue is specific to R or Spark in general by running an example job through <code>spark-submit</code> and validating that no errors are thrown:
<code># Find the spark directory using an environment variable
spark_home &lt;- Sys.getenv("SPARK_HOME")

# Or by getting the local spark installation
spark_home &lt;- sparklyr::spark_home_dir()</code>
Then, execute the sample compute Pi example by replacing “local” with the correct master parameter that you are troubleshooting:
<code># Launching a sample application to compute Pi
system2(
  file.path(spark_home, "bin", "spark-submit"),
  c(
    "--master", "local",
    "--class", "org.apache.spark.examples.SparkPi",
    dir(file.path(spark_home, "examples", "jars"), 
        pattern = "spark-examples", full.names = TRUE),
    100),
  stderr = FALSE
)</code>
<code>Pi is roughly 3.1415503141550314</code>
If the preceding message is not displayed, you will need to investigate why your Spark cluster is not properly configured, which is beyond the scope of this book. 
As a start, rerun the Pi example but remove <code>stderr = FALSE</code>; this prints errors to the console, which you then can use to investigate what the problem might be. 
When using a cloud provider or a Spark distribution, you can contact their support team to help you troubleshoot this further; otherwise, Stack Overflow is a good place to start.
If you do see the message, this means that your Spark cluster is properly configured but somehow R is not able to use Spark, so you need to troubleshoot in detail, as we will explain next.

<h4>7.12.2.1 Detailed</h4>
To troubleshoot the connection process in detail, you can manually replicate the two-step connection process, which is often very helpful to diagnose connection issues. 
First, <code>spark-submit</code> is triggered from R, which submits the application to Spark; second, R connects to the running Spark application.
First, identify the Spark installation directory and the path to the correct <code>sparklyr*.jar</code> file by running the following:
<code>dir(system.file("java", package = "sparklyr"),
    pattern = "sparklyr", full.names = T)</code>
Ensure that you identify the correct version that matches your Spark cluster—for instance, <code>sparklyr-2.1-2.11.jar</code> for Spark 2.1.
Then, from the terminal, run this:
<code>$SPARK_HOME/bin/spark-submit --class sparklyr.Shell $PATH_TO_SPARKLYR_JAR 8880 42</code>
<code>18/06/11 12:13:53 INFO sparklyr: Session (42) found port 8880 is available
18/06/11 12:13:53 INFO sparklyr: Gateway (42) is waiting for sparklyr client
                                 to connect to port 8880</code>
The parameter <code>8880</code> represents the default port to use in <code>sparklyr</code>, while 42 is the session number, which is a cryptographically secure number generated by <code>sparklyr</code>, but for troubleshooting purposes can be as simple as <code>42</code>.
If this first connection step fails, it means that the cluster can’t accept the application. 
This usually means that there are not enough resources, or there are permission restrictions.
The second step is to connect from R as follows (notice that there is a 60-second timeout, so you’ll need to run the R command after running the terminal command; if needed, you can configure this timeout as described in Chapter 9):
<code>library(sparklyr)
sc &lt;- spark_connect(master = "sparklyr://localhost:8880/42", version = "2.3")</code>
If this second connection step fails, it usually means that there is a connectivity problem between R and the driver node. 
You can try using a different connection port, for instance.

<h3>7.12.3 Windows</h3>
Connecting from Windows is, in most cases, as straightforward as connecting from Linux and macOS. 
However, there are a few common connection issues that you should be aware of:
<ul>
<li>Firewalls and antivirus software might block ports for your connection. 
The default port used by <code>sparklyr</code> is <code>8880</code>; double-check that this port is not being blocked.</li>
<li>Long path names can cause issues, especially with older Windows systems like Windows 7. 
When you’re using these systems, try connecting with Spark installed with all folders, using at most eight characters and no spaces in their names.</li>
</ul>

<h2>7.13 Recap</h2>
This chapter presented an overview of Spark’s architecture, connection concepts, and examples to connect in local mode, standalone, YARN, Mesos, Kubernetes, and Livy. 
It also presented edge nodes and their role while connecting to Spark clusters. 
This should have provided you with enough information to successfully connect to any Apache Spark cluster.
To troubleshoot connection problems beyond the techniques described in this chapter, we recommend that you search for the connection problem in Stack Overflow, the <code>sparklyr</code> issues GitHub page, and, if needed, open a new GitHub issue in <code>sparklyr</code> to assist further.
In &lt;&lt;data>>, we cover how to use Spark to read and write from a variety of data sources and formats, which allows you to be more agile when adding new data sources for data analysis. 
What used to take days, weeks, or even months, you now can complete in hours by embracing data lakes.

<h2><span class="orange">Chapter 8 Data</span></h2>
With the knowledge acquired in previous chapters, you are now equipped to start doing analysis and modeling at scale! So far, however, we haven’t really explained much about how to read data into Spark. 
We’ve explored how to use <code>copy_to()</code> to upload small datasets or functions like <code>spark_read_csv()</code> or <code>spark_write_csv()</code> without explaining in detail how and why.
So, you are about to learn how to read and write data using Spark. 
And, while this is important on its own, this chapter will also introduce you to the <em>data lake</em>—a repository of data stored in its natural or raw format that provides various benefits over existing storage architectures. 
For instance, you can easily integrate data from external systems without transforming it into a common format and without assuming those sources are as reliable as your internal data sources.
In addition, we will also discuss how to extend Spark’s capabilities to work with data not accessible out of the box and make several recommendations focused on improving performance for reading and writing data. 
Reading large datasets often requires you to fine-tune your Spark cluster configuration, but that’s the topic of Chapter 9.

<h2>8.1 Overview</h2>
In Chapter 1, you learned that beyond big data and big compute, you can also use Spark to improve velocity, variety, and veracity in data tasks. 
While you can use the learnings of this chapter for any task requiring loading and storing data, it is particularly interesting to present this chapter in the context of dealing with a variety of data sources. 
To understand why, we should first take a quick detour to examine how data is currently processed in many organizations.
For several years, it’s been a common practice to store large datasets in a relational <em>database</em>, a system first proposed in 1970 by Edgar F. 
Codd. 
You can think of a database as a collection of tables that are related to one another, where each table is carefully designed to hold specific data types and relationships to other tables. 
Most relational database systems use <em>Structured Query Language</em> (SQL) for querying and maintaining the database. 
Databases are still widely used today, with good reason: they store data reliably and consistently; in fact, your bank probably stores account balances in a database and that’s a good practice.
However, databases have also been used to store information from other applications and systems. 
For instance, your bank might also store data produced by other banks, such as incoming checks. 
To accomplish this, the external data needs to be extracted from the external system, transformed into something that fits the current database, and finally be loaded into it. 
This is known as <em>Extract, Transform, and Load</em> (ETL), a general procedure for copying data from one or more sources into a destination system that represents the data differently from the source. 
The ETL process became popular in the 1970s.
Aside from databases, data is often also loaded into a <em>data warehouse</em>, a system used for reporting and data analysis. 
The data is usually stored and indexed in a format that increases data analysis speed but that is often not suitable for modeling or running custom distributed code. 
The challenge is that changing databases and data warehouses is usually a long and delicate process, since data needs to be reindexed and the data from multiple data sources needs to be carefully transformed into single tables that are shared across data sources.
Instead of trying to transform all data sources into a common format, you can embrace this variety of data sources in a <em>data lake</em>, a system or repository of data stored in its natural format (see Figure 8.1). 
Since data lakes make data available in its original format, there is no need to carefully transform it in advance; anyone can use it for analysis, which adds significant flexibility over ETL. 
You then can use Spark to unify data processing from data lakes, databases, and data warehouses through a single interface that is scalable across all of them. 
Some organizations also use Spark to replace their existing ETL process; however, this falls in the realm of data engineering, which is well beyond the scope of this book. 
We illustrate this with dotted lines in Figure 8.1.

<img src="https://therinspark.com/the-r-in-spark_files/figure-html/data-data-lake-1.png" height="280pt" />

FIGURE 8.1: Spark processing raw data from a data lakes, databases, and data warehouses

In order to support a broad variety of data source, Spark needs to be able to read and write data in several different <em>file formats</em> (CSV, JSON, Parquet, etc), access them while stored in several <em>file systems</em> (HDFS, S3, DBFS, etc) and, potentially, interoperate with other <em>storage systems</em> (databases, data warehouses, etc). 
We will get to all of that; but first, we will start by presenting how to read, write and copy data using Spark.

<h2>8.2 Reading Data</h2>
To support a broad variety of data sources, Spark needs to be able to read and write data in several different file formats (CSV, JSON, Parquet, and others), and access them while stored in several file systems (HDFS, S3, DBFS, and more) and, potentially, interoperate with other storage systems (databases, data warehouses, etc.). 
We will get to all of that, but first, we will start by presenting how to read, write, and copy data using Spark.

<h3>8.2.1 Paths</h3>
If you are new to Spark, it is highly recommended to review this section before you start working with large datasets. 
We will introduce several techniques that improve the speed and efficiency of reading data. 
Each subsection presents specific ways to take advantage of how Spark reads files, such as the ability to treat entire folders as datasets as well as being able to describe them to read datasets faster in Spark.
<code>letters &lt;- data.frame(x = letters, y = 1:length(letters))

dir.create("data-csv")
write.csv(letters[1:3, ], "data-csv/letters1.csv", row.names = FALSE)
write.csv(letters[1:3, ], "data-csv/letters2.csv", row.names = FALSE)

do.call("rbind", lapply(dir("data-csv", full.names = TRUE), read.csv))</code>
<code>  x y
1 a 1
2 b 2
3 c 3
4 a 1
5 b 2
6 c 3</code>
In Spark, there is the notion of a folder as a dataset. 
Instead of enumerating each file, simply pass the path containing all the files. 
Spark assumes that every file in that folder is part of the same dataset. 
This implies that the target folder should be used only for data purposes. 
This is especially important since storage systems like HDFS store files across multiple machines, but, conceptually, they are stored in the same folder; when Spark reads the files from this folder, it’s actually executing distributed code to read each file within each machine—no data is transferred between machines when distributed files are read:
<code>library(sparklyr)
sc &lt;- spark_connect(master = "local", version = "2.3")

spark_read_csv(sc, "data-csv/")</code>
<code># Source: spark&lt;datacsv> [?? x 2]
   x         y
   &lt;chr> &lt;int>
 1 a         1
 2 b         2
 3 c         3
 4 d         4
 5 e         5
 6 a         1
 7 b         2
 8 c         3
 9 d         4
10 e         5</code>
The “folder as a table” idea is found in other open source technologies as well. 
Under the hood, Hive tables work the same way. 
When you query a Hive table, the mapping is done over multiple files within the same folder. 
The folder’s name usually matches the name of the table visible to the user.
Next, we will present a technique that allows Spark to read files faster as well as to reduce read failures by describing the structure of a dataset in advance.

<h3>8.2.2 Schema</h3>
When reading data, Spark is able to determine the data source’s column names and column types, also known as the <em>schema</em>. 
However, guessing the schema comes at a cost; Spark needs to do an initial pass on the data to guess what it is. 
For a large dataset, this can add a significant amount of time to the data ingestion process, which can become costly even for medium-size datasets. 
For files that are read over and over again, the additional read time accumulates over time.
To avoid this, Spark allows you to provide a column definition by providing a <code>columns</code> argument to describe your dataset. 
You can create this schema by sampling a small portion of the original file yourself:
<code>spec_with_r &lt;- sapply(read.csv("data-csv/letters1.csv", nrows = 10), class)
spec_with_r</code>
<code>        x         y 
 "factor" "integer" </code>
Or, you can set the column specification to a vector containing the column types explicitly. 
The vector’s values are named to match the field names:
<code>spec_explicit &lt;- c(x = "character", y = "numeric")
spec_explicit</code>
<code>          x           y 
"character"   "numeric" </code>
The accepted variable types are: <code>integer</code>, <code>character</code>, <code>logical</code>, <code>double</code>, <code>numeric</code>, <code>factor</code>, <code>Date</code>, and <code>POSIXct</code>.
Then, when reading using <code>spark_read_csv()</code>, you can pass <code>spec_with_r</code> to the <code>columns</code> argument to match the names and types of the original file. 
This helps to improve performance since Spark will not need to determine the column types.
<code>spark_read_csv(sc, "data-csv/", columns = spec_with_r)</code>
<code># Source: spark&lt;datacsv> [?? x 2]
  x         y
  &lt;chr> &lt;int>
1 a         1
2 b         2
3 c         3
4 a         1
5 b         2
6 c         3</code>
The following example shows how to set the field type to something different. 
However, the new field type needs to be a compatible type in the original dataset. 
For example, you cannot set a <code>character</code> field to <code>numeric</code>. 
If you use an incompatible type, the file read will fail with an error. 
Additionally, the following example also changes the names of the original fields:
<code>spec_compatible &lt;- c(my_letter = "character", my_number = "character")

spark_read_csv(sc, "data-csv/", columns = spec_compatible)</code>
<code># Source: spark&lt;datacsv> [?? x 2]
  my_letter my_number
  &lt;chr>     &lt;chr>    
1 a         1        
2 b         2        
3 c         3        
4 a         1        
5 b         2        
6 c         3    </code>
In Spark, malformed entries can cause errors during reading, particularly for non-character fields. 
To prevent such errors, we can use a file specification that imports them as characters and then use <code>dplyr</code> to coerce the field into the desired type.
This subsection reviewed how we can read files faster and with fewer failures, which lets us start our analysis more quickly. 
Another way to accelerate our analysis is by loading less data into Spark memory, which we examine in the next section.

<h3>8.2.3 Memory</h3>
By default, when using Spark with R, when you read data, it is copied into Spark’s distributed memory, making data analysis and other operations very fast. 
There are cases, such as when the data is too big, for which loading all the data might not be practical or even necessary. 
For those cases, Spark can just “map” the files without copying data into memory.
The mapping creates a sort of virtual table in Spark. 
The implication is that when a query runs against that table, Spark needs to read the data from the files at that time. 
Any consecutive reads after that will do the same. 
In effect, Spark becomes a pass-through for the data. 
The advantage of this method is that there is almost no up-front time cost to “reading” the file; the mapping is very fast. 
The downside is that running queries that actually extract data will take longer.
This is controlled by the <code>memory</code> argument of the read functions. 
Setting it to <code>FALSE</code> prevents the data copy (the default is <code>TRUE</code>):
<code>mapped_csv &lt;- spark_read_csv(sc, "data-csv/", memory = FALSE)</code>
There are good use cases for this method, one of which is when not all columns of a table are needed. 
For example, take a very large file that contains many columns. 
Assuming this is not the first time you interact with this data, you would know what columns are needed for the analysis. 
When you know which columns you need, the files can be read using <code>memory = FALSE</code>, and then the needed columns can be selected with <code>dplyr</code>. 
The resulting <code>dplyr</code> variable can then be cached into memory, using the <code>compute()</code> function. 
This will make Spark query the file(s), pull the selected fields, and copy only that data into memory. 
The result is an in-memory table that took comparatively less time to ingest:
<code>mapped_csv %>%
  dplyr::select(y) %>%
  dplyr::compute("test")</code>
The next section covers a short technique to make it easier to carry the original field names of imported data.

<h3>8.2.4 Columns</h3>
Spark 1.6 required that column names be sanitized, so R does that by default. 
There might be cases when you would like to keep the original names intact, or when working with Spark version 2.0 or above. 
To do that, set the <code>sparklyr.sanitize.column.names</code> option to <code>FALSE</code>:
<code>options(sparklyr.sanitize.column.names = FALSE)
copy_to(sc, iris, overwrite = TRUE)</code>
<code># Source:   table&lt;iris> [?? x 5]
# Database: spark_connection
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
          &lt;dbl>       &lt;dbl>        &lt;dbl>       &lt;dbl> &lt;chr>  
 1          5.1         3.5          1.4         0.2 setosa 
 2          4.9         3            1.4         0.2 setosa 
 3          4.7         3.2          1.3         0.2 setosa 
 4          4.6         3.1          1.5         0.2 setosa 
 5          5           3.6          1.4         0.2 setosa 
 6          5.4         3.9          1.7         0.4 setosa 
 7          4.6         3.4          1.4         0.3 setosa 
 8          5           3.4          1.5         0.2 setosa 
 9          4.4         2.9          1.4         0.2 setosa 
10          4.9         3.1          1.5         0.1 setosa 
# ... 
with more rows</code>
With this review of how to read data into Spark, we move on to look at how we can write data from our Spark session.

<h2>8.3 Writing Data</h2>
Some projects require that new data generated in Spark be written back to a remote source. 
For example, the data could be new predicted values returned by a Spark model. 
The job processes the mass generation of predictions, but then the predictions need to be stored. 
This section focuses on how you should use Spark for moving the data from Spark into an external destination.
Many new users start by downloading Spark data into R, and then upload it to a target, as illustrated in Figure 8.2. 
It works for smaller datasets, but it becomes inefficient for larger ones. 
The data typically grows in size to the point that it is no longer feasible for R to be the middle point.

<img src="https://therinspark.com/the-r-in-spark_files/figure-html/data-avoid-approach-1.png" height="100pt" />

FIGURE 8.2: Incorrect use of Spark when writing large datasets

All efforts should be made to have Spark connect to the target location. 
This way, reading, processing, and writing happens within the same Spark session.
As Figure 8.3 shows, a better approach is to use Spark to read, process, and write to the target. 
This approach is able to scale as big as the Spark cluster allows, and prevents R from becoming a choke point.

<img src="https://therinspark.com/the-r-in-spark_files/figure-html/data-recommended-approach-1.png" height="100pt" />

FIGURE 8.3: Correct use of Spark when writing large datasets

Consider the following scenario: a Spark job just processed predictions for a large dataset, resulting in a considerable amount of predictions. 
Choosing a method to write results will depend on the technology infrastructure you are working on. 
More specifically, it will depend on Spark and the target running, or not, in the same cluster.
Back to our scenario, we have a large dataset in Spark that needs to be saved. 
When Spark and the target are in the same cluster, copying the results is not a problem; the data transfer is between RAM and disk of the same cluster or efficiently shuffled through a high-bandwidth connection.
But what to do if the target is not within the Spark cluster? There are two options, and choosing one will depend on the size of the data and network speed:

<dt>Spark transfer</dt>
In this case, Spark connects to the remote target location and copies the new data. 
If this is done within the same datacenter, or cloud provider, the data transfer could be fast enough to have Spark write the data directly.

<dt>External transfer and otherwise</dt>
Spark can write the results to disk and transfers them via a third-party application. 
Spark writes the results as files and then a separate job copies the files over. 
In the target location, you would use a separate process to transfer the data into the target location.

It is best to recognize that Spark, R, and any other technology are tools. 
No tool can do everything, nor should be expected to. 
Next we will describe how to copy data into Spark or collect large datasets that don’t fit in-memory, this can be used to transfer data across clusters, or help initialize your distributed datasets.

<h2>8.4 Copy</h2>
Previous chapters used <code>copy_to()</code> as a handy helper to copy data into Spark; however, you can use <code>copy_to()</code> only to transfer in-memory datasets that are already loaded in memory. 
These datasets tend to be much smaller than the kind of datasets you would want to copy into Spark.
For instance, suppose that we have a 3 GB dataset generated as follows:
<code>dir.create("largefile.txt")
write.table(matrix(rnorm(10 * 10^6), ncol = 10), "largefile.txt/1",
            append = T, col.names = F, row.names = F)
for (i in 2:30) 
  file.copy("largefile.txt/1", paste("largefile.txt/", i))</code>
If we had only 2 GB of memory in the driver node, we would not be able to load this 3 GB file into memory using <code>copy_to()</code>. 
Instead, when using the HDFS as storage in your cluster, you can use the <code>hadoop</code> command-line tool to copy files from disk into Spark from the terminal as follows. 
Notice that the following code works only in clusters using HDFS, not in local environments.
<code>hadoop fs -copyFromLocal largefile.txt largefile.txt</code>
You then can read the uploaded file, as described in the File Formats section; for text files, you would run:
<code>spark_read_text(sc, "largefile.txt", memory = FALSE)</code>
<code># Source: spark&lt;largefile> [?? x 1]
   line                                                                   
   &lt;chr>                                                                  
 1 0.0982531064914565 -0.577567317599452 -1.66433938237253 -0.20095089489…
 2 -1.08322304504007 1.05962389624635 1.1852771207729 -0.230934710049462 …
 3 -0.398079835552421 0.293643382374479 0.727994248743204 -1.571547990532…
 4 0.418899768227183 0.534037617828835 0.921680317620166 -1.6623094393911…
 5 -0.204409401553028 -0.0376212693728992 -1.13012269711811 0.56149527218…
 6 1.41192628218417 -0.580413572014808 0.727722566256326 0.5746066486689 …
 7 -0.313975036262443 -0.0166426329807508 -0.188906975208319 -0.986203251…
 8 -0.571574679637623 0.513472254005066 0.139050812059352 -0.822738334753…
 9 1.39983023148955 -1.08723592838627 1.02517804413913 -0.412680186313667…
10 0.6318328148434 -1.08741784644221 -0.550575696474202 0.971967251067794…
# … with more rows</code>
<code>collect()</code> has a similar limitation in that it can collect only datasets that fit your driver memory; however, if you had to extract a large dataset from Spark through the driver node, you could use specialized tools provided by the distributed storage. 
For HDFS, you would run the following:
<code>hadoop fs -copyToLocal largefile.txt largefile.txt</code>
Alternatively, you can also collect datasets that don’t fit in memory by providing a callback to <code>collect()</code>. 
A callback is just an R function that will be called over each Spark partition. 
You then can write this dataset to disk or push to other clusters over the network.
You could use the following code to collect 3 GB even if the driver node collecting this dataset had less than 3 GB of memory. 
That said, as Chapter 3 explains, you should avoid collecting large datasets into a single machine since this creates a significant performance bottleneck. 
For conciseness, we will collect only the first million rows; feel free to remove <code>head(10^6)</code> if you have a few minutes to spare:
<code>dir.create("large")
spark_read_text(sc, "largefile.txt", memory = FALSE) %>%
  head(10^6) %>%
  collect(callback = function(df, idx) {
    writeLines(df$line, paste0("large/large-", idx, ".txt"))
  })</code>
Make sure you clean up these large files and empty your recycle bin as well:
<code>unlink("largefile.txt", recursive = TRUE)
unlink("large", recursive = TRUE)</code>
In most cases, data will already be stored in the cluster, so you should not need to worry about copying large datasets; instead, you can usually focus on reading and writing different file formats, which we describe next.

<h2>8.5 File Formats</h2>
Out of the box, Spark is able to interact with several file formats, like CSV, JSON, LIBSVM, ORC, and Parquet. 
Table 8.1 maps the file format to the function you should use to read and write data in Spark.
<table>
<caption>TABLE 8.1: Spark functions to read and write file formats</caption>
<thead>
<tr><th align="left">Format</th><th align="left">Read</th><th align="left">Write</th></tr>
</thead>
<tbody>
<tr><td align="left">Comma separated values (CSV)</td><td align="left">spark_read_csv()</td><td align="left">spark_write_csv()</td></tr>
<tr><td align="left">JavaScript Object Notation (JSON)</td><td align="left">spark_read_json()</td><td align="left">spark_write_json()</td></tr>
<tr><td align="left">Library for Support Vector Machines (LIBSVM)</td><td align="left">spark_read_libsvm()</td><td align="left">spark_write_libsvm()</td></tr>
<tr><td align="left">Optimized Row Columnar (ORC)</td><td align="left">spark_read_orc()</td><td align="left">spark_write_orc()</td></tr>
<tr><td align="left">Apache Parquet</td><td align="left">spark_read_parquet()</td><td align="left">spark_write_parquet()</td></tr>
<tr><td align="left">Text</td><td align="left">spark_read_text()</td><td align="left">spark_write_text()</td></tr>
</tbody>
</table>
The following sections will describe special considerations particular to each file format as well as some of the strengths and weaknesses of some popular file formats, starting with the well-known CSV file format.

<h3>8.5.1 CSV</h3>
The CSV format might be the most common file type in use today. 
It is defined by a text file separated by a given character, usually a comma. 
It should be pretty straightforward to read CSV files; however, it’s worth mentioning a couple techniques that can help you process CSVs that are not fully compliant with a well-formed CSV file. 
Spark offers the following modes for addressing parsing issues:

<dt>Permissive</dt>
Inserts NULL values for missing tokens

<dt>Drop Malformed</dt>
Drops lines that are malformed

<dt>Fail Fast</dt>
Aborts if it encounters any malformed line

You can use these in <code>sparklyr</code> by passing them inside the <code>options</code> argument. 
The following example creates a file with a broken entry. 
It then shows how it can be read into Spark:
<code>## Creates bad test file
writeLines(c("bad", 1, 2, 3, "broken"), "bad.csv")

spark_read_csv(
  sc,
  "bad3",
  "bad.csv",
  columns = list(foo = "integer"),
  options = list(mode = "DROPMALFORMED"))</code>
<code># Source: spark&lt;bad3> [?? x 1]
    foo
  &lt;int>
1     1
2     2
3     3</code>
Spark provides an issue tracking column, which was hidden by default. 
To enable it, add <code>_corrupt_record</code> to the <code>columns</code> list. 
You can combine this with the use of the <code>PERMISSIVE</code> mode. 
All rows will be imported, invalid entries will receive an <code>NA</code>, and the issue will be tracked in the <code>_corrupt_record</code> column:
<code>spark_read_csv(
  sc,
  "bad2",
  "bad.csv",
  columns = list(foo = "integer", "_corrupt_record" = "character"),
  options = list(mode = "PERMISSIVE")
)</code>
<code># Source: spark&lt;bad2> [?? x 2]
    foo `_corrupt_record`
  &lt;int> &lt;chr>            
1     1 NA               
2     2 NA               
3     3 NA               
4    NA broken  </code>
Reading and storing data as CSVs is quite common and supported across most systems. 
For tabular datasets, it is still a popular option, but for datasets containing nested structures and nontabular data, JSON is usually preferred.

<h3>8.5.2 JSON</h3>
JSON is a file format originally derived from JavaScript that has grown to be language-independent and very popular due to its flexibility and ubiquitous support. 
Reading and writing JSON files is quite straightforward:
<code>writeLines("{&#39;a&#39;:1, &#39;b&#39;: {&#39;f1&#39;: 2, &#39;f3&#39;: 3}}", "data.json")
simple_json &lt;- spark_read_json(sc, "data.json")
simple_json</code>
<code># Source: spark&lt;data> [?? x 2]
      a b         
  &lt;dbl> &lt;list>    
1     1 &lt;list [2]></code>
However, when you deal with a dataset containing nested fields like the one from this example, it is worth pointing out how to extract nested fields. 
One approach is to use a JSON path, which is a domain-specific syntax commonly used to extract and query JSON files. 
You can use a combination of <code>get_json_object()</code> and <code>to_json()</code> to specify the JSON path you are interested in. 
To extract <code>f1</code> you would run the following transformation:
<code>simple_json %>% dplyr::transmute(z = get_json_object(to_json(b), &#39;$.f1&#39;))</code>
<code># Source: spark&lt;?> [?? x 3]
      a b          z    
  &lt;dbl> &lt;list>     &lt;chr>
1     1 &lt;list [2]> 2 </code>
Another approach is to install <code>sparkly.nested</code> from CRAN with <code>install.packages("sparklyr.nested")</code> and then unnest nested data with <code>sdf_unnest()</code>:
<code>sparklyr.nested::sdf_unnest(simple_json, "b")</code>
<code># Source: spark&lt;?> [?? x 3]
      a    f1    f3
  &lt;dbl> &lt;dbl> &lt;dbl>
1     1     2     3</code>
While JSON and CSVs are quite simple to use and versatile, they are not optimized for performance; however, other formats like ORC, AVRO, and Parquet are.

<h3>8.5.3 Parquet</h3>
Apache Parquet, Apache ORC, and Apache AVRO are all file formats designed with performance in mind. 
Parquet and ORC store data in columnar format, while AVRO is row-based. 
All of them are binary file formats, which reduces storage space and improves performance. 
This comes at the cost of making them a bit more difficult to read by external systems and libraries; however, this is usually not an issue when used as intermediate data storage within Spark.
To illustrate this, Figure 8.4 plots the result of running a 1-million-row write-speed benchmark using the <code>bench</code> package; feel free to use your own benchmarks over meaningful datasets when deciding which format best fits your needs:
<code>numeric &lt;- copy_to(sc, data.frame(nums = runif(10^6)))
bench::mark(
  CSV = spark_write_csv(numeric, "data.csv", mode = "overwrite"),
  JSON = spark_write_json(numeric, "data.json", mode = "overwrite"),
  Parquet = spark_write_parquet(numeric, "data.parquet", mode = "overwrite"),
  ORC = spark_write_parquet(numeric, "data.orc", mode = "overwrite"),
  iterations = 20
) %>% ggplot2::autoplot()</code>

<img src="https://therinspark.com/images/data-file-format-benchmark-resized.png" />

FIGURE 8.4: One-million-rows write benchmark between CSV, JSON, Parquet, and ORC

From now on, be sure to disconnect from Spark whenever we present a new <code>spark_connect()</code> command:
<code>spark_disconnect(sc)</code>
This concludes the introduction to some of the out-of-the-box supported file formats, we will present next how to deal with formats that require external packages and customization.

<h3>8.5.4 Others</h3>
Spark is a very flexible computing platform. 
It can add functionality by using extension programs, called packages. 
You can access a new source type or file system by using the appropriate package.
Packages need to be loaded into Spark at connection time. 
To load the package, Spark needs its location, which could be inside the cluster, in a file share, or the internet.
In <code>sparklyr</code>, the package location is passed to <code>spark_connect()</code>. 
All packages should be listed in the <code>sparklyr.connect.packages</code> entry of the connection configuration.
It is possible to access data source types that we didn’t previously list. 
Loading the appropriate default package for Spark is the first of two steps The second step is to actually read or write the data. 
The <code>spark_read_source()</code> and <code>spark_write_source()</code> functions do that. 
They are generic functions that can use the libraries imported by a default package.
For instance, we can read XML files as follows:
<code>sc &lt;- spark_connect(master = "local", version = "2.3", config = list(
  sparklyr.connect.packages = "com.databricks:spark-xml_2.11:0.5.0"))

writeLines("&lt;ROWS>&lt;ROW>&lt;text>Hello World&lt;/text>&lt;/ROW>", "simple.xml")
spark_read_source(sc, "simple_xml", "simple.xml", "xml")</code>
<code># Source: spark&lt;data> [?? x 1]
  text       
  &lt;chr>      
1 Hello World</code>
which you can also write back to XML with ease, as follows:
<code>tbl(sc, "simple_xml") %>%
  spark_write_source("xml", options = list(path = "data.xml"))</code>
In addition, there are a few extensions developed by the R community to load additional file formats, such as <code>sparklyr.nested</code> to assist with nested data, <code>spark.sas7bdat</code> to read data from SAS, <code>sparkavro</code> to read data in AVRO format, and <code>sparkwarc</code> to read WARC files, which use extensibility mechanisms introduced in Chapter 10. 
Chapter 11 presents techniques to use R packages to load additional file formats, and Chapter 13 presents techniques to use Java libraries to complement this further. 
But first, let’s explore how to retrieve and store files from several different file systems.

<h2>8.6 File Systems</h2>
Spark defaults to the file system on which it is currently running. 
In a YARN managed cluster, the default file system will be HDFS. 
An example path of <em>/home/user/file.csv</em> will be read from the cluster’s HDFS folders, not the Linux folders. 
The operating system’s file system will be accessed for other deployments, such as Standalone, and <code>sparklyr</code>’s local.
The file system protocol can be changed when reading or writing. 
You do this via the <code>path</code> argument of the <code>sparklyr</code> function. 
For example, a full path of _file://home/user/file.csv_ forces the use of the local operating system’s file system.
There are many other file system protocols, such as <code>_dbfs://_</code> for Databricks’ file system, <code>_s3a://_</code> for Amazon’s S3 service, <code>_wasb://_</code> for Microsoft Azure storage, and <code>_gs://_</code> for Google storage.
Spark does not provide support for all them directly; instead, they are configured as needed. 
For instance, accessing the “s3a” protocol requires adding a package to the <code>sparklyr.connect.packages</code> configuration setting, while connecting and specifying appropriate credentials might require using the <code>AWS_ACCESS_KEY_ID</code> and <code>AWS_SECRET_ACCESS_KEY</code> environment variables.
<code>Sys.setenv(AWS_ACCESS_KEY_ID = my_key_id)
Sys.setenv(AWS_SECRET_ACCESS_KEY = my_secret_key)

sc &lt;- spark_connect(master = "local", version = "2.3", config = list(
  sparklyr.connect.packages = "org.apache.hadoop:hadoop-aws:2.7.7"))

my_file &lt;- spark_read_csv(sc, "my-file", path = "s3a://my-bucket/my-file.csv")</code>
Accessing other file protocols requires loading different packages, although, in some cases, the vendor providing the Spark environment might load the package for you. 
Please refer to your vendor’s documentation to find out whether that is the case.

<h2>8.7 Storage Systems</h2>
A data lake and Spark usually go hand-in-hand, with optional access to storage systems like databases and data warehouses. 
Presenting all the different storage systems with appropriate examples would be quite time-consuming, so instead we present some of the commonly used storage systems.
As a start, Apache <em>Hive</em> is a data warehouse software that facilitates reading, writing, and managing large datasets residing in distributed storage using SQL. 
In fact, Spark has components from Hive built directly into its sources. 
It is very common to have installations of Spark or Hive side-by-side, so we will start by presenting Hive, followed by Cassandra, and then close by looking at JDBC connections.

<h3>8.7.1 Hive</h3>
In YARN managed clusters, Spark provides a deeper integration with Apache Hive. 
Hive tables are easily accessible after opening a Spark connection.
You can access a Hive table’s data using <code>DBI</code> by referencing the table in a SQL statement:
<code>sc &lt;- spark_connect(master = "local", version = "2.3")
spark_read_csv(sc, "test", "data-csv/", memory = FALSE)

DBI::dbGetQuery(sc, "SELECT * FROM test limit 10")</code>
Another way to reference a table is with <code>dplyr</code> using the <code>tbl()</code> function, which retrieves a reference to the table:
<code>dplyr::tbl(sc, "test")</code>
It is important to reiterate that no data is imported into R; the <code>tbl()</code> function only creates a reference. 
You then can pipe more <code>dplyr</code> verbs following the <code>tbl()</code> command:
<code>dplyr::tbl(sc, "test") %>%
  dplyr::group_by(y) %>%
  dplyr::summarise(totals = sum(y))</code>
Hive table references assume a default database source. 
Often, the needed table is in a different database within the metastore. 
To access it using SQL, prefix the database name to the table. 
Separate them using a period, as demonstrated here:
<code>DBI::dbSendQuery(sc, "SELECT * FROM databasename.table")</code>
In <code>dplyr</code>, the <code>in_schema()</code> function can be used. 
The function is used inside the <code>tbl()</code> call:
<code>tbl(sc, dbplyr::in_schema("databasename", "table"))</code>
You can also use the <code>tbl_change_db()</code> function to set the current session’s default database. 
Any subsequent call via <code>DBI</code> or <code>dplyr</code> will use the selected name as the default database:
<code>tbl_change_db(sc, "databasename")</code>
The following examples require additional Spark packages and databases which might be difficult to follow unless you happen to have a JDBC driver or Cassandra database accessible to you.
<code>spark_disconnect(sc)</code>
Next, we explore a less structured storage system, often referred to as a <em>NoSQL database</em>.

<h3>8.7.2 Cassandra</h3>
Apache <em>Cassandra</em> is a free and open source, distributed, wide-column store, NoSQL database management system designed to handle large amounts of data across many commodity servers. 
While there are many other database systems beyond Cassandra, taking a quick look at how Cassandra can be used from Spark will give you insight into how to make use of other database and storage systems like Solr, Redshift, Delta Lake, and others.
The following example code shows how to use the <code>datastax:spark-cassandra-connector</code> package to read from Cassandra. 
The key is to use the <code>org.apache.spark.sql.cassandra</code> library as the <code>source</code> argument. 
It provides the mapping Spark can use to make sense of the data source. 
Unless you have a Cassandra database, skip executing the following statement:
<code>sc &lt;- spark_connect(master = "local", version = "2.3", config = list(
  sparklyr.connect.packages = "datastax:spark-cassandra-connector:2.3.1-s_2.11"))

spark_read_source(
  sc, 
  name = "emp",
  source = "org.apache.spark.sql.cassandra",
  options = list(keyspace = "dev", table = "emp"),
  memory = FALSE)</code>
One of the most useful features of Spark when dealing with external databases and data warehouses is that Spark can push down computation to the database, a feature known as <em>pushdown predicates</em>. 
In a nutshell, pushdown predicates improve performance by asking remote databases smart questions. 
When you execute a query that contains the <code>filter(age > 20)</code> expression against a remote table referenced through <code>spark_read_source()</code> and not loaded in memory, rather than bringing the entire table into Spark, it will be passed to the remote database and only a subset of the remote table is retrieved.
While it is ideal to find Spark packages that support the remote storage system, there will be times when a package is not available and you need to consider vendor JDBC drivers.

<h3>8.7.3 JDBC</h3>
When a Spark package is not available to provide connectivity, you can consider a JDBC connection. 
JDBC is an interface for the programming language Java, which defines how a client can access a database.
It is quite easy to connect to a remote database with <code>spark_read_jdbc()</code>, and <code>spark_write_jdbc()</code>; as long as you have access to the appropriate JDBC driver, which at times is trivial and other times is quite an adventure. 
To keep this simple, we can briefly consider how a connection to a remote MySQL database could be accomplished.
First, you would need to download the appropriate JDBC driver from MySQL’s developer portal and specify this additional driver as a <code>sparklyr.shell.driver-class-path</code> connection option. 
Since JDBC drivers are Java-based, the code is contained within a <em>JAR</em> (Java ARchive) file. 
As soon as you’re connected to Spark with the appropriate driver, you can use the <em>jdbc://</em> protocol to access particular drivers and databases. 
Unless you are willing to download and configure MySQL on your own, skip executing the following statement:
<code>sc &lt;- spark_connect(master = "local", version = "2.3", config = list(
  "sparklyr.shell.driver-class-path" =
    "~/Downloads/mysql-connector-java-5.1.41/mysql-connector-java-5.1.41-bin.jar"
))

spark_read_jdbc(sc, "person_jdbc",  options = list(
  url = "jdbc:mysql://localhost:3306/sparklyr",
  user = "root", password = "&lt;password>",
  dbtable = "person"))</code>
If you are a customer of particular database vendors, making use of the vendor-provided resources is usually the best place to start looking for appropriate drivers.

<h2>8.8 Recap</h2>
This chapter expanded on how and why you should use Spark to connect and process a variety of data sources through a new data storage model known as data lakes—a storage pattern that provides more flexibility than standard ETL processes by enabling you to use raw datasets with, potentially, more information to enrich data analysis and modeling.
We also presented best practices for reading, writing, and copying data into and from Spark. 
We then returned to exploring the components of a data lake: file formats and file systems, with the former representing how data is stored, and the latter where the data is stored. 
You then learned how to tackle file formats and storage systems that require additional Spark packages, reviewed some of the performance trade-offs across file formats, and learned the concepts required to make use of storage systems (databases and warehouses) in Spark.
While reading and writing datasets should come naturally to you, you might still hit resource restrictions while reading and writing large datasets. 
To handle these situations, Chapter 9 shows you how Spark manages tasks and data across multiple machines, which in turn allows you to further improve the performance of your analysis and modeling tasks.

<h2><span class="orange">Chapter 9 Tuning</span></h2>
In previous chapters, we’ve assumed that computation within a Spark cluster works efficiently. 
While this is true in some cases, it is often necessary to have some knowledge of the operations Spark runs internally to fine-tune configuration settings that will make computations run efficiently. 
This chapter explains how Spark computes data over large datasets and provides details on how to optimize its operations.
For instance, in this chapter you’ll learn how to request more compute nodes and increase the amount of memory, which, if you remember from Chapter 2, defaults to only 2 GB in local instances. 
You will learn how Spark unifies computation through partitioning, shuffling, and caching. 
As mentioned a few chapters back, this is the last chapter describing the internals of Spark; after you complete this chapter, we believe that you will have the intermediate Spark skills necessary to be productive at using Spark.
In Chapters 10–12 we explore exciting techniques to deal with specific modeling, scaling, and computation problems. 
However, we must first understand how Spark performs internal computations, what pieces we can control, and why.

<h2>9.1 Overview</h2>
Spark performs distributed computation by configuring, partitioning, executing, shuffling, caching, and serializing data, tasks, and resources across multiple machines:
<ul>
<li><em>Configuring</em> requests the cluster manager for resources: total machines, memory, and so on.</li>
<li><em>Partitioning</em> splits the data among various machines. 
Partitions can be either implicit or explicit.</li>
<li><em>Executing</em> means running an arbitrary transformation over each partition.</li>
<li><em>Shuffling</em> redistributes data to the correct machine.</li>
<li><em>Caching</em> preserves data in memory across different computation cycles.</li>
<li><em>Serializing</em> transforms data to be sent over the network to other workers or back to the driver node.</li>
</ul>
To illustrate each concept, let’s create three partitions with unordered integers and then sort them using <code>arrange()</code>:
<code>data &lt;- copy_to(sc, 
  data.frame(id = c(4, 9, 1, 8, 2, 3, 5, 7, 6)),
  repartition = 3)

data %>% arrange(id) %>% collect()</code>
Figure 9.1 shows how this sorting <em>job</em> would conceptually work across a cluster of machines. 
First, Spark would <em>configure</em> the cluster to use three worker machines. 
In this example, the numbers <code>1</code> through <code>9</code> are partitioned across three storage instances. 
Since the <em>data</em> is already partitioned, each worker node loads this implicit <em>partition</em>; for instance, <code>4</code>, <code>9</code>, and <code>1</code> are loaded in the first worker node. 
Afterward, a <em>task</em> is distributed to each worker to apply a transformation to each data partition in each worker node; this task is denoted by <code>f(x)</code>. 
In this example, <code>f(x)</code> <em>executes</em> a sorting operation within a partition. 
Since Spark is general, execution over a partition can be as simple or complex as needed.
The result is then <em>shuffled</em> to the correct machine to finish the sorting operation across the entire dataset, which completes a stage. 
A <em>stage</em> is a set of operations that Spark can execute without shuffling data between machines. 
After the data is sorted across the cluster, the sorted results can be optionally <em>cached</em> in memory to avoid rerunning this computation multiple times.
Finally, a small subset of the results is <em>serialized</em>, through the network connecting the cluster machines, back to the driver node to print a preview of this sorting example.
Notice that while Figure 9.1 describes a sorting operation, a similar approach applies to filtering or joining datasets and analyzing and modeling data at scale. 
Spark provides support to perform custom partitions, custom shuffling, and so on, but most of these lower-level operations are not exposed in <code>sparklyr</code>; instead, <code>sparklyr</code> makes those operations available through higher-level commands provided by data analysis tools like <code>dplyr</code> or <code>DBI</code>, modeling, and by using many extensions. 
For those few cases in which you might need to implement low-level operations, you can always use Spark’s Scala API through <code>sparklyr</code> extensions or run custom distributed R code.
To effectively tune Spark, we will start by getting familiar with Spark’s computation graph and Spark’s event <em>timeline</em>. 
Both are accessible through Spark’s web interface.

<img src="https://therinspark.com/images/tuning-spark-overview-resized.png" />

FIGURE 9.1: Sorting distributed data with Apache Spark

<h3>9.1.1 Graph</h3>
Spark describes all computation steps using a Directed Acyclic Graph (DAG), which means that all computations in Spark move computation forward without repeating previous steps, which helps Spark optimize computations effectively.
The best way to understand Spark’s computation graph for a given operation—sorting for our example—is to open the last <em>completed query</em> on the SQL tab in Spark’s web interface. 
Figure 9.2 shows the resulting graph for this sorting operation, which contains the following operations:

<dt><code>WholeStageCodegen</code></dt>
This block specifies that the operations it contains were used to generate computer code that was efficiently translated to byte code. 
There is usually a small cost associated with translating operations into byte code, but this is a worthwhile price to pay since the operations then can be executed much faster from Spark. 
In general, you can ignore this block and focus on the operations that it contains.

<dt><code>InMemoryTableScan</code></dt>
This means that the original dataset <code>data</code> was stored in memory and traversed row by row once.

<dt><code>Exchange</code></dt>
Partitions were exchanged—that is, shuffled—across executors in your cluster.

<dt><code>Sort</code></dt>
Once the records arrived at the right executor, they were sorted in this final stage.

<img src="https://therinspark.com/images/tuning-spark-graph-visualization-sql.png" />

FIGURE 9.2: Spark graph for a sorting query

From the query details, you then can open the last Spark job to arrive to the job details page, which you can expand by using “DAG Visualization” to create a graph similar to Figure 9.3. 
This graph shows a few additional details and the stages in this job. 
Notice that there are no arrows pointing back to previous steps, since Spark makes use of acyclic graphs.

<img src="https://therinspark.com/images/tuning-spark-graph-visualization-resized.png" />

FIGURE 9.3: Spark graph for a sorting job

Next, we dive into a Spark stage and explore its event timeline.

<h3>9.1.2 Timeline</h3>
The <em>event timeline</em> is a great summary of how Spark is spending computation cycles over each stage. 
Ideally, you want to see this timeline consisting of mostly CPU usage since other tasks can be considered overhead. 
You also want to see Spark using all the CPUs across all the cluster nodes available to you.
Select the first stage in the current job and expand the event timeline, which should look similar to Figure 9.4. 
Notice that we explicitly requested three partitions, which are represented by three lanes in this visualization.

<img src="https://therinspark.com/images/tuning-spark-event-timeline.png" />

FIGURE 9.4: Spark event timeline

Since our machine is equipped with four CPUs, we can(((“parallel execution”))) parallelize this computation even further by explicitly repartitioning data using <code>sdf_repartition()</code>, with the result shown in Figure 9.5:
<code>data %>% sdf_repartition(4) %>% arrange(id) %>% collect()</code>

<img src="https://therinspark.com/images/tuning-spark-event-timeline-repartition.png" />

FIGURE 9.5: Spark event timeline with additional partitions

Figure 9.5 now shows four execution lanes with most time spent under Executor Computing Time, which shows us that this particular operation is making better use of our compute resources. 
When you are working with clusters, requesting more compute nodes from your cluster should shorten computation time. 
In contrast, for timelines that show significant time spent shuffling, requesting more compute nodes might not shorten time and might actually make everything slower. 
There is no concrete set of rules to follow to optimize a stage; however, as you gain experience understanding this timeline over multiple operations, you will develop insights as to how to properly optimize Spark operations.

<h2>9.2 Configuring</h2>
When tuning a Spark application, the most common resources to configure are memory and cores, specifically:

<dt>Memory in driver</dt>
The amount of memory required in the driver node

<dt>Memory per worker</dt>
The amount of memory required in the worker nodes

<dt>Cores per worker</dt>
The number of CPUs required in the worker nodes

<dt>Number of workers</dt>
The number of workers required for this session

<strong>Note:</strong> It is recommended to request significantly more memory for the driver than the memory available over each worker node. 
In most cases, you will want to request one core per worker.
In local mode there are no workers, but we can still configure memory and cores to use through the following:
<code># Initialize configuration with defaults
config &lt;- spark_config()

# Memory
config["sparklyr.shell.driver-memory"] &lt;- "2g"

# Cores
config["sparklyr.connect.cores.local"] &lt;- 2

# Connect to local cluster with custom configuration
sc &lt;- spark_connect(master = "local", config = config)</code>
When using the Spark Standalone and the Mesos cluster managers, all the available memory and cores are assigned by default; therefore, there are no additional configuration changes required, unless you want to restrict resources to allow multiple users to share this cluster. 
In this case, you can use <code>total-executor-cores</code> to restrict the total executors requested. 
The <em>Spark Standalone</em> and <em>Spark on Mesos</em> guides provide additional information on sharing clusters.
When running under YARN Client, you would configure memory and cores as follows:
<code># Memory in Driver
config["sparklyr.shell.driver-memory"] &lt;- "2g"

# Memory per Worker
config["spark.executor.memory"] &lt;- "2G" 

# Cores per Worker
config["sparklyr.shell.executor-cores"] &lt;- 1

# Number of Workers
config["sparklyr.shell.num-executors"] &lt;- 3</code>
When using YARN in cluster mode you can use <code>sparklyr.shell.driver-cores</code> to configure total cores requested in the driver node. 
The Spark on YARN guide provides additional configuration settings that can benefit you.
There are a few types of configuration settings:

<dt><em>Connect</em></dt>
These settings are set as parameters to <code>spark_connect()</code>. 
They are common settings used while connecting.

<dt><em>Submit</em></dt>
These settings are set while <code>sparklyr</code> is being submitted to Spark through <code>spark-submit</code>; some are dependent on the cluster manager being used.

<dt><em>Runtime</em></dt>
These settings configure Spark when the Spark session is created. 
They are independent of the cluster manager and specific to Spark.

<dt><em>sparklyr</em></dt>
Use these to configure <code>sparklyr</code> behavior. 
These settings are independent of the cluster manager and particular to R.

The following subsections present extensive lists of all the available settings. 
It is not required that you fully understand them all while tuning Spark, but skimming through them could prove useful in the future for troubleshooting issues. 
If you prefer, you can skip these subsections and use them instead as reference material as needed.

<h3>9.2.1 Connect Settings</h3>
You can use the parameters listed in Table 9.1 with <code>spark_connect()</code>. 
They configure high-level settings that define the connection method, Spark’s installation path, and the version of Spark to use.
<table>
<caption>TABLE 9.1: Parameters used when connecting to Spark</caption>
<thead>
<tr><th align="left">name</th><th align="left">value</th></tr>
</thead>
<tbody>
<tr><td align="left">master</td><td align="left">Spark cluster url to connect to. 
Use “local” to connect to a local instance of Spark installed via ‘spark_install()’.</td></tr>
<tr><td align="left">spark_home</td><td align="left">The path to a Spark installation. 
Defaults to the path provided by the SPARK_HOME environment variable. 
If SPARK_HOME is defined, it will always be used unless the version parameter is specified to force the use of a locally installed version.</td></tr>
<tr><td align="left">method</td><td align="left">The method used to connect to Spark. 
Default connection method is “shell” to connect using spark-submit, use “livy” to perform remote connections using HTTP, “databricks” when using a Databricks cluster or “qubole” when using a Qubole cluster.</td></tr>
<tr><td align="left">app_name</td><td align="left">The application name to be used while running in the Spark cluster.</td></tr>
<tr><td align="left">version</td><td align="left">The version of Spark to use. 
Only applicable to “local” Spark connections.</td></tr>
<tr><td align="left">config</td><td align="left">Custom configuration for the generated Spark connection. 
See spark_config for details.</td></tr>
</tbody>
</table>
You can configure additional settings by specifying a list in the <code>config</code> parameter. 
Let’s now take a look at what those settings can be.

<h3>9.2.2 Submit Settings</h3>
Some settings must be specified when <code>spark-submit</code> (the terminal application that launches Spark) is run. 
For instance, since <code>spark-submit</code> launches a driver node that runs as a Java instance, how much memory is allocated needs to be specified as a parameter to <code>spark-submit</code>.
You can list all the available <code>spark-submit</code> parameters by running the following:
<code>spark_home_dir() %>% file.path("bin", "spark-submit") %>% system2()</code>
For readability, we’ve provided the output of this command in Table 9.2, replacing the <code>spark-submit</code> parameter with the appropriate <code>spark_config()</code> setting and removing the parameters that are not applicable or already presented in this chapter.
<table>
<caption>TABLE 9.2: Setting available to configure spark-submit</caption>
<thead>
<tr><th align="left">name</th><th align="left">value</th></tr>
</thead>
<tbody>
<tr><td align="left">sparklyr.shell.jars</td><td align="left">Specified as ‘jars’ parameter in ‘spark_connect()’.</td></tr>
<tr><td align="left">sparklyr.shell.packages</td><td align="left">Comma-separated list of maven coordinates of jars to include on the driver and executor classpaths. 
Will search the local maven repo, then maven central and any additional remote repositories given by ‘sparklyr.shell.repositories’. 
The format for the coordinates should be groupId:artifactId:version.</td></tr>
<tr><td align="left">sparklyr.shell.exclude-packages</td><td align="left">Comma-separated list of groupId:artifactId, to exclude while resolving the dependencies provided in ‘sparklyr.shell.packages’ to avoid dependency conflicts.</td></tr>
<tr><td align="left">sparklyr.shell.repositories</td><td align="left">Comma-separated list of additional remote repositories to search for the maven coordinates given with ‘sparklyr.shell.packages’</td></tr>
<tr><td align="left">sparklyr.shell.files</td><td align="left">Comma-separated list of files to be placed in the working directory of each executor. 
File paths of these files in executors can be accessed via SparkFiles.get(fileName).</td></tr>
<tr><td align="left">sparklyr.shell.conf</td><td align="left">Arbitrary Spark configuration property set as PROP=VALUE.</td></tr>
<tr><td align="left">sparklyr.shell.properties-file</td><td align="left">Path to a file from which to load extra properties. 
If not specified, this will look for conf/spark-defaults.conf.</td></tr>
<tr><td align="left">sparklyr.shell.driver-java-options</td><td align="left">Extra Java options to pass to the driver.</td></tr>
<tr><td align="left">sparklyr.shell.driver-library-path</td><td align="left">Extra library path entries to pass to the driver.</td></tr>
<tr><td align="left">sparklyr.shell.driver-class-path</td><td align="left">Extra class path entries to pass to the driver. 
Note that jars added with ‘sparklyr.shell.jars’ are automatically included in the classpath.</td></tr>
<tr><td align="left">sparklyr.shell.proxy-user</td><td align="left">User to impersonate when submitting the application. 
This argument does not work with ‘sparklyr.shell.principal’ / ‘sparklyr.shell.keytab’.</td></tr>
<tr><td align="left">sparklyr.shell.verbose</td><td align="left">Print additional debug output.</td></tr>
</tbody>
</table>
The remaining settings, shown in Table 9.3, are specific to YARN.
<table>
<caption>TABLE 9.3: Settings avalable to configure spark-submit when using YARN</caption>
<thead>
<tr><th align="left">name</th><th align="left">value</th></tr>
</thead>
<tbody>
<tr><td align="left">sparklyr.shell.queue</td><td align="left">The YARN queue to submit to (Default: “default”).</td></tr>
<tr><td align="left">sparklyr.shell.archives</td><td align="left">Comma separated list of archives to be extracted into the working directory of each executor.</td></tr>
<tr><td align="left">sparklyr.shell.principal</td><td align="left">Principal to be used to login to KDC, while running on secure HDFS.</td></tr>
<tr><td align="left">sparklyr.shell.keytab</td><td align="left">The full path to the file that contains the keytab for the principal specified above. 
This keytab will be copied to the node running the Application Master via the Secure Distributed Cache, for renewing the login tickets and the delegation tokens periodically.</td></tr>
</tbody>
</table>
In general, any <code>spark-submit</code> setting is configured through <code>sparklyr.shell.X</code>, where X is the name of the <code>spark-submit</code> parameter without the <code>--</code> prefix.

<h3>9.2.3 Runtime Settings</h3>
As mentioned, some Spark settings configure the session runtime. 
The runtime settings are a superset of the submit settings given that it is usually helpful to retrieve the current configuration even if a setting can’t be changed.
To list the Spark settings set in your current Spark session, you can run the following:
<code>spark_session_config(sc)</code>
Table 9.4 describes the runtime settings.
<table>
<caption>TABLE 9.4: Setting available to configure the Spark session</caption>
<thead>
<tr><th align="left">name</th><th align="left">value</th></tr>
</thead>
<tbody>
<tr><td align="left">spark.master</td><td align="left">local[4]</td></tr>
<tr><td align="left">spark.sql.shuffle.partitions</td><td align="left">4</td></tr>
<tr><td align="left">spark.driver.port</td><td align="left">62314</td></tr>
<tr><td align="left">spark.submit.deployMode</td><td align="left">client</td></tr>
<tr><td align="left">spark.executor.id</td><td align="left">driver</td></tr>
<tr><td align="left">spark.jars</td><td align="left">/Library/…/sparklyr/java/sparklyr-2.3-2.11.jar</td></tr>
<tr><td align="left">spark.app.id</td><td align="left">local-1545518234395</td></tr>
<tr><td align="left">spark.env.SPARK_LOCAL_IP</td><td align="left">127.0.0.1</td></tr>
<tr><td align="left">spark.sql.catalogImplementation</td><td align="left">hive</td></tr>
<tr><td align="left">spark.spark.port.maxRetries</td><td align="left">128</td></tr>
<tr><td align="left">spark.app.name</td><td align="left">sparklyr</td></tr>
<tr><td align="left">spark.home</td><td align="left">/Users/…/spark/spark-2.3.2-bin-hadoop2.7</td></tr>
<tr><td align="left">spark.driver.host</td><td align="left">localhost</td></tr>
</tbody>
</table>
However, there are many more configuration settings available in Spark, as described in the <em>Spark Configuration</em> guide. 
It’s beyond the scope of this book to describe them all, so, if possible, take some time to identify the ones that might be of interest to your particular use cases.

<h3>9.2.4 sparklyr Settings</h3>
Apart from Spark settings, there are a few settings particular to <code>sparklyr</code>. 
You usually don’t use these settings while tuning Spark; instead, they are helpful while troubleshooting Spark from R. 
For instance, you can use <code>sparklyr.log.console = TRUE</code> to output the Spark logs into the R console; this is ideal while troubleshooting but too noisy otherwise. 
Here’s how to list the settings (results are presented in Table 9.5):
<code>spark_config_settings()</code>
<table>
<caption>TABLE 9.5: Settings available to configure the sparklyr package</caption>
<thead>
<tr><th align="left">name</th><th align="left">description</th></tr>
</thead>
<tbody>
<tr><td align="left">sparklyr.apply.packages</td><td align="left">Configures default value for packages parameter in spark_apply().</td></tr>
<tr><td align="left">sparklyr.apply.rlang</td><td align="left">Experimental feature. 
Turns on improved serialization for spark_apply().</td></tr>
<tr><td align="left">sparklyr.apply.serializer</td><td align="left">Configures the version spark_apply() uses to serialize the closure.</td></tr>
<tr><td align="left">sparklyr.apply.schema.infer</td><td align="left">Number of rows collected to infer schema when column types specified in spark_apply().</td></tr>
<tr><td align="left">sparklyr.arrow</td><td align="left">Use Apache Arrow to serialize data?</td></tr>
<tr><td align="left">sparklyr.backend.interval</td><td align="left">Total seconds sparklyr will check on a backend operation.</td></tr>
<tr><td align="left">sparklyr.backend.timeout</td><td align="left">Total seconds before sparklyr will give up waiting for a backend operation to complete.</td></tr>
<tr><td align="left">sparklyr.collect.batch</td><td align="left">Total rows to collect when using batch collection, defaults to 100,000.</td></tr>
<tr><td align="left">sparklyr.cancellable</td><td align="left">Cancel spark jobs when the R session is interrupted?</td></tr>
<tr><td align="left">sparklyr.connect.aftersubmit</td><td align="left">R function to call after spark-submit executes.</td></tr>
<tr><td align="left">sparklyr.connect.app.jar</td><td align="left">The path to the sparklyr jar used in spark_connect().</td></tr>
<tr><td align="left">sparklyr.connect.cores.local</td><td align="left">Number of cores to use in spark_connect(master = “local”), defaults to parallel::detectCores().</td></tr>
<tr><td align="left">sparklyr.connect.csv.embedded</td><td align="left">Regular expression to match against versions of Spark that require package extension to support CSVs.</td></tr>
<tr><td align="left">sparklyr.connect.csv.scala11</td><td align="left">Use Scala 2.11 jars when using embedded CSV jars in Spark 1.6.X.</td></tr>
<tr><td align="left">sparklyr.connect.jars</td><td align="left">Additional JARs to include while submitting application to Spark.</td></tr>
<tr><td align="left">sparklyr.connect.master</td><td align="left">The cluster master as spark_connect() master parameter, notice that the ‘spark.master’ setting is usually preferred.</td></tr>
<tr><td align="left">sparklyr.connect.packages</td><td align="left">Spark packages to include when connecting to Spark.</td></tr>
<tr><td align="left">sparklyr.connect.ondisconnect</td><td align="left">R function to call after spark_disconnect().</td></tr>
<tr><td align="left">sparklyr.connect.sparksubmit</td><td align="left">Command executed instead of spark-submit when connecting.</td></tr>
<tr><td align="left">sparklyr.connect.timeout</td><td align="left">Total seconds before giving up connecting to the sparklyr gateway while initializing.</td></tr>
<tr><td align="left">sparklyr.dplyr.period.splits</td><td align="left">Should ‘dplyr’ split column names into database and table?</td></tr>
<tr><td align="left">sparklyr.extensions.catalog</td><td align="left">Catalog PATH where extension JARs are located. 
Defaults to ‘TRUE’, ‘FALSE’ to disable.</td></tr>
<tr><td align="left">sparklyr.gateway.address</td><td align="left">The address of the driver machine.</td></tr>
<tr><td align="left">sparklyr.gateway.config.retries</td><td align="left">Number of retries to retrieve port and address from config, useful when using functions to query port or address in kubernetes.</td></tr>
<tr><td align="left">sparklyr.gateway.interval</td><td align="left">Total of seconds sparkyr will check on a gateway connection.</td></tr>
<tr><td align="left">sparklyr.gateway.port</td><td align="left">The port the sparklyr gateway uses in the driver machine, defaults to 8880.</td></tr>
<tr><td align="left">sparklyr.gateway.remote</td><td align="left">Should the sparklyr gateway allow remote connections? This is required in yarn cluster, etc.</td></tr>
<tr><td align="left">sparklyr.gateway.routing</td><td align="left">Should the sparklyr gateway service route to other sessions? Consider disabling in kubernetes.</td></tr>
<tr><td align="left">sparklyr.gateway.service</td><td align="left">Should the sparklyr gateway be run as a service without shutting down when the last connection disconnects?</td></tr>
<tr><td align="left">sparklyr.gateway.timeout</td><td align="left">Total seconds before giving up connecting to the sparklyr gateway after initialization.</td></tr>
<tr><td align="left">sparklyr.gateway.wait</td><td align="left">Total seconds to wait before retrying to contact the sparklyr gateway.</td></tr>
<tr><td align="left">sparklyr.livy.auth</td><td align="left">Authentication method for Livy connections.</td></tr>
<tr><td align="left">sparklyr.livy.headers</td><td align="left">Additional HTTP headers for Livy connections.</td></tr>
<tr><td align="left">sparklyr.livy.sources</td><td align="left">Should sparklyr sources be sourced when connecting? If false, manually register sparklyr jars.</td></tr>
<tr><td align="left">sparklyr.log.invoke</td><td align="left">Should every call to invoke() be printed in the console? Can be set to ‘callstack’ to log call stack.</td></tr>
<tr><td align="left">sparklyr.log.console</td><td align="left">Should driver logs be printed in the console?</td></tr>
<tr><td align="left">sparklyr.progress</td><td align="left">Should job progress be reported to RStudio?</td></tr>
<tr><td align="left">sparklyr.progress.interval</td><td align="left">Total of seconds to wait before attempting to retrieve job progress in Spark.</td></tr>
<tr><td align="left">sparklyr.sanitize.column.names</td><td align="left">Should partially unsupported column names be cleaned up?</td></tr>
<tr><td align="left">sparklyr.stream.collect.timeout</td><td align="left">Total seconds before stopping collecting a stream sample in sdf_collect_stream().</td></tr>
<tr><td align="left">sparklyr.stream.validate.timeout</td><td align="left">Total seconds before stopping to check if stream has errors while being created.</td></tr>
<tr><td align="left">sparklyr.verbose</td><td align="left">Use verbose logging across all sparklyr operations?</td></tr>
<tr><td align="left">sparklyr.verbose.na</td><td align="left">Use verbose logging when dealing with NAs?</td></tr>
<tr><td align="left">sparklyr.verbose.sanitize</td><td align="left">Use verbose logging while sanitizing columns and other objects?</td></tr>
<tr><td align="left">sparklyr.web.spark</td><td align="left">The URL to Spark’s web interface.</td></tr>
<tr><td align="left">sparklyr.web.yarn</td><td align="left">The URL to YARN’s web interface.</td></tr>
<tr><td align="left">sparklyr.worker.gateway.address</td><td align="left">The address of the worker machine, most likely localhost.</td></tr>
<tr><td align="left">sparklyr.worker.gateway.port</td><td align="left">The port the sparklyr gateway uses in the driver machine.</td></tr>
<tr><td align="left">sparklyr.yarn.cluster.accepted.timeout</td><td align="left">Total seconds before giving up waiting for cluster resources in yarn cluster mode.</td></tr>
<tr><td align="left">sparklyr.yarn.cluster.hostaddress.timeout</td><td align="left">Total seconds before giving up waiting for the cluster to assign a host address in yarn cluster mode.</td></tr>
<tr><td align="left">sparklyr.yarn.cluster.lookup.byname</td><td align="left">Should the current user name be used to filter yarn cluster jobs while searching for submitted one?</td></tr>
<tr><td align="left">sparklyr.yarn.cluster.lookup.prefix</td><td align="left">Application name prefix used to filter yarn cluster jobs while searching for submitted one.</td></tr>
<tr><td align="left">sparklyr.yarn.cluster.lookup.username</td><td align="left">The user name used to filter yarn cluster jobs while searching for submitted one.</td></tr>
<tr><td align="left">sparklyr.yarn.cluster.start.timeout</td><td align="left">Total seconds before giving up waiting for yarn cluster application to get registered.</td></tr>
</tbody>
</table>

<h2>9.3 Partitioning</h2>
As mentioned in Chapter 1, MapReduce and Spark were designed with the purpose of performing computations against data stored across many machines. 
The subset of the data available for computation over each compute instance is known as a <em>partition</em>.
By default, Spark computes over each existing <em>implicit</em> partition since it’s more effective to run computations where the data is already located. 
However, there are cases for which you will want to set an <em>explicit</em> partition to help Spark make more efficient use of your cluster resources.

<h3>9.3.1 Implicit Partitions</h3>
As Chapter 8 explained, Spark can read data stored in many formats and different storage systems; however, since shuffling data is an expensive operation, Spark executes tasks reusing the partitions in the storage system. 
Therefore, these partitions are implicit to Spark since they are already well defined and expensive to rearrange.
There is always an implicit partition for every computation in Spark defined by the distributed storage system, even for operations which you wouldn’t expect that create partitions, like <code>copy_to()</code>.
You can explore the number of partitions a computation will require by using <code>sdf_num_partitions()</code>:
<code>sdf_len(sc, 10) %>% sdf_num_partitions()</code>
<code>[1] 2</code>
While in most cases the default partitions work just fine, there are cases for which you will need to be explicit about the partitions you choose.

<h3>9.3.2 Explicit Partitions</h3>
There will be times when you have many more or far fewer compute instances than data partitions. 
In both cases, it can help to <em>repartition</em> data to match your cluster resources.
Various data functions, like <code>spark_read_csv()</code>, already support a <code>repartition</code> parameter to request that Spark repartition data appropriately. 
For instance, we can create a sequence of 10 numbers partitioned by 10 as follows:
<code>sdf_len(sc, 10, repartition = 10) %>% sdf_num_partitions()</code>
<code>[1] 10</code>
For datasets that are already partitioned, we can also use <code>sdf_repartition()</code>:
<code>sdf_len(sc, 10, repartition = 10) %>% 
  sdf_repartition(4) %>%
  sdf_num_partitions()</code>
<code>[1] 4</code>
The number of partitions usually significantly changes the speed and resources being used; for instance, the following example calculates the mean over 10 million rows with different partition sizes:
<code>library(microbenchmark)
library(ggplot2)

microbenchmark(
    "1 Partition(s)" = sdf_len(sc, 10^7, repartition = 1) %>%
      summarise(mean(id)) %>% collect(),
    "2 Partition(s)" = sdf_len(sc, 10^7, repartition = 2) %>%
      summarise(mean(id)) %>% collect(),
    times = 10
) %>% autoplot() + theme_light() </code>
Figure 9.6 shows that sorting data with two partitions is almost twice as fast. 
This is because two CPUs can be used to execute this operation. 
However, it is not necessarily the case that higher partitions produce faster computation; instead, partitioning data is particular to your computing cluster and the data analysis operations being performed.

<img src="https://therinspark.com/images/tuning-partition-explicit.png" />

FIGURE 9.6: Computation speed with additional explicit partitions

<h2>9.4 Caching</h2>
Recall from Chapter 1 that Spark was designed to be faster than its predecessors by using memory instead of disk to store data. 
This is formally known as a Spark <em>resilient distributed dataset</em> (RDD). 
An RDD distributes copies of the same data across many machines, such that if one machine fails, others can complete the task—hence, the term “resilient.” Resiliency is important in distributed systems since, while things will usually work in one machine, when running over thousands of machines the likelihood of something failing is much higher. 
When a failure happens, it is preferable to be fault tolerant to avoid losing the work of all the other machines. 
RDDs accomplish this by tracking data lineage information to rebuild lost data automatically on failure.
In <code>sparklyr</code>, you can control when an RDD is loaded or unloaded from memory using <code>tbl_cache()</code> and <code>tbl_uncache()</code>.
Most <code>sparklyr</code> operations that retrieve a Spark DataFrame cache the results in memory. 
For instance, running <code>spark_read_parquet()</code> or <code>copy_to()</code> will provide a Spark DataFrame that is already cached in memory. 
As a Spark DataFrame, this object can be used in most <code>sparklyr</code> functions, including data analysis with <code>dplyr</code> or machine learning:
<code>library(sparklyr)
sc &lt;- spark_connect(master = "local")</code>
<code>iris_tbl &lt;- copy_to(sc, iris, overwrite = TRUE)</code>
You can inspect which tables are cached by navigating to the Spark UI using <code>spark_web(sc)</code>, clicking the Storage tab, and then clicking on a specific RDD, as illustrated in Figure 9.7.

<img src="https://therinspark.com/images/tuning-cache-rdd-web-resized.png" />

FIGURE 9.7: Cached RDD in the Spark web interface

Data loaded in memory will be released when the R session terminates, either explicitly or implicitly, with a restart or disconnection; however, to free up resources, you can use <code>tbl_uncache()</code>:
<code>tbl_uncache(sc, "iris")</code>

<h3>9.4.1 Checkpointing</h3>
Checkpointing is a slightly different type of caching; while it also saves data, it will additionally break the graph computation lineage. 
For example, if a cached partition is lost, it can be computed from the computation graph, which is not possible with checkpointing since the source of computation is lost.
When performing operations which create expensive computation graphs, it can make sense to checkpoint to save and break the computation lineage in order to help Spark reduce graph computation resources; otherwise, Spark might try to optimize a computation graph that is really not useful to optimize.
You can checkpoint explicitly by saving to CSV, Parquet, and other file formats. 
Or, let Spark checkpoint this for you by using <code>sdf_checkpoint()</code> in <code>sparklyr</code>, as follows:
<code># set checkpoint path
spark_set_checkpoint_dir(sc, getwd())

# checkpoint the iris dataset
iris_tbl %>% sdf_checkpoint()</code>
Notice that checkpointing truncates the computation lineage graph, which can speed up performance if the same intermediate result is used multiple times.

<h3>9.4.2 Memory</h3>
Memory in Spark is categorized into <em>reserved</em>, <em>user</em>, <em>execution</em>, or <em>storage</em>:

<dt>Reserved</dt>
Reserved memory is the memory Spark needs to function and therefore is overhead that is required and should not be configured. 
This value defaults to 300 MB.

<dt>User</dt>
User memory is the memory used to execute custom code. 
<code>sparklyr</code> makes use of this memory only indirectly when executing <code>dplyr</code> expressions or modeling a dataset.

<dt>Execution</dt>
Execution memory is used to execute code by Spark, mostly to process the results from the partition and perform shuffling.

<dt>Storage</dt>
Storage memory is used to cache RDDs—for instance, when using <code>compute()</code> in <code>sparklyr</code>.

As part of tuning execution, you can consider tweaking the amount of memory allocated for user, execution, and storage by creating a Spark connection with different values than the defaults provided in Spark:
<code>config &lt;- spark_config()

# define memory available for storage and execution
config$spark.memory.fraction &lt;- 0.75

# define memory available for storage
config$spark.memory.storageFraction &lt;- 0.5</code>
For instance, if you want to use Spark to store large amounts of data in memory with the purpose of quickly filtering and retrieving subsets, you can expect Spark to use little execution or user memory. 
Therefore, to maximize storage memory, you can tune Spark as follows:
<code>config &lt;- spark_config()

# define memory available for storage and execution
config$spark.memory.fraction &lt;- 0.90

# define memory available for storage
config$spark.memory.storageFraction &lt;- 0.90</code>
However, note that Spark will borrow execution memory from storage and vice versa if needed and if possible; therefore, in practice, there should be little need to tune the memory settings.

<h2>9.5 Shuffling</h2>
Shuffling is the operation that redistributes data across machines; it is usually expensive and therefore something you should try to minimize. 
You can easily identify whether significant time is being spent shuffling by looking at the event timeline. 
It is possible to reduce shuffling by reframing data analysis questions or hinting Spark appropriately.
This would be relevant, for instance, when joining DataFrames that differ in size significantly; that is, one set is orders of magnitude smaller than the other one. 
You can consider using <code>sdf_broadcast()</code> to mark a DataFrame as small enough for use in broadcast joins, meaning it pushes one of the smaller DataFrames to each of the worker nodes to reduce shuffling the bigger DataFrame. 
Here’s one example for <code>sdf_broadcast()</code>:
<code>sdf_len(sc, 10000) %>%
    sdf_broadcast() %>%
    left_join(sdf_len(sc, 100))</code>

<h2>9.6 Serialization</h2>
Serialization is the process of translating data and tasks into a format that can be transmitted between machines and reconstructed on the receiving end.
It is not that common to need to adjust serialization when tuning Spark; however, it is worth mentioning that there are alternative serialization modules like the Kryo Serializer that can provide performance improvements over the default Java Serializer.
You can turn on the Kryo Serializer in <code>sparklyr</code> through the following:
<code>config &lt;- spark_config()

config$spark.serializer &lt;- "org.apache.spark.serializer.KryoSerializer"
sc &lt;- spark_connect(master = "local", config = config)</code>

<h2>9.7 Configuration Files</h2>
Configuring the <code>spark_config()</code> settings before connecting is the most common approach while tuning Spark. 
However, after you identify the parameters in your connection, you should consider switching to use a configuration file since it will remove the clutter in your connection code and also allow you to share the configuration settings across projects and coworkers.
For instance, instead of connecting to Spark like this:
<code>config &lt;- spark_config()
config["sparklyr.shell.driver-memory"] &lt;- "2G"
sc &lt;- spark_connect(master = "local", config = config)</code>
you can define a <em>config.yml</em> file with the desired settings. 
This file should be located in the current working directory or in parent directories. 
For example, you can create the following <em>config.yml</em> file to modify the default driver memory:
<code>default:
  sparklyr.shell.driver-memory: 2G</code>
Then, connecting with the same configuration settings becomes much cleaner by using instead:
<code>sc &lt;- spark_connect(master = "local")</code>
You can also specify an alternate configuration filename or location by setting the <code>file</code> parameter in <code>spark_config()</code>. 
One additional benefit from using configuration files is that a system administrator can change the default configuration by changing the value of the <code>R_CONFIG_ACTIVE</code> environment variable. 
See the GitHub rstudio/config repo for additional information.

<h2>9.8 Recap</h2>
This chapter provided a broad overview of Spark internals and detailed configuration settings to help you speed up computation and enable high computation loads. 
It provided the foundations to understand bottlenecks and guidance on common configuration considerations. 
However, fine-tuning Spark is a broad topic that would require many more chapters to cover extensively. 
Therefore, while troubleshooting Spark’s performance and scalability, searching the web, and consulting online communities, it is often necessary to fine-tune your particular environment as well.
Chapter 10 introduces the ecosystem of Spark extensions that are available in R. 
Most extensions are highly specialized, but they will prove to be extremely useful in specific cases and for readers with particular needs. 
For instance, they can process nested data, perform graph analysis, and use different modeling libraries like <code>rsparkling</code> from H20. 
In addition, the next few chapters introduce many advanced data analysis and modeling topics that are required to master large-scale computing in R.

<h2><span class="orange">Chapter 10 Extensions</span></h2>
In Chapter 9, you learned how Spark processes data at large scale by allowing users to configure the cluster resources, partition data implicitly or explicitly, execute commands across distributed compute nodes, shuffle data across them when needed, cache data to improve performance, and serialize data efficiently over the network. 
You also learned how to configure the different Spark settings used while connecting, submitting a job, and running an application, as well as particular settings applicable only to R and R extensions that we present in this chapter.
Chapters 3-4, and 8 provided a foundation to read and understand most datasets. 
However, the functionality that was presented was scoped to Spark’s built-in features and tabular datasets. 
This chapter goes beyond tabular data and explores how to analyze and model networks of interconnected objects through graph processing, analyze genomics datasets, prepare data for deep learning, analyze geographic datasets, and use advanced modeling libraries like H2O and XGBoost over large-scale datasets.
The combination of all the content presented in the previous chapters should take care of most of your large-scale computing needs. 
However, for those few use cases for which functionality is still lacking, the following chapters provide tools to extend Spark yourself—through custom R transformation, custom Scala code, or a recent new execution mode in Spark that enables analyzing real-time datasets. 
However, before reinventing the wheel, let’s examine some of the extensions available in Spark.

<h2>10.1 Overview</h2>
In Chapter 1, we presented the R community as a vibrant group of individuals collaborating with each other in many ways—for example, moving open science forward by creating R packages that you can install from CRAN. 
In a similar way, but at a much smaller scale, the R community has contributed extensions that increase the functionality initially supported in Spark and R. 
Spark itself also provides support for creating Spark extensions and, in fact, many R extensions make use of Spark extensions.
Extensions are constantly being created, so this section will be outdated at some given point in time. 
In addition, we might not even be aware of many Spark and R extensions. 
However, at the very least we can track the extensions that are available in CRAN by looking at the “reverse imports” for <code>sparklyr</code> in CRAN. 
Extensions and R packages published in CRAN tend to be the most stable since when a package is published in CRAN, it goes through a review process that increases the overall quality of a contribution.
While we wish we could present all the extensions, we’ve instead scoped this chapter to the extensions that should be the most interesting to you. 
You can find additional extensions at the github.com/r-spark organization or by searching repositories on GitHub with the <code>sparklyr</code> tag.

<dt>rsparkling</dt>
The <code>rsparkling</code> extensions allows you to use H2O and Spark from R. 
This extension is what we would consider advanced modeling in Spark. 
While Spark’s built-in modeling library, Spark MLlib, is quite useful in many cases; H2O’s modeling capabilities can compute additional statistical metrics and can provide performance and scalability improvements over Spark MLlib. 
We, ourselves, have not performed detailed comparisons nor benchmarks between MLlib and H2O; so this is something you will have to research on your own to create a complete picture of when to use H2O’s capabilities.

<dt>graphframes</dt>
The <code>graphframes</code> extensions adds support to process graphs in Spark. 
A graph is a structure that describes a set of objects in which some pairs of the objects are in some sense related. 
As you learned in Chapter 1, ranking web pages was an early motivation to develop precursors to Spark powered by MapReduce; web pages happen to form a graph if you consider a link between pages as the relationship between each pair of pages. 
Computing operations likes PageRank over graphs can be quite useful in web search and social networks, for example.

<dt>sparktf</dt>
The <code>sparktf</code> extension provides support to write TensorFlow records in Spark. 
TensorFlow is one of the leading deep learning frameworks, and it is often used with large amounts of numerical data represented as TensorFlow records, a file format optimized for TensorFlow. 
Spark is often used to process unstructured and large-scale datasets into smaller numerical datasets that can easily fit into a GPU. 
You can use this extension to save datasets in the TensorFlow record file format.

<dt>xgboost</dt>
The <code>xgboost</code> extension brings the well-known XGBoost modeling library to the world of large-scale computing. 
XGBoost is a scalable, portable, and distributed library for gradient boosting. 
It became well known in the machine learning competition circles after its use in the winning solution of the Higgs Boson Machine Learning Challenge and has remained popular in other Kaggle competitions since then.

<dt>variantspark</dt>
The <code>variantspark</code> extension provides an interface to use Variant Spark, a scalable toolkit for genome-wide association studies (GWAS). 
It currently provides functionality to build random forest models, estimating variable importance, and reading variant call format (VCF) files. 
While there are other random forest implementations in Spark, most of them are not optimized to deal with GWAS datasets, which usually come with thousands of samples and millions of pass:[variables].

<dt>geospark</dt>
The <code>geospark</code> extension enables us to load and query large-scale geographic datasets. 
Usually datasets containing latitude and longitude points or complex areas are defined in the well-known text (WKT) format, a text markup language for representing vector geometry objects on a map.

Before you learn how and when to use each extension, we should first briefly explain how you can use extensions with R and Spark.
First, a Spark extension is just an R package that happens to be aware of Spark. 
As with any other R package, you will first need to install the extension. 
After you’ve installed it, it is important to know that you will need to reconnect to Spark before the extension can be used. 
So, in general, here’s the pattern you should follow:
<code>library(sparkextension)
library(sparklyr)

sc &lt;- spark_connect(master = "&lt;master>")</code>
Notice that <code>sparklyr</code> is loaded after the extension to allow the extension to register properly. 
If you had to install and load a new extension, you would first need to disconnect using <code>spark_disconnect(sc)</code>, restart your R session, and repeat the preceding steps with the new extension.
It’s not difficult to install and use Spark extensions from R; however, each extension can be a world of its own, so most of the time you will need to spend time understanding what the extension is, when to use it, and how to use it properly. 
The first extension you will learn about is the <code>rsparkling</code> extension, which enables you to use H2O in Spark with R.

<h2>10.2 H2O</h2>
H2O, created by H2O.ai, is open source software for large-scale modeling that allows you to fit thousands of potential models as part of discovering patterns in data. 
You can consider using H2O to complement or replace Spark’s default modeling algorithms. 
It is common to use Spark’s default modeling algorithms and transition to H2O when Spark’s algorithms fall short or when advanced functionality (like additional modeling metrics or automatic model selection) is desired.
We can’t do justice to H2O’s great modeling capabilities in a single paragraph; explaining H2O properly would require a book in and of itself. 
Instead, we would like to recommend reading Darren Cook’s <em>Practical Machine Learning with H2O</em> (O’Reilly) to explore in-depth H2O’s modeling algorithms and features. 
In the meantime, you can use this section as a brief guide to get started using H2O in Spark with R.
To use H2O with Spark, it is important to know that there are four components involved: H2O, Sparkling Water, <code>rsparkling</code>, and Spark. 
Sparkling Water allows users to combine the fast, scalable machine learning algorithms of H2O with the capabilities of Spark. 
You can think of Sparkling Water as a component bridging Spark with H2O and <code>rsparkling</code> as the R frontend for Sparkling Water, as depicted in Figure 10.1.

<img src="https://therinspark.com/the-r-in-spark_files/figure-html/extensions-h2o-diagram-1.png" height="280pt" />

FIGURE 10.1: H2O components with Spark and R

First, install <code>rsparkling</code> and <code>h2o</code> as specified on the <code>rsparkling</code> documentation site.
<code>install.packages("h2o", type = "source",
  repos = "http://h2o-release.s3.amazonaws.com/h2o/rel-yates/5/R")
install.packages("rsparkling", type = "source",
  repos = "http://h2o-release.s3.amazonaws.com/sparkling-water/rel-2.3/31/R")</code>
It is important to note that you need to use compatible versions of Spark, Sparkling Water, and H2O as specified in their documentation; we present instructions for Spark 2.3, but using different Spark versions will require you to install different versions. 
So let’s start by checking the version of H2O by running the following:
<code>packageVersion("h2o")</code>
<code>## [1] &#39;3.26.0.2&#39;</code>
<code>packageVersion("rsparkling")</code>
<code>## [1] &#39;0.2.18&#39;</code>
We then can connect with the supported Spark versions as follows (you will have to adjust the <code>master</code> parameter for your particular cluster):
<code>library(rsparkling)
library(sparklyr)
library(h2o)

sc &lt;- spark_connect(master = "local", version = "2.3",
                    config = list(sparklyr.connect.timeout = 3 * 60))

cars &lt;- copy_to(sc, mtcars)</code>
H2O provides a web interface that can help you monitor training and access much of H2O’s functionality. 
You can access the web interface (called H2O Flow) through <code>h2o_flow(sc)</code>, as shown in Figure 10.2.
When using H2O, you will have to convert your Spark DataFrame into and H2O DataFrame through <code>as_h2o_frame</code>:
<code>cars_h2o &lt;- as_h2o_frame(sc, cars)
cars_h2o</code>
<code>   mpg cyl disp  hp drat    wt  qsec vs am gear carb
1 21.0   6  160 110 3.90 2.620 16.46  0  1    4    4
2 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4
3 22.8   4  108  93 3.85 2.320 18.61  1  1    4    1
4 21.4   6  258 110 3.08 3.215 19.44  1  0    3    1
5 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2
6 18.1   6  225 105 2.76 3.460 20.22  1  0    3    1

[32 rows x 11 columns] </code>

<img src="https://therinspark.com/images/extensions-h2o-flow-resized.png" />

FIGURE 10.2: The H2O Flow interface using Spark with R

Then, you can use many of the modeling functions available in the <code>h2o</code> package with ease. 
For instance, we can fit a generalized linear model with ease:
<code>model &lt;- h2o.glm(x = c("wt", "cyl"),
                 y = "mpg",
                 training_frame = cars_h2o,
                 lambda_search = TRUE)</code>
H2O provides additional metrics not necessarily available in Spark’s modeling algorithms. 
The model that we just fit, <code>Residual Deviance</code>, is provided in the model, while this would not be a standard metric when using Spark MLlib.
<code>model</code>
<code>...
MSE:  6.017684
RMSE:  2.453097
MAE:  1.940985
RMSLE:  0.1114801
Mean Residual Deviance :  6.017684
R^2 :  0.8289895
Null Deviance :1126.047
Null D.o.F. 
:31
Residual Deviance :192.5659
Residual D.o.F. 
:29
AIC :156.2425</code>
Then, you can run prediction over the generalized linear model (GLM). 
A similar approach would work for many other models available in H2O:
<code>predictions &lt;- as_h2o_frame(sc, copy_to(sc, data.frame(wt = 2, cyl = 6)))
h2o.predict(model, predictions)</code>
<code>   predict
1 24.05984

[1 row x 1 column]</code>
You can also use H2O to perform automatic training and tuning of many models, meaning that H2O can choose which model to use for you using AutoML:
<code>automl &lt;- h2o.automl(x = c("wt", "cyl"), y = "mpg",
                     training_frame = cars_h2o,
                     max_models = 20,
                     seed = 1)</code>
For this particular dataset, H2O determines that a deep learning model is a better fit than a GLM. 
Specifically, H2O’s AutoML explored using XGBoost, deep learning, GLM, and a Stacked Ensemble model:
<code>automl@leaderboard</code>
<code>model_id              mean_residual_dev…     rmse      mse      mae     rmsle
1 DeepLearning_…                6.541322 2.557601 6.541322 2.192295 0.1242028
2 XGBoost_grid_1…               6.958945 2.637981 6.958945 2.129421 0.1347795
3 XGBoost_grid_1_…              6.969577 2.639996 6.969577 2.178845 0.1336290
4 XGBoost_grid_1_…              7.266691 2.695680 7.266691 2.167930 0.1331849
5 StackedEnsemble…              7.304556 2.702694 7.304556 1.938982 0.1304792
6 XGBoost_3_…                   7.313948 2.704431 7.313948 2.088791 0.1348819</code>
Rather than using the leaderboard, you can focus on the best model through <code>automl@leader</code>; for example, you can glance at the particular parameters from this deep learning model as follows:
<code>tibble::tibble(parameter = names(automl@leader@parameters),
               value = as.character(automl@leader@parameters))</code>
<code># A tibble: 20 x 2
   parameter                         values                                                       
   &lt;chr>                             &lt;chr>                                                        
 1 model_id                          DeepLearning_grid_1_AutoML…         
 2 training_frame                    automl_training_frame_rdd…
 3 nfolds                            5                                                            
 4 keep_cross_validation_models      FALSE                                                        
 5 keep_cross_validation_predictions TRUE                                                         
 6 fold_assignment                   Modulo                                                       
 7 overwrite_with_best_model         FALSE                                                        
 8 activation                        RectifierWithDropout                                         
 9 hidden                            200                                                          
10 epochs                            10003.6618461538                                             
11 seed                              1                                                            
12 rho                               0.95                                                         
13 epsilon                           1e-06                                                        
14 input_dropout_ratio               0.2                                                          
15 hidden_dropout_ratios             0.4                                                          
16 stopping_rounds                   0                                                            
17 stopping_metric                   deviance                                                     
18 stopping_tolerance                0.05                                                         
19 x                                 c("cyl", "wt")                                         
20 y                                 mpg </code>
You can then predict using the leader as follows:
<code>h2o.predict(automl@leader, predictions)</code>
<code>   predict
1 30.74639

[1 row x 1 column] </code>
Many additional examples are available, and you can also request help from the official GitHub repository for the <code>rsparkling</code> package.
The next extension, <code>graphframes</code>, allows you to process large-scale relational datasets. 
Before you start using it, make sure to disconnect with <code>spark_disconnect(sc)</code> and restart your R session since using a different extension requires you to reconnect to Spark and reload <code>sparklyr</code>.

<h2>10.3 Graphs</h2>
The first paper in the history of graph theory was written by Leonhard Euler on the Seven Bridges of Königsberg in 1736. 
The problem was to devise a walk through the city that would cross each bridge once and only once. 
Figure 10.3 presents the original diagram.

<img src="https://therinspark.com/images/extensions-eulers-paths-resized.png" />

FIGURE 10.3: The Seven Bridges of Königsberg from the Euler archive

Today, a graph is defined as an ordered pair \(G=(V,E)\), with \(V\) a set of vertices (nodes or points) and \(E \subseteq \{\{x, y\} | (x, y) ∈ \mathrm{V}^2 \land x \ne y\}\) a set of edges (links or lines), which are either an unordered pair for <em>undirected graphs</em> or an ordered pair for <em>directed graphs</em>. 
The former describes links where the direction does not matter, and the latter describes links where it does.
As a simple example, we can use the <code>highschool</code> dataset from the <code>ggraph</code> package, which tracks friendship among high school boys. 
In this dataset, the vertices are the students and the edges describe pairs of students who happen to be friends in a particular year:
<code>install.packages("ggraph")
install.packages("igraph")</code>
<code>ggraph::highschool</code>
<code># A tibble: 506 x 3
    from    to  year
   &lt;dbl> &lt;dbl> &lt;dbl>
 1     1    14  1957
 2     1    15  1957
 3     1    21  1957
 4     1    54  1957
 5     1    55  1957
 6     2    21  1957
 7     2    22  1957
 8     3     9  1957
 9     3    15  1957
10     4     5  1957
# … with 496 more rows</code>
While the high school dataset can easily be processed in R, even medium-size graph datasets can be difficult to process without distributing this work across a cluster of machines, for which Spark is well suited. 
Spark supports processing graphs through the <code>graphframes</code> extension, which in turn uses the GraphX Spark component. 
GraphX is Apache Spark’s API for graphs and graph-parallel computation. 
It’s comparable in performance to the fastest specialized graph-processing systems and provides a growing library of graph algorithms.
A graph in Spark is also represented as a DataFrame of edges and vertices; however, our format is slightly different since we will need to construct a DataFrame for vertices. 
Let’s first install the <code>graphframes</code> extension:
<code>install.packages("graphframes")</code>
Next, we need to connect, copying the <code>highschool</code> dataset and transforming the graph to the format that this extension expects. 
Here, we scope this dataset to the friendships of the year 1957:
<code>library(graphframes)
library(sparklyr)
library(dplyr)

sc &lt;- spark_connect(master = "local", version = "2.3")
highschool_tbl &lt;- copy_to(sc, ggraph::highschool, "highschool") %>%
  filter(year == 1957) %>%
  transmute(from = as.character(as.integer(from)),
            to = as.character(as.integer(to)))

from_tbl &lt;- highschool_tbl %>% distinct(from) %>% transmute(id = from)
to_tbl &lt;- highschool_tbl %>% distinct(to) %>% transmute(id = to)

vertices_tbl &lt;- distinct(sdf_bind_rows(from_tbl, to_tbl))
edges_tbl &lt;- highschool_tbl %>% transmute(src = from, dst = to)</code>
The <code>vertices_tbl</code> table is expected to have a single <code>id</code> column:
<code>vertices_tbl</code>
<code># Source: spark&lt;?> [?? x 1]
   id   
   &lt;chr>
 1 1    
 2 34   
 3 37   
 4 43   
 5 44   
 6 45   
 7 56   
 8 57   
 9 65   
10 71   
# … with more rows</code>
And the <code>edges_tbl</code> is expected to have <code>src</code> and <code>dst</code> columns:
<code>edges_tbl</code>
<code># Source: spark&lt;?> [?? x 2]
   src   dst  
   &lt;chr> &lt;chr>
 1 1     14   
 2 1     15   
 3 1     21   
 4 1     54   
 5 1     55   
 6 2     21   
 7 2     22   
 8 3     9    
 9 3     15   
10 4     5    
# … with more rows</code>
You can now create a GraphFrame:
<code>graph &lt;- gf_graphframe(vertices_tbl, edges_tbl)</code>
We now can use this graph to start analyzing this dataset. 
For instance, we’ll find out how many friends on average every boy has, which is referred to as the <em>degree</em> or <em>valency</em> of a <em>vertex</em>:
<code>gf_degrees(graph) %>% summarise(friends = mean(degree))</code>
<code># Source: spark&lt;?> [?? x 1]
  friends
    &lt;dbl>
1    6.94</code>
We then can find what the shortest path to some specific vertex (a boy for this dataset). 
Since the data is anonymized, we can just pick the boy identified as <code>33</code> and find how many degrees of separation exist between them:
<code>gf_shortest_paths(graph, 33) %>%
  filter(size(distances) > 0) %>%
  mutate(distance = explode(map_values(distances))) %>%
  select(id, distance)</code>
<code># Source: spark&lt;?> [?? x 2]
   id    distance
   &lt;chr>    &lt;int>
 1 19           5
 2 5            4
 3 27           6
 4 4            4
 5 11           6
 6 23           4
 7 36           1
 8 26           2
 9 33           0
10 18           5
# … with more rows</code>
Finally, we can also compute PageRank over this graph, which was presented in Chapter 1’s discussion of Google’s page ranking algorithm:
<code>gf_graphframe(vertices_tbl, edges_tbl) %>%
  gf_pagerank(reset_prob = 0.15, max_iter = 10L)</code>
<code>GraphFrame
Vertices:
  Database: spark_connection
  $ id       &lt;dbl> 12, 12, 14, 14, 27, 27, 55, 55, 64, 64, 41, 41, 47, 47, 6…
  $ pagerank &lt;dbl> 0.3573460, 0.3573460, 0.3893665, 0.3893665, 0.2362396, 0.…
Edges:
  Database: spark_connection
  $ src    &lt;dbl> 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 12, 12, 12,…
  $ dst    &lt;dbl> 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,…
  $ weight &lt;dbl> 0.25000000, 0.25000000, 0.25000000, 0.25000000, 0.25000000,…</code>
To give you some insights into this dataset, Figure 10.4 plots this chart using the <code>ggraph</code> and highlights the highest PageRank scores for the following dataset:
<code>highschool_tbl %>%
  igraph::graph_from_data_frame(directed = FALSE) %>%
  ggraph(layout = &#39;kk&#39;) + 
    geom_edge_link(alpha = 0.2,
                   arrow = arrow(length = unit(2, &#39;mm&#39;)),
                   end_cap = circle(2, &#39;mm&#39;),
                   start_cap = circle(2, &#39;mm&#39;)) + 
    geom_node_point(size = 2, alpha = 0.4)</code>

<img src="https://therinspark.com/images/extensions-graph-pagerank-resized.png" />

FIGURE 10.4: High school ggraph dataset with highest PageRank highlighted

There are many more graph algorithms provided in <code>graphframes</code>—for example, breadth-first search, connected components, label propagation for detecting communities, strongly connected components, and triangle count. 
For questions on this extension refer to the official GitHub repository. 
We now present a popular gradient-boosting framework—make sure to disconnect and restart before trying the next extension.

<h2>10.4 XGBoost</h2>
A <em>decision tree</em> is a flowchart-like structure in which each internal node represents a test on an attribute, each branch represents the outcome of the test, and each leaf node represents a class label. 
For example, Figure 10.5 shows a decision tree that could help classify whether an employee is likely to leave given a set of factors like job satisfaction and overtime. 
When a decision tree is used to predict continuous variables instead of discrete outcomes—say, how likely someone is to leave a company—it is referred to as a <em>regression tree</em>.

<img src="https://therinspark.com/the-r-in-spark_files/figure-html/extensions-decision-diagram-1.png" height="280pt" />

FIGURE 10.5: A decision tree to predict job attrition based on known factors

While a decision tree representation is quite easy to understand and to interpret, finding out the decisions in the tree requires mathematical techniques like <em>gradient descent</em> to find a local minimum. 
Gradient descent takes steps proportional to the negative of the gradient of the function at the current point. 
The gradient is represented by \(\nabla\), and the learning rate by \(\gamma\). 
You simply start from a given state \(a_n\) and compute the next iteration \(a_{n+1}\) by following the direction of the gradient:
<center style="margin-top: 30px; margin-bottom: 30px">
\(a_{n+1} = a_n - \gamma \nabla F(a_n)\)
</center>
XGBoost is an open source software library that provides a gradient-boosting framework. 
It aims to provide scalable, portable, and distributed gradient boosting for training gradient-boosted decision trees (GBDT) and gradient-boosted regression trees (GBRT). 
Gradient-boosted means XGBoost uses gradient descent and boosting, which is a technique that chooses each predictor sequentially.
<code>sparkxgb</code> is an extension that you can use to train XGBoost models in Spark; however, be aware that currently Windows is unsupported. 
To use this extension, first install it from CRAN:
<code>install.packages("sparkxgb")</code>
Then, you need to import the <code>sparkxgb</code> extension followed by your usual Spark connection code, adjusting <code>master</code> as needed:
<code>library(sparkxgb)
library(sparklyr)
library(dplyr)

sc &lt;- spark_connect(master = "local", version = "2.3")</code>
For this example, we use the <code>attrition</code> dataset from the <code>rsample</code> package, which you would need to install by using <code>install.packages("rsample")</code>. 
This is a fictional dataset created by IBM data scientists to uncover the factors that lead to employee attrition:
<code>attrition &lt;- copy_to(sc, rsample::attrition)
attrition</code>
<code># Source: spark&lt;?> [?? x 31]
     Age Attrition BusinessTravel DailyRate Department DistanceFromHome
   &lt;int> &lt;chr>     &lt;chr>              &lt;int> &lt;chr>                 &lt;int>
 1    41 Yes       Travel_Rarely       1102 Sales                     1
 2    49 No        Travel_Freque…       279 Research_…                8
 3    37 Yes       Travel_Rarely       1373 Research_…                2
 4    33 No        Travel_Freque…      1392 Research_…                3
 5    27 No        Travel_Rarely        591 Research_…                2
 6    32 No        Travel_Freque…      1005 Research_…                2
 7    59 No        Travel_Rarely       1324 Research_…                3
 8    30 No        Travel_Rarely       1358 Research_…               24
 9    38 No        Travel_Freque…       216 Research_…               23
10    36 No        Travel_Rarely       1299 Research_…               27
# … with more rows, and 25 more variables: Education &lt;chr>,
#   EducationField &lt;chr>, EnvironmentSatisfaction &lt;chr>, Gender &lt;chr>,
#   HourlyRate &lt;int>, JobInvolvement &lt;chr>, JobLevel &lt;int>, JobRole &lt;chr>,
#   JobSatisfaction &lt;chr>, MaritalStatus &lt;chr>, MonthlyIncome &lt;int>,
#   MonthlyRate &lt;int>, NumCompaniesWorked &lt;int>, OverTime &lt;chr>,
#   PercentSalaryHike &lt;int>, PerformanceRating &lt;chr>,
#   RelationshipSatisfaction &lt;chr>, StockOptionLevel &lt;int>,
#   TotalWorkingYears &lt;int>, TrainingTimesLastYear &lt;int>,
#   WorkLifeBalance &lt;chr>, YearsAtCompany &lt;int>, YearsInCurrentRole &lt;int>,
#   YearsSinceLastPromotion &lt;int>, YearsWithCurrManager &lt;int></code>
To build an XGBoost model in Spark, use <code>xgboost_classifier()</code>. 
We will compute attrition against all other features by using the <code>Attrition ~ .</code> formula and specify <code>2</code> for the number of classes since the attrition attribute tracks only whether an employee leaves or stays. 
Then, you can use <code>ml_predict()</code> to predict over large-scale datasets:
<code>xgb_model &lt;- xgboost_classifier(attrition,
                                Attrition ~ .,
                                num_class = 2,
                                num_round = 50,
                                max_depth = 4)

xgb_model %>%
  ml_predict(attrition) %>%
  select(Attrition, predicted_label, starts_with("probability_")) %>%
  glimpse()</code>
<code>Observations: ??
Variables: 4
Database: spark_connection
$ Attrition       &lt;chr> "Yes", "No", "Yes", "No", "No", "No", "No", "No", "No", …
$ predicted_label &lt;chr> "No", "Yes", "No", "Yes", "Yes", "Yes", "Yes", "Yes", "Y…
$ probability_No  &lt;dbl> 0.753938094, 0.024780750, 0.915146366, 0.143568754, 0.07…
$ probability_Yes &lt;dbl> 0.24606191, 0.97521925, 0.08485363, 0.85643125, 0.927375…</code>
XGBoost became well known in the competition circles after its use in the winning solution of the Higgs Machine Learning Challenge, which uses the ATLAS experiment to identify the Higgs boson. 
Since then, it has become a popular model and used for a large number of Kaggle competitions. 
However, decision trees could prove limiting especially in datasets with nontabular data like images, audio, and text, which you can better tackle with deep learning models—should we remind you to disconnect and restart?

<h2>10.5 Deep Learning</h2>
A <em>perceptron</em> is a mathematical model introduced by Frank Rosenblatt, who developed it as a theory for a hypothetical nervous system. 
The perceptron maps stimuli to numeric inputs that are weighted into a threshold function that activates only when enough stimuli is present, mathematically:
\(f(x) = \begin{cases} 1 &amp; \sum_{i=1}^m w_i x_i + b > 0\\ 0 &amp; \text{otherwise} \end{cases}\)
Minsky and Papert found out that a single perceptron can classify only datasets that are linearly separable; however, they also revealed in their book <em>Perceptrons</em> that layering perceptrons would bring additional classification capabilities. 
Figure 10.6 presents the original diagram showcasing a multilayered perceptron.

<img src="https://therinspark.com/images/extensions-minsky-multi-layers.png" />

FIGURE 10.6: Layered perceptrons, as illustrated in the book Perceptrons

Before we start, let’s first install all the packages that we are about to use:
<code>install.packages("sparktf")
install.packages("tfdatasets")</code>
Using Spark we can create a multilayer perceptron classifier with <code>ml_multilayer_perceptron_classifier()</code> and gradient descent to classify and predict over large datasets. 
Gradient descent was introduced to layered perceptrons by Geoff Hinton.
<code>library(sparktf)
library(sparklyr)

sc &lt;- spark_connect(master = "local", version = "2.3")

attrition &lt;- copy_to(sc, rsample::attrition)

nn_model &lt;- ml_multilayer_perceptron_classifier(
  attrition,
  Attrition ~ Age + DailyRate + DistanceFromHome + MonthlyIncome,
  layers = c(4, 3, 2),
  solver = "gd")

nn_model %>%
  ml_predict(attrition) %>%
  select(Attrition, predicted_label, starts_with("probability_")) %>%
  glimpse()</code>
<code>Observations: ??
Variables: 4
Database: spark_connection
$ Attrition       &lt;chr> "Yes", "No", "Yes", "No", "No", "No", "No", "No", "No"…
$ predicted_label &lt;chr> "No", "No", "No", "No", "No", "No", "No", "No", "No", …
$ probability_No  &lt;dbl> 0.8439275, 0.8439275, 0.8439275, 0.8439275, 0.8439275,…
$ probability_Yes &lt;dbl> 0.1560725, 0.1560725, 0.1560725, 0.1560725, 0.1560725,…</code>
Notice that the columns must be numeric, so you will need to manually convert them with the feature transforming techniques presented in Chapter 4. 
It is natural to try to add more layers to classify more complex datasets; however, adding too many layers will cause the gradient to vanish, and other techniques will need to use these deep layered networks, also known as <em>deep learning models</em>.
Deep learning models solve the vanishing gradient problem by making use of special activation functions, dropout, data augmentation and GPUs. 
You can use Spark to retrieve and preprocess large datasets into numerical-only datasets that can fit in a GPU for deep learning training. 
TensorFlow is one of the most popular deep learning frameworks. 
As mentioned previously, it supports a binary format known as TensorFlow records.
You can write TensorFlow records using the <code>sparktf</code> in Spark, which you can prepare to process in GPU instances with libraries like Keras or TensorFlow.
You can then preprocess large datasets in Spark and write them as TensorFlow records using <code>spark_write_tf()</code>:
<code>copy_to(sc, iris) %>%
  ft_string_indexer_model(
    "Species", "label",
    labels = c("setosa", "versicolor", "virginica")
  ) %>%
  spark_write_tfrecord(path = "tfrecord")</code>
After you have trained the dataset with Keras or TensorFlow, you can use the <code>tfdatasets</code> package to load it. 
You will also need to install the TensorFlow runtime by using <code>install_tensorflow()</code> and install Python on your own. 
To learn more about training deep learning models with Keras, we recommend reading <em>Deep Learning with R</em>.
<code>tensorflow::install_tensorflow()
tfdatasets::tfrecord_dataset("tfrecord/part-r-00000")</code>
<code>&lt;DatasetV1Adapter shapes: (), types: tf.string></code>
Training deep learning models in a single local node with one or more GPUs is often enough for most applications; however, recent state-of-the-art deep learning models train using distributed computing frameworks like Apache Spark. 
Distributed computing frameworks are used to achieve higher petaflops each day the systems spends training these models. 
OpenAI analyzed trends in the field of <em>artificial intelligence</em> (AI) and cluster computing (illustrated in Figure 10.7). 
It should be obvious from the figure that there is a trend in recent years to use distributed computing frameworks.

<img src="https://therinspark.com/images/extensions-distributed-training-resized.png" />

FIGURE 10.7: Training using distributed systems based on OpenAI analysis

Training large-scale deep learning models is possible in Spark and TensorFlow through frameworks like Horovod. 
Today, it’s possible to use Horovod with Spark from R using the <code>reticulate</code> package, since Horovod requires Python and Open MPI, this goes beyond the scope of this book. 
Next, we will introduce a different Spark extension in the domain of genomics.

<h2>10.6 Genomics</h2>
The human genome consists of two copies of about 3 billion base pairs of DNA within the 23 chromosome pairs. 
Figure 10.8 shows the organization of the genome into chromosomes. 
DNA strands are composed of nucleotides, each composed of one of four nitrogen-containing nucleobases: cytosine (C), guanine (G), adenine (A), or thymine (T). 
Since the DNA of all humans is nearly identical, we need to store only the differences from the reference genome in the form of a variant call format (VCF) file.

<img src="https://therinspark.com/images/extensions-genomics-diagram-resized.png" />

FIGURE 10.8: The idealized human diploid karyotype showing the organization of the genome into chromosomes

<code>variantspark</code> is a framework based on Scala and Spark to analyze genome datasets. 
It is being developed by CSIRO Bioinformatics team in Australia. 
<code>variantspark</code> was tested on datasets with 3,000 samples, each one containing 80 million features in either unsupervised clustering approaches or supervised applications, like classification and regression. 
<code>variantspark</code> can read VCF files and run analyses while using familiar Spark DataFrames.
To get started, install <code>variantspark</code> from CRAN, connect to Spark, and retrieve a <code>vsc</code> connection to <code>variantspark</code>:
<code>library(variantspark)
library(sparklyr)

sc &lt;- spark_connect(master = "local", version = "2.3",
                    config = list(sparklyr.connect.timeout = 3 * 60))

vsc &lt;- vs_connect(sc)</code>
We can start by loading a VCF file:
<code>vsc_data &lt;- system.file("extdata/", package = "variantspark")

hipster_vcf &lt;- vs_read_vcf(vsc, file.path(vsc_data, "hipster.vcf.bz2"))
hipster_labels &lt;- vs_read_csv(vsc, file.path(vsc_data, "hipster_labels.txt"))
labels &lt;- vs_read_labels(vsc, file.path(vsc_data, "hipster_labels.txt"))</code>
<code>variantspark</code> uses random forest to assign an importance score to each tested variant reflecting its association to the interest phenotype. 
A variant with higher importance score implies it is more strongly associated with the phenotype of interest. 
You can compute the importance and transform it into a Spark table, as follows:
<code>importance_tbl &lt;- vs_importance_analysis(vsc, hipster_vcf, 
                                         labels, n_trees = 100) %>%
  importance_tbl()

importance_tbl</code>
<code># Source: spark&lt;?> [?? x 2]
   variable    importance
   &lt;chr>            &lt;dbl>
 1 2_109511398 0         
 2 2_109511454 0         
 3 2_109511463 0.00000164
 4 2_109511467 0.00000309
 5 2_109511478 0         
 6 2_109511497 0         
 7 2_109511525 0         
 8 2_109511527 0         
 9 2_109511532 0         
10 2_109511579 0         
# … with more rows</code>
You then can use <code>dplyr</code> and <code>ggplot2</code> to transform the output and visualize it (see Figure 10.9):
<code>library(dplyr)
library(ggplot2)

importance_df &lt;- importance_tbl %>% 
  arrange(-importance) %>% 
  head(20) %>% 
  collect()

ggplot(importance_df) +
  aes(x = variable, y = importance) + 
  geom_bar(stat = &#39;identity&#39;) +          
  scale_x_discrete(limits = 
    importance_df[order(importance_df$importance), 1]$variable) + 
  coord_flip()</code>

<img src="https://therinspark.com/images/extensions-genomics-importance-resized.png" />

FIGURE 10.9: Genomic importance analysis using variantspark

This concludes a brief introduction to genomic analysis in Spark using the <code>variantspark</code> extension. 
Next, we move away from microscopic genes to macroscopic datasets that contain geographic locations across the world.

<h2>10.7 Spatial</h2>
<code>geospark</code> enables distributed geospatial computing using a grammar compatible with <code>dplyr</code> and <code>sf</code>, which provides a set of tools for working with geospatial vectors.
You can install <code>geospark</code> from CRAN, as follows:
<code>install.packages("geospark")</code>
Then, initialize the <code>geospark</code> extension and connect to Spark:
<code>library(geospark)
library(sparklyr)

sc &lt;- spark_connect(master = "local", version = "2.3")</code>
Next, we load a spatial dataset containing polygons and points:
<code>polygons &lt;- system.file("examples/polygons.txt", package="geospark") %>%
  read.table(sep="|", col.names = c("area", "geom"))

points &lt;- system.file("examples/points.txt", package="geospark") %>%
  read.table(sep = "|", col.names = c("city", "state", "geom"))

polygons_wkt &lt;- copy_to(sc, polygons)
points_wkt &lt;- copy_to(sc, points)</code>
There are various spatial operations defined in <code>geospark</code>, as depicted in Figure 10.10. 
These operations allow you to control how geospatial data should be queried based on overlap, intersection, disjoint sets, and so on.

<img src="https://therinspark.com/images/extensions-geospark-operations.png" />

FIGURE 10.10: Spatial operations available in geospark

For instance, we can use these operations to find the polygons that contain a given set of points using <code>st_contains()</code>:
<code>library(dplyr)
polygons_wkt &lt;- mutate(polygons_wkt, y = st_geomfromwkt(geom))
points_wkt &lt;- mutate(points_wkt, x = st_geomfromwkt(geom))

inner_join(polygons_wkt,
           points_wkt,
           sql_on = sql("st_contains(y,x)")) %>% 
  group_by(area, state) %>%
  summarise(cnt = n()) </code>
<code># Source: spark&lt;?> [?? x 3]
# Groups: area
  area            state   cnt
  &lt;chr>           &lt;chr> &lt;dbl>
1 california area CA       10
2 new york area   NY        9
3 dakota area     ND       10
4 texas area      TX       10
5 dakota area     SD        1</code>
You can also plot these datasets by collecting a subset of the entire dataset or aggregating the geometries in Spark before collecting them. 
One package you should look into is <code>sf</code>.
We close this chapter by presenting a couple of troubleshooting techniques applicable to all extensions.

<h2>10.8 Troubleshooting</h2>
When you are using a new extension for the first time, we recommend increasing the connection timeout (given that Spark will usually need to download extension dependencies) and changing logging to verbose to help you troubleshoot when the download process does not complete:
<code>config &lt;- spark_config()
config$sparklyr.connect.timeout &lt;- 3 * 60
config$sparklyr.log.console = TRUE

sc &lt;- spark_connect(master = "local", config = config)</code>
In addition, you should know that Apache IVY is a popular dependency manager focusing on flexibility and simplicity, and is used by Apache Spark for installing extensions. 
When the connection fails while you are using an extension, consider clearing your IVY cache by running the following:
<code>unlink("~/.ivy2", recursive = TRUE)</code>
In addition, you can also consider opening GitHub issues from the following extensions repositories to get help from the extension authors:
<ul>
<li><em>rsparkling</em>: github.com/h2oai/sparkling-water.</li>
<li><em>sparkxgb</em>: github.com/rstudio/sparkxgb.</li>
<li><em>sparktf</em>: github.com/rstudio/sparktf.</li>
<li><em>variantspark</em>: github.com/r-spark/variantspark.</li>
<li><em>geospark</em>: github.com/r-spark/geospark.</li>
</ul>

<h2>10.9 Recap</h2>
This chapter provided a brief overview on using some of the Spark extensions available in R, which happens to be as easy as installing a package. 
You then learned how to use the <code>rsparkling</code> extension, which provides access to H2O in Spark, which in turn provides additional modeling functionality like enhanced metrics and the ability to automatically select models. 
We then jumped to <code>graphframes</code>, an extension to help you process relational datasets that are formally referred to as graphs. 
You also learned how to compute simple connection metrics or run complex algorithms like PageRank.
The XGBoost and deep learning sections provided alternate modeling techniques that use gradient descent: the former over decision trees, and the latter over deep multilayered perceptrons where we can use Spark to preprocess datasets into records that later can be consumed by TensorFlow and Keras using the <code>sparktf</code> extension. 
The last two sections introduced extensions to process genomic and spatial datasets through the <code>variantspark</code> and <code>geospark</code> extensions.
These extensions, and many more, provide a comprehensive library of advanced functionality that, in combination with the analysis and modeling techniques presented, should cover most tasks required to run in computing clusters. 
However, when functionality is lacking, you can consider writing your own extension, which is what we discuss in Chapter 13, or you can apply custom transformations over each partition using R code, as we describe in Chapter 11.

<h2><span class="orange">Chapter 11 Distributed R</span></h2>
In previous chapters, you learned how to perform data analysis and modeling in local Spark instances and proper Spark clusters. 
In Chapter 10 specifically, we examined how to make use of the additional functionality provided by the Spark and R communities at large. 
In most cases, the combination of Spark functionality and extensions is more than enough to perform almost any computation. 
However, for those cases in which functionality is lacking in Spark and their extensions, you could consider distributing R computations to worker nodes yourself.
You can run arbitrary R code in each worker node to run any computation—you can run simulations, crawl content from the web, transform data, and so on. 
In addition, you can also make use of any package available in CRAN and private packages available in your organization, which reduces the amount of code that you need to write to help you remain productive.
If you are already familiar with R, you might be tempted to use this approach for all Spark operations; however, this is not the recommended use of <code>spark_apply()</code>. 
Previous chapters provided more efficient techniques and tools to solve well-known problems; in contrast, <code>spark_apply()</code> introduces additional cognitive overhead, additional troubleshooting steps, performance trade-offs, and, in general, additional complexity you should avoid. 
Not to say that <code>spark_apply()</code> should never be used; rather, <code>spark_apply()</code> is reserved to support use cases for which previous tools and techniques fell short.

<h2>11.1 Overview</h2>
Chapter 1 introduced MapReduce as a technique capable of processing large-scale datasets. 
It also described how Apache Spark provided a superset of operations to perform MapReduce computations easily and more efficiently. 
Chapter 9 presented insights into how Spark works by applying custom transformations over each partition of the distributed datasets. 
For instance, if we multiplied each element of a distributed numeric dataset by 10, Spark would apply a mapping operation over each partition through multiple workers. 
A conceptual view of this process is illustrated in Figure 11.1.

<img src="https://therinspark.com/the-r-in-spark_files/figure-html/distributed-times-ten-1.png" height="280pt" />

FIGURE 11.1: Map operation when multiplying by 10

This chapter presents how to define a custom <code>f(x)</code> mapping operation using <code>spark_apply()</code>; for the previous example, <code>spark_apply()</code> provides support to define <code>10 * x</code>, as follows:
<code>sdf_len(sc, 3) %>% spark_apply(~ 10 * .x)</code>
<code># Source: spark&lt;?> [?? x 1]
     id
* &lt;dbl>
1    10
2    20
3    30</code>
Notice that <code>~ 10 * .x</code> is plain R code executed across all worker nodes. 
The <code>~</code> operator is defined in the <code>rlang</code> package and provides a compact definition of a function equivalent to <code>function(.x) 10 * .x</code>; this compact form is also known as an <em>anonymous function</em>, or <em>lambda expression</em>.
The <code>f(x)</code> function must take an R DataFrame (or something that can be automatically transformed to one) as input and must also produce an R DataFrame as output, as shown in Figure 11.2.

<img src="https://therinspark.com/the-r-in-spark_files/figure-html/distributed-spark-apply-input-output-1.png" height="100pt" />

FIGURE 11.2: Expected function signature in spark_apply() mappings

We can refer back to the original MapReduce example from Chapter 1, where the map operation was defined to split sentences into words and the total unique words were counted as the reduce operation.
In R, we could make use of the <code>unnest_tokens()</code> function from the <code>tidytext</code> R package, which you would need to install from CRAN before connecting to Spark. 
You can then use <code>tidytext</code> with <code>spark_apply()</code> to tokenize those sentences into a table of words:
<code>sentences &lt;- copy_to(sc, data_frame(text = c("I like apples", "I like bananas")))

sentences %>%
  spark_apply(~tidytext::unnest_tokens(.x, word, text))</code>
<code># Source: spark&lt;?> [?? x 1]
  word   
* &lt;chr>  
1 i      
2 like   
3 apples 
4 i      
5 like   
6 bananas</code>
We can complete this MapReduce example by performing the reduce operation with <code>dplyr</code>, as follows:
<code>sentences %>%
  spark_apply(~tidytext::unnest_tokens(., word, text)) %>%
  group_by(word) %>%
  summarise(count = count())</code>
<code># Source: spark&lt;?> [?? x 2]
  word    count
* &lt;chr>   &lt;dbl>
1 i           2
2 apples      1
3 like        2
4 bananas     1</code>
The rest of this chapter will explain in detail the use cases, features, caveats, considerations, and troubleshooting techniques required when you are defining custom mappings through <code>spark_apply()</code>.
<strong>Note:</strong> The previous sentence tokenizer example can be more efficiently implemented using concepts from previous chapters, specifically through <code>sentences %>% ft_tokenizer("text", "words") %>% transmute(word = explode(words))</code>.

<h2>11.2 Use Cases</h2>
Now that we’ve presented an example to help you understand how <code>spark_apply()</code> works, we’ll cover a few practical use cases for it:

<dt>Import</dt>
You can consider using R to import data from external data sources and formats. 
For example, when a file format is not natively supported in Spark or its extensions, you can consider using R code to implement a distributed <em>custom parser</em> using R packages.

<dt>Model</dt>
It is natural to use the rich modeling capabilities already available in R with Spark. 
In most cases, R models can’t be used across large data; however, we will present two particular use cases where R models can be useful at scale. 
For instance, when data fits into a single machine, you can use <em>grid search</em> to optimize their parameters in parallel. 
In cases where the data can be partitioned to create several models over subsets of the data, you can use <em>partitioned modeling</em> in R to compute models across partitions.

<dt>Transform</dt>
You can use R’s rich data transformation capabilities to complement Spark. 
We’ll present a use case of evaluating data by external systems, and use R to interoperate with them by calling them through(((“web APIs”))) a <em>web API</em>.

<dt>Compute</dt>
When you need to perform large-scale computation in R, or <em>big compute</em> as described in Chapter 1, Spark is ideal to distribute this computation. 
We will present <em>simulations</em> as a particular use case for large-scale computing in R.

As we now explore each use case in detail, we’ll provide a working example to help you understand how to use <code>spark_apply()</code> effectively.

<h3>11.2.1 Custom Parsers</h3>
Though Spark and its various extensions provide support for many file formats (CSVs, JSON, Parquet, AVRO, etc.), you might need other formats to use at scale. 
You can parse these additional formats using <code>spark_apply()</code> and many existing R packages. 
In this section, we will look at how to parse logfiles, though similar approaches can be followed to parse other file formats.
It is common to use Spark to analyze logfiles—for instance, logs that track download data from Amazon S3. 
The <code>webreadr</code> package can simplify the process of parsing logs by providing support to load logs stored as Amazon S3, Squid, and the Common log format. 
You should install <code>webreadr</code> from CRAN before connecting to Spark.
For example, an Amazon S3 log looks as follows:
<code>#Version: 1.0
#Fields: date time x-edge-location sc-bytes c-ip cs-method cs(Host) cs-uri-stem
  sc-status cs(Referer) cs(User-Agent) cs-uri-query cs(Cookie) x-edge-result-type
  x-edge-request-id x-host-header cs-protocol cs-bytes time-taken 
  
2014-05-23  01:13:11    FRA2    182 192.0.2.10  GET d111111abcdef8.cloudfront.net
  /view/my/file.html    200 www.displaymyfiles.com  Mozilla/4.0%20
  (compatible;%20MSIE%205.0b1;%20Mac_PowerPC)   -   zip=98101   RefreshHit
  MRVMF7KydIvxMWfJIglgwHQwZsbG2IhRJ07sn9AkKUFSHS9EXAMPLE==
  d111111abcdef8.cloudfront.net http    -   0.001</code>
This can be parsed easily with <code>read_aws()</code>, as follows:
<code>aws_log &lt;- system.file("extdata/log.aws", package = "webreadr")
webreadr::read_aws(aws_log)</code>
<code># A tibble: 2 x 18
  date                edge_location bytes_sent ip_address http_method host  path 
  &lt;dttm>              &lt;chr>              &lt;int> &lt;chr>      &lt;chr>       &lt;chr> &lt;chr>
1 2014-05-23 01:13:11 FRA2                 182 192.0.2.10 GET         d111… /vie…
2 2014-05-23 01:13:12 LAX1             2390282 192.0.2.2… GET         d111… /sou…
# ... 
with 11 more variables: status_code &lt;int>, referer &lt;chr>, user_agent &lt;chr>,
#   query &lt;chr>, cookie &lt;chr>, result_type &lt;chr>, request_id &lt;chr>,
#   host_header &lt;chr>, protocol &lt;chr>, bytes_received &lt;chr>, time_elapsed &lt;dbl></code>
To scale this operation, we can make use of <code>read_aws()</code> using <code>spark_apply()</code>:
<code>spark_read_text(sc, "logs", aws_log, overwrite = TRUE, whole = TRUE) %>%
  spark_apply(~webreadr::read_aws(.x$contents))</code>
<code># Source: spark&lt;?> [?? x 18]
  date                edge_location bytes_sent ip_address http_method host  path 
* &lt;dttm>              &lt;chr>              &lt;int> &lt;chr>      &lt;chr>       &lt;chr> &lt;chr>
1 2014-05-23 01:13:11 FRA2                 182 192.0.2.10 GET         d111… /vie…
2 2014-05-23 01:13:12 LAX1             2390282 192.0.2.2… GET         d111… /sou…
# ... 
with 11 more variables: status_code &lt;int>, referer &lt;chr>, user_agent &lt;chr>,
#   query &lt;chr>, cookie &lt;chr>, result_type &lt;chr>, request_id &lt;chr>,
#   host_header &lt;chr>, protocol &lt;chr>, bytes_received &lt;chr>, time_elapsed &lt;dbl></code>
The code used by plain R and <code>spark_apply()</code> is similar; however, with <code>spark_apply()</code>, logs are parsed in parallel across all the worker nodes available in your cluster.
This concludes the custom parsers discussion; you can parse many other file formats at scale from R following a similar approach. 
Next we’ll look at present partitioned <em>modeling</em> as another use case focused on modeling across several datasets in parallel.

<h3>11.2.2 Partitioned Modeling</h3>
There are many modeling packages available in R that can also be run at scale by partitioning the data into manageable groups that fit in the resources of a single machine.
For instance, suppose that you have a 1 TB dataset for sales data across multiple cities and you are tasked with creating sales predictions over each city. 
For this case, you can consider partitioning the original dataset per city—say, into 10 GB of data per city—which could be managed by a single compute instance. 
For this kind of partitionable dataset, you can also consider using <code>spark_apply()</code> by training each model over each city.
As a simple example of partitioned modeling, we can run a linear regression using the <code>iris</code> dataset partitioned by species:
<code>iris &lt;- copy_to(sc, datasets::iris)

iris %>%
  spark_apply(nrow, group_by = "Species")</code>
<code># Source: spark&lt;?> [?? x 2]
  Species    result
  &lt;chr>       &lt;int>
1 versicolor     50
2 virginica      50
3 setosa         50</code>
Then you can run a linear regression over each species using <code>spark_apply()</code>:
<code>iris %>%
  spark_apply(
    function(e) summary(lm(Petal_Length ~ Petal_Width, e))$r.squared,
    names = "r.squared",
    group_by = "Species")</code>
<code># Source: spark&lt;?> [?? x 2]
  Species    r.squared
  &lt;chr>          &lt;dbl>
1 versicolor     0.619
2 virginica      0.104
3 setosa         0.110</code>
As you can see from the <code>r.squared</code> results and intuitively in Figure 11.3, the linear model for <code>versicolor</code> better fits to the regression line:
<code>purrr::map(c("versicolor", "virginica", "setosa"),
  ~dplyr::filter(datasets::iris, Species == !!.x) %>%
    ggplot2::ggplot(ggplot2::aes(x = Petal.Length, y = Petal.Width)) +
    ggplot2::geom_point())</code>

<img src="https://therinspark.com/images/distributed-r-partitioned-modeling.png" />

FIGURE 11.3: Modeling over species in the iris dataset

This concludes our brief overview on how to perform modeling over several different partitionable datasets. 
A similar technique can be applied to perform modeling over the same dataset using different modeling parameters, as we cover next.

<h3>11.2.3 Grid Search</h3>
Many R packages provide models that require defining multiple parameters to configure and optimize. 
When the value of these parameters is unknown, we can distribute this list of unknown parameters across a cluster of machines to find the optimal parameter combination. 
If the list contains more than one parameter to optimize, it is common to test against all the combinations between parameter A and parameter B, creating a grid of parameters. 
The process of searching for the best parameter over this parameter grid is commonly known as <em>grid search</em>.
For example, we can define a grid of parameters to optimize decision tree models as follows:
<code>grid &lt;- list(minsplit = c(2, 5, 10), maxdepth = c(1, 3, 8)) %>%
  purrr:::cross_df() %>%
  copy_to(sc, ., repartition = 9)
grid</code>
<code># Source: spark&lt;?> [?? x 2]
  minsplit maxdepth
     &lt;dbl>    &lt;dbl>
1        2        1
2        5        1
3       10        1
4        2        3
5        5        3
6       10        3
7        2        8
8        5        8
9       10        8</code>
The grid dataset was copied by using <code>repartition = 9</code> to ensure that each partition is contained in one machine, since the grid also has nine rows. 
Now, assuming that the original dataset fits in every machine, we can distribute this dataset to many machines and perform parameter search to find the model that best fits this data:
<code>spark_apply(
  grid,
  function(grid, cars) {
    model &lt;- rpart::rpart(
      am ~ hp + mpg,
      data = cars,
      control = rpart::rpart.control(minsplit = grid$minsplit,
                                     maxdepth = grid$maxdepth)
    )
    dplyr::mutate(
      grid,
      accuracy = mean(round(predict(model, dplyr::select(cars, -am))) == cars$am)
    )
  },
  context = mtcars)</code>
<code># Source: spark&lt;?> [?? x 3]
  minsplit maxdepth accuracy
     &lt;dbl>    &lt;dbl>    &lt;dbl>
1        2        1    0.812
2        5        1    0.812
3       10        1    0.812
4        2        3    0.938
5        5        3    0.938
6       10        3    0.812
7        2        8    1    
8        5        8    0.938
9       10        8    0.812</code>
For this model, <code>minsplit = 2</code> and <code>maxdepth = 8</code> produces the most accurate results. 
You can now use this specific parameter combination to properly train your model.

<h3>11.2.4 Web APIs</h3>
A web API is a program that can do something useful through a web interface that other programs can reuse. 
For instance, services like Twitter provide web APIs that allow you to automate reading tweets from a program written in R and other programming languages. 
You can make use of web APIs using <code>spark_apply()</code> by sending programmatic requests to external services using R code.
For example, Google provides a web API to label images using deep learning techniques; you can use this API from R, but for larger datasets, you need to access its APIs from Spark. 
You can use Spark to prepare data to be consumed by a web API and then use <code>spark_apply()</code> to perform this call and process all the incoming results back in Spark.
The next example makes use of the <code>googleAuthR</code> package to authenticate to Google Cloud, the <code>RoogleVision</code> package to perform labeling over the Google Vision API, and <code>spark_apply()</code> to interoperate between Spark and Google’s deep learning service. 
To run the following example, you’ll first need to disconnect from Spark and download your <em>cloudml.json</em> file from the Google developer portal:
<code>sc &lt;- spark_connect(
  master = "local",
  config = list(sparklyr.shell.files = "cloudml.json"))

images &lt;- copy_to(sc, data.frame(
  image = "http://pbs.twimg.com/media/DwzcM88XgAINkg-.jpg"
))

spark_apply(images, function(df) {
  googleAuthR::gar_auth_service(
    scope = "https://www.googleapis.com/auth/cloud-platform",
    json_file = "cloudml.json")
  
  RoogleVision::getGoogleVisionResponse(
    df$image,
    download = FALSE)
})</code>
<code># Source: spark&lt;?> [?? x 4]
  mid       description score topicality
  &lt;chr>     &lt;chr>       &lt;dbl>      &lt;dbl>
1 /m/04rky  Mammal      0.973      0.973
2 /m/0bt9lr Dog         0.958      0.958
3 /m/01z5f  Canidae     0.956      0.956
4 /m/0kpmf  Dog breed   0.909      0.909
5 /m/05mqq3 Snout       0.891      0.891</code>
To successfully run a large distributed computation over a web API, the API needs to be able to scale to support the load from all the Spark executors. 
We can trust that major service providers are likely to support all the requests incoming from your cluster. 
But when you’re calling internal web APIs, make sure the API can handle the load. 
Also, when you’re using third-party services, consider the cost of calling their APIs across all the executors in your cluster to avoid potentially expensive and unexpected charges.
Next we’ll describe a use case for big compute where R is used to perform distributed rendering.

<h3>11.2.5 Simulations</h3>
You can use R combined with Spark to perform large-scale computing. 
The use case we explore here is rendering computationally expensive images using the <code>rayrender</code> package, which uses <em>ray tracing</em>, a photorealistic technique commonly used in movie production.
Let’s use this package to render a simple scene that includes a few spheres (see Figure 11.4) that use a <em>lambertian material</em>, a diffusely reflecting material or “matte”. 
First, install <code>rayrender</code> using <code>install.packages("rayrender")</code>. 
Then, be sure you’ve disconnected and reconnected Spark:
<code>library(rayrender)

scene &lt;- generate_ground(material = lambertian()) %>%
  add_object(sphere(material = metal(color="orange"), z = -2)) %>%
  add_object(sphere(material = metal(color="orange"), z = +2)) %>%
  add_object(sphere(material = metal(color="orange"), x = -2))

render_scene(scene, lookfrom = c(10, 5, 0), parallel = TRUE)</code>

<img src="https://therinspark.com/images/distributed-r-rayrender-resized.png" />

FIGURE 11.4: Ray tracing in Spark using R and rayrender

In higher resolutions, say 1920 x 1080, the previous example takes several minutes to render the single frame from Figure 11.4; rendering a few seconds at 30 frames per second would take several hours in a single machine. 
However, we can reduce this time using multiple machines by parallelizing computation across them. 
For instance, using 10 machines with the same number of CPUs would cut rendering time tenfold:
<code>system2("hadoop", args = c("fs", "-mkdir", "/rendering"))

sdf_len(sc, 628, repartition = 628) %>%
  spark_apply(function(idx, scene) {
    render &lt;- sprintf("%04d.png", idx$id)
    rayrender::render_scene(scene, width = 1920, height = 1080,
                            lookfrom = c(12 * sin(idx$id/100), 
                                         5, 12 * cos(idx$id/100)),
                            filename = render)
      
    system2("hadoop", args = c("fs", "-put", render, "/user/hadoop/rendering/"))
  }, context = scene, columns = list()) %>% collect()</code>
After all the images are rendered, the last step is to collect them from HDFS and use tools like <code>ffmpeg</code> to convert individual images into an animation:
<code>hadoop fs -get rendering/
ffmpeg -s 1920x1080 -i rendering/%d.png -vcodec libx264 -crf 25
       -pix_fmt yuv420p rendering.mp4</code>
<strong>Note:</strong> This example assumes HDFS is used as the storage technology for Spark and being run under a <code>hadoop</code> user, you will need to adjust this for your particular storage or user.
We’ve covered some common use cases for <code>spark_apply()</code>, but you are certainly welcome to find other use cases for your particular needs. 
The next sections present technical concepts you’ll need to understand to create additional use cases and to use <code>spark_apply()</code> effectively.

<h2>11.3 Partitions</h2>
Most Spark operations that analyze data with <code>dplyr</code> or model with MLlib don’t require understanding how Spark partitions data; they simply work automatically. 
However, for distributed R computations, this is not the case. 
For these you will have to learn and understand how exactly Spark is partitioning your data and provide transformations that are compatible with them. 
This is required since <code>spark_apply()</code> receives each partition and allows you to perform any transformation, not the entire dataset. 
You can refresh concepts like partitioning and transformations using the diagrams and examples from Chapter 9.
To help you understand how partitions are represented in <code>spark_apply()</code>, consider the following code:
<code>sdf_len(sc, 10) %>%
  spark_apply(~nrow(.x))</code>
<code># Source: spark&lt;?> [?? x 1]
  result
*  &lt;int>
1      5
2      5</code>
Should we expect the output to be the total number of rows? As you can see from the results, in general the answer is no; Spark assumes data will be distributed across multiple machines, so you’ll often find it already partitioned, even for small datasets. 
Because we should not expect <code>spark_apply()</code> to operate over a single partition, let’s find out how many partitions <code>sdf_len(sc, 10)</code> contains:
<code>sdf_len(sc, 10) %>% sdf_num_partitions()</code>
<code>[1] 2</code>
This explains why counting rows through <code>nrow()</code> under <code>spark_apply()</code> retrieves two rows since there are two partitions, not one. 
<code>spark_apply()</code> is retrieving the count of rows over each partition, and each partition contains 5 rows, not 10 rows total, as you might have expected.
For this particular example, we could further aggregate these partitions by repartitioning and then adding up—this would resemble a simple MapReduce operation using <code>spark_apply()</code>:
<code>sdf_len(sc, 10) %>%
  spark_apply(~nrow(.x)) %>%
  sdf_repartition(1) %>%
  spark_apply(~sum(.x))</code>
<code># Source: spark&lt;?> [?? x 1]
  result
*  &lt;int>
1     10</code>
So now that you know about partitions using <code>spark_apply()</code>, we’ll move on to using <code>group_by</code> to control partitions.

<h2>11.4 Grouping</h2>
When using <code>spark_apply()</code>, we can request explicit partitions from Spark. 
For instance, if we had to process numbers less than four in one partition and the remaining ones in a second partition, we could create these groups explicitly and then request <code>spark_apply()</code> to use them:
<code>sdf_len(sc, 10) %>%
  transmute(groups = id &lt; 4) %>%
  spark_apply(~nrow(.x), group_by = "groups")</code>
<code># Source: spark&lt;?> [?? x 2]
  groups result
* &lt;lgl>   &lt;int>
1 TRUE        3
2 FALSE       7</code>
Notice that <code>spark_apply()</code> is still processing two partitions, but in this case we expect these partitions since we explicitly requested them in <code>spark_apply()</code>; therefore, you can safely interpret the results as “there are three integers less than four”.
<strong>Note</strong>: You can only group data by partitions that fit in a single machine; if one of the groups is too large, an exception will be thrown. 
To perform operations over groups that exceed the resources of a single node, you can consider partitioning to smaller units or use <code>dplyr::do</code>, which is currently optimized for large partitions.
The takeaway from this section is to always consider partitions when dealing with <code>spark_apply()</code>. 
Next, we will zoom in to <code>spark_apply()</code> to understand how columns are interpreted.

<h2>11.5 Columns</h2>
By default, <code>spark_apply()</code> automatically inspects the DataFrame being produced to learn column names and types. 
For example:
<code>sdf_len(sc, 1) %>%
  spark_apply(~ data.frame(numbers = 1, names = "abc"))</code>
<code># Source: spark&lt;?> [?? x 2]
  numbers names
*   &lt;dbl> &lt;chr>
1       1 abc </code>
However, this is inefficient since <code>spark_apply()</code> needs to run twice: first, to find columns by computing <code>spark_apply()</code> against a subset of all the data, and then to compute the actual desired values.
To improve performance, you can explicitly specify the columns through the <code>columns</code> parameters. 
This parameter takes a named list of types expected in the resulting DataFrame. 
We can then rewrite the previous example to run only once by specifying the correct type for the <code>numbers</code> column:
<code>sdf_len(sc, 1) %>%
  spark_apply(
    ~ data.frame(numbers = 1, names = "abc"),
    columns = list(numbers = "double", names = "character"))</code>
<code># Source: spark&lt;?> [?? x 2]
  numbers names
*   &lt;dbl> &lt;chr>
1       1 abc </code>
Now that we’ve presented how rows and columns interact with <code>spark_apply()</code>, let’s move on to making use of the contextual information sometimes required when processing distributed datasets.

<h2>11.6 Context</h2>
To process partitions using <code>spark_apply()</code>, you might need to include auxiliary data that is small enough to fit in each node. 
This was the case in the grid search use case, where the dataset was passed to all partitions and remained unpartitioned itself.
We can modify the initial <code>f(x) = 10 * x</code> example in this chapter to customize the multiplier. 
It was originally set to <code>10</code>, but we can make it configurable by specifying it as the <code>context</code> parameter:
<code>sdf_len(sc, 4) %>%
  spark_apply(
    function(data, context) context * data,
    context = 100
  )</code>
<code># Source: spark&lt;?> [?? x 1]
     id
  &lt;dbl>
1   100
2   200
3   300
4   400</code>
Figure 11.5 illustrates this example conceptually. 
Notice that the data partitions are still variable; however, the contextual parameter is distributed to all the nodes.

<img src="https://therinspark.com/the-r-in-spark_files/figure-html/distributed-times-context-1.png" height="280pt" />

FIGURE 11.5: Map operation when multiplying with context

The grid search example used this parameter to pass a DataFrame to each worker node; however, since the context parameter is serialized as an R object, it can contain anything. 
For instance, if you need to pass multiple values—or even multiple datasets—you can pass a list with values.
The following example defines a <code>f(x) = m * x + b</code> function and runs <code>m = 10</code> and <code>b = 2</code>:
<code>sdf_len(sc, 4) %>%
  spark_apply(
    ~.y$m * .x + .y$b,
    context = list(b = 2, m = 10)
  )</code>
<code># Source: spark&lt;?> [?? x 1]
     id
  &lt;dbl>
1    12
2    22
3    32
4    42</code>
Notice that we’ve renamed <code>context</code> to <code>.y</code> to shorten the variable name. 
This works because <code>spark_apply()</code> assumes context is the second parameter in functions and expressions.
You’ll find the <code>context</code> parameter extremely useful; for instance, the next section presents how to properly construct functions, and <code>context</code> is used in advanced use cases to construct functions dependent on other functions.

<h2>11.7 Functions</h2>
Earlier we presented <code>spark_apply()</code> as an operation to perform custom transformations using a function or expression. 
In programming literature, functions with a context are also referred to as a <em>closure</em>.
Expressions are useful to define short transformations, like <code>~ 10 * .x</code>. 
For an expression, <code>.x</code> contains a partition and <code>.y</code> the context, when available. 
However, it can be hard to define an expression for complex code that spans multiple lines. 
For those cases, functions are more appropriate.
Functions enable complex and multiline transformations, and are defined as <code>function(data, context) {}</code> where you can provide arbitrary code within the <code>{}</code>. 
We’ve seen them in previous sections when using Google Cloud to transform images into image captions.
The function passed to <code>spark_apply()</code> is serialized using <code>serialize()</code>, which is described as “a simple low-level interface for serializing to connections”. 
One current limitation of <code>serialize()</code> is that it won’t serialize objects being referenced outside its environment. 
For instance, the following function errors out since the closure references <code>external_value</code>:
<code>external_value &lt;- 1
spark_apply(iris, function(e) e + external_value)</code>
As workarounds to this limitation, you can add the functions your closure needs into the <code>context</code> and then assign the functions into the global environment:
<code>func_a &lt;- function() 40
func_b &lt;- function() func_a() + 1
func_c &lt;- function() func_b() + 1

sdf_len(sc, 1) %>% spark_apply(function(df, context) {
  for (name in names(context)) assign(name, context[[name]], envir = .GlobalEnv)
  func_c()
}, context = list(
  func_a = func_a,
  func_b = func_b,
  func_c = func_c
))</code>
<code># Source: spark&lt;?> [?? x 1]
  result
   &lt;dbl>
1     42</code>
When this isn’t feasible, you can also create your own R package with the functionality you need and then use your package in <code>spark_apply()</code>.
You’ve learned all the functionality available in <code>spark_apply()</code> using plain R code. 
In the next section we present how to use packages when distributing computations. 
R packages are essential when you are creating useful transformations.

<h2>11.8 Packages</h2>
With <code>spark_apply()</code> you can use any R package inside Spark. 
For instance, you can use the <code>broom</code> package to create a tidy(((“DataFrames”, “from linear regression output”))) DataFrame from linear regression output:
<code>spark_apply(
  iris,
  function(e) broom::tidy(lm(Petal_Length ~ Petal_Width, e)),
  names = c("term", "estimate", "std.error", "statistic", "p.value"),
  group_by = "Species")</code>
<code># Source: spark&lt;?> [?? x 6]
  Species    term        estimate std.error statistic  p.value
  &lt;chr>      &lt;chr>          &lt;dbl>     &lt;dbl>     &lt;dbl>    &lt;dbl>
1 versicolor (Intercept)    1.78     0.284       6.28 9.48e- 8
2 versicolor Petal_Width    1.87     0.212       8.83 1.27e-11
3 virginica  (Intercept)    4.24     0.561       7.56 1.04e- 9
4 virginica  Petal_Width    0.647    0.275       2.36 2.25e- 2
5 setosa     (Intercept)    1.33     0.0600     22.1  7.68e-27
6 setosa     Petal_Width    0.546    0.224       2.44 1.86e- 2</code>
The first time you call <code>spark_apply()</code>, all the contents in your local <code>.libPaths()</code> (which contains all R packages) will be copied into each Spark worker node. 
Packages are only copied once and persist as long as the connection remains open. 
It’s not uncommon for R libraries to be several gigabytes in size, so be prepared for a one-time tax while the R packages are copied over to your Spark cluster. 
You can disable package distribution by setting <code>packages = FALSE</code>.
<strong>Note:</strong> Since packages are copied only once for the duration of the <code>spark_connect()</code> connection, installing additional packages is not supported while the connection is active. 
Therefore, if a new package needs to be installed, <code>spark_disconnect()</code> the connection, modify packages, and then reconnect. 
In addition, R packages are not copied in local mode, because the packages already exist on the local system.
Though this section was brief, using packages with distributed R code opens up an entire new universe of interesting use cases. 
Some of those use cases were presented in this chapter, but by looking at the rich ecosystem of R packages available today you’ll find many more.
This section completes our discussion of the functionality needed to distribute R code with R packages. 
We’ll now cover some of the requirements your cluster needs to make use of <code>spark_apply()</code>.

<h2>11.9 Cluster Requirements</h2>
The functionality presented in previous chapters did not require special configuration of your Spark cluster—as long as you had a properly configured Spark cluster, you could use R with it. 
However, for the functionality presented here, your cluster administrator, cloud provider, or you will have to configure your cluster by installing either:
<ul>
<li>R in every node, to execute R code across your cluster</li>
<li>Apache Arrow in every node when using Spark 2.3 or later (Arrow provides performance improvements that bring distributed R code closer to native Scala code)</li>
</ul>
Let’s take a look at each requirement to ensure that you properly consider the trade-offs or benefits that they provide.

<h3>11.9.1 Installing R</h3>
Starting with the first requirement, the R runtime is expected to be preinstalled in <em>every</em> node in the cluster; this is a requirement specific to <code>spark_apply()</code>.
Failure to install R in every node will trigger a <code>Cannot run program, no such file or directory</code> error when you attempt to use <code>spark_apply()</code>.
Contact your cluster administrator to consider making the R runtime available throughout the entire cluster. 
If R is already installed, you can specify the installation path to use with the <code>spark.r.command</code> configuration setting, as shown here:
<code>config &lt;- spark_config()
config["spark.r.command"] &lt;- "&lt;path-to-r-version>"

sc &lt;- spark_connect(master = "local", config = config)
sdf_len(sc, 10) %>% spark_apply(function(e) e)</code>
A <em>homogeneous cluster</em> is required since the driver node distributes, and potentially compiles, packages to the workers. 
For instance, the driver and workers must have the same processor architecture, system libraries, and so on. 
This is usually the case for most clusters, but might not be true for yours.
Different cluster managers, Spark distributions, and cloud providers support different solutions to install additional software (like R) across every node in the cluster; follow instructions when installing R over each worker node. 
Here are a few examples:

<dt>Spark Standalone</dt>
Requires connecting to each machine and installing R; tools like <code>pssh</code> allow you to run a single installation command against multiple machines.

<dt>Cloudera</dt>
Provides an R parcel (see the Cloudera blog post “How to Distribute Your R code with sparklyr and Cloudera Data Science Workbench”), which enables R over each worker node.

<dt>Amazon EMR</dt>
R is preinstalled when starting an EMR cluster as mentioned in Clusters - Amazon EMR.

<dt>Microsoft HDInsight</dt>
R is preinstalled and no additional steps are needed.

<dt>Livy</dt>
Livy connections <em>do not</em> support distributing packages because the client machine where the libraries are precompiled might not have the same processor architecture or operating systems as the cluster machines.

Strictly speaking, this completes the last requirement for your cluster. 
However, we strongly recommend you use Apache Arrow with <code>spark_apply()</code> to support large-scale computation with minimal overhead.

<h3>11.9.2 Apache Arrow</h3>
Before introducing Apache Arrow, we’ll discuss how data is stored and transferred between Spark and R. 
As R was designed from its inception to perform fast numeric computations to accomplish this, it’s important to figure out the best way to store data.
Some computing systems store data internally by row; however, most interesting numerical operations require data to be processed by column. 
For example, calculating the mean of a column requires processing each column on its own, not the entire row. 
Spark stores data by default by row, since it’s easier to partition; in contrast, R stores data by column. 
Therefore, something needs to transform both representations when data is transferred between Spark and R, as shown in Figure 11.6.

<img src="https://therinspark.com/the-r-in-spark_files/figure-html/distributed-r-transformation-1.png" height="200pt" />

FIGURE 11.6: Data transformation between Spark and R

This transformation from rows to columns needs to happen for each partition. 
In addition, data also must be transformed from Scala’s internal representation to R’s internal representation. 
Apache Arrow reduces these transformations that waste a lot of CPU cycles.
Apache Arrow is a cross-language development platform for in-memory data. 
In Spark, it speeds up transferring data between Scala and R by defining a common data format compatible with many programming languages. 
Instead of having to transform between Scala’s internal representation and R’s, you can use the same structure for both languages. 
In addition, transforming data from row-based storage to columnar storage is performed in parallel in Spark, which can be further optimized by using the columnar storage formats presented in Chapter 8. 
The improved transformations are shown in Figure 11.6.

<img src="https://therinspark.com/the-r-in-spark_files/figure-html/distributed-r-using-arrow-1.png" height="260pt" />

FIGURE 11.7: Data transformation between Spark and R using Apache Arrow

Apache Arrow is not required but is strongly recommended while you are working with <code>spark_apply()</code>. 
It has been available since Spark 2.3.0; however, it requires system administrators to install the Apache Arrow runtime in every node (see http://arrow.apache.org/install/).
In addition, to use Apache Arrow with <code>sparklyr</code>, you also need to install the <code>arrow</code> package:
<code>install.packages("arrow")</code>
Before we use <code>arrow</code>, let’s take a measurement to validate:
<code>system.time(
  sdf_len(sc, 10^4) %>% spark_apply(nrow) %>% collect()
)</code>
<code>   user  system elapsed 
  0.240   0.020   7.957</code>
In our particular system, processing 10,000 rows takes about 8 seconds. 
To enable Arrow, simply include the library and use <code>spark_apply()</code> as usual. 
Let’s measure how long it takes <code>spark_apply()</code> to process 1 million rows:
<code>library(arrow)
system.time(
  sdf_len(sc, 10^6) %>% spark_apply(nrow) %>% collect()
)</code>
<code>   user  system elapsed 
  0.317   0.021   3.922</code>
In our system, Apache Arrow can process 100 times more data in half the time: just 4 seconds.
Most functionality in <code>arrow</code> simply works in the background, improving performance and data serialization; however, there is one setting you should be aware of. 
The <code>spark.sql.execution.arrow.maxRecordsPerBatch</code> configuration setting specifies the default size of each arrow data transfer. 
It’s shared with other Spark components and defaults to 10,000 rows:
<code>library(arrow)
sdf_len(sc, 2 * 10^4) %>% spark_apply(nrow)</code>
<code># Source: spark&lt;?> [?? x 1]
  result
   &lt;int>
1  10000
2  10000</code>
You might need to adjust this number based on how much data your system can handle, making it smaller for large datasets or bigger for operations that require records to be processed together. 
We can change this setting to 5,000 rows and verify the partitions change appropriately:
<code>config &lt;- spark_config()
config$spark.sql.execution.arrow.maxRecordsPerBatch &lt;- 5 * 10^3

sc &lt;- spark_connect(master = "local", config = config)
sdf_len(sc, 2 * 10^4) %>% spark_apply(nrow)</code>
<code># Source: spark&lt;?> [?? x 1]
  result
   &lt;int>
1   5000
2   5000
3   5000
4   5000</code>
So far we’ve presented use cases, main operations, and cluster requirements. 
Now we’ll discuss the troubleshooting techniques useful when distributing R code.

<h2>11.10 Troubleshooting</h2>
A custom transformation can fail for many reasons. 
To learn how to troubleshoot errors, let’s simulate a problem by triggering an error ourselves:
<code>sdf_len(sc, 1) %>% spark_apply(~stop("force an error"))</code>
<code>Error in force(code) : 
  sparklyr worker rscript failure, check worker logs for details
    Log: wm_bx4cn70s6h0r5vgsldm0000gn/T/Rtmpob83LD/file2aac1a6188_spark.log

---- Output Log ----
19/03/11 14:12:24 INFO sparklyr: Worker (1) completed wait using lock for RScript</code>
Notice that the error message mentions inspecting the logs. 
When running in local mode, you can simply run the following:
<code>spark_log(sc, filter = "terminated unexpectedly")</code>
<code>19/03/11 14:12:24 ERROR sparklyr: RScript (1) terminated unexpectedly:
                                              force an error </code>
This points to the artificial <code>stop("force an error")</code> error we mentioned. 
However, if you’re not working in local mode, you will have to retrieve the worker logs from your cluster manager. 
Since this can be cumbersome, one alternative is to rerun <code>spark_apply()</code> but return the error message yourself:
<code>sdf_len(sc, 1) %>% spark_apply(~tryCatch(
    stop("force an error"),
    error = function(e) e$message
))</code>
<code># Source: spark&lt;?> [?? x 1]
  result        
  &lt;chr>         
1 force an error</code>
Among the other, more advanced troubleshooting techniques applicable to <code>spark_apply()</code>, the following sections present these techniques in order. 
You should try to troubleshoot by using worker logs first, then identifying partitioning errors, and finally, attempting to debug a worker node.

<h3>11.10.1 Worker Logs</h3>
Whenever <code>spark_apply()</code> is executed, information regarding execution is written over each worker node. 
You can use this log to write custom messages to help you diagnose and fine-tune your code.
For instance, suppose that we don’t know what the first column name of <code>df</code> is. 
We can write a custom log message executed from the worker nodes using <code>worker_log()</code> as follows:
<code>sdf_len(sc, 1) %>% spark_apply(function(df) {
  worker_log("the first column in the data frame is named ", names(df)[[1]])
  df
})</code>
<code># Source: spark&lt;?> [?? x 1]
     id
* &lt;int>
1     1</code>
When running locally, we can filter the log entries for the worker as follows:
<code>spark_log(sc, filter = "sparklyr: RScript")</code>
<code>18/12/18 11:33:47 INFO sparklyr: RScript (3513) the first column in the dataframe
                                                is named id 
18/12/18 11:33:47 INFO sparklyr: RScript (3513) computed closure 
18/12/18 11:33:47 INFO sparklyr: RScript (3513) updating 1 rows 
18/12/18 11:33:47 INFO sparklyr: RScript (3513) updated 1 rows 
18/12/18 11:33:47 INFO sparklyr: RScript (3513) finished apply 
18/12/18 11:33:47 INFO sparklyr: RScript (3513) finished </code>
Notice that the logs print our custom log entry, showing that <code>id</code> is the name of the first column in the given DataFrame.
This functionality is useful when troubleshooting errors; for instance, if we force an error using the <code>stop()</code> function:
<code>sdf_len(sc, 1) %>% spark_apply(function(df) {
  stop("force an error")
})</code>
We will get an error similar to the following:
<code> Error in force(code) : 
  sparklyr worker rscript failure, check worker logs for details</code>
As suggested by the error, we can look in the worker logs for the specific errors as follows:
<code>spark_log(sc)</code>
This will show an entry containing the error and the call stack:
<code>18/12/18 11:26:47 INFO sparklyr: RScript (1860) computing closure 
18/12/18 11:26:47 ERROR sparklyr: RScript (1860) terminated unexpectedly:
                                                 force an error 
18/12/18 11:26:47 ERROR sparklyr: RScript (1860) collected callstack: 
11: stop("force and error")
10: (function (df) 
{
    stop("force and error")
})(structure(list(id = 1L), class = "data.frame", row.names = c(NA, 
-1L)))</code>
Notice that <code>spark_log(sc)</code> only retrieves the worker logs when you’re using local clusters. 
When running in proper clusters with multiple machines, you will have to use the tools and user interface provided by the cluster manager to find these log entries.

<h3>11.10.2 Resolving Timeouts</h3>
When you are running with several hundred executors, it becomes more likely that some tasks will hang indefinitely. 
In this situation, most of the tasks in your job complete successfully, but a handful of them are still running and do not fail or succeed.
Suppose that you need to calculate the size of many web pages. 
You could use <code>spark_apply()</code> with something similar to:
<code>sdf_len(sc, 3, repartition = 3) %>%
  spark_apply(~ download.file("https://google.com", "index.html") +
                file.size("index.html"))</code>
Some web pages might not exist or take too long to download. 
In this case, most tasks will succeed, but a few will hang. 
To prevent these few tasks from blocking all computations, you can use the <code>spark.speculation</code> Spark setting. 
With this setting enabled, once 75% of all tasks succeed, Spark will look for tasks taking longer than the median task execution time and retry. 
You can use the <code>spark.speculation.multiplier</code> setting to configure the time multiplier used to determine when a task is running slow.
Therefore, for this example, you could configure Spark to retry tasks that take four times longer than the median as follows:
<code>config &lt;- spark_config()
config["spark.speculation"] &lt;- TRUE
config["spark.speculation.multiplier"] &lt;- 4</code>

<h3>11.10.3 Inspecting Partitions</h3>
If a particular partition fails, you can detect the broken partition by computing a digest and then retrieving that particular partition. 
As usual, you can install <code>digest</code> from CRAN before connecting to Spark:
<code>sdf_len(sc, 3) %>% spark_apply(function(x) {
    worker_log("processing ", digest::digest(x), " partition")
    # your code
    x
})</code>
This will add an entry similar to:
<code>18/11/03 14:48:32 INFO sparklyr: RScript (2566)
  processing f35b1c321df0162e3f914adfb70b5416 partition </code>
When executing this in your cluster, look in the logs for the task that is not finishing. 
Once you have that digest, you can cancel the job. 
Then you can use that digest to retrieve the specific DataFrame to R with something like this:
<code>sdf_len(sc, 3) %>% spark_apply(function(x) {
    if (identical(digest::digest(x),
                  "f35b1c321df0162e3f914adfb70b5416")) x else x[0,]
}) %>% collect()</code>
<code># A tibble: 1 x 1
  result
   &lt;int>
1      1</code>
You can then run this in R to troubleshoot further.

<h3>11.10.4 Debugging Workers</h3>
A debugger is a tool that lets you execute your code line by line; you can use this to troubleshoot <code>spark_apply()</code> for local connections. 
You can start <code>spark_apply()</code> in debug mode by using the <code>debug</code> parameter and then following the instructions:
<code>sdf_len(sc, 1) %>% spark_apply(function() {
  stop("Error!")
}, debug = TRUE)</code>
<code>Debugging spark_apply(), connect to worker debugging session as follows:
  1. 
Find the workers &lt;sessionid> and &lt;port> in the worker logs, from RStudio
     click &#39;Log&#39; under the connection, look for the last entry with contents:
     &#39;Session (&lt;sessionid>) is waiting for sparklyr client to connect to
      port &lt;port>&#39;
  2. 
From a new R session run:
     debugonce(sparklyr:::spark_worker_main)
     sparklyr:::spark_worker_main(&lt;sessionid>, &lt;port>)</code>
As these instructions indicate, you’ll need to connect “as the worker node” from a different R session and then step through the code. 
This method is less straightforward than previous ones, since you’ll also need to step through some lines of <code>sparklyr</code> code; thus, we only recommend this as a last resort. 
(You can also try the online resources described in Chapter 2.)
Let’s now wrap up this chapter with a brief recap of the functionality we presented.

<h2>11.11 Recap</h2>
This chapter presented <code>spark_apply()</code> as an advanced technique you can use to fill gaps in functionality in Spark or its many extensions. 
We presented example use cases for <code>spark_apply()</code> to parse data, model in parallel many small datasets, perform a grid search, and call web APIs. 
You learned how partitions relate to <code>spark_apply()</code>, and how to create custom groups, distribute contextual information across all nodes, and troubleshoot problems, limitations, and cluster configuration caveats.
We also strongly recommended using Apache Arrow as a library when working with Spark with R, and presented installation, use cases, and considerations you should be aware of.
Up to this point, we’ve only worked with large datasets of static data, which doesn’t change over time and remains invariant while we analyze, model, and visualize them. 
In Chapter 12, we will introduce techniques to process datasets that, in addition to being large, are also growing in such a way that they resemble a stream of information.

<h2><span class="orange">Chapter 12 Streaming</span></h2>
Looking back at the previous chapters, we’ve covered a good deal, but not everything. 
We’ve analyzed tabular datasets, performed unsupervised learning over raw text, analyzed graphs and geographic datasets, and even transformed data with custom R code! So now what?
Though we weren’t explicit about this, we’ve assumed until this point that your data is static, and didn’t change over time. 
But suppose for a moment your job is to analyze traffic patterns to give recommendations to the department of transportation. 
A reasonable approach would be to analyze historical data and then design predictive models that compute forecasts overnight. 
Overnight? That’s very useful, but traffic patterns change by the hour and even by the minute. 
You could try to preprocess and predict faster and faster, but eventually this model breaks—you can’t load large-scale datasets, transform them, score them, unload them, and repeat this process by the second.
Instead, we need to introduce a different kind of dataset—one that is not static but rather dynamic, one that is like a table but is growing constantly. 
We will refer to such datasets as <em>streams</em>.

<h2>12.1 Overview</h2>
We know how to work with large-scale static datasets, but how can we reason about large-scale real-time datasets? Datasets with an infinite amount of entries are known as <strong>streams</strong>.
For static datasets, if we were to do real-time scoring using a pretrained topic model, the entries would be lines of text; for real-time datasets, we would perform the same scoring over an infinite number of lines of text. 
Now, in practice, you will never process an infinite number of records. 
You will eventually stop the stream—or this universe might end, whichever comes first. 
Regardless, thinking of the datasets as infinite makes it much easier to reason about them.
Streams are most relevant when processing real-time data—for example, when analyzing a Twitter feed or stock prices. 
Both examples have well-defined columns, like “tweet” or “price,” but there are always new rows of data to be analyzed.
<em>Spark Streaming</em> provides scalable and fault-tolerant data processing over streams of data. 
That means you can use many machines to process multiple streaming sources, perform joins with other streams or static sources, and recover from failures with at-least-once guarantees (each message is certain to be delivered, but may do so multiple times).
In Spark, you create streams by defining a <em>source</em>, a <em>transformation</em>, and a <em>sink</em>; you can think of these steps as reading, transforming, and writing a stream, as shown in Figure 12.1 describes.

<img src="https://therinspark.com/the-r-in-spark_files/figure-html/streaming-working-1.png" height="280pt" />

FIGURE 12.1: Working with Spark Streaming

Let’s take a look at each of these a little more closely:

<dt>Reading</dt>
Streams read data using any of the <code>stream_read_*()</code> functions; the read operation defines the <em>source</em> of the stream. 
You can define one or multiple sources from which to read.

<dt>Transforming</dt>
A stream can perform one or multiple transformations using <code>dplyr</code>, <code>SQL</code>, feature transformers, scoring pipelines, or distributed R code. 
Transformations can not only be applied to one or more streams, but can also use a combination of streams and static data sources; for instance, those loaded into Spark with <code>spark_read_()</code> functions—this means that you can combine static data and real-time data sources with ease.

<dt>Writing</dt>
The write operations are performed with the family of <code>stream_write_*()</code> functions, while the read operation defined the sink of the stream. 
You can specify a single sink or multiple ones to write data to.

You can read and write to streams in several different file formats: CSV, JSON, Parquet, Optimized Row Columnar (ORC), and text (see Table 12.1). 
You also can read and write from and to Kafka, which we will introduce later on.
<table>
<caption>TABLE 12.1: Spark functions to read and write streams</caption>
<thead>
<tr><th align="left">Format</th><th align="left">Read</th><th align="left">Write</th></tr>
</thead>
<tbody>
<tr><td align="left">CSV</td><td align="left">stream_read_csv</td><td align="left">stream_write_csv</td></tr>
<tr><td align="left">JSON</td><td align="left">stream_read_json</td><td align="left">stream_write_json</td></tr>
<tr><td align="left">Kafka</td><td align="left">stream_read_kafka</td><td align="left">stream_write_kafka</td></tr>
<tr><td align="left">ORC</td><td align="left">stream_read_orc</td><td align="left">stream_write_orc</td></tr>
<tr><td align="left">Parquet</td><td align="left">stream_read_parquet</td><td align="left">stream_write_parquet</td></tr>
<tr><td align="left">Text</td><td align="left">stream_read_text</td><td align="left">stream_write_text</td></tr>
<tr><td align="left">Memory</td><td align="left"></td><td align="left">stream_write_memory</td></tr>
</tbody>
</table>
Since the transformation step is optional, the simplest stream we can define is one that continuously copies text files between source and destination.
First, install the <code>future</code> package using <code>install.packages("future")</code> and connect to Spark.
Since a stream requires the source to exist, create a <code>source</code> folder:
<code>dir.create("source")</code>
We are now ready to define our first stream!
<code>stream &lt;- stream_read_text(sc, "source/") %>%
  stream_write_text("destination/")</code>
The streams starts running with <code>stream_write_*()</code>; once executed, the stream will monitor the <em><code>source</code></em> path and process data into the <em>++destination /++</em> path as it arrives.
We can use <code>stream_generate_test()</code> to produce a file every second containing lines of text that follow a given distribution; you can read more about this in Appendix. 
In practice, you would connect to existing sources without having to generate data artificially. 
We can then use <code>view_stream()</code> to track the rows per second (rps) being processed in the source, and in the destination, and their latest values over time:
<code>future::future(stream_generate_test(interval = 0.5))</code>
<code>stream_view(stream)</code>
The result is shown in Figure 12.2.

<img src="https://therinspark.com/images/streaming-stream-view-resized.png" />

FIGURE 12.2: Monitoring a stream generating rows following a binomial distribution

Notice that the rps rate in the destination stream is higher than that in the source stream. 
This is expected and desirable since Spark measures incoming rates from the source stream, but also actual row-processing times in the destination stream. 
For example, if 10 rows per second are written to the <em>source/</em> path, the incoming rate is 10 rps. 
However, if it takes Spark only 0.01 seconds to write all those 10 rows, the output rate is 100 rps.
Use <code>stream_stop()</code> to properly stop processing data from this stream:
<code>stream_stop(stream)</code>
This exercise introduced how we can easily start a Spark stream that reads and writes data based on a simulated stream. 
Let’s do something more interesting than just copying data with proper transformations.

<h2>12.2 Transformations</h2>
In a real-life scenario, the incoming data from a stream would not be written as is to the output. 
The Spark Streaming job would make transformations to the data, and then write the transformed data.
Streams can be transformed using <code>dplyr</code>, SQL queries, ML pipelines, or R code. 
We can use as many transformations as needed in the same way that Spark DataFrames can be transformed with <code>sparklyr</code>.
The source of the transformation can be a stream or DataFrame, but the output is always a stream. 
If needed, you can always take a snapshot from the destination stream and then save the output as a DataFrame. 
That is what <code>sparklyr</code> will do for you if a destination stream is not specified.
Each of the following subsections covers an option provided by <code>sparklyr</code> to perform transformations on a stream.

<h3>12.2.1 Analysis</h3>
You can analyze streams with <code>dplyr</code> verbs and SQL using <code>DBI</code>. 
As a quick example, we will filter rows and add columns over a stream. 
We won’t explicitly call <code>stream_generate_test()</code>, but you can call it on your own through the <code>later</code> package if you feel the urge to verify that data is being processed continuously:
<code>library(dplyr)

stream_read_csv(sc, "source") %>%
  filter(x > 700) %>%
  mutate(y = round(x / 100))</code>
<code># Source: spark&lt;?> [inf x 2]
       x     y
   &lt;int> &lt;dbl>
 1   701     7
 2   702     7
 3   703     7
 4   704     7
 5   705     7
 6   706     7
 7   707     7
 8   708     7
 9   709     7
10   710     7
# … with more rows</code>
It’s also possible to perform aggregations over the entire history of the stream. 
The history could be filtered or not:
<code>stream_read_csv(sc, "source") %>%
  filter(x > 700) %>%
  mutate(y = round(x / 100)) %>%
  count(y) </code>
<code># Source: spark&lt;?> [inf x 2]
      y     n
  &lt;dbl> &lt;dbl>
1     8 25902
2     9 25902
3    10 13210
4     7 12692</code>
Grouped aggregations of the latest data in the stream require a timestamp. 
The timestamp will note when the reading function (in this case <code>stream_read_csv()</code>) first “saw” that specific record. 
In Spark Streaming terminology, the timestamp is called a <em>watermark</em>. 
The <code>spark_watermark()</code> function adds the timestamp. 
In this example, the watermark will be the same for all records, since the five files were read by the stream after they were created. 
Note that only Kafka and memory <em>outputs</em> support watermarks:
<code>stream_read_csv(sc, "source") %>%
  stream_watermark()</code>
<code># Source: spark&lt;?> [inf x 2]
       x timestamp          
   &lt;int> &lt;dttm>             
 1   276 2019-06-30 07:14:21
 2   277 2019-06-30 07:14:21
 3   278 2019-06-30 07:14:21
 4   279 2019-06-30 07:14:21
 5   280 2019-06-30 07:14:21
 6   281 2019-06-30 07:14:21
 7   282 2019-06-30 07:14:21
 8   283 2019-06-30 07:14:21
 9   284 2019-06-30 07:14:21
10   285 2019-06-30 07:14:21
# … with more rows</code>
After the watermark is created, you can use it in the <code>group_by()</code> verb. 
You can then pipe it into a <code>summarise()</code> function to get some stats of the stream:
<code>stream_read_csv(sc, "source") %>%
  stream_watermark() %>%
  group_by(timestamp) %>%
  summarise(
    max_x = max(x, na.rm = TRUE),
    min_x = min(x, na.rm = TRUE),
    count = n()
  ) </code>
<code># Source: spark&lt;?> [inf x 4]
  timestamp           max_x min_x  count
  &lt;dttm>              &lt;int> &lt;int>  &lt;dbl>
1 2019-06-30 07:14:55  1000     1 259332</code>

<h3>12.2.2 Modeling</h3>
Spark streams currently don’t support training on real-time datasets. 
Aside from the technical challenges, even if it were possible, it would be quite difficult to train models since the model itself would need to adapt over time. 
Known as <em>online learning</em>, this is perhaps something that Spark will support in the future.
That said, there are other modeling concepts we can use with streams, like feature transformers and scoring. 
Let’s try out a feature transformer with streams, and leave scoring for the next section, since we will need to train a model.
The next example uses the <code>ft_bucketizer()</code> feature transformer to modify the stream followed by regular <code>dplyr</code> functions, which you can use just as you would with static datasets:
<code>stream_read_csv(sc, "source") %>%
  mutate(x = as.numeric(x)) %>%
  ft_bucketizer("x", "buckets", splits = 0:10 * 100) %>%
  count(buckets)  %>%
  arrange(buckets)</code>
<code># Source:     spark&lt;?> [inf x 2]
# Ordered by: buckets
   buckets     n
     &lt;dbl> &lt;dbl>
 1       0 25747
 2       1 26008
 3       2 25992
 4       3 25908
 5       4 25905
 6       5 25903
 7       6 25904
 8       7 25901
 9       8 25902
10       9 26162</code>

<h3>12.2.3 Pipelines</h3>
Spark pipelines can be used for scoring streams, but not to train over streaming data. 
The former is fully supported, while the latter is a feature under active development by the Spark community.
To score a stream, it’s necessary to first create our model. 
So let’s build, fit, and save a simple pipeline:
<code>cars &lt;- copy_to(sc, mtcars)

model &lt;- ml_pipeline(sc) %>%
  ft_binarizer("mpg", "over_30", 30) %>%
  ft_r_formula(over_30 ~ wt) %>%
  ml_logistic_regression() %>%
  ml_fit(cars)</code>
<strong>Tip:</strong> If you choose to, you can make use of other concepts presented in Chapter 5, like saving and reloading pipelines through <code>ml_save()</code> and <code>ml_load()</code> before scoring streams.
We can then generate a stream based on <code>mtcars</code> using <code>stream_generate_test()</code>, and score the model using <code>ml_transform()</code>:
<code>future::future(stream_generate_test(mtcars, "cars-stream", iterations = 5))

ml_transform(model, stream_read_csv(sc, "cars-stream"))</code>
<code># Source: spark&lt;?> [inf x 17]
     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb over_30
   &lt;dbl> &lt;int> &lt;dbl> &lt;int> &lt;dbl> &lt;dbl> &lt;dbl> &lt;int> &lt;int> &lt;int> &lt;int>   &lt;dbl>
 1  15.5     8 318     150  2.76  3.52  16.9     0     0     3     2       0
 2  15.2     8 304     150  3.15  3.44  17.3     0     0     3     2       0
 3  13.3     8 350     245  3.73  3.84  15.4     0     0     3     4       0
 4  19.2     8 400     175  3.08  3.84  17.0     0     0     3     2       0
 5  27.3     4  79      66  4.08  1.94  18.9     1     1     4     1       0
 6  26       4 120. 
    91  4.43  2.14  16.7     0     1     5     2       0
 7  30.4     4  95.1   113  3.77  1.51  16.9     1     1     5     2       1
 8  15.8     8 351     264  4.22  3.17  14.5     0     1     5     4       0
 9  19.7     6 145     175  3.62  2.77  15.5     0     1     5     6       0
10  15       8 301     335  3.54  3.57  14.6     0     1     5     8       0
# … with more rows, and 5 more variables: features &lt;list>, label &lt;dbl>,
#   rawPrediction &lt;list>, probability &lt;list>, prediction &lt;dbl></code>
Though this example was put together with a few lines of code, what we just accomplished is actually quite impressive. 
You copied data into Spark, performed feature engineering, trained a model, and scored the model over a real-time dataset, with just seven lines of code! Let’s try now to use custom transformations, in real time.

<h3>12.2.4 Distributed R {streaming-r-code}</h3>
Arbitrary R code can also be used to transform a stream with the use of <code>spark_apply()</code>. 
This approach follows the same principles discussed in Chapter 11, where <code>spark_apply()</code> runs R code over each executor in the cluster where data is available. 
This enables processing high-throughput streams and fulfills low-latency requirements:
<code>stream_read_csv(sc, "cars-stream") %>%
  select(mpg) %>%
  spark_apply(~ round(.x), mpg = "integer") %>%
  stream_write_csv("cars-round")</code>
which, as you would expect, processes data from <code>cars-stream</code> into <code>cars-round</code> by running the custom <code>round()</code> R function. 
Let’s peek into the output sink:
<code>spark_read_csv(sc, "cars-round")</code>
<code># Source: spark&lt;carsround> [?? x 1]
     mpg
   &lt;dbl>
 1    16
 2    15
 3    13
 4    19
 5    27
 6    26
 7    30
 8    16
 9    20
10    15
# … with more rows</code>
Again, make sure you apply the concepts you already know about <code>spark_apply()</code> when using streams; for instance, you should consider using <code>arrow</code> to significantly improve performance. 
Before we move on, disconnect from Spark:
This was our last transformation for streams. 
We’ll now learn how to use Spark Streaming with Kafka.
<code>spark_disconnect(sc)</code>

<h2>12.3 Kafka</h2>
Apache Kafka is an open source stream-processing software platform developed by LinkedIn and donated to the Apache Software Foundation. 
It is written in Scala and Java. 
To describe it using an analogy, Kafka is to real-time storage what Hadoop is to static storage.
Kafka stores the stream as records, which consist of a key, a value, and a timestamp. 
It can handle multiple streams that contain different information, by categorizing them by topic. 
Kafka is commonly used to connect multiple real-time applications. 
A <em>producer</em> is an application that streams data into Kafka, while a <em>consumer</em> is the one that reads from Kafka; in Kafka terminology, a consumer application <em>subscribes</em> to topics. 
Therefore, the most basic workflow we can accomplish with Kafka is one with a single producer and a single consumer; this is illustrated in Figure 12.3.

<img src="https://therinspark.com/the-r-in-spark_files/figure-html/streaming-kafka-apis-1.png" height="100pt" />

FIGURE 12.3: A basic Kafka workflow

If you are new to Kafka, we don’t recommend you run the code from this section. 
However, if you’re really motivated to follow along, you will first need to install Kafka as explained in Appendix or deploy it in your cluster.
Using Kafka also requires you to have the Kafka package when connecting to Spark. 
Make sure this is specified in your connection <code>config</code>:
<code>library(sparklyr)
library(dplyr)

sc &lt;- spark_connect(master = "local", config = list(
  sparklyr.shell.packages = "org.apache.spark:spark-sql-kafka-0-10_2.11:2.4.0"
))</code>
Once connected, it’s straightforward to read data from a stream:
<code>stream_read_kafka(
  sc, 
  options = list(
    kafka.bootstrap.server = "host1:9092, host2:9092", 
    subscribe = "&lt;topic-name>"
    )
  ) </code>
However, notice that you need to properly configure the <code>options</code> list; <code>kafka.bootstrap.server</code> expects a list of Kafka hosts, while <code>topic</code> and <code>subscribe</code> define which topic should be used when writing or reading from Kafka, respectively.
Though we’ve started by presenting a simple single-producer and single-consumer use case, Kafka also allows much more complex interactions. 
We will next read from one topic, process its data, and then write the results to a different topic. 
Systems that are producers and consumers from the same topic are referred to as <em>stream processors</em>. 
In Figure 12.4, the stream processor reads topic A and then writes results to topic B. 
This allows for a given consumer application to read results instead of “raw” feed data.

<img src="https://therinspark.com/the-r-in-spark_files/figure-html/streaming-kafka-two-outputs-1.png" height="260pt" />

FIGURE 12.4: A Kafka workflow using stream processors

Three modes are available when processing Kafka streams in Spark: <em>complete</em>, <em>update</em>, and <em>append</em>. 
The <code>complete</code> mode provides the totals for every group every time there is a new batch; <code>update</code> provides totals for only the groups that have updates in the latest batch; and <code>append</code> adds raw records to the target topic. 
The <code>append</code> mode is not meant for aggregates, but works well for passing a filtered subset to the target topic.
In our next example, the producer streams random letters into Kafka under a <code>letters</code> topic. 
Then, Spark will act as the stream processor, reading the <code>letters</code> topic and computing unique letters, which are then written back to Kafka under the <code>totals</code> topic. 
We’ll use the <code>update</code> mode when writing back into Kafka; that is, only the totals that changed will be sent to Kafka. 
This change is determined after each batch from the <code>letters</code> topic:
<code>hosts  &lt;- "localhost:9092"

read_options &lt;- list(kafka.bootstrap.servers = hosts, subscribe = "letters")
write_options &lt;- list(kafka.bootstrap.servers = hosts, topic = "totals")

stream_read_kafka(sc, options = read_options) %>%
  mutate(value = as.character(value)) %>%         # coerce into a character
  count(value) %>%                                # group and count letters
  mutate(value = paste0(value, "=", n)) %>%       # kafka expects a value field
  stream_write_kafka(mode = "update",
                     options = write_options)</code>
You can take a quick look at totals by reading from Kafka:
<code>stream_read_kafka(sc, options = totals_options)</code>
Using a new terminal session, use Kafka’s command-line tool to manually add single letters into the <code>letters</code> topic:
<code>kafka-console-producer.sh --broker-list localhost:9092 --topic letters
>A
>B
>C</code>
The letters that you input are pushed to Kafka, read by Spark, aggregated within Spark, and pushed back into Kafka, Then, finally, they are consumed by Spark again to give you a glimpse into the <code>totals</code> topic. 
This was quite a setup, but also a realistic configuration commonly found in real-time processing projects.
Next, we will use the Shiny framework to visualize streams, in real time!

<h2>12.4 Shiny</h2>
Shiny’s reactive framework is well suited to support streaming information, which you can use to display real-time data from Spark using <code>reactiveSpark()</code>. 
There is far more to learn about Shiny than we could possibly present here. 
However, if you’re already familiar with Shiny, this example should be quite easy to understand.
We have a modified version of the <em>k</em>-means Shiny example that, instead of getting the data from the static <code>iris</code> dataset, is generated with <code>stream_generate_test()</code>, consumed by Spark, retrieved to Shiny through <code>reactiveSpark()</code>, and then displayed as shown in Figure 12.5.
To run this example, store the following Shiny app under <code>shiny/shiny-stream.R</code>:
<code>library(sparklyr)
library(shiny)

unlink("shiny-stream", recursive = TRUE)
dir.create("shiny-stream", showWarnings = FALSE)

sc &lt;- spark_connect(
  master = "local", version = "2.3",
  config = list(sparklyr.sanitize.column.names = FALSE))
  
ui &lt;- pageWithSidebar(
  headerPanel(&#39;Iris k-means clustering from Spark stream&#39;),
  sidebarPanel(
    selectInput(&#39;xcol&#39;, &#39;X Variable&#39;, names(iris)),
    selectInput(&#39;ycol&#39;, &#39;Y Variable&#39;, names(iris),
                selected=names(iris)[[2]]),
    numericInput(&#39;clusters&#39;, &#39;Cluster count&#39;, 3,
                 min = 1, max = 9)
  ),
  mainPanel(plotOutput(&#39;plot1&#39;))
)

server &lt;- function(input, output, session) {
  iris &lt;- stream_read_csv(sc, "shiny-stream",
                          columns = sapply(datasets::iris, class)) %>%
    reactiveSpark()
  
  selectedData &lt;- reactive(iris()[, c(input$xcol, input$ycol)])
  clusters &lt;- reactive(kmeans(selectedData(), input$clusters))
  
  output$plot1 &lt;- renderPlot({
    par(mar = c(5.1, 4.1, 0, 1))
    plot(selectedData(), col = clusters()$cluster, pch = 20, cex = 3)
    points(clusters()$centers, pch = 4, cex = 4, lwd = 4)
  })
}

shinyApp(ui, server)</code>
This Shiny application can then be launched with <code>runApp()</code>, like so:
<code>shiny::runApp("shiny/shiny-stream.R")</code>
While the Shiny app is running, launch a new R session from the same directory and create a test stream with <code>stream_generate_test()</code>. 
This will generate a stream of continuous data that Spark can process and Shiny can visualize (as illustrated in Figure 12.5):
<code>sparklyr::stream_generate_test(datasets::iris, "shiny/shiny-stream",
                               rep(5, 10^3))</code>

<img src="https://therinspark.com/images/streaming-shiny-app-resized.png" />

FIGURE 12.5: Progression of Spark reactive loading data into the Shiny app

In this section you learned how easy it is to create a Shiny app that can be used for several different purposes, such as monitoring and dashboarding.
In a more complex implementation, the source would more likely be a Kafka stream.
Before we transition, disconnect from Spark and clear the folders that we used:
<code>spark_disconnect(sc)

unlink(c("source", "destination", "cars-stream",
         "car-round", "shiny/shiny-stream"), recursive = TRUE)</code>

<h2>12.5 Recap</h2>
From static datasets to real-time datasets, you’ve truly mastered many of the large-scale computing techniques. 
Specifically, in this chapter, you learned how static data can be generalized to real time if we think of it as an infinite table. 
We were then able to create a simple stream, without any data transformations, that copies data from point A to point B.
This humble start became quite useful when you learned about the several different transformations you can apply to streaming data—from data analysis transformations using the <code>dplyr</code> and <code>DBI</code> packages, to feature transformers introduced while modeling, to fully fledged pipelines capable of scoring in real time, to, last but not least, transforming datasets with custom R code. 
This was a lot to digest, for sure.
We then presented Apache Kafka as a reliable and scalable solution for real-time data. 
We showed you how a real-time system could be structured by introducing you to consumers, producers, and topics. 
These, when properly combined, create powerful abstractions to process real-time data.
Then we closed with “a cherry on top of the sundae”: presenting how to use Spark Streaming in Shiny. 
Since a stream can be transformed into a reactive (which is the lingua franca of the world of reactivity), the ease of this approach was a nice surprise.
It’s time now to move on to our very last (and quite short) chapter, Chapter 13; there we’ll try to persuade you to use your newly acquired knowledge for the benefit of the Spark and R communities at large.

<h2><span class="orange">Chapter 13 Contributing</span></h2>
In Chapter 12, we equipped you with the tools to tackle large-scale and real-time data processing in Spark using R. 
In this final chapter we focus less on learning and more on giving back to the Spark and R communities or colleagues in your professional career. 
It really takes an entire community to keep this going, so we are counting on you!
There are many ways to contribute, from helping community members and opening GitHub issues to providing new functionality for yourself, colleagues, or the R and Spark community. 
However, we’ll focus here on writing and sharing code that extends Spark, to help others use new functionality you can provide as an author of Spark extensions using R. 
Specifically, you’ll learn what an extension is, the different types of extensions you can build, what building tools are available, and when and how to build an extension from scratch.
You will also learn how to make use of the hundreds of extensions available in Spark and the millions of components available in Java that can easily be used in R. 
We’ll also cover how to create code natively in Scala that makes use of Spark. 
As you might know, R is a great language for interfacing with other languages, such as C++, SQL, Python, and many others. 
It’s no surprise, then, that working with Scala from R will follow similar practices that make R ideal for providing easy-to-use interfaces that make data processing productive and that are loved by many of us.

<h2>13.1 Overview</h2>
When you think about giving back to your larger coding community, the most important question you can ask about any piece of code you write is: would this code be useful to someone else?
Let’s start by considering one of the first and simplest lines of code presented in this book. 
This code was used to load a simple CSV file:
<code>spark_read_csv(sc, "cars.csv")</code>
Code this basic is probably not useful to someone else. 
However, you could tailor that same example to something that generates more interest, perhaps the following:
<code>spark_read_csv(sc, "/path/that/is/hard/to/remember/data.csv")</code>
This code is quite similar to the first. 
But if you work with others who are working with this dataset, the answer to the question about usefulness would be yes—this would very likely be useful to someone else!
This is surprising since it means that not all useful code needs to be advanced or complicated. 
However, for it to be useful to others, it does need to be packaged, presented, and shared in a format that is easy to consume.
A first attempt would be to save this into a <em>teamdata.R</em> file and write a function wrapping it:
<code>load_team_data &lt;- function() {
  spark_read_text(sc, "/path/that/is/hard/to/remember/data.csv")
}</code>
This is an improvement, but it would require users to manually share this file again and again. 
Fortunately, this problem is easily solved in R, through <em>R packages</em>.
An R package contains R code in a format that is installable using the function <code>install.packages()</code>. 
One example is <code>sparklyr</code>. 
There are many other R packages available; you can also create your own. 
For those of you new to creating them, we encourage you to read Hadley Wickham’s book, <em>R Packages</em> (O’Reilly). 
Creating an R package allows you to easily share your functions with others by sharing the package file in your organization.
Once you create a package, there are many ways of sharing it with colleagues or the world. 
For instance, for packages meant to be private, consider using Drat or products like RStudio Package Manager. 
R packages meant for public consumption are made available to the R community in CRAN (the Comprehensive R Archive Network).
These repositories of R packages allow users to install packages through <code>install.packages("teamdata")</code> without having to worry where to download the package from. 
It also allows other packages to reuse your package.
In addition to using R packages like <code>sparklyr</code>, <code>dplyr</code>, <code>broom</code>, and others to create new R packages that extend Spark, you can also use all the functionality available in the Spark API or Spark Extensions or write custom Scala code.
For instance, suppose that there is a new file format similar to a CSV but not quite the same. 
We might want to write a function named <code>spark_read_file()</code> that would take a path to this new file type and read it in Spark. 
One approach would be to use <code>dplyr</code> to process each line of text or any other R library using <code>spark_apply()</code>. 
Another would be to use the Spark API to access methods provided by Spark. 
A third approach would be to check whether someone in the Spark community has already provided a Spark extension that supports this new file format. 
Last but not least, you could write your own custom Scala code that makes use of any Java library, including Spark and its extensions. 
This is shown in Figure 13.1.

<img src="https://therinspark.com/the-r-in-spark_files/figure-html/contributing-types-of-extensions-1.png" height="340pt" />

FIGURE 13.1: Extending Spark using the Spark API or Spark extensions, or writing Scala code

We will focus first on extending Spark using the Spark API, since the techniques required to call the Spark API are also applicable while calling Spark extensions or custom Scala code.

<h2>13.2 Spark API</h2>
Before we introduce the Spark API, let’s consider a simple and well-known problem. 
Suppose we want to count the number of lines in a distributed and potentially large text file—say, <em>cars.csv</em>, which we initialize as follows:
<code>library(sparklyr)
library(dplyr)
sc &lt;- spark_connect(master = "local", version = "2.3")

cars &lt;- copy_to(sc, mtcars)
spark_write_csv(cars, "cars.csv", mode = "overwrite")</code>
Now, to count how many lines are available in this file, we can run the following:
<code>spark_read_text(sc, "cars.csv") %>% count()</code>
<code># Source: spark&lt;?> [?? x 1]
      n
  &lt;dbl>
1    33</code>
Easy enough: we used <code>spark_read_text()</code> to read the entire text file, followed by counting lines using <code>dplyr’s</code> <code>count()</code>. 
Now, suppose that neither <code>spark_read_text()</code>, nor <code>dplyr</code>, nor any other Spark functionality, is available to you. 
How would you ask Spark to count the number of rows in <em>cars.csv</em>?
If you do this in Scala, you find in the Spark documentation that by using the Spark API you can count lines in a file as follows:
<code>val textFile = spark.read.textFile("cars.csv")
textFile.count()</code>
So, to use the functionality available in the Spark API from R, like <code>spark.read.textFile</code>, you can use <code>invoke()</code>, <code>invoke_static()</code>, or <code>invoke_new()</code>. 
(As their names suggest, the first invokes a method from an object, the second invokes a method from a static object, and the third creates a new object.) We then use these functions to call Spark’s API and execute code similar to the one provided in Scala:
<code>spark_context(sc) %>% 
  invoke("textFile", "cars.csv", 1L) %>% 
  invoke("count")</code>
<code>[1] 33</code>
While the <code>invoke()</code> function was originally designed to call Spark code, it can also call any code available in Java. 
For instance, we can create a Java <code>BigInteger</code> with the following code:
<code>invoke_new(sc, "java.math.BigInteger", "1000000000")</code>
<code>&lt;jobj[225]>
  java.math.BigInteger
  1000000000</code>
As you can see, the object created is not an R object but rather a proper Java object. 
In R, this Java object is represented by the <code>spark_jobj</code>. 
These objects are meant to be used with the <code>invoke()</code> functions or <code>spark_dataframe()</code> and <code>spark_connection()</code>. 
<code>spark_dataframe()</code> transforms a <code>spark_jobj</code> into a Spark DataFrame when possible, whereas <code>spark_connect()</code> retrieves the original Spark connection object, which can be useful to avoid passing the <code>sc</code> object across functions.
While calling the Spark API can be useful in some cases, most of the functionality available in Spark is already supported in <code>sparklyr</code>. 
Therefore, a more interesting way to extend Spark is by using one of its many existing extensions.

<h2>13.3 Spark Extensions</h2>
Before we get started with this section, consider navigating to spark-packages.org, a site that tracks Spark extensions provided by the Spark community. 
Using the same techniques presented in the previous section, you can use these extensions from R.
For instance, there is Apache Solr, a system designed to perform full-text searches over large datasets, something that Apache Spark currently does not support natively. 
Also, as of this writing, there is no extension for R to support Solr. 
So, let’s try to solve this by using a Spark extension.
First, if you search “spark-packages.org” to find a Solr extension, you should be able to locate <code>spark-solr</code>. 
The “How to” extension mentions that the <code>com.lucidworks.spark:spark-solr:2.0.1</code> should be loaded. 
We can accomplish this in R using the <code>sparklyr.shell.packages</code> configuration option:
<code>config &lt;- spark_config()
config["sparklyr.shell.packages"] &lt;- "com.lucidworks.spark:spark-solr:3.6.3"
config["sparklyr.shell.repositories"] &lt;- 
  "http://repo.spring.io/plugins-release/,http://central.maven.org/maven2/"
  
sc &lt;- spark_connect(master = "local", config = config, version = "2.3")</code>
While specifying the <code>sparklyr.shell.packages</code> parameter is usually enough, for this particular extension, dependencies failed to download from the Spark packages repository. 
You would need to manually find the failed dependencies in the Maven repo and add further repositories under the <code>sparklyr.shell.repositories</code> parameter.
<strong>Note:</strong> When you use an extension, Spark connects to the Maven package repository to retrieve it. 
This can take significant time depending on the extension and your download speeds. 
In this case, consider using the <code>sparklyr.connect.timeout</code> configuration parameter to allow Spark to download the required files.
From the <code>spark-solr</code> documentation, you would find that this extension can be used with the following Scala code:
<code>val options = Map(
  "collection" -> "{solr_collection_name}",
  "zkhost" -> "{zk_connect_string}"
)

val df = spark.read.format("solr")
  .options(options)
  .load()</code>
We can translate this to R code:
<code>spark_session(sc) %>%
  invoke("read") %>%
  invoke("format", "solr") %>%
  invoke("option", "collection", "&lt;collection>") %>%
  invoke("option", "zkhost", "&lt;host>") %>%
  invoke("load")</code>
This code will fail, however, since it would require a valid Solr instance and configuring Solr goes beyond the scope of this book. 
But this example provides insights as to how you can create Spark extensions. 
It’s also worth mentioning that you can use <code>spark_read_source()</code> to read from generic sources to avoid writing custom <code>invoke()</code> code.
As pointed out in Overview, consider sharing code with others using R packages. 
While you could require users of your package to specify <code>sparklyr.shell.packages</code>, you can avoid this by registering dependencies in your R package. 
Dependencies are declared under a <code>spark_dependencies()</code> function; thus, for the example in this section:
<code>spark_dependencies &lt;- function(spark_version, scala_version, ...) {
  spark_dependency(
    packages = "com.lucidworks.spark:spark-solr:3.6.3",
    repositories = c(
      "http://repo.spring.io/plugins-release/",
      "http://central.maven.org/maven2/")
  )
}

.onLoad &lt;- function(libname, pkgname) {
  sparklyr::register_extension(pkgname)
}</code>
The <code>onLoad</code> function is automatically called by R when your library loads. 
It should call <code>register_extension()</code>, which will then call back <code>spark_dependencies()</code>, to allow your extension to provide additional dependencies. 
This example supports Spark 2.4, but you should also support mapping Spark and Scala versions to the correct Spark extension version.
There are about 450 Spark extensions you can use; in addition, you can also use any Java library from a Maven repository, where Maven Central has over 3 million artifacts. 
While not all Maven Central libraries might be relevant to Spark, the combination of Spark extensions and Maven repositories certainly opens many interesting possibilities for you to consider!
However, for those cases where no Spark extension is available, the next section will teach you how to use custom Scala code from your own R package.

<h2>13.4 Scala Code</h2>
Scala code enables you to use any method in the Spark API, Spark extensions, or Java library. 
In addition, writing Scala code when running in Spark can provide performance improvements over R code using <code>spark_apply()</code>. 
In general, the structure of your R package will contain R code and Scala code; however, the Scala code will need to be compiled as JARs (Java ARchive files) and included in your package. 
Figure 13.2 shows this structure.

<img src="https://therinspark.com/the-r-in-spark_files/figure-html/contributing-scala-code-1.png" height="200pt" />

FIGURE 13.2: R package structure when using Scala code

As usual, the R code should be placed under a top-level <em>R</em> folder, Scala code under a <em>java</em> folder, and the compiled JARs under an <em>inst/java</em> folder. 
Though you are certainly welcome to manually compile the Scala code, you can use helper functions to download the required compiler and compile Scala code.
To compile Scala code, you’ll need to install the Java Development Kit 8 (JDK8, for short). 
Download the JDK from Oracle’s Java download page; this will require you to restart your R session.
You’ll also need a Scala compiler for Scala 2.11 and 2.12. 
The Scala compilers can be automatically downloaded and installed using <code>download_scalac()</code>:
<code>download_scalac()</code>
Next, you’ll need to compile your Scala sources using <code>compile_package_jars()</code>. 
By default, it uses <code>spark_compilation_spec()</code>, which compiles your sources for the following Spark versions:
<code>[1] "1.5.2" "1.6.0" "2.0.0" "2.3.0" "2.4.0"</code>
You can also customize this specification by creating custom entries with <code>spark_compilation_spec()</code>.
While you could create the project structure for the Scala code from scratch, you can also simply call <em>spark_extension(path)</em> to create an extension in the given path. 
This extension will be mostly empty but will contain the appropriate project structure to call the Scala code.
Since <code>spark_extension()</code> is registered as a custom project extension in RStudio, you can also create an R package that extends Spark using Scala code from the File menu; click New Project and then select “R Package using Spark” as shown in Figure 13.3.

<img src="https://therinspark.com/images/contributing-r-rstudio-project-resized.png" />

FIGURE 13.3: Creating a Scala extension package from RStudio

Once you are ready to compile your package JARs, you can simply run the following:
<code>compile_package_jars()</code>
Since the JARs are compiled by default into the <em>inst/</em> package path, when you are building the R package all the JARs will also be included within the package. 
This means that you can share or publish your R package, and it will be fully functional by R users. 
For advanced Spark users with most of their expertise in Scala, it’s compelling to consider writing libraries for R users and the R community in Scala and then easily packaging these into R packages that are easy to consume, use, and share among them.
If you are interested in developing a Spark extension with R and you get stuck along the way, consider joining the <code>sparklyr</code> Gitter channel, where many of us hang out to help this wonderful community to grow. 
We hope to hear from you soon!

<h2>13.5 Recap</h2>
This final chapter introduced you to a new set of tools to use to expand Spark functionality beyond what R and R packages currently support. 
This vast new space of libraries includes more than 450 Spark extensions and millions of Java artifacts you can use in Spark from R. 
Beyond these resources, you also learned how to build Java artifacts using Scala code that can be easily embedded and compiled from R.
This brings us back to this book’s purpose, presented early on; while we know you’ve learned how to perform large-scale computing using Spark in R, we’re also confident that you have acquired the knowledge required to help other community members through Spark extensions. 
We can’t wait to see your new creations, which will surely help grow the Spark and R communities at large.
To close, we hope the first chapters gave you an easy introduction to Spark and R. 
Following that, we presented analysis and modeling as foundations for using Spark, with the familiarity of R packages you already know and love. 
You moved on to learning how to perform large-scale computing in proper Spark clusters. 
The last third of this book focused on advanced topics: using extensions, distributing R code, processing real-time data, and, finally, giving back by using Spark extensions using R and Scala code.
We’ve tried to present the best possible content. 
However, if you know of any way to improve this book, please open a GitHub issue under the the-r-in-spark repo, and we’ll address your suggestions in upcoming revisions. 
We hope you enjoyed reading this book, and that you’ve learned as much as we have learned while writing it. 
We hope it was worthy of your time—it has been an honor having you as our reader.

<h2><span class="orange">Chapter 14 Appendix</span></h2>

<h2>14.1 Preface</h2>

<h3>14.1.1 Formatting</h3>
The following <code>ggplot2</code> theme was use to format plots in this book:
<code>plot_style &lt;- function() {
  font &lt;- "Helvetica"

  ggplot2::theme_classic() +
  ggplot2::theme(
    plot.title = ggplot2::element_text(
      family = font, size=14, color = "#222222"),
    plot.subtitle = ggplot2::element_text(
      family=font, size=12, color = "#666666"),

    legend.position = "right",
    legend.background = ggplot2::element_blank(),
    legend.title = ggplot2::element_blank(),
    legend.key = ggplot2::element_blank(),
    legend.text = ggplot2::element_text(
      family=font, size=14, color="#222222"),

    axis.title.y = ggplot2::element_text(
      margin = ggplot2::margin(t = 0, r = 8, b = 0, l = 0),
      size = 14, color="#666666"),
    axis.title.x = ggplot2::element_text(
      margin = ggplot2::margin(t = -2, r = 0, b = 0, l = 0),
      size = 14, color = "#666666"),
    axis.text = ggplot2::element_text(
      family=font, size=14, color="#222222"),
    axis.text.x = ggplot2::element_text(
      margin = ggplot2::margin(5, b = 10)),
    axis.ticks = ggplot2::element_blank(),
    axis.line = ggplot2::element_blank(),

    panel.grid.minor = ggplot2::element_blank(),
    panel.grid.major.y = ggplot2::element_line(color = "#eeeeee"),
    panel.grid.major.x = ggplot2::element_line(color = "#ebebeb"),

    panel.background = ggplot2::element_blank(),

    strip.background = ggplot2::element_rect(fill = "white"),
    strip.text = ggplot2::element_text(size  = 20,  hjust = 0)
  )
}</code>
Which you can then active with:
<code>ggplot2::theme_set(plot_style())</code>

<h2>14.2 Introduction</h2>

<h3>14.2.1 Worlds Store Capacity</h3>
The following script was used to generate the worlds store capacity diagram:
<code>library(ggplot2)
library(dplyr)
library(tidyr)
read.csv("data/01-worlds-capacity-to-store-information.csv", skip = 8) %>%
  gather(key = storage, value = capacity, analog, digital) %>%
  mutate(year = X, terabytes = capacity / 1e+12) %>%
  ggplot(aes(x = year, y = terabytes, group = storage)) +
    geom_line(aes(linetype = storage)) +
    geom_point(aes(shape = storage)) +
    scale_y_log10(
      breaks = scales::trans_breaks("log10", function(x) 10^x),
      labels = scales::trans_format("log10", scales::math_format(10^x))
    ) +
    theme_light() +
    theme(legend.position = "bottom")</code>

<h3>14.2.2 Daily downloads of CRAN packages</h3>
The CRAN downloads chart was generated through:
<code>downloads_csv &lt;- "data/01-intro-r-cran-downloads.csv"
if (!file.exists(downloads_csv)) {
  downloads &lt;- cranlogs::cran_downloads(from = "2014-01-01", to = "2019-01-01")
  readr::write_csv(downloads, downloads_csv)
}

cran_downloads &lt;- readr::read_csv(downloads_csv)

ggplot(cran_downloads, aes(date, count)) + 
  labs(title = "CRAN Packages",
       subtitle = "Total daily downloads over time") +
  geom_point(colour="black", pch = 21, size = 1) +
  scale_x_date() + xlab("year") + ylab("downloads") +
  scale_x_date(date_breaks = "1 year",
               labels = function(x) substring(x, 1, 4)) +
  scale_y_continuous(
      limits = c(0, 3.5 * 10^6),
      breaks = c(0.5 * 10^6, 10^6, 1.5 * 10^6, 2 * 10^6, 2.5 * 10^6, 3 * 10^6, 3.5 * 10^6),
      labels = c(", "1M", ", "2M", ", "3M", ")
    )</code>

<h2>14.3 Getting Started</h2>

<h3>14.3.1 Prerequisites</h3>

<h4>14.3.1.1 Installing R</h4>
From r-project.org, download and launch the R installer for your platform, Windows, Macs or Linux available.

<img src="https://therinspark.com/images/appendix-download-r-resized.png" />

FIGURE 14.1: The R Project for Statistical Computing

<h4>14.3.1.2 Installing Java</h4>
From java.com/download, download and launch the installer for your platform, Windows, Macs or Linux are also available.

<img src="https://therinspark.com/images/appendix-download-java-resized.png" />

FIGURE 14.2: Java Download Page

Starting with Spark 2.1, Java 8 is required; however, previous versions of Spark support Java 7. 
Regardless, we recommend installing Java Runtime Engine 8, or JRE 8 for short.
<strong>Note:</strong> For advanced readers that are already using the Java Development Kit, JDK for short. 
Please notice that JDK 9+ is currently unsupported so you will need to downgrade to JDK 8 by uninstalling JDK 9+ or by setting <code>JAVA_HOME</code> appropiately.

<h4>14.3.1.3 Installing RStudio</h4>
While installing RStudio is not strictly required to work with Spark with R, it will make you much more productive and therefore, I would recommend you take the time to install RStudio from rstudio.com/download, then download and launch the installer for your platform: Windows, Macs or Linux.

<img src="https://therinspark.com/images/appendix-rstudio-resized.png" />

FIGURE 14.3: RStudio Downloads Page

After launching RStudio, you can use RStudio’s console panel to execute the code provided in this chapter.

<h4>14.3.1.4 Using RStudio</h4>
If you are not familiar with RStudio, you should make note of the following panes:
<ul>
<li><em>Console</em>: A standalone R console you can use to execute all the code presented in this book.</li>
<li><em>Packages</em>: This pane allows you to install <code>sparklyr</code> with ease, check its version, navigate to the help contents, etc.</li>
<li><em>Connections</em>: This pane allows you to connecto to Spark, manage your active connection and view the available datasets.</li>
</ul>

<img src="https://therinspark.com/images/appendix-rstudio-overview-resized.png" />

FIGURE 14.4: RStudio Overview

<h2>14.4 Analysis</h2>

<h3>14.4.1 Hive Functions</h3>
<table>
<colgroup>
<col />
<col />
</colgroup>
<thead>
<tr><th>Name</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>size(Map&lt;K.V>)</td><td>Returns the number of elements in the map type.</td></tr>
<tr><td>size(Array&lt;T>)</td><td>Returns the number of elements in the array type.</td></tr>
<tr><td>map_keys(Map&lt;K.V>)</td><td>Returns an unordered array containing the keys of the input map.</td></tr>
<tr><td>map_values(Map&lt;K.V>)</td><td>Returns an unordered array containing the values of the input map.</td></tr>
<tr><td>array_contains(Array&lt;T>, value)</td><td>Returns TRUE if the array contains value.</td></tr>
<tr><td>sort_array(Array&lt;T>)</td><td>Sorts the input array in ascending order according to the natural ordering of the array elements and returns it</td></tr>
<tr><td>binary(string or binary)</td><td>Casts the parameter into a binary.</td></tr>
<tr><td>cast(expr as ‘type’)</td><td>Converts the results of the expression expr to the given type.</td></tr>
<tr><td>from_unixtime(bigint unixtime[, string format])</td><td>Converts the number of seconds from unix epoch (1970-01-01 00:00:00 UTC) to a string.</td></tr>
<tr><td>unix_timestamp()</td><td>Gets current Unix timestamp in seconds.</td></tr>
<tr><td>unix_timestamp(string date)</td><td>Converts time string in format yyyy-MM-dd HH:mm:ss to Unix timestamp (in seconds).</td></tr>
<tr><td>to_date(string timestamp)</td><td>Returns the date part of a timestamp string.</td></tr>
<tr><td>year(string date)</td><td>Returns the year part of a date.</td></tr>
<tr><td>quarter(date/timestamp/string)</td><td>Returns the quarter of the year for a date.</td></tr>
<tr><td>month(string date)</td><td>Returns the month part of a date or a timestamp string.</td></tr>
<tr><td>day(string date) dayofmonth(date)</td><td>Returns the day part of a date or a timestamp string.</td></tr>
<tr><td>hour(string date)</td><td>Returns the hour of the timestamp.</td></tr>
<tr><td>minute(string date)</td><td>Returns the minute of the timestamp.</td></tr>
<tr><td>second(string date)</td><td>Returns the second of the timestamp.</td></tr>
<tr><td>weekofyear(string date)</td><td>Returns the week number of a timestamp string.</td></tr>
<tr><td>extract(field FROM source)</td><td>Retrieve fields such as days or hours from source. 
Source must be a date, timestamp, interval or a string that can be converted into either a date or timestamp.</td></tr>
<tr><td>datediff(string enddate, string startdate)</td><td>Returns the number of days from startdate to enddate.</td></tr>
<tr><td>date_add(date/timestamp/string startdate, tinyint/smallint/int days)</td><td>Adds a number of days to startdate.</td></tr>
<tr><td>date_sub(date/timestamp/string startdate, tinyint/smallint/int days)</td><td>Subtracts a number of days to startdate.</td></tr>
<tr><td>from_utc_timestamp({any primitive type} ts, string timezone)</td><td>Converts a timestamp in UTC to a given timezone.</td></tr>
<tr><td>to_utc_timestamp({any primitive type} ts, string timezone)</td><td>Converts a timestamp in a given timezone to UTC.</td></tr>
<tr><td>current_date</td><td>Returns the current date.</td></tr>
<tr><td>current_timestamp</td><td>Returns the current timestamp.</td></tr>
<tr><td>add_months(string start_date, int num_months, output_date_format)</td><td>Returns the date that is num_months after start_date.</td></tr>
<tr><td>last_day(string date)</td><td>Returns the last day of the month which the date belongs to.</td></tr>
<tr><td>next_day(string start_date, string day_of_week)</td><td>Returns the first date which is later than start_date and named as day_of_week.</td></tr>
<tr><td>trunc(string date, string format)</td><td>Returns date truncated to the unit specified by the format.</td></tr>
<tr><td>months_between(date1, date2)</td><td>Returns number of months between dates date1 and date2.</td></tr>
<tr><td>date_format(date/timestamp/string ts, string fmt)</td><td>Converts a date/timestamp/string to a value of string in the format specified by the date format fmt.</td></tr>
<tr><td>if(boolean testCondition, T valueTrue, T valueFalseOrNull)</td><td>Returns valueTrue when testCondition is true, returns valueFalseOrNull otherwise.</td></tr>
<tr><td>isnull( a )</td><td>Returns true if a is NULL and false otherwise.</td></tr>
<tr><td>isnotnull ( a )</td><td>Returns true if a is not NULL and false otherwise.</td></tr>
<tr><td>nvl(T value, T default_value)</td><td>Returns default value if value is null else returns value.</td></tr>
<tr><td>COALESCE(T v1, T v2, …)</td><td>Returns the first v that is not NULL, or NULL if all v’s are NULL.</td></tr>
<tr><td>CASE a WHEN b THEN c [WHEN d THEN e]* [ELSE f] END</td><td>When a = b, returns c; when a = d, returns e; else returns f.</td></tr>
<tr><td>nullif( a, b )</td><td>Returns NULL if a=b; otherwise returns a.</td></tr>
<tr><td>assert_true(boolean condition)</td><td>Throw an exception if ‘condition’ is not true, otherwise return null.</td></tr>
<tr><td>ascii(string str)</td><td>Returns the numeric value of the first character of str.</td></tr>
<tr><td>base64(binary bin)</td><td>Converts the argument from binary to a base 64 string.</td></tr>
<tr><td>character_length(string str)</td><td>Returns the number of UTF-8 characters contained in str.</td></tr>
<tr><td>chr(bigint</td><td>double A)</td></tr>
<tr><td>concat(string</td><td>binary A, string</td></tr>
<tr><td>context_ngrams(array&lt;array&lt;string>>, array&lt;string>, int K, int pf)</td><td>Returns the top-k contextual N-grams from a set of tokenized sentences.</td></tr>
<tr><td>concat_ws(string SEP, string A, string B…)</td><td>Like concat() above, but with custom separator SEP.</td></tr>
<tr><td>decode(binary bin, string charset)</td><td>Decodes the first argument into a String using the provided character set (one of ‘US-ASCII’, ‘ISO-8859-1’, ‘UTF-8’, ‘UTF-16BE’, ‘UTF-16LE’, ‘UTF-16’). 
If either argument is null, the result will also be null.</td></tr>
<tr><td>elt(N int,str1 string,str2 string,str3 string,…)</td><td>Return string at index number, elt(2,‘hello’,‘world’) returns ‘world’.</td></tr>
<tr><td>encode(string src, string charset)</td><td>Encodes the first argument into a BINARY using the provided character set (one of ‘US-ASCII’, ‘ISO-8859-1’, ‘UTF-8’, ‘UTF-16BE’, ‘UTF-16LE’, ‘UTF-16’).</td></tr>
<tr><td>field(val T,val1 T,val2 T,val3 T,…)</td><td>Returns the index of val in the val1,val2,val3,… list or 0 if not found.</td></tr>
<tr><td>find_in_set(string str, string strList)</td><td>Returns the first occurance of str in strList where strList is a comma-delimited string.</td></tr>
<tr><td>format_number(number x, int d)</td><td>Formats the number X to a format like <code>'#,###,###.##'</code>, rounded to D decimal places, and returns the result as a string. 
If D is 0, the result has no decimal point or fractional part.</td></tr>
<tr><td>get_json_object(string json_string, string path)</td><td>Extracts json object from a json string based on json path specified, and returns json string of the extracted json object.</td></tr>
<tr><td>in_file(string str, string filename)</td><td>Returns true if the string str appears as an entire line in filename.</td></tr>
<tr><td>instr(string str, string substr)</td><td>Returns the position of the first occurrence of substr in str.</td></tr>
<tr><td>length(string A)</td><td>Returns the length of the string.</td></tr>
<tr><td>locate(string substr, string str[, int pos])</td><td>Returns the position of the first occurrence of substr in str after position pos.</td></tr>
<tr><td>lower(string A) lcase(string A)</td><td>Returns the string resulting from converting all characters of B to lower case.</td></tr>
<tr><td>lpad(string str, int len, string pad)</td><td>Returns str, left-padded with pad to a length of len. 
If str is longer than len, the return value is shortened to len characters.</td></tr>
<tr><td>ltrim(string A)</td><td>Returns the string resulting from trimming spaces from the beginning(left hand side) of A.</td></tr>
<tr><td>ngrams(array&lt;array&lt;string>>, int N, int K, int pf)</td><td>Returns the top-k N-grams from a set of tokenized sentences, such as those returned by the sentences() UDAF.</td></tr>
<tr><td>octet_length(string str)</td><td>Returns the number of octets required to hold the string str in UTF-8 encoding.</td></tr>
<tr><td>parse_url(string urlString, string partToExtract [, string keyToExtract])</td><td>Returns the specified part from the URL. 
Valid values for partToExtract include HOST, PATH, QUERY, REF, PROTOCOL, AUTHORITY, FILE, and USERINFO.</td></tr>
<tr><td>printf(String format, Obj… args)</td><td>Returns the input formatted according do printf-style format strings.</td></tr>
<tr><td>regexp_extract(string subject, string pattern, int index)</td><td>Returns the string extracted using the pattern.</td></tr>
<tr><td>regexp_replace(string INITIAL_STRING, string PATTERN, string REPLACEMENT)</td><td>Returns the string resulting from replacing all substrings in INITIAL_STRING that match the java regular expression syntax defined in PATTERN with instances of REPLACEMENT.</td></tr>
<tr><td>repeat(string str, int n)</td><td>Repeats str n times.</td></tr>
<tr><td>replace(string A, string OLD, string NEW)</td><td>Returns the string A with all non-overlapping occurrences of OLD replaced with NEW.</td></tr>
<tr><td>reverse(string A)</td><td>Returns the reversed string.</td></tr>
<tr><td>rpad(string str, int len, string pad)</td><td>Returns str, right-padded with pad to a length of len.</td></tr>
<tr><td>rtrim(string A)</td><td>Returns the string resulting from trimming spaces from the end(right hand side) of A.</td></tr>
<tr><td>sentences(string str, string lang, string locale)</td><td>Tokenizes a string of natural language text into words and sentences, where each sentence is broken at the appropriate sentence boundary and returned as an array of words.</td></tr>
<tr><td>space(int n)</td><td>Returns a string of n spaces.</td></tr>
<tr><td>split(string str, string pat)</td><td>Splits str around pat (pat is a regular expression).</td></tr>
<tr><td>str_to_map(text[, delimiter1, delimiter2])</td><td>Splits text into key-value pairs using two delimiters. 
Delimiter1 separates text into K-V pairs, and Delimiter2 splits each K-V pair. 
Default delimiters are ‘,’ for delimiter1 and ‘:’ for delimiter2.</td></tr>
<tr><td>substr(string</td><td>binary A, int start)</td></tr>
<tr><td>substring_index(string A, string delim, int count)</td><td>Returns the substring from string A before count occurrences of the delimiter delim.</td></tr>
<tr><td>translate(string</td><td>char</td></tr>
<tr><td>trim(string A)</td><td>Returns the string resulting from trimming spaces from both ends of A.</td></tr>
<tr><td>unbase64(string str)</td><td>Converts the argument from a base 64 string to BINARY.</td></tr>
<tr><td>upper(string A) ucase(string A)</td><td>Returns the string resulting from converting all characters of A to upper case. 
For example, upper(‘fOoBaR’) results in ‘FOOBAR’.</td></tr>
<tr><td>initcap(string A)</td><td>Returns string, with the first letter of each word in uppercase, all other letters in lowercase. 
Words are delimited by whitespace.</td></tr>
<tr><td>levenshtein(string A, string B)</td><td>Returns the Levenshtein distance between two strings.</td></tr>
<tr><td>soundex(string A)</td><td>Returns soundex code of the string.</td></tr>
<tr><td>mask(string str[, string upper[, string lower[, string number]]])</td><td>Returns a masked version of str.</td></tr>
<tr><td>mask_first_n(string str[, int n])</td><td>Returns a masked version of str with the first n values masked. 
mask_first_n(“1234-5678-8765-4321”, 4) results in nnnn-5678-8765-4321.</td></tr>
<tr><td>mask_last_n(string str[, int n])</td><td>Returns a masked version of str with the last n values masked.</td></tr>
<tr><td>mask_show_first_n(string str[, int n])</td><td>Returns a masked version of str, showing the first n characters unmasked.</td></tr>
<tr><td>mask_show_last_n(string str[, int n])</td><td>Returns a masked version of str, showing the last n characters unmasked.</td></tr>
<tr><td>mask_hash(string</td><td>char</td></tr>
<tr><td>java_method(class, method[, arg1[, arg2..]])</td><td>Synonym for reflect.</td></tr>
<tr><td>reflect(class, method[, arg1[, arg2..]])</td><td>Calls a Java method by matching the argument signature, using reflection.</td></tr>
<tr><td>hash(a1[, a2…])</td><td>Returns a hash value of the arguments.</td></tr>
<tr><td>current_user()</td><td>Returns current user name from the configured authenticator manager.</td></tr>
<tr><td>logged_in_user()</td><td>Returns current user name from the session state.</td></tr>
<tr><td>current_database()</td><td>Returns current database name.</td></tr>
<tr><td>md5(string/binary)</td><td>Calculates an MD5 128-bit checksum for the string or binary.</td></tr>
<tr><td>sha1(string/binary)sha(string/binary)</td><td>Calculates the SHA-1 digest for string or binary and returns the value as a hex string.</td></tr>
<tr><td>crc32(string/binary)</td><td>Computes a cyclic redundancy check value for string or binary argument and returns bigint value.</td></tr>
<tr><td>sha2(string/binary, int)</td><td>Calculates the SHA-2 family of hash functions (SHA-224, SHA-256, SHA-384, and SHA-512).</td></tr>
<tr><td>aes_encrypt(input string/binary, key string/binary)</td><td>Encrypt input using AES.</td></tr>
<tr><td>aes_decrypt(input binary, key string/binary)</td><td>Decrypt input using AES.</td></tr>
<tr><td>version()</td><td>Returns the Hive version.</td></tr>
<tr><td>count(expr)</td><td>Returns the total number of retrieved rows.</td></tr>
<tr><td>sum(col), sum(DISTINCT col)</td><td>Returns the sum of the elements in the group or the sum of the distinct values of the column in the group.</td></tr>
<tr><td>avg(col), avg(DISTINCT col)</td><td>Returns the average of the elements in the group or the average of the distinct values of the column in the group.</td></tr>
<tr><td>min(col)</td><td>Returns the minimum of the column in the group.</td></tr>
<tr><td>max(col)</td><td>Returns the maximum value of the column in the group.</td></tr>
<tr><td>variance(col), var_pop(col)</td><td>Returns the variance of a numeric column in the group.</td></tr>
<tr><td>var_samp(col)</td><td>Returns the unbiased sample variance of a numeric column in the group.</td></tr>
<tr><td>stddev_pop(col)</td><td>Returns the standard deviation of a numeric column in the group.</td></tr>
<tr><td>stddev_samp(col)</td><td>Returns the unbiased sample standard deviation of a numeric column in the group.</td></tr>
<tr><td>covar_pop(col1, col2)</td><td>Returns the population covariance of a pair of numeric columns in the group.</td></tr>
<tr><td>covar_samp(col1, col2)</td><td>Returns the sample covariance of a pair of a numeric columns in the group.</td></tr>
<tr><td>corr(col1, col2)</td><td>Returns the Pearson coefficient of correlation of a pair of a numeric columns in the group.</td></tr>
<tr><td>percentile(BIGINT col, p)</td><td>Returns the exact pth percentile of a column in the group (does not work with floating point types). 
p must be between 0 and 1.</td></tr>
<tr><td>percentile(BIGINT col, array(p1 [, p2]…))</td><td>Returns the exact percentiles p1, p2, … of a column in the group. 
pi must be between 0 and 1.</td></tr>
<tr><td>percentile_approx(DOUBLE col, p [, B])</td><td>Returns an approximate pth percentile of a numeric column (including floating point types) in the group. 
The B parameter controls approximation accuracy at the cost of memory. 
Higher values yield better approximations, and the default is 10,000. 
When the number of distinct values in col is smaller than B, this gives an exact percentile value.</td></tr>
<tr><td>percentile_approx(DOUBLE col, array(p1 [, p2]…) [, B])</td><td>Same as above, but accepts and returns an array of percentile values instead of a single one.</td></tr>
<tr><td>regr_avgx(independent, dependent)</td><td>Equivalent to avg(dependent).</td></tr>
<tr><td>regr_avgy(independent, dependent)</td><td>Equivalent to avg(independent).</td></tr>
<tr><td>regr_count(independent, dependent)</td><td>Returns the number of non-null pairs used to fit the linear regression line.</td></tr>
<tr><td>regr_intercept(independent, dependent)</td><td>Returns the y-intercept of the linear regression line, i.e. the value of b in the equation dependent = a * independent + b.</td></tr>
<tr><td>regr_r2(independent, dependent)</td><td>Returns the coefficient of determination for the regression.</td></tr>
<tr><td>regr_slope(independent, dependent)</td><td>Returns the slope of the linear regression line, i.e. the value of a in the equation dependent = a * independent + b.</td></tr>
<tr><td>regr_sxx(independent, dependent)</td><td>Equivalent to regr_count(independent, dependent) * var_pop(dependent).</td></tr>
<tr><td>regr_sxy(independent, dependent)</td><td>Equivalent to regr_count(independent, dependent) * covar_pop(independent, dependent).</td></tr>
<tr><td>regr_syy(independent, dependent)</td><td>Equivalent to regr_count(independent, dependent) * var_pop(independent).</td></tr>
<tr><td>histogram_numeric(col, b)</td><td>Computes a histogram of a numeric column in the group using b non-uniformly spaced bins. 
The output is an array of size b of double-valued (x,y) coordinates that represent the bin centers and heights</td></tr>
<tr><td>collect_set(col)</td><td>Returns a set of objects with duplicate elements eliminated.</td></tr>
<tr><td>collect_list(col)</td><td>Returns a list of objects with duplicates.</td></tr>
<tr><td>ntile(INTEGER x)</td><td>Divides an ordered partition into x groups called buckets and assigns a bucket number to each row in the partition. 
This allows easy calculation of tertiles, quartiles, deciles, percentiles and other common summary statistics.</td></tr>
<tr><td>explode(ARRAY&lt;T> a)</td><td>Explodes an array to multiple rows. 
Returns a row-set with a single column (col), one row for each element from the array.</td></tr>
<tr><td>explode(MAP&lt;Tkey,Tvalue> m)</td><td>Explodes a map to multiple rows. 
Returns a row-set with a two columns (key,value) , one row for each key-value pair from the input map.</td></tr>
<tr><td>posexplode(ARRAY&lt;T> a)</td><td>Explodes an array to multiple rows with additional positional column of int type (position of items in the original array, starting with 0). 
Returns a row-set with two columns (pos,val), one row for each element from the array.</td></tr>
<tr><td>inline(ARRAY&lt;STRUCT&lt;f1:T1,…,fn:Tn>> a)</td><td>Explodes an array of structs to multiple rows. 
Returns a row-set with N columns (N = number of top level elements in the struct), one row per struct from the array.</td></tr>
<tr><td>stack(int r,T1 V1,…,Tn/r Vn)</td><td>Breaks up n values V1,…,Vn into r rows. 
Each row will have n/r columns. 
r must be constant.</td></tr>
<tr><td>json_tuple(string jsonStr,string k1,…,string kn)</td><td>Takes JSON string and a set of n keys, and returns a tuple of n values.</td></tr>
<tr><td>parse_url_tuple(string urlStr,string p1,…,string pn)</td><td>Takes URL string and a set of n URL parts, and returns a tuple of n values.</td></tr>
</tbody>
</table>

<h2>14.5 Modeling</h2>

<h3>14.5.1 MLlib Functions</h3>
The following table exhibits the ML algorithms supported in sparklyr:

<h4>14.5.1.1 Classification</h4>
<table>
<thead>
<tr><th>Algorithm</th><th>Function</th></tr>
</thead>
<tbody>
<tr><td>Decision Trees</td><td>ml_decision_tree_classifier()</td></tr>
<tr><td>Gradient-Boosted Trees</td><td>ml_gbt_classifier()</td></tr>
<tr><td>Linear Support Vector Machines</td><td>ml_linear_svc()</td></tr>
<tr><td>Logistic Regression</td><td>ml_logistic_regression()</td></tr>
<tr><td>Multilayer Perceptron</td><td>ml_multilayer_perceptron_classifier()</td></tr>
<tr><td>Naive-Bayes</td><td>ml_naive_bayes()</td></tr>
<tr><td>One vs Rest</td><td>ml_one_vs_rest()</td></tr>
<tr><td>Random Forests</td><td>ml_random_forest_classifier()</td></tr>
</tbody>
</table>

<h4>14.5.1.2 Regression</h4>
<table>
<thead>
<tr><th>Algorithm</th><th>Function</th></tr>
</thead>
<tbody>
<tr><td>Accelerated Failure Time Survival Regression</td><td>ml_aft_survival_regression()</td></tr>
<tr><td>Decision Trees</td><td>ml_decision_tree_regressor()</td></tr>
<tr><td>Generalized Linear Regression</td><td>ml_generalized_linear_regression()</td></tr>
<tr><td>Gradient-Boosted Trees</td><td>ml_gbt_regressor()</td></tr>
<tr><td>Isotonic Regression</td><td>ml_isotonic_regression()</td></tr>
<tr><td>Linear Regression</td><td>ml_linear_regression()</td></tr>
</tbody>
</table>

<h4>14.5.1.3 Clustering</h4>
<table>
<thead>
<tr><th>Algorithm</th><th>Function</th></tr>
</thead>
<tbody>
<tr><td>Bisecting K-Means Clustering</td><td>ml_bisecting_kmeans()</td></tr>
<tr><td>Gaussian Mixture Clustering</td><td>ml_gaussian_mixture()</td></tr>
<tr><td>K-Means Clustering</td><td>ml_kmeans()</td></tr>
<tr><td>Latent Dirichlet Allocation</td><td>ml_lda()</td></tr>
</tbody>
</table>

<h4>14.5.1.4 Recommendation</h4>
<table>
<thead>
<tr><th>Algorithm</th><th>Function</th></tr>
</thead>
<tbody>
<tr><td>Alternating Least Squares Factorization</td><td>ml_als()</td></tr>
</tbody>
</table>

<h4>14.5.1.5 Frequent Pattern Mining</h4>
<table>
<thead>
<tr><th>Algorithm</th><th>Function</th></tr>
</thead>
<tbody>
<tr><td>FPGrowth</td><td>ml_fpgrowth()</td></tr>
</tbody>
</table>

<h4>14.5.1.6 Feature Transformers</h4>
<table>
<thead>
<tr><th>Transformer</th><th>Function</th></tr>
</thead>
<tbody>
<tr><td>Binarizer</td><td>ft_binarizer()</td></tr>
<tr><td>Bucketizer</td><td>ft_bucketizer()</td></tr>
<tr><td>Chi-Squared Feature Selector</td><td>ft_chisq_selector()</td></tr>
<tr><td>Vocabulary from Document Collections</td><td>ft_count_vectorizer()</td></tr>
<tr><td>Discrete Cosine Transform</td><td>ft_discrete_cosine_transform()</td></tr>
<tr><td>Transformation using dplyr</td><td>ft_dplyr_transformer()</td></tr>
<tr><td>Hadamard Product</td><td>ft_elementwise_product()</td></tr>
<tr><td>Feature Hasher</td><td>ft_feature_hasher()</td></tr>
<tr><td>Term Frequencies using Hashing</td><td>export(ft_hashing_tf)</td></tr>
<tr><td>Inverse Document Frequency</td><td>ft_idf()</td></tr>
<tr><td>Imputation for Missing Values</td><td>export(ft_imputer)</td></tr>
<tr><td>Index to String</td><td>ft_index_to_string()</td></tr>
<tr><td>Feature Interaction Transform</td><td>ft_interaction()</td></tr>
<tr><td>Rescale to [-1, 1] Range</td><td>ft_max_abs_scaler()</td></tr>
<tr><td>Rescale to [min, max] Range</td><td>ft_min_max_scaler()</td></tr>
<tr><td>Locality Sensitive Hashing</td><td>ft_minhash_lsh()</td></tr>
<tr><td>Converts to n-grams</td><td>ft_ngram()</td></tr>
<tr><td>Normalize using the given P-Norm</td><td>ft_normalizer()</td></tr>
<tr><td>One-Hot Encoding</td><td>ft_one_hot_encoder()</td></tr>
<tr><td>Feature Expansion in Polynomial Space</td><td>ft_polynomial_expansion()</td></tr>
<tr><td>Maps to Binned Categorical Features</td><td>ft_quantile_discretizer()</td></tr>
<tr><td>SQL Transformation</td><td>ft_sql_transformer()</td></tr>
<tr><td>Standardizes Features using Corrected STD</td><td>ft_standard_scaler()</td></tr>
<tr><td>Filters out Stop Words</td><td>ft_stop_words_remover()</td></tr>
<tr><td>Map to Label Indices</td><td>ft_string_indexer()</td></tr>
<tr><td>Splits by White Spaces</td><td>ft_tokenizer()</td></tr>
<tr><td>Combine Vectors to Row Vector</td><td>ft_vector_assembler()</td></tr>
<tr><td>Indexing Categorical Feature</td><td>ft_vector_indexer()</td></tr>
<tr><td>Subarray of the Original Feature</td><td>ft_vector_slicer()</td></tr>
<tr><td>Transform Word into Code</td><td>ft_word2vec()</td></tr>
</tbody>
</table>

<h2>14.6 Clusters</h2>

<h3>14.6.1 Google trends for mainframes, cloud computing and kubernetes</h3>
Data downloaded from https://bit.ly/2YnHkNI.
<code>library(dplyr)

read.csv("data/clusters-trends.csv", skip = 2) %>%
  mutate(year = as.Date(paste(Month, "-01", sep = "))) %>%
    mutate(`On-Premise` = `mainframe...Worldwide.`,
           Cloud = `cloud.computing...Worldwide.`,
           Kubernetes = `kubernetes...Worldwide.`) %>%
    tidyr::gather(`On-Premise`, Cloud, Kubernetes,
                  key = "trend", value = "popularity") %>%
    ggplot(aes(x=year, y=popularity, group=trend)) +
      geom_line(aes(linetype = trend, color = trend)) +
      scale_x_date(date_breaks = "2 year", date_labels = "%Y") +
      labs(title = "Cluster Computing Trends",
           subtitle = paste("Search popularity for on-premise (mainframe)",
                            "cloud computing and kubernetes ")) +
      scale_color_grey(start = 0.6, end = 0.2) +
      geom_hline(yintercept = 0, size = 1, colour = "#333333") +
      theme(axis.title.x = element_blank())</code>

<h2>14.7 Streaming</h2>

<h3>14.7.1 Stream Generator</h3>
The <code>stream_generate_test()</code> function creates a local test stream. 
This function works independently from a Spark connection. 
The following example will create five files in sub-folder called “source”. 
The files will be created one second apart from the previous file’s creation.
<code>library(sparklyr)

stream_generate_test(iterations = 5, path = "source", interval = 1)</code>
After the function completes, all of the files should show up in the “source” folder. 
Notice that the file size vary. 
This is so that it simulates what a true stream would do.
<code>file.info(file.path("source", list.files("source")))[1] </code>
<code>##                     size
## source/stream_1.csv   44
## source/stream_2.csv  121
## source/stream_3.csv  540
## source/stream_4.csv 2370
## source/stream_5.csv 7236</code>
The <code>stream_generate_test()</code> by default will create a single numeric variable data frame.
<code>readr::read_csv("source/stream_5.csv")</code>
<code>## # A tibble: 1,489 x 1
##        x
##    &lt;dbl>
##  1   630
##  2   631
##  3   632
##  4   633
##  5   634
##  6   635
##  7   636
##  8   637
##  9   638
## 10   639
## # ... 
with 1,479 more rows</code>

<h3>14.7.2 Installing Kafka</h3>
This instructions were put together using information from the official Kafka site. 
Specifically from the Quickstart page, and at the time of writing this book. 
Newer versions of Kafka undoubtely will be available when reading this book. 
The idea is to “timestamp” the versions used in the example in the Streaming chapter.
<ol style="list-style-type: decimal">
<li>Download Kafka
<code>wget http://apache.claz.org/kafka/2.2.0/kafka_2.12-2.2.0.tgz</code></li>
<li>Expand the tar file and enter the new folder
<code>tar -xzf kafka_2.12-2.2.0.tgz
cd kafka_2.12-2.2.0</code></li>
<li>Start the Zookeeper service that comes with Kafka
<code>bin/zookeeper-server-start.sh config/zookeeper.properties</code></li>
<li>Start the Kafka service
<code>bin/kafka-server-start.sh config/server.properties</code></li>
</ol>
Make sure to always start Zookeper first, and then Kafka.

<h2><span class="orange">Chapter 15 References</span></h2>

<script src='https://williamkpchan.github.io/LibDocs/readbook.js'></script>
<script>
var lazyLoadInstance = new LazyLoad({
    elements_selector: ".lazy"
    // ... more custom settings?
});
</script>
</pre></body></html>
