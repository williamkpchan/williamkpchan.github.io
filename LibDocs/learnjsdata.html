<base target="_blank"><html><head><title>learn js data</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src="https://williamkpchan.github.io/lazyload.min.js"></script>
<script type='text/javascript' src='https://williamkpchan.github.io/mainscript.js'></script>
<script src="D:/Dropbox/Public/commonfunctions.js"></script>
<script src="https://d3js.org/d3.v4.min.js"></script>

<script>
  var showTopicNumber = true;
  var bookid = "learn js data"
  var markerName = "h2"
</script>
<style>
body{width:80%;margin-left: 10%; font-size:22px;}
h1, h2 {color: gold;}
strong {color: orange;}
pre{width:100%;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px; background-color:#044;}
</style></head><body onkeypress="chkKey()"><center>
<h1>learn js data</h1>
<a href="#mustWatch" class="red goldbs" target="_self">Must Watch!</a>
<br><br>
<div id="toc"></div></center>
<br><br>
<div id="mustWatch"><center><span class="red">MustWatch</span></center><br>
</div>
<pre>
<br>
<br>

<h2><span class="orange">About this guide</span></h2>
This guide teaches the basics of manipulating data using JavaScript in the
browser, or in node.js. 
Specifically, these tasks are geared around preparing
data for further analysis and visualization.

Here we demonstrate some basic techniques and how to implement them
using core JavaScript API, the <a href="http://d3js.org/">d3.js</a> library and <a href="http://lodash.com/">lodash</a>.

It assumes you already have some basic knowledge of JavaScript.

<h2>News</h2>
<strong>01/11/2019</strong>: We also have an amazing <a href="https://beta.observablehq.com/@dakoop/learn-js-data">Observable version of the guide</a> provided by the very talented <a href="https://beta.observablehq.com/@dakoop">@dakoop</a>. 
Observable is a great, interactive way to try out JavaScript. 
Give it a try now!

<strong>01/10/2019</strong>: We've updated the guide to use <a href="https://github.com/d3/d3/blob/master/CHANGES.md#changes-in-d3-50">D3v5</a>. 
The new changes mostly impact the "Reading in Data" section of the guide. 
A very special thank you goes out to <a href="https://github.com/erinbrown">Erin Brown</a> who contributed the PR to make this happen! We really appreciate the help!

<strong>03/20/2017</strong>: We've updated the guide to use <strong>D3v4</strong>!! Thanks very much to <a href="https://twitter.com/kanitw">Kanit Ham Wong</a> and others at the <a href="https://idl.cs.washington.edu/">UW Interactive Data Lab</a> for support, suggestions, and motivation for this process. 
Thanks to <a href="https://twitter.com/adamrpearce">Adam Pearce</a> for doing most of the converting!

<h2>Code</h2>
Each document in this repo is executed when loaded into a browser. 
Check it out by opening the Developer Tools Console. 
You should see the output of the following code block:

<code>console.log("This is the index!");</code>

Check out the <a href="https://github.com/vlandham/js_data">full source on github</a>.

<h2>Why?</h2>
Is data cleaning and processing in JavaScript something you would actually want to do? <em>Maybe</em>.

There are other languages out there that do a great job with data wrangling:

<a href="https://www.tidyverse.org/">R with the Tidyverse</a>

<a href="http://nbviewer.ipython.org/gist/fonnesbeck/5850413">Python with pandas</a>

These tools are great and you should use them. 
Often times, however, you are already familiar with a particular language (like JavaScript) and would like to get started with data, but want to take it one step at a time.

Additionally, sometimes you are already in a particular environment (like JavaScript) and don't have the luxury of switching to one of these other options.

In these cases, JavaScript could be considered a viable option for your data analysis. 
And if you find yourself in one of these situations, or just want to try out JavaScript for data analysis for fun, then <em>this guide is for you</em>!

Check out some of the tasks, and see if JavaScript Data something you want to try yourself.

<h2>Thanks!</h2>
This guide is the result of quite a team effort.

Its inspiration came from a ponderous tweet by the one and only <a href="http://ghostweather.com/">Lynn Cherney</a>, who lamented the dirth of JavaScript data guidance at the time.

The beautiful folks at <a href="https://bocoup.com/">Bocoup</a> are the reason this guide exists. 
They had the foresight to provide the all important luxury of time so that it could be written. 
Thanks to <a href="https://bocoup.com/about/bocouper/jory-burson">Jory Burson</a> and <a href="https://bocoup.com/about/bocouper/boaz-sender">Boaz Sender</a> for creating a culture that gave space for these kinds of things to be created.

The bulk of this guide was written while at Bocoup by <a href="https://medium.com/@ireneros">Irene Ros</a>, <a href="http://clome.info/">Yannick Assogba</a>, and <a href="http://vallandingham.me/">Jim Vallandingham</a>.

Since that time, we have had <a href="https://github.com/vlandham/js_data/graphs/contributors">numerous other contributors</a>, who have seen something to improve, and made us all better for their help.

Perhaps hackneyed, but almost always true - It takes a village. 
So to that village we want to say, "Thanks!".

<h2><span class="orange">Getting Started</span></h2>
<h2>About Tasks</h2>
This guide is broken up into a number of tasks, which we can think of as little modules or <em>recipes</em>.

Each task tries to encapsulate a concrete lesson around common data manipulation and analysis processes. 
Tasks attempt to be self-contained and stay focused on the, well, <em>task at hand</em>.

This guide was built with for client side data processing (in the browser), but can easily be used in a server side (Node) application with a bit of tweaking (you can check out the <a href="node.html">analyzing data with Node</a> section for the details later).

<h2>Why D3?</h2>
<a href="http://d3js.org/">D3.js</a> is largely known for its data visualization capabilities - and for good reason. 
It is quickly becoming the de facto standard for interactive visualization on the web.

Its core feature of binding data to visual representations happens to require a lot of manipulation of said data. 
Thus, while this toolkit is focused around visualization, it is well suited for data processing as well!

And, a typical output for data manipulation is at least some sort of visualization of that data, in which case you are all ready to go.

<h2>A Note about D3v4</h2>
In the not too distant past, a major rewrite of the D3.js library was completed and released into the wild. 
In includes quite a few API changes and a <a href="https://github.com/d3">very modular structure</a> (meaning in theory you can just use the bits of D3 that you want and not the rest).

This major rewrite makes D3 a lot better - but it also makes it more challenging to read and use old code and sometimes to understand the documentation. 
But don't despair! We've <a href="v3/">maintained the old version of this guide using D3v3</a> in case you have old code you need help with. 

<h2>Why lodash?</h2>
<a href="https://lodash.com">Lodash</a> is fast, popular, and fills in some holes in D3's processing features. 
Plus, it's functional style and chaining capabilities make it work well alongside D3.

<h2>Code Snippets</h2>
There are a bunch of useful snippets in this guide. 
Here is an example:

<code>var theMax = d3.max([1,2,20,3]);
console.log(theMax);
</code>
<code>=&gt; 20
</code>
<div class="aside">This code is using d3.js</div>

We use a little arrow, <code>=&gt;</code>, to indicate output from a code snippet. 
This same output you can view by opening the <a href="https://developer.chrome.com/devtools/docs/console">console</a> of your favorite web browser.

Snippets in this guide that are not pure JavaScript will be marked with the libraries used to make them work.

<h2>Preparing Your Site for Data Processing</h2>
To get started using these tools for your data processing, you are going to want to include them in your html file along with a JavaScript file to perform the analysis.

I typically download these scripts and include local copies in my page. 
You can keep "libraries" that you are using but didn't write in a <code>lib</code> folder, and the code you write yourself in a <code>src</code> folder. 
Then you want to load all these files on an HTML page. 
To do this, you would want to have your HTML look something like this:

<code class="lang-html">&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;script src='lib/d3.js'&gt;&lt;/script&gt;
&lt;script src='lib/lodash.js'&gt;&lt;/script&gt;
&lt;script src='src/analysis.js'&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code>

<code>src/analysis.js</code> would be where your analysis code goes. 
I put these <code>script</code> tags at the end of the <code>body</code> - just so that if there is other content on the page, it won't be delayed in loading. 
Typically, I name this main HTML file <code>index.html</code> - so that its loaded automatically as the root page.

<h2>Running a Local Server</h2>
D3's functions for <a href="read_data.html">reading data</a> require you be running the page from a server. 
You can do this on your own machine by running a local server out of the root directory of your site.

There are many options for easy-to-spin-up web servers:

<a href="http://www.pythonforbeginners.com/modules-in-python/how-to-use-simplehttpserver/">SimpleHTTPServer</a> for Python

<a href="http://www.benjaminoakes.com/2013/09/13/ruby-simple-http-server-minimalist-rake/">httpd</a> for Ruby

<a href="https://github.com/nodeapps/http-server">http-server</a> for Node

Lately, I have been using that last option - <code>http-server</code>. 
If you have <a href="https://nodejs.org/en/">Node</a> and <a href="https://www.npmjs.com/">npm</a> installed, you can grab the required package by installing it from the command line:

<code class="lang-bash">npm install -g http-server</code>

(The <code>-g</code> flag stands for <em>global</em> - which allows you to access <code>http-server</code> from any directory on your machine.

Then <code>cd</code> to your analysis directory and start it up!

<code class="lang-bash">cd /path/to/dir
http-server</code>

In your web browser, open up <a href="http://0.0.0.0:8080">http://0.0.0.0:8080</a> and you should be ready to go!

<h2>Next Task</h2>
<a href="read_data.html">Reading in Data</a>

<h2>See Also</h2>
<a href="http://howtonode.org/how-to-install-nodejs">Installing Node</a> - if you need some help getting <code>http-server</code> on your machine.

</div>
<h2><span class="orange">Reading in Data</span></h2>
The first step in any data processing is getting the data! Here is how to parse in and prepare common input formats using D3.js

<h2>Parsing CSV Files</h2>
<a href="https://github.com/d3/d3/blob/master/API.md#fetches-d3-fetch">D3 has a bunch</a> of filetypes it can support when loading data, and one of the most common is probably plain old CSV (comma separated values).

Let's say you had a csv file with some city data in it:

<code class="lang-bash">cities.csv:

city,state,population,land area
seattle,WA,652405,83.9
new york,NY,8405837,302.6
boston,MA,645966,48.3
kansas city,MO,467007,315.0</code>

Use <a href="https://github.com/d3/d3-fetch/blob/master/README.md#csv">d3.csv</a> to convert it into an array of objects

<code>d3.csv("/data/cities.csv").then(function(data) {
  console.log(data[0]);
});
</code>
<code>=&gt; {city: "seattle", state: "WA", population: "652405", land area: "83.9"}</code>
<div class="aside">This code is using d3.js</div>

You can see that the headers of the original CSV have been used as the property names for the data objects. 
Using <code>d3.csv</code> in this manner requires that your CSV file has a header row.

If you look closely, you can also see that the values associated with these properties are all strings. 
This is probably <em>not what you want</em> in the case of numbers. 
When loading CSVs and other flat files, you have to do the type conversion.

We will see more of this in other tasks, but a simple way to do this is to use the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Unary_plus">+</a> operator (unary plus). 
<code>forEach</code> can be used to iterate over the data array.

<code>d3.csv("/data/cities.csv").then(function(data) {
  data.forEach(function(d) {
d.population = +d.population;
d["land area"] = +d["land area"];
  });
  console.log(data[0]);
});
</code>
<code>=&gt; {city: "seattle", state: "WA", population: 652405, land area: 83.9}</code>
<div class="aside">This code is using d3.js</div>

<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_Accessors">Dot notation</a> is a useful way to access the properties of these data objects. 
However, if your headers have spaces in them, then you will need to use bracket notation as shown.

This can also be done during the loading of the data, by <code>d3.csv</code> directly. 
This is done by providing an accessor function to <code>d3.csv</code>, whose return value will be the individual data objects in our data array.

<code>d3.csv("/data/cities.csv", function(d) {
  return {
city : d.city,
state : d.state,
population : +d.population,
land_area : +d["land area"]
  };
}).then(function(data) {
  console.log(data[0]);
});
</code>
<code>=&gt; {city: "seattle", state: "WA", population: 652405, land_area: 83.9}</code>
<div class="aside">This code is using d3.js</div>

In this form, you have complete control over the data objects and can rename properties (like <code>land_area</code>) and convert values (like <code>population</code>) willy-nilly. 
 On the other hand, you have to be quite explicit about which properties to return. 
This may or may not be what you are into.

I typically allow D3 to load all the data, and then make modifications in a post-processing step, but it might be more effective for you to be more explicit with the modifications.

<h2>Reading TSV Files</h2>
CSV is probably the most common flat file format, but in no way the only one.

I often like to use TSV (tab separated files) - to get around the issues of numbers and strings often having commas in them.

D3 can parse TSV's with <a href="https://github.com/d3/d3-fetch/blob/master/README.md#tsv">d3.tsv</a>.

Here is <code>animals.tsv</code>, as an example:

<code>nametypeavg_weight
tigermammal260
hippomammal3400
komodo dragonreptile150</code>

Loading animals.tsv with <code>d3.tsv</code>:

<code>d3.tsv("/data/animals.tsv").then(function(data) {
  console.log(data[0]);
});
</code>
<code>=&gt; {name: "tiger", type: "mammal", avg_weight: "260"}</code>
<div class="aside">This code is using d3.js</div>

<h2>Reading Other Flat Files</h2>
In fact, <code>d3.csv</code> and <code>d3.tsv</code> are only the tip of the iceberg. 
If you have a non-standard delimited flat file, you can parse them too using <a href="https://github.com/d3/d3-fetch/blob/master/README.md#dsv">d3.dsv</a>!

For example, here is a pipe-delimited file called <code>animals_piped.txt</code>:

<code>name|type|avg_weight
tiger|mammal|260
hippo|mammal|3400
komodo dragon|reptile|150</code>

We first provide <code>d3.dsv</code> with the delimiter, in this case, a pipe (<code>|</code>), then read in our file:

<code>d3.dsv("|", "/data/animals_piped.txt").then(function(data){
  console.log(data[1]);
});
</code>
<code>=&gt; {name: "hippo", type: "mammal", avg_weight: "3400"}
</code>
<div class="aside">This code is using d3.js</div>

<h2>Reading JSON Files</h2>
For nested data, or for passing around data where you don't want to mess with data typing, its hard to beat <a href="http://json.org/">JSON</a>.

JSON has become the language of the internet for good reason. 
Its easy to understand, write, and parse. 
And with <a href="https://github.com/d3/d3-fetch/blob/master/README.md#json">d3.json</a> - you too can harness its power.

Here is an example JSON file called <code>employees.json</code>:

<code>[
 {"name":"Andy Hunt",
  "title":"Big Boss",
  "age": 68,
  "bonus": true
 },
 {"name":"Charles Mack",
  "title":"Jr Dev",
  "age":24,
  "bonus": false
 }
]</code>

Loading <code>employees.json</code> with <code>d3.json</code>:

<code>d3.json("/data/employees.json").then(function(data) {
  console.log(data[0]);
});
</code>
<code>=&gt; {name: "Andy Hunt", title: "Big Boss", age: 68, bonus: true}</code>
<div class="aside">This code is using d3.js</div>

We can see that, unlike our flat file parsing, numeric types stay numeric. 
Indeed, a JSON value can be a string, a number, a boolean value, an array, or another object. 
This allows nested data to be dealt with easily.

<h2>Loading Multiple Files</h2>
D3's basic loading mechanism is fine for one file, but starts to get messy as we nest multiple callbacks.

For loading multiple files, we can use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promises</a> to wait for multiple data sources to be loaded.

<code>Promise.all([
  d3.csv("/data/cities.csv"),
  d3.tsv("/data/animals.tsv")
]).then(function(data) {
  console.log(data[0][0])  // first row of cities
  console.log(data[1][0])  // first row of animals
});
</code>
<code>=&gt; {city: "seattle", state: "WA", population: "652405", land area: "83.9"}
{name: "tiger", type: "mammal", avg_weight: "260"}</code>
<div class="aside">This code is using d3.js</div>

Note that inside the <code>all</code> method we load two types of files - using two different loading functions - so this is an easy way to mix and match file types.

The method returns an array of our data sources. 
The first item returns our cities; the second, our animals.

<h2>Next Task</h2>
<a href="combine_data.html">Combining Data</a>

<h2>See Also</h2>
<a href="https://github.com/d3/d3-fetch">D3 documentation</a>

<a href="https://github.com/d3/d3-fetch#xml">Loading XML with D3</a>

<a href="http://bl.ocks.org/mbostock/1014829">Loading External SVG with D3</a> - SVG is just XML!

</div>
<h2><span class="orange">Combining Data</span></h2>
<em>Note: This task was very generously contributed by <a href="http://timogrossenbacher.ch/">Timo Grossenbacher</a> - Geographer and Data Specialist extraordinaire. 
Thanks very much Timo!</em>

Often, you have to combine two or more different data sets because they contain complementary information. 
Or, for example, the data come in chunks from the server and need to be reassembled on the client side.

Combining or <em>merging</em> data may involve one of the following tasks:

Combine data sets by one or more common attributes

Add together rows from different data sets

Combine attributes from different data sets

<h2>Combine data sets by one or more common attributes</h2>
Let's say we have a list of the following articles:

<code>var articles = [{
"id": 1,
"name": "vacuum cleaner",
"weight": 9.9,
"price": 89.9,
"brand_id": 2
}, {
"id": 2,
"name": "washing machine",
"weight": 540,
"price": 230,
"brand_id": 1
}, {
"id": 3,
"name": "hair dryer",
"weight": 1.2,
"price": 24.99,
"brand_id": 2
}, {
"id": 4,
"name": "super fast laptop",
"weight": 400,
"price": 899.9,
"brand_id": 3
}];
</code>

And of the following brands:

<code>var brands = [{
"id": 1,
"name": "SuperKitchen"
}, {
"id": 2,
"name": "HomeSweetHome"
}];
</code>

As you can see, in each article, <code>brand_id</code> points to a particular brand, whose details are saved in another data set - which can be considered a <em>lookup table</em> in this case. 
This is often how separate data schemes are stored in a server-side database. 
Also note that the last article in the list has a <code>brand_id</code> for which no brand is stored in <code>brands</code>.

What we want to do now is to combine both datasets, so we can reference the brand's <code>name</code> directly from an article. 
There are several ways to achieve this.

<h3>Using native <code>Array</code> functions</h3>

We can implement a simple join (<em>left outer join</em> in database terms) using native, i.e., already existing <code>Array</code> functions as follows. 
The method presented here modifies the <code>articles</code> array <em>in place</em> by adding a new key-value-pair for <code>brand</code>.

<code>articles.forEach(function(article) {
var result = brands.filter(function(brand) {
return brand.id === article.brand_id;
});
delete article.brand_id;
article.brand = (result[0] !== undefined) ? result[0].name : null;
});
console.log(articles);
</code>
<code>=&gt; [{
"id": 1,
"name": "vacuum cleaner",
"weight": 9.9,
"price": 89.9,
"brand": "HomeSweetHome"
}, {
"id": 2,
"name": "washing machine",
"weight": 540,
"price": 230,
"brand": "SuperKitchen"
}, {
"id": 3,
"name": "hair dryer",
"weight": 1.2,
"price": 24.99,
"brand": "HomeSweetHome"
}, {
"id": 4,
"name": "super fast laptop",
"weight": 400,
"price": 899.9,
"brand": null
}];
</code>

First, we loop over each <code>article</code>, where we take its <code>brand_id</code> to look up the corresponding <code>brand</code> using the native <code>filter</code> function. 
Note that this function returns an array and we expect it to have only one element. 
In case there is no corresponding <code>brand</code>, <code>result[0]</code> will be <code>undefined</code>, and in order to prevent an error (something like <code>result[0] is undefined</code>), we use the ternary operator.

Also, as we no longer need <code>brand_id</code> after the lookup has been done, we can safely delete it.

If we want to join by more than one attribute, we can modify the filter function to achieve this. 
Hypothetically, this might look something like:

<code class="lang-js">innerArray.filter(function(innerArrayItem) {
  return (
innerArrayItem.idA === outerArrayItem.idA &amp;&amp;
innerArrayItem.idB === outerArrayItem.idB
  );
});</code>
<h3>Using a generic and more efficient approach</h3>

A more generic, and also more performant version of a join is proposed below (abbreviated from <a href="http://stackoverflow.com/questions/17500312/is-there-some-way-i-can-join-the-contents-of-two-javascript-arrays-much-like-i/17500836#17500836">this StackOverflow answer</a>). 
Its output is equivalent to the one of the above method.

<code>function join(lookupTable, mainTable, lookupKey, mainKey, select) {
var l = lookupTable.length,
m = mainTable.length,
lookupIndex = [],
output = [];
for (var i = 0; i &lt; l; i++) { // loop through l items
var row = lookupTable[i];
lookupIndex[row[lookupKey]] = row; // create an index for lookup table
}
for (var j = 0; j &lt; m; j++) { // loop through m items
var y = mainTable[j];
var x = lookupIndex[y[mainKey]]; // get corresponding row from lookupTable
output.push(select(y, x)); // select only the columns you need
}
return output;
};
</code>

Because above defined function creates an index for the <code>lookupTable</code> (in our case <code>brands</code>) in the first iteration, it runs considerably faster than the previously shown method. 
Also, via a callback, it allows us to directly define which keys (or "attributes") we want to retain in the resulting, joined array (<code>output</code>). 
It is used like so:

<code>var result = join(brands, articles, "id", "brand_id", function(article, brand) {
return {
id: article.id,
name: article.name,
weight: article.weight,
price: article.price,
brand: (brand !== undefined) ? brand.name : null
};
});
console.log(result);</code>
<code>=&gt; [{
"id": 1,
"name": "vacuum cleaner",
"weight": 9.9,
"price": 89.9,
"brand": "HomeSweetHome"
}, {
"id": 2,
"name": "washing machine",
"weight": 540,
"price": 230,
"brand": "SuperKitchen"
}, {
"id": 3,
"name": "hair dryer",
"weight": 1.2,
"price": 24.99,
"brand": "HomeSweetHome"
}, {
"id": 4,
"name": "super fast laptop",
"weight": 400,
"price": 899.9,
"brand": null
}];
</code>

Note that we don't modify <code>articles</code> <em>in place</em> but create a new array.

<h2>Add together rows from different data sets</h2>
Let's say we want to load a huge data set from the server, but because of network performance reasons, we load it in three chunks and reassemble it on the client side. 
With D3v5 and later, we can use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all">Promise.all()</a> to run many requests concurrently, combining them after they have finished downloading using <a href="https://github.com/d3/d3-array/blob/master/README.md#merge">d3.merge()</a>. 
Note that <code>Promise.all()</code> takes an array of Promises, in this case supplied by calls to <code>d3.csv()</code>.

<code>Promise.all([
d3.csv("/data/big_data_1.csv"),
d3.csv("/data/big_data_2.csv"),
d3.csv("/data/big_data_3.csv")
]).then(function(allData) {
console.log(d3.merge(allData));
});
</code>
<code>=&gt; [{"a": "1", "b": "2"},{"a": "3", "b": "4"},{"a": "5", "b": "6"}]</code>
<div class="aside">This code is using d3.js</div>

Note that the argument passed to <code>d3.merge</code> must be an array itself, which is why we use the square brackets.

<h2>Combine attributes from different data sets</h2>
In the last case, we have two or more data sets that contain attributes describing the same observations, or conceptual entities, and they need to be combined. 
This implies that all data sets have the same length. 
For example, <code>dataset_1</code> below contains two observations of attribute <code>type</code> and attribute <code>model</code>, while <code>dataset_2</code> contains the same two entities, but observed through attributes <code>price</code> and <code>weight</code>.

<code>var dataset_1 = [{
'type': 'boat',
'model': 'Ocean Queen 2000'
}, {
'type': 'car',
'model': 'Ferrari'
}];
var dataset_2 = [{
'price': 23202020,
'weight': 5656.9
}, {
'price': 59988,
'weight': 1.9
}];</code>

So in both data sets we essentially have separate information about the same conceptual entities, thus it makes sense to "merge" them, for which we can use lodash's <code>merge</code> function:

<code>var result = _.merge(dataset_1, dataset_2);
console.log(result);</code>
<code>=&gt; [{
'type': 'boat',
'model': 'Ocean Queen 2000',
'price': 23202020,
'weight': 5656.9
}, {
'type': 'car',
'model': 'Ferrari',
'price': 59988,
'weight': 1.9
}];</code>
<div class="aside">This code is using lodash</div>

<h2>Next Task</h2>
<a href="summarize_data.html">Summarizing Data</a>

<h2><span class="orange">Summarizing Data</span></h2>
With the data <a href="read_data.html">loaded</a>, we want to take a quick look at what we have. 
D3 has a number of tools to use for quick data exploration.

To start, let's pretend we have loaded up a csv file - and have a dataset that looks something like:

<code>var data = [
  {"city":"seattle", "state":"WA", "population":652405, "land_area":83.9},
  {"city":"new york", "state":"NY", "population":8405837, "land_area":302.6},
  {"city":"boston", "state":"MA", "population":645966, "land_area":48.3},
  {"city":"kansas city", "state":"MO", "population":467007, "land_area":315}
];
</code>
<h2>Min &amp; Max</h2>
As it turns out, D3 comes to the rescue again, with <a href="https://github.com/d3/d3-array#min">d3.min</a> and <a href="https://github.com/d3/d3-array#max">d3.max</a>. 
Use the callback function to indicate which property (or computed value based on the properties) to access.

<code>var minLand = d3.min(data, function(d) { return d.land_area; });
console.log(minLand);
</code>
<code>=&gt; 48.3

</code>
<div class="aside">This code is using d3.js</div>

<code>var maxLand = d3.max(data, function(d) { return d.land_area; });
console.log(maxLand);
</code>
<code>=&gt; 315

</code>
<div class="aside">This code is using d3.js</div>

If you want both of them at the same time, you can use <a href="https://github.com/d3/d3-array#extent">d3.extent</a>

<code>var landExtent = d3.extent(data, function(d) { return d.land_area; });
console.log(landExtent);
</code>
<code>=&gt; [48.3, 315]

</code>
<div class="aside">This code is using d3.js</div>

This returns an array with the first element the minimum value and the second element the maximum.

<h2>Summary Statistics</h2>
D3 provides a few basic tools to analyze your data, all using the same format as the min and max functions. 
Simply provide the property you would like to analyze, and you are good to go.

<a href="https://github.com/d3/d3-array#mean">d3.mean</a>

<code>var landAvg = d3.mean(data, function(d) { return d.land_area; });
console.log(landAvg);
</code>
<code>=&gt; 187.45

</code>
<div class="aside">This code is using d3.js</div>

<a href="https://github.com/d3/d3-array#median">d3.median</a>

<code>var landMed = d3.median(data, function(d) { return d.land_area; });
console.log(landMed);
</code>
<code>=&gt; 193.25

</code>
<div class="aside">This code is using d3.js</div>

<a href="https://github.com/d3/d3-array#deviation">d3.deviation</a> - for standard deviation

<code>var landSD = d3.deviation(data, function(d) { return d.land_area; });
console.log(landSD);
</code>
<code>=&gt; 140.96553952414519

</code>
<div class="aside">This code is using d3.js</div>

<h2>Next Task</h2>
<a href="iterate_data.html">Iterating and Reducing</a>

<h2>See Also</h2>
<a href="https://github.com/tmcw/simple-statistics">simple statistics</a> - more JavaScript based stats written in easier to comprehend code.

<a href="http://vega.github.io/datalib/">Datalib</a> - A Javascript utility library for data loading, type inference, common statistics, and string templates that was created to power <a href="http://vega.github.io/vega">Vega</a> and <a href="http://vega.github.io/vega-lite">Vega-Lite</a>.

</div>
<h2><span class="orange">Iterating Over and Reducing Data</span></h2>
Most of the functions we used to <a href="summarize_data.html">summarize</a> our data had to iterate over the entire dataset to generate their results - but the details were hidden behind the function. 
Now let's look at how we might perform this iteration ourselves for other metrics and manipulations!

Again, we start with a basic data set already loaded:

<code>var data = [
  {"city":"seattle", "state":"WA", "population":652405, "land_area":83.9},
  {"city":"new york", "state":"NY", "population":8405837, "land_area":302.6},
  {"city":"boston", "state":"MA", "population":645966, "land_area":48.3},
  {"city":"kansas city", "state":"MO", "population":467007, "land_area":315}
];
</code>
<h2>Iterating</h2>
First some basic iteration. 
We already saw this in the data loading task, but a common way to process each data object is by using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">forEach</a>

<code>var count = 0;

data.forEach(function(d) {
  count += 1;
});

console.log(count);
</code>
<code>=&gt; 4

</code>

<em>Of course, data also has the property <code>length</code> which would be the actual way to get the number of data elements in <code>data</code> - but this is just an example.</em>

<code>console.log(data.length);
</code>
<code>=&gt; 4

</code>
<h2>Immutability</h2>
Let me sidetrack this task just a bit to talk about

<code>forEach</code> provides for a basic way to loop through our data set. 
We can use this to modify the data in place, generate counts, or perform other manipulations that deal with each piece of data individually.

This works, but can get clunky and confusing fast. 
Keeping straight what form the data is in at any given time can be confusing, as can side effects of modifying your data that you might not be aware of.

To combat this confusion, it can be useful to think of the data as <em>immutable</em>. 
Immutable data cannot be modified once created. 
Immutability seems a bit counterintuitive for a task where we want to coerce our data into the form we want - but it comes together with the concept of <strong>transformations</strong>.

The idea is simple: each immutable dataset can be <em>transformed</em> into another immutable dataset through the use of a transformation function that works on each component of the data.

This process helps simplify the data flow, but if you have to make a copy of your data object each time, it can make code a bit brittle as you have to keep track of every attribute of your dataset.

<h2>Cloning</h2>
To help with this issue of brittle transformations, lodash provides the <a href="https://lodash.com/docs#clone">clone</a> function.

This function takes an object and returns a copy of that object. 
That copy is now a separate data object that you can edit without effecting the original object.

<code>var dataObject = {"name":"Carl", "age":"48", "salary":"12300"};
var copyOfData = _.clone(dataObject);
copyOfData.age = +copyOfData.age;
copyOfData.salary = +copyOfData.salary;
console.log(dataObject);
</code>
<code>=&gt; {name: "Carl", age: "48", salary: "12300"}

</code>
<div class="aside">This code is using lodash</div>

<code>console.log(copyOfData);
</code>
<code>=&gt; {name: "Carl", age: 48, salary: 12300}

</code>

By default, the <code>clone</code> function will not copy over nested objects. 
Instead these nested objects are simply passed by referenced - meaning the original and the copy will still share them.

<code>var dataObject = {"name":"Saul", "stats":{"age":"55"}};
var shallowCopy = _.clone(dataObject);
shallowCopy.stats.age = +shallowCopy.stats.age;
console.log(dataObject);
</code>
<code>=&gt; {"name":"Saul","stats":{"age":55}}

</code>
<div class="aside">This code is using lodash</div>

<code>console.log(shallowCopy);
</code>
<code>=&gt; {"name":"Saul","stats":{"age":55}}

</code>

Note that because <code>stats</code> is a nested object the modification happened in both spots!

To prevent this "feature", we can pass <code>true</code> as the second parameter to <code>clone</code> to indicate that the copy should be deep and copy nested objects as well.

<code>var dataObject = {"name":"Saul", "stats":{"age":"55"}};
var deepCopy = _.clone(dataObject, true);
deepCopy.stats.age = +deepCopy.stats.age;
console.log(dataObject);
</code>
<code>=&gt; {"name":"Saul","stats":{"age":"55"}}

</code>
<div class="aside">This code is using lodash</div>

<code>console.log(deepCopy);
</code>
<code>=&gt; {"name":"Saul","stats":{"age":55}}

</code>

lodash also has a <a href="https://lodash.com/docs#cloneDeep">cloneDeep</a> that can be used to make the deep-ness more explicit.

<h2>Mapping</h2>
JavaScript's <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map">map</a> can be a very useful tool to implement this concept of a transformation on immutable data.

<code>map</code> takes an array and produces another array which is the result of the callback function being executed on each element in the array.

<code>var smallData = data.map(function(d,i) {

  return {
name: d.city.toUpperCase(),
index: i + 1,
rounded_area: Math.round(d.land_area)
  };
});
console.log(data[0]);
console.log(smallData[0]);
</code>
<code>=&gt; {city: "seattle", state: "WA", population: 652405, land_area: 83.9}
  {name: "SEATTLE", index: 1, rounded_area: 84}

</code>

The callback function gets called for each element in the array, and also has access to the index of that element in the array. 
The result is an array of returned values from the callback.

With plain JavaScript, the immutability of an array is just <em>in the mind of the developer</em>. 
While <code>map</code> does not modify the array, it is easy for your callback method to do so. 
That is why we return a new object in the callback. 
lodash's <a href="https://lodash.com/docs#clone">clone</a> would be another approach to getting a copy of each data element as a starting point for the transformation.

<h2>Filtering</h2>
Select a subset of the data using the built in <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter">filter</a> method. 
This creates a new array of data (again see transformation talk above) with only the values that the callback function returns <code>true</code> for.

<code>var large_land = data.filter(function(d) { return d.land_area &gt; 200; });
console.log(JSON.stringify(large_land));
</code>
<code>=&gt; [{"city":"new york","state":"NY","population":8405837,"land_area":302.6},
  {"city":"kansas city","state":"MO","population":467007,"land_area":315}]

</code>
<h2>Sorting</h2>
Similar to filtering, sorting data based on attributes is something you'll want to do frequently.

The built in <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort">sort</a> for arrays can do this. 
A caveat to this function is that, unlike filter, map, and other functions, this <em>modifies the array you are sorting in place</em>, instead of returning a new array with the objects sorted.

To sort an array, you need a comparator function. 
This is a function that takes two pieces of data and indicates which one you want higher in the list. 
The comparator-function-way to do this is to return a negative value if the first value should go higher then the second value, and a positive value if the second value should go higher. 
If they are equal, and you don't care, then return a 0.

Let's see it in action. 
Here is a way to sort by population in a descending order (larger populations come first).

<code>data.sort(function(a,b) {
  return b.population - a.population;
});
console.log(JSON.stringify(data));
</code>
<code>=&gt; [{"city":"new york","state":"NY","population":8405837,"land_area":302.6},
   {"city":"seattle","state":"WA","population":652405,"land_area":83.9},
   {"city":"boston","state":"MA","population":645966,"land_area":48.3},
   {"city":"kansas city","state":"MO","population":467007,"land_area":315}]
</code>

This <code>b - a</code> thing is a pretty common way to generate this kind of sort. 
But you could also do it more explicitly. 
Thinking through it, if b's population is larger then a's, then the value returned by <code>b.population - a.population</code> will be positive - so b will be sorted toward the top of the array. 
If the reverse is true, then the result will be negative, and a will be sorted first.

Note again, that the sort happened <em>on the original data</em>, which I'm not a big fan of.

D3 also has a few helper functions to implement ascending and descending comparator functions - but (as far as I can tell) they only accept arrays of raw numbers instead of objects. 
So to use <a href="https://github.com/d3/d3-array#ascending">d3.ascending</a> or <a href="https://github.com/d3/d3-array#descending">d3.descending</a> you would have to do something like this:

<code>var populations = data.map(function(d) { return d.population; });
console.log(populations);
</code>
<code>=&gt; [652405, 8405837, 645966, 467007]

</code>
<code>populations.sort(d3.descending);
console.log(populations);
</code>
<code>=&gt; [8405837, 652405, 645966, 467007]

</code>

I'm usually looking to keep my data objects together, so I shy away from using these methods, but they might be great for what you are trying to do.

A <strong>big gotcha</strong> with sorting that you should watch out for is that if you do not pass a comparator function, the default function sorts <em>alphabetically</em>. 
So, the array:

<code>var nums = [3,1,10,20];
</code>

Would be sorted to:

<code>console.log(nums.sort());
</code>
<code>=&gt; [1, 10, 20, 3]

</code>

This is never what you want for data sorting. 
For this reason, you should never use sort without a comparator function.

<h2>Reducing</h2>
These functions all take an array and reduce it down to a single number. 
But what if that number isn't the one you want? Well, you can take this reduction into your own hands with <code>reduce</code>!

The syntax for <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">reduce</a> is always hard for me to remember, so let's go over it with the classic example: summing up a value.

<code>var landSum = data.reduce(function(sum, d) {
  return sum + d.land_area;
}, 0);
console.log(landSum);
</code>
<code>=&gt; 749.8

</code>

The first parameter to <code>reduce</code> is the callback function that will return the running "total" of the reduction. 
This function is passed in the previous value returned from the last time the callback was called. 
Here, that parameter - <code>sum</code> provides the running total as we move through the array. 
The second parameter to the callback <code>d</code> is the current value of the array we are working on.

<code>reduce</code> can take an initial value, which is the second parameter to the <code>reduce</code> call. 
For this example, we start the sum at 0. 
If there is no starting value provided, then for the first execution of the callback (when there is no previous value) the first parameter to the callback will be the value of the first element of the array, and the reduction starts with the second element.

It always makes more sense to me to provide a starting value - unless you know what you are doing. 
You can also get the current index into the array (and the whole array itself) if that is useful to you.

<code>var weirdString = data.reduce(function(str, d, i) {
  var ending = (i % 2 === 0) ? " is cool." : " sucks." ;
  return str + " " + d.city + ending;
}, "");
console.log(weirdString);
</code>
<code>=&gt; seattle is cool. 
new york sucks. 
boston is cool. 
kansas city sucks.

</code>

_And summing over a variable is only used for example. 
You can always just use <a href="https://github.com/d3/d3-array#d3_sum">d3.sum</a> for this instead._

<h2>Chaining Functions</h2>
One of the great things about these more <em>functional</em> functions is that it is possible to chain them together into one big data wrangling pipeline!

<code>var bigCities = data.filter(function(d) { return d.population &gt; 500000; })
  .sort(function(a,b) { return a.population - b.population; })
  .map(function(d) { return d.city; });
console.log(bigCities);
</code>
<code>=&gt; ["boston", "seattle", "new york"]

</code>

Since we are using <code>sort</code> after <code>filter</code>, sort is working on the returned array from <code>filter</code>. 
The sort function at least is nice enough to also return the array, so chaining is still possible.

<h2>Next Task</h2>
<a href="group_data.html">Grouping Data</a>

<h2>See Also</h2>
<a href="http://www.macwright.org/2015/01/03/reduce-juice.html">Making Juice with Reduce</a> - Tom MacWright's intro to the ill-used reduce

<a href="https://github.com/facebook/immutable-js">Immutable JS</a> - if you want to get serious about immutable data structures in JavaScript

<a href="http://fr.umio.us/why-ramda/">Ramda</a> - a more functional approach to data processing in JS

</div>
<h2><span class="orange">Grouping Data</span></h2>
Grouping data is an important capability to have when doing data analysis. 
Often times, you will want to break apart the data by a categorical variable and look at statistics or details for each group.

D3 includes the powerful <a href="https://github.com/d3/d3-collection#nests">d3.nest</a> functionality to produce these groupings with a minimal amount of code.

<h2>Nest Basics</h2>
Fundamentally, <code>d3.nest</code> is about taking a flat data structure and turning it into a nested one. 
The user gets to decide how the nesting should occur, and how deep to nest. 
This is a bit different then many group_by concepts, where only a single level of nesting is allowed.

Let's say we have the following CSV file of "expenses":

<code>name,amount,date
jim,34.0,11/12/2015
carl,120.11,11/12/2015
jim,45.0,12/01/2015
stacy,12.00,01/04/2016
stacy,34.10,01/04/2016
stacy,44.80,01/05/2016</code>

And that has been converted to a nice array of objects via our <a href="read_data.html">data reading powers</a> into something like this:

<code>var expenses = [{"name":"jim","amount":34,"date":"11/12/2015"},
  {"name":"carl","amount":120.11,"date":"11/12/2015"},
  {"name":"jim","amount":45,"date":"12/01/2015"},
  {"name":"stacy","amount":12.00,"date":"01/04/2016"},
  {"name":"stacy","amount":34.10,"date":"01/04/2016"},
  {"name":"stacy","amount":44.80,"date":"01/05/2016"}
];
</code>

And now we want to slice up this data in different ways.

First, let's use nest to group by <code>name</code>:

<code>var expensesByName = d3.nest()
  .key(function(d) { return d.name; })
  .entries(expenses);
</code>
<div class="aside">This code is using d3.js</div>

Which results in a nested data structure:

<code>expensesByName = [
  {"key":"jim","values":[
{"name":"jim","amount":34,"date":"11/12/2015"},
{"name":"jim","amount":45,"date":"12/01/2015"}
  ]},
  {"key":"carl","values":[
{"name":"carl","amount":120.11,"date":"11/12/2015"}
  ]},
  {"key":"stacy","values":[
{"name":"stacy","amount":12.00,"date":"01/04/2016"},
{"name":"stacy","amount":34.10,"date":"01/04/2016"},
{"name":"stacy","amount":44.80,"date":"01/05/2016"}
  ]}
];
</code>

<code>expensesByName</code> is an array of objects. 
Each object has a <code>key</code> property - which is what we used as the grouping value using the <code>key</code> function. 
Here, we used the values associated with the <code>name</code> property as the key.

The <code>values</code> property of these entries is an array containing all the original data objects that had that key.

<h2>Summarizing Groups</h2>
The nested structure can be great for visualizing your data, but might be a little underwhelming for analytical applications. 
Never fear! <a href="https://github.com/d3/d3-collection#nest_rollup">d3.rollup</a> is here!

With <code>rollup</code>, you provide a function that takes the array of values for each group and it produces a value based on that array. 
This provides for some very flexible <em>group by</em> functionality.

Here is a simple one to get back the counts for each name:

<code>var expensesCount = d3.nest()
  .key(function(d) { return d.name; })
  .rollup(function(v) { return v.length; })
  .entries(expenses);
console.log(JSON.stringify(expensesCount));
</code>
<code>=&gt; [{"key":"jim","values":2},{"key":"carl","values":1},{"key":"stacy","values":3}]

</code>
<div class="aside">This code is using d3.js</div>

The individual records are gone (for better or worse) and in their place are the values returned by our rollup function. 
The naming stays the same (<em>key</em> and <em>values</em>) but the content is yours to specify. 
Note that the value passed into the <code>rollup</code> callback is the array of values for that key.

Here is another example where we get the average amount per person:

<code>var expensesAvgAmount = d3.nest()
  .key(function(d) { return d.name; })
  .rollup(function(v) { return d3.mean(v, function(d) { return d.amount; }); })
  .entries(expenses);
console.log(JSON.stringify(expensesAvgAmount));
</code>
<code>=&gt; [{"key":"jim","values":39.5},{"key":"carl","values":120.11},{"key":"stacy","values":30.3}]

</code>
<div class="aside">This code is using d3.js</div>

Pretty cool right? Any roll-up function you can think of, you can make happen. 
And you don't need to stop at just one. 
<code>rollup</code> can return an object, so you can easily produce multiple metrics on your groups.

<code>var expenseMetrics = d3.nest()
  .key(function(d) { return d.name; })
  .rollup(function(v) { return {
count: v.length,
total: d3.sum(v, function(d) { return d.amount; }),
avg: d3.mean(v, function(d) { return d.amount; })
  }; })
  .entries(expenses);
console.log(JSON.stringify(expenseMetrics));
</code>
<code>=&gt; [{"key":"jim","values":{"count":2,"total":79,"avg":39.5}},
 {"key":"carl","values":{"count":1,"total":120.11,"avg":120.11}},
 {"key":"stacy","values":{"count":3,"total":90.9,"avg":30.3}}]

</code>
<div class="aside">This code is using d3.js</div>

<h2>Object Output</h2>
The array output can be useful for using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map">map</a> or <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">forEach</a>. 
But you can also have <code>d3.nest</code> return an object of the results, for direct access. 
Note the use of <a href="https://github.com/d3/d3-collection#nest_object">nest.object</a> below.

<code>var expensesTotal = d3.nest()
  .key(function(d) { return d.name; })
  .rollup(function(v) { return d3.sum(v, function(d) { return d.amount; }); })
  .object(expenses);
console.log(JSON.stringify(expensesTotal));
</code>
<code>=&gt; {"jim":79,"carl":120.11,"stacy":90.9}

</code>
<div class="aside">This code is using d3.js</div>

And if you want to get real fancy, take a look at <a href="https://github.com/d3/d3-collection#nest_map">nest.map</a> for getting a <a href="https://github.com/d3/d3-collection#map">d3.map</a> instance back.

<h2>Multi-Level Nesting</h2>
And you thought that single-level nesting was cool. 
Wait till you try multiple levels!

By adding more keys, you can sub-divide your data even further. 
Here is expense sums by name and then by date:

<code>var expensesTotalByDay = d3.nest()
  .key(function(d) { return d.name; })
  .key(function(d) { return d.date; })
  .rollup(function(v) { return d3.sum(v, function(d) { return d.amount; }); })
  .object(expenses);
console.log(JSON.stringify(expensesTotalByDay));
</code>
<code>=&gt; {"jim":{"11/12/2015":34,"12/01/2015":45},
 "carl":{"11/12/2015":120.11},
 "stacy":{"01/04/2016":46.1,"01/05/2016":44.8}}

</code>
<div class="aside">This code is using d3.js</div>

Now the <code>rollup</code> callback is called for each of our smaller subgroups.

The order of the <code>nest.key</code> calls determines the order of the grouping. 
If we reverse our keys, we get the totals by date and then by name:

<code>var expensesTotalByDay = d3.nest()
  .key(function(d) { return d.date; })
  .key(function(d) { return d.name; })
  .rollup(function(v) { return d3.sum(v, function(d) { return d.amount; }); })
  .object(expenses);
console.log(JSON.stringify(expensesTotalByDay));
</code>
<code>=&gt; {"11/12/2015":{"jim":34,"carl":120.11},
 "12/01/2015":{"jim":45},
 "01/04/2016":{"stacy":46.1},
 "01/05/2016":{"stacy":44.8}}

</code>
<div class="aside">This code is using d3.js</div>

Here the values are the same, but the mapping might be more convenient, depending on the questions you are trying to answer.

<h2>Derived Key Values</h2>
Remember, we are specifying our key value using a function. 
This gives us the power to group on derived or otherwise on-the-fly keys.

For example, if we wanted to find out totals for all expenses for each year, we would just do some <a href="strings.html">basic string manipulation</a> on the date string:

<code>var expensesByYear = d3.nest()
  .key(function(d) { return d.date.split("/")[2]; })
  .rollup(function(v) { return d3.sum(v, function(d) { return d.amount; }); })
  .object(expenses);
console.log(JSON.stringify(expensesByYear));
</code>
<code>=&gt; {"2015":199.11,"2016":90.9}

</code>
<div class="aside">This code is using d3.js</div>

All this flexibility provides for a powerful toolkit for exploring your data.

<h2>Next Task</h2>
<a href="strings.html">Working with Strings</a>

<h2>See Also</h2>
<a href="http://bl.ocks.org/shancarter/raw/4748131/">Mister Nester</a> - a <code>d3.nest</code> power tool!

<a href="http://bl.ocks.org/phoebebright/raw/3176159/">Phoebe Bright Nest Tutorial</a> - lots more nest examples

</div>
<h2><span class="orange">Working with Strings</span></h2>
String cleaning is something you end up doing quite a lot. 
Hopefully this task will help make the process less painful. 
There are a near infinite transformations you might want to do with strings, so we won't get to everything, but this will serve as a starting point for common manipulations that will come up again and again.

We will start with generic JavaScript string functions and add in a bit of <a href="https://lodash.com/">lodash</a> magic to make things easier.

<h2>String Basics</h2>
Similar to arrays, the characters in strings are accessible via indexing

<code>var aChar = "Hello There!"[6];
console.log(aChar);
</code>
<code>=&gt; T</code>

Also, just like arrays, you have access to the powerful <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/slice">slice</a> method, which is used to extract sub-sections based on indexes.

<code>var aSlice = "Hello There!".slice(6,11);
console.log(aSlice);
</code>
<code>=&gt; There</code>

The sliced string goes up to - but not including - the last index.

And, of course, string concatenation is done in JavaScript using the <code>+</code> operator. 
Use parenthesis if you want to do actual arithmetic inside your concatenation.

<code>var orderNum = 8;
console.log("You are number " + (orderNum + 1) + " in line.");
</code>
<code>=&gt; You are number 9 in line.</code>

Check <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String">the documentation</a> for all the other basic tools.

<h2>Stripping Whitespace</h2>
Often, you are going to have some surrounding whitespace that you don't want corrupting the rest of your data. 
Reading CSV files gives a good example of this, as spaces are typically also used in conjunction with the commas to separate columns.

A data file like this:

<code>cities_spaced.csv:

city  ,state ,population,land area
  seattle  ,WA , 652405 ,83.9
new york,NY,8405837,  302.6</code>

When <a href="read_data.html">read in</a> can produce quite the messy dataset:

<code>d3.csv("data/cities_spaced.csv", function(data) {
  console.log(JSON.stringify(data));
});
</code>
<code>=&gt; [{"city  ":"  seattle  ","state ":"WA ","population":" 652405 ","land area":"83.9"},
{"city  ":"new york","state ":"NY","population":"8405837","land area":"  302.6"}]</code>
<div class="aside">This code is using d3.js</div>

Note the spaces in the property names as well as the values. 
In cases like this, it might be best to <a href="iterate_data.html">map</a> the data back to a clean version. 
Lodash's <a href="https://lodash.com/docs#trim">trim</a> can help. 
It removes that unsightly whitespace from the front and back of your strings.

Here is a version of the data loading function that removes whitespace. 
It uses

<code>d3.csv("data/cities_spaced.csv").then(function(data) {
  var clean = data.map(function(d) {
var cleanD = {};
d3.keys(d).forEach(function(k) {
  cleanD[_.trim(k)] = _.trim(d[k]);
});
return cleanD;
  });
  console.log(JSON.stringify(clean));
});
</code>
<code>=&gt; [{"city":"seattle","state":"WA","population":"652405","land area":"83.9"},
{"city":"new york","state":"NY","population":"8405837","land area":"302.6"}]</code>
<div class="aside">This code is using d3.js and lodash</div>

The strings are now clear of those pesky spaces.

<h2>Find and Replace</h2>
Extracting data from strings can sometimes mean extracting pieces of strings. 
Finding out if a string contains a keyword or sub-string of interest is a first step in quantifying the content of a body of text.

<a href="">indexOf</a> can be used to perform this searching. 
You pass it a sub-string, and it'll tell you the location in string you are calling it where that sub-string starts. 
<code>-1</code> is returned if the sub-string can't be found. 
You can use this to build a little string finder, by comparing the return value to <code>-1</code>.

<code>console.log("A man, a plan, a canal".indexOf("man") !== -1);
</code>
<code>=&gt; true</code>
<code>console.log("A man, a plan, a canal".indexOf("panama") !== -1);
</code>
<code>=&gt; false</code>

Replace is the butter to find's bread. 
We will see more replacing when we get to regular expressions, but replacing sections of a string can be done with the <a href="">replace</a> method.

<code>console.log("A man, a plan, a canal".replace("canal", ""));
</code>
<code>=&gt; "A man, a plan, a"</code>
<h2>Templating</h2>
When you need to create a more complicated string, such as an html snippet, it may
become too tedious to just combine strings by concatenating them with your variables. 
Consider
the following example:

<code class="lang-html">&lt;div class="person"&gt;
  &lt;span class="name"&gt;Birdman&lt;/span&gt;
  &lt;span class="occupation"&gt;Imaginary Super Hero&lt;/span&gt;
&lt;/div&gt;</code>

If we wanted to build it using string concatenation, it might look like this:

<code>var person = { name : "Birdman", occupation: "Imaginary Super Hero" };
var html_snippet = "&lt;div class=\"person\"&gt;" +
  "&lt;span class=\"name\"&gt;" + person.name + "&lt;/span&gt;" +
  "&lt;span class=\"occupation\"&gt;" + person.occupation + "&lt;/span&gt;" +
"&lt;/div&gt;";
console.log(html_snippet);
</code>
<code>=&gt; '&lt;div class="person"&gt;&lt;span class="name"&gt;Birdman&lt;/span&gt;&lt;span class="occupation"&gt;Imaginary Super Hero&lt;/span&gt;&lt;/div&gt;'</code>

That's a lot of string escaping! You can imagine this gets pretty hard to manage
after a while.

In order to simplify this process, you can use lodash templates to define a "template"
that you can reuse with different data. 
Using our example above, we might define it
like so:

<code>var templateString = "&lt;div class='person'&gt;" +
  "  &lt;span class='name'&gt;&lt;%= name %&gt;&lt;/span&gt;" +
  "  &lt;span class='occupation'&gt;&lt;%= occupation %&gt;&lt;/span&gt;" +
  "&lt;/div&gt;";
var templateFunction = _.template(templateString);
</code>

Now you can use this template function with lots of data to generate the
same snippet of html:

<code>console.log(templateFunction(person));
</code>
<code>=&gt; '&lt;div class="person"&gt;&lt;span class="name"&gt;Birdman&lt;/span&gt;&lt;span class="occupation"&gt;Imaginary Super Hero&lt;/span&gt;&lt;/div&gt;'</code>
<div class="aside">This code is using lodash</div>

<code>var anotherPerson = { name : "James. 
James Bond", occupation: "Spy" };
console.log(templateFunction(anotherPerson));
</code>
<code>=&gt; '&lt;div class="person"&gt;&lt;span class="name"&gt;James. 
James Bond&lt;/span&gt;&lt;span class="occupation"&gt;Spy&lt;/span&gt;&lt;/div&gt;'</code>
<h2>Next Task</h2>
<a href="regexes.html">Regular Expressions</a>

<h2>See Also</h2>
<a href="http://www.quirksmode.org/js/strings.html">Working With Strings</a> - a great guide to more string basics

<a href="https://github.com/epeli/underscore.string">underscore.string</a> - for all the other string functions you might want

<a href="http://underscorejs.org/#template">underscore.template</a> - for a deeper dive into underscore's template function

<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">ES2016's Template Literal syntax</a> that allows template string without the need for lodash/underscore if you use ES2016 or <a href="https://basarat.gitbooks.io/typescript/content/docs/template-strings.html">TypeScript</a>. 

</div>
<h2><span class="orange">Regular Expressions</span></h2>
Regular expressions are used to match certain patterns of strings within other strings.

They can be a useful tool for extracting <em>patterns</em> rather than exact strings, for example:
telephone numbers (sequences of numbers of a specific length,) street numbers or email
addresses.

<h2>Finding Strings</h2>
<code>var str = "how much wood would a woodchuck chuck if a woodchuck could chuck wood";
var regex = /wood/;
</code>

If we want to know whether the string "wood" appears in our larger string <code>str</code> we
could do the following

<code>if (regex.test(str)) {
  console.log("we found 'wood' in the string!");
}
</code>
<code>=&gt; "we found 'wood' in the string!"</code>

To see the actual matches we found in the string, we can use the <code>match</code> method
to find all matches available:

<code>var matches = str.match(regex);
console.log(matches);
</code>
<code>=&gt; ["wood"]</code>

Note that this only returned one match, even though the word "wood" appears several
times in our original string. 
In order to find all individual instances of wood, we need
to add the global flag, which we can do by adding a <code>g</code> to the end of our expression:

<code>regex = /wood/g;
console.log(str.match(regex));
</code>
<code>=&gt; ["wood", "wood", "wood", "wood"]</code>

Now, note that two of those matches actually belonged to the word "woodchuck", which
was not a part of our results. 
If we wanted to extend our regular expression to match both
we could do so in a few ways:

<code>regex = /wood.*?\b/g;
console.log(str.match(regex));
</code>
<code>=&gt; ["wood", "woodchuck", "woodchuck", "wood"]</code>

In this regular expression we are matching everything that starts with the string "wood"
followed by 0 or more characters (<code>.*?</code>) until a word break (<code>\b</code>) occures.
Alternatively, we could also just search for both words:

<code>regex = /woodchuck|wood/g;
console.log(str.match(regex));
</code>
<code>=&gt; ["wood", "woodchuck", "woodchuck", "wood"]</code>

Note the order in which we did the last search. 
We used the word "woodchuch" before
the word "wood". 
If we were to run our expression like so: <code>/wood|woodchuck/g</code>, we would
end up with <code>["wood", "wood", "wood", "wood"]</code> again because that search would be
"greedy".

<h2>Replacing with regular expressions</h2>
If we wanted to replace the word "wood" in our original string, with the word
"nun", we could do it like so:

<code>regex = /wood/g;
var newstr = str.replace(regex, "nun");
console.log(newstr);
</code>
<code>=&gt; "how much nun would a nunchuck chuck if a nunchuck could chuck nun"</code>

Probably not what you'd be going for, but you get our drift.

<h2>Finding Numbers</h2>
Extracting numbers from strings is a common task when looking for things like
dollar amounts or any other numerical measurements that might be scattered about
in the text.
For example, if we wanted to extract the total amount of money spent
on groceries from this message:

<code>var message = "I bought a loaf of bread for $3.99, some milk for $2.49 and" +
  "a box of chocolate cookies for $6.95";
</code>

we could define a regular expression that looks for dollar amounts by defining a
pattern like so.

<code>regex = /\$([0-9\.]+)\b/g;
</code>

this pattern looks for:

A dollar sign (<code>\$</code>) to indicate the beginning of a price

A set of repeating characters that can be a number (<code>0-9</code>) or the period character <code>.</code>. 
These can appear repeatedly (<code>+</code>). 
Note that we're not being particularly careful in making sure we only have one period in our string, for example.

A word break that would indicate the end of the price string (<code>\b</code>).

If we wanted to find all the matches, we could use our string <code>match</code> function like so:

<code>matches = message.match(regex);
console.log(matches);
</code>
<code>=&gt; ["$3.99", "$2.49", "$6.95"]</code>

This is great! We have all our dollar amounts. 
While this gets us 90% there, we
can't really add them with those <code>$</code> signs. 
To remove them, we can use our trusty
<code>reduce</code> function like so:

<code>matches.reduce(function(sum, value) {
  return sum + Number(value.slice(1));
}, 0);
</code>
<code>=&gt; 13.43</code>
<h2>Useful special characters</h2>
We've used a few special characters so far, like <code>\b</code> to indicate a word break. 
There
are a few others that might be useful to you:

<code>\d</code> - any number character. 
 Equivalent to [0-9].

<code>\D</code> - any non number character. 
Equivalent to [^0-9].

<code>\s</code> - any single space character. 
This includes a single space, tab, line feed or
form feed.

You can see a full list of all special characters here:
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions">MDN - Regular Expressions</a>

<h2>Next Task</h2>
<a href="time.html">Working With Time</a>

<h2>See Also</h2>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions">MDN - Regular Expressions</a> - for more information about regular expressions

</div>
<h2><span class="orange">Working with Time</span></h2>
Time is one of those tricky programming things that seems like it should be easy, but usually turns out not to be. 
We will use D3's built in <a href="https://github.com/d3/d3-time-format#timeParse">time parsing</a> and <a href="https://github.com/d3/d3-time#_interval">interval</a> functions. 
We will also take a look at the powerful <a href="http://momentjs.com/">Moment.js</a> library, for when you just need more time power.

<h2>String to Date</h2>
The first task when dealing with dates is usually getting a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date">Date object</a> out of a string. 
Most of the time, your data will have dates or times in an (mostly) arbitrary format, and you need to force that mess into an actual date.

D3 has <a href="https://github.com/d3/d3-time-format#timeParse">d3.timeParse</a> which provides a way to do this parsing. 
It was a little confusing for me the first time I tried it. 
You use this function to create a string parser, and then use the parser to actually convert the string.

In our <a href="group_data.html">nesting example</a>, we saw data that had dates as strings:

<code>var expense = {"name":"jim","amount":34,"date":"11/12/2015"};
</code>

To convert this date string to a Date object, we would need a parser that looks like:

<code>var parser = d3.timeParse("%m/%d/%Y");
</code>
<div class="aside">This code is using d3.js</div>

The input string to <code>d3.timeParse</code> indicates what the date string should look like. 
You have a <a href="https://github.com/d3/d3-time-format#locale_format">lot of options</a> for the special, percent-sign-prefixed variables. 
You can see in the string I'm using month, day, and four-digit year. 
The slashes in the format string are not special variables - but just what we expect to find separating the fields in the date string.

Next we use the parser to parse our string.

<code>expense.date = parser(expense.date);
console.log(expense);
</code>
<code>=&gt; {name: "jim", amount: 34, date: Thu Nov 12 2015 00:00:00 GMT-0500 (EST)}

</code>
<div class="aside">This code is using d3.js</div>

Note that the returned value of the <code>d3.timeParse</code> function is itself a function, so we can just pass our date string to this function directly.

Also note that the timezone is dependent on your local browser, so you might see a different value if you live in a different timezone.

Cool! Now our date is actually a Date object.

Here are a few more time parsers to show the capabilities of D3's parsing. 
Note again that we are creating a <code>d3.timeParse</code> function and then passing in a string to parse, this time all on one line.

Just the date:

<code>var date = d3.timeParse("%A, %B %-d, %Y")("Wednesday, November 12, 2014");
console.log(date);
</code>
<code>=&gt; Wed Nov 12 2014 00:00:00 GMT-0500 (EST)

</code>
<div class="aside">This code is using d3.js</div>

The little dash in front of the <code>d</code> is to remove the 0-padding)

<code>date = d3.timeParse("%m/%y")("12/14");
console.log(date);
</code>
<code>=&gt; Mon Dec 01 2014 00:00:00 GMT-0500 (EST)

</code>

You can see it defaults to the first day of the month.

Just the time:

<code>var time = d3.timeParse("%I:%M%p")("12:34pm");
console.log(time);
</code>
<code>=&gt; Mon Jan 01 1900 12:34:00 GMT-0500 (EST)

</code>
<div class="aside">This code is using d3.js</div>

Gives you a somewhat strange default date.

Date and time:

<code>time = d3.timeParse("%m/%d/%Y %H:%M:%S %p")("1/2/2014 8:22:05 AM");
console.log(time);
</code>
<code>=&gt; Thu Jan 02 2014 08:22:05 GMT-0500 (EST)

</code>
<div class="aside">This code is using d3.js</div>

This could also be done using some built in short-hands:

<code>time = d3.timeParse("%x %X")("1/2/2014 8:22:05 AM");
console.log(time);
</code>
<code>=&gt; Thu Jan 02 2014 08:22:05 GMT-0500 (EST)

</code>
<div class="aside">This code is using d3.js</div>

You can see that <code>d3.timeParse</code> gives you a lot of flexibility about what your time string will look like.

<h2>Modifying Time</h2>
In many cases, you might want to modify a date object. 
Perhaps you only want to display the hour from a date, or maybe you want to figure out what a week from now would be.

The <a href="https://github.com/d3/d3-time#_interval">d3.time</a> set of functions provides a starting point for these kinds of manipulations.

Intervals allow for modifying dates around specific time slices like minutes, hours, days, months, or years. 
We are given a number of functions to work with each interval, depending on what we might want to do.

So, to get the nearest hour from a date, we can use <a href="https://github.com/d3/d3-time#interval_round">d3.timeHour.round</a>

<code>var hourParser = d3.timeParse("%I:%M%p");
var time = hourParser("10:34pm");
var hour = d3.timeHour.round(time);
console.log(hour);
</code>
<code>=&gt; Mon Jan 01 1900 23:00:00 GMT-0500

</code>
<div class="aside">This code is using d3.js</div>

It returns a date object that just contains the nearest hour (11:00pm). 
We can display this by using a <a href="https://github.com/d3/d3-time-format#timeFormat">d3.timeFormat</a> to format the date object into a string.

<code>var hourFormater = d3.timeFormat("%I:%M%p")
console.log(hourFormater(hour));
</code>
<code>=&gt; 11:00PM

</code>
<h2>Moment.js</h2>
<a href="http://momentjs.com/">Moment.js</a> is another JavaScript library that could be better suited to your needs, if you happen to be doing a lot of time manipulations. 
Its syntax and capabilities seem a bit more intuitive for certain <a href="http://momentjs.com/docs/#/manipulating/">time manipulations</a>.

Check it out if you need more time control power!

<h2>Next Task</h2>
<a href="assumptions.html">Checking Data Assumptions</a>

<h2>See Also</h2>
<a href="http://momentjs.com/">moment.js</a>

</div>
<h2><span class="orange">Checking Data Assumptions</span></h2>
Data processing is tricky business, full of pitfalls and gotchas. 
Hopefully the tasks in this guide help with getting started in this process. 
But you, I, and the entire world will make mistakes. 
It's natural.

But mistakes in data processing, like all other kinds of mistakes, can be painful. 
They can result in hours of bug hunting, days of reprocessing, and months of crying. 
Since we know mistakes happen and will continue to happen, what can we do to take away some of the pain?

In a word, <em>padding</em>. 
We need some padding to protect us from the bumps and bruises of data processing. 
And I would suggest that this padding come in the form of simple tests that check the assumptions you have about the shape and contents of your data.

Unless there is an extreme performance need, these tests should run in the data processing pipeline. 
Optimally, they would be easy to turn on and off so that you can disable them if you need to if your code is deployed.

<h2>Assertions</h2>
These tests can be created with <a href="http://en.wikipedia.org/wiki/Assertion_%28software_development%29">assertions</a> - functions that check the truthiness of a statement in code. 
Typically, they raise an error when an expected truth is not actually true.

JavaScript doesn't have a built assertions, but we can rectify this deficiency with a simple function.

<code>function assert(isTrue, message) {
  if(!isTrue) {
console.log(message);
return false;
  }
  return true;
}
</code>

This will output a given message if the input is not true. 
Typically assertions <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/throw">throw</a> errors, but we can just log it for explaining purposes.

<h2>Data Content Assumptions</h2>
Now let's use our <code>assert</code> function to check some assumptions about the details of our data.

We can use lodash's suite of <a href="https://lodash.com/docs#isBoolean">type checking functions</a> to take care of performing the checks, passing the result of the check to <code>assert</code> to produce our errors.

Let's say our data importing process has made some mistakes:

<code>var data = [{"name":"Dan",
 "age":23,
 "superhuman":false},
{"name":"Sleepwalker",
  "age":NaN,
  "superhuman":"TRUE"}
];
</code>

Our first entry looks ok, where our second entry has some problems. 
The age parsing for the immortal <a href="http://en.wikipedia.org/wiki/Sleepwalker_%28comics%29">Sleepwalker</a> has left him with no age. 
Also, bad input data has left us with a string in <code>superhuman</code>, where we expect a boolean.

A simple assumption checking function that could be run on this data could look something like this:

<code>function checkDataContent(data) {
  data.forEach(function(d) {
var dString = JSON.stringify(d);
assert(_.isString(d.name), dString + " has a bad name - should be a string");
assert(_.isNumber(d.age), dString + " has a bad age - should be a number");
assert(!_.isNaN(d.age), dString + " has a bad age - should not be NaN");
assert(_.isBoolean(d.superhuman), dString + " has a bad superhuman - should be boolean");
  });
}

checkDataContent(data);
</code>
<code>=&gt; {"name":"Sleepwalker","age":null,"superhuman":"TRUE"} has a bad age - should not be NaN
{"name":"Sleepwalker","age":null,"superhuman":"TRUE"} has a bad superhuman - should be boolean

</code>
<div class="aside">This code is using lodash</div>

Again, the focus here is on detection of data problems. 
You want something quick and simple that will serve as an early warning sign.

Unfortunately, the JavaScript primitive <code>NaN</code> is indeed a number, and so additional checks need to be made. 
As more data comes in, this function will need to be updated to add more checks. 
This might get a bit tedious, but a little bit of checking can go a long way towards maintaining sanity.

<h2>Data Shape Assumptions</h2>
Just as you can test your assumptions about the content of your data elements, it can be a good idea to test your assumptions about the <em>shape</em> of your data. 
Here, shape just refers to the size and structure of your data. 
Rows and columns.

Something simple to perform this check could look like this:

<code>function checkDataShape(data) {
  assert(data.length &gt; 0, "data is empty");
  assert(data.length &gt; 4, "data is too small");
  var keys = d3.keys(data[0]);
  assert(keys.length === 4, "wrong number of columns");
}

checkDataShape(data);
</code>
<code>=&gt; data is too small
wrong number of columns

</code>

The two assumption functions could easily be combined into one, but it's important to look at both aspects of your data.

<h2>Data Equality Assumptions</h2>
Finally, its often useful to check assumptions about data objects being equal. 
Lodash comes to the rescue again with the <a href="https://lodash.com/docs/4.17.4#isEqual">isEqual</a> function:

<code>console.log(_.isEqual({ tea: 'green' }, { tea: 'green' }));

console.log(_.isEqual({ tea: 'earl' }, { tea: 'green' }));
</code>
<code>=&gt; true

false
</code>
<h2>More Assertions</h2>
If this is an approach that appeals to you, it might be worth exploring more powerful assertion libraries.

One such tool is <a href="http://chaijs.com/api/assert/">Chai</a> which comes with a great
collection of assertion helpers. 
These can help you check for more complicated things like whether
two objects are equal or whether an object has or doesn't have a property in a more succinct style.

<h2>Next Task</h2>
<a href="node.html">Using Node</a>

<h2>See Also</h2>
<a href="http://www.pgbovine.net/parsing-raw-data.htm">Parsing raw data</a> - a great guide that motivated this section

<a href="http://chaijs.com/api/assert/">Chai</a> - Chai's assert library

<a href="http://arasatasaygin.github.io/is.js/">is.js</a> - provides a great set of checking functions to complement lodash's set.

<a href="https://github.com/validate-io">validate.io</a> - provides a similar set of checking functions, but all as separate projects - so you can include only the checks you want to use.

</div>
<h2><span class="orange">Analyzing Data with Node</span></h2>
As mentioned in the <a href="getting_started.html">introduction</a>, this guide is mostly geared for client-side data analysis, but with a few augmentations, the same tools can be readily used server-side with <a href="https://nodejs.org/">Node</a>.

If the data is too large, this might in fact be your only option if you want to use JavaScript for your data analysis. 
Trying to deal with large data in the browser might result in your users having to wait for a long time. 
No user will wait for 5 minutes with a frozen browser, no matter how cool the analysis might be.

<h2>Setting up a Node Project</h2>
To get started with Node, ensure both node and <a href="https://www.npmjs.com/">npm</a>, the Node package manager, are installed and available via the command line:

<code class="lang-bash">which node
# /usr/local/bin/node
which npm
# /usr/local/bin/npm</code>

Your paths may be different then mine, but as long as <code>which</code> returns something, you should be good to go.

If node isn't installed on your machine, you can <a href="https://github.com/joyent/node/wiki/installing-node.js-via-package-manager#osx">install it easily via a package manager</a>.

Create a new directory for your data analysis project. 
In this example, we have a directory with a sub-directory called <code>data</code> which contains our <code>animals.tsv</code> file inside.

<code class="lang-bash">animals_analysis
|
 - data
   |
- animals.tsv</code>
<h2>Installing Node Modules</h2>
Next, we want to install our JavaScript tools, D3 and lodash. 
With Node, we can automate the process by using <code>npm</code>. 
Inside your data analysis directory run the following:

<code class="lang-bash">npm install d3
npm install lodash</code>

You can see that npm creates a new sub-directory called <code>node_modules</code> by default, where your packages are installed. 
Everything is kept local, so you don't have to worry about problems with missing or out-of-date packages. 
Your analysis tools for each project are ready to go.

A <code>package.json</code> file can be useful for saving this kind of meta information about your project: dependencies, name, description, etc. 
Check out this <a href="http://browsenpm.org/package.json">interactive example</a> or <a href="https://docs.npmjs.com/files/package.json">npm's documentation</a> for more information.

<h2>Requiring Modules</h2>
Now we create a separate JavaScript file to do our analysis in:

<code class="lang-bash">touch analyze.js</code>

Inside this file, we first <a href="http://openmymind.net/2012/2/3/Node-Require-and-Exports/">require</a> our external dependencies.

<code class="lang-js">var fs = require("fs");
var d3 = require("d3");
var _ = require("lodash");</code>

We are requiring our locally installed <code>d3</code> and <code>lodash</code> packages. 
Note how we assign them to variables, which are used to access their functions later in the code.

We also require the <a href="https://nodejs.org/api/fs.html">file system</a> module. 
As we will see in a second, we need this to load our data - which is really the key difference between client-side and server-side use of these tools

<h2>Loading Data in Node</h2>
D3's data loading functionality is based on <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a>, which is great, but Node does not have <code>XMLHttpRequest</code>. 
There are packages around this mismatch, but a more elegant solution is to just use Node's built in file system functionality to load the data, and then D3 to parse it.

<code class="lang-js">fs.readFile("data/animals.tsv", "utf8", function(error, data) {
  data = d3.tsvParse(data);
  console.log(JSON.stringify(data));
});</code>

<a href="https://nodejs.org/api/fs.html#fs_fs_readfile_filename_options_callback">fs.readFile</a> is asynchronous and takes a callback function when it is finished loading the data.

Like our Queue example in <a href="read_data.html">client-side reading</a>, the parameters of this function start with <code>error</code>, which will be <code>null</code> unless there is an error.

The data returned by <code>readFile</code> is the raw string contents of the file.

We can use <a href="https://github.com/d3/d3-dsv#tsvParseRows">d3.tsvParse</a> which takes a string and and converts it into an array of data objects - just like what we are used to on the client side!

From this point on, we can use d3 and lodash functionality to analyze our data.

A full, but very simple script might look like this:

<code class="lang-js">var fs = require("fs");
var d3 = require("d3");
var _  = require("lodash");

fs.readFile("data/animals.tsv", "utf8", function(error, data) {
  data = d3.tsvParse(data);
  console.log(JSON.stringify(data));

  var maxWeight = d3.max(data, function(d) { return d.avg_weight; });
  console.log(maxWeight);
});</code>
<h2>Running the Analysis</h2>
Since this is not in a browser, we need to execute this script, much like you would with a script written in Ruby or Python.

From the command line, we can simply run it with <code>node</code> to see the results.

<code class="lang-bash">node analyze.js</code>
<code>=&gt; [{"name":"tiger","type":"mammal","avg_weight":"260"},{"name":"hippo","type":"mammal","avg_weight":"3400"},{"name":"komodo dragon","type":"reptile","avg_weight":"150"}]
3400</code>
<h2>Writing Data</h2>
Maybe the original data set is too big, but we can use Node to perform an initial pre-processing or filtering step and output the result to a new file to work with later.

Node has <a href="https://nodejs.org/api/fs.html#fs_fs_writefile_filename_data_options_callback">fs.writeFile</a> that can perform this easily.

Inside the read callback, we can call this to write the data out.

<code class="lang-js">var bigAnimals = data.filter(function(d) { return d.avg_weight &gt; 300; });
bigAnimalsString = JSON.stringify(bigAnimals);

fs.writeFile("big_animals.json", bigAnimalsString, function(err) {
  console.log("file written");
});</code>

Running this should leave us with a <code>big_animals.json</code> file in our analysis folder.

This is fine if JSON is what you want, but often times you want to output TSV or CSV files for further analysis. 
D3 to the rescue again!

D3 includes <a href="https://github.com/d3/d3-dsv#csvFormat">d3.csvFormat</a> (and the equivalent for TSV and other file formats) which converts our array of data objects into a string - perfect for writing to a file.

Let's use it to make a CSV of our big animals.

<code class="lang-js">var bigAnimals = data.filter(function(d) { return d.avg_weight &gt; 300; });
bigAnimalsString = d3.csvFormat(bigAnimals);

fs.writeFile("big_animals.csv", bigAnimalsString, function(err) {
  console.log("file written");
});</code>

Run this with the same <code>node analysis.js</code> and now you should have a lovely little <code>big_animals.csv</code> file in your directory. 
It even takes care of the headers for you:

<code>name,type,avg_weight
hippo,mammal,3400</code>

Now even <a href="https://medium.com/@wtrsld/big-data-made-me-do-it-5bfc3f46871c">BIG data</a> is no match for us - using the power of JavaScript!

<script src='https://williamkpchan.github.io/LibDocs/readbook.js'></script>
<script>
var lazyLoadInstance = new LazyLoad({
    elements_selector: ".lazy"
    // ... more custom settings?
});
</script></pre>
</body></html>