<base target="_blank"><html><head><title>ESP 32 page 1</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src="https://williamkpchan.github.io/lazyload.min.js"></script>
<script src='https://williamkpchan.github.io/mainscript.js'></script>
<script src="https://williamkpchan.github.io/commonfunctions.js"></script>
<script>
var showTopicNumber = true;
var topicEnd = "<br>";
var bookid = "ESP 32 page 1"
var markerName = "h2"
</script>
<style>
body{width:80%;margin-left: 10%; font-size:24px;}
h1, h2 {color: gold;}
strong {color: orange;}
img {width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%;-radius:3px;}
k {color: #205080;}
</style></head><body onkeypress="chkKey()"><center>

<div id="toc"></div></center>
<pre>
<h2>WebSocket Server: Display Sensor Readings</h2>
In this guide, you'll learn how to create a WebSocket server with the ESP32 to display sensor readings on a web page. Whenever the ESP32 has new readings available, the web page is updated automatically without the need to manually refresh it.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/04/ESP32-Websocket-Server-Sensor-Readings.jpg">
<h3>Introducing WebSocket Protocol</h3>
A WebSocket is a persistent connection between a client and a server that allows bidirectional communication between both parties using a TCP connection. This means you can send data from the client to the server and from the server to the client at any given time. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/10/ESP3-ESP82662-WebSocket-Server-How-it-Works-f.png">
The client establishes a WebSocket connection with the server through a process known as <em>WebSocket handshake</em>. The handshake starts with an HTTP request/response, allowing servers to handle HTTP connections as well as WebSocket connections on the same port. Once the connection is established, the client and the server can send WebSocket data in full duplex mode.
Using the WebSockets protocol, the server (ESP32 board) can send information to the client or to all clients without being requested. This also allows us to send information to the web browser when a change occurs.
This change can be something that happened on the web page (you clicked a button) or something that happened on the ESP32 side like pressing a physical button on a circuit, or new sensor readings available.
Learn how to control the ESP32 outputs via WebSocket protocol: <a href="https://randomnerdtutorials.com/esp32-websocket-server-arduino/">ESP32 WebSocket Server: Control Outputs (Arduino IDE)</a>.
<h3>Project Overview</h3>
Here's the web page we'll build for this project.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/04/ESP-Websocket-Server-Display-Sensor-Readings-Web-Browser-ESP32.png">
We'll create a web page that displays temperature, humidity, and pressure.
The web page displays the latest sensor readings when you open or refresh the web page.
The sensor readings update automatically whenever there's a new reading available on the ESP32 without the need to refresh the webpage.
The web server works perfectly on multiple clients (multiple web browser tabs on the same device or different devices).
<h3>How does it work?</h3>
The ESP hosts a web server that displays a web page with three cards for the sensor readings.
When you open the webpage, it sends a message (getReadings) to the ESP via WebSocket protocol. The server (ESP) receives that message. When that happens, it gets new readings from the sensors and sends them back to the client (web browser), also via web socket protocol. This way, whenever you open a new tab, it always shows the current and updated values.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/04/Websocket-Server-ESP32-sensor-readings-how-it-works-1.png">
Every 30 seconds, the ESP gets new readings and sends them to all connected clients (all web browser tabs opened) via WebSocket protocol. The client receives that message and displays the readings on the web page.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/04/Websocket-Server-ESP32-sensor-readings-how-it-works.png">
<h3>Prerequisites</h3>
Before proceeding with this tutorial, make sure you check all the following prerequisites.
<h3>1) Parts Required</h3>
To follow this project you need:
<a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32 Board</a>  read <a href="https://makeradvisor.com/esp32-development-boards-review-comparison/" target="_blank" rel="noopener" title="">ESP32 Development Boards Review and Comparison</a>
<a href="https://makeradvisor.com/tools/bme280-sensor-module/" target="_blank">BME280 sensor module</a>  check the <a href="https://randomnerdtutorials.com/esp32-bme280-arduino-ide-pressure-temperature-humidity/" title="">BME280 getting started guide with the ESP32</a>
<a href="https://makeradvisor.com/tools/mb-102-solderless-breadboard-830-points/" target="_blank">Breadboard</a>
<a href="https://makeradvisor.com/tools/jumper-wires-kit-120-pieces/" target="_blank">Jumper wires</a>
For this example, we'll use a BME280 sensor, but you can use any other sensor you're familiar with.
You can use the preceding links or go directly to <a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank">MakerAdvisor.com/tools</a> to find all the parts for your projects at the best price!
<a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/header-200.png?w=828&quality=100&strip=all&ssl=1" data-recalc-dims="1" loading="lazy" fetchpriority="low"></a>
<h3>2) Arduino IDE and ESP32 Boards Add-on</h3>
We'll program the ESP32 using Arduino IDE. So, you must have the ESP32 add-on installed. Follow the next tutorial if you haven't already:
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing ESP32 Board in Arduino IDE (Windows, Mac OS X, Linux)</a>
If you want to use VS Code with the PlatformIO extension, follow the next tutorial instead to learn how to program the ESP32:
<a href="https://randomnerdtutorials.com/vs-code-platformio-ide-esp32-esp8266-arduino/">Getting Started with VS Code and PlatformIO IDE for ESP32 and ESP8266 (Windows, Mac OS X, Linux Ubuntu)</a>
<h3>3) Filesystem Uploader Plugin</h3>
To upload the HTML, CSS, and JavaScript files needed to build this project to the ESP32 flash memory (SPIFFS), we'll use a plugin for Arduino IDE: <k>SPIFFS</k> <k>Filesystem uploader</k>. Follow the next tutorial to install the filesystem uploader plugin if you haven't already:
<a href="https://randomnerdtutorials.com/install-esp32-filesystem-uploader-arduino-ide/">ESP32: Install SPIFFS FileSystem Uploader Plugin in Arduino IDE</a>
If you're using VS Code with the PlatformIO extension, read the following tutorial to learn how to upload files to the filesystem:
<a href="https://randomnerdtutorials.com/esp32-vs-code-platformio-spiffs/">ESP32 with VS Code and PlatformIO: Upload Files to Filesystem (SPIFFS)</a>
<h3>4) Libraries</h3>
To build this project, you need to install the following libraries:
<a style="font-size: inherit;" href="https://github.com/arduino-libraries/Arduino_JSON" target="_blank">Arduino_JSON library by Arduino version 0.1.0</a> (Arduino Library Manager)
<a href="https://github.com/adafruit/Adafruit_BME280_Library" target="_blank" rel="noopener" title="">Adafruit_BME280</a> (Arduino Library Manager)
<a href="https://github.com/me-no-dev/ESPAsyncWebServer" target="_blank">ESPAsyncWebServer</a> (.zip folder)
<a href="https://github.com/me-no-dev/AsyncTCP" target="_blank">AsyncTCP</a> (.zip folder)
You can install the first two libraries using the Arduino Library Manager. Go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k> and search for the library name.
The ESPAsyncWebServer and AsynTCP libraries aren't available to install through the Arduino Library Manager, so you need to copy the library files to the Arduino Installation Libraries folder. Alternatively, in your Arduino IDE, you can go to <k>Sketch</k>> <k>Include Library</k> > <k>Add .zip Library</k> and select the libraries you've just downloaded.
<h4>Installing Libraries (VS Code + PlatformIO)</h4>
If you're programming the ESP32 using PlatformIO, you should add the following lines to the platformio.ini file to include the libraries (also change the Serial Monitor speed to 115200):
<k>platform = <a href="/cdn-cgi/l/email-protection" data-cfemail="1f7a6c6f6d7a6c6c76792c2d5f2c312a312f">[email protected]</a>
board = esp32doit-devkit-v1
framework = arduino
monitor_speed = 115200
lib_deps = ESP Async WebServer
    arduino-libraries/Arduino_JSON @ 0.1.0
    adafruit/Adafruit BME280 Library @ ^2.1.0
    adafruit/Adafruit Unified Sensor @ ^1.1.4</k>
<h3>Building the Circuit</h3>
To exemplify how to display sensor readings on a web server with the ESP32, we'll send sensor readings from a BME280 sensor to the browser. So, you need to wire a BME280 sensor to your ESP32. You can also use any other sensor you're familiar with.
<h3>Schematic Diagram</h3>
We're going to use I2C communication with the BME280 sensor module. For that, wire the sensor to the default ESP32 SCL (GPIO 22) and SDA (GPIO 21) pins, as shown in the following schematic diagram.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/10/ESP32-BME280-Sensor-Temperature-Humidity-Pressure-Wiring-Diagram-Circuit_f.png">
Recommended reading: <a href="https://randomnerdtutorials.com/esp32-pinout-reference-gpios/">ESP32 Pinout Reference: Which GPIO pins should you use?</a>
<h3>Organizing Your Files</h3>
To keep the project organized and make it easier to understand, we'll create four files to build the web server:
Arduino sketch: to get the sensor readings and handle the web server;
index.html: to define the content of the web page to display the sensor readings;
style.css: to style the web page;
script.js: to program the behavior of the web pagehandle what happens when you open the web page and display the readings received via WebSocket protocol.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/04/Sensor-readings-Multiple-Series-Organizing-Files.png">
You should save the HTML, CSS, and JavaScript files inside a folder called <em><k>data</k> </em>inside the Arduino sketch folder, as shown in the previous diagram. We'll upload these files to the ESP32 filesystem (SPIFFS).
<k>You can download all project files:</k>
<k><a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_Sensor_Readings_WebSocket/ESP32_Sensor_Readings_WebSocket.zip" target="_blank" rel="noopener" title="">Download all the project files</a></k>
<h3>HTML File</h3>
Copy the following to the index.html file.
<k>&lt;!DOCTYPE html>
&lt;html>
    &lt;head>
        &lt;title>ESP IOT DASHBOARD&lt;/title>
        &lt;meta name="viewport" content="width=device-width, initial-scale=1">
        &lt;link rel="icon" type="image/png" href="favicon.png">
        &lt;link rel="stylesheet" type="text/css" href="style.css">
    &lt;/head>
    &lt;body>
        &lt;div>
            &lt;h1>SENSOR READINGS (WEBSOCKET)&lt;/h2>
        &lt;/div>
        &lt;div>
            &lt;div>
                &lt;div>
                    &lt;p>&lt;i style="color:#059e8a;">&lt;/i> Temperature&lt;/p>
                    &lt;p>&lt;span>&lt;/span> &deg;C&lt;/p>
                &lt;/div>
                &lt;div>
                    &lt;p> Humidity&lt;/p>
                    &lt;p>&lt;span>&lt;/span> &percnt;&lt;/p>
                &lt;/div>
                &lt;div>
                    &lt;p> Pressure&lt;/p>
                    &lt;p>&lt;span>&lt;/span> hpa&lt;/p>
                &lt;/div>
            &lt;/div>
        &lt;/div>
        &lt;script src="script.js">&lt;/script>
    &lt;/body>
&lt;/html></k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_Sensor_Readings_WebSocket/data/index.html" target="_blank">View raw code</a>
We won't go into much detail about the content of the HTML file. Just the relevant parts.
The following lines display a card for the temperature.
<k>&lt;div>
    &lt;p>&lt;i style="color:#059e8a;">&lt;/i> Temperature&lt;/p>
    &lt;p>&lt;span>&lt;/span> &deg;C&lt;/p>
&lt;/div></k>
The temperature will show up in the following paragraph between the &lt;span> tags. Notice that you need a unique id for that HTML tag so that later we know how to refer to this HTML element. In this case, the unique id is temperature.
<k>&lt;span>&lt;/span></k>
We do a similar procedure for the humidity and pressure. The unique ids for the HTML elements where we'll display the humidity and pressure are humidity and pressure.
<k>&lt;div>
      &lt;p> Humidity&lt;/p>
      &lt;p>&lt;span>&lt;/span> &percnt;&lt;/p>
&lt;/div>
&lt;div>
    &lt;p> Pressure&lt;/p>
    &lt;p>&lt;span>&lt;/span> hpa&lt;/p>
&lt;/div></k>
<h3>CSS File</h3>
Copy the following to the style.css file.  Feel free to change it to make the web page look as you wish. We won't explain how the CSS for this web page works because it is not relevant for this tutorial.
<k>html {
    font-family: Arial, Helvetica, sans-serif;
    display: inline-block;
    text-align: center;
}
h1 {
    font-size: 1.8rem;
    color: white;
}
.topnav {
    overflow: hidden;
    background-color: #0A1128;
}
body {
    margin: 0;
}
.content {
    padding: 50px;
}
.card-grid {
    max-width: 800px;
    margin: 0 auto;
    display: grid;
    grid-gap: 2rem;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
}
.card {
    background-color: white;
    box-shadow: 2px 2px 12px 1px rgba(140,140,140,.5);
}
.card-title {
    font-size: 1.2rem;
    font-weight: bold;
    color: #034078
}
.reading {
    font-size: 1.2rem;
    color: #1282A2;
}</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_Sensor_Readings_WebSocket/data/style.css" target="_blank">View raw code</a>
<h3>JavaScript File</h3>
Copy the following to the script.js file.
<k>
var gateway = `ws://${window.location.hostname}/ws`;
var websocket;
// Init web socket when the page loads
window.addEventListener('load', onload);
function onload(event) {
    initWebSocket();
}
function getReadings(){
    websocket.send("getReadings");
}
function initWebSocket() {
    console.log('Trying to open a WebSocket connection');
    websocket = new WebSocket(gateway);
    websocket.onopen = onOpen;
    websocket.onclose = onClose;
    websocket.onmessage = onMessage;
}
// When websocket is established, call the getReadings() function
function onOpen(event) {
    console.log('Connection opened');
    getReadings();
}
function onClose(event) {
    console.log('Connection closed');
    setTimeout(initWebSocket, 2000);
}
// Function that receives the message from the ESP32 with the readings
function onMessage(event) {
    console.log(event.data);
    var myObj = JSON.parse(event.data);
    var keys = Object.keys(myObj);
    for (var i = 0; i &lt; keys.length; i++){
        var key = keys[i];
        document.getElementById(key).innerHTML = myObj[key];
    }
}</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_Sensor_Readings_WebSocket/data/script.js" target="_blank">View raw code</a>
Here's a list of what this code does:
initializes a WebSocket connection with the server;
sends a message to the server to get the current sensor readings;
uses the response to update the sensor readings on the web page;
handles data exchange through the WebSocket protocol.
Let's take a look at this JavaScript code to see how it works.
The gateway is the entry point to the WebSocket interface. window.location.hostname gets the current page address (the web server IP address).
<k>var gateway = ws://${window.location.hostname}/ws;</k>
Create a new global variable called websocket.
<k>var websocket;</k>
Add an event listener that will call the onload function when the web page loads.
<k>window.addEventListener('load', onload);</k>
The onload() function calls the initWebSocket() function to initialize a WebSocket connection with the server.
<k>function onload(event) {
  initWebSocket();
}</k>
The initWebSocket() function initializes a WebSocket connection on the gateway defined earlier. We also assign several callback functions for when the WebSocket connection is opened, closed, or when a message is received. 
<k>function initWebSocket() {
  console.log('Trying to open a WebSocket connection');
  websocket = new WebSocket(gateway);
  websocket.onopen = onOpen;
  websocket.onclose = onClose;
  websocket.onmessage = onMessage;
}</k>
Note that when the WebSocket connection is open, we'll call the getReadings function.
<k>function onOpen(event) {
  console.log('Connection opened');
  getReadings();
}</k>
The getReadings() function sends a message to the server getReadings to get the current sensor readings. Then, we must handle what happens when we receive that message on the server side (ESP32).
<k>function getReadings(){
  websocket.send("getReadings");
}</k>
We handle the messages received via WebSocket protocol on the onMessage() function.
<k>// Function that receives the message from the ESP32 with the readings
function onMessage(event) {
  console.log(event.data);
  var myObj = JSON.parse(event.data);
  var keys = Object.keys(myObj);
  for (var i = 0; i &lt; keys.length; i++){
    var key = keys[i];
    document.getElementById(key).innerHTML = myObj[key];
  }
}</k>
The server sends the readings in JSON format, for example:
<k>{
  temperature: 20;
  humidity: 50;
  pressure: 1023;
}</k>
The onMessage() function simply goes through all the key values (temperature, humidity, and pressure) and places them in the corresponding places on the HTML page. In this case, the keys have the same name as the ids we've defined on the HTML page. So, we can simply do something like this:
<k>for (var i = 0; i &lt; keys.length; i++){
  var key = keys[i];
  document.getElementById(key).innerHTML = myObj[key];
}</k>
<h3>Code for ESP32 WebSocket Server (Sensor Readings)</h3>
Copy the following code to your Arduino IDE.
<k>/*********
  Rui Santos
  Complete instructions at https://RandomNerdTutorials.com/esp32-websocket-server-sensor/
  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files.
  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
*********/
#include &lt;Arduino.h>
#include &lt;WiFi.h>
#include &lt;AsyncTCP.h>
#include &lt;ESPAsyncWebServer.h>
#include "SPIFFS.h"
#include &lt;Arduino_JSON.h>
#include &lt;Adafruit_BME280.h>
#include &lt;Adafruit_Sensor.h>
// Replace with your network credentials
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
// Create AsyncWebServer object on port 80
AsyncWebServer server(80);
// Create a WebSocket object
AsyncWebSocket ws("/ws");
// Json Variable to Hold Sensor Readings
JSONVar readings;
// Timer variables
unsigned long lastTime = 0;
unsigned long timerDelay = 30000;
// Create a sensor object
Adafruit_BME280 bme;
// Init BME280
void initBME(){
  if (!bme.begin(0x76)) {
    Serial.println("Could not find a valid BME280 sensor, check wiring!");
    while (1);
  }
}
// Get Sensor Readings and return JSON object
String getSensorReadings(){
  readings["temperature"] = String(bme.readTemperature());
  readings["humidity"] =  String(bme.readHumidity());
  readings["pressure"] = String(bme.readPressure()/100.0F);
  String jsonString = JSON.stringify(readings);
  return jsonString;
}
// Initialize SPIFFS
void initSPIFFS() {
  if (!SPIFFS.begin(true)) {
    Serial.println("An error has occurred while mounting SPIFFS");
  }
  Serial.println("SPIFFS mounted successfully");
}
// Initialize WiFi
void initWiFi() {
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  Serial.print("Connecting to WiFi ..");
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print('.');
    delay(1000);
  }
  Serial.println(WiFi.localIP());
}
void notifyClients(String sensorReadings) {
  ws.textAll(sensorReadings);
}
void handleWebSocketMessage(void *arg, uint8_t *data, size_t len) {
  AwsFrameInfo *info = (AwsFrameInfo*)arg;
  if (info->final && info->index == 0 && info->len == len && info->opcode == WS_TEXT) {
    //data[len] = 0;
    //String message = (char*)data;
    // Check if the message is "getReadings"
    //if (strcmp((char*)data, "getReadings") == 0) {
      //if it is, send current sensor readings
      String sensorReadings = getSensorReadings();
      Serial.print(sensorReadings);
      notifyClients(sensorReadings);
    //}
  }
}
void onEvent(AsyncWebSocket *server, AsyncWebSocketClient *client, AwsEventType type, void *arg, uint8_t *data, size_t len) {
  switch (type) {
    case WS_EVT_CONNECT:
      Serial.printf("WebSocket client #%u connected from %s\n", client->id(), client->remoteIP().toString().c_str());
      break;
    case WS_EVT_DISCONNECT:
      Serial.printf("WebSocket client #%u disconnected\n", client->id());
      break;
    case WS_EVT_DATA:
      handleWebSocketMessage(arg, data, len);
      break;
    case WS_EVT_PONG:
    case WS_EVT_ERROR:
      break;
  }
}
void initWebSocket() {
  ws.onEvent(onEvent);
  server.addHandler(&ws);
}
void setup() {
  Serial.begin(115200);
  initBME();
  initWiFi();
  initSPIFFS();
  initWebSocket();
  // Web Server Root URL
  server.on("/", HTTP_GET, [](AsyncWebServerRequest *request) {
    request->send(SPIFFS, "/index.html", "text/html");
  });
  server.serveStatic("/", SPIFFS, "/");
  // Start server
  server.begin();
}
void loop() {
  if ((millis() - lastTime) > timerDelay) {
    String sensorReadings = getSensorReadings();
    Serial.print(sensorReadings);
    notifyClients(sensorReadings);
  lastTime = millis();
  }
  ws.cleanupClients();
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_Sensor_Readings_WebSocket/ESP32_Sensor_Readings_WebSocket.ino" target="_blank">View raw code</a>
<h3>How the Code Works</h3>
Continue reading to learn how the code works, or skip to the demonstration section.
<h4>Including Libraries</h4>
The Adafruit_Sensor and Adafruit_BME280 libraries are needed to interface with the BME280 sensor.
<k>#include &lt;Adafruit_BME280.h>
#include &lt;Adafruit_Sensor.h></k>
The WiFi, ESPAsyncWebServer and AsyncTCP libraries are used to create the web server.
<k>#include &lt;WiFi.h>
#include &lt;AsyncTCP.h>
#include &lt;ESPAsyncWebServer.h></k>
We'll save the HTML, CSS, and JavaScript files on the ESP32 filesystem, so we also need to include the SPIFFS.h library.
<k>#include "SPIFFS.h"</k>
To create JSON objects, we'll use the Arduino_JSON library.
<k>#include &lt;Arduino_JSON.h></k>
<h4>Network Credentials</h4>
Insert your network credentials in the following variables, so that the ESP32 can connect to your local network using Wi-Fi.
<k>const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
<h4>AsyncWebServer and AsyncWebSocket</h4>
Create an AsyncWebServer object on port 80.
<k>AsyncWebServer server(80);</k>
The following line creates a new websocket object on /ws.
<k>// Create a WebSocket object
AsyncWebSocket ws("/ws");</k>
<h4>Timer Variables</h4>
The following variables are used to create timers in our code. In our case, we'll send sensor readings to the client via WebSocket protocol every 30000 milliseconds (30 seconds). You can change the timerDelay variable to any other value that makes sense for your project.
<k>// Timer variables
unsigned long lastTime = 0;
unsigned long timerDelay = 30000;</k>
<h4>Initializing the BME280 Sensor</h4>
The following line creates an Adafruit_BME280 object to refer to the sensor called bme.
<k>// Create a sensor object
Adafruit_BME280 bme;</k>
The initBME() function initializes the sensor. It will be called later in the setup().
<k>// Init BME280
void initBME(){
  if (!bme.begin(0x76)) {
    Serial.println("Could not find a valid BME280 sensor, check wiring!");
    while (1);
  }
}</k>
<h4>Getting Sensor Readings (JSON String)</h4>
The getSensoreadings() function creates a JSON string with the current sensor readings.
<k>// Get Sensor Readings and return JSON object
String getSensorReadings(){
  readings["temperature"] = String(bme.readTemperature());
  readings["humidity"] = String(bme.readHumidity());
  readings["pressure"] = String(bme.readPressure()/100.0F);
  String jsonString = JSON.stringify(readings);
  return jsonString;
}</k>
<h4>Initializing the Filesystem</h4>
The initSPIFFS() function initializes SPIFFS, the ESP32 filesystem we're using in this project to save the HTML, CSS, and Javascript files.
<k>// Initialize SPIFFS
void initSPIFFS() {
  if (!SPIFFS.begin(true)) {
    Serial.println("An error has occurred while mounting SPIFFS");
  }
  Serial.println("SPIFFS mounted successfully");
}</k>
<h4>Initializing Wi-Fi</h4>
The following function initializes Wi-Fi and connects to your network using the credentials you used previously. This function will be called later in the setup().
<k>// Initialize WiFi
void initWiFi() {
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  Serial.print("Connecting to WiFi ..");
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print('.');
    delay(1000);
  }
  Serial.println(WiFi.localIP());
}</k>
<h4>Notifying all Clients Via WebSocket</h4>
The notifyClients() function notifies all clients with the current sensor readings. Calling this function is what allows us to notify changes in all clients whenever we get new sensor readings (every 30 seconds).
<k>void notifyClients(String sensorReadings) {
  ws.textAll(sensorReadings);
}</k>
<h4>Handling WebSocket Messages</h4>
The handleWebSocketMessage(), as the name suggests, handles what happens when the server receives a message from the client via WebSocket protocol. We've seen in the JavaScript file, that the server can receive the getReadings message.
When the ESP32 receives the getReadings message, it sends the current sensor readings.
<k>void handleWebSocketMessage(void *arg, uint8_t *data, size_t len) {
  AwsFrameInfo *info = (AwsFrameInfo*)arg;
  if (info->final && info->index == 0 && info->len == len && info->opcode == WS_TEXT) {
    data[len] = 0;
    String message = (char*)data;
    //Check if the message is "getReadings"
    if (strcmp((char*)data, "getReadings") == 0) {
      if it is, send current sensor readings
      String sensorReadings = getSensorReadings();
      Serial.print(sensorReadings);
      notifyClients(sensorReadings);
    }
  }
}</k>
<h4>Handling WebSocket Events</h4>
The onEvent() function handles other WebSocket events.
<k>void onEvent(AsyncWebSocket *server, AsyncWebSocketClient *client, AwsEventType type, void *arg, uint8_t *data, size_t len) {
  switch (type) {
    case WS_EVT_CONNECT:
      Serial.printf("WebSocket client #%u connected from %s\n", client->id(), client->remoteIP().toString().c_str());
      break;
    case WS_EVT_DISCONNECT:
      Serial.printf("WebSocket client #%u disconnected\n", client->id());
      break;
    case WS_EVT_DATA:
      handleWebSocketMessage(arg, data, len);
      break;
    case WS_EVT_PONG:
    case WS_EVT_ERROR:
      break;
  }
}</k>
<h4>Initializing WebSocket Protocol</h4>
The initWebSocket() function initializes the WebSocket protocol.
<k>void initWebSocket() {
  ws.onEvent(onEvent);
  server.addHandler(&ws);
}</k>
<h4>setup()</h4>
In the setup(), we initialize the Serial Monitor, the BME280 sensor, Wi-Fi, the filesystem, and the WebSocket protocol by calling the functions we've created previously.
<k>Serial.begin(115200);
initBME();
initWiFi();
initSPIFFS();
initWebSocket();</k>
The following lines will serve the index.html and the other referenced static files saved on SPIFFS (style.css and script.js) when you access the web server.
<k>// Web Server Root URL
server.on("/", HTTP_GET, [](AsyncWebServerRequest *request) {
  request->send(SPIFFS, "/index.html", "text/html");
});
server.serveStatic("/", SPIFFS, "/");</k>
Finally, start the server.
<k>// Start server
server.begin();</k>
<h4>loop()</h4>
In the loop(), we get and send new sensor readings every 30000 milliseconds (30 seconds).
<k>void loop() {
  if ((millis() - lastTime) > timerDelay) {
    String sensorReadings = getSensorReadings();
    Serial.print(sensorReadings);
    notifyClients(sensorReadings);
    lastTime = millis();
  }
  ws.cleanupClients();
}</k>
<h3>Upload Code and Files</h3>
After inserting your network credentials, save the code. Go to <k>Sketch</k> > <k>Show Sketch Folder</k>, and create a folder called <k>data</k>. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/12/Arduino-IDE-Show-sketch-folder.png">
Inside that folder, you should place the HTML, CSS, and JavaScript files.
Upload those files to the filesystem: go to <k>Tools </k>> <k>ESP32 Data Sketch Upload</k> and wait for the files to be uploaded.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/12/ESP32-Sketch-Data-Upload.png">
Then, upload the code to your ESP32 board. Make sure you modified the code with your network credentials.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/upload-button-arduino-ide.png">
When everything is successfully uploaded, open the Serial Monitor at a baud rate of 115200. Press the ESP32 EN/RST button, and it should print the ESP32 IP address.
<h3>Demonstration</h3>
Open a browser on your local network and paste the ESP32 IP address. You should get access to the web server page that displays the sensor readings.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/04/ESP-Websocket-Server-Display-Sensor-Readings-Web-Browser-ESP32.png">
The readings update automatically on the web page every 30 seconds.
You can have multiple clients on different web browser tabs or devices and it will update automatically on all clients.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/04/websocket-server-sensor-readings-ESP32-demonstration-1.png">
<h3>Wrapping Up</h3>
In this tutorial, you've learned how to build a websocket server with the ESP32 that serves a web page to display sensor readings. The sensor readings update automatically on the web page without the need to manually refresh it.
We hope you learned a lot from this tutorial. Let us know in the comments below if you successfully followed this tutorial and got the project working. 

<h2>CAM: Take and Send Photos via Email using an SMTP Server</h2>
This tutorial shows how to send captured photos from the ESP32-CAM to your email account using an <a href="https://randomnerdtutorials.com/esp32-send-email-smtp-server-arduino-ide/">SMTP Server</a>. We'll show you a simple example that takes a photo when the ESP32 boots and sends it as an attachment in an email. The last photo taken is temporarily saved in the ESP32 LittleFS filesystem.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/06/ESP32-CAM-Send-Email-1024x576.jpg">
<em>Updated 19 September 2023.</em>
To make this project work, the ESP32-CAM needs to be connected to a router with access to the internet  needs to be connected to your local network.
This project is compatible with any <a href="https://makeradvisor.com/esp32-camera-cam-boards-review-comparison/" target="_blank">ESP32 camera board with the OV2640 camera</a>. You just need to make sure you use the right pin assignment for the board you're using: <a href="https://randomnerdtutorials.com/esp32-cam-camera-pin-gpios/">ESP32-CAM Camera Boards: Pin and GPIOs Assignment Guide</a>.
<h3>ESP Mail Client Library</h3>
To send emails with the <a href="https://makeradvisor.com/tools/esp32-cam/" target="_blank">ESP32-CAM</a>, we'll use the <a href="https://github.com/mobizt/ESP-Mail-Client" target="_blank">ESP-Mail-Client library</a>. This library allows the ESP32 to send and receive emails with or without attachments via SMTP and IMAP servers. 
In this project, we'll use <a href="https://randomnerdtutorials.com/esp32-send-email-smtp-server-arduino-ide/">SMTP</a> to send an email with an attachment. The attachment is a photo taken with the ESP32-CAM.
SMTP means Simple Mail Transfer Protocol and it is an internet standard for email transmission. To send emails through code, you need to know your SMTP server details. Each email provider has a different SMTP server.
<k>Installing the ESP-Mail-Client Library</k>
Before proceeding with this tutorial, you need to install the <a href="https://github.com/mobizt/ESP-Mail-Client" target="_blank">ESP-Mail-Client library</a>.
Go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k> and search for <k>ESP Mail Client</k>. Install the <em>ESP Mail Client library by Mobizt</em>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/06/Install-ESP-Mail-Client-Library-Arduino-IDE.png">
<h3>Sender Email (New Account)</h3>
We recommend creating a new email account to send the emails to your main personal email address. <k>Do not use your main personal email to send emails via ESP32</k>. If something goes wrong in your code or if by mistake you make too many requests, you can be banned or have your account temporarily disabled.
We'll use a newly created Gmail.com account to send the emails, but you can use any other email provider. The receiver email can be your personal email without any problem.
<h3>Create a Sender Email Account</h3>
Create a new email account for sending emails with the ESP32. If you want to use a Gmail account, <a href="https://www.google.com/gmail/about/" target="_blank">go to this link</a> to create a new one.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/02/GMAIL-create-a-new-account.png">
<h3>Create an App Password</h3>
You need to create an app password so that the ESP32 is able to send emails using your Gmail account. An App Password is a 16-digit passcode that gives a less secure app or device permission to access your Google Account. <a href="https://support.google.com/accounts/answer/185833" target="_blank">Learn more about sign-in with app passwords here</a>.
An app password can only be used with accounts that have <k><a href="https://support.google.com/accounts/answer/185839">2-step verification turned on</a></k>. 
<ol>
Open your <a href="https://myaccount.google.com/">Google Account</a>.
In the navigation panel, select <k>Security</k>.
Under Signing in to Google, select <k>2-Step Verification</k> > <k>Get started</k>.
Follow the on-screen steps.
</ol>
After enabling 2-step verification, you can create an app password.
<ol>
Open your <a href="https://myaccount.google.com/">Google Account</a>.
In the navigation panel, select <k>Security</k>.
Under Signing in to Google, select <k>App Passwords</k>.
</ol>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/06/create-app-password-gmail.png">
<ol start="4">In the Select app field, choose <k>mail</k>. For the device, select <k>Other</k> and give it a name, for example <em>ESP32.</em> Then, click on <k>Generate</k>. It will pop-up a window with a password that you'll use with the ESP32 or ESP8266 to send emails. Save that password (even though it says you won't need to remmeber it) because you'll need it later.</ol>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/06/generated-app-password-gmail.png">
Now, you should have an app password that you'll use on the ESP32 code to send the emails.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/06/Gmail-app-password-created-for-esp32-send-emails.png">
If you're using another email provider, check how to create an app password. You should be able to find the instructions with a quick google search <k>your_email_provider</k> + create app password.
<h3>Gmail SMTP Server Settings</h3>
If you're using a Gmail account, these are the SMTP Server details:
SMTP Server: <k>smtp.gmail.com</k>
SMTP username: Complete Gmail address
SMTP password: Your Gmail password
SMTP port (TLS): <k>587</k>
SMTP port (SSL): <k>465</k>
SMTP TLS/SSL required: <k>yes</k>
<h3>Outlook SMTP Server Settings</h3>
For Outlook accounts, these are the SMTP Server settings:
SMTP Server: <k>smtp.office365.com</k>
SMTP Username: Complete Outlook email address
SMTP Password: Your Outlook password
SMTP Port: <k>587</k>
SMTP TLS/SSL Required: <k>Yes</k>
<h3>Live or Hotmail SMTP Server Settings</h3>
For Live or Hotmail accounts, these are the SMTP Server settings:
SMTP Server: <k>smtp.live.com</k>
SMTP Username: Complete Live/Hotmail email address
SMTP Password: Your Windows Live Hotmail password
SMTP Port: <k>587</k>
SMTP TLS/SSL Required: <k>Yes</k>
If you're using another email provider, you need to search for its SMTP Server settings. Now, you have everything ready to start sending emails with the ESP32-CAM.
<h3>Code  ESP32-CAM Send Email</h3>
The following code takes a photo when the ESP32-CAM first boots and sends it to your email account. Before uploading the code, make sure you insert your sender email settings as well as your recipient email.
<k>/*********
  Rui Santos
  Complete instructions at https://RandomNerdTutorials.com/esp32-cam-projects-ebook/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files.
  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
*********/
#include "esp_camera.h"
#include "SPI.h"
#include "driver/rtc_io.h"
#include &lt;ESP_Mail_Client.h>
#include &lt;FS.h>
#include &lt;WiFi.h>
// REPLACE WITH YOUR NETWORK CREDENTIALS
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
// To send Email using Gmail use port 465 (SSL) and SMTP Server smtp.gmail.com
// You need to create an email app password
#define emailSenderAccount    "<a href="/cdn-cgi/l/email-protection" data-cfemail="c695838882839499838b878f8a86a1aba7afaae8a5a9ab">[email protected]</a>"
#define emailSenderPassword   "YOUR_EMAIL_APP_PASSWORD"
#define smtpServer            "smtp.gmail.com"
#define smtpServerPort        465
#define emailSubject          "ESP32-CAM Photo Captured"
#define emailRecipient        "<a href="/cdn-cgi/l/email-protection" data-cfemail="164f59434449535b575f5a494453555f465f53584256736e777b667a733875797b">[email protected]</a>"
#define CAMERA_MODEL_AI_THINKER
#if defined(CAMERA_MODEL_AI_THINKER)
  #define PWDN_GPIO_NUM     32
  #define RESET_GPIO_NUM    -1
  #define XCLK_GPIO_NUM      0
  #define SIOD_GPIO_NUM     26
  #define SIOC_GPIO_NUM     27
  #define Y9_GPIO_NUM       35
  #define Y8_GPIO_NUM       34
  #define Y7_GPIO_NUM       39
  #define Y6_GPIO_NUM       36
  #define Y5_GPIO_NUM       21
  #define Y4_GPIO_NUM       19
  #define Y3_GPIO_NUM       18
  #define Y2_GPIO_NUM        5
  #define VSYNC_GPIO_NUM    25
  #define HREF_GPIO_NUM     23
  #define PCLK_GPIO_NUM     22
#else
  #error "Camera model not selected"
#endif
/* The SMTP Session object used for Email sending */
SMTPSession smtp;
/* Callback function to get the Email sending status */
void smtpCallback(SMTP_Status status);
// Photo File Name to save in LittleFS
#define FILE_PHOTO "photo.jpg"
#define FILE_PHOTO_PATH "/photo.jpg"
void setup() {
  WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0); //disable brownout detector
  
  Serial.begin(115200);
  Serial.println();
  // Connect to Wi-Fi
  WiFi.begin(ssid, password);
  Serial.print("Connecting to WiFi...");
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println();
  
  // Print ESP32 Local IP Address
  Serial.print("IP Address: http://");
  Serial.println(WiFi.localIP());
  // Init filesystem
  ESP_MAIL_DEFAULT_FLASH_FS.begin();
   
  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer = LEDC_TIMER_0;
  config.pin_d0 = Y2_GPIO_NUM;
  config.pin_d1 = Y3_GPIO_NUM;
  config.pin_d2 = Y4_GPIO_NUM;
  config.pin_d3 = Y5_GPIO_NUM;
  config.pin_d4 = Y6_GPIO_NUM;
  config.pin_d5 = Y7_GPIO_NUM;
  config.pin_d6 = Y8_GPIO_NUM;
  config.pin_d7 = Y9_GPIO_NUM;
  config.pin_xclk = XCLK_GPIO_NUM;
  config.pin_pclk = PCLK_GPIO_NUM;
  config.pin_vsync = VSYNC_GPIO_NUM;
  config.pin_href = HREF_GPIO_NUM;
  config.pin_sccb_sda = SIOD_GPIO_NUM;
  config.pin_sccb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn = PWDN_GPIO_NUM;
  config.pin_reset = RESET_GPIO_NUM;
  config.xclk_freq_hz = 20000000;
  config.pixel_format = PIXFORMAT_JPEG;
  config.grab_mode = CAMERA_GRAB_LATEST;
  
  if(psramFound()){
    config.frame_size = FRAMESIZE_UXGA;
    config.jpeg_quality = 10;
    config.fb_count = 1;
  } else {
    config.frame_size = FRAMESIZE_SVGA;
    config.jpeg_quality = 12;
    config.fb_count = 1;
  }
  // Initialize camera
  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed with error 0x%x", err);
    return;
  }
  
  capturePhotoSaveLittleFS();
  sendPhoto();
}
void loop() {
}
// Capture Photo and Save it to LittleFS
void capturePhotoSaveLittleFS( void ) {
  // Dispose first pictures because of bad quality
  camera_fb_t* fb = NULL;
  // Skip first 3 frames (increase/decrease number as needed).
  for (int i = 0; i &lt; 3; i++) {
    fb = esp_camera_fb_get();
    esp_camera_fb_return(fb);
    fb = NULL;
  }
    
  // Take a new photo
  fb = NULL;  
  fb = esp_camera_fb_get();  
  if(!fb) {
    Serial.println("Camera capture failed");
    delay(1000);
    ESP.restart();
  }  
  // Photo file name
  Serial.printf("Picture file name: %s\n", FILE_PHOTO_PATH);
  File file = LittleFS.open(FILE_PHOTO_PATH, FILE_WRITE);
  // Insert the data in the photo file
  if (!file) {
    Serial.println("Failed to open file in writing mode");
  }
  else {
    file.write(fb->buf, fb->len); // payload (image), payload length
    Serial.print("The picture has been saved in ");
    Serial.print(FILE_PHOTO_PATH);
    Serial.print(" - Size: ");
    Serial.print(fb->len);
    Serial.println(" bytes");
  }
  // Close the file
  file.close();
  esp_camera_fb_return(fb);
}
void sendPhoto( void ) {
  
  /** Enable the debug via Serial port
   * none debug or 0
   * basic debug or 1
  */
  smtp.debug(1);
  /* Set the callback function to get the sending results */
  smtp.callback(smtpCallback);
  /* Declare the session config data */
  Session_Config config;
  
  /*Set the NTP config time
  For times east of the Prime Meridian use 0-12
  For times west of the Prime Meridian add 12 to the offset.
  Ex. American/Denver GMT would be -6. 6 + 12 = 18
  See https://en.wikipedia.org/wiki/Time_zone for a list of the GMT/UTC timezone offsets
  */
  config.time.ntp_server = F("pool.ntp.org,time.nist.gov");
  config.time.gmt_offset = 0;
  config.time.day_light_offset = 1;
  /* Set the session config */
  config.server.host_name = smtpServer;
  config.server.port = smtpServerPort;
  config.login.email = emailSenderAccount;
  config.login.password = emailSenderPassword;
  config.login.user_domain = "";
  /* Declare the message class */
  SMTP_Message message;
  /* Enable the chunked data transfer with pipelining for large message if server supported */
  message.enable.chunking = true;
  /* Set the message headers */
  message.sender.name = "ESP32-CAM";
  message.sender.email = emailSenderAccount;
  message.subject = emailSubject;
  message.addRecipient("Sara", emailRecipient);
  String htmlMsg = "&lt;h2>Photo captured with ESP32-CAM and attached in this email.&lt;/h2>";
  message.html.content = htmlMsg.c_str();
  message.html.charSet = "utf-8";
  message.html.transfer_encoding = Content_Transfer_Encoding::enc_qp;
  message.priority = esp_mail_smtp_priority::esp_mail_smtp_priority_normal;
  message.response.notify = esp_mail_smtp_notify_success | esp_mail_smtp_notify_failure | esp_mail_smtp_notify_delay;
  /* The attachment data item */
  SMTP_Attachment att;
  /** Set the attachment info e.g. 
   * file name, MIME type, file path, file storage type,
   * transfer encoding and content encoding
  */
  att.descr.filename = FILE_PHOTO;
  att.descr.mime = "image/png"; 
  att.file.path = FILE_PHOTO_PATH;
  att.file.storage_type = esp_mail_file_storage_type_flash;
  att.descr.transfer_encoding = Content_Transfer_Encoding::enc_base64;
  /* Add attachment to the message */
  message.addAttachment(att);
  /* Connect to server with the session config */
  if (!smtp.connect(&config))
    return;
  /* Start sending the Email and close the session */
  if (!MailClient.sendMail(&smtp, &message, true))
    Serial.println("Error sending Email, " + smtp.errorReason());
}
// Callback function to get the Email sending status
void smtpCallback(SMTP_Status status){
  /* Print the current status */
  Serial.println(status.info());
  /* Print the sending result */
  if (status.success())
  {
    Serial.println("----------------");
    Serial.printf("Message sent success: %d\n", status.completedCount());
    Serial.printf("Message sent failled: %d\n", status.failedCount());
    Serial.println("----------------\n");
    struct tm dt;
    for (size_t i = 0; i &lt; smtp.sendingResult.size(); i++){
      /* Get the result item */
      SMTP_Result result = smtp.sendingResult.getItem(i);
      time_t ts = (time_t)result.timestamp;
      localtime_r(&ts, &dt);
      ESP_MAIL_PRINTF("Message No: %d\n", i + 1);
      ESP_MAIL_PRINTF("Status: %s\n", result.completed ? "success" : "failed");
      ESP_MAIL_PRINTF("Date/Time: %d/%d/%d %d:%d:%d\n", dt.tm_year + 1900, dt.tm_mon + 1, dt.tm_mday, dt.tm_hour, dt.tm_min, dt.tm_sec);
      ESP_MAIL_PRINTF("Recipient: %s\n", result.recipients.c_str());
      ESP_MAIL_PRINTF("Subject: %s\n", result.subject.c_str());
    }
    Serial.println("----------------\n");
   // You need to clear sending result as the memory usage will grow up.
   smtp.sendingResult.clear();
  }
}
</k>
<a href="https://github.com/RuiSantosdotme/ESP32-CAM-eBook/raw/master/Code/Module_3/Send_Photos_Email_NEW/Send_Photos_Email_NEW.ino" target="_blank">View raw code</a>
<h3>How the Code Works</h3>
Continue reading to learn how the code works, or skip to the Demonstration section. Don't forget to insert your network credentials and email settings in the code. Also, if you're using a camera model other than an ESP32-CAM AI-Thinker, don't forget to change the pin assignment.
<h3>Importing Libraries</h3>
Import the required libraries. The ESP3_Mail_Client.h is used to send emails, the FS.h is used to access and save files to LittleFS and the WiFi.h library is used to initialize Wi-Fi and connect your ESP32-CAM to your local network.
<k>#include "esp_camera.h"
#include "SPI.h"
#include "driver/rtc_io.h"
#include &lt;ESP_Mail_Client.h>
#include &lt;FS.h>
#include &lt;WiFi.h></k>
<h3>Network Credentials</h3>
Insert your network credentials in the following variables:
<k>const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
<h3>Email Settings</h3>
Type the email sender account on the emailSenderAccount variable and its password on the emailSenderPassword variable.
<k>#define emailSenderAccount   "<a href="/cdn-cgi/l/email-protection" data-cfemail="91d4c9d0dcc1ddd4cec2d4dfd5d4c3ced0d2d2dec4dfc5d1f6fcf0f8fdbff2fefc">[email protected]</a>"
#define emailSenderPassword  "SENDER_ACCOUNT_PASSWORD"</k>
Insert the recipient's email. This is the email that will receive the emails sent by the ESP32:
<k>#define emailRecipient "<a href="/cdn-cgi/l/email-protection" data-cfemail="f6afb9a3a4a9b3bbb7bfbaa9a4b3b5bfa6bfb3b8a2b6919b979f9ad895999b">[email protected]</a>"</k>
Insert your email provider SMTP settings on the following lines. We're using the settings for a Gmail account. If you're using a different email provider, replace with the corresponding SMTP settings.
<k>#define smtpServer "smtp.gmail.com"
#define smtpServerPort 465</k>
Write the email subject on the emailSubject variable.
<k>#define emailSubject "ESP32-CAM Photo Captured"</k>
Create a STMPSession object called smtp that contains the data to send via email and all the other configurations.
<k>/* The SMTP Session object used for Email sending */
SMTPSession smtp;</k>
The photo taken with the ESP32 camera will be temporarily saved in LittleFS under the name photo.jpg on the root directory.
<k>#define FILE_PHOTO "photo.jpg"
#define FILE_PHOTO_PATH "/photo.jpg"</k>
<h3>ESP32 Camera Pins</h3>
Define the pins used by your camera model. We're using the ESP32-CAM AI-Thinker.
<k>#define PWDN_GPIO_NUM     32
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM      0
#define SIOD_GPIO_NUM     26
#define SIOC_GPIO_NUM     27
#define Y9_GPIO_NUM       35
#define Y8_GPIO_NUM       34
#define Y7_GPIO_NUM       39
#define Y6_GPIO_NUM       36
#define Y5_GPIO_NUM       21
#define Y4_GPIO_NUM       19
#define Y3_GPIO_NUM       18
#define Y2_GPIO_NUM        5
#define VSYNC_GPIO_NUM    25
#define HREF_GPIO_NUM     23
#define PCLK_GPIO_NUM     22</k>
<h3>setup()</h3>
In the setup(), connect the ESP32 to Wi-Fi.
<k>// Connect to Wi-Fi
WiFi.begin(ssid, password);
Serial.print("Connecting to WiFi...");
while (WiFi.status() != WL_CONNECTED) {
  delay(500);
  Serial.print(".");
}
Serial.println();</k>
Print the ESP32-CAM IP address:
<k>// Print ESP32 Local IP Address
Serial.print("IP Address: http://");
Serial.println(WiFi.localIP());</k>
In the setup(), you initialize the filesystem using the ESP Mail Client library method. The default filesystem set in the library for the ESP32 is LittleFS (you can change the default in the library file <em>ESP_Mail_FS.h</em>).
<k>// Init filesystem
ESP_MAIL_DEFAULT_FLASH_FS.begin();</k>
The following lines configure the camera and set the camera settings:
<k>camera_config_t config;
config.ledc_channel = LEDC_CHANNEL_0;
config.ledc_timer = LEDC_TIMER_0;
config.pin_d0 = Y2_GPIO_NUM;
config.pin_d1 = Y3_GPIO_NUM;
config.pin_d2 = Y4_GPIO_NUM;
config.pin_d3 = Y5_GPIO_NUM;
config.pin_d4 = Y6_GPIO_NUM;
config.pin_d5 = Y7_GPIO_NUM;
config.pin_d6 = Y8_GPIO_NUM;
config.pin_d7 = Y9_GPIO_NUM;
config.pin_xclk = XCLK_GPIO_NUM;
config.pin_pclk = PCLK_GPIO_NUM;
config.pin_vsync = VSYNC_GPIO_NUM;
config.pin_href = HREF_GPIO_NUM;
config.pin_sccb_sda = SIOD_GPIO_NUM;
config.pin_sccb_scl = SIOC_GPIO_NUM;
config.pin_pwdn = PWDN_GPIO_NUM;
config.pin_reset = RESET_GPIO_NUM;
config.xclk_freq_hz = 20000000;
config.pixel_format = PIXFORMAT_JPEG;
config.grab_mode = CAMERA_GRAB_LATEST;
if(psramFound()){
  config.frame_size = FRAMESIZE_UXGA;
  config.jpeg_quality = 10;
  config.fb_count = 2;
} else {
  config.frame_size = FRAMESIZE_SVGA;
  config.jpeg_quality = 12;
  config.fb_count = 1;
}</k>
Initialize the camera.
<k>// Initialize camera
esp_err_t err = esp_camera_init(&config);
if (err != ESP_OK) {
  Serial.printf("Camera init failed with error 0x%x", err);
  return;
}</k>
After initializing the camera, call the capturePhotoSaveLittleFS() and the sendPhoto() functions. These functions are defined at the end of the code.
<h3>capturePhotoSaveLittleFS() function</h3>
The capturePhotoSaveLittleFS() function captures a photo and saves it in the ESP32 LittleFS. In the following lines, you take a photo and save it in the framebuffer FB.
<k>Note:</k> sometimes, the first pictures taken with the ESP32-CAM are not good because the sensor has not adjusted the white balance yet. So, to make sure we get a good picture, we discard the first three pictures (that number may vary depending on your board, so adjust accordingly).
<k>//Dispose first pictures because of bad quality
camera_fb_t* fb = NULL;
// Skip first 3 frames (increase/decrease number as needed).
for (int i = 0; i &lt; 3; i++) {
  fb = esp_camera_fb_get();
  esp_camera_fb_return(fb);
  fb = NULL;
}
    
// Take a new photo
fb = NULL;  
fb = esp_camera_fb_get();  
if(!fb) {
  Serial.println("Camera capture failed");
  delay(1000);
  ESP.restart();
}  </k>
Then, create a new file in LitteFS where the photo will be saved.
<k>Serial.printf("Picture file name: %s\n", FILE_PHOTO_PATH);
File file = LittleFS.open(FILE_PHOTO_PATH, FILE_WRITE);</k>
Check if the file was successfully created. If not, print an error message.
<k>if (!file) {
  Serial.println("Failed to open file in writing mode");
}</k>
If a new file was successfully created, copy the image from the buffer to that newly created file.
<k>file.write(fb->buf, fb->len); // payload (image), payload length
Serial.print("The picture has been saved in ");
Serial.print(FILE_PHOTO_PATH);
Serial.print(" - Size: ");
Serial.print(fb->len);
Serial.println(" bytes");</k>
Close the file and clear the buffer for future use.
<k>file.close();
esp_camera_fb_return(fb);</k>
<h3>sendPhoto() function</h3>
After having the photo successfully saved in LittleFS, we'll send it via email by calling the sendPhoto() function. Let's take a look at that function.
<k>void sendPhoto( void ) {</k>
Enable debugging via serial port for the email status:
<k>smtp.debug(1);</k>
Set the callback function to get the sending results:
<k>smtp.callback(smtpCallback);</k>
Declare an email session:
<k>Session_Config config;</k>
Configure the time so that the email is timestamped correctly. You may need to adjust the gmt_offset variable depending on your location.
<k>/*Set the NTP config time
For times east of the Prime Meridian use 0-12
For times west of the Prime Meridian add 12 to the offset.
Ex. American/Denver GMT would be -6. 6 + 12 = 18
See https://en.wikipedia.org/wiki/Time_zone for a list of the GMT/UTC timezone offsets
*/
config.time.ntp_server = F("pool.ntp.org,time.nist.gov");
config.time.gmt_offset = 0;
config.time.day_light_offset = 1;</k>
Set the server host, port, sender email, and password for this email session:
<k>/* Set the session config */
config.server.host_name = smtpServer;
config.server.port = smtpServerPort;
config.login.email = emailSenderAccount;
config.login.password = emailSenderPassword;
config.login.user_domain = "";</k>
Declare a SMTP_Message class:
<k>SMTP_Message message;</k>
Set the message headerssender name, email sender, subject, and recipient (you can change the recipient name):
<k>/* Set the message headers */
message.sender.name = "ESP32-CAM";
message.sender.email = emailSenderAccount;
message.subject = emailSubject;
message.addRecipient("Sara", emailRecipient);
</k>
In the following lines, set the content of the message in the htmlMsg variable:
<k>String htmlMsg = "&lt;h2>Photo captured with ESP32-CAM and attached in this email.&lt;/h2>";
message.html.content = htmlMsg.c_str();
message.html.charSet = "utf-8";
message.html.transfer_encoding = Content_Transfer_Encoding::enc_qp;</k>
Now, we need to take care of the attachments. Create an attachment:
<k>SMTP_Attachment att;</k>
Set the attachment info: document name, mime type, file path, and where the content is saved (in our case it is saved in flash (esp_mail_file_storage_type_flash)):
<k>att.descr.filename = FILE_PHOTO;
att.descr.mime = "image/png"; 
att.file.path = FILE_PHOTO_PATH;
att.file.storage_type = esp_mail_file_storage_type_flash;
att.descr.transfer_encoding = Content_Transfer_Encoding::enc_base64;</k>
Add the attachment to the message:
<k>
/* Add attachment to the message */
message.addAttachment(att);</k>
Connect to the SMTP server:
<k>/* Connect to server with the session config */
if (!smtp.connect(&config))
  return;</k>
Finally, the following lines send the message:
<k>/* Start sending the Email and close the session */
if (!MailClient.sendMail(&smtp, &message, true))
  Serial.println("Error sending Email, " + smtp.errorReason());</k>
In this example, the email is sent once when the ESP32 boots, that's why the loop() is empty.
<k>void loop() {
}</k>
To send a new email, you just need to reset your board (press the on-board RESET button).
<h3>Demonstration</h3>
After making the necessary changes to the code: camera pinout, sender's email address, sender's email password, recipient's email address, and network credentials, you can upload the code to your board.
If you don't know how to upload code to the ESP32-CAM, read the following post:
<a href="https://randomnerdtutorials.com/program-upload-code-esp32-cam/">How to Program / Upload Code to ESP32-CAM AI-Thinker (Arduino IDE)</a>
After uploading, open the Serial Monitor and press the ESP32-CAM RESET button. The ESP32 should connect to Wi-Fi, take a photo, save it in LittleFS, connect to the SMTP server, and send the email as shown below.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/Send-email-ESP32-CAM-Serial-Monitor.png">
After a few seconds, you should have a new email from the ESP32-CAM in your inbox. As you can see in the image below, the sender's email name is ESP32-CAM as we've defined in the code, and the subject ESP32-CAM Photo Captured.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/ESP32-CAM-Email-with-Photo-Received-Inbox.png">
Open the email and you should see a photo captured by the ESP32-CAM.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/ESP32-CAM-Send-Photo-To-Email-Gmail-Inbox.png">
You can open or download the photo to see it in full size.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/Photo-taken-with-ESP32-CAM-Full-Size.jpg">
<h3>Wrapping Up</h3>
In this tutorial, you've learned how to send emails with photos taken with the ESP32-CAM. The example presented is as simple as possible: it takes a photo and sends it via email when the ESP32-CAM first boots. To send another email, you need to reset the board.
This project doesn't have a practical application, but it is useful to understand how to send an email with an attachment. After this, it should be fairly easy to include this feature in your own ESP32-CAM projects.

<h2>Send Emails using an SMTP Server: HTML, Text, and Attachments (Arduino IDE)</h2>
Learn how to send emails with the ESP32 using an SMTP Server. We'll show you how to send a simple email with HTML or raw text and how to send attachments like images and files (<em>.txt</em>). The <a aria-label="ESP32 board (opens in a new tab)" href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32 board</a> will be programmed using Arduino IDE.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/06/ESP32-Send-Emails-SMTP-Server-Text-Attachments.jpg">
<em>Updated 24 June 2023</em>
In this tutorial, we cover the following topics:
ESP32 Send Email (HTML and raw text)
ESP32 Send Emails with Attachments (image and .txt file)
We have a similar tutorial for the ESP8266 board: <a href="https://randomnerdtutorials.com/esp8266-nodemcu-send-email-smtp-server-arduino/">ESP8266 NodeMCU Send Emails using an SMTP Server: HTML, Text, and Attachments (Arduino)</a>
<h3>Introducing SMTP Servers</h3>
<k>SMTP </k>means <em>Simple Mail Transfer Protocol</em> and it is an internet standard for email transmission. To send emails using an ESP32, you need to connect it to an SMTP Server.
<h3>ESP Mail Client Library</h3>
To send emails with the <a aria-label="ESP32 (opens in a new tab)" href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32</a>, we'll use the <a href="https://github.com/mobizt/ESP-Mail-Client" target="_blank">ESP-Mail-Client library</a>. This library allows the ESP32 to send and receive emails with or without attachments via SMTP and IMAP servers. 
In this tutorial, we'll use SMTP to send an email with and without attachments. As an example, we'll send an image (.png) and a text (.txt) file. The files sent via email can be saved in the ESP32 Filesystem (SPIFFS, LittleFS, or FatFs) or a microSD card (not covered in this tutorial).
<k>Installing the ESP-Mail-Client Library</k>
Before proceeding with this tutorial, you need to install the <a href="https://github.com/mobizt/ESP-Mail-Client" target="_blank">ESP-Mail-Client library</a>.
Go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k> and search for <k>ESP Mail Client</k>. Install the <em>ESP Mail Client library by Mobizt</em>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/06/Install-ESP-Mail-Client-Library-Arduino-IDE.png">
<h3>Sender Email (New Account)</h3>
We recommend creating a new email account to send the emails to your main personal email address. <k>Do not use your main personal email to send emails via ESP32</k>. If something goes wrong in your code or if by mistake you make too many requests, you can be banned or have your account temporarily disabled.
We'll use a newly created Gmail.com account to send the emails, but you can use any other email provider. The receiver email can be your personal email without any problem.
<h3>Create a Sender Email Account</h3>
Create a new email account for sending emails with the ESP32. If you want to use a Gmail account, <a href="https://www.google.com/gmail/about/" target="_blank" aria-label=" (opens in a new tab)">go to this link</a> to create a new one.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/02/GMAIL-create-a-new-account.png">
<h3>Create an App Password</h3>
You need to create an app password so that the ESP32 is able to send emails using your Gmail account. An App Password is a 16-digit passcode that gives a less secure app or device permission to access your Google Account. <a href="https://support.google.com/accounts/answer/185833" target="_blank">Learn more about sign-in with app passwords here</a>.
An app password can only be used with accounts that have <k><a href="https://support.google.com/accounts/answer/185839">2-step verification turned on</a></k>. 
<ol>
Open your <a href="https://myaccount.google.com/">Google Account</a>.
In the navigation panel, select <k>Security</k>.
Under Signing in to Google, select <k>2-Step Verification</k> > <k>Get started</k>.
Follow the on-screen steps.
</ol>
After enabling 2-step verification, you can create an app password.
<ol>
Open your <a href="https://myaccount.google.com/">Google Account</a>.
In the navigation panel, select <k>Security</k>.
Under Signing in to Google, select <k>App Passwords</k>.
</ol>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/06/create-app-password-gmail.png">
<ol start="4">In the Select app field, choose <k>mail</k>. For the device, select <k>Other</k> and give it a name, for example <em>ESP32.</em> Then, click on <k>Generate</k>. It will pop-up a window with a password that you'll use with the ESP32 or ESP8266 to send emails. Save that password (even though it says you won't need to remember it) because you'll need it later.</ol>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/06/generated-app-password-gmail.png">
Now, you should have an app password that you'll use on the ESP32 code to send the emails.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/06/Gmail-app-password-created-for-esp32-send-emails.png">
If you're using another email provider, check how to create an app password. You should be able to find the instructions with a quick google search <k>your_email_provider</k> + create app password.
<h3>Gmail SMTP Server Settings</h3>
If you're using a Gmail account, these are the SMTP Server details:
SMTP Server: <k>smtp.gmail.com</k>
SMTP username: Complete Gmail address
SMTP password: Your Gmail password
SMTP port (TLS): <k>587</k>
SMTP port (SSL): <k>465</k>
SMTP TLS/SSL required: <k>yes</k>
<h3>Outlook SMTP Server Settings</h3>
For Outlook accounts, these are the SMTP Server settings:
SMTP Server: <k>smtp.office365.com</k>
SMTP Username: Complete Outlook email address
SMTP Password: Your Outlook password
SMTP Port: <k>587</k>
SMTP TLS/SSL Required: <k>Yes</k>
<h3>Live or Hotmail SMTP Server Settings</h3>
For Live or Hotmail accounts, these are the SMTP Server settings:
SMTP Server: <k>smtp.live.com</k>
SMTP Username: Complete Live/Hotmail email address
SMTP Password: Your Windows Live Hotmail password
SMTP Port: <k>587</k>
SMTP TLS/SSL Required: <k>Yes</k>
If you're using another email provider, you need to search for its SMTP Server settings. Now, you have everything ready to start sending emails with your ESP32.
<hr>
<h3>Send an Email with HTML or Raw Text with ESP32 (Arduino IDE)</h3>
The following code sends an email via SMTP Server with HTML or raw text. For demonstration purposes, the ESP32 sends an email once when it boots. Then, you should be able to modify the code and integrate it into your own projects.
Don't upload the code yet, you need to make some modifications to make it work for you.
<k>/*
  Rui Santos
  Complete project details at:
   - ESP32: https://RandomNerdTutorials.com/esp32-send-email-smtp-server-arduino-ide/
   - ESP8266: https://RandomNerdTutorials.com/esp8266-nodemcu-send-email-smtp-server-arduino/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files.
  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
  Example adapted from: https://github.com/mobizt/ESP-Mail-Client
*/
#include &lt;Arduino.h>
#if defined(ESP32)
  #include &lt;WiFi.h>
#elif defined(ESP8266)
  #include &lt;ESP8266WiFi.h>
#endif
#include &lt;ESP_Mail_Client.h>
#define WIFI_SSID "REPLACE_WITH_YOUR_SSID"
#define WIFI_PASSWORD "REPLACE_WITH_YOUR_PASSWORD"
/** The smtp host name e.g. smtp.gmail.com for GMail or smtp.office365.com for Outlook or smtp.mail.yahoo.com */
#define SMTP_HOST "smtp.gmail.com"
#define SMTP_PORT 465
/* The sign in credentials */
#define AUTHOR_EMAIL "<a href="/cdn-cgi/l/email-protection" data-cfemail="e1b8aeb4b3bea4aca0a8ada1b9b9b9b9cf828e8c">[email protected]</a>"
#define AUTHOR_PASSWORD "YOUR_EMAIL_APP_PASS"
/* Recipient's email*/
#define RECIPIENT_EMAIL "<a href="/cdn-cgi/l/email-protection" data-cfemail="673522242e372e2229332238222a262e2b273f3f3f3f4904080a">[email protected]</a>"
/* Declare the global used SMTPSession object for SMTP transport */
SMTPSession smtp;
/* Callback function to get the Email sending status */
void smtpCallback(SMTP_Status status);
void setup(){
  Serial.begin(115200);
  Serial.println();
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  Serial.print("Connecting to Wi-Fi");
  while (WiFi.status() != WL_CONNECTED){
    Serial.print(".");
    delay(300);
  }
  Serial.println();
  Serial.print("Connected with IP: ");
  Serial.println(WiFi.localIP());
  Serial.println();
  /*  Set the network reconnection option */
  MailClient.networkReconnect(true);
  /** Enable the debug via Serial port
   * 0 for no debugging
   * 1 for basic level debugging
   *
   * Debug port can be changed via ESP_MAIL_DEFAULT_DEBUG_PORT in ESP_Mail_FS.h
   */
  smtp.debug(1);
  /* Set the callback function to get the sending results */
  smtp.callback(smtpCallback);
  /* Declare the Session_Config for user defined session credentials */
  Session_Config config;
  /* Set the session config */
  config.server.host_name = SMTP_HOST;
  config.server.port = SMTP_PORT;
  config.login.email = AUTHOR_EMAIL;
  config.login.password = AUTHOR_PASSWORD;
  config.login.user_domain = "";
  /*
  Set the NTP config time
  For times east of the Prime Meridian use 0-12
  For times west of the Prime Meridian add 12 to the offset.
  Ex. American/Denver GMT would be -6. 6 + 12 = 18
  See https://en.wikipedia.org/wiki/Time_zone for a list of the GMT/UTC timezone offsets
  */
  config.time.ntp_server = F("pool.ntp.org,time.nist.gov");
  config.time.gmt_offset = 3;
  config.time.day_light_offset = 0;
  /* Declare the message class */
  SMTP_Message message;
  /* Set the message headers */
  message.sender.name = F("ESP");
  message.sender.email = AUTHOR_EMAIL;
  message.subject = F("ESP Test Email");
  message.addRecipient(F("Sara"), RECIPIENT_EMAIL);
    
  /*Send HTML message*/
  /*String htmlMsg = "&lt;div style=\"color:#2f4468;\">&lt;h1>Hello World!&lt;/h2>&lt;p>- Sent from ESP board&lt;/p>&lt;/div>";
  message.html.content = htmlMsg.c_str();
  message.html.content = htmlMsg.c_str();
  message.text.charSet = "us-ascii";
  message.html.transfer_encoding = Content_Transfer_Encoding::enc_7bit;*/
   
  //Send raw text message
  String textMsg = "Hello World! - Sent from ESP board";
  message.text.content = textMsg.c_str();
  message.text.charSet = "us-ascii";
  message.text.transfer_encoding = Content_Transfer_Encoding::enc_7bit;
  
  message.priority = esp_mail_smtp_priority::esp_mail_smtp_priority_low;
  message.response.notify = esp_mail_smtp_notify_success | esp_mail_smtp_notify_failure | esp_mail_smtp_notify_delay;
  /* Connect to the server */
  if (!smtp.connect(&config)){
    ESP_MAIL_PRINTF("Connection error, Status Code: %d, Error Code: %d, Reason: %s", smtp.statusCode(), smtp.errorCode(), smtp.errorReason().c_str());
    return;
  }
  if (!smtp.isLoggedIn()){
    Serial.println("\nNot yet logged in.");
  }
  else{
    if (smtp.isAuthenticated())
      Serial.println("\nSuccessfully logged in.");
    else
      Serial.println("\nConnected with no Auth.");
  }
  /* Start sending Email and close the session */
  if (!MailClient.sendMail(&smtp, &message))
    ESP_MAIL_PRINTF("Error, Status Code: %d, Error Code: %d, Reason: %s", smtp.statusCode(), smtp.errorCode(), smtp.errorReason().c_str());
}
void loop(){
}
/* Callback function to get the Email sending status */
void smtpCallback(SMTP_Status status){
  /* Print the current status */
  Serial.println(status.info());
  /* Print the sending result */
  if (status.success()){
    // ESP_MAIL_PRINTF used in the examples is for format printing via debug Serial port
    // that works for all supported Arduino platform SDKs e.g. AVR, SAMD, ESP32 and ESP8266.
    // In ESP8266 and ESP32, you can use Serial.printf directly.
    Serial.println("----------------");
    ESP_MAIL_PRINTF("Message sent success: %d\n", status.completedCount());
    ESP_MAIL_PRINTF("Message sent failed: %d\n", status.failedCount());
    Serial.println("----------------\n");
    for (size_t i = 0; i &lt; smtp.sendingResult.size(); i++)
    {
      /* Get the result item */
      SMTP_Result result = smtp.sendingResult.getItem(i);
      // In case, ESP32, ESP8266 and SAMD device, the timestamp get from result.timestamp should be valid if
      // your device time was synched with NTP server.
      // Other devices may show invalid timestamp as the device time was not set i.e. it will show Jan 1, 1970.
      // You can call smtp.setSystemTime(xxx) to set device time manually. Where xxx is timestamp (seconds since Jan 1, 1970)
      
      ESP_MAIL_PRINTF("Message No: %d\n", i + 1);
      ESP_MAIL_PRINTF("Status: %s\n", result.completed ? "success" : "failed");
      ESP_MAIL_PRINTF("Date/Time: %s\n", MailClient.Time.getDateTimeString(result.timestamp, "%B %d, %Y %H:%M:%S").c_str());
      ESP_MAIL_PRINTF("Recipient: %s\n", result.recipients.c_str());
      ESP_MAIL_PRINTF("Subject: %s\n", result.subject.c_str());
    }
    Serial.println("----------------\n");
    // You need to clear sending result as the memory usage will grow up.
    smtp.sendingResult.clear();
  }
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP/ESP_Email_Simple.ino" target="_blank">View raw code</a>
You need to insert your network credentials as well as set the sender email, SMTP Server details, recipient, and message.
<h3>How the Code Works</h3>
This code is adapted from an example provided by the library. The example is well commented so that you understand what each line of code does. Let's just take a look at the relevant parts that you need or may need to change.
First, insert your network credentials in the following lines:
<k>#define WIFI_SSID "REPLACE_WITH_YOUR_SSID"
#define WIFI_PASSWORD "REPLACE_WITH_YOUR_PASSWORD"</k>
Insert your SMTP server settings. If you're using a Gmail account to send the emails, these are the settings:
<k>#define SMTP_HOST "smtp.gmail.com"
#define SMTP_PORT 465</k>
Insert the sender email login credentials (complete email and app password you created previously).
<k>#define AUTHOR_EMAIL "<a href="/cdn-cgi/l/email-protection" data-cfemail="b4edfbe1e6ebf1f9f5fdf8f4ecececec9ad7dbd9">[email protected]</a>"
#define AUTHOR_PASSWORD "YOUR_EMAIL_PASS"</k>
Insert the recipient email:
<k>#define RECIPIENT_EMAIL "<a href="/cdn-cgi/l/email-protection" data-cfemail="2c7e696f657c65696278697369616d65606c74747474024f4341">[email protected]</a>"</k>
You may need to adjust the gmt_offset variable depending on your location so that the email is timestamped with the right time.
<k>config.time.ntp_server = F("pool.ntp.org,time.nist.gov");
config.time.gmt_offset = 3;
config.time.day_light_offset = 0;</k>
Set the message headers in the following lines in the setup()sender name, sender email, email subject, and the recipient name and email:
<k>  /* Set the message headers */
  message.sender.name = F("ESP");
  message.sender.email = AUTHOR_EMAIL;
  message.subject = F("ESP Test Email");
  message.addRecipient(F("Sara"), RECIPIENT_EMAIL);</k>
In the following lines, set the content of the message (raw text) in the textMsg variable:
<k>//Send raw text message
String textMsg = "Hello World - Sent from ESP board";
message.text.content = textMsg.c_str();
message.text.charSet = "us-ascii";
message.text.transfer_encoding = Content_Transfer_Encoding::enc_7bit;</k>
If you want to send HTML text instead, uncomment the following lines you should insert your HTML text in the htmlMsg variable.
<k>/*Send HTML message*/
/*String htmlMsg = "&lt;div style=\"color:#2f4468;\">&lt;h1>Hello World!&lt;/h2>&lt;p>- Sent from ESP board&lt;/p>&lt;/div>";
message.html.content = htmlMsg.c_str();
message.html.content = htmlMsg.c_str();
message.text.charSet = "us-ascii";
message.html.transfer_encoding = Content_Transfer_Encoding::enc_7bit;*/</k>
Finally, the following lines send the message:
<k>if (!MailClient.sendMail(&smtp, &message))
  Serial.println("Error sending Email, " + smtp.errorReason());</k>
<h3>Demonstration</h3>
Upload the code to your ESP32. After uploading, open the Serial Monitor at a baud rate of 115200. Press the ESP32 Reset button.
If everything went as expected you should get a similar message in the Serial Monitor.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/06/send_email_ESP32_serial_monitor.png">
Check your email account. You should have received an email from your ESP32 board.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/02/ESP32-SMTP-Server-Receive-Email-Test.png">
If you set the option to send a message with HTML text, this is what the message looks like:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/02/ESP32-SMTP-Server-Send-Email-with-Body-Text-format-HTML.png">
If you've enabled the raw text message, this is the email that you should receive.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/02/ESP32-SMTP-Server-Send-Email-with-Body-Text-only-format.png">
<hr>
<h3>Send Attachments via Email with ESP32 (Arduino IDE)</h3>
In this section, we'll show you how to send attachments in your emails sent by the ESP32. We'll show you how to send <em>.txt </em>files or pictures. This can be useful to send a <em>.txt</em> file with sensor readings from the past few hours or to send a <a href="https://randomnerdtutorials.com/esp32-cam-take-photo-save-microsd-card/">photo captured by an ESP32-CAM</a>. 
For this tutorial, the files to be sent should be saved on the ESP32 filesystem (LittleFS).
<h3>Upload files to LittleFS</h3>
To send files via email, these should be saved on the ESP32 filesystem or on a microSD card. We'll upload a picture and a .txt file to the ESP32 LittleFS filesystem using the <a href="https://github.com/lorol/arduino-esp32fs-plugin" target="_blank" rel="noopener" title="">ESP32 Filesystem Uploader plugin for Arduino IDE</a>. Follow the next tutorial to install the plugin if you don't have it installed yet:
<a href="https://randomnerdtutorials.com/esp32-littlefs-arduino-ide/" title="">Install ESP32 Filesystem Uploader in Arduino IDE (LittleFS and SPIFFS support)</a>
Create a new Arduino sketch and save it. Go to <k>Sketch </k>> <k>Show Sketch</k> folder. Inside the Arduino sketch folder, create a folder called <k>data</k>. Move a .jpg file and .txt file to your <k>data </k>folder.
<k>Alternatively, you can <a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP/ESP_Email_Attachments/ESP_Email_Attachments.zip" target="_blank">click here to download the project folder</a>.</k>
<k>Note: </k> with the default code,<em> your files must be named image.png</em> and <em>text_file.txt</em>. Alternatively, you can modify the code to import files with a different name.
We'll be sending these <k><a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP/ESP_Email_Attachments/ESP_Email_Attachments.zip" target="_blank">files</a></k>:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/04/Files-to-send-via-email-ESP-Mail-Client.png">
Your folder structure should look as follows (<k><a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP/ESP_Email_Attachments/ESP_Email_Attachments.zip" target="_blank">download project folder</a></k>):
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/04/Send-Email-Attachments-Folder-Structure-filesystem_organizing-files.png">
After moving the files to the <k>data </k>folder, in your Arduino IDE, go to <k>Tools </k>> <k>ESP32 Sketch Data Upload</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2018/10/sketch-data-upload.png">
Then, select <k>LittleFS </k>and wait for the files to be uploaded.
<a href="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/06/ESP32-upload-files-to-littlefs.png?quality=100&strip=all&ssl=1"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/06/ESP32-upload-files-to-littlefs.png"></a>
You should get a success message on the debugging window. If the files were successfully uploaded, move on to the next section. 
<a href="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/06/LittleFS-Image-uploaded.png?quality=100&strip=all&ssl=1"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/06/LittleFS-Image-uploaded.png"></a>
<k>Note: </k> if you start seeing many dots .____..____ being printed on the debugging window, you need to hold the ESP32 on-board BOOT button for the files to be uploaded.
<h3>Code</h3>
The following code sends an email with a <em>.txt</em> file and a picture attached. Before uploading the code, make sure you insert your sender email settings and your recipient email.
<k>/*
  Rui Santos
  Complete project details at:
   - ESP32: https://RandomNerdTutorials.com/esp32-send-email-smtp-server-arduino-ide/
   - ESP8266: https://RandomNerdTutorials.com/esp8266-nodemcu-send-email-smtp-server-arduino/
   
  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files.
  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
  Example adapted K. Suwatchai (Mobizt): https://github.com/mobizt/ESP-Mail-Client Copyright (c) 2021 mobizt
*/
// To use send Email for Gmail to port 465 (SSL), less secure app option should be enabled. https://myaccount.google.com/lesssecureapps?pli=1
#include &lt;Arduino.h>
#if defined(ESP32)
  #include &lt;WiFi.h>
#elif defined(ESP8266)
  #include &lt;ESP8266WiFi.h>
#endif
#include &lt;ESP_Mail_Client.h>
#define WIFI_SSID "REPLACE_WITH_YOUR_SSID"
#define WIFI_PASSWORD "REPLACE_WITH_YOUR_PASSWORD"
#define SMTP_HOST "smtp.gmail.com"
/** The smtp port e.g. 
 * 25  or esp_mail_smtp_port_25
 * 465 or esp_mail_smtp_port_465
 * 587 or esp_mail_smtp_port_587
*/
#define SMTP_PORT 465
/* The sign in credentials */
#define AUTHOR_EMAIL "<a href="/cdn-cgi/l/email-protection" data-cfemail="fea7b1abaca1bbb3bfb7b2bea6a6a6a6d09d9193">[email protected]</a>"
#define AUTHOR_PASSWORD "YOUR_EMAIL_APP_PASS"
/* Recipient's email*/
#define RECIPIENT_EMAIL "<a href="/cdn-cgi/l/email-protection" data-cfemail="5d0f181e140d14181309180218101c14111d05050505733e3230">[email protected]</a>"
/* The SMTP Session object used for Email sending */
SMTPSession smtp;
/* Callback function to get the Email sending status */
void smtpCallback(SMTP_Status status);
void setup(){
  Serial.begin(115200);
  Serial.println();
  Serial.print("Connecting to AP");
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  while (WiFi.status() != WL_CONNECTED){
    Serial.print(".");
    delay(200);
  }
  Serial.println("");
  Serial.println("WiFi connected.");
  Serial.println("IP address: ");
  Serial.println(WiFi.localIP());
  Serial.println();
  // Init filesystem
  ESP_MAIL_DEFAULT_FLASH_FS.begin();
  /** Enable the debug via Serial port
   * none debug or 0
   * basic debug or 1
  */
  smtp.debug(1);
  /* Set the callback function to get the sending results */
  smtp.callback(smtpCallback);
  /* Declare the Session_Config for user defined session credentials */
  Session_Config config;
  /* Set the session config */
  config.server.host_name = SMTP_HOST;
  config.server.port = SMTP_PORT;
  config.login.email = AUTHOR_EMAIL;
  config.login.password = AUTHOR_PASSWORD;
  config.login.user_domain = "mydomain.net";
  
  /*
  Set the NTP config time
  For times east of the Prime Meridian use 0-12
  For times west of the Prime Meridian add 12 to the offset.
  Ex. American/Denver GMT would be -6. 6 + 12 = 18
  See https://en.wikipedia.org/wiki/Time_zone for a list of the GMT/UTC timezone offsets
  */
  config.time.ntp_server = F("pool.ntp.org,time.nist.gov");
  config.time.gmt_offset = 3;
  config.time.day_light_offset = 0;
  /* Declare the message class */
  SMTP_Message message;
  /* Enable the chunked data transfer with pipelining for large message if server supported */
  message.enable.chunking = true;
  /* Set the message headers */
  message.sender.name = "ESP Mail";
  message.sender.email = AUTHOR_EMAIL;
  message.subject = F("Test sending Email with attachments and inline images from Flash");
  message.addRecipient(F("Sara"), RECIPIENT_EMAIL);
  /** Two alternative content versions are sending in this example e.g. plain text and html */
  String htmlMsg = "This message contains attachments: image and text file.";
  message.html.content = htmlMsg.c_str();
  message.html.charSet = "utf-8";
  message.html.transfer_encoding = Content_Transfer_Encoding::enc_qp;
  message.priority = esp_mail_smtp_priority::esp_mail_smtp_priority_normal;
  message.response.notify = esp_mail_smtp_notify_success | esp_mail_smtp_notify_failure | esp_mail_smtp_notify_delay;
  /* The attachment data item */
  SMTP_Attachment att;
  /** Set the attachment info e.g. 
   * file name, MIME type, file path, file storage type,
   * transfer encoding and content encoding
  */
  att.descr.filename = "image.png";
  att.descr.mime = "image/png"; //binary data
  att.file.path = "/image.png";
  att.file.storage_type = esp_mail_file_storage_type_flash;
  att.descr.transfer_encoding = Content_Transfer_Encoding::enc_base64;
  /* Add attachment to the message */
  message.addAttachment(att);
  message.resetAttachItem(att);
  att.descr.filename = "text_file.txt";
  att.descr.mime = "text/plain";
  att.file.path = "/text_file.txt";
  att.file.storage_type = esp_mail_file_storage_type_flash;
  att.descr.transfer_encoding = Content_Transfer_Encoding::enc_base64;
  /* Add attachment to the message */
  message.addAttachment(att);
  /* Connect to server with the session config */
  if (!smtp.connect(&config)){
    ESP_MAIL_PRINTF("Connection error, Status Code: %d, Error Code: %d, Reason: %s", smtp.statusCode(), smtp.errorCode(), smtp.errorReason().c_str());
    return;
  }
  if (!smtp.isLoggedIn()){
    Serial.println("\nNot yet logged in.");
  }
  else{
    if (smtp.isAuthenticated())
      Serial.println("\nSuccessfully logged in.");
    else
      Serial.println("\nConnected with no Auth.");
  }
  /* Start sending the Email and close the session */
  if (!MailClient.sendMail(&smtp, &message, true))
    Serial.println("Error sending Email, " + smtp.errorReason());
}
void loop(){
}
/* Callback function to get the Email sending status */
void smtpCallback(SMTP_Status status){
  /* Print the current status */
  Serial.println(status.info());
  /* Print the sending result */
  if (status.success()){
    Serial.println("----------------");
    ESP_MAIL_PRINTF("Message sent success: %d\n", status.completedCount());
    ESP_MAIL_PRINTF("Message sent failled: %d\n", status.failedCount());
    Serial.println("----------------\n");
    struct tm dt;
    for (size_t i = 0; i &lt; smtp.sendingResult.size(); i++){
      /* Get the result item */
      SMTP_Result result = smtp.sendingResult.getItem(i);
      time_t ts = (time_t)result.timestamp;
      localtime_r(&ts, &dt);
      ESP_MAIL_PRINTF("Message No: %d\n", i + 1);
      ESP_MAIL_PRINTF("Status: %s\n", result.completed ? "success" : "failed");
      ESP_MAIL_PRINTF("Date/Time: %d/%d/%d %d:%d:%d\n", dt.tm_year + 1900, dt.tm_mon + 1, dt.tm_mday, dt.tm_hour, dt.tm_min, dt.tm_sec);
      ESP_MAIL_PRINTF("Recipient: %s\n", result.recipients.c_str());
      ESP_MAIL_PRINTF("Subject: %s\n", result.subject.c_str());
    }
    Serial.println("----------------\n");
    
    // You need to clear sending result as the memory usage will grow up.
    smtp.sendingResult.clear();
  }
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP/ESP_Email_Attachments/ESP_Email_Attachments.ino" target="_blank">View raw code</a>
<h3>How the code works</h3>
This code is very similar to the previous one, so we'll just take a look at the relevant parts to send attachments.
In the setup(), you initialize the filesystem using the ESP Mail Client library method. The default filesystem set in the library for the ESP32 is LittleFS (you can change the default in the library file <em>ESP_Mail_FS.h</em>).
<k>// Init filesystem
ESP_MAIL_DEFAULT_FLASH_FS.begin();</k>
You need to create an attachment as follows:
<k>/* The attachment data item */
SMTP_Attachment att;</k>
Then, add the attachment details: filename, MIME type, file path, file storage type, and transfer encoding. In the following lines, we're sending the image file.
<k>att.descr.filename = "image.png";
att.descr.mime = "image/png"; 
att.file.path = "/image.png";
att.file.storage_type = esp_mail_file_storage_type_flash;
att.descr.transfer_encoding = Content_Transfer_Encoding::enc_base64;</k>
Finally, add the attachment to the message:
<k>message.addAttachment(att);</k>
If you want to send more attachments, you need to call the following line before adding the next attachment:
<k>message.resetAttachItem(att);</k>
Then, enter the details of the other attachment (text file):
<k>att.descr.filename = "text_file.txt";
att.descr.mime = "text/plain";
att.file.path = "/text_file.txt";
att.file.storage_type = esp_mail_file_storage_type_flash;
att.descr.transfer_encoding = Content_Transfer_Encoding::enc_base64;</k>
And add this attachment to the message:
<k>message.addAttachment(att);</k>
Finally, you just need to send the message as you did with the previous example:
<k>if (!MailClient.sendMail(&smtp, &message, true))
  Serial.println("Error sending Email, " + smtp.errorReason());</k>
<h3>Demonstration</h3>
After uploading the code, open the Serial Monitor at a baud rate of 115200 and press the on-board EN/RESET button. If everything goes smoothly, you should get a similar message on the Serial Monitor.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/04/ESP8266-email-message-sent-successfully-Arduino-IDE-Serial-Monitor.png">
Check the recipient's email address. You should have a new email with two attachments.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/04/ESP-email-attachments-image-file.png">
<h3>Wrapping Up</h3>
In this tutorial you've learned how to send emails with the ESP32 using an SMTP Server. For this method to work, the ESP32 should have access to the internet.
If you don't want to use an SMTP Server, you can also write a <a href="https://randomnerdtutorials.com/esp32-esp8266-send-email-notification/">PHP script to send email notifications with the ESP32 or ESP8266 board</a>. 
You've learned how to send a simple email with text and with attachments. When using attachments, these should be saved on the ESP32 filesystem (LittleFS) or on a microSD card (not covered in this tutorial).
The examples presented show how to send a single email when the ESP32 boots. The idea is to modify the code and include it in your own projects. For example, it can be useful to send a .txt file with the sensor readings, send a photo captured with the ESP32-CAM, use deep sleep to wake up your board every hour and send an email with data, etc.
<h2>Upload Files to LittleFS using Arduino IDE</h2>
In this guide, you'll learn how to upload files to the ESP32 Filesystem (LittleFS) by using a plugin for Arduino IDE (1.8.X). LittleFS is a lightweight filesystem created for microcontrollers that lets you access the flash memory like you would do in a standard file system on your computer, but simpler and more limited. The plugin we'll install lets you use three different filesystems: LittleFS, SPIFFS, or FatFS.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/06/Install-Filesystem-Plugin-ESP32.jpg">
At the moment, this method is <k>not </k>compatible with Arduino 2.0. So, you should be using Arduino IDE version 1.8.X.
If you want to use LittleFS with the ESP8266, read: <a href="https://randomnerdtutorials.com/install-esp8266-nodemcu-littlefs-arduino/" title="">Install ESP8266 NodeMCU LittleFS Filesystem Uploader in Arduino IDE</a>.
<k>Table of Contents</k>
Introducing LittleFS
Installing the Arduino ESP32 filesystem uploader
Windows Instructions
Mac OS X Instructions
Uploading Files to ESP32 LittleFS using the Filesystem Uploader
Testing the ESP32 Filesystem Uploader
<h3>Introducing LittleFS</h3>
LittleFS is a lightweight filesystem created for microcontrollers that lets you access the flash memory like you would do in a standard file system on your computer, but it's simpler and more limited. You can read, write, close, and delete files. Using a filesystem with the ESP32 boards is especially useful to:
Create configuration files with settings;
Save data permanently;
Create files to save small amounts of data instead of using a microSD card;
<a href="https://randomnerdtutorials.com/esp32-web-server-spiffs-spi-flash-file-system/" title="">Save HTML, CSS, and JavaScript files to build a web server</a>;
<a href="https://randomnerdtutorials.com/display-images-esp32-esp8266-web-server/">Save images, figures, and icons</a>;
And much more.
<h3>Installing the Arduino ESP32 filesystem uploader</h3>
Currently, there is a plugin for the Arduino IDE (version 1.8.X) that allows you to pack and upload files to the SPIFFS, LittleFS, or FatFS filesystem image in the ESP32 filesystem.
<k>Note</k>: in most of our projects we use SPIFFS for the ESP32 filesystem. It's still compatible with the ESP32, and you can use SPIFFS without any issues. However, currently, many libraries are moving to LittleFS.
The plugin we'll install is both compatible with SPIFFS and LittleFS. So, it's an advantage over the older plugin and you can still use SPIFFS.
There are a few advantages of using LittleFS over SPIFFS:
LittleFS is optimized for low resource usage and it employs a<k> wear-leveling algorithm</k> that evenly distributes writes across the flash memory, prolonging its lifespan.
LittleFS provides faster mount times and file access by utilizing a <k>directory indexing structure</k>.
LittleFS minimizes the risk of data corruption during power loss or system failures.
LittleFS is under active development. 
<h3>Windows Instructions</h3>
Follow the next steps to install the filesystem uploader if you're using Windows:
<k>1)</k> Go to the <a href="https://github.com/lorol/arduino-esp32fs-plugin/releases" target="_blank" rel="noopener" title="">releases page</a> and click the latest <k>esp32fs.zip</k> file to download.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/06/Arduino-ESP32-Uploader-Plugin-Download.png">
<k>2)</k> Unzip the downloaded file. You should have a folder called <k>esp32fs </k>with a file called <k>esp32fs.jar</k> inside.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/06/esp32fs-folder-file.png">
<k>3)</k> Find your Sketchbook location. In your Arduino IDE, go to <k>File</k> > <k>Preferences</k> and check your Sketchbook location. In my case, it's in the following path: C:\Users\sarin\Documents\Arduino.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2018/10/Arduino-Sketchbook-location.png">
<k>4)</k> Go to the sketchbook location, and create a <k>tools </k>folder if you don't have it already (make sure that the Arduino IDE application is closed).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2018/10/creating-tools-folder-sketchbook-location.png">
<k>5)</k> Inside the <k><em>tools </em></k>folder, create another folder called <k><em>ESP32FS </em></k>if you haven't already.
<k>6)</k> Inside the <k>ESP32FS </k>folder, create a folder called <k><em>tool</em></k>.
<k>7)</k> Copy the <em><k>esp32fs.jar</k></em> file to the <k><em>tool </em></k>folder (if you already have an <em><k>esp32fs.jar</k></em> file from a previous plugin, delete it and replace it with the new one). So, the directory structure will look like this:
&lt;home_dir>/Arduino/tools/ESP32FS/tool/esp32fs.jar
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/06/uploader-plugin-esp32-file-directory.png">
<k>8)</k> Now, you can open Arduino IDE.
To check if the plugin was successfully installed, open your Arduino IDE and select your ESP32 board. In the <k>Tools</k> menu, check that you have the option <k>ESP32 Sketch Data Upload</k>. Click on that option. A window will pop up for you to choose the filesystem you want to use.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/06/Filesystem-uploader-plugin-esp32-littlefs.png">
As you can see, you have the option to choose from LittleFS, SPIFFS, or FatFS and you can even have the option to erase flash if needed.
Congratulations! You've successfully installed the Filesystem uploader plugin for the ESP32 on the Arduino IDE.
<h3>Mac OS X Instructions</h3>
Follow the next instructions if you're using MacOS X.
<k>1)</k> Go to the <a href="https://github.com/lorol/arduino-esp32fs-plugin/releases" target="_blank" rel="noopener" title="">releases page</a> and click the latest <k><em>esp32fs.zip</em></k> file to download.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/06/Arduino-ESP32-Uploader-Plugin-Download.png">
<k>2)</k> Unpack the files. You should have a folder called <k>esp32fs </k>with a file called <k>esp32fs.jar</k> inside.
<k>3)</k> Create a folder called <k>tools</k> in /Documents/Arduino/ if you haven't already.
<k>4)</k> Inside the tools folder create another one called <k>ESP32FS</k>.
<k>5)</k> Inside the <k>ESP32FS </k>folder, create a folder called <k><em>tool</em></k>. So, the directory structure will look like this:
&lt;home_dir>/Arduino/tools/ESP32FS/tool/
<k>6)</k> Copy the unpacked <k><em>esp32fs.jar</em></k> file to the <k>tool</k> directory (if you already have an <em><k>esp32fs.jar</k></em> file from a previous plugin, delete it and replace it with the new one). You should have a similar folder structure.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/06/ESP32-Filesystem-tool-directory-macos.png">
<k>7)</k> Now, you can open Arduino IDE.
To check if the plugin was successfully installed, open your Arduino IDE and select your ESP32 board. In the <k>Tools</k> menu, check that you have the option <k>ESP32 Sketch Data Upload</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/06/ESP32-sketch-data-upload-arduino-ide-macos.png">
Click on that option. A window will pop up for you to choose the filesystem you want to use.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/06/Filesystem-uploader-plugin-esp32-littlefs-macos.png">
As you can see, you have the option to choose from LittleFS, SPIFFS, or FatFS and you can even have the option to erase flash if needed.
Congratulations! You've successfully installed the Filesystem uploader plugin for the ESP32 on the Arduino IDE.
<h3>Uploading Files using the Filesystem Uploader</h3>
To upload files to the ESP32 LittleFS filesystem follow the next instructions.
<k>1)</k> Create an Arduino sketch and save it. For demonstration purposes, you can save an empty sketch.
<k>2)</k> Then, open the sketch folder. You can go to <k>Sketch </k>> <k>Show Sketch Folder</k>. The folder where your sketch is saved should open.
<img class="lazy" data-src="https://i0.wp.com/rntlab.com/wp-content/uploads/2018/09/show-sketch-folder.png?w=828&quality=100&strip=all&ssl=1" alt="Arduino IDE Show Sketch folder to create data folder" data-recalc-dims="1" loading="lazy" fetchpriority="low">
<k>3)</k> Inside that folder, create a new folder called <em><k>data</k></em>.
<img class="lazy" data-src="https://i0.wp.com/rntlab.com/wp-content/uploads/2018/09/data.fodler.png?w=828&quality=100&strip=all&ssl=1" alt="ESP32 Arduino Sketch Example File Filesystem fs LittleFS" data-recalc-dims="1" loading="lazy" fetchpriority="low">
<k>4)</k> Inside the <k><em>data</em> </k>folder is where you should put the files you want to save into the ESP32 filesystem. As an example, create a <em>.txt</em> file with some text called <em>test_example</em>.
<img class="lazy" data-src="https://i0.wp.com/rntlab.com/wp-content/uploads/2018/09/text_txt.png?w=828&quality=100&strip=all&ssl=1" alt="ESP32 Notepad Test Example File Filesystem fs LittleFS" data-recalc-dims="1" loading="lazy" fetchpriority="low">
<k>5)</k> Then, to upload the files, in the Arduino IDE, you just need to go to <k>Tools </k>> <k>ESP32 Sketch Data Upload</k>.
<img class="lazy" data-src="https://i0.wp.com/rntlab.com/wp-content/uploads/2018/09/sketch-data-upload.png?w=828&quality=100&strip=all&ssl=1" alt="ESP32 Sketch Data Upload Arduino IDE FS Filesystem" data-recalc-dims="1" loading="lazy" fetchpriority="low">
6. Select the <k>LittleFS </k>option and click OK.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/06/Filesystem-uploader-plugin-esp32-littlefs.png">
Make sure the <k>Serial Monitor is closed</k> before uploading the files, otherwise, you'll get an error related to the Serial communication, and the files won't upload.
The uploader will overwrite anything you had already saved in the filesystem.
<k>Note</k>: in some ESP32 development boards you need to press the on-board <k>BOOT </k>button for around two seconds to upload the files.
The files were successfully uploaded to the ESP32 filesystem when you see the message <k>LittleFS Image Uploaded</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/06/LittleFS-image-uploaded-successfully.png">
<h3>Testing the Filesystem Uploader Plugin</h3>
Now, let's just check if the file was actually saved into the ESP32 filesystem. Simply upload the following code to your ESP32 board.
<k>/*********
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-littlefs-arduino-ide/
*********/
#include "LittleFS.h"
 
void setup() {
  Serial.begin(115200);
  
  if(!LittleFS.begin()){
    Serial.println("An Error has occurred while mounting SPIFFS");
    return;
  }
  
  File file = LittleFS.open("/test_example.txt");
  if(!file){
    Serial.println("Failed to open file for reading");
    return;
  }
  
  Serial.println("File Content:");
  while(file.available()){
    Serial.write(file.read());
  }
  file.close();
}
 
void loop() {
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_Read_Files_LittleFS.ino" target="_blank">View raw code</a>
After uploading, open the Serial Monitor at a baud rate of 115200. Press the ESP32 <k>ENABLE</k>/<k>RST</k> button. It should print the content of your <em>.txt</em> file on the Serial Monitor.
<img class="lazy" data-src="https://i0.wp.com/rntlab.com/wp-content/uploads/2018/09/testing-file-system-serial-monitor.png?w=828&quality=100&strip=all&ssl=1" alt="ESP32 LittleFS Filesystem Example Arduino IDE Serial Monitor" data-recalc-dims="1" loading="lazy" fetchpriority="low">
You've successfully uploaded files to the ESP32 filesystem using the plugin.
<h3>Wrapping Up</h3>
In this tutorial, you installed a plugin for the Arduino IDE that allows you to upload files to the ESP32 filesystem. This plugin supports three different filesystems: SPIFFS, LittleFS, and FatFS.
While many libraries and projects are moving to LittleFS, SPIFSS is still used and your previous projects that use SPIFFS should still be working.
Because this new plugin supports both SPIFFS and LittleFS, you should consider installing this one instead of the <a href="https://randomnerdtutorials.com/install-esp32-filesystem-uploader-arduino-ide/" title="">SPIFFS plugin</a> so that you have more flexibility with the choice of filesystem.
<h2>26 Free Guides for Sensors and Modules</h2>
There is a wide variety of sensors, modules, and peripherals compatible with the ESP32 boards. We have tutorials for the most popular components. This article is a compilation of 26 free guides for ESP32 sensors and modules. Most guides cover programming the ESP32 using the Arduino core, but we also have tutorials for MicroPython.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/ESP32-Sensors-Modules-Free-Guides.jpg">
We have a similar article for the ESP8266: <a href="https://randomnerdtutorials.com/esp8266-nodemcu-guides-sensors-modules/" title="">20 Free Guides for Sensors and Modules [ESP8266]</a>.
Here's a quick list of the sensors/modules:
<k>Environmental Sensors:</k>
<ol>
DS18B20 Temperature Sensor
Type-K Thermocouple Temperature Sensor
DHT11/DHT22 Temperature and Humidity Sensor
BME280 Temperature, Humidity, and Pressure Sensor
BME680 Environmental Sensor (Gas, Pressure, Humidity, Temperature)
BMP388 Altimeter Sensor (Pressure, Altitude, Temperature)
BMP180 Barometric Sensor (Pressure, Altitude, Temperature)
BH1750 Light Sensor
TDS Sensor (Total Dissolved Solids)
</ol>
<k>Motion-Related Sensors:</k>
<ol start="10">
PIR Motion Sensor
Door Sensor (reed switch)
HC-SR04 Ultrasonic Sensor
MPU6050 Accelerometer and Gyroscope
RCWL-0516 Microwave Radar Proximity Sensor
</ol>
<k>Other Sensors/Modules/Peripherals:</k>
<ol start="15">
microSD Card Module
Potentiometer
Relay Module
Load Cell with HX711 Amplifier
</ol>
<k>Displays:</k>
<ol start="19">
OLED Display (SSD1306)
I2C LCD (Liquid Crystal Display)
RGB LED Strip
</ol>
<k>Communication:</k>
<ol start="22">
LoRa Transceiver
I2C Multiplexer (TCA9548A)
</ol>
<k>Motors:</k>
<ol start="24">
Servo Motor
DC Motor
Stepper Motor
</ol>
<h3>Environmental Sensors</h3>
<h3><a href="https://randomnerdtutorials.com/esp32-ds18b20-temperature-arduino-ide/">1. DS18B20 Temperature Sensor</a></h3>
<a href="https://randomnerdtutorials.com/esp32-ds18b20-temperature-arduino-ide/"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2016/10/ds18b20.png"></a>
The DS18B20 temperature sensor is a one-wire digital temperature sensor. This means that it just requires one data line (and GND) to communicate with your ESP32. Each DS18B20 temperature sensor has a unique 64-bit serial code. This allows you to wire multiple sensors to the same data wire. So, you can get temperature from multiple sensors using just one GPIO. 
The DS18B20 temperature sensor is also available in waterproof version.
<a href="https://randomnerdtutorials.com/esp32-ds18b20-temperature-arduino-ide/"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2016/10/ds18b20-waterproof.jpg"></a>
To get started, you can follow the next tutorials:
<k>Arduino core:</k>
<a href="https://randomnerdtutorials.com/esp32-ds18b20-temperature-arduino-ide/">ESP32 DS18B20 Temperature Sensor with Arduino IDE (Single, Multiple, Web Server)</a>
<a href="https://randomnerdtutorials.com/esp32-multiple-ds18b20-temperature-sensors/">ESP32 with Multiple DS18B20 Temperature Sensors</a>
<k>MicroPython:</k>
<a href="https://randomnerdtutorials.com/micropython-ds18b20-esp32-esp8266/">MicroPython: DS18B20 Temperature Sensor with ESP32 and ESP8266</a>
<a href="https://makeradvisor.com/tools/ds18b20-temperature-sensor-2/" target="_blank">Get a DS18B20 Temperature Sensor</a>.
<a href="https://makeradvisor.com/tools/ds18b20-digital-temperature-sensor/" target="_blank">Get a DS18B20 Temperature Sensor (waterproof version)</a>.
<h3><a href="https://randomnerdtutorials.com/esp32-k-type-thermocouple-max6675/">2. Type-K Thermocouple Temperature Sensor</a></h3>
<a href="https://randomnerdtutorials.com/esp32-k-type-thermocouple-max6675/"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/01/K-type-thermocouple-MAX6675-amplifier.png"></a>
A K-type thermocouple is a type of temperature sensor with a wide measurement range like <U+2212>200 to 1260oC (<U+2212>326 to 2300oF). To get the temperature from the thermocouple we need a thermocouple amplifier. We use the MAX6675 amplifier that is sold together with the thermocouple, but you can use any other amplifier, like the MAX31855.
To get started, follow the next tutorial:
<k>Arduino core:</k>
<a href="https://randomnerdtutorials.com/esp32-k-type-thermocouple-max6675/">ESP32: K-Type Thermocouple with MAX6675 Amplifier</a>
<a href="https://makeradvisor.com/tools/type-k-thermocouple-max6675-amplifier/" target="_blank">Get the Type-K Thermocouple temperature sensor.</a>
<h3><a href="https://randomnerdtutorials.com/esp32-dht11-dht22-temperature-humidity-sensor-arduino-ide/">3. DHT11/DHT22 Temperature and Humidity Sensor</a></h3>
<a href="https://randomnerdtutorials.com/esp32-dht11-dht22-temperature-humidity-sensor-arduino-ide/"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/dht11-dht22-sensors.jpg"></a>
The DHT11 and DHT22 sensors are used to measure temperature and relative humidity. These sensors contain a chip that does analog to digital conversion and spits out a digital signal with the temperature and humidity. This makes them very easy to use with any microcontroller.
To get started, follow the next tutorials:
<k>Arduino Core:</k>
<a href="https://randomnerdtutorials.com/esp32-dht11-dht22-temperature-humidity-sensor-arduino-ide/">ESP32 with DHT11/DHT22 Temperature and Humidity Sensor using Arduino IDE</a>
<k>MicroPython:</k>
<a href="https://randomnerdtutorials.com/esp32-esp8266-dht11-dht22-micropython-temperature-humidity-sensor/">MicroPython: ESP32/ESP8266 with DHT11/DHT22 Temperature and Humidity Sensor</a>
<a href="https://makeradvisor.com/tools/dht22-temperature-humidity-sensor/" target="_blank">Get a DHT22 temperature and humidity sensor.</a>
<a href="https://makeradvisor.com/tools/dht11-temperature-humidity-sensor/" target="_blank">Get a DHT11 temperature and humidity sensor.</a>
<h3><a href="https://randomnerdtutorials.com/esp32-bme280-arduino-ide-pressure-temperature-humidity/">4. BME280 Temperature, Humidity, and Pressure Sensor</a></h3>
<a href="https://randomnerdtutorials.com/esp32-bme280-arduino-ide-pressure-temperature-humidity/"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/BME280-sensor.png"></a>
The <a href="https://makeradvisor.com/tools/bme280-sensor-module/" target="_blank">BME280 sensor</a> module reads barometric pressure, temperature, and humidity. Because pressure changes with altitude, you can also estimate altitude. There are several versions of this sensor module: some can communicate using only I2C communication protocol, and others have the additional option to use the SPI communication protocol. We usually use the I2C protocol with this sensor. This sensor is very versatile and we use it in many of our tutorials.
To get started, follow the next tutorials:
<k>Arduino core:</k>
<a href="https://randomnerdtutorials.com/esp32-bme280-arduino-ide-pressure-temperature-humidity/">ESP32 with BME280 Sensor using Arduino IDE (Pressure, Temperature, Humidity)</a>
<k>MicroPython:</k>
<a href="https://randomnerdtutorials.com/micropython-bme280-esp32-esp8266/">MicroPython: BME280 with ESP32 and ESP8266 (Pressure, Temperature, Humidity)</a>
<a href="https://makeradvisor.com/tools/bme280-sensor-module/" target="_blank">Get a BME280 temperature, humidity, and pressure sensor.</a>
<h3><a href="https://randomnerdtutorials.com/esp32-bme680-sensor-arduino/">5. BME680 Environmental Sensor (Gas, Pressure, Humidity, Temperature)</a></h3>
<a href="https://randomnerdtutorials.com/esp32-bme680-sensor-arduino/"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/BME680-Gas-sensor-humidity-barometric-pressure-ambient-temperature-gas-air-quality.jpg"></a>
The BME680 is an environmental sensor that combines gas, pressure, humidity, and temperature sensors. The gas sensor can detect a broad range of gases like volatile organic compounds (VOC). For this reason, the BME680 can be used in indoor air quality control.
To get started, follow the next tutorials:
<k>Arduino core:</k>
<a href="https://randomnerdtutorials.com/esp32-bme680-sensor-arduino/">ESP32: BME680 Environmental Sensor using Arduino IDE (Gas, Pressure, Humidity, Temperature)</a>
<k>MicroPython: </k>
<a href="https://randomnerdtutorials.com/micropython-bme680-esp32-esp8266/">MicroPython: BME680 with ESP32 and ESP8266 (Temperature, Humidity, Pressure, Gas)</a>
<a href="https://makeradvisor.com/tools/bme680-gas-sensor-module/" target="_blank">Get a BME680 environmental sensor. </a>
<h3><a href="https://randomnerdtutorials.com/esp32-bmp388-arduino/">6. BMP388 Altimeter Sensor (Pressure, Altitude, Temperature)</a></h3>
<a href="https://randomnerdtutorials.com/esp32-bmp388-arduino/"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/BMP388-Sensor-Module-Temperature-Altitude-Pressure.jpg"></a>
The <a href="https://makeradvisor.com/tools/bmp388-sensor-module/" target="_blank">BMP388</a> is a precise, low-power, low-noise absolute barometric pressure sensor that measures absolute pressure and temperature. Because pressure changes with altitude, we can also estimate altitude with great accuracy. For this reason, this sensor is handy for drone navigation and other applications like vertical velocity calculation; internet of things; weather forecast, and weather stations; health care applications; fitness applications; and much more.
To get started, follow the next tutorial:
<k>Arduino core:</k>
<a href="https://randomnerdtutorials.com/esp32-bmp388-arduino/">ESP32 with BMP388 Barometric/Altimeter Sensor (Arduino IDE)</a>
<a href="https://makeradvisor.com/tools/bmp388-sensor-module/" target="_blank">Get a BMP388 altimeter sensor.</a>
<h3><a href="https://randomnerdtutorials.com/esp32-with-bmp180-barometric-sensor/">7. BMP180 Barometric Sensor (Pressure, Altitude, Temperature)</a></h3>
<a href="https://randomnerdtutorials.com/esp32-with-bmp180-barometric-sensor/"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/bmp180-arduino-sensor-module-img.jpg"></a>
The BMP180 is a digital pressure sensor and it measures the absolute pressure of the air around it. It features a measurement range from 300 to 1100hPa with an accuracy down to 0.02 hPa. Because temperature affects the pressure, the sensor comes with a temperature sensor to give temperature compensated pressure readings.
Additionally, because the pressure changes with altitude, you can also estimate the altitude based on the current pressure measurement. The sensor communicates with a microcontroller using I2C communication protocol.
To get started, follow the next tutorial:
<k>Arduino core:</k>
<a href="https://randomnerdtutorials.com/esp32-with-bmp180-barometric-sensor/">ESP32 with BMP180 Barometric Sensor  Guide</a>
<a href="https://makeradvisor.com/tools/bmp180-barometric-sensor/" target="_blank">Get a BMP180 barometric sensor.</a>
<h3><a href="https://randomnerdtutorials.com/esp32-bh1750-ambient-light-sensor/">8. BH1750 Light Sensor</a></h3>
<a href="https://randomnerdtutorials.com/esp32-bh1750-ambient-light-sensor/"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/01/BH1750-ambient-light-sensors.jpg"></a>
The BH1750 is a 16-bit ambient light sensor that communicates via I2C protocol. It outputs luminosity measurements in lux (SI-derived unit of illuminance). It can measure a minimum of 1 lux and a maximum of 65535 lux. It can be used in a wide variety of projects. For example: to detect if it is day or night; to adjust or turn on/off LED's brightness accordingly to ambient light; to adjust LCDs and screen's brightness; to detect if an LED is lit; etc.
To get started, follow the next tutorial:
<k>Arduino core:</k>
<a href="https://randomnerdtutorials.com/esp32-bh1750-ambient-light-sensor/">ESP32 with BH1750 Ambient Light Sensor</a>
<a href="https://makeradvisor.com/tools/bh1750-ambient-light-sensor/" target="_blank">Get a BH1750 ambient light sensor.</a>
<h3><a href="https://randomnerdtutorials.com/esp32-tds-water-quality-sensor/">9. TDS Sensor (Total Dissolved Solids)</a></h3>
<a href="https://randomnerdtutorials.com/esp32-tds-water-quality-sensor/"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/03/TDS-Sensor-263.jpg"></a>
A TDS meter indicates the total dissolved solids like salts, minerals, and metals, in a solution. This parameter can be used to give you an idea of water quality and compare water from different sources. One of the main applications of a TDS meter is aquarium water quality monitoring.
To get started, follow the next tutorial:
<k>Arduino core:</k>
<a href="https://randomnerdtutorials.com/esp32-tds-water-quality-sensor/">ESP32 with TDS Sensor (Water Quality Sensor)</a>
<a href="https://makeradvisor.com/tools/tds-sensor/" target="_blank">Get a TDS (total dissolved solids) sensor.</a>
<hr>
<h3>Motion Related Sensors</h3>
<h3><a href="https://randomnerdtutorials.com/esp32-pir-motion-sensor-interrupts-timers/">10. PIR Motion Sensor</a></h3>
<a href="https://randomnerdtutorials.com/esp32-pir-motion-sensor-interrupts-timers/"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2014/08/pir.jpg"></a>
The PIR motion sensor is ideal to detect movement. PIR stands for Passive Infrared and it measures infrared light from objects in its field of view. So, it can detect motion based on changes in infrared light in the environment. It is ideal to detect if a human or animal has moved in or out of the sensor range.
Get started with the following tutorials:
<k>Arduino core:</k>
<a href="https://randomnerdtutorials.com/esp32-pir-motion-sensor-interrupts-timers/">ESP32 with PIR Motion Sensor using Interrupts and Timers</a>
<k>MicroPython:</k>
<a href="https://randomnerdtutorials.com/micropython-interrupts-esp32-esp8266/">MicroPython: Interrupts with ESP32 and ESP8266 (PIR motion sensor)</a>
<a href="https://makeradvisor.com/tools/pir-motion-sensor-hc-sr501/" target="_blank">Get a PIR Motion Sensor (HC-SR501).</a>
<h3><a href="https://randomnerdtutorials.com/esp32-door-status-telegram/" title="ESP32 Door Status Monitor with Telegram Notifications">11. Door Sensor (reed switch)</a></h3>
<a href="https://randomnerdtutorials.com/esp32-door-status-telegram/"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/magnetic-reed-switch-white-img.jpg"></a>
A magnetic contact switch is a reed switch encased in a plastic shell so that you can easily apply it on a door, a window, or a drawer to detect if it is open or closed.
We have several tutorials with the ESP32 that use a reed switch and send notifications when the door is opened or closed:
<a href="https://randomnerdtutorials.com/esp32-door-status-telegram/">ESP32 Door Status Monitor with Telegram Notifications</a>
<a href="https://randomnerdtutorials.com/esp32-door-status-monitor-email/">ESP32 Door Status Monitor with Email Notifications (IFTTT)</a>
<a href="https://makeradvisor.com/tools/magnetic-reed-switch/" target="_blank">Get a magnetic reed switch.</a>
<h3><a href="https://randomnerdtutorials.com/esp32-hc-sr04-ultrasonic-arduino/">12. HC-SR04 Ultrasonic Sensor</a></h3>
<a href="https://randomnerdtutorials.com/esp32-hc-sr04-ultrasonic-arduino/"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/HC-SR04-ultrasonic-sensor.jpg"></a>
The HC-SR04 ultrasonic sensor uses sonar to determine the distance to an object. This sensor reads from 2cm to 400cm (0.8inch to 157inch) with an accuracy of 0.3cm (0.1inches), which is good for most hobbyist projects. In addition, this particular module comes with ultrasonic transmitter and receiver modules.
Get started with one of the following tutorials:
<k>Arduino core:</k>
<a href="https://randomnerdtutorials.com/esp32-hc-sr04-ultrasonic-arduino/">ESP32 with HC-SR04 Ultrasonic Sensor with Arduino IDE</a>
<k>MicroPython:</k>
<a href="https://randomnerdtutorials.com/micropython-hc-sr04-ultrasonic-esp32-esp8266/">MicroPython: HC-SR04 Ultrasonic Sensor with ESP32 and ESP8266 (Measure distance)</a>
<a href="https://makeradvisor.com/tools/ultrasonic-sensor-hc-sr04/" target="_blank">Get an HC-SR04 ultrasonic sensor.</a>
<h3><a href="https://randomnerdtutorials.com/esp32-mpu-6050-accelerometer-gyroscope-arduino/">13. MPU6050 Accelerometer and Gyroscope</a></h3>
<a href="https://randomnerdtutorials.com/esp32-mpu-6050-accelerometer-gyroscope-arduino/"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/MPU-6050-sensor.jpg"></a>
The MPU-6050 IMU (Inertial Measurement Unit) is a 3-axis accelerometer and 3-axis gyroscope sensor. The accelerometer measures the gravitational acceleration and the gyroscope measures the rotational velocity. Additionally, this module also measures temperature. This sensor is ideal to determine the orientation of a moving object.
To get started, follow the next tutorial:
<k>Arduino core:</k>
<a href="https://randomnerdtutorials.com/esp32-mpu-6050-accelerometer-gyroscope-arduino/">ESP32 with MPU-6050 Accelerometer, Gyroscope, and Temperature Sensor (Arduino)</a>
<a href="https://makeradvisor.com/tools/mpu-6050-3-axis-accelerometer-and-gyroscope-sensor/" target="_blank">Get an MPU6050 accelerometer and gyroscope.</a>
<h3><a href="https://randomnerdtutorials.com/esp32-rcwl-0516-arduino/" title="">14. RCWL-0516 Microwave Radar Proximity Sensor</a></h3>
<a href="https://randomnerdtutorials.com/esp32-rcwl-0516-arduino/"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/08/RCWL-0516-arduino-tutorial.jpg"></a>
The RCWL-0516 is a small, inexpensive sensor that uses microwave radar to detect the presence of moving objects. The RCWL-0516 sensor has a single output pin that goes HIGH when it detects movement. It outputs LOW when no motion is detected. This sensor is many times used as an alternative to the PIR motion sensor.
Get started with the following tutorial:
<a href="https://randomnerdtutorials.com/esp32-rcwl-0516-arduino/">ESP32 with RCWL-0516 Microwave Radar Proximity Sensor (Arduino IDE)</a>
Get an <a href="https://makeradvisor.com/tools/rcwl-0516-microwave-radar/" target="_blank" rel="noopener" title="">RCWL-0516 Microwave Radar Proximity Sensor</a>.
<hr>
<h3>Other Sensors/Modules/Peripherals</h3>
<h3><a href="https://randomnerdtutorials.com/esp32-microsd-card-arduino/" target="_blank">15. microSD Card Module</a></h3>
<a href="https://randomnerdtutorials.com/esp32-microsd-card-arduino/"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/02/microSD-card-module-ESP32-ESP8266-Arduino.png"></a>
The microSD card module allows you to interface the ESP32 with a microSD card. You can use the microSD card with the ESP32 to create, write, read, and delete files. It can be very useful for datalogging, to save configuration files or save files to serve to clients via a web server.
To get started, follow the next tutorial:
<k>Arduino core:</k>
<a href="https://randomnerdtutorials.com/esp32-microsd-card-arduino/">ESP32: Guide for MicroSD Card Module using Arduino IDE</a>
<a href="https://makeradvisor.com/tools/sd-card-module/" target="_blank">Get a microSD card module.</a>
<h3><a href="https://randomnerdtutorials.com/esp32-adc-analog-read-arduino-ide/">16. Potentiometer</a></h3>
<a href="https://randomnerdtutorials.com/esp32-adc-analog-read-arduino-ide/"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/potentiometer.jpg"></a>
A potentiometer, also referred to as a pot, is a manually adjustable resistor that can be used in numerous applications: adjust the speed of a DC motor, adjust the position of a stepper or servo motor, adjust threshold values, adjust light intensity, and much more.
To get a value from a potentiometer, you need to know how to read analog signals with the ESP32. Get started with the following tutorials:
<k>Arduino core:</k>
<a href="https://randomnerdtutorials.com/esp32-adc-analog-read-arduino-ide/">ESP32 ADC  Read Analog Values with Arduino IDE (potentiometer)</a>
<k>MicroPython:</k>
<a href="https://randomnerdtutorials.com/esp32-esp8266-analog-readings-micropython/">ESP32/ESP8266 Analog Readings with MicroPython</a>
To learn how a potentiometer works, we recommend taking a quick look at the following guide:
<a href="https://randomnerdtutorials.com/electronics-basics-how-a-potentiometer-works/">Electronics Basics  How a Potentiometer Works</a>
<a href="https://makeradvisor.com/tools/potentiometer-assortment-kit/" target="_blank">Get a potentiometers assortment kit. </a>
<h3><a href="https://randomnerdtutorials.com/esp32-relay-module-ac-web-server/">17. Relay Module</a></h3>
<a href="https://randomnerdtutorials.com/esp32-relay-module-ac-web-server/"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/03/relay-module.jpg"></a>
A relay is an electrically operated switch and like any other switch, it that can be turned on or off, letting the current go through or not. It can be controlled with low voltages, like the 3.3V provided by the ESP32 GPIOs, and allows us to control high voltages like 12V, 24V, or mains voltage (230V in Europe and 120V in the US).
Using a relay with the ESP32 is a great way to control AC household appliances remotely. Get started with the following tutorials:
<k>Arduino core:</k>
<a href="https://randomnerdtutorials.com/esp32-relay-module-ac-web-server/">ESP32 Relay Module  Control AC Appliances</a>
<k>MicroPython:</k>
<a href="https://randomnerdtutorials.com/micropython-relay-web-server-esp32-esp8266/">MicroPython: ESP32/ESP8266 Relay Module Web Server (AC Appliances)</a>
<k>Get a relay module</k>:
<a href="https://makeradvisor.com/tools/5v-2-channel-relay-module-optocoupler/" target="_blank">5V 2-channel relay module</a> (with optocoupler)
<a href="https://www.banggood.com/2Pcs-5V-1-Channel-Level-Trigger-Optocoupler-Relay-Module-For-Arduino-p-1366337.html?p=MA240439985285201910" target="_blank">5V 1-channel relay module</a> (with optocoupler)
<a href="https://www.banggood.com/5V-8-Channel-Relay-Module-Board-For-Arduino-PIC-AVR-DSP-ARM-p-74110.html?p=MA240439985285201910" target="_blank">5V 8-channel relay module</a> (with optocoupler)
<a href="https://www.banggood.com/BESTEP-16-Channel-5V-Relay-Module-LM2596-With-Optocoupler-Protection-Low-Level-Trigger-For-Auduino-p-1390338.html?p=MA240439985285201910&cur_warehouse=CN" target="_blank">5V 16-channel relay module</a> (with optocoupler)
<a href="https://www.banggood.com/BESTEP-1-Channel-3_3V-Low-Level-Trigger-Relay-Module-Optocoupler-Isolation-Terminal-For-Arduino-p-1355736.html?p=MA240439985285201910" target="_blank">3.3V 1-channel relay module</a> (with optocoupler)
<h3><a href="https://randomnerdtutorials.com/esp32-load-cell-hx711/">18. Load Cell with HX711 Amplifier</a></h3>
<a href="https://randomnerdtutorials.com/esp32-load-cell-hx711/"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/load-cell-hx711-amplifier-product.png"></a>
The load cell you see in the picture above is a strain gauge load cell. A strain gauge is an electrical sensor that measures force or strain on an object. The resistance of the strain gauge varies when an external force is applied to an object, which results in a deformation of the object's shape (in this case, the metal bar). The change of the resistance is proportional to the load applied, which allows us to calculate the weight of objects.
Get started with the following tutorial:
<k>Arduino core:</k>
<a href="https://randomnerdtutorials.com/esp32-load-cell-hx711/">ESP32 with Load Cell and HX711 Amplifier (Digital Scale)</a>
<a href="https://makeradvisor.com/tools/load-cell-hx711-amplifier/" target="_blank">Get a load cell with the HX711 amplifier.</a>
<hr>
<h3>Displays</h3>
<h3><a href="https://randomnerdtutorials.com/esp32-ssd1306-oled-display-arduino-ide/">19. OLED Display (SSD1306)</a></h3>
<a href="https://randomnerdtutorials.com/esp32-ssd1306-oled-display-arduino-ide/"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2016/07/oled.jpg"></a>
The <em>organic light-emitting diode </em>(OLED) display is a monocolor display that doesn't require backlight, which results in a very nice contrast in dark environments. Additionally, its pixels consume energy only when they are on, so the OLED display consumes less power when compared with other displays. It's available with different drivers, but we recommend getting the one with the SSD1306 driver, which is the most supported. There is also a wide variety of OLED sizes. We usually use the 0.96-inch display with 12864 pixels.
There are also ESP32 boards with a built-in OLED display. This is very useful because you don't need any extra circuitry if you want to add a physical visual interface to your project: <a href="https://randomnerdtutorials.com/esp32-built-in-oled-ssd1306/">ESP32 Built-in OLED Board (Wemos Lolin32): Pinout, Libraries and OLED Control</a>.
<k>Arduino core:</k>
<a href="https://randomnerdtutorials.com/esp32-ssd1306-oled-display-arduino-ide/">ESP32 OLED Display with Arduino IDE</a>
<a href="https://randomnerdtutorials.com/esp32-esp8266-dht-temperature-and-humidity-oled-display/">ESP32/ESP8266: DHT Temperature and Humidity Readings in OLED Display</a>
<k>MicroPython:</k>
<a href="https://randomnerdtutorials.com/micropython-oled-display-esp32-esp8266/">MicroPython: OLED Display with ESP32 and ESP8266</a>
<a href="https://randomnerdtutorials.com/micropython-ssd1306-oled-scroll-shapes-esp32-esp8266/">MicroPython: SSD1306 OLED Display Scroll Functions and Draw Shapes (ESP32/ESP8266)</a>
<a href="https://makeradvisor.com/tools/oled-display-128x64-0-96-inch/" target="_blank">Get an 0.96inch SSD1306 OLED display.</a>
<h3><a href="https://randomnerdtutorials.com/esp32-esp8266-i2c-lcd-arduino-ide/">20. I2C LCD (Liquid Crystal Display)</a></h3>
<a href="https://randomnerdtutorials.com/esp32-esp8266-i2c-lcd-arduino-ide/"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/I2C-LCD-OLED-display.png"></a>
The simplest and cheapest display screen around is the liquid crystal display (LCD). LCDs are found in everyday electronics devices like vending machines, calculators, parking meters, and printers, and are ideal for displaying text or small icons. 
LCDs are measured according to the number of rows and columns of characters that fit on the screen.  You'll find sizes ranging from 81 to 404. A 162 LCD can display 2 rows of 16 characters each and this is the one we use most in our projects. We recommend getting one that supports I2C because it makes wiring and coding even easier.
Get started with the following tutorial:
<k>Arduino core:</k>
<a href="https://randomnerdtutorials.com/esp32-esp8266-i2c-lcd-arduino-ide/">How to Use I2C LCD with ESP32 on Arduino IDE (ESP8266 compatible)</a>
<a href="https://makeradvisor.com/tools/i2c-lcd-16x2/" target="_blank">Get an I2C LCD display.</a>
<h3><a href="https://randomnerdtutorials.com/esp32-esp8266-rgb-led-strip-web-server/">21. RGB LED Strip</a></h3>
<a href="https://randomnerdtutorials.com/esp32-esp8266-rgb-led-strip-web-server/"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/rgb-led-strip.jpg"></a>
LED strips are just amazing, and there are a wide variety of LED strips to choose from. They can be analog, or digital, and vary in the density and number of LEDs, power supply, etc.
To learn more about the main differences between LED strips, I recommend taking a look at the following article: <a href="https://randomnerdtutorials.com/best-led-strip-for-your-project/">What's the Best LED Strip For Your Project? </a>
Analog LED strips have their LEDs wired in parallel. The whole strip works as a giant RGB LED. So, you can light up your whole strip in many different colors, but you can't control LEDs individually. This means your strip can only be one color at a time. This type of LED strips are cheaper than the digital ones and easier to use. You can follow the next tutorial that shows how to use those LED strips:
<k>Arduino core:</k>
<a href="https://randomnerdtutorials.com/esp32-esp8266-rgb-led-strip-web-server/">ESP32/ESP8266 RGB LED Strip with Color Picker Web Server</a>
When it comes to digital LED strips, you can control each LED individually  these are also called addressable LED strips. You can chose each LED color, its brightness and when they should be on and off. This allows you to do all sorts of crazy and awesome effects. Our favorite addressable RGB LED strip is the WS2812B. We have a MicroPython guide showing how to control an addressable RGB LED strip and produce amazing effects.
<k>MicroPython:</k>
<a href="https://randomnerdtutorials.com/micropython-ws2812b-addressable-rgb-leds-neopixel-esp32-esp8266/">MicroPython: WS2812B Addressable RGB LEDs with ESP32 and ESP8266</a>
<a href="https://makeradvisor.com/tools/dc12v-rgb-led-strip-ir-remote-controlled/" target="_blank">Get an Analog RGB LED Strip</a>.
<a href="https://makeradvisor.com/tools/ws2812b-addressable-rgb-led-strip/" target="_blank">Get a WS2812B addressable RGB LED Strip</a>.
<hr>
<h3>Communication</h3>
<h3><a href="https://randomnerdtutorials.com/esp32-lora-rfm95-transceiver-arduino-ide/">22. LoRa Transceiver</a></h3>
<a href="https://randomnerdtutorials.com/esp32-lora-rfm95-transceiver-arduino-ide/"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/RFM95-LoRa-transceiver-module.jpg"></a>
LoRa is a wireless data communication technology that uses a radio modulation technique that can be generated by Semtech LoRa transceiver chips. This modulation technique allows long-range communication of small amounts of data (which means a low bandwidth), and high immunity to interference while minimizing power consumption. So, it allows long-distance communication with low power requirements.
To use LoRa in your projects, you can use a transceiver like the <a href="https://makeradvisor.com/tools/rfm95-lora-transceiver-module/" target="_blank">RFM95 </a>or use an <a href="https://makeradvisor.com/esp32-sx1276-lora-ssd1306-oled/" target="_blank">ESP32 with a built-in LoRa transceiver module</a>.
Get started with the following tutorials:
<k>Arduino core:</k>
<a href="https://randomnerdtutorials.com/esp32-lora-rfm95-transceiver-arduino-ide/">ESP32 with LoRa using Arduino IDE  Getting Started</a>
<a href="https://randomnerdtutorials.com/ttgo-lora32-sx1276-arduino-ide/">TTGO LoRa32 SX1276 OLED Board: Getting Started with Arduino IDE</a>
<a href="https://makeradvisor.com/tools/rfm95-lora-transceiver-module/" target="_blank">Get an RFM95 LoRa transceiver module</a>.
<a href="https://makeradvisor.com/tools/ttgo-lora32-sx1276-esp32-oled/" target="_blank">Get an ESP32 with a built-in LoRa chip</a>. 
<h3><a href="https://randomnerdtutorials.com/tca9548a-i2c-multiplexer-esp32-esp8266-arduino/">23. TCA9548A I2C Multiplexer</a></h3>
<a href="https://randomnerdtutorials.com/tca9548a-i2c-multiplexer-esp32-esp8266-arduino/"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/TCA9548A-I2C-Multiplexer.jpg"></a>
The I2C communication protocol allows you to communicate with multiple I2C devices on the same I2C bus as long as each device has a unique I2C address. However, it will not work if you want to connect multiple I2C devices with the same address.
The <a href="https://makeradvisor.com/tools/tca9548a-i2c-multiplexer/" target="_blank">TCA9548A I2C multiplexer</a> allows you to communicate with up to 8 I2C devices with the same I2C bus. The multiplexer communicates with a microcontroller using the I2C communication protocol. Then, you can select which I2C bus on the multiplexer you want to address.
Get started with the following tutorial:
<k>Arduino core:</k>
<a href="https://randomnerdtutorials.com/tca9548a-i2c-multiplexer-esp32-esp8266-arduino/">Guide for TCA9548A I2C Multiplexer: ESP32, ESP8266, Arduino</a>
<a href="https://makeradvisor.com/tools/tca9548a-i2c-multiplexer/" target="_blank">Get a TCA9584A I2C multiplexer</a>.
<hr>
<h3>Motors</h3>
<h3><a href="https://randomnerdtutorials.com/esp32-servo-motor-web-server-arduino-ide/" title="ESP32 Servo Motor Web Server with Arduino IDE">24. Servo Motor</a></h3>
<a href="https://randomnerdtutorials.com/esp32-servo-motor-web-server-arduino-ide/"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/micro-Servo-motor.jpg"></a>
Learn how to control a servo motor with the ESP32 remotely using a web server:
<a href="https://randomnerdtutorials.com/esp32-servo-motor-web-server-arduino-ide/">ESP32 Servo Motor Web Server with Arduino IDE</a>
<a href="https://makeradvisor.com/tools/micro-servo-motor-tool/" target="_blank">Get a micro servo motor</a>.
<h3><a href="https://randomnerdtutorials.com/esp32-dc-motor-l298n-motor-driver-control-speed-direction/">25. DC Motor and L298N Motor Driver</a></h3>
<a href="https://randomnerdtutorials.com/esp32-dc-motor-l298n-motor-driver-control-speed-direction/"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/DC-motor-L298N-driver.jpg"></a>
Learn how to control a DC motor (speed and direction) with the ESP32 using the L298N motor driver. To get started, follow the next tutorial:
<k>Arduino core:</k>
<a href="https://randomnerdtutorials.com/esp32-dc-motor-l298n-motor-driver-control-speed-direction/">ESP32 with DC Motor and L298N Motor Driver  Control Speed and Direction</a>
<a href="https://makeradvisor.com/tools/mini-dc-motor/" target="_blank">Get a mini DC motor.</a>
<a href="https://makeradvisor.com/tools/l298n-motor-driver/" target="_blank">Get a L298N motor driver.</a>
<h3><a href="https://randomnerdtutorials.com/esp32-stepper-motor-28byj-48-uln2003/">26. Stepper Motor</a></h3>
<a href="https://randomnerdtutorials.com/esp32-stepper-motor-28byj-48-uln2003/"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/stepper-motor-28byj-48-and-ULN2003-motor-driver.jpg"></a>
A stepper motor is a brushless DC electric motor that divides a full rotation into a number of steps. It moves one step at a time, and each step is the same size. This allows us to rotate the motor at a precise angle to a precise position. The stepper motor can rotate clockwise or counterclockwise.
To get started, follow the next tutorial:
<k>Arduino core:</k>
<a href="https://randomnerdtutorials.com/esp32-stepper-motor-28byj-48-uln2003/">ESP32 with Stepper Motor (28BYJ-48 and ULN2003 Motor Driver)</a>
<a href="https://makeradvisor.com/tools/28byj-48-stepper-motor-uln2003/" target="_blank">Get a stepper motor (2BYJ-48).</a>
<h3>Wrapping Up</h3>
This was our compilation of tutorials for the most popular sensors, modules, and peripherals compatible with the ESP32.
If you have a sensor/module that you would like to be covered on our website, just write a comment below.
<h2>Send Pushover Notifications (Arduino IDE)</h2>
In this guide, you'll learn how to send ESP32 notifications to Pushover. Pushover is a notification service that integrates with many applications. You can send push notifications to all of your devices and multiple users. You can manage your notifications with levels of priority, set silent hours, and set different sounds depending on the notification.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/02/ESP32-Pushover-Notifications-Tutorial-1.jpg">
<k>Table of Contents</k>
Introducing Pushover App
Installing Pushover App
Getting Pushover API Key and User Key
Pushover Notifications with the ESP32  Example Sketch (Arduino IDE)
Sending Pushover Notifications with the ESP32  Demonstration
New to the ESP32? <a href="https://randomnerdtutorials.com/getting-started-with-esp32/" title="">Start here: Getting Started with the ESP32 Development Board</a>.
<h3>Introducing Pushover</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/02/pushover-logo.png">
Pushover is a mobile and desktop app compatible with Android and iOS and Windows, MacOS, and Linux. It allows you to receive notifications from different sources and services and integrates with many applications.
You can receive notifications on all your devices simultaneously or send them to groups with multiple users. Additionally, you can customize things such as priority levels, set silent hours, and even different sounds depending on the type of notification.
After publishing<a href="https://randomnerdtutorials.com/send-notifications-esp32/" title=""> this previous tutorial</a>, we found that many of our readers were already using Pushover for other types of notifications. So, we thought it would be useful to know how to integrate Pushover with the ESP32 so that you have all your notifications in one place.
<h3>Pushover Pricing</h3>
You have a <k>free 30-day trial period </k>from the time you register so that you can experiment with the app. After that, if you want to continue using the app, it's just a one-time $5 USD purchase. Each user can send up to 10,000 messages per month for free.

<h3>Installing Pushover App</h3>
You can install the Pushover app on your computer, tablet, and smartphone. It is compatible with Windows, MacOS, and Linux, and with Android and iOS.
Download the app into your smartphone and create an account to get started.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/02/IMG_8963.png">
After creating your account, you'll have a free 30-day trial period.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/02/pushover-free-trial-get-started.png">
After that, you'll need to go to your email to verify your account.
<h3>Getting Pushover API Key and User Key</h3>
To send notifications to Pushover with the ESP32, we need to get an API key and the user (receiver) key.
For this step, we recommend logging in to your pushover account on your computer browser. Login here: <a href="https://pushover.net/login" target="_blank" rel="noopener" title="">https://pushover.net/login</a>.
You'll get access to your Pushover dashboard.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/02/pushover-dashboard.png">
At the top right corner, there's the <k>User Key</k>. Save it because you'll need it later.
You can also see all your devices and add more devices if you want. You can try to Push a Notification at the top left corner to check if notifications are working with your device.
Scroll down the page to create an Application/API Token.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/02/pushover-create-application-api-token-f.png">
Give a name and description(optional) to the API Token. You can also add an icon to that. We added an icon of an ESP32. So, when we receive a notification, it will be accompanied by the ESP32 icon. Finally, create the application.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/02/pushover-create-application-1.png">
Now, the application will show up on your dashboard under the <em>Your Applications</em> section.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/02/ESP32-application-pushover.png">
Click on the application name to get its API token. On that menu, you can also check how many notifications you have sent with that API token.
Save the API token because you'll need it later.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/02/Pushover-API-Token-ESP32.png">
Now that you have the user key and API token, you can start sending ESP32 notifications with Pushover.
<h3>Pushover Notifications with the ESP32  Example Sketch</h3>
Sending Pushover notifications with the ESP32 is very straightforward thanks to its API.<a href="https://pushover.net/api" target="_blank" rel="noopener" title=""> You can read Pushover's API documentation here</a>. You simply need to POST an HTTPS request with the ESP32 with the right parameters to the API endpoint: https://api.pushover.net/1/messages.json.
You must pass the following parameters:
token: your application's API token
user: your user key or user group key
message: the notification content
You can also pass other optional parameters:
attachment: an image attachment to send with the message.
device: the name of the device you want to receive the notification.
html: set to 1 to enable HTML parsing.
priority: set the notification priority level: a value of -2, -1, 0 (default), 1, or 2.
sound: the name of a supported sound to override your default sound choicevalues can be pushover, bike, bugle, cashregister, classical, cosmic, etc (<a href="https://pushover.net/api#sounds" target="_blank" rel="noopener" title="">check all available sound options here</a>). You can even upload your own sounds to your Pushover dashboard.
timestamp: a Unix timestamp of a time to display instead of when our API received the request.
title: your message's title, otherwise your app's name is used.
url: a supplementary URL to show with your message (documentation).
url_title: a title for the URL specified as the url parameter, otherwise just the URL is shown.
For more information about all the parameters, please <a href="https://pushover.net/api" target="_blank" rel="noopener" title="">check Pushover's API documentation</a>.
The code below shows how to send Pushover notifications with the ESP32 using an HTTPS POST request.
Before uploading the code to your board you need to insert your SSID and password, the user key, and Pushover App API token.
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-pushover-notifications-arduino/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
#include &lt;WiFi.h>
#include &lt;HTTPClient.h>
#include &lt;WiFiClientSecure.h>
#include &lt;ArduinoJson.h>
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
const char* apiToken = "API_TOKEN";
const char* userToken = "USER_TOKEN";
//Pushover API endpoint
const char* pushoverApiEndpoint = "https://api.pushover.net/1/messages.json";
//Pushover root certificate (valid from 11/10/2006 to 11/10/2031)
const char *PUSHOVER_ROOT_CA = "-----BEGIN CERTIFICATE-----\n"
                 "MIIDrzCCApegAwIBAgIQCDvgVpBCRrGhdWrJWZHHSjANBgkqhkiG9w0BAQUFADBh\n"
                 "MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3\n"
                 "d3cuZGlnaWNlcnQuY29tMSAwHgYDVQQDExdEaWdpQ2VydCBHbG9iYWwgUm9vdCBD\n"
                 "QTAeFw0wNjExMTAwMDAwMDBaFw0zMTExMTAwMDAwMDBaMGExCzAJBgNVBAYTAlVT\n"
                 "MRUwEwYDVQQKEwxEaWdpQ2VydCBJbmMxGTAXBgNVBAsTEHd3dy5kaWdpY2VydC5j\n"
                 "b20xIDAeBgNVBAMTF0RpZ2lDZXJ0IEdsb2JhbCBSb290IENBMIIBIjANBgkqhkiG\n"
                 "9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4jvhEXLeqKTTo1eqUKKPC3eQyaKl7hLOllsB\n"
                 "CSDMAZOnTjC3U/dDxGkAV53ijSLdhwZAAIEJzs4bg7/fzTtxRuLWZscFs3YnFo97\n"
                 "nh6Vfe63SKMI2tavegw5BmV/Sl0fvBf4q77uKNd0f3p4mVmFaG5cIzJLv07A6Fpt\n"
                 "43C/dxC//AH2hdmoRBBYMql1GNXRor5H4idq9Joz+EkIYIvUX7Q6hL+hqkpMfT7P\n"
                 "T19sdl6gSzeRntwi5m3OFBqOasv+zbMUZBfHWymeMr/y7vrTC0LUq7dBMtoM1O/4\n"
                 "gdW7jVg/tRvoSSiicNoxBN33shbyTApOB6jtSj1etX+jkMOvJwIDAQABo2MwYTAO\n"
                 "BgNVHQ8BAf8EBAMCAYYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUA95QNVbR\n"
                 "TLtm8KPiGxvDl7I90VUwHwYDVR0jBBgwFoAUA95QNVbRTLtm8KPiGxvDl7I90VUw\n"
                 "DQYJKoZIhvcNAQEFBQADggEBAMucN6pIExIK+t1EnE9SsPTfrgT1eXkIoyQY/Esr\n"
                 "hMAtudXH/vTBH1jLuG2cenTnmCmrEbXjcKChzUyImZOMkXDiqw8cvpOp/2PV5Adg\n"
                 "06O/nVsJ8dWO41P0jmP6P6fbtGbfYmbW0W5BjfIttep3Sp+dWOIrWcBAI+0tKIJF\n"
                 "PnlUkiaY4IBIqDfv8NZ5YBberOgOzW6sRBc4L0na4UU+Krk2U886UAb3LujEV0ls\n"
                 "YSEY1QSteDwsOoBrp+uvFRTp2InBuThs4pFsiv9kuXclVzDAGySj4dzp30d8tbQk\n"
                 "CAUw7C29C79Fv1C5qfPrmAESrciIxpg0X40KPMbp1ZWVbd4=\n"
                 "-----END CERTIFICATE-----\n";
void setup() {
  Serial.begin(115200);
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println("Connecting to WiFi...");
  }
  Serial.println("Connected to WiFi");
  //Make HTTPS POST request to send notification
  if (WiFi.status() == WL_CONNECTED) {
    // Create a JSON object with notification details
    // Check the API parameters: https://pushover.net/api
    StaticJsonDocument&lt;512> notification; 
    notification["token"] = apiToken; //required
    notification["user"] = userToken; //required
    notification["message"] = "Hello from ESP32"; //required
    notification["title"] = "ESP32 Notification"; //optional
    notification["url"] = ""; //optional
    notification["url_title"] = ""; //optional
    notification["html"] = ""; //optional
    notification["priority"] = ""; //optional
    notification["sound"] = "cosmic"; //optional
    notification["timestamp"] = ""; //optional
    // Serialize the JSON object to a string
    String jsonStringNotification;
    serializeJson(notification, jsonStringNotification);
    // Create a WiFiClientSecure object
    WiFiClientSecure client;
    // Set the certificate
    client.setCACert(PUSHOVER_ROOT_CA);
    // Create an HTTPClient object
    HTTPClient https;
    // Specify the target URL
    https.begin(client, pushoverApiEndpoint);
    // Add headers
    https.addHeader("Content-Type", "application/json");
    // Send the POST request with the JSON data
    int httpResponseCode = https.POST(jsonStringNotification);
    // Check the response
    if (httpResponseCode > 0) {
      Serial.printf("HTTP response code: %d\n", httpResponseCode);
      String response = https.getString();
      Serial.println("Response:");
      Serial.println(response);
    } else {
      Serial.printf("HTTP response code: %d\n", httpResponseCode);
    }
    // Close the connection
    https.end();
  }
}
void loop() {
  
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_Pushover_Notifications.ino" target="_blank">View raw code</a>
<h3>How the Code Works</h3>
Continue reading the learn how the code works, or skip to the demonstration section.
<h4>Include Libraries</h4>
You start by including the required libraries. The WiFi library to connect the ESP32 to your network, so that it can connect to the internet. The HTTPClient and WiFiClientSecure libraries will be used to make secure HTTP POST requests, and we'll use the ArduinoJSON library to create a JSON string to send all the required parameters on the body of the HTTP POST request.
<k>#include &lt;WiFi.h>
#include &lt;HTTPClient.h>
#include &lt;WiFiClientSecure.h>
#include &lt;ArduinoJson.h></k>
<h4>Network Credentials</h4>
Insert your network credentials in the following variables.
<k>const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
<h4>API Token and User Token</h4>
Insert the API token and user token on the following variables:
<k>const char* apiToken = "API_TOKEN";
const char* userToken = "USER_TOKEN";</k>
<h4>API Endpoint</h4>
Then, we set the API endpoint URL where we'll make the requests. According to the documentation, it is as follows:
<k>const char* pushoverApiEndpoint = "https://api.pushover.net/1/messages.json";</k>
<h4>SSL Certificate</h4>
To make secure HTTPS requests, we need the pushover's website TLS certificate. We're using the root certificate. It is valid until 2031. To learn how to get a website's TLS certificate, you can read this: <a href="https://randomnerdtutorials.com/esp32-https-requests/#getting-server-certificate-google-chrome" title="">Getting a Server's Certificate using Google Chrome</a>.
<k>const char *PUSHOVER_ROOT_CA = "-----BEGIN CERTIFICATE-----\n"
                 "MIIDrzCCApegAwIBAgIQCDvgVpBCRrGhdWrJWZHHSjANBgkqhkiG9w0BAQUFADBh\n"
                 "MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3\n"
                 "d3cuZGlnaWNlcnQuY29tMSAwHgYDVQQDExdEaWdpQ2VydCBHbG9iYWwgUm9vdCBD\n"
                 "QTAeFw0wNjExMTAwMDAwMDBaFw0zMTExMTAwMDAwMDBaMGExCzAJBgNVBAYTAlVT\n"
                 "MRUwEwYDVQQKEwxEaWdpQ2VydCBJbmMxGTAXBgNVBAsTEHd3dy5kaWdpY2VydC5j\n"
                 "b20xIDAeBgNVBAMTF0RpZ2lDZXJ0IEdsb2JhbCBSb290IENBMIIBIjANBgkqhkiG\n"
                 "9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4jvhEXLeqKTTo1eqUKKPC3eQyaKl7hLOllsB\n"
                 "CSDMAZOnTjC3U/dDxGkAV53ijSLdhwZAAIEJzs4bg7/fzTtxRuLWZscFs3YnFo97\n"
                 "nh6Vfe63SKMI2tavegw5BmV/Sl0fvBf4q77uKNd0f3p4mVmFaG5cIzJLv07A6Fpt\n"
                 "43C/dxC//AH2hdmoRBBYMql1GNXRor5H4idq9Joz+EkIYIvUX7Q6hL+hqkpMfT7P\n"
                 "T19sdl6gSzeRntwi5m3OFBqOasv+zbMUZBfHWymeMr/y7vrTC0LUq7dBMtoM1O/4\n"
                 "gdW7jVg/tRvoSSiicNoxBN33shbyTApOB6jtSj1etX+jkMOvJwIDAQABo2MwYTAO\n"
                 "BgNVHQ8BAf8EBAMCAYYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUA95QNVbR\n"
                 "TLtm8KPiGxvDl7I90VUwHwYDVR0jBBgwFoAUA95QNVbRTLtm8KPiGxvDl7I90VUw\n"
                 "DQYJKoZIhvcNAQEFBQADggEBAMucN6pIExIK+t1EnE9SsPTfrgT1eXkIoyQY/Esr\n"
                 "hMAtudXH/vTBH1jLuG2cenTnmCmrEbXjcKChzUyImZOMkXDiqw8cvpOp/2PV5Adg\n"
                 "06O/nVsJ8dWO41P0jmP6P6fbtGbfYmbW0W5BjfIttep3Sp+dWOIrWcBAI+0tKIJF\n"
                 "PnlUkiaY4IBIqDfv8NZ5YBberOgOzW6sRBc4L0na4UU+Krk2U886UAb3LujEV0ls\n"
                 "YSEY1QSteDwsOoBrp+uvFRTp2InBuThs4pFsiv9kuXclVzDAGySj4dzp30d8tbQk\n"
                 "CAUw7C29C79Fv1C5qfPrmAESrciIxpg0X40KPMbp1ZWVbd4=\n"
                 "-----END CERTIFICATE-----\n";</k>
<h4>Connect to Wi-Fi</h4>
In the setup(), start by connecting the ESP32 to your network:
<k>Serial.begin(115200);
WiFi.begin(ssid, password);
while (WiFi.status() != WL_CONNECTED) {
  delay(1000);
  Serial.println("Connecting to WiFi...");
}
Serial.println("Connected to WiFi");</k>
Learn more about ESP32 Wi-Fi functions: <a href="https://randomnerdtutorials.com/esp32-useful-wi-fi-functions-arduino/" title="">ESP32 Useful Wi-Fi Library Functions (Arduino IDE)</a>.
<h3>Setting Notification Parameters</h3>
After making sure we are connected to Wi-Fi, we create a JSON object called notification with the required parameters and some of the optional parameters. The required parameters are the API token, user token and the message.
<k>StaticJsonDocument&lt;512> notification; 
notification["token"] = apiToken; //required
notification["user"] = userToken; //required
notification["message"] = "Hello from ESP32"; //required
notification["title"] = "ESP32 Notification"; //optional
notification["url"] = ""; //optional
notification["url_title"] = ""; //optional
notification["html"] = ""; //optional
notification["priority"] = ""; //optional
notification["sound"] = "cosmic"; //optional
notification["timestamp"] = ""; //optional</k>
As you can see, the message is set on the following line:
<k>notification["message"] = "Hello from ESP32"; //required</k>
You can change the message to whatever it's useful for your application.
We also set the message title on the following line:
<k>notification["title"] = "ESP32 Notification"; //optional</k>
After getting all the parameters in a JSON object, we convert it to a String so that we can send it in the body of the HTTP POST request.
<k>String jsonStringNotification;
serializeJson(notification, jsonStringNotification);</k>
<h4>HTTPS POST Request</h4>
Now, we can finally make the HTTPS POST request.
Learn more about secure HTTPS requests with the ESP32: <a href="https://randomnerdtutorials.com/esp32-https-requests/" title="">ESP32 HTTPS Requests (Arduino IDE)</a>.
Learn more about HTTP POST requests with the ESP32:<a href="https://randomnerdtutorials.com/esp32-http-post-ifttt-thingspeak-arduino/" title=""> ESP32 HTTP POST Requests</a>. 
Create a WiFiClientSecure object called client.
<k>WiFiClientSecure client;</k>
Set a secure client with the certificate using the setCACert() method:
<k>client.setCACert(PUSHOVER_ROOT_CA);</k>
Then, create an HTTPClient instance called https.
<k>HTTPClient https;</k>
Initialize the https client on the host specified using the begin() method. In this case, we're making a request on the API endpoint.
<k>https.begin(client, pushoverApiEndpoint);</k>
Then, add the HTTP POST headerswe need to specify that we're going to send the data as a JSON string in the request body.
<k>// Add headers
https.addHeader("Content-Type", "application/json");</k>
Finally, we can send the POST request with the JSON data.
<k>// Send the POST request with the JSON data
int httpResponseCode = https.POST(jsonStringNotification);</k>
After making the request, we can check the server response. This is useful to know if the request succeeded or if there were any problems during the request or with the request body. To get the server response, we simply need to use the getString() method on the https object.
<k>if (httpResponseCode > 0) {
    Serial.printf("HTTP response code: %d\n", httpResponseCode);
    String response = https.getString();
    Serial.println("Response:");
    Serial.println(response);
  } else {
    Serial.printf("HTTP response code: %d\n", httpResponseCode);
}</k>
Finally, close the HTTPS connection using the end() method:
<k>https.end();</k>
This example sends a notification in the setup() when the ESP32 first runs. So, the loop() is empty. The idea is that you use this example in your own application. For example, to send a notification when motion is detected, when a sensor reading is above or below a certain threshold, to send sensor readings or GPIO states regularly, and many other possibilities in the home automation and IoT fields.
<h3>Demonstration</h3>
After inserting the SSID, password, user key, and API key, you can upload the code to your board.
After uploading, open the Serial Monitor at a baud rate of 115200. Press the ESP32 RST button so that it starts running the code.
You should get a success message (response code: 200) on your Serial Monitor.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/02/ESP32-Pushove-Request-Notification-Serial-Monitor.png">
And you should receive the notification on your smartphone.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/02/ESP32-message-received-pushover.png">
You can click on the message to open it.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/02/ESP32-notificaiton-received-pushover.png">
<h3>Pushover Settings</h3>
On your device, you can adjust the settings for your notifications. Click on the () icon at the top right corner. 
You'll get a page as shown below. You can set quiet hours and other settings like volume and sound for critical alerts, add custom sounds, and more.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/02/pushover-settings-notifications.png">
<h3>Wrapping Up</h3>
Pushover is a notification service that you can use to receive notifications from different apps and services in the same place. You can manage your notifications in terms of priority, set silence hours, and even set different sounds depending on the notification received.
In this tutorial, you learned how to send ESP32 notifications to Pushover using Pushover's API. Using the Pushover app is not free, but you have a 30-day free trial. If you decide that it is useful for your projects, you can have access to the app with a one-time payment fee of just 5$.

<h2>How to Log Data (9 Different Ways)</h2>
In this article, we'll share nine different methods to log and save data with the ESP32. Would you like to monitor a specific sensor with the ESP32 and keep track of the data over time? Would you like to save all your data records but you don't know how to do it or which method to use? Here we'll show you different ways to save data permanently with the ESP32. We'll show you methods that rely on third-party databases, services, hardware solutions, and others.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/01/ESP32-Different-Data-Storage-Methods.jpg">
<k>Table of Contents:</k>
Throughout this article, we'll cover the following methods to save data using the ESP32:
<ol>
MicroSD Card
ESP32 Filesystem (SPIFFS or LittleFS)
Firebase Realtime Database and Firebase Storage
InfluxDB Time Series Database
">Deta Base: Free and Unlimited Database
Thingspeak Channels
Google sheets
MySQL on a Cloud Server
MySQL on a Local Server
</ol>
<h3>1) ESP32 Datalogging using a MicroSD Card</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/02/ESP32-microSD-card-module-wiring-breadboard.jpg">
Using a microSD card with the ESP32 is a great way to save data permanently. You can save big amounts of data in <em>txt </em>or in other formatsas much as the microSD card size allows you to. You can also <a href="https://randomnerdtutorials.com/esp32-cam-photo-microsd-card-timestamp/" title="save pictures if you're using an ESP32-CAM">save pictures if you're using an ESP32-CAM</a>.
To interface a microSD card with the ESP32, you can use a microSD card module that communicates with the board via SPI communication protocol. These modules are usually pretty cheap. You can <a href="https://makeradvisor.com/tools/sd-card-module/" target="_blank" rel="noopener">check some microSD card modules here</a>. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/02/microSD-card-module-ESP32-ESP8266-Arduino.png">
Some ESP32 development boards already come with a built-in microSD card slot, so you won't need any extra circuitry or hardware.
We have a complete guide showing how to interface a microSD card with the ESP32 and how to handle filesread, write, create, delete, append, and much more.
<a href="https://randomnerdtutorials.com/esp32-microsd-card-arduino/">ESP32: Guide for MicroSD Card Module using Arduino IDE</a>
If you want a specific datalogging example with sensors, we also have the following projects (you can easily modify the projects to use other sensors):
<a href="https://randomnerdtutorials.com/altimeter-datalogger-esp32-bmp388/">Altimeter Datalogger: ESP32 with BMP388, MicroSD Card Storage and OLED Display</a>
<a href="https://randomnerdtutorials.com/esp32-data-logging-temperature-to-microsd-card/">ESP32 Data Logging Temperature to MicroSD Card</a>
<k>Advantages of using a microSD card with the ESP32 for datalogging:</k>
<k>Low-cost solution</k>: microSD card modules are very cheap.
<k>Huge storage capacity</k>: microSD cards are widely available and can save huge amounts of data.
<k>Easy to use</k>: it is easy to connect and easy to program with the ESP32.
<k>Doesn't require a connection to the internet</k>: so it's an interesting solution in remote places.
It can save data in different file formats.
However, you need to take into account some of the following disadvantages:
<k>Extra hardware</k>: unless your board already comes with a built-in microSD card slot, you'll need to get a microSD card module.
<k>Data corruption</k>: after long periods of using the microSD card, it might be corrupted and you'll lose all your data;
<k>Data is not accessible in real-time</k>: you need to remove the microSD card from the board and insert it into your computer to access the data (unless you build a webserver that serves the microSD card files online).
<hr>
<h3>2) Save Files on the ESP32 Filesystem (SPIFFS or LittleFS)</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/01/ESP32-Store-Data-SPIFFS-Filesystem.jpg">
The ESP32 contains a Serial Peripheral Interface Flash File System (SPIFFS). SPIFFS is a lightweight filesystem created for microcontrollers with a flash chip (like the ESP32) that allows you to store files in the flash memory.
Here are some tutorials using the ESP32 filesystem:
<a href="https://randomnerdtutorials.com/install-esp32-filesystem-uploader-arduino-ide/">Install ESP32 Filesystem Uploader in Arduino IDE</a>
<a href="https://randomnerdtutorials.com/esp32-web-server-spiffs-spi-flash-file-system/" title="">ESP32 Web Server using SPIFFS (SPI Flash File System)</a>
SPIFFS lets you access the flash memory like you would do in a normal filesystem in your computer, but simpler and more limited. You can read, write, close, and delete files. The SPIFFS library that allows you to interact with the flash chip doesn't support directories, so everything is saved on a flat structure.
LittleFS is a new filesystem that you can use with the ESP32 that supports directories, is faster, and has some other improvements over SPIFFS.
You can create files to save data on the ESP32 filesystem as you would do with a microSD card. The advantage is that you don't need any extra hardware. However, it's not appropriate for saving big amounts of data or for long-term datalogging applications and you're limited to the size dedicated to the filesystem on the ESP2 partition.
<k>Advantages of using SPIFFS or LittleFS with the ESP32 for datalogging:</k>
<k>Easy to use</k>: it is compatible with the FS.h library it's also used with the microSD card to create and handle files.
<k>No extra hardware needed</k>: all ESP32 boards comes with a flash chip, so you can use SPIFFS or LittleFS straight away.
Doesn't require internet connection.
<k>Disadvantages:</k>
<k>Storage limit</k>: the number and size of files you can save will depend on the flash chip memory size. Most will be in the range of 4MB, so the SPIFFS/LittleFS partition will be lower than that. Additonally, you can't use all SPIFFS partition memory for storage, only about 75%<a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/storage/spiffs.html" target="_blank" rel="noopener">check the docs</a>.
<k>Not suitable for long term datalogging</k> or very frequent writes: read and write to the filesystem might become slower as the available memory decreases.
<k>Not easy to visualize your data</k>: if you need to access all your data to process it later, you'll need to write a sketch that gets all data saved in spiffs, or a server that provides access to the filesystem files.
<h3>3) ESP32 Save Data to the Firebase Realtime Database</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/Firebase-logo.png">
Firebase is Google's mobile application development platform that provides several tools to save data:
<k>Realtime Database</k>: realtime, cloud-hosted, NoSQL database; data is stored in a JSON structure.
<k>Cloud Firestore</k>: realtime, cloud-hosted, NoSQL database; data is stored in documents.
<k>Cloud Storage</k>: scalable file storage to upload and download files.
After saving your data on Firebase, you can access all the data online by going to your Firebase console. Additionally, you can easily interact with their storage and database services using javascript and other programming languages, so you can create your own web application to display that data online as we do in our <a href="https://randomnerdtutorials.com/firebase-esp32-esp8266-ebook/">Firebase Web App with the ESP32 and ESP8266 eBook</a>. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/12/ESP-Firebase-Realtime-Database-Data-Logging.png">
We prefer using the Realtime Database for datalogging projects, because, in our opinion, it's easier to handle and program than Cloud Firestore. We have the following guides to learn how to get started datalogging using Firebase Realtime Database.
<a href="https://randomnerdtutorials.com/esp32-firebase-realtime-database/">ESP32: Getting Started with Firebase (Realtime Database)</a>
<a href="https://randomnerdtutorials.com/esp32-data-logging-firebase-realtime-database/">ESP32 Data Logging to Firebase Realtime Database</a>
<a href="https://randomnerdtutorials.com/esp32-esp8266-firebase-bme280-rtdb/">ESP32/ESP8266 Firebase: Send BME280 Sensor Readings to the Realtime Database</a>
Firebase Cloud Storage is another service that can be used to save files. Imagine that you have several files saved on the microSD card. The ESP32 can connect once a day to the internet to backup those files on Firebase Cloud Storage. We also have used Firebase Cloud Storage to store pictures taken with the ESP32-CAM:
<a href="https://randomnerdtutorials.com/esp32-cam-save-picture-firebase-storage/">ESP32-CAM Save Picture in Firebase Storage</a>
<k>Advantages of using Firebase Realtime Database with the ESP32 for datalogging:</k>
<k>Access from anywhere</k>: after submitting the data, it is available online and you can check it from anywhere in the world;
<k>Store and retrieve data in real-time</k>: the data submitted to the Firebase Realtime Database synchronizes in real-time with other devices and services (if you have several boards or a web app listening to that database, it receives the changes almost instantly);
<k>Free usage for small projects</k>: for personal projects, you can use Firebase tools for free until a predefined storage limit;
<k>Flexibility</k>: It's great if you want to build a web app for your IoT projects and you need to save different types of data;
<k>Users and authentication</k>: Firebase services provide tools to easily handle users and authentication.
<k>Disadvantages:</k>
<k>Might be difficult to get started</k>: You need to set up a Firebase project with authentication methods, database rules, and other settings that might be difficult for beginners (but if you follow our <a href="https://randomnerdtutorials.com/firebase-esp32-esp8266-ebook/">Firebase eBook</a>, you'll get everything set up in no time);
<k>Requires internet connection</k>: the ESP32 needs to be connected to the internet to connect with Firebase services, if the ESP32 is used in an environment without internet access, it will not be able to communicate with Firebase.
<k>Additional costs</k>: Firebase has a free plan that's usually more than enough for personal applications, but if you need more data storage, you'll need to get a paid plan. However, the free plan was always more than enough for our projects.
<hr>
<h3>4) InfluxDB Time Series Database</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/ESP32-ESP8266-Sensor-Readings-Dashboard.png">
InfluxDB is one of my favorite databases for datalogging. InfluxDB is an open-source high-performance time series database (TSDB) that can store large amounts of data per second. Each data point you submit to the database is associated with a particular timestamp. So, it is ideal for IoT datalogging projects like storing data from your weather station sensors.
You can run <a href="https://www.influxdata.com/products/influxdb/" target="_blank">InfluxDB in InfluxDB Cloud</a>, or locally on your laptop or <a href="https://randomnerdtutorials.com/install-influxdb-2-raspberry-pi/">Raspberry Pi</a>.
InfluxDB cloud is a great alternative because it hosts your data that can be accessed from anywhere. However, the free cloud plan only lets you save data until the last 30 days. Depending on your project application, that might be a good alternative. Or if you're willing to pay for a premium plan, InfluxDB cloud might be the best solution.
To get started datalogging with InfluxDB and the ESP32, you can follow the next tutorials.
<a href="https://randomnerdtutorials.com/esp32-influxdb/">ESP32: Getting Started with InfluxDB</a>
<a href="https://randomnerdtutorials.com/esp32-esp8266-sensor-bme280-influxdb/">ESP32/ESP8266: Send BME280 Sensor Readings to InfluxDB</a>
Besides being a database, InfluxDB also allows you to build dashboards with different types of graphs, charts, gauges, and more to display your data. You can do all of this using their interface. You don't need to write any code to build the charts or dashboard.
<k>Advantages of using InfluxDB for Datalogging with the ESP32:</k>
<k>It's a time-series database</k>: each reading you submit to the database will be associated with a specific timestamp. You don't need to get the date and time on the ESP32.
<k>Dashboard with customizable charts</k>: InfluxDB user interface provides tools for building custom dashboards to visualize your data. Without any knowledge of web programming, you can build awesome dashboards with customizable charts.
<k>It's available online</k>: if you use InfluxDB cloud storage, you can access your data from anywhere in the world by accessing your InfluxDB account.
<k>Also available offline</k>: if you want to have full control over your data, you can also install InfluxDB on your own cloud server, or <a href="https://randomnerdtutorials.com/install-influxdb-2-raspberry-pi/" title="">locally on a Raspberry Pi</a>.
<k>Disadvantages</k>:
<k>Requires installation</k>: you need to install and/or setup InfluxDB first, which might require an extra step on your project;
<k>Only time-based data</k>: all data is associated with a specific timestamp, so it might not be the best database if you want to save data that doesn't require a timestamp like JSON data.
<k>Requires internet connection</k>: the ESP32 needs to be connected to the internet to connect with InfluxDB, unless you install it locally.
<k>Retention period</k>: the free cloud plan only lets you save data until the last 30 days.
<hr>
<h3>5) Use Deta Base to Save Your Data</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/deta-base-demonstration.png">
Deta Base is a NoSQL database. It is unlimited, free, and easy to use. Additionally, it requires minimal setup. So, it's perfect for your hobbyist projects and prototyping. It offers a UI through which you can easily see, query, update and delete records in the database.
The biggest advantage of Deta Base over other database solutions is that it requires very little setup. Once you sign up for Deta Base, it's ready to use.
As with Firebase, you can create your own web applications to interact with the database. 
If you want to learn how to use Deta Base with the ESP32, you can follow our guide:
<a href="https://randomnerdtutorials.com/esp32-deta-base-database-arduino/">ESP32: Getting Started with Deta Base (Unlimited and Free Database for Developers)</a>
<k>Advantages of using Deta Base with the ESP32:</k>
It's free.
It requires minimal setup, once you sign up to Deta Base, you can start using it right away to store data.
It's fast and scalable.
You can check your data online from anywhere from your account.
<k>Disadvantages:</k>
<k>Small community</k>: it's still in the early stages, so if you need help, there's still little information online.
<k>Beta version</k>: it's in beta version, and you might encounter unexpected bugs.
<k>Requires internet connection</k>: like the other cloud solutions, the ESP32 needs to have access to the internet.
<hr>
<h3>6) Use ThingSpeak Channels</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/04/Thingspeak-Temperature-Humidity-Pressure-Fields-ESP32.png">
ThingSpeak is an IoT platform in which you can create channels to store data. It provides visualization tools and different widgets to display your data like charts, gauges, or numeric displays. The submitted data is also associated with a timestamp, which is useful if you want to display it on charts to see how it behaves over time. 
You can have multiple devices publishing data to your Thingspeak account. Usually, each device will require a channel. The free plan is limited to four channels.
In my opinion, the visual interface is easy to use, but it allows very little customization when compared with the tools provided by InfluxDB. However, it is perfect if you just want a simple visualization without having to worry about formatting details (like series colors, charts background colors, etc.).
The data is stored in the cloud, so you can access your data anywhere from your account,
We have two different tutorials that show different methods to publish data to Thingspeak. The following shows how to make an HTTP POST request with data to Thingspeak services (you need to write the request manually on the code):
<a href="https://randomnerdtutorials.com/esp32-http-post-ifttt-thingspeak-arduino/">ESP32 HTTP POST with Arduino IDE (ThingSpeak)</a>
An easier way to publish data to Thingspeak with the ESP32 is to use a library. You just need to call a function and pass as an argument the data you want to send.
<a href="https://randomnerdtutorials.com/esp32-thingspeak-publish-arduino/">ESP32 Publish Sensor Readings to ThingSpeak (easiest way)</a>
<k>Advantages of using ThinsSpeak with the ESP32:</k>
<k>Suitable for multiple IoT devices</k>: you can have multiple ESP32 boards and other IoT devices publishing data to your Thinspeak account.
<k>Free to use</k>: it provides a free plan with up to four channels. Usually, each device will require a different channel on ThingSpeak.
<k>Minimal setup</k>: you don't need to install anything on your computer or set up any database settings; once you create an account and a new channel, it's ready to use.
<k>Simple dashboard</k>: the data will be displayed on the widget of your choice, without having to program anything on the user interface.
<k>Disadvantages:</k>
<k>Limited free plan</k>: the free plan is limited to four channels, which might not be enough for your project.
<k>Little customization</k>: the number of available widgets is limited and allows very little customization.
<k>Requires internet connection</k>: like the other cloud solutions, the ESP32 needs to have access to the internet.
<hr>
<h3>7) Save ESP32 Data to Google Sheets</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2018/04/google_sheets_readings.png">
Another great alternative to log data with the ESP32 is to use Google Sheets. Then, you can analyze, manage and display your data using the features provided in Google Sheets. You can have access to your data from anywhere using your Google account. This is a good method if you need to store data that needs processing later on.
We have a guide showing how to log sensor readings to Google Sheets using IFTTT services. The advantage of using IFTTT services is that you don't need to create any scripts or additional configurations in your Google account.  However, it has some limitations in the number of requests you can make with the free account and with how much information you can save at once. Here's the tutorial:
<a href="https://randomnerdtutorials.com/esp32-esp8266-publish-sensor-readings-to-google-sheets/">ESP32 Publish Sensor Readings to Google Sheets</a>
If you don't want to rely on a third-party service to publish data to google sheets with the ESP32, there's currently a library to do that. Check the <a href="https://github.com/mobizt/ESP-Google-Sheet-Client" target="_blank" rel="noopener">Arduino Google Sheet Client Library for ESP8266 and ESP32</a>. 
<k>Advantages of saving ESP32 data to Google Sheets:</k>
<k>Easy data management</k>: if you need to process your data after collecting it, you can use all the functionalities of google sheets to process data.
<k>Access from anywhere</k>: you can easily access your data from your google account.
<k>Shareable</k>: you can share the google sheet file with other people by providing access to their specific email.
<k>Disadvantages:</k>
<k>It doesn't display the data visually automatically.</k> You need to know how to create charts and graphs (which is not difficult, so I don't think this is a big limitation).
If using a third-party service like IFTTT (free account) you're<k> limited to the number of requests</k> and fields you can pass at a time.
<k>Requires internet connection</k>: like the other cloud solutions, the ESP32 needs to have access to the internet.
<hr>
<h3>8) ESP32 Save Data to MySQL Database on a Cloud Server</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/06/ESP32-MySQL-Project-Overview.png">
You can install a MySQL Database on a cloud server and then, make requests with the ESP32 to publish and retrieve data. This method is great for those who like programming, setting up their own servers, and want to have full control over their data storage. If you're already familiar with MySQL and PHP, you'll certainly like this method.
The biggest disadvantage of this method is that you need to set up everything on your own from scratch which is easily prone to errors. Additionally, you'll need to pay for hosting and a domain name.
You can follow the next tutorials to set up a MySQL database on your own server and then, learn how to create a web page to display the data on charts:
<ol>
<a href="https://randomnerdtutorials.com/esp32-esp8266-mysql-database-php/">ESP32/ESP8266 Insert Data into MySQL Database using PHP and Arduino IDE</a>
<a href="https://randomnerdtutorials.com/visualize-esp32-esp8266-sensor-readings-from-anywhere/">Visualize Your Sensor Readings from Anywhere in the World (ESP32/ESP8266 + MySQL + PHP)</a>
</ol>
<hr>
<h3>9) MySQL Database on a Local Server (Raspberry Pi)</h3>
This is an alternative to the previous solution. If you want to set up a MySQL database locally on a Raspberry Pi to save the data coming from the ESP32, you'll need to follow the next tutorial first:
<a href="https://randomnerdtutorials.com/raspberry-pi-apache-mysql-php-lamp-server/">Raspberry Pi: Install Apache + MySQL + PHP (LAMP Server)</a>
Then, you can follow the next tutorial to learn how to actually publish data with the ESP32 to your local server and how to display it on a web page:
<a href="https://randomnerdtutorials.com/esp32-esp8266-raspberry-pi-lamp-server/" title="">ESP32/ESP8266 Publish Data to Raspberry Pi LAMP Server</a>
<h3>Wrapping Up</h3>
In this tutorial, we compiled different methods that you can use to save and log data permanently using your ESP32. Depending on your expertise level and project requirements, one solution might be more suitable than the others. There are many other methods besides the ones we covered here. We created a compilation of the tutorials we already have about this subject.
We hope you found this compilation guide useful. Let us know what's your favorite storage method and for which applications you use it.

<h2>CAM Post Images to Local or Cloud Server using PHP (Photo Manager)</h2>
Learn how to make HTTP POST requests using the ESP32-CAM board with Arduino IDE to send photos to a server. We'll show how to post a JPG/JPEG image to a local server (Raspberry Pi LAMP server) or to a cloud server (that you can access from anywhere). The photos will be displayed in a gallery where you can view or delete the photos. To save the images in the server and create the gallery, we'll use PHP scripts.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/03/ESP32-CAM-Cloud-Photo-Manager-f.jpg">
Updated on 27 March 2023
To build this project, you need to follow the next steps. Follow the LAMP Server or the Hosting Server instructions depending on if you want to access the photos locally or from anywhere.
<ol>
Hosting your PHP Application
<ol>
Raspberry Pi LAMP Server (local access)
Hosting Server (access from anywhere)
</ol>
PHP scripts to save and display photos in the server
<ol>
Raspberry Pi LAMP Server (local access)
Hosting Server (access from anywhere)
</ol>
Program the ESP32-CAM with Arduino IDE
Testing and Final Demonstration
</ol>
<h3>1. Hosting Your PHP Application</h3>
The goal of this project is to have a local or cloud server to store and access your ESP32-CAM photos. 
<k>1. Raspberry Pi local server</k>:
With a <a href="https://randomnerdtutorials.com/raspberry-pi-apache-mysql-php-lamp-server/">Raspberry Pi LAMP server</a>, you can access your images locally (as illustrated below).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/ESP32-CAM-Camera-Board-Send-Photo-Image-to-Raspberry-Pi-LAMP-Server-PHP-gallery-Script-Arduino.png">
You can run a <a href="https://randomnerdtutorials.com/raspberry-pi-apache-mysql-php-lamp-server/">LAMP (Linux, Apache, MySQL, PHP) server</a> on a Raspberry Pi to <a href="https://randomnerdtutorials.com/esp32-esp8266-raspberry-pi-lamp-server/">access data in your local network</a>. Raspberry Pi LAMP Server: Local Linux server that you use to access your images locally.
<a href="https://randomnerdtutorials.com/raspberry-pi-apache-mysql-php-lamp-server/" target="_blank" rel="noopener noreferrer">Setup Local RPi LAMP Server <U+00BB></a>
<k>2. Cloud server (Bluehost hosting solution)</k>
You also can visualize the ESP32-CAM photos from anywhere in the world by accessing your own server + domain. Here's a high level overview on how it works:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/ESP32-CAM-Camera-Board-Send-Photo-Image-to-Cloud-Server-PHP-gallery-Script-Arduino.png">
<a aria-label=" (opens in a new tab)" href="https://randomnerdtutorials.com/bluehost" target="_blank">Bluehost (user-friendly with cPanel)</a>: free domain name when you sign up for the 3-year plan. I recommend choosing the unlimited websites option; Note that any hosting service that offers PHP will work with this tutorial. If you don't have a hosting account, I recommend <a href="https://randomnerdtutorials.com/bluehost">signing up for Bluehost</a>.
<a href="https://randomnerdtutorials.com/bluehost" target="_blank" rel="noopener noreferrer">Get Hosting and Domain Name with Bluehost <U+00BB></a>
When buying a hosting account, you'll also have to purchase a domain name. This is what makes this project interesting: you'll be able to go your domain name (http://example.com) and see your ESP32-CAM photos. If you like our projects, you might consider signing up to Bluehost, because you'll be supporting our work.
<h3>HTTP POST Request Method</h3>
The Hypertext Transfer Protocol (HTTP) works as a request-response protocol between a client and server. Here's an example:
The ESP32 (client) submits an HTTP request to a Server (for example: local RPi Lamp Server or example.com);
The server returns a response to the ESP32 (client);
<k><a href="https://randomnerdtutorials.com/esp32-http-get-post-arduino/">HTTP POST</a></k> is used to send data to a server to create/update a resource. For example, publish an image to a server.
<k>POST /upload.php HTTP/1.1
Host: example.com
Content-Type: image/jpeg</k>
<h3>2.1. Preparing Your <em>.php</em> Files and <em>uploads</em> Folder (Raspberry Pi LAMP Server)</h3>
This section prepares your <em>.php</em> files and <em>uploads</em> folder for your Raspberry Pi LAMP Server. If you're using your own server + domain name, skip to the next section.
Having a <a href="https://randomnerdtutorials.com/raspberry-pi-apache-mysql-php-lamp-server/">Raspberry Pi running Apache and PHP</a>, in the Raspberry Pi board terminal window navigate to the <em>/var/www/html/</em> directory:
<k>pi@raspberrypi:~ $ cd /var/www/html/</k>
Create a new folder called <em>uploads</em>:
<k>pi@raspberrypi:/var/www/html $ mkdir uploads
pi@raspberrypi:/var/www/html $ ls
uploads</k>
At the moment, <em>/var/www/html</em> is owned by root, use the next commands to change to the pi user and give it all permissions so that you can save photos using a PHP script later on.
<k>sudo chown -R pi:pi /var/www/html
chmod -R 777 /var/www/html/</k>
Finally, create a new <em>upload.php</em> file:
<k>pi@raspberrypi:/var/www/html $ nano upload.php</k>
This PHP script is responsible for receiving incoming images from the ESP32-CAM, rename the images with a timestamp and store them in the <em>uploads </em>folder. Edit the newly created file (<em>upload.php</em>) and copy the following snippet:
<k>&lt;?php
// Rui Santos
// Complete project details at https://RandomNerdTutorials.com/esp32-cam-post-image-photo-server/
// Code Based on this example: w3schools.com/php/php_file_upload.asp
$target_dir = "uploads/";
$datum = mktime(date('H')+0, date('i'), date('s'), date('m'), date('d'), date('y'));
$target_file = $target_dir . date('Y.m.d_H:i:s_', $datum) . basename($_FILES["imageFile"]["name"]);
$uploadOk = 1;
$imageFileType = strtolower(pathinfo($target_file,PATHINFO_EXTENSION));
// Check if image file is a actual image or fake image
if(isset($_POST["submit"])) {
  $check = getimagesize($_FILES["imageFile"]["tmp_name"]);
  if($check !== false) {
    echo "File is an image - " . $check["mime"] . ".";
    $uploadOk = 1;
  }
  else {
    echo "File is not an image.";
    $uploadOk = 0;
  }
}
// Check if file already exists
if (file_exists($target_file)) {
  echo "Sorry, file already exists.";
  $uploadOk = 0;
}
// Check file size
if ($_FILES["imageFile"]["size"] > 500000) {
  echo "Sorry, your file is too large.";
  $uploadOk = 0;
}
// Allow certain file formats
if($imageFileType != "jpg" && $imageFileType != "png" && $imageFileType != "jpeg"
&& $imageFileType != "gif" ) {
  echo "Sorry, only JPG, JPEG, PNG & GIF files are allowed.";
  $uploadOk = 0;
}
// Check if $uploadOk is set to 0 by an error
if ($uploadOk == 0) {
  echo "Sorry, your file was not uploaded.";
// if everything is ok, try to upload file
}
else {
  if (move_uploaded_file($_FILES["imageFile"]["tmp_name"], $target_file)) {
    echo "The file ". basename( $_FILES["imageFile"]["name"]). " has been uploaded.";
  }
  else {
    echo "Sorry, there was an error uploading your file.";
  }
}
?>
</k>
<a href="https://github.com/RuiSantosdotme/ESP32-CAM-Arduino-IDE/raw/master/ESP32-CAM-HTTP-POST-Image/upload.php" target="_blank">View raw code</a>
Your <em>upload.php</em> file should look like this. Save your file and exit (Ctrl+X, Y, and Enter key):
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/upload-php-script-save-images-to-server-ESP32-CAM.png">
Then, create a new <em>gallery.php</em> file:
<k>pi@raspberrypi:/var/www/html $ nano gallery.php</k>
Edit the newly created file (<em>gallery.php</em>) and copy the following snippet:
<k>&lt;!-- 
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-cam-post-image-photo-server/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
-->
&lt;!DOCTYPE html>
&lt;html>
&lt;head>
  &lt;title>ESP32-CAM Photo Gallery&lt;/title>
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0">
  &lt;style>
    .flex-container {
      display: flex;
      flex-wrap: wrap;
    }
    .flex-container > div {
      text-align: center;
      margin: 10px;
    }
  &lt;/style>
&lt;/head>&lt;body>
&lt;h2>ESP32-CAM Photo Gallery&lt;/h2>
&lt;?php
  // Image extensions
  $image_extensions = array("png","jpg","jpeg","gif");
  // Check delete HTTP GET request - remove images
  if(isset($_GET["delete"])){
    $imageFileType = strtolower(pathinfo($_GET["delete"],PATHINFO_EXTENSION));
    if (file_exists($_GET["delete"]) && ($imageFileType == "jpg" ||  $imageFileType == "png" ||  $imageFileType == "jpeg") ) {
      echo "File found and deleted: " .  $_GET["delete"];
      unlink($_GET["delete"]);
    }
    else {
      echo 'File not found - &lt;a href="gallery.php">refresh&lt;/a>';
    }
  }
  // Target directory
  $dir = 'uploads/';
  if (is_dir($dir)){
    echo '&lt;div>';
    $count = 1;
    $files = scandir($dir);
    rsort($files);
    foreach ($files as $file) {
      if ($file != '.' && $file != '..') {?>
        &lt;div>
          &lt;p>&lt;a href="gallery.php?delete=&lt;?php echo $dir . $file; ?>">Delete file&lt;/a> - &lt;?php echo $file; ?>&lt;/p>
          &lt;a href="&lt;?php echo $dir . $file; ?>">
            &lt;img src="&lt;?php echo $dir . $file; ?>" style="width: 350px;" alt="" title=""/>
          &lt;/a>
       &lt;/div>
&lt;?php
       $count++;
      }
    }
  }
  if($count==1) { echo "&lt;p>No images found&lt;/p>"; } 
?>
  &lt;/div>
&lt;/body>
&lt;/html>
</k>
<a href="https://github.com/RuiSantosdotme/ESP32-CAM-Arduino-IDE/raw/master/ESP32-CAM-HTTP-POST-Image/gallery.php" target="_blank">View raw code</a>
This PHP script is responsible for displaying the images on the gallery. Your <em>gallery.php</em> file should look like this. Save your file and exit (Ctrl+X, Y, and Enter key):
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/gallery-php-script-save-images-to-server-ESP32-CAM.png">
<h3>2.2. Preparing Your <em>.php</em> Files and <em>uploads</em> Folder (Hosting Service)</h3>
If you prefer to run your server remotely and access the photos from anywhere, you need a hosting account. After signing up for a <a href="https://randomnerdtutorials.com/bluehost" target="_blank">hosting account and setting up a domain name</a>, you can login to your cPanel or similar dashboard. After that, open the File Manager.
Open the <k>Advanced</k> tab and select <k>File Manager</k>:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/ESP32-CAM-Advanced-open-File-Manager.png">
Then, select the <k>public_html</k> option. Press the <k>+ File</k> button to create a new <em>upload.php</em> file and a new <em>gallery.php</em> file. Then, click the <k>+Folder</k> button to create the <em>Uploads </em>folder.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/ESP32-CAM-Camera-CPanel-Create-New-Upload-PHP-File-Uploads-Folder.png">
With the three items created, edit the <em>upload.php</em> file:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/ESP32-CAM-PHP-files-and-folder-created.png">
This PHP script is responsible for receiving incoming images from the ESP32-CAM, rename the images with a timestamp and store them in the <em>uploads </em>folder. Edit the newly created file (<em>upload.php</em>) and copy the following snippet:
<k>&lt;?php
// Rui Santos
// Complete project details at https://RandomNerdTutorials.com/esp32-cam-post-image-photo-server/
// Code Based on this example: w3schools.com/php/php_file_upload.asp
$target_dir = "uploads/";
$datum = mktime(date('H')+0, date('i'), date('s'), date('m'), date('d'), date('y'));
$target_file = $target_dir . date('Y.m.d_H:i:s_', $datum) . basename($_FILES["imageFile"]["name"]);
$uploadOk = 1;
$imageFileType = strtolower(pathinfo($target_file,PATHINFO_EXTENSION));
// Check if image file is a actual image or fake image
if(isset($_POST["submit"])) {
  $check = getimagesize($_FILES["imageFile"]["tmp_name"]);
  if($check !== false) {
    echo "File is an image - " . $check["mime"] . ".";
    $uploadOk = 1;
  }
  else {
    echo "File is not an image.";
    $uploadOk = 0;
  }
}
// Check if file already exists
if (file_exists($target_file)) {
  echo "Sorry, file already exists.";
  $uploadOk = 0;
}
// Check file size
if ($_FILES["imageFile"]["size"] > 500000) {
  echo "Sorry, your file is too large.";
  $uploadOk = 0;
}
// Allow certain file formats
if($imageFileType != "jpg" && $imageFileType != "png" && $imageFileType != "jpeg"
&& $imageFileType != "gif" ) {
  echo "Sorry, only JPG, JPEG, PNG & GIF files are allowed.";
  $uploadOk = 0;
}
// Check if $uploadOk is set to 0 by an error
if ($uploadOk == 0) {
  echo "Sorry, your file was not uploaded.";
// if everything is ok, try to upload file
}
else {
  if (move_uploaded_file($_FILES["imageFile"]["tmp_name"], $target_file)) {
    echo "The file ". basename( $_FILES["imageFile"]["name"]). " has been uploaded.";
  }
  else {
    echo "Sorry, there was an error uploading your file.";
  }
}
?>
</k>
<a href="https://github.com/RuiSantosdotme/ESP32-CAM-Arduino-IDE/raw/master/ESP32-CAM-HTTP-POST-Image/upload.php" target="_blank">View raw code</a>
Save your file and exit.
Then, edit the <em>gallery.php</em> file and copy the following snippet. This is responsible for displaying the images in the gallery.
<k>&lt;!-- 
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-cam-post-image-photo-server/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
-->
&lt;!DOCTYPE html>
&lt;html>
&lt;head>
  &lt;title>ESP32-CAM Photo Gallery&lt;/title>
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0">
  &lt;style>
    .flex-container {
      display: flex;
      flex-wrap: wrap;
    }
    .flex-container > div {
      text-align: center;
      margin: 10px;
    }
  &lt;/style>
&lt;/head>&lt;body>
&lt;h2>ESP32-CAM Photo Gallery&lt;/h2>
&lt;?php
  // Image extensions
  $image_extensions = array("png","jpg","jpeg","gif");
  // Check delete HTTP GET request - remove images
  if(isset($_GET["delete"])){
    $imageFileType = strtolower(pathinfo($_GET["delete"],PATHINFO_EXTENSION));
    if (file_exists($_GET["delete"]) && ($imageFileType == "jpg" ||  $imageFileType == "png" ||  $imageFileType == "jpeg") ) {
      echo "File found and deleted: " .  $_GET["delete"];
      unlink($_GET["delete"]);
    }
    else {
      echo 'File not found - &lt;a href="gallery.php">refresh&lt;/a>';
    }
  }
  // Target directory
  $dir = 'uploads/';
  if (is_dir($dir)){
    echo '&lt;div>';
    $count = 1;
    $files = scandir($dir);
    rsort($files);
    foreach ($files as $file) {
      if ($file != '.' && $file != '..') {?>
        &lt;div>
          &lt;p>&lt;a href="gallery.php?delete=&lt;?php echo $dir . $file; ?>">Delete file&lt;/a> - &lt;?php echo $file; ?>&lt;/p>
          &lt;a href="&lt;?php echo $dir . $file; ?>">
            &lt;img src="&lt;?php echo $dir . $file; ?>" style="width: 350px;" alt="" title=""/>
          &lt;/a>
       &lt;/div>
&lt;?php
       $count++;
      }
    }
  }
  if($count==1) { echo "&lt;p>No images found&lt;/p>"; } 
?>
  &lt;/div>
&lt;/body>
&lt;/html>
</k>
<a href="https://github.com/RuiSantosdotme/ESP32-CAM-Arduino-IDE/raw/master/ESP32-CAM-HTTP-POST-Image/gallery.php" target="_blank">View raw code</a>
Save your file and exit. That's it! Your server is ready.
<h3>3. ESP32-CAM HTTP Post Images/Photos to Server</h3>
Now that you have your server ready (Raspberry Pi LAMP server or cloud server), it's time to prepare the ESP32-CAM with the code to publish a new image to your server every 30 seconds. Before proceeding with this tutorial, make sure you complete the following prerequisites.
<h3>Parts Required</h3>
To follow this tutorial you need the following components:
<k><a href="https://makeradvisor.com/tools/esp32-cam/" target="_blank">ESP32-CAM with OV2640</a></k>  read <a href="https://makeradvisor.com/esp32-camera-cam-boards-review-comparison/" target="_blank">Best ESP32-CAM Dev Boards</a>
<a href="https://makeradvisor.com/tools/ftdi-programmer-board/" target="_blank">FTDI programmer</a>
<a href="https://makeradvisor.com/tools/jumper-wires-kit-120-pieces/" target="_blank">Female-to-female jumper wires</a>
<a href="https://makeradvisor.com/tools/raspberry-pi-power-supply/" target="_blank">5V power supply for ESP32-CAM</a>
Local server:
<a href="https://makeradvisor.com/tools/raspberry-pi-board/" target="_blank">Raspberry Pi Board</a>   read <a href="https://makeradvisor.com/best-raspberry-pi-3-starter-kits/" target="_blank">Best Raspberry Pi Starter Kits</a>
<a href="https://makeradvisor.com/tools/microsd-card-raspberry-pi-16gb-class-10/" target="_blank">MicroSD Card  32GB Class10</a>
<a href="https://makeradvisor.com/tools/raspberry-pi-power-supply/" target="_blank">Raspberry Pi Power Supply (5V 2.5A)</a>
Cloud server (alternative): <a href="https://randomnerdtutorials.com/bluehost" target="_blank">Bluehost</a>
You can use the preceding links or go directly to <a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank">MakerAdvisor.com/tools</a> to find all the parts for your projects at the best price!
<a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/header-200.png?w=828&quality=100&strip=all&ssl=1" data-recalc-dims="1" loading="lazy" fetchpriority="low"></a>
<h3>Arduino IDE</h3>
We'll program the <a href="https://makeradvisor.com/tools/esp32-cam/" target="_blank">ESP32-CAM</a> using Arduino IDE, so make sure you have the ESP32 add-on installed.
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing the ESP32 Board in Arduino IDE (Windows, Mac OS X, Linux)</a>
<h3>Check the PHP URL</h3>
You should try to open the Raspberry Pi local IP address or your external example.com domain name, followed by <k>/upload.php</k> that should return:
<k>Sorry, only JPG, JPEG, PNG & GIF files are allowed.Sorry, your file was not uploaded.</k>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/ESP32-CAM-Camera-Board-Upload-Files-Image.png">
If you see that message save your URL/domain name and path, your server should be ready and you can continue with this guide.
Additionally, try to access the <k>/gallery.php </k>path. You should get something as shown below:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/ESP32-CAM-Camera-Board-gallery-PHP-file-view-delete-photos.png">
<h3>ESP32-CAM Code</h3>
If you're using a local server without TLS/SSL, or a cloud server that doesn't support HTTPS, use the HTTP POST Request Code.
If you're using a cloud server that requires HTTPS requests, use this code instead: HTTPS POST Request Code.
<h4>ESP32-CAM HTTP POST Request</h4>
The next sketch posts the image to a server using HTTP POST. Copy the code below to your Arduino IDE. 
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-cam-post-image-photo-server/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
#include &lt;Arduino.h>
#include &lt;WiFi.h>
#include "soc/soc.h"
#include "soc/rtc_cntl_reg.h"
#include "esp_camera.h"
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
String serverName = "192.168.1.XXX";   // REPLACE WITH YOUR Raspberry Pi IP ADDRESS
//String serverName = "example.com";   // OR REPLACE WITH YOUR DOMAIN NAME
String serverPath = "/upload.php";     // The default serverPath should be upload.php
const int serverPort = 80;
WiFiClient client;
// CAMERA_MODEL_AI_THINKER
#define PWDN_GPIO_NUM     32
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM      0
#define SIOD_GPIO_NUM     26
#define SIOC_GPIO_NUM     27
#define Y9_GPIO_NUM       35
#define Y8_GPIO_NUM       34
#define Y7_GPIO_NUM       39
#define Y6_GPIO_NUM       36
#define Y5_GPIO_NUM       21
#define Y4_GPIO_NUM       19
#define Y3_GPIO_NUM       18
#define Y2_GPIO_NUM        5
#define VSYNC_GPIO_NUM    25
#define HREF_GPIO_NUM     23
#define PCLK_GPIO_NUM     22
const int timerInterval = 30000;    // time between each HTTP POST image
unsigned long previousMillis = 0;   // last time image was sent
void setup() {
  WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0); 
  Serial.begin(115200);
  WiFi.mode(WIFI_STA);
  Serial.println();
  Serial.print("Connecting to ");
  Serial.println(ssid);
  WiFi.begin(ssid, password);  
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print(".");
    delay(500);
  }
  Serial.println();
  Serial.print("ESP32-CAM IP Address: ");
  Serial.println(WiFi.localIP());
  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer = LEDC_TIMER_0;
  config.pin_d0 = Y2_GPIO_NUM;
  config.pin_d1 = Y3_GPIO_NUM;
  config.pin_d2 = Y4_GPIO_NUM;
  config.pin_d3 = Y5_GPIO_NUM;
  config.pin_d4 = Y6_GPIO_NUM;
  config.pin_d5 = Y7_GPIO_NUM;
  config.pin_d6 = Y8_GPIO_NUM;
  config.pin_d7 = Y9_GPIO_NUM;
  config.pin_xclk = XCLK_GPIO_NUM;
  config.pin_pclk = PCLK_GPIO_NUM;
  config.pin_vsync = VSYNC_GPIO_NUM;
  config.pin_href = HREF_GPIO_NUM;
  config.pin_sscb_sda = SIOD_GPIO_NUM;
  config.pin_sscb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn = PWDN_GPIO_NUM;
  config.pin_reset = RESET_GPIO_NUM;
  config.xclk_freq_hz = 20000000;
  config.pixel_format = PIXFORMAT_JPEG;
  // init with high specs to pre-allocate larger buffers
  if(psramFound()){
    config.frame_size = FRAMESIZE_SVGA;
    config.jpeg_quality = 10;  //0-63 lower number means higher quality
    config.fb_count = 2;
  } else {
    config.frame_size = FRAMESIZE_CIF;
    config.jpeg_quality = 12;  //0-63 lower number means higher quality
    config.fb_count = 1;
  }
  
  // camera init
  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed with error 0x%x", err);
    delay(1000);
    ESP.restart();
  }
  sendPhoto(); 
}
void loop() {
  unsigned long currentMillis = millis();
  if (currentMillis - previousMillis >= timerInterval) {
    sendPhoto();
    previousMillis = currentMillis;
  }
}
String sendPhoto() {
  String getAll;
  String getBody;
  camera_fb_t * fb = NULL;
  fb = esp_camera_fb_get();
  if(!fb) {
    Serial.println("Camera capture failed");
    delay(1000);
    ESP.restart();
  }
  
  Serial.println("Connecting to server: " + serverName);
  if (client.connect(serverName.c_str(), serverPort)) {
    Serial.println("Connection successful!");    
    String head = "--RandomNerdTutorials\r\nContent-Disposition: form-data; name=\"imageFile\"; filename=\"esp32-cam.jpg\"\r\nContent-Type: image/jpeg\r\n\r\n";
    String tail = "\r\n--RandomNerdTutorials--\r\n";
    uint32_t imageLen = fb->len;
    uint32_t extraLen = head.length() + tail.length();
    uint32_t totalLen = imageLen + extraLen;
  
    client.println("POST " + serverPath + " HTTP/1.1");
    client.println("Host: " + serverName);
    client.println("Content-Length: " + String(totalLen));
    client.println("Content-Type: multipart/form-data; boundary=RandomNerdTutorials");
    client.println();
    client.print(head);
  
    uint8_t *fbBuf = fb->buf;
    size_t fbLen = fb->len;
    for (size_t n=0; n&lt;fbLen; n=n+1024) {
      if (n+1024 &lt; fbLen) {
        client.write(fbBuf, 1024);
        fbBuf += 1024;
      }
      else if (fbLen%1024>0) {
        size_t remainder = fbLen%1024;
        client.write(fbBuf, remainder);
      }
    }   
    client.print(tail);
    
    esp_camera_fb_return(fb);
    
    int timoutTimer = 10000;
    long startTimer = millis();
    boolean state = false;
    
    while ((startTimer + timoutTimer) > millis()) {
      Serial.print(".");
      delay(100);      
      while (client.available()) {
        char c = client.read();
        if (c == '\n') {
          if (getAll.length()==0) { state=true; }
          getAll = "";
        }
        else if (c != '\r') { getAll += String(c); }
        if (state==true) { getBody += String(c); }
        startTimer = millis();
      }
      if (getBody.length()>0) { break; }
    }
    Serial.println();
    client.stop();
    Serial.println(getBody);
  }
  else {
    getBody = "Connection to " + serverName +  " failed.";
    Serial.println(getBody);
  }
  return getBody;
}
</k>
<a href="https://github.com/RuiSantosdotme/ESP32-CAM-Arduino-IDE/raw/master/ESP32-CAM-HTTP-POST-Image/ESP32-CAM-HTTP-POST-Image.ino" target="_blank">View raw code</a>
<h4>ESP32-CAM HTTPS POST Request</h4>
The next sketch posts the image to a server using HTTPS POST. Copy the code below to your Arduino IDE.
<k>/*
  Rui Santos
  Complete project details at:
  https://RandomNerdTutorials.com/esp32-cam-http-post-php-arduino/
  https://RandomNerdTutorials.com/esp32-cam-post-image-photo-server/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
#include &lt;Arduino.h>
#include &lt;WiFi.h>
#include &lt;WiFiClientSecure.h>
#include "soc/soc.h"
#include "soc/rtc_cntl_reg.h"
#include "esp_camera.h"
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
String serverName = "example.com";   //REPLACE WITH YOUR DOMAIN NAME
String serverPath = "/upload.php";     // The default serverPath should be upload.php
const int serverPort = 443; //server port for HTTPS
WiFiClientSecure client;
// CAMERA_MODEL_AI_THINKER
#define PWDN_GPIO_NUM     32
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM      0
#define SIOD_GPIO_NUM     26
#define SIOC_GPIO_NUM     27
#define Y9_GPIO_NUM       35
#define Y8_GPIO_NUM       34
#define Y7_GPIO_NUM       39
#define Y6_GPIO_NUM       36
#define Y5_GPIO_NUM       21
#define Y4_GPIO_NUM       19
#define Y3_GPIO_NUM       18
#define Y2_GPIO_NUM        5
#define VSYNC_GPIO_NUM    25
#define HREF_GPIO_NUM     23
#define PCLK_GPIO_NUM     22
const int timerInterval = 30000;    // time between each HTTP POST image
unsigned long previousMillis = 0;   // last time image was sent
void setup() {
  WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0); 
  Serial.begin(115200);
  WiFi.mode(WIFI_STA);
  Serial.println();
  Serial.print("Connecting to ");
  Serial.println(ssid);
  WiFi.begin(ssid, password);  
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print(".");
    delay(500);
  }
  Serial.println();
  Serial.print("ESP32-CAM IP Address: ");
  Serial.println(WiFi.localIP());
  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer = LEDC_TIMER_0;
  config.pin_d0 = Y2_GPIO_NUM;
  config.pin_d1 = Y3_GPIO_NUM;
  config.pin_d2 = Y4_GPIO_NUM;
  config.pin_d3 = Y5_GPIO_NUM;
  config.pin_d4 = Y6_GPIO_NUM;
  config.pin_d5 = Y7_GPIO_NUM;
  config.pin_d6 = Y8_GPIO_NUM;
  config.pin_d7 = Y9_GPIO_NUM;
  config.pin_xclk = XCLK_GPIO_NUM;
  config.pin_pclk = PCLK_GPIO_NUM;
  config.pin_vsync = VSYNC_GPIO_NUM;
  config.pin_href = HREF_GPIO_NUM;
  config.pin_sscb_sda = SIOD_GPIO_NUM;
  config.pin_sscb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn = PWDN_GPIO_NUM;
  config.pin_reset = RESET_GPIO_NUM;
  config.xclk_freq_hz = 20000000;
  config.pixel_format = PIXFORMAT_JPEG;
  // init with high specs to pre-allocate larger buffers
  if(psramFound()){
    config.frame_size = FRAMESIZE_SVGA;
    config.jpeg_quality = 10;  //0-63 lower number means higher quality
    config.fb_count = 2;
  } else {
    config.frame_size = FRAMESIZE_CIF;
    config.jpeg_quality = 12;  //0-63 lower number means higher quality
    config.fb_count = 1;
  }
  
  // camera init
  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed with error 0x%x", err);
    delay(1000);
    ESP.restart();
  }
  sendPhoto(); 
}
void loop() {
  unsigned long currentMillis = millis();
  if (currentMillis - previousMillis >= timerInterval) {
    sendPhoto();
    previousMillis = currentMillis;
  }
}
String sendPhoto() {
  String getAll;
  String getBody;
  camera_fb_t * fb = NULL;
  fb = esp_camera_fb_get();
  if(!fb) {
    Serial.println("Camera capture failed");
    delay(1000);
    ESP.restart();
  }
  
  Serial.println("Connecting to server: " + serverName);
  
  client.setInsecure(); //skip certificate validation
  if (client.connect(serverName.c_str(), serverPort)) {
    Serial.println("Connection successful!");    
    String head = "--RandomNerdTutorials\r\nContent-Disposition: form-data; name=\"imageFile\"; filename=\"esp32-cam.jpg\"\r\nContent-Type: image/jpeg\r\n\r\n";
    String tail = "\r\n--RandomNerdTutorials--\r\n";
    uint32_t imageLen = fb->len;
    uint32_t extraLen = head.length() + tail.length();
    uint32_t totalLen = imageLen + extraLen;
  
    client.println("POST " + serverPath + " HTTP/1.1");
    client.println("Host: " + serverName);
    client.println("Content-Length: " + String(totalLen));
    client.println("Content-Type: multipart/form-data; boundary=RandomNerdTutorials");
    client.println();
    client.print(head);
  
    uint8_t *fbBuf = fb->buf;
    size_t fbLen = fb->len;
    for (size_t n=0; n&lt;fbLen; n=n+1024) {
      if (n+1024 &lt; fbLen) {
        client.write(fbBuf, 1024);
        fbBuf += 1024;
      }
      else if (fbLen%1024>0) {
        size_t remainder = fbLen%1024;
        client.write(fbBuf, remainder);
      }
    }   
    client.print(tail);
    
    esp_camera_fb_return(fb);
    
    int timoutTimer = 10000;
    long startTimer = millis();
    boolean state = false;
    
    while ((startTimer + timoutTimer) > millis()) {
      Serial.print(".");
      delay(100);      
      while (client.available()) {
        char c = client.read();
        if (c == '\n') {
          if (getAll.length()==0) { state=true; }
          getAll = "";
        }
        else if (c != '\r') { getAll += String(c); }
        if (state==true) { getBody += String(c); }
        startTimer = millis();
      }
      if (getBody.length()>0) { break; }
    }
    Serial.println();
    client.stop();
    Serial.println(getBody);
  }
  else {
    getBody = "Connection to " + serverName +  " failed.";
    Serial.println(getBody);
  }
  return getBody;
}
</k>
<a href="https://github.com/RuiSantosdotme/ESP32-CAM-Arduino-IDE/raw/master/ESP32-CAM-HTTP-POST-Image/ESP32-CAM-HTTPS-POST-Image.ino" target="_blank">View raw code</a>

<h4>Inserting your Network Credentials, Camera, and Server Details</h4>
Before uploading the code, you need to insert your network credentials in the following variables:
<k>const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
Make sure you select the right camera module. In this case, we're using the AI-THINKER Model. If you're using another camera model, you can read this <a href="https://randomnerdtutorials.com/esp32-cam-camera-pin-gpios/">Guide ESP32-CAM Camera Boards: Pin and GPIOs Assignment</a>.
Add your Raspberry Pi IP address or use the server domain name:
<k>String serverName = "192.168.1.XXX";   // REPLACE WITH YOUR Raspberry Pi IP ADDRESS
//String serverName = "example.com";   // OR REPLACE WITH YOUR DOMAIN NAME
String serverPath = "/upload.php";     // The default serverPath should be upload.php</k>
<h3>Upload Code to ESP32-CAM</h3>
Now you can upload the code to your ESP32-CAM board. Connect the ESP32-CAM board to your computer using an <a aria-label="FTDI programmer (opens in a new tab)" href="https://makeradvisor.com/tools/ftdi-programmer-board/" target="_blank">FTDI programmer</a>. 
Follow the next schematic diagram:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/ESP32-CAM-FTDI-programmer-5V-supply.png">
Many FTDI programmers have a jumper that allows you to select 3.3V or 5V. Make sure the jumper is in the right place to select 5V.
<k>Important: </k> GPIO 0 needs to be connected to GND so that you're able to upload code.
<table><tbody>
<tr>
<td><k>ESP32-CAM</k></td>
<td><k>FTDI Programmer</k></td>
</tr>
<tr>
<td>GND</td>
<td>GND</td>
</tr>
<tr>
<td>5V</td>
<td>VCC (5V)</td>
</tr>
<tr>
<td>U0R</td>
<td>TX</td>
</tr>
<tr>
<td>U0T</td>
<td>RX</td>
</tr>
<tr>
<td>GPIO 0</td>
<td>GND</td>
</tr>
</tbody></table>To upload the code, follow the next steps:
<ol>
Go to <k>Tools </k>> <k>Board </k>and select <k>AI-Thinker ESP32-CAM</k>.
Go to <k>Tools </k>> <k>Port </k>and select the COM port the ESP32 is connected to.
Then, click the upload button to upload the code.
When you start to see these dots on the debugging window as shown below, press the ESP32-CAM on-board RST button.   
</ol>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/dots-uploading-code.png">
After a few seconds, the code should be successfully uploaded to your board.
If you have troubles uploading the code, read our <a href="https://randomnerdtutorials.com/esp32-cam-troubleshooting-guide/">ESP32-CAM Troubleshooting Guide</a>.
<h3>How the Code Works</h3>
Here's a quick explanation of how the code works:
Imports all libraries;
Defines the needed variables;
Defines the camera pins;
In the setup() you establish a Wi-Fi connection and initialize the ESP32 camera. 
The loop() has a <a href="https://randomnerdtutorials.com/esp32-pir-motion-sensor-interrupts-timers/">timer</a> that calls the sendPhoto() function every 30 seconds. You can change that delay time in the timerInterval variable.
The sendPhoto() function is the part that actually takes a photo and sends it to your server. You can use that function in other of your projects that require taking and publishing a photo to a server.
<h3>4. Testing and Final Demonstration</h3>
After uploading the code to your board, open the Arduino IDE Serial Monitor and you should see a similar message being printed every 30 seconds:
<k>The file esp32-cam.jpg has been uploaded.</k>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/ESP32-CAM-esp32-cam-jpg-file-Arduino-IDE-Serial-Monitor.png">
If you go to your local server URL <em>http://IP-Address/uploads</em>, or to your cloud server URL <em>https://example.com/uploads</em> you should have a folder with all your stored photos.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/ESP32-CAM-Camera-Board-Uploads-Folder-Images-stored-server.png">
You can open each link to open a new page with the full image:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/ESP32-CAM-Upload-Photo-to-Server-PHP-Arduino-IDE.jpg">
Now, if you go to your local server URL <em>http://IP-Address/gallery.php</em>, or to your cloud server URL <em>https://example.com/gallery.php,</em> you can access the gallery page, where you can view and delete the photos.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/ESP32-CAM-Camera-Photo-Gallery-view-PHP-f.jpg">
To delete any photo, just click on the Delete file link next to each image.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/06/ESP32-CAM-delete-file-from-gallery-php.jpg">
<h3>Wrapping Up</h3>
That's it! Now, you can send your ESP32-CAM photos to any server using HTTP POST. Modify this project to best suit your needs. For example, take a photo and send to a server when motion is detected.

<h2>Control ESP32 and ESP8266 GPIOs from Anywhere in the World</h2>
In this project, you'll learn how to control your ESP32 or ESP8266 GPIOs from anywhere in the world. This can be very useful to control a relay, a thermostat, or any other device remotely.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/ESP32-ESP8266-Control-GPIOs-from-anywhere-cloud-php.jpg">
<em>Updated on 27 March 2023</em>
This project is also very versatile. Through your cloud dashboard, you can easily control more outputs (without uploading new code to your board) and you can even connect multiple boards to your server.
Previously, we've stored sensor readings into a database and we've used different methods to display sensor readings on a:
<a href="https://randomnerdtutorials.com/esp32-esp8266-mysql-database-php/">Table</a>
<a href="https://randomnerdtutorials.com/visualize-esp32-esp8266-sensor-readings-from-anywhere/">Charts</a>
<a href="https://randomnerdtutorials.com/cloud-weather-station-esp32-esp8266/">Gauges</a>
Now, I've created this new project where you can create buttons in a dashboard and assign them to a Board and GPIO number. Then, you can use the toggle switches to control the ESP32 or ESP8266 outputs from anywhere.
There are many ways of controlling outputs from anywhere, and even though this is a working solution there are other <a href="https://randomnerdtutorials.com/firebase-control-esp32-gpios/" title="">methods that provide a two-way communication with your devices</a>. I also recommend that you take this project further and add more features to fit your own needs.
To build this project, you'll use these technologies:
ESP32 or ESP8266 programmed with Arduino IDE
Hosting server and domain name
PHP scripts to store and retrieve the output states stored in a MySQL database
<k>Table of Contents</k>
This project is divided into the following main sections:
<ol>
Hosting Your PHP Application and MySQL Database
Preparing Your MySQL Database
Creating Your Dashboard Files
PHP Script  Update and Retrieve Output States
PHP Script for Database Functions
PHP Script  Control Buttons
Setting Up the ESP32 or ESP8266
</ol>
<h3>Watch the Video Demonstration</h3>
To see how the project works, you can watch the following video demonstration:

<h3>0. Download Source Code</h3>
For this project, you'll need these files:
SQL query to create your table: <a aria-label="Outputs_and_Boards_Table.sql (opens in a new tab)" href="https://github.com/RuiSantosdotme/control-esp32-esp8266-gpios-from-anywhere/blob/master/Code/Outputs_and_Boards_Table.sql" target="_blank">Outputs_and_Boards_Table.sql</a>
Insert and access database: <a aria-label="esp-database.php (opens in a new tab)" href="https://github.com/RuiSantosdotme/control-esp32-esp8266-gpios-from-anywhere/blob/master/Code/esp-database.php" target="_blank">esp-database.php</a>
Handle HTTP requests: <a aria-label="esp-outputs-action.php (opens in a new tab)" href="https://github.com/RuiSantosdotme/control-esp32-esp8266-gpios-from-anywhere/blob/master/Code/esp-outputs-action.php" target="_blank">esp-outputs-action.php</a>
CSS file to style your web page: <a aria-label="esp-style.css (opens in a new tab)" href="https://github.com/RuiSantosdotme/control-esp32-esp8266-gpios-from-anywhere/blob/master/Code/esp-style.css" target="_blank">esp-style.css</a>
Display your control buttons: <a aria-label="esp-outputs.php (opens in a new tab)" href="https://github.com/RuiSantosdotme/control-esp32-esp8266-gpios-from-anywhere/blob/master/Code/esp-outputs.php" target="_blank">esp-outputs.php</a>
Arduino Sketch for ESP32 (<k>with HTTPS</k>): <a href="https://github.com/RuiSantosdotme/control-esp32-esp8266-gpios-from-anywhere/blob/master/Code/HTTPS_ESP32_GET_Request_JSON.ino" target="_blank" rel="noopener" title="">ESP32_HTTPS_GET_Request_JSON.ino</a>
Arduino Sketch for ESP8266 (<k>with HTTPS</k>): <a href="https://github.com/RuiSantosdotme/control-esp32-esp8266-gpios-from-anywhere/blob/master/Code/HTTPS_ESP8266_GET_Request_JSON.ino" target="_blank" rel="noopener" title="">ESP8266_HTTPS_GET_Request_JSON.ino</a>
Arduino Sketch for ESP32 (without HTTPS): <a aria-label="ESP32_HTTP_GET_Request_JSON.ino (opens in a new tab)" href="https://github.com/RuiSantosdotme/control-esp32-esp8266-gpios-from-anywhere/blob/master/Code/ESP32_HTTP_GET_Request_JSON.ino.ino" target="_blank">ESP32_HTTP_GET_Request_JSON.ino</a>
Arduino Sketch for ESP8266 (without HTTPS): <a aria-label="ESP8266_HTTP_GET_Request_JSON.ino (opens in a new tab)" href="https://github.com/RuiSantosdotme/control-esp32-esp8266-gpios-from-anywhere/blob/master/Code/ESP8266_HTTP_GET_Request_JSON.ino.ino" target="_blank">ESP8266_HTTP_GET_Request_JSON.ino</a>
<k><a aria-label=" (opens in a new tab)" href="https://github.com/RuiSantosdotme/control-esp32-esp8266-gpios-from-anywhere/archive/master.zip" target="_blank">Download all projects files</a></k>
<h3>1. Hosting Your PHP Application and MySQL Database</h3>
The goal of this project is to have your own domain name and hosting account that allows you to control your ESP32 or ESP8266 GPIOs from anywhere in the world.
Here's a high-level overview of how the project works:
<a href="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/Control-outputs-from-anywhere-project-overview.png?quality=100&strip=all&ssl=1"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/Control-outputs-from-anywhere-project-overview.png"></a>
<ol>
You have a web page running a PHP script with some toggle buttons that allow you to control the outputs on and off;
When you press the buttons, it updates the output state and saves it in your database;
You can add more buttons or delete them from your dashboard;
Then, you can have an ESP32 or ESP8266 or even multiple boards that make HTTP GET requests every X number of seconds to your server;
Finally, according to the result of that HTTP GET request, the ESP board updates its GPIOs accordingly.
</ol>
<h3>Hosting Services</h3>
I recommend using one of the following hosting services that can handle all the project requirements:
<a aria-label=" (opens in a new tab)" href="https://randomnerdtutorials.com/bluehost" target="_blank">Bluehost (user-friendly with cPanel)</a>: free domain name when you sign up for the 3-year plan. I recommend choosing the unlimited websites option;
<a aria-label=" (opens in a new tab)" style="font-size: inherit; background-color: initial;" href="https://randomnerdtutorials.com/digitalocean" target="_blank">Digital Ocean</a>: Linux server that you manage through a command line. I only recommended this option for advanced users.
Those two services are the ones that I use and personally recommend, but you can use any other hosting service. Any hosting service that offers PHP and MySQL will work with this tutorial. If you don't have a hosting account, I recommend <a href="https://randomnerdtutorials.com/bluehost">signing up for Bluehost</a>.
<a href="https://randomnerdtutorials.com/bluehost" target="_blank" rel="noopener noreferrer">Get Hosting and Domain Name with Bluehost <U+00BB></a>
When buying a hosting account, you'll also have to purchase a domain name. This is what makes this project interesting: you'll be able to go your domain name (http://example.com) and control your boards.
If you like our projects, you might consider signing up for one of the recommended hosting services, because you'll be supporting our work.
<k>Note: </k> you can also run a <a href="https://randomnerdtutorials.com/raspberry-pi-apache-mysql-php-lamp-server/">LAMP (Linux, Apache, MySQL, PHP) server</a> on a Raspberry Pi to <a href="https://randomnerdtutorials.com/esp32-esp8266-raspberry-pi-lamp-server/">control your boards in your local network</a>. However, the purpose of this tutorial is to control the ESP outputs with your own domain name that you can access from anywhere in the world.
<h3>2. Preparing Your MySQL Database</h3>
After signing up for a <a aria-label="hosting and setting up a domain name (opens in a new tab)" href="https://randomnerdtutorials.com/bluehost" target="_blank">hosting account and setting up a domain name</a>, you can login to your cPanel or similar dashboard. After that, follow the next steps to create your database, username, password and SQL table.
<h3>Creating a database and user</h3>
Open the <k>Advanced</k> tab:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/cpanel-bluehost-advanced-tab.jpg">
<k>1.</k> Type database in the search bar and select MySQL Database Wizard.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/08/A-CPanel-select-MySQL-database-wizard-to-create-db.png">
<k>2.</k> Enter your desired Database name. In my case, the database name is esp_data. Then, press the Next Step button:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/08/ESP32-ESP8266-CPanel-Create-MySQL-Database.png">
<k>Note: </k> later you'll have to use the database name with the prefix that your host gives you (my database prefix in the screenshot above is blurred). I'll refer to it as example_esp_data from now on.
<k>3.</k> Type your Database username and set a password. You must save all those details, because you'll need them later to establish a database connection with your PHP code.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/08/ESP32-ESP8266-CPanel-Create-MySQL-Database-User-Password.png">
That's it! Your new database and user were created successfully. Now, save all your details because you'll need them later:
<k>Database name</k>: example_esp_data
<k>Username</k>: example_esp_board
<k>Password</k>: your password
<h3>Creating a SQL table</h3>
After creating your database and user, go back to cPanel dashboard and search for phpMyAdmin.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/08/ESP32-ESP8266-CPanel-Open-PHPMyAdmin.png">
In the left sidebar, select your database name example_esp_data and open the SQL tab. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/08/ESP32-ESP8266-PHPMyAdmin-Open-Database.png">
<k>Important: </k> make sure you've opened the example_esp_data database. Then, click the SQL tab. If you don't follow these exact steps and run the SQL query, you might create a table in the wrong database.
Copy the SQL query in the following snippet:
<k>CREATE TABLE Outputs (
    id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(64),
    board INT(6),
    gpio INT(6),
    state INT(6)
);
INSERT INTO `Outputs`(`name`, `board`, `gpio`, `state`) VALUES ("Built-in LED", 1, 2, 0);
CREATE TABLE Boards (
    id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    board INT(6),
    last_request TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
INSERT INTO `Boards`(`board`) VALUES (1);
</k>
<a href="https://raw.githubusercontent.com/RuiSantosdotme/control-esp32-esp8266-gpios-from-anywhere/master/Code/Outputs_and_Boards_Table.sql" target="_blank">View raw code</a>
Paste it in the SQL query field (highlighted with a red rectangle) and press the Go button to create your table:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/Create-MySQL-Tables-for-control-ESP32-ESP8266-GPIOs-Dashboard.png">
After that, you should see your newly created tables called Boards and Outputs in the example_esp_data database as shown in the figure below:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/MySQL-Tables-created-for-control-ESP32-ESP8266-GPIOs-Dashboard.png">
<h3>3. Creating Your Dashboard Files</h3>
In this section, we're going to create the files that are responsible for creating your Dashboard. Here are the files:
Insert and access database: <a href="https://github.com/RuiSantosdotme/control-esp32-esp8266-gpios-from-anywhere/blob/master/Code/esp-database.php" target="_blank">esp-database.php</a>
Handle HTTP requests: <a href="https://github.com/RuiSantosdotme/control-esp32-esp8266-gpios-from-anywhere/blob/master/Code/esp-outputs-action.php" target="_blank">esp-outputs-action.php</a>
CSS file to style your web page: <a href="https://github.com/RuiSantosdotme/control-esp32-esp8266-gpios-from-anywhere/blob/master/Code/esp-style.css" target="_blank">esp-style.css</a>
Display your control buttons: <a href="https://github.com/RuiSantosdotme/control-esp32-esp8266-gpios-from-anywhere/blob/master/Code/esp-outputs.php" target="_blank">esp-outputs.php</a> 
If you're using a hosting provider with cPanel, you can search for File Manager:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/08/ESP32-ESP8266-CPanel-Open-Edit-PHP-Files.png?w=828&quality=100&strip=all&ssl=1" alt="ESP32 ESP8266 CPanel Open Edit PHP Files with File Manager" data-recalc-dims="1" loading="lazy" fetchpriority="low">
Then, select the <k>public_html</k> option and press the + File button to create a new file.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/06/ESP32-ESP8266-CPanel-Create-New-PHP-File.png">
<k>Note: </k> if you're following this tutorial and you're not familiar with PHP, I recommend creating these exact files.
Create four new files in <k>/public_html</k> with these exact names and extensions:
<em>esp-database.php</em>
<em>esp-outputs-action.php</em>
<em>esp-outputs.php</em>
<em>esp-style.css</em>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/Create-PHP-files-for-control-ESP32-ESP8266-GPIOs-Dashboard.png">
<h3>4. PHP Script  Update and Retrieve Output States</h3>
In this section, we're going to create a PHP script that is responsible for receiving incoming requests and interacting with your MySQL database.
Edit the newly created file (<em>esp-outputs-action.php</em>) and copy the following snippet:
<k>&lt;?php
    include_once('esp-database.php');
    $action = $id = $name = $gpio = $state = "";
    if ($_SERVER["REQUEST_METHOD"] == "POST") {
        $action = test_input($_POST["action"]);
        if ($action == "output_create") {
            $name = test_input($_POST["name"]);
            $board = test_input($_POST["board"]);
            $gpio = test_input($_POST["gpio"]);
            $state = test_input($_POST["state"]);
            $result = createOutput($name, $board, $gpio, $state);
            $result2 = getBoard($board);
            if(!$result2->fetch_assoc()) {
                createBoard($board);
            }
            echo $result;
        }
        else {
            echo "No data posted with HTTP POST.";
        }
    }
    if ($_SERVER["REQUEST_METHOD"] == "GET") {
        $action = test_input($_GET["action"]);
        if ($action == "outputs_state") {
            $board = test_input($_GET["board"]);
            $result = getAllOutputStates($board);
            if ($result) {
                while ($row = $result->fetch_assoc()) {
                    $rows[$row["gpio"]] = $row["state"];
                }
            }
            echo json_encode($rows);
            $result = getBoard($board);
            if($result->fetch_assoc()) {
                updateLastBoardTime($board);
            }
        }
        else if ($action == "output_update") {
            $id = test_input($_GET["id"]);
            $state = test_input($_GET["state"]);
            $result = updateOutput($id, $state);
            echo $result;
        }
        else if ($action == "output_delete") {
            $id = test_input($_GET["id"]);
            $board = getOutputBoardById($id);
            if ($row = $board->fetch_assoc()) {
                $board_id = $row["board"];
            }
            $result = deleteOutput($id);
            $result2 = getAllOutputStates($board_id);
            if(!$result2->fetch_assoc()) {
                deleteBoard($board_id);
            }
            echo $result;
        }
        else {
            echo "Invalid HTTP request.";
        }
    }
    function test_input($data) {
        $data = trim($data);
        $data = stripslashes($data);
        $data = htmlspecialchars($data);
        return $data;
    }
?>
</k>
<a href="https://raw.githubusercontent.com/RuiSantosdotme/control-esp32-esp8266-gpios-from-anywhere/master/Code/esp-outputs-action.php" target="_blank">View raw code</a>
<h3>5. PHP Script for Database Functions</h3>
Edit your file <em>esp-database.php</em> that inserts, deletes, and retrieves data. Copy the next PHP script:
<k>&lt;?php
    $servername = "localhost";
    // Your Database name
    $dbname = "REPLACE_WITH_YOUR_DATABASE_NAME";
    // Your Database user
    $username = "REPLACE_WITH_YOUR_USERNAME";
    // Your Database user password
    $password = "REPLACE_WITH_YOUR_PASSWORD";
    function createOutput($name, $board, $gpio, $state) {
        global $servername, $username, $password, $dbname;
        // Create connection
        $conn = new mysqli($servername, $username, $password, $dbname);
        // Check connection
        if ($conn->connect_error) {
            die("Connection failed: " . $conn->connect_error);
        }
        $sql = "INSERT INTO Outputs (name, board, gpio, state)
        VALUES ('" . $name . "', '" . $board . "', '" . $gpio . "', '" . $state . "')";
       if ($conn->query($sql) === TRUE) {
            return "New output created successfully";
        }
        else {
            return "Error: " . $sql . "&lt;br>" . $conn->error;
        }
        $conn->close();
    }
    function deleteOutput($id) {
        global $servername, $username, $password, $dbname;
        // Create connection
        $conn = new mysqli($servername, $username, $password, $dbname);
        // Check connection
        if ($conn->connect_error) {
            die("Connection failed: " . $conn->connect_error);
        }
        $sql = "DELETE FROM Outputs WHERE id='". $id .  "'";
       if ($conn->query($sql) === TRUE) {
            return "Output deleted successfully";
        }
        else {
            return "Error: " . $sql . "&lt;br>" . $conn->error;
        }
        $conn->close();
    }
    function updateOutput($id, $state) {
        global $servername, $username, $password, $dbname;
        // Create connection
        $conn = new mysqli($servername, $username, $password, $dbname);
        // Check connection
        if ($conn->connect_error) {
            die("Connection failed: " . $conn->connect_error);
        }
        $sql = "UPDATE Outputs SET state='" . $state . "' WHERE id='". $id .  "'";
       if ($conn->query($sql) === TRUE) {
            return "Output state updated successfully";
        }
        else {
            return "Error: " . $sql . "&lt;br>" . $conn->error;
        }
        $conn->close();
    }
    function getAllOutputs() {
        global $servername, $username, $password, $dbname;
        // Create connection
        $conn = new mysqli($servername, $username, $password, $dbname);
        // Check connection
        if ($conn->connect_error) {
            die("Connection failed: " . $conn->connect_error);
        }
        $sql = "SELECT id, name, board, gpio, state FROM Outputs ORDER BY board";
        if ($result = $conn->query($sql)) {
            return $result;
        }
        else {
            return false;
        }
        $conn->close();
    }
    function getAllOutputStates($board) {
        global $servername, $username, $password, $dbname;
        // Create connection
        $conn = new mysqli($servername, $username, $password, $dbname);
        // Check connection
        if ($conn->connect_error) {
            die("Connection failed: " . $conn->connect_error);
        }
        $sql = "SELECT gpio, state FROM Outputs WHERE board='" . $board . "'";
        if ($result = $conn->query($sql)) {
            return $result;
        }
        else {
            return false;
        }
        $conn->close();
    }
    function getOutputBoardById($id) {
        global $servername, $username, $password, $dbname;
        // Create connection
        $conn = new mysqli($servername, $username, $password, $dbname);
        // Check connection
        if ($conn->connect_error) {
            die("Connection failed: " . $conn->connect_error);
        }
        $sql = "SELECT board FROM Outputs WHERE id='" . $id . "'";
        if ($result = $conn->query($sql)) {
            return $result;
        }
        else {
            return false;
        }
        $conn->close();
    }
    function updateLastBoardTime($board) {
        global $servername, $username, $password, $dbname;
        // Create connection
        $conn = new mysqli($servername, $username, $password, $dbname);
        // Check connection
        if ($conn->connect_error) {
            die("Connection failed: " . $conn->connect_error);
        }
        $sql = "UPDATE Boards SET last_request=now() WHERE board='". $board .  "'";
       if ($conn->query($sql) === TRUE) {
            return "Output state updated successfully";
        }
        else {
            return "Error: " . $sql . "&lt;br>" . $conn->error;
        }
        $conn->close();
    }
    function getAllBoards() {
        global $servername, $username, $password, $dbname;
        // Create connection
        $conn = new mysqli($servername, $username, $password, $dbname);
        // Check connection
        if ($conn->connect_error) {
            die("Connection failed: " . $conn->connect_error);
        }
        $sql = "SELECT board, last_request FROM Boards ORDER BY board";
        if ($result = $conn->query($sql)) {
            return $result;
        }
        else {
            return false;
        }
        $conn->close();
    }
    function getBoard($board) {
        global $servername, $username, $password, $dbname;
        // Create connection
        $conn = new mysqli($servername, $username, $password, $dbname);
        // Check connection
        if ($conn->connect_error) {
            die("Connection failed: " . $conn->connect_error);
        }
        $sql = "SELECT board, last_request FROM Boards WHERE board='" . $board . "'";
        if ($result = $conn->query($sql)) {
            return $result;
        }
        else {
            return false;
        }
        $conn->close();
    }
    function createBoard($board) {
        global $servername, $username, $password, $dbname;
        // Create connection
        $conn = new mysqli($servername, $username, $password, $dbname);
        // Check connection
        if ($conn->connect_error) {
            die("Connection failed: " . $conn->connect_error);
        }
        $sql = "INSERT INTO Boards (board) VALUES ('" . $board . "')";
       if ($conn->query($sql) === TRUE) {
            return "New board created successfully";
        }
        else {
            return "Error: " . $sql . "&lt;br>" . $conn->error;
        }
        $conn->close();
    }
    function deleteBoard($board) {
        global $servername, $username, $password, $dbname;
        // Create connection
        $conn = new mysqli($servername, $username, $password, $dbname);
        // Check connection
        if ($conn->connect_error) {
            die("Connection failed: " . $conn->connect_error);
        }
        $sql = "DELETE FROM Boards WHERE board='". $board .  "'";
       if ($conn->query($sql) === TRUE) {
            return "Board deleted successfully";
        }
        else {
            return "Error: " . $sql . "&lt;br>" . $conn->error;
        }
        $conn->close();
    }
?>
</k>
<a href="https://raw.githubusercontent.com/RuiSantosdotme/control-esp32-esp8266-gpios-from-anywhere/master/Code/esp-database.php" target="_blank">View raw code</a>
Before saving the file, you need to modify the $dbname, $username and $password variables with your unique details:
<k>// Your Database name
$dbname = "example_esp_data";
// Your Database user
$username = "example_esp_board";
// Your Database user password
$password = "YOUR_USER_PASSWORD";</k>
After adding the database name, username and password, save the file and continue with this tutorial.
<h3>6. PHP Script  Control Buttons</h3>
You'll also need to add a CSS file to style your dashboard (<em>esp-style.css</em>). Copy that CSS to your file and save it:
<k>/**
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/control-esp32-esp8266-gpios-from-anywhere/
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
**/
html {
    font-family: Arial;
    display: inline-block;
    text-align: center;
}
h2 {
    font-size: 3.0rem;
}
body {
    max-width: 600px;
    margin:0px auto;
    padding-bottom: 25px;
}
.switch {
    position: relative;
    display: inline-block;
    width: 120px;
    height: 68px;
}
.switch input {
    display: none
}
.slider {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #949494;
    border-radius: 34px;
}
.slider:before {
    position: absolute;
    content: "";
    height: 52px;
    width: 52px;
    left: 8px; bottom: 8px;
    background-color: #fff;
    -webkit-transition: .4s;
    transition: .4s;
    border-radius: 68px;
}
input:checked+.slider {
    background-color: #008B74;
}
input:checked+.slider:before {
    -webkit-transform: translateX(52px);
    -ms-transform: translateX(52px);
    transform: translateX(52px);
}
input[type=text], input[type=number], select {
    width: 100%;
    padding: 12px 20px;
    margin: 8px 0;
    display: inline-block;
    border: 1px solid #ccc;
    border-radius: 4px;
    box-sizing: border-box;
}
input[type=submit] {
    width: 100%;
    background-color: #008B74;
    color: white;
    padding: 14px 20px;
    margin: 8px 0;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}
input[type=submit]:hover {
    background-color: #005a4c;
}
div {
    text-align: left;
    border-radius: 4px;
    background-color: #efefef;
    padding: 20px;
}
</k>
<a href="https://raw.githubusercontent.com/RuiSantosdotme/control-esp32-esp8266-gpios-from-anywhere/master/Code/esp-style.css" target="_blank">View raw code</a>
Finally, copy the next PHP script to your <em>esp-outputs.php</em> files that will display your control buttons and allow you to create/delete buttons:
<k>&lt;!--
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/control-esp32-esp8266-gpios-from-anywhere/
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
-->
&lt;?php
    include_once('esp-database.php');
    $result = getAllOutputs();
    $html_buttons = null;
    if ($result) {
        while ($row = $result->fetch_assoc()) {
            if ($row["state"] == "1"){
                $button_checked = "checked";
            }
            else {
                $button_checked = "";
            }
            $html_buttons .= '&lt;h3>' . $row["name"] . ' - Board '. $row["board"] . ' - GPIO ' . $row["gpio"] . ' (&lt;i>&lt;a onclick="deleteOutput(this)" href="javascript:void(0);"id"] . '">Delete&lt;/a>&lt;/i>)&lt;/h3>&lt;label>&lt;input type="checkbox" onchange="updateOutput(this)"id"] . '" ' . $button_checked . '>&lt;span>&lt;/span>&lt;/label>';
        }
    }
    $result2 = getAllBoards();
    $html_boards = null;
    if ($result2) {
        $html_boards .= '&lt;h3>Boards&lt;/h3>';
        while ($row = $result2->fetch_assoc()) {
            $row_reading_time = $row["last_request"];
            // Uncomment to set timezone to - 1 hour (you can change 1 to any number)
            //$row_reading_time = date("Y-m-d H:i:s", strtotime("$row_reading_time - 1 hours"));
            // Uncomment to set timezone to + 4 hours (you can change 4 to any number)
            //$row_reading_time = date("Y-m-d H:i:s", strtotime("$row_reading_time + 7 hours"));
            $html_boards .= '&lt;p>&lt;strong>Board ' . $row["board"] . '&lt;/strong> - Last Request Time: '. $row_reading_time . '&lt;/p>';
        }
    }
?>
&lt;!DOCTYPE HTML>
&lt;html>
    &lt;head>&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        &lt;meta name="viewport" content="width=device-width, initial-scale=1">
        &lt;link rel="stylesheet" type="text/css" href="esp-style.css">
        &lt;title>ESP Output Control&lt;/title>
    &lt;/head>
&lt;body>
    &lt;h2>ESP Output Control&lt;/h2>
    &lt;?php echo $html_buttons; ?>
    &lt;br>&lt;br>
    &lt;?php echo $html_boards; ?>
    &lt;br>&lt;br>
    &lt;div>&lt;form onsubmit="return createOutput();">
        &lt;h3>Create New Output&lt;/h3>
        &lt;label for="outputName">Name&lt;/label>
        &lt;input type="text" name="name">&lt;br>
        &lt;label for="outputBoard">Board ID&lt;/label>
        &lt;input type="number" name="board" min="0">
        &lt;label for="outputGpio">GPIO Number&lt;/label>
        &lt;input type="number" name="gpio" min="0">
        &lt;label for="outputState">Initial GPIO State&lt;/label>
        &lt;select name="state">
          &lt;option value="0">0 = OFF&lt;/option>
          &lt;option value="1">1 = ON&lt;/option>
        &lt;/select>
        &lt;input type="submit" value="Create Output">
        &lt;p>&lt;strong>Note:&lt;/strong> in some devices, you might need to refresh the page to see your newly created buttons or to remove deleted buttons.&lt;/p>
    &lt;/form>&lt;/div>
    &lt;script>
        function updateOutput(element) {
            var xhr = new XMLHttpRequest();
            if(element.checked){
                xhr.open("GET", "esp-outputs-action.php?action=output_update&id="+element.id+"&state=1", true);
            }
            else {
                xhr.open("GET", "esp-outputs-action.php?action=output_update&id="+element.id+"&state=0", true);
            }
            xhr.send();
        }
        function deleteOutput(element) {
            var result = confirm("Want to delete this output?");
            if (result) {
                var xhr = new XMLHttpRequest();
                xhr.open("GET", "esp-outputs-action.php?action=output_delete&id="+element.id, true);
                xhr.send();
                alert("Output deleted");
                setTimeout(function(){ window.location.reload(); });
            }
        }
        function createOutput(element) {
            var xhr = new XMLHttpRequest();
            xhr.open("POST", "esp-outputs-action.php", true);
            xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
            xhr.onreadystatechange = function() {
                if (this.readyState === XMLHttpRequest.DONE && this.status === 200) {
                    alert("Output created");
                    setTimeout(function(){ window.location.reload(); });
                }
            }
            var outputName = document.getElementById("outputName").value;
            var outputBoard = document.getElementById("outputBoard").value;
            var outputGpio = document.getElementById("outputGpio").value;
            var outputState = document.getElementById("outputState").value;
            var httpRequestData = "action=output_create&name="+outputName+"&board="+outputBoard+"&gpio="+outputGpio+"&state="+outputState;
            xhr.send(httpRequestData);
        }
    &lt;/script>
&lt;/body>
&lt;/html>
</k>
<a href="https://raw.githubusercontent.com/RuiSantosdotme/control-esp32-esp8266-gpios-from-anywhere/master/Code/esp-outputs.php" target="_blank">View raw code</a>
If you try to access your domain name in the following URL path, you'll see the following:
<k>https://example.com/esp-outputs.php</k>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/control-esp32-esp8266-gpios-from-anywhere-f.png">
That's it! You should see that web page with your default button. The default button is called <k>Built-in LED</k>, it's assigned to <k>Board 1</k> and controls <k>GPIO 2</k>.
<h3>7. Setting Up the ESP32 or ESP8266</h3>
This project is compatible with both the ESP32 and ESP8266 boards. You just need to assemble a simple circuit and upload the sketches provided.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/08/esp32-vs-esp8266-devlopment-boards.jpg?w=828&quality=100&strip=all&ssl=1" alt="ESP32 vs ESP8266 Development Boards" data-recalc-dims="1" loading="lazy" fetchpriority="low">
<h3>Parts Required</h3>
To test this project, we'll connect some LEDs to the ESP32 and ESP8266 GPIOs. Here's a list of parts you need to build the circuit for this project:
<a aria-label=" (opens in a new tab)" href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32 board</a> (read <a href="https://makeradvisor.com/esp32-development-boards-review-comparison/" target="_blank">Best ESP32 dev boards</a>)
<a href="https://makeradvisor.com/tools/esp8266-esp-12e-nodemcu-wi-fi-development-board/" target="_blank">ESP8266 board</a> (read <a aria-label=" (opens in a new tab)" href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">Best ESP8266 dev boards</a>)
<a href="https://makeradvisor.com/tools/3mm-5mm-leds-kit-storage-box/" target="_blank" aria-label="5x LEDs<U+2028> (opens in a new tab)">5x LEDs</a>
<a href="https://makeradvisor.com/tools/resistors-kits/" target="_blank" aria-label="5x 220 Ohm resistors<U+2028> (opens in a new tab)">5x 220 Ohm resistors</a>
<a href="https://makeradvisor.com/tools/jumper-wires-kit-120-pieces/" target="_blank">Jumper wires</a>
<a href="https://makeradvisor.com/tools/mb-102-solderless-breadboard-830-points/" target="_blank">Breadboard</a>
You can use the preceding links or go directly to <a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank">MakerAdvisor.com/tools</a> to find all the parts for your projects at the best price!
<a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/header-200.png?w=828&quality=100&strip=all&ssl=1" data-recalc-dims="1" loading="lazy" fetchpriority="low"></a>
<h3>Schematics</h3>
For this example, we'll use an ESP32 board with 3 LEDs and an ESP8266 with 2 LEDs. Instead of LEDs, you can connect a relay module or any other device to the ESP GPIOs.
<a href="https://randomnerdtutorials.com/esp32-relay-module-ac-web-server/">Relay module with ESP32</a>
<a href="https://randomnerdtutorials.com/esp8266-relay-module-ac-web-server/">Relay module with ESP8266</a>
<h4>LEDs wiring to ESP32  Board #1</h4>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/ESP32-Control-LEDs-GPIOs-from-anywhere.png">
<k>Recommended reading:</k> <a href="https://randomnerdtutorials.com/esp32-pinout-reference-gpios/">which ESP32 GPIOs should you use.</a>
<h4>LEDs wiring to ESP8266  Board #2</h4>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/ESP8266-Control-LEDs-GPIOs-from-anywhere.png">
<k>Recommended reading:</k> <a href="https://randomnerdtutorials.com/esp8266-pinout-reference-gpios/">which ESP8266 GPIOs should you use.</a> 
<h3>ESP32 Code  Board #1</h3>
We'll program the ESP32/ESP8266 using Arduino IDE, so you must have the ESP add-on installed in your Arduino IDE. 
Follow one of the next tutorials depending on the board you're using:
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Install the ESP32 Board in Arduino IDE</a>
<a style="font-size: inherit; background-color: initial;" href="https://randomnerdtutorials.com/how-to-install-esp8266-board-arduino-ide/">Install the ESP8266 Board in Arduino IDE</a>
You also need to install the <a aria-label="Arduino_JSON library (opens in a new tab)" href="https://github.com/arduino-libraries/Arduino_JSON" target="_blank">Arduino_JSON library</a>. You can install this library in the Arduino IDE Library Manager. Just go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries </k> and search for the library name as follows:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/Install-Arduino-JSON-library-Arduino-IDE.png">
After installing the necessary board add-ons and libraries, copy the following code to your Arduino IDE, but don't upload it yet. You need to make some changes to make it work for you.
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/control-esp32-esp8266-gpios-from-anywhere/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
#include &lt;WiFi.h>
#include &lt;HTTPClient.h>
#include &lt;WiFiClientSecure.h>
#include &lt;Arduino_JSON.h>
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
//Your IP address or domain name with URL path
const char* serverName = "https://example.com/esp-outputs-action.php?action=outputs_state&board=1";
// Update interval time set to 5 seconds
const long interval = 5000;
unsigned long previousMillis = 0;
String outputsState;
void setup() {
  Serial.begin(115200);
  
  WiFi.begin(ssid, password);
  Serial.println("Connecting");
  while(WiFi.status() != WL_CONNECTED) { 
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.print("Connected to WiFi network with IP Address: ");
  Serial.println(WiFi.localIP());
}
void loop() {
  unsigned long currentMillis = millis();
  
  if(currentMillis - previousMillis >= interval) {
     // Check WiFi connection status
    if(WiFi.status()== WL_CONNECTED ){ 
      outputsState = httpGETRequest(serverName);
      Serial.println(outputsState);
      JSONVar myObject = JSON.parse(outputsState);
  
      // JSON.typeof(jsonVar) can be used to get the type of the var
      if (JSON.typeof(myObject) == "undefined") {
        Serial.println("Parsing input failed!");
        return;
      }
    
      Serial.print("JSON object = ");
      Serial.println(myObject);
    
      // myObject.keys() can be used to get an array of all the keys in the object
      JSONVar keys = myObject.keys();
    
      for (int i = 0; i &lt; keys.length(); i++) {
        JSONVar value = myObject[keys[i]];
        Serial.print("GPIO: ");
        Serial.print(keys[i]);
        Serial.print(" - SET to: ");
        Serial.println(value);
        pinMode(atoi(keys[i]), OUTPUT);
        digitalWrite(atoi(keys[i]), atoi(value));
      }
      // save the last HTTP GET Request
      previousMillis = currentMillis;
    }
    else {
      Serial.println("WiFi Disconnected");
    }
  }
}
String httpGETRequest(const char* serverName) {
  WiFiClientSecure *client = new WiFiClientSecure;
  
  // set secure client without certificate
  client->setInsecure();
  HTTPClient https;
    
  // Your IP address with path or Domain name with URL path 
  https.begin(*client, serverName);
  
  // Send HTTP POST request
  int httpResponseCode = https.GET();
  
  String payload = "{}"; 
  
  if (httpResponseCode>0) {
    Serial.print("HTTP Response code: ");
    Serial.println(httpResponseCode);
    payload = https.getString();
  }
  else {
    Serial.print("Error code: ");
    Serial.println(httpResponseCode);
  }
  // Free resources
  https.end();
  return payload;
}
</k>
<a href="https://github.com/RuiSantosdotme/control-esp32-esp8266-gpios-from-anywhere/raw/master/Code/HTTPS_ESP32_GET_Request_JSON.ino" target="_blank">View raw code</a>
<k>Note: </k>Most servers require you to make HTTPS requests. The code above makes HTTPS requests to be compliant with the requirements of most cloud servers nowadays.
Your server doesn't support HTTPS? <a href="https://github.com/RuiSantosdotme/control-esp32-esp8266-gpios-from-anywhere/blob/master/Code/ESP32_HTTP_GET_Request_JSON.ino.ino" target="_blank" rel="noopener" title="">Use this code instead</a>.
<h4>Setting your network credentials</h4>
You need to modify the following lines with your network credentials: SSID and password. The code is well commented on where you should make the changes.
<k>// Replace with your network credentials
const char* ssid     = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
<h4>Setting your serverName</h4>
You also need to type your domain name, so the ESP makes the HTTP GET request to your own server.
<k>const char* serverName = "https://example.com/esp-outputs-action.php?action=outputs_state&board=1";</k>
Notice that on the URL serverName we have a parameter board=1. This indicates the board ID. If you want to add more boards, you should change that ID. That identifies the board you want to control.
Now, you can upload the code to your board. It should work straight away.
This project is already quite long, so we won't cover how the code works. In summary, your ESP32 makes an HTTP GET request to your server every X number of seconds to update the GPIOs states (by default it's set to 5 seconds).
<k>const long interval = 5000;</k>
Then, the board will update its outputs accordingly to the request response.
Open your Serial Monitor and you should see something similar:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/ESP32-Arduino-IDE-Serial-Monitor-Example.png">
The request retrieves a JSON object that contains the GPIO number and its state. In this case, it tells us that GPIO 2 should be LOW {2:0}.
<h3>ESP8266 Code  Board #2</h3>
For this example, we're controlling the outputs from two boards simultaneously. You can use next code for your ESP8266 board:
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/control-esp32-esp8266-gpios-from-anywhere/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
#include &lt;ESP8266WiFi.h>
#include &lt;ESP8266HTTPClient.h>
#include &lt;WiFiClientSecureBearSSL.h>
#include &lt;Arduino_JSON.h>
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
//Your IP address or domain name with URL path
//const char* serverName = "https://example.com/esp-outputs-action.php?action=outputs_state&board=1";
// Update interval time set to 5 seconds
const long interval = 5000;
unsigned long previousMillis = 0;
String outputsState;
void setup() {
  Serial.begin(115200);
  
  WiFi.begin(ssid, password);
  Serial.println("Connecting");
  while(WiFi.status() != WL_CONNECTED) { 
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.print("Connected to WiFi network with IP Address: ");
  Serial.println(WiFi.localIP());
}
void loop() {
  unsigned long currentMillis = millis();
  
  if(currentMillis - previousMillis >= interval) {
     // Check WiFi connection status
    if(WiFi.status()== WL_CONNECTED ){ 
      outputsState = httpGETRequest(serverName);
      Serial.println(outputsState);
      JSONVar myObject = JSON.parse(outputsState);
  
      // JSON.typeof(jsonVar) can be used to get the type of the var
      if (JSON.typeof(myObject) == "undefined") {
        Serial.println("Parsing input failed!");
        return;
      }
    
      Serial.print("JSON object = ");
      Serial.println(myObject);
    
      // myObject.keys() can be used to get an array of all the keys in the object
      JSONVar keys = myObject.keys();
    
      for (int i = 0; i &lt; keys.length(); i++) {
        JSONVar value = myObject[keys[i]];
        Serial.print("GPIO: ");
        Serial.print(keys[i]);
        Serial.print(" - SET to: ");
        Serial.println(value);
        pinMode(atoi(keys[i]), OUTPUT);
        digitalWrite(atoi(keys[i]), atoi(value));
      }
      // save the last HTTP GET Request
      previousMillis = currentMillis;
    }
    else {
      Serial.println("WiFi Disconnected");
    }
  }
}
String httpGETRequest(const char* serverName) {
  std::unique_ptr&lt;BearSSL::WiFiClientSecure>client(new BearSSL::WiFiClientSecure);
  // Ignore SSL certificate validation
  client->setInsecure();
  HTTPClient https;
    
  // Your IP address with path or Domain name with URL path 
  https.begin(*client, serverName);
  
  // Send HTTP POST request
  int httpResponseCode = https.GET();
  
  String payload = "{}"; 
  
  if (httpResponseCode>0) {
    Serial.print("HTTP Response code: ");
    Serial.println(httpResponseCode);
    payload = https.getString();
  }
  else {
    Serial.print("Error code: ");
    Serial.println(httpResponseCode);
  }
  // Free resources
  https.end();
  return payload;
}
</k>
<a href="https://github.com/RuiSantosdotme/control-esp32-esp8266-gpios-from-anywhere/raw/master/Code/HTTPS_ESP8266_GET_Request_JSON.ino" target="_blank">View raw code</a>
To prepare the code for your ESP8266, just enter the SSID, password, domain name, and board ID (in this case, it's board ID number 2).
<k>Note: </k>Most servers require you to make HTTPS requests. The code above makes HTTPS requests to be compliant with the requirements of most cloud servers nowadays.
Your server doesn't support HTTPS? <a href="https://github.com/RuiSantosdotme/control-esp32-esp8266-gpios-from-anywhere/blob/master/Code/ESP8266_HTTP_GET_Request_JSON.ino.ino" target="_blank" rel="noopener" title="">Use this code instead</a>.
<h3>Demonstration</h3>
After completing all the steps, power both your ESP boards.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/ESP32-ESP8266-Control-GPIOs-from-Anywhere-circuit-schematic-diagram.jpg">
If you open your domain name in this URL path:
<k>https://example.com/esp-outputs.php</k>
You should see the default button in your Dashboard:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/control-esp32-esp8266-gpios-from-anywhere-f.png">
If you press that button on and off, you should be able to control GPIO 2 from your ESP32  Board #1.
You can add more buttons to your project, type a name (<k>LED 2</k>), set board the id to number <k>1</k>, then type the desired GPIO that you want to control (<k>33</k>).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/Create-Dashoard-switches-buttons-to-control-ESP32-ESP8266-GPIOs.png">
Create another button for <k>Board 1</k> to control <k>GPIO 32</k>. Then, add two buttons for <k>Board 2</k> (<k>GPIO 2</k> and <k>GPIO 4</k>).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/control-esp-gpios-from-anywhere-multiple-boards-f.png">
At any point in time, you can use the delete link to remove buttons from your Dashboard or use the form at the bottom to create more.
<k>Note: </k> in some devices, you might need to refresh the page to see your newly created buttons or to remove deleted buttons.
Finally, there's a section that shows the last time a board made a request and updated its outputs.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/control-gpios-anywhere-last-request-esp32-esp8266.png">
Since this is not a two-way communication, when you press the buttons to control your outputs, your board doesn't update the outputs instantly. It will take a few seconds for your ESP board to make a new HTTP GET request and update its output states. With the <k>Last Request Time</k> section, you can see when that happened. Just refresh the page to see the updated values.
The web page is also mobile responsive, so you can use any device to access your server.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/Control-ESP32-ESP8266-GPIOs-from-Anywhere-in-the-World-dashboard-demo.jpg">
<h3>Wrapping Up</h3>
In this tutorial you've learned how to control your ESP32 and ESP8266 outputs from anywhere in the world. This requires that you have your own <a aria-label="server and domain name (opens in a new tab)" href="https://randomnerdtutorials.com/bluehost" target="_blank">server and domain name</a> (alternatively, you can use a <a href="https://randomnerdtutorials.com/esp32-esp8266-raspberry-pi-lamp-server/">Raspberry Pi LAMP Server for local access</a>).
There are many other features that you can add to your server, you can merge it with our previous projects to <a href="https://randomnerdtutorials.com/cloud-weather-station-esp32-esp8266/">display sensor readings</a>. Feel free to add more ESP boards to run simultaneously and define other outputs to control.
I encourage you to change the web page appearance, add more features <a href="https://randomnerdtutorials.com/esp32-esp8266-send-email-notification/">like email notifications</a>, publish data from different sensors, use multiple ESP boards, and much more.

<h2>DIY Cloud Weather Station with ESP32/ESP8266 (MySQL Database and PHP)</h2>
Build a cloud weather station dashboard to visualize your ESP32 or ESP8266 sensor readings from anywhere in the world. You'll visualize your sensor data displayed on gauges and on a table. The ESP32 or ESP8266 will make an HTTP POST request to a PHP script to insert your data into a MySQL database.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/ESP32-ESP8266-Cloud-Weather-Station-PHP.jpg">
<em>Updated on 27 March 2023</em>
Previously, we've stored sensor readings in a database and displayed<a href="https://randomnerdtutorials.com/esp32-esp8266-mysql-database-php/"> them on a table</a> or <a href="https://randomnerdtutorials.com/visualize-esp32-esp8266-sensor-readings-from-anywhere/">charts that you can access from anywhere</a> using your own server. Now, I've decided to take a few steps further and add some more information to the web page.
I've added two gauges to display the latest temperature and humidity readings as well as some statistics about the minimum, maximum and average readings from a number of readings that you can define. You can also visualize all the latest readings on a table and you can select how many readings you want to show.
To build this project, you'll use these technologies:
ESP32 or ESP8266 programmed with Arduino IDE
Hosting server and domain name
PHP script to insert data into MySQL and display it on a web page
MySQL database to store readings
<k>Table of Contents</k>
This project is divided into the following main sections:
<ol>
Hosting Your PHP Application and MySQL Database
Preparing Your MySQL Database
PHP Script HTTP POST  Receive and Insert Data in MySQL Database
PHP Script for Database Functions
PHP Script  Display Database Readings on Gauges and Table
Setting Up the ESP32 or ESP8266
</ol>
<h3>Watch the Video Demonstration</h3>
To see how the project works, you can watch the following video demonstration:

<h3>0. Download Source Code</h3>
For this project, you'll need these files:
SQL query to create your table: <a aria-label=" (opens in a new tab)" href="https://github.com/RuiSantosdotme/Cloud-Weather-Station-ESP32-ESP8266/blob/master/code/SensorData_Table.sql" target="_blank">SensorData_Table.sql</a>
Insert and access database readings: <a aria-label=" (opens in a new tab)" href="https://github.com/RuiSantosdotme/Cloud-Weather-Station-ESP32-ESP8266/blob/master/code/esp-database.php" target="_blank">esp-database.php</a>
Handle HTTP Post requests: <a aria-label=" (opens in a new tab)" href="https://github.com/RuiSantosdotme/Cloud-Weather-Station-ESP32-ESP8266/blob/master/code/esp-post-data.php" target="_blank">esp-post-data.php</a>
CSS file to style your web page: <a aria-label=" (opens in a new tab)" href="https://github.com/RuiSantosdotme/Cloud-Weather-Station-ESP32-ESP8266/blob/master/code/esp-style.css" target="_blank">esp-style.css</a>
Display your sensor readings: <a aria-label=" (opens in a new tab)" href="https://github.com/RuiSantosdotme/Cloud-Weather-Station-ESP32-ESP8266/blob/master/code/esp-weather-station.php" target="_blank">esp-weather-station.php</a>
Arduino Sketch for <k>ESP32</k>: <a href="https://github.com/RuiSantosdotme/Cloud-Weather-Station-ESP32-ESP8266/blob/master/code/HTTPS_ESP32_Cloud_Weather_Station.ino" target="_blank" rel="noopener" title="">HTTPS_ESP32_Cloud_Weather_Station.ino</a>
Arduino Sketch for <k>ESP8266 :</k> <a href="https://github.com/RuiSantosdotme/Cloud-Weather-Station-ESP32-ESP8266/blob/master/code/HTTPS_ESP8266_Cloud_Weather_Station.ino" target="_blank" rel="noopener" title="">HTTPS_ESP8266_Cloud_Weather_Station.ino</a>
If your server doesn't support HTTPS, use this Arduino Sketch (compatible with the ESP32 and ESP8266: <a aria-label=" (opens in a new tab)" href="https://github.com/RuiSantosdotme/Cloud-Weather-Station-ESP32-ESP8266/blob/master/code/ESP_HTTP_POST_MySQL.ino" target="_blank">ESP_HTTP_POST_MySQL.ino</a>
<a aria-label=" (opens in a new tab)" href="https://github.com/RuiSantosdotme/Cloud-Weather-Station-ESP32-ESP8266/archive/master.zip" target="_blank"><k>Download all projects files</k></a>
<h3>1. Hosting Your PHP Application and MySQL Database</h3>
The goal of this project is to have your own domain name and hosting account that allows you to store sensor readings from the ESP32 or ESP8266. You can visualize the readings from anywhere in the world by accessing your own server domain. 
Here's a high-level overview of how the project works:
<a href="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/ESP32-ESP8266-Gauge-weather-station-project-overview.png?quality=100&strip=all&ssl=1"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/ESP32-ESP8266-Gauge-weather-station-project-overview.png"></a>
<ol>
You have an ESP32 or ESP8266 that sends sensor readings to your own server. For this, you have your board connected to your router;
In your server, there's a PHP script that allows you to store your readings in a MySQL database;
Then, another PHP script will display the web page with the gauges, table, and all the other information;
Finally, you can visualize the readings from anywhere in the world by accessing your own domain name.
</ol>
<h3>Hosting Services</h3>
I recommend using one of the following hosting services that can handle all the project requirements:
<a aria-label=" (opens in a new tab)" href="https://randomnerdtutorials.com/bluehost" target="_blank">Bluehost (user-friendly with cPanel)</a>: free domain name when you sign up for the 3-year plan. I recommend choosing the unlimited websites option;
<a aria-label=" (opens in a new tab)" style="font-size: inherit; background-color: initial;" href="https://randomnerdtutorials.com/digitalocean" target="_blank">Digital Ocean</a>: Linux server that you manage through a command line. I only recommended this option for advanced users.
Those two services are the ones that I use and personally recommend, but you can use any other hosting service. Any hosting service that offers PHP and MySQL will work with this tutorial. If you don't have a hosting account, I recommend <a href="https://randomnerdtutorials.com/bluehost">signing up for Bluehost</a>.
<a href="https://randomnerdtutorials.com/bluehost" target="_blank" rel="noopener noreferrer">Get Hosting and Domain Name with Bluehost <U+00BB></a>
When buying a hosting account, you'll also have to purchase a domain name. This is what makes this project interesting: you'll be able to go to your domain name (https://example.com) and see your ESP readings.
If you like our projects, you might consider signing up for one of the recommended hosting services, because you'll be supporting our work.
<k>Note: </k> you can also run a <a href="https://randomnerdtutorials.com/raspberry-pi-apache-mysql-php-lamp-server/">LAMP (Linux, Apache, MySQL, PHP) server</a> on a Raspberry Pi to <a href="https://randomnerdtutorials.com/esp32-esp8266-raspberry-pi-lamp-server/">access data in your local network</a>. However, the purpose of this tutorial is to publish readings in your own domain name that you can access from anywhere in the world. This allows you to easily access your ESP readings without relying on a third-party IoT platform.
<h3>2. Preparing Your MySQL Database</h3>
After signing up for a <a aria-label="hosting and setting up a domain name (opens in a new tab)" href="https://randomnerdtutorials.com/bluehost" target="_blank">hosting account and setting up a domain name</a>, you can login to your cPanel or similar dashboard. After that, follow the next steps to create your database, username, password, and SQL table.
<h3>Creating a database and user</h3>
Open the <k>Advanced</k> tab:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/cpanel-bluehost-advanced-tab.jpg">
<k>1.</k> Type database in the search bar and select MySQL Database Wizard.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/08/A-CPanel-select-MySQL-database-wizard-to-create-db.png">
<k>2.</k> Enter your desired Database name. In my case, the database name is esp_data. Then, press the Next Step button:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/08/ESP32-ESP8266-CPanel-Create-MySQL-Database.png">
<k>Note: </k> later you'll have to use the database name with the prefix that your host gives you (my database prefix in the screenshot above is blurred). I'll refer to it as example_esp_data from now on.
<k>3.</k> Type your Database username and set a password. You must save all those details because you'll need them later to establish a database connection with your PHP code.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/08/ESP32-ESP8266-CPanel-Create-MySQL-Database-User-Password.png">
That's it! Your new database and user were created successfully. Now, save all your details because you'll need them later:
<k>Database name</k>: example_esp_data
<k>Username</k>: example_esp_board
<k>Password</k>: your password
<h3>Creating a SQL table</h3>
After creating your database and user, go back to cPanel dashboard and search for phpMyAdmin.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/08/ESP32-ESP8266-CPanel-Open-PHPMyAdmin.png">
In the left sidebar, select your database name example_esp_data and open the SQL tab. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/08/ESP32-ESP8266-PHPMyAdmin-Open-Database.png">
<k>Important: </k> make sure you've opened the example_esp_data database. Then, click the SQL tab. If you don't follow these exact steps and run the SQL query, you might create a table in the wrong database.
Copy the SQL query in the following snippet:
<k>CREATE TABLE SensorData (
    id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    sensor VARCHAR(30) NOT NULL,
    location VARCHAR(30) NOT NULL,
    value1 VARCHAR(10),
    value2 VARCHAR(10),
    value3 VARCHAR(10),
    reading_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
)
</k>
<a href="https://github.com/RuiSantosdotme/Cloud-Weather-Station-ESP32-ESP8266/raw/master/code/SensorData_Table.sql" target="_blank">View raw code</a>
Paste it in the SQL query field (highlighted with a red rectangle) and press the Go button to create your table:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/06/ESP32-ESP8266-PHPMyAdmin-Create-SQL-Table.png">
After that, you should see your newly created table called SensorData in the example_esp_data database as shown in the figure below:
<a href="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/06/ESP32-ESP8266-PHPMyAdmin-View-SQL-Database.png?quality=100&strip=all&ssl=1"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/06/ESP32-ESP8266-PHPMyAdmin-View-SQL-Database.png"></a>
<h3>3. PHP Script HTTP POST  Receive and Insert Data in MySQL Database</h3>
In this section, we're going to create a PHP script that is responsible for receiving incoming requests from the ESP32 or ESP8266 and inserting the data into a MySQL database.
If you're using a hosting provider with cPanel, you can search for File Manager:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/08/ESP32-ESP8266-CPanel-Open-Edit-PHP-Files.png?w=828&quality=100&strip=all&ssl=1" alt="ESP32 ESP8266 CPanel Open Edit PHP Files with File Manager" data-recalc-dims="1" loading="lazy" fetchpriority="low">
Then, select the <k>public_html</k> option and press the + File button to create a new <em>.php</em> file.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/06/ESP32-ESP8266-CPanel-Create-New-PHP-File.png">
<k>Note: </k> if you're following this tutorial and you're not familiar with PHP or MySQL, I recommend creating these exact files. Otherwise, you'll need to modify the ESP sketch provided with different URL paths. 
Create a new file in <k>/public_html</k> with this exact name and extension: <em>esp-post-data.php</em>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/Create-esp-post-data-PHP-file.png">
Edit the newly created file (<em>esp-post-data.php</em>) and copy the following snippet:
<k>&lt;!--
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/cloud-weather-station-esp32-esp8266/
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
-->
&lt;?php
  include_once('esp-database.php');
  // Keep this API Key value to be compatible with the ESP code provided in the project page. If you change this value, the ESP sketch needs to match
  $api_key_value = "tPmAT5Ab3j7F9";
  $api_key= $sensor = $location = $value1 = $value2 = $value3 = "";
  if ($_SERVER["REQUEST_METHOD"] == "POST") {
    $api_key = test_input($_POST["api_key"]);
    if($api_key == $api_key_value) {
      $sensor = test_input($_POST["sensor"]);
      $location = test_input($_POST["location"]);
      $value1 = test_input($_POST["value1"]);
      $value2 = test_input($_POST["value2"]);
      $value3 = test_input($_POST["value3"]);
      $result = insertReading($sensor, $location, $value1, $value2, $value3);
      echo $result;
    }
    else {
      echo "Wrong API Key provided.";
    }
  }
  else {
    echo "No data posted with HTTP POST.";
  }
  function test_input($data) {
    $data = trim($data);
    $data = stripslashes($data);
    $data = htmlspecialchars($data);
    return $data;
  }
</k>
<a href="https://github.com/RuiSantosdotme/Cloud-Weather-Station-ESP32-ESP8266/raw/master/code/esp-post-data.php" target="_blank">View raw code</a>
<h3>4. PHP Script for Database Functions</h3>
Create a new file in <k>/public_html</k> that is responsible for inserting and accessing data in your database. Name your file: <em>esp-database.php</em> 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/Create-esp-database-PHP-file.png">
Copy that PHP script:
<k>&lt;!--
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/cloud-weather-station-esp32-esp8266/
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
-->
&lt;?php
  $servername = "localhost";
  // REPLACE with your Database name
  $dbname = "REPLACE_WITH_YOUR_DATABASE_NAME";
  // REPLACE with Database user
  $username = "REPLACE_WITH_YOUR_USERNAME";
  // REPLACE with Database user password
  $password = "REPLACE_WITH_YOUR_PASSWORD";
  function insertReading($sensor, $location, $value1, $value2, $value3) {
    global $servername, $username, $password, $dbname;
    // Create connection
    $conn = new mysqli($servername, $username, $password, $dbname);
    // Check connection
    if ($conn->connect_error) {
      die("Connection failed: " . $conn->connect_error);
    }
    $sql = "INSERT INTO SensorData (sensor, location, value1, value2, value3)
    VALUES ('" . $sensor . "', '" . $location . "', '" . $value1 . "', '" . $value2 . "', '" . $value3 . "')";
    if ($conn->query($sql) === TRUE) {
      return "New record created successfully";
    }
    else {
      return "Error: " . $sql . "&lt;br>" . $conn->error;
    }
    $conn->close();
  }
  
  function getAllReadings($limit) {
    global $servername, $username, $password, $dbname;
    // Create connection
    $conn = new mysqli($servername, $username, $password, $dbname);
    // Check connection
    if ($conn->connect_error) {
      die("Connection failed: " . $conn->connect_error);
    }
    $sql = "SELECT id, sensor, location, value1, value2, value3, reading_time FROM SensorData order by reading_time desc limit " . $limit;
    if ($result = $conn->query($sql)) {
      return $result;
    }
    else {
      return false;
    }
    $conn->close();
  }
  function getLastReadings() {
    global $servername, $username, $password, $dbname;
    // Create connection
    $conn = new mysqli($servername, $username, $password, $dbname);
    // Check connection
    if ($conn->connect_error) {
      die("Connection failed: " . $conn->connect_error);
    }
    $sql = "SELECT id, sensor, location, value1, value2, value3, reading_time FROM SensorData order by reading_time desc limit 1" ;
    if ($result = $conn->query($sql)) {
      return $result->fetch_assoc();
    }
    else {
      return false;
    }
    $conn->close();
  }
  function minReading($limit, $value) {
     global $servername, $username, $password, $dbname;
    // Create connection
    $conn = new mysqli($servername, $username, $password, $dbname);
    // Check connection
    if ($conn->connect_error) {
      die("Connection failed: " . $conn->connect_error);
    }
    $sql = "SELECT MIN(" . $value . ") AS min_amount FROM (SELECT " . $value . " FROM SensorData order by reading_time desc limit " . $limit . ") AS min";
    if ($result = $conn->query($sql)) {
      return $result->fetch_assoc();
    }
    else {
      return false;
    }
    $conn->close();
  }
  function maxReading($limit, $value) {
     global $servername, $username, $password, $dbname;
    // Create connection
    $conn = new mysqli($servername, $username, $password, $dbname);
    // Check connection
    if ($conn->connect_error) {
      die("Connection failed: " . $conn->connect_error);
    }
    $sql = "SELECT MAX(" . $value . ") AS max_amount FROM (SELECT " . $value . " FROM SensorData order by reading_time desc limit " . $limit . ") AS max";
    if ($result = $conn->query($sql)) {
      return $result->fetch_assoc();
    }
    else {
      return false;
    }
    $conn->close();
  }
  function avgReading($limit, $value) {
     global $servername, $username, $password, $dbname;
    // Create connection
    $conn = new mysqli($servername, $username, $password, $dbname);
    // Check connection
    if ($conn->connect_error) {
      die("Connection failed: " . $conn->connect_error);
    }
    $sql = "SELECT AVG(" . $value . ") AS avg_amount FROM (SELECT " . $value . " FROM SensorData order by reading_time desc limit " . $limit . ") AS avg";
    if ($result = $conn->query($sql)) {
      return $result->fetch_assoc();
    }
    else {
      return false;
    }
    $conn->close();
  }
?>
</k>
<a href="https://github.com/RuiSantosdotme/Cloud-Weather-Station-ESP32-ESP8266/raw/master/code/esp-database.php" target="_blank">View raw code</a>
Before saving the file, you need to modify the $dbname, $username and $password variables with your unique details:
<k>// Your Database name
$dbname = "example_esp_data";
// Your Database user
$username = "example_esp_board";
// Your Database user password
$password = "YOUR_USER_PASSWORD";</k>
After adding the database name, username and password, save the file and continue with this tutorial. If you try to access your domain name in the next URL path, you'll see the following:
<k>https://example.com/esp-post-data.php</k>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/esp-post-data-example-PHP-file.png">
<h3>5. PHP Script  Display Database Readings on Gauges and Table</h3>
You'll also need to add a CSS file to style your dashboard, name it: <em>esp-style.css</em>:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/Create-esp-style-CSS-file.png">
Copy that CSS to your file and save it:
<k>/**
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/cloud-weather-station-esp32-esp8266/
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
**/
body {
    width: 60%;
    margin: auto;
    text-align: center;
    font-family: Arial;
    top: 50%;
    left: 50%;
}
@media screen and (max-width: 800px) {
    body {
        width: 100%;
    }
}
table {
    margin-left: auto;
    margin-right: auto;
}
div {
    margin-left: auto;
    margin-right: auto;
}
h2 { font-size: 2.5rem; }
.header {
 padding: 1rem;
 margin: 0 0 2rem 0;
 background: #f2f2f2;
}
h1 {
    font-size: 2rem;
    font-family: Arial, sans-serif;
    text-align: center;
    text-transform: uppercase;
}
.content {
    display: flex;
}
@media screen and (max-width: 500px) /* Mobile */ {
    .content {
        flex-direction: column;
    }
}
.mask {
    position: relative;
    overflow: hidden;
    display: block;
    width: 12.5rem;
    height: 6.25rem;
    margin: 1.25rem;
}
.semi-circle {
    position: relative;
    display: block;
    width: 12.5rem;
    height: 6.25rem;
    background: linear-gradient(to right, #3498db 0%, #05b027 33%, #f1c40f 70%, #c0392b 100%);
    border-radius: 50% 50% 50% 50% / 100% 100% 0% 0%;
}
.semi-circle::before {
    content: "";
    position: absolute;
    bottom: 0;
    left: 50%;
    z-index: 2;
    display: block;
    width: 8.75rem;
    height: 4.375rem;
    margin-left: -4.375rem;
    background: #fff;
    border-radius: 50% 50% 50% 50% / 100% 100% 0% 0%;
}
.semi-circle--mask {
    position: absolute;
    top: 0;
    left: 0;
    width: 12.5rem;
    height: 12.5rem;
    background: transparent;
    transform: rotate(120deg) translate3d(0, 0, 0);
    transform-origin: center center;
    backface-visibility: hidden;
    transition: all 0.3s ease-in-out;
}
.semi-circle--mask::before {
    content: "";
    position: absolute;
    top: 0;
    left: 0%;
    z-index: 2;
    display: block;
    width: 12.625rem;
    height: 6.375rem;
    margin: -1px 0 0 -1px;
    background: #f2f2f2;
    border-radius: 50% 50% 50% 50% / 100% 100% 0% 0%;
}
.gauge--2 .semi-circle { background: #3498db; }
.gauge--2 .semi-circle--mask { transform: rotate(20deg) translate3d(0, 0, 0); }
#tableReadings { border-collapse: collapse; }
#tableReadings td, #tableReadings th {
    border: 1px solid #ddd;
    padding: 10px;
}
#tableReadings tr:nth-child(even){ background-color: #f2f2f2; }
#tableReadings tr:hover { background-color: #ddd; }
#tableReadings th {
    padding: 10px;
    background-color: #2f4468;
    color: white;
}
</k>
<a href="https://github.com/RuiSantosdotme/Cloud-Weather-Station-ESP32-ESP8266/raw/master/code/esp-style.css" target="_blank">View raw code</a>
Finally, create another PHP file in the <k>/public_html</k> directory that will display all the database content on a web page. Name your new file: <em>esp-weather-station.php </em>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/Create-esp-weather-station-PHP-file.png">
Edit the newly created file (<em>esp-weather-station.php</em>) and copy the following code:
<k>&lt;!--
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/cloud-weather-station-esp32-esp8266/
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
-->
&lt;?php
    include_once('esp-database.php');
    if (isset($_GET["readingsCount"])){
      $data = $_GET["readingsCount"];
      $data = trim($data);
      $data = stripslashes($data);
      $data = htmlspecialchars($data);
      $readings_count = $_GET["readingsCount"];
    }
    // default readings count set to 20
    else {
      $readings_count = 20;
    }
    $last_reading = getLastReadings();
    $last_reading_temp = $last_reading["value1"];
    $last_reading_humi = $last_reading["value2"];
    $last_reading_time = $last_reading["reading_time"];
    // Uncomment to set timezone to - 1 hour (you can change 1 to any number)
    //$last_reading_time = date("Y-m-d H:i:s", strtotime("$last_reading_time - 1 hours"));
    // Uncomment to set timezone to + 7 hours (you can change 7 to any number)
    //$last_reading_time = date("Y-m-d H:i:s", strtotime("$last_reading_time + 7 hours"));
    $min_temp = minReading($readings_count, 'value1');
    $max_temp = maxReading($readings_count, 'value1');
    $avg_temp = avgReading($readings_count, 'value1');
    $min_humi = minReading($readings_count, 'value2');
    $max_humi = maxReading($readings_count, 'value2');
    $avg_humi = avgReading($readings_count, 'value2');
?>
&lt;!DOCTYPE html>
&lt;html>
    &lt;head>&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        &lt;link rel="stylesheet" type="text/css" href="esp-style.css">
        &lt;meta name="viewport" content="width=device-width, initial-scale=1">
        &lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js">&lt;/script>
    &lt;/head>
    &lt;header>
        &lt;h1><U+0001F4CA> ESP Weather Station&lt;/h2>
        &lt;form method="get">
            &lt;input type="number" name="readingsCount" min="1" placeholder="Number of readings (&lt;?php echo $readings_count; ?>)">
            &lt;input type="submit" value="UPDATE">
        &lt;/form>
    &lt;/header>
&lt;body>
    &lt;p>Last reading: &lt;?php echo $last_reading_time; ?>&lt;/p>
    &lt;section>
    &lt;div>
    &lt;h3>TEMPERATURE&lt;/h3>
              &lt;div>
  &lt;div>&lt;/div>
  &lt;div>&lt;/div>
&lt;/div>
    &lt;p style="font-size: 30px;">--&lt;/p>
    &lt;table cellspacing="5" cellpadding="5">
        &lt;tr>
            &lt;th colspan="3">Temperature &lt;?php echo $readings_count; ?> readings&lt;/th>
            &lt;/tr>
        &lt;tr>
            &lt;td>Min&lt;/td>
                    &lt;td>Max&lt;/td>
                    &lt;td>Average&lt;/td>
                &lt;/tr>
                &lt;tr>
                    &lt;td>&lt;?php echo $min_temp['min_amount']; ?> &deg;C&lt;/td>
                    &lt;td>&lt;?php echo $max_temp['max_amount']; ?> &deg;C&lt;/td>
                    &lt;td>&lt;?php echo round($avg_temp['avg_amount'], 2); ?> &deg;C&lt;/td>
                &lt;/tr>
            &lt;/table>
        &lt;/div>
        &lt;div>
            &lt;h3>HUMIDITY&lt;/h3>
            &lt;div>
                &lt;div>&lt;/div>
                &lt;div>&lt;/div>
            &lt;/div>
            &lt;p style="font-size: 30px;">--&lt;/p>
            &lt;table cellspacing="5" cellpadding="5">
                &lt;tr>
                    &lt;th colspan="3">Humidity &lt;?php echo $readings_count; ?> readings&lt;/th>
                &lt;/tr>
                &lt;tr>
                    &lt;td>Min&lt;/td>
                    &lt;td>Max&lt;/td>
                    &lt;td>Average&lt;/td>
                &lt;/tr>
                &lt;tr>
                    &lt;td>&lt;?php echo $min_humi['min_amount']; ?> %&lt;/td>
                    &lt;td>&lt;?php echo $max_humi['max_amount']; ?> %&lt;/td>
                    &lt;td>&lt;?php echo round($avg_humi['avg_amount'], 2); ?> %&lt;/td>
                &lt;/tr>
            &lt;/table>
        &lt;/div>
    &lt;/section>
&lt;?php
    echo   '&lt;h2> View Latest ' . $readings_count . ' Readings&lt;/h2>
            &lt;table cellspacing="5" cellpadding="5">
                &lt;tr>
                    &lt;th>ID&lt;/th>
                    &lt;th>Sensor&lt;/th>
                    &lt;th>Location&lt;/th>
                    &lt;th>Value 1&lt;/th>
                    &lt;th>Value 2&lt;/th>
                    &lt;th>Value 3&lt;/th>
                    &lt;th>Timestamp&lt;/th>
                &lt;/tr>';
    $result = getAllReadings($readings_count);
        if ($result) {
        while ($row = $result->fetch_assoc()) {
            $row_id = $row["id"];
            $row_sensor = $row["sensor"];
            $row_location = $row["location"];
            $row_value1 = $row["value1"];
            $row_value2 = $row["value2"];
            $row_value3 = $row["value3"];
            $row_reading_time = $row["reading_time"];
            // Uncomment to set timezone to - 1 hour (you can change 1 to any number)
            //$row_reading_time = date("Y-m-d H:i:s", strtotime("$row_reading_time - 1 hours"));
            // Uncomment to set timezone to + 7 hours (you can change 7 to any number)
            //$row_reading_time = date("Y-m-d H:i:s", strtotime("$row_reading_time + 7 hours"));
            echo '&lt;tr>
                    &lt;td>' . $row_id . '&lt;/td>
                    &lt;td>' . $row_sensor . '&lt;/td>
                    &lt;td>' . $row_location . '&lt;/td>
                    &lt;td>' . $row_value1 . '&lt;/td>
                    &lt;td>' . $row_value2 . '&lt;/td>
                    &lt;td>' . $row_value3 . '&lt;/td>
                    &lt;td>' . $row_reading_time . '&lt;/td>
                  &lt;/tr>';
        }
        echo '&lt;/table>';
        $result->free();
    }
?>
&lt;script>
    var value1 = &lt;?php echo $last_reading_temp; ?>;
    var value2 = &lt;?php echo $last_reading_humi; ?>;
    setTemperature(value1);
    setHumidity(value2);
    function setTemperature(curVal){
    //set range for Temperature in Celsius -5 Celsius to 38 Celsius
    var minTemp = -5.0;
    var maxTemp = 38.0;
        //set range for Temperature in Fahrenheit 23 Fahrenheit to 100 Fahrenheit
    //var minTemp = 23;
    //var maxTemp = 100;
    var newVal = scaleValue(curVal, [minTemp, maxTemp], [0, 180]);
    $('.gauge--1 .semi-circle--mask').attr({
    style: '-webkit-transform: rotate(' + newVal + 'deg);' +
    '-moz-transform: rotate(' + newVal + 'deg);' +
    'transform: rotate(' + newVal + 'deg);'
    });
    $("#temp").text(curVal + ' oC');
    }
    function setHumidity(curVal){
    //set range for Humidity percentage 0 % to 100 %
    var minHumi = 0;
    var maxHumi = 100;
    var newVal = scaleValue(curVal, [minHumi, maxHumi], [0, 180]);
    $('.gauge--2 .semi-circle--mask').attr({
    style: '-webkit-transform: rotate(' + newVal + 'deg);' +
    '-moz-transform: rotate(' + newVal + 'deg);' +
    'transform: rotate(' + newVal + 'deg);'
    });
    $("#humi").text(curVal + ' %');
    }
    function scaleValue(value, from, to) {
        var scale = (to[1] - to[0]) / (from[1] - from[0]);
        var capped = Math.min(from[1], Math.max(from[0], value)) - from[0];
        return ~~(capped * scale + to[0]);
    }
&lt;/script>
&lt;/body>
&lt;/html>
</k>
<a href="https://github.com/RuiSantosdotme/Cloud-Weather-Station-ESP32-ESP8266/raw/master/code/esp-weather-station.php" target="_blank">View raw code</a>
If you try to access your domain name in the following URL path, you'll see the following:
<k>https://example.com/esp-weather-station.php</k>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/esp32-esp8266-cloud-weather-station-no-data-yet.png">
That's it! If you see that web page with empty values in your browser, it means that everything is ready. In the next section, you'll learn how to insert data from your ESP32 or ESP8266 into the database.
<h3>6. Setting Up the ESP32 or ESP8266</h3>
This project is compatible with both the ESP32 and ESP8266 boards. You just need to assemble a simple circuit and upload the sketch provided to insert temperature, humidity, pressure, and more into your database every 10 minutes. The sketch is slightly different for each board.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/08/esp32-vs-esp8266-devlopment-boards.jpg?w=828&quality=100&strip=all&ssl=1" alt="ESP32 vs ESP8266 Development Boards" data-recalc-dims="1" loading="lazy" fetchpriority="low">
<h3>Parts Required</h3>
For this example, we'll get sensor readings from the BME280 sensor. Here's a list of parts you need to build the circuit for this project:
<a aria-label=" (opens in a new tab)" href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32 board</a> (read <a href="https://makeradvisor.com/esp32-development-boards-review-comparison/" target="_blank">Best ESP32 dev boards</a>)
Alternative  <a href="https://makeradvisor.com/tools/esp8266-esp-12e-nodemcu-wi-fi-development-board/" target="_blank">ESP8266</a> board (read <a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank" aria-label=" (opens in a new tab)">Best ESP8266 dev boards</a>)
<a href="https://makeradvisor.com/tools/bme280-sensor-module/" target="_blank">BME280 sensor</a>
<a href="https://makeradvisor.com/tools/jumper-wires-kit-120-pieces/" target="_blank">Jumper wires</a>
<a href="https://makeradvisor.com/tools/mb-102-solderless-breadboard-830-points/" target="_blank">Breadboard</a>
You can use the preceding links or go directly to <a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank">MakerAdvisor.com/tools</a> to find all the parts for your projects at the best price!
<a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/header-200.png?w=828&quality=100&strip=all&ssl=1" data-recalc-dims="1" loading="lazy" fetchpriority="low"></a>
<h3>Schematics</h3>
The BME280 sensor module we're using communicates via I2C communication protocol, so you need to connect it to the ESP32 or ESP8266 I2C pins.
<h4>BME280 wiring to ESP32</h4>
The ESP32 I2C pins are:
<k>GPIO 22:</k> SCL (SCK)
<k>GPIO 21:</k> SDA (SDI)
So, assemble your circuit as shown in the next schematic diagram (<a href="https://randomnerdtutorials.com/esp32-bme280-arduino-ide-pressure-temperature-humidity/">Guide for ESP32 with BME280</a> and <a href="https://randomnerdtutorials.com/esp32-web-server-with-bme280-mini-weather-station/">ESP32 BME280 Web Server</a>).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2018/03/ESP32-bme280_bb.png">
<k>Recommended reading:</k> <a href="https://randomnerdtutorials.com/esp32-pinout-reference-gpios/">ESP32 Pinout Reference Guide</a>
<h4>BME280 wiring to ESP8266</h4>
The ESP8266 I2C pins are:
<k>GPIO 5 </k>(D1): SCL (SCK)
<k>GPIO 4 </k>(D2): SDA (SDI)
Assemble your circuit as in the next schematic diagram if you're using an ESP8266 board (<a href="https://randomnerdtutorials.com/esp8266-bme280-arduino-ide/">read Guide for ESP8266 with BME280</a>).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/06/ESP8266-BME280-Arduino-IDE.png">
<k>Recommended reading:</k> <a href="https://randomnerdtutorials.com/esp8266-pinout-reference-gpios/">ESP8266 Pinout Reference Guide</a> 
<h3>Installing Libraries</h3>
We'll program the ESP32/ESP8266 using Arduino IDE, so you must have the ESP add-on installed in your Arduino IDE. 
Follow one of the next tutorials depending on the board you're using:
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Install the ESP32 Board in Arduino IDE</a>  you also need to <a href="https://randomnerdtutorials.com/esp32-bme280-arduino-ide-pressure-temperature-humidity/">install the BME280 Library and Adafruit_Sensor library</a>
<a style="font-size: inherit; background-color: initial;" href="https://randomnerdtutorials.com/how-to-install-esp8266-board-arduino-ide/">Install the ESP8266 Board in Arduino IDE</a>  you also need to <a href="https://randomnerdtutorials.com/esp8266-bme280-arduino-ide/">install the BME280 Library and Adafruit_Sensor library</a> 
<h3>ESP32 Code</h3>
Follow this section if you're using an ESP32. For an ESP8266 click here.
After installing the necessary board add-ons, copy the following code to your Arduino IDE, but don't upload it yet. You need to make some changes to make it work for you.
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-esp8266-mysql-database-php/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
#include &lt;WiFi.h>
#include &lt;WiFiClientSecure.h>
#include &lt;HTTPClient.h>
#include &lt;Wire.h>
#include &lt;Adafruit_Sensor.h>
#include &lt;Adafruit_BME280.h>
// Replace with your network credentials
const char* ssid     = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
// REPLACE with your Domain name and URL path or IP address with path
const char* serverName = "https://example.com/esp-post-data.php";
// Keep this API Key value to be compatible with the PHP code provided in the project page. 
// If you change the apiKeyValue value, the PHP file /post-esp-data.php also needs to have the same key 
String apiKeyValue = "tPmAT5Ab3j7F9";
String sensorName = "BME280";
String sensorLocation = "Office";
/*#include &lt;SPI.h>
#define BME_SCK 18
#define BME_MISO 19
#define BME_MOSI 23
#define BME_CS 5*/
#define SEALEVELPRESSURE_HPA (1013.25)
Adafruit_BME280 bme;  // I2C
//Adafruit_BME280 bme(BME_CS);  // hardware SPI
//Adafruit_BME280 bme(BME_CS, BME_MOSI, BME_MISO, BME_SCK);  // software SPI
void setup() {
  Serial.begin(115200);
  
  WiFi.begin(ssid, password);
  Serial.println("Connecting");
  while(WiFi.status() != WL_CONNECTED) { 
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.print("Connected to WiFi network with IP Address: ");
  Serial.println(WiFi.localIP());
  // (you can also pass in a Wire library object like &Wire2)
  bool status = bme.begin(0x76);
  if (!status) {
    Serial.println("Could not find a valid BME280 sensor, check wiring or change I2C address!");
    while (1);
  }
}
void loop() {
  //Check WiFi connection status
  if(WiFi.status()== WL_CONNECTED){
    WiFiClientSecure *client = new WiFiClientSecure;
    client->setInsecure(); //don't use SSL certificate
    HTTPClient https;
    
    // Your Domain name with URL path or IP address with path
    https.begin(*client, serverName);
    
    // Specify content-type header
    https.addHeader("Content-Type", "application/x-www-form-urlencoded");
    
    // Prepare your HTTP POST request data
    String httpRequestData = "api_key=" + apiKeyValue + "&sensor=" + sensorName
                          + "&location=" + sensorLocation + "&value1=" + String(bme.readTemperature())
                          + "&value2=" + String(bme.readHumidity()) + "&value3=" + String(bme.readPressure()/100.0F) + "";
    Serial.print("httpRequestData: ");
    Serial.println(httpRequestData);
    
    // You can comment the httpRequestData variable above
    // then, use the httpRequestData variable below (for testing purposes without the BME280 sensor)
    //String httpRequestData = "api_key=tPmAT5Ab3j7F9&sensor=BME280&location=Office&value1=24.75&value2=49.54&value3=1005.14";
    // Send HTTP POST request
    int httpResponseCode = https.POST(httpRequestData);
     
    // If you need an HTTP request with a content type: text/plain
    //https.addHeader("Content-Type", "text/plain");
    //int httpResponseCode = https.POST("Hello, World!");
    
    // If you need an HTTP request with a content type: application/json, use the following:
    //https.addHeader("Content-Type", "application/json");
    //int httpResponseCode = https.POST("{\"value1\":\"19\",\"value2\":\"67\",\"value3\":\"78\"}");
    
    if (httpResponseCode>0) {
      Serial.print("HTTP Response code: ");
      Serial.println(httpResponseCode);
    }
    else {
      Serial.print("Error code: ");
      Serial.println(httpResponseCode);
    }
    // Free resources
    https.end();
  }
  else {
    Serial.println("WiFi Disconnected");
  }
  //Send an HTTP POST request every 30 seconds
  delay(30000);  
}
</k>
<a href="https://github.com/RuiSantosdotme/Cloud-Weather-Station-ESP32-ESP8266/raw/master/code/HTTPS_ESP32_Cloud_Weather_Station.ino" target="_blank">View raw code</a>
<h4>Setting your network credentials</h4>
You need to modify the following lines with your network credentials: SSID and password. The code is well commented on where you should make the changes.
<k>// Replace with your network credentials
const char* ssid     = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
<h4>Setting your serverName</h4>
You also need to type your domain name, so the ESP publishes the readings to your own server.
<k>const char* serverName = "https://example.com/esp-post-data.php";</k>
Now, you can upload the code to your board.
<k>Note: </k>Most servers require you to make HTTPS requests. The code above makes HTTPS requests to be compliant with the requirements of most cloud servers nowadays.
Your server doesn't support HTTPS? <a href="https://github.com/RuiSantosdotme/Cloud-Weather-Station-ESP32-ESP8266/blob/master/code/ESP_HTTP_POST_MySQL.ino" target="_blank" rel="noopener" title="">Use this code instead</a>.
<h4>How the code works</h4>
This project is already quite long, so we won't cover in detail how the code works, but here's a quick summary:
Import all the libraries to make it work;
Set variables that you might want to change (apiKeyValue, sensorName, sensorLocation);
The apiKeyValue is just a random string that you can modify. It's used for security reasons, so only anyone that knows your API key can publish data to your database;
Initialize the serial communication for debugging purposes;
Establish a Wi-Fi connection with your router;
Initialize the BME280 to get readings;
Initialize a secure WiFi client.
Then, in the loop() is where you actually make the HTTP POST request every 10 minutes with the latest BME280 readings:
<k>// Your Domain name with URL path or IP address with path
http.begin(serverName);
// Specify content-type header
http.addHeader("Content-Type", "application/x-www-form-urlencoded");
// Prepare your HTTP POST request data
String httpRequestData = "api_key=" + apiKeyValue + "&sensor=" + sensorName                      + "&location=" + sensorLocation + "&value1=" + String(bme.readTemperature())                      + "&value2=" + String(bme.readHumidity()) + "&value3=" + String(bme.readPressure()/100.0F) + "";
int httpResponseCode = http.POST(httpRequestData);</k>
You can comment the httpRequestData variable above that concatenates all the BME280 readings and use the httpRequestData variable below for testing purposes:
<k>String httpRequestData = "api_key=tPmAT5Ab3j7F9&sensor=BME280&location=Office&value1=24.75&value2=49.54&value3=1005.14";</k>
Learn more about HTTPS Requests with the ESP32: <a href="https://randomnerdtutorials.com/esp32-https-requests/">ESP32 HTTPS Requests (Arduino IDE)</a>.
<h3>ESP8266 Code</h3>
Follow this section if you're using an ESP8266. For an ESP32 check the section above.
After installing the necessary board add-ons and libraries, copy the following code to your Arduino IDE, but don't upload it yet. You need to make some changes to make it work for you.
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-esp8266-mysql-database-php/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
#include &lt;ESP8266WiFi.h>
#include &lt;ESP8266HTTPClient.h>
#include &lt;WiFiClientSecureBearSSL.h>
#include &lt;Wire.h>
#include &lt;Adafruit_Sensor.h>
#include &lt;Adafruit_BME280.h>
// Replace with your network credentials
const char* ssid     = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
// REPLACE with your Domain name and URL path or IP address with path
const char* serverName = "https://example.com/esp-post-data.php";
// Keep this API Key value to be compatible with the PHP code provided in the project page. 
// If you change the apiKeyValue value, the PHP file /post-esp-data.php also needs to have the same key 
String apiKeyValue = "tPmAT5Ab3j7F9";
String sensorName = "BME280";
String sensorLocation = "Office";
/*#include &lt;SPI.h>
#define BME_SCK 18
#define BME_MISO 19
#define BME_MOSI 23
#define BME_CS 5*/
#define SEALEVELPRESSURE_HPA (1013.25)
Adafruit_BME280 bme;  // I2C
//Adafruit_BME280 bme(BME_CS);  // hardware SPI
//Adafruit_BME280 bme(BME_CS, BME_MOSI, BME_MISO, BME_SCK);  // software SPI
void setup() {
  Serial.begin(115200);
  
  WiFi.begin(ssid, password);
  Serial.println("Connecting");
  while(WiFi.status() != WL_CONNECTED) { 
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.print("Connected to WiFi network with IP Address: ");
  Serial.println(WiFi.localIP());
  // (you can also pass in a Wire library object like &Wire2)
  bool status = bme.begin(0x76);
  if (!status) {
    Serial.println("Could not find a valid BME280 sensor, check wiring or change I2C address!");
    while (1);
  }
}
void loop() {
  //Check WiFi connection status
  if(WiFi.status()== WL_CONNECTED){
    std::unique_ptr&lt;BearSSL::WiFiClientSecure>client(new BearSSL::WiFiClientSecure);
    // Ignore SSL certificate validation
    client->setInsecure();
    
    //create an HTTPClient instance
    HTTPClient https;
    
    // Your Domain name with URL path or IP address with path
    https.begin(*client, serverName);
    
    // Specify content-type header
    https.addHeader("Content-Type", "application/x-www-form-urlencoded");
    
    // Prepare your HTTP POST request data
    String httpRequestData = "api_key=" + apiKeyValue + "&sensor=" + sensorName
                          + "&location=" + sensorLocation + "&value1=" + String(bme.readTemperature())
                          + "&value2=" + String(bme.readHumidity()) + "&value3=" + String(bme.readPressure()/100.0F) + "";
    Serial.print("httpRequestData: ");
    Serial.println(httpRequestData);
    
    // You can comment the httpRequestData variable above
    // then, use the httpRequestData variable below (for testing purposes without the BME280 sensor)
    //String httpRequestData = "api_key=tPmAT5Ab3j7F9&sensor=BME280&location=Office&value1=24.75&value2=49.54&value3=1005.14";
    // Send HTTP POST request
    int httpResponseCode = https.POST(httpRequestData);
     
    // If you need an HTTP request with a content type: text/plain
    //http.addHeader("Content-Type", "text/plain");
    //int httpResponseCode = https.POST("Hello, World!");
    
    // If you need an HTTP request with a content type: application/json, use the following:
    //http.addHeader("Content-Type", "application/json");
    //int httpResponseCode = https.POST("{\"value1\":\"19\",\"value2\":\"67\",\"value3\":\"78\"}");
        
    if (httpResponseCode>0) {
      Serial.print("HTTP Response code: ");
      Serial.println(httpResponseCode);
    }
    else {
      Serial.print("Error code: ");
      Serial.println(httpResponseCode);
    }
    // Free resources
    https.end();
  }
  else {
    Serial.println("WiFi Disconnected");
  }
  //Send an HTTP POST request every 30 seconds
  delay(30000);  
}
</k>
<a href="https://github.com/RuiSantosdotme/Cloud-Weather-Station-ESP32-ESP8266/raw/master/code/HTTPS_ESP8266_Cloud_Weather_Station.ino" target="_blank">View raw code</a>
<h4>Setting your network credentials</h4>
You need to modify the following lines with your network credentials: SSID and password. The code is well commented on where you should make the changes.
<k>// Replace with your network credentials
const char* ssid     = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
<h4>Setting your serverName</h4>
You also need to type your domain name, so the ESP publishes the readings to your own server.
<k>const char* serverName = "https://example.com/esp-post-data.php";</k>
Now, you can upload the code to your board.
<k>Note: </k>Most servers require you to make HTTPS requests. The code above makes HTTPS requests to be compliant with the requirements of most cloud servers nowadays.
Your server doesn't support HTTPS? <a href="https://github.com/RuiSantosdotme/Cloud-Weather-Station-ESP32-ESP8266/blob/master/code/ESP_HTTP_POST_MySQL.ino" target="_blank" rel="noopener" title="">Use this code instead</a>.
Learn more about HTTPS Requests with the ESP8266: <a href="https://randomnerdtutorials.com/esp8266-nodemcu-https-requests/">ESP8266 NodeMCU HTTPS Requests (Arduino IDE)</a>.
<h3>Demonstration</h3>
After completing all the steps, let your ESP board collect some readings and publish them to your server. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/06/ESP32-BME280-Arduino-IDE-MySQL.jpg">
If everything is correct, this is what you should see in your Arduino IDE Serial Monitor:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/Arduino-IDE-Serial-Monitor-ESP32-ESP8266-Weather-Station.png">
If you open your domain name in this URL path:
<k>https://example.com/esp-weather-station.php</k>
You should see the latest 20 readings stored in your database. There are two gauges that show the latest temperature and humidity readings, and a timestamp.
Refresh the web page to see the latest readings:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/cloud-weather-station-esp32-esp8266.png">
There's a field where you can type the number of readings to visualize, as well as the number of readings for these statistics: minimum, maximum, and average. By default, it's set to 20. For example, if you type 30 and press the update button, you'll see that your web page updates and recalculates all the values.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/input-field-esp32-esp8266-weather-station.png">
The web page is also mobile responsive, so you can use any device to access it:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/ESP32-ESP8266-Weather-Station-Data-Example-Temperature-Humidity-Gauges-mobile-responsive-smartphone.jpg">
You can also go to phpMyAdmin to manage the data stored in your SensorData table. You can delete it, edit, etc
<a href="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/06/esp8266-mysql-database-phpmyadmin-arduino-demonstration.png?quality=100&strip=all&ssl=1"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/06/esp8266-mysql-database-phpmyadmin-arduino-demonstration.png"></a>
<h3>Wrapping Up</h3>
In this tutorial you've learned how to publish sensor data into a database in your own server domain that you can access from anywhere in the world. This requires that you have your own <a aria-label="server and domain name (opens in a new tab)" href="https://randomnerdtutorials.com/bluehost" target="_blank">server and domain name</a> (alternatively, you can use a <a href="https://randomnerdtutorials.com/esp32-esp8266-raspberry-pi-lamp-server/">Raspberry Pi LAMP Server for local access</a>).
I encourage you to change the web page appearance, add more features (<a href="https://randomnerdtutorials.com/esp32-esp8266-send-email-notification/">like email notifications</a>), publish data from different sensors, use multiple ESP boards, and much more.

<h2>Send Email Notification using PHP Script</h2>
In this project, you'll build an ESP32 or ESP8266 client that makes an HTTP POST request to a PHP script to send an email notification with sensor readings.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/10/Send-Email-ESP32-ESP8266-PHP-Script.png">
<em>Updated on 27 March 2023</em>
You can also set a threshold value, so your email notification is only sent if the temperature/humidity/pressure is above a certain value.
As an example, we'll be using a BME280 sensor connected to an ESP32 or ESP8266 board. You can modify the code provided to send readings from a different sensor or even use multiple boards.
This is a great way to send email notifications using the ESP32 or ESP8266 without relying on IFTTT or an SMTP server.
In order to build this project, you will:
<ol>
Host a server and setup a domain name
Create PHP script to send email notifications
Program ESP32 or ESP8266 with Arduino IDE
</ol>
This project is also a great addition to build upon our previous projects:
<a href="https://randomnerdtutorials.com/esp32-esp8266-mysql-database-php/">ESP32/ESP8266 Insert Data into MySQL Database using PHP and Arduino IDE</a>
<a href="https://randomnerdtutorials.com/visualize-esp32-esp8266-sensor-readings-from-anywhere/">Visualize Your Sensor Readings from Anywhere in the World</a>
<h3>1. Hosting Your PHP Application</h3>
The goal of this project is to have your own domain name and hosting account that allows you to send email notifications (without using an SMTP server, IFTTT, etc). 
Here's a high-level overview of how the project works:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/10/ESP32-ESP8266-send-email-notification-with-sensor-readings-overview.png">
I recommend using one of the following hosting services that can handle all the project requirements:
<a aria-label=" (opens in a new tab)" href="https://randomnerdtutorials.com/bluehost" target="_blank">Bluehost (user-friendly with cPanel)</a>: free domain name when you sign up for the 3-year plan. I recommend choosing the unlimited websites option;
<a aria-label=" (opens in a new tab)" style="font-size: inherit; background-color: initial;" href="https://randomnerdtutorials.com/digitalocean" target="_blank">Digital Ocean</a>: Linux server that you manage through a command line. I only recommended this option for advanced users.
Those two services are the ones that I use and personally recommend, but you can use any other hosting service. Any hosting service that offers PHP and MySQL will work with this tutorial. If you don't have a hosting account, I recommend <a href="https://randomnerdtutorials.com/bluehost">signing up for Bluehost</a>.
<a href="https://randomnerdtutorials.com/bluehost" target="_blank" rel="noopener noreferrer">Get Hosting and Domain Name with Bluehost <U+00BB></a>
When buying a hosting account, you'll also have to purchase a domain name. If you like our projects, you might consider signing up for one of the recommended hosting services, because you'll be supporting our work.
<k>Note: </k> you can also run a <a href="https://randomnerdtutorials.com/raspberry-pi-apache-mysql-php-lamp-server/">LAMP (Linux, Apache, MySQL, PHP) server</a> on a Raspberry Pi, but it can't send emails standalone. To send an email with a Raspberry Pi using PHP, you need to use an SMTP (Simple Mail Transfer Protocol) server.
<h3>2. PHP Script HTTP  Send Email Notification</h3>
After signing up for a <a aria-label="hosting and setting up a domain name (opens in a new tab)" href="https://randomnerdtutorials.com/bluehost" target="_blank">hosting account and setting up a domain name</a>, you can login to your cPanel or similar dashboard.
After that, follow the next steps to create a PHP script that is responsible for receiving incoming requests from the ESP32/ESP8266 and sending an email. 
If you're using a hosting provider with cPanel, go to Advanced and search for <k>File Manager</k>:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/10/cpanel-bluehost-file-manager.jpg">
Then, select the <k>public_html</k> option and press the <k>+ File</k> button to create a new <em>.php</em> file.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/06/ESP32-ESP8266-CPanel-Create-New-PHP-File.png">
<k>Note: </k> if you're following this tutorial and you're not familiar with PHP, I recommend creating that exact file. Otherwise, you'll need to modify the ESP sketch provided with a different URL path. 
Create a new file in <k>/public_html</k> with this exact name and extension: <em>email-notification.php</em>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/10/email-notification-php-file-new-created.png">
Edit the newly created file (<em>email-notification.php</em>) and copy the following script:
<k>&lt;?php
/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-esp8266-send-email-notification/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
// Receiver Email Address (where to send email notification)
$email_address = "<a href="/cdn-cgi/l/email-protection" data-cfemail="0a53657f784f676b63664b6e6e786f79794a6f726b677a666f24696567">[email protected]</a>";
// Keep this API Key value to be compatible with the ESP code provided in the project page. If you change this value, the ESP sketch needs to match
$api_key_value = "tPmAT5Ab3j7F9";
$api_key = $value1 = $value2 = $value3 = "";
if ($_SERVER["REQUEST_METHOD"] == "POST") {
    $api_key = test_input($_POST["api_key"]);
    if($api_key == $api_key_value) {
        $value1 = test_input($_POST["value1"]);
        $value2 = test_input($_POST["value2"]);
        $value3 = test_input($_POST["value3"]);
        
        // Email message
        $email_msg = "Temperature: " . $value1 . "oC\nHumidity: " . $value2 . "%\nPressure: " . $value3 . "hPa";
        
        // Use wordwrap() if lines are longer than 70 characters
        $email_msg = wordwrap($email_msg, 70);
        
        // Uncomment the next if statement to set a threshold 
        // ($value1 = temperature, $value2 = humidity, $value3 = pressure)
        /*if($value1 &lt; 24.0){
            echo "Temperature below threshold, don't send email";
            exit;
        }*/
        
        // send email with mail(receiver email address, email subject, email message)
        mail($email_address, "[NEW] ESP BME280 Readings", $email_msg);
        
        echo "Email sent";
    }
    else {
        echo "Wrong API Key provided.";
    }
}
else {
    echo "No data posted with HTTP POST.";
}
function test_input($data) {
    $data = trim($data);
    $data = stripslashes($data);
    $data = htmlspecialchars($data);
    return $data;
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP/ESP_Send_Email/email-notification.php" target="_blank">View raw code</a>
Before saving the file, you need to modify the $email_address variable with the receiver email address:
<k>// Receiver Email Address (where to send email notification)
$email_address = "<a href="/cdn-cgi/l/email-protection" data-cfemail="326b5d4740775f535b5e7356564057414172574a535f425e571c515d5f">[email protected]</a>";</k>
After adding the receiver email, save the file and continue with this tutorial. If you try to access your domain name in the next URL path, you'll see the following:
<k>https://example.com/email-notification.php</k>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/10/ESP32-ESP8266-Send-Email-PHP-Script-Test.png">
If you see that message, it means that everything is being setup properly. You can continue with this project.
<h3>3. Setting Up Your ESP32 or ESP8266</h3>
This project is compatible with both the ESP32 and ESP8266 boards. You just need to assemble a simple circuit and upload the sketch provided to publish temperature, humidity, and pressure readings to your PHP script, which will then be responsible to handle email notifications. The sketch is slightly different for each board.
<h3>Parts Required</h3>
For this example, we'll get sensor readings from the BME280 sensor. Here's a list of parts you need to build the circuit for this project:
<a aria-label=" (opens in a new tab)" href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32 board</a> (read <a href="https://makeradvisor.com/esp32-development-boards-review-comparison/" target="_blank">Best ESP32 dev boards</a>)
Alternative  <a href="https://makeradvisor.com/tools/esp8266-esp-12e-nodemcu-wi-fi-development-board/" target="_blank">ESP8266</a> board (read <a href="https://makeradvisor.com/best-esp8266-wi-fi-development-board/" target="_blank">Best ESP8266 dev boards</a>)
<a href="https://makeradvisor.com/tools/bme280-sensor-module/" target="_blank">BME280 sensor</a>
<a href="https://makeradvisor.com/tools/jumper-wires-kit-120-pieces/" target="_blank">Jumper wires</a>
<a href="https://makeradvisor.com/tools/mb-102-solderless-breadboard-830-points/" target="_blank">Breadboard</a>
You can use the preceding links or go directly to <a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank">MakerAdvisor.com/tools</a> to find all the parts for your projects at the best price!
<a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/header-200.png?w=828&quality=100&strip=all&ssl=1" data-recalc-dims="1" loading="lazy" fetchpriority="low"></a>
<h3>Schematics</h3>
The BME280 sensor module we're using communicates via I2C communication protocol, so you need to connect it to the ESP32 or ESP8266 I2C pins.
<h4>BME280 wiring to ESP32</h4>
<table><tbody>
<tr>
<td><k>BME280</k></td>
<td><k>ESP32</k></td>
</tr>
<tr>
<td>SCK (SCL Pin)</td>
<td> GPIO 22
</td>
</tr>
<tr>
<td>SDI (SDA pin) </td>
<td> GPIO 21
</td>
</tr>
</tbody></table>So, assemble your circuit as shown in the next schematic diagram (<a href="https://randomnerdtutorials.com/esp32-bme280-arduino-ide-pressure-temperature-humidity/">read the complete Guide for ESP32 with BME280</a>).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2018/03/ESP32-bme280_bb.png">
<k>Recommended reading:</k> <a href="https://randomnerdtutorials.com/esp32-pinout-reference-gpios/">ESP32 Pinout Reference Guide</a>
<h4>BME280 wiring to ESP8266</h4>
<table><tbody>
<tr>
<td><k>BME280</k></td>
<td><k>ESP8266</k></td>
</tr>
<tr>
<td>SCK (SCL Pin)</td>
<td> GPIO 5
</td>
</tr>
<tr>
<td>SDI (SDA pin) </td>
<td> GPIO 4
</td>
</tr>
</tbody></table>Assemble your circuit as in the next schematic diagram if you're using an ESP8266 board (<a href="https://randomnerdtutorials.com/esp8266-bme280-arduino-ide/">read the complete Guide for ESP8266 with BME280</a>).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/06/ESP8266-BME280-Arduino-IDE.png">
<k>Recommended reading:</k> <a href="https://randomnerdtutorials.com/esp8266-pinout-reference-gpios/">ESP8266 Pinout Reference Guide</a> 
<h3>Installing Libraries</h3>
We'll program the ESP32/ESP8266 using Arduino IDE, so you must have the ESP32/ESP8266 add-on installed in your Arduino IDE. Follow one of the next tutorials depending on the board you're using:
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Install the ESP32 Board in Arduino IDE</a>  you also need to <a href="https://randomnerdtutorials.com/esp32-bme280-arduino-ide-pressure-temperature-humidity/">install the BME280 Library </a>and <a aria-label=" (opens in a new tab)" href="https://github.com/adafruit/Adafruit_Sensor" target="_blank">Adafruit_Sensor library</a>
<a style="font-size: inherit; background-color: initial;" href="https://randomnerdtutorials.com/how-to-install-esp8266-board-arduino-ide/">Install the ESP8266 Board in Arduino IDE</a>  you also need to <a href="https://randomnerdtutorials.com/esp8266-bme280-arduino-ide/">install the BME280 Library </a>and <a href="https://github.com/adafruit/Adafruit_Sensor">Adafruit_Sensor library</a> 
<h3>ESP32 Code</h3>
Follow this section if you're using an ESP32. For an ESP8266 click here.
After installing the necessary board add-ons, copy the following code to your Arduino IDE, but don't upload it yet. You need to make some changes to make it work for you.
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-esp8266-send-email-notification/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
#include &lt;WiFi.h>
#include &lt;WiFiClientSecure.h>
#include &lt;HTTPClient.h>
#include &lt;Wire.h>
#include &lt;Adafruit_Sensor.h>
#include &lt;Adafruit_BME280.h>
// Replace with your network credentials
const char* ssid     = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
// REPLACE with your Domain name and URL path or IP address with path
const char* serverName = "https://example.com/email-notification.php";
// Keep this API Key value to be compatible with the PHP code provided in the project page. 
// If you change the apiKeyValue value, the PHP file /email-notification.php also needs to have the same key 
String apiKeyValue = "tPmAT5Ab3j7F9";
/*#include &lt;SPI.h>
#define BME_SCK 18
#define BME_MISO 19
#define BME_MOSI 23
#define BME_CS 5*/
#define SEALEVELPRESSURE_HPA (1013.25)
Adafruit_BME280 bme;  // I2C
//Adafruit_BME280 bme(BME_CS);  // hardware SPI
//Adafruit_BME280 bme(BME_CS, BME_MOSI, BME_MISO, BME_SCK);  // software SPI
void setup() {
  Serial.begin(115200);
  
  WiFi.begin(ssid, password);
  Serial.println("Connecting");
  while(WiFi.status() != WL_CONNECTED) { 
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.print("Connected to WiFi network with IP Address: ");
  Serial.println(WiFi.localIP());
  // (you can also pass in a Wire library object like &Wire2)
  bool status = bme.begin(0x76);
  if (!status) {
    Serial.println("Could not find a valid BME280 sensor, check wiring or change I2C address!");
    while (1);
  }
  //Check WiFi connection status
  if(WiFi.status()== WL_CONNECTED){
    WiFiClientSecure *client = new WiFiClientSecure;
    client->setInsecure(); //don't use SSL certificate
    HTTPClient https;
    
    // Your Domain name with URL path or IP address with path
    https.begin(*client, serverName);
    
    // Specify content-type header
    https.addHeader("Content-Type", "application/x-www-form-urlencoded");
    
    // Prepare your HTTP POST request data
    String httpRequestData = "api_key=" + apiKeyValue + "&value1=" + String(bme.readTemperature())
                           + "&value2=" + String(bme.readHumidity()) + "&value3=" + String(bme.readPressure()/100.0F) + "";
   
    Serial.print("httpRequestData: ");
    Serial.println(httpRequestData);
    
    // You can comment the httpRequestData variable above
    // then, use the httpRequestData variable below (for testing purposes without the BME280 sensor)
    //String httpRequestData = "api_key=tPmAT5Ab3j7F9&sensor=BME280&location=Office&value1=24.75&value2=49.54&value3=1005.14";
    // Send HTTP POST request
    int httpResponseCode = https.POST(httpRequestData);
     
    // If you need an HTTP request with a content type: text/plain
    //https.addHeader("Content-Type", "text/plain");
    //int httpResponseCode = https.POST("Hello, World!");
    
    // If you need an HTTP request with a content type: application/json, use the following:
    //https.addHeader("Content-Type", "application/json");
    //int httpResponseCode = https.POST("{\"value1\":\"19\",\"value2\":\"67\",\"value3\":\"78\"}");
    
    if (httpResponseCode>0) {
      Serial.print("HTTP Response code: ");
      Serial.println(httpResponseCode);
    }
    else {
      Serial.print("Error code: ");
      Serial.println(httpResponseCode);
    }
    // Free resources
    https.end();
  }
  else {
    Serial.println("WiFi Disconnected");
  } 
  // Use deep sleep to make the ESP send an email every X number of minutes/hours with low power consumption
  // ESP32 Deep Sleep Guide: https://RandomNerdTutorials.com/esp32-deep-sleep-arduino-ide-wake-up-sources/  
}
void loop() {
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/HTTPS_ESP32_Send_Email_PHP.ino" target="_blank">View raw code</a>
<h4>Setting your network credentials</h4>
You need to modify the following lines with your network credentials: SSID and password. The code is well commented on where you should make the changes.
<k>// Replace with your network credentials
const char* ssid     = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
<h4>Setting your serverName</h4>
You also need to type your domain name, so the ESP publishes the readings to your own server.
<k>const char* serverName = "https://example.com/email-notification.php";</k>
Now, you can upload the code to your board.
<k>Note: </k>Most servers require you to make HTTPS requests. The code above makes HTTPS requests to be compliant with the requirements of most cloud servers nowadays.
Your server doesn't support HTTPS? <a href="https://raw.githubusercontent.com/RuiSantosdotme/Random-Nerd-Tutorials/master/Projects/ESP/ESP_Send_Email/ESP_Send_Email.ino" target="_blank" rel="noopener" title="">Use this code instead</a>.
<h4>How the code works</h4>
Here's a quick summary of how the code works:
Import all the libraries to make it work (it will import either the ESP32 or ESP8266 libraries based on the selected board in your Arduino IDE);
Set variables that you might want to change (apiKeyValue);
The apiKeyValue is just a random string that you can modify. It's used for security reasons, so only anyone that knows your API key can send email notifications.
Initialize the serial communication for debugging purposes;
Establish a Wi-Fi connection with your router;
Initialize the BME280 sensor to get temperature, humidity, and pressure readings;
Initialize a secure WiFi client.
Then, in the rest of the setup() is where you actually make the HTTP POST with the latest BME280 readings:
<k>// Your Domain name with URL path or IP address with path
http.begin(client, serverName);
// Specify content-type header
http.addHeader("Content-Type", "application/x-www-form-urlencoded");
// Prepare your HTTP POST request data
String httpRequestData = "api_key=" + apiKeyValue + "&value1=" + String(bme.readTemperature())
                       + "&value2=" + String(bme.readHumidity()) + "&value3=" + String(bme.readPressure()/100.0F) + "";
int httpResponseCode = http.POST(httpRequestData);</k>
You can comment the httpRequestData variable above that concatenates all the BME280 readings and use the httpRequestData variable below for testing purposes:
<k>String httpRequestData = "api_key=tPmAT5Ab3j7F9&value1=24.75&value2=49.54&value3=1005.14";</k>
Learn more about HTTPS Requests with the ESP32: <a href="https://randomnerdtutorials.com/esp32-https-requests/">ESP32 HTTPS Requests (Arduino IDE)</a>.
<h3>ESP8266 Code</h3>
Follow this section if you're using an ESP8266. For an ESP32 check the section above.
After installing the necessary board add-ons, copy the following code to your Arduino IDE, but don't upload it yet. You need to make some changes to make it work for you.
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-esp8266-send-email-notification/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
#include &lt;ESP8266WiFi.h>
#include &lt;ESP8266HTTPClient.h>
#include &lt;WiFiClientSecureBearSSL.h>
#include &lt;Wire.h>
#include &lt;Adafruit_Sensor.h>
#include &lt;Adafruit_BME280.h>
// Replace with your network credentials
const char* ssid     = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
// REPLACE with your Domain name and URL path or IP address with path
const char* serverName = "https://example.com/email-notification.php";
// Keep this API Key value to be compatible with the PHP code provided in the project page. 
// If you change the apiKeyValue value, the PHP file /email-notification.php also needs to have the same key 
String apiKeyValue = "tPmAT5Ab3j7F9";
/*#include &lt;SPI.h>
#define BME_SCK 18
#define BME_MISO 19
#define BME_MOSI 23
#define BME_CS 5*/
#define SEALEVELPRESSURE_HPA (1013.25)
Adafruit_BME280 bme;  // I2C
//Adafruit_BME280 bme(BME_CS);  // hardware SPI
//Adafruit_BME280 bme(BME_CS, BME_MOSI, BME_MISO, BME_SCK);  // software SPI
void setup() {
  Serial.begin(115200);
  
  WiFi.begin(ssid, password);
  Serial.println("Connecting");
  while(WiFi.status() != WL_CONNECTED) { 
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.print("Connected to WiFi network with IP Address: ");
  Serial.println(WiFi.localIP());
  // (you can also pass in a Wire library object like &Wire2)
  bool status = bme.begin(0x76);
  if (!status) {
    Serial.println("Could not find a valid BME280 sensor, check wiring or change I2C address!");
    while (1);
  }
  //Check WiFi connection status
  if(WiFi.status()== WL_CONNECTED){
    std::unique_ptr&lt;BearSSL::WiFiClientSecure>client(new BearSSL::WiFiClientSecure);
    // Ignore SSL certificate validation
    client->setInsecure();
    
    //create an HTTPClient instance
    HTTPClient https;
    
    // Your Domain name with URL path or IP address with path
    https.begin(*client, serverName);
    
    // Specify content-type header
    https.addHeader("Content-Type", "application/x-www-form-urlencoded");
    
    // Prepare your HTTP POST request data
    String httpRequestData = "api_key=" + apiKeyValue + "&value1=" + String(bme.readTemperature())
                           + "&value2=" + String(bme.readHumidity()) + "&value3=" + String(bme.readPressure()/100.0F) + "";
    Serial.print("httpRequestData: ");
    Serial.println(httpRequestData);
    
    // You can comment the httpRequestData variable above
    // then, use the httpRequestData variable below (for testing purposes without the BME280 sensor)
    //String httpRequestData = "api_key=tPmAT5Ab3j7F9&sensor=BME280&location=Office&value1=24.75&value2=49.54&value3=1005.14";
    // Send HTTP POST request
    int httpResponseCode = https.POST(httpRequestData);
     
    // If you need an HTTP request with a content type: text/plain
    //http.addHeader("Content-Type", "text/plain");
    //int httpResponseCode = https.POST("Hello, World!");
    
    // If you need an HTTP request with a content type: application/json, use the following:
    //http.addHeader("Content-Type", "application/json");
    //int httpResponseCode = https.POST("{\"value1\":\"19\",\"value2\":\"67\",\"value3\":\"78\"}");
        
    if (httpResponseCode>0) {
      Serial.print("HTTP Response code: ");
      Serial.println(httpResponseCode);
    }
    else {
      Serial.print("Error code: ");
      Serial.println(httpResponseCode);
    }
    // Free resources
    https.end();
  }
  else {
    Serial.println("WiFi Disconnected");
  }
  // Use deep sleep to make the ESP send an email every X number of minutes/hours with low power consumption
  // ESP8266 Deep Sleep Guide: https://RandomNerdTutorials.com/esp8266-deep-sleep-with-arduino-ide/
}
void loop() {
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP8266/HTTPS_ESP8266_Send_Email_PHP.ino" target="_blank">View raw code</a>
<h4>Setting your network credentials</h4>
You need to modify the following lines with your network credentials: SSID and password. The code is well commented on where you should make the changes.
<k>// Replace with your network credentials
const char* ssid     = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
<h4>Setting your serverName</h4>
You also need to type your domain name, so the ESP publishes the readings to your own server.
<k>const char* serverName = "https://example.com/email-notification.php";</k>
Now, you can upload the code to your board.
<k>Note: </k>Most servers require you to make HTTPS requests. The code above makes HTTPS requests to be compliant with the requirements of most cloud servers nowadays.
Your server doesn't support HTTPS? <a href="https://raw.githubusercontent.com/RuiSantosdotme/Random-Nerd-Tutorials/master/Projects/ESP/ESP_Send_Email/ESP_Send_Email.ino" target="_blank" rel="noopener" title="">Use this code instead</a>.
Learn more about HTTPS Requests with the ESP8266: <a href="https://randomnerdtutorials.com/esp8266-nodemcu-https-requests/">ESP8266 NodeMCU HTTPS Requests (Arduino IDE)</a>.
<h3>Demonstration</h3>
After completing all the steps, power your ESP board and let it make an HTTP request to your server:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/06/ESP32-BME280-Arduino-IDE-MySQL.jpg">
If everything is working properly, this is what you should see in your Arduino IDE Serial Monitor:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/10/ESP32-ESP8266-Send-Email-Arduino-IDE-Serial-Monitor.png">
Open your email client, you should have a new email with the subject <k>[NEW] ESP BME280 Readings</k> with the latest temperature readings:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/03/Sensor-Readings-Email-PHP-ESP32-ESP8266-f.png">
To send a new email, press the ESP on-board RESET/ENABLE button to restart it and new readings will be sent out via email.
For a final application, I recommend using deep sleep to make the ESP send an email every X number of minutes/hours with low power consumption. Read one of these guides to add deep sleep to your sketch:
<a href="https://randomnerdtutorials.com/esp32-deep-sleep-arduino-ide-wake-up-sources/">ESP32 Deep Sleep with Arduino IDE and Wake Up Sources</a>
<a href="https://randomnerdtutorials.com/esp8266-deep-sleep-with-arduino-ide/">ESP8266 Deep Sleep with Arduino IDE</a>
<h3>Enable Threshold Notification</h3>
Finally, keep in mind that every time you restart your ESP (or the ESP wakes from deep sleep), it will send a new email notification with the current values. It might be useful to set a threshold value so that you only receive an email notification when your readings are above or below the threshold.
In your PHP script (<em>email-notification.php</em>), uncomment the following if statement:
<k>// Uncomment the next if statement to set a threshold 
// ($value1 = temperature, $value2 = humidity, $value3 = pressure)
/*if($value1 &lt; 24.0){
    echo "Temperature below threshold, don't send email";
    exit;
}*/</k>
It will look like this:
<k>// Uncomment the next if statement to set a threshold 
// ($value1 = temperature, $value2 = humidity, $value3 = pressure)
if($value1 &lt; 24.0){
    echo "Temperature below threshold, don't send email";
    exit;
}</k>
You can modify that if statement with the value threshold and only send an email based on that condition. With the current code, it will only send an email notification when the temperature is above 24.0oC.
<h3>Wrapping Up</h3>
In this tutorial you've learned how to send emails with the ESP32 and ESP8266 using your own <a aria-label="server and domain name (opens in a new tab)" href="https://randomnerdtutorials.com/bluehost" target="_blank">server and domain name</a>. 
The example provided is as simple as possible so that you can understand how everything works. After understanding this example, you may change the email content, publish different sensor readings, use multiple ESP boards, and much more.
<h2>Visualize Your Sensor Readings from Anywhere in the World (ESP32/ESP8266 + MySQL + PHP)</h2>
In this project, you'll create a web page that displays sensor readings in a plot that you can access from anywhere in the world. In summary, you'll build an ESP32 or ESP8266 client that makes a request to a PHP script to publish sensor readings in a MySQL database. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/08/ESP32-ESP8266-Sensor-Readings-from-Anywhere-MySQL-Database-PHP.jpg"><em>Updated on 26 March 2023</em>
As an example, we'll be using a BME280 sensor connected to an ESP board. You can modify the code provided to send readings from a different sensor or use multiple boards.
To create this project, you'll use these technologies:
ESP32 or ESP8266 programmed with Arduino IDE
Hosting server and domain name
PHP script to insert data into MySQL database and display it on a web page
MySQL database to store readings
PHP script to plot data from database in charts
You might also find helpful reading these projects:
<a href="https://randomnerdtutorials.com/esp32-esp8266-mysql-database-php/">ESP32/ESP8266 Insert Data into MySQL Database using PHP and Arduino IDE</a>
<a href="https://randomnerdtutorials.com/esp32-esp8266-plot-chart-web-server/">ESP32/ESP8266 Plot Sensor Readings in Real Time Charts  Web Server</a>
<k>Table of Contents</k>
The project is divided into the following main sections:
<ol>
Hosting Your PHP Application and MySQL Database
Preparing Your MySQL Database
PHP Script HTTP POST  Insert Data in MySQL Database
PHP Script  Visualize Database Content in a Chart
Setting up the ESP32 or ESP8266
</ol>
<h3>Watch the Video Demonstration</h3>
To see how the project works, you can watch the following video demonstration:

<h3>1. Hosting Your PHP Application and MySQL Database</h3>
The goal of this project is to have your own domain name and hosting account that allows you to store sensor readings from the ESP32 or ESP8266. You can visualize the readings from anywhere in the world by accessing your own server domain. Here's a high level overview of the project:
<a href="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/08/ESP32-MySQL-Charts-Project-Overview.png?quality=100&strip=all&ssl=1"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/08/ESP32-MySQL-Charts-Project-Overview.png"></a>
I recommend using one of the following hosting services that can handle all the project requirements:
<a aria-label=" (opens in a new tab)" href="https://randomnerdtutorials.com/bluehost" target="_blank">Bluehost (user-friendly with cPanel)</a>: free domain name when you sign up for the 3-year plan. I recommend choosing the unlimited websites option;
<a aria-label=" (opens in a new tab)" style="font-size: inherit; background-color: initial;" href="https://randomnerdtutorials.com/digitalocean" target="_blank">Digital Ocean</a>: Linux server that you manage through a command line. I only recommended this option for advanced users.
Those two services are the ones that I use and personally recommend, but you can use any other hosting service. Any hosting service that offers PHP and MySQL will work with this tutorial. If you don't have a hosting account, I recommend <a href="https://randomnerdtutorials.com/bluehost">signing up for Bluehost</a>.
<a href="https://randomnerdtutorials.com/bluehost" target="_blank" rel="noopener noreferrer">Get Hosting and Domain Name with Bluehost <U+00BB></a>
When buying a hosting account, you'll also have to purchase a domain name. This is what makes this project interesting: you'll be able to go your domain name (http://example.com) and see your ESP readings.
If you like our projects, you might consider signing up to one of the recommended hosting services, because you'll be supporting our work.
<k>Note: </k> you can also run a <a href="https://randomnerdtutorials.com/raspberry-pi-apache-mysql-php-lamp-server/">LAMP (Linux, Apache, MySQL, PHP) server</a> on a Raspberry Pi to <a href="https://randomnerdtutorials.com/esp32-esp8266-raspberry-pi-lamp-server/">access data in your local network</a>. However, the purpose of this tutorial is to publish readings in your own domain name that you can access from anywhere in the world. This allows you to easily access your ESP readings without relying on a third-party IoT platform.
<h3>2. Preparing Your MySQL Database</h3>
After signing up for a <a aria-label="hosting and setting up a domain name (opens in a new tab)" href="https://randomnerdtutorials.com/bluehost" target="_blank">hosting account and setting up a domain name</a>, you can login to your cPanel or similar dashboard. After that, follow the next steps to create your database, username, password and SQL table.
<h3>Creating a database and user</h3>
Open the <k>Advanced</k> tab:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/cpanel-bluehost-advanced-tab.jpg">
<k>1.</k> Type database in the search bar and select MySQL Database Wizard.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/08/A-CPanel-select-MySQL-database-wizard-to-create-db.png">
<k>2.</k> Enter your desired Database name. In my case, the database name is esp_data. Then, press the Next Step button:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/08/ESP32-ESP8266-CPanel-Create-MySQL-Database.png">
<k>Note: </k> later you'll have to use the database name with the prefix that your host gives you (my database prefix in the screenshot above is blurred). I'll refer to it as example_esp_data from now on.
<k>3.</k> Type your Database username and set a password. You must save all those details, because you'll need them later to establish a database connection with your PHP code.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/08/ESP32-ESP8266-CPanel-Create-MySQL-Database-User-Password.png">
That's it! Your new database and user were created successfully. Now, save all your details because you'll need them later:
<k>Database name</k>: example_esp_data
<k>Username</k>: example_esp_board
<k>Password</k>: your password
<h3>Creating a SQL table</h3>
After creating your database and user, go back to cPanel dashboard and search for phpMyAdmin.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/08/ESP32-ESP8266-CPanel-Open-PHPMyAdmin.png">
In the left sidebar, select your database name example_esp_data and open the SQL tab. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/08/ESP32-ESP8266-PHPMyAdmin-Open-Database.png">
<k>Important: </k> make sure you've opened the example_esp_data database. Then, click the SQL tab. If you don't follow these exact steps and run the SQL query, you might create a table in the wrong database.
Copy the SQL query in the following snippet:
<k>CREATE TABLE Sensor (
    id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    value1 VARCHAR(10),
    value2 VARCHAR(10),
    value3 VARCHAR(10),
    reading_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
)
</k>
<a href="https://github.com/RuiSantosdotme/Visualize-ESP32-ESP8266-Readings-Anywhere/raw/master/code/Sensor_Table.sql" target="_blank">View raw code</a>
Paste it in the SQL query field (highlighted with a red rectangle) and press the Go button to create your table:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/08/ESP32-ESP8266-PHPMyAdmin-Create-SQL-Table.png">
After that, you should see your newly created table called Sensor in the example_esp_data database as shown in the figure below:
<a href="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/06/ESP32-ESP8266-PHPMyAdmin-View-SQL-Database.png?quality=100&strip=all&ssl=1"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/08/ESP32-ESP8266-PHPMyAdmin-View-SQL-Database.png"></a>
<h3>3. PHP Script HTTP POST  Insert Data in MySQL Database</h3>
In this section, we're going to create a PHP script that receives incoming requests from the ESP32 or ESP8266 and inserts the data into a MySQL database.
If you're using a hosting provider with cPanel, you can search for File Manager:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/08/ESP32-ESP8266-CPanel-Open-Edit-PHP-Files.png">
Then, select the <k>public_html</k> option and press the + File button to create a new <em>.php</em> file.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/08/ESP32-ESP8266-CPanel-Create-New-PHP-File.png">
<k>Note: </k> if you're following this tutorial and you're not familiar with PHP or MySQL, I recommend creating these exact files. Otherwise, you'll need to modify the ESP sketch provided with different URL paths. 
Create a new file in <k>/public_html</k> with this exact name and extension: <em>post-data.php</em>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/08/PHP-Create-New-file-post-esp-data.png">
Edit the newly created file (<em>post-data.php</em>) and copy the following snippet:
<k>&lt;?php
/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
$servername = "localhost";
// REPLACE with your Database name
$dbname = "REPLACE_WITH_YOUR_DATABASE_NAME";
// REPLACE with Database user
$username = "REPLACE_WITH_YOUR_USERNAME";
// REPLACE with Database user password
$password = "REPLACE_WITH_YOUR_PASSWORD";
// Keep this API Key value to be compatible with the ESP32 code provided in the project page. If you change this value, the ESP32 sketch needs to match
$api_key_value = "tPmAT5Ab3j7F9";
$api_key = $value1 = $value2 = $value3 = "";
if ($_SERVER["REQUEST_METHOD"] == "POST") {
    $api_key = test_input($_POST["api_key"]);
    if($api_key == $api_key_value) {
        $value1 = test_input($_POST["value1"]);
        $value2 = test_input($_POST["value2"]);
        $value3 = test_input($_POST["value3"]);
        
        // Create connection
        $conn = new mysqli($servername, $username, $password, $dbname);
        // Check connection
        if ($conn->connect_error) {
            die("Connection failed: " . $conn->connect_error);
        } 
        
        $sql = "INSERT INTO Sensor (value1, value2, value3)
        VALUES ('" . $value1 . "', '" . $value2 . "', '" . $value3 . "')";
        
        if ($conn->query($sql) === TRUE) {
            echo "New record created successfully";
        } 
        else {
            echo "Error: " . $sql . "&lt;br>" . $conn->error;
        }
    
        $conn->close();
    }
    else {
        echo "Wrong API Key provided.";
    }
}
else {
    echo "No data posted with HTTP POST.";
}
function test_input($data) {
    $data = trim($data);
    $data = stripslashes($data);
    $data = htmlspecialchars($data);
    return $data;
}
</k>
<a href="https://github.com/RuiSantosdotme/Visualize-ESP32-ESP8266-Readings-Anywhere/raw/master/code/post-data.php" target="_blank">View raw code</a>
Before saving the file, you need to modify the $dbname, $username and $password variables with your unique details:
<k>// Your Database name
$dbname = "example_esp_data";
// Your Database user
$username = "example_esp_board";
// Your Database user password
$password = "YOUR_USER_PASSWORD";</k>
After adding the database name, username and password, save the file and continue with this tutorial. If you try to access your domain name in the next URL path, you'll see the message:
<k>http://example.com/post-data.php</k>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/08/ESP32-ESP8266-Test-ESP-Data-URL.png">
<h3>4. PHP Script  Visualize Database Content in a Chart</h3>
Create another PHP file in the <k>/public_html</k> directory that will plot the database content in a chart on a web page. Name your new file: <em>esp-chart.php </em>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/08/PHP-Create-New-file-esp-chart.png">
Edit the newly created file (<em>esp-chart.php</em>) and copy the following code:
<k>&lt;!--
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
-->
&lt;?php
$servername = "localhost";
// REPLACE with your Database name
$dbname = "REPLACE_WITH_YOUR_DATABASE_NAME";
// REPLACE with Database user
$username = "REPLACE_WITH_YOUR_USERNAME";
// REPLACE with Database user password
$password = "REPLACE_WITH_YOUR_PASSWORD";
// Create connection
$conn = new mysqli($servername, $username, $password, $dbname);
// Check connection
if ($conn->connect_error) {
    die("Connection failed: " . $conn->connect_error);
} 
$sql = "SELECT id, value1, value2, value3, reading_time FROM Sensor order by reading_time desc limit 40";
$result = $conn->query($sql);
while ($data = $result->fetch_assoc()){
    $sensor_data[] = $data;
}
$readings_time = array_column($sensor_data, 'reading_time');
// ******* Uncomment to convert readings time array to your timezone ********
/*$i = 0;
foreach ($readings_time as $reading){
    // Uncomment to set timezone to - 1 hour (you can change 1 to any number)
    $readings_time[$i] = date("Y-m-d H:i:s", strtotime("$reading - 1 hours"));
    // Uncomment to set timezone to + 4 hours (you can change 4 to any number)
    //$readings_time[$i] = date("Y-m-d H:i:s", strtotime("$reading + 4 hours"));
    $i += 1;
}*/
$value1 = json_encode(array_reverse(array_column($sensor_data, 'value1')), JSON_NUMERIC_CHECK);
$value2 = json_encode(array_reverse(array_column($sensor_data, 'value2')), JSON_NUMERIC_CHECK);
$value3 = json_encode(array_reverse(array_column($sensor_data, 'value3')), JSON_NUMERIC_CHECK);
$reading_time = json_encode(array_reverse($readings_time), JSON_NUMERIC_CHECK);
/*echo $value1;
echo $value2;
echo $value3;
echo $reading_time;*/
$result->free();
$conn->close();
?>
&lt;!DOCTYPE html>
&lt;html>
&lt;meta name="viewport" content="width=device-width, initial-scale=1">
  &lt;script src="https://code.highcharts.com/highcharts.js">&lt;/script>
  &lt;style>
    body {
      min-width: 310px;
    max-width: 1280px;
    height: 500px;
      margin: 0 auto;
    }
    h2 {
      font-family: Arial;
      font-size: 2.5rem;
      text-align: center;
    }
  &lt;/style>
  &lt;body>
    &lt;h2>ESP Weather Station&lt;/h2>
    &lt;div>&lt;/div>
    &lt;div>&lt;/div>
    &lt;div>&lt;/div>
&lt;script>
var value1 = &lt;?php echo $value1; ?>;
var value2 = &lt;?php echo $value2; ?>;
var value3 = &lt;?php echo $value3; ?>;
var reading_time = &lt;?php echo $reading_time; ?>;
var chartT = new Highcharts.Chart({
  chart:{ renderTo : 'chart-temperature' },
  title: { text: 'BME280 Temperature' },
  series: [{
    showInLegend: false,
    data: value1
  }],
  plotOptions: {
    line: { animation: false,
      dataLabels: { enabled: true }
    },
    series: { color: '#059e8a' }
  },
  xAxis: { 
    type: 'datetime',
    categories: reading_time
  },
  yAxis: {
    title: { text: 'Temperature (Celsius)' }
    //title: { text: 'Temperature (Fahrenheit)' }
  },
  credits: { enabled: false }
});
var chartH = new Highcharts.Chart({
  chart:{ renderTo:'chart-humidity' },
  title: { text: 'BME280 Humidity' },
  series: [{
    showInLegend: false,
    data: value2
  }],
  plotOptions: {
    line: { animation: false,
      dataLabels: { enabled: true }
    }
  },
  xAxis: {
    type: 'datetime',
    //dateTimeLabelFormats: { second: '%H:%M:%S' },
    categories: reading_time
  },
  yAxis: {
    title: { text: 'Humidity (%)' }
  },
  credits: { enabled: false }
});
var chartP = new Highcharts.Chart({
  chart:{ renderTo:'chart-pressure' },
  title: { text: 'BME280 Pressure' },
  series: [{
    showInLegend: false,
    data: value3
  }],
  plotOptions: {
    line: { animation: false,
      dataLabels: { enabled: true }
    },
    series: { color: '#18009c' }
  },
  xAxis: {
    type: 'datetime',
    categories: reading_time
  },
  yAxis: {
    title: { text: 'Pressure (hPa)' }
  },
  credits: { enabled: false }
});
&lt;/script>
&lt;/body>
&lt;/html>
</k>
<a href="https://github.com/RuiSantosdotme/Visualize-ESP32-ESP8266-Readings-Anywhere/raw/master/code/esp-chart.php" target="_blank">View raw code</a>
After adding the $dbname, $username and $password save the file and continue with this project. 
<k>// Your Database name
$dbname = "example_esp_data";
// Your Database user
$username = "example_esp_board";
// Your Database user password
$password = "YOUR_USER_PASSWORD";</k>
If you try to access your domain name in the following URL path, you'll see the following:
<k>https://example.com/esp-chart.php</k>
<a href="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/08/sensor-readings-anywhere-charts-empty.png?quality=100&strip=all&ssl=1"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/08/sensor-readings-anywhere-charts-empty.png"></a>
That's it! If you see three empty charts in your browser, it means that everything is ready. In the next section, you'll learn how to publish your ESP32 or ESP8266 sensor readings.
To build the charts, we'll use the <a href="https://www.highcharts.com/docs/" target="_blank" aria-label=" (opens in a new tab)">Highcharts library</a>. We'll create three charts: temperature, humidity and pressure over time. The charts display a maximum of 40 data points, and a new reading is added every 30 seconds, but you change these values in your code.
<h3>5. Setting up the ESP32 or ESP8266</h3>
This project is compatible with both the ESP32 and ESP8266 boards. You just need to assemble a simple circuit and upload the sketch provided to insert temperature, humidity, pressure, and more into your database every 30 seconds. The sketch is slightly different for each board.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/08/esp32-vs-esp8266-devlopment-boards.jpg">
<h3>Parts Required</h3>
For this example, we'll get sensor readings from the BME280 sensor. Here's a list of parts you need to build the circuit for this project:
<a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank" aria-label=" (opens in a new tab)">ESP32 board</a> (read <a href="https://makeradvisor.com/esp32-development-boards-review-comparison/" target="_blank">Best ESP32 dev boards</a>)
Alternative  <a href="https://makeradvisor.com/tools/esp8266-esp-12e-nodemcu-wi-fi-development-board/" target="_blank">ESP8266</a> board (read <a href="https://makeradvisor.com/best-esp8266-wi-fi-development-board/" target="_blank">Best ESP8266 dev boards</a>)
<a href="https://makeradvisor.com/tools/bme280-sensor-module/" target="_blank">BME280 sensor</a>
<a href="https://makeradvisor.com/tools/jumper-wires-kit-120-pieces/" target="_blank">Jumper wires</a>
<a href="https://makeradvisor.com/tools/mb-102-solderless-breadboard-830-points/" target="_blank">Breadboard</a>
You can use the preceding links or go directly to <a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank">MakerAdvisor.com/tools</a> to find all the parts for your projects at the best price!
<a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/header-200.png?w=828&quality=100&strip=all&ssl=1" data-recalc-dims="1" loading="lazy" fetchpriority="low"></a>
<h3>Schematics</h3>
The BME280 sensor module we're using communicates via I2C communication protocol, so you need to connect it to the ESP32 or ESP8266 I2C pins.
<h4>BME280 wiring to ESP32</h4>
The ESP32 I2C pins are:
<k>GPIO 22:</k> SCL (SCK)
<k>GPIO 21:</k> SDA (SDI)
So, assemble your circuit as shown in the next schematic diagram (<a href="https://randomnerdtutorials.com/esp32-bme280-arduino-ide-pressure-temperature-humidity/">read complete Guide for ESP32 with BME280</a>). 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2018/03/ESP32-bme280_bb.png">
<k>Recommended reading:</k> <a href="https://randomnerdtutorials.com/esp32-pinout-reference-gpios/">ESP32 Pinout Reference Guide</a>
<h4>BME280 wiring to ESP8266</h4>
The ESP8266 I2C pins are:
<k>GPIO 5 </k>(D1): SCL (SCK)
<k>GPIO 4 </k>(D2): SDA (SDI)
Assemble your circuit as in the next schematic diagram if you're using an ESP8266 board (<a href="https://randomnerdtutorials.com/esp8266-bme280-arduino-ide/">read complete Guide for ESP8266 with BME280</a>). 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/06/ESP8266-BME280-Arduino-IDE.png">
<k>Recommended reading:</k> <a href="https://randomnerdtutorials.com/esp8266-pinout-reference-gpios/">ESP8266 Pinout Reference Guide</a> 
<h3>Installing Libraries</h3>
We'll program the ESP32/ESP8266 using Arduino IDE, so you must have the ESP32/ESP8266 add-on installed in your Arduino IDE. Follow one of the next tutorials depending on the board you're using:
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Install the ESP32 Board in Arduino IDE</a>  you also need to <a href="https://randomnerdtutorials.com/esp32-bme280-arduino-ide-pressure-temperature-humidity/">install the BME280 Library and Adafruit_Sensor library</a>
<a href="https://randomnerdtutorials.com/how-to-install-esp8266-board-arduino-ide/">Install the ESP8266 Board in Arduino IDE</a>  you also need to <a href="https://randomnerdtutorials.com/esp8266-bme280-arduino-ide/">install the BME280 Library and Adafruit_Sensor library</a>
<h3>ESP32 Code</h3>
Follow this section if you're using an ESP32. For an ESP8266 click here.
After installing the necessary board add-ons, copy the following code to your Arduino IDE, but don't upload it yet. You need to make some changes to make it work for you.
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-esp8266-mysql-database-php/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
#include &lt;WiFi.h>
#include &lt;WiFiClientSecure.h>
#include &lt;HTTPClient.h>
#include &lt;Wire.h>
#include &lt;Adafruit_Sensor.h>
#include &lt;Adafruit_BME280.h>
// Replace with your network credentials
const char* ssid     = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
// REPLACE with your Domain name and URL path or IP address with path
//const char* serverName = "https://example.com/post-data.php";
// Keep this API Key value to be compatible with the PHP code provided in the project page. 
// If you change the apiKeyValue value, the PHP file /post-esp-data.php also needs to have the same key 
String apiKeyValue = "tPmAT5Ab3j7F9";
/*#include &lt;SPI.h>
#define BME_SCK 18
#define BME_MISO 19
#define BME_MOSI 23
#define BME_CS 5*/
#define SEALEVELPRESSURE_HPA (1013.25)
Adafruit_BME280 bme;  // I2C
//Adafruit_BME280 bme(BME_CS);  // hardware SPI
//Adafruit_BME280 bme(BME_CS, BME_MOSI, BME_MISO, BME_SCK);  // software SPI
void setup() {
  Serial.begin(115200);
  
  WiFi.begin(ssid, password);
  Serial.println("Connecting");
  while(WiFi.status() != WL_CONNECTED) { 
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.print("Connected to WiFi network with IP Address: ");
  Serial.println(WiFi.localIP());
  // (you can also pass in a Wire library object like &Wire2)
  bool status = bme.begin(0x76);
  if (!status) {
    Serial.println("Could not find a valid BME280 sensor, check wiring or change I2C address!");
    while (1);
  }
}
void loop() {
  //Check WiFi connection status
  if(WiFi.status()== WL_CONNECTED){
    WiFiClientSecure *client = new WiFiClientSecure;
    client->setInsecure(); //don't use SSL certificate
    HTTPClient https;
    
    // Your Domain name with URL path or IP address with path
    https.begin(*client, serverName);
    
    // Specify content-type header
    https.addHeader("Content-Type", "application/x-www-form-urlencoded");
    
    // Prepare your HTTP POST request data
    String httpRequestData = "api_key=" + apiKeyValue + "&value1=" + String(bme.readTemperature())
                           + "&value2=" + String(bme.readHumidity()) + "&value3=" + String(bme.readPressure()/100.0F) + "";
   
    Serial.print("httpRequestData: ");
    Serial.println(httpRequestData);
    
    // You can comment the httpRequestData variable above
    // then, use the httpRequestData variable below (for testing purposes without the BME280 sensor)
    //String httpRequestData = "api_key=tPmAT5Ab3j7F9&sensor=BME280&location=Office&value1=24.75&value2=49.54&value3=1005.14";
    // Send HTTP POST request
    int httpResponseCode = https.POST(httpRequestData);
     
    // If you need an HTTP request with a content type: text/plain
    //https.addHeader("Content-Type", "text/plain");
    //int httpResponseCode = https.POST("Hello, World!");
    
    // If you need an HTTP request with a content type: application/json, use the following:
    //https.addHeader("Content-Type", "application/json");
    //int httpResponseCode = https.POST("{\"value1\":\"19\",\"value2\":\"67\",\"value3\":\"78\"}");
    
    if (httpResponseCode>0) {
      Serial.print("HTTP Response code: ");
      Serial.println(httpResponseCode);
    }
    else {
      Serial.print("Error code: ");
      Serial.println(httpResponseCode);
    }
    // Free resources
    https.end();
  }
  else {
    Serial.println("WiFi Disconnected");
  }
  //Send an HTTP POST request every 30 seconds
  delay(30000);  
}
</k>
<a href="https://github.com/RuiSantosdotme/Visualize-ESP32-ESP8266-Readings-Anywhere/raw/master/code/HTTPS_Visualize_ESP32_Readings_Anywhere.ino" target="_blank">View raw code</a>
<h4>Setting your network credentials</h4>
You need to modify the following lines with your network credentials: SSID and password. The code is well commented on where you should make the changes.
<k>// Replace with your network credentials
const char* ssid     = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
<h4>Setting your serverName</h4>
You also need to type your domain name, so the ESP publishes the readings to your own server.
<k>const char* serverName = "https://example.com/post-data.php";</k>
Now, you can upload the code to your board.
<k>Note: </k> Most servers require you to make HTTPS requests. The code above makes HTTPS requests to be compliant with the requirements of most cloud servers nowadays.
Your server doesn't support HTTPS? <a href="https://raw.githubusercontent.com/RuiSantosdotme/Visualize-ESP32-ESP8266-Readings-Anywhere/master/code/Visualize_ESP32_ESP8266_Readings_Anywhere.ino" target="_blank" rel="noopener" title="">Use this code instead</a>.
<h4>How the code works</h4>
This project is already quite long, so we won't cover in detail how the code works, but here's a quick summary:
Import all the libraries to make it work;
Set variables that you might want to change (apiKeyValue);
The apiKeyValue is just a random string that you can modify. It's used for security reasons, so only anyone that knows your API key can publish data to your database;
Initialize the serial communication for debugging purposes;
Establish a Wi-Fi connection with your router;
Initialize the BME280 to get readings;
Initialize a secure WiFi client.
Then, in the loop() is where you actually make the HTTP POST request every 30 seconds with the latest BME280 readings:
<k>// Your Domain name with URL path or IP address with path
http.begin(serverName);
// Specify content-type header
http.addHeader("Content-Type", "application/x-www-form-urlencoded");
// Prepare your HTTP POST request data
String httpRequestData = "api_key=" + apiKeyValue + "&value1=" 
                       + String(bme.readTemperature()) 
                       + "&value2=" + String(bme.readHumidity()) 
                       + "&value3=" + String(bme.readPressure()/100.0F) + "";
int httpResponseCode = http.POST(httpRequestData);</k>
You can comment the httpRequestData variable above that concatenates all the BME280 readings and use the httpRequestData variable below for testing purposes:
<k>String httpRequestData = "api_key=tPmAT5Ab3j7F9&value1=24.75&value2=49.54&value3=1005.14";</k>
Learn more about HTTPS Requests with the ESP32: <a href="https://randomnerdtutorials.com/esp32-https-requests/">ESP32 HTTPS Requests (Arduino IDE)</a>.
<h3>ESP8266 Code</h3>
Follow this section if you're using an ESP8266. For an ESP32 check the section above.
After installing the necessary board add-ons and libraries, copy the following code to your Arduino IDE, but don't upload it yet. You need to make some changes to make it work for you.
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-esp8266-mysql-database-php/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
#include &lt;ESP8266WiFi.h>
#include &lt;ESP8266HTTPClient.h>
#include &lt;WiFiClientSecureBearSSL.h>
#include &lt;Wire.h>
#include &lt;Adafruit_Sensor.h>
#include &lt;Adafruit_BME280.h>
// Replace with your network credentials
const char* ssid     = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
// REPLACE with your Domain name and URL path or IP address with path
const char* serverName = "https://example.com/post-data.php";
// Keep this API Key value to be compatible with the PHP code provided in the project page. 
// If you change the apiKeyValue value, the PHP file /post-esp-data.php also needs to have the same key 
String apiKeyValue = "tPmAT5Ab3j7F9";
/*#include &lt;SPI.h>
#define BME_SCK 18
#define BME_MISO 19
#define BME_MOSI 23
#define BME_CS 5*/
#define SEALEVELPRESSURE_HPA (1013.25)
Adafruit_BME280 bme;  // I2C
//Adafruit_BME280 bme(BME_CS);  // hardware SPI
//Adafruit_BME280 bme(BME_CS, BME_MOSI, BME_MISO, BME_SCK);  // software SPI
void setup() {
  Serial.begin(115200);
  
  WiFi.begin(ssid, password);
  Serial.println("Connecting");
  while(WiFi.status() != WL_CONNECTED) { 
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.print("Connected to WiFi network with IP Address: ");
  Serial.println(WiFi.localIP());
  // (you can also pass in a Wire library object like &Wire2)
  bool status = bme.begin(0x76);
  if (!status) {
    Serial.println("Could not find a valid BME280 sensor, check wiring or change I2C address!");
    while (1);
  }
}
void loop() {
  //Check WiFi connection status
  if(WiFi.status()== WL_CONNECTED){
    std::unique_ptr&lt;BearSSL::WiFiClientSecure>client(new BearSSL::WiFiClientSecure);
    // Ignore SSL certificate validation
    client->setInsecure();
    
    //create an HTTPClient instance
    HTTPClient https;
    
    // Your Domain name with URL path or IP address with path
    https.begin(*client, serverName);
    
    // Specify content-type header
    https.addHeader("Content-Type", "application/x-www-form-urlencoded");
    
    // Prepare your HTTP POST request data
    String httpRequestData = "api_key=" + apiKeyValue + "&value1=" + String(bme.readTemperature())
                           + "&value2=" + String(bme.readHumidity()) + "&value3=" + String(bme.readPressure()/100.0F) + "";
    Serial.print("httpRequestData: ");
    Serial.println(httpRequestData);
    
    // You can comment the httpRequestData variable above
    // then, use the httpRequestData variable below (for testing purposes without the BME280 sensor)
    //String httpRequestData = "api_key=tPmAT5Ab3j7F9&sensor=BME280&location=Office&value1=24.75&value2=49.54&value3=1005.14";
    // Send HTTP POST request
    int httpResponseCode = https.POST(httpRequestData);
     
    // If you need an HTTP request with a content type: text/plain
    //http.addHeader("Content-Type", "text/plain");
    //int httpResponseCode = https.POST("Hello, World!");
    
    // If you need an HTTP request with a content type: application/json, use the following:
    //http.addHeader("Content-Type", "application/json");
    //int httpResponseCode = https.POST("{\"value1\":\"19\",\"value2\":\"67\",\"value3\":\"78\"}");
        
    if (httpResponseCode>0) {
      Serial.print("HTTP Response code: ");
      Serial.println(httpResponseCode);
    }
    else {
      Serial.print("Error code: ");
      Serial.println(httpResponseCode);
    }
    // Free resources
    https.end();
  }
  else {
    Serial.println("WiFi Disconnected");
  }
  //Send an HTTP POST request every 30 seconds
  delay(30000);  
}
</k>
<a href="https://github.com/RuiSantosdotme/Visualize-ESP32-ESP8266-Readings-Anywhere/raw/master/code/HTTPS_Visualize_ESP8266_Readings_Anywhere.ino" target="_blank">View raw code</a>
<h4>Setting your network credentials</h4>
You need to modify the following lines with your network credentials: SSID and password. The code is well commented on where you should make the changes.
<k>// Replace with your network credentials
const char* ssid     = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
<h4>Setting your serverName</h4>
You also need to type your domain name, so the ESP publishes the readings to your own server.
<k>const char* serverName = "https://example.com/post-data.php";</k>
Now, you can upload the code to your board.
rnt_box type=3] Most servers require you to make HTTPS requests. The code above makes HTTPS requests to be compliant with the requirements of most cloud servers nowadays.
Your server doesn't support HTTPS? <a href="https://raw.githubusercontent.com/RuiSantosdotme/Visualize-ESP32-ESP8266-Readings-Anywhere/master/code/Visualize_ESP32_ESP8266_Readings_Anywhere.ino" target="_blank" rel="noopener" title="">Use this code instead</a>.
Learn more about HTTPS Requests with the ESP8266: <a href="https://randomnerdtutorials.com/esp8266-nodemcu-https-requests/">ESP8266 NodeMCU HTTPS Requests (Arduino IDE)</a>.
<h3>Demonstration</h3>
After completing all the steps, let your ESP board collect some readings and publish them to your server. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/06/ESP32-BME280-Arduino-IDE-MySQL.jpg">
If everything is correct, this is what you should see in your Arduino IDE Serial Monitor:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/08/arduino-ide-serial-monitor-esp32-esp8266-publishing-readings-to-MySQL-database.png">
If you open your domain name in this URL path:
<k>https://example.com/esp-chart.php</k>
You should see all the readings stored in your database. Refresh the web page to see the latest readings:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/08/sensor-readings-anywhere-charts-esp32-esp8266.png">
You can also go to phpMyAdmin to manage the data stored in your Sensor table. You can delete it, edit, etc
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/03/ESP-sensor-readings-from-anywhere-http-post-request-phpmyadmin-demonstration.png">
<h3>Wrapping Up</h3>
In this tutorial, you learned how to publish sensor data into a database in your own server domain that you can access from anywhere in the world. This requires that you have your own <a aria-label="server and domain name (opens in a new tab)" href="https://randomnerdtutorials.com/bluehost" target="_blank">server and domain name</a> (you can also use a <a href="https://randomnerdtutorials.com/esp32-esp8266-raspberry-pi-lamp-server/">Raspberry Pi for local access</a>). 
With this setup, you control your server and can move to a different host if necessary. There are many cloud solutions both free and paid that you can use to publish your readings, but those services can have several disadvantages: restrictions on how many readings you can publish, the number of connected devices, who can see your data, etc. Additionally, the cloud service can be discontinued or change at any time.
The example provided is as simple as possible so that you can understand how everything works. After understanding this example, you may change the web page appearance, publish different sensor readings, publish from multiple ESP boards, and much more.
<h2>Erase Flash Memory (Factory Reset)</h2>
This is a quick guide showing how to erase the ESP32 flash memory to restore it to its original state. This might be useful if you want to delete any changes made to the firmware or configuration settings; if the system is crashing constantly and you can't upload new code; to clear data that is no longer needed, and other applications. We'll use a tool called <k>esptool</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/02/ESP32-erase-flash-factory-reset.jpg">
<h3>Installing esptool.py</h3>
To perform an ESP32 factory reset, we'll use <a href="https://pypi.org/project/esptool/" target="_blank" rel="noopener" title="">esptool</a>, which is <em>a Python-based, open-source, platform-independent utility to communicate with the ROM bootloader in Espressif chips.</em>
To install esptool, you need Python 3.7 or newer installed on your system. You can download and install Python at the following link (make sure you download the right package for your system):
<a href="https://www.python.org/downloads/" target="_blank" rel="noopener" title="">Download Python</a>
With Python 3 installed, open a Terminal window and install the latest stable esptool.py release with pip:
pip install esptool
<k>Note:</k> with some Python installations that command may not work and you'll receive an error. If that's the case, try to install esptool.py with:
pip3 install esptool
python -m pip install esptool
pip2 install esptool
<em>Setuptools </em>is also a requirement that is not available on all systems by default. You can install it with the following command:
pip install setuptools
After installing, you will have esptool.py installed into the default Python executables directory and you should be able to run it with the command esptool. In your Terminal window, run the following command:
python -m esptool
If it was installed properly, it should display a similar message (regardless of your operating system):
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/02/esptool-arguments.png">
<h3>Erasing the ESP32 Flash</h3>
Follow the next steps to erase the ESP32 flash:
<k>1) </k>Connect the ESP32 to your computer;
<k>2) </k>Open a Terminal window on your computer;
<k>3)</k> Hold the ESP32 BOOT button;
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/02/ESP32-BOOT-button.jpg">
<k>4)</k> Copy the following command to your terminal window and press Enter (continue holding the BOOT button).
python -m esptool --chip esp32 erase_flash
<k>5)</k> When the <k>Erasing</k> process begins, you can release the <k>BOOT/FLASH</k> button. After a few seconds, the ESP32 flash memory will be erased.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/02/esptool-erase-flash.png">
<k>Note: </k>if after the <k>Connecting </k> message you keep seeing new dots appearing, it means that your ESP32 is not in flashing mode. You need to repeat all the steps described earlier and hold the <k>BOOT/FLASH</k> button again to ensure that your ESP32 goes into flashing mode and completes the erasing process successfully.
<h3>Troubleshooting</h3>
If you encounter a permission error while trying to run the esptool command, open the command prompt as a administrator (or as sudo on Linux).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/07/cmd_run_as_admin.png">
<h3>Wrapping Up</h3>
This was a quick guide showing you how to erase the ESP32 flash to perform a factory reset. We hope this tutorial is useful.
If you're using an ESP8266 board, you can follow the instructions in the following tutorial:
<a href="https://randomnerdtutorials.com/esp8266-nodemcu-erase-flash-memory/">ESP8266 NodeMCU: Erase Flash Memory (Factory Reset)</a>
<h2>Send BME280 Sensor Readings to InfluxDB</h2>
In this guide, you'll learn how to send BME280 sensor readings to InfluxDB using the ESP32 or ESP8266 boards. InfluxDB is a time series database. Each record on the database is associated with a  timestamp, which makes it ideal for datalogging IoT and Home Automation projects. InfluxDB also provides dashboard tools to visualize data in different formats like charts, gauges, histograms, etc.
<a href="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/ESP32-ESP8266-BME280-InfluxDB.jpg?quality=100&strip=all&ssl=1"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/ESP32-ESP8266-BME280-InfluxDB.jpg"></a>
By the end of this tutorial, you'll be able to build a dashboard as shown below to display all your sensor readings over time.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/ESP32-ESP8266-Sensor-Readings-Dashboard.png">
To get started with InfluxDB, read one of the following guides:
<a href="https://randomnerdtutorials.com/esp32-influxdb/">ESP32: Getting Started with InfluxDB</a>
<a href="https://randomnerdtutorials.com/esp8266-nodemcu-influxdb/">ESP8266 NodeMCU: Getting Started with InfluxDB</a>
<h3>What is InfluxDB?</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/influxdb-logo.png">
InfluxDB is an open-source high-performance time series database (TSDB) that can store large amounts of data per second. Each data point you submit to the database is associated with a particular timestamp. So, it is ideal for IoT datalogging projects like storing data from your weather station sensors.
You can run <a href="https://www.influxdata.com/products/influxdb/" target="_blank">InfluxDB in InfluxDB Cloud</a>, or locally on your laptop or <a href="https://randomnerdtutorials.com/install-influxdb-2-raspberry-pi/">Raspberry Pi</a>.
<blockquote>
<k>Why use InfluxDB Cloud?</k> It's a fast, elastic, serverless real-time monitoring platform, dashboarding engine, analytics service and event and metrics processor.
<cite>https://www.influxdata.com/products/influxdb-cloud/</cite>
</blockquote>
For a more in-depth introduction to InfluxDB, check the following tutorials before proceeding:
ESP32: Getting Started with InfluxDB
ESP8266: Getting Started with InfluxDB
<h3>Creating an InfluxDB Account</h3>
If you don't have an InfluxDB account, follow the next steps. If you already have an account, you can skip to the next section.
If you want to run InfluxDB locally on a Raspberry Pi, follow the next tutorial first: <a href="https://randomnerdtutorials.com/install-influxdb-2-raspberry-pi/">Install InfluxDB 2 on Raspberry Pi</a>. Then, proceed to the Loading Data in InfluxDB section.
<k>1) </k>Go to <a href="https://cloud2.influxdata.com/signup" target="_blank">https://cloud2.influxdata.com/signup</a> and create an InfluxDB account.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/InfluxDB-create-account.png">
<k>2)</k> Select where you want to save your data. I selected the Google Cloud option, but you can select one of the other options. Select the region, it should be the closest to your location. Then, enter something on the Company Name field, and agree to the terms before proceeding.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/Influx-DB-Select-Provider.png">
<k>3)</k> Select the InfluxDB plan. For this example, we'll be using the Free plan. For most of our IoT projects, the Free plan works just fine. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/Influx-DB-Select-Plan.png">
<k>4)</k> After selecting the plan, you'll be redirected to the <k>Getting Started</k> page.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/05/InfluxDB-Cloud-Get-Started.png">
<h3>Loading Data in InfluxDB</h3>
<k><k>5)</k> Click on <k><k> Load Data</k> </k></k>icon and select <k><k><k>Sources</k></k></k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/02/influxdb-sources.png">
<k>6)</k> Scroll down until you find the <k>Arduino </k>option under the <k>Client Libraries</k> section.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/05/influxdb-client-libraries-arduino.png">
Click on Initialize Client.
<a href="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/05/Arduino-client-Create-Bucket-InfluxDB-cloud.png?quality=100&strip=all&ssl=1"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/05/Arduino-client-Create-Bucket-InfluxDB-cloud.png"></a>
The page that opens allows you to create buckets, and it also shows some sample code to interface the ESP8266 or ESP32 boards with InfluxDB.
<h3>Creating an InfluxDB Bucket</h3>
<k>7)</k> Create a new bucket to store your data. Click on <k>+ Create Bucket</k> to create a new bucket for this example. You can use the settings by default, or you can customize them.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/05/influxdb-creating-bucket-esp8266.png">
<h3>Getting InfluxDB URL and API Token</h3>
<k>8)</k> Get your InfluxDB URL* and other details you'll need later. Scroll down to the<em> Configure InfluxDB profile</em> snippet. Then, copy the INFLUXDB_URL, INFLUXDB_TOKEN, INFLUXDB_ORG, and INFLUXDB_BUCKET.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/02/influxdb-details-arduino-client.png">
* if you're running InfluxDB locally on a Raspberry Pi, the URL will be the Raspberry Pi IP address on port 8086. For example 192.168.1.106:8086.
<h3>API Tokens</h3>
If you've followed the previous steps, InfluxDB cloud has already created an API token for you that you could find in the snippet presented in the previous step. If you go to the Load Data icon and select API Tokens, you'll find the previously generated API token. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/05/influxdb-api-token.png">
On this page, you can generate a new API token if needed.
At this moment, you should have saved the following:
InfluxDB Server URL
InfluxDB Organization
InfluxDB Bucket Name
API Token
<hr>
<h3>ESP32/ESP8266 Send Sensor Readings to InfluxDB</h3>
In this section, we'll program the ESP32 and ESP8266 boards to send BME280 temperature, humidity, and pressure readings to InfluxDB.
<h3>Parts Required</h3>
For this project, you need the following parts*:
<a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32</a> or<a href="https://makeradvisor.com/tools/esp8266-esp-12e-nodemcu-wi-fi-development-board/" target="_blank"> ESP8266</a> board (read <a href="https://makeradvisor.com/esp32-vs-esp8266/" target="_blank">ESP32 vs ESP8266</a>);
<a href="https://makeradvisor.com/tools/bme280-sensor-module/" target="_blank">BME280</a> or any other sensor you're familiar with;
<a href="https://makeradvisor.com/tools/mb-102-solderless-breadboard-830-points/" target="_blank">Breadboard</a>;        <a href="https://makeradvisor.com/tools/jumper-wires-kit-120-pieces/"> </a>
<a href="https://makeradvisor.com/tools/jumper-wires-kit-120-pieces/" target="_blank">Jumper wires</a>.
* you can also test the project with random values instead of sensor readings, or you can use any other sensor you're familiar with.
You can use the preceding links or go directly to <a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank">MakerAdvisor.com/tools</a> to find all the parts for your projects at the best price!
<a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/header-200.png?w=828&quality=100&strip=all&ssl=1" data-recalc-dims="1" loading="lazy" fetchpriority="low"></a>
<h3>Schematic Diagram</h3>
In this tutorial, we'll send BME280 sensor readings to InfluxDB. So, you need to wire the BME280 sensor to your board. Follow one of the next schematic diagrams.
<h4>ESP32 with BME280</h4>
We're going to use I2C communication with the BME280 sensor module. Wire the sensor to the default ESP32 SCL (GPIO 22) and SDA (GPIO 21) pins, as shown in the following schematic diagram.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/10/ESP32-BME280-Sensor-Temperature-Humidity-Pressure-Wiring-Diagram-Circuit_f.png">
Not familiar with the BME280 with the ESP32? Read this tutorial: <a href="https://randomnerdtutorials.com/esp32-bme280-arduino-ide-pressure-temperature-humidity/"><k>ESP32 with BME280 Sensor using Arduino IDE (Pressure, Temperature, Humidity)</k></a>.
<h4>ESP8266 with BME280 </h4>
We're going to use I2C communication with the BME280 sensor module. For that, wire the sensor to the ESP8266 SDA (GPIO 4) and SCL (GPIO 5) pins, as shown in the following schematic diagram.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/ESP8266-NodeMCU-BME280-Sensor-Temperature-Humidity-Pressure-Wiring-Diagram-Circuit.png">
Not familiar with the BME280 with the ESP8266? Read this tutorial: <a href="https://randomnerdtutorials.com/esp8266-bme280-arduino-ide/"><k>ESP8266 with BME280 using Arduino IDE (Pressure, Temperature, Humidity)</k></a>.
<h3>Installing Libraries</h3>
For this project, you need to install the following libraries:
<a href="https://github.com/tobiasschuerg/InfluxDB-Client-for-Arduino" target="_blank">InfluxDB Arduino Client Library</a>
<a href="https://github.com/adafruit/Adafruit_BME280_Library" target="_blank">Adafruit BME280 Library</a>
<a href="https://github.com/adafruit/Adafruit_Sensor" target="_blank">Adafruit Unified Sensor Library</a>
<h4>Installation  Arduino IDE</h4>
If you're using Arduino IDE, follow the next steps to install the library.
<ol>
Go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k>
Search for InfluxDB and install the <k>ESP8266 Influxdb library by Tobias Sh<a8><b9>rg</k>.
</ol>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/Install-Influxdb-Client-Arduino-IDE.png">
<k>Note: </k> we are using ESP8266 Boards <k>version 3.0.1</k> and ESP32 Boards <k>version 2.0.1</k> Check your boards' version in <k>Tools </k>> <k>Board </k>> <k>Boards Manager</k>. Then, search for <k>ESP8266</k> or <k>ESP32</k> and upgrade to one of those versions. (I found some issues with the newest 3.0.2 and 2.0.2 versions)
<ol start="3">Follow the same instructions to install the <k>Adafruit BME280</k> Library and <k>Adafruit Unified Sensor</k> Library.</ol>
<h4>Installation  VS Code</h4>
If you're using VS Code with the PlatformIO extension, start by creating an Arduino project for your ESP32 or ESP8266 board.
Then, click on the <k>PIO Home</k> icon and then select the <k>Libraries tab</k>. Search for <k>influxdb</k>. Select the <k>ESP8266 Influxdb</k> by Tobias Sch<a8><b9>rg.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/Install-InfluxDB-library-VS-Code.png">
Follow the same procedure for the Adafruit BME280 library and Adafruit Unified Sensor library.
Your plaformio.ini file should look as follows (we also added a line to change the Serial Monitor baud rate to 115200).
<k>monitor_speed = 115200
lib_deps = 
tobiasschuerg/ESP8266 Influxdb@^3.12.0
adafruit/Adafruit BME280 Library@^2.2.2
adafruit/Adafruit Unified Sensor@^1.1.5</k>
<h3>Send Sensor Readings to InfluxDBCode</h3>
Copy the following code to the Arduino IDE or to the main.cpp file if you're using VS Code with the PlatformIO extension. The code is compatible with both the ESP32 and ESP8266 boards.
This code is based <a href="https://github.com/tobiasschuerg/InfluxDB-Client-for-Arduino/blob/master/examples/BasicWrite/BasicWrite.ino" target="_blank">on this library example</a>. We made a few modifications to include the BME280 sensor readings.
<k>/*
  Rui Santos
  Complete project details at our blog: https://RandomNerdTutorials.com/
  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files.
  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
*/
// Based on this library example: https://github.com/tobiasschuerg/InfluxDB-Client-for-Arduino/blob/master/examples/SecureBatchWrite/SecureBatchWrite.ino
#include &lt;Arduino.h>
#include &lt;Wire.h>
#include &lt;Adafruit_Sensor.h>
#include &lt;Adafruit_BME280.h>
#if defined(ESP32)
  #include &lt;WiFiMulti.h>
  WiFiMulti wifiMulti;
  #define DEVICE "ESP32"
#elif defined(ESP8266)
  #include &lt;ESP8266WiFiMulti.h>
  ESP8266WiFiMulti wifiMulti;
  #define DEVICE "ESP8266"
  #define WIFI_AUTH_OPEN ENC_TYPE_NONE
#endif
#include &lt;InfluxDbClient.h>
#include &lt;InfluxDbCloud.h>
// WiFi AP SSID
#define WIFI_SSID "REPLACE_WITH_YOUR_SSID"
// WiFi password
#define WIFI_PASSWORD "REPLACE_WITH_YOUR_PASSWORD"
// InfluxDB v2 server url, e.g. https://eu-central-1-1.aws.cloud2.influxdata.com (Use: InfluxDB UI -> Load Data -> Client Libraries)
#define INFLUXDB_URL "REPLACE_WITH_YOUR_DATABASE_URL"
// InfluxDB v2 server or cloud API authentication token (Use: InfluxDB UI -> Load Data -> Tokens -> &lt;select token>)
#define INFLUXDB_TOKEN "REPLACE_WITH_YOUR_TOKEN"
// InfluxDB v2 organization id (Use: InfluxDB UI -> Settings -> Profile -> &lt;name under tile> )
#define INFLUXDB_ORG "REPLACE_WITH_YOUR_ORG"
// InfluxDB v2 bucket name (Use: InfluxDB UI -> Load Data -> Buckets)
#define INFLUXDB_BUCKET "SENSOR"
// Set timezone string according to https://www.gnu.org/software/libc/manual/html_node/TZ-Variable.html
// Examples:
//  Pacific Time:   "PST8PDT"
//  Eastern:        "EST5EDT"
//  Japanesse:      "JST-9"
//  Central Europe: "CET-1CEST,M3.5.0,M10.5.0/3"
#define TZ_INFO "WET0WEST,M3.5.0/1,M10.5.0"
// InfluxDB client instance with preconfigured InfluxCloud certificate
InfluxDBClient client(INFLUXDB_URL, INFLUXDB_ORG, INFLUXDB_BUCKET, INFLUXDB_TOKEN, InfluxDbCloud2CACert);
// InfluxDB client instance without preconfigured InfluxCloud certificate for insecure connection 
//InfluxDBClient client(INFLUXDB_URL, INFLUXDB_ORG, INFLUXDB_BUCKET, INFLUXDB_TOKEN);
// Data point
Point sensorReadings("measurements");
//BME280
Adafruit_BME280 bme; // I2C
float temperature;
float humidity;
float pressure;
// Initialize BME280
void initBME(){
  if (!bme.begin(0x76)) {
    Serial.println("Could not find a valid BME280 sensor, check wiring!");
    while (1);
  }
}
void setup() {
  Serial.begin(115200);
  // Setup wifi
  WiFi.mode(WIFI_STA);
  wifiMulti.addAP(WIFI_SSID, WIFI_PASSWORD);
  Serial.print("Connecting to wifi");
  while (wifiMulti.run() != WL_CONNECTED) {
    Serial.print(".");
    delay(500);
  }
  Serial.println();
  
  //Init BME280 sensor
  initBME();
  
  // Add tags
  sensorReadings.addTag("device", DEVICE);
  sensorReadings.addTag("location", "office");
  sensorReadings.addTag("sensor", "bme280");
  // Accurate time is necessary for certificate validation and writing in batches
  // For the fastest time sync find NTP servers in your area: https://www.pool.ntp.org/zone/
  // Syncing progress and the time will be printed to Serial.
  timeSync(TZ_INFO, "pool.ntp.org", "time.nis.gov");
  // Check server connection
  if (client.validateConnection()) {
    Serial.print("Connected to InfluxDB: ");
    Serial.println(client.getServerUrl());
  } else {
    Serial.print("InfluxDB connection failed: ");
    Serial.println(client.getLastErrorMessage());
  }
}
void loop() {
  // Get latest sensor readings
  temperature = bme.readTemperature();
  humidity = bme.readHumidity();
  pressure = bme.readPressure()/100.0F;
  // Add readings as fields to point
  sensorReadings.addField("temperature", temperature);
  sensorReadings.addField("humidity", humidity);
  sensorReadings.addField("pressure", pressure);
  // Print what are we exactly writing
  Serial.print("Writing: ");
  Serial.println(client.pointToLineProtocol(sensorReadings));
  
  // Write point into buffer
  client.writePoint(sensorReadings);
  // Clear fields for next usage. Tags remain the same.
  sensorReadings.clearFields();
  // If no Wifi signal, try to reconnect it
  if (wifiMulti.run() != WL_CONNECTED) {
    Serial.println("Wifi connection lost");
  }
  // Wait 10s
  Serial.println("Wait 10s");
  delay(10000);
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP/ESP_InfluxDB_BME280.ino" target="_blank">View raw code</a>
Before uploading the code to your board, you need to insert your network credentials, the database URL, token, organization, and bucket name. Also, don't forget to insert your timezone. <a href="https://github.com/nayarsystems/posix_tz_db/blob/master/zones.csv" target="_blank">Check this document to search for your timezone</a> in the right format.
<h3>How the Code Works</h3>
Start by including the required libraries and setting the DEVICE name accordingly to the selected board (ESP32 or ESP8266).
<k>#include &lt;Arduino.h>
#include &lt;Wire.h>
#include &lt;Adafruit_Sensor.h>
#include &lt;Adafruit_BME280.h>
#if defined(ESP32)
  #include &lt;WiFiMulti.h>
  WiFiMulti wifiMulti;
  #define DEVICE "ESP32"
#elif defined(ESP8266)
  #include &lt;ESP8266WiFiMulti.h>
  ESP8266WiFiMulti wifiMulti;
  #define DEVICE "ESP8266"
  #define WIFI_AUTH_OPEN ENC_TYPE_NONE
#endif
#include &lt;InfluxDbClient.h>
#include &lt;InfluxDbCloud.h></k>
Insert your network credentials on the following variables so that the ESP32 or ESP8266 boards can connect to the internet using your local network.
<k>// WiFi AP SSID
#define WIFI_SSID "REPLACE_WITH_YOUR_SSID"
// WiFi password
#define WIFI_PASSWORD "REPLACE_WITH_YOUR_PASSWORD"</k>
Insert the InfluxDB server URL on the following linesthe one you've gotten in this step:
<k>// InfluxDB v2 server url, e.g. https://eu-central-1-1.aws.cloud2.influxdata.com (Use: InfluxDB UI -> Load Data -> Client Libraries)
#define INFLUXDB_URL "REPLACE_WITH_YOUR_INFLUXDB_URL"</k>
<k>Note: </k> if you're running InfluxDB locally on a Raspberry Pi, the URL will be the Raspberry Pi IP address on port 8086. For example 192.168.1.106:8086.
Insert your InfluxDB tokensaved in this step:
<k>#define INFLUXDB_TOKEN "REPLACE_WITH_YOUR_INFLUXDB_TOKEN"</k>
Add your InfluxDB organization name<a href="http://influxdb-URL">check this step</a>.
<k>#define INFLUXDB_ORG "REPLACE_WITH_YOUR_INFLUXXDB_ORGANIZATION_ID"</k>
Finally, add your InfluxDB bucket name:
<k>#define INFLUXDB_BUCKET "REPLACE_WITH_YOUR_BUCKET_NAME"</k>
<h4>Setting your Timezone</h4>
You must set your timezone accordingly to <a href="https://www.gnu.org/software/libc/manual/html_node/TZ-Variable.html" target="_blank">these instructions</a>. The easiest way is to <k><a href="https://github.com/nayarsystems/posix_tz_db/blob/master/zones.csv" target="_blank">check this table and copy your timezone from there</a>.</k> In my case, it's Lisbon timezone:
<k>#define TZ_INFO "WET0WEST,M3.5.0/1,M10.5.0"</k>
<h4>InfluxDB Client</h4>
Now that you have all the required settings, you can create an InfluxDBClient instance. We're creating a secure client that uses a preconfigured certificate<a href="https://github.com/tobiasschuerg/InfluxDB-Client-for-Arduino#secure-connection" target="_blank">learn more about secure connection</a>.
<k>InfluxDBClient client(INFLUXDB_URL, INFLUXDB_ORG, INFLUXDB_BUCKET, INFLUXDB_TOKEN, InfluxDbCloud2CACert);</k>
<h4>Point</h4>
Then, we create a Point instance called sensorReadings. The point will be called measurements on the database. Later in the code, we can refer to that point (sensorReadings) to add tags and fields.
<k>Point sensorReadings("measurements");</k>
<k>Note: </k> A set of data in a database row is known as <k>point</k>. Each point has a <k>measurement</k>, a <k>tag set</k>, a <k>field key</k>, a <k>field value</k>, and a <k>timestamp</k>.
<h4>BME280 Variables</h4>
Create an Adafruit_BME280 instance called bme on the default ESP I2C pins.
<k>Adafruit_BME280 bme; // I2C</k>
Create variables to save the temperature, humidity, and pressure readings.
<k>float temperature;
float humidity;
float pressure;</k>
<h4>initBME() function</h4>
The initBME() function initializes the BME280 sensor. We'll call it later in the setup() to initialize the sensor.
<k>// Initialize BME280
void initBME(){
  if (!bme.begin(0x76)) {
    Serial.println("Could not find a valid BME280 sensor, check wiring!");
    while (1);
  }
}</k>
<h4>setup()</h4>
In the setup(), initialize the Serial Monitor for debugging purposes.
<k>Serial.begin(115200);</k>
Initialize Wi-Fi.
<k>// Setup wifi
WiFi.mode(WIFI_STA);
wifiMulti.addAP(WIFI_SSID, WIFI_PASSWORD);
Serial.print("Connecting to wifi");
while (wifiMulti.run() != WL_CONNECTED) {
  Serial.print(".");
  delay(500);
}
Serial.println();</k>
Call the initBME() function to initialize the BME280 sensor.
<k>//Init BME280 sensor
initBME();</k>
Add tags to your data using addTag(). We're adding the device name, the name of the sensor, and the location of the sensor. You may add other tags that might be useful for your specific project.
<k>sensorReadings.addTag("device", DEVICE);
sensorReadings.addTag("location", "office");
sensorReadings.addTag("sensor", "bme280");</k>
Synchronize time, which is necessary for certificate validation.
<k>timeSync(TZ_INFO, "pool.ntp.org", "time.nis.gov");</k>
Check the connection to the InfluxDB server and print any error messages in case the connection fails:
<k>// Check server connection
if (client.validateConnection()) {
  Serial.print("Connected to InfluxDB: ");
  Serial.println(client.getServerUrl());
} else {
  Serial.print("InfluxDB connection failed: ");
  Serial.println(client.getLastErrorMessage());
}</k>
<h4>loop()</h4>
In the loop(), we'll send the sensor readings to InfluxDB every 10 seconds.
We get temperature, humidity, and pressure readings:
<k>temperature = bme.readTemperature();
humidity = bme.readHumidity();
pressure = bme.readPressure()/100.0F;</k>
And we add those readings as fields to our point (database data row).
<k>// Add readings as fields to point
sensorReadings.addField("temperature", temperature);
sensorReadings.addField("humidity", humidity);
sensorReadings.addField("pressure", pressure);</k>
Print in the Serial Monitor what we're writing to the point:
<k>Serial.println(client.pointToLineProtocol(sensorReadings));</k>
Finally, to actually add the point to the database, we use the writePoint() method on the InfluxDBClient object and pass as argument the point we want to add: client.writePoint(sensorReadings).
<k>client.writePoint(sensorReadings);</k>
Clear the fields to be ready for usage in the next loop.
<k>sensorReadings.clearFields();</k>
New data is written to the database every 10 seconds.
<k>Serial.println("Wait 10s");
delay(10000);</k>
<h3>DemonstrationVisualizing your Data</h3>
After inserting all the required settings on the code, you can upload it to your ESP32/ESP8266 board. If you get any error during compilation, check the following:
check that you have an ESP32/ESP8266 board selected in <k>Tools </k>> <k>Board</k>.
Check your ESP32/ESP8266 boards installation version in <k>Tools </k>> <k>Board </k>> <k>Boards Manager</k> > <k>ESP8266</k> or <k>ESP32</k>. Select version <k>3.0.1</k> for ESP8266 or version <k>2.01</k> for ESP32 if you're getting issues with other versions.
After uploading the code to your board, open the Serial Monitor at a baud rate of 115200. Press the ESP on-board RESET button to restart the board. It should print something similar on the Serial Monitor:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/InfluxDB-send-sensor-readings-ESP32.png">
Now, go to your InfludDB account and go to the <k>Data Explorer</k> by clicking on the corresponding icon.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/05/influxdb-data-explorer.png">
Now, you can visualize your data. Start by selecting the bucket you want. Then, we need to add filters to select our data. Select the <k>measurement</k> under the <k>_measurement </k>field, the device and the location. Then, you can select the temperature, humidity, or pressure values. You can also select all readings if you want to plot them all on the same chart.
After making the query, click on the SUBMIT button. This will display your data in your chosen format. In the upper left corner, you can select different ways to visualize the data. You can also click on the CUSTOMIZE button to change the color of the series.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/InfluxDB-ESP32-ESP8266-Temperature-Data-Explorer.png">
You can create a dashboard to show multiple data visualizations in different formats (gauges, histogram, single stat, etc.) or different data on the same page. For example, multiple charts to show temperature, humidity, and pressure, and boxes to show the current measurements.
<h3>Creating a Dashboard</h3>
Click on the <k>Dashboard </k>icon.
<a href="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/02/influxdb-dashboard-icon.png?quality=100&strip=all&ssl=1"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/02/influxdb-dashboard-icon.png"></a>
Then on <k>Create Dashboard</k> > <k>New dashboard</k>.
Add a cell. Make the query to get your data and select the visualization you want. Give a name to the cell, for example, <k>Office Temperature(ESP32)</k>. You can also click on the <k>Customize </k>button to customize the graph (we suggest selecting different colors for temperature, humidity, and pressure). Finally, click on the <k><U+2713></k> icon in the top right corner to add the visualization as a cell to your dashboard.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/InfluxDB-ESP32-ESP8266-Temperature-Cell.png">
Repeat the same process for the other readings (humidity, and pressure). You can also add a single stat to show the current values of each reading.
I have the ESP32 and ESP8266 running the same code simultaneously, so I created a dashboard that shows the readings of each board.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/ESP32-ESP8266-Sensor-Readings-Dashboard.png">
You can move your cells to different positions and organize the dashboard in a way that makes sense for you. You can also customize the way the data is refreshed and how many data points you want to see (up to the past 30 days).
<h3>Wrapping Up</h3>
In this tutorial, you learned how to send multiple sensor readings to InfluxDB. InfluxDB adds a timestamp to all data rows (point).
As an example, we used a BME280 sensor, but you can easily modify the example to use any other sensor or add more sensors. You can also run this example on multiple boards to monitor the temperature, humidity, and pressure in different placesdon't forget to add different tags to identify the places or the boards.
<h2>Getting Started with InfluxDB</h2>
This guide will get you started quickly with InfluxDB using the ESP32 board. InfluxDB is an open-source time series database (TSDB). So, it is ideal to store sensor data with timestamps over a determined period of time. In this tutorial, you'll set up an InfluxDB bucket to save data, and you'll learn how to save ESP32 data to the database. InfluxDB also offers different ways to visualize and organize your data (dashboards, charts, tables, gauges, etc).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/ESP32-Getting-Started-with-InfluxDB.jpg">
We have a similar tutorial for the <a href="https://randomnerdtutorials.com/esp8266-nodemcu-influxdb/">ESP8266 NodeMCU board: Getting Started with InfluxDB</a>
<k>Table of Contents</k>
Introducing InfluxDB
Creating an InfluxDB Account
Loading Data in InfluxDB
Interfacing the ESP32 with InfluxDB
Visualizing Data on InfluxDB
<h3>What is InfluxDB?</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/influxdb-logo.png">
InfluxDB is an open-source high-performance time series database (TSDB) that can store large amounts of data per second. Each data point you submit to the database is associated with a particular timestamp. So, it is ideal for IoT datalogging projects like storing data from your weather station sensors.
You can run <a href="https://www.influxdata.com/products/influxdb/" target="_blank">InfluxDB in InfluxDB Cloud</a>, or locally on your laptop or <a href="https://randomnerdtutorials.com/install-influxdb-2-raspberry-pi/">Raspberry Pi</a>.
<blockquote>
<k>Why use InfluxDB Cloud?</k> It's a fast, elastic, serverless real-time monitoring platform, dashboarding engine, analytics service and event and metrics processor.
<cite>https://www.influxdata.com/products/influxdb-cloud/</cite>
</blockquote>
<h3>InfluxDB Key Terms</h3>
Before getting started, there are some important terms you need to understand. We'll just take a look at the most relevant terms, you can read the complete <a href="https://docs.influxdata.com/influxdb/v2.2/reference/glossary/" target="_blank">glossary</a>. Don't worry if some of the terms are confusing. You'll better understand those terms when you start writing to the database.
In InfluDB, a <k>bucket</k> is named location where the time series data is stored. All buckets have a <k>retention period</k>it defines the duration of time that a bucket retains data. Points with timestamps older than the retention period are dropped.
Data in InfluxDB is stored in tables within rows and columns. A set of data in a row is known as <k>point</k> (similar to a row in a SQL database table). Each point has a <k>measurement</k>, a <k>tag set</k>, a <k>field key</k>, a <k>field value</k>, and a <k>timestamp</k>;
Columns store <k>tag sets</k> (indexed) and <k>fields sets</k>. The only required column is <k>time</k>, which stores <k>timestamps </k>and is included in all InfluxDB tables.
<k>tag</k>: the key-value pair in InfluxDB's data structure that records metadata. Tags are an optional part of InfluxDB's data structure but they are useful for storing commonly-queried metadata; tags are indexed so queries on tags are performant.
<k>tag key</k>: tag keys are strings and store metadata. Tag keys are indexed so queries on tag keys are processed quickly.
<k>tag value</k>: tag values are strings and they store metadata. Tag values are indexed so queries on tag values are processed quickly.
<k>field</k>: the key-value pair in InfluxDB's data structure that records metadata and the actual data value. Fields are required in InfluxDB's data structure and they are not indexed  queries on field values scan all points that match the specified time range and, as a result, are not performant relative to tags.
<k>field key</k>: the key of the key-value pair. Field keys are strings and they store metadata.
<k>field value</k>: the value of a key-value pair. Field values are the actual data; they can be strings, floats, integers, or booleans. A field value is always associated with a timestamp. Field values are not indexed  queries on field values scan all points that match the specified time range and, as a result, are not performant.
<k>measurement</k>: the part of InfluxDB's structure that describes the data stored in the associated fields.
We also recommend taking a quick look at the <a href="https://docs.influxdata.com/influxdb/v2.2/reference/key-concepts/" target="_blank">InfluxDB key concepts</a>.
<h3>Creating an InfluxDB Account</h3>
If you want to run InfluxDB locally on a Raspberry Pi, follow the next tutorial first: <a href="https://randomnerdtutorials.com/install-influxdb-2-raspberry-pi/">Install InfluxDB 2 on Raspberry Pi</a>. Then, proceed to the Loading Data in InfluxDB section.
<k>1) </k>Go to <a href="https://cloud2.influxdata.com/signup" target="_blank">https://cloud2.influxdata.com/signup</a> and create an InfluxDB account.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/InfluxDB-create-account.png">
<k>2)</k> Select where you want to save your data. I choose the Google Cloud option, but you can choose one of the other options. Select the region, it should be the closest to your location. Then, enter something on the Company Name field, and agree to the terms before proceeding.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/Influx-DB-Select-Provider.png">
<k>3)</k> Select the InfluxDB plan. For this example, we'll be using the Free plan. For most of our IoT projects, the Free plan works just fine. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/Influx-DB-Select-Plan.png">
<k>4)</k> After selecting the plan, you'll be redirected to the <k>Getting Started</k> page.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/05/InfluxDB-Cloud-Get-Started.png">
<h3>Loading Data in InfluxDB</h3>
<k>5)</k> Click on the<k> Load Data</k> icon and select <k>Sources</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/02/influxdb-sources.png">
<k>6)</k> Scroll down until you find the <k>Arduino </k>option under the <k>Client Libraries</k> section.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/05/influxdb-client-libraries-arduino.png">
Click on Initialize Client.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/05/Arduino-client-Create-Bucket-InfluxDB-cloud.png">
The page that opens allows you to create buckets, and it also shows some sample code to interface the ESP8266 or ESP32 boards with InfluxDB.
<h3>Creating an InfluxDB Bucket</h3>
<k>7)</k> Create a new bucket to store your data. Click on <k>+ Create Bucket</k> to create a new bucket for this example. You can use the settings by default, or you can customize them.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/05/influxdb-creating-bucket.png">
<h3>Getting InfluxDB URL and API Token</h3>
<k>8)</k> Get your InfluxDB URL* and other details you'll need later. Scroll down to the<em> Configure InfluxDB profile</em> snippet. Then, copy the INFLUXDB_URL, INFLUXDB_TOKEN, INFLUXDB_ORG, and INFLUXDB_BUCKET.
<a href="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/02/influxdb-details-arduino-client.png?quality=100&strip=all&ssl=1"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/02/influxdb-details-arduino-client.png"></a>
<k>*</k> if you're running InfluxDB locally on a Raspberry Pi, the URL will be the Raspberry Pi IP address on port 8086. For example 192.168.1.106:8086.
<h3>API Tokens</h3>
If you've followed the previous steps, InfluxDB cloud has already created an API token for you that you could find in the snippet presented in the previous step. If you go to the Load Data icon and select API Tokens, you'll find the previously generated API token. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/05/influxdb-api-token.png">
On this page, you can generate a new API token if needed.
At this moment, you should have saved the following:
InfluxDB Server URL
InfluxDB Organization
InfluxDB Bucket Name
API Token
<hr>
<h3>Interfacing the ESP32 with InfluxDB</h3>
We'll program the ESP32 using Arduino IDe, so make sure you have the ESP32 boards add-on installed:
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing the ESP32 Board in Arduino IDE (Windows, Mac OS X, Linux)</a>
Alternatively, you can use VS Code with the PlatformIO extension. Check the following tutorial to get started with VS Code + PlatformIO:
<a href="https://randomnerdtutorials.com/vs-code-platformio-ide-esp32-esp8266-arduino/">Getting Started with VS Code and PlatformIO IDE for ESP32 and ESP8266</a>
<h3>Install the InfluxDB Arduino Client Library</h3>
There is a library that makes it easy to interface the ESP32 with InfluxDB: the <a href="https://github.com/tobiasschuerg/InfluxDB-Client-for-Arduino" target="_blank">InfluxDB Arduino Client Library</a>. This library is also compatible with ESP8266 boards.
<h4>Installation  Arduino IDE</h4>
If you're using Arduino IDE, follow the next steps to install the library.
<ol>
Go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k>
Search for InfluxDB and install the ESP8266 Influxdb library by Tobias Sh<a8><b9>rg (even though it has ESP8266 in the name, it is also compatible with the ESP32).
</ol>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/Install-Influxdb-Client-Arduino-IDE.png">
<k>Note: </k> we are using ESP32 Boards <k>version 2.0.1</k>. Check your boards version in <k>Tools </k>> <k>Board </k>> <k>Boards Manager</k>. Then, search for <k>ESP32 </k>and upgrade to version 2.0.1 (at the moment there are some issues with version 2.0.2, so don't select that one).
<h4>Installation  VS Code</h4>
If you're using VS Code with the PlatformIO extension, start by creating an Arduino project for your ESP32 board.
Then, click on the <k>PIO Home</k> icon and then select the <k>Libraries tab</k>. Search for <k>influxdb</k>. Select the <k>ESP8266 Influxdb</k> byt Tobias Sch<a8><b9>rg.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/Install-InfluxDB-library-VS-Code.png">
<h3>ESP32 Save Data in InfluxDB</h3>
To show you how to save data to InfluxDB using the ESP32, we'll take a look at one of the examples provided by the library. In your Arduino IDE, go to File > Examples > ESP8266 Infuxdb > Secure Write. Or simply copy the code below to your Arduino IDE.
<k>/**
 * Secure Write Example code for InfluxDBClient library for Arduino
 * Enter WiFi and InfluxDB parameters below
 *
 * Demonstrates connection to any InfluxDB instance accesible via:
 *  - unsecured http://...
 *  - secure https://... (appropriate certificate is required)
 *  - InfluxDB 2 Cloud at https://cloud2.influxdata.com/ (certificate is preconfigured)
 * Measures signal level of the actually connected WiFi network
 * This example demonstrates time handling, secure connection and measurement writing into InfluxDB
 * Data can be immediately seen in a InfluxDB 2 Cloud UI - measurement wifi_status
 * 
 * Complete project details at our blog: https://RandomNerdTutorials.com/
 * 
 **/
#if defined(ESP32)
  #include &lt;WiFiMulti.h>
  WiFiMulti wifiMulti;
#define DEVICE "ESP32"
  #elif defined(ESP8266)
#include &lt;ESP8266WiFiMulti.h>
  ESP8266WiFiMulti wifiMulti;
  #define DEVICE "ESP8266"
#endif
#include &lt;InfluxDbClient.h>
#include &lt;InfluxDbCloud.h>
// WiFi AP SSID
#define WIFI_SSID "REPLACE_WITH_YOUR_SSID"
// WiFi password
#define WIFI_PASSWORD "REPLACE_WITH_YOUR_PASSWORD"
// InfluxDB v2 server url, e.g. https://eu-central-1-1.aws.cloud2.influxdata.com (Use: InfluxDB UI -> Load Data -> Client Libraries)
#define INFLUXDB_URL "REPLACE_WITH_YOUR_DATABASE_URL"
// InfluxDB v2 server or cloud API token (Use: InfluxDB UI -> Data -> API Tokens -> Generate API Token)
#define INFLUXDB_TOKEN "REPLACE_WITH_YOUR_TOKEN"
// InfluxDB v2 organization id (Use: InfluxDB UI -> User -> About -> Common Ids )
#define INFLUXDB_ORG "REPLACE_WITH_YOUR_ORG"
// InfluxDB v2 bucket name (Use: InfluxDB UI ->  Data -> Buckets)
#define INFLUXDB_BUCKET "ESP32"
// Set timezone string according to https://www.gnu.org/software/libc/manual/html_node/TZ-Variable.html
// Examples:
//  Pacific Time: "PST8PDT"
//  Eastern: "EST5EDT"
//  Japanesse: "JST-9"
//  Central Europe: "CET-1CEST,M3.5.0,M10.5.0/3"
#define TZ_INFO "WET0WEST,M3.5.0/1,M10.5.0"
// InfluxDB client instance with preconfigured InfluxCloud certificate
InfluxDBClient client(INFLUXDB_URL, INFLUXDB_ORG, INFLUXDB_BUCKET, INFLUXDB_TOKEN, InfluxDbCloud2CACert);
// InfluxDB client instance without preconfigured InfluxCloud certificate for insecure connection 
//InfluxDBClient client(INFLUXDB_URL, INFLUXDB_ORG, INFLUXDB_BUCKET, INFLUXDB_TOKEN);
// Data point
Point sensor("wifi_status");
void setup() {
  Serial.begin(115200);
  // Setup wifi
  WiFi.mode(WIFI_STA);
  wifiMulti.addAP(WIFI_SSID, WIFI_PASSWORD);
  Serial.print("Connecting to wifi");
  while (wifiMulti.run() != WL_CONNECTED) {
    Serial.print(".");
    delay(500);
  }
  Serial.println();
  // Add tags
  sensor.addTag("device", DEVICE);
  sensor.addTag("SSID", WiFi.SSID());
  // Alternatively, set insecure connection to skip server certificate validation 
  //client.setInsecure();
  // Accurate time is necessary for certificate validation and writing in batches
  // For the fastest time sync find NTP servers in your area: https://www.pool.ntp.org/zone/
  // Syncing progress and the time will be printed to Serial.
  timeSync(TZ_INFO, "pool.ntp.org", "time.nis.gov");
  // Check server connection
  if (client.validateConnection()) {
    Serial.print("Connected to InfluxDB: ");
    Serial.println(client.getServerUrl());
  } else {
    Serial.print("InfluxDB connection failed: ");
    Serial.println(client.getLastErrorMessage());
  }
}
void loop() {
  // Store measured value into point
  sensor.clearFields();
  // Report RSSI of currently connected network
  sensor.addField("rssi", WiFi.RSSI());
  // Print what are we exactly writing
  Serial.print("Writing: ");
  Serial.println(client.pointToLineProtocol(sensor));
  // If no Wifi signal, try to reconnect it
  if (wifiMulti.run() != WL_CONNECTED) {
    Serial.println("Wifi connection lost");
  }
  // Write point
  if (!client.writePoint(sensor)) {
    Serial.print("InfluxDB write failed: ");
    Serial.println(client.getLastErrorMessage());
  }
  //Wait 10s
  Serial.println("Wait 10s");
  delay(10000);
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP/ESP_InfluxDB_SecureWrite.ino" target="_blank">View raw code</a>
Before uploading the code to your board, you need to insert your network credentials, InfludDB URL, organization ID, and bucket name.
This example illustrates how to create a data point on the database with tags and fields. It saves the RSSI of the connected network (Wi-Fi strength between the ESP32 and your router) every 10 seconds.
Let's take a quick look at how the code works.
<h3>How the Code Works</h3>
First, it starts by including the required libraries. In this example, it uses the WiFiMulti instead of the WiFi library to connect the ESP32 to a network. It also defines the DEVICE name depending on the selected board.
<k>#if defined(ESP32)
  #include &lt;WiFiMulti.h>
  WiFiMulti wifiMulti;
  #define DEVICE "ESP32"
#elif defined(ESP8266)
  #include &lt;ESP8266WiFiMulti.h>
  ESP8266WiFiMulti wifiMulti;
  #define DEVICE "ESP8266"
#endif</k>
<k>Note</k>: the WiFiMulti library allows the ESP32 to connect to the network with the best RSSI (received signal strength indicator) among a list of added networks. In this example, it only connects to one network.
Include the required InfluxDB libraries to e able to communicate with InfluxDB:
<k>#include &lt;InfluxDbClient.h>
#include &lt;InfluxDbCloud.h></k>
Insert your network credentials in the following variables so that the ESP32 can connect to the internet:
<k>// WiFi AP SSID
#define WIFI_SSID "REPLACE_WITH_YOUR_SSID"
// WiFi password
#define WIFI_PASSWORD "REPLACE_WITH_YOUR_PASSWORD"</k>
Insert the InfluxDB server URL on the following linesthe one you've gotten in this step:
<k>// InfluxDB v2 server url, e.g. https://eu-central-1-1.aws.cloud2.influxdata.com (Use: InfluxDB UI -> Load Data -> Client Libraries)
#define INFLUXDB_URL "REPLACE_WITH_YOUR_INFLUXDB_URL"</k>
<k>Note: </k> if you're running InfluxDB locally on a Raspberry Pi, the URL will be the Raspberry Pi IP address on port 8086. For example 192.168.1.106:8086.
Insert your InfluxDB tokensaved in this step:
<k>#define INFLUXDB_TOKEN "REPLACE_WITH_YOUR_INFLUXDB_TOKEN"</k>
Add your InfluxDB organization name<a href="http://influxdb-URL">check this step</a>.
<k>#define INFLUXDB_ORG "REPLACE_WITH_YOUR_INFLUXXDB_ORGANIZATION_ID"</k>
Finally, add your InfluxDB bucket name:
<k>#define INFLUXDB_BUCKET "ESP32"</k>
<h3>Setting your Timezone</h3>
You must set your timezone accordingly to <a href="https://www.gnu.org/software/libc/manual/html_node/TZ-Variable.html" target="_blank">these instructions</a>. The easiest way is to <k><a href="https://github.com/nayarsystems/posix_tz_db/blob/master/zones.csv" target="_blank">check this table and copy your timezone from there</a>.</k> In my case, it's Lisbon timezone:
<k>#define TZ_INFO "WET0WEST,M3.5.0/1,M10.5.0"</k>
<h3>InfluxDB Client</h3>
Now that you have all the required settings, you can create an InfluxDBClient instance. We're creating a secure client that uses a preconfigured certificate<a href="https://github.com/tobiasschuerg/InfluxDB-Client-for-Arduino#secure-connection" target="_blank">learn more about secure connection here</a>.
<k>InfluxDBClient client(INFLUXDB_URL, INFLUXDB_ORG, INFLUXDB_BUCKET, INFLUXDB_TOKEN, InfluxDbCloud2CACert);</k>
<h3>Point</h3>
Then, we create a Point instance called sensor. The point will be called wifi_status on the database. Later in the code, we can refer to that point (sensor) to add tags and fields.
<k>Point sensor("wifi_status");</k>
<k>Note: </k> A set of data in a database row is known as <k>point</k>. Each point has a <k>measurement</k>, a <k>tag set</k>, a <k>field key</k>, a <k>field value</k>, and a <k>timestamp</k>.
<h3>setup()</h3>
In the setup(), initialize the Serial Monitor.
<k>Serial.begin(115200);</k>
 Setup and connect to Wi-Fi:
<k>// Setup wifi
WiFi.mode(WIFI_STA);
wifiMulti.addAP(WIFI_SSID, WIFI_PASSWORD);
Serial.print("Connecting to wifi");
while (wifiMulti.run() != WL_CONNECTED) {
  Serial.print(".");
  delay(500);
}
Serial.println();</k>
Then, we add tags to our data. Tags are metadata that allows us to better organize our data. It's also an easier way to query data in a more efficient way later on. In this example, we have the device tag that saves the device name (either ESP32 or ESP8266), and the SSID tag that saves the SSID of the connected network. To add a tag we call the addTag() method to the sensor point. We pass as arguments the tag key and value.
<k>// Add tags
sensor.addTag("device", DEVICE);
sensor.addTag("SSID", WiFi.SSID());</k>
Imagine that you have this example running on multiple boards and each board has a unique device tag. Then, it would be easier to query the data relative to a specific device using the device tag. The same for the SSID of the connected network.
The following lines sync the time with the NTP servers.
<k>timeSync(TZ_INFO, "pool.ntp.org", "time.nis.gov");</k>
The following snippet checks the connection to the InfluxDB server:
<k>if (client.validateConnection()) {
  Serial.print("Connected to InfluxDB: ");
  Serial.println(client.getServerUrl());
} else {
  Serial.print("InfluxDB connection failed: ");
  Serial.println(client.getLastErrorMessage());
}</k>
<h3>loop()</h3>
In the loop(), we add fields (the actual data) to the point. We start by clearing the point fields:
<k>sensor.clearFields();</k>
We add a field to that point, using the addField() method and passing as arguments, the key (rssi) and the actual RSSI value (WiFi.RSSI()).
<k>sensor.addField("rssi", WiFi.RSSI());</k>
Print in the Serial Monitor what we're writing to the point:
<k>Serial.println(client.pointToLineProtocol(sensor));</k>
Finally, to actually add the point to the database, we use the writePoint() method on the InfluxDBClient object and pass as argument the point we want to add: client.writePoint(sensor). We run the command inside an if statement for debugging purposes.
<k>if (!client.writePoint(sensor)) {
  Serial.print("InfluxDB write failed: ");
  Serial.println(client.getLastErrorMessage());
}</k>
We write new data to the database every 10 seconds.
<k>//Wait 10s
Serial.println("Wait 10s");
delay(10000);</k>
<hr>
<h3>Demonstration  Visualizing Data on InfluxDB</h3>
After inserting all the required settings on the code, you can upload it to your ESP32 board. If you get any error during compilation, check the following:
Check that you have an ESP32 board selected in <k>Tools </k>> <k>Board</k>.
Check your ESP32 boards installation version in <k>Tools </k>> <k>Board </k>> <k>Boards Manager</k> > <k>ESP32</k>. Select version <k>2.0.1</k> if you're getting issues with other versions.
After uploading the code to your board, open the Serial Monitor at a baud rate of 115200. Press the ESP32 on-board RST button to restart the board. It should print something similar on the Serial Monitor:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/ESP32-WriteSecure-InfluxDB-Example-Serial-Monitor-Demonstration.png">
Now, go to your InfludDB account and go to the <k>Data Explorer</k> by clicking on the corresponding icon.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/05/influxdb-data-explorer.png">
Now, you can visualize your data. Start by selecting the bucket you wantin our case, it's the ESP32. Then, we need to add filters to select our data. Select the <k>wifi_status</k> under the <k>_measurement </k>field, your <k>SSID </k>under the <k>SSID</k> tag (in this case we just have one SSID, but if we add multiple SSIDs, we could filter the data easily because we added the SSID as a tag). Finally, select the field tag (<k>rrsi</k>) and device (<k>ESP32</k>). 
Finally, click on the <k>SUBMIT </k>button.
This will display your data in your chosen format. In the upper left corner, you can select different ways to visualize the data.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/InfluxDB-ESP32-Data-Explorer.png">
You can create a dashboard to show multiple data visualizations in different formats (gauges, histograms, single stat, etc.) or different data on the same page.
<h3>Creating a Dashboard</h3>
Click on the <k>Dashboard </k>icon.
<a href="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/02/influxdb-dashboard-icon.png?quality=100&strip=all&ssl=1"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/02/influxdb-dashboard-icon.png"></a>
Then on <k>Create Dashboard</k> > <k>New dashboard</k>.
Add a cell. Make the query to get your data and select the visualization you want. Give a name to the cell, for example, <k>ESP32 RSSI History</k>. You can also click on the <k>Customize </k>button to customize the graph. Finally, click on the <k><U+2713></k> icon in the top right corner to add the visualization as a cell to your dashboard.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/ESP32-RSSI-History-InfluxDB-Cell.png">
You can add other visualizations to your dashboard. You just need to add a new cell for each visualization. For example, I added a table and a single stat that shows the current SSID.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/ESP32-WiFi-Connection-Strength-InfluxDB-Dashboard.png">
You can move your cells to different positions and organize the dashboard in a way that makes sense for you. You can also customize the way the data is refreshed and how many data points you want to see (up to the past 30 days on the free cloud plan).
<h3>Wrapping Up</h3>
This was just a quick introduction to InfluxDB with the ESP32. You learned how to create a database bucket and how to create and send points using the ESP32. In this example, we're sending the RSSI. In an IoT application, you can add sensor readings, current consumption, or any other data that makes sense for your IoT and Home Automation projects.
Follow the next tutorial to learn how to <a href="https://randomnerdtutorials.com/esp32-esp8266-sensor-bme280-influxdb/">Send BME280 Sensor Readings to InfluxDB with ESP32/ESP8266 boards</a>.
We hope you liked this tutorial and that it helped you get started with InfluxDB. We'll create more tutorials about this subject soon. So, stay tuned!
<h2>7 Different Ways to Send Notifications with the ESP32</h2>
In this guide, we'll show you seven different ways to send notifications with the ESP32. We'll cover sending SMS, emails, WhatsApp messages, and Telegram messages. We'll show you different options for each notification type.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/ESP32-Send-Notifications.jpg">
<k>Table of Contents</k>
In this tutorial, we'll cover the following notification methods:
<k>Email:</k>
<k>1</k>  ESP32: Send emails using an SMTP server
<k>2</k>  ESP32: Send emails with IFTTT
<k>3</k>  ESP32: Send emails using a PHP server
<k>Telegram:</k>
<k>4</k>  ESP32: Send Telegram messages (using Telegram API)
<k>WhatsApp</k>:
<k>5</k>  ESP32: Send WhatsApp messages (using callmebot API)
<k>SMS:</k>
<k>6</k>  ESP32: Send SMS using a modem (SIM800L and SIM7000G)
<k>7</k>  ESP32: Send SMS using Twilio API
<h3>Send Emails with the ESP32</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2023/01/BME280-Sensor-Readings-Email.jpg">
There are different methods to send emails with the ESP32. 
<k><a href="https://randomnerdtutorials.com/esp32-send-email-smtp-server-arduino-ide/">SMTP Server</a></k>
Our preferred method is using an SMTP server. SMTP means <em>Simple Mail Transfer Protocol</em> and it is an internet standard for email transmission. To send emails using an ESP32, you can connect it to an SMTP Server. 
Check the following tutorial to learn how to send emails with the ESP32 using an SMTP server:
<a href="https://randomnerdtutorials.com/esp32-send-email-smtp-server-arduino-ide/">ESP32 Send Emails using an SMTP Server</a>
We also have a similar tutorial using MicroPython firmware:
<a href="https://randomnerdtutorials.com/micropython-send-emails-esp32-esp826/" title="">MicroPython: Send Emails with the ESP32/ESP826</a>
<k><a href="https://randomnerdtutorials.com/esp32-door-status-monitor-email/">IFTTT (Webhooks and email service)</a></k>
Another alternative method is using IFTTT (If this then that). You can create an applet on IFTTT that will send you an email when you make a request to the webhooks service. If you want to experiment with this method, check the following tutorial:
<a href="https://randomnerdtutorials.com/esp32-door-status-monitor-email/">ESP32: Email Notifications using IFTTT</a>
<k><a href="https://randomnerdtutorials.com/esp32-esp8266-send-email-notification/">PHP Server</a></k>
You can create a PHP server that will send you emails upon an ESP32 request. You can use a cloud server or a local server on a Raspberry Pi, for example. Check the tutorial below:
<a href="https://randomnerdtutorials.com/esp32-esp8266-send-email-notification/">ESP32/ESP8266 Send Email Notification using PHP Script</a>
<hr>
<h3>Send Messages to Telegram with the ESP32</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/telegram-logo.png">
<a href="https://telegram.org/" target="_blank">Telegram</a> Messenger is a cloud-based instant messaging and voice-over IP service. You can easily install it on your smartphone (Android and iPhone) or computer (PC, Mac, and Linux). It is free and without any ads. Telegram allows you to create bots that you can interact with.
<em>Bots are third-party applications that run inside Telegram. Users can interact with bots by sending them messages, commands, and inline requests. You control your bots using HTTPS requests to Telegram Bot API</em>.
So, you just need to make some HTTP requests with the ESP32 to be able to send messages to your Telegram account. The ESP32 can also listen to messages that you send to your bot. So, you can also control your boards by sending messages via Telegram.
We have several tutorials showing how to use the Telegram API for different purposes:
<a href="https://randomnerdtutorials.com/telegram-esp32-motion-detection-arduino/">Telegram: ESP32 <k>Motion Detection with Notifications</k></a>
<a href="https://randomnerdtutorials.com/telegram-control-esp32-esp8266-nodemcu-outputs/">Telegram: <k>Control </k>ESP32 <k>Outputs</k></a>
<a href="https://randomnerdtutorials.com/telegram-group-esp32-esp8266/">Telegram Group: Control ESP32 Outputs</a>
<a href="https://randomnerdtutorials.com/esp32-door-status-telegram/">ESP32 Door Status Monitor with Telegram Notifications</a>
<a href="https://randomnerdtutorials.com/telegram-esp32-cam-photo-arduino/">Telegram: ESP32-CAM Take and <k>Send Photo</k></a>
<hr>
<h3>Send Messages to WhatsApp with the ESP32</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/09/Whatsapp-logo.png">
WhatsApp Messenger, or simply WhatsApp, is an internationally available American freeware, cross-platform centralized instant messaging and voice-over-IP service owned by Meta Platforms. It allows you to send messages using your phone's internet connection, so you can avoid SMS fees.
There are different ways to send messages to WhatsApp using the ESP32. We've experimented with the <a href="https://www.callmebot.com/">callmebot API</a> and it worked pretty well. You can check our tutorial that explains how to send messages to WhatsApp with the ESP32:
<a href="https://randomnerdtutorials.com/esp32-send-messages-whatsapp/">ESP32: Send Messages to WhatsApp</a>
We also have an example using MicroPython firmware:
<a href="https://randomnerdtutorials.com/micropython-whatsapp-esp32-esp826/" title="">MicroPython: Send Messages to WhatsApp with the ESP32/ESP826</a>
<hr>
<h3>Send an SMS with the ESP32</h3>
To send SMS with the ESP32, you can connect it to a modem and use a SIM card or use a third-party service.
There are several modules for the ESP32 that allow you to connect a SIM card. There are also ESP32 development boards that come with a built-in modem like the SIM800L or SIM7000G. To send SMS with these modules, you need a SIM card with an SMS plan or credit.
We have tutorials showing how to send SMS with the ESP32 SIM800L and ESP32 SIM7000G. Check them below:
<a href="https://randomnerdtutorials.com/esp32-sim800l-send-text-messages-sms/">ESP32 SIM800L: Send Text Messages (SMS Alert) with Sensor Readings</a>
<a href="https://randomnerdtutorials.com/lilygo-t-sim7000g-esp32-lte-gprs-gps/">LILYGO T-SIM7000G ESP32: Send SMS</a>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/twilio-logo.png">
Another alternative is to use a third-party service that will send the SMS for you. You just need to make HTTP requests to their API to use their services. We have a tutorial showing how to send SMS with the ESP32 using Twilio services (these are not free, but they provide you with some credit so that you can experiment with the service).
<a href="https://randomnerdtutorials.com/send-sms-esp32-twilio/" title="">Send SMS with the ESP32 (Twilio)</a>
<h3>Wrapping Up</h3>
In this article, we've shown you different ways to send notifications with the ESP32. We've covered sending emails, messages to Telegram, messages to WhatsApp, and SMS.
Sending notifications with the ESP32 is a very useful feature. For example, to send an alert when motion is detected, when a sensor is above or below a certain threshold value, or to send you messages periodically with sensor values or GPIO states.
We hope you've found this compilation useful.
<h2>Send SMS with the ESP32 (Twilio)</h2>
This guide shows how to send SMS with the ESP32 using an online service called Twilio. With this service, you can send SMS with the ESP32 without needing a GSM module or a dedicated physical SIM card. Using Twilio is not free but you can sign up for a free trial for testing purposes. We'll use a free trial account throughout the tutorial.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/ESP32-Send-SMS-Twilio.jpg">
You can send SMS with the ESP32 without the need to rely on third-party services if you have a GSM module and a dedicated SIM card. We have tutorials showing how to send SMS with the ESP32 using the SIM800L and SIM7000G modules:
<a href="https://randomnerdtutorials.com/esp32-sim800l-send-text-messages-sms/">ESP32 SIM800L: Send Text Messages (SMS Alert) with Sensor Readings</a>
<a href="https://randomnerdtutorials.com/lilygo-t-sim7000g-esp32-lte-gprs-gps/">LILYGO T-SIM7000G ESP32: Connect to the Internet, Send SMS, and Get GPS Data</a>
If you're looking for different types of notifications and alerts with the ESP32, you can check the following tutorials:
<a href="https://randomnerdtutorials.com/esp32-send-email-smtp-server-arduino-ide/">How to send <k>emails </k>with the ESP32?</a>
<a href="https://randomnerdtutorials.com/esp32-send-messages-whatsapp/">Send <k>WhatsApp </k>messages with the ESP32</a>
<a href="https://randomnerdtutorials.com/telegram-esp32-motion-detection-arduino/"><k>Telegram</k>: ESP32 Motion Detection with Notifications (Arduino IDE)</a>
<h3>Introducing Twilio</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/twilio-logo.png">
Twilio provides programmable communication tools for making and receiving phone calls, sending and receiving text messages, and performing other communication functions using its web service APIs. Throughout this tutorial, we'll use their programmable messaging services.
Twilio is a paid service, but you can sign-up for a free account for testing purposes. Then, if their services are useful for your specific project, you can always upgrade your account later on. We'll use a free trial account throughout this tutorial.
<h3>Creating a Free Trial Account</h3>
Go to <a href="https://www.twilio.com/" target="_blank" rel="noopener">https://www.twilio.com/</a> and click on <k>Sign up and start building</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/Twilio-home-page.png">
Enter your details and get started with a free trial.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/Twilio-start-free-trial.png">
<h3>Set Up the Free Twilio Trial Account</h3>
There are some steps you need to follow to set up your free Twilio trial account. We'll describe the steps you need to follow in the present tutorial. You can also check <a href="https://www.twilio.com/docs/usage/tutorials/how-to-use-your-free-trial-account" target="_blank" rel="noopener">Twilio's official instructions here</a>.
<h3>Verify your personal phone number</h3>
When you sign up for your free trial account, you verified your personal phone number. It should be on the <a href="https://console.twilio.com/us1/develop/phone-numbers/manage/verified" target="_blank" rel="noopener">list of verified phone numbers</a> on your dashboard: <k>Phone Numbers</k> > <k>Manage </k>> <k>Verified Caller IDs</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/twilio-verified-personal-number.jpg">
<h3>Verify other recipient numbers</h3>
When using the free trial account, you must verify all numbers that you'll want to send an SMS. When verifying the numbers, you'll get an SMS with a verification code that you need to insert. So, you need to have physical access to those numbers. This is not needed on the paid account.
On that previous menu (<k>Phone Numbers</k> > <k>Manage </k>> <k>Verified Caller IDs</k>), click on <k>Add new Called ID</k> to add a new verified number. You'll receive an SMS with a verification code on that number.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/twilio-verified-caller-ids.png">
<h3>Get a Twilio Phone Number</h3>
To send messages using Twilio, you'll need to purchase a Twilio phone number. At the time of writing this tutorial, when I signed up for the free account, I got a $15.50 credit, which is enough to get a phone number and test sending some SMS.
On your dashboard, on the left sidebar, go to <k>Phone Numbers</k> > <k>Manage </k>> <k>Buy a number</k>. You'll see a list of available numbers. Make sure you select SMS on the number capabilities. You can also select the country. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/buy-twilio-number.png">
<k>Note: </k> I tried purchasing a number from my country (Portugal), but I needed to fill out a regulatory bundle and submit some documents for review. So I ended up buying a card from the US instead, which didn't require any of that and was ten times cheaper. This works for testing purposes, once you decide to move for a more permanent solution, double-check if that number is the most suitable for your case scenario.
Once you've chosen a phone number click on the <k>Buy</k> button.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/twilio-buy-us-phone-number.png">
<h3>Programmable Messaging  Get Set Up</h3>
Now, you have everything set up to start creating a programmable messaging service. On your dashboard, on the left sidebar click on <k>Messaging </k>> <k>Try it out</k> > <k>Get Set Up</k>. Then, click on <k>Start set up</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/twilio-programmable-messaging.png">
Give a name to the Messaging Service, for example, <em>ESP32 Alerts</em> and click on <k>Create Messaging Service</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/twilio-create-messaging-service-1.png">
Then, select the Twilio phone number you created previously and click on <k>Add this number</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/create-messaging-service-2.png">
After that, the programmable messaging service will be all set up. You'll get access to your account information: account SID and Auth token. You'll need them later in the ESP32 code.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/twilio-create-messaging-service.png">
You can test if everything is working as expected by clicking on <k>Try SMS</k>. You'll see a similar page as shown below. Enter the phone number you want to send the message to (it must be a verified numbersee this previous section), select the messaging service you created previously, and write some body text and click on <k>Send test SMS</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/twilio-try-test-sms.png">
After a few seconds, you should receive the test SMS on the selected number.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/SMS-from-twilio-trial.png">
All SMS sent from a Twilio trial account will have the text: Sent from your Twilio trial account. This text doesn't show up on premium accounts.
<h3>ESP32: Send SMS using Twilio</h3>
Sending SMS using Twilio is very straightforward thanks to its API. You can <a href="https://www.twilio.com/docs/sms/api" target="_blank" rel="noopener">read the SMS API documentation</a>. You simply make HTTP requests with the ESP32 with the right parameters (accordingly to Twilio's API) to send SMS. You can check <a href="https://randomnerdtutorials.com/esp32-http-get-post-arduino/">this tutorial about HTTP requests with the ESP32</a>.
Or you can use a library that takes care of all that, and you just need to insert your Twilio account details and the SMS body text. Throughout this tutorial, we'll use a library called <a href="https://github.com/ademuri/twilio-esp32-client" target="_blank" rel="noopener">twilio-esp32-client</a>.
<h3>Installing the twilio-esp32-client Library</h3>
The twilio-esp32-client library can be installed through the Arduino IDE Library Manager. Go to <k>Sketch </k>> <k>Include Library </k>> <k>Manage Libraries</k>. Search for <k>twilio-esp32-client</k> and install the library.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/twilio-esp32-client-library.png">
<h3>ESP32 Send SMS using Twilio  Code</h3>
Sending code using Twilio using the <k>twilio-esp32-client</k> library is very straightforward. First, you need to create a Twilio instance, and then you just need to call the send_message() method and pass as arguments your Twilio account details, sender and recipient numbers, and the message body. The following code is an example from the library's <em>examples </em>folder.
<k>/*********
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/send-sms-esp32-twilio/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files.  
  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
*********/
// Library example: https://github.com/ademuri/twilio-esp32-client
#include "twilio.hpp"
// Set these - but DON'T push them to GitHub!
static const char *ssid = "REPLACE_WITH_YOUR_SSID";
static const char *password = "REPLACE_WITH_YOUR_PASSWORD";
// Values from Twilio (find them on the dashboard)
static const char *account_sid = "REPLACE_WITH_YOUR_ACCOUNT_SID";
static const char *auth_token = "REPLACE_WITH_YOUR_ACCOUNT_AUTH_TOKEN";
// Phone number should start with "+&lt;countrycode>"
static const char *from_number = "REPLACE_WITH_TWILIO_NUMBER";
// You choose!
// Phone number should start with "+&lt;countrycode>"
static const char *to_number = "REPLACE_WITH_RECIPIENT_NUMBER";
static const char *message = "Hello from my ESP32 (via twilio)";
Twilio *twilio;
void setup() {
  Serial.begin(115200);
  Serial.print("Connecting to WiFi network ;");
  Serial.print(ssid);
  Serial.println("'...");
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    Serial.println("Connecting...");
    delay(500);
  }
  Serial.println("Connected!");
  twilio = new Twilio(account_sid, auth_token);
  delay(1000);
  String response;
  bool success = twilio->send_message(to_number, from_number, message, response);
  if (success) {
    Serial.println("Sent message successfully!");
  } else {
    Serial.println(response);
  }
}
void loop() {
  
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_Send_SMS_Twilio.ino" target="_blank">View raw code</a>
<h3>How the Code Works</h3>
Start by including the twilio-esp32-client library.
<k>#include "twilio.hpp"</k>
Insert your network credentials on the following lines:
<k>static const char *ssid = "REPLACE_WITH_YOUR_SSID";
static const char *password = "REPLACE_WITH_YOUR_PASSWORD";</k>
Insert your Twilio account details: the account SID and token, and the Twilio phone number. 
<k>static const char *account_sid = "REPLACE_WITH_YOUR_ACCOUNT_SSID";
static const char *auth_token = "REPLACE_WITH_YOUR_ACCOUNT_AUTH_TOKEN";
// Phone number should start with "+&lt;countrycode>"
static const char *from_number = "REPLACE_WITH_TWILIO_PHONE_NUMBER";</k>
Insert the recipient number and the message.
<k>// Phone number should start with "+&lt;countrycode>"
static const char *to_number = "INSERT_RECIPIENT_NUMBER";
static const char *message = "Hello from my ESP32 (via twilio)";</k>
If you're using a free trial account, the recipient number must be on the list of the Verified caller IDs.
Create a Twilio pointer variable called twilio.
<k>Twilio *twilio;</k>
In the setup(), initialize the Serial Monitor and connect the ESP32 to your local network so that it can get access to the internet and make the HTTP requests to send SMS.
<k>  Serial.begin(115200);
  Serial.print("Connecting to WiFi network ;");
  Serial.print(ssid);
  Serial.println("'...");
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    Serial.println("Connecting...");
    delay(500);
  }
  Serial.println("Connected!");</k>
The following line instantiates a new Twilio instance with the account details:
<k> twilio = new Twilio(account_sid, auth_token);</k>
Then call the send_message() function that accepts as arguments the recipient number, the sender number, the message, and a variable to hold the response. This function makes an HTTP request in the background with all the necessary parameters to Twilio API to send SMS.
<k>  String response;
  bool success = twilio->send_message(to_number, from_number, message, response);
  if (success) {
    Serial.println("Sent message successfully!");
  } else {
    Serial.println(response);
  }
}</k>
This function will return true if the message is successfully sent or the response of the HTTP request in case it fails.
Sending an SMS is not free and it will be deducted from the credit on your Twilio account. So, we're just sending one SMS on the setup() when the board starts. The idea is to apply this sample code to your own project.
The loop() is empty.
<k>void loop() {
}</k>
<h3>Demonstration</h3>
After inserting all the required details, you can upload the code to your ESP32 board. Select an ESP32 board in <k>Tools</k> > <k>Board </k>and select the COM port in <k>Tools </k>> <k>Port</k>. Then, click on the Upload button.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/05/arduino-2-0-upload-button.png">
After uploading, open the Serial Monitor at a baud rate of 115200. Press the ESP32 RST button to restart the board. If everything goes as expected, you should receive a similar message as shown below.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/ESP32-send-sms-via-twilio-Serial-Monitor-demonstration.png">
After a few seconds, you should receive an SMS from Twilio on your phone.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/Twilio-SMS-ESP32.png">
<h3>Wrapping Up</h3>
In this tutorial, you learned how to send SMS with the ESP32 using Twilio programmable messaging API. The advantage of using this method is that you don't need to have a modem or a physical SIM card to send SMS with your board.
However, you need to buy a Twilio phone number, and you'll need to pay a monthly subscription for the card. You'll also need to pay for each SMS you send. You can sign up for a free trial account that gives you credit to experiment with Twilio in your projectsso, you can try their services for a while for free. If you feel their service is the right for your projects, then you can update your account later on.
You can also send SMS with the ESP32 using other methodsusing modems like the SIM800L, SIM7000G, and others. We have tutorials showing how to send SMS with the ESP32 using the SIM800L and SIM7000G modules:
<a href="https://randomnerdtutorials.com/esp32-sim800l-send-text-messages-sms/">ESP32 SIM800L: Send Text Messages (SMS Alert) with Sensor Readings</a>
<a href="https://randomnerdtutorials.com/lilygo-t-sim7000g-esp32-lte-gprs-gps/">LILYGO T-SIM7000G ESP32: Connect to the Internet, Send SMS, and Get GPS Data</a>
We hope you find this tutorial useful.
Thanks for reading.
<center><a href="https://randomnerdtutorials.com/pcbway" target="_blank"><img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/2022/03/728x280.jpg" width="728" height="280" loading="lazy" fetchpriority="low"></a></center>
<a href="https://randomnerdtutorials.com/smart-home-ebook/">
<img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/elementor/thumbs/Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px-pupj8i6e7hlzpgwxe82jjd8skst9vmrjt9lpqb0v0g.jpg" title="Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px" alt="SMART HOME with Raspberry Pi ESP32 and ESP8266 Node-RED InfluxDB eBook" loading="lazy" width="117" height="180" fetchpriority="low"></a>
<h4><a href="https://randomnerdtutorials.com/smart-home-ebook/">SMART HOME with Raspberry Pi, ESP32, ESP8266 [eBook] </a></h4>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
<h2>HTTPS Requests (Arduino IDE)</h2>
In this guide, you'll learn how to make HTTPS requests with the ESP32. We'll introduce you to some HTTPS fundamental concepts and provide several examples (with and without certificates) using two different libraries: HttpClient and WiFiClientSecure.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/ESP32-HTTPS-Requests.jpg">
Using an ESP8266 board? <a href="https://randomnerdtutorials.com/esp8266-nodemcu-https-requests/" title="">Check this tutorial instead: ESP8266 NodeMCU HTTPS Requests</a>
<k>Table of Contents</k>
Throughout this article, we'll cover the following subjects:
What is HTTPS?
Why do you need HTTPS with the ESP32?
SSL/TLS Certificates
Certificate Chain
Certificates Expiration Date
Getting a Server's Certificate using Google Chrome
HTTPS Requests with the ESP32 (WiFiClientSecure)
ESP32 HTTPS Requests with Certificate
ESP32 HTTPS Requests without Certificate
HTTPS Requests with the ESP32 (HTTPClient)
ESP32 HTTPS Requests with Certificate
ESP32 HTTPS Requests without Certificate
<h3>Introduction</h3>
To understand how to make HTTPS requests with the ESP32, it's better to be familiar with some fundamental concepts that we'll explain next. We also recommend taking a look at the following article:
<a href="https://randomnerdtutorials.com/esp32-esp8266-https-ssl-tls/">ESP32/ESP8266 with HTTPS and SSL/TLS Encryption: Basic Concepts</a>
<h3>What is HTTPS?</h3>
HTTPS is the secure version of the HTTP protocol, hence the S, which stands for secure.
HTTP is a protocol to transfer data over the internet. When that data is encrypted with SSL/TLS, it's called HTTPS.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/HTTP-vs-HTTPS.png">
To simplify, HTTPS is just the HTTP protocol but with encrypted data using SSL/TLS.
<h3>Why do you need HTTPS with the ESP32?</h3>
Using HTTPS ensures the following:
<k>1) Encryption</k>: all traffic between the ESP32 and a server will be encryptedno one can spy on your requests and passwords, they will only see gibberish.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/ESP32-HTTPS-Requests-encryption.png">
When using the ESP32 libraries to make HTTPS requests, they take care of encryption and decryption of the messages.
<k>2) Server trust (identification):</k> when using HTTPS, via TLS/SSL certificates, you ensure you are connected to the server you would expectthis means, you always know to who you are connected to.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/SSL-TLS-certificate_SSL-certificate.png">
To make sure we are connected to the right server, we need to check the server certificate on the ESP32. This means we need to download the server certificate and hard code it on our sketch so that we can check if we're actually connected to the server we are expecting.
<h3>TLS/SSL Certificates</h3>
SSL certificates are issued by legitimate <k>Certificate Authorities</k>. One of the most known is LetsEncrypt. Certificate Authorities confirm the identity of the certificate owner and provide proof that the certificate is valid. The certificate also contains the server's public key for asymmetrically encrypted communication with a client.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/TLS-SSL-Certificate-Public-Key.png">
When a Certificate Authority issues a certificate, it signs the certificate with its root certificate. This root certificate should be on the database of trusted certificates called a <k>root store</k>. Your browser and the operating system contain a database of root certificates that they can trust (root store). The following screenshot shows some of the trusted root certificates.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/trusted-root-certificates.png">
So, when you connect to a website using your browser, it checks if its certificate was signed by a root certificate that belongs to its root store. New root certificates are added or deleted to the root store with each browser update.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/HTTPS-browser-valid-certificate.png">
When you're using an ESP32, you need to upload the certificates that you trust to your board. Usually, you'll add only the certificate for the server you'll want to connect to. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/ESP32-check-server-certificate.png">
But, it's also possible to upload a root store to your board to have more options, and don't have to worry about searching for a specific website's certificate.
<h3>Certificate Chain</h3>
An SSL certificate is part of an SSL certificate chain. <k>What is a certificate chain?</k>
A certificate chain includes the following:
root certificate (from a Certificate Authority);
one or more intermediate certificates;
the server certificate.
The server certificate is what makes your browser show a secure padlock icon when you visit a website. It means the server has a <k>valid</k> SSL/TLS certificate and all the connections with the website are encrypted. A valid SSL/TLS certificate is a certificate trusted by your browser. What makes it trustable?
As we've mentioned previously, SSL/TLS certificates are issued by Certificate Authorities. However, these authorities don't issue certificates directly to websites. They use intermediates that will issue the server certificate (<k>Certificate Authority</k> > <k>Intermediate certificate</k> > <k>server certificate</k>). The following screenshot shows an example for the Github website. You can see the certificate hierarchy highlighted with a red rectangle.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/certificate-hierarchy-github.png">
Your browser checks this certificate chain until it finds the root certificate. If that certificate is in the browser's root store, then it considers the certificate to be valid. In this case, the DigiCert Global Root CA is in the browser's root store. So, it will display the secure icon on the browser bar.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/github-secure-icon.png">
The following diagram shows a high-level overview of how it works.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/12/certificate-chain-f_certificate-chain.png">
<k>In summary:</k>
<k>root certificate</k>: it's a self-signed certificate issued by a Certificate Authority. The private key of this certificate is used to sign the next certificate in the hierarchy of certificates. Root certificates are loaded in the trust stores of browsers and operating systems.
<k>intermediate certificate</k>: it's signed by the private key of the root certificate. The private key of the intermediate certificate is the one that signs the server certificate. There can be more than one intermediate certificate.
<k>server certificate</k>: this certificate is issued to a specific domain name on a server. It's signed by the intermediate certificate private key. If it is valid (trustable certificate chain), the browser displays a secure padlock badge on the search bar next to the website domain.
With the ESP32, to check the validity of a server, you can load any of those certificates: root, intermediate, or server certificate.
<h3>Certificates Expiration Date</h3>
SSL/TLS certificates have an expiry date. You can check on a browser the expiry date of the certificate for a particular server. The server's certificate usually has a short-term validity.
So, if you want to use it in your ESP32 projects, you'll need to update your code quite frequently. If you want your code to run for years without worrying, you can use the website's root certificate, which usually has a validity of five to ten years or more.
<h3>Getting a Server's Certificate</h3>
There are different ways to get the server's certificate. One of the easiest ways is to download the certificate directly from your browser. You can also use <a href="https://www.openssl.org/" target="_blank" rel="noopener">OpenSSL </a>and get all the certificate information you need using the command line (we won't cover this method in this tutorial). 
In this section, you'll learn how to get the server's certificate. We'll generally use the root certificate, but you can use any of the other certificates on the certificate chainyou just need to be aware of the certificate expiry date.
<h3>Getting a Server's Certificate using Google Chrome</h3>
In this section, we'll show you how to get the certificate for a server using Google Chrome (that's the web browser we use more often). Instructions for other web browsers should be similar.
One of the examples we'll use later is to make an HTTPS request to the howmyssl.com website. So, for demonstration purposes, we'll show you how to get its root certificate. It is similar for other websites.
<k>How to Get Websites's Certificate using Google Chrome?</k>
<ol>
Go to the website that you want to get the certificate for.
</ol>
<ol start="2">Click on the padlock icon and then click on <k>Show connection details</k>.</ol>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/google-chrome-get-website-certificate-1.png">
<ol start="3">Then, click on <k>Show certificate</k>.</ol>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/google-chrome-get-website-certificate-2.png">
<ol start="4">A new window will open the all the information about the website's certificate. Click on the Details tab, make sure you select the root certificate (that's what we're looking for in this example), then click on <k>Export</k>
</ol>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/google-chrome-get-website-certificate-3.png">
<ol start="5">Select a place on your computer to save the certificate. Save it on the default format: Base64-encoded ASCII, single certificate (*.pem, .crt).  And that's it. </ol>
You can double-click on the certificate to check it's details, including the expiration date.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/certificate-information.png">
Open the certificate using Notepad or other similar software. You should get something similar as shown below.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/root-certificate-notepad.png">
We need to convert this to Arduino multi-line string, so that we can use it in our sketch. Basically, you need to add a  at the beginning of each line and a \n \ at the end of each line, except the last line that you should add \n. So, you'll get something as shown below: 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/certificate-multiline-string.png">
<h3>HTTPS Requests with the ESP32</h3>
Now that you know all the major important aspects of certificates and how to get a server's certificate, let's finally take a look at how to make HTTPS requests on the ESP32 using the Arduino core. We'll cover different methods using two different libraries: WiFiClientSecure and HTTPClient.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/ESP32-HTTPS-Requests.png">
<h3>ESP32 HTTPS Requests using WiFiClientSecure Library</h3>
You can find a simple example showing how to make HTTPS requests with the WiFiClientSecure library on your Arduino IDE.
<h3>ESP32 HTTPS Requests with Certificate</h3>
Make sure you have an ESP32 board selected in <k>Tools </k>> <k>Board</k>. Then, go to <k>File </k>> <k>Examples</k> > <k>WiFiClientSecure </k>> <k>WiFiClientSecure</k>.
You can modify the following code with the certificate we got from the previous steps, which is valid until 2035.
<k>/*
  Complete project details: https://RandomNerdTutorials.com/esp32-https-requests/
  
  Wifi secure connection example for ESP32 - Running on TLS 1.2 using mbedTLS
  Suporting the following chipersuites:
  "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384","TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384","TLS_DHE_RSA_WITH_AES_256_GCM_SHA384","TLS_ECDHE_ECDSA_WITH_AES_256_CCM","TLS_DHE_RSA_WITH_AES_256_CCM","TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384","TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384","TLS_DHE_RSA_WITH_AES_256_CBC_SHA256","TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA","TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA","TLS_DHE_RSA_WITH_AES_256_CBC_SHA","TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8","TLS_DHE_RSA_WITH_AES_256_CCM_8","TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384","TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384","TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384","TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384","TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384","TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256","TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA","TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256","TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256","TLS_DHE_RSA_WITH_AES_128_GCM_SHA256","TLS_ECDHE_ECDSA_WITH_AES_128_CCM","TLS_DHE_RSA_WITH_AES_128_CCM","TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256","TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256","TLS_DHE_RSA_WITH_AES_128_CBC_SHA256","TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA","TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA","TLS_DHE_RSA_WITH_AES_128_CBC_SHA","TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8","TLS_DHE_RSA_WITH_AES_128_CCM_8","TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256","TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256","TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256","TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256","TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256","TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256","TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA","TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA","TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA","TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA","TLS_DHE_PSK_WITH_AES_256_GCM_SHA384","TLS_DHE_PSK_WITH_AES_256_CCM","TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384","TLS_DHE_PSK_WITH_AES_256_CBC_SHA384","TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA","TLS_DHE_PSK_WITH_AES_256_CBC_SHA","TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384","TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384","TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384","TLS_PSK_DHE_WITH_AES_256_CCM_8","TLS_DHE_PSK_WITH_AES_128_GCM_SHA256","TLS_DHE_PSK_WITH_AES_128_CCM","TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256","TLS_DHE_PSK_WITH_AES_128_CBC_SHA256","TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA","TLS_DHE_PSK_WITH_AES_128_CBC_SHA","TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256","TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256","TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256","TLS_PSK_DHE_WITH_AES_128_CCM_8","TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA","TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA","TLS_RSA_WITH_AES_256_GCM_SHA384","TLS_RSA_WITH_AES_256_CCM","TLS_RSA_WITH_AES_256_CBC_SHA256","TLS_RSA_WITH_AES_256_CBC_SHA","TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384","TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384","TLS_ECDH_RSA_WITH_AES_256_CBC_SHA","TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384","TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384","TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA","TLS_RSA_WITH_AES_256_CCM_8","TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384","TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256","TLS_RSA_WITH_CAMELLIA_256_CBC_SHA","TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384","TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384","TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384","TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384","TLS_RSA_WITH_AES_128_GCM_SHA256","TLS_RSA_WITH_AES_128_CCM","TLS_RSA_WITH_AES_128_CBC_SHA256","TLS_RSA_WITH_AES_128_CBC_SHA","TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256","TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256","TLS_ECDH_RSA_WITH_AES_128_CBC_SHA","TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256","TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256","TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA","TLS_RSA_WITH_AES_128_CCM_8","TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256","TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256","TLS_RSA_WITH_CAMELLIA_128_CBC_SHA","TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256","TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256","TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256","TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256","TLS_RSA_WITH_3DES_EDE_CBC_SHA","TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA","TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA","TLS_RSA_PSK_WITH_AES_256_GCM_SHA384","TLS_RSA_PSK_WITH_AES_256_CBC_SHA384","TLS_RSA_PSK_WITH_AES_256_CBC_SHA","TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384","TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384","TLS_RSA_PSK_WITH_AES_128_GCM_SHA256","TLS_RSA_PSK_WITH_AES_128_CBC_SHA256","TLS_RSA_PSK_WITH_AES_128_CBC_SHA","TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256","TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256","TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA","TLS_PSK_WITH_AES_256_GCM_SHA384","TLS_PSK_WITH_AES_256_CCM","TLS_PSK_WITH_AES_256_CBC_SHA384","TLS_PSK_WITH_AES_256_CBC_SHA","TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384","TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384","TLS_PSK_WITH_AES_256_CCM_8","TLS_PSK_WITH_AES_128_GCM_SHA256","TLS_PSK_WITH_AES_128_CCM","TLS_PSK_WITH_AES_128_CBC_SHA256","TLS_PSK_WITH_AES_128_CBC_SHA","TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256","TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256","TLS_PSK_WITH_AES_128_CCM_8","TLS_PSK_WITH_3DES_EDE_CBC_SHA","TLS_EMPTY_RENEGOTIATION_INFO_SCSV"]
  2017 - Evandro Copercini - Apache 2.0 License.
*/
#include &lt;WiFiClientSecure.h>
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
const char*  server = "www.howsmyssl.com";  // Server URL
// www.howsmyssl.com root certificate authority, to verify the server
// change it to your server root CA
// SHA1 fingerprint is broken now!
const char* test_root_ca= \
  "-----BEGIN CERTIFICATE-----\n" \
  "MIIFazCCA1OgAwIBAgIRAIIQz7DSQONZRGPgu2OCiwAwDQYJKoZIhvcNAQELBQAw\n" \
  "TzELMAkGA1UEBhMCVVMxKTAnBgNVBAoTIEludGVybmV0IFNlY3VyaXR5IFJlc2Vh\n" \
  "cmNoIEdyb3VwMRUwEwYDVQQDEwxJU1JHIFJvb3QgWDEwHhcNMTUwNjA0MTEwNDM4\n" \
  "WhcNMzUwNjA0MTEwNDM4WjBPMQswCQYDVQQGEwJVUzEpMCcGA1UEChMgSW50ZXJu\n" \
  "ZXQgU2VjdXJpdHkgUmVzZWFyY2ggR3JvdXAxFTATBgNVBAMTDElTUkcgUm9vdCBY\n" \
  "MTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAK3oJHP0FDfzm54rVygc\n" \
  "h77ct984kIxuPOZXoHj3dcKi/vVqbvYATyjb3miGbESTtrFj/RQSa78f0uoxmyF+\n" \
  "0TM8ukj13Xnfs7j/EvEhmkvBioZxaUpmZmyPfjxwv60pIgbz5MDmgK7iS4+3mX6U\n" \
  "A5/TR5d8mUgjU+g4rk8Kb4Mu0UlXjIB0ttov0DiNewNwIRt18jA8+o+u3dpjq+sW\n" \
  "T8KOEUt+zwvo/7V3LvSye0rgTBIlDHCNAymg4VMk7BPZ7hm/ELNKjD+Jo2FR3qyH\n" \
  "B5T0Y3HsLuJvW5iB4YlcNHlsdu87kGJ55tukmi8mxdAQ4Q7e2RCOFvu396j3x+UC\n" \
  "B5iPNgiV5+I3lg02dZ77DnKxHZu8A/lJBdiB3QW0KtZB6awBdpUKD9jf1b0SHzUv\n" \
  "KBds0pjBqAlkd25HN7rOrFleaJ1/ctaJxQZBKT5ZPt0m9STJEadao0xAH0ahmbWn\n" \
  "OlFuhjuefXKnEgV4We0+UXgVCwOPjdAvBbI+e0ocS3MFEvzG6uBQE3xDk3SzynTn\n" \
  "jh8BCNAw1FtxNrQHusEwMFxIt4I7mKZ9YIqioymCzLq9gwQbooMDQaHWBfEbwrbw\n" \
  "qHyGO0aoSCqI3Haadr8faqU9GY/rOPNk3sgrDQoo//fb4hVC1CLQJ13hef4Y53CI\n" \
  "rU7m2Ys6xt0nUW7/vGT1M0NPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNV\n" \
  "HRMBAf8EBTADAQH/MB0GA1UdDgQWBBR5tFnme7bl5AFzgAiIyBpY9umbbjANBgkq\n" \
  "hkiG9w0BAQsFAAOCAgEAVR9YqbyyqFDQDLHYGmkgJykIrGF1XIpu+ILlaS/V9lZL\n" \
  "ubhzEFnTIZd+50xx+7LSYK05qAvqFyFWhfFQDlnrzuBZ6brJFe+GnY+EgPbk6ZGQ\n" \
  "3BebYhtF8GaV0nxvwuo77x/Py9auJ/GpsMiu/X1+mvoiBOv/2X/qkSsisRcOj/KK\n" \
  "NFtY2PwByVS5uCbMiogziUwthDyC3+6WVwW6LLv3xLfHTjuCvjHIInNzktHCgKQ5\n" \
  "ORAzI4JMPJ+GslWYHb4phowim57iaztXOoJwTdwJx4nLCgdNbOhdjsnvzqvHu7Ur\n" \
  "TkXWStAmzOVyyghqpZXjFaH3pO3JLF+l+/+sKAIuvtd7u+Nxe5AW0wdeRlN8NwdC\n" \
  "jNPElpzVmbUq4JUagEiuTDkHzsxHpFKVK7q4+63SM1N95R1NbdWhscdCb+ZAJzVc\n" \
  "oyi3B43njTOQ5yOf+1CceWxG1bQVs5ZufpsMljq4Ui0/1lvh+wjChP4kqKOJ2qxq\n" \
  "4RgqsahDYVvTH9w7jXbyLeiNdd8XM2w9U/t7y0Ff/9yi0GE44Za4rF2LN9d11TPA\n" \
  "mRGunUHBcnWEvgJBQl9nJEiU0Zsnvgc/ubhPgXRR4Xq37Z0j4r7g1SgEEzwxA57d\n" \
  "emyPxgcYxn/eR44/KJ4EBs+lVDR3veyJm+kXQ99b21/+jh5Xos1AnX5iItreGCc=\n" \
  "-----END CERTIFICATE-----\n"; 
// You can use x.509 client certificates if you want
//const char* test_client_key = "";   //to verify the client
//const char* test_client_cert = "";  //to verify the client
WiFiClientSecure client;
void setup() {
  //Initialize serial and wait for port to open:
  Serial.begin(115200);
  delay(100);
  Serial.print("Attempting to connect to SSID: ");
  Serial.println(ssid);
  WiFi.begin(ssid, password);
  // attempt to connect to Wifi network:
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print(".");
    // wait 1 second for re-trying
    delay(1000);
  }
  Serial.print("Connected to ");
  Serial.println(ssid);
  client.setCACert(test_root_ca);
  //client.setCertificate(test_client_cert); // for client verification
  //client.setPrivateKey(test_client_key);// for client verification
  Serial.println("\nStarting connection to server...");
  if (!client.connect(server, 443))
    Serial.println("Connection failed!");
  else {
    Serial.println("Connected to server!");
    // Make a HTTP request:
    client.println("GET https://www.howsmyssl.com/a/check HTTP/1.0");
    client.println("Host: www.howsmyssl.com");
    client.println("Connection: close");
    client.println();
    while (client.connected()) {
      String line = client.readStringUntil('\n');
      if (line == "\r") {
        Serial.println("headers received");
        break;
      }
    }
    // if there are incoming bytes available
    // from the server, read them and print them:
    while (client.available()) {
      char c = client.read();
      Serial.write(c);
    }
    client.stop();
  }
}
void loop() {
  // do nothing
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_HTTPS/ESP32_WiFiClientSecure_Certificate/ESP32_WiFiClientSecure_Certificate.ino" target="_blank">View raw code</a>
This example establishes a secure connection with the www.howsmyssl.com website and checks its certificate to ensure we're connected to the server that we expect.
If you're used to making HTTP requests with the ESP32 using the WiFiClient library, this example is not much different.
<h4>How does the Code Work?</h4>
You need to include the WiFiClientSecure library.
<k>#include &lt;WiFiClientSecure.h></k>
Insert your network credentials in the following lines.
<k>const char* ssid     = "REPLACE_WITH_YOUR_SSID";     // your network SSID (name of wifi network)
const char* password = "REPLACE_WITH_YOUR_PASSWORD"; // your network password</k>
Insert the server URL. In this case, we'll make a request to www.howsmyssl.com. This website will return how good the SSL of the client is (in this case, the ESP32).
<k>const char*  server = "www.howsmyssl.com";  // Server URL</k>
Then, you need to insert the server certificate. We're using the root certificate.
<k>const char* test_root_ca= \
     "-----BEGIN CERTIFICATE-----\n" \
     "MIIFazCCA1OgAwIBAgIRAIIQz7DSQONZRGPgu2OCiwAwDQYJKoZIhvcNAQELBQAw\n" \
     "TzELMAkGA1UEBhMCVVMxKTAnBgNVBAoTIEludGVybmV0IFNlY3VyaXR5IFJlc2Vh\n" \
     "cmNoIEdyb3VwMRUwEwYDVQQDEwxJU1JHIFJvb3QgWDEwHhcNMTUwNjA0MTEwNDM4\n" \
     "WhcNMzUwNjA0MTEwNDM4WjBPMQswCQYDVQQGEwJVUzEpMCcGA1UEChMgSW50ZXJu\n" \
     "ZXQgU2VjdXJpdHkgUmVzZWFyY2ggR3JvdXAxFTATBgNVBAMTDElTUkcgUm9vdCBY\n" \
     "MTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAK3oJHP0FDfzm54rVygc\n" \
     "h77ct984kIxuPOZXoHj3dcKi/vVqbvYATyjb3miGbESTtrFj/RQSa78f0uoxmyF+\n" \
     "0TM8ukj13Xnfs7j/EvEhmkvBioZxaUpmZmyPfjxwv60pIgbz5MDmgK7iS4+3mX6U\n" \
     "A5/TR5d8mUgjU+g4rk8Kb4Mu0UlXjIB0ttov0DiNewNwIRt18jA8+o+u3dpjq+sW\n" \
     "T8KOEUt+zwvo/7V3LvSye0rgTBIlDHCNAymg4VMk7BPZ7hm/ELNKjD+Jo2FR3qyH\n" \
     "B5T0Y3HsLuJvW5iB4YlcNHlsdu87kGJ55tukmi8mxdAQ4Q7e2RCOFvu396j3x+UC\n" \
     "B5iPNgiV5+I3lg02dZ77DnKxHZu8A/lJBdiB3QW0KtZB6awBdpUKD9jf1b0SHzUv\n" \
     "KBds0pjBqAlkd25HN7rOrFleaJ1/ctaJxQZBKT5ZPt0m9STJEadao0xAH0ahmbWn\n" \
     "OlFuhjuefXKnEgV4We0+UXgVCwOPjdAvBbI+e0ocS3MFEvzG6uBQE3xDk3SzynTn\n" \
     "jh8BCNAw1FtxNrQHusEwMFxIt4I7mKZ9YIqioymCzLq9gwQbooMDQaHWBfEbwrbw\n" \
     "qHyGO0aoSCqI3Haadr8faqU9GY/rOPNk3sgrDQoo//fb4hVC1CLQJ13hef4Y53CI\n" \
     "rU7m2Ys6xt0nUW7/vGT1M0NPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNV\n" \
     "HRMBAf8EBTADAQH/MB0GA1UdDgQWBBR5tFnme7bl5AFzgAiIyBpY9umbbjANBgkq\n" \
     "hkiG9w0BAQsFAAOCAgEAVR9YqbyyqFDQDLHYGmkgJykIrGF1XIpu+ILlaS/V9lZL\n" \
     "ubhzEFnTIZd+50xx+7LSYK05qAvqFyFWhfFQDlnrzuBZ6brJFe+GnY+EgPbk6ZGQ\n" \
     "3BebYhtF8GaV0nxvwuo77x/Py9auJ/GpsMiu/X1+mvoiBOv/2X/qkSsisRcOj/KK\n" \
     "NFtY2PwByVS5uCbMiogziUwthDyC3+6WVwW6LLv3xLfHTjuCvjHIInNzktHCgKQ5\n" \
     "ORAzI4JMPJ+GslWYHb4phowim57iaztXOoJwTdwJx4nLCgdNbOhdjsnvzqvHu7Ur\n" \
     "TkXWStAmzOVyyghqpZXjFaH3pO3JLF+l+/+sKAIuvtd7u+Nxe5AW0wdeRlN8NwdC\n" \
     "jNPElpzVmbUq4JUagEiuTDkHzsxHpFKVK7q4+63SM1N95R1NbdWhscdCb+ZAJzVc\n" \
     "oyi3B43njTOQ5yOf+1CceWxG1bQVs5ZufpsMljq4Ui0/1lvh+wjChP4kqKOJ2qxq\n" \
     "4RgqsahDYVvTH9w7jXbyLeiNdd8XM2w9U/t7y0Ff/9yi0GE44Za4rF2LN9d11TPA\n" \
     "mRGunUHBcnWEvgJBQl9nJEiU0Zsnvgc/ubhPgXRR4Xq37Z0j4r7g1SgEEzwxA57d\n" \
     "emyPxgcYxn/eR44/KJ4EBs+lVDR3veyJm+kXQ99b21/+jh5Xos1AnX5iItreGCc=\n" \
     "-----END CERTIFICATE-----\n";</k>
Create a new client called client using WiFiClient secure.
<k>WiFiClientSecure client;</k>
In the setup(), initialize the Serial Monitor and connect to your network.
<k>//Initialize serial and wait for port to open:
Serial.begin(115200);
delay(100);
Serial.print("Attempting to connect to SSID: ");
Serial.println(ssid);
WiFi.begin(ssid, password);
// attempt to connect to Wifi network:
while (WiFi.status() != WL_CONNECTED) {
  Serial.print(".");
  // wait 1 second for re-trying
  delay(1000);
}
Serial.print("Connected to ");
Serial.println(ssid);</k>
The following line set the client certificate using the setCACert() method on the client.
<k> client.setCACert(test_root_ca);</k>
Then, the client connects to the server. For HTTPS, you need to use port 443.
<k>if (!client.connect(server, 443))
    Serial.println("Connection failed!");</k>
If the connection is successful, we can make the HTTP request. In this case, we're making a GET request. Note that you need to use the https:// before the URL you'll make a request to.
<k>  else {
    Serial.println("Connected to server!");
    // Make a HTTP request:
    client.println("GET https://www.howsmyssl.com/a/check HTTP/1.0");
    client.println("Host: www.howsmyssl.com");
    client.println("Connection: close");
    client.println();</k>
Finally, we get and print the response from the server:
<k>while (client.connected()) {
      String line = client.readStringUntil('\n');
      if (line == "\r") {
        Serial.println("headers received");
        break;
      }
    }
    // if there are incoming bytes available
    // from the server, read them and print them:
    while (client.available()) {
      char c = client.read();
      Serial.write(c);
    }</k>
In the end, we close the connection with the client.
<k>client.stop();</k>
In this example, we make the request once in the setup(). The loop() is empty, but you can add any other tasks that you need in your project. Or, depending on the application, you can make the request on the loop().
<k>void loop() {
  // do nothing
}</k>
In summary, to make HTTPS requests:
Include the WiFiClientSecure library;
Create a WiFiClientSecure client;
Use port 443;
Use the setCACert() function to set the client certificate.
Use https on the URL when making the HTTPS request.
<h4>Demonstration</h4>
Upload the code to your board.
Open the Serial Monitor at a baud rate of 115200 and press the onboard RST button.
You should get something as shown in the following screenshot.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/WiFiClientSecure-ESP32-Serial-Monitor.png">
If you scroll to the right, you'll get the result of how secure the connection is. You should get a Probably Okay.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/WiFiClientSecure-ESP32-Serial-Monitor-2.png">
<h3>ESP32 HTTPS Requests without Certificate</h3>
If you want to skip the SSL server certificate verification, but you still want to have encrypted communication, you can remove the following line:
<k> client.setCACert(test_root_ca);</k>
And add the following line before connecting with the client:
<k>client.setInsecure();</k>
The complete example can be found below.
<k>/*
  Complete project details: https://RandomNerdTutorials.com/esp32-https-requests/
  
  Based on the WiFiClientSecure example HTTPS Requests without Certificate
  Wifi secure connection example for ESP32
  Running on TLS 1.2 using mbedTLS
  Suporting the following chipersuites:
  "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384","TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384","TLS_DHE_RSA_WITH_AES_256_GCM_SHA384","TLS_ECDHE_ECDSA_WITH_AES_256_CCM","TLS_DHE_RSA_WITH_AES_256_CCM","TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384","TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384","TLS_DHE_RSA_WITH_AES_256_CBC_SHA256","TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA","TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA","TLS_DHE_RSA_WITH_AES_256_CBC_SHA","TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8","TLS_DHE_RSA_WITH_AES_256_CCM_8","TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384","TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384","TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384","TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384","TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384","TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256","TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA","TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256","TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256","TLS_DHE_RSA_WITH_AES_128_GCM_SHA256","TLS_ECDHE_ECDSA_WITH_AES_128_CCM","TLS_DHE_RSA_WITH_AES_128_CCM","TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256","TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256","TLS_DHE_RSA_WITH_AES_128_CBC_SHA256","TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA","TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA","TLS_DHE_RSA_WITH_AES_128_CBC_SHA","TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8","TLS_DHE_RSA_WITH_AES_128_CCM_8","TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256","TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256","TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256","TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256","TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256","TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256","TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA","TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA","TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA","TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA","TLS_DHE_PSK_WITH_AES_256_GCM_SHA384","TLS_DHE_PSK_WITH_AES_256_CCM","TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384","TLS_DHE_PSK_WITH_AES_256_CBC_SHA384","TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA","TLS_DHE_PSK_WITH_AES_256_CBC_SHA","TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384","TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384","TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384","TLS_PSK_DHE_WITH_AES_256_CCM_8","TLS_DHE_PSK_WITH_AES_128_GCM_SHA256","TLS_DHE_PSK_WITH_AES_128_CCM","TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256","TLS_DHE_PSK_WITH_AES_128_CBC_SHA256","TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA","TLS_DHE_PSK_WITH_AES_128_CBC_SHA","TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256","TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256","TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256","TLS_PSK_DHE_WITH_AES_128_CCM_8","TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA","TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA","TLS_RSA_WITH_AES_256_GCM_SHA384","TLS_RSA_WITH_AES_256_CCM","TLS_RSA_WITH_AES_256_CBC_SHA256","TLS_RSA_WITH_AES_256_CBC_SHA","TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384","TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384","TLS_ECDH_RSA_WITH_AES_256_CBC_SHA","TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384","TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384","TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA","TLS_RSA_WITH_AES_256_CCM_8","TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384","TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256","TLS_RSA_WITH_CAMELLIA_256_CBC_SHA","TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384","TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384","TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384","TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384","TLS_RSA_WITH_AES_128_GCM_SHA256","TLS_RSA_WITH_AES_128_CCM","TLS_RSA_WITH_AES_128_CBC_SHA256","TLS_RSA_WITH_AES_128_CBC_SHA","TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256","TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256","TLS_ECDH_RSA_WITH_AES_128_CBC_SHA","TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256","TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256","TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA","TLS_RSA_WITH_AES_128_CCM_8","TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256","TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256","TLS_RSA_WITH_CAMELLIA_128_CBC_SHA","TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256","TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256","TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256","TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256","TLS_RSA_WITH_3DES_EDE_CBC_SHA","TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA","TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA","TLS_RSA_PSK_WITH_AES_256_GCM_SHA384","TLS_RSA_PSK_WITH_AES_256_CBC_SHA384","TLS_RSA_PSK_WITH_AES_256_CBC_SHA","TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384","TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384","TLS_RSA_PSK_WITH_AES_128_GCM_SHA256","TLS_RSA_PSK_WITH_AES_128_CBC_SHA256","TLS_RSA_PSK_WITH_AES_128_CBC_SHA","TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256","TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256","TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA","TLS_PSK_WITH_AES_256_GCM_SHA384","TLS_PSK_WITH_AES_256_CCM","TLS_PSK_WITH_AES_256_CBC_SHA384","TLS_PSK_WITH_AES_256_CBC_SHA","TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384","TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384","TLS_PSK_WITH_AES_256_CCM_8","TLS_PSK_WITH_AES_128_GCM_SHA256","TLS_PSK_WITH_AES_128_CCM","TLS_PSK_WITH_AES_128_CBC_SHA256","TLS_PSK_WITH_AES_128_CBC_SHA","TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256","TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256","TLS_PSK_WITH_AES_128_CCM_8","TLS_PSK_WITH_3DES_EDE_CBC_SHA","TLS_EMPTY_RENEGOTIATION_INFO_SCSV"]
  2017 - Evandro Copercini - Apache 2.0 License.
*/
#include &lt;WiFiClientSecure.h>
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
const char*  server = "www.howsmyssl.com";  // Server URL
WiFiClientSecure client;
void setup() {
  //Initialize serial and wait for port to open:
  Serial.begin(115200);
  delay(100);
  Serial.print("Attempting to connect to SSID: ");
  Serial.println(ssid);
  WiFi.begin(ssid, password);
  // attempt to connect to Wifi network:
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print(".");
    // wait 1 second for re-trying
    delay(1000);
  }
  Serial.print("Connected to ");
  Serial.println(ssid);
  client.setInsecure();
  Serial.println("\nStarting connection to server...");
  if (!client.connect(server, 443))
    Serial.println("Connection failed!");
  else {
    Serial.println("Connected to server!");
    // Make a HTTP request:
    client.println("GET https://www.howsmyssl.com/a/check HTTP/1.0");
    client.println("Host: www.howsmyssl.com");
    client.println("Connection: close");
    client.println();
    while (client.connected()) {
      String line = client.readStringUntil('\n');
      if (line == "\r") {
        Serial.println("headers received");
        break;
      }
    }
    // if there are incoming bytes available
    // from the server, read them and print them:
    while (client.available()) {
      char c = client.read();
      Serial.write(c);
    }
    client.stop();
  }
}
void loop() {
  // do nothing
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_HTTPS/ESP32_WiFiClientSecure_No_Certificate/ESP32_WiFiClientSecure_No_Certificate.ino" target="_blank">View raw code</a>
With this example, your connection is still encrypted, but you won't be sure if you're talking to the right server. This scenario is useful for testing purposes.
<h3>ESP32 HTTPS Requests with Certificate Bundle</h3>
Instead of just using one certificate, you can use a certificate bundle: a collection of trusted certificates that you can load into your board. Then, you don't have to worry about getting the certificate for a specific server.
The WiFiClient library provides some information about how to use a certificate bundle on the following link:
<a href="https://github.com/espressif/arduino-esp32/blob/master/libraries/WiFiClientSecure/README.md#using-a-bundle-of-root-certificate-authority-certificates" target="_blank" rel="noopener">https://github.com/espressif/arduino-esp32/blob/master/libraries/WiFiClientSecure/README.md#using-a-bundle-of-root-certificate-authority-certificates</a>
I followed all the instructions provided, and got the following issue:
[  1799][E][ssl_client.cpp:37] _handle_error(): [start_ssl_client():276]: (-12288) X509 - A fatal error occurred, eg the chain is too long or the vrfy callback failed
If anyone knows how to fix this issue, please share in the comments below.
<h3>ESP32 HTTP Requests using HTTPClient Library</h3>
The HTTPClient library provides a simple example showing how to make HTTPS requests with the ESP32. You can find the example in your Arduino IDE. First, make sure you have an ESP32 board selected in <k>Tools </k>> <k>Board</k>. Then, go to <k>File</k> > <k>Examples </k>> <k>HTTPClient </k>> <k>BasicHttpsClient</k>. We created new sketches based on that example. See the code below.
<h3>ESP32 HTTPS Requests with Certificate</h3>
The following sketch makes a request to howsmyssl.com like the previous examples but uses the HTTPClient library. It checks the server certificate. We'll use the root certificate we've gotten in previous steps.
<k>/*
  Complete project details: https://RandomNerdTutorials.com/esp32-https-requests/
  Based on the BasicHTTPSClient.ino example found at Examples > BasicHttpsClient
*/
#include &lt;Arduino.h>
#include &lt;WiFi.h>
#include &lt;WiFiClientSecure.h>
#include &lt;HTTPClient.h>
// Replace with your network credentials
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
// www.howsmyssl.com root certificate authority, to verify the server
// change it to your server root CA
const char* rootCACertificate = \
     "-----BEGIN CERTIFICATE-----\n" \
     "MIIFazCCA1OgAwIBAgIRAIIQz7DSQONZRGPgu2OCiwAwDQYJKoZIhvcNAQELBQAw\n" \
     "TzELMAkGA1UEBhMCVVMxKTAnBgNVBAoTIEludGVybmV0IFNlY3VyaXR5IFJlc2Vh\n" \
     "cmNoIEdyb3VwMRUwEwYDVQQDEwxJU1JHIFJvb3QgWDEwHhcNMTUwNjA0MTEwNDM4\n" \
     "WhcNMzUwNjA0MTEwNDM4WjBPMQswCQYDVQQGEwJVUzEpMCcGA1UEChMgSW50ZXJu\n" \
     "ZXQgU2VjdXJpdHkgUmVzZWFyY2ggR3JvdXAxFTATBgNVBAMTDElTUkcgUm9vdCBY\n" \
     "MTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAK3oJHP0FDfzm54rVygc\n" \
     "h77ct984kIxuPOZXoHj3dcKi/vVqbvYATyjb3miGbESTtrFj/RQSa78f0uoxmyF+\n" \
     "0TM8ukj13Xnfs7j/EvEhmkvBioZxaUpmZmyPfjxwv60pIgbz5MDmgK7iS4+3mX6U\n" \
     "A5/TR5d8mUgjU+g4rk8Kb4Mu0UlXjIB0ttov0DiNewNwIRt18jA8+o+u3dpjq+sW\n" \
     "T8KOEUt+zwvo/7V3LvSye0rgTBIlDHCNAymg4VMk7BPZ7hm/ELNKjD+Jo2FR3qyH\n" \
     "B5T0Y3HsLuJvW5iB4YlcNHlsdu87kGJ55tukmi8mxdAQ4Q7e2RCOFvu396j3x+UC\n" \
     "B5iPNgiV5+I3lg02dZ77DnKxHZu8A/lJBdiB3QW0KtZB6awBdpUKD9jf1b0SHzUv\n" \
     "KBds0pjBqAlkd25HN7rOrFleaJ1/ctaJxQZBKT5ZPt0m9STJEadao0xAH0ahmbWn\n" \
     "OlFuhjuefXKnEgV4We0+UXgVCwOPjdAvBbI+e0ocS3MFEvzG6uBQE3xDk3SzynTn\n" \
     "jh8BCNAw1FtxNrQHusEwMFxIt4I7mKZ9YIqioymCzLq9gwQbooMDQaHWBfEbwrbw\n" \
     "qHyGO0aoSCqI3Haadr8faqU9GY/rOPNk3sgrDQoo//fb4hVC1CLQJ13hef4Y53CI\n" \
     "rU7m2Ys6xt0nUW7/vGT1M0NPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNV\n" \
     "HRMBAf8EBTADAQH/MB0GA1UdDgQWBBR5tFnme7bl5AFzgAiIyBpY9umbbjANBgkq\n" \
     "hkiG9w0BAQsFAAOCAgEAVR9YqbyyqFDQDLHYGmkgJykIrGF1XIpu+ILlaS/V9lZL\n" \
     "ubhzEFnTIZd+50xx+7LSYK05qAvqFyFWhfFQDlnrzuBZ6brJFe+GnY+EgPbk6ZGQ\n" \
     "3BebYhtF8GaV0nxvwuo77x/Py9auJ/GpsMiu/X1+mvoiBOv/2X/qkSsisRcOj/KK\n" \
     "NFtY2PwByVS5uCbMiogziUwthDyC3+6WVwW6LLv3xLfHTjuCvjHIInNzktHCgKQ5\n" \
     "ORAzI4JMPJ+GslWYHb4phowim57iaztXOoJwTdwJx4nLCgdNbOhdjsnvzqvHu7Ur\n" \
     "TkXWStAmzOVyyghqpZXjFaH3pO3JLF+l+/+sKAIuvtd7u+Nxe5AW0wdeRlN8NwdC\n" \
     "jNPElpzVmbUq4JUagEiuTDkHzsxHpFKVK7q4+63SM1N95R1NbdWhscdCb+ZAJzVc\n" \
     "oyi3B43njTOQ5yOf+1CceWxG1bQVs5ZufpsMljq4Ui0/1lvh+wjChP4kqKOJ2qxq\n" \
     "4RgqsahDYVvTH9w7jXbyLeiNdd8XM2w9U/t7y0Ff/9yi0GE44Za4rF2LN9d11TPA\n" \
     "mRGunUHBcnWEvgJBQl9nJEiU0Zsnvgc/ubhPgXRR4Xq37Z0j4r7g1SgEEzwxA57d\n" \
     "emyPxgcYxn/eR44/KJ4EBs+lVDR3veyJm+kXQ99b21/+jh5Xos1AnX5iItreGCc=\n" \
     "-----END CERTIFICATE-----\n";
void setup() {
  Serial.begin(115200);
  Serial.println();
  // Initialize Wi-Fi
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  Serial.print("Connecting to WiFi ..");
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print('.');
    delay(1000);
  }
  Serial.println(WiFi.localIP());
}
void loop() {
  WiFiClientSecure *client = new WiFiClientSecure;
  if(client) {
    // set secure client with certificate
    client->setCACert(rootCACertificate);
    //create an HTTPClient instance
    HTTPClient https;
    //Initializing an HTTPS communication using the secure client
    Serial.print("[HTTPS] begin...\n");
    if (https.begin(*client, "https://www.howsmyssl.com/a/check")) {  // HTTPS
      Serial.print("[HTTPS] GET...\n");
      // start connection and send HTTP header
      int httpCode = https.GET();
      // httpCode will be negative on error
      if (httpCode > 0) {
      // HTTP header has been send and Server response header has been handled
       Serial.printf("[HTTPS] GET... code: %d\n", httpCode);
      // file found at server
        if (httpCode == HTTP_CODE_OK || httpCode == HTTP_CODE_MOVED_PERMANENTLY) {
          // print server response payload
          String payload = https.getString();
          Serial.println(payload);
        }
      }
      else {
        Serial.printf("[HTTPS] GET... failed, error: %s\n", https.errorToString(httpCode).c_str());
      }
      https.end();
    }
  }
  else {
    Serial.printf("[HTTPS] Unable to connect\n");
  }
  Serial.println();
  Serial.println("Waiting 2min before the next round...");
  delay(120000);
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_HTTPS/ESP32_BasicHttpsClient_Certificate/ESP32_BasicHttpsClient_Certificate.ino" target="_blank">View raw code</a>
<h4>How does the Code Work?</h4>
Start by including the required libraries: WiFi.h, WiFiClientSecure.h, and HTTPClient.h.
<k>#include &lt;Arduino.h>
#include &lt;WiFi.h>
#include &lt;WiFiClientSecure.h>
#include &lt;HTTPClient.h></k>
Insert your network credentials in the following lines:
<k>// Replace with your network credentials
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
Next, you need to add the server certificate. We're using the root certificate for howsmyssl.com (see previous steps).
<k>const char* rootCACertificate = \
     "-----BEGIN CERTIFICATE-----\n" \
     "MIIFazCCA1OgAwIBAgIRAIIQz7DSQONZRGPgu2OCiwAwDQYJKoZIhvcNAQELBQAw\n" \
     "TzELMAkGA1UEBhMCVVMxKTAnBgNVBAoTIEludGVybmV0IFNlY3VyaXR5IFJlc2Vh\n" \
     "cmNoIEdyb3VwMRUwEwYDVQQDEwxJU1JHIFJvb3QgWDEwHhcNMTUwNjA0MTEwNDM4\n" \
     "WhcNMzUwNjA0MTEwNDM4WjBPMQswCQYDVQQGEwJVUzEpMCcGA1UEChMgSW50ZXJu\n" \
     "ZXQgU2VjdXJpdHkgUmVzZWFyY2ggR3JvdXAxFTATBgNVBAMTDElTUkcgUm9vdCBY\n" \
     "MTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAK3oJHP0FDfzm54rVygc\n" \
     "h77ct984kIxuPOZXoHj3dcKi/vVqbvYATyjb3miGbESTtrFj/RQSa78f0uoxmyF+\n" \
     "0TM8ukj13Xnfs7j/EvEhmkvBioZxaUpmZmyPfjxwv60pIgbz5MDmgK7iS4+3mX6U\n" \
     "A5/TR5d8mUgjU+g4rk8Kb4Mu0UlXjIB0ttov0DiNewNwIRt18jA8+o+u3dpjq+sW\n" \
     "T8KOEUt+zwvo/7V3LvSye0rgTBIlDHCNAymg4VMk7BPZ7hm/ELNKjD+Jo2FR3qyH\n" \
     "B5T0Y3HsLuJvW5iB4YlcNHlsdu87kGJ55tukmi8mxdAQ4Q7e2RCOFvu396j3x+UC\n" \
     "B5iPNgiV5+I3lg02dZ77DnKxHZu8A/lJBdiB3QW0KtZB6awBdpUKD9jf1b0SHzUv\n" \
     "KBds0pjBqAlkd25HN7rOrFleaJ1/ctaJxQZBKT5ZPt0m9STJEadao0xAH0ahmbWn\n" \
     "OlFuhjuefXKnEgV4We0+UXgVCwOPjdAvBbI+e0ocS3MFEvzG6uBQE3xDk3SzynTn\n" \
     "jh8BCNAw1FtxNrQHusEwMFxIt4I7mKZ9YIqioymCzLq9gwQbooMDQaHWBfEbwrbw\n" \
     "qHyGO0aoSCqI3Haadr8faqU9GY/rOPNk3sgrDQoo//fb4hVC1CLQJ13hef4Y53CI\n" \
     "rU7m2Ys6xt0nUW7/vGT1M0NPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNV\n" \
     "HRMBAf8EBTADAQH/MB0GA1UdDgQWBBR5tFnme7bl5AFzgAiIyBpY9umbbjANBgkq\n" \
     "hkiG9w0BAQsFAAOCAgEAVR9YqbyyqFDQDLHYGmkgJykIrGF1XIpu+ILlaS/V9lZL\n" \
     "ubhzEFnTIZd+50xx+7LSYK05qAvqFyFWhfFQDlnrzuBZ6brJFe+GnY+EgPbk6ZGQ\n" \
     "3BebYhtF8GaV0nxvwuo77x/Py9auJ/GpsMiu/X1+mvoiBOv/2X/qkSsisRcOj/KK\n" \
     "NFtY2PwByVS5uCbMiogziUwthDyC3+6WVwW6LLv3xLfHTjuCvjHIInNzktHCgKQ5\n" \
     "ORAzI4JMPJ+GslWYHb4phowim57iaztXOoJwTdwJx4nLCgdNbOhdjsnvzqvHu7Ur\n" \
     "TkXWStAmzOVyyghqpZXjFaH3pO3JLF+l+/+sKAIuvtd7u+Nxe5AW0wdeRlN8NwdC\n" \
     "jNPElpzVmbUq4JUagEiuTDkHzsxHpFKVK7q4+63SM1N95R1NbdWhscdCb+ZAJzVc\n" \
     "oyi3B43njTOQ5yOf+1CceWxG1bQVs5ZufpsMljq4Ui0/1lvh+wjChP4kqKOJ2qxq\n" \
     "4RgqsahDYVvTH9w7jXbyLeiNdd8XM2w9U/t7y0Ff/9yi0GE44Za4rF2LN9d11TPA\n" \
     "mRGunUHBcnWEvgJBQl9nJEiU0Zsnvgc/ubhPgXRR4Xq37Z0j4r7g1SgEEzwxA57d\n" \
     "emyPxgcYxn/eR44/KJ4EBs+lVDR3veyJm+kXQ99b21/+jh5Xos1AnX5iItreGCc=\n" \
     "-----END CERTIFICATE-----\n";</k>
In the setup () initialize the Serial Monitor and connect to Wi-Fi.
<k>void setup() {
  Serial.begin(115200);
  Serial.println();
  // Initialize Wi-Fi
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  Serial.print("Connecting to WiFi ..");
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print('.');
    delay(1000);
  }
  Serial.println(WiFi.localIP());
}</k>
In the loop(), create a pointer to WiFiClientSecure called client.
<k> WiFiClientSecure *client = new WiFiClientSecure;</k>
Set a secure client with the certificate using the setCACert() method:
<k> client->setCACert(rootCACertificate);</k>
Then, create an HTTPClient instance called https.
<k>//create an HTTPClient instance
HTTPClient https;</k>
Initialize the https client on the host specified using the begin() method. In this case, we're making a request on the following URL: https://www.howsmyssl.com/a/check.
<k> if (https.begin(*client, "https://www.howsmyssl.com/a/check")) {  // HTTPS</k>
Get the server response code.
<k> int httpCode = https.GET();</k>
If the response code is a positive number, it means the connection was established successfully, so we can read the response payload using the getString() method on the https object. Then, we can print the payload in the Serial Monitor. In a practical application, you can do whatever task you need with the ESP32 depending on the received payload.
<k>if (https.begin(client, "https://www.howsmyssl.com/a/check")) {  // HTTPS
  Serial.print("[HTTPS] GET...\n");
  // start connection and send HTTP header
  int httpCode = https.GET();
  // httpCode will be negative on error
  if (httpCode > 0) {
    // HTTP header has been send and Server response header has been handled
    Serial.printf("[HTTPS] GET... code: %d\n", httpCode);
    // file found at server
    if (httpCode == HTTP_CODE_OK || httpCode == HTTP_CODE_MOVED_PERMANENTLY) {
      // print server response payload
      String payload = https.getString();
      Serial.println(payload);
    }
  }</k>
If the response code is a negative number, it means we have an error. We'll print the error code.
<k>else {
   Serial.printf("[HTTPS] GET... failed, error: %s\n", https.errorToString(httpCode).c_str());
}</k>
Finally, close the HTTPS connection using the end() method:
<k>https.end();</k>
This specific example makes a request every two minutes. You can change it depending on your project requirements.
<k>  Serial.println("Waiting 2min before the next round...");
  delay(120000);</k>
<h4>Demonstration</h4>
You can change the debug level to get more information about what's going on in the process. Go to <k>Tools </k>> <k>Core Debug Level</k> > <k>Debug</k>. Then, you can upload the code to the ESP32.
After uploading the code, open the Serial Monitor at a baud rate of 115200. Press the on-board RST board to start running the newly uploaded code. 
You should get something similar as shown in the picture below.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/ESP32-HTTPS-Client-Demonstration-Serial-Monitor-1.png">
If you scroll to the right, you'll get the result of how secure the connection is. You should get a Probably Okay.
<h3>ESP32 HTTPS Requests without Certificate</h3>
If you want to skip the SSL server certificate verification, but you still want to have encrypted communication, you can remove the following line:
<k> client.setCACert(test_root_ca);</k>
And add the following line before starting the HTTP client:
<k>client.setInsecure();</k>
The complete example can be found below.
<k>/*
  Complete project details: https://RandomNerdTutorials.com/esp32-https-requests/
  Based on the BasicHTTPSClient.ino example found at Examples > BasicHttpsClient
*/
#include &lt;Arduino.h>
#include &lt;WiFi.h>
#include &lt;WiFiClientSecure.h>
#include &lt;HTTPClient.h>
// Replace with your network credentials
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
void setup() {
  Serial.begin(115200);
  Serial.println();
  // Initialize Wi-Fi
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  Serial.print("Connecting to WiFi ..");
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print('.');
    delay(1000);
  }
  Serial.println(WiFi.localIP());
}
void loop() {
 WiFiClientSecure *client = new WiFiClientSecure;
  if(client) {
    // set secure client without certificate
    client->setInsecure();
    //create an HTTPClient instance
    HTTPClient https;
    //Initializing an HTTPS communication using the secure client
    Serial.print("[HTTPS] begin...\n");
    if (https.begin(*client, "https://www.howsmyssl.com/a/check")) {  // HTTPS
      Serial.print("[HTTPS] GET...\n");
      // start connection and send HTTP header
      int httpCode = https.GET();
      // httpCode will be negative on error
      if (httpCode > 0) {
      // HTTP header has been send and Server response header has been handled
       Serial.printf("[HTTPS] GET... code: %d\n", httpCode);
      // file found at server
        if (httpCode == HTTP_CODE_OK || httpCode == HTTP_CODE_MOVED_PERMANENTLY) {
          // print server response payload
          String payload = https.getString();
          Serial.println(payload);
        }
      }
      else {
        Serial.printf("[HTTPS] GET... failed, error: %s\n", https.errorToString(httpCode).c_str());
      }
      https.end();
    }
  }
  else {
    Serial.printf("[HTTPS] Unable to connect\n");
  }
  Serial.println();
  Serial.println("Waiting 2min before the next round...");
  delay(120000);
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_HTTPS/ESP32_HTTPSClient_No_Certificate/ESP32_HTTPSClient_No_Certificate.ino" target="_blank">View raw code</a>
With this example, your connection is still encrypted, but you won't be sure if you're talking to the right server. This scenario is useful for testing purposes.
After uploading this example, here's what you should get:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/ESP32-HTTPS-Client-No-Certificate-Demonstration-Serial-Monitor-1.png">
Your connection is still encrypted, but it will skip SSL verification.
<h3>Wrapping Up</h3>
In this tutorial, you learned how to make HTTPS requests with the ESP32. You also learned about the basic concepts of <a href="https://randomnerdtutorials.com/esp32-esp8266-https-ssl-tls/">HTTPS protocol and about SSL/TLS certificates</a>.
We've taken a look at examples with the WiFiClientSecure and HTTPClient libraries. The examples presented are as simple as possible so that you can modify them and apply them to your own projects. You learned how to make HTTPS requests with and without verification of the SSL/TLS certificate.
<h2>with HTTPS and SSL/TLS Encryption: Basic Concepts</h2>
This article is a quick and simple introduction to HTTPS and SSL/TLS encryption with the ESP32 and ESP8266 NodeMCU board. We'll take a look at some concepts and terms that you've probably heard before but you might not know exactly what they mean: HTTPS, SSL/TLS, certificates, asymmetric and symmetric key encryption, and more.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/ESP32-ESP8266-HTTPS-Basic-Concepts.jpg">
<k>Table of Contents</k>
Throughout this article, we'll cover the following subjects:
What is HTTPS?Why do you need HTTPS?
What is SSL/TLS?
How does SSL/TLS encryption work?Public key and private key
Communication over HTTPS
SSL certificates
Self-signed certificates
ESP32: HTTPS requests (Arduino IDE)
ESP32 HTTPS server (Arduino IDE)
ESP8266: HTTPS requests (Arduino IDE)
ESP8266 HTTPS server (Arduino IDE)
<h3>What is HTTPS? </h3>
HTTPS is the secure version of the HTTP protocol, hence the S, which stands for secure.
HTTP is a protocol to transfer data over the internet. When that data is encrypted with SSL/TLS, it's called HTTPS.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/HTTP-vs-HTTPS.png">
To simplify, HTTPS is just the HTTP protocol but with encrypted data using SSL/TLS.
<h3>Why do you need HTTPS?</h3>
Using HTTPS ensures the following:
<k>Privacy</k>: no one can spy on your requests and passwords because the messages are encrypted.
<k>Integrity</k>: the message is not manipulated on its way to its destination (prevents men-in-the-middle) attacks.
<k>Identification:</k> when using HTTPS, via SSL certificates, you ensure you are connected to the server you would expect.
<h3>What is SSL/TLS?</h3>
<k>SSL </k>stands for <k>S</k>ecure <k>S</k>ocket <k>L</k>ayer and <k>TLS</k> stands for <k>T</k>ransport <k>L</k>ayer <k>S</k>ecurity. These are two protocols used for secured encryption. SSL is currently deprecated. TLS 1.3 is currently the most recent protocol used for secure encryption on the web.
<h3>How does SSL/TLS encryption work?</h3>
There are two types of encryption algorithms: <k>symmetric key algorithm</k> and <k>asymmetric key algorithm</k>.
<k>Symmetric Key Encryption</k>
With a symmetric-key algorithm, the same key is used to encrypt and decrypt the messages. So, both the client and server need to have the same key.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/Symmetric-key-encryption.png">
The disadvantage of using a symmetric key algorithm is that keys are hard to share and you need to be careful how and with who you distribute the key.
<k>Asymmetric Key Encryption</k>
The SSL/TLS encryption uses asymmetric keys.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/Asymmetric-key-encryption.png">
How does asymmetric key encryption work? Very briefly:
You have two asymmetric keys: a public key and a private key.
The public key and private key work together.
The public key, as the name suggests, is visible to anyone.
Only the private key can decrypt the message encrypted with the corresponding public key.
<h3>Public Key and Private Key</h3>
In summary, here's how it works:
The browser client tries to contact the server.
The server sends the public key to the client (browser) via the server's SSL certificate.
The browser sends a message to the server encrypted with the public key.
Only the ones with the private key (the server) can decipher the message.
<h3>Communication over HTTPS</h3>
How the communication between the server and client works over HTTPS? The following diagram shows a high-level overview of how it works.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/HTTPS-Communication-SSL-certificte_f.png">
You, the client on your browser, try to connect with the server (<k>1</k>);
The server sends back its certificate (<k>2</k>) so that the browser can check the authenticity of the server (<k>3</k>). The certificate contains the public key.
If the certificate is valid, the client creates a new key (called session key) (<k>4</k>) that will be used later to encrypt communication between the client and server. 
The client encrypts the session key using the public key sent by the server (<k>5</k>).
The server receives the session key encrypted with the public key and can decipher the message because only the server has access to the corresponding private key to decrypt the message (<k>6</k>);
From now on, both the client and server have a secret key (that's only known to them) that they can use to encrypt further communication (<k>7</k>) (symmetric key encryption).
<h3>SSL Certificates</h3>
SSL certificates are issued by legitimate Certificate Authorities. One of the most known is LetsEncrypt. Certificate Authorities also confirm the identity of the certificate owner and provide proof that the certificate is valid. 
When a Certificate Authority issues a certificate, it signs the certificate with its root certificate. This root certificate should be on the database of trusted certificates.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/HTTPS-browser-valid-certificate.png">
Your browser then checks if the certificate is valid (if it was signed with a root certificate on the database of trusted root certificates) and displays a green lock icon on the browser bar if it is.
<h3><k>Self-signed Certificates</k></h3>
You can self-sign your certificates. These provide the same level of encryption as one generated by an authority, and these are free. However, all browsers will check if the certificate is issued by a trusted Certificate Authority. So, you'll be warned by your browser that the site you're visiting is not safe because it doesn't trust the certificate and so, can't identify its owner.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/browser-self-signed-certificate_HTTPS-browser-self-signedcate.png">
The web browser will display a warning sign and the HTTPS letters in red. This means the website has a certificate, but the certificate is unverified (like self-signed certificates) or out of date. This means that the connection between you and the server is encrypted, but no one can guarantee that the domain really belongs to the company indicated on the site. 
Self-signed certificates are fine to use on your DIY and IoT projects, intranets, like your local network, or inside a company's network. However, if you're creating a project for a company that will be accessed by clients outside the company network, like a public website, it's best to use a certificate from a Certificate Authority.
SSL certificates have an expiry date. So, if you're using an ESP32 to connect to a website via HTTPS, you should keep in mind that you'll need to update the code with the new website's certificate in the future.
If you're still confused about all of these new terms, we recommend taking a look at the following website that explains in a fun way how everything works: https://howhttps.works/.  
<h3>ESP32: HTTPS Requests (Arduino IDE)</h3>
If you're familiar with HTTP requests with the ESP32 migrating to HTTPS is very straightforward. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/ESP32-HTTPS-Requests.png">
If you're using the WiFiClient library, you just need to make the following changes:
<ol>
Use WiFiClientSecure.h library instead of WiFiClient.h
Use port 443 instead of port 80
Change the host URL to https instead of http
</ol>
With this, you ensure that your communication is encrypted using TLS.
An additional security step is to check the server certificate (the certificate of the website you want to connect to). You can skip this step while testing and prototyping. The communication will be encrypted, but you won't be sure of the integrity of the server you are trying to communicate with.
You can also find examples using HTTPS with the HTTPClient library.
If you want to start working on your HTTPS requests right away, take a look at the examples provided in the ESP32 package for the Arduino core.
WiFiClientSecure example: <k>File </k>> <k>Examples </k>> <k>ESP32 </k>> <k>WFiClientSecure </k>> <k><a href="https://github.com/espressif/arduino-esp32/blob/master/libraries/WiFiClientSecure/examples/WiFiClientSecure/WiFiClientSecure.ino" target="_blank" rel="noopener">WiFiClientSecure</a></k>
HTTPClient with HTTPS example: <k>File </k>> <k>Examples </k>> <k>ESP32 </k>> <k>BasicHttpsClient </k>> <k><a href="https://github.com/espressif/arduino-esp32/blob/master/libraries/HTTPClient/examples/BasicHttpsClient/BasicHttpsClient.ino" target="_blank" rel="noopener">BasicHttpsClient</a></k>
<h3>ESP32 HTTPS Server (Arduino IDE)</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/ESP32-HTTPS-Server.png">
At the moment, there are not many examples of building an HTTPS web server with the ESP32 using the Arduino core. Unfortunately, the AsyncWebServer library that we use in most of our projects, doesn't fully support HTTPS at the moment.
Nevertheless, there is another library that provides easy methods to build an ESP32 HTTPS web server, including an example that generates certificates on the fly. Here's a link to the library: <a href="https://github.com/fhessel/esp32_https_server" target="_blank" rel="noopener">esp32_https_server library</a>.
If you're familiar with ESP-IDF, you can take a look at the documentation on the following link:
<a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/protocols/esp_https_server.html" target="_blank" rel="noopener">ESP-IDF HTTPS Server Documentation</a>
<h3>ESP8266 HTTPS Requests (Arduino IDE)</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/ESP8266-HTTPS-Requests.png">
There are several examples that show how to make HTTPS requests with the ESP8266. You can check the examples available in your Arduino IDE. Make sure you have the latest version of the ESP8266 boards installed to make sure you have access to the latest version of the examples and that these will work.
To update the ESP8266 boards' installation, you just need to go to <k>Tools </k>> <k>Boards </k>> <k>Boards Manager</k>, search for <k>ESP8266, </k>and install the latest version.
Then, you'll have access to the examples' latest version. You can check the following examples:
Basic HTTPS Client using the ESP8266HTTPClient library: <k>File </k>> <k>Examples</k> > <k>ESP8266HTTPClient </k>> <k><a href="https://github.com/esp8266/Arduino/blob/master/libraries/ESP8266HTTPClient/examples/BasicHttpsClient/BasicHttpsClient.ino" target="_blank" rel="noopener">BasicHttpsClient</a></k>
Basic HTTPS Client using WiFiClientSecure library: <k>File </k>> <k>Examples </k>> <k>ESP8266WiFi </k>> <k><a href="https://github.com/esp8266/Arduino/tree/master/libraries/ESP8266WiFi/examples/HTTPSRequest" target="_blank" rel="noopener">HTTPSRequest</a></k>
You'll need to update the certificates and fingerprints to make the examples work. If you can't make the examples work, don't worry, we'll publish some tutorials with examples and instructions soon.
<h3>ESP8266 HTTPS Server (Arduino IDE)</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/11/ESP8266-HTTPS-Server.png">
The ESP8266 is not optimized for SSL cryptography, so running an HTTPS Server on the ESP8266 is very demanding. You need to set the clock frequency to 160MHz and even so, you might get unexpected resets on the board. 
For an ESP8266 HTTPS web server, you can take a look at an example using the ESP8266WebServer library on the following link:
<a href="https://github.com/esp8266/Arduino/blob/master/libraries/ESP8266WebServer/examples/HelloServerBearSSL/HelloServerBearSSL.ino" target="_blank" rel="noopener">ESP8266 HTTPS Server (BearSSL)</a>
<h3>Wrapping Up</h3>
In this tutorial, we've taken a look at the HTTPS protocol, SSL/TLS encryption, and SSL certificates. I'm far from being an expert in these subjects, so if anything doesn't sound right in this article, please let me know in the comments below.
We've also taken a quick look at possible ways to secure your ESP32/ESP8266 IoT projects: how to make HTTPS requests and how to set the ESP32/ESP8266 as an HTTPS server with a certificate. We'll create more tutorials with practical examples about these subjects in the upcoming weeks, so stay tuned.
If you have any examples of HTTPS servers with the ESP32 or are familiar with any other libraries to build an HTTPS server, please share them in the comments below.
Thanks for reading.
<center><a href="https://randomnerdtutorials.com/pcbway" target="_blank"><img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/2022/03/728x280.jpg" width="728" height="280" loading="lazy" fetchpriority="low"></a></center>
<a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/">
<img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/elementor/thumbs/Build-Web-Servers-with-ESP32-and-ESP8266-eBook-2nd-Edition-500px-h-p2lw6wwnkk9ystvwe9iof8zx6yt4x7uma3cqfup534.jpg" title="Build-Web-Servers-with-ESP32-and-ESP8266-eBook-2nd-Edition-500px-h" alt="Build-Web-Servers-with-ESP32-and-ESP8266-eBook-2nd-Edition-500px-h" loading="lazy" width="129" height="180" fetchpriority="low"></a>
<h4><a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/">[eBook] Build Web Servers with ESP32 and ESP8266 (2nd Edition)</a></h4>
Build Web Server projects with the ESP32 and ESP8266 boards to control outputs and monitor sensors remotely. Learn HTML, CSS, JavaScript and client-server communication protocols <k><a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
Build Web Server projects with the ESP32 and ESP8266 boards to control outputs and monitor sensors remotely. Learn HTML, CSS, JavaScript and client-server communication protocols <k><a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
<h2>Send Messages to WhatsApp</h2>
In this guide, you'll learn how to send messages to your WhatsApp account with the ESP32. This can be useful to receive notifications from the ESP32 with sensor readings, alert messages when a sensor reading is above or below a certain threshold, when motion is detected, and many other applications. We'll program the ESP32 using Arduino IDE and to send the messages we'll use a free API called <a href="https://www.callmebot.com/blog/free-api-whatsapp-messages/" target="_blank" rel="noopener">CallMeBot</a>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/09/ESP32-Send-WhatsApp-Messages.jpg">
We have a similar tutorial for the ESP8266 board:
<a href="https://randomnerdtutorials.com/esp8266-nodemcu-send-messages-whatsapp/">ESP8266 NodeMCU: Send Messages to WhatsApp</a>
<h3>Introducing WhatsApp</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/09/Whatsapp-logo.png">
WhatsApp Messenger, or simply WhatsApp, is an internationally available American freeware, cross-platform centralized instant messaging and voice-over-IP service owned by Meta Platforms. It allows you to send messages using your phone's internet connection, so you can avoid SMS fees.
<a href="https://randomnerdtutorials.com/build-a-home-automation-system-for-100/">
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/home-automation-sb-img.jpg?fit=400%2C225&quality=100&strip=all&ssl=1" alt="" srcset="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/home-automation-sb-img.jpg?w=400&quality=100&strip=all&ssl=1 400w, https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/home-automation-sb-img.jpg"></a>
<k><a href="https://randomnerdtutorials.com/build-a-home-automation-system-for-100/">Build a Home Automation System from Scratch <U+00BB></a> </k>With Raspberry Pi, ESP8266, Arduino, and Node-RED.
<a href="https://randomnerdtutorials.com/home-automation-using-esp8266/">
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/esp8266-sb-img.jpg?fit=400%2C225&quality=100&strip=all&ssl=1" alt="" srcset="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/esp8266-sb-img.jpg?w=400&quality=100&strip=all&ssl=1 400w, https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/esp8266-sb-img.jpg"></a>
<k><a href="https://randomnerdtutorials.com/home-automation-using-esp8266/">Home Automation using ESP8266 eBook and video course <U+00BB></a> </k>Build IoT and home automation projects.
<a href="https://randomnerdtutorials.com/arduino-step-by-step-projects/">
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/arduino-sb-img.jpg?fit=400%2C225&quality=100&strip=all&ssl=1" alt="" srcset="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/arduino-sb-img.jpg?w=400&quality=100&strip=all&ssl=1 400w, https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/arduino-sb-img.jpg"></a>
<k><a href="https://randomnerdtutorials.com/arduino-step-by-step-projects/">Arduino Step-by-Step Projects <U+00BB></a> </k>Build 25 Arduino projects with our course, even with no prior experience!

<h2>Getting Started with the ESP32 Development Board</h2>
New to ESP32? Start here! The ESP32 is a series of low-cost and low-power System on a Chip (SoC) microcontrollers developed by Espressif that include Wi-Fi and Bluetooth wireless capabilities and dual-core processor. If you're familiar with the ESP8266, the ESP32 is its successor, loaded with lots of new features.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/10/ESP32-Getting-Started.jpg">
<em>Updated 29 September 2023</em>
New to the ESP32? You're in the right place. This guide contains all the information you need to get started with the ESP32. Learn what is an ESP32, how to select an ESP32 board, how to get your first program working, and much more. Here's what we'll cover in this guide:
<k>Table of Contents</k>
Introducing the ESP32
ESP32 Specifications
ESP32 vs ESP8266
ESP32 Development Boards
How to choose an ESP32 development board?
What is the best ESP32 development board for beginners?
ESP32 DEVKIT DOIT
ESP32 GPIOs Pinout Guide
How to program the ESP32?
ESP32 with Arduino IDE
Upload Code to the ESP32 using Arduino IDE
<h3>Introducing the ESP32</h3>
First, to get started, <k>what is an ESP32</k>? The ESP32 is a series of chip microcontrollers developed by Espressif. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/10/espressif-logo.png">
Why are they so popular? Mainly because of the following features:
<k>Low-cost</k>: you can get an ESP32 starting at $6, which makes it easily accessible to the general public;
<k>Low-power</k>: the ESP32 consumes very little power compared with other microcontrollers, and it supports low-power mode states like <a href="https://randomnerdtutorials.com/esp32-deep-sleep-arduino-ide-wake-up-sources/">deep sleep</a> to save power;
<k><a href="https://randomnerdtutorials.com/esp32-useful-wi-fi-functions-arduino/">Wi-Fi capabilities</a></k>: the ESP32 can easily connect to a Wi-Fi network to connect to the internet (station mode), or create its own Wi-Fi wireless network (<a href="https://randomnerdtutorials.com/esp32-access-point-ap-web-server/">access point mode</a>) so other devices can connect to itthis is essential for IoT and Home Automation projectsyou can have multiple devices communicating with each other using their Wi-Fi capabilities; 
<k>Bluetooth</k>: the ESP32 supports <a href="https://randomnerdtutorials.com/esp32-bluetooth-classic-arduino-ide/">Bluetooth classic</a> and <a href="https://randomnerdtutorials.com/esp32-bluetooth-low-energy-ble-arduino-ide/">Bluetooth Low Energy (BLE)</a>which is useful for a wide variety of IoT applications;
<a href="https://randomnerdtutorials.com/esp32-dual-core-arduino-ide/">Dual-core</a>: most ESP32 are dual-core they come with 2 Xtensa 32-bit LX6 microprocessors: core 0 and core 1.
<a href="https://randomnerdtutorials.com/esp32-pinout-reference-gpios/">Rich peripheral input/output interface</a>the ESP32 supports a wide variety of input (read data from the outside world) and output (to send commands/signals to the outside world) peripherals like <a href="https://randomnerdtutorials.com/esp32-touch-pins-arduino-ide/">capacitive touch</a>, <a href="https://randomnerdtutorials.com/esp32-adc-analog-read-arduino-ide/">ADCs</a>, DACs, UART, <a href="https://randomnerdtutorials.com/esp32-spi-communication-arduino/">SPI</a>, <a href="https://randomnerdtutorials.com/esp32-i2c-communication-arduino-ide/">I2C</a>, <a href="https://randomnerdtutorials.com/esp32-pwm-arduino-ide/">PWM</a>, and much more.
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Compatible with the Arduino programming language</a>: those that are already familiar with programming the Arduino board, you'll be happy to know that they can program the ESP32 in the Arduino style.
<a href="https://randomnerdtutorials.com/getting-started-micropython-esp32-esp8266/">Compatible with MicroPython</a>: you can program the ESP32 with MicroPython firmware, which is a re-implementation of Python 3 targeted for microcontrollers and embedded systems.
<h3>ESP32 Specifications</h3>
If you want to get a bit more technical and specific, you can take a look at the following detailed specifications of the ESP32 (source: http://esp32.net/)for more details, <a href="https://www.espressif.com/sites/default/files/documentation/esp32_datasheet_en.pdf" target="_blank" rel="noopener">check the datasheet)</a>:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/10/ESP32-module.png"><figcaption>ESP32 module: ESP-WROOM-32</figcaption>
<k>Wireless connectivity</k><k><a href="https://randomnerdtutorials.com/esp32-web-server-arduino-ide/" target="_blank">WiFi</a>:</k> 150.0 Mbps data rate with HT40
<k>Bluetooth:</k> <a href="https://randomnerdtutorials.com/esp32-bluetooth-low-energy-ble-arduino-ide/" target="_blank">BLE (Bluetooth Low Energy)</a> and <a href="https://randomnerdtutorials.com/esp32-bluetooth-classic-arduino-ide/" target="_blank">Bluetooth Classic</a>
<k>Processor:</k> Tensilica Xtensa Dual-Core 32-bit LX6 microprocessor, running at 160 or 240 MHz
<k>Memory</k>:
<k>ROM:</k> 448 KB (for booting and core functions)
<k>SRAM:</k> 520 KB (for data and instructions)
<k>RTC fast SRAM</k>: 8 KB (for data storage and main CPU during RTC Boot from the deep-sleep mode)
<k>RTC slow SRAM</k>: 8KB (for co-processor accessing during deep-sleep mode)
<k>eFuse</k>: 1 Kbit (of which 256 bits are used for the system (MAC address and chip configuration) and the remaining 768 bits are reserved for customer applications, including Flash-Encryption and Chip-ID)
<k>Embedded flash</k>: flash connected internally via IO16, IO17, SD_CMD, SD_CLK, SD_DATA_0 and SD_DATA_1 on ESP32-D2WD and ESP32-PICO-D4.
0 MiB (ESP32-D0WDQ6, ESP32-D0WD, and ESP32-S0WD chips)
2 MiB (ESP32-D2WD chip)
4 MiB (ESP32-PICO-D4 SiP module)
<k>Low Power:</k> ensures that you can still use ADC conversions, for example, during <a href="https://randomnerdtutorials.com/esp32-deep-sleep-arduino-ide-wake-up-sources/" target="_blank">deep sleep</a>.
<a href="https://randomnerdtutorials.com/esp32-pinout-reference-gpios/" target="_blank"><k>Peripheral Input/Output:</k> </a>
peripheral interface with DMA that includes <a href="https://randomnerdtutorials.com/esp32-touch-pins-arduino-ide/" target="_blank">capacitive touch</a>
<a href="https://randomnerdtutorials.com/esp32-adc-analog-read-arduino-ide/" target="_blank">ADCs (Analog-to-Digital Converter)</a>
DACs (Digital-to-Analog Converter)
<a href="https://randomnerdtutorials.com/esp32-i2c-communication-arduino-ide/" target="_blank">I2C (Inter-Integrated Circuit)</a>
UART (Universal Asynchronous Receiver/Transmitter)
<a href="https://randomnerdtutorials.com/esp32-spi-communication-arduino/" target="_blank">SPI (Serial Peripheral Interface)</a>
I2S (Integrated Interchip Sound)
RMII (Reduced Media-Independent Interface)
<a href="https://randomnerdtutorials.com/esp32-pwm-arduino-ide/" target="_blank">PWM (Pulse-Width Modulation)</a>
<k>Security:</k> hardware accelerators for AES and SSL/TLS
<h3>Main Differences Between ESP32 and ESP8266</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/08/esp32-vs-esp8266-devlopment-boards.jpg">
Previously, we mentioned that the ESP32 is the ESP8266 successor. <k>What are the main differences between ESP32 and ESP8266 boards?</k>
The ESP32 adds an <a href="https://randomnerdtutorials.com/esp32-dual-core-arduino-ide/">extra CPU core</a>, faster <a href="https://randomnerdtutorials.com/esp32-useful-wi-fi-functions-arduino/">Wi-Fi</a>, <a href="https://randomnerdtutorials.com/esp32-pinout-reference-gpios/">more GPIOs</a>, and supports <a href="https://randomnerdtutorials.com/esp32-bluetooth-classic-arduino-ide/">Bluetooth 4.2</a> and <a href="https://randomnerdtutorials.com/esp32-bluetooth-low-energy-ble-arduino-ide/">Bluetooth low energy</a>. Additionally, the ESP32 comes with <a href="https://randomnerdtutorials.com/esp32-touch-pins-arduino-ide/">touch-sensitive pins</a> that can be used to <a href="https://randomnerdtutorials.com/esp32-touch-wake-up-deep-sleep/">wake up the ESP32 from deep sleep</a>, and <a href="https://randomnerdtutorials.com/esp32-hall-effect-sensor/">built-in hall effect sensor</a>. 
Both boards are cheap, but the ESP32 costs slightly more. While the ESP32 can cost around $6 to $12, the ESP8266 can cost $4 to $6 (but it really depends on where you get them and what model you're buying).
So, in summary:
The ESP32 is faster than the ESP8266;
The ESP32 comes with more GPIOs with multiple functions;
The ESP32 supports analog measurements on 18 channels (analog-enabled pins) versus just one 10-bit ADC pin on the ESP8266;
The ESP32 supports Bluetooth while the ESP8266 doesn't;
The ESP32 is dual-core (most models), and the ESP8266 is single core;
The ESP32 is a bit more expensive than the ESP8266.
For a more detailed analysis of the differences between those boards, we recommend reading the following article: <a href="https://makeradvisor.com/esp32-vs-esp8266/" target="_blank" rel="noopener">ESP32 vs ESP8266  Pros and Cons</a>.
<h3>ESP32 Development Boards</h3>
ESP32 refers to the bare ESP32 chip. However, the ESP32 term is also used to refer to ESP32 development boards. Using ESP32 bare chips is not easy or practical, especially when learning, testing, and prototyping. Most of the time, you'll want to use an ESP32 development board.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/10/ESP32-Devleopment-boards.jpg">
These development boards come with all the needed circuitry to power and program the chip, connect it to your computer, pins to connect peripherals, built-in power and control LEDs, an antenna for wi-fi signal, and other useful features. Others even come with extra hardware like specific sensors or modules, displays, or a camera in the case of the ESP32-CAM.
<h3>How to Choose an ESP32 Development Board?</h3>
Once you start searching for ESP32 boards online, you'll find there is a wide variety of boards from different vendors. While they all work in a similar way, some boards may be more suitable for some projects than others. When looking for an ESP32 development board there are several aspects you need to take into account:
<k>USB-to-UART interface and voltage regulator circuit</k>. Most full-featured development boards have these two features. This is important to easily connect the ESP32 to your computer to upload code and apply power.
<k>BOOT and RESET/EN buttons</k> to put the board in flashing mode or reset (restart) the board. Some boards don't have the BOOT button. Usually, these boards go into flashing mode automatically.
<k>Pin configuration and the number of pins.</k> To properly use the ESP32 in your projects, you need to have access to the board pinout (like a map that shows which pin corresponds to which GPIO and its features). So make sure you have access to the pinout of the board you're getting. Otherwise, you may end up using the ESP32 incorrectly.
<k>Antenna connector</k>. Most boards come with an onboard antenna for Wi-Fi signal. Some boards come with an antenna connector to optionally connect an external antenna. Adding an external antenna increases your Wi-Fi range.
<k>Battery connector</k>. If you want to power your ESP32 using batteries, there are development boards that come with connectors for LiPo batteriesthis can be handier. You can also power a regular ESP32 with batteries through the power pins.
<k>Extra hardware features</k>. There are ESP32 development boards with extra hardware features. For example, some may come with a built-in OLED display, a LoRa module, a SIM800 module (for GSM and GPRS), a battery holder, a camera, or others.
<h4><k>What is the best ESP32 development board for beginners?</k></h4>
For beginners, we recommend an ESP32 board with a vast selection of available GPIOs, and without any extra hardware features. It's also important that it comes with voltage regular and USB input for power and upload code. 
In most of our ESP32 projects, we use the <a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/">ESP32 DEVKIT DOIT board</a>, and that's the one we recommend for beginners. There are different versions of this board with a different number of available pins (30, 36, and 38)all boards work in a similar way.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/10/ESP32-DOIT-Board.jpg">
<k>Where to Buy?</k>
You can check the following link to find the ESP32 DEVKIT DOIT board in different stores:
<a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32 DEVKIT DOIT board</a>
Other similar boards with the features mentioned previously may also be a good option like the Adafruit ESP32 Feather, Sparkfun ESP32 Thing, NodeMCU-32S, Wemos LoLin32, etc.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/10/ESP32-boards.jpg">
<h3>ESP32 DEVKIT DOIT</h3>
In this article, we'll be using the ESP32 DEVKIT DOIT board as a reference. If you have a different board, don't worry. The information on this page is also compatible with other ESP32 development boards.
The picture below shows the ESP32 DEVKIT DOIT V1 board, version with 36 GPIO pins.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/10/ESP32-Front-Back.jpg">
<h3>Specifications  ESP32 DEVKIT V1 DOIT</h3>
The following table shows a summary of the ESP32 DEVKIT V1 DOIT board features and specifications:
<table><tbody>
<tr>
<td><k>Number of cores</k></td>
<td>2 (dual core)</td>
</tr>
<tr>
<td><k>Wi-Fi</k></td>
<td>2.4 GHz up to 150 Mbits/s</td>
</tr>
<tr>
<td><k>Bluetooth</k></td>
<td>BLE (Bluetooth Low Energy) and legacy Bluetooth</td>
</tr>
<tr>
<td><k>Architecture</k></td>
<td>32 bits</td>
</tr>
<tr>
<td><k>Clock frequency</k></td>
<td>Up to 240 MHz</td>
</tr>
<tr>
<td><k>RAM</k></td>
<td>512 KB</td>
</tr>
<tr>
<td><k>Pins</k></td>
<td>30, 36, or 38 (depending on the model)</td>
</tr>
<tr>
<td><k>Peripherals</k></td>
<td>Capacitive touch, ADC (analog to digital converter), DAC (digital to analog converter), I2C (Inter-Integrated Circuit), UART (universal asynchronous receiver/transmitter), CAN 2.0 (Controller Area Netwokr), SPI (Serial Peripheral Interface), I2S (Integrated Inter-IC Sound), RMII (Reduced Media-Independent Interface), PWM (pulse width modulation), and more.</td>
</tr>
<tr>
<td><k>Built-in buttons</k></td>
<td>RESET and BOOT buttons</td>
</tr>
<tr>
<td><k>Built-in LEDs</k></td>
<td>built-in blue LED connected to GPIO2; built-in red LED that shows the board is being powered</td>
</tr>
<tr>
<td><k>USB to UART bridge</k></td>
<td>CP2102</td>
</tr>
</tbody></table>This particular ESP32 board comes with 36 pins, 18 on each side. The number of available GPIOs depends on your board model.
To learn more about the ESP32 GPIOs, read our GPIO reference guide: <a href="https://randomnerdtutorials.com/esp32-pinout-reference-gpios/">ESP32 Pinout Reference: Which GPIO pins should you use?</a>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/10/ESP32-labelled.jpg">
It comes with a microUSB interface that you can use to connect the board to your computer to upload code or apply power. 
It uses the CP2102 chip (USB to UART) to communicate with your computer via a COM port using a serial interface. Another popular chip is the CH340. Check what's the USB to UART chip converter on your board because you'll need to install the required drivers so that your computer can communicate with the board (more information about this later in this guide).
This board also comes with a RESET button (may be labeled EN) to restart the board and a BOOT button to put the board in flashing mode (available to receive code). Note that some boards may not have a BOOT button.
It also comes with a built-in blue LED that is internally connected to GPIO 2. This LED is useful for debugging to give some sort of visual physical output. There's also a red LED that lights up when you provide power to the board.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/10/ESP32-board-Built_in-LED-turned-on-HIGH.jpg">
<h3>ESP32 GPIOs Pinout Guide</h3>
The ESP32 chip comes with 48 pins with multiple functions. Not all pins are exposed in all ESP32 development boards, and some pins should not be used. The ESP32 DEVKIT V1 DOIT board usually comes with 36 exposed GPIOs that you can use to connect peripherals.
<k>Power Pins</k>
Usually, all boards come with power pins: 3V3, GND, and VIN. You can use these pins to power the board (if you're not providing power through the USB port), or to get power for other peripherals (if you're powering the board using the USB port).
<k>General Purpose Input Output Pins (GPIOS)</k>
Almost all GPIOs have a number assigned and that's how you should refer to themby their number.
With the ESP32 you can decide which pins are UART, <a href="https://randomnerdtutorials.com/esp32-i2c-communication-arduino-ide/">I2C</a>, or <a href="https://randomnerdtutorials.com/esp32-spi-communication-arduino/">SPI </a> you just need to set that on the code. This is possible due to the ESP32 chip's multiplexing feature that allows to assign multiple functions to the same pin.
If you don't set them on the code, the pins will be configured by default as shown in the figure below (the pin location can change depending on the manufacturer). Additionally, there are pins with specific features that make them suitable or not for a particular project.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2018/08/ESP32-DOIT-DEVKIT-V1-Board-Pinout-36-GPIOs-updated.jpg">
We have a detailed guide dedicated to the ESP32 GPIOs that we recommend you read: <a href="https://randomnerdtutorials.com/esp32-pinout-reference-gpios/">ESP32 Pinout Reference Guide</a>. It shows how to use the ESP32 GPIOs and explains what are the best GPIOs to use depending on your project.
The placement of the GPIOs might be different depending on your board model. However, usually, each specific GPIO works in the same way regardless of the development board you're using (with some exceptions). For example, regardless of the board, usually GPIO5 is always the VSPI CS0 pin, GPIO 23 always corresponds to VSPI MOSI for SPI communication, etc.
<h3>How to Program the ESP32?</h3>
The ESP32 can be programmed using different firmware and programming languages. You can use:
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Arduino C/C++ using the Arduino core for the ESP32</a>
Espressif IDF (IoT Development Framework)
<a href="https://randomnerdtutorials.com/getting-started-micropython-esp32-esp8266/" target="_blank">Micropython</a>
JavaScript
LUA

Our preferred method to program the ESP32 is with C/C++ Arduino programming language. We also have some guides and tutorials using <a href="https://randomnerdtutorials.com/projects-esp32-esp8266-micropython/">MicroPython firmware</a>.
Throughout this guide, we'll cover<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/"> programming the ESP32 using the Arduino core for the ESP32 board</a>. If you prefer using MicroPython, please refer to this guide: <a href="https://randomnerdtutorials.com/getting-started-micropython-esp32-esp8266/">Getting Started with MicroPython on ESP32</a>.
<h3>Programming ESP32 with Arduino IDE</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/10/arduino-logo.png">
To program your boards, you need an IDE to write your code. For beginners, we recommend using Arduino IDE. While it's not the best IDE, it works well and is simple and intuitive to use for beginners. After getting familiar with Arduino IDE and you start creating more complex projects, you may find it useful to use <a href="https://randomnerdtutorials.com/vs-code-platformio-ide-esp32-esp8266-arduino/">VS Code with the Platformio extension</a> instead.
If you're just getting started with the ESP32, start with <a href="https://www.arduino.cc/en/software" target="_blank" rel="noopener">Arduino IDE</a>. At the time of writing this tutorial, <k>we recommend using the legacy version (1.8.19)</k> with the ESP32. While version 2 works well with Arduino, there are still some bugs and some features that are not supported yet for the ESP32.
<h3>Installing Arduino IDE</h3>
To run Arduino IDE, you need JAVA installed on your computer. If you don't, go to the following website to download and install the latest version: <a href="http://java.com/download" target="_blank" rel="noopener">http://java.com/download</a>.
<h4>Downloading Arduino IDE</h4>
To download the Arduino IDE, visit the following URL:
<a href="https://www.arduino.cc/en/Main/Software" target="_blank" rel="noopener">https://www.arduino.cc/en/Main/Software</a>
<k>Don't install the 2.0 version.</k> At the time of writing this tutorial, <k>we recommend using the legacy version (1.8.19)</k> with the ESP32. While version 2 works well with Arduino, there are still some bugs and some features that are not supported yet for the ESP32.
Scroll down until you find the legacy version section.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/10/Arduino-IDE-Install-Legacy.png">
Select your operating system and download the software. For Windows, we recommend downloading the <k>Windows ZIP file</k>. 
<h3>Running Arduino IDE</h3>
Grab the folder you've just downloaded and unzip it. Run the executable file called <em>arduino.exe</em> (highlighted below).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/10/execute-arduino-ide.png">
The Arduino IDE window should open.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/10/arduino-ide-1819.png">
<h3>Installing the ESP32 in Arduino IDE</h3>
To be able to program the ESP32 using Arduino IDE, you need to add support for the ESP32 boards. Follow the next steps:
<ol>
Go to <k>File</k> > <k>Preferences</k>.
</ol>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/10/Arduino-IDE-Preferences.png">
<ol start="2">Enter the following into the <em>Additional Board Manager URLs</em> field. This will add support for ESP32 and ESP8266 boards as well.</ol>
https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_index.json, http://arduino.esp8266.com/stable/package_esp8266com_index.json
 See the figure below. Then, click the <k>OK</k> button.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/10/Additional-Boards-Manager-URL.png">
<ol start="3">Open the <k>Boards Manager</k>. Go to <k>Tools </k>> <k>Board</k> ><k>Boards Manager</k>
</ol>
<ol start="4">Search for <k>ESP32</k> and install the <k>ESP32 by Espressif Systems</k>:</ol>
 That's it. It will be installed after a few seconds.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/10/Boards-Manager-ESP32-Arduino-IDE.png">
After this, restart your Arduino IDE.
Then, go to <k>Tools </k>> <k>Board </k>and check that you have ESP32 boards available.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/10/ESP32-boards-available-arduino-ide.png">
Now, you're ready to start programming your ESP32 using Arduino IDE.
<h3>ESP32 Examples</h3>
In your Arduino IDE, you can find multiple examples for the ESP32. First, make sure you have an ESP32 board selected in <k>Tools </k>> <k>Board</k>. Then, simply go to <k>File </k>> <k>Examples </k>and check out the examples under the ESP32 section.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/10/Examples-for-ESP32-Arduino-IDE.png">
<h3>Update the ESP32 Core in Arduino IDE</h3>
Once in a while, it's a good idea to check if you have the latest version of the ESP32 boards add-on installed.
You just need to go to <k>Tools</k> > <k>Board</k> <k>> Boards Manager</k>, search for <k>ESP32</k>, and check the version that you have installed. If there is a more recent version available, select that version to install it.
<h3>Upload Code to the ESP32 using Arduino IDE</h3>
To show you how to upload code to your ESP32 board, we'll try a simple example available in the Arduino IDE examples for the ESP32.
First, make sure you have an ESP32 selected in <k>Tools </k>> <k>Board</k>. Then, go to <k>File </k>> <k>Examples </k>> <k>WiFi </k>> <k>WiFiScan</k>.
This will load a sketch that scans Wi-Fi networks within the range of your ESP32 board.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/10/ESP32-WiFiScan-Example.png">
Connect your ESP32 development board to your computer using a USB cable. If you have an ESP32 DEVKIT DOIT board, the built-in red LED will turn on. This indicates the board is receiving power.
<k>Important: </k> you must use a USB cable with data wires. Some USB cables from chargers or power banks are power only and they don't transfer datathese won't work.
Now, follow the next steps to upload the code.
1) Go to <k>Tools</k> > <k>Board</k>, scroll down to the ESP32 section and select the name of your ESP32 board. In my case, it's the DOIT ESP32 DEVKIT V1 board.
2) Go to <k>Tools</k> > <k>Port</k> and select a COM port available. If the COM port is grayed out, this means you don't have the required USB drivers. Check the section Installing USB Drivers before proceeding.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/10/ESP32-selecting-COM-port-Arduino-IDE.png">
3) Press the upload button.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/05/arduino-2-0-upload-button.png">
Some boards will automatically go into flashing mode and the code will be successfully uploaded straight away.
Other boards don't go into flashing mode automatically, so you may end up getting the following error.
Failed to connect to ESP32: Timed out... Connecting...
Or something like:
A fatal error occurred: Failed to connect to ESP32: Wrong boot mode detected (0x13)! The chip needs to be in download mode.
This means the ESP32 was not in flashing mode when you tried to upload the code. In this situation, you should long press the board <k>BOOT </k>button, when you start seeing the <k>Connecting.</k> message on the debugging window.
<k>Note: </k> in some boards, a simple trick can make the ESP32 go into flashing mode automatically. Check it out on the following tutorial: <a href="https://randomnerdtutorials.com/solved-failed-to-connect-to-esp32-timed-out-waiting-for-packet-header/">[SOLVED] Failed to connect to ESP32: Timed out waiting for packet header</a>.
Now, the code should be successfully uploaded to the board. You should get a <k>Done uploading </k>message.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/10/ESP32-Arduino-IDE-done-uploading.png">
<h3>Demonstration</h3>
To see if the code is working as expected, open the Serial Monitor at a baud rate of 115200.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/10/Serial-Monitor.png">
Press the ESP32 RST or EN button to restart the board and start running the newly uploaded code.
You should get a list of nearby wi-fi networks.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/10/ESP32-WiFiScan-Serial-Monitor.png">
This means everything went as expected.
<h3>Installing ESP32 USB Drivers</h3>
After connecting the ESP32 board to your computer, if the COM port in Arduino IDE is grayed out, it means you don't have the necessary USB drivers installed on your computer.
Most ESP32 boards either use the CP2101 or CH340 drivers. Check the USB to UART converter on your board, and install the corresponding drivers.
You'll easily find instructions with a quick google search. For example install CP2101 drivers Windows.
<h3>Wrapping Up</h3>
We hope you've found this getting started guide useful. I think we've included all the required information for you to get started. You learned what is an ESP32, how to choose an ESP32 development board, and how to upload new code to the ESP32 using Arduino IDE.
Want to learn more? We recommend the following tutorials to get started:
<a href="https://randomnerdtutorials.com/esp32-digital-inputs-outputs-arduino/">ESP32 Digital Inputs and Digital Outputs (Arduino IDE)</a>
<a href="https://randomnerdtutorials.com/esp32-web-server-arduino-ide/" target="_blank">ESP32 Web Server Tutorial</a>
Also, don't forget to take a look at the ESP32 pinout to learn how to use its GPIOs:
<a href="https://randomnerdtutorials.com/esp32-pinout-reference-gpios/">ESP32 Pinout Reference: Which GPIO pins should you use?</a>
If you're serious about learning about the ESP32, we recommend taking a look at our best-selling eBook:
<a href="https://randomnerdtutorials.com/learn-esp32-with-arduino-ide/"><k>Learn ESP32 with Arduino IDE</k> <k>eBook</k></a>
You can also check all our free ESP32 tutorials and guides on the following link:
<a href="https://randomnerdtutorials.com/projects-esp32/">More ESP32 Projects</a>
If you like ESP32 make sure you <a href="https://randomnerdtutorials.com/download">subscribe to our blog</a>, so you don't miss upcoming projects.
<k>Do you have any questions? </k><k>Leave a comment down below!</k>
Thanks for reading.
<center><a href="https://randomnerdtutorials.com/pcbway" target="_blank"><img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/2022/03/728x280.jpg" width="728" height="280" loading="lazy" fetchpriority="low"></a></center>
<a href="https://randomnerdtutorials.com/smart-home-ebook/">
<img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/elementor/thumbs/Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px-pupj8i6e7hlzpgwxe82jjd8skst9vmrjt9lpqb0v0g.jpg" title="Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px" alt="SMART HOME with Raspberry Pi ESP32 and ESP8266 Node-RED InfluxDB eBook" loading="lazy" width="117" height="180" fetchpriority="low"></a>
<h4><a href="https://randomnerdtutorials.com/smart-home-ebook/">SMART HOME with Raspberry Pi, ESP32, ESP8266 [eBook] </a></h4>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
<h2>Wireless Communication Protocols</h2>
The ESP32 supports several different wireless communication protocols. Each protocol has its advantages and disadvantages and one can be more suitable than the other depending on the application. This guide is a compilation of all our articles about wireless communication protocols with the ESP32.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/09/ESP32-Wireless-Communication-protocols.jpg">
<h3>Communication Protocols</h3>
In this article, we'll cover the following communication protocols:
BLE (Bluetooth Low Energy)
Bluetooth Classic
ESP-NOW
Wi-Fi
MQTT
LoRa
GSM/GPRS/LTE
<em>We'll keep this article updated as new tutorials are posted.</em>
<h3>Bluetooth Low Energy (BLE)</h3>
Bluetooth Low Energy, BLE for short, is a power-conserving variant of Bluetooth. BLE's primary application is short-distance transmission of small amounts of data (low bandwidth). 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/Bluetooth-low-energy.png">
Unlike Bluetooth which is always on, BLE remains in sleep mode constantly except for when a connection is initiated. This makes it consume very low power. BLE consumes approximately 100x less power than Bluetooth (depending on the use case).
Additionally, BLE supports not only point-to-point communication, but also broadcast mode, and mesh network. Due to its properties, BLE is suitable for applications that need to exchange small amounts of data periodically running on a coin cell. For example, BLE is of great use in healthcare, fitness, tracking, beacons, security, and home automation industries.
Low power consumption
Short distance transmission
Low bandwidth (small amounts of data)
Ideal for exchanging small amounts of data periodically
Supports point-to-point, broadcast, and mesh network
Learn how to get started with BLE on the ESP32 with our guides:
<a href="https://randomnerdtutorials.com/esp32-bluetooth-low-energy-ble-arduino-ide/">Getting Started with ESP32 Bluetooth Low Energy (BLE) on Arduino IDE</a>
<a href="https://randomnerdtutorials.com/esp32-ble-server-client/">ESP32 BLE Server and Client (Bluetooth Low Energy)</a>
<hr>
<h3>Bluetooth Classic</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/bluetooth-1.png">
Bluetooth is a wireless technology standard used for exchanging data between fixed and mobile devices over short distances. It is optimized for continuous data streaming, while BLE is optimized for short burst data transmission. It consumes approximately x100 more power than BLE.
 Short distance transmission
 Optimized for continuous data streaming
Learn how to use Bluetooth Classic with the ESP32:
<a href="https://randomnerdtutorials.com/esp32-bluetooth-classic-arduino-ide/">ESP32 Bluetooth Classic with Arduino IDE  Getting Started</a>
<hr>
<h3>ESP-NOW</h3>
ESP-NOW is a connectionless communication protocol developed by Espressif that features short packet transmission. This protocol enables multiple devices to talk to each other in an easy way.
Stating the Espressif website, ESP-NOW is a <em>protocol developed by Espressif, which enables multiple devices to communicate with one another without using Wi-Fi. The protocol is similar to the low-power 2.4GHz wireless connectivity (). The pairing between devices is needed prior to their communication. After the pairing is done, the connection is safe and peer-to-peer, with no handshake being required</em>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/esp-now-logo.png">
Fast communication protocol
Up to 250-byte payload can be carried
Encrypted and unencrypted communication
Range communication (220 meters in opan en field accordingly to our experiments)
Read our articles about ESP-NOW:
<a href="https://randomnerdtutorials.com/esp-now-esp32-arduino-ide/">Getting Started with ESP-NOW (ESP32 with Arduino IDE)</a>
<a href="https://randomnerdtutorials.com/esp-now-two-way-communication-esp32/">ESP-NOW Two-Way Communication Between ESP32 Boards</a>
<a href="https://randomnerdtutorials.com/?s=esp-now">More ESP-NOW tutorials</a>
<hr>
<h3>Wi-Fi (client-server communication protocols)</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/wi-fi-logo.png">
<h3>HTTP Requests</h3>
You can exchange data between ESP32 boards using HTTP requests. One board acts as a server (Wi-Fi access point) and the other board acts as a client (Wi-Fi station).
Learn how to send data from one ESP32 board to the other using HTTP requests:
<a href="https://randomnerdtutorials.com/esp32-client-server-wi-fi/">ESP32 Client-Server Wi-Fi Communication Between Two Boards</a>
The ESP32 can also make HTTP requests to third-party services on the internet to send or receive data. For that, the ESP32 needs to be connected to a Wi-Fi network with internet access.
<a href="https://randomnerdtutorials.com/esp32-http-get-post-arduino/">ESP32 HTTP GET and HTTP POST with Arduino IDE (JSON, URL Encoded, Text)</a>
<h3>Server-Sent Events</h3>
Server-Sent Events (SSE) allow the client to receive automatic updates from a server via HTTP connection. 
The client initiates the SSE connection and the server uses the event source protocol to send updates to the client. The client will receive updates from the server, but it can't send any data to the server after the initial handshake.
Server-sent events are useful when you need to send new data to the server without the need for a request by the server, for example send sensor readings periodically or notifications.
Learn how to use server-sent events on an ESP32 web server:
<a href="https://randomnerdtutorials.com/esp32-web-server-sent-events-sse/">ESP32 Web Server using Server-Sent Events</a>
<h3>WebSocket</h3>
A WebSocket is a persistent connection between a client and server that allows bidirectional communication between both parties using a TCP connection. This means you can send data from the client to the server and from the server to the client at any given time.
Get started with WebSocket protocol on the ESP32 by following the next tutorial:
<a href="https://randomnerdtutorials.com/esp32-websocket-server-arduino/">ESP32 WebSocket Server: Control Outputs (Arduino IDE)</a>
<hr>
<h3>MQTT</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/09/mqtt-logo.jpg">
MQTT stands for Message Queuing Telemetry Transport. It is a lightweight publish and subscribe system where you can publish and receive messages as a client. MQTT is a simple messaging protocol, designed for constrained devices with low-bandwidth.
To use MQTT to exchange data, you need an MQTT broker that is responsible for receiving all messages, filtering the messages, and publishing the message to all subscribed clients. MQTT is perfect for IoT projects with multiple devices.
Read our articles about the  MQTT communication protocol with the ESP32.
<a href="https://randomnerdtutorials.com/what-is-mqtt-and-how-it-works/">What is MQTT and How It Works</a>
<a href="https://randomnerdtutorials.com/esp32-mqtt-publish-subscribe-arduino-ide/">ESP32 MQTT  Publish and Subscribe with Arduino IDE</a>
<a href="https://randomnerdtutorials.com/micropython-mqtt-esp32-esp8266/">MicroPython  Getting Started with MQTT on ESP32/ESP8266</a>
<hr>
<h3>LoRa</h3>
LoRa is a wireless data communication technology that uses a radio modulation technique that can be generated by Semtech LoRa transceiver chips. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/03/LoRa.png">
LoRa allows long range communication of small amounts of data (which means a low bandwidth), and high immunity to interference while minimizing power consumption. So, it allows long distance communication with low power requirements.
Long range communication
Low bandwidth (small amounts of data)
High immunity to interference
Low power consumption
To use LoRa with the ESP32 boards, you need a LoRa transceiver chip. The word transceiver means that the chip can send and receive LoRa messages. There are ESP32 boards that already come with an <a aria-label="on-board LoRa transceiver chip (opens in a new tab)" href="https://makeradvisor.com/tools/ttgo-lora32-sx1276-esp32-oled/" target="_blank">on-board LoRa transceiver chip</a>, which makes wiring much simpler.
Read our articles about LoRa communication:
<a href="https://randomnerdtutorials.com/esp32-lora-rfm95-transceiver-arduino-ide/">ESP32 with LoRa using Arduino IDE  Getting Started</a>  learn what is LoRa, how to connect a LoRa chip to the ESP32, and exchange data between boards.
<a href="https://randomnerdtutorials.com/ttgo-lora32-sx1276-arduino-ide/">TTGO LoRa32 SX1276 OLED Board: Getting Started with Arduino IDE</a>  learn how to get started with LoRa with a board with a built-in LoRa chip and OLED display.
<a href="https://randomnerdtutorials.com/esp32-lora-sensor-web-server/">ESP32 LoRa Sensor Monitoring with Web Server (Long Range Communication)</a>  set up an ESP32 as a LoRa receiver and as a web server to display received readings.
<hr>
<h3>GSM/GPRS/LTE</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/09/4G-LTE.png">
You can connect your ESP32 board to a modem to be able to send and receive SMS and phone calls and connect to the internet using a SIM card as you would do with your smartphone. Some of those modems can also get GPS data like latitude, longitude, altitude, and date and time.
There are different modules available that are compatible with the ESP32 and there are also ESP32 boards that already come with a built-in modem and all the necessary circuitry.
We've experimented with the<a href="https://makeradvisor.com/ttgo-t-call-esp32-with-sim800l-gsm-gprs/" target="_blank"> ESP32 SIM8000L (2G)</a>, and the <a href="https://makeradvisor.com/lilygo-t-sim7000g-esp32/" target="_blank">ESP32 SIM7000G (3G and 4G)</a>, and we had pretty good results.
To get started with those boards, you can take a look at the following tutorials:
<a href="https://randomnerdtutorials.com/lilygo-t-sim7000g-esp32-lte-gprs-gps/">Getting Started with LILYGO <k>T-SIM7000G</k> ESP32 (LTE, GPRS, and GPS)</a>
<a href="https://randomnerdtutorials.com/esp32-sim800l-publish-data-to-cloud/">ESP32 Publish Data to Cloud without Wi-Fi (TTGO T-Call ESP32 <k>SIM800L</k>)</a>
<a href="https://randomnerdtutorials.com/esp32-sim800l-send-text-messages-sms/">ESP32 <k>SIM800L</k>: Send Text Messages (SMS Alert) with Sensor Readings</a>
<a href="https://randomnerdtutorials.com/esp32-cloud-mqtt-broker-sim800l/">Connect ESP32 to Cloud MQTT Broker (TTGO T-Call ESP32 <k>SIM800L</k>)</a>
<h3>Wrapping Up</h3>
There are many different wireless communication protocols compatible with the ESP32 boards. This makes it one of the most versatile boards for IoT and Home Automation projects. In this article, we've covered LoRa, Bluetooth, Bluetooth Low Energy, ESP-NOW, Wi-Fi, MQTT, and GSM/GPRS/LTE.
<h2>ESP-NOW Encrypted Messages</h2>
In this guide, you'll learn how to encrypt ESP-NOW messages exchanged between ESP32 boards. ESP-NOW uses the CCMP method for encryption using a Primary Master Key (PMK) and Local Master Keys (LMK).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/09/ESP32-ESP-NOW-Encrypted-Messages.jpg">
If you're new to ESP-NOW, we recommend reading the following getting started guide first to get familiar with ESP-NOW concepts and functions on the ESP32:
<a href="https://randomnerdtutorials.com/esp-now-esp32-arduino-ide/">Getting Started with ESP-NOW (ESP32 with Arduino IDE)</a>
<h3>CCMP Security Protocol</h3>
CCMP means Counter Mode with Cipher Block Chaining Message Authentication Code Protocol. This is an encryption protocol designed for Wireless LAN. ESP-NOW can use the CCMP method to encrypt messages. 
Accordingly to the <a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/network/esp_now.html?highlight=esp_now_set_pmk#security" target="_blank">documentation</a>:
<em>ESP-NOW use <k>CCMP </k>method which can be referenced in IEEE Std. 802.11-2012 to protect the vendor-specific action frame. </em>
The Wi-Fi device maintains a <k>Primary Master Key (PMK)</k> and several <k>Local Master Keys (LMK)</k>. The length of the keys is 16 bytes.
<h3>Primary Master Key (PMK)</h3>
PMK is used to encrypt LMK with the AES-128 algorithm. To set the PMK key of the Wi-Fi device, you can use the esp_now_set_pmk() function to set PMK. If PMK is not set, a default PMK will be used.
<h3>Local Master Key (LMK)</h3>
You should set the LMK of the paired device to encrypt the vendor-specific action frame with CCMP method. The maximum number of different LMKs is six. The LMK is a property of the peer, esp_now_peer_info_t object, and can be set on the lmk property as we'll see later.
<h3>ESP32: Getting Board MAC Address</h3>
To communicate via ESP-NOW, you need to know the MAC Addresses of the boards so that you can add each other as peers.
Each ESP32 has a <a href="https://randomnerdtutorials.com/get-change-esp32-esp8266-mac-address-arduino/">unique MAC Address</a> and that's how we identify each board (learn how to <a href="https://randomnerdtutorials.com/get-change-esp32-esp8266-mac-address-arduino/">Get and Change the ESP32 MAC Address</a>).
To get your board's MAC Address, upload the following code.
<k>// Complete Instructions to Get and Change ESP MAC Address: https://RandomNerdTutorials.com/get-change-esp32-esp8266-mac-address-arduino/
#include "WiFi.h"
 
void setup(){
  Serial.begin(115200);
  WiFi.mode(WIFI_MODE_STA);
  Serial.println(WiFi.macAddress());
}
 
void loop(){
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_Get_MAC_Address.ino" target="_blank">View raw code</a>
After uploading the code, open the Serial Monitor at a baud rate of 115200 and press the ESP32 RST/EN button. The MAC address should be printed as follows:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/01/ESP32_MAC_Address_Serial_monitor.jpg">
Save your board MAC address because you'll need it in the next ESP-NOW examples.
<h3>Project Overview</h3>
The example we'll show you is very simple so that you can understand how to encrypt your ESP-NOW messages. The sender will send a structure that contains two random numbers, x and y, and a counter variable (to keep track of the number of sent packets).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/09/ESP-NOW-send-encrypted-messages.png">
Here are the main steps:
<ol>
The sender sets its PMK;
The sender adds the receiver as a peer and sets its LMK;
The receiver sets its PMK (should be the same of the receiver);
The receiver adds the sender as a peer and sets its LMK (should be the same as the one set on the sender board);
The sender sends the following structure to the receiver board:
</ol>
<k>typedef struct struct_message {
    int counter;
    int x;
    int y;
} struct_message;</k>
<ol start="6">The receiver gets the message.</ol>
<h3>ESP32 Sender Sketch (ESP-NOW Encrypted)</h3>
Here's the code for the ESP32 Sender board. Copy the code to your Arduino IDE, but don't upload it yet. You need to make a few modifications to make it work for you.
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/?s=esp-now
  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files.
  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
*/
#include &lt;esp_now.h>
#include &lt;WiFi.h>
// REPLACE WITH THE RECEIVER'S MAC Address
uint8_t receiverAddress[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
// PMK and LMK keys
static const char* PMK_KEY_STR = "REPLACE_WITH_PMK_KEY";
static const char* LMK_KEY_STR = "REPLACE_WITH_LMK_KEY";
// Structure example to send data
// Must match the receiver structure
typedef struct struct_message {
    int counter;
    int x;
    int y;
} struct_message;
// Create a struct_message called myData
struct_message myData;
// Counter variable to keep track of number of sent packets
int counter;
// callback when data is sent
void OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {
  Serial.print("\r\nLast Packet Send Status:\t");
  Serial.println(status == ESP_NOW_SEND_SUCCESS ? "Delivery Success" : "Delivery Fail");
}
 
void setup() {
  // Init Serial Monitor
  Serial.begin(115200);
 
  // Set device as a Wi-Fi Station
  WiFi.mode(WIFI_STA);
  
  // Init ESP-NOW
  if (esp_now_init() != ESP_OK) {
    Serial.println("There was an error initializing ESP-NOW");
    return;
  }
  
  // Set PMK key
  esp_now_set_pmk((uint8_t *)PMK_KEY_STR);
  
  // Register the receiver board as peer
  esp_now_peer_info_t peerInfo;
  memcpy(peerInfo.peer_addr, receiverAddress, 6);
  peerInfo.channel = 0;
  //Set the receiver device LMK key
  for (uint8_t i = 0; i &lt; 16; i++) {
    peerInfo.lmk[i] = LMK_KEY_STR[i];
  }
  // Set encryption to true
  peerInfo.encrypt = true;
  
  // Add receiver as peer        
  if (esp_now_add_peer(&peerInfo) != ESP_OK){
    Serial.println("Failed to add peer");
    return;
  }
  // Once ESPNow is successfully Init, we will register for Send CB to
  // get the status of transmitted packet
  esp_now_register_send_cb(OnDataSent);
}
void loop() {
  static unsigned long lastEventTime = millis();
  static const unsigned long EVENT_INTERVAL_MS = 5000;
  if ((millis() - lastEventTime) > EVENT_INTERVAL_MS) {
    lastEventTime = millis();
    
    // Set values to send
    myData.counter = counter++;
    myData.x = random(0,50);
    myData.y = random(0,50);
  
    // Send message via ESP-NOW
    esp_err_t result = esp_now_send(receiverAddress, (uint8_t *) &myData, sizeof(myData));
    if (result == ESP_OK) {
      Serial.println("Sent with success");
    }
    else {
      Serial.println("Error sending the data");
    }  
  }
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP/ESP_NOW/ESP_NOW_Encryption/ESP32_Sender_Encrypted.ino" target="_blank">View raw code</a>
Don't forget you need to add the receiver's MAC address in the code. In my case, the receiver MAC address is 30:AE:A4:07:0D:64. So, it will look as follows on the code:
<k>// REPLACE WITH THE RECEIVER'S MAC Address
uint8_t receiverAddress[] = {0x30, 0xAE, 0xA4, 0x07, 0x0D, 0x64};</k>
Let's take a look at the relevant parts of code that deal with encryption.
Create the PMK and LMK keys for this device on the following lines. It can be made of numbers and letters and the keys are 16 bytes (you can search online for online byte counter to check the length of your keys).
<k>static const char* PMK_KEY_STR = "REPLACE_WITH_PMK_KEY";
static const char* LMK_KEY_STR = "REPLACE_WITH_LMK_KEY";</k>
For example, the key can be something like this 00XXmkwei/lpP<U+00C7>f. 
The sender and receiver should have the same PMK and LMK keys.
Set the device PMK key using the esp_now_set_pmk() function as follows:
<k>esp_now_set_pmk((uint8_t *)PMK_KEY_STR);</k>
The LMK is a property of the peer device, so you must set it when you register a device as peer. You set the LMK as follows:
<k>for (uint8_t i = 0; i &lt; 16; i++) {
   peerInfo.lmk[i] = LMK_KEY_STR[i];
}</k>
You also need to set the encrypt peer property as true.
<k>peerInfo.encrypt = true;</k>
And that's it. This is all you need to do to encrypt ESP-NOW messages. Now, you can use the ESP-NOW function to exchange data and the messages will be encrypted.
<h3>ESP32 Receiver Sketch (ESP-NOW Encrypted Messages)</h3>
Here's the code for the ESP32 Receiver board. Copy the code to your Arduino IDE, but don't upload it yet. You need to make a few modifications to make it work for you.
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/?s=esp-now
  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files.
  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
*/
#include &lt;esp_now.h>
#include &lt;WiFi.h>
// REPLACE WITH YOUR MASTER MAC Address
uint8_t masterMacAddress[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
// PMK and LMK keys
static const char* PMK_KEY_STR = "REPLACE_WITH_PMK_KEY";
static const char* LMK_KEY_STR = "REPLACE_WITH_LMK_KEY";
// Structure example to send data
// Must match the sender structure
typedef struct struct_message {
    int counter; // must be unique for each sender board
    int x;
    int y;
} struct_message;
// Create a struct_message called myData
struct_message myData;
// Function to print MAC address on Serial Monitor
void printMAC(const uint8_t * mac_addr){
  char macStr[18];
  snprintf(macStr, sizeof(macStr), "%02x:%02x:%02x:%02x:%02x:%02x",
           mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5]);
  Serial.println(macStr);
}
// Callback function executed when data is received
void OnDataRecv(const uint8_t * mac_addr, const uint8_t *incomingData, int len) {
 
  Serial.print("Packet received from: ");
  printMAC(mac_addr);
  
  memcpy(&myData, incomingData, sizeof(myData));
  Serial.print("Bytes received: ");
  Serial.println(len);
  Serial.print("Packet number: ");
  Serial.println(myData.counter);
  Serial.print("X: ");
  Serial.println(myData.x);
  Serial.print("Y: ");
  Serial.println(myData.y);
}
void setup() {
  // Init Serial Monitor
  Serial.begin(115200);
 
  // Set device as a Wi-Fi Station
  WiFi.mode(WIFI_STA);
  
  // Init ESP-NOW
  if (esp_now_init() != ESP_OK) {
    Serial.println("There was an error initializing ESP-NOW");
    return;
  }
  
  // Set the PMK key
  esp_now_set_pmk((uint8_t *)PMK_KEY_STR);
  
  // Register the master as peer
  esp_now_peer_info_t peerInfo;
  memcpy(peerInfo.peer_addr, masterMacAddress, 6);
  peerInfo.channel = 0;
  // Setting the master device LMK key
  for (uint8_t i = 0; i &lt; 16; i++) {
    peerInfo.lmk[i] = LMK_KEY_STR[i];
  }
  // Set encryption to true
  peerInfo.encrypt = true;
  
  // Add master as peer       
  if (esp_now_add_peer(&peerInfo) != ESP_OK){
    Serial.println("Failed to add peer");
    return;
  }
  
  // Once ESPNow is successfully Init, we will register for recv CB to
  // get recv packer info
  esp_now_register_recv_cb(OnDataRecv);
}
void loop() {
  
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP/ESP_NOW/ESP_NOW_Encryption/ESP32_Receiver_Encrypted.ino" target="_blank">View raw code</a>
You need to add the sender board as a peer. So, you need to know its MAC address. Add the sender MAC address in the following line:
<k>uint8_t masterMacAddress[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};</k>
Set the PMK and LMK keys. Should be the same as the other board.
<k>static const char* PMK_KEY_STR = "REPLACE_WITH_PMK_KEY";
static const char* LMK_KEY_STR = "REPLACE_WITH_LMK_KEY";</k>
Set the device PMK key using the esp_now_set_pmk() function as follows:
<k>esp_now_set_pmk((uint8_t *)PMK_KEY_STR);</k>
The LMK is a property of the peer device, so you must set it when you register a device as peer. You set the LMK as follows:
<k>for (uint8_t i = 0; i &lt; 16; i++) {
  peerInfo.lmk[i] = LMK_KEY_STR[i];}</k>
You also need to set the encrypt peer property as true.
<k>peerInfo.encrypt = true;</k>
And that's it, now the receiver board can receiver and decrypt the encrypted messages sent by the sender.
<h3>Demonstration</h3>
Upload the codes to the corresponding boards.
Open the Serial Monitor to check what's going on. You can use PuTTY to be able to see the messages on both boards simultaneously. 
This is what you should get on the receiver board:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/09/ESP-NOW-Receiver-Encrypted-Messages-Received.png">
On the sender board, you should get Delivery Success messages.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/09/ESP-NOW-Sender-Encrypted-Messages-Serial-Monitor-Delivery-Success.png">
<h3>Wrapping Up</h3>
In this tutorial, you learned how to encrypt ESP-NOW messages using PMK and LMK keys.
I tested the encryption in different scenarios and here are the results:
<k>Sender and receiver encrypted with same keys</k>: receiver board receives the messages successfully;
The sender sends encrypted messages, but the receiver doesn't have the keys or has different keys: the receiver doesn't get the messages;
<k>The receiver has the code for encryption but the sender doesn't</k>: the receiver gets the messages anyway. I don't think this is the behavior we expected. Since we add the encryption code on both boards, one would expect that if the receiver board got a message that is not encrypted, it would ignore it. But that's not what happens. It receives all messages, encrypted and not encrypted. At the moment, there isn't a way to know if the received message is encrypted or not, which seems like a limitation at the moment. 
<h2>ESP-NOW: Auto-pairing for ESP32/ESP8266 with Bidirectional Communication and Web Server</h2>
This guide shows how to build an ESP32 web server and use ESP-NOW communication protocol simultaneously. We'll show you how to establish a two-way communication between the master (web server) and slaves, and how to automatically add boards to the network (auto-pairing).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/09/ESP-NOW-Web-Server-auto-pairing.jpg">
This tutorial is an improvement of the following: 
<a href="https://randomnerdtutorials.com/esp32-esp-now-wi-fi-web-server/">ESP32: ESP-NOW Web Server Sensor Dashboard (ESP-NOW + Wi-Fi)</a>
The new version includes:
Two-way communication between the server and the slaves;
Auto-pairing peersyou don't need to know any of the boards' MAC addresses. You don't need to add peers manually. You just need to run the codes provided and the boards will be automatically added to the ESP-NOW network.
The improvements were suggested by one of our readers (<k>Jean-Claude Servaye</k>). You can find the original codes on <a href="https://github.com/Servayejc" target="_blank">his GitHub page</a>.
If you're new to ESP-NOW, we recommend getting familiar with ESP-NOW concepts and functions first. Check the following getting started guides:
<a href="https://randomnerdtutorials.com/esp-now-esp32-arduino-ide/">Getting Started with ESP-NOW (ESP32 with Arduino IDE)</a>
<a href="https://randomnerdtutorials.com/esp-now-esp8266-nodemcu-arduino-ide/">Getting Started with ESP-NOW (ESP8266 NodeMCU with Arduino IDE)</a>
<a href="https://randomnerdtutorials.com/esp-now-two-way-communication-esp32/">ESP-NOW Two-Way Communication Between ESP32 Boards</a>
<a href="https://randomnerdtutorials.com/esp-now-two-way-communication-esp8266-nodemcu/">ESP-NOW Two-Way Communication Between ESP8266 NodeMCU Boards</a>
<h3>Using ESP-NOW and Wi-Fi (Web Server) Simultaneously</h3>
There are a few things you need to take into account if you want to use Wi-Fi to host a web server and use ESP-NOW simultaneously to receive sensor readings from other boards:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/08/ESP-NOW-With-Wi-Fi-Web-Server-How-It-Works.png">
The ESP32/ESP8266 sender boards <k>must use the same Wi-Fi channel</k> as the receiver board (server).
The Wi-Fi channel of the receiver board is automatically assigned by your Wi-Fi router.
The Wi-Fi mode of the receiver board must be access point and station (WIFI_AP_STA).
You can set up the same Wi-Fi channel manually, but we'll do it automatically. The sender will try different Wi-Fi channels until it gets a response from the server.
<h3>Project Overview</h3>
Here's a quick overview of the example we'll build:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/09/ESP-NOW-Web-Server-Example.png">
There are two ESP sender boards (ESP32 or ESP8266) that send readings<k>*</k> via ESP-NOW to one ESP32 receiver board (<a href="https://randomnerdtutorials.com/esp-now-many-to-one-esp32/">ESP-NOW many to one configuration</a>);
The receiver board receives the packets and displays the readings on a web page;
The web page is updated automatically every time it receives a new reading using Server-Sent Events (SSE);
The receiver also sends data to the senderthis is to illustrate how to establish bidirectional communication. As an example, we'll send arbitrary values, but you can easily replace them with sensor readings or any other data like threshold values, or commands to turn on/off GPIOs.
<k>*</k>we'll send arbitrary temperature and humidity valueswe won't use an actual sensor. After testing the project and checking that everything is working as expected you can use a sensor of your choice (it doesn't have to be temperature or humidity).
<h3>Auto-Pairing</h3>
Here's how the auto-pairing with peers (sender(server)/slave boards) works:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/09/ESP-NOW-auto-pairing-diagram.png">
The peer sends a message of type PAIRING to the server (<k>1</k>) using the broadcast MAC address ff:ff:ff:ff:ff:ff. When you send data to this MAC address, all ESP-NOW devices receive the message. For the server to receive the message, they need to communicate on the same Wi-Fi channel.
If the peer doesn't receive a message from the server, it tries to send the same message on a different Wi-Fi channel. It repeats the process until it gets a message from the server.
The server receives the message and the address of the peer (<k>2</k>).
The server adds the address of the peer to his peer list (<k>3</k>).
The server replies to the peer with a message of type PAIRING with its information (MAC address and channel) (<k>4</k>).
The peer receives the message and the WiFi.macAddress of the server (<k>5</k>).
The peer adds the received address of the server to his peer list (<k>6</k>).
The peer tries to send a message to the server address but it fails to transmit*.<ol>
The peer adds the WiFi.softAPmacAddress of the server to his peer list.
The peer sends a message to the server WiFi.softAPmacAddress.
</ol>
The server receives the message from the peer.
They can now communicate bidirectionally (<k>6</k>).
*ESP32 in WIFI_AP_STA mode responds with its WiFi.macAddress but it uses WiFi.softAPmacAddress to receive from ESP8266 peer. 
WiFi.softAPmacAddress is created from WiFi.macAddress by adding 1 to the last byte<a href="https://docs.espressif.com/projects/esp-idf/en/v3.1.7/api-reference/system/base_mac_address.html" title="check the documentation">check the documentation</a>.
<h3>Prerequisites</h3>
Before proceeding with this project, make sure you check the following prerequisites.
<h3>Arduino IDE</h3>
We'll program the ESP32 and ESP8266 boards using Arduino IDE, so before proceeding with this tutorial, make sure you have the ESP32 and ESP8266 boards installed in your Arduino IDE.
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing ESP32 Board in Arduino IDE (Windows, Mac OS X, and Linux)</a>
<a href="https://randomnerdtutorials.com/how-to-install-esp8266-board-arduino-ide/">Installing ESP8266 Board in Arduino IDE (Windows, Mac OS X, Linux)</a>
<h3>Async Web Server Libraries</h3>
To build the web server you need to install the following libraries:
<a href="https://github.com/me-no-dev/ESPAsyncWebServer" target="_blank">ESPAsyncWebServer</a> 
<a href="https://github.com/me-no-dev/AsyncTCP" target="_blank">AsyncTCP</a>
These libraries aren't available to install through the Arduino Library Manager, so you need to copy the library files to the Arduino Installation Libraries folder. Alternatively, in your Arduino IDE, you can go to <k>Sketch </k>> <k>Include Library</k> > <k>Add .zip Library</k> and select the libraries you've just downloaded.
<h3>Arduino_JSON Library</h3>
Our examples will use the <a href="https://arduinojson.org/" target="_blank">ArduinoJSON library by Benoit Blanchon</a> version <k>6.18.3</k>. You can install this library in the Arduino IDE Library Manager. Just go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k> and search for the library name ArduinoJSON as follows:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/09/arduinojson_Benoit_Blanchon.png">
<h3>Parts Required</h3>
To test this project, you need at least three ESP boards. One ESP32 board to act as a server and two sender/slave ESP boards that can be ESP32 or ESP8266.
<a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32</a> (read <a href="https://makeradvisor.com/esp32-development-boards-review-comparison/" target="_blank">Best ESP32 development boards</a>)
<a href="https://makeradvisor.com/tools/esp8266-esp-12e-nodemcu-wi-fi-development-board/" target="_blank">ESP8266 </a>(read <a href="https://makeradvisor.com/tools/esp8266-esp-12e-nodemcu-wi-fi-development-board/" target="_blank">Best ESP8266 development boards</a>)
<h3>ESP32 Server</h3>
Here are the server features:
Pairs automatically with peers (other ESP-NOW boards);
Receives packets from peers;
Hosts a web server to display the latest received packets;
Also sends data back to the other boards (bidirectional communication with peers).
<h3>ESP32 Server Code</h3>
Upload the following code to your ESP32 board. This can receive data from multiple boards. However, the web page is just prepared to display data from two boards. You can easily modify the web page to accommodate more boards.
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/?s=esp-now
  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files.
  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
  Based on JC Servaye example: https://github.com/Servayejc/esp_now_web_server/
*/
#include &lt;esp_now.h>
#include &lt;WiFi.h>
#include "ESPAsyncWebServer.h"
#include "AsyncTCP.h"
#include &lt;ArduinoJson.h>
// Replace with your network credentials (STATION)
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
esp_now_peer_info_t slave;
int chan; 
enum MessageType {PAIRING, DATA,};
MessageType messageType;
int counter = 0;
// Structure example to receive data
// Must match the sender structure
typedef struct struct_message {
  uint8_t msgType;
  uint8_t id;
  float temp;
  float hum;
  unsigned int readingId;
} struct_message;
typedef struct struct_pairing {       // new structure for pairing
    uint8_t msgType;
    uint8_t id;
    uint8_t macAddr[6];
    uint8_t channel;
} struct_pairing;
struct_message incomingReadings;
struct_message outgoingSetpoints;
struct_pairing pairingData;
AsyncWebServer server(80);
AsyncEventSource events("/events");
const char index_html[] PROGMEM = R"rawliteral(
&lt;!DOCTYPE HTML>&lt;html>
&lt;head>
  &lt;title>ESP-NOW DASHBOARD&lt;/title>
  &lt;meta name="viewport" content="width=device-width, initial-scale=1">
  &lt;link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
  &lt;link rel="icon" href="data:,">
  &lt;style>
    html {font-family: Arial; display: inline-block; text-align: center;}
    p {  font-size: 1.2rem;}
    body {  margin: 0;}
    .topnav { overflow: hidden; background-color: #2f4468; color: white; font-size: 1.7rem; }
    .content { padding: 20px; }
    .card { background-color: white; box-shadow: 2px 2px 12px 1px rgba(140,140,140,.5); }
    .cards { max-width: 700px; margin: 0 auto; display: grid; grid-gap: 2rem; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); }
    .reading { font-size: 2.8rem; }
    .packet { color: #bebebe; }
    .card.temperature { color: #fd7e14; }
    .card.humidity { color: #1b78e2; }
  &lt;/style>
&lt;/head>
&lt;body>
  &lt;div>
    &lt;h3>ESP-NOW DASHBOARD&lt;/h3>
  &lt;/div>
  &lt;div>
    &lt;div>
      &lt;div>
        &lt;h4>&lt;i>&lt;/i> BOARD #1 - TEMPERATURE&lt;/h4>&lt;p>&lt;span>&lt;span>&lt;/span> &deg;C&lt;/span>&lt;/p>&lt;p>Reading ID: &lt;span>&lt;/span>&lt;/p>
      &lt;/div>
      &lt;div>
        &lt;h4>&lt;i>&lt;/i> BOARD #1 - HUMIDITY&lt;/h4>&lt;p>&lt;span>&lt;span>&lt;/span> &percnt;&lt;/span>&lt;/p>&lt;p>Reading ID: &lt;span>&lt;/span>&lt;/p>
      &lt;/div>
      &lt;div>
        &lt;h4>&lt;i>&lt;/i> BOARD #2 - TEMPERATURE&lt;/h4>&lt;p>&lt;span>&lt;span>&lt;/span> &deg;C&lt;/span>&lt;/p>&lt;p>Reading ID: &lt;span>&lt;/span>&lt;/p>
      &lt;/div>
      &lt;div>
        &lt;h4>&lt;i>&lt;/i> BOARD #2 - HUMIDITY&lt;/h4>&lt;p>&lt;span>&lt;span>&lt;/span> &percnt;&lt;/span>&lt;/p>&lt;p>Reading ID: &lt;span>&lt;/span>&lt;/p>
      &lt;/div>
    &lt;/div>
  &lt;/div>
&lt;script>
if (!!window.EventSource) {
 var source = new EventSource('/events');
 
 source.addEventListener('open', function(e) {
  console.log("Events Connected");
 }, false);
 source.addEventListener('error', function(e) {
  if (e.target.readyState != EventSource.OPEN) {
    console.log("Events Disconnected");
  }
 }, false);
 
 source.addEventListener('message', function(e) {
  console.log("message", e.data);
 }, false);
 
 source.addEventListener('new_readings', function(e) {
  console.log("new_readings", e.data);
  var obj = JSON.parse(e.data);
  document.getElementById("t"+obj.id).innerHTML = obj.temperature.toFixed(2);
  document.getElementById("h"+obj.id).innerHTML = obj.humidity.toFixed(2);
  document.getElementById("rt"+obj.id).innerHTML = obj.readingId;
  document.getElementById("rh"+obj.id).innerHTML = obj.readingId;
 }, false);
}
&lt;/script>
&lt;/body>
&lt;/html>)rawliteral";
void readDataToSend() {
  outgoingSetpoints.msgType = DATA;
  outgoingSetpoints.id = 0;
  outgoingSetpoints.temp = random(0, 40);
  outgoingSetpoints.hum = random(0, 100);
  outgoingSetpoints.readingId = counter++;
}
// ---------------------------- esp_ now -------------------------
void printMAC(const uint8_t * mac_addr){
  char macStr[18];
  snprintf(macStr, sizeof(macStr), "%02x:%02x:%02x:%02x:%02x:%02x",
           mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5]);
  Serial.print(macStr);
}
bool addPeer(const uint8_t *peer_addr) {      // add pairing
  memset(&slave, 0, sizeof(slave));
  const esp_now_peer_info_t *peer = &slave;
  memcpy(slave.peer_addr, peer_addr, 6);
  
  slave.channel = chan; // pick a channel
  slave.encrypt = 0; // no encryption
  // check if the peer exists
  bool exists = esp_now_is_peer_exist(slave.peer_addr);
  if (exists) {
    // Slave already paired.
    Serial.println("Already Paired");
    return true;
  }
  else {
    esp_err_t addStatus = esp_now_add_peer(peer);
    if (addStatus == ESP_OK) {
      // Pair success
      Serial.println("Pair success");
      return true;
    }
    else 
    {
      Serial.println("Pair failed");
      return false;
    }
  }
} 
// callback when data is sent
void OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {
  Serial.print("Last Packet Send Status: ");
  Serial.print(status == ESP_NOW_SEND_SUCCESS ? "Delivery Success to " : "Delivery Fail to ");
  printMAC(mac_addr);
  Serial.println();
}
void OnDataRecv(const uint8_t * mac_addr, const uint8_t *incomingData, int len) { 
  Serial.print(len);
  Serial.print(" bytes of data received from : ");
  printMAC(mac_addr);
  Serial.println();
  StaticJsonDocument&lt;1000> root;
  String payload;
  uint8_t type = incomingData[0];       // first message byte is the type of message 
  switch (type) {
  case DATA :                           // the message is data type
    memcpy(&incomingReadings, incomingData, sizeof(incomingReadings));
    // create a JSON document with received data and send it by event to the web page
    root["id"] = incomingReadings.id;
    root["temperature"] = incomingReadings.temp;
    root["humidity"] = incomingReadings.hum;
    root["readingId"] = String(incomingReadings.readingId);
    serializeJson(root, payload);
    Serial.print("event send :");
    serializeJson(root, Serial);
    events.send(payload.c_str(), "new_readings", millis());
    Serial.println();
    break;
  
  case PAIRING:                            // the message is a pairing request 
    memcpy(&pairingData, incomingData, sizeof(pairingData));
    Serial.println(pairingData.msgType);
    Serial.println(pairingData.id);
    Serial.print("Pairing request from: ");
    printMAC(mac_addr);
    Serial.println();
    Serial.println(pairingData.channel);
    if (pairingData.id > 0) {     // do not replay to server itself
      if (pairingData.msgType == PAIRING) { 
        pairingData.id = 0;       // 0 is server
        // Server is in AP_STA mode: peers need to send data to server soft AP MAC address 
        WiFi.softAPmacAddress(pairingData.macAddr);   
        pairingData.channel = chan;
        Serial.println("send response");
        esp_err_t result = esp_now_send(mac_addr, (uint8_t *) &pairingData, sizeof(pairingData));
        addPeer(mac_addr);
      }  
    }  
    break; 
  }
}
void initESP_NOW(){
    // Init ESP-NOW
    if (esp_now_init() != ESP_OK) {
      Serial.println("Error initializing ESP-NOW");
      return;
    }
    esp_now_register_send_cb(OnDataSent);
    esp_now_register_recv_cb(OnDataRecv);
} 
void setup() {
  // Initialize Serial Monitor
  Serial.begin(115200);
  Serial.println();
  Serial.print("Server MAC Address:  ");
  Serial.println(WiFi.macAddress());
  // Set the device as a Station and Soft Access Point simultaneously
  WiFi.mode(WIFI_AP_STA);
  // Set device as a Wi-Fi Station
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println("Setting as a Wi-Fi Station..");
  }
  Serial.print("Server SOFT AP MAC Address:  ");
  Serial.println(WiFi.softAPmacAddress());
  chan = WiFi.channel();
  Serial.print("Station IP Address: ");
  Serial.println(WiFi.localIP());
  Serial.print("Wi-Fi Channel: ");
  Serial.println(WiFi.channel());
  initESP_NOW();
  
  // Start Web server
  server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
    request->send_P(200, "text/html", index_html);
  });
  
  // Events 
  events.onConnect([](AsyncEventSourceClient *client){
    if(client->lastId()){
      Serial.printf("Client reconnected! Last message ID that it got is: %u\n", client->lastId());
    }
    // send event with message "hello!", id current millis
    // and set reconnect delay to 1 second
    client->send("hello!", NULL, millis(), 10000);
  });
  server.addHandler(&events);
  
  // start server
  server.begin();
}
void loop() {
  static unsigned long lastEventTime = millis();
  static const unsigned long EVENT_INTERVAL_MS = 5000;
  if ((millis() - lastEventTime) > EVENT_INTERVAL_MS) {
    events.send("ping",NULL,millis());
    lastEventTime = millis();
    readDataToSend();
    esp_now_send(NULL, (uint8_t *) &outgoingSetpoints, sizeof(outgoingSetpoints));
  }
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP/ESP_NOW/ESP_NOW_Auto_Pairing/ESP32_Server.ino" target="_blank">View raw code</a>
<h3>How the Code Works</h3>
We already explained how the server code works in great detail in a <a href="https://randomnerdtutorials.com/esp32-esp-now-wi-fi-web-server/">previous project</a>. So, we'll just take a look at the relevant parts for auto-pairing.
<h4>Message Types</h4>
The server and senders can exchange two types of messages: messages with pairing data with MAC address, channel, and board id, and messages with the actual data like sensor readings.
So, we create an enumerated type that holds the possible incoming message types (PAIRING and DATA).
<k>enum MessageType {PAIRING, DATA,};</k>
<em>An enumerated type is a data type (usually user-defined) consisting of a set of named constants called enumerators. The act of creating an enumerated type defines an enumeration. When an identifier such as a variable is declared having an enumerated type, the variable can be assigned any of the enumerators as a value</em>. Source: https://playground.arduino.cc/Code/Enum/
After that, we create a variable of that type we've just created called messageType. Remember that this variable can only have two possible values: PAIRING or DATA.
<k>MessageType messageType;</k>
<h4>Data Structure</h4>
Create a structure that will contain the data we'll receive. We called this structure struct_message and it contains the message type (so that we know if we received a message with data or with peer info), board ID, temperature and humidity readings, and the reading ID.
<k>typedef struct struct_message {
  uint8_t msgType;
  uint8_t id;
  float temp;
  float hum;
  unsigned int readingId;
} struct_message;</k>
We also need another structure to contain the peer information for pairing the peer. We call this structure struct_pairing. This structure will contain the message type, board id, mac address of the sender board, and Wi-Fi channel.
<k>typedef struct struct_pairing {       // new structure for pairing
    uint8_t msgType;
    uint8_t id;
    uint8_t macAddr[6];
    uint8_t channel;
} struct_pairing;</k>
We create two variables of type struct_message, one called incomingReadings that will store the readings coming from the slaves, and another called outgoingSetpoints that will hold the data to send to the slaves.
<k>struct_message incomingReadings;
struct_message outgoingSetpoints;</k>
We also create a variable of type struct_pairing to hold the peer information.
<k>struct_pairing pairingData;</k>
<h4>readDataToSend() Function</h4>
The readDataToSend() should be used to get data from whichever sensor you're using and put them on the associated structure to be sent to the slave boards.
<k>void readDataToSend() {
  outgoingSetpoints.msgType = DATA;
  outgoingSetpoints.id = 0;
  outgoingSetpoints.temp = random(0, 40);
  outgoingSetpoints.hum = random(0, 100);
  outgoingSetpoints.readingId = counter++;
}</k>
The msgType should be DATA. The id corresponds to the board id (we're setting the server board ID to 0, the others boards should have id=1, 2, 3, and so on). Finally, temp and hum hold the sensor readings. In this case, we're setting them to random values. You should replace that with the correct functions to get data from your sensor. Every time we send a new set of readings, we increase the counter variable.
<h4>Adding a Peer</h4>
We create a function called addPeer() that will return a boolean variable (either true or false) that indicates whether the pairing process was successful or not. This function tries to add peers. It will be called later when the board receives a message of type PAIRING. If the peer is already on the list of peers, it returns true. It also returns true if the peer is successfully added. It returns false, if it fails to add the peer to the list.
<k>bool addPeer(const uint8_t *peer_addr) {      // add pairing
  memset(&slave, 0, sizeof(slave));
  const esp_now_peer_info_t *peer = &slave;
  memcpy(slave.peer_addr, peer_addr, 6);
  
  slave.channel = chan; // pick a channel
  slave.encrypt = 0; // no encryption
  // check if the peer exists
  bool exists = esp_now_is_peer_exist(slave.peer_addr);
  if (exists) {
    // Slave already paired.
    Serial.println("Already Paired");
    return true;
  }
  else {
    esp_err_t addStatus = esp_now_add_peer(peer);
    if (addStatus == ESP_OK) {
      // Pair success
      Serial.println("Pair success");
      return true;
    }
    else 
    {
      Serial.println("Pair failed");
      return false;
    }
  }
} </k>
<h4>Receiving and Handling ESP-NOW Messages</h4>
The OnDataRecv() function will be executed when you receive a new ESP-NOW packet.
<k>void OnDataRecv(const uint8_t * mac_addr, const uint8_t *incomingData, int len) {</k>
Inside that function, print the length of the message and the sender's MAC address:
<k>Serial.print(len);
Serial.print(" bytes of data received from : ");
printMAC(mac_addr);</k>
Previously, we've seen that we can receive two types of messages: PAIRING and DATA. So, we must handle the message content differently depending on the type of message. We can get the type of message as follows:
<k>uint8_t type = incomingData[0];       // first message byte is the type of message</k>
Then, we'll run different codes depending if the message is of type DATA or PAIRING.
If it is of type DATA, copy the information in the incomingData variable into the incomingReadings structure variable.
<k>memcpy(&incomingReadings, incomingData, sizeof(incomingReadings));</k>
Then, create a JSON document with the received information (root):
<k>// create a JSON document with received data and send it by event to the web page
root["id"] = incomingReadings.id;
root["temperature"] = incomingReadings.temp;
root["humidity"] = incomingReadings.hum;
root["readingId"] = String(incomingReadings.readingId);</k>
Convert the JSON document to a string (payload):
<k>serializeJson(root, payload);</k>
After gathering all the received data on the payload variable, send that information to the browser as an event (new_readings).
<k>events.send(payload.c_str(), "new_readings", millis());</k>
We've seen <a href="https://randomnerdtutorials.com/esp32-esp-now-wi-fi-web-server/">on a previous project</a> how to handle these events on the client side. 
If the message is of type PAIRING, it contains the peer information.
<k>case PAIRING:                            // the message is a pairing request</k>
We save the received data in the incomingData variable and print the details on the Serial Monitor.
<k>memcpy(&pairingData, incomingData, sizeof(pairingData));
Serial.println(pairingData.msgType);
Serial.println(pairingData.id);
Serial.print("Pairing request from: ");
printMAC(mac_addr);
Serial.println();
Serial.println(pairingData.channel);</k>
The server responds back with its MAC address (in access point mode) and channel, so that the peer knows it sent the information using the right channel and can add the server as peer.
<k>if (pairingData.id > 0) {     // do not replay to server itself
  if (pairingData.msgType == PAIRING) { 
    pairingData.id = 0;       // 0 is server
    // Server is in AP_STA mode: peers need to send data to server soft AP MAC address 
    WiFi.softAPmacAddress(pairingData.macAddr);   
    pairingData.channel = chan;
    Serial.println("send response");
    esp_err_t result = esp_now_send(mac_addr, (uint8_t *) &pairingData, sizeof(pairingData));</k>
Finally, the server adds the sender to its peer list using the addPeer() function we created previously.
<k>addPeer(mac_addr);</k>
<h4>Initialize ESP-NOW</h4>
The initESP_NOW() function intializes ESP-NOW and registers the callback functions for when data is sent and received.
<k>void initESP_NOW(){
    // Init ESP-NOW
    if (esp_now_init() != ESP_OK) {
      Serial.println("Error initializing ESP-NOW");
      return;
    }
    esp_now_register_send_cb(OnDataSent);
    esp_now_register_recv_cb(OnDataRecv);
}</k>
<h4>setup()</h4>
In the setup(), print the board MAC address:
<k>Serial.println(WiFi.macAddress());</k>
Set the ESP32 receiver as station and soft access point simultaneously:
<k>WiFi.mode(WIFI_AP_STA);</k>
The following lines connect the ESP32 to your local network and print the IP address and the Wi-Fi channel:
<k>WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println("Setting as a Wi-Fi Station..");
  }</k>
Print the board MAC address in access point mode, which is different than the MAC address on station mode.
<k>Serial.print("Server SOFT AP MAC Address:  ");
Serial.println(WiFi.softAPmacAddress());</k>
Get the board Wi-Fi channel and print it in the Serial Monitor.
<k>chan = WiFi.channel();
Serial.print("Station IP Address: ");
Serial.println(WiFi.localIP());
Serial.print("Wi-Fi Channel: ");
Serial.println(WiFi.channel());</k>
Initialize ESP-NOW by calling the initESP_NOW() function we created previously.
<k>initESP_NOW();</k>
<h4>Send Data Messages to the Sender Boards</h4>
In the loop(), every 5 seconds (EVENT_INTERVAL_MS) get data from a sensor or sample data by calling the readDataToSend() function. It adds new data to the outgoingSetpoints structure.
<k>readDataToSend();</k>
Finally, send that data to all registered peers.
<k>esp_now_send(NULL, (uint8_t *) &outgoingSetpoints, sizeof(outgoingSetpoints));</k>
That's pretty much how the server code works when it comes to handling ESP-NOW messages and automatically adding peers.
<h3>Testing the Server</h3>
After uploading the code to the receiver board, press the on-board EN/RST button. The ESP32 IP address should be printed on the Serial Monitor as well as the Wi-Fi channel.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/09/ESP-NOW-Server-Serial-Monitor.png">
You can access the web server on the board's IP address. At the moment, there won't be any data displayed because we haven't prepared the sender boards yet. Let the server board run the code.
<h3>ESP32/ESP8266 Sender</h3>
Here are the sender board features:
Pairs automatically with server;
Sends packets with sensor readings to server;
Also receives data from the server (bidirectional communication).
<h3>Auto-Pairing</h3>
Here's how the auto-pairing with the server works:
The sender doesn't have access to the router;
The sender doesn't know the server's MAC address;
The server must be running for this to work (with the previous code);
The sender sets esp now on channel 1;
The server adds an entry with the broadcast address to its peer list;
The sender sends a PAIRING message request in broadcast mode:
If the server receives the message we are on the correct channel:
The server adds the received MAC to his peer list (previous section);
The server replies to the MAC address with a message containing his channel number and MAC address (previous section);
The sender replaces the broadcast address with the server address in his peer list.
elseThe sender repeats the process on the next channel.
WiFi.softAPmacAddress is created from WiFi.macAddress by adding 1 to the last byte<a href="https://docs.espressif.com/projects/esp-idf/en/v3.1.7/api-reference/system/base_mac_address.html" title="check the documentation">check the documentation</a>.
<h3>ESP32 Sender Code</h3>
Upload the following code to your ESP32 board. 
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/?s=esp-now
  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files.
  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
  Based on JC Servaye example: https://github.com/Servayejc/esp_now_sender/
*/
#include &lt;Arduino.h>
#include &lt;esp_now.h>
#include &lt;esp_wifi.h>
#include &lt;WiFi.h>
#include &lt;EEPROM.h>
// Set your Board and Server ID 
#define BOARD_ID 1
#define MAX_CHANNEL 11  // for North America // 13 in Europe
uint8_t serverAddress[] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};
//Structure to send data
//Must match the receiver structure
// Structure example to receive data
// Must match the sender structure
typedef struct struct_message {
  uint8_t msgType;
  uint8_t id;
  float temp;
  float hum;
  unsigned int readingId;
} struct_message;
typedef struct struct_pairing {       // new structure for pairing
    uint8_t msgType;
    uint8_t id;
    uint8_t macAddr[6];
    uint8_t channel;
} struct_pairing;
//Create 2 struct_message 
struct_message myData;  // data to send
struct_message inData;  // data received
struct_pairing pairingData;
enum PairingStatus {NOT_PAIRED, PAIR_REQUEST, PAIR_REQUESTED, PAIR_PAIRED,};
PairingStatus pairingStatus = NOT_PAIRED;
enum MessageType {PAIRING, DATA,};
MessageType messageType;
#ifdef SAVE_CHANNEL
  int lastChannel;
#endif  
int channel = 1;
 
// simulate temperature and humidity data
float t = 0;
float h = 0;
unsigned long currentMillis = millis();
unsigned long previousMillis = 0;   // Stores last time temperature was published
const long interval = 10000;        // Interval at which to publish sensor readings
unsigned long start;                // used to measure Pairing time
unsigned int readingId = 0;   
// simulate temperature reading
float readDHTTemperature() {
  t = random(0,40);
  return t;
}
// simulate humidity reading
float readDHTHumidity() {
  h = random(0,100);
  return h;
}
void addPeer(const uint8_t * mac_addr, uint8_t chan){
  esp_now_peer_info_t peer;
  ESP_ERROR_CHECK(esp_wifi_set_channel(chan ,WIFI_SECOND_CHAN_NONE));
  esp_now_del_peer(mac_addr);
  memset(&peer, 0, sizeof(esp_now_peer_info_t));
  peer.channel = chan;
  peer.encrypt = false;
  memcpy(peer.peer_addr, mac_addr, sizeof(uint8_t[6]));
  if (esp_now_add_peer(&peer) != ESP_OK){
    Serial.println("Failed to add peer");
    return;
  }
  memcpy(serverAddress, mac_addr, sizeof(uint8_t[6]));
}
void printMAC(const uint8_t * mac_addr){
  char macStr[18];
  snprintf(macStr, sizeof(macStr), "%02x:%02x:%02x:%02x:%02x:%02x",
           mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5]);
  Serial.print(macStr);
}
void OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {
  Serial.print("\r\nLast Packet Send Status:\t");
  Serial.println(status == ESP_NOW_SEND_SUCCESS ? "Delivery Success" : "Delivery Fail");
}
void OnDataRecv(const uint8_t * mac_addr, const uint8_t *incomingData, int len) { 
  Serial.print("Packet received from: ");
  printMAC(mac_addr);
  Serial.println();
  Serial.print("data size = ");
  Serial.println(sizeof(incomingData));
  uint8_t type = incomingData[0];
  switch (type) {
  case DATA :      // we received data from server
    memcpy(&inData, incomingData, sizeof(inData));
    Serial.print("ID  = ");
    Serial.println(inData.id);
    Serial.print("Setpoint temp = ");
    Serial.println(inData.temp);
    Serial.print("SetPoint humidity = ");
    Serial.println(inData.hum);
    Serial.print("reading Id  = ");
    Serial.println(inData.readingId);
    if (inData.readingId % 2 == 1){
      digitalWrite(LED_BUILTIN, LOW);
    } else { 
      digitalWrite(LED_BUILTIN, HIGH);
    }
    break;
  case PAIRING:    // we received pairing data from server
    memcpy(&pairingData, incomingData, sizeof(pairingData));
    if (pairingData.id == 0) {              // the message comes from server
      printMAC(mac_addr);
      Serial.print("Pairing done for ");
      printMAC(pairingData.macAddr);
      Serial.print(" on channel " );
      Serial.print(pairingData.channel);    // channel used by the server
      Serial.print(" in ");
      Serial.print(millis()-start);
      Serial.println("ms");
      addPeer(pairingData.macAddr, pairingData.channel); // add the server  to the peer list 
      #ifdef SAVE_CHANNEL
        lastChannel = pairingData.channel;
        EEPROM.write(0, pairingData.channel);
        EEPROM.commit();
      #endif  
      pairingStatus = PAIR_PAIRED;             // set the pairing status
    }
    break;
  }  
}
PairingStatus autoPairing(){
  switch(pairingStatus) {
    case PAIR_REQUEST:
    Serial.print("Pairing request on channel "  );
    Serial.println(channel);
    // set WiFi channel   
    ESP_ERROR_CHECK(esp_wifi_set_channel(channel,  WIFI_SECOND_CHAN_NONE));
    if (esp_now_init() != ESP_OK) {
      Serial.println("Error initializing ESP-NOW");
    }
    // set callback routines
    esp_now_register_send_cb(OnDataSent);
    esp_now_register_recv_cb(OnDataRecv);
  
    // set pairing data to send to the server
    pairingData.msgType = PAIRING;
    pairingData.id = BOARD_ID;     
    pairingData.channel = channel;
    // add peer and send request
    addPeer(serverAddress, channel);
    esp_now_send(serverAddress, (uint8_t *) &pairingData, sizeof(pairingData));
    previousMillis = millis();
    pairingStatus = PAIR_REQUESTED;
    break;
    case PAIR_REQUESTED:
    // time out to allow receiving response from server
    currentMillis = millis();
    if(currentMillis - previousMillis > 250) {
      previousMillis = currentMillis;
      // time out expired,  try next channel
      channel ++;
      if (channel > MAX_CHANNEL){
         channel = 1;
      }   
      pairingStatus = PAIR_REQUEST;
    }
    break;
    case PAIR_PAIRED:
      // nothing to do here 
    break;
  }
  return pairingStatus;
}  
void setup() {
  Serial.begin(115200);
  Serial.println();
  pinMode(LED_BUILTIN, OUTPUT);
  Serial.print("Client Board MAC Address:  ");
  Serial.println(WiFi.macAddress());
  WiFi.mode(WIFI_STA);
  WiFi.disconnect();
  start = millis();
  #ifdef SAVE_CHANNEL 
    EEPROM.begin(10);
    lastChannel = EEPROM.read(0);
    Serial.println(lastChannel);
    if (lastChannel >= 1 && lastChannel &lt;= MAX_CHANNEL) {
      channel = lastChannel; 
    }
    Serial.println(channel);
  #endif  
  pairingStatus = PAIR_REQUEST;
}  
void loop() {
  if (autoPairing() == PAIR_PAIRED) {
    unsigned long currentMillis = millis();
    if (currentMillis - previousMillis >= interval) {
      // Save the last time a new reading was published
      previousMillis = currentMillis;
      //Set values to send
      myData.msgType = DATA;
      myData.id = BOARD_ID;
      myData.temp = readDHTTemperature();
      myData.hum = readDHTHumidity();
      myData.readingId = readingId++;
      esp_err_t result = esp_now_send(serverAddress, (uint8_t *) &myData, sizeof(myData));
    }
  }
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP/ESP_NOW/ESP_NOW_Auto_Pairing/ESP32_Sender.ino" target="_blank">View raw code</a>
<h3>ESP8266 Sender Code</h3>
If you're using ESP8266 boards, use the following code instead. It's similar to the previous code but uses the ESP8266-specific ESP-NOW functions.
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/?s=esp-now
  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files.
  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
  Based on JC Servaye example: https://https://github.com/Servayejc/esp8266_espnow
*/
#include &lt;ESP8266WiFi.h>
#include &lt;espnow.h>
uint8_t channel = 1;
int readingId = 0;
int id = 2;
unsigned long currentMillis = millis(); 
unsigned long lastTime = 0;  
unsigned long timerDelay = 2000;  // send readings timer
uint8_t broadcastAddressX[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
enum PairingStatus {PAIR_REQUEST, PAIR_REQUESTED, PAIR_PAIRED, };
PairingStatus pairingStatus = PAIR_REQUEST;
enum MessageType {PAIRING, DATA,};
MessageType messageType;
// Define variables to store DHT readings to be sent
float temperature;
float humidity;
// Define variables to store incoming readings
float incomingTemp;
float incomingHum;
int incomingReadingsId;
// Updates DHT readings every 10 seconds
//const long interval = 10000; 
unsigned long previousMillis = 0;    // will store last time DHT was updated 
//Structure example to send data
//Must match the receiver structure
typedef struct struct_message {
  uint8_t msgType;
  uint8_t id;
  float temp;
  float hum;
  unsigned int readingId;
} struct_message;
typedef struct struct_pairing {       // new structure for pairing
    uint8_t msgType;
    uint8_t id;
    uint8_t macAddr[6];
    uint8_t channel;
} struct_pairing;
// Create a struct_message called myData
struct_message myData;
struct_message incomingReadings;
struct_pairing pairingData;
#define BOARD_ID 2
unsigned long start;
// Callback when data is sent
void OnDataSent(uint8_t *mac_addr, uint8_t sendStatus) {
  Serial.print("Last Packet Send Status: ");
  if (sendStatus == 0){
    Serial.println("Delivery success");
  }
  else{
    Serial.println("Delivery fail");
  }
}
void printMAC(const uint8_t * mac_addr){
  char macStr[18];
  snprintf(macStr, sizeof(macStr), "%02x:%02x:%02x:%02x:%02x:%02x",
           mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5]);
  Serial.print(macStr);
}
void printIncomingReadings(){
  // Display Readings in Serial Monitor
  Serial.println("INCOMING READINGS");
  Serial.print("Temperature: ");
  Serial.print(incomingTemp);
  Serial.println(" oC");
  Serial.print("Humidity: ");
  Serial.print(incomingHum);
  Serial.println(" %");
  Serial.print("Led: ");
  Serial.print(incomingReadingsId);
}
// Callback when data is received
void OnDataRecv(uint8_t * mac, uint8_t *incomingData, uint8_t len) {
  Serial.print("Size of message : ");
  Serial.print(len);
  Serial.print(" from ");
  printMAC(mac);
  Serial.println();
  uint8_t type = incomingData[0];
  switch (type) {
  case DATA :  
    memcpy(&incomingReadings, incomingData, sizeof(incomingReadings));
    Serial.print(len);
    Serial.print(" Data bytes received from: ");
    printMAC(mac);
    Serial.println();
    incomingTemp = incomingReadings.temp;
    incomingHum = incomingReadings.hum;
    printIncomingReadings();
    
    if (incomingReadings.readingId % 2 == 1){
      digitalWrite(LED_BUILTIN, LOW);
    } else { 
      digitalWrite(LED_BUILTIN, HIGH);
    }
    break;
  case PAIRING:
    memcpy(&pairingData, incomingData, sizeof(pairingData));
    if (pairingData.id == 0) {                // the message comes from server
      Serial.print("Pairing done for ");
      printMAC(pairingData.macAddr);
      Serial.print(" on channel " );
      Serial.print(pairingData.channel);    // channel used by the server
      Serial.print(" in ");
      Serial.print(millis()-start);
      Serial.println("ms");
      //esp_now_del_peer(pairingData.macAddr);
      //esp_now_del_peer(mac);
      esp_now_add_peer(pairingData.macAddr, ESP_NOW_ROLE_COMBO, pairingData.channel, NULL, 0); // add the server to the peer list 
      pairingStatus = PAIR_PAIRED ;            // set the pairing status
    }
    break;
  }  
}
void getReadings(){
  // Read Temperature
  temperature = 22.5;
  humidity = 55.5;
}
PairingStatus autoPairing(){
  switch(pairingStatus) {
  case PAIR_REQUEST:
    Serial.print("Pairing request on channel "  );
    Serial.println(channel);
  
    // clean esp now
    esp_now_deinit();
    WiFi.mode(WIFI_STA);
    // set WiFi channel   
    wifi_promiscuous_enable(1);
    wifi_set_channel(channel);
    wifi_promiscuous_enable(0);
    //WiFi.printDiag(Serial);
    WiFi.disconnect();
    // Init ESP-NOW
    if (esp_now_init() != 0) {
      Serial.println("Error initializing ESP-NOW");
    }
    esp_now_set_self_role(ESP_NOW_ROLE_COMBO);
    // set callback routines
    esp_now_register_send_cb(OnDataSent);
    esp_now_register_recv_cb(OnDataRecv);
    
    // set pairing data to send to the server
    pairingData.id = BOARD_ID;     
    pairingData.channel = channel;
    previousMillis = millis();
    // add peer and send request
    Serial.println(esp_now_send(broadcastAddressX, (uint8_t *) &pairingData, sizeof(pairingData)));
    pairingStatus = PAIR_REQUESTED;
    break;
  case PAIR_REQUESTED:
    // time out to allow receiving response from server
    currentMillis = millis();
    if(currentMillis - previousMillis > 100) {
      previousMillis = currentMillis;
      // time out expired,  try next channel
      channel ++;
      if (channel > 11) {
        channel = 0;
      }
      pairingStatus = PAIR_REQUEST; 
    }
    break;
  case PAIR_PAIRED:
    //Serial.println("Paired!");
    break;
  }
  return pairingStatus;
} 
void setup() {
  // Init Serial Monitor
  Serial.begin(74880);
  pinMode(LED_BUILTIN, OUTPUT);
  // Init DHT sensor
 
  // Set device as a Wi-Fi Station
  WiFi.mode(WIFI_STA);
  Serial.println(WiFi.macAddress());
  WiFi.disconnect();
  // Init ESP-NOW
  if (esp_now_init() != 0) {
    Serial.println("Error initializing ESP-NOW");
    return;
  }
  // Set ESP-NOW Role
  esp_now_set_self_role(ESP_NOW_ROLE_COMBO);
    
  // Register for a callback function that will be called when data is received
  esp_now_register_recv_cb(OnDataRecv);
  esp_now_register_send_cb(OnDataSent);
  pairingData.id = 2;
}
 
void loop() { 
  if (autoPairing() == PAIR_PAIRED) { 
    static unsigned long lastEventTime = millis();
    static const unsigned long EVENT_INTERVAL_MS = 10000;
    if ((millis() - lastEventTime) > EVENT_INTERVAL_MS) {
      Serial.print(".");
      getReadings();
      //Set values to send
      myData.msgType = DATA;
      myData.id = 2;
      myData.temp = temperature;
      myData.hum = humidity;
      myData.readingId = readingId ++;
      
      // Send message via ESP-NOW to all peers 
      esp_now_send(pairingData.macAddr, (uint8_t *) &myData, sizeof(myData));
      lastEventTime = millis();
    }
  }
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP/ESP_NOW/ESP_NOW_Auto_Pairing/ESP8266_Sender.ino" target="_blank">View raw code</a>
<h3>How the Code Works</h3>
The ESP32 and ESP8266 are slightly different when it comes to the ESP-NOW-specific functions. But they are structured similarly. So, we'll just take a look at the ESP32 code.
We'll take a look at the relevant sections that handle auto-pairing with the server. The rest of the code was already explained in great detail in a <a href="https://randomnerdtutorials.com/esp32-esp-now-wi-fi-web-server/">previous project</a>.
<h4>Set Board ID</h4>
Define the sender board ID. Each board should have a different id so that the server knows who sent the message. Board id 0 is reserved for the server, so you should start numbering your sender boards at 1.
<k>// Set your Board ID (ESP32 Sender #1 = BOARD_ID 1, ESP32 Sender #2 = BOARD_ID 2, etc)
#define BOARD_ID 1</k>
<h4>Define the maximum number of channels</h4>
The sender will loop through different Wi-Fi channels until it finds the server. So, set the maximum number of channels.
<k>#define MAX_CHANNEL 11  // for North America // 13 in Europe</k>
<h4>Server's MAC Address</h4>
The sender board doesn't know the server MAC address. So, we'll start by sending a message to the broadcast MAC address FF:FF:FF:FF:FF:FF on different channels. When we send messages to this MAC address, all ESP-NOW devices receive this message. Then, the server will respond back with its actual MAC address when we find the right Wi-Fi channel.
<k>uint8_t serverAddress[] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};</k>
<h4>Data Structure</h4>
Similarly to the server code, we create two structures. One to receive actual data and another to receive details for pairing.
<k>//Structure to send data
//Must match the receiver structure
// Structure example to receive data
// Must match the sender structure
typedef struct struct_message {
  uint8_t msgType;
  uint8_t id;
  float temp;
  float hum;
  unsigned int readingId;
} struct_message;
typedef struct struct_pairing {       // new structure for pairing
    uint8_t msgType;
    uint8_t id;
    uint8_t macAddr[6];
    uint8_t channel;
} struct_pairing;
//Create 2 struct_message 
struct_message myData;  // data to send
struct_message inData;  // data received
struct_pairing pairingData;</k>
<h4>Pairing Statues</h4>
Then, we create an enumeration type called ParingStatus that can have the following values: NOT_PAIRED, PAIR_REQUEST, PAIR_REQUESTED, and PAIR_PAIRED. This will help us following the pairing status situation.
<k>enum PairingStatus {NOT_PAIRED, PAIR_REQUEST, PAIR_REQUESTED, PAIR_PAIRED,};</k>
We create a variable of that type called pairingStatus. When the board first starts, it's not paired, so it's set to NOT_PAIRED.
<k>PairingStatus pairingStatus = NOT_PAIRED;</k>
<h4>Message Types</h4>
As we did in the server, we also create a MessageType so that we know if we received a pairing message or a message with data.
<k>enum MessageType {PAIRING, DATA,};
MessageType messageType;</k>
<h4>Adding a Peer</h4>
This function adds a new peer to the list. It accepts as arguments the peer MAC address and channel.
<k>void addPeer(const uint8_t * mac_addr, uint8_t chan){
  esp_now_peer_info_t peer;
  ESP_ERROR_CHECK(esp_wifi_set_channel(chan ,WIFI_SECOND_CHAN_NONE));
  esp_now_del_peer(mac_addr);
  memset(&peer, 0, sizeof(esp_now_peer_info_t));
  peer.channel = chan;
  peer.encrypt = false;
  memcpy(peer.peer_addr, mac_addr, sizeof(uint8_t[6]));
  if (esp_now_add_peer(&peer) != ESP_OK){
    Serial.println("Failed to add peer");
    return;
  }
  memcpy(serverAddress, mac_addr, sizeof(uint8_t[6]));
}</k>
<h4>Receiving and Handling ESP-NOW Messages</h4>
The OnDataRecv() function will be executed when you receive a new ESP-NOW packet.
<k>void OnDataRecv(const uint8_t * mac_addr, const uint8_t *incomingData, int len) {</k>
Inside that function, print the length of the message and the sender's MAC address:
<k>Serial.print("Packet received from: ");
printMAC(mac_addr);
Serial.println();
Serial.print("data size = ");
Serial.println(sizeof(incomingData));</k>
Previously, we've seen that we can receive two types of messages: PAIRING and DATA. So, we must handle the message content differently depending on the type of message. We can get the type of message as follows:
<k>uint8_t type = incomingData[0];       // first message byte is the type of message</k>
Then, we'll run different codes depending if the message is of type DATA or PAIRING.
If it is of type DATA, copy the information in the incomingData variable into the inData structure variable.
<k>memcpy(&inData, incomingData, sizeof(inData));</k>
Then, we simply print the received data on the Serial Monitor. You can do any other tasks with the received data that might be useful for your project.
<k>Serial.print("ID  = ");
Serial.println(inData.id);
Serial.print("Setpoint temp = ");
Serial.println(inData.temp);
Serial.print("SetPoint humidity = ");
Serial.println(inData.hum);
Serial.print("reading Id  = ");
Serial.println(inData.readingId);</k>
In this case, we blink the built-in LED whenever the reading ID is an odd number, but you can perform any other tasks depending on the received data.
<k>if (incomingReadings.readingId % 2 == 1){
  digitalWrite(LED_BUILTIN, LOW);
} else { 
  digitalWrite(LED_BUILTIN, HIGH);
}
break;</k>
If the message is of type PAIRING, first we check if the received message is from the server and not from another sender board. We know that because the id variable for the server is 0.
<k>case PAIRING:    // we received pairing data from server
  memcpy(&pairingData, incomingData, sizeof(pairingData));
  if (pairingData.id == 0) {              // the message comes from server</k>
Then, we print the MAC address and channel. This information is sent by the server. 
<k>Serial.print("Pairing done for ");
printMAC(pairingData.macAddr);
Serial.print(" on channel " );
Serial.print(pairingData.channel);    // channel used by the server</k>
So, now that we know the server details, we can call the addPeer() function and pass as arguments the server MAC address and channel to add the server to the peer list.
<k>addPeer(pairingData.macAddr, pairingData.channel); // add the server  to the peer list </k>
If the pairing is successful, we change the pairingStatus to PAIR_PAIRED.
<k>pairingStatus = PAIR_PAIRED;             // set the pairing status</k>
<h4>Auto Pairing</h4>
The autoPairing() function returns the pairing status.
<k>PairingStatus autoPairing(){</k>
We can have different scenarios. If it is of type PAIR_REQUEST, it will set up the ESP-NOW callback functions and send the first message of type PAIRING to the broadcast address on a predefined channel (starting at 1). After that, we change the pairing status to PAIR_REQUESTED (it means we've already sent a request).
<k>case PAIR_REQUEST:
    Serial.print("Pairing request on channel "  );
    Serial.println(channel);
// set WiFi channel   
ESP_ERROR_CHECK(esp_wifi_set_channel(channel,  WIFI_SECOND_CHAN_NONE));
if (esp_now_init() != ESP_OK) {
  Serial.println("Error initializing ESP-NOW");
}
// set callback routines
esp_now_register_send_cb(OnDataSent);
esp_now_register_recv_cb(OnDataRecv);
  
// set pairing data to send to the server
pairingData.msgType = PAIRING;
pairingData.id = BOARD_ID;     
pairingData.channel = channel;
// add peer and send request
addPeer(serverAddress, channel);
esp_now_send(serverAddress, (uint8_t *) &pairingData, sizeof(pairingData));
previousMillis = millis();
pairingStatus = PAIR_REQUESTED;</k>
After sending a pairing message, we wait some time to see if we get a message from the server. If we don't, we try on the next Wi-Fi channel and change the pairingStatus to PAIR_REQUEST again, so that the board sends a new request on a different Wi-Fi channel.
<k>case PAIR_REQUESTED:
// time out to allow receiving response from server
currentMillis = millis();
if(currentMillis - previousMillis > 250) {
  previousMillis = currentMillis;
  // time out expired,  try next channel
  channel ++;
  if (channel > MAX_CHANNEL){
     channel = 1;
  }   
  pairingStatus = PAIR_REQUEST;
}
break;</k>
If the pairingStatus is PAIR_PAIRED, meaning we're already paired with the server, we don't need to do anything.
<k>case PAIR_PAIRED:
   // nothing to do here 
break;</k>
Finally, return the pairingStatus.
<k>return pairingStatus;</k>
<h4>setup()</h4>
In the setup(), set the pairingStatus to PAIR_REQUEST.
<k>pairingStatus = PAIR_REQUEST;</k>
<h4>loop()</h4>
In the loop(), check if the board is paired with the server before doing anything else.
<k>if (autoPairing() == PAIR_PAIRED) {</k>
This will run the autoPairing() function and handle the auto-pairing with the server. When the board is paired with the sender (PAIR_PAIRED), we can communicate with the server to exchange data with messages of type DATA.
<h4>Sending Messages to the Server</h4>
In this case, we're sending arbitrary temperature and humidity values, but you can exchange any other data with the server.
<k>unsigned long currentMillis = millis();
if (currentMillis - previousMillis >= interval) {
  // Save the last time a new reading was published
  previousMillis = currentMillis;
  //Set values to send
  myData.msgType = DATA;
  myData.id = BOARD_ID;
  myData.temp = readDHTTemperature();
  myData.hum = readDHTHumidity();
  myData.readingId = readingId++;
  esp_err_t result = esp_now_send(serverAddress, (uint8_t *) &myData, sizeof(myData));
}</k>
<h3>Testing the Sender Boards</h3>
Now, you can test the sender boards. We recommend opening a serial communication with the server on another software like PuTTY for example so that you can see what's going on on the server and sender simultaneously.
After having the server running, you can upload the sender code to the other boards.
After uploading the code, open the Serial Monitor at a baud rate of 115200 and press the RST button so that the board starts running the code.
This is what the sender should return.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/09/ESP-NOW-auto-pairing-sender-finding-channel-serial-monitor.png">
As you can see, first, it sends a pairing request using different channels until it gets a response from the server. In this case, it is using channel 6.
After that, we start receiving messages from the server. We also send messages to the server.
On the server side, this is what happens:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/09/ESP-NOW-Auto-pairng-server-pairing.png">
The server receives a pairing request from the sender. It will pair with the sender. In my case, it was already paired because I had run this code before. After data, we start sending and receiving data.
You can upload the sender code to multiple boards and they will all automatically pair with the server. The sender boards can be ESP32 or ESP8266 boards. Make sure you use the right code for the board you're using. 
Now, you can go to the server's IP address to see the readings from the sender boards displayed on the dashboard. The web page is prepared to display readings from two boards. If you want to display more readings you need to modify the web page.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/09/ESP-NOW-Web-Server-dashboard.png">
<h3>Wrapping Up</h3>
In this tutorial, we've shown you how you can build a ESP-NOW Web Server, pair with peers automatically and establish a two-way communication between server and senders boards.
You can adapt the parts of code that deal with auto-pairing and use them in your ESP-NOW examples.
We would like to thank <k>Jean-Claude Servaye</k> for sharing his ESP-NOW auto-pairing code sketches with us. We only made a few modifications to the sketches. You can find the original codes on <a href="https://github.com/Servayejc" target="_blank">his GitHub page</a>.
You may also like:
<a href="https://randomnerdtutorials.com/?s=ESP-NOW">More ESP-NOW examples</a>
<a href="https://randomnerdtutorials.com/learn-esp32-with-arduino-ide/">Learn ESP32 with Arduino IDE ebook</a>
<a href="https://randomnerdtutorials.com/home-automation-using-esp8266/">Home Automation using ESP8266 ebook</a>
<a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/">Build Web Server with ESP32 and ESP8266 ebook</a>
Thanks for reading.
<center><a href="https://randomnerdtutorials.com/pcbway" target="_blank"><img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/2022/03/728x280.jpg" width="728" height="280" loading="lazy" fetchpriority="low"></a></center>
<a href="https://randomnerdtutorials.com/smart-home-ebook/">
<img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/elementor/thumbs/Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px-pupj8i6e7hlzpgwxe82jjd8skst9vmrjt9lpqb0v0g.jpg" title="Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px" alt="SMART HOME with Raspberry Pi ESP32 and ESP8266 Node-RED InfluxDB eBook" loading="lazy" width="117" height="180" fetchpriority="low"></a>
<h4><a href="https://randomnerdtutorials.com/smart-home-ebook/">SMART HOME with Raspberry Pi, ESP32, ESP8266 [eBook] </a></h4>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
<h2>LILYGO T-SIM7000G ESP32: Get GPS Data (Latitude, Longitude, Altitude, and more)</h2>
In this quick guide, you'll learn how to get GPS data with the LILYGO T-SIM7000G ESP32 board using Arduino IDE. This tutorial is also compatible with a regular ESP32 connected to a SIM7000G module.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/LILYGO-T-SIM7000-ESP32-Get-GPS-Data.jpg">
<h3>Introducing the LILYGO T-SIM7000G ESP32</h3>
The <a href="https://makeradvisor.com/tools/t-sim7000g-esp32/" target="_blank">LILYGO T-SIM7000G</a> is an ESP32 development board with a SIM7000G chip. This adds LTE (4G), GPS, and GPRS to your board. This means that with this board you can send SMS, get location and time using GPS, and connect it to the internet using a SIM card data plan. This board doesn't support phone calls.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/ESP32-TSIM7000G.jpg">
Besides the SIM7000G module, the board also comes with some interesting features like a battery holder for a 18650 battery, a battery charging circuit where you can connect solar panels to recharge the battery, and a microSD card slot that can be useful for data logging projects or to save configuration settings.
For a more in-depth introduction, we recommend following the getting started guide:
<a href="https://randomnerdtutorials.com/lilygo-t-sim7000g-esp32-lte-gprs-gps/" title="Getting Started with LILYGO T-SIM7000G ESP32 (LTE, GPRS, and GPS)">Getting Started with LILYGO T-SIM7000G ESP32 (LTE, GPRS, and GPS)</a>
<k>Where to buy LILYGO T-SIM7000G ESP32?</k>
Check the following link:
<a href="https://makeradvisor.com/tools/t-sim7000g-esp32/" target="_blank">LILYGO T-SIM7000G ESP32 (LTE, GPRS, and GPS)  Maker Advisor</a>
All stores in the previous link should sell the latest version, but double-check the product page, just in case the seller changes something.
You can use the preceding links or go directly to <a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank">MakerAdvisor.com/tools</a> to find all the parts for your projects at the best price!
<a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/header-200.png?w=828&quality=100&strip=all&ssl=1" data-recalc-dims="1" loading="eager" fetchpriority="high" decoding="async"></a>
<h3>Libraries</h3>
The ESP32 communicates with the SIM7000G chip by sending AT commands via serial communication. You don't need a library, you can simply establish a serial communication with the module and start sending AT commands. There's a manual with all the SIM7000G AT commands:
<a href="https://cdn.geekfactory.mx/sim7000g/SIM7000%20Series_AT%20Command%20Manual_V1.06.pdf" target="_blank">SIM7000G AT Commands Manual</a>
However, it might be more practical to use a library. For example, the <a href="https://github.com/vshymanskyy/TinyGSM" target="_blank">TinyGSM</a> library knows which commands to send, and how to handle AT responses, and wraps that into the standard Arduino Client interfacethat's the library we'll use in this tutorial.
<h4>Installing the TinyGSM Library</h4>
Open your Arduino IDE and go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k>. The Library Manager should open. Search for <k>TinyGSM</k>. Select the TinyGSM library by Volodymyr Shymanskyy.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/tinygsm-library-arduino-ide.png">
You also need to install the StreamDebugger library. Go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k>, search for <k>StreamDebugger</k>, and install it.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/streamdebugger-library-arduino-ide.png">
<h3>Preparing the LILYGO T-SIM7000G ESP32 Board</h3>
To get GPS data with your board, you don't need to connect a SIM card. You only need to connect the GPS antenna to the board.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/ESP32-SIM7000G-GPS-antenna-connected.jpg">
<h3>LILYGO T-SIM7000G ESP32 BoardGet GPS Data</h3>
Copy the following code to your Arduino IDE.
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/lilygo-t-sim7000g-esp32-gps-data/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
#define TINY_GSM_MODEM_SIM7000
#define TINY_GSM_RX_BUFFER 1024 // Set RX buffer to 1Kb
#include &lt;TinyGsmClient.h>
// LilyGO T-SIM7000G Pinout
#define UART_BAUD   115200
#define PIN_DTR     25
#define PIN_TX      27
#define PIN_RX      26
#define PWR_PIN     4
#define LED_PIN     12
// Set serial for debug console (to Serial Monitor, default speed 115200)
#define SerialMon Serial
// Set serial for AT commands
#define SerialAT  Serial1
TinyGsm modem(SerialAT);
void setup(){
  SerialMon.begin(115200);
  SerialMon.println("Place your board outside to catch satelite signal");
  // Set LED OFF
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, HIGH);
  //Turn on the modem
  pinMode(PWR_PIN, OUTPUT);
  digitalWrite(PWR_PIN, HIGH);
  delay(300);
  digitalWrite(PWR_PIN, LOW);
  delay(1000);
  
  // Set module baud rate and UART pins
  SerialAT.begin(UART_BAUD, SERIAL_8N1, PIN_RX, PIN_TX);
  // Restart takes quite some time
  // To skip it, call init() instead of restart()
  SerialMon.println("Initializing modem...");
  if (!modem.restart()) {
    Serial.println("Failed to restart modem, attempting to continue without restarting");
  }
  
  // Print modem info
  String modemName = modem.getModemName();
  delay(500);
  SerialMon.println("Modem Name: " + modemName);
  String modemInfo = modem.getModemInfo();
  delay(500);
  SerialMon.println("Modem Info: " + modemInfo);
}
void loop(){
  // Set SIM7000G GPIO4 HIGH ,turn on GPS power
  // CMD:AT+SGPIO=0,4,1,1
  // Only in version 20200415 is there a function to control GPS power
  modem.sendAT("+SGPIO=0,4,1,1");
  if (modem.waitResponse(10000L) != 1) {
    SerialMon.println(" SGPIO=0,4,1,1 false ");
  }
  modem.enableGPS();
  
  delay(15000);
  float lat      = 0;
  float lon      = 0;
  float speed    = 0;
  float alt     = 0;
  int   vsat     = 0;
  int   usat     = 0;
  float accuracy = 0;
  int   year     = 0;
  int   month    = 0;
  int   day      = 0;
  int   hour     = 0;
  int   min      = 0;
  int   sec      = 0;
  
  for (int8_t i = 15; i; i--) {
    SerialMon.println("Requesting current GPS/GNSS/GLONASS location");
    if (modem.getGPS(&lat, &lon, &speed, &alt, &vsat, &usat, &accuracy,
                     &year, &month, &day, &hour, &min, &sec)) {
      SerialMon.println("Latitude: " + String(lat, 8) + "\tLongitude: " + String(lon, 8));
      SerialMon.println("Speed: " + String(speed) + "\tAltitude: " + String(alt));
      SerialMon.println("Visible Satellites: " + String(vsat) + "\tUsed Satellites: " + String(usat));
      SerialMon.println("Accuracy: " + String(accuracy));
      SerialMon.println("Year: " + String(year) + "\tMonth: " + String(month) + "\tDay: " + String(day));
      SerialMon.println("Hour: " + String(hour) + "\tMinute: " + String(min) + "\tSecond: " + String(sec));
      break;
    } 
    else {
      SerialMon.println("Couldn't get GPS/GNSS/GLONASS location, retrying in 15s.");
      delay(15000L);
    }
  }
  SerialMon.println("Retrieving GPS/GNSS/GLONASS location again as a string");
  String gps_raw = modem.getGPSraw();
  SerialMon.println("GPS/GNSS Based Location String: " + gps_raw);
  SerialMon.println("Disabling GPS");
  modem.disableGPS();
  // Set SIM7000G GPIO4 LOW ,turn off GPS power
  // CMD:AT+SGPIO=0,4,1,0
  // Only in version 20200415 is there a function to control GPS power
  modem.sendAT("+SGPIO=0,4,1,0");
  if (modem.waitResponse(10000L) != 1) {
    SerialMon.println(" SGPIO=0,4,1,0 false ");
  }
  delay(200);
  // Do nothing forevermore
  while (true) {
      modem.maintain();
  }
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/LILYGO_T-SIM7000G/GPS_Tester.ino" target="_blank">View raw code</a>
<h3>How the Code Works</h3>
Let's take a quick look at the relevant parts of the code.
First, you need to define the module you're using. The library is compatible with many different modules. To use the SIM7000G, include the following line:
<k>#define TINY_GSM_MODEM_SIM7000</k>
Include the TinyGSM library.
<k>#include &lt;TinyGsmClient.h></k>
The following lines set the board pins to control the modem:
<k>// LilyGO T-SIM7000G Pinout
#define UART_BAUD   115200
#define PIN_DTR     25
#define PIN_TX      27
#define PIN_RX      26
#define PWR_PIN     4
#define LED_PIN     12</k>
You need to create two Serial instances. One for the Serial Monitor that we'll call SerialMon, and another to communicate with the modem via AT commands, that we call SerialAT.
<k>// Set serial for debug console (to Serial Monitor, default speed 115200)
#define SerialMon Serial
// Set serial for AT commands
#define SerialAT  Serial1</k>
Create a TinyGSM instance called modem on the SerialAT.
<k>TinyGsm modem(SerialAT);</k>
Initialize the Serial Monitor at a baud rate of 115200.
<k>SerialMon.begin(115200);</k>
Turn on the modem by setting the power pin to HIGH and LOW at a specific interval.
<k>//Turn on the modem
pinMode(PWR_PIN, OUTPUT);
digitalWrite(PWR_PIN, HIGH);
delay(300);
digitalWrite(PWR_PIN, LOW);</k>
Initialize a Serial communication with the modem on the RX and TX pins we defined earlier.
<k>SerialAT.begin(UART_BAUD, SERIAL_8N1, PIN_RX, PIN_TX);</k>
Restart or init the modem:
<k>// Restart takes quite some time
// To skip it, call init() instead of restart()
SerialMon.println("Initializing modem...");
if (!modem.restart()) {
  Serial.println("Failed to restart modem, attempting to continue without restarting");
}</k>
Get some modem info using the getModemName() and getModemInfo() methods. These lines are optional and you don't actually need them to get GPS data.
<k>// Print modem info
String modemName = modem.getModemName();
delay(500);
SerialMon.println("Modem Name: " + modemName);
String modemInfo = modem.getModemInfo();
delay(500);
SerialMon.println("Modem Info: " + modemInfo);</k>
There are two versions of the LILYGO SIM7000G ESP32 board. The latest comes with active GPS antenna power controlwhen the module GPIO 4 is not turned on the antenna consumes only the static current of the LDO. This means we need to turn GPIO 4 on before getting GPS data to power the antenna. That's what the next lines do:
<k>// Set SIM7000G GPIO4 HIGH ,turn on GPS power
// CMD:AT+SGPIO=0,4,1,1
// Only in version 20200415 is there a function to control GPS power
modem.sendAT("+SGPIO=0,4,1,1");
if (modem.waitResponse(10000L) != 1) {
  SerialMon.println(" SGPIO=0,4,1,1 false ");
}</k>
You can start GPS using the enableGPS() method.
<k>modem.enableGPS();</k>
Then, we create variables where we'll save the GPS data. We'll get latitude, longitude, speed, altitude, visible satellites, used satellites, accuracy, and date and time.
<k>delay(15000);
float lat      = 0;
float lon      = 0;
float speed    = 0;
float alt     = 0;
int   vsat     = 0;
int   usat     = 0;
float accuracy = 0;
int   year     = 0;
int   month    = 0;
int   day      = 0;
int   hour     = 0;
int   min      = 0;
int   sec      = 0;</k>
The following line gets GPS data using the getGPS() method and saves the values on the right variables.
<k>if (modem.getGPS(&lat, &lon, &speed, &alt, &vsat, &usat, &accuracy,
                     &year, &month, &day, &hour, &min, &sec))</k>
Then, we simply print the values on the Serial Monitor. Now that you have the relevant information saved on variables, it's easy to modify this project for your own needs. For example, a GPS tracker, GPS data logger, etc.
<k>SerialMon.println("Latitude: " + String(lat, 8) + "\tLongitude: " + String(lon, 8));
SerialMon.println("Speed: " + String(speed) + "\tAltitude: " + String(alt));
SerialMon.println("Visible Satellites: " + String(vsat) + "\tUsed Satellites: " + String(usat));
SerialMon.println("Accuracy: " + String(accuracy));
SerialMon.println("Year: " + String(year) + "\tMonth: " + String(month) + "\tDay: " + String(day));
SerialMon.println("Hour: " + String(hour) + "\tMinute: " + String(min) + "\tSecond: " + String(sec));</k>
You can also get all raw data returned by the GPS using the getGPRSraw() method. 
<k>String gps_raw = modem.getGPSraw();
SerialMon.println("GPS/GNSS Based Location String: " + gps_raw);</k>
When you're done using GPS, you can turn it off using the disableGPS() method:
<k>modem.disableGPS();</k>
And finally, turn off the power to the antenna by turning GPIO 4 off:
<k>// Set SIM7000G GPIO4 LOW ,turn off GPS power
// CMD:AT+SGPIO=0,4,1,0
// Only in version 20200415 is there a function to control GPS power
modem.sendAT("+SGPIO=0,4,1,0");
if (modem.waitResponse(10000L) != 1) {
  SerialMon.println(" SGPIO=0,4,1,0 false ");
}</k>
<h3>Demonstration</h3>
In your Arduino IDE, go to <k>Tools </k>> <k>Boards </k>and select the <k>ESP32 Dev Module</k>. Select the COM port in <k>Tools </k>> <k>Port</k>.
Then, upload the code to your board.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/05/arduino-2-0-upload-button.png">
Open the Serial Monitor at a baud rate of 115200 and press the on-board RST button to restart the board. Place your board outside or next to a window or door so that it can catch satellite signals.
It may take some time until it is able to get some GPS data, as you can see in the screenshot of my Serial Monitor.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/GPS_tester_serial_monitor.png">
As you can see, it gets latitude, longitude, speed, altitude, visible satellites, number of used satellites to get position, accuracy, and UTC date and time. The longitude and latitude I got were very accurate. So, in my case, it was working pretty well to get the location.
It also outputs the complete GNSS navigation information parsed from NMEA sentences (that you can't see above because the Serial Monitor window is too small). NMEA stands for National Marine Electronics Association, and in the world of GPS, it is a standard data format supported by GPS manufacturers. The output is as follows. The commas separate different values. 
<k>1,1,20220809173458.000,41.12XXXX,-8.52XXXX,140.200,0.00,237.6,1,,2.3,2.5,1.0,,20,5,1,,48,,</k>
Here's what each value means, in order:
<ol>
GNSS run status
Fix status
UTC date and time
Latitude
Longitude
MSL altitude
Speed over ground
Course over ground
Fix mode
Reserver1
HDOP
PDOP
VDOP
Reserved2
GNSS Satellites in View
GPS Satellites used
GLONASS Satellites used
Reserver3
C/N0 max
HPA
VPA
</ol>
You can learn more about these parameters and possible values by checking the <k>AT+CGNSINF</k> AT command on the SIM7000G AT commands manual.
<h3>Wrapping Up</h3>
In this tutorial, you learned how to use the LILYGO T-SIM7000G ESP32 board to get GPS data. We showed you a simple example that prints the GPS data in the Serial Monitor. The idea is to modify the example and apply it to your own projects. It should also be compatible with a regular ESP32 board connected to a separated SIM7000G module.
The ESP32 T-SIM7000G board features will allow you to build a wide variety of projects taking into account that it can connect to the internet in remote locations using a SIM card data plan and send SMS. The fact that it can use a battery and solar panels for charging is also great, and the microSD card can also be very useful for datalogging or to save configuration settings.
<h2>Getting Started with LILYGO T-SIM7000G ESP32 (LTE, GPRS, and GPS)</h2>
Get started with the ESP32 and the SIM7000G LTE/GPS/GPRS module. Throughout this tutorial, we'll use the LILYGO T-SIM7000G ESP32 board that combines the ESP32 chip, the SIM7000G module, microSD card slot, battery holder, and charger on the same board. Besides Wi-Fi and Bluetooth, you can communicate with this ESP32 board using SMS. You can also connect it to the internet using your SIM card data plan and get GPS location.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/Getting-Started-LILYGO-T-SIM7000G-ESP32.jpg">
<h3>Introducing the LILYGO T-SIM7000G ESP32</h3>
The LILYGO T-SIM7000G is an ESP32 development board with a SIM7000G chip. This adds LTE (4G), GPS, and GPRS to your board. This means that with this board you can send SMS, get location and time using GPS, and connect it to the internet using a SIM card data plan. This board doesn't support phone calls.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/ESP32-TSIM7000G.jpg">
Besides the SIM7000G module, the board also comes with some interesting features like a battery holder for a 18650 battery, a battery charging circuit where you can connect solar panels to recharge the battery, and a microSD card slot that can be useful for data logging projects or to save configuration settings.
Here's a summary of the LILYGO T-SIM7000G ESP32 board features:
Supply voltage: 3.3V DC or 5V DC
ESP32 chip (WROVER-B Module) (240MHz dual-core processor)
Flash memory: 4MB
PSRAM: 8MB
SRAM: 520KB
Built-in Wi-Fi
Built-in Bluetooth
USB to serial converter: CP2104 or CH9102 (drivers)
Built-in SIM7000G module
Built-in nano SIM card slot
Built-in SIM antenna slot
Built-in GPS antenna slot
Built-in Li-ion/Li-Po battery charging circuit:
DW01A battery protection IC
CN3065 solar energy charging interface for 4.4-6.8V solar panel
Built-in 1x 18650 battery holder
Built-in solar panel connector 2p JST-PH
Built-in Micro SD card slot
Built-in on/off switch
To use the capabilities of this board you need to have a nano SIM card with a data plan and a <a href="https://makeradvisor.com/tools/usb-c-data-charging-cable/" target="_blank">USB-C cable</a> to upload code to the board.
The package includes an external antenna for LTE, and another antenna for GPS.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/ESP32-SIM7000G-GPS-antenna-SIM-antenna.jpg">
There are two versions of this board (Version 20191227 and version 20200415). The picture below shows the two versions. Visually, they mainly differ on the position of the nano SIM card holder.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/ESP32-SIM700G-LILYGO-OLD-VS-NEW.jpg">
The first version had some design issues, so it is recommended to get the latest version. Aditionally, the latest version comes with some improvements taking into account users' feedback. I got my board a long time ago, I've got the first version and that's the one we'll use throughout this tutorial. However, this is also compatible with the latest board. 
Here's a list of the improvements on the latest version (<a href="https://github.com/Xinyuan-LilyGO/LilyGO-T-SIM7000G?spm=a2g0o.detail.1000023.1.35684571ByWwA0" target="_blank">check the documentation</a>):
Added active GPS antenna power control, when the module GPIO 4 is not turned on, the antenna consumes only the static current of the LDO;
Replaced TP4056 with CN3065 for solar charge input management;
Added reverse battery protection;
Added battery overcharge protection;
Added battery over-discharge protection.
You can check the schematic diagrams for each version on the following links:
<a href="https://github.com/Xinyuan-LilyGO/LilyGO-T-SIM7000G/blob/master/schematic/SIM7000G_20191227.pdf" target="_blank">LILYGO T-SIM7000G ESP32 <k>Version 1.0</k> schematic diagram</a>
<a href="https://github.com/Xinyuan-LilyGO/LilyGO-T-SIM7000G/blob/master/schematic/SIM7000G_20200415.pdf" target="_blank">LILYGO T-SIM7000G ESP32 <k>Version 1.1</k> schematic diagram</a>
<k>Where to buy LILYGO T-SIM7000G ESP32?</k>
Check the following link:
<a href="https://makeradvisor.com/tools/t-sim7000g-esp32/" target="_blank">LILYGO T-SIM7000G ESP32 (LTE, GPRS, and GPS)  Maker Advisor</a>
All stores in the previous link should sell the latest version, but double-check the product page, just in case the seller changes something.
You can use the preceding links or go directly to <a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank">MakerAdvisor.com/tools</a> to find all the parts for your projects at the best price!
<a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/header-200.png?w=828&quality=100&strip=all&ssl=1" data-recalc-dims="1" loading="lazy" fetchpriority="low"></a>
<h3>LILYGO T-SIM7000G ESP32 Pinout</h3>
The following pictures show the pinout of the T-SIM7000G ESP32 board.
This is the pinout for version V1.0.
<a href="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/LILYGO-SIM7000G-ESP32-V1_0_pinout.jpg?quality=100&strip=all&ssl=1"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/LILYGO-SIM7000G-ESP32-V1_0_pinout.jpg"></a><figcaption><a href="https://github.com/Xinyuan-LilyGO/LilyGO-T-SIM7000G/blob/master/Historical/SIM7000G_20191227/README.MD" target="_blank">Image source</a></figcaption>
And this is the pinout for the improved board V1.1.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/LILYGO-SIM7000G-V1_1-ESP32-pinout.jpg"><figcaption><a href="https://github.com/Xinyuan-LilyGO/LilyGO-T-SIM7000G/blob/master/Historical/SIM7000G_20200415/README.MD" target="_blank">Image source</a></figcaption>
The following table shows the connections between the ESP32 and the SIM7000G chip:
<table><tbody>
<tr>
<td><k>SIM7000G</k></td>
<td><k>ESP32</k></td>
</tr>
<tr>
<td>TX</td>
<td>GPIO 26</td>
</tr>
<tr>
<td>RX</td>
<td>GPIO 27</td>
</tr>
<tr>
<td>POWER</td>
<td>GPIO 4</td>
</tr>
</tbody></table>To communicate with the microSD card, you need SPI communication protocol. These are the GPIOs used:
<table><tbody>
<tr>
<td><k>MicroSD Card (TF card)</k></td>
<td><k>ESP32</k></td>
</tr>
<tr>
<td>MOSI</td>
<td>GPIO 15</td>
</tr>
<tr>
<td>SCLK</td>
<td>GPIO 14</td>
</tr>
<tr>
<td>CS</td>
<td>GPIO 13</td>
</tr>
<tr>
<td>MISO</td>
<td>GPIO 2</td>
</tr>
</tbody></table><h3>SIM Card</h3>
This board only supports nano SIM cards. You need a SIM card for LTE and GPRS. However, if you only want to use GPS data, you don't need a SIM card.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/LILYGO-T-SIM7000G-ESP32-nano-SIM-card.jpg">
To use LTE and GPRS you need a SIM card with some data plan. This can be expensive in some countries, so it might be cost prohibitive depending on how much you can get a data plan for in your country.
Where we live (Portugal), we can get a SIM card with data plan, calls, and SMS (enough for ESP32 projects) for approximately $12. We recommend using a SIM card with a prepaid or monthly plan, so that you know exactly how much you'll spend. There are also companies specialized in SIM cards for IoT projects.
<h3>APN Details</h3>
To connect your SIM card to the internet, you need to have your phone plan provider's <k>APN details</k>. You need the domain name, username, and password.
In my case, I'm using Vodafone Portugal. If you search for GPRS APN settings followed by your phone plan provider name, (in my case its: GPRS APN Vodafone<k> Portugal</k>), you can usually find in a forum or in their website all the information that you need.
It might be a bit tricky to find the details if you don't use a well-known provider. So, you might need to contact them directly.
<h3>AT Commands</h3>
AT commands are used to control MODEMs, as is the case of the SIM7000G. In the case of the ESP32, you send the AT commands via serial communication protocol. Then, the modem responds back also via serial communication.
There are four types of AT commands: test; read; set; execution. You can find the complete list of AT commands for the SIM7000G on the following link:
<a href="https://cdn.geekfactory.mx/sim7000g/SIM7000%20Series_AT%20Command%20Manual_V1.06.pdf" target="_blank">SIM7000G AT Commands</a> (mudar para um link nosso?)
Here are some of the most common AT commands:
check communication with the module: <k>AT</k>
check if SIM card is ready: <k>AT+CPIN?</k>
check the registration status of the device: <k>AT+CGREG?</k>
send SMS to a number: <k>AT+CMGS=PHONE_NUMBER</k>(in international format)
<h3>Libraries</h3>
As we explained previously, the ESP32 communicates with the SIM7000G chip by sending AT commands via serial communication. You don't need a library, you can simply establish a serial communication with the module and start sending AT commands. 
However, it might be more practical to use a library. For example, the <a href="https://github.com/vshymanskyy/TinyGSM" target="_blank">TinyGSM</a> library knows which commands to send, and how to handle AT responses, and wraps that into the standard Arduino Client interfacethat's the library we'll use in this tutorial.
<h4>Installing the TinyGSM Library</h4>
Open your Arduino IDE and go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k>. The Library Manager should open. Search for <k>TinyGSM</k>. Select the TinyGSM library by Volodymyr Shymanskyy.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/tinygsm-library-arduino-ide.png">
You also need to install the StreamDebugger library. Go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k>, search for <k>StreamDebugger</k>, and install it.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/streamdebugger-library-arduino-ide.png">
<h3>Preparing the LILYGO T-SIM7000G ESP32 Board</h3>
Before testing your board, you need to follow the next steps:
<k>1)</k> Insert a nano SIM card;
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/nano-SIM-card-vodafone.jpg">
<k>2) </k>Connect the Full Band LTE antenna (SIM);
<k>3)</k> Connect the GPS antenna.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/ESP32-T-SIM7000G-antennas.jpg">
If you want to test the microSD card features, you should only connect a microSD card, after uploading the code.
<h3>LILYGO T-SIM7000G ESP32 Network Test</h3>
The first sketch you should run on your board is the Network Test. This will tell you the network selection settings you should usethis depends on the SIM card, modem(SIM7000G), and the mobile network operator it uses.
<ol>Copy the following code to your Arduino IDE (the code was adapted <a href="https://github.com/Xinyuan-LilyGO/LilyGO-T-SIM7000G/blob/master/examples/Arduino_NetworkTest/Arduino_NetworkTest.ino" target="_blank">from this example</a>).</ol>
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/lilygo-t-sim7000g-esp32-lte-gprs-gps/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
// Original code: https://github.com/Xinyuan-LilyGO/LilyGO-T-SIM7000G/blob/master/examples/Arduino_NetworkTest/Arduino_NetworkTest.ino
#define TINY_GSM_MODEM_SIM7000
#define TINY_GSM_RX_BUFFER 1024 // Set RX buffer to 1Kb
#define SerialAT Serial1
// Set serial for debug console (to the Serial Monitor, default speed 115200)
#define SerialMon Serial
// See all AT commands, if wanted
// #define DUMP_AT_COMMANDS
// set GSM PIN, if any
#define GSM_PIN ""
// Your GPRS credentials, if any
const char apn[]  = "";     //SET TO YOUR APN
const char gprsUser[] = "";
const char gprsPass[] = "";
#include &lt;TinyGsmClient.h>
#include &lt;SPI.h>
#include &lt;SD.h>
#include &lt;Ticker.h>
#ifdef DUMP_AT_COMMANDS
  #include &lt;StreamDebugger.h>
  StreamDebugger debugger(SerialAT, SerialMon);
  TinyGsm modem(debugger);
#else
  TinyGsm modem(SerialAT);
#endif
// LilyGO T-SIM7000G Pinout
#define UART_BAUD           115200
#define PIN_DTR             25
#define PIN_TX              27
#define PIN_RX              26
#define PWR_PIN             4
#define SD_MISO             2
#define SD_MOSI             15
#define SD_SCLK             14
#define SD_CS               13
#define LED_PIN             12
void modemPowerOn(){
  pinMode(PWR_PIN, OUTPUT);
  digitalWrite(PWR_PIN, LOW);
  delay(1000);
  digitalWrite(PWR_PIN, HIGH);
}
void modemPowerOff(){
  pinMode(PWR_PIN, OUTPUT);
  digitalWrite(PWR_PIN, LOW);
  delay(1500);
  digitalWrite(PWR_PIN, HIGH);
}
void modemRestart(){
  modemPowerOff();
  delay(1000);
  modemPowerOn();
}
void setup(){
  // Set console baud rate
  SerialMon.begin(115200);
  delay(10);
  // Set LED OFF
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, HIGH);
  modemPowerOn();
  Serial.println("========SDCard Detect.======");
  SPI.begin(SD_SCLK, SD_MISO, SD_MOSI);
  if (!SD.begin(SD_CS)) {
      Serial.println("SDCard MOUNT FAIL");
  } else {
    uint32_t cardSize = SD.cardSize() / (1024 * 1024);
    String str = "SDCard Size: " + String(cardSize) + "MB";
    Serial.println(str);
  }
  Serial.println("===========================");
  SerialAT.begin(UART_BAUD, SERIAL_8N1, PIN_RX, PIN_TX);
  Serial.println("/**********************************************************/");
  Serial.println("To initialize the network test, please make sure your LTE ");
  Serial.println("antenna has been connected to the SIM interface on the board.");
  Serial.println("/**********************************************************/\n\n");
  delay(10000);
}
void loop(){
  String res;
  Serial.println("========INIT========");
  if (!modem.init()) {
    modemRestart();
    delay(2000);
    Serial.println("Failed to restart modem, attempting to continue without restarting");
    return;
  }
  Serial.println("========SIMCOMATI======");
  modem.sendAT("+SIMCOMATI");
  modem.waitResponse(1000L, res);
  res.replace(GSM_NL "OK" GSM_NL, "");
  Serial.println(res);
  res = "";
  Serial.println("=======================");
  Serial.println("=====Preferred mode selection=====");
  modem.sendAT("+CNMP?");
  if (modem.waitResponse(1000L, res) == 1) {
    res.replace(GSM_NL "OK" GSM_NL, "");
    Serial.println(res);
  }
  res = "";
  Serial.println("=======================");
  Serial.println("=====Preferred selection between CAT-M and NB-IoT=====");
  modem.sendAT("+CMNB?");
  if (modem.waitResponse(1000L, res) == 1) {
    res.replace(GSM_NL "OK" GSM_NL, "");
    Serial.println(res);
  }
  res = "";
  Serial.println("=======================");
  String name = modem.getModemName();
  Serial.println("Modem Name: " + name);
  String modemInfo = modem.getModemInfo();
  Serial.println("Modem Info: " + modemInfo);
  // Unlock your SIM card with a PIN if needed
  if ( GSM_PIN && modem.getSimStatus() != 3 ) {
    modem.simUnlock(GSM_PIN);
  }
  for (int i = 0; i &lt;= 4; i++) {
    uint8_t network[] = {
        2,  /*Automatic*/
        13, /*GSM only*/
        38, /*LTE only*/
        51  /*GSM and LTE only*/
    };
    Serial.printf("Try %d method\n", network[i]);
    modem.setNetworkMode(network[i]);
    delay(3000);
    bool isConnected = false;
    int tryCount = 60;
    while (tryCount--) {
      int16_t signal =  modem.getSignalQuality();
      Serial.print("Signal: ");
      Serial.print(signal);
      Serial.print(" ");
      Serial.print("isNetworkConnected: ");
      isConnected = modem.isNetworkConnected();
      Serial.println( isConnected ? "CONNECT" : "NO CONNECT");
      if (isConnected) {
        break;
      }
      delay(1000);
      digitalWrite(LED_PIN, !digitalRead(LED_PIN));
    }
    if (isConnected) {
        break;
    }
  }
  digitalWrite(LED_PIN, HIGH);
  Serial.println();
  Serial.println("Device is connected .");
  Serial.println();
  Serial.println("=====Inquiring UE system information=====");
  modem.sendAT("+CPSI?");
  if (modem.waitResponse(1000L, res) == 1) {
    res.replace(GSM_NL "OK" GSM_NL, "");
    Serial.println(res);
  }
  Serial.println("/**********************************************************/");
  Serial.println("After the network test is complete, please enter the  ");
  Serial.println("AT command in the serial terminal.");
  Serial.println("/**********************************************************/\n\n");
  while (1) {
    while (SerialAT.available()) {
      SerialMon.write(SerialAT.read());
    }
    while (SerialMon.available()) {
      SerialAT.write(SerialMon.read());
    }
  }
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/LILYGO_T-SIM7000G/Network_Test.ino" target="_blank">View raw code</a>
<ol start="2">Insert your SIM card pin, if you have it. In my case, I disabled the pin. </ol>
<k>#define GSM_PIN ""</k>
<ol start="3">Insert your apn details on the following lines:</ol>
<k>const char apn[]  = "";     //SET TO YOUR APN
const char gprsUser[] = "";
const char gprsPass[] = "";</k>
For example, in my case:
<k>const char apn[]  = "net2.vodafone.pt";     //SET TO YOUR APN
const char gprsUser[] = "vodafone";
const char gprsPass[] = "vodafone";</k>
<ol start="4">Go to <k>Tools </k>> <k>Board </k>and select <k>ESP32 Dev Module</k>.</ol>
<ol start="5">Finally, upload the code to your board.</ol>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/05/arduino-2-0-upload-button.png">
Now, you can insert a microSD card, if you want to test the microSD card features.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/ESP32-T-SIM7000G-microSD-card.jpg">
Then, open the Serial Monitor at a baud rate of 115200. Press the on-board RST button to restart the board.
Wait some time until the board connects to the network (in my case, it may take up to 2 minutes).
You should get something similar in the Serial Monitor.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/SIM7000-network-test-ESP32-Serial-Monitor.png">
You can see that it identifies the microSD card and connects to the network successfully.
Check the preferred mode selection and the preferred selection between CAT-M and NB-IoT. You'll need those parameters later, and they differ depending on your SIM card and provider.
<h3>LILYGO T-SIM7000G ESP32: Connect to the Internet, Send SMS, and Get GPS Data</h3>
If everything went as expected, now you're ready to test other functions like connecting to the internet, sending SMS, and getting GPS data.
Copy the following code to your Arduino IDE. This code was adapted <a href="https://github.com/Xinyuan-LilyGO/LilyGO-T-SIM7000G/blob/master/examples/Arduino_TinyGSM/AllFunctions/AllFunctions.ino" target="_blank">from this example</a>.
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/lilygo-t-sim7000g-esp32-lte-gprs-gps/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
// Based on the following example: https://github.com/Xinyuan-LilyGO/LilyGO-T-SIM7000G/blob/master/examples/Arduino_TinyGSM/AllFunctions/AllFunctions.ino
#define TINY_GSM_MODEM_SIM7000
#define TINY_GSM_RX_BUFFER 1024 // Set RX buffer to 1Kb
#define SerialAT Serial1
// See all AT commands, if wanted
#define DUMP_AT_COMMANDS
// set GSM PIN, if any
#define GSM_PIN ""
// Your GPRS credentials, if any
const char apn[]  = "";     //SET TO YOUR APN
const char gprsUser[] = "";
const char gprsPass[] = "";
// Set phone number, if you want to test SMS
// Set a recipient phone number to test sending SMS (it must be in international format including the "+" sign)
#define SMS_TARGET  ""
#include &lt;TinyGsmClient.h>
#include &lt;SPI.h>
#include &lt;SD.h>
#include &lt;Ticker.h>
#ifdef DUMP_AT_COMMANDS  // if enabled it requires the streamDebugger lib
  #include &lt;StreamDebugger.h>
  StreamDebugger debugger(SerialAT, Serial);
  TinyGsm modem(debugger);
#else
  TinyGsm modem(SerialAT);
#endif
#define uS_TO_S_FACTOR 1000000ULL  // Conversion factor for micro seconds to seconds
#define TIME_TO_SLEEP  60          // Time ESP32 will go to sleep (in seconds)
#define UART_BAUD   115200
#define PIN_DTR     25
#define PIN_TX      27
#define PIN_RX      26
#define PWR_PIN     4
#define SD_MISO     2
#define SD_MOSI     15
#define SD_SCLK     14
#define SD_CS       13
#define LED_PIN     12
int counter, lastIndex, numberOfPieces = 24;
String pieces[24], input;
void setup(){
  // Set console baud rate
  Serial.begin(115200);
  delay(10);
  // Set LED OFF
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, HIGH);
  pinMode(PWR_PIN, OUTPUT);
  digitalWrite(PWR_PIN, HIGH);
  delay(300);
  digitalWrite(PWR_PIN, LOW);
  SPI.begin(SD_SCLK, SD_MISO, SD_MOSI, SD_CS);
  if (!SD.begin(SD_CS)) {
    Serial.println("SDCard MOUNT FAIL");
  } else {
    uint32_t cardSize = SD.cardSize() / (1024 * 1024);
    String str = "SDCard Size: " + String(cardSize) + "MB";
    Serial.println(str);
  }
  Serial.println("\nWait...");
  delay(1000);
  SerialAT.begin(UART_BAUD, SERIAL_8N1, PIN_RX, PIN_TX);
  // Restart takes quite some time
  // To skip it, call init() instead of restart()
  Serial.println("Initializing modem...");
  if (!modem.restart()) {
    Serial.println("Failed to restart modem, attempting to continue without restarting");
  }
}
void loop(){
  // Restart takes quite some time
  // To skip it, call init() instead of restart()
  Serial.println("Initializing modem...");
  if (!modem.init()) {
    Serial.println("Failed to restart modem, attempting to continue without restarting");
  }
  String name = modem.getModemName();
  delay(500);
  Serial.println("Modem Name: " + name);
  String modemInfo = modem.getModemInfo();
  delay(500);
  Serial.println("Modem Info: " + modemInfo);
  
  // Unlock your SIM card with a PIN if needed
  if ( GSM_PIN && modem.getSimStatus() != 3 ) {
      modem.simUnlock(GSM_PIN);
  }
  modem.sendAT("+CFUN=0 ");
  if (modem.waitResponse(10000L) != 1) {
    DBG(" +CFUN=0  false ");
  }
  delay(200);
  /*
    2 Automatic
    13 GSM only
    38 LTE only
    51 GSM and LTE only
  * * * */
  String res;
  // CHANGE NETWORK MODE, IF NEEDED
  res = modem.setNetworkMode(2);
  if (res != "1") {
    DBG("setNetworkMode  false ");
    return ;
  }
  delay(200);
  /*
    1 CAT-M
    2 NB-Iot
    3 CAT-M and NB-IoT
  * * */
  // CHANGE PREFERRED MODE, IF NEEDED
  res = modem.setPreferredMode(1);
  if (res != "1") {
    DBG("setPreferredMode  false ");
    return ;
  }
  delay(200);
  /*AT+CBANDCFG=&lt;mode>,&lt;band>[,&lt;band>]
   * &lt;mode> "CAT-M"   "NB-IOT"
   * &lt;band>  The value of &lt;band> must is in the band list of getting from  AT+CBANDCFG=?
   * For example, my SIM card carrier "NB-iot" supports B8.  I will configure +CBANDCFG= "Nb-iot ",8
   */
  /* modem.sendAT("+CBANDCFG=\"NB-IOT\",8 ");*/
  
  /* if (modem.waitResponse(10000L) != 1) {
       DBG(" +CBANDCFG=\"NB-IOT\" ");
   }*/
   delay(200);
  modem.sendAT("+CFUN=1 ");
  if (modem.waitResponse(10000L) != 1) {
    DBG(" +CFUN=1  false ");
  }
  delay(200);
  SerialAT.println("AT+CGDCONT?");
  delay(500);
  if (SerialAT.available()) {
    input = SerialAT.readString();
    for (int i = 0; i &lt; input.length(); i++) {
      if (input.substring(i, i + 1) == "\n") {
        pieces[counter] = input.substring(lastIndex, i);
        lastIndex = i + 1;
        counter++;
       }
        if (i == input.length() - 1) {
          pieces[counter] = input.substring(lastIndex, i);
        }
      }
      // Reset for reuse
      input = "";
      counter = 0;
      lastIndex = 0;
      for ( int y = 0; y &lt; numberOfPieces; y++) {
        for ( int x = 0; x &lt; pieces[y].length(); x++) {
          char c = pieces[y][x];  //gets one byte from buffer
          if (c == ',') {
            if (input.indexOf(": ") >= 0) {
              String data = input.substring((input.indexOf(": ") + 1));
              if ( data.toInt() > 0 && data.toInt() &lt; 25) {
                modem.sendAT("+CGDCONT=" + String(data.toInt()) + ",\"IP\",\"" + String(apn) + "\",\"0.0.0.0\",0,0,0,0");
              }
              input = "";
              break;
            }
          // Reset for reuse
          input = "";
         } else {
          input += c;
         }
      }
    }
  } else {
    Serial.println("Failed to get PDP!");
  }
  Serial.println("\n\n\nWaiting for network...");
  if (!modem.waitForNetwork()) {
    delay(10000);
    return;
  }
  if (modem.isNetworkConnected()) {
    Serial.println("Network connected");
  }
  
  // --------TESTING GPRS--------
  Serial.println("\n---Starting GPRS TEST---\n");
  Serial.println("Connecting to: " + String(apn));
  if (!modem.gprsConnect(apn, gprsUser, gprsPass)) {
    delay(10000);
    return;
  }
  Serial.print("GPRS status: ");
  if (modem.isGprsConnected()) {
    Serial.println("connected");
  } else {
    Serial.println("not connected");
  }
  String ccid = modem.getSimCCID();
  Serial.println("CCID: " + ccid);
  String imei = modem.getIMEI();
  Serial.println("IMEI: " + imei);
  String cop = modem.getOperator();
  Serial.println("Operator: " + cop);
  IPAddress local = modem.localIP();
  Serial.println("Local IP: " + String(local));
  int csq = modem.getSignalQuality();
  Serial.println("Signal quality: " + String(csq));
  SerialAT.println("AT+CPSI?");     //Get connection type and band
  delay(500);
  if (SerialAT.available()) {
    String r = SerialAT.readString();
    Serial.println(r);
  }
  Serial.println("\n---End of GPRS TEST---\n");
  modem.gprsDisconnect();
  if (!modem.isGprsConnected()) {
    Serial.println("GPRS disconnected");
  } else {
    Serial.println("GPRS disconnect: Failed.");
  }
  // --------TESTING GPS--------
  
  Serial.println("\n---Starting GPS TEST---\n");
  // Set SIM7000G GPIO4 HIGH ,turn on GPS power
  // CMD:AT+SGPIO=0,4,1,1
  // Only in version 20200415 is there a function to control GPS power
  modem.sendAT("+SGPIO=0,4,1,1");
  if (modem.waitResponse(10000L) != 1) {
    DBG(" SGPIO=0,4,1,1 false ");
  }
  modem.enableGPS();
  float lat,  lon;
  while (1) {
    if (modem.getGPS(&lat, &lon)) {
      Serial.printf("lat:%f lon:%f\n", lat, lon);
      break;
    } else {
      Serial.print("getGPS ");
      Serial.println(millis());
    }
    delay(2000);
  }
  modem.disableGPS();
  // Set SIM7000G GPIO4 LOW ,turn off GPS power
  // CMD:AT+SGPIO=0,4,1,0
  // Only in version 20200415 is there a function to control GPS power
  modem.sendAT("+SGPIO=0,4,1,0");
  if (modem.waitResponse(10000L) != 1) {
    DBG(" SGPIO=0,4,1,0 false ");
  }
  Serial.println("\n---End of GPRS TEST---\n");
  // --------TESTING SENDING SMS--------
  res = modem.sendSMS(SMS_TARGET, String("Hello from ") + imei);
  DBG("SMS:", res ? "OK" : "fail");
  // --------TESTING POWER DONW--------
  // Try to power-off (modem may decide to restart automatically)
  // To turn off modem completely, please use Reset/Enable pins
  modem.sendAT("+CPOWD=1");
  if (modem.waitResponse(10000L) != 1) {
    DBG("+CPOWD=1");
  }
  // The following command does the same as the previous lines
  modem.poweroff();
  Serial.println("Poweroff.");
  // GO TO SLEEP
  esp_sleep_enable_timer_wakeup(TIME_TO_SLEEP * uS_TO_S_FACTOR);
  delay(200);
  esp_deep_sleep_start();
  // Do nothing forevermore
  while (true) {
      modem.maintain();
  }
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/LILYGO_T-SIM7000G/Full_Test.ino" target="_blank">View raw code</a>
Insert your SIM card pin on the following line:
<k>#define GSM_PIN ""</k>
Fill your APN details:
<k>const char apn[]  = "net2.vodafone.pt";     //SET TO YOUR APN
const char gprsUser[] = "vodafone";
const char gprsPass[] = "vodafone";</k>
Set a recipient phone number to test sending SMS (it must be in international format including the + sign):
<k>// Set phone number, if you want to test SMS
#define SMS_TARGET  "+XXXXXXXXXXXXXXXX"</k>
Set the network mode with the value you got from the previous example.
<k>/*
  2 Automatic
  13 GSM only
  38 LTE only
  51 GSM and LTE only
* * * */
String res;
<k>// CHANGE NETWORK MODE, IF NEEDED
</k>res = modem.setNetworkMode(<k>2</k>);
if (res != "1") {
  DBG("setNetworkMode  false ");
  return ;
}
delay(200);</k>
Change the preferred mode with the value you got from the previous example.
<k>/*
  1 CAT-M
  2 NB-Iot
  3 CAT-M and NB-IoT
* * */
<k>// CHANGE PREFERRED MODE, IF NEEDED
</k>res = modem.setPreferredMode(<k>1</k>);
if (res != "1") {
  DBG("setPreferredMode  false ");
  return ;
}
delay(200);</k>
After that, you can upload the code to your board. Don't forget to select<k> ESP32 Dev Module</k> in <k>Tools </k>> <k>Board</k>. You also need to <k>remove the microSD card every time you want to upload a new sketch</k>.
After uploading, you can insert the microSD card. Open the Serial Monitor at a baud rate of 115200, and press the on-board RST button to restart it.
The board may take some time to get GPS data for the first time. Your <k>board needs to be placed outside to be able to get a satellite signal</k>. I placed mine next to the window and it was able to accurately get the GPS position.
You should get something similar.
<k>Wait...
Initializing modem...
ATE0
AT+CFUN=0
Failed to restart modem, attempting to continue without restarting
Initializing modem...
AT
AT
AT
OK
ATE0
ATE0
OK
AT+CMEE=0
OK
AT+CLTS=1
OK
AT+CBATCHK=1
OK
AT+CPIN?
+CPIN: READY
OK
AT+GMM
SIMCOM_SIM7000G
OK
Modem Name: SIMCOM SIM7000G
ATI
SIM7000G R1529
OK
Modem Info: SIM7000G R1529
AT+SGPIO=0,4,1,0
OK
AT+CPIN?
+CPIN: READY
OK
AT+CFUN=0 
+CPIN: NOT READY
OK
AT+CNMP=2
OK
AT+CMNB=1
OK
AT+CFUN=1 
OK
AT+CGDCONT=1,"IP","net2.vodafone.pt","0.0.0.0",0,0,0,0
AT+CGDCONT=13,"IP","net2.vodafone.pt","0.0.0.0",0,0,0,0
Waiting for network...
AT+CEREG?
OK
AT+CGREG?
+CGREG: 0,2
OK
AT+CEREG?
+CEREG: 0,0
OK
AT+CGREG?
+CGREG: 0,2
OK
AT+CEREG?
+CEREG: 0,0
OK
AT+CGREG?
+CGREG: 0,2
OK
AT+CEREG?
+CEREG: 0,0
OK
AT+CGREG?
+CGREG: 0,2
OK
AT+CEREG?
+CEREG: 0,0
OK
AT+CGREG?
+CGREG: 0,2
OK
AT+CEREG?
+CEREG: 0,0
OK
AT+CGREG?
+CGREG: 0,2
OK
AT+CEREG?
DST: 1
*PSUTTZ: 22/08/07,13:45:17","+04",1
+CEREG: 0,0
OK
AT+CGREG?
+CGREG: 0,1
OK
AT+CEREG?
+CEREG: 0,0
OK
AT+CGREG?
+CGREG: 0,1
OK
Network connected
---Starting GPRS TEST---
Connecting to: net2.vodafone.pt
AT+CIPSHUT
SHUT OK
AT+CGATT=0
OK
AT+SAPBR=3,1,"Contype","GPRS"
OK
AT+SAPBR=3,1,"APN","net2.vodafone.pt"
OK
AT+SAPBR=3,1,"USER","vodafone"
OK
AT+SAPBR=3,1,"PWD","vodafone"
OK
AT+CGDCONT=1,"IP","net2.vodafone.pt"
OK
AT+CGATT=1
OK
AT+CGACT=1,1
DST: 1
*PSUTTZ: 22/08/07,13:45:19","+04",1
OK
AT+SAPBR=1,1
OK
AT+SAPBR=2,1
+SAPBR: 1,1,"10.196.118.208"
OK
AT+CIPMUX=1
OK
AT+CIPQSEND=1
OK
AT+CIPRXGET=1
OK
AT+CSTT="net2.vodafone.pt","vodafone","vodafone"
OK
AT+CIICR
OK
AT+CIFSR;E0
10.196.118.208
OK
GPRS status: AT+CGATT?
+CGATT: 1
OK
AT+CIFSR;E0
10.196.118.208
OK
connected
AT+CCID
8935101211825295132f
OK
CCID: 8935101211825295132f
AT+GSN
869951031125929
OK
IMEI: 869951031125929
AT+COPS?
+COPS: 0,0,"vodafone P",3
OK
Operator: vodafone P
AT+CIFSR;E0
10.196.118.208
OK
Local IP: 3497444362
AT+CSQ
+CSQ: 22,0
OK
Signal quality: 22
+CPSI: GSM,Online,268-01,0x000e,63308,15 EGSM 900,-73,0,38-38
OK
---End of GPRS TEST---
AT+CIPSHUT
SHUT OK
AT+CGATT=0
+SAPBR 1: DEACT
OK
AT+CGATT?
+CGATT: 0
OK
GPRS disconnected
---Starting GPS TEST---
AT+SGPIO=0,4,1,1
OK
AT+CGNSPWR=1
OK
AT+CGNSINF
+CGNSINF: 0,,,,,,,,,,,,,,,,,,,,
OK
getGPS 26839
AT+CGNSINF
+CGNSINF: 1,0,,,,,,,0,,,,,,12,,,,50,,
OK
getGPS 28844
AT+CGNSINF
+CGNSINF: 1,0,,,,,,,0,,,,,,12,,,,51,,
OK
getGPS 30850
AT+CGNSINF
+CGNSINF: 1,0,,,,,,,0,,,,,,13,,,,51,,
OK
getGPS 32856
AT+CGNSINF
+CGNSINF: 1,0,,,,,,,0,,,,,,12,,,,51,,
OK
getGPS 34862
AT+CGNSINF
+CGNSINF: 1,0,,,,,,,0,,,,,,12,,,,51,,
OK
getGPS 36868
AT+CGNSINF
+CGNSINF: 1,1,20220807134533.000,41.12XXXX,-8.530XXXX,116.200,0.00,0.0,1,,4.2,,,,13,4,,,51,,
OK
lat:41.12XXXX lon:-8.530XXXX
AT+CGNSPWR=0
OK
AT+SGPIO=0,4,1,0
OK
---End of GPRS TEST---
AT+CMGF=1
OK
AT+CSCS="GSM"
OK
AT+CMGS="+351916XXXXXXXX"
>Hello from 86995103XXXXXXXXX 
+CMGS: 228
OK
AT+CPOWD=1
NORMAL POWER DOWN
AT+CPOWD=1
Poweroff.</k>
<h3>How the Code Works</h3>
Let's take a quick look at the relevant parts of code.
First, you need to define the module you're using. The library is compatible with many different modules. To use the SIM7000G, include the following line:
<k>#define TINY_GSM_MODEM_SIM7000</k>
Insert the SIM card pin, APN details, and SMS recipient:
<k>// set GSM PIN, if any
#define GSM_PIN ""
// Your GPRS credentials, if any
const char apn[]  = "net2.vodafone.pt";     //SET TO YOUR APN
const char gprsUser[] = "vodafone";
const char gprsPass[] = "vodafone";
// Set phone numbers, if you want to test SMS
#define SMS_TARGET  "+351916301581"</k>
Include the TinyGSM and SPI libraries. You also need to include the SD library if you want to use the microSD card.
<k>#include &lt;TinyGsmClient.h>
#include &lt;SPI.h>
#include &lt;SD.h>
#include &lt;Ticker.h></k>
Create a TinyGsmClient instance:
<k>#ifdef DUMP_AT_COMMANDS  // if enabled it requires the streamDebugger lib
  #include &lt;StreamDebugger.h>
  StreamDebugger debugger(SerialAT, Serial);
  TinyGsm modem(debugger);
#else
  TinyGsm modem(SerialAT);
#endif</k>
<h3>SIM7000G pinout</h3>
The following lines set the module baud rate and pinout:
<k>#define UART_BAUD   115200
#define PIN_DTR     25
#define PIN_TX      27
#define PIN_RX      26
#define PWR_PIN     4
#define SD_MISO     2
#define SD_MOSI     15
#define SD_SCLK     14
#define SD_CS       13
#define LED_PIN     12</k>
<h3>Power the modem</h3>
In the  setup(), you always need to include the following instructions to turn on the modem:
<k>pinMode(PWR_PIN, OUTPUT);
digitalWrite(PWR_PIN, HIGH);
delay(300);
digitalWrite(PWR_PIN, LOW);</k>
<h3>Initialize microSD Card</h3>
The following lines initialize the microSD card on the pins we defined earlier.
<k>SPI.begin(SD_SCLK, SD_MISO, SD_MOSI, SD_CS);
if (!SD.begin(SD_CS)) {
  Serial.println("SDCard MOUNT FAIL");
} else {
  uint32_t cardSize = SD.cardSize() / (1024 * 1024);
  String str = "SDCard Size: " + String(cardSize) + "MB";
  Serial.println(str);
}</k>
To learn more about using the microSD card with the ESP32, you can read the following guide: <a href="https://randomnerdtutorials.com/esp32-microsd-card-arduino/">ESP32: Guide for MicroSD Card Module using Arduino IDE</a>.
<h3>Start Serial Communication</h3>
Start a serial communication with the modem:
<k> SerialAT.begin(UART_BAUD, SERIAL_8N1, PIN_RX, PIN_TX);</k>
<h3>Restart and Initialize the Modem</h3>
Call the following lines to restart the modem:
<k>// Restart takes quite some time
// To skip it, call init() instead of restart()
Serial.println("Initializing modem...");
if (!modem.restart()) {
  Serial.println("Failed to restart modem, attempting to continue without restarting");
}</k>
Or the following lines to initialize:
<k>// To skip it, call init() instead of restart()
Serial.println("Initializing modem...");
if (!modem.init()) {
  Serial.println("Failed to restart modem, attempting to continue without restarting");
}</k>
Difference between restart() and init() according to documentation:  restart() generally takes longer than init() but ensures the module doesn't have lingering connections.
<h3>Get Modem Name and Info</h3>
You can use the getModemName() and getModemInfo() to get information about the modem.
<k>String name = modem.getModemName();
delay(500);
Serial.println("Modem Name: " + name);
String modemInfo = modem.getModemInfo();
delay(500);
Serial.println("Modem Info: " + modemInfo);</k>
<h3>Connect GPRS</h3>
To connect GPRS using the APN details:
<k>if (!modem.gprsConnect(apn, gprsUser, gprsPass)) {
  delay(10000);
  return;
}</k>
To check if it is connected, you can use the  isGprsConnected() method:
<k>if (modem.isGprsConnected()) {
  Serial.println("connected");
} else {
  Serial.println("not connected");
}</k>
<h3>Start GPS and Get Location</h3>
As mentioned previously, there are two versions of the LILYGO SIM7000G ESP32 board. The latest comes with active GPS antenna power controlwhen the module GPIO 4 is not turned on the antenna consumes only the static current of the LDO. This means we need to turn GPIO 4 on before getting GPS data to power the antenna. That's what the next lines do:
<k>// Set SIM7000G GPIO4 HIGH ,turn on GPS power
// CMD:AT+SGPIO=0,4,1,1
// Only in version 20200415 is there a function to control GPS power
modem.sendAT("+SGPIO=0,4,1,1");
if (modem.waitResponse(10000L) != 1) {
  DBG(" SGPIO=0,4,1,1 false ");
}</k>
If you have the oldest version, you don't need those lines of code.
You can start GPS using the enableGPS() method.
<k>modem.enableGPS();</k>
Get latitude and longitude using the getGPS() method.
<k>float lat,  lon;
while (1) {
  if (modem.getGPS(&lat, &lon)) {
    Serial.printf("lat:%f lon:%f\n", lat, lon);
    break;
  } else {
    Serial.print("getGPS ");
    Serial.println(millis());
  }
  delay(2000);
}</k>
When you're done using GPS, you can turn it off using the disableGPS() method:
<k>modem.disableGPS();</k>
And finally, turn off the power to the antenna by turning GPIO 4 off:
<k>// Set SIM7000G GPIO4 LOW ,turn off GPS power
// CMD:AT+SGPIO=0,4,1,0
// Only in version 20200415 is there a function to control GPS power
modem.sendAT("+SGPIO=0,4,1,0");
if (modem.waitResponse(10000L) != 1) {
  DBG(" SGPIO=0,4,1,0 false ");
}</k>
<h3>Sending SMS</h3>
To send an SMS, you can simply use the sendSMS() method and pass as arguments the recipient number and the message.
<k>res = modem.sendSMS(SMS_TARGET, String("Hello from ") + imei);
DBG("SMS:", res ? "OK" : "fail");</k>
<h3>Powering Down the Module</h3>
The LILYGO is supposed to work on a 18650 battery and solar panel, so we must cut power whenever it's not needed. So, it's useful to have a function to turn off the modem completely. You can use the poweroff() method or send the +CPOWD=1 AT command.
<k>modem.sendAT("+CPOWD=1");
if (modem.waitResponse(10000L) != 1) {
  DBG("+CPOWD=1");
}
// The following command does the same as the previous lines
modem.poweroff();
Serial.println("Poweroff.");</k>
And that's it for the most relevant parts of code.
<h3>Wrapping Up</h3>
In this tutorial, you learned how to use the LILYGO T-SIM7000G ESP32 board. This tutorial can also be applied if you're using a regular ESP32 connected to an external SIM7000G module. This module supports LTE, GPRS, and GPS, which can be very useful for IoT and Home Automation projects.
You learned how to connect GPRS, how to send SMS messages and how to get GPS data. The idea is to include the snippets of code you need in your own projects.
The LILYGO T-SIM7000G ESP32 board also comes with a microSD card slot that can be useful for datalogging projects or to save configuration settings. Furthermore, it comes with a battery holder and a battery charging circuit to use with solar panels. So, it's suitable to use in remote locations. However, I haven't experimented with the battery circuit yet.
For more examples, you can explore the <a href="https://github.com/vshymanskyy/TinyGSM" target="_blank">TinyGSM library repository</a> or the official <a href="https://github.com/Xinyuan-LilyGO/LilyGO-T-SIM7000G" target="_blank">LILYGO T-SIM7000G Github page</a>.
Do you have one of these boards? What do you think? Let us know in the comments below.
You may also like the following tutorials (that with minor changes can be used with the SIM7000G board):
<a href="https://randomnerdtutorials.com/esp32-cloud-mqtt-broker-sim800l/">Connect ESP32 to Cloud MQTT Broker (TTGO T-Call ESP32 SIM800L)</a>
<a href="https://randomnerdtutorials.com/esp32-sim800l-send-text-messages-sms/">ESP32 SIM800L: Send Text Messages (SMS Alert) with Sensor Readings</a>
<a href="https://randomnerdtutorials.com/esp32-sim800l-publish-data-to-cloud/">ESP32 Publish Data to Cloud without Wi-Fi (TTGO T-Call ESP32 SIM800L)</a>
<h2>Getting Started with Deta Base (Unlimited and Free Database for Developers)</h2>
Get started with Deta Base using the ESP32 board. Deta Base is a NoSQL database. It is unlimited, free, and easy to use. Additionally, it requires minimal setup. So, it's perfect for your hobbyist projects and prototyping. You'll learn how to perform create, read, update, delete and query operations in a Deta Base instance using an ESP32.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/ESP32-Get-Started-Deta-Base.jpg">
To interact with Deta base using the ESP32, we'll use the <a href="https://github.com/A223D/detaBaseArduinoESP32" target="_blank">detaBaseArduinoESP32 library</a>. The present tutorial was based on the guides created by the library developer. You can find the guides on the following link:
<a href="https://github.com/A223D/ESP32DetaGuides" target="_blank">ESP32 Deta Base Guides by Kushagra Goel</a>
<h3>Introducing Deta Base</h3>
The best way to describe <a href="https://www.deta.sh/" target="_blank">Deta Base</a>:
<blockquote>
Deta Base is a fully-managed, fast, scalable and secure NoSQL database with a focus on end-user simplicity. It offers a <a href="https://docs.deta.sh/docs/base/base_ui" target="_blank">UI</a> through which you can easily see, query, update and delete records in the database.
<cite>https://docs.deta.sh/docs/base/about</cite>
</blockquote>
And the best part is that Deta Base is <k>free </k>to use!
If you're wondering where your data is saved and if it is secured, here's the answer:
<blockquote>
Your data is encrypted and stored safely on AWS. Encryption keys are managed by AWS; AWS manages Exabytes of the world's most sensitive data.
<cite>https://docs.deta.sh/docs/base/about#is-my-data-secure</cite>
</blockquote>
We recommend taking a look at the docs to get more familiar with Deta Base:
<a href="https://docs.deta.sh/docs/base/about" target="_blank">Deta Base documentation</a>
Deta Base is still in the beta version, so you may expect improvements in the future.
<h3>Creating a Deta Base Account</h3>
To get started, you need to create a Deta Base account. Go to <a href="http://deta.sh" target="_blank">deta.sh</a>, and click on <k>Join Deta</k> to create a new account.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/deta-base-website.jpg">
Enter a username, password, and email to create a new account.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/Deta-base-sign-up.jpg">
Deta base will send you a verification email. Verify your account, and you should be redirected to your Deta dashboard. The following window pops up:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/see-my-key-deta-base.png">
By default, it creates a new project called default. As mentioned, projects are accessed via ids and keys. When you click on the <k>See My Key button</k>, you'll get your project id and key. Make sure you <k>save it somewhere because you'll need those later</k><k>the key will only be shown once</k>. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/deta-base-project-confidentials.jpg">
When you're done. Click <k>Close</k>.
The library we'll use with the ESP32 automatically creates a Base (database table) instance for your project. So, you don't need to manually create it on the Deta Base interface.
<h3>Installing the Deta Base Library for ESP32</h3>
To interact with Deta Base using the ESP32, we'll use the <a href="https://github.com/A223D/detaBaseArduinoESP32" target="_blank">detaBaseArduinoESP32 library</a>. You can install the library in the Arduino IDE. Go to <k>Sketch</k> > <k>Include Library</k> > <k>Manage Libraries</k>. Search for <k>detabasearduinoesp32 </k>and install the library by Kushagra Goel.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/install-detabasearduinoesp32-library-Arduino-IDE.png">
<h3>Deta Base with ESP32: CRUD Operations</h3>
In this section, you'll learn how to program your ESP32 to perform CRUD (create, read, update, delete) operations and queries on Deta Base. The library provides a simple example showing how to do that.
In the Arduino IDE, make sure you have an ESP32 board selected in <k>Tools </k>> <k>Board</k>. Then, go to <k>File </k>> <k>Examples </k>> <k>detabaseAduinoESP32 </k>and select the <k>detaLibTest </k>example.
The following code should load.
<k># Original Source: https://github.com/A223D/detaBaseArduinoESP32/blob/main/examples/detaLibTest/detaLibTest.ino
#include &lt;detaBaseArduinoESP32.h>
#include &lt;WiFiClientSecure.h>
#define LED 2
char* apiKey = "MY_KEY";
char* detaID = "MY_ID";
char* detaBaseName = "MY_BASE";
WiFiClientSecure client;
DetaBaseObject detaObj(client, detaID, detaBaseName, apiKey, true);
void setup() {
  Serial.begin(115200);
  Serial.println("Let's begin initialization");
  pinMode(LED, OUTPUT);
  digitalWrite(LED, LOW);
  Serial.println("Reached before WiFi init");
  WiFi.begin("0xCAFE", "0xC0FFEE");
  Serial.println("Waiting to connect to WiFi");
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println();
  digitalWrite(LED, HIGH);
}
// PUT "{\"items\":[{\"age\":4}]}"
//INSERT "{\"item\":{\"key\":\"cba\",\"age\":4}}"
//INSERT "{\"item\":{\"key\":\"abc\",\"age\":4}}"
//UPDATE "{\"increment\":{\"age\":1}}", key:abc
//UPDATE "{\"increment\":{\"age\":1}}", key:cba
//QUERY "{\"query\":[{\"age?lt\": 10}]}"
void loop() {
  printResult(detaObj.putObject("{\"items\":[{\"age\":4}]}"));
  Serial.println();
  printResult(detaObj.getObject("cba"));
  Serial.println();
  printResult(detaObj.deleteObject("abc"));
  Serial.println();
  printResult(detaObj.insertObject("{\"item\":{\"key\":\"cba\",\"age\":4}}"));
  Serial.println();
  printResult(detaObj.insertObject("{\"item\":{\"key\":\"abc\",\"age\":4}}"));
  Serial.println();
  printResult(detaObj.updateObject("{\"increment\":{\"age\":1}}", "abc"));
  Serial.println();
  printResult(detaObj.updateObject("{\"increment\":{\"age\":1}}", "bcs"));
  Serial.println();
  printResult(detaObj.query("{\"query\":[{\"age?lt\": 10}]}"));
  Serial.println();
  while (true);
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/detaLibTest.ino" target="_blank">View raw code</a>
You need to insert your project API KEY and ID. You also need to inserte a name for the databaseit can be whatever you want. I called it Test.
<k>char* apiKey = "REPLACE_WITH_YOUR_PROJECT_API_KEY";
char* detaID = "REPLACE_WITH_YOUR_PROJECT_ID";
char* detaBaseName = "Test";</k>
In the setup(), you need to include your network credentials, SSID and password so that your ESP32 can connect to the internet.
<k>WiFi.begin(WIFI_SSID, WIFI_PASSWORD);</k>
You can upload the code now and it will work straight away. We recommend reading through the following section to understand how things actually work.
<h3>How it Works</h3>
Read this section to learn how to interact with Deta Base using the ESP32.
<h3>Include Libraries</h3>
First, include the detaBaseArduinoESP32 library. You also need to include the WiFiClientSecure librarythis automatically includes the WiFi.h library, also needed in this example.
<k>#include &lt;detaBaseArduinoESP32.h>
#include &lt;WiFiClientSecure.h></k>
<h3>Deta Base Key, ID, and Name</h3>
Insert the project key, ID, and a name for the Base. As mentioned previously, if not created yet, the library will automatically create a Base instance for you on Deta Base. The name for the database can be whatever best describes it. In this case, I called it Test. If you've already created a Base instance manually on Deta Base, you can use it's name here.
<k>char* apiKey = "REPLACE_WITH_YOUR_PROJECT_API_KEY";
char* detaID = "REPLACE_WITH_YOUR_PROJECT_ID";
char* detaBaseName = "Test";</k>
<h3>Creating a DetaBaseObject</h3>
Then, you need to create a WiFiClientSecure and a DetaBaseObject objects. The DetaBaseObject accepts as arguments the WiFi client, the project ID, base name, API key, lastly a boolean variable. This last boolean variable when set to true enables debugging statement.
<k>WiFiClientSecure client;
//choose this:
DetaBaseObject detaObj(client, detaID, detaBaseName, apiKey, true);
//or this:
//DetaBaseObject detaObj(client, detaID, detaBaseName, apiKey);</k>
The client is passed to the DetaBaseObject as is, without any modification. This is done because a root CA certificate is set in the DetaBaseObject constructor. This is required since we are making requests over HTTPS.
<h3>setup()</h3>
In the setup(), connect the ESP32 to Wi-Fi using your Wi-Fi credentials: SSID and password.
<k>void setup() {
  Serial.begin(115200);
  Serial.println("Let's begin initialization");
  pinMode(LED, OUTPUT);
  digitalWrite(LED, LOW);
  Serial.println("Reached before WiFi init");
<k>  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
</k>  Serial.println("Waiting to connect to WiFi");
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println();
  digitalWrite(LED, HIGH);
}</k>
<h3>Insert</h3>
To insert items into the database, you can use the putObject() function. As described in the <a href="https://docs.deta.sh/docs/base/http/#put-items" target="_blank">Deta Base documentation</a>, a put operation expects a JSON object in the following format:
<k>{
  // array of items to put
  "items": [
    {
      "key": {key}, // optional, a random key is generated if not provided
      "field1": "value1",
      // rest of item
    },
    // rest of items
  ]
}</k>
The key is optional, and will be assigned by Deta Base if not provided. If a key is provided, and an entry already exists with that key, it is overwritten. 
The following line of code:
<k>printResult(detaObj.putObject("{\"items\":[{\"age\":4}]}"));</k>
That contains the following JSON:
<k>{
  "items":[
    {
      "age":"4"
    }
  ]
}</k>
Adds the following to the database:
<k>{
  "age": 4
}</k>
A backslash character (\) is added before each  to indicate an escape character, since we require  in the JSON input. 
<k>Note: </k> <k>Keys have to be strings</k>. If you want to use a number as a key, make sure it is interpreted as a string by enclosing it in double-quotes. (Double quotes with back-slashes.)
With PUT you can insert multiple items in a single request. For example:
<k>printResult(detaObj.putObject("{\"items\":[{\"age\":4,\"weight\":28}]}"));</k>
If the request succeeds, we will see a 200-level status code in the Serial monitor, as well as the entire object(s) with its key(s).
If you go to your Deta Base project, you should see a new base instance and the item we've just inserted.
<h3>Retrieve an Object</h3>
You can retrieve an object by its key using the getObject() function. The function expects a key as argument. It can be an existing key or a non-existing key.
The following line of code tries to retrieve an object with cba key. 
<k>printResult(detaObj.getObject("cba"));</k>
You should get an error message because there isn't any object with that key on the database yet.
However, if you manually create an object with the cba key and run the code again, it will retrieve the object with success.
To create an object manually, you can click on the <k>+Add </k>button on the deta base interface. It will automatically create a new item with a predefined key. You can change it to cba.
<h3>Delete</h3>
To delete an object on the database, use the deleteObject() function. This function accepts as an argument the key of the object we want to delete. The output of this function returns a 200-level code that indicates success even though there's no object with that key. In our case, it tries to delete an object with the abc key. 
<k>printResult(detaObj.deleteObject("abc"));</k>
However, if there was an object with the abc key it would be deleted.
<h3>Insert</h3>
To insert a new item in the database, you can use the insertObject() function that will make a <a href="https://docs.deta.sh/docs/base/http/#insert-item" target="_blank">POST request</a>. This will create a new item only if no item with the same key exists. It expects a JSON in the following format:
<k>{
  "item": {
    "key": {key}, // optional
    // rest of item
  }
}</k>
If you don't provide a key, Deta Base will automatically do that for you.
In the example, the following line:
<k>printResult(detaObj.insertObject("{\"item\":{\"key\":\"cba\",\"age\":4}}"));</k>
Adds the following object to the database:
<k>{
  "key": "cba",
  "age": 4
}</k>
If you're already have an object with that key you'll get a 400-level code and an error in the payload message.
<h3>Update</h3>
The updateObject() method updates existing entries. It accepts as arguments the key for an existing objkect and a JSON object in the following format:
<k>{
  "set"  :  {
    //set some attribute to some value like
    //age: 10
  },
  "increment"  :{
    //increment some attribute by some value like
    //age: 1
  },
  "append":  {
    //append some value to some list attribute like
    //names: ["John"]
  },
  "prepend": {
    //append some value to some list attribute like
    //names: ["Sam"]
  },
  "delete":  [//attributes to be deleted]
}</k>
All of those JSON sub-objects (set, increment, append, prepend, and delete) are optional.
You can learn more about this type of request on the <a href="https://docs.deta.sh/docs/base/http/#update-item" target="_blank">documentation</a>.
In our example, the following line will increment the age by 1 in the entry with the abc key.
<k> printResult(detaObj.updateObject("{\"increment\":{\"age\":1}}", "abc"));</k>
<h3>Query Data</h3>
Deta Base also supports queries for fetching data that match certain conditions. You can learn more about Deta Base Queries on the following link:
<a href="https://docs.deta.sh/docs/base/queries/" target="_blank">Deta Base Queries Documentation</a>
To make a query you can use the query() function that accepts as argument the query itself in JSON format (see the link to the documentation above).
The following query will return all the objects whose value of age is less than 10, which in our case corresponds to all objects in the database.
<k>printResult(detaObj.query("{\"query\":[{\"age?lt\": 10}]}"));</k>
<h3>Demonstration</h3>
After running the example, you should get the following on the Serial Monitor.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/ESP32-with-deta-base-demonstration-serial-monitor-1.png">
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/ESP32-with-deta-base-demonstration-serial-monitor-2.png">
And your database should look as follows.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/deta-base-demonstration.png">
<h3>Wrapping Up</h3>
In this tutorial, you learned how to interact with Deta Base using the ESP32. Deta Base is a NoSQL database, it's free and unlimited. This means you won't have to pay anything to use it, and you can add as many entries as needed. The database requires minimal setup and you can use it right away. Thanks to the <a href="https://github.com/A223D/detaBaseArduinoESP32" target="_blank">detaBaseArduinoESP32 library</a>, it's even easier to make HTTP requests to the database and handle the responses.
In this example, you learned how to insert sample values. You can easily modify the examples to save sensor readings, for example, or GPIO states. 
The present tutorial was based on the <a href="https://github.com/A223D/ESP32DetaGuides" target="_blank">tutorial created by Kushagra Goel</a>.
We hope you found this article useful.
We have guides for other popular databases with the ESP32:
<a href="https://randomnerdtutorials.com/esp32-firebase-realtime-database/">ESP32: Getting Started with <k>Firebase (Realtime Database)</k></a>
<a href="https://randomnerdtutorials.com/esp32-influxdb/">ESP32: Getting Started with <k>InfluxDB</k></a> <k>(Time Series Database)</k>
<a href="https://randomnerdtutorials.com/esp32-esp8266-mysql-database-php/">ESP32/ESP8266 Insert Data into <k>MySQL Database</k> using PHP and Arduino IDE</a>
<h2>SPI Communication: Set Pins, Multiple SPI Bus Interfaces, and Peripherals (Arduino IDE)</h2>
This is a simple guide about SPI communication protocol with the ESP32 using Arduino IDE. We'll take a look at the ESP32 SPI pins, how to connect SPI devices, define custom SPI pins, how to use multiple SPI devices, and much more.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/ESP32-SPI-Communication-protocol.jpg">
<k>Table of Contents:</k>
Introducing ESP32 SPI Communication Protocol
ESP32 SPI Peripherals
ESP32 SPI Pins
Using Custom ESP32 SPI Pins
ESP32 with Multiple SPI Devices
Multiple SPI Devices (same bus, different CS pin)
Using Two SPI Bus Interfaces (use HSPI and VSPI simultaneously)
This tutorial focus on programming the ESP32 using the Arduino core, so before proceeding, you should have the ESP32 add-on installed in your Arduino IDE. Follow the next tutorial to install the ESP32 on the Arduino IDE, if you haven't already.
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing the ESP32 Board in Arduino IDE (Windows, Mac OS X, and Linux instructions)</a>
Alternatively, you can also use VS Code with the PlatformIO extension to program your boards using the Arduino core:
<a href="https://randomnerdtutorials.com/vs-code-platformio-ide-esp32-esp8266-arduino/">Getting Started with VS Code and PlatformIO IDE for ESP32 and ESP8266 (Windows, Mac OS X, Linux Ubuntu)</a>
<h3>Introducing ESP32 SPI Communication Protocol</h3>
SPI stands for <k>S</k>erial <k>P</k>eripheral <k>I</k>nterface, and it is a synchronous serial data protocol used by microcontrollers to communicate with one or more peripherals. For example, your ESP32 board communicating with a sensor that supports SPI or with another microcontroller.
In an SPI communication, there is always a <k>controller </k>(also called <em>master</em>) that controls the <k>peripheral </k>devices (also called <em>slaves</em>). Data can be sent and received simultaneously. This means that the master can send data to a slave, and a slave can send data to the master at the same time.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/SPI-communication.png">
You can have <em>only one master</em>, which will be a microcontroller (the ESP32), but you can have multiple slaves. A slave can be a sensor, a display, a microSD card, etc., or another microcontroller. This means you can have an ESP32 connected to multiple sensors, but the same sensor can't be connected to multiple ESP32 boards simultaneously.
<h3>SPI Interface</h3>
For SPI communication you need four lines:
<k>MISO</k>: Master In Slave Out
<k>MOSI</k>: Master Out Slave In
<k>SCK</k>: Serial Clock
<k>CS </k>/<k>SS</k>: Chip Select (used to select the device when multiple peripherals are used on the same SPI bus)
On a slave-only device, like sensors, displays, and others, you may find a different terminology:
<k>MISO </k>may be labeled as <k>SDO</k> (Serial Data Out)
<k>MOSI </k>may be labeled as <k>SDI</k> (Serial Data In)
<h3>ESP32 SPI Peripherals</h3>
The ESP32 integrates 4 SPI peripherals: SPI0, SPI1, SPI2 (commonly referred to as <k>HSPI</k>), and SPI3 (commonly referred to as <k>VSPI</k>). 
SP0 and SP1 are used internally to communicate with the built-in flash memory, and you should not use them for other tasks.
You can use <k>HSPI </k>and <k>VSPI </k>to communicate with other devices. HSPI and VSPI have independent bus signals, and each bus can drive up to three SPI slaves.
<h3>ESP32 Default SPI Pins</h3>
Many ESP32 boards come with default SPI pins pre-assigned. The pin mapping for most boards is as follows:
<table><tbody>
<tr>
<td><k>SPI</k></td>
<td><k>MOSI</k></td>
<td><k>MISO</k></td>
<td><k>SCLK</k></td>
<td><k>CS</k></td>
</tr>
<tr>
<td><k>VSPI</k></td>
<td>GPIO 23</td>
<td>GPIO 19</td>
<td>GPIO 18</td>
<td>GPIO 5</td>
</tr>
<tr>
<td><k>HSPI</k></td>
<td>GPIO 13</td>
<td>GPIO 12</td>
<td>GPIO 14</td>
<td>GPIO 15</td>
</tr>
</tbody></table><k>Warning: </k> depending on the board you're using, the default SPI pins might be different. So, make sure you check the pinout for the board you're using. Additionally, some boards don't have pre-assigned SPI pins, so you need to set them on code.
<k>Note: </k> usually, when not specified, the board will use the VSPI pins when initializing an SPI communication with the default settings.
Whether your board comes with pre-assigned pins or not, you can always set them on code.
<h3>Finding your ESP32 Board's Default SPI Pins</h3>
If you're not sure about your board's default SPI pins, you can upload the following code to find out.
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-spi-communication-arduino/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
//Find the default SPI pins for your board
//Make sure you have the right board selected in Tools > Boards
void setup() {
  // put your setup code here, to run once:
  Serial.begin(115200);
  Serial.print("MOSI: ");
  Serial.println(MOSI);
  Serial.print("MISO: ");
  Serial.println(MISO);
  Serial.print("SCK: ");
  Serial.println(SCK);
  Serial.print("SS: ");
  Serial.println(SS);  
}
void loop() {
  // put your main code here, to run repeatedly:
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/SPI/ESP32_Find_SPI_Pins.ino" target="_blank">View raw code</a>
<k>Important: </k> make sure you select the board you're using in <k>Tools </k>> <k>Board</k>, otherwise, you may not get the right pins.
After uploading the code, open the Serial Monitor, RST your board and you'll see the SPI pins.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/ESP32-Default-SPI-Pins-Serial-Monitor.jpg">
<h3>Using Custom ESP32 SPI Pins</h3>
When using libraries to interface with your SPI peripherals, it's usually simple to use custom SPI pins because you can pass them as arguments to the library constructor.
For example, take a quick look at the following example that interfaces with a <a href="https://randomnerdtutorials.com/esp32-bme280-arduino-ide-pressure-temperature-humidity/">BME280 sensor</a> using the Adafruit_BME280 library.
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-spi-communication-arduino/
  Based on the Adafruit_BME280_Library example: https://github.com/adafruit/Adafruit_BME280_Library/blob/master/examples/bme280test/bme280test.ino
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
#include &lt;Wire.h>
#include &lt;Adafruit_Sensor.h>
#include &lt;Adafruit_BME280.h>
#include &lt;SPI.h>
#define BME_SCK 25
#define BME_MISO 32
#define BME_MOSI 26
#define BME_CS 33
#define SEALEVELPRESSURE_HPA (1013.25)
//Adafruit_BME280 bme; // I2C
//Adafruit_BME280 bme(BME_CS); // hardware SPI
Adafruit_BME280 bme(BME_CS, BME_MOSI, BME_MISO, BME_SCK); // software SPI
unsigned long delayTime;
void setup() {
  Serial.begin(9600);
  Serial.println(F("BME280 test"));
  bool status;
  // default settings
  // (you can also pass in a Wire library object like &Wire2)
  status = bme.begin();  
  if (!status) {
    Serial.println("Could not find a valid BME280 sensor, check wiring!");
    while (1);
  }
  Serial.println("-- Default Test --");
  delayTime = 1000;
  Serial.println();
}
void loop() { 
  printValues();
  delay(delayTime);
}
void printValues() {
  Serial.print("Temperature = ");
  Serial.print(bme.readTemperature());
  Serial.println(" *C");
  
  // Convert temperature to Fahrenheit
  /*Serial.print("Temperature = ");
  Serial.print(1.8 * bme.readTemperature() + 32);
  Serial.println(" *F");*/
  
  Serial.print("Pressure = ");
  Serial.print(bme.readPressure() / 100.0F);
  Serial.println(" hPa");
  Serial.print("Approx. Altitude = ");
  Serial.print(bme.readAltitude(SEALEVELPRESSURE_HPA));
  Serial.println(" m");
  Serial.print("Humidity = ");
  Serial.print(bme.readHumidity());
  Serial.println(" %");
  Serial.println();
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/SPI/ESP32_BME280_Custom_SPI_Pins.ino" target="_blank">View raw code</a>
You can easily pass your custom SPI pins to the library constructor.
<k>Adafruit_BME280 bme(BME_CS, BME_MOSI, BME_MISO, BME_SCK);</k>
In that case, I was using the following SPI pins (not default) and everything worked as expected:
<k>#define BME_SCK 25
#define BME_MISO 32
#define BME_MOSI 26
#define BME_CS 33</k>
If you're not using a library, or the library you're using doesn't accept the pins in the library constructor, you may need to initialize the SPI bus yourself. In that case, you would need to call the SPI.begin() method on the setup() and pass the SPI pins as arguments:
<k>SPI.begin(SCK, MISO, MOSI, SS);</k>
You can see an example of this scenario <a href="https://randomnerdtutorials.com/ttgo-lora32-sx1276-arduino-ide/">in this tutorial</a>, in which we initialize an SPI LoRa transceiver that is connected to custom SPI pins. <a href="https://randomnerdtutorials.com/esp32-microsd-card-arduino/#sdcardcustompins">Or this example</a> showing how to <a href="https://randomnerdtutorials.com/esp32-microsd-card-arduino/#sdcardcustompins">use custom SPI pins with a microSD card module</a>.
<h3>ESP32 with Multiple SPI Devices</h3>
As we've seen previously, you can use two different SPI buses on the ESP32 and each bus can connect up to three different peripherals. This means that we can connect up to six SPI devices to the ESP32. If you need to use more, you can use an SPI multiplexer.
<h3>Multiple SPI Devices (same bus, different CS pin)</h3>
To connect multiple SPI devices, you can use the same SPI bus as long as each peripheral uses a different CS pin.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/ESP32-SPI-communication-multiple-peripherals-same-bus.png">
To select the peripheral you want to communicate with, you should set its CS pin to LOW. For example, imagine you have peripheral 1 and peripheral 2. To read from peripheral 1, make sure its CS pin is set to LOW (here represented as CS_1):
<k>digitalWrite(CS_1, LOW); // enable CS pin to read from peripheral 1
/*
 use any SPI functions to communicate with peripheral 1
*/</k>
Then, at same point, you'll want to read from peripheral 2. You should disable peripheral 1 CS pin by setting it to HIGH, and enable peripheral 2 CS pin by setting it to LOW:
<k>digitalWrite(CS_1, HIGH); // disable CS pin from peripheral 1
digitalWrite(CS_2, LOW);  // enable CS pin to read from peripheral 2
/*
 use any SPI functions to communicate with peripheral 2
*/</k>
<h3>ESP32 Using Two SPI Bus Interfaces (Use HSPI and VSPI simultaneously)</h3>
To communicate with multiple SPI peripherals simultaneously, you can use the ESP32 two SPI buses (HSPI and VSPI). You can use the default HSPI and VSPI pins or use custom pins.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/08/ESP32-SPI-communication-multiple-bus-interfaces.png">
Briefly, to use HSPI and VSPI simultaneously, you just need to.
<k>1)</k> First, make sure you include the SPI library in your code.
<k>#include &lt;SPI.h></k>
<k>2)</k> Initialize two SPIClass objects with different names, one on the HSPI bus and another on the VSPI bus. For example:
<k>vspi = new SPIClass(VSPI);
hspi = new SPIClass(HSPI);</k>
<k>3)</k> Call the begin() method on those objects.
<k>vspi.begin();
hspi.begin();</k>
You can pass custom pins to the begin() method if needed.
<k>vspi.begin(VSPI_CLK, VSPI_MISO, VSPI_MOSI, VSPI_SS);
hspi.begin(HSPI_CLK, HSPI_MISO, HSPI_MOSI, HSPI_SS);</k>
<k>4)</k> Finally, you also need to set the SS pins as outputs. For example:
<k>pinMode(VSPI_SS, OUTPUT);
pinMode(HSPI_SS, OUTPUT);</k>
Then, use the usual commands to interact with the SPI devices, whether you're using a sensor library or the SPI library methods.
You can find an example of how to use multiple SPI buses on the <a href="https://github.com/espressif/arduino-esp32/blob/master/libraries/SPI/examples/SPI_Multiple_Buses/SPI_Multiple_Buses.ino" target="_blank">arduino-esp32 SPI library</a>. See the example below:
<k>
/* The ESP32 has four SPi buses, however as of right now only two of
 * them are available to use, HSPI and VSPI. Simply using the SPI API 
 * as illustrated in Arduino examples will use VSPI, leaving HSPI unused.
 * 
 * However if we simply intialise two instance of the SPI class for both
 * of these buses both can be used. However when just using these the Arduino
 * way only will actually be outputting at a time.
 * 
 * Logic analyser capture is in the same folder as this example as
 * "multiple_bus_output.png"
 * 
 * created 30/04/2018 by Alistair Symonds
 */
#include &lt;SPI.h>
// Define ALTERNATE_PINS to use non-standard GPIO pins for SPI bus
#ifdef ALTERNATE_PINS
  #define VSPI_MISO   2
  #define VSPI_MOSI   4
  #define VSPI_SCLK   0
  #define VSPI_SS     33
  #define HSPI_MISO   26
  #define HSPI_MOSI   27
  #define HSPI_SCLK   25
  #define HSPI_SS     32
#else
  #define VSPI_MISO   MISO
  #define VSPI_MOSI   MOSI
  #define VSPI_SCLK   SCK
  #define VSPI_SS     SS
  #define HSPI_MISO   12
  #define HSPI_MOSI   13
  #define HSPI_SCLK   14
  #define HSPI_SS     15
#endif
#if CONFIG_IDF_TARGET_ESP32S2 || CONFIG_IDF_TARGET_ESP32S3
#define VSPI FSPI
#endif
static const int spiClk = 1000000; // 1 MHz
//uninitalised pointers to SPI objects
SPIClass * vspi = NULL;
SPIClass * hspi = NULL;
void setup() {
  //initialise two instances of the SPIClass attached to VSPI and HSPI respectively
  vspi = new SPIClass(VSPI);
  hspi = new SPIClass(HSPI);
  
  //clock miso mosi ss
#ifndef ALTERNATE_PINS
  //initialise vspi with default pins
  //SCLK = 18, MISO = 19, MOSI = 23, SS = 5
  vspi->begin();
#else
  //alternatively route through GPIO pins of your choice
  vspi->begin(VSPI_SCLK, VSPI_MISO, VSPI_MOSI, VSPI_SS); //SCLK, MISO, MOSI, SS
#endif
#ifndef ALTERNATE_PINS
  //initialise hspi with default pins
  //SCLK = 14, MISO = 12, MOSI = 13, SS = 15
  hspi->begin();
#else
  //alternatively route through GPIO pins
  hspi->begin(HSPI_SCLK, HSPI_MISO, HSPI_MOSI, HSPI_SS); //SCLK, MISO, MOSI, SS
#endif
  //set up slave select pins as outputs as the Arduino API
  //doesn't handle automatically pulling SS low
  pinMode(vspi->pinSS(), OUTPUT); //VSPI SS
  pinMode(hspi->pinSS(), OUTPUT); //HSPI SS
}
// the loop function runs over and over again until power down or reset
void loop() {
  //use the SPI buses
  spiCommand(vspi, 0b01010101); // junk data to illustrate usage
  spiCommand(hspi, 0b11001100);
  delay(100);
}
void spiCommand(SPIClass *spi, byte data) {
  //use it as you would the regular arduino SPI API
  spi->beginTransaction(SPISettings(spiClk, MSBFIRST, SPI_MODE0));
  digitalWrite(spi->pinSS(), LOW); //pull SS slow to prep other end for transfer
  spi->transfer(data);
  digitalWrite(spi->pinSS(), HIGH); //pull ss high to signify end of data transfer
  spi->endTransaction();
}
</k>
<a href="https://github.com/espressif/arduino-esp32/raw/master/libraries/SPI/examples/SPI_Multiple_Buses/SPI_Multiple_Buses.ino" target="_blank">View raw code</a>
<h3>Wrapping Up</h3>
This article was a quick and simple guide showing you how to use SPI communication with the ESP32 using the Arduino corewith the ESP32 acting as a controller (<em>master</em>).
In summary, the ESP32 has four SPI buses, but only two can be used to control peripherals, the HSPI and VSPI. Most ESP32 have pre-assigned HSPI and VSPI GPIOs, but you can always change the pin assignment in the code.
You can use the HSPI and VSPI buses simultaneously to drive multiple SPI peripherals, or you can use multiple peripherals on the same bus as long as their CS pin is connected to a different GPIO.
We didn't dive deeply into examples, because each sensor, library, and case scenario is different. But, now you should have a better idea of how to interface one or multiple SPI devices with the ESP32.
For more detailed information about the SPI Master driver on the ESP32, you can <a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/peripherals/spi_master.html" target="_blank">check the espressif official documentation</a>.
We didn't cover setting the ESP32 as an SPI slave, but you can <a href="https://github.com/hideakitai/ESP32SPISlave" target="_blank">check these examples</a>.
We hope you find this tutorial useful. We have a similar article, but about I2C communication protocol. Check it out on the following link:
<a href="https://randomnerdtutorials.com/esp32-i2c-communication-arduino-ide/">ESP32 I2C Communication: Set Pins, Multiple Bus Interfaces and Peripherals (Arduino IDE)</a>
<h2>Control ESP32/ESP8266 GPIOs from Anywhere (Firebase Web App)</h2>
In this guide, you'll create a Firebase Web App to control the ESP32 or ESP8266 GPIOs from anywhere. The access to the web app is protected with authentication using email and password. The GPIO states are saved on the Firebase Realtime Database. The web app writes to the database to change the GPIO states and the ESP boards are listening for database changes to update the GPIO states accordingly.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/ESP-Control-GPIOs-from-Anywhere-Firebase.jpg">
This article is Part 2 of a previous tutorial. You need to complete one of the following tutorials before proceeding:
<a href="https://randomnerdtutorials.com/firebase-control-esp32-gpios/">Control ESP32 GPIOs from Anywhere using Firebase</a>
<a href="https://randomnerdtutorials.com/firebase-control-esp8266-nodemcu-gpios/">Control ESP8266 NodeMCU GPIOs from Anywhere using Firebase</a>
<h3>Project Overview</h3>
In this tutorial (Part 2), you'll create a web app to control the ESP32 or ESP8266 GPIOs from anywhere. In a previous tutorial, you learned how to set the ESP32 or ESP8266 to listen to database changes and update its GPIOs accordingly. You changed the GPIO states manually on the Realtime Database using the Firebase console. Now, you'll create your own web app, hosted on Firebase, to control your boards from anywhere.
The following diagram shows a high-level overview of the project we'll buildprogramming the ESP32/ESP8266 and setting up the Firebase Project was done in Part 1:
<a href="https://randomnerdtutorials.com/firebase-control-esp32-gpios/">Part 1ESP32</a>
<a href="https://randomnerdtutorials.com/firebase-control-esp8266-nodemcu-gpios/">Part 1ESP8266</a>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/Firebase-Control-Outputs-from-anywhere-web-app-project-overview-03.png">
Firebase hosts your web app over a global CDN using Firebase Hosting and provides an SSL certificate. You can access your web app from anywhere using the Firebase-generated domain name.
When you first access the web app, you need to authenticate with an authorized email address and password. You already set up that user and the authentication method in Part 1.
After authentication, you can access a web app page that shows several buttons to change the GPIO states on the database.
The ESP32 or ESP8266 is listening to database changes. When you click on the buttons, the GPIO states change on the database, and the ESP updates the states accordingly.
The web app also shows what's the current state of the GPIOs.
As an example, we'll control three GPIOs (12, 13, and 14). As mentioned in the previous tutorial, you can add/remove more GPIOs and boards or control other GPIOs.
Once you're logged in, you can logout any time. The next time you'll access the app you'll need to login again.
The following screenshot shows what the web page looks like on a computer web browser.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/Control-from-Anywhere-Firebase-App-small.png">
<h3>Prerequisites</h3>
Before start creating the Firebase Web App, you need to check the following prerequisites.
<h3>Creating a Firebase Project</h3>
You should have followed the one the following tutorials first:
<a href="https://randomnerdtutorials.com/firebase-control-esp32-gpios/">Control ESP32 GPIOs from Anywhere using Firebase</a>
<a href="https://randomnerdtutorials.com/firebase-control-esp8266-nodemcu-gpios/">Control ESP8266 NodeMCU GPIOs from Anywhere using Firebase</a>
The ESP32/ESP8266 must be running the code provided in that tutorial. The realtime database and authentication must be set up also as shown in the tutorial.
<h3>Install Required Software</h3>
Before getting started you need to install the required software to create the Firebase Web App. Here's a list of the software you need to install (click on the links for instructions):
<a href="https://randomnerdtutorials.com/esp32-firebase-web-app/#install-vs-code">Visual Studio Code</a>
<a href="https://randomnerdtutorials.com/esp32-firebase-web-app/#install-nodejs">Node.JS LTS version</a>
<a href="https://randomnerdtutorials.com/esp32-firebase-web-app/#install-firebase-tools">Install Firebase Tools</a>
<hr>
<h3>1) Add an App to Your Firebase Project</h3>
<k>1)</k> Go to your Firebase project Console and add an app to your project by clicking on the <k>+Add app </k>button. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/Firebase-Add-App-to-Project.png">
<k>2)</k> Select the web app icon.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/Firebase-Add-Web-App-to-Project.png">
<k>3)</k> Give your app a name. Then, check the box next to <k> Also set up Firebase Hosting for this App</k>. Click <k>Register app</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/add-firebase-to-web-app-example.png">
<k>4)</k> Then, copy the firebaseConfig object and save it because you'll need it later.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/app-firebase-config-object.png">
After this, you can also access the firebaseConfig object if you go to your Project settings in your Firebase console.
<k>5)</k> Click <k>Next</k> on the proceeding steps, and finally on <k>Continue to console</k>.
<hr>
<h3>2) Setting Up a Firebase Web App Project (VS Code)</h3>
Follow the next steps to create a Firebase Web App Project using VS Code.
<h3>1) Creating a Project Folder</h3>
<k>1)</k> Create a folder on your computer where you want to save your Firebase projectfor example, <em>Firebase-Project</em> on the Desktop.
<k>2)</k> Open VS Code. Go to <k>File</k> > <k>Open Folder</k> and select the folder you've just created.
<k>3)</k> Go to <k>Terminal </k>> <k>New Terminal</k>. A new Terminal window should open on your project path.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/Terminal-Window-Firebase-Folder-Project.png">
<h3>2) Firebase Login</h3>
<k>4)</k> On the previous Terminal window, type the following:
<k><k>firebase </k>login</k>
<k>5)</k> You'll be asked to collect CLI usage and error reporting information. Enter <k>n</k> and press <k>Enter</k> to deny.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/Terminal-Window-Login-Firebase-VS-Code.png">
<k>Note:</k> If you are already logged in, it will show a message saying: Already logged in as <a href="/cdn-cgi/l/email-protection" data-cfemail="8bfef8eef9cbece6eae2e7a5e8e4e6">[email protected]</a>.
<k>6)</k> After this, it will pop up a new window on your browser to login into your firebase account.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/Login-Firebase-Account.png">
<k>7)</k> Allow Firebase CLI to access your google account.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/Login-Firebase-Account-2.png">
<k>8)</k> After this, Firebase CLI login should be successful. You can close the browser window.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/Firebase-CLI-Login-Successful.png">
<h3>3) Initializing Web App Firebase Project</h3>
<k>9)</k> After successfully login in, run the following command to start a Firebase project directory in the current folder.
<k><k>firebase </k>init</k>
<k>10)</k> You'll be asked if you want to initialize a Firebase project in the current directory. Enter <k>Y</k> and hit <k>Enter</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/Firebase-Start-Project-VS-Code.png">
<k>11)</k> Then, use up and down arrows and the Space key to select the options. Select the following options:
<k>Realtime Database</k>: Configure security rules file for Realtime Database and (optionally) provision default instance.  
<k>Hosting</k>: Configure files for Firebase Hosting and (optionally) set up GitHub Action deploys
The selected options will show up with a green asterisk. Then, hit <k>Enter</k>. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/realtime-database-hosting-options.png">
<k>12)</k> Select the option Use an existing projectit should be highlighted in bluethen, hit Enter.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/Firebase-Project-Setup-VS-Code.png">
<k>13)</k> After that, select the Firebase project for this directoryit should be <k>the project created in Part 1</k>. In my case, it is called <em>esp-firebase-demo</em>. Then hit <k>Enter</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/add-firebase-project-VS-Code.png">
<k>14)</k> Press <k>Enter </k>on the following question to select the default database security rules file: <k>What file should be used for Realtime Database Security Rules?</k>
<k>15)</k> Then, select the hosting options as shown below:
What do you want to use as your public directory? Hit <k>Enter </k>to select <k>public</k>.
Configure as a single-page app (rewrite urls to /index.html)? <k>No</k>
Set up automatic builds and deploys with GitHub? <k>No</k>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/firebase-hosting-setup-all-options.png">
<k>16)</k> The Firebase project should now be initialized successfully. Notice that VS code created some essential files under your project folder.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/firebase-project-app-created-successfully.png">
The index.html file contains some HTML text to build a web page. For now, leave the default HTML text. The idea is to replace that with your own HTML text to build a custom web page for your needs. We'll do that later in this tutorial.
<k>17)</k> To check if everything went as expected, run the following command on the VS Code Terminal window.
<k><k>firebase </k>deploy</k>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/firebase-first-deploy-test-app.png">
You should get a <k>Deploy complete!</k> message and an URL to the Project Console and the Hosting URL.
<k>18)</k> Copy the hosting URL and paste it into a web browser window. You should see the following web page. You can access that web page from anywhere in the world.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/firebase-hosting-complete.png">
The web page you've seen previously is built with the HTML file placed in the public folder of your Firebase project. By changing the content of that file, you can create your own web app. That's what we're going to do in the next section.
<hr>
<h3>3) Creating Firebase Web App</h3>
Now that you've created a Firebase project app successfully on VS Code, follow the next steps to customize the app to display the sensor readings on a login-protected web page.
<h3>index.html</h3>
Copy the following to your index.html file. This HTML file creates a simple web page with ON and OFF buttons to control GPIOs 12, 13, and 14.
If you aren't authenticated, it shows a login form. When you authenticate with an authorized user email and corresponding password, it shows the user interface with the buttons.
<k>&lt;!DOCTYPE html>
&lt;!-- Complete Project Details at: https://RandomNerdTutorials.com/ -->
&lt;html>
  &lt;head>
    &lt;meta charset="utf-8">
    &lt;meta name="viewport" content="width=device-width, initial-scale=1">
    &lt;title>ESP IoT Firebase App&lt;/title>
    &lt;!-- update the version number as needed -->
    &lt;script src="https://www.gstatic.com/firebasejs/8.8.1/firebase-app.js">&lt;/script>
    &lt;!-- include only the Firebase features as you need -->
    &lt;script src="https://www.gstatic.com/firebasejs/8.8.1/firebase-auth.js">&lt;/script>
    &lt;script src="https://www.gstatic.com/firebasejs/8.8.1/firebase-database.js">&lt;/script>
    &lt;script>
      // REPLACE WITH YOUR web app's Firebase configuration
      const firebaseConfig = {
        apiKey: "",
        authDomain: "",
        databaseURL: "",
        projectId: "",
        storageBucket: "",
        messagingSenderId: "",
        appId: ""
      };
      // Initialize firebase
      firebase.initializeApp(firebaseConfig);
      // Make auth and database references
      const auth = firebase.auth();
      const db = firebase.database();
    &lt;/script>
    &lt;link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
    &lt;link rel="icon" type="image/png" href="favicon.png">
    &lt;link rel="stylesheet" type="text/css" href="style.css">
&lt;/head>
&lt;body>
  &lt;!--TOP BAR-->
  &lt;div>
    &lt;h1>ESP GPIO Control &lt;i>&lt;/i>&lt;/h2>
  &lt;/div>
  &lt;!--AUTHENTICATION BAR (USER DETAILS/LOGOUT BUTTON)-->
  &lt;div style="display: none;">
    &lt;p>&lt;span>User logged in&lt;/span>
       &lt;span>USEREMAIL&lt;/span>
       &lt;a href="/">(logout)&lt;/a>
    &lt;/p>
  &lt;/div>
  &lt;!--LOGIN FORM-->
  &lt;form style="display: none;">
    &lt;div>
      &lt;label for="input-email">&lt;b>Email&lt;/b>&lt;/label>
      &lt;input type="text" placeholder="Enter Username" required>
      &lt;label for="input-password">&lt;b>Password&lt;/b>&lt;/label>
      &lt;input type="password" placeholder="Enter Password" required>
      &lt;button type="submit">Login&lt;/button>
      &lt;p style="color:red;">&lt;/p>
    &lt;/div>
  &lt;/form>
  &lt;!--CONTENT (SENSOR READINGS)-->
  &lt;div style="display: none;">
    &lt;div>
      &lt;!--CARD FOR GPIO 12-->
      &lt;div>
        &lt;p>&lt;i>&lt;/i> GPIO 12&lt;/p>
        &lt;p>
          &lt;button>ON&lt;/button>
          &lt;button>OFF&lt;/button>
        &lt;/p>
        &lt;p>State:&lt;span>&lt;/span>&lt;/p>
      &lt;/div>
      &lt;!--CARD FOR GPIO 13-->
      &lt;div>
        &lt;p>&lt;i>&lt;/i> GPIO 13&lt;/p>
        &lt;p>
          &lt;button>ON&lt;/button>
          &lt;button>OFF&lt;/button>
        &lt;/p>
        &lt;p>State:&lt;span>&lt;/span>&lt;/p>
      &lt;/div>
      &lt;!--CARD FOR GPIO 14-->
      &lt;div>
        &lt;p>&lt;i>&lt;/i> GPIO 14&lt;/p>
        &lt;p>
          &lt;button>ON&lt;/button>
          &lt;button>OFF&lt;/button>
        &lt;/p>
        &lt;p>State:&lt;span>&lt;/span>&lt;/p>
      &lt;/div>
    &lt;/div>
  &lt;/div>
    &lt;script src="scripts/auth.js">&lt;/script>
    &lt;script src="scripts/index.js">&lt;/script>
  &lt;/body>
&lt;/html></k>
<a href="https://github.com/RuiSantosdotme/Firebase-ESP/raw/main/ESP-Firebase-Control-GPIOs-Anywhere/Web-App/index.html" target="_blank">View raw code</a>
You need to modify the code with your own firebaseConfig objectthe one you've got in this step.
<h4>How it Works</h4>
Let's take a quick look at the HTML file, or skip to the next section.
In the &lt;head> of the HTML file, we must add all the required metadata.
The title of the web page is <k>ESP Firebase App</k>, but you can change it in the following line.
<k>&lt;title>ESP Firebase App&lt;/title></k>
You must add the following line to be able to use Firebase with your app.
<k>&lt;script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js">&lt;/script></k>
You must also add any Firebase products you want to use. In this example, we're using the Realtime Database and Authentication.
<k>&lt;script src="https://www.gstatic.com/firebasejs/8.8.1/firebase-auth.js">&lt;/script>
&lt;script src="https://www.gstatic.com/firebasejs/8.8.1/firebase-database.js">&lt;/script></k>
Then, replace the firebaseConfig object with the one you've gotten from this step.
<k>const firebaseConfig = {
  apiKey: "REPLACE_WITH_YOUR_Firebase_CONFIGURATION",
  authDomain: "REPLACE_WITH_YOUR_Firebase_CONFIGURATION",
  databaseURL: "REPLACE_WITH_YOUR_Firebase_CONFIGURATION",
  projectId: "REPLACE_WITH_YOUR_Firebase_CONFIGURATION",
  storageBucket: "REPLACE_WITH_YOUR_Firebase_CONFIGURATION",
  messagingSenderId: "REPLACE_WITH_YOUR_Firebase_CONFIGURATION",
  appId: "REPLACE_WITH_YOUR_Firebase_CONFIGURATION"
};</k>
Finally, Firebase is initialized, and we create two global variables db and auth that refer to Firebase authentication and to Firebase realtime database.
<k>// Initialize firebase
firebase.initializeApp(firebaseConfig);
      
// Make auth and database references
const auth = firebase.auth();
const db = firebase.database();</k>
The following line allows us to use <a href="https://fontawesome.com/" target="_blank">fontawesome icons</a>:
<k>&lt;link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"></k>
The next includes a <a href="https://github.com/RuiSantosdotme/build-web-servers-dl/raw/main/favicon.zip" target="_blank">favicon</a> on our web page.
<k>&lt;link rel="icon" type="image/png" href="favicon.png"></k>
Finally, reference an external style.css file to format the HTML page.
<k>&lt;link rel="stylesheet" type="text/css" href="style.css"></k>
We're done with the metadata. Now, let's go to the HTML parts that are visible to the usergo between the &lt;body> and &lt;/body> tags.
We create a top navigation bar with the name of our app and a small icon from fontawesome.
<k>&lt;!--TOP BAR-->
&lt;div>
  &lt;h1>ESP GPIO Control &lt;i>&lt;/i>&lt;/h2>
&lt;/div></k>
The following lines create a bar with the details of the authenticated user (email). It also shows a logout link to log out the user. 
<k>&lt;div style="display: none;">
  &lt;p>&lt;span>User logged in&lt;/span>
     &lt;span>USEREMAIL&lt;/span>
     &lt;a href="/">(logout)&lt;/a>
  &lt;/p>
&lt;/div></k>
First, we set the display style of all elements to none. We'll hide and show content depending if the user is authenticated or notwe'll handle that using JavaScript.
Next, the following lines create the login form with an input field for the email and an input field for the password:
<k>&lt;form style="display: none;">  
  &lt;div>
    &lt;label for="input-email">&lt;b>Email&lt;/b>&lt;/label>
    &lt;input type="text" placeholder="Enter Username" required>
  
    &lt;label for="input-password">&lt;b>Password&lt;/b>&lt;/label>
    &lt;input type="password" placeholder="Enter Password" required>
          
    &lt;button type="submit">Login&lt;/button>
    &lt;p style="color:red;">&lt;/p>
  &lt;/div>
&lt;/form></k>
Inside the form, there's also a paragraph to display an error message if the login fails.
<k>&lt;p style="color:red;">&lt;/p></k>
Finally, we create a grid to display different cards for the GPIOs.
<k>&lt;div style="display: none;">
  &lt;div></k>
For example, the following lines create a card for GPIO 12:
<k>&lt;!--CARD FOR GPIO 12-->
&lt;div>
  &lt;p>&lt;i>&lt;/i> GPIO 12&lt;/p>
  &lt;p>
    &lt;button>ON&lt;/button>
    &lt;button>OFF&lt;/button>
  &lt;/p>
  &lt;p>State:&lt;span>&lt;/span>&lt;/p>
&lt;/div></k>
The buttons have specific ids so that we can refer to them later on in the Javascript files. There's also a span tag with a specific id to insert the GPIO state.
Creating the cards for the other GPIOs is similar:
<k>&lt;!--CARD FOR GPIO 13-->
&lt;div>
  &lt;p>&lt;i>&lt;/i> GPIO 13&lt;/p>
  &lt;p>
    &lt;button>ON&lt;/button>
    &lt;button>OFF&lt;/button>
  &lt;/p>
  &lt;p>State:&lt;span>&lt;/span>&lt;/p>
&lt;/div>
&lt;!--CARD FOR GPIO 14-->
&lt;div>
  &lt;p>&lt;i>&lt;/i> GPIO 14&lt;/p>
  &lt;p>
    &lt;button>ON&lt;/button>
    &lt;button>OFF&lt;/button>
  &lt;/p>
  &lt;p>State:&lt;span>&lt;/span>&lt;/p>
&lt;/div></k>
It's important to keep in mind the ids of each of those elements, so that's its easier to identify them on the JavaScript file. You can use any other ids that make sense for your project.
<table><tbody>
<tr>
<td></td>
<td><k>GPIO 12</k></td>
<td><k>GPIO 13</k></td>
<td><k>GPIO 14</k></td>
</tr>
<tr>
<td><k>ON Button</k></td>
<td>btn1On</td>
<td>btn2On</td>
<td>btn3On</td>
</tr>
<tr>
<td><k>OFF Button</k></td>
<td>btn1Off</td>
<td>btn2Off</td>
<td>btn3Off</td>
</tr>
<tr>
<td><k>State</k></td>
<td>state1</td>
<td>state2</td>
<td>state3</td>
</tr>
</tbody></table>Finally, we need to add references to the external JavaScript files. For our application, we'll create two JavaScript files: auth.js (that handles everything related to the authentication) and index.js that handles everything related to the UI. We'll create those files inside a folder called scripts inside the public folder of our application.
<k>&lt;script src="scripts/auth.js">&lt;/script>
&lt;script src="scripts/index.js">&lt;/script></k>
After making the necessary changes (inserting your firebaseConfig object), you can save the HTML file.
<h3>style.css</h3>
Inside the public folder create a file called style.css. To create the file, select the public folder, and then click on the <k>+file</k> icon at the top of the File Explorer. Call it style.css.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/Firebase-Project-VS-Code-CSS-File.png">
Then, copy the following to the style.css file
<k>html {
    font-family: Verdana, Geneva, Tahoma, sans-serif;
    display: inline-block;
    text-align: center;
}
h1 {
    font-size: 1.8rem;
    color: white;
}
.topnav {
    overflow: hidden;
    background-color: #049faa;
    color: white;
    font-size: 1rem;
    padding: 10px;
}
#authentication-bar{
    background-color:mintcream;
    padding-top: 10px;
    padding-bottom: 10px;
}
#user-details{
    color: cadetblue;
}
.content {
    padding: 20px;
}
body {
    margin: 0;
}
.card-grid {
    max-width: 800px;
    margin: 0 auto;
    display: grid;
    grid-gap: 2rem;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
}
.card {
    background-color: white;
    box-shadow: 2px 2px 12px 1px rgba(140,140,140,.5);
}
.card-title {
    font-size: 1.2rem;
    color: #034078
}
.state {
    color:#1282A2;
}
button {
    background-color: #049faa;
    color: white;
    padding: 14px 20px;
    margin: 8px 0;
    border: none;
    cursor: pointer;
    border-radius: 4px;
}
.button-on {
    background-color:#034078;
}
.button-on:hover {
    background-color: #1282A2;
}
.button-off {
    background-color:#858585;
}
.button-off:hover {
    background-color: #252524;
}
.form-elements-container{
    padding: 16px;
    width: 250px;
    margin: 0 auto;
}
input[type=text], input[type=password] {
    width: 100%;
    padding: 12px 20px;
    margin: 8px 0;
    display: inline-block;
    border: 1px solid #ccc;
    box-sizing: border-box;
}</k>
<a href="https://github.com/RuiSantosdotme/Firebase-ESP/raw/main/ESP-Firebase-Control-GPIOs-Anywhere/Web-App/style.css" target="_blank">View raw code</a>
The CSS file includes some simple styles to make our webpage look better. We won't discuss how CSS works in this tutorial. You can easily modify the CSS file to change the colors and font size, for example.
<h3>JavaScript Files</h3>
We'll create two JavaScript files (auth.js and index.js) inside a scripts folder inside the public folder.
Select the public folder, then click on the <k>+folder</k> icon to create a new folder. Call scripts to that new folder.
Then, select the scripts folder and click on the <k>+file</k> icon. Create a file called auth.js. Then, repeat the previous steps to create an index.js.
The following image shows how your web app project folder structure should look like.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/Firebase-Project-VS-Code-Folder-File-Structure.png">
<h4>auth.js</h4>
Now let's implement user sign-in using Firebase authentication. We'll implement sign-in using email and password.
Copy the following to the auth.js file you created previously. 
<k>document.addEventListener("DOMContentLoaded", function(){
    // listen for auth status changes
    auth.onAuthStateChanged(user => {
        if (user) {
            console.log("user logged in");
            console.log(user);
            setupUI(user);
        } else {
            console.log("user logged out");
            setupUI();
        }
    });
    // login
    const loginForm = document.querySelector('#login-form');
    loginForm.addEventListener('submit', (e) => {
        e.preventDefault();
        // get user info
        const email = loginForm['input-email'].value;
        const password = loginForm['input-password'].value;
        // log the user in
        auth.signInWithEmailAndPassword(email, password).then((cred) => {
            // close the login modal & reset form
            loginForm.reset();
            console.log(email);
        })
        .catch((error) =>{
            const errorCode = error.code;
            const errorMessage = error.message;
            document.getElementById("error-message").innerHTML = errorMessage;
            console.log(errorMessage);
        });
    });
    // logout
    const logout = document.querySelector('#logout-link');
    logout.addEventListener('click', (e) => {
    e.preventDefault();
    auth.signOut();
    });
    
});</k>
<a href="https://github.com/RuiSantosdotme/Firebase-ESP/raw/main/ESP-Firebase-Control-GPIOs-Anywhere/Web-App/scripts/auth.js" target="_blank">View raw code</a>
Then, save the file. This file takes care of everything related to the login and logout of the user. Continue reading to learn how the code works or skip to the next section.
<k>Login</k>
The following lines are responsible for logging in the user.
<k>const loginForm = document.querySelector('#login-form');
loginForm.addEventListener('submit', (e) => {
  e.preventDefault();
  // get user info
  const email = loginForm['input-email'].value;
  const password = loginForm['input-password'].value;
  // log the user in
  auth.signInWithEmailAndPassword(email, password).then((cred) => {
    // close the login modal & reset form
    loginForm.reset();
    console.log(email);
  })
  .catch((error) =>{
    const errorCode = error.code;
    const errorMessage = error.message;
    document.getElementById("error-message").innerHTML = errorMessage;
    console.log(errorMessage);
  });
});</k>
We create a variable that refers to the login form HTML element called loginForm.
<k>const loginForm = document.querySelector('#login-form');</k>
If you go back to the index.html file, you can see that the form has the login-form id.
We add an event listener of type submit to the form. This means that the subsequent instructions will run whenever the form is submitted.
<k>loginForm.addEventListener('submit', (e) => {</k>
You can get the submitted data as follows.
<k>const email = loginForm['input-email'].value;
const password = loginForm['input-password'].value;</k>
If you go back to the HTML file, you'll see that the input fields contain the following ids: input-email and input-password for the email and password, respectively.
Now that we have the inserted email and password, we can try to log in to Firebase. To do that, pass the user's email address and password to the following method: signInWithEmailAndPassword:
<k>auth.signInWithEmailAndPassword(email, password).then((cred) => {</k>
After logging in, we reset the form and print the user email in the console.
<k>auth.signInWithEmailAndPassword(email, password).then((cred) => {
  // close the login modal & reset form
  loginForm.reset();
  console.log(email);
})</k>
In case there is an error signing in, we catch the error message, and display it on the error-message HTML element (a paragraph below the form).
<k>.catch((error) =>{
  const errorCode = error.code;
  const errorMessage = error.message;
  document.getElementById("error-message").innerHTML = errorMessage;
  console.log(errorMessage);
});</k>
<k>Logout</k>
The following snippet is responsible for logging out the user.
<k>const logout = document.querySelector('#logout-link');
logout.addEventListener('click', (e) => {
  e.preventDefault();
  auth.signOut();
});</k>
When the user is logged in, a logout link is visible in the authentication bar. That link has the logout-link id (see on the HTML file). So, first, we create a variable called logout that refers to the logout link.
<k>const logout = document.querySelector('#logout-link');</k>
Then, we add an event listener of type click. This means the subsequent instructions will run whenever you click on the logout link.
<k>logout.addEventListener('click', (e) => {</k>
When the button is clicked, we sign out the user using the signOut method.
<k>auth.signOut();</k>
<k>Auth State Changes</k>
To keep track of the user authentication stateto know if the user is logged in or logged out, there is a method called onAuthSateChanged that allows you to receive an event whenever the authentication state changes.
<k>auth.onAuthStateChanged(user => {
  if (user) {
    console.log("user logged in");
    console.log(user);
    setupUI(user);
    var uid = user.uid;
    console.log(uid);
  } else {
    console.log("user logged out");
    setupUI();
  }
});</k>
If the user returned is null, the user is currently signed out. Otherwise, it is currently signed in.
In both scenarios, we print the current user state to the console and call the setupUI() function. We haven't created that function yet (we'll create it in the next section), but it will be responsible for handling the user interface accordingly to the authentication state.
When the user is logged in, we pass the user as an argument to the setupUI() function. In this case, we'll display the complete user interface to show the buttons to control the GPIOs, as you'll see later.
<k>if (user) {
  console.log("user logged in");
  console.log(user);
  setupUI(user);</k>
If the user is logged out, we call the setupUI() function without any argument. In that scenario, we'll simply display a message informing that the user is logged out and doesn't have access to the interface (as we'll see later).
<k>} else {
  console.log("user logged out");
  setupUI();
}</k>
<h4>index.js</h4>
The index.js file handles the UI  it shows the right content depending on the user authentication status. When the user is logged in, it gets the GPIO states from the database and updates the GPIO states on the interface. Then, it changes the states whenever you press the buttons.
Copy the following to the index.js file. 
<k>const loginElement = document.querySelector('#login-form');
const contentElement = document.querySelector("#content-sign-in");
const userDetailsElement = document.querySelector('#user-details');
const authBarElement = document.querySelector("#authentication-bar");
// Elements for GPIO states
const stateElement1 = document.getElementById("state1");
const stateElement2 = document.getElementById("state2");
const stateElement3 = document.getElementById("state3");
// Button Elements
const btn1On = document.getElementById('btn1On');
const btn1Off = document.getElementById('btn1Off');
const btn2On = document.getElementById('btn2On');
const btn2Off = document.getElementById('btn2Off');
const btn3On = document.getElementById('btn3On');
const btn3Off = document.getElementById('btn3Off');
// Database path for GPIO states
var dbPathOutput1 = 'board1/outputs/digital/12';
var dbPathOutput2 = 'board1/outputs/digital/13';
var dbPathOutput3 = 'board1/outputs/digital/14';
// Database references
var dbRefOutput1 = firebase.database().ref().child(dbPathOutput1);
var dbRefOutput2 = firebase.database().ref().child(dbPathOutput2);
var dbRefOutput3 = firebase.database().ref().child(dbPathOutput3);
// MANAGE LOGIN/LOGOUT UI
const setupUI = (user) => {
  if (user) {
    //toggle UI elements
    loginElement.style.display = 'none';
    contentElement.style.display = 'block';
    authBarElement.style.display ='block';
    userDetailsElement.style.display ='block';
    userDetailsElement.innerHTML = user.email;
    //Update states depending on the database value
    dbRefOutput1.on('value', snap => {
        if(snap.val()==1) {
            stateElement1.innerText="ON";
        }
        else{
            stateElement1.innerText="OFF";
        }
    });
    dbRefOutput2.on('value', snap => {
        if(snap.val()==1) {
            stateElement2.innerText="ON";
        }
        else{
            stateElement2.innerText="OFF";
        }
    });
    dbRefOutput3.on('value', snap => {
        if(snap.val()==1) {
            stateElement3.innerText="ON";
        }
        else{
            stateElement3.innerText="OFF";
        }
    });
    // Update database uppon button click
    btn1On.onclick = () =>{
        dbRefOutput1.set(1);
    }
    btn1Off.onclick = () =>{
        dbRefOutput1.set(0);
    }
    btn2On.onclick = () =>{
        dbRefOutput2.set(1);
    }
    btn2Off.onclick = () =>{
        dbRefOutput2.set(0);
    }
    btn3On.onclick = () =>{
        dbRefOutput3.set(1);
    }
    btn3Off.onclick = () =>{
        dbRefOutput3.set(0);
    }
  // if user is logged out
  } else{
    // toggle UI elements
    loginElement.style.display = 'block';
    authBarElement.style.display ='none';
    userDetailsElement.style.display ='none';
    contentElement.style.display = 'none';
  }
}</k>
<a href="https://github.com/RuiSantosdotme/Firebase-ESP/raw/main/ESP-Firebase-Control-GPIOs-Anywhere/Web-App/scripts/index.js" target="_blank">View raw code</a>
Continue reading to learn how the code works or skip to the next section.
<k>Getting HTML Elements</k>
First, we create variables to refer to several elements on the UI interface by referring to their ids. To identify these elements, we recommend that you take a look at the HTML file provided and find the elements with the referred ids.
<k>const loginElement = document.querySelector('#login-form');
const contentElement = document.querySelector("#content-sign-in");
const userDetailsElement = document.querySelector('#user-details');
const authBarElement = document.querySelector("#authentication-bar");</k>
The loginElement corresponds to the login form. The contentElement corresponds to the section of the web page that is visible when the user is logged in (that shows the sensor readings). The userDetailsElement corresponds to a section that will display the email of the logged in user. The auhtBarElement corresponds to the authentication bar that shows the current user status, the email of the authenticated user and the logout link.
The following creates variables to refer to the buttons as GPIOs states on the interface:
<k>// Elements for GPIO states
const stateElement1 = document.getElementById("state1");
const stateElement2 = document.getElementById("state2");
const stateElement3 = document.getElementById("state3");
// Button Elements
const btn1On = document.getElementById('btn1On');
const btn1Off = document.getElementById('btn1Off');
const btn2On = document.getElementById('btn2On');
const btn2Off = document.getElementById('btn2Off');
const btn3On = document.getElementById('btn3On');
const btn3Off = document.getElementById('btn3Off');</k>
<h4>Database Paths and References</h4>
Then, we need to create database paths to where the GPIOs states are saved:
<k>// Database path for GPIO states
var dbPathOutput1 = 'board1/outputs/digital/12';
var dbPathOutput2 = 'board1/outputs/digital/13';
var dbPathOutput3 = 'board1/outputs/digital/14';</k>
To be able to interact with the database on those paths, we need to create database references using those paths:
<k>// Database references
var dbRefOutput1 = firebase.database().ref().child(dbPathOutput1);
var dbRefOutput2 = firebase.database().ref().child(dbPathOutput2);
var dbRefOutput3 = firebase.database().ref().child(dbPathOutput3);</k>
<k>sertupUI() Function</k>
Then, we create the setupUI() function that will handle the UI accordingly to the state of the user authentication.
In the auth.js file, we called the setupUI() function with the user argument setupUI(user) if the user is logged in; or the function without argument setupUI() when the user is logged out.
So, let's check what happens when the user is logged in.
<k>if (user) {</k>
We show the authentication bar (that shows the user details and the logout link). To do that, we can set its display style to block. We also want the web page's main content with the sensor readings to be visible.
<k>contentElement.style.display = 'block';
authBarElement.style.display ='block';</k>
Finally, we can get the logged in user email with user.email and display it in the userDetailsElement section as follows:
<k>userDetailsElement.innerHTML = user.email;</k>
<k>Get GPIO States</k>
The following lines get the GPIO states whenever there's a change in the database and update the corresponding HTML elements with the new values.
<k>//Update states depending on the database value
dbRefOutput1.on('value', snap => {
  if(snap.val()==1) {
    stateElement1.innerText="ON";
  }
  else{
    stateElement1.innerText="OFF";
  }
});
dbRefOutput2.on('value', snap => {
  if(snap.val()==1) {
    stateElement2.innerText="ON";
  }
  else{
    stateElement2.innerText="OFF";
  }
});
dbRefOutput3.on('value', snap => {
  if(snap.val()==1) {
    stateElement3.innerText="ON";
  }
  else{
    stateElement3.innerText="OFF";
  }
});</k>
<h4>Button Events</h4>
Then, we add events to the buttons to write 1 or 0 to the corresponding database path accordingly to the button that was pressed.
<k>// Update database upon button click
btn1On.onclick = () =>{
  dbRefOutput1.set(1);
}
btn1Off.onclick = () =>{
  dbRefOutput1.set(0);
}
btn2On.onclick = () =>{
  dbRefOutput2.set(1);
}
btn2Off.onclick = () =>{
  dbRefOutput2.set(0);
}
btn3On.onclick = () =>{
  dbRefOutput3.set(1);
}
btn3Off.onclick = () =>{
  dbRefOutput3.set(0);
}</k>
<k>Logged Out UI</k>
The following snippet handles the UI when the user logs out. We want to hide the authentication bar and the main webpage content (GPIO states and corresponding buttons) and show the login form.
<k>} else{
  // toggle UI elements
  loginElement.style.display = 'block';
  authBarElement.style.display ='none';
  contentElement.style.display = 'none';
}</k>
<h3>Favicon File</h3>
To display a favicon in your web app, you need to move the picture you want to use as favicon to the public folder. The picture should be called favicon.png. You can simply drag the favicon file from your computer into the public folder in VS Code.
We're using the following icon as a favicon for our web app:
<a href="https://github.com/RuiSantosdotme/build-web-servers-dl/raw/main/favicon.zip" target="_blank">favicon.png</a>
<h3>Deploy your App</h3>
After saving the HTML, CSS, and JavaScript files, deploy your app on VS Code by running the following command on the Terminal window.
<k><k>firebase</k> deploy</k>
The Terminal should display something as follows:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/ESP32-ESP8266-Deploy-Firebase-App-VS-Code-1.png">
Firebase offers a free hosting service to serve your assets and web apps. Then, you can access your web app from anywhere.
You can use the Hosting URL provided to access your web app from anywhere.
<h3>Demonstration</h3>
Congratulations! You successfully deployed your app. It is now hosted on a global CDN using Firebase hosting. You can access your web app from anywhere on the Hosting URL provided. In my case, it is https://esp-firebase-demo.web.app.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/Firebase-Web-App-Control-GPIOs-from-Anywhere-with-Authentication.png">
The web app is responsive, and you can access it using your smartphone, computer, or tablet.
Insert the email and password of the authorized user you added in the Firebase Authentication methods. After that, you can access the dashboard to control the ESP32 or ESP8266 GPIOs.
Go to your project's Firebase console <k>Hosting</k> tab. You can see your app domains, deploy history, and you can even roll back to previous versions of your app.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/ESP32-ESP8266-Firebase-Web-App-Deploy-History.png">
<h3>Wrapping Up</h3>
In this tutorial, you learned how to create a Firebase Web App with login/logout authentication to control the ESP32 or ESP8266 GPIOs from anywhere. The GPIO states are saved on the realtime database and the ESP is listening to any changes that occur in the database to update the GPIOs right away. You can easily add more GPIOs or more boards to this project.
The database is protected using database rules. Only authorized authenticated users can access the web app to control the GPIOs.
You can combine this project with other <a href="https://randomnerdtutorials.com/?s=firebase">ESP32/ESP8266 Firebase projects we have published</a> and add more functionalities to your app.
<h2>Firebase: Control ESP32 GPIOs from Anywhere</h2>
In this guide, you'll learn how to control the ESP32 GPIOs from anywhere using Firebase. We'll create nodes on the Firebase Realtime Database to save the current GPIO states. Whenever there's a change in the database nodes, the ESP32 updates its GPIOs accordingly. You can change the GPIOs states by writing on the database yourself, or you can create a web app to do that (<a href="https://randomnerdtutorials.com/esp32-esp8266-firebase-gauges-charts/">check this tutorial</a>).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/ESP32-Control-GPIOs-from-Anywhere-Firebase.jpg">
<a href="https://randomnerdtutorials.com/control-esp-gpios-firebase-web-app/"><k>PART 2:</k> Control ESP32/ESP8266 GPIOs from Anywhere (Firebase Web App)</a>
<h3>What is Firebase?</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/Firebase-logo.png">
Firebase is Google's mobile application development platform that helps you build, improve, and grow your app. Firebase provides <em>free </em>services like <k><a href="https://randomnerdtutorials.com/esp32-firebase-web-app/">hosting</a></k>, <k><a href="https://randomnerdtutorials.com/esp32-esp8266-firebase-authentication/">authentication</a></k>, and <k><a href="https://randomnerdtutorials.com/esp32-firebase-realtime-database/">realtime database</a> </k>that allow you to build a fully-featured web app to control and monitor the ESP32 and ESP8266 boards that would be much more difficult and laborious to build and set up on your own.
<h3>Project Overview</h3>
The following diagram shows a high-level overview of the project we'll build.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/ESP32-Firebase-Control-Outputs-from-anywhere-project-overview-01.png">
<ol>
The ESP32 authenticates as a user with email and password to be able to access the database (that user must be added on the Firebase authentication methods);
The database is protected using database rules. We'll add the following rule: only authenticated users can access the database;
The database has several nodes that save the ESP32 GPIO states. As an example, we'll control three GPIOs (12, 13, and 14). You can add or remove nodes to control more or less GPIOs.
The ESP32 will listen for changes on the GPIOs database nodes. Whenever there's a change, it will update the GPIO states accordingly.
You can change the GPIO states manually on the database using the Firebase console, or you can create a web page (accessible from anywhere) with buttons to control the GPIOs and show the current GPIO states (<a href="https://randomnerdtutorials.com/control-esp-gpios-firebase-web-app/">check PART 2</a>).
</ol>
These are the main steps to complete this project:
<ol>
Create a Firebase Project
Set Authentication Methods
Get Project API Key
Set up the Realtime Database
Set up Database Security Rules
Organizing your Database Nodes
ESP32: Listening for Database Changes (control GPIOs) 
</ol>
<h3>Preparing Arduino IDE</h3>
For this tutorial, we'll program the ESP32 board using the Arduino core. So, make sure you have the ESP32 add-on installed in your Arduino IDE:
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing the ESP32 Board in Arduino IDE (Windows, Mac OS X, Linux)</a>
If you want to program the ESP boards using VS Code with the PlatformIO extension, follow the next tutorial instead:
<a href="https://randomnerdtutorials.com/vs-code-platformio-ide-esp32-esp8266-arduino/">Getting Started with VS Code and PlatformIO IDE for ESP32 and ESP8266</a>
<h3>1) Create Firebase Proje3t</h3>
<k>1)</k> Go to <a style="font-size: inherit;" href="https://firebase.google.com/" target="_blank">Firebase </a>and sign in using a Google Account.
<k>2)</k> Click <em style="font-size: inherit;">Get Started</em> and then <k>Add project</k> to create a new project.
<k>3)</k> Give a name to your project, for example <em style="font-size: inherit;">ESP Firebase Demo</em>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/Create-firebase-project-1.png">
 <k>4)</k> Disable the option <em style="font-size: inherit;">Enable Google Analytics</em> for this project as it is not needed and click <k>Create project</k>. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/2-Set-Up-Firebase-Project-ESP32-ESP8266.png">
 <k>5)</k> It will take a few seconds to set up your project. Then, click <k>Continue</k> when it's ready. 
 <k>6)</k> You'll be redirected to your Project console page. 
<h3>2) Set Authentication Methods</h3>
To allow authentication with email and password, first, you need to set authentication methods for your app. 
Most apps need to know the identity of a user. In other words, it takes care of logging in and identifying the users (in this case, the ESP32 or ESP8266). Knowing a user's identity allows an app to securely save user data in the cloud and provide the same personalized experience across all of the user's devices. To learn more about the authentication methods, you can <a href="https://firebase.google.com/docs/auth" target="_blank">read the documentation</a>.
<k>1)</k> On the left sidebar, click on <k>Authentication </k>and then on <k>Get started</k>. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/Firebase-Project-Authentication.png">
<k>2)</k> Select the Option <k>Email/Password</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/Authentication-methods.png">
<k>3)</k> Enable that authentication method and click <k>Save</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/Firebase-email-password-sign-in-provider.png">
<k>4)</k> The authentication with email and password should now be enabled.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/email-password-enabled.png">
<k>5)</k> Now, you need to add a user. On the <k>Authentication </k>tab, select the <k>Users </k>tab at the top. Then, click on <k>Add User</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/Firebase-Add-New-User.png">
<k>6)</k> Add an email address for the authorized user. It can be your google account email or any other email. You can also create an email for this specific project. Add a password that will allow you to sign in to your app and access the database. Don't forget to save the password in a safe place because you'll need it later. When you're done, click <k>Add user</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/Firebase-Add-User-Email-Password.png">
<k>7)</k> A new user was successfully created and added to the <k>Users</k> table.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/Users-Table-Firebase.png">
Notice that Firebase creates a unique UID for each registered user. The user UID allows us to identify the user and keep track of the user to provide or deny access to the project or the database. There's also a column that registers the date of the last sign-in. At the moment, it is empty because we haven't signed in with that user yet.
Copy the User UID because you'll need it later.
<h3>3) Get Project API Key</h3>
To interface with your Firebase project using the ESP32 or ESP8266 boards, you need to get your project API key. Follow the next steps to get your project API key.
<k>1)</k> On the left sidebar, click on <k>Project Settings</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/Firebase-project-settings.png">
<k>2)</k> Copy the Web API Key to a safe place because you'll need it later.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/Firebase-Project-Settings-Web-API-Key.png">
<h3>4) Set up the Realtime Database</h3>
Now, let's create a realtime database and set up database rules for our project.
<k>1)</k> On the left sidebar, click on <k>Realtime Database</k> and then click on <k>Create Database</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/Firebase-Project-Create-Realtime-Database.png">
<k>2)</k> Select your database location. It should be the closest to your location.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/2-Set-Up-Firebase-database-ESP32-ESP8266.png">
<k>3)</k> Set up security rules for your database. You can select <k>Start in test mode</k>. We'll change the database rules in just a moment.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/3-Set-Up-Firebase-database-ESP32-ESP8266.png">
<k>4)</k> Your database is now created. You need to copy and save the database URLhighlighted in the following imagebecause you'll need it later in your ESP32 code.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/Firebase-project-database-URL.png">
<h3>5) Set up Database Security Rules</h3>
Now, let's set up the database rules. On the <k>Realtime Database</k> tab, select the <k>Rules</k> tab at the top. Then, click on <k>Edit rules</k>, and add the following rules. 
<k>{
  "rules": {
    ".read": "auth.uid === 'REPLACE_WITH_YOUR_USER_UID'",
    ".write": "auth.uid === 'REPLACE_WITH_YOUR_USER_UID'"
  }
}</k>
Insert the UID of the user you created previously. Then, click <k>Publish</k>.
These database rules determine that:
Only the user with that specific UID can read and write to the database (change the GPIO states).
<h3>Add More Users</h3>
To add more users, you can simply go to the <k>Authentication </k>tab and click <k>Add user</k>. Add an email and password for the new user, and finally click on <k>Add user</k> to create the user.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/Firebase-Add-New-User-Email-Password-Dashboard.png">
Copy the user UID of that new user and add it to the database rules, as follows:
<k>{
  "rules": {
    ".read": "auth.uid === 'REPLACE_WITH_YOUR_USER_UID' || auth.uid === 'REPLACE_WITH_USER_UID2'",
    ".write": "auth.uid === 'REPLACE_WITH_YOUR_USER_UID' || auth.uid === 'REPLACE_WITH_USER_UID2'"
  }
}</k>
For example. In my case, the UIDs of the users are: <k>RjO3taAzMMXB82Xmir2LQ7XXXXXX </k>and <k>9QdDc9as5mRXGAjEsQiUJkXXXXXX</k>. So, the database rules will look as follows:
<k>{
  "rules": {
    ".read": "auth.uid === '<k>RjO3taAzMMXB82Xmir2LQ7XXXXXX</k>' || auth.uid === '<k>9QdDc9as5mRXGAjEsQiUJkXXXXXX</k>'",
    ".write": "auth.uid === '<k>RjO3taAzMMXB82Xmir2LQ7XXXXXX</k>' || auth.uid === '<k>9QdDc9as5mRXGAjEsQiUJkXXXXXX</k>'"
  }
}</k>
Finally, Publish your database rules.
To learn more about database rules, you can check the <a href="https://firebase.google.com/docs/database/security" target="_blank">Firebase documentation</a>.
<h3>6) Organizing Your Database Nodes</h3>
All the data stored in the Firebase Realtime Database is stored as JSON objects. So, you can think of the database as a cloud-based JSON tree. When you add data to the JSON tree, it becomes a node with an associated key in the existing JSON structure.
<k>Not familiar with JSON?</k> <a href="https://www.w3schools.com/js/js_json_intro.asp" target="_blank">Read this quick guide</a>.
The best way to organize your data will depend on your project features and how users access the data.
We want to control the ESP32 GPIOs. We can organize the data in a way that makes it easy to add more GPIOs and boards later on. So, we can structure the database as follows:
board1:outputs:digital:
12: 0
13: 0
14: 0
In JSON format, here's what it would look like:
<k>{
  "board1": {
    "outputs": {
      "digital": {
        "12": 0,
        "13": 0,
        "14": 0
      }
    }
  }
}</k>
<h3>Creating Database Nodes</h3>
Now let's create the database nodes in our database. You can create the nodes manually by writing the nodes on the Firebase console, on the web app, or via the ESP32. We'll create them manually, so it is easier to follow the tutorial.
<k>1)</k> Click on the <k>Realtime Database</k> so that we start creating the nodes.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/Firebase-Realtime-database.png">
<k>2)</k> You can create the database nodes manually by using the (<k>+</k>) icons on the database. However, to prevent typos, we provide a JSON file that you can upload to create the same nodes as ours. Click the link below to download the JSON file.
<a href="https://github.com/RuiSantosdotme/Firebase-ESP/blob/main/ESP-Firebase-Control-GPIOs-Anywhere/database-outputs.zip?raw=true" target="_blank">Download database JSON file</a>
After downloading, unzip the folder to access the <em>.json</em> file.
<k>3)</k> Now, go back to your database on the Firebase console. Click on the three-dot icon and select <k>Import JSON</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/Firebase-RTDB-Import-JSON.png">
<k>4)</k> Select the JSON file that you've just downloaded.
<k>5)</k> Your database should look as shown below.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/Firebase-RTDB-Control-GPIOs-Structure-Example.png">
All the database nodes required for this project are created. You can proceed to the next section.
<h3>7) ESP32: Listening for Database Changes (control GPIOs)</h3>
In this section, we'll program the ESP32 board to do the following tasks:
<ol>
Authenticate as a user with email and password (the user you set up in this section);
Listening for database changes on the GPIO nodes and changing their states accordingly.
</ol>
<h3>Parts Required</h3>
For this project, you need the following parts:
<a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32</a> (read <a href="https://makeradvisor.com/esp32-development-boards-review-comparison/" target="_blank">Best ESP32 Development Boards</a>);
<a href="https://makeradvisor.com/tools/3mm-5mm-leds-kit-storage-box/" target="_blank">3x LEDs</a>;
<a href="https://makeradvisor.com/tools/resistors-kits/" target="_blank">3x 220Ohm resistors</a>;
<a href="https://makeradvisor.com/tools/mb-102-solderless-breadboard-830-points/" target="_blank">Breadboard</a>;        <a href="https://makeradvisor.com/tools/jumper-wires-kit-120-pieces/"> </a>
<a href="https://makeradvisor.com/tools/jumper-wires-kit-120-pieces/" target="_blank">Jumper wires</a>.
You can use the preceding links or go directly to <a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank">MakerAdvisor.com/tools</a> to find all the parts for your projects at the best price!
<a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/header-200.png?w=828&quality=100&strip=all&ssl=1" data-recalc-dims="1" loading="lazy" fetchpriority="low"></a>
<h3>Schematic Diagram</h3>
In this example, we'll control three LEDs connected to GPIOs 12, 13, and 14. So, wire three LEDs to the ESP32. You can follow the next schematic diagram.
<a href="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/05/ESP32-three-LEDs-schematic-diagram.png?quality=100&strip=all&ssl=1"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/05/ESP32-three-LEDs-schematic-diagram.png"></a>
You can use any <a href="https://randomnerdtutorials.com/esp32-pinout-reference-gpios/">other suitable ESP32 GPIOs</a>, but you also need to change the database nodes.
<h3>Installing the Firebase ESP Client Library</h3>
The <a href="https://github.com/mobizt/Firebase-ESP-Client" target="_blank">Firebase ESP Client Library</a> provides many examples on how to interface the ESP32 with Firebase services. <a href="https://github.com/mobizt/Firebase-ESP-Client" target="_blank">Check the library Github page here</a> and consider supporting the author if the library is useful for your projects.
<h4>
<k>Install the Firebase-ESP-Client Library</k> (Arduino IDE)</h4>
Follow this section if you're using Arduino IDE. 
Go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k>, search for Firebase ESP Client. Select the <k>Firebase Arduino Client Library for ESP8266 and ESP32</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/Install-Firebase-ESP-Client-Library-Arduino-IDE-f.png">
Now, you're all set to start programming the ESP32 boards to interact with the database.
<h4>
<k>Install the Firebase-ESP-Client Library</k> (VS Code)</h4>
Follow the next instructions if you're using VS Code + PlatformIO.
Click on the <k>PIO Home</k> icon and select the <k>Libraries tab</k>. Search for <k>Firebase ESP Client</k>. Select the <k>Firebase Arduino Client Library for ESP8266 and ESP32</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/Install-Firebase-Library-VS-Code-1.png">
Then, click <k>Add to Project</k> and select the project you're working on.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/Install-Firebase-Library-VS-Code-2.png">
Also, change the monitor speed to 115200 by adding the following line to the platformio.ini file of your project:
<k>monitor_speed = 115200</k>
<h3>Listening for Database Changes (GPIO states)  Code</h3>
Copy the following code to your Arduino IDE or to the main.cpp file if you're using VS Code.
You need to insert the following in the code before uploading it to your board:
your network credentials
project API key
database URL
authorized user email and password
<k>/*
  Rui Santos
  Complete project details at our blog.
    - ESP32: https://RandomNerdTutorials.com/firebase-control-esp32-gpios/
    - ESP8266: https://RandomNerdTutorials.com/firebase-control-esp8266-nodemcu-gpios/
  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files.
  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
  Based in the RTDB Basic Example by Firebase-ESP-Client library by mobizt
  https://github.com/mobizt/Firebase-ESP-Client/blob/main/examples/RTDB/Basic/Basic.ino
*/
#include &lt;Arduino.h>
#if defined(ESP32)
  #include &lt;WiFi.h>
#elif defined(ESP8266)
  #include &lt;ESP8266WiFi.h>
#endif
#include &lt;Firebase_ESP_Client.h>
// Provide the token generation process info.
#include "addons/TokenHelper.h"
// Provide the RTDB payload printing info and other helper functions.
#include "addons/RTDBHelper.h"
// Insert your network credentials
#define WIFI_SSID "REPLACE_WITH_YOUR_SSID"
#define WIFI_PASSWORD "REPLACE_WITH_YOUR_PASSWORD"
// Insert Firebase project API Key
#define API_KEY "REPLACE_WITH_YOUR_PROJECT_API_KEY"
// Insert Authorized Username and Corresponding Password
#define USER_EMAIL "REPLACE_WITH_THE_USER_EMAIL"
#define USER_PASSWORD "REPLACE_WITH_THE_USER_PASSWORD"
// Insert RTDB URLefine the RTDB URL
#define DATABASE_URL "REPLACE_WITH_YOUR_DATABASE_URL"
// Define Firebase objects
FirebaseData stream;
FirebaseAuth auth;
FirebaseConfig config;
// Variables to save database paths
String listenerPath = "board1/outputs/digital/";
// Declare outputs
const int output1 = 12;
const int output2 = 13;
const int output3 = 14;
// Initialize WiFi
void initWiFi() {
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  Serial.print("Connecting to WiFi ..");
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print('.');
    delay(1000);
  }
  Serial.println(WiFi.localIP());
  Serial.println();
}
// Callback function that runs on database changes
void streamCallback(FirebaseStream data){
  Serial.printf("stream path, %s\nevent path, %s\ndata type, %s\nevent type, %s\n\n",
                data.streamPath().c_str(),
                data.dataPath().c_str(),
                data.dataType().c_str(),
                data.eventType().c_str());
  printResult(data); //see addons/RTDBHelper.h
  Serial.println();
  // Get the path that triggered the function
  String streamPath = String(data.dataPath());
  // if the data returned is an integer, there was a change on the GPIO state on the following path /{gpio_number}
  if (data.dataTypeEnum() == fb_esp_rtdb_data_type_integer){
    String gpio = streamPath.substring(1);
    int state = data.intData();
    Serial.print("GPIO: ");
    Serial.println(gpio);
    Serial.print("STATE: ");
    Serial.println(state);
    digitalWrite(gpio.toInt(), state);
  }
  /* When it first runs, it is triggered on the root (/) path and returns a JSON with all keys
  and values of that path. So, we can get all values from the database and updated the GPIO states*/
  if (data.dataTypeEnum() == fb_esp_rtdb_data_type_json){
    FirebaseJson json = data.to&lt;FirebaseJson>();
    // To iterate all values in Json object
    size_t count = json.iteratorBegin();
    Serial.println("\n---------");
    for (size_t i = 0; i &lt; count; i++){
        FirebaseJson::IteratorValue value = json.valueAt(i);
        int gpio = value.key.toInt();
        int state = value.value.toInt();
        Serial.print("STATE: ");
        Serial.println(state);
        Serial.print("GPIO:");
        Serial.println(gpio);
        digitalWrite(gpio, state);
        Serial.printf("Name: %s, Value: %s, Type: %s\n", value.key.c_str(), value.value.c_str(), value.type == FirebaseJson::JSON_OBJECT ? "object" : "array");
    }
    Serial.println();
    json.iteratorEnd(); // required for free the used memory in iteration (node data collection)
  }
  
  //This is the size of stream payload received (current and max value)
  //Max payload size is the payload size under the stream path since the stream connected
  //and read once and will not update until stream reconnection takes place.
  //This max value will be zero as no payload received in case of ESP8266 which
  //BearSSL reserved Rx buffer size is less than the actual stream payload.
  Serial.printf("Received stream payload size: %d (Max. %d)\n\n", data.payloadLength(), data.maxPayloadLength());
}
void streamTimeoutCallback(bool timeout){
  if (timeout)
    Serial.println("stream timeout, resuming...\n");
  if (!stream.httpConnected())
    Serial.printf("error code: %d, reason: %s\n\n", stream.httpCode(), stream.errorReason().c_str());
}
void setup(){
  Serial.begin(115200);
  initWiFi();
  // Initialize Outputs
  pinMode(output1, OUTPUT);
  pinMode(output2, OUTPUT);
  pinMode(output3, OUTPUT);
  
  // Assign the api key (required)
  config.api_key = API_KEY;
  // Assign the user sign in credentials
  auth.user.email = USER_EMAIL;
  auth.user.password = USER_PASSWORD;
  // Assign the RTDB URL (required)
  config.database_url = DATABASE_URL;
  Firebase.reconnectWiFi(true);
  // Assign the callback function for the long running token generation task */
  config.token_status_callback = tokenStatusCallback; //see addons/TokenHelper.h
  // Assign the maximum retry of token generation
  config.max_token_generation_retry = 5;
  // Initialize the library with the Firebase authen and config
  Firebase.begin(&config, &auth);
  // Streaming (whenever data changes on a path)
  // Begin stream on a database path --> board1/outputs/digital
  if (!Firebase.RTDB.beginStream(&stream, listenerPath.c_str()))
    Serial.printf("stream begin error, %s\n\n", stream.errorReason().c_str());
  // Assign a calback function to run when it detects changes on the database
  Firebase.RTDB.setStreamCallback(&stream, streamCallback, streamTimeoutCallback);
  delay(2000);
}
void loop(){
  if (Firebase.isTokenExpired()){
    Firebase.refreshToken(&config);
    Serial.println("Refresh token");
  }
}
</k>
<a href="https://github.com/RuiSantosdotme/Firebase-ESP/raw/main/ESP-Firebase-Control-GPIOs-Anywhere/ESP-Firebase-Control-GPIOs-Anywhere.ino" target="_blank">View raw code</a>
<h3>How the Code Works</h3>
Continue reading to learn how the code works or skip to the demonstration section.
<h4>Include Libraries</h4>
First, include the required libraries. This code is also compatible with the ESP8266.
<k>#include &lt;Arduino.h>
#if defined(ESP32)
  #include &lt;WiFi.h>
#elif defined(ESP8266)
  #include &lt;ESP8266WiFi.h>
#endif
#include &lt;Firebase_ESP_Client.h>
// Provide the token generation process info.
#include "addons/TokenHelper.h"
// Provide the RTDB payload printing info and other helper functions.
#include "addons/RTDBHelper.h"</k>
<h4>Network Credentials</h4>
Include your network credentials in the following lines so that your boards can connect to the internet using your local network.
<k>// Insert your network credentials
#define WIFI_SSID "REPLACE_WITH_YOUR_SSID"
#define WIFI_PASSWORD "REPLACE_WITH_YOUR_PASSWORD"</k>
<h4>Firebase Project API Key, Firebase User, and Database URL</h4>
Insert your Firebase project API keythe one you've gotten in this section.
<k>#define API_KEY "REPLACE_WITH_YOUR_PROJECT_API_KEY"</k>
Insert the authorized email and the corresponding passwordthese are the details of the user you've added in this section.
<k>// Insert Authorized Email and Corresponding Password
#define USER_EMAIL "REPLACE_WITH_THE_USER_EMAIL"
#define USER_PASSWORD "REPLACE_WITH_THE_USER_PASSWORD"</k>
Insert your database URL in the following line:
<k>// Insert RTDB URLefine the RTDB URL
#define DATABASE_URL "REPLACE_WITH_YOUR_DATABASE_URL"</k>
<h4>Firebase Objects and Other Variables</h4>
First, you need to create a FirebaseData object (we called it stream) to handle the data when there's a change on a specific database path.
<k>FirebaseData stream;</k>
The next line defines a FirebaseAuth object needed for authentication.
<k>FirebaseAuth auth;</k>
Finally, the following line defines a FirebaseConfig object required for configuration data.
<k>FirebaseConfig config;</k>
<h4>Database Path</h4>
Then, create a variable that saves the database path where we'll be listening for changes. Taking into account the database structure we created previously, the listener database path should be as follows:
<k>String listenerPath = "board1/outputs/digital/";</k>
If you want to add more boards, then you just need to change the listener path accordingly.
Create variables for the outputs you'll control. In our case, we're controlling GPIOs 12, 13, and 14. You can control any other ESP32 GPIOs (you'll also need to change the database nodes):
<k>const int output1 = 12;
const int output2 = 13;
const int output3 = 14;</k>
<h4>initWifi()</h4>
The iniWifi() function connects the ESP32 to your local network. We'll call it later in the setup() to initialize Wi-Fi.
<k>// Initialize WiFi
void initWiFi() {
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  Serial.print("Connecting to WiFi ..");
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print('.');
    delay(1000);
  }
  Serial.println(WiFi.localIP());
  Serial.println();
}</k>
<h4>setup()</h4>
Let's now jump to the setup(). We'll take a look at the streamCallback() function later.
Initialize the Serial Monitor:
<k>Serial.begin(115200);</k>
Call the initiWiFi() function we created previously, to connect your board to your local network.
<k>initWiFi();</k>
Initialize the GPIOs as outputs.
<k>// Initialize Outputs
pinMode(output1, OUTPUT);
pinMode(output2, OUTPUT);
pinMode(output3, OUTPUT);</k>
Assign the API key to the Firebase configuration.
<k>config.api_key = API_KEY;</k>
The following lines assign the email and password to the Firebase authentication object.
<k>auth.user.email = USER_EMAIL;
auth.user.password = USER_PASSWORD;</k>
Assign the database URL to the Firebase configuration object.
<k>config.database_url = DATABASE_URL;</k>
Add the following to the configuration object.
<k>// Assign the callback function for the long running token generation task
config.token_status_callback = tokenStatusCallback; //see addons/TokenHelper.h
// Assign the maximum retry of token generation
config.max_token_generation_retry = 5;</k>
Initialize the Firebase library (authenticate) with the configuration and authentication settings we defined earlier.
<k>// Initialize the library with the Firebase authen and config
Firebase.begin(&config, &auth);</k>
<h4>Stream Database  Listening for Changes</h4>
Listening for changes on the database works with callback functions. This means, that when a change is detected on the database, a callback function will run.
The following line of code starts a stream to listen for changes on the listenerPath.
<k>if (!Firebase.RTDB.beginStream(&stream, listenerPath.c_str()))</k>
Then, set a callback function to be triggered whenever there's a change on the listenerPaththe streamCallback function.
<k>Firebase.RTDB.setStreamCallback(&stream, streamCallback, streamTimeoutCallback);</k>
<h4>streamCallback() function</h4>
Let's now take a look at the streamCallback function created previously.
When the streamCallback() function is triggered, an object called data of type FirebaseStream is passed automatically as an argument to that function. From that object, we can get the stream path, the data path (the full database path where the change occurred, including the value of the lowest child), the data type of that value, and the event type that triggered the stream.
<k>void streamCallback(FirebaseStream data){
  Serial.printf("stream path, %s\nevent path, %s\ndata type, %s\nevent type, %s\n\n",
                data.streamPath().c_str(),
                data.dataPath().c_str(),
                data.dataType().c_str(),
                data.eventType().c_str());
  printResult(data); //see addons/RTDBHelper.h
  Serial.println();
  // Get the path that triggered the function
  String streamPath = String(data.dataPath());</k>
 Then, from the obtained information, the ESP can run certain tasks, like updating the GPIO states.
When you change the value of the GPIO states on the database, the data returned by that event is an integer (in this case, 0 or 1). So, first, we check if the response is an integer:
<k>if (data.dataTypeEnum() == fb_esp_rtdb_data_type_integer){</k>
If it is, the event path corresponds to the GPIO node path, for example /12. From that path, we can get the GPIO number we want to change, we just need to cut the / from the string.
<k>String gpio = streamPath.substring(1);</k>
To better understand this, you can take a look at the following screenshot. It shows what you get when there's a change in the GPIOs states.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/streaming-database-Firebase-ESP-detect-changes.png">
We can get the value of the returned data as follows (knowing beforehand that it is an integer):
<k>int state = data.intData();</k>
Then, we can simply call the digitalWrite() function and pass as arguments the GPIO number and the state to keep the ESP32 output states updated.
<k>digitalWrite(gpio.toInt(), state);</k>
When the ESP first connects to the database, it is triggered on the root(/) path and returns a JSON object with all child nodes. So, we can get all values from the database and update the ESP32 GPIOs when it first runs. This is also useful because if the ESP32 resets, it will always receive this JSON object first, and will be able to update all GPIOs.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/streaming-database-Firebase-Serial-Monitor.png">
As you can see from the previous screenshot, the JSON object it receives looks as follows (it might be different depending on the GPIO states):
<k>{
  "12": 0,
  "13": 0,
  "14": 0
}</k>
When this happens, the returned data is of type JSON. So, we can get it with the following if statement:
<k>if (data.dataTypeEnum() == fb_esp_rtdb_data_type_json){</k>
We can convert the returned data to a FirebaseJSON object:
<k>FirebaseJson json = data.to&lt;FirebaseJson>();</k>
Then, we can iterate through the whole JSON object and get the keys (GPIOs) and corresponding values (GPIO states). In each iteration, we save the GPIO on the gpio variable and its corresponding state on the state variable. Then, we call the digitalWrite() function to update its state.
<k>// To iterate all values in Json object
size_t count = json.iteratorBegin();
Serial.println("\n---------");
for (size_t i = 0; i &lt; count; i++){
    FirebaseJson::IteratorValue value = json.valueAt(i);
    int gpio = value.key.toInt();
    int state = value.value.toInt();
    Serial.print("STATE: ");
    Serial.println(state);
    Serial.print("GPIO:");
    Serial.println(gpio);
    digitalWrite(gpio, state);
    Serial.printf("Name: %s, Value: %s, Type: %s\n", value.key.c_str(), value.value.c_str(), value.type == FirebaseJson::JSON_OBJECT ? "object" : "array");
}
Serial.println();
json.iteratorEnd(); // required for free the used memory in iteration (node data collection)</k>
This runs through all keys and values allowing us to update all GPIOs.
Because all our code works with callback functions, we don't need to place anything on the loop() besides the lines to refresh the Firebase token.
<k>void loop(){
  if (Firebase.isTokenExpired()){
    Firebase.refreshToken(&config);
    Serial.println("Refresh token");
  }
}</k>
If the ESP32 needs to perform other tasks, you can add them in the loop(). In our case, this example only listens for database changes.
<h3>Demonstration</h3>
After inserting all required credentials, upload the code to your board. 
After uploading, open the Serial Monitor at a baud rate of 115200 and reset the board. You should get something as shown below.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/streaming-database-Firebase-Serial-Monitor.png">
As you can see, when the ESP first runs, it gets a JSON object with all GPIO states.
<k>{
  "12": 0,
  "13": 0,
  "14": 0
}</k>
Then, go to the Firebase Realtime Database on the Firebase console. Manually change the GPIO states (either 0 or 1). After inserting a new value, press Enter.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/Firebase-Realtime-Database-save-ESP-output-states.png">
Right after, you'll see on the Serial Monitor that the ESP32 detected the changes.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/streaming-database-Firebase-ESP-detect-changes.png">
And it will update the GPIO states and light up the LEDs almost instantaneously.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/ESP32-Three-LEDs-Breadboard.jpg">
Then, if you reset your board (press the RST button or remove and apply power again), when it restarts, it will get the latest GPIO states from the database and updates them right away.
<h3>Taking it Further  Add More Boards</h3>
You can take this project further and add more boards. To do that, create new database nodes for a second board. You can add ESP32 or ESP8266 boards.
You can download the following JSON file and import it to your database, and it will create nodes for two boards:
<a href="https://github.com/RuiSantosdotme/Firebase-ESP/blob/main/ESP-Firebase-Control-GPIOs-Anywhere/database-outputs-multiple-boards.zip?raw=true" target="_blank">Download JSON file</a>
After uploading the JSON file, the database will look as follows:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/Firebase-RTDB-Save-Multiple-Boards-GPIO-States.png">
Now, you can upload the same code to the new board (it is compatible with the ESP32 and ESP8266). But <k>don't forget to change the listening path</k>. It should be: 
<k>String listenerPath = "<k>board2</k>/outputs/digital/";</k>
Now, you can control both boards by changing the GPIO states on the database.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/ESP32-ESP8266-Three-LEDs.jpg">
In Part 2, we'll create a Firebase web app so that you have a nice interface to control your GPIOs from anywhere without having to use the Firebase console and change the database manually:
<k>PART 2</k>: <a href="https://randomnerdtutorials.com/control-esp-gpios-firebase-web-app/">Control ESP32/ESP8266 GPIOs from Anywhere (Firebase Web App)</a>
<h3>Wrapping Up</h3>
In this tutorial, you learned how to use the Firebase Realtime Database to save the ESP GPIO states. You also learned how to program the ESP32 to listen for database changes. Whenever a change is detected, we updated the corresponding GPIO states. You can change the code so that the ESP listens for any other data saved on the database, not only GPIO states. Because you can access the Firebase Realtime Database from anywhere, you can control your boards from anywhere too. This is great for IoT projects.
In Part 2, we'll create a web app to control your GPIOs from anywhere, without the need to login manually on the Firebase console:
<k>PART 2</k>: <a href="https://randomnerdtutorials.com/control-esp-gpios-firebase-web-app/">Control ESP32/ESP8266 GPIOs from Anywhere (Firebase Web App)</a>
If you like Firebase projects, please take a look at our new eBook. We're sure you'll like it:
<k><a href="https://randomnerdtutorials.com/firebase-esp32-esp8266-ebook/">Firebase Web App with ESP32 and ESP8266</a></k>
<h2>WiFiMulti: Connect to the Strongest Wi-Fi Network (from a list of networks)</h2>
Learn how to use WiFiMulti with the ESP32. It allows you to register multiple networks (SSID/password combinations). The ESP32 will connect to the Wi-Fi network with the strongest signal (RSSI). If the connection is lost, it will connect to the next network on the list.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/ESP32-Wi-Fi-Multi.jpg">
Using WiFiMulti in your ESP32 IoT projects is useful if your board can have access to more than one Wi-Fi network. Implementing this feature in your projects is very simple and improves your projects significantly.
<h3>ESP32 with WiFiMulti</h3>
You can easily add WiFiMulti to your ESP32 projects with just a few lines of code. You can find an example in your Arduino IDE. With an ESP32 board select (Tools > Board), go to <k>File </k>> <k>Examples </k>> <k>WiFi </k>> <k>WifiMulti</k>. 
Here are the essential steps to use WiFiMulti with the ESP32.
<h3>Include Libraries</h3>
First, you need to include both WiFi.h and WiFiMulti.h libraries.
<k>#include &lt;WiFi.h>
#include &lt;WiFiMulti.h></k>
<h3>WiFiMulti Object</h3>
Then, you need to create a WiFiMulti object:
<k>WiFiMulti wifiMulti;</k>
<h3>Add List of Networks</h3>
Then, in the setup(), use the addAp() method on the wifiMulti object to add a network. The addAP() method accepts as arguments the network SSID and password. You should add at least one network.
<k>wifiMulti.addAP("ssid_from_AP_1", "your_password_for_AP_1");
wifiMulti.addAP("ssid_from_AP_2", "your_password_for_AP_2");
wifiMulti.addAP("ssid_from_AP_3", "your_password_for_AP_3");</k>
<h3>Connect to Wi-Fi</h3>
Finally, connect to Wi-Fi using the run() method. You can also print a message in case the Wi-Fi is disconnected.
<k>if(wifiMulti.run() != WL_CONNECTED) {
  Serial.println("WiFi not connected!");
  delay(1000);
}</k>
You can run this snippet on the loop() section and if the ESP32 gets disconnected from a Wi-Fi network, it will automatically try to connect to the next strongest network on the list.
<h3>ESP32 with WiFiMulti Example</h3>
For you to understand how WiFiMulti works with the ESP32, we created a simple example that does the following:
scans for available wi-fi networks and prints their RSSI (so that you can check that the ESP32 is actually connecting to the strongest network on the list);
connects to the strongest wi-fi network from a list of provided networks;
in case it loses connection with the network, it will automatically connect to the next strongest network on the list.
To test this, you can copy the following code to your Arduino IDE. It is based on the <a href="https://github.com/espressif/arduino-esp32/blob/master/libraries/WiFi/examples/WiFiScan/WiFiScan.ino" target="_blank">WiFiScan</a> and <a href="https://github.com/espressif/arduino-esp32/blob/master/libraries/WiFi/examples/WiFiMulti/WiFiMulti.ino" target="_blank">WiFiMulti </a>examples provided in the Arduino core examples for the ESP32.
<k>/*
 *  Based on the following examples:
 *  WiFi > WiFiMulti: https://github.com/espressif/arduino-esp32/blob/master/libraries/WiFi/examples/WiFiMulti/WiFiMulti.ino
 *  WiFi > WiFiScan: https://github.com/espressif/arduino-esp32/blob/master/libraries/WiFi/examples/WiFiScan/WiFiScan.ino
 *  Complete project details at our blog: https://RandomNerdTutorials.com/
 *  
 */
#include &lt;WiFi.h>
#include &lt;WiFiMulti.h>
WiFiMulti wifiMulti;
// WiFi connect timeout per AP. Increase when connecting takes longer.
const uint32_t connectTimeoutMs = 10000;
void setup(){
  Serial.begin(115200);
  delay(10);
  WiFi.mode(WIFI_STA);
  
  // Add list of wifi networks
  wifiMulti.addAP("ssid_from_AP_1", "your_password_for_AP_1");
  wifiMulti.addAP("ssid_from_AP_2", "your_password_for_AP_2");
  wifiMulti.addAP("ssid_from_AP_3", "your_password_for_AP_3");
  // WiFi.scanNetworks will return the number of networks found
  int n = WiFi.scanNetworks();
  Serial.println("scan done");
  if (n == 0) {
      Serial.println("no networks found");
  } 
  else {
    Serial.print(n);
    Serial.println(" networks found");
    for (int i = 0; i &lt; n; ++i) {
      // Print SSID and RSSI for each network found
      Serial.print(i + 1);
      Serial.print(": ");
      Serial.print(WiFi.SSID(i));
      Serial.print(" (");
      Serial.print(WiFi.RSSI(i));
      Serial.print(")");
      Serial.println((WiFi.encryptionType(i) == WIFI_AUTH_OPEN)?" ":"*");
      delay(10);
    }
  }
  // Connect to Wi-Fi using wifiMulti (connects to the SSID with strongest connection)
  Serial.println("Connecting Wifi...");
  if(wifiMulti.run() == WL_CONNECTED) {
    Serial.println("");
    Serial.println("WiFi connected");
    Serial.println("IP address: ");
    Serial.println(WiFi.localIP());
  }
}
void loop(){
  //if the connection to the stongest hotstop is lost, it will connect to the next network on the list
  if (wifiMulti.run(connectTimeoutMs) == WL_CONNECTED) {
    Serial.print("WiFi connected: ");
    Serial.print(WiFi.SSID());
    Serial.print(" ");
    Serial.println(WiFi.RSSI());
  }
  else {
    Serial.println("WiFi not connected!");
  }
  delay(1000);
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_WiFiMulti.ino" target="_blank">View raw code</a>
Don't forget to add a list of networks on the following lines. You can multiply those lines to add more networks.
<k>wifiMulti.addAP("ssid_from_AP_1", "your_password_for_AP_1");
wifiMulti.addAP("ssid_from_AP_2", "your_password_for_AP_2");
wifiMulti.addAP("ssid_from_AP_3", "your_password_for_AP_3");</k>
<k>Note: </k> if you want to test this project, but at the moment, you only have access to one network, you can create a hotspot with your smartphone and add the hotspot name and password to the list of available networks. I tested this with my iPhone and it worked perfectly (<k>you may need to remove spaces and special characters from the hotspot name</k>).
<h3>ESP32 with WiFiMulti Demonstration</h3>
After adding a list of networks to your code, you can upload it to your ESP32.
Open the Serial Monitor at a baud rate of 115200 and press the ESP32 RST button to restart the board.
First, it will show a list of nearby networks and corresponding RSSI. In my case, I have access to the first and third networks. In my case, the ESP32 connects to the iPhone network which is the strongest on the list (an RSSI closer to zero means a stronger signal).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/WiFi-Multi-Demonstration.png">
If I remove the iPhone hotspot, the connection will be lost and it will connect to the next strongest network on the list.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/WiFi-Multi-Demonstration-2.png">
<h3>Wrapping Up</h3>
In this tutorial, you learned how to use WiFiMulti with the ESP32 to add a list of networks that the ESP32 can connect to. It will connect to the network with the strongest signal (RSSI). If it loses connection with that network, it will automatically try to connect to the next network on the list.
We hope you find this tutorial useful. We have other tutorials related to Wi-Fi functions with the ESP32 that you may find useful:
<a href="https://randomnerdtutorials.com/esp32-useful-wi-fi-functions-arduino/">ESP32 Useful Wi-Fi Library Functions (Arduino IDE)</a>
<a href="https://randomnerdtutorials.com/solved-reconnect-esp32-to-wifi/">[SOLVED] Reconnect ESP32 to Wi-Fi Network After Lost Connection</a>
<h2>with Load Cell and HX711 Amplifier (Digital Scale)</h2>
In this guide, you'll learn how to create a scale with the ESP32 using a load cell and the HX711 amplifier. First, you'll learn how to wire the load cell and the HX711 amplifier to the ESP32 to build a scale. Then, we'll show you how to calibrate the scale, and a simple example to get the weight of objects. Later, we'll also add a display to show the measurements and a button to tare the scale.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/03/ESP32-load-cell-HX711-amplifier.jpg">
<k>Table of Contents</k>
In this tutorial, we'll cover the following topics:
Introducing Load Cells (Strain Gauges)
HX711 Amplifier
Setting Up Load Cell
Wiring Load Cell and HX711 Amplifier to the ESP32
Installing HX711 Library
Calibrating the Scale
Weighting Objects  Code
Digital Scale with ESP32
<h3>Introducing Load Cells</h3>
A load cell converts a force into an electrical signal that can be measured. The electrical signal changes proportionally to the force applied. There are different types of load cells: strain gauges, pneumatic, and hydraulic. In this tutorial, we'll cover strain gauge load cells.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/03/load-cell.jpg">
Strain gauge load cells are composed of a metal bar with attached strain gauges (under the white glue in the picture above). A strain gauge is an electrical sensor that measures force or strain on an object. The resistance of the strain gauges varies when an external force is applied to an object, which results in a deformation of the object's shape (in this case, the metal bar). The change of the resistance is proportional to the load applied, which allows us to calculate the weight of objects.
Usually, load cells have four strain gauges hooked up in a Wheatstone bridge (as shown below) that allow us to get accurate resistance measurements. For a more detailed explanation of how strain gauges work, <a href="https://www.allaboutcircuits.com/textbook/direct-current/chpt-9/strain-gauges/" target="_blank">read this article</a>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/03/load-cell-setup-scale-wheatstone-brifge-01.png">
The wires coming from the load cell usually have the following colors:
Red: VCC (E+)
Black: GND (E-)
White: Output  (A-)
Green: Output + (A+)
<k>Applications</k>
Strain gauge load cells can be used in a wide variety of applications. For example:
check if an object's weight changes over time;
measure the weight of an object;
detect the presence of an object;
estimate a container's liquid level;
etc.
Because the changes in strain when weighting objects are so small, we need an amplifier. The load cell we're using is usually sold together with an HX711 amplifier. So, that's the amplifier we'll use.
<h3>HX711 Amplifier</h3>
The HX711 amplifier is a breakout board that allows you to easily read load cells to measure weight. You wire the load cell wires on one side, and the microcontroller on the other side. The HX711 communicates with the microcontroller using two-wire interface (Clock and Data).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/03/hx711-amplifier.jpg">
You need to solder header pins on the GND, DT, SCK, and VCC pins to connect to the ESP32. I soldered the load cell wires directly to the E+, E-, A-, and A+ pins. The load cell wires were very thin and fragile, be careful when soldering to not damage the wires.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/03/hx711-amplifier-soldered.jpg">
 
For more information about the HX711 amplifier, you can <a href="https://cdn.sparkfun.com/datasheets/Sensors/ForceFlex/hx711_english.pdf" target="_blank">consult the HX711 datasheet</a>.
<h3>Setting Up the Load Cell</h3>
Our load cell kit came with two acrylic plates and some screws to set up the load cell as a scale. You can use wood plates or 3D-print your own plates.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/03/Load-cell-hx711-amplifier-package.jpg">
You should attach the plates to the load cell in a way that creates a strain between the opposite ends of the metal bar. The bottom plate holds the load cell, and the upper plate is where you place the objects.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/03/load-cell-setup-scale.png">
The following figure shows what my load cell with the acrylic plates looks like.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/03/load-cell-scale-arduino.jpg">
<h3>Where to Buy Load Cell with HX711?</h3>
You can check the load cell with the HX711 on Maker Advisor to find the best price (with or without acrylic plates included). There are load cells with different measurement ranges. The most common maximum weights are 1kg, 5kg, 10kg, and 20kg.
<a href="https://makeradvisor.com/tools/load-cell-hx711-amplifier/" target="_blank" rel="noopener"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/03/load-cell-hx711-amplifier-product.png"></a>
<a href="https://makeradvisor.com/tools/load-cell-hx711-amplifier/" target="_blank">Load Cell with HX711 Amplifier</a>
You can use the preceding links or go directly to <a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank">MakerAdvisor.com/tools</a> to find all the parts for your projects at the best price!
<a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/header-200.png?w=828&quality=100&strip=all&ssl=1" data-recalc-dims="1" loading="lazy" fetchpriority="low"></a>
<h3>Wiring Load Cell and HX711 Amplifier to the ESP32</h3>
The HX711 amplifier communicates via two-wire interface. You can connect it to any GPIOs of your chosen microcontroller. We're connecting the data pin (DT) to GPIO 16 and the clock pin (CLK) to GPIO 4. You can use any other suitable pins (check the <a href="https://randomnerdtutorials.com/esp32-pinout-reference-gpios/">ESP32 pinout guide</a>).
Follow the next table or schematic diagram to wire the load cell to the ESP32 board.
<table><tbody>
<tr>
<td><k>Load Cell</k></td>
<td><k>HX711</k></td>
<td><k>HX711</k></td>
<td><k>ESP32</k></td>
</tr>
<tr>
<td>
Red (E+)</td>
<td><k>E+</k></td>
<td><k>GND</k></td>
<td>GND</td>
</tr>
<tr>
<td>
Black (E-)</td>
<td><k>E-</k></td>
<td><k>DT</k></td>
<td>GPIO 16</td>
</tr>
<tr>
<td>
White (A-)</td>
<td><k>A-</k></td>
<td><k>SCK</k></td>
<td>GPIO 4</td>
</tr>
<tr>
<td>
Green (A+)</td>
<td><k>A+</k></td>
<td><k>VCC</k></td>
<td>3.3V</td>
</tr>
</tbody></table><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/03/ESP32-load-cell-diagram_bb.png">
<h3>Installing the HX711 Library</h3>
There are several different libraries to get measurements from a load cell using the HX711 amplifier. We'll use the <a href="https://github.com/bogde/HX711" target="_blank">HX711 library by bodge</a>. It is compatible with the ESP32, ESP8266, and Arduino.
<h3>Arduino IDE</h3>
Follow the next instructions to install the library if you're using Arduino IDE.
<ol>
Open Arduino IDE and go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k>.
Search for <k>HX711 Arduino Library</k> and install the library by Bogdan Necula.
</ol>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/03/Install-HX711-Bogdan-Library-Arduino-IDE.png">
 
<h3>VS Code with PlatformIO</h3>
If you're using VS Code with the PlatformIO extension to program your boards, follow the next instructions.
<ol>
After creating a new project on PlatformIO for your board, go to the PIO Home (click on the house icon on the bottom bar). Then, click on <k>Libraries</k>. Search for <k>HX711 </k>and select the Library by bodge.
Then, click on <k>Add to Project</k> and select the project you're working on.
</ol>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/03/Install-HX711-Bogdan-Library-PlatformIO.png">
Now, if you go to your project folder and open the platformio.ini file, there should be a line to include the library as follows:
<k>lib_deps = bogde/HX711@^0.7.5</k>
Also add the following line to change the Serial Monitor speed to 115200:
<k>monitor_speed = 115200</k>
<hr>
<h3>Calibrating the Scale (ESP32 with Load Cell)</h3>
At this time, we assume you have wired the load cell to the HX711 amplifier and the amplifier to the ESP32. You should also have your scale set up (two plates wired on opposite ends on the load cell), and have installed the HX711 library.
Before getting the weight of objects, you need to calibrate your load cell first by getting the <u>calibration factor</u>. Your calibration factor will be different than mine, so you shouldn't skip this section.
<k>1)</k> Prepare an object with a known weight. I used my kitchen scale and weighed a glass with water (300g).
<k>2)</k> Upload the following code to your ESP32. We wrote the following code taking into account the instructions to calibrate the load cell provided by the <a href="https://github.com/bogde/HX711#how-to-calibrate-your-load-cell" target="_blank">library documentation</a>.
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-load-cell-hx711/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
// Calibrating the load cell
#include &lt;Arduino.h>
#include "soc/rtc.h"
#include "HX711.h"
// HX711 circuit wiring
const int LOADCELL_DOUT_PIN = 16;
const int LOADCELL_SCK_PIN = 4;
HX711 scale;
void setup() {
  Serial.begin(115200);
  rtc_clk_cpu_freq_set(RTC_CPU_FREQ_80M);
  scale.begin(LOADCELL_DOUT_PIN, LOADCELL_SCK_PIN);
}
void loop() {
  if (scale.is_ready()) {
    scale.set_scale();    
    Serial.println("Tare... remove any weights from the scale.");
    delay(5000);
    scale.tare();
    Serial.println("Tare done...");
    Serial.print("Place a known weight on the scale...");
    delay(5000);
    long reading = scale.get_units(10);
    Serial.print("Result: ");
    Serial.println(reading);
  } 
  else {
    Serial.println("HX711 not found.");
  }
  delay(1000);
}
//calibration factor will be the (reading)/(known weight)
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_Load_Cell/ESP32_Calibrate_Load_Cell.ino" target="_blank">View raw code</a>
<k>3)</k> After uploading, open the Serial Monitor at a baud rate of 115200 and reset the ESP32 board.
<k>4)</k> Follow the instructions on the Serial Monitor: remove any weights from the scale (it will tare automatically). Then, place an object with a known weight on the scale and wait until you get a value.
<k>5)</k> Calculate your calibration factor using the formula:
<k>calibration factor = (reading)/(known weight)</k>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/03/calibrate-load-cell-arduino-ide.png">
 In our case, the reading is -141449. The known weight is 300g, so our calibration factor will be: -141449/300 = -471.497.
<k>calibration factor = -141449/300 = -471.497</k>
Save your calibration factor because you'll need it later. Yours will be different than ours.
Because the output of the sensor is proportional to the force applied to the load cell, you can calibrate your scale using whatever unit makes sense for you. I used grams, but you can use pounds, kilograms, or even pieces of cat food (<a href="https://youtu.be/iywsJB-T-mU" target="_blank">as in this Andreas Spiess video</a>).
<hr>
<h3>Weighting Objects (ESP32 with Load Cell)</h3>
Now that you know your calibration factor, you can use your load cell to weight objects. Start by weighing objects with a known weight and repeat the calibration process if the values are not accurate.
Copy the following code to your Arduino IDE. Before uploading it to your board, don't forget to insert your calibration factor in line 43/44 of the code. The following code is the <a href="https://github.com/bogde/HX711/blob/master/examples/HX711_full_example/HX711_full_example.ino" target="_blank">example provided by the library</a> that demonstrates the use of most of its functions.
<k>/*
 * Complete project details at https://RandomNerdTutorials.com/esp32-load-cell-hx711/
 *
 * HX711 library for Arduino - example file
 * https://github.com/bogde/HX711
 *
 * MIT License
 * (c) 2018 Bogdan Necula
 *
**/
#include &lt;Arduino.h>
#include "HX711.h"
#include "soc/rtc.h"
// HX711 circuit wiring
const int LOADCELL_DOUT_PIN = 16;
const int LOADCELL_SCK_PIN = 4;
HX711 scale;
void setup() {
  Serial.begin(115200);
  rtc_clk_cpu_freq_set(RTC_CPU_FREQ_80M);
  Serial.println("HX711 Demo");
  Serial.println("Initializing the scale");
  scale.begin(LOADCELL_DOUT_PIN, LOADCELL_SCK_PIN);
  Serial.println("Before setting up the scale:");
  Serial.print("read: \t\t");
  Serial.println(scale.read());      // print a raw reading from the ADC
  Serial.print("read average: \t\t");
  Serial.println(scale.read_average(20));   // print the average of 20 readings from the ADC
  Serial.print("get value: \t\t");
  Serial.println(scale.get_value(5));   // print the average of 5 readings from the ADC minus the tare weight (not set yet)
  Serial.print("get units: \t\t");
  Serial.println(scale.get_units(5), 1);  // print the average of 5 readings from the ADC minus tare weight (not set) divided
            // by the SCALE parameter (not set yet)
            
  scale.set_scale(INSERT YOUR CALIBRATION FACTOR);
  //scale.set_scale(-471.497);                      // this value is obtained by calibrating the scale with known weights; see the README for details
  scale.tare();               // reset the scale to 0
  Serial.println("After setting up the scale:");
  Serial.print("read: \t\t");
  Serial.println(scale.read());                 // print a raw reading from the ADC
  Serial.print("read average: \t\t");
  Serial.println(scale.read_average(20));       // print the average of 20 readings from the ADC
  Serial.print("get value: \t\t");
  Serial.println(scale.get_value(5));   // print the average of 5 readings from the ADC minus the tare weight, set with tare()
  Serial.print("get units: \t\t");
  Serial.println(scale.get_units(5), 1);        // print the average of 5 readings from the ADC minus tare weight, divided
            // by the SCALE parameter set with set_scale
  Serial.println("Readings:");
}
void loop() {
  Serial.print("one reading:\t");
  Serial.print(scale.get_units(), 1);
  Serial.print("\t| average:\t");
  Serial.println(scale.get_units(10), 5);
  scale.power_down();             // put the ADC in sleep mode
  delay(5000);
  scale.power_up();
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_Load_Cell/ESP32_Test_Load_Cell.ino" target="_blank">View raw code</a>
<h3>How the Code Works</h3>
Start by including the required libraries. We've included Arduino.h in case you're using PlatformIO instead of Arduino IDE.
<k>#include &lt;Arduino.h>
#include "HX711.h"
#include "soc/rtc.h"</k>
<k>Note:</k> we've read in some places that you need to slow down the ESP32 processor because of the HX711 frequency. I'm not sure if this is really needed or not. We've experimented with and without slowing down and everything worked fine in both scenarios. Nonetheless, we've added that option to the code. You can always remove it. To do that you need to include soc/rtc.h.
The following lines define the GPIOs you'll use to connect to the HX711 amplifier. We chose GPIOs 16 and 4. You can use any other suitable GPIOs.
<k>const int LOADCELL_DOUT_PIN = 16;
const int LOADCELL_SCK_PIN = 4;</k>
Then, create an instance of the HX711 library called scale that you'll use later on to get the measurements.
<k>HX711 scale;</k>
<h4>setup()</h4>
In the setup(), initialize the Serial monitor.
<k>Serial.begin(115200);</k>
Slow down the ESP32 processor.
<k>rtc_clk_cpu_freq_set(RTC_CPU_FREQ_80M);</k>
Initialize the load cell by calling the begin() method on the scale object and passing the GPIOs as arguments.
<k>scale.begin(LOADCELL_DOUT_PIN, LOADCELL_SCK_PIN);</k>
Then, it calls several methods that you can use to get readings using the library.
read(): gets a raw reading from the sensor
read_average(number of readings): gets the average of the latest defined number of readings
get_value(number of readings): gets the average of the last defined number of readings minus the tare weight;
get_units(number of readings): gets the average of the last defined number of readings minus the tare weight divided by the calibration factor  this will output a reading in your desired units.
<k>Serial.println("Before setting up the scale:");
Serial.print("read: \t\t");
Serial.println(scale.read());      // print a raw reading from the ADC
Serial.print("read average: \t\t");
Serial.println(scale.read_average(20));   // print the average of 20 readings from the ADC
Serial.print("get value: \t\t");
Serial.println(scale.get_value(5));   // print the average of 5 readings from the ADC minus the tare weight (not set yet)
Serial.print("get units: \t\t");
Serial.println(scale.get_units(5), 1);  // print the average of 5 readings from the ADC minus tare weight (not set) divided
// by the SCALE parameter (not set yet)</k>
In the following line, don't forget to insert your calibration factor. It uses the set_scale() method.
<k>scale.set_scale(INSERT YOUR CALIBRATION FACTOR)</k>
Then, call the tare() method to tare the scale.
<k>scale.tare();               // reset the scale to 0</k>
After this setup, the scale should be ready to get accurate readings in your desired unit. The example calls the same previous methods so that you can see the difference before and after setting up the scale.
<k>Serial.print("read: \t\t");
Serial.println(scale.read());                 // print a raw reading from the ADC
Serial.print("read average: \t\t");
Serial.println(scale.read_average(20));       // print the average of 20 readings from the ADC
Serial.print("get value: \t\t");
Serial.println(scale.get_value(5));   // print the average of 5 readings from the ADC minus the tare weight, set with tare()
Serial.print("get units: \t\t");
Serial.println(scale.get_units(5), 1);        // print the average of 5 readings from the ADC minus tare weight, divided
// by the SCALE parameter set with set_scale</k>
<h4>loop()</h4>
In the loop(), the example calls the get_units() method in two different ways: to get one single readings (without any parameters) and to get the average of the last 10 readings.
<k>Serial.print("one reading:\t");
Serial.print(scale.get_units(), 1);
Serial.print("\t| average:\t");
Serial.println(scale.get_units(10), 5);</k>
It shuts down the ADC that reads the sensor by using the power_down() method. Then, it waits for 5 seconds, powers up the ADC (power_up()), and the loop() repeats. So, you'll get new readings on the Serial Monitor every 5 seconds.
<k>scale.power_down();             // put the ADC in sleep mode
delay(5000);
scale.power_up();</k>
<h3>Demonstration</h3>
Upload the code to your ESP32 board. After uploading, open the Serial Monitor at a baud rate of 115200. 
Let the code run a few seconds so that it has time to set up the scale (you'll see the message on the Serial Monitor). Then, place any object on the scale to measure it and you'll get the results on the Serial Monitor.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/03/ESP32-scale-demonstration.png">
I experimented with several objects and compared them against the value on my kitchen scale, and the results were the same. So, I can say that my ESP32 scale is at least as accurate as my kitchen scale.
<hr>
<h3>Digital Scale with ESP32</h3>
In this section, we'll create a simple digital scale with the ESP32. We'll add an OLED display to show the results and a pushbutton to tare the scale.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/03/ESP32-digital-scale.jpg">
<h3>Parts Required</h3>
Here's a list of the parts required for this project:
<a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32 </a>(read <a href="https://makeradvisor.com/esp32-development-boards-review-comparison/" target="_blank">Best ESP32 Development Boards</a>)
<a href="https://makeradvisor.com/tools/load-cell-hx711-amplifier/" target="_blank">Load Cell with HX711 Amplifier</a>
<a href="https://makeradvisor.com/tools/oled-display-128x64-0-96-inch/" target="_blank">I2C SSD1306 OLED Display</a>
<a href="https://makeradvisor.com/tools/pushbuttons-kit/" target="_blank">Pushbutton</a>
<a href="https://makeradvisor.com/tools/resistors-kits/" target="_blank">10K Ohm Resistor</a>
<a href="https://makeradvisor.com/tools/mb-102-solderless-breadboard-830-points/" target="_blank">Breadboard</a>
<a href="https://makeradvisor.com/tools/jumper-wires-kit-120-pieces/" target="_blank">Jumper Wires</a>
<h3>Schematic Diagram</h3>
Add an OLED display and a pushbutton to your previous circuit on the following pins:
<table><tbody>
<tr>
<td><k>OLED Display</k></td>
<td><k>ESP32</k></td>
</tr>
<tr>
<td>VCC</td>
<td>3.3V or 5V*</td>
</tr>
<tr>
<td>GND</td>
<td>GND</td>
</tr>
<tr>
<td>SDA</td>
<td>GPIO 21</td>
</tr>
<tr>
<td>SCL</td>
<td>GPIO 22</td>
</tr>
</tbody></table>*connect to 3.3V or 5V depending on the model.
Not familiar with the OLED display? Read: <a href="https://randomnerdtutorials.com/esp32-ssd1306-oled-display-arduino-ide/">ESP32 OLED Display with Arduino IDE</a>
Wire the pushbutton via a 10kOhm pull-down resistor to GPIO 19. The other lead of the pushbutton should be connected to 3.3V. You can use any other suitable GPIO (<a href="https://randomnerdtutorials.com/esp32-pinout-reference-gpios/">check the ESP32 pinout guide</a>). 
You can follow the next schematic diagram to wire your parts.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/03/ESP32-digital-scale_wiring.png">
<h3>ESP32 Digital Scale  Code</h3>
For simplicity, we'll handle the pushbutton using a simple library that detects button presses with debouncing (so we don't need to worry about that in our code). To write to the OLED display, we'll use the <a href="https://github.com/adafruit/Adafruit_SSD1306" target="_blank">Adafruit SSD1306</a> and <a href="https://github.com/adafruit/Adafruit-GFX-Library" target="_blank">Adafruit GFX</a> libraries.
<h4>Pushbutton Library</h4>
There are many libraries with many functionalities to handle pushbuttons. We'll use the <a href="https://github.com/pololu/pushbutton-arduino" target="_blank">pushbutton library by polulu</a>. It is a simple library but comes with everything we need for this project. In your Arduino IDE, go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k> and search for <k>pushbutton</k>. Install the pushbutton library by polulu.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/03/pushbutton-library-polulu-arduino-ide.png">
Alternatively, if you don't want to use the library you can add the debounce code yourself (which is not difficult). For a debounce code example, in the Arduino IDE, you can go to File > Examples > Digital > Debounce. 
<h4>OLED Libraries</h4>
We'll use the following libraries to control the OLED display. Make sure you have these libraries installed:
<a href="https://github.com/adafruit/Adafruit_SSD1306" target="_blank">Adafruit_SSD1306 library</a>
<a href="https://github.com/adafruit/Adafruit-GFX-Library" target="_blank">Adafruit_GFX library</a>
You can install the libraries using the Arduino Library Manager. Go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k> and search for the library name.
<h4>Installing Libraries  PlatformIO</h4>
If you're using VS Code with the PlatformIO extension, follow the next steps to install the library:
<ol>
After creating a new project on PlatformIO for your board, go to the PIO Home (click on the house icon on the bottom bar). Then, click on <k>Libraries</k>. Search for <k>pushbutton</k> and select the Pushbutton library by Polulu.
Then, click on <k>Add to Project</k> and select the project you're working on.
Repeat the process for the <k>Adafruit SSD1306</k> and <k>Adafruit GFX</k> libraries. Also, don't forget to add the <k>HX711</k> library too.
</ol>
In your platformio.ini file, you should have the following lines that include all the required libraries (also change the Serial Monitor speed to 115200).
<k>monitor_speed = 115200
lib_deps = 
bogde/HX711@^0.7.5
pololu/Pushbutton@^2.0.0
        adafruit/Adafruit SSD1306@^2.4.6
adafruit/Adafruit GFX Library@^1.10.10</k>
<h3>Code</h3>
Copy the following code to your Arduino IDE. Before uploading it to the ESP32, you need to insert your calibration factor (obtained previously).
<k>/*
  Rui Santos
  Complete project details at https://RandomNerdTutorials.com/esp32-load-cell-hx711/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files.
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
*/
// Library HX711 by Bogdan Necula: https://github.com/bogde/HX711
// Library: pushbutton by polulu: https://github.com/pololu/pushbutton-arduino
#include &lt;Arduino.h>
#include "HX711.h"
#include "soc/rtc.h"
#include &lt;Wire.h>
#include &lt;Adafruit_GFX.h>
#include &lt;Adafruit_SSD1306.h>
#include &lt;Pushbutton.h>
// HX711 circuit wiring
const int LOADCELL_DOUT_PIN = 16;
const int LOADCELL_SCK_PIN = 4;
HX711 scale;
int reading;
int lastReading;
//REPLACE WITH YOUR CALIBRATION FACTOR
#define CALIBRATION_FACTOR -471.497
//OLED Display
#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 64 // OLED display height, in pixels
// Declaration for an SSD1306 display connected to I2C (SDA, SCL pins)
#define OLED_RESET     -1 // Reset pin # (or -1 if sharing Arduino reset pin)
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);
//Button
#define BUTTON_PIN 19
Pushbutton button(BUTTON_PIN);
void displayWeight(int weight){
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(WHITE);
  display.setCursor(0, 10);
  // Display static text
  display.println("Weight:");
  display.display();
  display.setCursor(0, 30);
  display.setTextSize(2);
  display.print(weight);
  display.print(" ");
  display.print("g");
  display.display();  
}
void setup() {
  Serial.begin(115200);
  rtc_clk_cpu_freq_set(RTC_CPU_FREQ_80M);
  if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { 
    Serial.println(F("SSD1306 allocation failed"));
    for(;;);
  }
  delay(2000);
  display.clearDisplay();
  display.setTextColor(WHITE);
  
  Serial.println("Initializing the scale");
  scale.begin(LOADCELL_DOUT_PIN, LOADCELL_SCK_PIN);
  scale.set_scale(CALIBRATION_FACTOR);   // this value is obtained by calibrating the scale with known weights; see the README for details
  scale.tare();               // reset the scale to 0
}
void loop() {
  if (button.getSingleDebouncedPress()){
    Serial.print("tare...");
    scale.tare();
  }
  
  if (scale.wait_ready_timeout(200)) {
    reading = round(scale.get_units());
    Serial.print("Weight: ");
    Serial.println(reading);
    if (reading != lastReading){
      displayWeight(reading); 
    }
    lastReading = reading;
  }
  else {
    Serial.println("HX711 not found.");
  }
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_Load_Cell/ESP32_Digital_Scale.ino" target="_blank">View raw code</a>
<h3>How the Code Works</h3>
Start by including the required libraries:
<k>#include &lt;Arduino.h>
#include "HX711.h"
#include "soc/rtc.h"
#include &lt;Wire.h>
#include &lt;Adafruit_GFX.h>
#include &lt;Adafruit_SSD1306.h>
#include &lt;Pushbutton.h></k>
Define the pins for the HX711 (load cell)we're using the same as previous examples:
<k>// HX711 circuit wiring
const int LOADCELL_DOUT_PIN = 16;
const int LOADCELL_SCK_PIN = 4;</k>
Create an HX711 instance called scale.
<k>HX711 scale;</k>
The following variables will hold the current weight reading and the last weight reading. We only want to update the OLED display in case there's a new reading, so that's why we need these two variables. Additionally, we don't want to measure decimals of grams which will make the scale too sensitive for our applicationthat's why these variables are integers. If you need decimals in your measurements, you can define float variables instead.
<k>int reading;
int lastReading;</k>
Don't forget to replace the next value with your calibration factor. In my case, that line of code looks as follows (my value is negative):
<k>#define CALIBRATION_FACTOR -471.497</k>
Next, we need to define the OLED width and height:
<k>#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 64 // OLED display height, in pixels</k>
And create an instance of the Adafruit_SSD1306 library called display.
<k>Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);</k>
Define the GPIO you'll use to read the button and create a Pushbutton object called button on that pin.
<k>#define BUTTON_PIN 19
Pushbutton button(BUTTON_PIN);</k>
<h4>displayWeight() function</h4>
We created a function called displayWeight() that accepts as arguments the weight you want to display on the OLED.
<k>void displayWeight(int weight){
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(WHITE);
  display.setCursor(0, 10);
  // Display static text
  display.println("Weight:");
  display.display();
  display.setCursor(0, 30);
  display.setTextSize(2);
  display.print(weight);
  display.print(" ");
  display.print("g");
  display.display();  
}</k>
Not familiar with the OLED display? Read: <a href="https://randomnerdtutorials.com/esp32-ssd1306-oled-display-arduino-ide/">ESP32 OLED Display with Arduino IDE</a>.
<h4>setup()</h4>
In the setup(), initialize the Serial Monitor.
<k>Serial.begin(115200);</k>
Initialize the OLED display:
<k>if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { 
  Serial.println(F("SSD1306 allocation failed"));
  for(;;);
}
delay(2000);
display.clearDisplay();
display.setTextColor(WHITE);</k>
And finally, initialize the load cell:
<k>Serial.println("Initializing the scale");
scale.begin(LOADCELL_DOUT_PIN, LOADCELL_SCK_PIN);
scale.set_scale(CALIBRATION_FACTOR);   // this value is obtained by calibrating the scale with known weights
scale.tare();               // reset the scale to 0</k>
<h4>loop()</h4>
The pushbutton library allows us to wait for an event in case of a pushbutton press or pushbutton release. In this case, we check whether the pushbutton was pushed using the getSingleDebouncePress() method and call the tare() function if the button was pressed.
<k>if (button.getSingleDebouncedPress()){
  Serial.print("tare...");
  scale.tare();
}</k>
The HX711 provides a <a href="https://github.com/bogde/HX711#non-blocking-mode" target="_blank">non-blocking method to get readings</a>. It defines a maximum timeout to wait for the hardware to be initialized and doesn't block your code in case the scale gets disconnected or in case of hardware failures.
<k>if (scale.wait_ready_timeout(200)) {
    reading = round(scale.get_units());
    Serial.print("Weight: ");
    Serial.println(reading);</k>
In the loop(), we are constantly getting new readings and checking them against the latest reading. If we got a new measurement, we call the displayWeight() function to update the OLED display.
<k>if (reading != lastReading){
  displayWeight(reading); 
}</k>
<h3>Demonstration</h3>
After uploading the code to your board, you can start weighing objects with your load cell. The readings will show up on the OLED display. You can tare the scale by pressing the pushbutton.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/03/ESP32-digital-scale-demonstration.jpg">
Once again, the readings on my ESP32 digital scale correspond to the readings on my kitchen scale.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/03/digital-scale-kitchen.jpg">
<h3>Wrapping Up</h3>
In this tutorial, you learned how to interface a strain gauge load cell with the ESP32 using the HX711 amplifier. The output of the load cell is proportional to the force applied. So, you can calibrate it to be used in g, kg, ib, or any other unit that makes sense for your project.
In summary, you learned how to calibrate the scale and how to get the weight of objects. You also learned how to create a simple digital scale with the ESP32 using an OLED display to show the measurements and a pushbutton to tare the scale.
<h2>Install ESP32 Filesystem Uploader in Arduino IDE</h2>
The ESP32 contains a Serial Peripheral Interface Flash File System (SPIFFS). SPIFFS is a lightweight filesystem created for microcontrollers with a flash chip, which is connected by SPI bus, like the ESP32 flash memory. In this article we're going to show how to easily upload files to the ESP32 filesystem using a plugin for Arduino IDE.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2018/10/Install-ESP32-Filesystem-Uploader-Arduino-IDE.jpg">
<k>Note: </k> if you have an ESP8266 board, read: <a href="https://randomnerdtutorials.com/install-esp8266-nodemcu-littlefs-arduino/">Install ESP8266 NodeMCU LittleFS Filesystem Uploader in Arduino IDE</a>.
At the moment, this is not compatible with Arduino 2.0.
If you're using VS Code with the PlatformIO extension, read the following tutorial instead:
<a href="https://randomnerdtutorials.com/esp32-vs-code-platformio-spiffs/">ESP32 with VS Code and PlatformIO: Upload Files to Filesystem (SPIFFS)</a>
<k>Table of Contents</k>
Introducing SPIFFS
Installing the Arduino ESP32 Filesystem Uploader
Windows Instructions
MacOS X Instructions
Uploading Files using the Filesystem Uploader
Testing the Uploader
<h3>Introducing SPIFFS</h3>
SPIFFS lets you access the flash memory like you would do in a normal filesystem in your computer, but simpler and more limited. You can read, write, close, and delete files. At the time of writing this post, SPIFFS doesn't support directories, so everything is saved on a flat structure.
Using SPIFFS with the <a aria-label="ESP32 board (opens in a new tab)" href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32 board</a> is especially useful to:
Create configuration files with settings;
Save data permanently;
Create files to save small amounts of data instead of using a microSD card;
<a href="https://randomnerdtutorials.com/esp32-web-server-spiffs-spi-flash-file-system/">Save HTML and CSS files to build a web server</a>;
<a href="https://randomnerdtutorials.com/display-images-esp32-esp8266-web-server/">Save images, figures, and icons</a>;
And much more.
With SPIFFS, you can write the HTML and CSS in separate files and save them on the ESP32 filesystem. Check the following tutorial to learn how to build a web server with files stored on the ESP32 file system:
<a href="https://randomnerdtutorials.com/esp32-web-server-spiffs-spi-flash-file-system/">ESP32 Web Server using SPIFFS (SPI Flash File System)</a>
<h3>Installing the Arduino ESP32 Filesystem Uploader</h3>
You can create, save and write files to the ESP32 filesystem by writing the code yourself on the Arduino IDE. This is not very useful, because you'd have to type the content of your files in the Arduino sketch.
Fortunately, there is a plugin for the Arduino IDE that allows you to upload files directly to the ESP32 filesystem from a folder on your computer. This makes it really easy and simple to work with files. Let's install it.
<k>Note: </k> at the time of writing this post, the ESP32 Filesystem Uploader plugin is not supported on Arduino 2.0.
First, make sure you have the ESP32 add-on for the Arduino IDE. If you don't, follow the next tutorial:
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/"><k>Windows, Mac, and Linux</k> instructions  Installing the ESP32 Board in Arduino IDE</a>
<h3>Windows Instructions</h3>
Follow the next steps to install the filesystem uploader if you're using Windows:
<k>1)</k> Go to the <a href="https://github.com/me-no-dev/arduino-esp32fs-plugin/releases/" target="_blank" aria-label=" (opens in a new tab)">releases page and click the ESP32FS-1.0.zip</a> file to download.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/07/ESP32-SPIFFS-Download-installer.png">
<k>2)</k> Find your Sketchbook location. In your Arduino IDE, go to <k>File</k> > <k>Preferences</k> and check your Sketchbook location. In my case, it's in the following path: C:\Users\sarin\Documents\Arduino.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2018/10/Arduino-Sketchbook-location.png">
<k>3)</k> Go to the sketchbook location, and create a <k>tools </k>folder.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2018/10/creating-tools-folder-sketchbook-location.png">
<k>4)</k> Unzip the downloaded <em>.zip</em> folder. Open it and copy the <em><k>ESP32FS </k></em>folder to the <k>tools</k> folder you created in the previous step. You should have a similar folder structure:
<k>&lt;Sketchbook-location>/<k>tools/ESP32FS/tool/esp32fs.jar</k></k>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2018/10/install-filesystem-plugin-folder-structure.png">
<k>5)</k> Finally, restart your Arduino IDE.
To check if the plugin was successfully installed, open your Arduino IDE. Select your ESP32 board, go to <k>Tools </k>and check that you have the option <k>ESP32 Sketch Data Upload</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2018/10/sketch-data-upload.png">
<h3>MacOS X</h3>
Follow the next instructions if you're using MacOS X.
<k>1)</k> Go to the <a href="https://github.com/me-no-dev/arduino-esp32fs-plugin/releases/" target="_blank" aria-label=" (opens in a new tab)">releases page and click the ESP32FS-1.0.zip</a> file to download.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/07/ESP32-SPIFFS-Download-installer.png">
<k>2)</k> Unpack the files. 
<k>3)</k> Create a folder called <k>tools</k> in /Documents/Arduino/.
<k>4)</k> Copy the unpacked <k><em>ESP32FS </em></k>folder to the <k>tools</k> directory. You should have a similar folder structure.
<k>~Documents/Arduino/<k>tools/ESP32FS/tool/esp32fs.jar</k></k>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2018/10/install-filesystem-plugin-folder-structure-mac-os-X.png">
<k>5)</k> Finally, restart your Arduino IDE.
To check if the plugin was successfully installed, open your Arduino IDE. Select your ESP32 board, go to <k>Tools </k>and check that you have the option <k>ESP32 Sketch Data Upload</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/04/ESP32-Data-Sketch-Upload-Menu-Arduino-IDE-Mac-OS.png">
<a href="https://github.com/me-no-dev/arduino-esp32fs-plugin#usage"></a>
<h3>Uploading Files using the Filesystem Uploader</h3>
To upload files to the ESP32 filesystem follow the next instructions.
<k>1)</k> Create an Arduino sketch and save it. For demonstration purposes, you can save an empty sketch.
<k>2)</k> Then, open the sketch folder. You can go to <k>Sketch </k>> <k>Show Sketch Folder</k>. The folder where your sketch is saved should open.
<img class="lazy" data-src="https://i0.wp.com/rntlab.com/wp-content/uploads/2018/09/show-sketch-folder.png?w=828&quality=100&strip=all&ssl=1" alt="Arduino IDE Show Sketch folder to create data folder" data-recalc-dims="1" loading="lazy" fetchpriority="low">
<k>3)</k> Inside that folder, create a new folder called <em><k>data</k></em>.
<img class="lazy" data-src="https://i0.wp.com/rntlab.com/wp-content/uploads/2018/09/data.fodler.png?w=828&quality=100&strip=all&ssl=1" alt="ESP32 Arduino Sketch Example File Filesystem fs SPIFFS" data-recalc-dims="1" loading="lazy" fetchpriority="low">
<k>4)</k> Inside the <k><em>data</em> </k>folder is where you should put the files you want to save into the ESP32 filesystem. As an example, create a <em>.txt</em> file with some text called <em>test_example</em>.
<img class="lazy" data-src="https://i0.wp.com/rntlab.com/wp-content/uploads/2018/09/text_txt.png?w=828&quality=100&strip=all&ssl=1" alt="ESP32 Notepad Test Example File Filesystem fs SPIFFS" data-recalc-dims="1" loading="lazy" fetchpriority="low">
<k>5)</k> Then, to upload the files, in the Arduino IDE, you just need to go to <k>Tools </k>> <k>ESP32 Sketch Data Upload</k>.
<img class="lazy" data-src="https://i0.wp.com/rntlab.com/wp-content/uploads/2018/09/sketch-data-upload.png?w=828&quality=100&strip=all&ssl=1" alt="ESP32 Sketch Data Upload Arduino IDE SPIFFS FS Filesystem" data-recalc-dims="1" loading="lazy" fetchpriority="low">
The uploader will overwrite anything you had already saved in the filesystem.
<k>Note</k>: in some ESP32 development boards you need to press the on-board <k>BOOT </k>button when you see the Connecting .____ message.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2018/10/connecting.png">
The files were successfully uploaded to the ESP32 filesystem when you see the message <k>SPIFFS Image Uploaded</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2018/10/spiffs-uploaded.png">
<h3>Testing the Uploader</h3>
Now, let's just check if the file was actually saved into the ESP32 filesystem. Simply upload the following code to your ESP32 board.
<k>/*********
  Rui Santos
  Complete project details at https://randomnerdtutorials.com  
*********/
#include "SPIFFS.h"
 
void setup() {
  Serial.begin(115200);
  
  if(!SPIFFS.begin(true)){
    Serial.println("An Error has occurred while mounting SPIFFS");
    return;
  }
  
  File file = SPIFFS.open("/test_example.txt");
  if(!file){
    Serial.println("Failed to open file for reading");
    return;
  }
  
  Serial.println("File Content:");
  while(file.available()){
    Serial.write(file.read());
  }
  file.close();
}
 
void loop() {
}
</k>
<a href="https://github.com/RuiSantosdotme/ESP32-Course/raw/master/code/SPIFFS/SPIFFS_Test/SPIFFS_Test.ino" target="_blank">View raw code</a>
After uploading, open the Serial Monitor at a baud rate of 115200. Press the ESP32 <k>ENABLE</k>/<k>RST</k> button. It should print the content of your <em>.txt</em> file on the Serial Monitor.
<img class="lazy" data-src="https://i0.wp.com/rntlab.com/wp-content/uploads/2018/09/testing-file-system-serial-monitor.png?w=828&quality=100&strip=all&ssl=1" alt="ESP32 SPIFFS FS Filesystem Example Arduino IDE Serial Monitor" data-recalc-dims="1" loading="lazy" fetchpriority="low">
You've successfully uploaded files to the ESP32 filesystem using the plugin.
<h3>Wrapping Up</h3>
Using the filesystem uploader plugin is one of the easiest ways to upload files to the ESP32 filesystem. Check the following project to see how to build a web server using HTML and CSS files stored on the filesystem: <a href="https://randomnerdtutorials.com/esp32-web-server-spiffs-spi-flash-file-system/">ESP32 Web Server using SPIFFS (SPI Flash File System)</a>.
Another way to save data permanently is using the ESP32 Preferences library. It is especially useful to save data as key:value pairs in the flash memory. Check the following tutorial:
<a href="https://randomnerdtutorials.com/esp32-save-data-permanently-preferences/"> ESP32 Save Data Permanently using Preferences Library</a>
For more projects with ESP32, check the following resources:
<k><a href="https://randomnerdtutorials.com/learn-esp32-with-arduino-ide/"></a><a href="https://randomnerdtutorials.com/learn-esp32-with-arduino-ide/">Learn ESP32 with Arduino IDE</a></k>
<k><a href="https://randomnerdtutorials.com/learn-esp32-with-arduino-ide/"></a><a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/">Build Web Servers with ESP32 and ESP8266</a></k>
<k><a href="https://randomnerdtutorials.com/learn-esp32-with-arduino-ide/"></a><a href="https://randomnerdtutorials.com/firebase-esp32-esp8266-ebook/">Firebase Web App with ESP32 and ESP8266</a></k>
<k><a href="https://randomnerdtutorials.com/learn-esp32-with-arduino-ide/"></a><a href="https://randomnerdtutorials.com/projects-esp32/">Free ESP32 Projects and Tutorials</a></k>
<center><a href="https://randomnerdtutorials.com/pcbway" target="_blank"><img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/2022/03/728x280.jpg" width="728" height="280" loading="lazy" fetchpriority="low"></a></center>
<a href="https://randomnerdtutorials.com/smart-home-ebook/">
<img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/elementor/thumbs/Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px-pupj8i6e7hlzpgwxe82jjd8skst9vmrjt9lpqb0v0g.jpg" title="Smart-Home-Raspberry-Pi-ESP32-ESP8266-eBook500px" alt="SMART HOME with Raspberry Pi ESP32 and ESP8266 Node-RED InfluxDB eBook" loading="lazy" width="117" height="180" fetchpriority="low"></a>
<h4><a href="https://randomnerdtutorials.com/smart-home-ebook/">SMART HOME with Raspberry Pi, ESP32, ESP8266 [eBook] </a></h4>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
Learn how to build a home automation system and we'll cover the following main subjects: Node-RED, Node-RED Dashboard, Raspberry Pi, ESP32, ESP8266, MQTT, and InfluxDB database <k><a href="https://randomnerdtutorials.com/smart-home-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
<h2>with TDS Sensor (Water Quality Sensor)</h2>
In this guide, you'll learn how to use a TDS meter (Total Dissolved Solids) with the ESP32. A TDS meter indicates the total dissolved solids like salts, minerals, and metals, in a solution. This parameter can be used to give you an idea of water quality and compare water from different sources. One of the main applications of a TDS meter is aquarium water quality monitoring.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/02/ESP32-TDS-Sensor-Water-Quality-Sensor.jpg">
We'll use the TDS meter from keystudio and show you a simple example to measure TDS in ppm units using Arduino IDE.
<k>Table of Contents</k>
In this tutorial, we'll cover the following topics
Introducing the TDS Meter
Interfacing the TDS Meter with the ESP32
Reading TDS with the ESP32  Arduino Code
<h3>Introducing the TDS Meter</h3>
A TDS meter measures the number of total dissolved solids like salts, minerals, and metals in the water. As the number of dissolved solids in the water increases, the conductivity of the water increases, and that allow us to calculate the total dissolved solids in ppm (mg/L).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/02/TDS-meter-keystudio.jpg">
Although this is a good indicator to monitor the quality of the water, <k>note that it does not measure contaminants in the water</k>. Thus, you can't rely solely on this indicator to determine if the water is good for consumption or not.
A TDS meter can be useful to monitor water quality in many applications like pools, aquariums, fish tanks, hydroponics, water purifiers, etc.
In this tutorial, we'll use the TDS meter from keystudio that comes with an interface module and an electrode probe (see picture above).
For more information about the TDS meter, we recommend taking a look at the <a href="https://wiki.keyestudio.com/KS0429_keyestudio_TDS_Meter_V1.0" target="_blank">official documentation</a>.
<h3>Features and Specifications</h3>
This tutorial refers to the TDS Meter V1.0 from keystudio. Here are the sensor parameters:
<k>TDS Meter:</k>
Input Voltage: DC 3.3 ~ 5.5V
Output Voltage: 0 ~ 2.3V
Working Current: 3 ~ 6mA
TDS Measurement Range: 0 ~ 1000ppm
TDS Measurement Accuracy:  10% F.S. (25 )
Module Interface: XH2.54-3P
Electrode Interface: XH2.54-2P
<k>TDS Probe:</k>
Number of Needle: 2
Total Length: 60cm
Connection Interface: XH2.54-2P
Color: White
Waterproof Probe
<h3>Where to Buy TDS Sensor?</h3>
<a href="https://makeradvisor.com/tools/tds-sensor/" target="_blank" rel="noopener"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/03/TDS-Sensor-263.jpg"></a>
You can check the TDS sensor on Maker Advisor to find the best price:
<a href="https://makeradvisor.com/tools/tds-sensor/" target="_blank">TDS Sensor</a>
You can use the preceding links or go directly to <a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank">MakerAdvisor.com/tools</a> to find all the parts for your projects at the best price!
<a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/header-200.png?w=828&quality=100&strip=all&ssl=1" data-recalc-dims="1" loading="eager" fetchpriority="high" decoding="async"></a>
<h3>Interfacing the TDS Meter with the ESP32</h3>
The TDS meter outputs an analog signal that can be measured using an ADC pin on the ESP32. You can <a href="https://randomnerdtutorials.com/esp32-pinout-reference-gpios/">check the ESP32 ADC pins here</a>.
Wire the sensor as in the following table:
<table><tbody>
<tr>
<td><k>TDS Sensor</k></td>
<td><k>ESP32</k></td>
</tr>
<tr>
<td>GND</td>
<td>GND</td>
</tr>
<tr>
<td>VCC</td>
<td>3.3V</td>
</tr>
<tr>
<td>Data</td>
<td>GPIO 27 (or any other <a href="https://randomnerdtutorials.com/esp32-adc-analog-read-arduino-ide/">ESP32 ADC pin</a>)</td>
</tr>
</tbody></table><h3>Reading TDS (water quality) with the ESP32  Code</h3>
As we mentioned previously, the sensor outputs an analog signal that can be converted to TDS in ppm. We're using the code provided by the <a href="https://wiki.keyestudio.com/KS0429_keyestudio_TDS_Meter_V1.0" target="_blank">sensor documentation</a> with some modifications. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/02/ESP32-TDS-Sensor.jpg">
To get more accurate results, you'll probably need to calibrate your sensor against a solution with a known TDS value. Also, take into account the non-linearity of the ESP32 ADC when it comes to low and high values. 
However, these adjustments might be not needed if you are not concerned about specific values but about a qualitative value of TDS.
Upload the following code to your ESP32.
<k>// Original source code: https://wiki.keyestudio.com/KS0429_keyestudio_TDS_Meter_V1.0#Test_Code
// Project details: https://RandomNerdTutorials.com/esp32-tds-water-quality-sensor/
#define TdsSensorPin 27
#define VREF 3.3              // analog reference voltage(Volt) of the ADC
#define SCOUNT  30            // sum of sample point
int analogBuffer[SCOUNT];     // store the analog value in the array, read from ADC
int analogBufferTemp[SCOUNT];
int analogBufferIndex = 0;
int copyIndex = 0;
float averageVoltage = 0;
float tdsValue = 0;
float temperature = 25;       // current temperature for compensation
// median filtering algorithm
int getMedianNum(int bArray[], int iFilterLen){
  int bTab[iFilterLen];
  for (byte i = 0; i&lt;iFilterLen; i++)
  bTab[i] = bArray[i];
  int i, j, bTemp;
  for (j = 0; j &lt; iFilterLen - 1; j++) {
    for (i = 0; i &lt; iFilterLen - j - 1; i++) {
      if (bTab[i] > bTab[i + 1]) {
        bTemp = bTab[i];
        bTab[i] = bTab[i + 1];
        bTab[i + 1] = bTemp;
      }
    }
  }
  if ((iFilterLen & 1) > 0){
    bTemp = bTab[(iFilterLen - 1) / 2];
  }
  else {
    bTemp = (bTab[iFilterLen / 2] + bTab[iFilterLen / 2 - 1]) / 2;
  }
  return bTemp;
}
void setup(){
  Serial.begin(115200);
  pinMode(TdsSensorPin,INPUT);
}
void loop(){
  static unsigned long analogSampleTimepoint = millis();
  if(millis()-analogSampleTimepoint > 40U){     //every 40 milliseconds,read the analog value from the ADC
    analogSampleTimepoint = millis();
    analogBuffer[analogBufferIndex] = analogRead(TdsSensorPin);    //read the analog value and store into the buffer
    analogBufferIndex++;
    if(analogBufferIndex == SCOUNT){ 
      analogBufferIndex = 0;
    }
  }   
  
  static unsigned long printTimepoint = millis();
  if(millis()-printTimepoint > 800U){
    printTimepoint = millis();
    for(copyIndex=0; copyIndex&lt;SCOUNT; copyIndex++){
      analogBufferTemp[copyIndex] = analogBuffer[copyIndex];
      
      // read the analog value more stable by the median filtering algorithm, and convert to voltage value
      averageVoltage = getMedianNum(analogBufferTemp,SCOUNT) * (float)VREF / 4096.0;
      
      //temperature compensation formula: fFinalResult(25^C) = fFinalResult(current)/(1.0+0.02*(fTP-25.0)); 
      float compensationCoefficient = 1.0+0.02*(temperature-25.0);
      //temperature compensation
      float compensationVoltage=averageVoltage/compensationCoefficient;
      
      //convert voltage value to tds value
      tdsValue=(133.42*compensationVoltage*compensationVoltage*compensationVoltage - 255.86*compensationVoltage*compensationVoltage + 857.39*compensationVoltage)*0.5;
      
      //Serial.print("voltage:");
      //Serial.print(averageVoltage,2);
      //Serial.print("V   ");
      Serial.print("TDS Value:");
      Serial.print(tdsValue,0);
      Serial.println("ppm");
    }
  }
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_TDS_Sensor.ino" target="_blank">View raw code</a>
<h3>How the Code Works</h3>
Let's take a quick look at the code. You can also skip right away to the Demonstration section.
The TdsSensorPin variable saves the GPIO where you want to get the readings. We chose GPIO27, but you can use any other ADC pin.
<k>#define TdsSensorPin 27</k>
Then, insert the analog voltage reference for the ADC. For the ESP32 is 3.3V, for an Arduino, for example, it is 5V.
<k>#define VREF 3.3    // analog reference voltage(Volt) of the ADC</k>
Before getting a measurement value, we'll apply a median filtering algorithm to get a more stable value. The SCOUNT variable refers to the number of samples we'll filter before getting an actual value.
<k>#define SCOUNT  30  // sum of sample point</k>
Then, we need some arrays to store the readings as well as some index variables that will allow us to go through the arrays.
<k>int analogBuffer[SCOUNT];     // store the analog value in the array, read from ADC
int analogBufferTemp[SCOUNT];
int analogBufferIndex = 0;
int copyIndex = 0;</k>
Initialize the averageVoltage variable and tsdValue as float variables.
<k>float averageVoltage = 0;
float tdsValue = 0;</k>
The temperature variable saves the current temperature value. The temperature influences the readings, so there is an algorithm that compensates for fluctuations in temperature. In this example, the reference temperature is 25oC, but you can change it depending on your environment. For more accurate results, you can add a temperature sensor and get the actual temperature at the time of reading the sensor.
<k>float temperature = 25;       // current temperature for compensation</k>
The following function will be used to get a stable TDS value from an array of readings.
<k>// median filtering algorithm
int getMedianNum(int bArray[], int iFilterLen){
  int bTab[iFilterLen];
  for (byte i = 0; i&lt;iFilterLen; i++)
  bTab[i] = bArray[i];
  int i, j, bTemp;
  for (j = 0; j &lt; iFilterLen - 1; j++) {
    for (i = 0; i &lt; iFilterLen - j - 1; i++) {
      if (bTab[i] > bTab[i + 1]) {
        bTemp = bTab[i];
        bTab[i] = bTab[i + 1];
        bTab[i + 1] = bTemp;
      }
    }
  }
  if ((iFilterLen & 1) > 0){
    bTemp = bTab[(iFilterLen - 1) / 2];
  }
  else {
    bTemp = (bTab[iFilterLen / 2] + bTab[iFilterLen / 2 - 1]) / 2;
  }
  return bTemp;
}</k>
In the setup(), initialize the Serial Monitor at a baud rate of 115200.
<k>Serial.begin(115200);</k>
Set the TDS sensor pin as an input.
<k>pinMode(TdsSensorPin,INPUT);</k>
In the loop(), get new TDS readings every 40 milliseconds and save them in the buffer:
<k>static unsigned long analogSampleTimepoint = millis();
if(millis()-analogSampleTimepoint > 40U){     //every 40 milliseconds,read the analog value from the ADC
  analogSampleTimepoint = millis();
  analogBuffer[analogBufferIndex] = analogRead(TdsSensorPin);    //read the analog value and store into the buffer
  analogBufferIndex++;
  if(analogBufferIndex == SCOUNT){ 
    analogBufferIndex = 0;
  }
}   </k>
Every 800 milliseconds, it gets the latest readings and gets the average voltage by using the filtering algorithm created before:
<k>static unsigned long printTimepoint = millis();
if(millis()-printTimepoint > 800U){
  printTimepoint = millis();
  for(copyIndex=0; copyIndex&lt;SCOUNT; copyIndex++){
    analogBufferTemp[copyIndex] = analogBuffer[copyIndex];
      
    // read the analog value more stable by the median filtering algorithm, and convert to voltage value
    averageVoltage = getMedianNum(analogBufferTemp,SCOUNT) * (float)VREF / 4096.0;</k>
Then, it calculates a temperature compensation coefficient and calculates the TDS value taking that value into account:
<k>//temperature compensation formula: fFinalResult(25^C) = fFinalResult(current)/(1.0+0.02*(fTP-25.0)); 
float compensationCoefficient = 1.0+0.02*(temperature-25.0);
//temperature compensation
float compensationVoltage=averageVoltage/compensationCoefficient;
      
//convert voltage value to tds value
tdsValue=(133.42*compensationVoltage*compensationVoltage*compensationVoltage - 255.86*compensationVoltage*compensationVoltage + 857.39*compensationVoltage)*0.5;</k>
Finally, it prints the TDS value in ppm:
<k>Serial.print("TDS Value:");
Serial.print(tdsValue,0);
Serial.println("ppm");</k>
<h3>Demonstration</h3>
After copying the code to the Arduino IDE, upload the code to your board. Don't forget to select the right board in <k>Tools </k>> <k>Board </k>and the right COM port in <k>Tools </k>> <k>Port</k>.
After uploading, open the Serial Monitor at a baud rate of 115200 and press the ESP32 RST button so that the code starts working.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/02/TDS-meter-ESP32-ESP8266-arduino-testing.jpg">
It will show a value of 0 if the probe is not submerged. Put the probe on a solution to check its TDS. You can try with tap water and add some salt to see if the values increase.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/02/TDS-Sensor-Arduino-IDE-Serial-Monitor-Demonstration.png">
I measured the TDS value for tap water in my house, and I got a value of around 100ppm, which is a good value for drinking water. 
I also tested tea, and the TDS value increased to about 230ppm, which seems a reasonable value. 
Finally, I also measured the TDS value of bottled water and I got a value of 0ppm. I'm not sure if this value is correct because the water is advertised as mineral water, so the minerals dissolved in the water should account for a TDS value. I think this value can be explained due to the non-linearity of the ESP32 ADC pins for small voltage values. Do you have one of these sensors? What values did you get for bottled water?
<h3>Wrapping Up</h3>
A TDS meter can measure the total dissolved solids in a solution. It can be used as an indicator of water quality and allows you to characterize the water. The meter returns the TDS value in ppm (parts per millionmg/L). The TDS value has many applications but it cannot be used by itself to determine if the water is drinkable or not.
A great application of this type of sensor is an aquarium water quality monitor. You can use this sensor alongside a waterproof DS18B20 temperature sensor to monitor your fish tank, for example. 
Are you interested in an Aquarium Water Quality Monitor? I was thinking about creating a web app to monitor and control your aquarium temperature and water quality and additionally, also be able to control a pump via an output pin of the ESP32. What do you think?
<h2>K-Type Thermocouple with MAX6675 Amplifier</h2>
In this guide, you'll learn how to read temperature using a <k>K-Type Thermocouple with the MAX6675 amplifier </k>with the ESP32 board. A K-type thermocouple is a type of temperature sensor with a wide measurement range like <U+2212>200 to 1260oC (<U+2212>326 to 2300oF).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/01/ESP32-Thermocouple-Type-K-MAX6675.jpg">
This tutorial covers how to interface the k-type thermocouple with your ESP32 board, install the required library and use a simple sketch to display the sensor readings in the Serial Monitor.
<k>Table of Contents</k>
In this tutorial, we'll cover the following topics:
Introducing K-Type Thermocouple
MAX 6675 Amplifier
Interfacing K-Type Thermocouple with MAX 6675 Amplifier
Installing MAX 6675 Arduino Library
Code  Get Temperature from K-Type Thermocouple with MAX 6675 Amplifier
<h3>What is a K-Type Thermocouple?</h3>
A thermocouple is a device that consists of two different electrical conductors that form an electrical junctionthermal junction. The change in temperature at the junction creates a slightly but measurable voltage at the reference junction that can be used to calculate the temperature.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/02/thermocouple-how-it-works.png">
A thermocouple can be made of different metals. The metals used will affect the voltage range, cost, and sensitivity. There are standardized metal combinations that result in different thermocouple types: B, E, J, N, K, R, T, and S.
Our tutorial is about the k-type thermocouple. A  k-type thermocouple is made out of chrome and alumel conductors and has a general temperature range of <U+2212>200 to 1260oC (<U+2212>328 to 2300oF).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/02/type-k-thermocouple-f.jpg">
<h3>MAX6675 Amplifier</h3>
To get the temperature from the thermocouple we need a thermocouple amplifier. The temperature output from the thermocouple amplifier depends on the voltage read on the reference junction. The voltage at the reference junction depends on the temperature difference between the reference junction and the thermal junction. So, we need to know the temperature at the reference junction.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/02/MAX6675-amplifier-f.jpg">
The MAX6675 thermocouple comes with a temperature sensor to measure temperature at the reference junction (cold-compensation reference) and amplifies the tiny voltage at the reference junction so that we can read it using our microcontrollers. The MAX6675 amplifier communicates with a microcontroller using SPI communication protocol and the data is output in a 12-bit resolution.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/01/K-type-thermocouple-MAX6675-amplifier.png">
Usually, you can get a pack with a k-type thermocouple and the MAX6675 amplifier. Here's a list of the MAX6675 most relevant features. For a more detailed description, please consult the <a href="https://datasheets.maximintegrated.com/en/ds/MAX6675.pdf" target="_blank">MAX6675 datasheet</a>. 
Direct digital conversion of type -K thermocouple output
Cold-junction compensaiton
Simple SPI-compatible serial interface
Operating voltage range: 3.0 to 5.5V
Operating temperature range: <U+2212>20 to 85oC
Resolves temperatures to 0.25oC, allows readings as high as 1024oC (1875oF). 
<h3>Interfacing K-Type Thermocouple with MAX6675 Amplifier</h3>
As mentioned previously, the MAX 6675 communicates with a microcontroller using SPI communication protocol.
<table><tbody>
<tr>
<td><k>MAX6675</k></td>
<td><k>Microcontroller</k></td>
</tr>
<tr>
<td><k>SO</k></td>
<td>MISO</td>
</tr>
<tr>
<td><k>CS</k></td>
<td>CS</td>
</tr>
<tr>
<td><k>SCK</k></td>
<td>CLK</td>
</tr>
<tr>
<td><k>VCC</k></td>
<td>VCC (3.3V or 5V)</td>
</tr>
<tr>
<td><k>GND</k></td>
<td>GND</td>
</tr>
</tbody></table>
<hr>
<h3>Get Temperature from K-Type Thermocouple with MAX6675 Amplifier</h3>
In this section, you'll learn how to get temperature from your k-type thermocouple. We'll show you a simple example that reads the temperature and displays it on the Arduino IDE Serial Monitor.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/02/type-k-thermocouple-max6675-esp32-f.JPG.jpg">
<h3>Parts Required</h3>
To complete this tutorial, you need the following parts:
<a href="https://makeradvisor.com/tools/type-k-thermocouple-max6675-amplifier/" target="_blank">K-type thermocouple with MAX6675 amplifier</a>
<a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32 </a>(read <a href="https://makeradvisor.com/esp32-development-boards-review-comparison/" target="_blank">Best ESP32 development boards</a>)
<a href="https://makeradvisor.com/tools/jumper-wires-kit-120-pieces/" target="_blank">Jumper wires</a> (female-to-female)
You can use the preceding links or go directly to <a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank">MakerAdvisor.com/tools</a> to find all the parts for your projects at the best price!
<a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/header-200.png?w=828&quality=100&strip=all&ssl=1" data-recalc-dims="1" loading="lazy" fetchpriority="low"></a>
<h3>Schematic  ESP32 with K-type thermocouple and MAX6675 Amplifier</h3>
Wire the MAX6675 Amplifier to the ESP32 as shown in the following schematic diagram.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/02/ESP32-MAX6675-Thermocouple-wiring-Diagram.png">You can also follow the next table.
<table><tbody>
<tr>
<td><k>MAX6675</k></td>
<td><k>ESP32</k></td>
</tr>
<tr>
<td>GND</td>
<td>GND</td>
</tr>
<tr>
<td>VCC</td>
<td>3.3V</td>
</tr>
<tr>
<td>SCK</td>
<td>GPIO 5</td>
</tr>
<tr>
<td>CS</td>
<td>GPIO 23</td>
</tr>
<tr>
<td>SO</td>
<td>GPIO 19</td>
</tr>
</tbody></table><h3>Installing MAX6675 Arduino Library</h3>
There are different libraries to get temperature from a K-type thermocouple using the MAX6675 amplifier. We'll use the <a href="https://github.com/adafruit/MAX6675-library" target="_blank">max6675 library from Adafruit</a>.
Follow the next steps to install the library in your Arduino IDE:
Open your Arduino IDE and go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k>. The Library Manager should open.
Search for <k>max6675</k>  in the search box and install the library from Adafruit.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/01/install-MAX6675-library-arduino-IDE.png"><h3>Code  Get Temperature from K-Type Thermocouple with MAX 6675 Amplifier</h3>
Getting temperature from the K-Type thermocouple with the ESP32 is very simple. The library provides an example that gets temperature and displays the results on the Arduino IDE Serial monitor.
 The code was adapted from the <a href="https://github.com/adafruit/MAX6675-library/tree/master/examples/serialthermocouple" target="_blank">example</a> provided by the library to make it compatible with the ESP32.
<k>// this example is public domain. enjoy! https://learn.adafruit.com/thermocouple/
#include "max6675.h"
int thermoDO = 19;
int thermoCS = 23;
int thermoCLK = 5;
MAX6675 thermocouple(thermoCLK, thermoCS, thermoDO);
void setup() {
  Serial.begin(9600);
  Serial.println("MAX6675 test");
  // wait for MAX chip to stabilize
  delay(500);
}
void loop() {
  // basic readout test, just print the current temp
  
  Serial.print("C = "); 
  Serial.println(thermocouple.readCelsius());
  Serial.print("F = ");
  Serial.println(thermocouple.readFahrenheit());
  
  // For the MAX6675 to update, you must delay AT LEAST 250ms between reads!
  delay(1000);
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_Thermocouple.ino" target="_blank">View raw code</a>
<h3> How the Code Works</h3>
First, include the max6675.h library.
<k>#include "max6675.h"</k>
Define the pins that are interfacing with the MAX6675 thermocouple amplifier.
<k>int thermoDO = 19;
int thermoCS = 23;
int thermoCLK = 5;</k>
Create a MAX6675 object called thermocouple on the pins we've defined previously.
<k>MAX6675 thermocouple(thermoCLK, thermoCS, thermoDO);</k>
In the setup(), initialize the Serial Monitor at a baud rate of 9600.
<k>Serial.begin(9600);</k>
In the loop(), we read the temperature and display it on the Serial Monitor. The library provides a method to read the temperature in Celsius and a method to read the temperature in Fahrenheit degrees.
thermocouple.readCelsius(): returns temperature in Celsius degrees.
thermocouple.readFahrenheit(): returns temperature in Fahrenheit degrees.
The following lines read the temperature and display it on the Serial Monitor.
<k>Serial.print("C = "); 
Serial.println(thermocouple.readCelsius());
Serial.print("F = ");
Serial.println(thermocouple.readFahrenheit());</k>
As you can see, it's very simple to get temperature readings using the K-type thermocouple with the MAX6675 amplifier.
<h3>Demonstration</h3>
Upload the code to your ESP32 board. Don't forget the select the board you're using in <k>Tools </k>> <k>Board </k>and select the COM port your board is connected to in <k>Tools </k>> <k>Port</k>.
After uploading the code to the ESP32, open the Serial Monitor at a baud rate of 9600. Press the ESP32 on-board RST button.
New temperature readings are displayed on the Serial Monitor every second.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/02/Type-K-thermocouple-temperature-serial-monitor.png">
<h3>Wrapping Up</h3>
In this tutorial, you learned how to read temperature using the k-type thermocouple with the MAX6675 amplifier. Thermocouples have a wide temperature measurement range and allow you to read very high temperaturesas high as 1024oC (1875oF) when using k-type thermocouple with MAX6675.
We have tutorials for other popular sensors with the ESP32 board that you may like:
<a style="font-size: inherit;" href="https://randomnerdtutorials.com/esp32-mqtt-publish-ds18b20-temperature-arduino/">ESP32 with DS18B20: <k>Temperature Sensor</k></a>
<a href="https://randomnerdtutorials.com/esp32-mqtt-publish-bme680-arduino/">ESP32 with BME680: <k>Gas, Pressure, Humidity, and Temperature</k> <k>Sensor</k></a>
<a href="https://randomnerdtutorials.com/esp32-mqtt-publish-bme280-arduino/">ESP32 with BME280: <k>Temperature, Humidity, and Pressure Sensor</k></a>
<a href="https://randomnerdtutorials.com/esp32-dht11-dht22-temperature-humidity-sensor-arduino-ide/">ESP32 DHT11/DHT22: <k>Temperature, and Humidity Sensor</k></a>
<a href="https://randomnerdtutorials.com/esp32-bmp388-arduino/">ESP32 with BMP388: <k>Altimeter Sensor</k></a>
<a href="https://randomnerdtutorials.com/esp32-hc-sr04-ultrasonic-arduino/">ESP32 HC-SR04: <k>Ultrasonic Distance Sensor</k></a>
<a href="https://randomnerdtutorials.com/esp32-pir-motion-sensor-interrupts-timers/">ESP32 PIR: <k>Motion Sensor</k></a>
<a href="https://randomnerdtutorials.com/esp32-with-bmp180-barometric-sensor/">ESP32 BMP180: <k>Pressure Sensor</k></a>
<a href="https://randomnerdtutorials.com/esp32-bh1750-ambient-light-sensor/">ESP32 with  BH1750 <k>Ambient Light Sensor</k></a>
<h2>with BH1750 Ambient Light Sensor</h2>
The BH1750 is a 16-bit ambient light sensor. In this guide, you'll learn how to use the BH1750 ambient light sensor with the ESP32 board using Arduino IDE. The sensor communicates with a microcontroller using I2C communication protocol.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/01/BH1750-Ambient-Light-Sensor-ESP32.jpg">
You'll learn how to wire the sensor to the ESP32 board, install the required libraries and use a simple sketch to display the sensor readings in the Serial Monitor.
This tutorial covers the following topics:
Introducing the BH1750 Ambient Light Sensor
BH1750 Pinout
BH1750 I2C Interface
Example: BH1750: Read Ambient Light with ESP32
<h3>Introducing BH1750 Ambient Light Sensor</h3>
The BH1750 is a 16-bit ambient light sensor that communicates via I2C protocol. It outputs luminosity measurements in lux (SI-derived unit of illuminance). It can measure a minimum of 1 lux and a maximum of 65535 lux. 
The sensor may come in different breakout board formats. See pictures below. Both images represent a BH1750 sensor.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/01/BH1750-ambient-light-sensors.jpg">
<h3>BH1750 Features</h3>
Here's a list of the BH1750 sensor features. For more information consult the <a href="https://datasheet.octopart.com/BH1750FVI-TR-Rohm-datasheet-25365051.pdf" target="_blank">BH1750 sensor datasheet</a>. 
I2C bus Interface
Spectral responsibility is approximately human eye response
Illuminance to digital converter
Range: 1  65535 lux
Low current by power down function
50Hz / 60Hz Light noise reject-function
It is possible to select 2 different I2 C slave addresses
Small measurement variation (+/- 20%)
The influence of infrared is very small
Supports continuous measurement mode
Supports one-time measurement mode
<h3>Measurement Modes</h3>
The sensor supports two different measurement modes: <em>continuous measurement mode</em>, and <em>one-time </em>measurement mode. Each mode supports three different resolution modes.
<table><tbody>
<tr>
<td><k>Low Resolution Mode</k></td>
<td>4 lux precision</td>
<td>16 ms measurement time</td>
</tr>
<tr>
<td><k>High Resolution Mode</k></td>
<td>1 lux precision</td>
<td>120 ms measurement time</td>
</tr>
<tr>
<td><k>High Resolution Mode 2</k></td>
<td>0.5 lux precision</td>
<td> 120 ms measurement time </td>
</tr>
</tbody></table>In continuous measurement mode, the sensor continuously measures ambient light values. In one-time measurement mode, the sensor measures the ambient light value once, and then it goes to power down mode.
<h3><k>Applications</k></h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/02/BH1750-Ambient-light-sensor-f.jpg">
The BH1750 is an ambient light sensor so it can be used in a wide variety of projects. For example:
to detect if it is day or night;
to adjust or turn on/off LED's brightness accordingly to ambient light;
to adjust LCDs and screen's brightness;
to detect if an LED is lit;

<h3>BH1750 Pinout</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/02/BH1750-pinout.JPG.jpg">
Here's the BH1750 Pinout:
<table><tbody>
<tr>
<td><k>VCC</k></td>
<td>Powers the sensor (3.3V or 5V)</td>
</tr>
<tr>
<td><k>GND</k></td>
<td>Common GND</td>
</tr>
<tr>
<td><k>SCL</k></td>
<td>SCL pin for I2C communication</td>
</tr>
<tr>
<td>
<k>SDA</k> (Data)</td>
<td>SDA pin for I2C communication</td>
</tr>
<tr>
<td>
<k>ADD</k>*</td>
<td>Selects address</td>
</tr>
</tbody></table>The  ADD pin is used to set the I2C sensor address. If the voltage on that pin is less than 0.7VCC (pin is left floating or connected to GND), the I2C address is 0x23. But, if the voltage is higher than 0.7xVCC (pin is connected to VCC), the address is 0x5C. In summary:
ADD pin floating or connected to GND  address: 0x23
ADD pin connected to VCC  address: 0x5C
<h3>BH1750 I2C Interface</h3>
The BH1750 ambient light sensor supports I2C interface.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/02/BH1750-with-ESP32-f.jpg">
You can connect the BH1750 sensor to the ESP32 using the default's I2C pins:
<table><tbody>
<tr>
<td><k>BH1750</k></td>
<td><k>ESP32</k></td>
</tr>
<tr>
<td>SCL</td>
<td>GPIO 22</td>
</tr>
<tr>
<td>SDA</td>
<td>GPIO 21</td>
</tr>
</tbody></table>GPIO 22 and GPIO 21 are the ESP32 default I2C pins. You can use other pins as long as you set them properly on code.
<h3>BH1750: Read Ambient Light with ESP32</h3>
Now that you are more familiar with the BH1750 sensor, let's test it. In this section, we'll build a simple project that reads the ambient light and displays it in the Arduino IDE Serial Monitor.
<h3>Parts Required</h3>
To complete this tutorial you need the following parts:
<a href="https://makeradvisor.com/tools/bh1750-ambient-light-sensor/" target="_blank" title="https://makeradvisor.com/tools/bh1750-ambient-light-sensor/">BH1750 ambient light sensor</a>
<a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32 </a>(read <a href="https://makeradvisor.com/esp32-development-boards-review-comparison/" target="_blank">Best ESP32 development boards</a>)
<a href="https://makeradvisor.com/tools/mb-102-solderless-breadboard-830-points/" target="_blank">Breadboard </a>(optional)
<a href="https://makeradvisor.com/tools/jumper-wires-kit-120-pieces/" target="_blank">Jumper wires</a> (optional)
You can use the preceding links or go directly to <a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank">MakerAdvisor.com/tools</a> to find all the parts for your projects at the best price!
<a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/header-200.png?w=828&quality=100&strip=all&ssl=1" data-recalc-dims="1" loading="lazy" fetchpriority="low"></a>
<h3>Schematic  ESP32 with BH1750</h3>
Wire the BH1750 sensor to the ESP32 I2C pins. You can follow the next schematic diagram.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/01/ESP32-BH1750-Wiring-Diagram.png">
You can also follow the next table:
<table><tbody>
<tr>
<td><k>BH1750</k></td>
<td><k>ESP32</k></td>
</tr>
<tr>
<td><k>VCC</k></td>
<td>3.3V</td>
</tr>
<tr>
<td><k>GND</k></td>
<td>GND</td>
</tr>
<tr>
<td><k>SCL</k></td>
<td>GPIO 22</td>
</tr>
<tr>
<td>
<k>SDA</k> (Data)</td>
<td>GPIO 21</td>
</tr>
<tr>
<td>
<k>ADD</k>*</td>
<td>Don't connect</td>
</tr>
</tbody></table>By not connecting the <k>ADD </k>pin, we're selecting 0x23 I2C address. Connect it to 3.3V to select 0x5C address instead.
<h3>Preparing Arduino IDE</h3>
We'll program the ESP32 board using Arduino IDE. So, make sure you have the ESP32 add-on installed. Follow the next tutorial:
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing the ESP32 Board in Arduino IDE (Windows, Mac OS X, Linux)</a>
<h3>Installing the BH1750 Library</h3>
There are several libraries to read from the BH1750 sensor. We'll use the <a href="https://github.com/claws/BH1750" target="_blank">BH1750 library by Christopher Laws</a>. It is compatible with the ESP32, ESP8266, and Arduino.
Open your Arduino IDE and go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k>. The Library Manager should open. 
 Search for <k>BH1750</k> on the search box and install the <em>BH1750 library by Christopher Laws</em>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/01/BHT1750-Library-Arduino-IDE.png">
<h3>Code  Reading BH1750 Ambient Light Sensor</h3>
Copy the following code to your Arduino IDE. This code simply reads ambient light in lux and displays the values on the Serial Monitor. It is the example code from the library called <k>BH1750test </k>(you can access it in <k>File </k>> <k>Examples </k>> <k>BH1750 </k>> <k>BH1750test</k>
<k>/*
  Example of BH1750 library usage. This example initialises the BH1750 object using the default high resolution continuous mode and then makes a light level reading every second.
*/
#include &lt;Wire.h>
#include &lt;BH1750.h>
BH1750 lightMeter;
void setup(){
  Serial.begin(9600);
  // Initialize the I2C bus (BH1750 library doesn't do this automatically)
  Wire.begin();
  // On esp8266 you can select SCL and SDA pins using Wire.begin(D4, D3);
  // For Wemos / Lolin D1 Mini Pro and the Ambient Light shield use Wire.begin(D2, D1);
  lightMeter.begin();
  Serial.println(F("BH1750 Test begin"));
}
void loop() {
  float lux = lightMeter.readLightLevel();
  Serial.print("Light: ");
  Serial.print(lux);
  Serial.println(" lx");
  delay(1000);
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/Arduino/BH1750test.ino" target="_blank">View raw code</a>
The library also provides other examples worth exploring.
<h3>How the Code Works</h3>
We start by including the required libraries. The Wire.h library to use I2C communication protocol and the BH1750.h library to read from the sensor.
<k>#include &lt;Wire.h>
#include &lt;BH1750.h></k>
Then, we create a BH1750 object called lightMeter.
<k>BH1750 lightMeter;</k>
In the setup(), initialize the Serial Monitor at a baud rate of 9600.
<k>Serial.begin(9600);</k>
Initialize I2C communication protocol. It will start an I2C communication on the microcontroller's default I2C pins. If you want to use different I2C pins, pass them to the begin() method like this Wire.begin(SDA, SCL).
<k>Wire.begin();</k>
Initialize the sensor using the begin() method on the BH1750 object (lightMeter).
<k>lightMeter.begin();</k>
In the loop(), we create a variable called lux, that saves the luminance values. To get the value, you simply call the readLightLevel() function on the BH1750 object (lightMeter).
<k>float lux = lightMeter.readLightLevel();</k>
Finally, display the measurement on the Serial Monitor.
<k>Serial.print("Light: ");
Serial.print(lux);
Serial.println(" lx");</k>
You get and print a new reading every second.
<k>delay(1000);</k>
<h3>Demonstration</h3>
Now, you can upload the code to your board. First, connect your board to your computer. Then, go to <k>Tools </k>> <k>Board </k>and select the ESP32 board you're using. Go to <k>Tools </k>> <k>Port </k>and select the COM port your board is connected to. Finally, click on the upload button.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/05/arduino-2-0-upload-button.png">
After successfully uploading the code, open the Serial Monitor at a <u>baud rate of 9600</u> and press the ESP32 on-board RST button.
New luminance readings should be printed in the Serial Monitor.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/01/BH1750-readings-serial-monitor.png">
<h3>Other Useful Functions</h3>
The library we're using with the BH1750 sensor provides other examples that illustrate other useful functions and features. You can <a href="https://github.com/claws/BH1750/tree/master/examples" target="_blank">check all BH1750 library examples here</a>.
<h3>Setting Measurement Mode</h3>
By default, the library uses the continuous high resolution measurement mode, but you can change it by passing the desired measurement mode to the begin() method when initializing the sensor. For example:
<k>lightMeter.begin(BH1750::CONTINUOUS_HIGH_RES_MODE)</k>
Here's a list of all available modes:
BH1750_CONTINUOUS_LOW_RES_MODE
BH1750_CONTINUOUS_HIGH_RES_MODE (default)
BH1750_CONTINUOUS_HIGH_RES_MODE_2
BH1750_ONE_TIME_LOW_RES_MODE
BH1750_ONE_TIME_HIGH_RES_MODE
BH1750_ONE_TIME_HIGH_RES_MODE_2
See the properties of each mode in this previous section.
<h3>Wrapping Up</h3>
In this tutorial, you've learned how to use the BH1750 ambient light sensor with the ESP32. The sensor is very easy to use. It uses I2C communication protocol, which makes wiring simple, and the library provides methods to easily get the readings.
<h2>Firebase Data Logging Web App (Gauges, Charts, and Table)</h2>
In this project, you'll create a Firebase Web App that displays all the sensor readings saved on the Firebase Realtime Database. We'll create a web interface with gauges, charts, and a table to display all your data records. We'll also add a button that allows you to delete all data from the database and checkboxes to customize the user interface. This web application will be protected with authentication (using email and password) and all the data is restricted to the user using database rules.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/02/ESP32-Firebase-BME280-Datalogging-web-app.jpg">
This project is Part 2 of the following tutorial (there is a version for ESP32 and a version for ESP8266):
<a href="https://randomnerdtutorials.com/esp32-data-logging-firebase-realtime-database/">ESP32 Data Logging to Firebase Realtime Database</a>
<a href="https://randomnerdtutorials.com/esp8266-data-logging-firebase-realtime-database/" title="https://randomnerdtutorials.com/esp8266-data-logging-firebase-realtime-database/">ESP8266 Data Logging to Firebase Realtime Database</a>
You must follow one of those tutorials first, before proceeding
Here's a summary of the web app features:
login with email and password
displays time of the last update
cards to display the last sensor readings
gauges to display the last sensor readings
charts that display data history with timestamps
select how many readings to display on charts
checkboxes to enable/disable the different display options
table that displays all readings saved on the database
button to delete database data
<h3>Project Overview</h3>
In this tutorial (Part 2), you'll create a web app to display the sensor readings logged with timestamps on the Firebase Realtime Database (read this previous tutorial  <a href="https://randomnerdtutorials.com/esp32-data-logging-firebase-realtime-database/">ESP32 version</a> / <a href="https://randomnerdtutorials.com/esp8266-data-logging-firebase-realtime-database/">ESP8266 version</a>).
The following video shows the web app project we'll buildprogramming the ESP32/ESP8266 and setting up the Firebase Project was done in Part 1 (<a href="https://randomnerdtutorials.com/esp32-data-logging-firebase-realtime-database/">ESP32 Part 1</a>; <a href="https://randomnerdtutorials.com/esp8266-data-logging-firebase-realtime-database/">ESP8266 Part 1</a>).

Firebase hosts your web app over a global CDN using Firebase Hosting and provides an SSL certificate. You can access your web app from anywhere using the Firebase-generated domain name.
When you first access the web app, you need to authenticate with an authorized email address and password. You already set up that user and the <a href="https://randomnerdtutorials.com/esp32-esp8266-firebase-bme280-rtdb/#Set-Authentication-Methods">authentication method in Part 1</a>.
After authentication, you can access a web app page that shows the sensor readings. The sensor readings are displayed in cards, gauges, charts and table. You can select how many readings you want to show on the charts and you can also choose how you can view your data. 
There is a button to show/hide all readings saved on the database on a table with timestamps.
There's also a Delete button that allows you to delete all data from the database.
All the data is restricted using database rules.
<h3>Prerequisites</h3>
Before start creating the Firebase Web App, you need to check the following prerequisites:
<h3>Creating a Firebase Project</h3>
You should have followed one of the next tutorials first:
<a href="https://randomnerdtutorials.com/esp32-data-logging-firebase-realtime-database/">ESP32 Data Logging to Firebase Realtime Database</a>
<a href="https://randomnerdtutorials.com/esp8266-data-logging-firebase-realtime-database/">ESP8266 Data Logging to Firebase Realtime Database</a>
The ESP32/ESP8266 must be running the code provided in that tutorial. The realtime database and authentication must be set up also as shown in the tutorial.
<h3>Install Required Software</h3>
Before getting started you need to install the required software to create the Firebase Web App. Here's a list of the software you need to install (click on the links for instructions):
<a href="https://randomnerdtutorials.com/esp32-firebase-web-app/#install-vs-code">Visual Studio Code</a>
<a href="https://randomnerdtutorials.com/esp32-firebase-web-app/#install-nodejs">Node.JS LTS version</a>
<a href="https://randomnerdtutorials.com/esp32-firebase-web-app/#install-firebase-tools">Install Firebase Tools</a>
<hr>
<h3>1) Add an App to Your Firebase Project</h3>
<k>1)</k> Go to your Firebase project Console and add an app to your project by clicking on the <k>+Add app </k>button. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/Firebase-Add-App-to-Project.png">
<k>2)</k> Select the web app icon.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/Firebase-Add-Web-App-to-Project.png">
<k>3)</k> Give your app a name. Then, check the box next to <k> Also set up Firebase Hosting for this App</k>. Click <k>Register app</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/add-firebase-to-web-app-example.png">
<k>4)</k> Then, copy the firebaseConfig object and save it because you'll need it later.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/app-firebase-config-object.png">
After this, you can also access the firebaseConfig object if you go to your Project settings in your Firebase console.
<k>5)</k> Click <k>Next</k> on the proceeding steps, and finally on <k>Continue to console</k>.
<hr>
<h3>2) Setting Up a Firebase Web App Project (VS Code)</h3>
Follow the next steps to create a Firebase Web App Project using VS Code.
<h3>1) Creating a Project Folder</h3>
<k>1)</k> Create a folder on your computer where you want to save your Firebase projectfor example, <em>Firebase-Project</em> on the Desktop.
<k>2)</k> Open VS Code. Go to <k>File</k> > <k>Open Folder</k> and select the folder you've just created.
<k>3)</k> Go to <k>Terminal </k>> <k>New Terminal</k>. A new Terminal window should open on your project path.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/Terminal-Window-Firebase-Folder-Project.png">
<h3>2) Firebase Login</h3>
<k>4)</k> On the previous Terminal window, type the following:
<k><k>firebase </k>login</k>
<k>5)</k> You'll be asked to collect CLI usage and error reporting information. Enter <k>n</k> and press <k>Enter</k> to deny.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/Terminal-Window-Login-Firebase-VS-Code.png">
<k>Note:</k> If you are already logged in, it will show a message saying: Already logged in as <a href="/cdn-cgi/l/email-protection" data-cfemail="e99c9a8c9ba98e84888085c78a8684">[email protected]</a>.
<k>6)</k> After this, it will pop up a new window on your browser to login into your firebase account.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/Login-Firebase-Account.png">
<k>7)</k> Allow Firebase CLI to access your google account.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/Login-Firebase-Account-2.png">
<k>8)</k> After this, Firebase CLI login should be successful. You can close the browser window.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/Firebase-CLI-Login-Successful.png">
<h3>3) Initializing Web App Firebase Project</h3>
<k>9)</k> After successfully login in, run the following command to start a Firebase project directory in the current folder.
<k><k>firebase </k>init</k>
<k>10)</k> You'll be asked if you want to initialize a Firebase project in the current directory. Enter <k>Y</k> and hit <k>Enter</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/Firebase-Start-Project-VS-Code.png">
<k>11)</k> Then, use up and down arrows and the Space key to select the options. Select the following options:
<k>Realtime Database</k>: Configure security rules file for Realtime Database and (optionally) provision default instance.  
<k>Hosting</k>: Configure files for Firebase Hosting and (optionally) set up GitHub Action deploys
The selected options will show up with a green asterisk. Then, hit <k>Enter</k>. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/realtime-database-hosting-options.png">
<k>12)</k> Select the option Use an existing projectit should be highlighted in bluethen, hit Enter.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/Firebase-Project-Setup-VS-Code.png">
<k>13)</k> After that, select the Firebase project for this directoryit should be <k><a href="https://randomnerdtutorials.com/esp32-esp8266-firebase-bme280-rtdb/">the project created in this previous tutorial</a></k>. In my case, it is called <em>esp-firebase-demo</em>. Then hit <k>Enter</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/add-firebase-project-VS-Code.png">
<k>14)</k> Press <k>Enter </k>on the following question to select the default database security rules file: <k>What file should be used for Realtime Database Security Rules?</k>
<k>15)</k> Then, select the hosting options as shown below:
What do you want to use as your public directory? Hit <k>Enter </k>to select <k>public</k>.
Configure as a single-page app (rewrite urls to /index.html)? <k>No</k>
Set up automatic builds and deploys with GitHub? <k>No</k>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/firebase-hosting-setup-all-options.png">
<k>16)</k> The Firebase project should now be initialized successfully. Notice that VS code created some essential files under your project folder.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/firebase-project-app-created-successfully.png">
The index.html file contains some HTML text to build a web page. For now, leave the default HTML text. The idea is to replace that with your own HTML text to build a custom web page for your needs. We'll do that later in this tutorial.
<k>17)</k> To check if everything went as expected, run the following command on the VS Code Terminal window.
<k><k>firebase </k>deploy</k>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/firebase-first-deploy-test-app.png">
You should get a <k>Deploy complete!</k> message and an URL to the Project Console and the Hosting URL.
<k>18)</k> Copy the hosting URL and paste it into a web browser window. You should see the following web page. You can access that web page from anywhere in the world.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/firebase-hosting-complete.png">
The web page you've seen previously is built with the HTML file placed in the public folder of your Firebase project. By changing the content of that file, you can create your own web app. That's what we're going to do in the next section.
<hr>
<h3>3) Creating Firebase Web App</h3>
Now that you've created a Firebase project app successfully on VS Code, follow the next steps to customize the app to display the sensor readings on a login-protected web page.
<h3>index.html</h3>
Copy the following to your index.html file (it is inside the public folder).
<k>&lt;!DOCTYPE html>
&lt;html>
  &lt;head>
    &lt;meta charset="utf-8">
    &lt;meta name="viewport" content="width=device-width, initial-scale=1">
    &lt;title>ESP Datalogging Firebase App&lt;/title>
    &lt;!-- include Firebase SDK -->
    &lt;script src="https://www.gstatic.com/firebasejs/8.8.1/firebase-app.js">&lt;/script>
    &lt;!-- include only the Firebase features as you need -->
    &lt;script src="https://www.gstatic.com/firebasejs/8.8.1/firebase-auth.js">&lt;/script>
    &lt;script src="https://www.gstatic.com/firebasejs/8.8.1/firebase-database.js">&lt;/script>
    &lt;script>
      // Replace with your app config object
      const firebaseConfig = {
        apiKey: "REPLACE_WITH_YOUR_Firebase_CONFIGURATION",
        authDomain: "REPLACE_WITH_YOUR_Firebase_CONFIGURATION",
        databaseURL: "REPLACE_WITH_YOUR_Firebase_CONFIGURATION",
        projectId: "REPLACE_WITH_YOUR_Firebase_CONFIGURATION",
        storageBucket: "REPLACE_WITH_YOUR_Firebase_CONFIGURATION",
        messagingSenderId: "REPLACE_WITH_YOUR_Firebase_CONFIGURATION",
        appId: "REPLACE_WITH_YOUR_Firebase_CONFIGURATION"
      };
      // Initialize firebase
      firebase.initializeApp(firebaseConfig);
      // Make auth and database references
      const auth = firebase.auth();
      const db = firebase.database();
    &lt;/script>
    &lt;!-- include highchartsjs to build the charts-->
    &lt;script src="https://code.highcharts.com/highcharts.js">&lt;/script>
    &lt;!-- include to use jquery-->
    &lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js">&lt;/script>
    &lt;!--include icons from fontawesome-->
    &lt;link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
    &lt;!-- include Gauges Javascript library-->
    &lt;script src="https://cdn.rawgit.com/Mikhus/canvas-gauges/gh-pages/download/2.1.7/all/gauge.min.js">&lt;/script>
    &lt;!--reference for favicon-->
    &lt;link rel="icon" type="image/png" href="favicon.png">
    &lt;!--reference a stylesheet-->
    &lt;link rel="stylesheet" type="text/css" href="style.css">
  &lt;/head>
  &lt;body>
    &lt;!--TOP BAR-->
    &lt;div>
      &lt;h1>Sensor Readings App &lt;i>&lt;/i>&lt;/h2>
    &lt;/div>
    &lt;!--AUTHENTICATION BAR (USER DETAILS/LOGOUT BUTTON)-->
    &lt;div style="display: none;">
      &lt;p>&lt;span>User logged in&lt;/span>
        &lt;span>USEREMAIL&lt;/span>
        &lt;a href="/">(logout)&lt;/a>
      &lt;/p>
    &lt;/div>
    &lt;!--LOGIN FORM-->
    &lt;form style="display: none;">
      &lt;div>
        &lt;label for="input-email">&lt;b>Email&lt;/b>&lt;/label>
        &lt;input type="text" placeholder="Enter Username" required>
        &lt;label for="input-password">&lt;b>Password&lt;/b>&lt;/label>
        &lt;input type="password" placeholder="Enter Password" required>
        &lt;button type="submit">Login&lt;/button>
        &lt;p style="color:red;">&lt;/p>
      &lt;/div>
    &lt;/form>
    &lt;!--CONTENT (SENSOR READINGS)-->
    &lt;div style="display: none;">
      &lt;!--LAST UPDATE-->
      &lt;p>&lt;span class ="date-time">Last update: &lt;span>&lt;/span>&lt;/span>&lt;/p>
      &lt;p>
        Cards: &lt;input type="checkbox" name="cards-checkbox" checked>
        Gauges: &lt;input type="checkbox" name="gauges-checkbox" checked>
        Charts: &lt;input type="checkbox" name="charts-checkbox" unchecked>
      &lt;/p>
      &lt;div>
        &lt;div>
          &lt;!--TEMPERATURE-->
          &lt;div>
            &lt;p>&lt;i style="color:#059e8a;">&lt;/i> TEMPERATURE&lt;/p>
            &lt;p>&lt;span>&lt;span>&lt;/span> &deg;C&lt;/span>&lt;/p>
          &lt;/div>
          &lt;!--HUMIDITY-->
          &lt;div>
            &lt;p>&lt;i style="color:#00add6;">&lt;/i> HUMIDITY&lt;/p>
            &lt;p>&lt;span>&lt;span>&lt;/span> &percnt;&lt;/span>&lt;/p>
          &lt;/div>
          &lt;!--PRESSURE-->
          &lt;div>
            &lt;p>&lt;i style="color:#e1e437;">&lt;/i> PRESSURE&lt;/p>
            &lt;p>&lt;span>&lt;span>&lt;/span> hPa&lt;/span>&lt;/p>
          &lt;/div>
        &lt;/div>
      &lt;/div>
      &lt;!--GAUGES-->
      &lt;div id ="gauges-div">
        &lt;div>
          &lt;!--TEMPERATURE-->
          &lt;div>
            &lt;canvas>&lt;/canvas>
          &lt;/div>
          &lt;!--HUMIDITY-->
          &lt;div>
            &lt;canvas>&lt;/canvas>
          &lt;/div>
        &lt;/div>
      &lt;/div>
      &lt;!--CHARTS-->
      &lt;div style="display:none">
        &lt;!--SET NUMBER OF READINGS INPUT FIELD-->
        &lt;div>
          &lt;p> Number of readings: &lt;input type="number">&lt;/p>
        &lt;/div>
        &lt;!--TEMPERATURE-CHART-->
        &lt;div>
          &lt;div>
            &lt;p>&lt;i style="color:#059e8a;">&lt;/i> TEMPERATURE CHART&lt;/p>
            &lt;div>&lt;/div>
          &lt;/div>
        &lt;/div>
        &lt;!--HUMIDITY-CHART-->
        &lt;div>
          &lt;div>
            &lt;p>&lt;i style="color:#00add6;">&lt;/i> HUMIDITY CHART&lt;/p>
            &lt;div>&lt;/div>
          &lt;/div>
        &lt;/div>
        &lt;!--PRESSURE-CHART-->
        &lt;div>
          &lt;div>
            &lt;p>&lt;i style="color:#e1e437;">&lt;/i> PRESSURE CHART&lt;/p>
            &lt;div>&lt;/div>
          &lt;/div>
        &lt;/div>
      &lt;/div>
    &lt;!--BUTTONS TO HANDLE DATA-->
    &lt;p>
      &lt;!--View data button-->
      &lt;button>View all data&lt;/button>
      &lt;!--Hide data button-->
      &lt;button style= "display:none;">Hide data&lt;/button>
      &lt;!--Delete data button-->
      &lt;button>Delete data&lt;/button>
    &lt;/p>
    &lt;!--Modal to delete data-->
    &lt;div sytle="display:none">
      &lt;span onclick = "document.getElementById('delete-modal').style.display='none'" title="Close Modal">&lt;/span>
      &lt;form id= "delete-data-form" action="/">
        &lt;div>
          &lt;h1>Delete Data&lt;/h2>
          &lt;p>Are you sure you want to delete all data from database?&lt;/p>
          &lt;div>
            &lt;button type="button" onclick="document.getElementById('delete-modal').style.display='none'">Cancel&lt;/button>
            &lt;button type="submit" onclick="document.getElementById('delete-modal').style.display='none'">Delete&lt;/button>
          &lt;/div>
        &lt;/div>
      &lt;/form>
    &lt;/div>
    &lt;!--TABLE WITH ALL DATA-->
    &lt;div class ="cards">
      &lt;div style= "display:none;">
        &lt;table>
            &lt;tr>
              &lt;th>Timestamp&lt;/th>
              &lt;th>Temp (oC)&lt;/th>
              &lt;th>Hum (%)&lt;/th>
              &lt;th>Pres (hPa)&lt;/th>
            &lt;/tr>
            &lt;tbody>
            &lt;/tbody>
        &lt;/table>
        &lt;p>&lt;button style= "display:none;">More results...&lt;/button>&lt;/p>
      &lt;/div>
    &lt;/div>
  &lt;/div>
    &lt;!--INCLUDE JS FILES-->
    &lt;script src="scripts/auth.js">&lt;/script>
    &lt;script src="scripts/charts-definition.js">&lt;/script>
    &lt;script src="scripts/gauges-definition.js">&lt;/script>
    &lt;script src="scripts/index.js">&lt;/script>
  &lt;/body>
&lt;/html>
</k>
<a href="https://github.com/RuiSantosdotme/Firebase-ESP/raw/main/ESP-Firebase-Datalogging-Web-App/index.html" target="_blank">View raw code</a>
<k>Important</k>: you need to modify the code with your own firebaseConfig objectthe one you've got in this step.
<k>const firebaseConfig = {
  apiKey: "REPLACE_WITH_YOUR_Firebase_CONFIGURATION",
  authDomain: "REPLACE_WITH_YOUR_Firebase_CONFIGURATION",
  databaseURL: "REPLACE_WITH_YOUR_Firebase_CONFIGURATION",
  projectId: "REPLACE_WITH_YOUR_Firebase_CONFIGURATION",
  storageBucket: "REPLACE_WITH_YOUR_Firebase_CONFIGURATION",
  messagingSenderId: "REPLACE_WITH_YOUR_Firebase_CONFIGURATION",
  appId: "REPLACE_WITH_YOUR_Firebase_CONFIGURATION"
};</k>
<h3>style.css</h3>
Inside the public folder create a file called style.css. To create the file, select the public folder, and then click on the <k>+file</k> icon at the top of the File Explorer. Call it style.css.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/Firebase-Project-VS-Code-CSS-File.png">
Then, copy the following to the style.css file
<k>html {
    font-family: Verdana, Geneva, Tahoma, sans-serif;
    display: inline-block;
    text-align: center;
}
body {
    margin: 0;
    width: 100%;
}
.topnav {
    overflow: hidden;
    background-color: #049faa;
    color: white;
    font-size: 1rem;
    padding: 5px;
}
#authentication-bar{
    background-color:mintcream;
    padding-top: 10px;
    padding-bottom: 10px;
}
#user-details{
    color: cadetblue;
}
.content {
    padding: 20px;
}
.card {
    background-color: white;
    box-shadow: 2px 2px 12px 1px rgba(140,140,140,.5);
    padding: 5%;
}
.cards {
    max-width: 800px;
    margin: 0 auto;
    margin-bottom: 10px;
    display: grid;
    grid-gap: 2rem;
    grid-template-columns: repeat(auto-fit, minmax(200px, 2fr));
}
.reading {
    color: #193036;
}
.date-time{
    font-size: 0.8rem;
    color: #1282A2;
}
button {
    background-color: #049faa;
    color: white;
    padding: 14px 20px;
    margin: 8px 0;
    border: none;
    cursor: pointer;
    border-radius: 4px;
}
button:hover {
   opacity: 0.8;
}
.deletebtn{
    background-color: #c52c2c;
}
.form-elements-container{
    padding: 16px;
    width: 250px;
    margin: 0 auto;
}
input[type=text], input[type=password] {
    width: 100%;
    padding: 12px 20px;
    margin: 8px 0;
    display: inline-block;
    border: 1px solid #ccc;
    box-sizing: border-box;
}
table {
    width: 100%;
    text-align: center;
    font-size: 0.8rem;
}   
tr, td {
    padding: 0.25rem;
}
tr:nth-child(even) {
    background-color: #f2f2f2
}
tr:hover {
    background-color: #ddd;
}
th {
    position: sticky;
    top: 0;
    background-color: #50b8b4;
    color: white;
}
/* The Modal (background) */
.modal {
    display: none; /* Hidden by default */
    position: fixed; /* Stay in place */
    z-index: 1; /* Sit on top */
    left: 0;
    top: 0;
    width: 100%; /* Full width */
    height: 100%; /* Full height */
    overflow: auto; /* Enable scroll if needed */
    background-color: #474e5d;
    padding-top: 50px;
}
  
/* Modal Content/Box */
.modal-content {
    background-color: #fefefe;
    margin: 5% auto 15% auto; /* 5% from the top, 15% from the bottom and centered */
    border: 1px solid #888;
    width: 80%; /* Could be more or less, depending on screen size */
}
  
/* Style the horizontal ruler */
hr {
    border: 1px solid #f1f1f1;
    margin-bottom: 25px;
}
/* The Modal Close Button (x) */
.close {
    position: absolute;
    right: 35px;
    top: 15px;
    font-size: 40px;
    font-weight: bold;
    color: #f1f1f1;
}
.close:hover,
.close:focus {
    color: #f44336;
    cursor: pointer;
}
/* Clear floats */
.clearfix::after {
    content: "";
    clear: both;
    display: table;
}
/* Change styles for cancel button and delete button on extra small screens */
@media screen and (max-width: 300px) {
    .cancelbtn, .deletebtn {
        width: 100%;
    }
}
</k>
<a href="https://github.com/RuiSantosdotme/Firebase-ESP/raw/main/ESP-Firebase-Datalogging-Web-App/style.css" target="_blank">View raw code</a>
The CSS file includes some simple styles to make our webpage look better. We won't discuss how CSS works in this tutorial.
<h3>JavaScript Files</h3>
We'll create four JavaScript files (auth.js, index.js, charts-definition.js, and gauges-definition.js) inside a scripts folder inside the public folder.
Select the public folder, then click on the <k>+folder</k> icon to create a new folder. Call scripts to that new folder.
Then, select the scripts folder and click on the <k>+file</k> icon. Create a file called auth.js. Then, repeat the previous steps to create the index.js, charts-definition.js, and gauges-definition.js files.
The following image shows what your web app project folder structure should look like.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/02/Firebase-Datalogging-Project-Structure-Web-App.png">
<h4>auth.js</h4>
Copy the following to the auth.js file you created previously.
<k>document.addEventListener("DOMContentLoaded", function(){
    // listen for auth status changes
    auth.onAuthStateChanged(user => {
        if (user) {
          console.log("user logged in");
          console.log(user);
          setupUI(user);
          var uid = user.uid;
          console.log(uid);
        } else {
          console.log("user logged out");
          setupUI();
        }
    });
    // login
    const loginForm = document.querySelector('#login-form');
    loginForm.addEventListener('submit', (e) => {
        e.preventDefault();
        // get user info
        const email = loginForm['input-email'].value;
        const password = loginForm['input-password'].value;
        // log the user in
        auth.signInWithEmailAndPassword(email, password).then((cred) => {
            // close the login modal & reset form
            loginForm.reset();
            console.log(email);
        })
        .catch((error) =>{
            const errorCode = error.code;
            const errorMessage = error.message;
            document.getElementById("error-message").innerHTML = errorMessage;
            console.log(errorMessage);
        });
    });
    // logout
    const logout = document.querySelector('#logout-link');
    logout.addEventListener('click', (e) => {
        e.preventDefault();
        auth.signOut();
    });
});  
</k>
<a href="https://github.com/RuiSantosdotme/Firebase-ESP/raw/main/ESP-Firebase-Datalogging-Web-App/scripts/auth.js" target="_blank">View raw code</a>
Then, save the file. This file takes care of everything related to the login and logout of the user. 
<h4>index.js</h4>
The index.js file handles the UIit shows the right content depending on the user authentication status. When the user is logged in, this file gets new readings from the database whenever there's a change and displays them in the right places.
Copy the following to the index.js file. 
<k>// convert epochtime to JavaScripte Date object
function epochToJsDate(epochTime){
  return new Date(epochTime*1000);
}
// convert time to human-readable format YYYY/MM/DD HH:MM:SS
function epochToDateTime(epochTime){
  var epochDate = new Date(epochToJsDate(epochTime));
  var dateTime = epochDate.getFullYear() + "/" +
    ("00" + (epochDate.getMonth() + 1)).slice(-2) + "/" +
    ("00" + epochDate.getDate()).slice(-2) + " " +
    ("00" + epochDate.getHours()).slice(-2) + ":" +
    ("00" + epochDate.getMinutes()).slice(-2) + ":" +
    ("00" + epochDate.getSeconds()).slice(-2);
  return dateTime;
}
// function to plot values on charts
function plotValues(chart, timestamp, value){
  var x = epochToJsDate(timestamp).getTime();
  var y = Number (value);
  if(chart.series[0].data.length > 40) {
    chart.series[0].addPoint([x, y], true, true, true);
  } else {
    chart.series[0].addPoint([x, y], true, false, true);
  }
}
// DOM elements
const loginElement = document.querySelector('#login-form');
const contentElement = document.querySelector("#content-sign-in");
const userDetailsElement = document.querySelector('#user-details');
const authBarElement = document.querySelector('#authentication-bar');
const deleteButtonElement = document.getElementById('delete-button');
const deleteModalElement = document.getElementById('delete-modal');
const deleteDataFormElement = document.querySelector('#delete-data-form');
const viewDataButtonElement = document.getElementById('view-data-button');
const hideDataButtonElement = document.getElementById('hide-data-button');
const tableContainerElement = document.querySelector('#table-container');
const chartsRangeInputElement = document.getElementById('charts-range');
const loadDataButtonElement = document.getElementById('load-data');
const cardsCheckboxElement = document.querySelector('input[name=cards-checkbox]');
const gaugesCheckboxElement = document.querySelector('input[name=gauges-checkbox]');
const chartsCheckboxElement = document.querySelector('input[name=charts-checkbox]');
// DOM elements for sensor readings
const cardsReadingsElement = document.querySelector("#cards-div");
const gaugesReadingsElement = document.querySelector("#gauges-div");
const chartsDivElement = document.querySelector('#charts-div');
const tempElement = document.getElementById("temp");
const humElement = document.getElementById("hum");
const presElement = document.getElementById("pres");
const updateElement = document.getElementById("lastUpdate")
// MANAGE LOGIN/LOGOUT UI
const setupUI = (user) => {
  if (user) {
    //toggle UI elements
    loginElement.style.display = 'none';
    contentElement.style.display = 'block';
    authBarElement.style.display ='block';
    userDetailsElement.style.display ='block';
    userDetailsElement.innerHTML = user.email;
    // get user UID to get data from database
    var uid = user.uid;
    console.log(uid);
    // Database paths (with user UID)
    var dbPath = 'UsersData/' + uid.toString() + '/readings';
    var chartPath = 'UsersData/' + uid.toString() + '/charts/range';
    // Database references
    var dbRef = firebase.database().ref(dbPath);
    var chartRef = firebase.database().ref(chartPath);
    // CHARTS
    // Number of readings to plot on charts
    var chartRange = 0;
    // Get number of readings to plot saved on database (runs when the page first loads and whenever there's a change in the database)
    chartRef.on('value', snapshot =>{
      chartRange = Number(snapshot.val());
      console.log(chartRange);
      // Delete all data from charts to update with new values when a new range is selected
      chartT.destroy();
      chartH.destroy();
      chartP.destroy();
      // Render new charts to display new range of data
      chartT = createTemperatureChart();
      chartH = createHumidityChart();
      chartP = createPressureChart();
      // Update the charts with the new range
      // Get the latest readings and plot them on charts (the number of plotted readings corresponds to the chartRange value)
      dbRef.orderByKey().limitToLast(chartRange).on('child_added', snapshot =>{
        var jsonData = snapshot.toJSON(); // example: {temperature: 25.02, humidity: 50.20, pressure: 1008.48, timestamp:1641317355}
        // Save values on variables
        var temperature = jsonData.temperature;
        var humidity = jsonData.humidity;
        var pressure = jsonData.pressure;
        var timestamp = jsonData.timestamp;
        // Plot the values on the charts
        plotValues(chartT, timestamp, temperature);
        plotValues(chartH, timestamp, humidity);
        plotValues(chartP, timestamp, pressure);
      });
    });
    // Update database with new range (input field)
    chartsRangeInputElement.onchange = () =>{
      chartRef.set(chartsRangeInputElement.value);
    };
    //CHECKBOXES
    // Checbox (cards for sensor readings)
    cardsCheckboxElement.addEventListener('change', (e) =>{
      if (cardsCheckboxElement.checked) {
        cardsReadingsElement.style.display = 'block';
      }
      else{
        cardsReadingsElement.style.display = 'none';
      }
    });
    // Checbox (gauges for sensor readings)
    gaugesCheckboxElement.addEventListener('change', (e) =>{
      if (gaugesCheckboxElement.checked) {
        gaugesReadingsElement.style.display = 'block';
      }
      else{
        gaugesReadingsElement.style.display = 'none';
      }
    });
    // Checbox (charta for sensor readings)
    chartsCheckboxElement.addEventListener('change', (e) =>{
      if (chartsCheckboxElement.checked) {
        chartsDivElement.style.display = 'block';
      }
      else{
        chartsDivElement.style.display = 'none';
      }
    });
    // CARDS
    // Get the latest readings and display on cards
    dbRef.orderByKey().limitToLast(1).on('child_added', snapshot =>{
      var jsonData = snapshot.toJSON(); // example: {temperature: 25.02, humidity: 50.20, pressure: 1008.48, timestamp:1641317355}
      var temperature = jsonData.temperature;
      var humidity = jsonData.humidity;
      var pressure = jsonData.pressure;
      var timestamp = jsonData.timestamp;
      // Update DOM elements
      tempElement.innerHTML = temperature;
      humElement.innerHTML = humidity;
      presElement.innerHTML = pressure;
      updateElement.innerHTML = epochToDateTime(timestamp);
    });
    // GAUGES
    // Get the latest readings and display on gauges
    dbRef.orderByKey().limitToLast(1).on('child_added', snapshot =>{
      var jsonData = snapshot.toJSON(); // example: {temperature: 25.02, humidity: 50.20, pressure: 1008.48, timestamp:1641317355}
      var temperature = jsonData.temperature;
      var humidity = jsonData.humidity;
      var pressure = jsonData.pressure;
      var timestamp = jsonData.timestamp;
      // Update DOM elements
      var gaugeT = createTemperatureGauge();
      var gaugeH = createHumidityGauge();
      gaugeT.draw();
      gaugeH.draw();
      gaugeT.value = temperature;
      gaugeH.value = humidity;
      updateElement.innerHTML = epochToDateTime(timestamp);
    });
    // DELETE DATA
    // Add event listener to open modal when click on "Delete Data" button
    deleteButtonElement.addEventListener('click', e =>{
      console.log("Remove data");
      e.preventDefault;
      deleteModalElement.style.display="block";
    });
    // Add event listener when delete form is submited
    deleteDataFormElement.addEventListener('submit', (e) => {
      // delete data (readings)
      dbRef.remove();
    });
    // TABLE
    var lastReadingTimestamp; //saves last timestamp displayed on the table
    // Function that creates the table with the first 100 readings
    function createTable(){
      // append all data to the table
      var firstRun = true;
      dbRef.orderByKey().limitToLast(100).on('child_added', function(snapshot) {
        if (snapshot.exists()) {
          var jsonData = snapshot.toJSON();
          console.log(jsonData);
          var temperature = jsonData.temperature;
          var humidity = jsonData.humidity;
          var pressure = jsonData.pressure;
          var timestamp = jsonData.timestamp;
          var content = '';
          content += '&lt;tr>';
          content += '&lt;td>' + epochToDateTime(timestamp) + '&lt;/td>';
          content += '&lt;td>' + temperature + '&lt;/td>';
          content += '&lt;td>' + humidity + '&lt;/td>';
          content += '&lt;td>' + pressure + '&lt;/td>';
          content += '&lt;/tr>';
          $('#tbody').prepend(content);
          // Save lastReadingTimestamp --> corresponds to the first timestamp on the returned snapshot data
          if (firstRun){
            lastReadingTimestamp = timestamp;
            firstRun=false;
            console.log(lastReadingTimestamp);
          }
        }
      });
    };
    // append readings to table (after pressing More results... button)
    function appendToTable(){
      var dataList = []; // saves list of readings returned by the snapshot (oldest-->newest)
      var reversedList = []; // the same as previous, but reversed (newest--> oldest)
      console.log("APEND");
      dbRef.orderByKey().limitToLast(100).endAt(lastReadingTimestamp).once('value', function(snapshot) {
        // convert the snapshot to JSON
        if (snapshot.exists()) {
          snapshot.forEach(element => {
            var jsonData = element.toJSON();
            dataList.push(jsonData); // create a list with all data
          });
          lastReadingTimestamp = dataList[0].timestamp; //oldest timestamp corresponds to the first on the list (oldest --> newest)
          reversedList = dataList.reverse(); // reverse the order of the list (newest data --> oldest data)
          var firstTime = true;
          // loop through all elements of the list and append to table (newest elements first)
          reversedList.forEach(element =>{
            if (firstTime){ // ignore first reading (it's already on the table from the previous query)
              firstTime = false;
            }
            else{
              var temperature = element.temperature;
              var humidity = element.humidity;
              var pressure = element.pressure;
              var timestamp = element.timestamp;
              var content = '';
              content += '&lt;tr>';
              content += '&lt;td>' + epochToDateTime(timestamp) + '&lt;/td>';
              content += '&lt;td>' + temperature + '&lt;/td>';
              content += '&lt;td>' + humidity + '&lt;/td>';
              content += '&lt;td>' + pressure + '&lt;/td>';
              content += '&lt;/tr>';
              $('#tbody').append(content);
            }
          });
        }
      });
    }
    viewDataButtonElement.addEventListener('click', (e) =>{
      // Toggle DOM elements
      tableContainerElement.style.display = 'block';
      viewDataButtonElement.style.display ='none';
      hideDataButtonElement.style.display ='inline-block';
      loadDataButtonElement.style.display = 'inline-block'
      createTable();
    });
    loadDataButtonElement.addEventListener('click', (e) => {
      appendToTable();
    });
    hideDataButtonElement.addEventListener('click', (e) => {
      tableContainerElement.style.display = 'none';
      viewDataButtonElement.style.display = 'inline-block';
      hideDataButtonElement.style.display = 'none';
    });
  // IF USER IS LOGGED OUT
  } else{
    // toggle UI elements
    loginElement.style.display = 'block';
    authBarElement.style.display ='none';
    userDetailsElement.style.display ='none';
    contentElement.style.display = 'none';
  }
}
</k>
<a href="https://github.com/RuiSantosdotme/Firebase-ESP/raw/main/ESP-Firebase-Datalogging-Web-App/scripts/index.js" target="_blank">View raw code</a>
<h4>charts-definition.js</h4>
Copy the following to the charts-definition.js file. This file creates the different charts using the <a href="https://www.highcharts.com/" target="_blank">highcharts javascript library</a>. 
<k>// Create the charts when the web page loads
window.addEventListener('load', onload);
function onload(event){
  chartT = createTemperatureChart();
  chartH = createHumidityChart();
  chartP = createPressureChart();
}
// Create Temperature Chart
function createTemperatureChart() {
  var chart = new Highcharts.Chart({
    chart:{ 
      renderTo:'chart-temperature',
      type: 'spline' 
    },
    series: [
      {
        name: 'BME280'
      }
    ],
    title: { 
      text: undefined
    },
    plotOptions: {
      line: { 
        animation: false,
        dataLabels: { 
          enabled: true 
        }
      }
    },
    xAxis: {
      type: 'datetime',
      dateTimeLabelFormats: { second: '%H:%M:%S' }
    },
    yAxis: {
      title: { 
        text: 'Temperature Celsius Degrees' 
      }
    },
    credits: { 
      enabled: false 
    }
  });
  return chart;
}
// Create Humidity Chart
function createHumidityChart(){
  var chart = new Highcharts.Chart({
    chart:{ 
      renderTo:'chart-humidity',
      type: 'spline'  
    },
    series: [{
      name: 'BME280'
    }],
    title: { 
      text: undefined
    },    
    plotOptions: {
      line: { 
        animation: false,
        dataLabels: { 
          enabled: true 
        }
      },
      series: { 
        color: '#50b8b4' 
      }
    },
    xAxis: {
      type: 'datetime',
      dateTimeLabelFormats: { second: '%H:%M:%S' }
    },
    yAxis: {
      title: { 
        text: 'Humidity (%)' 
      }
    },
    credits: { 
      enabled: false 
    }
  });
  return chart;
}
// Create Pressure Chart
function createPressureChart() {
  var chart = new Highcharts.Chart({
    chart:{ 
      renderTo:'chart-pressure',
      type: 'spline'  
    },
    series: [{
      name: 'BME280'
    }],
    title: { 
      text: undefined
    },    
    plotOptions: {
      line: { 
        animation: false,
        dataLabels: { 
          enabled: true 
        }
      },
      series: { 
        color: '#A62639' 
      }
    },
    xAxis: {
      type: 'datetime',
      dateTimeLabelFormats: { second: '%H:%M:%S' }
    },
    yAxis: {
      title: { 
        text: 'Pressure (hPa)' 
      }
    },
    credits: { 
      enabled: false 
    }
  });
  return chart;
}</k>
<a href="https://github.com/RuiSantosdotme/Firebase-ESP/raw/main/ESP-Firebase-Datalogging-Web-App/scripts/charts-definition.js" target="_blank">View raw code</a>
<h4>gauges-definition.js</h4>
In our web app, we'll display a gauge for the temperature and another for the humidity. The gauges-definition.js file contains functions to create the gauges.
<k>// Create Temperature Gauge
function createTemperatureGauge() {
    var gauge = new LinearGauge({
        renderTo: 'gauge-temperature',
        width: 120,
        height: 400,
        units: "Temperature C",
        minValue: 0,
        startAngle: 90,
        ticksAngle: 180,
        maxValue: 40,
        colorValueBoxRect: "#049faa",
        colorValueBoxRectEnd: "#049faa",
        colorValueBoxBackground: "#f1fbfc",
        valueDec: 2,
        valueInt: 2,
        majorTicks: [
            "0",
            "5",
            "10",
            "15",
            "20",
            "25",
            "30",
            "35",
            "40"
        ],
        minorTicks: 4,
        strokeTicks: true,
        highlights: [
            {
                "from": 30,
                "to": 40,
                "color": "rgba(200, 50, 50, .75)"
            }
        ],
        colorPlate: "#fff",
        colorBarProgress: "#CC2936",
        colorBarProgressEnd: "#049faa",
        borderShadowWidth: 0,
        borders: false,
        needleType: "arrow",
        needleWidth: 2,
        needleCircleSize: 7,
        needleCircleOuter: true,
        needleCircleInner: false,
        animationDuration: 1500,
        animationRule: "linear",
        barWidth: 10,
    });
    return gauge;
}
// Create Humidity Gauge
function createHumidityGauge(){
    var gauge = new RadialGauge({
        renderTo: 'gauge-humidity',
        width: 300,
        height: 300,
        units: "Humidity (%)",
        minValue: 0,
        maxValue: 100,
        colorValueBoxRect: "#049faa",
        colorValueBoxRectEnd: "#049faa",
        colorValueBoxBackground: "#f1fbfc",
        valueInt: 2,
        majorTicks: [
            "0",
            "20",
            "40",
            "60",
            "80",
            "100"
    
        ],
        minorTicks: 4,
        strokeTicks: true,
        highlights: [
            {
                "from": 80,
                "to": 100,
                "color": "#03C0C1"
            }
        ],
        colorPlate: "#fff",
        borderShadowWidth: 0,
        borders: false,
        needleType: "line",
        colorNeedle: "#007F80",
        colorNeedleEnd: "#007F80",
        needleWidth: 2,
        needleCircleSize: 3,
        colorNeedleCircleOuter: "#007F80",
        needleCircleOuter: true,
        needleCircleInner: false,
        animationDuration: 1500,
        animationRule: "linear"
    });
    return gauge;
}</k>
<a href="https://github.com/RuiSantosdotme/Firebase-ESP/raw/main/ESP-Firebase-Datalogging-Web-App/scripts/gauges-definition.js" target="_blank">View raw code</a>
<h3>Favicon File</h3>
To display a favicon in your web app, you need to move the picture you want to use as favicon to the public folder. The picture should be called favicon.png. You can simply drag the favicon file from your computer into the public folder in VS Code.
We're using the following icon as a favicon for our web app:
<a href="https://github.com/RuiSantosdotme/build-web-servers-dl/raw/main/favicon.zip" target="_blank">favicon.png</a>
<h3>Deploy your App</h3>
After saving the HTML, CSS, and JavaScript files, deploy your app on VS Code by running the following command on the Terminal window.
<k><k>firebase</k> deploy</k>
The Terminal should display something as follows:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/02/Firebase-deploy-web-app.png">
Firebase offers a free hosting service to serve your assets and web apps. Then, you can access your web app from anywhere.
You can use the Hosting URL provided to access your web app from anywhere.
<h3>Demonstration</h3>
Congratulations! You successfully deployed your app. It is now hosted on a global CDN using Firebase hosting. You can access your web app from anywhere on the Hosting URL provided. In my case, it is https://esp-firebase-demo.web.app.
The web app is responsive, and you can access it using your smartphone, computer, or tablet.
When you first access the web app, you'll see a form to insert the email username and password.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/02/Firebase-Sensor-Readings-App-Login-Page.jpg">
Insert the email and password of the authorized user you added in the Firebase Authentication methods. If the form doesn't show up at first, refresh the web page. After that, you can access the web page with the readings.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/02/Firebase-Sensor-Readings-App-Cards-Gauges.jpg">
The readings are displayed in cards, gauges, charts, and a table. You can also select which interfaces you want to see by checking/unchecking the checkboxes.
You can also check the readings displayed on charts. You can select the charts range, but keep in mind that selecting more than 30 readings will take some time.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/02/Firebase-Sensor-Readings-App-Charts.jpg">
Finally, if you want to see all the readings. You can open the readings table. At the end of the table, there's a button to load more readings until all readings are displayed.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/02/Firebase-Sensor-Readings-App-table-all-data.jpg">
There is also a button to delete all data if you want to remove all readings from the database.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/02/Firebase-Sensor-Readings-App-Delete-Data.jpg">
Here's a video showing how the web app works.

<h3>Wrapping Up</h3>
In this tutorial, you created a Firebase Web App with login/logout authentication that displays sensor readings in many different ways. The sensor readings are saved on the realtime database. The database is protected using database rules (that you've already set up in a previous tutorial).
You can apply what you learned here to display any other type of data, and you can change the files in the public folder to add different functionalities and features to your project.
We didn't explain how the javascript files work because the project is quite long. However, if there is enough interest in this subject, we can split this application into smaller projects so that you understand how to handle data using queries and how to display it in different ways. Let us know what you think in the comments below.
<h2>Data Logging to Firebase Realtime Database</h2>
In this guide, you'll learn how to log data with the ESP32 to the Firebase Realtime Database with timestamps (data logging) so that you have a record of your data history. As an example, we'll log temperature, humidity, and pressure from a BME280 sensor and we'll get timestamps from an NTP server. Then, you can access the data using the Firebase console, or build a web app to display the results (<a href="https://randomnerdtutorials.com/esp32-esp8266-firebase-gauges-charts/">check this tutorial</a>).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/12/ESP32-Firebase-Datalogging.jpg">
 <strong style="font-size: inherit;">Part 2:</k> <a style="font-size: inherit;" href="https://randomnerdtutorials.com/esp32-esp8266-firebase-gauges-charts/">ESP32/ESP8266: Firebase Data Logging Web App (Gauges, Charts, and Table)</a> 
Other Firebase Tutorials with the ESP32/ESP8266 that you might be interested in:
<a href="https://randomnerdtutorials.com/esp32-firebase-realtime-database/">ESP32: Getting Started with Firebase (Realtime Database)</a>
<a href="https://randomnerdtutorials.com/esp8266-nodemcu-firebase-realtime-database/">ESP8266 NodeMCU: Getting Started with Firebase (Realtime Database)</a>
<a href="https://randomnerdtutorials.com/esp32-firebase-web-app/">ESP32 with Firebase  Creating a Web App</a>
<a href="https://randomnerdtutorials.com/esp8266-nodemcu-firebase-web-app/">ESP8266 NodeMCU with Firebase  Creating a Web App</a>
<a href="https://randomnerdtutorials.com/esp32-esp8266-firebase-authentication/">ESP32/ESP8266 Firebase Authentication (Email and Password)</a>
<a href="https://randomnerdtutorials.com/esp32-esp8266-firebase-bme280-rtdb/">ESP32/ESP8266 Firebase: Send BME280 Sensor Readings to the Realtime Database</a>
<a href="https://randomnerdtutorials.com/esp32-esp8266-firebase-web-app-sensor/">ESP32/ESP8266: Firebase Web App to Display Sensor Readings (with Authentication)</a>
<h3>What is Firebase?</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/Firebase-logo.png">
Firebase is Google's mobile application development platform that helps you build, improve, and grow your app. It has many services used to manage data from any android, IOS, or web application like <a href="https://randomnerdtutorials.com/esp32-esp8266-firebase-authentication/">authentication</a>, <a href="https://randomnerdtutorials.com/esp32-firebase-realtime-database/">realtime database</a>, <a href="https://randomnerdtutorials.com/esp32-firebase-web-app/">hosting</a>, etc.
<h3>Project Overview</h3>
The following diagram shows a high-level overview of the project we'll build.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/12/Firebase-BME280-ESP32-Datalogging.png">
<ol>
The ESP32 authenticates as a user with email and password (that user must be set on the Firebase authentication methods);
After authentication, the ESP gets the user UID;
The database is protected with security rules. The user can only access the database nodes under the node with its user UID. After getting the user UID, the ESP can publish data to the database;
The ESP32 gets temperatrure, humidity and pressure from the BME280 sensor.
It gets epoch time right after gettings the readings (timestamp).
The ESP32 sends temperature, humidity, pressure and timestamp to the database.
New readings are added to the database periodically. You'll have a record of all readings on the Firebase realtime database.
</ol>
These are the main steps to complete this project:
<ol>
Create Firebase Project
Set Authentication Methods
Get Project API Key
Set up Realtime Database
Set up Database Security Rules
ESP32 Datalogging (Firebase Realtime Database)
</ol>
You can continue with the Firebase project <k><a href="https://randomnerdtutorials.com/esp32-esp8266-firebase-authentication/">from this previous</a> tutorial</k> or create a new project. If you use the Firebase project of that previous tutorial, you can skip to section <a style="font-size: inherit;" href="#Set-up-Realtime-Database">4) Set up Realtime Database</a> because the authentication methods are already set up.
<h3>Preparing Arduino IDE</h3>
For this tutorial, we'll program the ESP32 board using the Arduino core. So, make sure you have the ESP32 add-on installed in your Arduino IDE:
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing the ESP32 Board in Arduino IDE (Windows, Mac OS X, Linux)</a>
If you want to program the ESP boards using VS Code with the PlatformIO extension, follow the following tutorial instead:
<a href="https://randomnerdtutorials.com/vs-code-platformio-ide-esp32-esp8266-arduino/">Getting Started with VS Code and PlatformIO IDE for ESP32 and ESP8266</a>
<h3>1) Create Firebase Proje3t</h3>
<k>1)</k> Go to <a style="font-size: inherit;" href="https://firebase.google.com/" target="_blank">Firebase </a>and sign in using a Google Account.
<k>2)</k> Click <em style="font-size: inherit;">Get Started</em> and then <k>Add project</k> to create a new project.
<k>3)</k> Give a name to your project, for example, <em style="font-size: inherit;">ESP Firebase Demo</em>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/Create-firebase-project-1.png">
 <k>4)</k> Disable the option <em style="font-size: inherit;">Enable Google Analytics</em> for this project as it is not needed and click <k>Create project</k>. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/2-Set-Up-Firebase-Project-ESP32-ESP8266.png">
 <k>5)</k> It will take a few seconds to set up your project. Then, click <k>Continue</k> when it's ready. 
 <k>6)</k> You'll be redirected to your Project console page. 
<h3>2) Set Authentication Methods</h3>
To allow authentication with email and password, first, you need to set authentication methods for your app. 
Most apps need to know the identity of a user. In other words, it takes care of logging in and identifying the users (in this case, the ESP32). Knowing a user's identity allows an app to securely save user data in the cloud and provide the same personalized experience across all of the user's devices. To learn more about the authentication methods, you can <a href="https://firebase.google.com/docs/auth" target="_blank">read the documentation</a>.
<k>1)</k> On the left sidebar, click on <k>Authentication </k>and then on <k>Get started</k>. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/Firebase-Project-Authentication.png">
<k>2)</k> Select the Option <k>Email/Password</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/Authentication-methods.png">
<k>3)</k> Enable that authentication method and click <k>Save</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/Firebase-email-password-sign-in-provider.png">
<k>4)</k> The authentication with email and password should now be enabled.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/email-password-enabled.png">
<k>5)</k> Now, you need to add a user. On the <k>Authentication </k>tab, select the <k>Users </k>tab at the top. Then, click on <k>Add User</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/Firebase-Add-New-User.png">
<k>6)</k> Add an email address for the authorized user. It can be your google account email or any other email. You can also create an email for this specific project. Add a password that will allow you to sign in to your app and access the database. Don't forget to save the password in a safe place because you'll need it later. When you're done, click <k>Add user</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/Firebase-Add-User-Email-Password.png">
<k>7)</k> A new user was successfully created and added to the <k>Users</k> table.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/Users-Table-Firebase.png">
Notice that Firebase creates a unique UID for each registered user. The user UID allows us to identify the user and keep track of the user to provide or deny access to the project or the database. There's also a column that registers the date of the last sign-in. At the moment, it is empty because we haven't signed in with that user yet.
<h3>3) Get Project API Key</h3>
To interface with your Firebase project using the ESP32 board, you need to get your project API key. Follow the next steps to get your project API key.
<k>1)</k> On the left sidebar, click on <k>Project Settings</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/Firebase-project-settings.png">
<k>2)</k> Copy the Web API Key to a safe place because you'll need it later.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/Firebase-Project-Settings-Web-API-Key.png">
<h3>4) Set up Realtime Database</h3>
Now, let's create a realtime database and set up database rules for our project.
<k>1)</k> On the left sidebar, click on <k>Realtime Database</k> and then click on <k>Create Database</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/Firebase-Project-Create-Realtime-Database.png">
<k>2)</k> Select your database location. It should be the closest to your location.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/2-Set-Up-Firebase-database-ESP32-ESP8266.png">
<k>3)</k> Set up security rules for your database. You can select <k>Start in test mode</k>. We'll change the database rules in just a moment.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/3-Set-Up-Firebase-database-ESP32-ESP8266.png">
<k>4)</k> Your database is now created. You need to copy and save the database URLhighlighted in the following imagebecause you'll need it later in your ESP32 code.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/Firebase-project-database-URL.png">
<h3>5) Set up Database Security Rules</h3>
Now, let's set up the database rules. On the <k>Realtime Database</k> tab, select the <k>Rules</k> tab at the top. Then, click on <k>Edit rules</k>, copy the following rules and then click <k>Publish</k>.
<k>// These rules grant access to a node matching the authenticated
// user's ID from the Firebase auth token
{
  "rules": {
    "UsersData": {
      "$uid": {
        ".read": "$uid === auth.uid",
        ".write": "$uid === auth.uid"
      }
    }
  }
}</k>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/Firebase-Set-up-Database-Security-Rules.png">
These rules grant access to a node matching the authenticated user's UID. This grants that each authenticated user can only access its own data. This means the user can only access the nodes that are under a node with its corresponding user UID. If there are other data published on the database, not under a node with the users' UID, that user can't access that data.
For example, imagine our user UID is RjO3taAzMMXBB2Xmir2LQ. With our security rules, it can read and write data to the database under the node UsersData/RjO3taAzMMXBB2Xmir2LQ.
You'll better understand how this works when you start working with the ESP32.
<h3>6) ESP32 Datalogging (Firebase Realtime Database)</h3>
In this section, we'll program the ESP32 board to do the following tasks:
<ol>
Authenticate as a user with email and password (the user you set up in this section);
Get BME280 readings: temperature, humidity, and pressure;
Get epoch time (timestamp) from an NTP server;
Send sensor readings and timestamp to the realtime database as an authorized user.
</ol>
<h3>Parts Required</h3>
For this project, you need the following parts*:
<a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32</a> board (read <a href="https://makeradvisor.com/esp32-development-boards-review-comparison/" target="_blank">best ESP32 development boards</a>);
<a href="https://makeradvisor.com/tools/bme280-sensor-module/" target="_blank">BME280</a> or any other sensor you're familiar with;
<a href="https://makeradvisor.com/tools/mb-102-solderless-breadboard-830-points/" target="_blank">Breadboard</a>;        <a href="https://makeradvisor.com/tools/jumper-wires-kit-120-pieces/"> </a>
<a href="https://makeradvisor.com/tools/jumper-wires-kit-120-pieces/" target="_blank">Jumper wires</a>.
* you can also test the project with random values instead of sensor readings, or you can use any other sensor you're familiar with.
You can use the preceding links or go directly to <a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank">MakerAdvisor.com/tools</a> to find all the parts for your projects at the best price!
<a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/header-200.png?w=828&quality=100&strip=all&ssl=1" data-recalc-dims="1" loading="lazy" fetchpriority="low"></a>
<h3>Schematic Diagram</h3>
In this tutorial, we'll send BME280 sensor readings to the Firebase Realtime Database. So, you need to wire the BME280 sensor to your board.
We're going to use I2C communication with the BME280 sensor module. For that, wire the sensor to the default ESP32 SCL (GPIO 22) and SDA (GPIO 21) pins, as shown in the following schematic diagram.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/10/ESP32-BME280-Sensor-Temperature-Humidity-Pressure-Wiring-Diagram-Circuit_f.png">
Not familiar with the BME280 with the ESP32? Read this tutorial: <a href="https://randomnerdtutorials.com/esp32-bme280-arduino-ide-pressure-temperature-humidity/"><k>ESP32 with BME280 Sensor using Arduino IDE (Pressure, Temperature, Humidity)</k></a>.
<h3>Installing Libraries</h3>
For this project, you need to install the following libraries:
<a href="https://github.com/mobizt/Firebase-ESP-Client" target="_blank">Firebase ESP Client Library</a>
<a href="https://github.com/adafruit/Adafruit_BME280_Library" target="_blank">Adafruit BME280 Library</a>
<a href="https://github.com/adafruit/Adafruit_Sensor" target="_blank">Adafruit Unified Sensor Library</a>
<h4>Installing Libraries  VS Code</h4>
Follow the next instructions if you're using VS Code with the PlatformIO extension.
<h5><k>Install the Firebase-ESP-Client Library</k></h5>
There is a library with lots of examples to use Firebase with the ESP32: the <a href="https://github.com/mobizt/Firebase-ESP-Client" target="_blank">Firebase-ESP-Client library</a>. This library is compatible with both the ESP32 and ESP8266 boards.
Click on the <k>PIO Home</k> icon and select the <k>Libraries tab</k>. Search for <k>Firebase ESP Client</k>. Select the <k>Firebase Arduino Client Library for ESP8266 and ESP32</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/Install-Firebase-Library-VS-Code-1.png">
Then, click <k>Add to Project</k> and select the project you're working on.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/Install-Firebase-Library-VS-Code-2.png">
<k>Install the BME280 Library</k> 
In the <k>Libraries</k> tab, search for <k>BME280</k>. Select the <k>Adafruit BME280</k> library.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/PlatformIO-VS-Code-Search-BME280-library.png">
 Then, click <k>Add to Project</k> and select the project you're working on.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/PlatformIO-add-library-to-project.png">
Also, change the monitor speed to 115200 by adding the following line to the platformio.ini file of your project:
<k>monitor_speed = 115200</k>
<h4>Installation  Arduino IDE</h4>
Follow this section if you're using Arduino IDE. 
You need to install the following libraries:
<a href="https://github.com/mobizt/Firebase-ESP-Client" target="_blank">Firebase ESP Client Library</a>
<a href="https://github.com/adafruit/Adafruit_BME280_Library" target="_blank">Adafruit BME280 Library</a>
<a href="https://github.com/adafruit/Adafruit_Sensor" target="_blank">Adafruit Unified Sensor Library</a>
Go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k>, search for the libraries' names and install the libraries.
For the Firebase Client library, select the <k>Firebase Arduino Client Library for ESP8266 and ESP32</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/Install-Firebase-ESP-Client-Library-Arduino-IDE-f.png">
Now, you're all set to start programming the ESP32 board to interact with the database.
<h3>
DataloggingFirebase Realtime Database Code</h3>
Copy the following code to your Arduino IDE or to the main.cpp file if you're using VS Code.
You need to insert your network credentials, project API key, database URL, and the authorized user email and password.
<k>/*
  Rui Santos
  Complete project details at our blog: https://RandomNerdTutorials.com/esp32-data-logging-firebase-realtime-database/
  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files.
  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
*/
#include &lt;Arduino.h>
#include &lt;WiFi.h>
#include &lt;Firebase_ESP_Client.h>
#include &lt;Wire.h>
#include &lt;Adafruit_Sensor.h>
#include &lt;Adafruit_BME280.h>
#include "time.h"
// Provide the token generation process info.
#include "addons/TokenHelper.h"
// Provide the RTDB payload printing info and other helper functions.
#include "addons/RTDBHelper.h"
// Insert your network credentials
#define WIFI_SSID "REPLACE_WITH_YOUR_SSID"
#define WIFI_PASSWORD "REPLACE_WITH_YOUR_PASSWORD"
// Insert Firebase project API Key
#define API_KEY "REPLACE_WITH_YOUR_PROJECT_API_KEY"
// Insert Authorized Email and Corresponding Password
#define USER_EMAIL "REPLACE_WITH_THE_USER_EMAIL"
#define USER_PASSWORD "REPLACE_WITH_THE_USER_PASSWORD"
// Insert RTDB URLefine the RTDB URL
#define DATABASE_URL "REPLACE_WITH_YOUR_DATABASE_URL"
// Define Firebase objects
FirebaseData fbdo;
FirebaseAuth auth;
FirebaseConfig config;
// Variable to save USER UID
String uid;
// Database main path (to be updated in setup with the user UID)
String databasePath;
// Database child nodes
String tempPath = "/temperature";
String humPath = "/humidity";
String presPath = "/pressure";
String timePath = "/timestamp";
// Parent Node (to be updated in every loop)
String parentPath;
int timestamp;
FirebaseJson json;
const char* ntpServer = "pool.ntp.org";
// BME280 sensor
Adafruit_BME280 bme; // I2C
float temperature;
float humidity;
float pressure;
// Timer variables (send new readings every three minutes)
unsigned long sendDataPrevMillis = 0;
unsigned long timerDelay = 180000;
// Initialize BME280
void initBME(){
  if (!bme.begin(0x76)) {
    Serial.println("Could not find a valid BME280 sensor, check wiring!");
    while (1);
  }
}
// Initialize WiFi
void initWiFi() {
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  Serial.print("Connecting to WiFi ..");
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print('.');
    delay(1000);
  }
  Serial.println(WiFi.localIP());
  Serial.println();
}
// Function that gets current epoch time
unsigned long getTime() {
  time_t now;
  struct tm timeinfo;
  if (!getLocalTime(&timeinfo)) {
    //Serial.println("Failed to obtain time");
    return(0);
  }
  time(&now);
  return now;
}
void setup(){
  Serial.begin(115200);
  // Initialize BME280 sensor
  initBME();
  initWiFi();
  configTime(0, 0, ntpServer);
  // Assign the api key (required)
  config.api_key = API_KEY;
  // Assign the user sign in credentials
  auth.user.email = USER_EMAIL;
  auth.user.password = USER_PASSWORD;
  // Assign the RTDB URL (required)
  config.database_url = DATABASE_URL;
  Firebase.reconnectWiFi(true);
  fbdo.setResponseSize(4096);
  // Assign the callback function for the long running token generation task */
  config.token_status_callback = tokenStatusCallback; //see addons/TokenHelper.h
  // Assign the maximum retry of token generation
  config.max_token_generation_retry = 5;
  // Initialize the library with the Firebase authen and config
  Firebase.begin(&config, &auth);
  // Getting the user UID might take a few seconds
  Serial.println("Getting User UID");
  while ((auth.token.uid) == "") {
    Serial.print('.');
    delay(1000);
  }
  // Print user UID
  uid = auth.token.uid.c_str();
  Serial.print("User UID: ");
  Serial.println(uid);
  // Update database path
  databasePath = "/UsersData/" + uid + "/readings";
}
void loop(){
  // Send new readings to database
  if (Firebase.ready() && (millis() - sendDataPrevMillis > timerDelay || sendDataPrevMillis == 0)){
    sendDataPrevMillis = millis();
    //Get current timestamp
    timestamp = getTime();
    Serial.print ("time: ");
    Serial.println (timestamp);
    parentPath= databasePath + "/" + String(timestamp);
    json.set(tempPath.c_str(), String(bme.readTemperature()));
    json.set(humPath.c_str(), String(bme.readHumidity()));
    json.set(presPath.c_str(), String(bme.readPressure()/100.0F));
    json.set(timePath, String(timestamp));
    Serial.printf("Set json... %s\n", Firebase.RTDB.setJSON(&fbdo, parentPath.c_str(), &json) ? "ok" : fbdo.errorReason().c_str());
  }
}
</k>
<a href="https://github.com/RuiSantosdotme/Firebase-ESP/raw/main/ESP32-Firebase-Datalogging/ESP32-Firebase-Datalogging.ino" target="_blank">View raw code</a>
<h3>How the Code Works</h3>
Continue reading to learn how the code works or skip to the demonstration section.
<h4>Include Libraries</h4>
First, include the required libraries. The WiFi.h library to connect the ESP32 to the internet, the Firebase_ESP_Client.h  library to interface the boards with Firebase, the Wire, Adafruit_Sensor, and Adafruit_BME280 to interface with the BME280 sensor, and the time library to get the time.
<k>#include &lt;Arduino.h>
#include &lt;WiFi.h>
#include &lt;Firebase_ESP_Client.h>
#include &lt;Wire.h>
#include &lt;Adafruit_Sensor.h>
#include &lt;Adafruit_BME280.h>
#include "time.h"</k>
You also need to include the following for the Firebase library to work.
<k>// Provide the token generation process info.
#include "addons/TokenHelper.h"
// Provide the RTDB payload printing info and other helper functions.
#include "addons/RTDBHelper.h"</k>
<h4>Network Credentials</h4>
Include your network credentials in the following lines so that your boards can connect to the internet using your local network.
<k>// Insert your network credentials
#define WIFI_SSID "REPLACE_WITH_YOUR_SSID"
#define WIFI_PASSWORD "REPLACE_WITH_YOUR_PASSWORD"</k>
<h4>Firebase Project API Key, Firebase User, and Database URL</h4>
Insert your Firebase project API keythe one you've gotten in this section.
<k>#define API_KEY "REPLACE_WITH_YOUR_PROJECT_API_KEY"</k>
Insert the authorized email and the corresponding passwordthese are the details of the user you've added in this section.
<k>// Insert Authorized Email and Corresponding Password
#define USER_EMAIL "REPLACE_WITH_THE_USER_EMAIL"
#define USER_PASSWORD "REPLACE_WITH_THE_USER_PASSWORD"</k>
Insert your database URL in the following line:
<k>// Insert RTDB URLefine the RTDB URL
#define DATABASE_URL "REPLACE_WITH_YOUR_DATABASE_URL"</k>
<h4>Firebase Objects and Other Variables</h4>
The following line defines a FirebaseData object.
<k>FirebaseData fbdo;</k>
The next line defines a FirebaseAuth object needed for authentication.
<k>FirebaseAuth auth;</k>
Finally, the following line defines a FirebaseConfig object required for configuration data.
<k>FirebaseConfig config;</k>
The uid variable will be used to save the user's UID. We can get the user's UID after the authentication.
<k>String uid;</k>
The databasePath variable saves the database main path, which will be updated later with the user UID.
<k>String databasePath;</k>
The following variables save the database child nodes for the temperature, humidity, pressure, and timestamp.
<k>String tempPath = "/temperature";
String humPath = "/humidity";
String presPath = "/pressure";
String timePath = "/timestamp";</k>
The parentPath is the parent node that will be updated in every loop with the current timestamp.
<k>// Parent Node (to be updated in every loop)
String parentPath;</k>
To better understand how we'll organize our data, here's a diagram.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/12/Firebase-BME280-datalogging-database.png">
It might seem redundant to save the timestamp twice (in the parent node and in the child node), however, having all the data at the same level of the hierarchy will make things simpler in the future, if we want to build a web app to display the data.
The timestamp variable will be used to save time (epoch time format).
<k>int timestamp;</k>
To learn more about getting epoch time with the ESP32 board, you can check the following tutorial:
<a href="https://randomnerdtutorials.com/epoch-unix-time-esp32-arduino/">Get Epoch/Unix Time with the ESP32 (Arduino IDE)</a>
We'll send all the readings and corresponding timestamp to the realtime database at the same time by creating a JSON object that contains the values of those variables. The ESP Firebase Client library has its own JSON methods. We'll use them to send data in JSON format to the database. We start by creating a variable of type FirebaseJson called json.
<k>FirebaseJson json;</k>
The ESP_Firebase_Client library provides some examples showing how to use FirebaseJson and how to send data in JSON format to the database: <a href="https://github.com/mobizt/Firebase-ESP-Client/tree/main/examples/FirebaseJson" target="_blank">ESP_Firebase_Client library FirebaseJson examples.</a>
We'll request the time from <em>pool.ntp.org</em>, which is a cluster of time servers that anyone can use to request the time.
<k>const char* ntpServer = "pool.ntp.org";</k>
Then, create an Adafruit_BME280 object called bme. This automatically creates a sensor object on the ESP32 default I2C pins.
<k>Adafruit_BME280 bme; // I2C</k>
The following variables will hold the temperature, humidity, and pressure readings from the sensor.
<k>float temperature;
float humidity;
float pressure;</k>
<h4>Delay Time</h4>
The sendDataPrevMillis and timerDelay variables are used to check the delay time between each send. In this example, we're setting the delay time to 3 minutes (18000 milliseconds). Once you test this project and check that everything is working as expected, we recommend increasing the delay.
<k>// Timer variables (send new readings every three minutes)
unsigned long sendDataPrevMillis = 0;
unsigned long timerDelay = 180000;</k>
<h4>initBME()</h4>
The initBME() function initializes the BME280 library using the bme object created previously. Then, you should call this library in the setup().
<k>void initBME(){
  if (!bme.begin(0x76)) {
    Serial.println("Could not find a valid BME280 sensor, check wiring!");
    while (1);
  }
}</k>
<h4>initWiFi()</h4>
The initWiFi() function connects your ESP to the internet using the network credentials provided. You must call this function later in the setup() to initialize WiFi.
<k>// Initialize WiFi
void initWiFi() {
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  Serial.print("Connecting to WiFi ..");
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print('.');
    delay(1000);
  }
  Serial.println(WiFi.localIP());
  Serial.println();
}</k>
<h4>getTime()</h4>
The getTime() function returns the current epoch time.
<k>// Function that gets current epoch time
unsigned long getTime() {
  time_t now;
  struct tm timeinfo;
  if (!getLocalTime(&timeinfo)) {
    //Serial.println("Failed to obtain time");
    return(0);
  }
  time(&now);
  return now;
}</k>
<h4>setup()</h4>
In setup(), initialize the Serial Monitor for debugging purposes at a baud rate of 115200.
<k>Serial.begin(115200);</k>
Call the initBME() function to initialize the BME280 sensor.
<k>initBME();</k>
Call the initWiFi() function to initialize WiFi.
<k>initWiFi();</k>
Configure the time:
<k>configTime(0, 0, ntpServer);</k>
Assign the API key to the Firebase configuration.
<k>config.api_key = API_KEY;</k>
The following lines assign the email and password to the Firebase authentication object.
<k>auth.user.email = USER_EMAIL;
auth.user.password = USER_PASSWORD;</k>
Assign the database URL to the Firebase configuration object.
<k>config.database_url = DATABASE_URL;</k>
Add the following to the configuration object.
<k>// Assign the callback function for the long running token generation task
config.token_status_callback = tokenStatusCallback; //see addons/TokenHelper.h
// Assign the maximum retry of token generation
config.max_token_generation_retry = 5;</k>
Initialize the Firebase library (authenticate) with the configuration and authentication settings we defined earlier.
<k>// Initialize the library with the Firebase authen and config
Firebase.begin(&config, &auth);</k>
After initializing the library, we can get the user UID by calling auth.token.uid. Getting the user's UID might take some time, so we add a while loop that waits until we get it.
<k>// Getting the user UID might take a few seconds
Serial.println("Getting User UID");
while ((auth.token.uid) == "") {
  Serial.print('.');
  delay(1000);
}</k>
Finally, we save the user's UID in the uid variable and print it in the Serial Monitor.
<k>uid = auth.token.uid.c_str();
Serial.print("User UID: ");
Serial.print(uid);</k>
After getting the user UID, we can update the database path to include the user UID.
<k>// Update database path
databasePath = "/UsersData/" + uid + "/readings";</k>
<h4>loop()</h4>
In the loop(), check if it is time to send new readings:
<k>if (Firebase.ready() && (millis() - sendDataPrevMillis > timerDelay || sendDataPrevMillis == 0)){
  sendDataPrevMillis = millis();</k>
If it is, get the current time and save it in the timestamp variable.
<k>//Get current timestamp
timestamp = getTime();
Serial.print ("time: ");
Serial.println (timestamp);</k>
Update the parentPath variable to include the timestamp.
<k>parentPath= databasePath + "/" + String(timestamp);
</k>
Then, add data to the json object by using the set() method and passing as first argument the child node destination (key) and as second argument the value:
<k>json.set(tempPath.c_str(), String(bme.readTemperature()));
json.set(humPath.c_str(), String(bme.readHumidity()));
json.set(presPath.c_str(), String(bme.readPressure()/100.0F));
json.set(timePath, String(timestamp));
</k>
Finally, call Firebase.RTDB.setJSON(&fbdo, parentPath.c_str(), &json) to append the data to the parent path. We can call that instruction inside a Serial.printf() command to print the results in the Serial Monitor at the same time the command runs.
<k>Serial.printf("Set json... %s\n", Firebase.RTDB.setJSON(&fbdo, parentPath.c_str(), &json) ? "ok" : fbdo.errorReason().c_str());</k>
<h3>Demonstration</h3>
Upload the previous code to your ESP32 board. Don't forget to insert your network credentials, project API key, database URL, user email, and the corresponding password.
After uploading the code, press the board RST button so that it starts running the code. It should authenticate to Firebase, get the user UID, and immediately send new readings to the database.
Open the Serial Monitor at a baud rate of 115200 and check that everything is working as expected.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/12/ESP-Send-JSON-Firebase-Serial-Monitor.png">
Aditionally, go to the Realtime Database on your Firebase project interface and check that new readings are saved. Notice that it saves the data under a node with the own user UIDthis is a way to restrict access to the database.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/12/ESP-Firebase-Realtime-Database-Data-Logging.png">
Wait some time until you get some readings on the database. Expand the nodes to check the data.
<h3>Wrapping Up</h3>
In this tutorial, you learned how to log your sensor readings with timestamps to the Firebase Realtime Database using the ESP32. This was just a simple example for you to understand how it works. 
You can use other methods provided by the ESP_Firebase_Client library to log your data, and you can organize your database in different ways. We organized the database in a way that is convenient for another project that we'll publish soon.
In PART 2, we'll create a Firebase Web App to display all saved data in a table and the latest readings on charts.
<k>Part 2:</k> <a href="https://randomnerdtutorials.com/esp32-esp8266-firebase-gauges-charts/">ESP32/ESP8266: Firebase Data Logging Web App (Gauges, Charts, and Table)</a> 
We hope you've found this tutorial useful.
If you like Firebase projects, please take a look at our new eBook. We're sure you'll like it:
<k><a href="https://randomnerdtutorials.com/firebase-esp32-esp8266-ebook/">Firebase Web App with ESP32 and ESP8266</a></k>
<h2>CAM Save Picture in Firebase Storage</h2>
In this guide, you'll learn how to take and upload a picture to Firebase Storage using the ESP32-CAM. You'll create a Firebase project with Storage that allows you to store your files. Then, you can access your Firebase console to visualize the pictures or create a web app to display them (we'll do this in a future tutorial). The ESP32-CAM will be programmed using Arduino IDE.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/11/ESP32-CAM-Firebase-Storage.jpg">
<em>Updated 19 September 2023.</em>
<k>Note: </k>this project is compatible with any <a href="https://makeradvisor.com/esp32-camera-cam-boards-review-comparison/" target="_blank">ESP32 Camera Board with the OV2640 camera</a>. You just need to make sure you use the right <a href="https://randomnerdtutorials.com/esp32-cam-ai-thinker-pinout/">pinout for the board</a> you're using.
<h3>What is Firebase?</h3>
<img class="lazy" data-src="https://i2.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/Firebase-logo.png">
Firebase is Google's mobile application development platform that helps you build, improve, and grow your app. It has many services used to manage data from any Android, IOS, or web application like <a href="https://randomnerdtutorials.com/esp32-esp8266-firebase-authentication/">authentication</a>, <a href="https://randomnerdtutorials.com/esp32-firebase-realtime-database/">realtime database</a>, <a href="https://randomnerdtutorials.com/esp32-firebase-web-app/">hosting</a>, storage, etc.
<h3>Project Overview</h3>
This simple tutorial exemplifies how to take and send photos taken with the ESP32-CAM to Firebase Storage. The ESP32-CAM takes a picture and sends it to Firebase every time it resets (press the RST button). The idea is that you add some sort of trigger that might be useful for your projects, like a <a href="https://randomnerdtutorials.com/esp32-cam-pir-motion-detector-photo-capture/">PIR motion sensor</a> or a pushbutton, for example.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/01/ESP32-CAM-Firebase-Storage-Project-Overview-update.png">
When the ESP32 first runs, it takes a new picture and saves it in the filesystem (LittleFS);
The ESP32-CAM connects to Firebase as a user with email and password;
The ESP32-CAM sends the picture to Firebase Storage;
After that, you can go to your Firebase console to view the pictures;
Later, you can build a web app that you can access from anywhere to display the ESP32-CAM pictures (we'll create this in a future tutorial).
<h3>Contents</h3>
Here's a summary of the steps you need to follow to create this project.
<ol>
Create a Firebase Project
Set Authentication Methods
Create Storage Bucket
Get Project API Key
ESP32-CAM Send Pictures to Firebase Storage
</ol>
<h3>1) Create a Firebase Project</h3>
<k>1)</k> Go to <a style="font-size: inherit;" href="https://firebase.google.com/" target="_blank">Firebase </a>and sign in using a Google Account.
<k>2)</k> Click <k>Get Started</k> and then <k>Add project</k> to create a new project.
<k>3)</k> Give a name to your project, for example: <em style="font-size: inherit;">ESP Firebase Demo</em>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/Create-firebase-project-1.png">
 <k>4)</k> Disable the option <em style="font-size: inherit;">Enable Google Analytics</em> for this project as it is not needed and click <k>Create project</k>. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/2-Set-Up-Firebase-Project-ESP32-ESP8266.png">
 <k>5)</k> It will take a few seconds to set up your project. Then, click <em style="font-size: inherit;">Continue </em>when it's ready. 
 <k>6)</k> You'll be redirected to your Project console page. 
<h3>2) Set Authentication Methods</h3>
To allow authentication with email and password, first, you need to set authentication methods for your app. 
Most apps need to know the identity of a user. In other words, it takes care of logging in and identifying the users (in this case, the ESP32-CAM). Knowing a user's identity allows an app to securely save user data in the cloud and provide the same personalized experience across all of the user's devices. To learn more about the authentication methods, you can <a href="https://firebase.google.com/docs/auth" target="_blank">read the documentation</a>.
<k>1)</k> On the left sidebar, click on <k>Authentication </k>and then on <k>Get started</k>. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/Firebase-Project-Authentication.png">
<k>2)</k> Select the Option <k>Email/Password</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/Authentication-methods.png">
<k>3)</k> Enable that authentication method and click <k>Save</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/Firebase-email-password-sign-in-provider.png">
<k>4)</k> The authentication with email and password should now be enabled.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/email-password-enabled.png">
<k>5)</k> Now, you need to add a user. Still on the <k>Authentication </k>tab, select the <k>Users </k>tab at the top. Then, click on <k>Add User</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/Firebase-Add-New-User.png">
<k>6)</k> Add an email address for the authorized user. It can be your google account email or any other email. You can also create an email for this specific project. Add a password that will allow you to sign in to your app and access the storage files. Don't forget to save the password in a safe place because you'll need it later. When you're done, click <k>Add user</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/Firebase-Add-User-Email-Password.png">
<k>7)</k> A new user was successfully created and added to the <k>Users</k> table.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/Users-Table-Firebase.png">
Notice that Firebase creates a unique UID for each registered user. The user UID allows us to identify the user and keep track of the user to provide or deny access to the project or the database. There's also a column that registers the date of the last sign-in. At the moment, it is empty because we haven't signed in with that user yet.
<h3>3) Create Storage Bucket</h3>
 <k>1)</k> On the left sidebar, click on <k>Storage </k>and then on <k>Get started</k>. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/11/Firebase-Storage-Get-Started.png">
<k>2) </k>Select <em>Start in <k>test mode</k></em>click <k>Next</k>. We'll change the storage rules later on.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/01/Create-storage-bucket-Firebase.png">
<k>3) </k>Select your storage locationit should be the closest to your country.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/11/firebase-storage-location.png">
<k>4)</k> Wait a few seconds while it creates the storage bucket.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/11/Firebase-Creating-Storage-Bucket.png">
<k>5)</k> The storage bucket is now set up. Copy the storage bucket ID because you'll need it later (copy only the section highlighted with a red rectangle as shown below).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/11/Firebase-Storage-Bucket-Set-Up-ID.png">
<h3>Storage Rules</h3>
We'll change the storage rules so that only authenticated users can upload files to the storage bucket. Select the <k>Rules</k> tab.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/10/storage-rules.png">
Change your database rules. Use the following rules:
<k>rules_version = '2';
service firebase.storage {
  match /b/{bucket}/o {
    match /{allPaths=**} {
      allow read, write: if request.auth !=null;
    }
  }
}</k>
When you're done, click <k>Publish</k>.
<h3>4) Get Project API Key</h3>
To interface with your Firebase project using the ESP32-CAM, you need to get your project API key. Follow the next steps to get your project API key.
<k>1)</k> On the left sidebar, click on <k>Project Settings</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/Firebase-project-settings.png">
<k>2)</k> Copy the Web API Key to a safe place because you'll need it later.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/Firebase-Project-Settings-Web-API-Key.png">
<hr>
<h3>5) ESP32-CAM  Send Pictures to Firebase Storage</h3>
Before proceeding with the tutorial, make sure you check the following prerequisites.
<h3>Installing the ESP32 add-on</h3>
We'll program the ESP32-CAM board using Arduino IDE. So you need the Arduino IDE installed as well as the ESP32 add-on. Follow the next tutorial to install it, if you haven't already.
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-mac-and-linux-instructions/">Installing the ESP32 Board in Arduino IDE (Mac OS X and Linux instructions)</a>
<h3>Installing ESP Firebase Client Library</h3>
The <a href="https://github.com/mobizt/Firebase-ESP-Client" target="_blank">Firebase-ESP-Client library</a> provides several examples to interface with Firebase services. It provides an example that shows how to send files to Firebase Storage. Our code we'll be based on that example. So, you need to make sure you have that library installed.
<h4>Installation  VS Code + PlatformIO</h4>
If you're using VS Code with the PlatformIO extension, click on the <k>PIO Home</k> icon and select the <k>Libraries tab</k>. Search for <k>Firebase ESP Client </k>. Select the <k>Firebase Arduino Client Library for ESP8266 and ESP32</k>.
<img class="lazy" data-src="https://i1.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/Install-Firebase-Library-VS-Code-1.png">
Then, click <k>Add to Project</k> and select the project you're working on.
<img class="lazy" data-src="https://i1.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/Install-Firebase-Library-VS-Code-2.png">
Also, change the monitor speed to 115200 by adding the following line to the platformio.ini file of your project:
<k>monitor_speed = 115200</k>
<h4>Installation  Arduino IDE</h4>
If you're using Arduino IDE, follow the next steps to install the library.
<ol>
Go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k>
Search for <em>Firebase ESP Client</em> and install the <em>Firebase Arduino Client Library for ESP8266 and ESP32</em> by Mobizt.
</ol>
<img class="lazy" data-src="https://i2.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/Install-Firebase-ESP-Client-Library-Arduino-IDE-f.png">
Now, you're all set to start programming the ESP32-CAM board to send pictures to Firebase Storage.
<h3>ESP32-CAM Send Pictures to Firebase  Code</h3>
Copy the following code to your Arduino IDE, or to the main.cpp file if you're using VS Code. It takes a picture and sends it to Firebase when it first boots.
<k>/*********
  Rui Santos
  Complete instructions at: https://RandomNerdTutorials.com/esp32-cam-save-picture-firebase-storage/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files.
  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
  Based on the example provided by the ESP Firebase Client Library
*********/
#include "Arduino.h"
#include "WiFi.h"
#include "esp_camera.h"
#include "soc/soc.h"           // Disable brownout problems
#include "soc/rtc_cntl_reg.h"  // Disable brownout problems
#include "driver/rtc_io.h"
#include &lt;LittleFS.h>
#include &lt;FS.h>
#include &lt;Firebase_ESP_Client.h>
//Provide the token generation process info.
#include &lt;addons/TokenHelper.h>
//Replace with your network credentials
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
// Insert Firebase project API Key
#define API_KEY "REPLACE_WITH_YOUR_FIREBASE_PROJECT_API_KEY"
// Insert Authorized Email and Corresponding Password
#define USER_EMAIL "REPLACE_WITH_THE_AUTHORIZED_USER_EMAIL"
#define USER_PASSWORD "REPLACE_WITH_THE_AUTHORIZED_USER_PASSWORD"
// Insert Firebase storage bucket ID e.g bucket-name.appspot.com
#define STORAGE_BUCKET_ID "REPLACE_WITH_YOUR_STORAGE_BUCKET_ID"
// For example:
//#define STORAGE_BUCKET_ID "esp-iot-app.appspot.com"
// Photo File Name to save in LittleFS
#define FILE_PHOTO_PATH "/photo.jpg"
#define BUCKET_PHOTO "/data/photo.jpg"
// OV2640 camera module pins (CAMERA_MODEL_AI_THINKER)
#define PWDN_GPIO_NUM     32
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM      0
#define SIOD_GPIO_NUM     26
#define SIOC_GPIO_NUM     27
#define Y9_GPIO_NUM       35
#define Y8_GPIO_NUM       34
#define Y7_GPIO_NUM       39
#define Y6_GPIO_NUM       36
#define Y5_GPIO_NUM       21
#define Y4_GPIO_NUM       19
#define Y3_GPIO_NUM       18
#define Y2_GPIO_NUM        5
#define VSYNC_GPIO_NUM    25
#define HREF_GPIO_NUM     23
#define PCLK_GPIO_NUM     22
boolean takeNewPhoto = true;
//Define Firebase Data objects
FirebaseData fbdo;
FirebaseAuth auth;
FirebaseConfig configF;
void fcsUploadCallback(FCS_UploadStatusInfo info);
bool taskCompleted = false;
// Capture Photo and Save it to LittleFS
void capturePhotoSaveLittleFS( void ) {
  // Dispose first pictures because of bad quality
  camera_fb_t* fb = NULL;
  // Skip first 3 frames (increase/decrease number as needed).
  for (int i = 0; i &lt; 4; i++) {
    fb = esp_camera_fb_get();
    esp_camera_fb_return(fb);
    fb = NULL;
  }
    
  // Take a new photo
  fb = NULL;  
  fb = esp_camera_fb_get();  
  if(!fb) {
    Serial.println("Camera capture failed");
    delay(1000);
    ESP.restart();
  }  
  // Photo file name
  Serial.printf("Picture file name: %s\n", FILE_PHOTO_PATH);
  File file = LittleFS.open(FILE_PHOTO_PATH, FILE_WRITE);
  // Insert the data in the photo file
  if (!file) {
    Serial.println("Failed to open file in writing mode");
  }
  else {
    file.write(fb->buf, fb->len); // payload (image), payload length
    Serial.print("The picture has been saved in ");
    Serial.print(FILE_PHOTO_PATH);
    Serial.print(" - Size: ");
    Serial.print(fb->len);
    Serial.println(" bytes");
  }
  // Close the file
  file.close();
  esp_camera_fb_return(fb);
}
void initWiFi(){
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println("Connecting to WiFi...");
  }
}
void initLittleFS(){
  if (!LittleFS.begin(true)) {
    Serial.println("An Error has occurred while mounting LittleFS");
    ESP.restart();
  }
  else {
    delay(500);
    Serial.println("LittleFS mounted successfully");
  }
}
void initCamera(){
 // OV2640 camera module
  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer = LEDC_TIMER_0;
  config.pin_d0 = Y2_GPIO_NUM;
  config.pin_d1 = Y3_GPIO_NUM;
  config.pin_d2 = Y4_GPIO_NUM;
  config.pin_d3 = Y5_GPIO_NUM;
  config.pin_d4 = Y6_GPIO_NUM;
  config.pin_d5 = Y7_GPIO_NUM;
  config.pin_d6 = Y8_GPIO_NUM;
  config.pin_d7 = Y9_GPIO_NUM;
  config.pin_xclk = XCLK_GPIO_NUM;
  config.pin_pclk = PCLK_GPIO_NUM;
  config.pin_vsync = VSYNC_GPIO_NUM;
  config.pin_href = HREF_GPIO_NUM;
  config.pin_sscb_sda = SIOD_GPIO_NUM;
  config.pin_sscb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn = PWDN_GPIO_NUM;
  config.pin_reset = RESET_GPIO_NUM;
  config.xclk_freq_hz = 20000000;
  config.pixel_format = PIXFORMAT_JPEG;
  config.grab_mode = CAMERA_GRAB_LATEST;
  if (psramFound()) {
    config.frame_size = FRAMESIZE_UXGA;
    config.jpeg_quality = 10;
    config.fb_count = 1;
  } else {
    config.frame_size = FRAMESIZE_SVGA;
    config.jpeg_quality = 12;
    config.fb_count = 1;
  }
  // Camera init
  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed with error 0x%x", err);
    ESP.restart();
  } 
}
void setup() {
  // Serial port for debugging purposes
  Serial.begin(115200);
  initWiFi();
  initLittleFS();
  // Turn-off the 'brownout detector'
  WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0);
  initCamera();
  //Firebase
  // Assign the api key
  configF.api_key = API_KEY;
  //Assign the user sign in credentials
  auth.user.email = USER_EMAIL;
  auth.user.password = USER_PASSWORD;
  //Assign the callback function for the long running token generation task
  configF.token_status_callback = tokenStatusCallback; //see addons/TokenHelper.h
  Firebase.begin(&configF, &auth);
  Firebase.reconnectWiFi(true);
}
void loop() {
  if (takeNewPhoto) {
    capturePhotoSaveLittleFS();
    takeNewPhoto = false;
  }
  delay(1);
  if (Firebase.ready() && !taskCompleted){
    taskCompleted = true;
    Serial.print("Uploading picture... ");
    //MIME type should be valid to avoid the download problem.
    //The file systems for flash and SD/SDMMC can be changed in FirebaseFS.h.
    if (Firebase.Storage.upload(&fbdo, STORAGE_BUCKET_ID /* Firebase Storage bucket id */, FILE_PHOTO_PATH /* path to local file */, mem_storage_type_flash /* memory storage type, mem_storage_type_flash and mem_storage_type_sd */, BUCKET_PHOTO /* path of remote file stored in the bucket */, "image/jpeg" /* mime type */,fcsUploadCallback)){
      Serial.printf("\nDownload URL: %s\n", fbdo.downloadURL().c_str());
    }
    else{
      Serial.println(fbdo.errorReason());
    }
  }
}
// The Firebase Storage upload callback function
void fcsUploadCallback(FCS_UploadStatusInfo info){
    if (info.status == firebase_fcs_upload_status_init){
        Serial.printf("Uploading file %s (%d) to %s\n", info.localFileName.c_str(), info.fileSize, info.remoteFileName.c_str());
    }
    else if (info.status == firebase_fcs_upload_status_upload)
    {
        Serial.printf("Uploaded %d%s, Elapsed time %d ms\n", (int)info.progress, "%", info.elapsedTime);
    }
    else if (info.status == firebase_fcs_upload_status_complete)
    {
        Serial.println("Upload completed\n");
        FileMetaInfo meta = fbdo.metaData();
        Serial.printf("Name: %s\n", meta.name.c_str());
        Serial.printf("Bucket: %s\n", meta.bucket.c_str());
        Serial.printf("contentType: %s\n", meta.contentType.c_str());
        Serial.printf("Size: %d\n", meta.size);
        Serial.printf("Generation: %lu\n", meta.generation);
        Serial.printf("Metageneration: %lu\n", meta.metageneration);
        Serial.printf("ETag: %s\n", meta.etag.c_str());
        Serial.printf("CRC32: %s\n", meta.crc32.c_str());
        Serial.printf("Tokens: %s\n", meta.downloadTokens.c_str());
        Serial.printf("Download URL: %s\n\n", fbdo.downloadURL().c_str());
    }
    else if (info.status == firebase_fcs_upload_status_error){
        Serial.printf("Upload failed, %s\n", info.errorMsg.c_str());
    }
}
</k>
<a href="https://github.com/RuiSantosdotme/Firebase-ESP/raw/main/ESP32-CAM-Save-Picture-Firebase-Storage/ESP32-CAM-Save-Picture-Firebase-Storage.ino" target="_blank">View raw code</a>
You need to insert your network credentials, storage bucket ID, and project API key for the project to work.
This sketch was based on a <a href="https://github.com/mobizt/Firebase-ESP-Client/tree/main/examples/Storage/FirebaseStorage/UploadFile" target="_blank">basic example provided by the library</a>. You can find more examples <a href="https://github.com/mobizt/Firebase-ESP-Client/tree/main/examples" target="_blank">here</a>.
<h3>How the Code Works</h3>
Continue reading to learn how the code works or skip to the demonstration section.
<h4>Libraries</h4>
First, include the required libraries.
<k>#include "WiFi.h"
#include "esp_camera.h"
#include "Arduino.h"
#include "soc/soc.h"           // Disable brownout problems
#include "soc/rtc_cntl_reg.h"  // Disable brownout problems
#include "driver/rtc_io.h"
#include &lt;LittleFS.h>
#include &lt;FS.h>
#include &lt;Firebase_ESP_Client.h>
//Provide the token generation process info.
#include &lt;addons/TokenHelper.h></k>
<h4>Network Credentials</h4>
Insert your network credentials in the following variables so that the ESP can connect to the internet and communicate with Firebase.
<k>//Replace with your network credentials
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
<h4>Firebase Project API Key</h4>
Insert your Firebase project API keysee this section: 4) Get Project API Key.
<k>// Insert Firebase project API Key
#define API_KEY "REPLACE_WITH_YOUR_FIREBASE_PROJECT_API_KEY."</k>
<h4>User Email and Password</h4>
Insert the authorized email and the corresponding passwordsee this section: 2) Set Authentication Methods.
<k>#define USER_EMAIL "REPLACE_WITH_THE_AUTHORIZED_USER_EMAIL"
#define USER_PASSWORD "REPLACE_WITH_THE_AUTHORIZED_USER_PASSWORD"</k>
<h4>Firebase Storage Bucket ID</h4>
Insert the Firebase storage bucket ID, e.g <em>bucket-name.appspot.com</em>. In my case, it is esp-firebase-demo.appspot.com. (remove any slashes / at the end or at the beginning of the bucket ID, otherwise, it will not work).
<k>define STORAGE_BUCKET_ID "REPLACE_WITH_YOUR_STORAGE_BUCKET_ID"</k>
<h4>Picture Path</h4>
The FILE_PHOTO_PATH variable defines the LittleFS path where the picture will be saved. It will be saved with the name photo.jpg.
<k>#define FILE_PHOTO "/photo.jpg"</k>
We also have a variable to hold the path where the picture will be saved on the Storage Bucket on Firebase.
<k>#define BUCKET_PHOTO "/data/photo.jpg"
</k>
<h4>ESP32-CAM Pin Definition</h4>
The following lines define the ESP32-CAM pins. This is the definition for the ESP32-CAM AI-Thinker module. If you're using another ESP32-CAM module, you need to modify the pin definitioncheck this tutorial: <a href="https://randomnerdtutorials.com/esp32-cam-camera-pin-gpios/">ESP32-CAM Camera Boards: Pin and GPIOs Assignment Guide</a>.
<k>// OV2640 camera module pins (CAMERA_MODEL_AI_THINKER)
#define PWDN_GPIO_NUM     32
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM      0
#define SIOD_GPIO_NUM     26
#define SIOC_GPIO_NUM     27
#define Y9_GPIO_NUM       35
#define Y8_GPIO_NUM       34
#define Y7_GPIO_NUM       39
#define Y6_GPIO_NUM       36
#define Y5_GPIO_NUM       21
#define Y4_GPIO_NUM       19
#define Y3_GPIO_NUM       18
#define Y2_GPIO_NUM        5
#define VSYNC_GPIO_NUM    25
#define HREF_GPIO_NUM     23
#define PCLK_GPIO_NUM     22</k>
<h4>Other Variables</h4>
The takeNewPhoto variable checks if it is time to take a new photo. We'll set it to true, so that it takes a picture when the board first runs.
<k>boolean takeNewPhoto = true;</k>
Then, we define Firebase configuration data objects.
<k>//Define Firebase Data objects
FirebaseData fbdo;
FirebaseAuth auth;
FirebaseConfig configF;</k>
The taskCompleted is a boolean variable that checks if we successfully connected to Firebase.
<k>bool taskCompleted = false;</k>
<h4>capturePhotoSaveLittleFS() Function</h4>
The capturePhotoSaveLittleFS() function takes a photo and saves it in the ESP32 filesystem.
<k>// Capture Photo and Save it to LittleFS
void capturePhotoSaveLittleFS( void ) {
  // Dispose first pictures because of bad quality
  camera_fb_t* fb = NULL;
  // Skip first 3 frames (increase/decrease number as needed).
  for (int i = 0; i &lt; 4; i++) {
    fb = esp_camera_fb_get();
    esp_camera_fb_return(fb);
    fb = NULL;
  }
    
  // Take a new photo
  fb = NULL;  
  fb = esp_camera_fb_get();  
  if(!fb) {
    Serial.println("Camera capture failed");
    delay(1000);
    ESP.restart();
  }  
  // Photo file name
  Serial.printf("Picture file name: %s\n", FILE_PHOTO_PATH);
  File file = LittleFS.open(FILE_PHOTO_PATH, FILE_WRITE);
  // Insert the data in the photo file
  if (!file) {
    Serial.println("Failed to open file in writing mode");
  }
  else {
    file.write(fb->buf, fb->len); // payload (image), payload length
    Serial.print("The picture has been saved in ");
    Serial.print(FILE_PHOTO_PATH);
    Serial.print(" - Size: ");
    Serial.print(fb->len);
    Serial.println(" bytes");
  }
  // Close the file
  file.close();
  esp_camera_fb_return(fb);
}</k>
<h4>initWiFi() Function</h4>
The initWiFi() function initializes Wi-Fi.
<k>void initWiFi(){
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println("Connecting to WiFi...");
  }
}</k>
<h4>initLittleFS() Function</h4>
The initLittleFS() function initializes the LittleFS filesystem.
<k>void initLittleFS(){
  if (!LittleFS.begin(true)) {
    Serial.println("An Error has occurred while mounting LittleFS");
    ESP.restart();
  }
  else {
    delay(500);
    Serial.println("LittleFS mounted successfully");
  }
}</k>
<h4>initCamera() Function</h4>
The initCamera() function initializes the ESP32-CAM.
<k>void initCamera(){
 // OV2640 camera module
  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer = LEDC_TIMER_0;
  config.pin_d0 = Y2_GPIO_NUM;
  config.pin_d1 = Y3_GPIO_NUM;
  config.pin_d2 = Y4_GPIO_NUM;
  config.pin_d3 = Y5_GPIO_NUM;
  config.pin_d4 = Y6_GPIO_NUM;
  config.pin_d5 = Y7_GPIO_NUM;
  config.pin_d6 = Y8_GPIO_NUM;
  config.pin_d7 = Y9_GPIO_NUM;
  config.pin_xclk = XCLK_GPIO_NUM;
  config.pin_pclk = PCLK_GPIO_NUM;
  config.pin_vsync = VSYNC_GPIO_NUM;
  config.pin_href = HREF_GPIO_NUM;
  config.pin_sscb_sda = SIOD_GPIO_NUM;
  config.pin_sscb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn = PWDN_GPIO_NUM;
  config.pin_reset = RESET_GPIO_NUM;
  config.xclk_freq_hz = 20000000;
  config.pixel_format = PIXFORMAT_JPEG;
  if (psramFound()) {
    config.frame_size = FRAMESIZE_UXGA;
    config.jpeg_quality = 10;
    config.fb_count = 2;
  } else {
    config.frame_size = FRAMESIZE_SVGA;
    config.jpeg_quality = 12;
    config.fb_count = 1;
  }
  // Camera init
  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed with error 0x%x", err);
    ESP.restart();
  } 
}</k>
<h4>setup()</h4>
In the setup(), initialize the Serial Monitor, Wi-Fi, LittleFS, and the camera.
<k>// Serial port for debugging purposes
Serial.begin(115200);
initWiFi();
initLittleFS();
// Turn-off the 'brownout detector'
WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0);
initCamera();</k>
Then, assign the following settings to the Firebase configuration objects.
<k>// Assign the api key
configF.api_key = API_KEY;
//Assign the user sign in credentials
auth.user.email = USER_EMAIL;
auth.user.password = USER_PASSWORD;
//Assign the callback function for the long running token generation task
configF.token_status_callback = tokenStatusCallback; //see addons/TokenHelper.h</k>
Finally, initialize Firebase.
<k>Firebase.begin(&configF, &auth);
Firebase.reconnectWiFi(true);</k>
<h4>loop()</h4>
In the loop(), take a new picture and save it to the filesystem.
<k>if (takeNewPhoto) {
  capturePhotoSaveLittleFS();
  takeNewPhoto = false;
}</k>
Finally, send the picture to Firebase.
<k>if (Firebase.ready() && !taskCompleted){
    taskCompleted = true;
    Serial.print("Uploading picture... ");
    //MIME type should be valid to avoid the download problem.
    //The file systems for flash and SD/SDMMC can be changed in FirebaseFS.h.
    if (Firebase.Storage.upload(&fbdo, STORAGE_BUCKET_ID /* Firebase Storage bucket id */, FILE_PHOTO_PATH /* path to local file */, mem_storage_type_flash /* memory storage type, mem_storage_type_flash and mem_storage_type_sd */, BUCKET_PHOTO /* path of remote file stored in the bucket */, "image/jpeg" /* mime type */,fcsUploadCallback)){
      Serial.printf("\nDownload URL: %s\n", fbdo.downloadURL().c_str());
    }
    else{
      Serial.println(fbdo.errorReason());
    }
  }</k>
The command that actually sends the picture is Firebase.Storage.upload():
<k>Firebase.Storage.upload(&fbdo, STORAGE_BUCKET_ID, FILE_PHOTO, mem_storage_type_flash, FILE_PHOTO, "image/jpeg", fcsUploadCallback)</k>
This function returns a boolean variable indicating the success of the operation.
It accepts as the second argument, the storage bucket ID. Then, the path where the file is saved; the storage type (it can be LittleFS or SD Card); the path where the file will be saved in the Firebase storage; the mime type, and a callback function (fcsUploadCallback) (this callback function simply inform us of the uploading process state).
<k>// The Firebase Storage upload callback function
void fcsUploadCallback(FCS_UploadStatusInfo info){
    if (info.status == firebase_fcs_upload_status_init){
        Serial.printf("Uploading file %s (%d) to %s\n", info.localFileName.c_str(), info.fileSize, info.remoteFileName.c_str());
    }
    else if (info.status == firebase_fcs_upload_status_upload)
    {
        Serial.printf("Uploaded %d%s, Elapsed time %d ms\n", (int)info.progress, "%", info.elapsedTime);
    }
    else if (info.status == firebase_fcs_upload_status_complete)
    {
        Serial.println("Upload completed\n");
        FileMetaInfo meta = fbdo.metaData();
        Serial.printf("Name: %s\n", meta.name.c_str());
        Serial.printf("Bucket: %s\n", meta.bucket.c_str());
        Serial.printf("contentType: %s\n", meta.contentType.c_str());
        Serial.printf("Size: %d\n", meta.size);
        Serial.printf("Generation: %lu\n", meta.generation);
        Serial.printf("Metageneration: %lu\n", meta.metageneration);
        Serial.printf("ETag: %s\n", meta.etag.c_str());
        Serial.printf("CRC32: %s\n", meta.crc32.c_str());
        Serial.printf("Tokens: %s\n", meta.downloadTokens.c_str());
        Serial.printf("Download URL: %s\n\n", fbdo.downloadURL().c_str());
    }
    else if (info.status == firebase_fcs_upload_status_error){
        Serial.printf("Upload failed, %s\n", info.errorMsg.c_str());
    }

<h2>Create a Wi-Fi Manager (AsyncWebServer library)</h2>
In this guide, you'll create and set up a Wi-Fi Manager with the ESPAsyncWebServer library that you can modify to use with your web server projects or with any project that needs a connection to a Wi-Fi network. The Wi-Fi Manager allows you to connect the ESP32 board to different Access Points (networks) without hard-coding network credentials (SSID and password) and upload new code to your board. Your ESP will automatically join the last saved network or set up an Access Point that you can use to configure the network credentials.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/12/ESP32-Wi-Fi-Manager-Web-Server.jpg">
To better understand how this project works, we recommend taking a look at the following tutorials:
<a href="https://randomnerdtutorials.com/esp32-esp8266-input-data-html-form/">Input Data on HTML Form ESP32/ESP8266 Web Server using Arduino IDE</a>
<a href="https://randomnerdtutorials.com/esp32-access-point-ap-web-server/">How to Set an ESP32 Access Point (AP) for Web Server</a>
<a href="https://randomnerdtutorials.com/esp32-static-fixed-ip-address-arduino-ide/">ESP32 Static/Fixed IP Address</a>
We also use this Wi-Fi Manager approach on the following project:
<a href="https://randomnerdtutorials.com/esp32-status-indicator-sensor-pcb/">ESP32 Neopixel Status Indicator and Sensor PCB Shield with Wi-Fi Manager</a>
<h3>How it Works</h3>
Take a look at the following diagram to understand how the Wi-Fi Manager we'll create works.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/11/ESP32-ESP8266-wi-fi-manager-web-server-how-it-works.png">
When the ESP first starts, it tries to read the ssid.txt, pass.txt and ip.txt files* (<k>1</k>);
If the files are empty (<k>2</k>) (the first time you run the board, the files are empty), your board is set as an access point (<k>3</k>);
Using any Wi-Fi enabled device with a browser, you can connect to the newly created Access Point (default name ESP-WIFI-MANAGER);
After establishing a connection with the ESP-WIFI-MANAGER, you can go to the default IP address 192.168.4.1 to open a web page that allows you to configure your SSID and password (<k>4</k>);
The SSID, password, and IP address inserted in the form are saved in the corresponding files: ssid.txt, pass.txt, and ip.txt (<k>5</k>);
After that, the ESP board restarts (<k>6</k>);
This time, after restarting, the files are not empty, so the ESP will try to connect to the network in station mode using the settings you've inserted in the form (<k>7</k>);
If it establishes a connection, the process is completed successfully, and you can access the main web server page that can do whatever you want (control sensor readings, control outputs, display some text, etc.) (<k>9</k>). Otherwise, it will set the Access Point (<k>3</k>), and you can access the default IP address (192.168.4.1) to add another SSID/password combination.
 <k>*</k> we also created a <em>gateway</em> field and a gateway.txt file to save the IP address gateway (this is not shown in the diagram).
To show you how to set the Wi-Fi Manager, we'll set up a web server that controls one output (GPIO2the built-in LED). You can apply the Wi-Fi Manager to any web server project built with the ESPAsyncWebServer library or to any project that requires the ESP to be connected to a wi-fi network.
<h3>Prerequisites</h3>
We'll program the ESP32 board using Arduino IDE. So make sure you have the ESP32 board add-on installed.
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing ESP32 Board in Arduino IDE (Windows, Mac OS X, and Linux)</a>
If you want to program the ESP32 using VS Code + PlatformIO, follow the next tutorial:
<a href="https://randomnerdtutorials.com/vs-code-platformio-ide-esp32-esp8266-arduino/">Getting Started with VS Code and PlatformIO IDE for ESP32 and ESP8266 (Windows, Mac OS X, Linux Ubuntu)</a>
<h3>Installing Libraries (Arduino IDE)</h3>
You need to install the following libraries in your Arduino IDE to build the web server for this project.
<a href="https://github.com/me-no-dev/ESPAsyncWebServer/archive/refs/heads/master.zip" target="_blank">ESPAsyncWebServer </a>(.zip folder)
<a href="https://github.com/me-no-dev/AsyncTCP/archive/refs/heads/master.zip" target="_blank">AsyncTCP </a>(.zip folder)
The ESPAsyncWebServer, AsynTCP, and ESPAsyncTCP libraries aren't available to install through the Arduino Library Manager, so you need to copy the library files to the Arduino installation Libraries folder. Alternatively, in your Arduino IDE, you can go to <k>Sketch </k>> <k>Include Library</k> > <k>Add .zip Library</k> and select the libraries you've just downloaded.
<h3>Installing Libraries (VS Code + PlatformIO)</h3>
If you're programming the ESP32 using PlatformIO, copy the following to the platformio.ini to include the ESPAsyncWebServer library (it will automatically include any dependencies like the AsynTCP or ESPAsyncTCP libraries) and change the baud rate to 115200:
<k>monitor_speed = 115200
lib_deps = ESP Async WebServer</k>
<h3>Filesystem Uploader</h3>
Before proceeding, you need to have the ESP32 Uploader Plugin installed in your Arduino IDE.
<a href="https://randomnerdtutorials.com/install-esp32-filesystem-uploader-arduino-ide/">Install ESP32 Filesystem Uploader in Arduino IDE</a>
If you're using VS Code with PlatformIO, follow the next tutorials to learn how to upload files to the filesystem:
<a href="https://randomnerdtutorials.com/esp32-vs-code-platformio-spiffs/">ESP32 with VS Code and PlatformIO: Upload Files to Filesystem (SPIFFS)</a>
<h3>Organizing your Files</h3>
To keep the project organized and make it easier to understand, we'll create four different files to build the web server:
<k>Arduino sketch </k>that handles the web server;
<k>index.html</k>: to define the content of the web page in station mode to control the output (or any other web page you want to build);
<k>style.css</k>: to style the web pages;
<k>wifimanager.html</k>: to define the web page's content to display the Wi-Fi Manager when the ESP is in access point mode.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/11/ESP32-ESP8266-Web-Server-Wi-Fi-Manager-Files.png">
You should save the HTML and CSS files inside a folder called <em><k>data</k> </em>inside the Arduino sketch folder, as shown in the previous diagram. We'll upload these files to the ESP32 filesystem (SPIFFS).
<k>You can download all project files:</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_WiFi_Manager/ESP32_WiFi_Manager.zip" target="_blank">Download All the Arduino Project Files</a>
<h3>Creating the HTML Files</h3>
For this project, you need two HTML files. One to build the main page that controls the output (index.html) and another to build the Wi-Fi Manager page (wifimanager.html).
<h3>index.html</h3>
Here's the text you should copy to your index.html file.
<k>&lt;!DOCTYPE html>
&lt;html>
  &lt;head>
    &lt;title>ESP WEB SERVER&lt;/title>
    &lt;meta name="viewport" content="width=device-width, initial-scale=1">
    &lt;link rel="stylesheet" type="text/css" href="style.css">
    &lt;link rel="icon" type="image/png" href="favicon.png">
    &lt;link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
  &lt;/head>
  &lt;body>
    &lt;div>
      &lt;h1>ESP WEB SERVER&lt;/h2>
    &lt;/div>
    &lt;div>
      &lt;div>
        &lt;div>
          &lt;p>&lt;i>&lt;/i> GPIO 2&lt;/p>
          &lt;p>
            &lt;a href="on">&lt;button>ON&lt;/button>&lt;/a>
            &lt;a href="off">&lt;button>OFF&lt;/button>&lt;/a>
          &lt;/p>
          &lt;p>State: %STATE%&lt;/p>
        &lt;/div>
      &lt;/div>
    &lt;/div>
  &lt;/body>
&lt;/html></k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_WiFi_Manager/data/index.html" target="_blank">View raw code</a>
We won't explain how this HTML file works because that's not the purpose of this tutorial. The purpose of this tutorial is to explain the parts related to the Wi-Fi Manager.
<h3>wifimanager.html</h3>
The Wi-Fi Manager web page looks like this:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2022/02/ESP32-ESP8266-Wi-Fi-Manager-Fields.png">
Copy the following to the wifimanager.html file. This creates a web page with a form with three input fields and a <k>Submit</k> button.
<k>&lt;!DOCTYPE html>
&lt;html>
&lt;head>
  &lt;title>ESP Wi-Fi Manager&lt;/title>
  &lt;meta name="viewport" content="width=device-width, initial-scale=1">
  &lt;link rel="icon" href="data:,">
  &lt;link rel="stylesheet" type="text/css" href="style.css">
&lt;/head>
&lt;body>
  &lt;div>
    &lt;h1>ESP Wi-Fi Manager&lt;/h2>
  &lt;/div>
  &lt;div>
    &lt;div>
      &lt;div>
        &lt;form action="/" method="POST">
          &lt;p>
            &lt;label for="ssid">SSID&lt;/label>
            &lt;input type="text" id ="ssid" name="ssid">&lt;br>
            &lt;label for="pass">Password&lt;/label>
            &lt;input type="text" id ="pass" name="pass">&lt;br>
            &lt;label for="ip">IP Address&lt;/label>
            &lt;input type="text" id ="ip" name="ip" value="192.168.1.200">&lt;br>
            &lt;label for="gateway">Gateway Address&lt;/label>
            &lt;input type="text" id ="gateway" name="gateway" value="192.168.1.1">&lt;br>
            &lt;input type ="submit" value ="Submit">
          &lt;/p>
        &lt;/form>
      &lt;/div>
    &lt;/div>
  &lt;/div>
&lt;/body>
&lt;/html>
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_WiFi_Manager/data/wifimanager.html" target="_blank">View raw code</a>
In this HTML file, we create an HTML form that will make an HTTP POST request with the data submitted to the server.
<k>&lt;form action="/" method="POST"></k>
The form contains three input fields and corresponding labels: SSID, password, and IP address.
This is the input field for the SSID:
<k>&lt;label for="ssid">SSID&lt;/label>
&lt;input type="text" id ="ssid" name="ssid">&lt;br></k>
This is the input field for the password.
<k>&lt;label for="pass">Password&lt;/label>
&lt;input type="text" id ="pass" name="pass">&lt;br></k>
There is an input field for the IP address that you want to attribute to the ESP in station mode. As default, we set it to 192.168.1.200 (you can set another default IP address, or you can delete the value parameterit won't have a default value).
<k>&lt;input type="text" id ="ip" name="ip" value="192.168.1.200"></k>
Finally, there's an input field for the gateway address. If the default IP address is 192.168.1.200, the gateway can be 192.168.1.1 by default.
<k>&lt;input type="text" id ="gateway" name="gateway" value="192.168.1.1">&lt;br></k>
<h3>CSS File</h3>
Copy the following styles to your style.css file. We won't explain how these styles work. We have already explained how similar styles work in <a href="https://randomnerdtutorials.com/?s=web+server">other ESP Web Server projects</a>.
<k>html {
  font-family: Arial, Helvetica, sans-serif; 
  display: inline-block; 
  text-align: center;
}
h1 {
  font-size: 1.8rem; 
  color: white;
}
p { 
  font-size: 1.4rem;
}
.topnav { 
  overflow: hidden; 
  background-color: #0A1128;
}
body {  
  margin: 0;
}
.content { 
  padding: 5%;
}
.card-grid { 
  max-width: 800px; 
  margin: 0 auto; 
  display: grid; 
  grid-gap: 2rem; 
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
}
.card { 
  background-color: white; 
  box-shadow: 2px 2px 12px 1px rgba(140,140,140,.5);
}
.card-title { 
  font-size: 1.2rem;
  font-weight: bold;
  color: #034078
}
input[type=submit] {
  border: none;
  color: #FEFCFB;
  background-color: #034078;
  padding: 15px 15px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-size: 16px;
  width: 100px;
  margin-right: 10px;
  border-radius: 4px;
  transition-duration: 0.4s;
  }
input[type=submit]:hover {
  background-color: #1282A2;
}
input[type=text], input[type=number], select {
  width: 50%;
  padding: 12px 20px;
  margin: 18px;
  display: inline-block;
  border: 1px solid #ccc;
  border-radius: 4px;
  box-sizing: border-box;
}
label {
  font-size: 1.2rem; 
}
.value{
  font-size: 1.2rem;
  color: #1282A2;  
}
.state {
  font-size: 1.2rem;
  color: #1282A2;
}
button {
  border: none;
  color: #FEFCFB;
  padding: 15px 32px;
  text-align: center;
  font-size: 16px;
  width: 100px;
  border-radius: 4px;
  transition-duration: 0.4s;
}
.button-on {
  background-color: #034078;
}
.button-on:hover {
  background-color: #1282A2;
}
.button-off {
  background-color: #858585;
}
.button-off:hover {
  background-color: #252524;
} </k>

<h2>Firebase Web App to Display Sensor Readings (with Authentication)</h2>
In this guide, you'll create a Firebase Web App to display sensor readings saved on the Firebase Realtime Database. The sensor readings web page is protected with authentication with email and password. You'll learn how to display data from the database and how to add authentication to your web app.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/ESP32-ESP8266-Firebase-App-Sensor-Readings-Authentication.png">
This article is Part 2 of this previous tutorial: <a href="https://randomnerdtutorials.com/esp32-esp8266-firebase-bme280-rtdb/">ESP32/ESP8266 Firebase: Send BME280 Sensor Readings to the Realtime Database</a>. Follow that tutorial first, before proceeding.
<h3>Project Overview</h3>
In this tutorial (Part 2), you'll create a web app to display the sensor readings saved on the Firebase Realtime Database (<a href="https://randomnerdtutorials.com/esp32-esp8266-firebase-bme280-rtdb/">read this previous tutorial</a>).
The following diagram shows a high-level overview of the project we'll buildprogramming the ESP32/ESP8266 and setting up the Firebase Project was done in <a href="https://randomnerdtutorials.com/esp32-esp8266-firebase-bme280-rtdb/">Part 1</a>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/ESP32-ESP8266-Firebase-Web-App-Authentication-Overview.png">
Firebase hosts your web app over a global CDN using Firebase Hosting and provides an SSL certificate. You can access your web app from anywhere using the Firebase-generated domain name.
When you first access the web app, you need to authenticate with an authorized email address and password. You already set up that user and the <a href="https://randomnerdtutorials.com/esp32-esp8266-firebase-bme280-rtdb/#Set-Authentication-Methods">authentication method in Part 1</a>.
After authentication, you can access a web app page that shows the sensor readings saved on the realtime database. The<a href="https://randomnerdtutorials.com/esp32-esp8266-firebase-bme280-rtdb/#Set-up-Realtime-Database"> realtime database was set up on Part 1</a>.
Once you're logged in, you can logout any time. The next time you'll acces the app you'll need to login again.
<h3>Prerequisites</h3>
Before start creating the Firebase Web App, you need to check the following prerequisites.
<h3>Creating a Firebase Project</h3>
You should have followed the following tutorial first:
<a href="https://randomnerdtutorials.com/esp32-esp8266-firebase-bme280-rtdb/">ESP32/ESP8266 Firebase: Send BME280 Sensor Readings to the Realtime Database</a>
The ESP32/ESP8266 must be running the code provided in that tutorial. The realtime database and authentication must be set up also as shown in the tutorial.
<h3>Install Required Software</h3>
Before getting started you need to install the required software to create the Firebase Web App. Here's a list of the software you need to install (click on the links for instructions):
<a href="https://randomnerdtutorials.com/esp32-firebase-web-app/#install-vs-code">Visual Studio Code</a>
<a href="https://randomnerdtutorials.com/esp32-firebase-web-app/#install-nodejs">Node.JS LTS version</a>
<a href="https://randomnerdtutorials.com/esp32-firebase-web-app/#install-firebase-tools">Install Firebase Tools</a>
<hr>
<h3>1) Add an App to Your Firebase Project</h3>
<k>1)</k> Go to your Firebase project Console and add an app to your project by clicking on the <k>+Add app </k>button. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/Firebase-Add-App-to-Project.png">
<k>2)</k> Select the web app icon.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/Firebase-Add-Web-App-to-Project.png">
<k>3)</k> Give your app a name. Then, check the box next to <k> Also set up Firebase Hosting for this App</k>. Click <k>Register app</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/add-firebase-to-web-app-example.png">
<k>4)</k> Then, copy the firebaseConfig object and save it because you'll need it later.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/app-firebase-config-object.png">
After this, you can also access the firebaseConfig object if you go to your Project settings in your Firebase console.
<k>5)</k> Click <k>Next</k> on the proceeding steps, and finally on <k>Continue to console</k>.
<hr>
<h3>2) Setting Up a Firebase Web App Project (VS Code)</h3>
Follow the next steps to create a Firebase Web App Project using VS Code.
<h3>1) Creating a Project Folder</h3>
<k>1)</k> Create a folder on your computer where you want to save your Firebase projectfor example, <em>Firebase-Project</em> on the Desktop.
<k>2)</k> Open VS Code. Go to <k>File</k> > <k>Open Folder</k> and select the folder you've just created.
<k>3)</k> Go to <k>Terminal </k>> <k>New Terminal</k>. A new Terminal window should open on your project path.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/Terminal-Window-Firebase-Folder-Project.png">
<h3>2) Firebase Login</h3>
<k>4)</k> On the previous Terminal window, type the following:
<k><k>firebase </k>login</k>
<k>5)</k> You'll be asked to collect CLI usage and error reporting information. Enter <k>n</k> and press <k>Enter</k> to deny.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/Terminal-Window-Login-Firebase-VS-Code.png">
<k>Note:</k> If you are already logged in, it will show a message saying: Already logged in as <a href="/cdn-cgi/l/email-protection" data-cfemail="7f0a0c1a0d3f18121e1613511c1012">[email protected]</a>.
<k>6)</k> After this, it will pop up a new window on your browser to login into your firebase account.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/Login-Firebase-Account.png">
<k>7)</k> Allow Firebase CLI to access your google account.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/Login-Firebase-Account-2.png">
<k>8)</k> After this, Firebase CLI login should be successful. You can close the browser window.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/Firebase-CLI-Login-Successful.png">
<h3>3) Initializing Web App Firebase Project</h3>
<k>9)</k> After successfully login in, run the following command to start a Firebase project directory in the current folder.
<k><k>firebase </k>init</k>
<k>10)</k> You'll be asked if you want to initialize a Firebase project in the current directory. Enter <k>Y</k> and hit <k>Enter</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/Firebase-Start-Project-VS-Code.png">
<k>11)</k> Then, use up and down arrows and the Space key to select the options. Select the following options:
<k>Realtime Database</k>: Configure security rules file for Realtime Database and (optionally) provision default instance.  
<k>Hosting</k>: Configure files for Firebase Hosting and (optionally) set up GitHub Action deploys
The selected options will show up with a green asterisk. Then, hit <k>Enter</k>. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/realtime-database-hosting-options.png">
<k>12)</k> Select the option Use an existing projectit should be highlighted in bluethen, hit Enter.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/Firebase-Project-Setup-VS-Code.png">
<k>13)</k> After that, select the Firebase project for this directoryit should be <k><a href="https://randomnerdtutorials.com/esp32-esp8266-firebase-bme280-rtdb/">the project created in this previous tutorial</a></k>. In my case, it is called <em>esp-firebase-demo</em>. Then hit <k>Enter</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/add-firebase-project-VS-Code.png">
<k>14)</k> Press <k>Enter </k>on the following question to select the default database security rules file: <k>What file should be used for Realtime Database Security Rules?</k>
<k>15)</k> Then, select the hosting options as shown below:
What do you want to use as your public directory? Hit <k>Enter </k>to select <k>public</k>.
Configure as a single-page app (rewrite urls to /index.html)? <k>No</k>
Set up automatic builds and deploys with GitHub? <k>No</k>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/firebase-hosting-setup-all-options.png">
<k>16)</k> The Firebase project should now be initialized successfully. Notice that VS code created some essential files under your project folder.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/firebase-project-app-created-successfully.png">
The index.html file contains some HTML text to build a web page. For now, leave the default HTML text. The idea is to replace that with your own HTML text to build a custom web page for your needs. We'll do that later in this tutorial.
<k>17)</k> To check if everything went as expected, run the following command on the VS Code Terminal window.
<k><k>firebase </k>deploy</k>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/firebase-first-deploy-test-app.png">
You should get a <k>Deploy complete!</k> message and an URL to the Project Console and the Hosting URL.
<k>18)</k> Copy the hosting URL and paste it into a web browser window. You should see the following web page. You can access that web page from anywhere in the world.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/firebase-hosting-complete.png">
The web page you've seen previously is built with the HTML file placed in the public folder of your Firebase project. By changing the content of that file, you can create your own web app. That's what we're going to do in the next section.
<hr>
<h3>3) Creating Firebase Web App</h3>
Now that you've created a Firebase project app successfully on VS Code, follow the next steps to customize the app to display the sensor readings on a login-protected web page.
<h3>index.html</h3>
Copy the following to your index.html file. This HTML file creates a simple web page that displays the readings saved on the <a href="https://randomnerdtutorials.com/esp32-esp8266-firebase-bme280-rtdb/">Realtime Database created on this previous project</a>. 
If you aren't authenticated, it shows a login form. When you authenticate with an authorized user email and corresponding password, it shows the user interface with the sensor readings.
<k>&lt;!-- Complete Project Details at: https://RandomNerdTutorials.com/ -->
&lt;!DOCTYPE html>
&lt;html>
  &lt;head>
    &lt;meta charset="utf-8">
    &lt;meta name="viewport" content="width=device-width, initial-scale=1">
    &lt;title>ESP IoT Firebase App&lt;/title>
    &lt;!-- update the version number as needed -->
    &lt;script src="https://www.gstatic.com/firebasejs/8.8.1/firebase-app.js">&lt;/script>
    &lt;!-- include only the Firebase features as you need -->
    &lt;script src="https://www.gstatic.com/firebasejs/8.8.1/firebase-auth.js">&lt;/script>
    &lt;script src="https://www.gstatic.com/firebasejs/8.8.1/firebase-database.js">&lt;/script>
    &lt;script>
     // REPLACE WITH YOUR web app's Firebase configuration
      const firebaseConfig = {
        apiKey: "REPLACE_WITH_YOUR_Firebase_CONFIGURATION",
        authDomain: "REPLACE_WITH_YOUR_Firebase_CONFIGURATION",
        databaseURL: "REPLACE_WITH_YOUR_Firebase_CONFIGURATION",
        projectId: "REPLACE_WITH_YOUR_Firebase_CONFIGURATION",
        storageBucket: "REPLACE_WITH_YOUR_Firebase_CONFIGURATION",
        messagingSenderId: "REPLACE_WITH_YOUR_Firebase_CONFIGURATION",
        appId: "REPLACE_WITH_YOUR_Firebase_CONFIGURATION"
      };
      // Initialize firebase
      firebase.initializeApp(firebaseConfig);
      // Make auth and database references
      const auth = firebase.auth();
      const db = firebase.database();
    &lt;/script>
    &lt;link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
    &lt;link rel="icon" type="image/png" href="favicon.png">
    &lt;link rel="stylesheet" type="text/css" href="style.css">
&lt;/head>
&lt;body>
  &lt;!--TOP BAR-->
  &lt;div>
    &lt;h1>Sensor Readings App &lt;i>&lt;/i>&lt;/h2>
  &lt;/div>
  &lt;!--AUTHENTICATION BAR (USER DETAILS/LOGOUT BUTTON)-->
  &lt;div style="display: none;">
    &lt;p>&lt;span>User logged in&lt;/span>
       &lt;span>USEREMAIL&lt;/span>
       &lt;a href="/">(logout)&lt;/a>
    &lt;/p>
  &lt;/div>
  &lt;!--LOGIN FORM-->
  &lt;form style="display: none;">
    &lt;div>
      &lt;label for="input-email">&lt;b>Email&lt;/b>&lt;/label>
      &lt;input type="text" placeholder="Enter Username" required>
      &lt;label for="input-password">&lt;b>Password&lt;/b>&lt;/label>
      &lt;input type="password" placeholder="Enter Password" required>
      &lt;button type="submit">Login&lt;/button>
      &lt;p style="color:red;">&lt;/p>
    &lt;/div>
  &lt;/form>
  &lt;!--CONTENT (SENSOR READINGS)-->
  &lt;div style="display: none;">
    &lt;div>
      &lt;!--TEMPERATURE-->
      &lt;div>
        &lt;p>&lt;i style="color:#059e8a;">&lt;/i> TEMPERATURE&lt;/p>
        &lt;p>&lt;span>&lt;span>&lt;/span> &deg;C&lt;/span>&lt;/p>
      &lt;/div>
      &lt;!--HUMIDITY-->
      &lt;div>
        &lt;p>&lt;i style="color:#00add6;">&lt;/i> HUMIDITY&lt;/p>
        &lt;p>&lt;span>&lt;span>&lt;/span> &percnt;&lt;/span>&lt;/p>
      &lt;/div>
      &lt;!--PRESSURE-->
      &lt;div>
        &lt;p>&lt;i style="color:#e1e437;">&lt;/i> PRESSURE&lt;/p>
        &lt;p>&lt;span>&lt;span>&lt;/span> hPa&lt;/span>&lt;/p>
      &lt;/div>
    &lt;/div>
  &lt;/div>
    &lt;script src="scripts/auth.js">&lt;/script>
    &lt;script src="scripts/index.js">&lt;/script>
  &lt;/body>
&lt;/html></k>
<a href="https://github.com/RuiSantosdotme/Firebase-ESP/raw/main/ESP-Firebase-Sensor-BME280/index.html" target="_blank">View raw code</a>
You need to modify the code with your own firebaseConfig objectthe one you've got in this step.
<h4>How it Works</h4>
Let's take a quick look at the HTML file, or skip to the next section.
In the &lt;head> of the HTML file, we must add all the required metadata.
The title of the web page is <k>ESP Firebase App</k>, but you can change it in the following line.
<k>&lt;title>ESP Firebase App&lt;/title></k>
You must add the following line to be able to use Firebase with your app.
<k>&lt;script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js">&lt;/script></k>
You must also add any Firebase products you want to use. In this example, we're using the Realtime Database and Authentication.
<k>&lt;script src="https://www.gstatic.com/firebasejs/8.8.1/firebase-auth.js">&lt;/script>
&lt;script src="https://www.gstatic.com/firebasejs/8.8.1/firebase-database.js">&lt;/script></k>
Then, replace the firebaseConfig object with the one you've gotten from this step.
<k>const firebaseConfig = {
  apiKey: "REPLACE_WITH_YOUR_Firebase_CONFIGURATION",
  authDomain: "REPLACE_WITH_YOUR_Firebase_CONFIGURATION",
  databaseURL: "REPLACE_WITH_YOUR_Firebase_CONFIGURATION",
  projectId: "REPLACE_WITH_YOUR_Firebase_CONFIGURATION",
  storageBucket: "REPLACE_WITH_YOUR_Firebase_CONFIGURATION",
  messagingSenderId: "REPLACE_WITH_YOUR_Firebase_CONFIGURATION",
  appId: "REPLACE_WITH_YOUR_Firebase_CONFIGURATION"
};</k>
Finally, Firebase is initialized, and we create two global variables db and auth that refer to Firebase authentication and to Firebase realtime database.
<k>// Initialize firebase
firebase.initializeApp(firebaseConfig);
      
// Make auth and database references
const auth = firebase.auth();
const db = firebase.database();</k>
The following line allows us to use <a href="https://fontawesome.com/" target="_blank">fontawesome icons</a>:
<k>&lt;link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"></k>
The next includes a <a href="https://github.com/RuiSantosdotme/build-web-servers-dl/raw/main/favicon.zip" target="_blank">favicon</a> on our web page.
<k>&lt;link rel="icon" type="image/png" href="favicon.png"></k>
Finally, reference an external style.css file to format the HTML page.
<k>&lt;link rel="stylesheet" type="text/css" href="style.css"></k>
We're done with the metadata. Now, let's go to the HTML parts that are visible to the usergo between the &lt;body> and &lt;/body> tags.
We create a top navigation bar with the name of our app and a small icon from fontawesome.
<k>&lt;div>
  &lt;h1>Sensor Readings App &lt;i>&lt;/i>&lt;/h2>
&lt;/div></k>
The following lines create a bar with the details of the authenticated user (email). It also shows a logout link to log out the user. 
<k>&lt;div style="display: none;">
  &lt;p>&lt;span>User logged in&lt;/span>
     &lt;span>USEREMAIL&lt;/span>
     &lt;a href="/">(logout)&lt;/a>
  &lt;/p>
&lt;/div></k>
First, we set the display style of all elements to none. We'll hide and show content depending if the user is authenticated or notwe'll handle that using JavaScript.
Next, the following lines create the login form with an input field for the email and an input field for the password:
<k>&lt;form style="display: none;">  
  &lt;div>
    &lt;label for="input-email">&lt;b>Email&lt;/b>&lt;/label>
    &lt;input type="text" placeholder="Enter Username" required>
  
    &lt;label for="input-password">&lt;b>Password&lt;/b>&lt;/label>
    &lt;input type="password" placeholder="Enter Password" required>
          
    &lt;button type="submit">Login&lt;/button>
    &lt;p style="color:red;">&lt;/p>
  &lt;/div>
&lt;/form></k>
Inside the form, there's also a paragraph to display an error message if the login fails.
<k>&lt;p style="color:red;">&lt;/p></k>
Finally, we create a grid to display the sensor readings.
<k>&lt;!--CONTENT (SENSOR READINGS)-->
&lt;div style="display: none;">
  &lt;div>
    &lt;!--TEMPERATURE-->
    &lt;div>
      &lt;p>&lt;i style="color:#059e8a;">&lt;/i> TEMPERATURE&lt;/p>
      &lt;p>&lt;span>&lt;span>&lt;/span> &deg;C&lt;/span>&lt;/p>
    &lt;/div>
    &lt;!--HUMIDITY-->
    &lt;div>
      &lt;p>&lt;i style="color:#00add6;">&lt;/i> HUMIDITY&lt;/p>
      &lt;p>&lt;span>&lt;span>&lt;/span> &percnt;&lt;/span>&lt;/p>
    &lt;/div>
    &lt;!--PRESSURE-->
    &lt;div>
      &lt;p>&lt;i style="color:#e1e437;">&lt;/i> PRESSURE&lt;/p>
      &lt;p>&lt;span>&lt;span>&lt;/span> hPa&lt;/span>&lt;/p>
    &lt;/div>
  &lt;/div>
&lt;/div></k>
The places where we'll insert the sensor readings have &lt;span> tags with specific ids so that we can refer to those HTML elements using JavaScript and insert sensor readings saved on the database.
temperature: id = temp
humidity: id = hum
pressure: id = pres
Finally, we need to add references to the external JavaScript files. For our application, we'll create two JavaScript files: auth.js (that handles everything related to the authentication) and index.js that handles everything related to the UI. We'll create those files inside a folder called scripts inside the public folder of our application.
<k>&lt;script src="scripts/auth.js">&lt;/script>
&lt;script src="scripts/index.js">&lt;/script></k>
After making the necessary changes (inserting your firebaseConfig object), you can save the HTML file.
<h3>style.css</h3>
Inside the public folder create a file called style.css. To create the file, select the public folder, and then click on the <k>+file</k> icon at the top of the File Explorer. Call it style.css.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/Firebase-Project-VS-Code-CSS-File.png">
Then, copy the following to the style.css file
<k>html {
    font-family: Verdana, Geneva, Tahoma, sans-serif;
    display: inline-block;
    text-align: center;
}
p {
    font-size: 1.2rem;
}
body {
    margin: 0;
}
.topnav {
    overflow: hidden;
    background-color: #049faa;
    color: white;
    font-size: 1rem;
    padding: 10px;
}
#authentication-bar{
    background-color:mintcream;
    padding-top: 10px;
    padding-bottom: 10px;
}
#user-details{
    color: cadetblue;
}
.content {
    padding: 20px;
}
.card {
    background-color: white;
    box-shadow: 2px 2px 12px 1px rgba(140,140,140,.5);
    padding: 5%;
}
.cards {
    max-width: 800px;
    margin: 0 auto;
    display: grid;
    grid-gap: 2rem;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
}
.reading {
    font-size: 1.4rem;
}
button {
    background-color: #049faa;
    color: white;
    padding: 14px 20px;
    margin: 8px 0;
    border: none;
    cursor: pointer;
    border-radius: 4px;
}
button:hover {
    opacity: 0.8;
}
.form-elements-container{
    padding: 16px;
    width: 250px;
    margin: 0 auto;
}
input[type=text], input[type=password] {
    width: 100%;
    padding: 12px 20px;
    margin: 8px 0;
    display: inline-block;
    border: 1px solid #ccc;
    box-sizing: border-box;
}
</k>
<a href="https://github.com/RuiSantosdotme/Firebase-ESP/raw/main/ESP-Firebase-Sensor-BME280/style.css" target="_blank">View raw code</a>
The CSS file includes some simple styles to make our webpage look better. We won't discuss how CSS works in this tutorial.
<h3>JavaScript Files</h3>
We'll create two JavaScript files (auth.js and index.js) inside a scripts folder inside the public folder.
Select the public folder, then click on the <k>+folder</k> icon to create a new folder. Call scripts to that new folder.
Then, select the scripts folder and click on the <k>+file</k> icon. Create a file called auth.js. Then, repeat the previous steps to create an index.js.
The following image show how your web app project folder structure should look like.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/Firebase-Project-VS-Code-Folder-File-Structure.png">
<h4>auth.js</h4>
Now let's implement user sign-in using Firebase authentication. We'll implement sign-in using email and password.
Copy the following to the auth.js file you created previously. 
<k>// listen for auth status changes
auth.onAuthStateChanged(user => {
 if (user) {
   console.log("user logged in");
   console.log(user);
   setupUI(user);
   var uid = user.uid;
   console.log(uid);
 } else {
   console.log("user logged out");
   setupUI();
 }
});
// login
const loginForm = document.querySelector('#login-form');
loginForm.addEventListener('submit', (e) => {
 e.preventDefault();
 // get user info
 const email = loginForm['input-email'].value;
 const password = loginForm['input-password'].value;
 // log the user in
 auth.signInWithEmailAndPassword(email, password).then((cred) => {
   // close the login modal & reset form
   loginForm.reset();
   console.log(email);
 })
 .catch((error) =>{
   const errorCode = error.code;
   const errorMessage = error.message;
   document.getElementById("error-message").innerHTML = errorMessage;
   console.log(errorMessage);
 });
});
// logout
const logout = document.querySelector('#logout-link');
logout.addEventListener('click', (e) => {
 e.preventDefault();
 auth.signOut();
});</k>
<a href="https://github.com/RuiSantosdotme/Firebase-ESP/raw/main/ESP-Firebase-Sensor-BME280/auth.js" target="_blank">View raw code</a>
Then, save the file. This file takes care of everything related to the login and logout of the user. Continue reading to learn how the code works or skip to the next section.
<k>Login</k>
The following lines are responsible for logging in the user.
<k>const loginForm = document.querySelector('#login-form');
loginForm.addEventListener('submit', (e) => {
  e.preventDefault();
  // get user info
  const email = loginForm['input-email'].value;
  const password = loginForm['input-password'].value;
  // log the user in
  auth.signInWithEmailAndPassword(email, password).then((cred) => {
    // close the login modal & reset form
    loginForm.reset();
    console.log(email);
  })
  .catch((error) =>{
    const errorCode = error.code;
    const errorMessage = error.message;
    document.getElementById("error-message").innerHTML = errorMessage;
    console.log(errorMessage);
  });
});</k>
We create a variable that refers to the login form HTML element called loginForm.
<k>const loginForm = document.querySelector('#login-form');</k>
If you go back to the index.html file, you can see that the form has the login-form id.
We add an event listener of type submit to the form. This means that the subsequent instructions will run whenever the form is submitted.
<k>loginForm.addEventListener('submit', (e) => {</k>
You can get the submitted data as follows.
<k>const email = loginForm['input-email'].value;
const password = loginForm['input-password'].value;</k>
If you go back to the HTML file, you'll see that the input fields contain the following ids: input-email and input-password for the email and password, respectively.
Now that we have the inserted email and password, we can try to log in to Firebase. To do that, pass the user's email address and password to the following method: signInWithEmailAndPassword:
<k>auth.signInWithEmailAndPassword(email, password).then((cred) => {</k>
After logging in, we reset the form and print the user email in the console.
<k>auth.signInWithEmailAndPassword(email, password).then((cred) => {
  // close the login modal & reset form
  loginForm.reset();
  console.log(email);
})</k>
In case there is an error signing in, we catch the error message, and display it on the error-message HTML element (a paragraph below the form).
<k>.catch((error) =>{
  const errorCode = error.code;
  const errorMessage = error.message;
  document.getElementById("error-message").innerHTML = errorMessage;
  console.log(errorMessage);
});</k>
<k>Logout</k>
The following snippet is responsible for logging out the user.
<k>const logout = document.querySelector('#logout-link');
logout.addEventListener('click', (e) => {
  e.preventDefault();
  auth.signOut();
});</k>
When the user is logged in, a logout link is visible in the authentication bar. That link has the logout-link id (see on the HTML file). So, first, we create a variable called logout that refers to the logout link.
<k>const logout = document.querySelector('#logout-link');</k>
Then, we add an event listener of type click. This means the subsequent instructions will run whenever you click on the logout link.
<k>logout.addEventListener('click', (e) => {</k>
When the button is clicked, we sign out the user using the signOut method.
<k>auth.signOut();</k>
<k>Auth State Changes</k>
To keep track of the user authentication stateto know if the user is logged in or logged out, there is a method called onAuthSateChanged that allows you to receive an event whenever the authentication state changes.
<k>auth.onAuthStateChanged(user => {
  if (user) {
    console.log("user logged in");
    console.log(user);
    setupUI(user);
    var uid = user.uid;
    console.log(uid);
  } else {
    console.log("user logged out");
    setupUI();
  }
});</k>
If the user returned is null, the user is currently signed out. Otherwise, it is currently signed in.
In both scenarios, we print the current user state to the console and call the setupUI() function. We haven't created that function yet (we'll create it in the next section), but it will be responsible for handling the user interface accordingly to the authentication state.
When the user is logged in, we pass the user as an argument to the setupUI() function. In this case, we'll display the complete user interface to show the sensor readings, as you'll see later.
<k>if (user) {
  console.log("user logged in");
  console.log(user);
  setupUI(user);</k>
We also get the user UID that we'll need later to insert and read data from the database.
<k>var uid = user.uid;
console.log(uid);</k>
If the user is logged out, we call the setupUI() function without any argument. In that scenario, we'll simply display a message informing that the user is logged out and doesn't have access to the interface (as we'll see later).
<k>} else {
  console.log("user logged out");
  setupUI();
}</k>
<h4>index.js</h4>
The index.js file handles the UI  it shows the right content depending on the user authentication status. When the user is logged in, this file gets new readings from the database whenever there's a change.
Copy the following to the index.js file. 
<k>const loginElement = document.querySelector('#login-form');
const contentElement = document.querySelector("#content-sign-in");
const userDetailsElement = document.querySelector('#user-details');
const authBarElement = document.querySelector("#authentication-bar");
// Elements for sensor readings
const tempElement = document.getElementById("temp");
const humElement = document.getElementById("hum");
const presElement = document.getElementById("pres");
// MANAGE LOGIN/LOGOUT UI
const setupUI = (user) => {
  if (user) {
    //toggle UI elements
    loginElement.style.display = 'none';
    contentElement.style.display = 'block';
    authBarElement.style.display ='block';
    userDetailsElement.style.display ='block';
    userDetailsElement.innerHTML = user.email;
    // get user UID to get data from database
    var uid = user.uid;
    console.log(uid);
    // Database paths (with user UID)
    var dbPathTemp = 'UsersData/' + uid.toString() + '/temperature';
    var dbPathHum = 'UsersData/' + uid.toString() + '/humidity';
    var dbPathPres = 'UsersData/' + uid.toString() + '/pressure';
    // Database references
    var dbRefTemp = firebase.database().ref().child(dbPathTemp);
    var dbRefHum = firebase.database().ref().child(dbPathHum);
    var dbRefPres = firebase.database().ref().child(dbPathPres);
    // Update page with new readings
    dbRefTemp.on('value', snap => {
      tempElement.innerText = snap.val().toFixed(2);
    });
    dbRefHum.on('value', snap => {
      humElement.innerText = snap.val().toFixed(2);
    });
    dbRefPres.on('value', snap => {
      presElement.innerText = snap.val().toFixed(2);
    });
  // if user is logged out
  } else{
    // toggle UI elements
    loginElement.style.display = 'block';
    authBarElement.style.display ='none';
    userDetailsElement.style.display ='none';
    contentElement.style.display = 'none';
  }
}
</k>
<a href="https://github.com/RuiSantosdotme/Firebase-ESP/raw/main/ESP-Firebase-Sensor-BME280/index.js" target="_blank">View raw code</a>
Continue reading to learn how the code works or skip to the next section.
<k>Getting HTML Elements</k>
First, we create variables to refer to several elements on the UI interface by referring to their ids. To identify these elements, we recommend that you take a look at the HTML file provided and find the elements with the referred ids.
<k>const loginElement = document.querySelector('#login-form');
const contentElement = document.querySelector("#content-sign-in");
const userDetailsElement = document.querySelector('#user-details');
const authBarElement = document.querySelector("#authentication-bar");
// Elements for sensor readings
const tempElement = document.getElementById("temp");
const humElement = document.getElementById("hum");
const presElement = document.getElementById("pres");</k>
The loginElement corresponds to the login form. The contentElement corresponds to the section of the web page that is visible when the user is logged in (that shows the sensor readings). The userDetailsElement corresponds to a section that will display the email of the logged in user. The auhtBarElement corresponds to the authentication bar that shows the current user status, the email of the authenticated user and the logout link.
<k>sertupUI() Function</k>
Then, we create the setupUI() function that will handle the UI accordingly to the state of the user authentication.
In the auth.js file, we called the setupUI() function with the user argument setupUI(user) if the user is logged in; or the function without argument setupUI() when the user is logged out.
So, let's check what happens when the user is logged in.
<k>if (user) {</k>
We define which parts of the UI should be visible or invisible. When the user is logged in, we want to hide the login form. To hide an element, we can set the display style to none. 
<k>loginElement.style.display = 'none';</k>
We show the authentication bar (that shows the user details and the logout link). To do that, we can set its display style to block. We also want the web page's main content with the sensor readings to be visible.
<k>contentElement.style.display = 'block';
authBarElement.style.display ='block';</k>
Finally, we can get the logged in user email with user.email and display it in the userDetailsElement section as follows:
<k>userDetailsElement.innerHTML = user.email;</k>
<k>User UID and Database Paths</k>
After we have a logged-in user, we can get its UID with user.uid.
<k>var uid = user.uid;
console.log(uid);</k>
After getting the user UID, we create variables to refer to the database paths where we save the data.
<k>// Database paths (with user UID)
var dbPathTemp = 'UsersData/' + uid.toString() + '/temperature';
var dbPathHum = 'UsersData/' + uid.toString() + '/humidity';
var dbPathPres = 'UsersData/' + uid.toString() + '/pressure';</k>
Then, we create database references to those paths.
<k>var dbRefTemp = firebase.database().ref().child(dbPathTemp);
var dbRefHum = firebase.database().ref().child(dbPathHum);
var dbRefPres = firebase.database().ref().child(dbPathPres);</k>
<k>Display Sensor Readings</k>
The following lines get the new sensor readings whenever there's a change and update the corresponding HTML elements with the new values.
<k>// Update page with new readings
dbRefTemp.on('value', snap => {
  tempElement.innerText = snap.val().toFixed(2);
});
dbRefHum.on('value', snap => {
  humElement.innerText = snap.val().toFixed(2);
});
dbRefPres.on('value', snap => {
  presElement.innerText = snap.val().toFixed(2);
});</k>
<k>Logged Out UI</k>
The following snippet handles the UI when the user logs out. We want to hide the authentication bar and the main webpage content (sensor readings) and show the login form.
<k>} else{
  // toggle UI elements
  loginElement.style.display = 'block';
  authBarElement.style.display ='none';
  contentElement.style.display = 'none';
}</k>
<h3>Favicon File</h3>
To display a favicon in your web app, you need to move the picture you want to use as favicon to the public folder. The picture should be called favicon.png. You can simply drag the favicon file from your computer into the public folder in VS Code.
We're using the following icon as a favicon for our web app:
<a href="https://github.com/RuiSantosdotme/build-web-servers-dl/raw/main/favicon.zip" target="_blank">favicon.png</a>
<h3>Deploy your App</h3>
After saving the HTML, CSS, and JavaScript files, deploy your app on VS Code by running the following command on the Terminal window.
<k><k>firebase</k> deploy</k>
The Terminal should display something as follows:
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/ESP32-ESP8266-Deploy-Firebase-App-VS-Code-1.png">
Firebase offers a free hosting service to serve your assets and web apps. Then, you can access your web app from anywhere.
You can use the Hosting URL provided to access your web app from anywhere.
<h3>Demonstration</h3>
Congratulations! You successfully deployed your app. It is now hosted on a global CDN using Firebase hosting. You can access your web app from anywhere on the Hosting URL provided. In my case, it is https://esp-firebase-demo.web.app.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/ESP32-ESP8266-Sensor-Readings-Firebase-App.png">
The web app is responsive, and you can access it using your smartphone, computer, or tablet.
Insert the email and password of the authorized user you added in the Firebase Authentication methods. After that, you can access the latest sensor readings.
Go to your project's Firebase console <k>Hosting</k> tab. You can see your app domains, deploy history, and you can even roll back to previous versions of your app.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/ESP32-ESP8266-Firebase-Web-App-Deploy-History.png">
<h3>Wrapping Up</h3>
In this tutorial, you learned how to create a Firebase Web App with login/logout authentication that displays sensor readings. The sensor readings are saved on the realtime database. The database is protected using database rules (that you've already set up in the previous tutorial).
You can apply what you learned here to display any other type of data, and you can change the files in the public folder to add different functionalities and features to your project.
<h2>Firebase: Send BME280 Sensor Readings to the Realtime Database</h2>
In this guide, you'll learn how to send BME280 sensor readings to the Firebase Realtime Database using the ESP32 or ESP8266 NodeMCU boards. The ESP board will authenticate as a user with email and password, and you'll add database security rules to secure your data. The boards will be programmed using the Arduino core.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/ESP32-ESP8266-Firebase-BME280-RTDB-Database-Rules.jpg">
Here's Part 2 of this project: <a href="https://randomnerdtutorials.com/esp32-esp8266-firebase-web-app-sensor/">ESP32/ESP8266: Firebase Web App to Display Sensor Readings (with Authentication)</a>
Other Firebase Tutorials with the ESP32/ESP8266 that you might be interested in:
<a href="https://randomnerdtutorials.com/esp32-firebase-realtime-database/">ESP32: Getting Started with Firebase (Realtime Database)</a>
<a href="https://randomnerdtutorials.com/esp8266-nodemcu-firebase-realtime-database/">ESP8266 NodeMCU: Getting Started with Firebase (Realtime Database)</a>
<a href="https://randomnerdtutorials.com/esp32-firebase-web-app/">ESP32 with Firebase  Creating a Web App</a>
<a href="https://randomnerdtutorials.com/esp8266-nodemcu-firebase-web-app/">ESP8266 NodeMCU with Firebase  Creating a Web App</a>
<a href="https://randomnerdtutorials.com/esp32-esp8266-firebase-authentication/">ESP32/ESP8266 Firebase Authentication (Email and Password)</a>
<h3>What is Firebase?</h3>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/Firebase-logo.png">
Firebase is Google's mobile application development platform that helps you build, improve, and grow your app. It has many services used to manage data from any android, IOS, or web application like <a href="https://randomnerdtutorials.com/esp32-esp8266-firebase-authentication/">authentication</a>, <a href="https://randomnerdtutorials.com/esp32-firebase-realtime-database/">realtime database</a>, <a href="https://randomnerdtutorials.com/esp32-firebase-web-app/">hosting</a>, etc.
<h3>Project Overview</h3>
The following diagram shows a high-level overview of the project we'll build.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/Firebase-BME280-Sensor-Readings-Database-Project-Overview.png">
<ol>
The ESP32/ESP8266 authenticates as a user with email and password (that user must be set on the Firebase authentication methods);
After authentication, the ESP gets the user UID;
The database is protected with security rules. The user can only access the database nodes under the node with its user UID. After getting the user UID, the ESP can publish data to the database;
The ESP sends temperature, humidity and pressure to the database.
</ol>
These are the main steps to complete this project:
<ol>
Create Firebase Project
Set Authentication Methods
Get Project API Key
Set up Realtime Database
Set up Database Security Rules
ESP32/ESP8266 Send Sensor Readings to the Realtime Database
</ol>
You can continue with the Firebase project <k><a href="https://randomnerdtutorials.com/esp32-esp8266-firebase-authentication/">from this previous</a> tutorial</k> or create a new project. If you use the Firebase project of that previous tutorial, you can skip to section <a style="font-size: inherit;" href="#Set-up-Realtime-Database">4) Set up Realtime Database</a> because the authentication methods are already set up.
<h3>Preparing Arduino IDE</h3>
For this tutorial, we'll program the ESP32 and ESP8266 boards using the Arduino core. So, make sure you have the ESP32 or ESP8266 add-on installed in your Arduino IDE:
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing the ESP32 Board in Arduino IDE (Windows, Mac OS X, Linux)</a>
<a href="https://randomnerdtutorials.com/how-to-install-esp8266-board-arduino-ide/">Installing ESP8266 Board in Arduino IDE (Windows, Mac OS X, Linux)</a>
If you want to program the ESP boards using VS Code with the PlatformIO extension, follow the following tutorial instead:
<a href="https://randomnerdtutorials.com/vs-code-platformio-ide-esp32-esp8266-arduino/">Getting Started with VS Code and PlatformIO IDE for ESP32 and ESP8266</a>
<h3>1) Create Firebase Proje3t</h3>
<k>1)</k> Go to <a style="font-size: inherit;" href="https://firebase.google.com/" target="_blank">Firebase </a>and sign in using a Google Account.
<k>2)</k> Click <em style="font-size: inherit;">Get Started</em> and then <k>Add project</k> to create a new project.
<k>3)</k> Give a name to your project, for example <em style="font-size: inherit;">ESP Firebase Demo</em>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/Create-firebase-project-1.png">
 <k>4)</k> Disable the option <em style="font-size: inherit;">Enable Google Analytics</em> for this project as it is not needed and click <k>Create project</k>. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/2-Set-Up-Firebase-Project-ESP32-ESP8266.png">
 <k>5)</k> It will take a few seconds to set up your project. Then, click <k>Continue</k> when it's ready. 
 <k>6)</k> You'll be redirected to your Project console page. 
<h3>2) Set Authentication Methods</h3>
To allow authentication with email and password, first, you need to set authentication methods for your app. 
Most apps need to know the identity of a user. In other words, it takes care of logging in and identifying the users (in this case, the ESP32 or ESP8266). Knowing a user's identity allows an app to securely save user data in the cloud and provide the same personalized experience across all of the user's devices. To learn more about the authentication methods, you can <a href="https://firebase.google.com/docs/auth" target="_blank">read the documentation</a>.
<k>1)</k> On the left sidebar, click on <k>Authentication </k>and then on <k>Get started</k>. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/Firebase-Project-Authentication.png">
<k>2)</k> Select the Option <k>Email/Password</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/Authentication-methods.png">
<k>3)</k> Enable that authentication method and click <k>Save</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/Firebase-email-password-sign-in-provider.png">
<k>4)</k> The authentication with email and password should now be enabled.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/email-password-enabled.png">
<k>5)</k> Now, you need to add a user. On the <k>Authentication </k>tab, select the <k>Users </k>tab at the top. Then, click on <k>Add User</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/Firebase-Add-New-User.png">
<k>6)</k> Add an email address for the authorized user. It can be your google account email or any other email. You can also create an email for this specific project. Add a password that will allow you to sign in to your app and access the database. Don't forget to save the password in a safe place because you'll need it later. When you're done, click <k>Add user</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/Firebase-Add-User-Email-Password.png">
<k>7)</k> A new user was successfully created and added to the <k>Users</k> table.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/Users-Table-Firebase.png">
Notice that Firebase creates a unique UID for each registered user. The user UID allows us to identify the user and keep track of the user to provide or deny access to the project or the database. There's also a column that registers the date of the last sign-in. At the moment, it is empty because we haven't signed in with that user yet.
<h3>3) Get Project API Key</h3>
To interface with your Firebase project using the ESP32 or ESP8266 boards, you need to get your project API key. Follow the next steps to get your project API key.
<k>1)</k> On the left sidebar, click on <k>Project Settings</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/Firebase-project-settings.png">
<k>2)</k> Copy the Web API Key to a safe place because you'll need it later.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/Firebase-Project-Settings-Web-API-Key.png">
<h3>4) Set up Realtime Database</h3>
Now, let's create a realtime database and set up database rules for our project.
<k>1)</k> On the left sidebar, click on <k>Realtime Database</k> and then click on <k>Create Database</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/Firebase-Project-Create-Realtime-Database.png">
<k>2)</k> Select your database location. It should be the closest to your location.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/2-Set-Up-Firebase-database-ESP32-ESP8266.png">
<k>3)</k> Set up security rules for your database. You can select <k>Start in test mode</k>. We'll change the database rules in just a moment.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/08/3-Set-Up-Firebase-database-ESP32-ESP8266.png">
<k>4)</k> Your database is now created. You need to copy and save the database URLhighlighted in the following imagebecause you'll need it later in your ESP32/ESP8266 code.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/Firebase-project-database-URL.png">
<h3>5) Set up Database Security Rules</h3>
Now, let's set up the database rules. On the <k>Realtime Database</k> tab, select the <k>Rules</k> tab at the top. Then, click on <k>Edit rules</k>, copy the following rules and then click <k>Publish</k>.
<k>// These rules grant access to a node matching the authenticated
// user's ID from the Firebase auth token
{
  "rules": {
    "UsersData": {
      "$uid": {
        ".read": "$uid === auth.uid",
        ".write": "$uid === auth.uid"
      }
    }
  }
}</k>
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/Firebase-Set-up-Database-Security-Rules.png">
These rules grant access to a node matching the authenticated user's UID. This grants that each authenticated user can only access its own data. This means the user can only access the nodes that are under a node with its corresponding user UID. If there are other data published on the database, not under a node with the users' UID, that user can't access that data.
For example, imagine our user UID is RjO3taAzMMXBB2Xmir2LQ. With our security rules, it can read and write data to the database under the node UsersData/RjO3taAzMMXBB2Xmir2LQ.
You'll better understand how this works when you start working with the ESP32/ESP8266.
<h3>6) ESP32/ESP8266 Send Sensor Readings to the Realtime Databa3e</h3>
In this section, we'll program the ESP32 or ESP8266 boards to do the following tasks:
<ol>
Authenticate as a user with email and password (the user you set up in this section);
Send sensor readings to the realtime database as an authorized user.
</ol>
<h3>Parts Required</h3>
For this project, you need the following parts*:
<a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32</a> or<a href="https://makeradvisor.com/tools/esp8266-esp-12e-nodemcu-wi-fi-development-board/" target="_blank"> ESP8266</a> board (read <a href="https://makeradvisor.com/esp32-vs-esp8266/" target="_blank">ESP32 vs ESP8266</a>);
<a href="https://makeradvisor.com/tools/bme280-sensor-module/" target="_blank">BME280</a> or any other sensor you're familiar with;
<a href="https://makeradvisor.com/tools/mb-102-solderless-breadboard-830-points/" target="_blank">Breadboard</a>;        <a href="https://makeradvisor.com/tools/jumper-wires-kit-120-pieces/"> </a>
<a href="https://makeradvisor.com/tools/jumper-wires-kit-120-pieces/" target="_blank">Jumper wires</a>.
* you can also test the project with random values instead of sensor readings, or you can use any other sensor you're familiar with.
You can use the preceding links or go directly to <a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank">MakerAdvisor.com/tools</a> to find all the parts for your projects at the best price!
<a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/header-200.png?w=828&quality=100&strip=all&ssl=1" data-recalc-dims="1" loading="lazy" fetchpriority="low"></a>
<h3>Schematic Diagram</h3>
In this tutorial, we'll send BME280 sensor readings to the Firebase Realtime Database. So, you need to wire the BME280 sensor to your board. Follow one of the following schematic diagrams.
<h4>ESP32 with BME280</h4>
We're going to use I2C communication with the BME280 sensor module. For that, wire the sensor to the default ESP32 SCL (GPIO 22) and SDA (GPIO 21) pins, as shown in the following schematic diagram.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/10/ESP32-BME280-Sensor-Temperature-Humidity-Pressure-Wiring-Diagram-Circuit_f.png">
Not familiar with the BME280 with the ESP32? Read this tutorial: <a href="https://randomnerdtutorials.com/esp32-bme280-arduino-ide-pressure-temperature-humidity/"><k>ESP32 with BME280 Sensor using Arduino IDE (Pressure, Temperature, Humidity)</k></a>.
<h4>ESP8266 with BME280 </h4>
We're going to use I2C communication with the BME280 sensor module. For that, wire the sensor to the ESP8266 SDA (GPIO 4) and SCL (GPIO 5) pins, as shown in the following schematic diagram.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/07/ESP8266-NodeMCU-BME280-Sensor-Temperature-Humidity-Pressure-Wiring-Diagram-Circuit.png">
Not familiar with the BME280 with the ESP8266? Read this tutorial: <a href="https://randomnerdtutorials.com/esp8266-bme280-arduino-ide/"><k>ESP8266 with BME280 using Arduino IDE (Pressure, Temperature, Humidity)</k></a>.
<h3>Installing Libraries</h3>
For this project, you need to install the following libraries:
<a href="https://github.com/mobizt/Firebase-ESP-Client" target="_blank">Firebase ESP Client Library</a>
<a href="https://github.com/adafruit/Adafruit_BME280_Library" target="_blank">Adafruit BME280 Library</a>
<a href="https://github.com/adafruit/Adafruit_Sensor" target="_blank">Adafruit Unified Sensor Library</a>
<h4>Installing Libraries  VS Code</h4>
Follow the next instructions if you're using VS Code with the PlatformIO extension.
<h5><k>Install the Firebase-ESP-Client Library</k></h5>
There is a library with lots of examples to use Firebase with the ESP32: the <a href="https://github.com/mobizt/Firebase-ESP-Client" target="_blank">Firebase-ESP-Client library</a>. This library is compatible with both the ESP32 and ESP8266 boards.
Click on the <k>PIO Home</k> icon and select the <k>Libraries tab</k>. Search for <k>Firebase ESP Client</k>. Select the <k>Firebase Arduino Client Library for ESP8266 and ESP32</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/Install-Firebase-Library-VS-Code-1.png">
Then, click <k>Add to Project</k> and select the project you're working on.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/Install-Firebase-Library-VS-Code-2.png">
<k>Install the BME280 Library</k> 
In the <k>Libraries</k> tab, search for <k>BME280</k>. Select the <k>Adafruit BME280</k> library.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/PlatformIO-VS-Code-Search-BME280-library.png">
 Then, click <k>Add to Project</k> and select the project you're working on.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/09/PlatformIO-add-library-to-project.png">
Also, change the monitor speed to 115200 by adding the following line to the platformio.ini file of your project:
<k>monitor_speed = 115200</k>
<h4>Installation  Arduino IDE</h4>
Follow this section if you're using Arduino IDE. 
You need to install the following libraries:
<a href="https://github.com/mobizt/Firebase-ESP-Client" target="_blank">Firebase ESP Client Library</a>
<a href="https://github.com/adafruit/Adafruit_BME280_Library" target="_blank">Adafruit BME280 Library</a>
<a href="https://github.com/adafruit/Adafruit_Sensor" target="_blank">Adafruit Unified Sensor Library</a>
Go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k>, search for the libraries' names and install the libraries.
For the Firebase Client library, select the <k>Firebase Arduino Client Library for ESP8266 and ESP32</k>.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/09/Install-Firebase-ESP-Client-Library-Arduino-IDE-f.png">
Now, you're all set to start programming the ESP32 and ESP8266 boards to interact with the database.
<h3>
Send Sensor Readings to the Realtime Database Code</h3>
Copy the following code to your Arduino IDE or to the main.cpp file if you're using VS Code.
You need to insert your network credentials, project API key, database URL, and the authorized user email and password.
<k>/*
  Rui Santos
  Complete project details at our blog: https://RandomNerdTutorials.com/esp32-esp8266-firebase-bme280-rtdb/
  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files.
  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
*/
#include &lt;Arduino.h>
#if defined(ESP32)
  #include &lt;WiFi.h>
#elif defined(ESP8266)
  #include &lt;ESP8266WiFi.h>
#endif
#include &lt;Firebase_ESP_Client.h>
#include &lt;Wire.h>
#include &lt;Adafruit_Sensor.h>
#include &lt;Adafruit_BME280.h>
// Provide the token generation process info.
#include "addons/TokenHelper.h"
// Provide the RTDB payload printing info and other helper functions.
#include "addons/RTDBHelper.h"
// Insert your network credentials
#define WIFI_SSID "REPLACE_WITH_YOUR_SSID"
#define WIFI_PASSWORD "REPLACE_WITH_YOUR_PASSWORD"
// Insert Firebase project API Key
#define API_KEY "REPLACE_WITH_YOUR_PROJECT_API_KEY"
// Insert Authorized Email and Corresponding Password
#define USER_EMAIL "REPLACE_WITH_THE_USER_EMAIL"
#define USER_PASSWORD "REPLACE_WITH_THE_USER_PASSWORD"
// Insert RTDB URLefine the RTDB URL
#define DATABASE_URL "REPLACE_WITH_YOUR_DATABASE_URL"
// Define Firebase objects
FirebaseData fbdo;
FirebaseAuth auth;
FirebaseConfig config;
// Variable to save USER UID
String uid;
// Variables to save database paths
String databasePath;
String tempPath;
String humPath;
String presPath;
// BME280 sensor
Adafruit_BME280 bme; // I2C
float temperature;
float humidity;
float pressure;
// Timer variables (send new readings every three minutes)
unsigned long sendDataPrevMillis = 0;
unsigned long timerDelay = 180000;
// Initialize BME280
void initBME(){
  if (!bme.begin(0x76)) {
    Serial.println("Could not find a valid BME280 sensor, check wiring!");
    while (1);
  }
}
// Initialize WiFi
void initWiFi() {
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  Serial.print("Connecting to WiFi ..");
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print('.');
    delay(1000);
  }
  Serial.println(WiFi.localIP());
  Serial.println();
}
// Write float values to the database
void sendFloat(String path, float value){
  if (Firebase.RTDB.setFloat(&fbdo, path.c_str(), value)){
    Serial.print("Writing value: ");
    Serial.print (value);
    Serial.print(" on the following path: ");
    Serial.println(path);
    Serial.println("PASSED");
    Serial.println("PATH: " + fbdo.dataPath());
    Serial.println("TYPE: " + fbdo.dataType());
  }
  else {
    Serial.println("FAILED");
    Serial.println("REASON: " + fbdo.errorReason());
  }
}
void setup(){
  Serial.begin(115200);
  // Initialize BME280 sensor
  initBME();
  initWiFi();
  // Assign the api key (required)
  config.api_key = API_KEY;
  // Assign the user sign in credentials
  auth.user.email = USER_EMAIL;
  auth.user.password = USER_PASSWORD;
  // Assign the RTDB URL (required)
  config.database_url = DATABASE_URL;
  Firebase.reconnectWiFi(true);
  fbdo.setResponseSize(4096);
  // Assign the callback function for the long running token generation task */
  config.token_status_callback = tokenStatusCallback; //see addons/TokenHelper.h
  // Assign the maximum retry of token generation
  config.max_token_generation_retry = 5;
  // Initialize the library with the Firebase authen and config
  Firebase.begin(&config, &auth);
  // Getting the user UID might take a few seconds
  Serial.println("Getting User UID");
  while ((auth.token.uid) == "") {
    Serial.print('.');
    delay(1000);
  }
  // Print user UID
  uid = auth.token.uid.c_str();
  Serial.print("User UID: ");
  Serial.println(uid);
  // Update database path
  databasePath = "/UsersData/" + uid;
  // Update database path for sensor readings
  tempPath = databasePath + "/temperature"; // --> UsersData/&lt;user_uid>/temperature
  humPath = databasePath + "/humidity"; // --> UsersData/&lt;user_uid>/humidity
  presPath = databasePath + "/pressure"; // --> UsersData/&lt;user_uid>/pressure
}
void loop(){
  // Send new readings to database
  if (Firebase.ready() && (millis() - sendDataPrevMillis > timerDelay || sendDataPrevMillis == 0)){
    sendDataPrevMillis = millis();
    // Get latest sensor readings
    temperature = bme.readTemperature();
    humidity = bme.readHumidity();
    pressure = bme.readPressure()/100.0F;
    // Send readings to database:
    sendFloat(tempPath, temperature);
    sendFloat(humPath, humidity);
    sendFloat(presPath, pressure);
  }
}
</k>
<a href="https://github.com/RuiSantosdotme/Firebase-ESP/raw/main/ESP-Firebase-Sensor-BME280/ESP-Firebase-Sensor-BME280.ino" target="_blank">View raw code</a>
<h3>How the Code Works</h3>
Continue reading to learn how the code works or skip to the demonstration section.
<h4>Include Libraries</h4>
First, include the required libraries. The WiFi.h library to connect the ESP32 to the internet (or the ESP8266WiFi.h library for the ESP8266 board), the Firebase_ESP_Client.h  library to interface the boards with Firebase, and the Wire, Adafruit_Sensor, and Adafruit_BME280 to interface with the BME280 sensor.
<k>#include &lt;Arduino.h>
#if defined(ESP32)
  #include &lt;WiFi.h>
#elif defined(ESP8266)
  #include &lt;ESP8266WiFi.h>
#endif
#include &lt;Firebase_ESP_Client.h>
#include &lt;Wire.h>
#include &lt;Adafruit_Sensor.h>
#include &lt;Adafruit_BME280.h></k>
You also need to include the following for the Firebase library to work.
<k>// Provide the token generation process info.
#include "addons/TokenHelper.h"
// Provide the RTDB payload printing info and other helper functions.
#include "addons/RTDBHelper.h"</k>
<h4>Network Credentials</h4>
Include your network credentials in the following lines so that your boards can connect to the internet using your local network.
<k>// Insert your network credentials
#define WIFI_SSID "REPLACE_WITH_YOUR_SSID"
#define WIFI_PASSWORD "REPLACE_WITH_YOUR_PASSWORD"</k>
<h4>Firebase Project API Key, Firebase User, and Database URL</h4>
Insert your Firebase project API keythe one you've gotten in this section.
<k>#define API_KEY "REPLACE_WITH_YOUR_PROJECT_API_KEY"</k>
Insert the authorized email and the corresponding passwordthese are the details of the user you've added in this section.
<k>// Insert Authorized Email and Corresponding Password
#define USER_EMAIL "REPLACE_WITH_THE_USER_EMAIL"
#define USER_PASSWORD "REPLACE_WITH_THE_USER_PASSWORD"</k>
Insert your database URL in the following line:
<k>// Insert RTDB URLefine the RTDB URL
#define DATABASE_URL "REPLACE_WITH_YOUR_DATABASE_URL"</k>
<h4>Firebase Objects and Other Variables</h4>
The following line defines a FirebaseData object.
<k>FirebaseData fbdo;</k>
The next line defines a FirebaseAuth object needed for authentication.
<k>FirebaseAuth auth;</k>
Finally, the following line defines a FirebaseConfig object required for configuration data.
<k>FirebaseConfig config;</k>
The uid variable will be used to save the user's UID. We can get the user's UID after the authentication.
<k>String uid;</k>
The following variables will be used to save the nodes to where we'll send the sensor readings. We'll update these variables later in the code when we get the user UID.
<k>// Variables to save database paths
String databasePath;
String tempPath;
String humPath;
String presPath;</k>
Then, create an Adafruit_BME280 object called bme. This automatically creates a sensor object on the ESP32 or ESP8266 default I2C pins.
<k>Adafruit_BME280 bme; // I2C</k>
The following variables will hold the temperature, humidity, and pressure readings from the sensor.
<k>float temperature;
float humidity;
float pressure;</k>
<h4>Delay Time</h4>
The sendDataPrevMillis and timerDelay variables are used to check the delay time between each send. In this example, we're setting the delay time to 3 minutes (18000 milliseconds). Once you test this project and check that everything is working as expected, we recommend increasing the delay.
<k>// Timer variables (send new readings every three minutes)
unsigned long sendDataPrevMillis = 0;
unsigned long timerDelay = 180000;</k>
<h4>initBME()</h4>
The initBME() function initializes the BME280 library using the bme object created previously. Then, you should call this library in the setup().
<k>void initBME(){
  if (!bme.begin(0x76)) {
    Serial.println("Could not find a valid BME280 sensor, check wiring!");
    while (1);
  }
}</k>
<h4>initWiFi()</h4>
The initWiFi() function connects your ESP to the internet using the network credentials provided. You must call this function later in the setup() to initialize WiFi.
<k>// Initialize WiFi
void initWiFi() {
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  Serial.print("Connecting to WiFi ..");
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print('.');
    delay(1000);
  }
  Serial.println(WiFi.localIP());
  Serial.println();
}</k>
<h4>Send Data to the Database</h4>
To store data at a specific node in the Firebase Realtime Database, you can use the following functions: set, setInt, setFloat, setDouble, setString, setJSON, setArray, setBlob, and setFile.
These functions return a boolean value indicating the success of the operation, which will be true if all of the following conditions are met: 
The server returns HTTP status code 200
The data types matched between request and response
Only setBlob and setFile functions that make a silent request to Firebase server, thus no payload response returned.
Learn more: <a href="https://randomnerdtutorials.com/esp32-firebase-realtime-database/">ESP32: Getting Started with Firebase (Realtime Database)</a>
In our example, we'll send float variables, so we need to use the setFloat() function as follows.
<k>Firebase.RTDB.setFloat(&fbdo, "DATABASE_NODE", VALUE)</k>
The second argument refers to the database node (char variable) to which we want to send the data. The third argument is the data we want to send (float variable).
As we'll need to send three float values, we created a functionthe sendFloat() function that accepts the node path and the value as arguments.
<k>// Write float values to the database
void sendFloat(String path, float value){
  if (Firebase.RTDB.setFloat(&fbdo, path.c_str(), value)){
    Serial.print("Writing value: ");
    Serial.print (value);
    Serial.print(" on the following path: ");
    Serial.println(path);
    Serial.println("PASSED");
    Serial.println("PATH: " + fbdo.dataPath());
    Serial.println("TYPE: " + fbdo.dataType());
  }
  else {
    Serial.println("FAILED");
    Serial.println("REASON: " + fbdo.errorReason());
  }
}</k>
Later, we'll call that function in the loop() to send sensor readings.
<h4>setup()</h4>
In setup(), initialize the Serial Monitor for debugging purposes at a baud rate of 115200.
<k>Serial.begin(115200);</k>
Call the initBME() function to initialize the BME280 sensor.
<k>initBME();</k>
Call the initWiFi() function to initialize WiFi.
<k>initWiFi();</k>
Assign the API key to the Firebase configuration.
<k>config.api_key = API_KEY;</k>
The following lines assign the email and password to the Firebase authentication object.
<k>auth.user.email = USER_EMAIL;
auth.user.password = USER_PASSWORD;</k>
Assign the database URL to the Firebase configuration object.
<k>config.database_url = DATABASE_URL;</k>
Add the following to the configuration object.
<k>// Assign the callback function for the long running token generation task
config.token_status_callback = tokenStatusCallback; //see addons/TokenHelper.h
// Assign the maximum retry of token generation
config.max_token_generation_retry = 5;</k>
Initialize the Firebase library (authenticate) with the configuration and authentication settings we defined earlier.
<k>// Initialize the library with the Firebase authen and config
Firebase.begin(&config, &auth);</k>
After initializing the library, we can get the user UID by calling auth.token.uid. Getting the user's UID might take some time, so we add a while loop that waits until we get it.
<k>// Getting the user UID might take a few seconds
Serial.println("Getting User UID");
while ((auth.token.uid) == "") {
  Serial.print('.');
  delay(1000);
}</k>
Finally, we save the user's UID in the uid variable and print it in the Serial Monitor.
<k>uid = auth.token.uid.c_str();
Serial.print("User UID: ");
Serial.print(uid);</k>
After getting the user UID, we can update the database node paths to include the user UID. That's what we do in the following lines.
<k>// Update database path for sensor readings
tempPath = databasePath + "/temperature"; // --> UsersData/&lt;user_uid>/temperature
humPath = databasePath + "/humidity"; // --> UsersData/&lt;user_uid>/humidity
presPath = databasePath + "/pressure"; // --> UsersData/&lt;user_uid>/pressure</k>
<h4>loop()</h4>
In the loop(), check if it is time to send new readings:
<k>if (Firebase.ready() && (millis() - sendDataPrevMillis > timerDelay || sendDataPrevMillis == 0)){
  sendDataPrevMillis = millis();</k>
If it is, get the latest sensor readings from the BME280 sensor and save them on the temperature, humidity, and pressure variables.
<k>// Get latest sensor readings
temperature = bme.readTemperature();
humidity = bme.readHumidity();
pressure = bme.readPressure()/100.0F;</k>
Finally, call the sendFloat() function to send the new readings to the database. Pass as arguments the node path and the value.
<k>// Send readings to database:
sendFloat(tempPath, temperature);
sendFloat(humPath, humidity);
sendFloat(presPath, pressure);</k>
<h3>Demonstration</h3>
Upload the previous code to your board. The code is compatible with both the ESP32 and ESP8266 boards. Don't forget to insert your network credentials, project API key, database URL, user email, and the corresponding password.
After uploading the code, press the board RST button so that it starts running the code. It should authenticate to Firebase, get the user UID, and immediately send new readings to the database.
Open the Serial Monitor at a baud rate of 115200 and check that everything is working as expected.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/Send-Data-Realtime-Database-Firebase-ESP32-ESP8266-Serial-Monitor.png">
Aditionally, go to the Realtime Database on your Firebase project interface and check that new readings are saved. Notice that it saves the data under a node with the own user UIDthis is a way to restrict access to the database.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/10/Send-Data-Realtime-Database-Firebase-ESP32-ESP8266.png">
And that's it. You've successfully sent sensor readings to the Firebase Realtime Database, and you protected the data using database rules.
<h3>Wrapping Up</h3>
In this tutorial, you've learned how to authenticate the ESP32/ESP8266 as a user with email and password, send sensor readings to the database, and set up security rules to protect your database and restrict access.
In <a href="https://randomnerdtutorials.com/esp32-esp8266-firebase-web-app-sensor/">PART 2</a>, we'll create a <a href="https://randomnerdtutorials.com/esp32-esp8266-firebase-web-app-sensor/">Firebase Web App with authentication (login with email and password)</a> that displays the sensor readings saved on the database. Only an authorized logged-in user can access the data. Later you'll be able to modify that project to display all sorts of data and restrict or allow access to the data to specific users.
We hope you've found this tutorial useful.
<k>>> <a href="https://randomnerdtutorials.com/esp32-esp8266-firebase-web-app-sensor/">Continue to Part 2: ESP32/ESP8266: Firebase Web App to Display Sensor Readings (with Authentication)</a></k>
If you like Firebase projects, please take a look at our new eBook. We're sure you'll like it:
<k><a href="https://randomnerdtutorials.com/firebase-esp32-esp8266-ebook/">Firebase Web App with ESP32 and ESP8266</a></k>
Learn more about the ESP32 and ESP8266 with our resources:
<a href="https://randomnerdtutorials.com/projects-esp32/" title="https://randomnerdtutorials.com/projects-esp32/">Free ESP32 Projects and Tutorials</a>
<a href="https://randomnerdtutorials.com/projects-esp8266/" title="https://randomnerdtutorials.com/projects-esp8266/">Free ESP8266 Projects and Tutorials</a>
<a href="https://randomnerdtutorials.com/learn-esp32-with-arduino-ide/">Learn ESP32 with Arduino IDE</a>
<a href="https://randomnerdtutorials.com/home-automation-using-esp8266/">Home Automation using ESP8266</a>
Thanks for reading.
<center><a href="https://randomnerdtutorials.com/pcbway" target="_blank"><img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/2022/03/728x280.jpg" width="728" height="280" loading="lazy" fetchpriority="low"></a></center>
<a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/">
<img class="lazy" data-src="https://randomnerdtutorials.com/wp-content/uploads/elementor/thumbs/Build-Web-Servers-with-ESP32-and-ESP8266-eBook-2nd-Edition-500px-h-p2lw6wwnkk9ystvwe9iof8zx6yt4x7uma3cqfup534.jpg" title="Build-Web-Servers-with-ESP32-and-ESP8266-eBook-2nd-Edition-500px-h" alt="Build-Web-Servers-with-ESP32-and-ESP8266-eBook-2nd-Edition-500px-h" loading="lazy" width="129" height="180" fetchpriority="low"></a>
<h4><a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/">[eBook] Build Web Servers with ESP32 and ESP8266 (2nd Edition)</a></h4>
Build Web Server projects with the ESP32 and ESP8266 boards to control outputs and monitor sensors remotely. Learn HTML, CSS, JavaScript and client-server communication protocols <k><a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
Build Web Server projects with the ESP32 and ESP8266 boards to control outputs and monitor sensors remotely. Learn HTML, CSS, JavaScript and client-server communication protocols <k><a href="https://randomnerdtutorials.com/build-web-servers-esp32-esp8266-ebook/" rel="noopener">DOWNLOAD <U+00BB></a></k>
<h2>NTP Time  Setting Up Timezones and Daylight Saving Time</a8></h2>
In this tutorial, you'll learn how to properly get the time with the ESP32 for your timezone and consider daylight saving time (if that's the case). The ESP32 will request the time from an NTP server, and the time will be automatically adjusted for your timezone with or without daylight saving time.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/11/ESP32-Timezones-Daylight-Saving-Time.jpg">
<k>Quick Answer:</k> call setenv(TZ, <k>timezone</k>, 1), where <k>timezone</k> is one of the <a href="https://github.com/nayarsystems/posix_tz_db/blob/master/zones.csv" target="_blank">timezones listed here</a>. Then, call tzset() to update to that timezone.
<hr>
If you're getting started, we recommend taking a look at the following tutorial first to learn how to get date and time from an NTP server:
<a href="https://randomnerdtutorials.com/esp32-date-time-ntp-client-server-arduino/">ESP32 NTP Client-Server: Get Date and Time (Arduino IDE)</a>
In that previous tutorial, we've shown an option to set up your timezone. However, that example doesn't take into account daylight saving time. Continue reading this tutorial to learn how to set up the timezone and daylight saving time properly.
Thanks to one of our readers (Hardy Maxa) who shared this information with us.
<h3>ESP32 Setting Timezone with Daylight Saving Time</h3>
According to <a href="https://github.com/espressif/esp-idf/blob/master/examples/protocols/sntp/README.md" target="_blank">documentation</a>:
To set local timezone, use <a href="https://man7.org/linux/man-pages/man3/setenv.3.html" target="_blank">setenv </a>and tzset POSIX functions. First, call setenv to set TZ environment variable to the correct value depending on device location. Format of the time string is described in <a href="https://www.gnu.org/software/libc/manual/html_node/TZ-Variable.html" target="_blank">libc documentation</a>. Next, call <a href="https://man7.org/linux/man-pages/man3/tzset.3.html" target="_blank">tzset </a>to update C library runtime data for the new time zone. Once these steps are done, localtime function will return correct local time, taking time zone offset and daylight saving time into account. 
You can check a <a href="https://github.com/nayarsystems/posix_tz_db/blob/master/zones.csv" target="_blank">list of timezone string variables here</a>. 
For example, I live in Porto. The timezone is Europe/Lisbon. From the list of timezone string variables,  I see that the timezone string variable for my location is WET0WEST,M3.5.0/1,M10.5.0, so after connecting to the NTP server, to get the time for my location I need to call:
<k>setenv("TZ","WET0WEST,M3.5.0/1,M10.5.0",1);</k>
 Followed by:
<k>tzset();</k>
Let's look at a demo sketch to understand how it works and how to use it in your ESP32 project.
<h3>ESP32 Timezone and DST Example Sketch</h3>
The following example was provided by one of our followers (Hardy Maxa), we've just made a few modifications.
Copy the following code to your Arduino IDE.
<k>// RTC demo for ESP32, that includes TZ and DST adjustments
// Get the POSIX style TZ format string from  https://github.com/nayarsystems/posix_tz_db/blob/master/zones.csv
// Created by Hardy Maxa
// Complete project details at: https://RandomNerdTutorials.com/esp32-ntp-timezones-daylight-saving/
#include &lt;WiFi.h>
#include "time.h"
const char * ssid="REPLACE_WITH_YOUR_SSID";
const char * wifipw="REPLACE_WITH_YOUR_PASSWORD";
void setTimezone(String timezone){
  Serial.printf("  Setting Timezone to %s\n",timezone.c_str());
  setenv("TZ",timezone.c_str(),1);  //  Now adjust the TZ.  Clock settings are adjusted to show the new local time
  tzset();
}
void initTime(String timezone){
  struct tm timeinfo;
  Serial.println("Setting up time");
  configTime(0, 0, "pool.ntp.org");    // First connect to NTP server, with 0 TZ offset
  if(!getLocalTime(&timeinfo)){
    Serial.println("  Failed to obtain time");
    return;
  }
  Serial.println("  Got the time from NTP");
  // Now we can set the real timezone
  setTimezone(timezone);
}
void printLocalTime(){
  struct tm timeinfo;
  if(!getLocalTime(&timeinfo)){
    Serial.println("Failed to obtain time 1");
    return;
  }
  Serial.println(&timeinfo, "%A, %B %d %Y %H:%M:%S zone %Z %z ");
}
void  startWifi(){
  WiFi.begin(ssid, wifipw);
  Serial.println("Connecting Wifi");
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print(".");
    delay(500);
  }
  Serial.print("Wifi RSSI=");
  Serial.println(WiFi.RSSI());
}
void setTime(int yr, int month, int mday, int hr, int minute, int sec, int isDst){
  struct tm tm;
  tm.tm_year = yr - 1900;   // Set date
  tm.tm_mon = month-1;
  tm.tm_mday = mday;
  tm.tm_hour = hr;      // Set time
  tm.tm_min = minute;
  tm.tm_sec = sec;
  tm.tm_isdst = isDst;  // 1 or 0
  time_t t = mktime(&tm);
  Serial.printf("Setting time: %s", asctime(&tm));
  struct timeval now = { .tv_sec = t };
  settimeofday(&now, NULL);
}
void setup(){
  Serial.begin(115200);
  Serial.setDebugOutput(true);
  startWifi();
  initTime("WET0WEST,M3.5.0/1,M10.5.0");   // Set for Melbourne/AU
  printLocalTime();
}
void loop() {
  int i;
  
  // put your main code here, to run repeatedly:
  Serial.println("Lets show the time for a bit.  Starting with TZ set for Melbourne/Australia");
  for(i=0; i&lt;10; i++){
    delay(1000);
    printLocalTime();
  }
  Serial.println();
  Serial.println("Now - change timezones to Berlin");
  setTimezone("CET-1CEST,M3.5.0,M10.5.0/3");
  for(i=0; i&lt;10; i++){
    delay(1000);
    printLocalTime();
  }
  Serial.println();
  Serial.println("Now - Lets change back to Lisbon and watch Daylight savings take effect");
  setTimezone("WET0WEST,M3.5.0/1,M10.5.0");
  printLocalTime();
  Serial.println();
  Serial.println("Now change the time.  1 min before DST takes effect. (1st Sunday of Oct)");
  Serial.println("AEST = Australian Eastern Standard Time. = UTC+10");
  Serial.println("AEDT = Australian Eastern Daylight Time. = UTC+11");
  setTime(2021,10,31,0,59,50,0);    // Set it to 1 minute before daylight savings comes in.
  
  for(i=0; i&lt;20; i++){
    delay(1000);
    printLocalTime();
  }
  Serial.println("Now change the time.  1 min before DST should finish. (1st Sunday of April)");
  setTime(2021,3,28,1,59,50,1);    // Set it to 1 minute before daylight savings comes in.  Note. isDst=1 to indicate that the time we set is in DST.
  
  for(i=0; i&lt;20; i++){
    delay(1000);
    printLocalTime();
  }
  // Now lets watch the time and see how long it takes for NTP to fix the clock
  Serial.println("Waiting for NTP update (expect in about 1 hour)");
  while(1) {
    delay(1000);
    printLocalTime();
  }
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_Timezones.ino" target="_blank">View raw code</a>
<h3>How the Code Works</h3>
First, you need to include the WiFi library to connect the ESP32 to the internet (NTP server) and the time library to deal with time.
<k>#include &lt;WiFi.h>
#include "time.h"</k>
To set the timezone, we created a function called setTimezone() that accepts as an argument a <a href="https://github.com/nayarsystems/posix_tz_db/blob/master/zones.csv" target="_blank">timezone string</a>. 
<k>void setTimezone(String timezone){</k>
Inside that function, we call the setenv() function for the TZ (timezone) parameter to set the timezone with whatever timezone you pass as an argument to the setTimezone() function.
<k>setenv("TZ",timezone.c_str(),1);  //  Now adjust the TZ.  Clock settings are adjusted to show the new local time</k>
After that, call the tzset() function for the changes to take effect.
<k>tzset();</k>
We won't go into detail about the other functions declared in the code because those were already explained in a previous tutorial:
<a href="https://randomnerdtutorials.com/esp32-date-time-ntp-client-server-arduino/">ESP32 NTP Client-Server: Get Date and Time (Arduino IDE)</a>
<h4>setup()</h4>
In the setup(), we initialize Wi-Fi so that the ESP32 can connect to the internet to connect to the NTP server.
<k>initWifi();</k>
Then, call the initTime() function and pass as argument the <a href="https://github.com/nayarsystems/posix_tz_db/blob/master/zones.csv" target="_blank">timezone String</a>. In our case, for Lisbon/PT timezone.
<k>initTime("WET0WEST,M3.5.0/1,M10.5.0");   // Set for Lisbon/PT</k>
After that, print the current local time.
<k>printLocalTime();</k>
<h4>loop()</h4>
In the loop() show the local time for ten seconds.
<k>Serial.println("Lets show the time for a bit.  Starting with TZ set for Lisbon/Portugal");
for(i=0; i&lt;10; i++){
  delay(1000);
  printLocalTime();
}</k>
If at any time in your code you need to change the timezone, you can do it by calling the setTimezone() function and passing as an argument the timezone string. For example, the following lines change the timezone to Berlin and display the time for ten seconds.
<k>Serial.println();
Serial.println("Now - change timezones to Berlin");
setTimezone("CET-1CEST,M3.5.0,M10.5.0/3");
for(i=0; i&lt;10; i++){
  delay(1000);
  printLocalTime();
}</k>
Then, we go back to our local time by calling the setTimezone() function again with the Lisbon/PT timezone string variable.
<k>Serial.println();
Serial.println("Now - Lets change back to Lisbon and watch Daylight savings take effect");
setTimezone("WET0WEST,M3.5.0/1,M10.5.0");
printLocalTime();</k>
To check if daylight saving time is taking effect, we'll change the time to 10 seconds before the winter time takes effect. In our case, it is on the last Sunday of October (it might be different for your location).
<k>Serial.println();
Serial.println("Now change the time.  1 min before DST takes effect. (Last Sunday of Oct)");
setTime(2021,10,31,0,59,50,0);    // Set it to 1 minute before daylight savings comes in.</k>
Then, show the time for a while to check that it is adjusting the time, taking into account DST.
<k>for(i=0; i&lt;20; i++){
  delay(1000);
  printLocalTime();
}</k>
After this, let's change the time again to check if it changes to summer time when it comes the time. In our case, it is on the last Sunday of March.
<k>Serial.println("Now change the time.  1 min before DST should finish. (Last Sunday of March)");
setTime(2021,3,28,1,59,50,1);    // Set it to 1 minute before daylight savings comes in.  Note. isDst=1 to indicate that the time we set is in DST.</k>
Show the time for a while to check that it is adjusting to the summer time.
<k>for(i=0; i&lt;20; i++){
  delay(1000);
  printLocalTime();
}</k>
<h3>Demonstration</h3>
Now, let's test the code. After inserting your network credentials, upload the code to your ESP32.
After that, open the Serial Monitor at a baud rate of 115200 and press the ESP32 RST button to start running the code.
First, it shows your local time with the timezone you've set on the code.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/11/ESP32-Set-Timezone-Example1-Serial-Monitor.png">
After that, it will change to the other timezone you've set on the code. In our case, we set to Berlin.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/11/ESP32-Set-Timezone-Example2-Serial-Monitor.png">
After that, you should see the change to winter time. In our case, when it's 2 a.m., the clock goes back one hour.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/11/ESP32-Change-Winter-Time-Automatically-Serial-Monitor-Example.png">
We also check if it adjusts to summer time when it comes the time. In the example below, you can see that the clock goes forward one hour to set summer time.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/11/ESP32-Change-Summer-Time-Automatically-Serial-Monitor-Example.png">
<h3>Wrapping Up</h3>
This quick tutorial taught you how to set timezone with daylight saving time using the setenv() and tzset() functions. 
<h2>Web Server: Display Sensor Readings in Gauges</h2>
Learn how to build a web server with the ESP32 to display sensor readings in gauges. As an example, we'll display temperature and humidity from a BME280 sensor in two different gauges: linear and radial. You can easily modify the project to plot any other data. To build the gauges, we'll use the canvas-gauges JavaScript library.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/11/ESP32-Web-Server-Gauges.jpg">
 We have a similar tutorial for the ESP8266 board: <a href="https://randomnerdtutorials.com/esp8266-web-server-gauges/">Web Server  Display Sensor Readings in Gauges</a> 
<h3>Project Overview</h3>
This project will build a web server with the ESP32 that displays temperature and humidity readings from a <a href="https://randomnerdtutorials.com/esp32-bme280-arduino-ide-pressure-temperature-humidity/">BME280 sensor</a>. We'll create a linear gauge that looks like a thermometer to display the temperature, and a radial gauge to display the humidity.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/11/ESP32-Gauges-Web-Server-Overview.png">
<h3>Server-Sent Events</h3>
The readings are updated automatically on the web page using Server-Sent Events (SSE). 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/11/ESP32-Gauges-Web-Server-Overview-Server-Sent-Events.png">
To learn more about SSE, you can read: 
<a href="https://randomnerdtutorials.com/esp32-web-server-sent-events-sse/">ESP32 Web Server using Server-Sent Events (Update Sensor Readings Automatically)</a>
<h3>Files Saved on the Filesystem</h3>
To keep our project better organized and easier to understand, we'll save the HTML, CSS, and JavaScript files to build the web page on the board's filesystem (SPIFFS).
Learn more about building a web server with files saved on the filesystem:
<a href="https://randomnerdtutorials.com/esp32-web-server-spiffs-spi-flash-file-system/">ESP32 Web Server using SPIFFS (SPI Flash File System)</a>
<h3>Prerequisites</h3>
Make sure you check all the prerequisites in this section before continuing with the project.
<h3>1. Install ESP32 Board in Arduino IDE</h3>
We'll program the ESP32 using Arduino IDE. So, you must have the ESP32 add-on installed. Follow the next tutorial if you haven't already:
<a href="https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/">Installing ESP32 Board in Arduino IDE (Windows, Mac OS X, Linux)</a>
If you want to use VS Code with the PlatformIO extension, follow the next tutorial instead to learn how to program the ESP32:
<a href="https://randomnerdtutorials.com/vs-code-platformio-ide-esp32-esp8266-arduino/">Getting Started with VS Code and PlatformIO IDE for ESP32 and ESP8266 (Windows, Mac OS X, Linux Ubuntu)</a>
<h3>2. Filesystem Uploader Plugin</h3>
To upload the HTML, CSS, and JavaScript files to the ESP32 flash memory (SPIFFS), we'll use a plugin for Arduino IDE: <k>SPIFFS</k> <k>Filesystem uploader</k>. Follow the next tutorial to install the filesystem uploader plugin:
<a href="https://randomnerdtutorials.com/install-esp32-filesystem-uploader-arduino-ide/">ESP32: Install SPIFFS FileSystem Uploader Plugin in Arduino IDE</a>
If you're using VS Code with the PlatformIO extension, read the following tutorial to learn how to upload files to the filesystem:
<a href="https://randomnerdtutorials.com/esp32-vs-code-platformio-spiffs/">ESP32 with VS Code and PlatformIO: Upload Files to Filesystem (SPIFFS)</a>
<h3>3. Installing Libraries</h3>
To build this project, you need to install the following libraries:
<a href="https://github.com/adafruit/Adafruit_BME280_Library" target="_blank">Adafruit_BME280</a> (Arduino Library Manager)
<a href="https://github.com/adafruit/Adafruit_Sensor" target="_blank">Adafruit_Sensor library</a> (Arduino Library Manager)
<a href="https://github.com/arduino-libraries/Arduino_JSON" target="_blank">Arduino_JSON library by Arduino version 0.1.0</a> (Arduino Library Manager)
<a aria-label=" (opens in a new tab)" href="https://github.com/me-no-dev/ESPAsyncWebServer" target="_blank">ESPAsyncWebServer</a> (.zip folder);
<a aria-label=" (opens in a new tab)" href="https://github.com/me-no-dev/AsyncTCP" target="_blank">AsyncTCP</a> (.zip folder).
You can install the first three libraries using the Arduino Library Manager. Go to <k>Sketch </k>> <k>Include Library</k> > <k>Manage Libraries</k> and search for the libraries' names.
The ESPAsyncWebServer and AsynTCP libraries aren't available to install through the Arduino Library Manager, so you need to copy the library files to the Arduino Installation Libraries folder. Alternatively, download the libraries' .zip folders, and then, in your Arduino IDE, go to <k>Sketch </k>> <k>Include Library</k> > <k>Add .zip Library</k> and select the libraries you've just downloaded.
<h3>Installing Libraries (VS Code + PlatformIO)</h3>
If you're programming the ESP32 using PlatformIO, you should add the following lines to the platformio.ini file to include the libraries (also change the Serial Monitor speed to 115200):
<k>monitor_speed = 115200
lib_deps = ESP Async WebServer
  arduino-libraries/Arduino_JSON @ 0.1.0
  adafruit/Adafruit BME280 Library @ ^2.1.0
  adafruit/Adafruit Unified Sensor @ ^1.1.4</k>
<h3>Parts Required</h3>
To follow this tutorial you need the following parts:
<a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">ESP32</a> (read <a href="https://makeradvisor.com/tools/esp32-dev-board-wi-fi-bluetooth/" target="_blank">Best ESP32 development boards</a>)
<a href="https://makeradvisor.com/tools/bme280-sensor-module/" target="_blank">BME280 Sensor</a>
<a href="https://makeradvisor.com/tools/jumper-wires-kit-120-pieces/" target="_blank">Jumper wires</a>
<a href="https://makeradvisor.com/tools/mb-102-solderless-breadboard-830-points/" target="_blank">Breadboard</a>
You can use any other sensor, or display any other values that are useful for your project. If you don't have the sensor, you can also experiment with random values to learn how the project works.
You can use the preceding links or go directly to <a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank">MakerAdvisor.com/tools</a> to find all the parts for your projects at the best price!
<a href="https://makeradvisor.com/tools/?utm_source=rnt&utm_medium=post&utm_campaign=post" target="_blank"><img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2017/10/header-200.png?w=828&quality=100&strip=all&ssl=1" data-recalc-dims="1" loading="eager" fetchpriority="high" decoding="async"></a>
<h3>Schematic Diagram</h3>
We'll send temperature and humidity readings from a BME280 sensor. We're going to use I2C communication with the BME280 sensor module. For that, wire the sensor to the default ESP32 SCL (GPIO 22) and SDA (GPIO 21) pins, as shown in the following schematic diagram.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/10/ESP32-BME280-Sensor-Temperature-Humidity-Pressure-Wiring-Diagram-Circuit_f.png">
Recommended reading: <a href="https://randomnerdtutorials.com/esp32-pinout-reference-gpios/">ESP32 Pinout Reference: Which GPIO pins should you use?</a>
<h3>Organizing Your Files</h3>
To keep the project organized and make it easier to understand, we'll create four files to build the web server:
<k>Arduino sketch </k>that handles the web server;
<k>index.html</k>: to define the content of the web page;
<k>sytle.css</k>: to style the web page;
<k>script.js</k>: to program the behavior of the web pagehandle web server responses, events, create the gauges, etc.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/04/Sensor-readings-Multiple-Series-Organizing-Files.png">
You should save the HTML, CSS, and JavaScript files inside a folder called <em><k>data</k> </em>inside the Arduino sketch folder, as shown in the previous diagram. We'll upload these files to the ESP32 filesystem (SPIFFS).
<k>You can download all project files:</k>
<k><a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_Gauges/ESP32_Gauges.zip" target="_blank">Download All the Arduino Project Files</a></k>
<h3>HTML File</h3>
Copy the following to the index.html file.
<k>&lt;!DOCTYPE html>
&lt;html>
  &lt;head>
    &lt;title>ESP IOT DASHBOARD&lt;/title>
    &lt;meta name="viewport" content="width=device-width, initial-scale=1">
    &lt;link rel="icon" type="image/png" href="favicon.png">
    &lt;link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
    &lt;link rel="stylesheet" type="text/css" href="style.css">
    &lt;script src="http://cdn.rawgit.com/Mikhus/canvas-gauges/gh-pages/download/2.1.7/all/gauge.min.js">&lt;/script>
  &lt;/head>
  &lt;body>
    &lt;div>
      &lt;h1>ESP WEB SERVER GAUGES&lt;/h2>
    &lt;/div>
    &lt;div>
      &lt;div>
        &lt;div>
          &lt;p>Temperature&lt;/p>
          &lt;canvas>&lt;/canvas>
        &lt;/div>
        &lt;div>
          &lt;p>Humidity&lt;/p>
          &lt;canvas>&lt;/canvas>
        &lt;/div>
      &lt;/div>
    &lt;/div>
    &lt;script src="script.js">&lt;/script>
  &lt;/body>
&lt;/html></k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_Gauges/data/index.html" target="_blank">View raw code</a>
The HTML file for this project is very simple. It includes the <a href="https://canvas-gauges.com/" target="_blank">JavaScript canvas-gauges library</a> in the head of the HTML file:
<k>&lt;script src="https://cdn.rawgit.com/Mikhus/canvas-gauges/gh-pages/download/2.1.7/all/gauge.min.js">&lt;/script></k>
There is a &lt;canvas> tag with the id gauge-temperature where we'll render the temperature gauge later on. 
<k>&lt;canvas>&lt;/canvas></k>
There is also another  &lt;canvas> tag with the id gauge-humidity, where we'll render the humidity gauge later on.  
<k>&lt;canvas>&lt;/canvas></k>
<h3>CSS File</h3>
Copy the following styles to your style.css file. It styles the web page with simple colors and styles.
<k>html {
  font-family: Arial, Helvetica, sans-serif; 
  display: inline-block; 
  text-align: center;
}
h1 {
  font-size: 1.8rem; 
  color: white;
}
p { 
  font-size: 1.4rem;
}
.topnav { 
  overflow: hidden; 
  background-color: #0A1128;
}
body {  
  margin: 0;
}
.content { 
  padding: 5%;
}
.card-grid { 
  max-width: 1200px; 
  margin: 0 auto; 
  display: grid; 
  grid-gap: 2rem; 
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
}
.card { 
  background-color: white; 
  box-shadow: 2px 2px 12px 1px rgba(140,140,140,.5);
}
.card-title { 
  font-size: 1.2rem;
  font-weight: bold;
  color: #034078
}</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_Gauges/data/style.css" target="_blank">View raw code</a>
<h3>JavaScript File (creating the gauges)</h3>
Copy the following to the script.js file.
<k>// Get current sensor readings when the page loads  
window.addEventListener('load', getReadings);
// Create Temperature Gauge
var gaugeTemp = new LinearGauge({
  renderTo: 'gauge-temperature',
  width: 120,
  height: 400,
  units: "Temperature C",
  minValue: 0,
  startAngle: 90,
  ticksAngle: 180,
  maxValue: 40,
  colorValueBoxRect: "#049faa",
  colorValueBoxRectEnd: "#049faa",
  colorValueBoxBackground: "#f1fbfc",
  valueDec: 2,
  valueInt: 2,
  majorTicks: [
      "0",
      "5",
      "10",
      "15",
      "20",
      "25",
      "30",
      "35",
      "40"
  ],
  minorTicks: 4,
  strokeTicks: true,
  highlights: [
      {
          "from": 30,
          "to": 40,
          "color": "rgba(200, 50, 50, .75)"
      }
  ],
  colorPlate: "#fff",
  colorBarProgress: "#CC2936",
  colorBarProgressEnd: "#049faa",
  borderShadowWidth: 0,
  borders: false,
  needleType: "arrow",
  needleWidth: 2,
  needleCircleSize: 7,
  needleCircleOuter: true,
  needleCircleInner: false,
  animationDuration: 1500,
  animationRule: "linear",
  barWidth: 10,
}).draw();
  
// Create Humidity Gauge
var gaugeHum = new RadialGauge({
  renderTo: 'gauge-humidity',
  width: 300,
  height: 300,
  units: "Humidity (%)",
  minValue: 0,
  maxValue: 100,
  colorValueBoxRect: "#049faa",
  colorValueBoxRectEnd: "#049faa",
  colorValueBoxBackground: "#f1fbfc",
  valueInt: 2,
  majorTicks: [
      "0",
      "20",
      "40",
      "60",
      "80",
      "100"
  ],
  minorTicks: 4,
  strokeTicks: true,
  highlights: [
      {
          "from": 80,
          "to": 100,
          "color": "#03C0C1"
      }
  ],
  colorPlate: "#fff",
  borderShadowWidth: 0,
  borders: false,
  needleType: "line",
  colorNeedle: "#007F80",
  colorNeedleEnd: "#007F80",
  needleWidth: 2,
  needleCircleSize: 3,
  colorNeedleCircleOuter: "#007F80",
  needleCircleOuter: true,
  needleCircleInner: false,
  animationDuration: 1500,
  animationRule: "linear"
}).draw();
// Function to get current readings on the webpage when it loads for the first time
function getReadings(){
  var xhr = new XMLHttpRequest();
  xhr.onreadystatechange = function() {
    if (this.readyState == 4 && this.status == 200) {
      var myObj = JSON.parse(this.responseText);
      console.log(myObj);
      var temp = myObj.temperature;
      var hum = myObj.humidity;
      gaugeTemp.value = temp;
      gaugeHum.value = hum;
    }
  }; 
  xhr.open("GET", "/readings", true);
  xhr.send();
}
if (!!window.EventSource) {
  var source = new EventSource('/events');
  
  source.addEventListener('open', function(e) {
    console.log("Events Connected");
  }, false);
  source.addEventListener('error', function(e) {
    if (e.target.readyState != EventSource.OPEN) {
      console.log("Events Disconnected");
    }
  }, false);
  
  source.addEventListener('message', function(e) {
    console.log("message", e.data);
  }, false);
  
  source.addEventListener('new_readings', function(e) {
    console.log("new_readings", e.data);
    var myObj = JSON.parse(e.data);
    console.log(myObj);
    gaugeTemp.value = myObj.temperature;
    gaugeHum.value = myObj.humidity;
  }, false);
}</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_Gauges/data/script.js" target="_blank">View raw code</a>
Here's a summary of what this code does:
initializing the event source protocol;
adding an event listener for the new_readings event;
creating the gauges;
getting the latest sensor readings from the new_readings event and display them in the corresponding gauges;
making an HTTP GET request for the current sensor readings when you access the web page for the first time.
<h3>Get Readings</h3>
When you access the web page for the first time, we'll request the server to get the current sensor readings. Otherwise, we would have to wait for new sensor readings to arrive (via Server-Sent Events), which can take some time depending on the interval that you set on the server.
Add an event listener that calls the getReadings function when the web page loads.
<k>// Get current sensor readings when the page loads
window.addEventListener('load', getReadings);</k>
The window object represents an open window in a browser. The addEventListener() method sets up a function to be called when a certain event happens. In this case, we'll call the getReadings function when the page loads (load') to get the current sensor readings.
Now, let's take a look at the getReadings function. Create a new XMLHttpRequest object. Then, send a GET request to the server on the /readings URL using the open() and send() methods.
<k>function getReadings() {
  var xhr = new XMLHttpRequest();
  xhr.open("GET", "/readings", true);
  xhr.send();
}</k>
When we send that request, the ESP will send a response with the required information. So, we need to handle what happens when we receive the response. We'll use the onreadystatechange property that defines a function to be executed when the readyState property changes. The readyState property holds the status of the XMLHttpRequest. The response of the request is ready when the readyState is 4, and the status is 200.
readyState = 4 means that the request finished and the response is ready;
status = 200 means OK
So, the request should look something like this:
<k>function getStates(){
  var xhr = new XMLHttpRequest();
  xhr.onreadystatechange = function() {
    if (this.readyState == 4 && this.status == 200) {
       DO WHATEVER YOU WANT WITH THE RESPONSE 
    }
  };
  xhr.open("GET", "/states", true);
  xhr.send();
}</k>
The response sent by the ESP is the following text in JSON format (those are just arbitrary values).
<k>{
  "temperature" : "25.02",
  "humidity" : "64.01",
}</k>
We need to convert the JSON string into a JSON object using the parse() method. The result is saved on the myObj variable.
<k>var myObj = JSON.parse(this.responseText);</k>
The myObj variable is a JSON object that contains the temperature and humidity readings. We want to update the gauges values with the corresponding readings. 
Updating the value of a gauge is straightforward. For example, our temperature gauge is called gaugeTemp (as we'll see later on), to update a value, we can simply call: gaugeTemp.value = NEW_VALUE. In our case, the new value is the temperature reading saved on the myObj JSON object.
<k>gaugeTemp.value = myObj.temperature;</k>
It is similar for the humidity (our humidity gauge is called gaugeHum).
<k>gaugeHum.value = myObj.humidity;</k>
Here's the complete getReadings() function.
<k>function getReadings(){
  var xhr = new XMLHttpRequest();
  xhr.onreadystatechange = function() {
    if (this.readyState == 4 && this.status == 200) {
      var myObj = JSON.parse(this.responseText);
      console.log(myObj);
      var temp = myObj.temperature;
      var hum = myObj.humidity;
      gaugeTemp.value = temp;
      gaugeHum.value = hum;
    }
  }; 
  xhr.open("GET", "/readings", true);
  xhr.send();
}</k>
<h3>Creating the Gauges</h3>
The canvas-charts library allows you to build linear and radial gauges to display your readings. It provides several examples, and it is very simple to use. We recommend taking a look at the documentation and exploring all the gauges functionalities:
<a href="https://canvas-gauges.com/documentation/user-guide/configuration" target="_blank">Canvas-Gauges User Guide Configuration</a>
<h4>Temperature Gauge</h4>
The following lines create the gauge to display the temperature.
<k>// Create Temperature Gauge
var gaugeTemp = new LinearGauge({
  renderTo: 'gauge-temperature',
  width: 120,
  height: 400,
  units: "Temperature C",
  minValue: 0,
  startAngle: 90,
  ticksAngle: 180,
  maxValue: 40,
  colorValueBoxRect: "#049faa",
  colorValueBoxRectEnd: "#049faa",
  colorValueBoxBackground: "#f1fbfc",
  valueDec: 2,
  valueInt: 2,
  majorTicks: [
      "0",
      "5",
      "10",
      "15",
      "20",
      "25",
      "30",
      "35",
      "40"
  ],
  minorTicks: 4,
  strokeTicks: true,
  highlights: [
      {
          "from": 30,
          "to": 40,
          "color": "rgba(200, 50, 50, .75)"
      }
  ],
  colorPlate: "#fff",
  colorBarProgress: "#CC2936",
  colorBarProgressEnd: "#049faa",
  borderShadowWidth: 0,
  borders: false,
  needleType: "arrow",
  needleWidth: 2,
  needleCircleSize: 7,
  needleCircleOuter: true,
  needleCircleInner: false,
  animationDuration: 1500,
  animationRule: "linear",
  barWidth: 10,
}).draw();</k>
To create a new linear gauge, use the new LinearGauge()  method and pass as an argument the properties of the gauge.
<k>var gaugeTemp = new LinearGauge({</k>
In the next line, define where you want to put the chart (it must be a &lt;canvas> element). In our example, we want to place it in the &lt;canvas> HTML element with the gauge-temperature idsee the HTML file section.
<k>renderTo: 'gauge-temperature',</k>
Then, we define other properties to customize our gauge. The names are self-explanatory, but we recommend taking a look at <a href="https://canvas-gauges.com/documentation/user-guide/configuration" target="_blank">all possible configurations</a> and changing the gauge to meet your needs. 
In the end, you need to apply the draw() method to actually display the gauge on the canvas.
<k>}).draw();</k>
Special attention that if you need to change the gauge range, you need to change the minValue and maxValue properties:
<k>minValue: 0,</k>
<k>maxValue: 40,</k>
You also need to adjust the majorTicks values for the values displayed on the axis.
<k>majorTicks: [
    "0",
    "5",
    "10",
    "15",
    "20",
    "25",
    "30",
    "35",
    "40"
],</k>
<h4>Humidity Gauge</h4>
Creating the humidity gauge is similar, but we use the new RadialGauge() function instead and it is rendered to the &lt;canvas> with the gauge-humidity id. Notice that we apply the draw() method on the gauge so that it is drawn on the canvas.
<k>// Create Humidity Gauge
var gaugeHum = new RadialGauge({
  renderTo: 'gauge-humidity',
  width: 300,
  height: 300,
  units: "Humidity (%)",
  minValue: 0,
  maxValue: 100,
  colorValueBoxRect: "#049faa",
  colorValueBoxRectEnd: "#049faa",
  colorValueBoxBackground: "#f1fbfc",
  valueInt: 2,
  majorTicks: [
      "0",
      "20",
      "40",
      "60",
      "80",
      "100"
  ],
  minorTicks: 4,
  strokeTicks: true,
  highlights: [
      {
          "from": 80,
          "to": 100,
          "color": "#03C0C1"
      }
  ],
  colorPlate: "#fff",
  borderShadowWidth: 0,
  borders: false,
  needleType: "line",
  colorNeedle: "#007F80",
  colorNeedleEnd: "#007F80",
  needleWidth: 2,
  needleCircleSize: 3,
  colorNeedleCircleOuter: "#007F80",
  needleCircleOuter: true,
  needleCircleInner: false,
  animationDuration: 1500,
  animationRule: "linear"
}).draw();</k>
<h3>Handle events</h3>
Update the readings on the gauge when the client receives the readings on the new_readings event
Create a new EventSource object and specify the URL of the page sending the updates. In our case, it's /events.
<k>if (!!window.EventSource) {
  var source = new EventSource('/events');</k>
Once you've instantiated an event source, you can start listening for messages from the server with addEventListener().
These are the default event listeners, as shown here in the AsyncWebServer <a href="https://github.com/me-no-dev/ESPAsyncWebServer#setup-event-source-in-the-browser" target="_blank">documentation</a>.
<k>source.addEventListener('open', function(e) {
  console.log("Events Connected");
}, false);
source.addEventListener('error', function(e) {
  if (e.target.readyState != EventSource.OPEN) {
    console.log("Events Disconnected");
  }
}, false);
source.addEventListener('message', function(e) {
  console.log("message", e.data);
}, false);</k>
Then, add the event listener for new_readings.
<k>source.addEventListener('new_readings', function(e) {</k>
When new readings are available, the ESP32 sends an event (new_readings) to the client. The following lines handle what happens when the browser receives that event.
<k>source.addEventListener('new_readings', function(e) {
  console.log("new_readings", e.data);
  var myObj = JSON.parse(e.data);
  console.log(myObj);
  gaugeTemp.value = myObj.temperature;
  gaugeHum.value = myObj.humidity;
}, false);</k>
Basically, print the new readings on the browser console, convert the data into a JSON object and display the readings on the corresponding gauges.
<h3>Arduino Sketch</h3>
Copy the following code to your Arduino IDE or to the main.cpp file if you're using PlatformIO.
You can also <a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_Gauges/ESP32_Gauges.zip" target="_blank">download all the files here</a>.
<k>/*********
  Rui Santos
  Complete instructions at https://RandomNerdTutorials.com/esp32-web-server-gauges/
  
  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files.
  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
*********/
#include &lt;Arduino.h>
#include &lt;WiFi.h>
#include &lt;AsyncTCP.h>
#include &lt;ESPAsyncWebServer.h>
#include "SPIFFS.h"
#include &lt;Arduino_JSON.h>
#include &lt;Adafruit_BME280.h>
#include &lt;Adafruit_Sensor.h>
// Replace with your network credentials
const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";
// Create AsyncWebServer object on port 80
AsyncWebServer server(80);
// Create an Event Source on /events
AsyncEventSource events("/events");
// Json Variable to Hold Sensor Readings
JSONVar readings;
// Timer variables
unsigned long lastTime = 0;
unsigned long timerDelay = 10000;
// Create a sensor object
Adafruit_BME280 bme; // BME280 connect to ESP32 I2C (GPIO 21 = SDA, GPIO 22 = SCL)
// Init BME280
void initBME(){
  if (!bme.begin(0x76)) {
    Serial.println("Could not find a valid BME280 sensor, check wiring!");
    while (1);
  }
}
// Get Sensor Readings and return JSON object
String getSensorReadings(){
  readings["temperature"] = String(bme.readTemperature());
  readings["humidity"] =  String(bme.readHumidity());
  String jsonString = JSON.stringify(readings);
  return jsonString;
}
// Initialize SPIFFS
void initSPIFFS() {
  if (!SPIFFS.begin()) {
    Serial.println("An error has occurred while mounting SPIFFS");
  }
  Serial.println("SPIFFS mounted successfully");
}
// Initialize WiFi
void initWiFi() {
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  Serial.print("Connecting to WiFi ..");
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print('.');
    delay(1000);
  }
  Serial.println(WiFi.localIP());
}
void setup() {
  // Serial port for debugging purposes
  Serial.begin(115200);
  initBME();
  initWiFi();
  initSPIFFS();
  // Web Server Root URL
  server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
    request->send(SPIFFS, "/index.html", "text/html");
  });
  server.serveStatic("/", SPIFFS, "/");
  // Request for the latest sensor readings
  server.on("/readings", HTTP_GET, [](AsyncWebServerRequest *request){
    String json = getSensorReadings();
    request->send(200, "application/json", json);
    json = String();
  });
  events.onConnect([](AsyncEventSourceClient *client){
    if(client->lastId()){
      Serial.printf("Client reconnected! Last message ID that it got is: %u\n", client->lastId());
    }
    // send event with message "hello!", id current millis
    // and set reconnect delay to 1 second
    client->send("hello!", NULL, millis(), 10000);
  });
  server.addHandler(&events);
  // Start server
  server.begin();
}
void loop() {
  if ((millis() - lastTime) > timerDelay) {
    // Send Events to the client with the Sensor Readings Every 10 seconds
    events.send("ping",NULL,millis());
    events.send(getSensorReadings().c_str(),"new_readings" ,millis());
    lastTime = millis();
  }
}
</k>
<a href="https://github.com/RuiSantosdotme/Random-Nerd-Tutorials/raw/master/Projects/ESP32/ESP32_Gauges/ESP32_Gauges.ino" target="_blank">View raw code</a>
<h3>How the code works</h3>
Let's take a look at the code and see how it works to send readings to the client using server-sent events.
<h4>Including Libraries</h4>
The Adafruit_Sensor and Adafruit_BME280 libraries are needed to interface with the BME280 sensor.
<k>#include &lt;Adafruit_BME280.h>
#include &lt;Adafruit_Sensor.h></k>
The WiFi, ESPAsyncWebServer, and AsyncTCP libraries are used to create the web server.
<k>#include &lt;WiFi.h>
#include &lt;AsyncTCP.h>
#include &lt;ESPAsyncWebServer.h></k>
We'll use SPIFFS to save the files to build the web server.
<k>#include "SPIFFS.h"</k>
You also need to include the Arduino_JSON library to make it easier to handle JSON strings.
<k>#include &lt;Arduino_JSON.h></k>
<h4>Network Credentials</h4>
Insert your network credentials in the following variables, so that the ESP32 can connect to your local network using Wi-Fi.
<k>const char* ssid = "REPLACE_WITH_YOUR_SSID";
const char* password = "REPLACE_WITH_YOUR_PASSWORD";</k>
<h4>AsyncWebServer and AsyncEventSource</h4>
Create an AsyncWebServer object on port 80.
<k>AsyncWebServer server(80);</k>
The following line creates a new event source on /events. 
<k>AsyncEventSource events("/events");</k>
<h4>Declaring Variables</h4>
The readings variable is a JSON variable to hold the sensor readings in JSON format.
<k>JSONVar readings;</k>
The lastTime and the timerDelay variables will be used to update sensor readings every X number of seconds. As an example, we'll get new sensor readings every 30 seconds (30000 milliseconds). You can change that delay time in the timerDelay variable.
<k>unsigned long lastTime = 0;
unsigned long timerDelay = 30000;</k>
Create an Adafruit_BME280 object called bme on the default ESP I2C pins.
<k>Adafruit_BME280 bme;</k>
<h4>Initialize BME280 Sensor</h4>
The following function can be called to initialize the BME280 sensor.
<k>// Init BME280
void initBME(){
  if (!bme.begin(0x76)) {
    Serial.println("Could not find a valid BME280 sensor, check wiring!");
    while (1);
  }
}</k>
<h4>Get BME280 Readings</h4>
To get temperature and humidity from the BME280 temperature, use the following methods on the bme object:
bme.readTemperature()
bme.readHumidity() 
The getSensorReadings() function gets the sensor readings and saves them on the readings JSON array.
<k>// Get Sensor Readings and return JSON object
String getSensorReadings(){
  readings["temperature"] = String(bme.readTemperature());
  readings["humidity"] =  String(bme.readHumidity());
  String jsonString = JSON.stringify(readings);
  return jsonString;
}</k>
The readings array is then converted into a JSON string variable using the stringify() method and saved on the jsonString variable.
The function returns the jsonString variable with the current sensor readings. The JSON string has the following format (the values are just arbitrary numbers for explanation purposes).
<k>{
  "temperature" : "25",
  "humidity" : "50"
}</k>
<h4>setup()</h4>
In the setup(), initialize the Serial Monitor, Wi-Fi, filesystem, and the BME280 sensor.
<k>void setup() {
  // Serial port for debugging purposes
  Serial.begin(115200);
  initBME();
  initWiFi();
  initSPIFFS();</k>
<h4>Handle Requests</h4>
When you access the ESP32 IP address on the root / URL, send the text that is stored on the index.html file to build the web page.
<k>server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
  request->send(SPIFFS, "/index.html", "text/html");
});</k>
Serve the other static files requested by the client (style.css and script.js).
<k>server.serveStatic("/", SPIFFS, "/");</k>
Send the JSON string with the current sensor readings when you receive a request on the /readings URL.
<k>// Request for the latest sensor readings
server.on("/readings", HTTP_GET, [](AsyncWebServerRequest *request){
  String json = getSensorReadings();
  request->send(200, "application/json", json);
  json = String();
});</k>
The json variable holds the return from the getSensorReadings() function. To send a JSON string as response, the send() method accepts as first argument the response code (200), the second is the content type (application/json) and finally the content (json variable).
<h4>Server Event Source</h4>
Set up the event source on the server.
<k>events.onConnect([](AsyncEventSourceClient *client){
  if(client->lastId()){
    Serial.printf("Client reconnected! Last message ID that it got is: %u\n", client->lastId());
  }
  // send event with message "hello!", id current millis
  // and set reconnect delay to 1 second
  client->send("hello!", NULL, millis(), 10000);
});
server.addHandler(&events);</k>
Finally, start the server.
<k>server.begin();</k>
<h4>loop()</h4>
In the loop(), send events to the browser with the newest sensor readings to update the web page every 30 seconds.
<k>events.send("ping",NULL,millis());
events.send(getSensorReadings().c_str(),"new_readings" ,millis());</k>
Use the send() method on the events object and pass as an argument the content you want to send and the name of the event. In this case, we want to send the JSON string returned by the getSensorReadings() function. The send() method accepts a variable of type char, so we need to use the c_str() method to convert the variable. The name of the events is new_readings.
Usually, we also send a ping message every X number of seconds. That line is not mandatory. It is used to check on the client side that the server is alive.
<k>events.send("ping",NULL,millis());</k>
<h3>Uploading Code and Files</h3>
After inserting your network credentials, save the code. Go to <k>Sketch</k> > <k>Show Sketch Folder</k>, and create a folder called <k>data</k>. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/12/Arduino-IDE-Show-sketch-folder.png">
Inside that folder, you should save the HTML, CSS, and JavaScript files.
Then, upload the code to your ESP32 board. Make sure you have the right board and COM port selected. Also, make sure you've added your network credentials.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2019/12/upload-button-arduino-ide.png">
After uploading the code, you need to upload the files. Go to <k>Tools </k>> <k>ESP32 Data Sketch Upload</k> and wait for the files to be uploaded.
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2020/12/ESP32-Sketch-Data-Upload.png">
When everything is successfully uploaded, open the Serial Monitor at a baud rate of 115200. Press the ESP32 EN/RST button, and it should print the ESP32 IP address.
<h3>Demonstration</h3>
Open your browser and type the ESP32 IP address. You should get access to the web page that shows the gauges with the latest sensor readings. 
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/11/Gauges-Web-Server-ESP32-ESP8266-Example.png">
You can also check your gauges using your smartphone (the web page is mobile responsive).
<img class="lazy" data-src="https://i0.wp.com/randomnerdtutorials.com/wp-content/uploads/2021/11/ESP-Gauges-Web-Server-Smartphone.jpg">
<h3>Wrapping Up</h3>
In this tutorial you've learned how to create a web server to display sensor readings in linear and radial gauges. As an example, we displayed temperature and humidity from a BME280 sensor. You can use those gauges to display any other values that may make sense for your project.


<script src='https://williamkpchan.github.io/LibDocs/readbook.js'></script>
<script>
var lazyLoadInstance = new LazyLoad({
 elements_selector: ".lazy"
});
</script>

</body></html>
